(DEFINE-FILE-INFO READTABLE "INTERLISP" PACKAGE "INTERLISP")
(FILECREATED "12-Oct-93 18:01:09" "{Pele:mv:envos}<LispCore>Sources>CLTL2>FILEPKG.;1" 190280 

      changes to%:  (FNS DEFAULT.EDITDEF)
                    (VARS FILEPKGCOMS)

      previous date%: "22-Sep-92 19:19:15" {DSK}<mo>usr>users>sybalsky>cltl2>sources>FILEPKG.;1)


(* ; "
Copyright (c) 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993 by Venue & Xerox Corporation.  All rights reserved.
The following program was created in 1982 but has not been published
within the meaning of the copyright law, is furnished under license,
and may not be used, copied and/or disclosed except in accordance
with the terms of said license.
")

(PRETTYCOMPRINT FILEPKGCOMS)

(RPAQQ FILEPKGCOMS
       [(COMS                                                (* ; 
            "standard records for accessing file  package type/command parts.  Exported for PRETTY")
              (VARS FILEPKGTYPEPROPS)
              (EXPORT (DECLARE%: EVAL@COMPILE DONTCOPY (RECORDS * FILEPKGRECORDS)))
              (FNS SEARCHPRETTYTYPELST PRETTYDEFMACROS FILEPKGCOMPROPS)
              (INITRECORDS * FILEPKGRECORDS))
        [DECLARE%: EVAL@COMPILE DOCOPY 

               (* ;; "Proclaim SPECIAL those variables that are used freely in a lot of code.")

               (P (CL:PROCLAIM '(CL:SPECIAL PRETTYDEFMACROS PRETTYTYPELST FILEPKGTYPES 
                                       PRETTYPRINTMACROS *DEFAULT-CLEANUP-COMPILER* MARKASCHANGEDFNS
                                       PRETTYFLG))
                  (CL:PROCLAIM '(GLOBAL FILELST SYSFILES LOADEDFILELST NOTLISTEDFILES 
                                       NOTCOMPILEDFILES MAKEFILEFORMS CLEANUPOPTIONS]
        (INITVARS (MSDATABASELST))
        [COMS 
              (* ;; "making, adding, listing, compiling files")

              (FNS CLEANUP COMPILEFILES COMPILEFILES0 CONTINUEDIT MAKEFILE FILECHANGES 
                   FILEPKG.MERGECHANGES FILEPKG.CHANGEDFNS MAKEFILE1 COMPILE-FILE? MAKEFILES ADDFILE
                   ADDFILE0 LISTFILES)
              (INITVARS (*DEFAULT-CLEANUP-COMPILER* 'CL:COMPILE-FILE)
                     (FILELST)
                     (LOADEDFILELST)
                     (NOTLISTEDFILES)
                     (NOTCOMPILEDFILES)
                     (MAKEFILEFORMS)
                     (NILCOMS))
              (ADDVARS (MAKEFILEOPTIONS RC C LIST FAST CLISP CLISPIFY NIL REMAKE NEW NOCLISP 
                              CLISP%  F ST STF (REC . RC)
                              (BREC . RC)
                              (TC . C)
                              (BC . C)
                              (TCOMPL . C)
                              (BCOMPL . C)))
              (INITVARS (MAKEFILEREMAKEFLG T)
                     (CLEANUPOPTIONS '(RC]
        (COMS 
              (* ;; "scanning file coms")

              (FNS FILEPKGCHANGES GETFILEPKGTYPE MARKASCHANGED FILECOMS WHEREIS SMASHFILECOMS 
                   FILEFNSLST FILECOMSLST UPDATEFILES INFILECOMS? INFILECOMTAIL INFILECOMS INFILECOM
                   INFILECOMSVALS INFILECOMSVAL INFILECOMSPROP IFCPROPS IFCEXPRTYPE IFCPROPSCAN 
                   IFCDECLARE INFILEPAIRS INFILECOMSMACRO))
        (COMS 
              (* ;; "adding to a file")

              (FNS FILES? FILES?1 FILES?PRINTLST ADDTOFILES? ADDTOFILE WHATIS ADDTOCOMS ADDTOCOM 
                   ADDTOCOM1 ADDNEWCOM MAKENEWCOM DEFAULTMAKENEWCOM)
              (INITVARS (DEFAULTCOMHASFILEFLG))
              (ADDVARS (MARKASCHANGEDFNS))
              (FNS MERGEINSERT MERGEINSERT1)
              (INITVARS [ADDTOFILEKEYLST `((%[ "" EXPLAINSTRING 
                                           "[ -- prettyprint the item to terminal and then ask again"
                                               NOECHOFLG T)
                                           ((MKSTRING (CHARACTER (CHARCODE "^J")))
                                            "" EXPLAINSTRING 
                                            "{line-feed} - same as previous response" NOECHOFLG T)
                                           (%  " 
" EXPLAINSTRING "{space} - no action" NOECHOFLG T)
                                           (%] "Nowhere
" EXPLAINSTRING "] - nowhere, item is marked as a dummy
" NOECHOFLG T)
                                           [%( "List:  (" EXPLAINSTRING "(list name)" NOECHOFLG T 
                                               KEYLST (( "" CONFIRMFLG (%) %] %  %
)
                                                          RETURN
                                                          (CDR ANSWER]
                                           (@ "Near: " EXPLAINSTRING 
                                                 "@ other-item   -- put the item near the other item"
                                                    NOECHOFLG T KEYLST (( "" CONFIRMFLG (%
)
                                                                           RETURN ANSWER)))
                                           (%
 "" RETURN '% )
                                           ("" "File name: " EXPLAINSTRING "a file name" KEYLST
                                               (]
                     (LASTFILE)))
        (COMS 
              (* ;; "deleting an item from a file")

              (FNS DELFROMFILES DELFROMCOMS DELFROMCOM DELFROMCOM1 REMOVEITEM MOVETOFILE)
              (P (MOVD? 'DELFROMFILES 'DELFROMFILE NIL T)
                 (MOVD? 'MOVETOFILE 'MOVEITEM NIL T))
              (ADDVARS (SYSPROPS PROPTYPE VARTYPE)))
        [COMS                                                (* ; 
                      "functions for doing things and marking them changed and auxiliary functions")
              (FNS SAVEPUT)
              [DECLARE%: DONTEVAL@LOAD DOCOPY (P (OR (CHANGENAME 'PUTPROPS 'PUTPROP 'SAVEPUT)
                                                     (CHANGENAME 'PUTPROPS '/PUT 'SAVEPUT]
              (FNS UNMARKASCHANGED PREEDITFN POSTEDITPROPS POSTEDITALISTS)
              (ADDVARS (LISPXFNS (PUT . SAVEPUT)
                              (PUTPROP . SAVEPUT]
        (COMS                                                (* ; 
                                                  "sub-functions for file package commands & types")
              (FNS ALISTS.GETDEF ALISTS.WHENCHANGED CLEARCLISPARRAY EXPRESSIONS.WHENCHANGED 
                   MAKEALISTCOMS MAKEFILESCOMS MAKELISPXMACROSCOMS MAKEPROPSCOMS MAKEUSERMACROSCOMS 
                   PROPS.WHENCHANGED FILEGETDEF.LISPXMACROS FILEGETDEF.ALISTS FILEGETDEF.RECORDS 
                   FILEGETDEF.PROPS FILEGETDEF.MACROS FILEGETDEF.VARS FILEGETDEF.FNS 
                   FILEPKGCOMS.PUTDEF FILES.PUTDEF VARS.PUTDEF FILES.WHENCHANGED)
              (ADDVARS (MACROPROPS MACRO BYTEMACRO DMACRO)
                     (SYSPROPS PROPTYPE))
              (PROP PROPTYPE I.S.OPR SUBR LIST CODE FILEDATES FILE FILEMAP EXPR VALUE COPYRIGHT 
                    FILETYPE)
              (PROP VARTYPE BAKTRACELST BREAKMACROS COMPILETYPELST EDITMACROS ERRORTYPELST FONTDEFS 
                    LISPXHISTORYMACROS LISPXMACROS PRETTYDEFMACROS PRETTYEQUIVLST PRETTYPRINTMACROS 
                    PRETTYPRINTYPEMACROS USERMACROS))
        (COMS                                                (* ; 
                    "Define the commands below AFTER the various properties have been established.")
              (USERMACROS M))
        (COMS                                                (* ; "GETDEF methods")
              (FNS RENAME CHANGECALLERS)
              (FNS SHOWDEF COPYDEF GETDEF GETDEFCOM GETDEFCOM0 GETDEFCURRENT GETDEFERR GETDEFFROMFILE
                   GETDEFSAVED PUTDEF EDITDEF DEFAULT.EDITDEF EDITDEF.FILES LOADDEF DWIMDEF DELDEF 
                   DELFROMLIST HASDEF GETFILEDEF SAVEDEF UNSAVEDEF COMPAREDEFS COMPARE TYPESOF)
              (INITVARS (WHEREIS.HASH)))
                                                             (* ; "Must come after PUTDEF")
        (COMS (FNS FIXEDITDATE EDITDATE?)
                                                             (* ; 
                                  "Edit date support for all kinds of definers (from PARC 6/10/92)")
              [VARS (EDITDATE-ARGLIST-DEFINERS '(FUNCTIONS TYPES))
                    (EDITDATE-NAME-DEFINERS '(STRUCTURES VARIABLES]
              (GLOBALVARS EDITDATE-ARGLIST-DEFINERS EDITDATE-NAME-DEFINERS))
        (COMS 
              (* ;; "how to dump FILEPKGCOMS. The SPLST must be initialized to contain FILEPKGCOMS in order to get started.")

              (FNS FILEPKGCOM FILEPKGTYPE)
              (PROP ARGNAMES FILEPKGCOM)
              (ADDVARS (FILEPKGCOMSPLST FILEPKGCOMS)
                     (FILEPKGTYPES FILEPKGCOMS))
              (FILEPKGCOMS FILEPKGCOMS)
              (FILEPKGCOMS ALISTS DEFS EDITMACROS EXPRESSIONS FIELDS FILEPKGTYPES FILES FILEVARS FNS
                     INITRECORDS INITVARS LISPXCOMS LISPXMACROS MACROS PRETTYDEFMACROS PROPS RECORDS
                     OLDRECORDS SYSRECORDS USERMACROS VARS * CONSTANTS))
        (ADDVARS (SHADOW-TYPES (FUNCTIONS FNS)
                        (VARIABLES VARS CONSTANTS)))
        (INITVARS (SAVEDDEFS))
        (COMS                                                (* ; "EDITCALLERS")
              (FNS FINDCALLERS EDITCALLERS EDITFROMFILE FINDATS LOOKIN)
              (FNS SEPRCASE)
              [INITVARS (DEFAULTRENAMEMETHOD '(EDITCALLERS CAREFUL]
              (INITVARS (SEPRCASEARRAYS)
                     (CLISPCASEARRAYS))
              (P (MOVD? 'INFILEP 'FINDFILE)
                                                             (* ; "or else from SPELLFILE"))
              (BLOCKS (EDITFROMFILE EDITFROMFILE LOOKIN (GLOBALVARS EDITLOADFNSFLG)
                             (NOLINKFNS LOADFROM)))
              (GLOBALVARS SYSFILES CLISPCASEARRAYS SEPRCASEARRAYS CLISPCHARS))
        (COMS                                                (* ; "EXPORT")
              (FNS IMPORTFILE IMPORTEVAL IMPORTFILESCAN CHECKIMPORTS GATHEREXPORTS \DUMPEXPORTS)
              (FILEPKGCOMS EXPORT)
              [INITVARS (BEGINEXPORTDEFSTRING "* %"FOLLOWING DEFINITIONS EXPORTED%")")
                     (ENDEXPORTDEFFORM '(* "END EXPORTED DEFINITIONS"]
              (GLOBALVARS BEGINEXPORTDEFSTRING ENDEXPORTDEFFORM))
        (COMS                                                (* ; "for GAINSPACE")
              (FNS CLEARFILEPKG)
              [ADDVARS (GAINSPACEFORMS (FILELST "erase filepkg information" (CLEARFILEPKG RESPONSE)
                                              ((Y "es")
                                               (N "o")
                                               (E . "verything")
                                               (F "ilemaps only
"]
              (GLOBALVARS SMASHPROPSLST1))
        (GLOBALVARS %#UNDOSAVES ADDTOFILEKEYLST CLEANUPOPTIONS CLISPIFYPRETTYFLG COMPILE.EXT 
               DECLARETAGSLST DEFAULTRENAMEMETHOD FILEPKGCOMSPLST FILERDTBL HISTORYCOMS HISTSTR0 
               I.S.OPRLST LISPXCOMS LISPXHISTORY LISPXHISTORYMACROS LISPXMACROS MACROPROPS 
               MAKEFILEOPTIONS MAKEFILEREMAKEFLG MSDATABASELST PRETTYHEADER PRETTYTRANFLG SAVEDDEFS 
               SYSPROPS USERMACROS USERRECLST USERWORDS FILEPKGTYPEPROPS)
        (BLOCKS (DELFROMCOMS DELFROMCOMS DELFROMCOM DELFROMCOM1 REMOVEITEM (NOLINKFNS . T)
                       (SPECVARS COMSNAME))
               (ADDTOFILEBLOCK ADDTOFILES? ADDTOFILE WHATIS ADDTOCOMS ADDTOCOM ADDTOCOM1 ADDNEWCOM
                      (NOLINKFNS . T)
                      (SPECVARS COMSNAME)
                      (ENTRIES ADDTOFILE ADDTOCOMS ADDTOFILES? ADDTOCOM1))
               (INFILECOMS? INFILECOMS? INFILECOMTAIL INFILECOMS INFILECOM INFILECOMSVAL 
                      INFILECOMSVALS INFILEPAIRS INFILECOMSMACRO IFCPROPS IFCEXPRTYPE IFCPROPSCAN 
                      IFCDECLARE (LOCALFREEVARS NAME LITERALS VAL TYPE ONFILETYPE ORIGFLG)
                      INFILECOMSPROP)
               (NIL MAKEFILE (LOCALVARS . T)
                      (SPECVARS FILE OPTIONS REPRINTFNS SOURCEFILE FILETYPE FILEDATES CHANGES))
               (ADDFILE ADDFILE ADDFILE0)
               (FILEPKGCHANGES FILEPKGCHANGES (NOLINKFNS . T))
               (NIL ALISTS.WHENCHANGED CHANGECALLERS CLEANUP CLEARCLISPARRAY COMPARE COMPAREDEFS 
                      COMPILEFILES COMPILEFILES0 CONTINUEDIT COPYDEF DEFAULTMAKENEWCOM DELFROMFILES 
                      EDITDEF EXPRESSIONS.WHENCHANGED FILECOMS FILECOMSLST FILEFNSLST FILEPKGCOM 
                      FILEPKGCOMPROPS FILEPKGTYPE FILES? FILES?1 GETFILEPKGTYPE HASDEF INFILECOMTAIL
                      LOADDEF MAKEALISTCOMS MAKEFILE1 MAKEFILES MAKEFILESCOMS MAKELISPXMACROSCOMS 
                      MAKENEWCOM MAKEPROPSCOMS MAKEUSERMACROSCOMS MARKASCHANGED MOVETOFILE 
                      POSTEDITPROPS PREEDITFN PRETTYDEFMACROS PROPS.WHENCHANGED PUTDEF RENAME SAVEDEF
                      SAVEPUT SEARCHPRETTYTYPELST SHOWDEF SMASHFILECOMS TYPESOF UNMARKASCHANGED 
                      UNSAVEDEF UPDATEFILES (GLOBALVARS %#UNDOSAVES SYSFILES MARKASCHANGEDSTATS 
                                                   COMPILE.EXT EDITMACROS EDITLOADFNSFLG LOADOPTIONS)
                      (LOCALVARS . T))
               (DELDEF DELDEF DELFROMLIST (NOLINKFNS . T))
               (GETDEF GETDEF DWIMDEF GETDEFCOM GETDEFCOM0 GETDEFERR GETDEFCURRENT GETDEFFROMFILE 
                      GETDEFSAVED (RETFNS GETDEFCOM)
                      (NOLINKFNS . T)
                      (GLOBALVARS NOT-FOUNDTAG)))
        (DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
               (ADDVARS (NLAMA \DUMPEXPORTS MAKEUSERMACROSCOMS MAKEPROPSCOMS MAKELISPXMACROSCOMS 
                               MAKEFILESCOMS MAKEALISTCOMS LISTFILES COMPILEFILES CLEANUP 
                               FILEPKGCOMPROPS PRETTYDEFMACROS)
                      (NLAML)
                      (LAMA FILEPKGTYPE FILEPKGCOM FILEPKGCHANGES])



(* ; "standard records for accessing file  package type/command parts.  Exported for PRETTY")


(RPAQQ FILEPKGTYPEPROPS (NEWCOM WHENFILED WHENUNFILED GETDEF NULLDEF DELDEF PUTDEF WHENCHANGED 
                                   HASDEF EDITDEF CANFILEDEF FILEGETDEF))
(* "FOLLOWING DEFINITIONS EXPORTED")(DECLARE%: EVAL@COMPILE DONTCOPY 

(RPAQQ FILEPKGRECORDS (FILEPKGCOM FILEPKGTYPE FILE FILEDATEPAIR FILEPROP))
(DECLARE%: EVAL@COMPILE

(ACCESSFNS FILEPKGCOM [[ADD (GETPROP DATUM 'ADDTOPRETTYCOM)
                                  (UNDOABLE (COND
                                               (NEWVALUE (/PUTPROP DATUM 'ADDTOPRETTYCOM NEWVALUE))
                                               (T (/REMPROP DATUM 'ADDTOPRETTYCOM]
                           [DELETE (GETPROP DATUM 'DELFROMPRETTYCOM)
                                  (UNDOABLE (COND
                                               (NEWVALUE (/PUTPROP DATUM 'DELFROMPRETTYCOM NEWVALUE))
                                               (T (/REMPROP DATUM 'DELFROMPRETTYCOM]
                           [PRETTYTYPE (GETPROP DATUM 'PRETTYTYPE)
                                  (UNDOABLE (COND
                                               (NEWVALUE (/PUTPROP DATUM 'PRETTYTYPE NEWVALUE))
                                               (T (/REMPROP DATUM 'PRETTYTYPE]
                           [CONTENTS (GETPROP DATUM 'FILEPKGCONTENTS)
                                  (UNDOABLE (COND
                                               (NEWVALUE (/PUTPROP DATUM 'FILEPKGCONTENTS NEWVALUE))
                                               (T (/REMPROP DATUM 'FILEPKGCONTENTS]
                           (MACRO [CDR (FASSOC DATUM (GETTOPVAL 'PRETTYDEFMACROS]
                                  (STANDARD [COND
                                               [NEWVALUE (PUTASSOC DATUM NEWVALUE
                                                                (OR (LISTP (GETTOPVAL 
                                                                                  'PRETTYDEFMACROS))
                                                                    (SETTOPVAL 'PRETTYDEFMACROS
                                                                           (LIST (LIST DATUM]
                                               (T (SETTOPVAL 'PRETTYDEFMACROS
                                                         (REMOVE (FASSOC DATUM (GETTOPVAL
                                                                                'PRETTYDEFMACROS))
                                                                (GETTOPVAL 'PRETTYDEFMACROS]
                                         UNDOABLE
                                         (COND
                                            [NEWVALUE (/PUTASSOC DATUM NEWVALUE
                                                             (OR (LISTP (GETTOPVAL 'PRETTYDEFMACROS))
                                                                 (/SETTOPVAL 'PRETTYDEFMACROS
                                                                        (LIST (LIST DATUM]
                                            (T (/SETTOPVAL 'PRETTYDEFMACROS
                                                      (REMOVE (FASSOC DATUM (GETTOPVAL 
                                                                                   'PRETTYDEFMACROS))
                                                             (GETTOPVAL 'PRETTYDEFMACROS]
                                                             (* Not an atom record cause want 
                                                           REMPROP on NILs.)
                                                             (* NOTE%: PRETTCOM on PRETTY has 
                                                           open-coded access to the MACRO 
                                                           property.)
                          (INIT (FILEPKGCOMPROPS ADDTOPRETTYCOM DELFROMPRETTYCOM PRETTYTYPE 
                                       FILEPKGCONTENTS)))

(ATOMRECORD FILEPKGTYPE (NEWCOM WHENFILED WHENUNFILED GETDEF NULLDEF DELDEF PUTDEF WHENCHANGED 
                                   HASDEF EDITDEF FILEGETDEF CANFILEDEF)
                            (ACCESSFNS FILEPKGTYPE [(CHANGEDLST (CAR (SEARCHPRETTYTYPELST DATUM))
                                                           (CAR (SEARCHPRETTYTYPELST DATUM NEWVALUE))
                                                           )
                                                    (CHANGED (GETTOPVAL (CAR (SEARCHPRETTYTYPELST
                                                                              DATUM)))
                                                           (STANDARD (SETTOPVAL (CAR (
                                                                                  SEARCHPRETTYTYPELST
                                                                                      DATUM NEWVALUE)
                                                                                     )
                                                                            NEWVALUE)
                                                                  UNDOABLE
                                                                  (/SETTOPVAL (CAR (
                                                                                  SEARCHPRETTYTYPELST
                                                                                    DATUM NEWVALUE))
                                                                         NEWVALUE)))
                                                    (DESCRIPTION (CAR (CDDR (SEARCHPRETTYTYPELST
                                                                             DATUM)))
                                                           (CAR (RPLACA (CDDR (SEARCHPRETTYTYPELST
                                                                               DATUM NEWVALUE))
                                                                       NEWVALUE)))
                                                    (ALLFIELDS NIL
                                                           (/SETTOPVAL 'PRETTYTYPELST
                                                                  (REMOVE (SEARCHPRETTYTYPELST DATUM)
                                                                         (GETTOPVAL 'PRETTYTYPELST]
                                                             (* NOTE%: PRETTYCOM on PRETTY has 
                                                           open-coded access to GETDEF property)
                                   (INIT [PROGN (SETQ SYSPROPS (UNION FILEPKGTYPEPROPS SYSPROPS))
                                                (MAPC FILEPKGTYPEPROPS (FUNCTION (LAMBDA (X)
                                                                                   (PUT X
                                                                                        'PROPTYPE
                                                                                        'FILEPKGCOMS]
                                         (ADDTOVAR PRETTYTYPELST ))))

(ATOMRECORD FILE (FILECHANGES FILEDATES FILEMAP)
                     [ACCESSFNS FILE ((FILEPROP (GETPROP DATUM 'FILE)
                                             (STANDARD (PUTPROP DATUM 'FILE NEWVALUE)
                                                    UNDOABLE
                                                    (/PUTPROP DATUM 'FILE NEWVALUE])

(RECORD FILEDATEPAIR (FILEDATE . DATEFILENAME))

(RECORD FILEPROP ((COMSNAME . LOADTYPE) . TOBEDUMPED))
)

(FILEPKGCOMPROPS ADDTOPRETTYCOM DELFROMPRETTYCOM PRETTYTYPE FILEPKGCONTENTS)

[PROGN (SETQ SYSPROPS (UNION FILEPKGTYPEPROPS SYSPROPS))
       (MAPC FILEPKGTYPEPROPS (FUNCTION (LAMBDA (X)
                                          (PUT X 'PROPTYPE 'FILEPKGCOMS]

(ADDTOVAR PRETTYTYPELST )
)

(* "END EXPORTED DEFINITIONS")

(DEFINEQ

(SEARCHPRETTYTYPELST
(LAMBDA (TYPE FLG) (* rmk%: " 3-JAN-82 22:55") (* ; "access functions used by the records") (AND (LITATOM TYPE) (OR (find X in PRETTYTYPELST suchthat (EQ (CADR X) TYPE)) (COND (FLG (/SETTOPVAL (QUOTE PRETTYTYPELST) (CONS (SETQ FLG (LIST (PACK* (QUOTE CHANGED) TYPE (QUOTE LST)) TYPE NIL)) (GETTOPVAL (QUOTE PRETTYTYPELST)))) (OR (LISTP (GETTOPVAL (CAR FLG))) (/SETTOPVAL (CAR FLG) NIL)) FLG)))))
)

(PRETTYDEFMACROS
(NLAMBDA ARGS (* lmm " 5-SEP-78 16:16") (* ; "included so that old files will continue to load") (for X in ARGS collect (FILEPKGCOM (CAR X) (QUOTE MACRO) (CDR X))))
)

(FILEPKGCOMPROPS
(NLAMBDA PROPS (MAPC PROPS (FUNCTION (LAMBDA (Y) (OR (MEMB Y SYSPROPS) (SETQ SYSPROPS (CONS Y SYSPROPS))) (PUT Y (QUOTE PROPTYPE) (QUOTE FILEPKGCOMS))))))
)
)

(RPAQQ FILEPKGRECORDS (FILEPKGCOM FILEPKGTYPE FILE FILEDATEPAIR FILEPROP))

(FILEPKGCOMPROPS ADDTOPRETTYCOM DELFROMPRETTYCOM PRETTYTYPE FILEPKGCONTENTS)

[PROGN (SETQ SYSPROPS (UNION FILEPKGTYPEPROPS SYSPROPS))
       (MAPC FILEPKGTYPEPROPS (FUNCTION (LAMBDA (X)
                                          (PUT X 'PROPTYPE 'FILEPKGCOMS]

(ADDTOVAR PRETTYTYPELST )
(DECLARE%: EVAL@COMPILE DOCOPY 

(CL:PROCLAIM '(CL:SPECIAL PRETTYDEFMACROS PRETTYTYPELST FILEPKGTYPES PRETTYPRINTMACROS 
                     *DEFAULT-CLEANUP-COMPILER* MARKASCHANGEDFNS PRETTYFLG))

(CL:PROCLAIM '(GLOBAL FILELST SYSFILES LOADEDFILELST NOTLISTEDFILES NOTCOMPILEDFILES MAKEFILEFORMS 
                     CLEANUPOPTIONS))
)

(RPAQ? MSDATABASELST )



(* ;; "making, adding, listing, compiling files")

(DEFINEQ

(CLEANUP
(NLAMBDA FILES (* lmm "14-Aug-84 19:17") (PROG (TEM1 TEM2 OPTIONS) (COND ((LISTP (CAR (SETQ FILES (NLAMBDA.ARGS FILES)))) (SETQ OPTIONS (CAR FILES)) (SETQ FILES (CDR FILES))) (T (SETQ OPTIONS CLEANUPOPTIONS))) (RETURN (APPEND (MAKEFILES OPTIONS FILES) (COND ((NOT (MEMB (QUOTE LIST) OPTIONS)) NIL) ((NULL FILES) (LISTFILES)) ((SETQ TEM1 (INTERSECTION FILES NOTLISTEDFILES)) (* ; "Intersection check because LISTFILES applied to NIL means list all of NOTLISTEDFILES.") (APPLY (QUOTE LISTFILES) TEM1))) (COND ((NULL (SETQ TEM1 (MEMB (QUOTE RC) OPTIONS)))) ((NULL FILES) (COMPILEFILES0 (SETQ TEM2 NOTCOMPILEDFILES) (CDR TEM1)) TEM2) ((SETQ TEM2 (INTERSECTION FILES NOTCOMPILEDFILES)) (COMPILEFILES0 TEM2 (CDR TEM1)) TEM2))))))
)

(COMPILEFILES
(NLAMBDA FILES (* lmm "14-Aug-84 19:17") (COND ((LISTP (CAR (SETQ FILES (NLAMBDA.ARGS FILES)))) (COMPILEFILES0 (CDR FILES) (CAR FILES))) (T (COMPILEFILES0 FILES))))
)

(COMPILEFILES0
(LAMBDA (FILES OPTIONS) (* rmk%: "19-FEB-83 21:59") (for X OPTS (RCFLG _ T) on (OR FILES NOTCOMPILEDFILES) first (SETQ OPTS (SELECTQ (CAR (LISTP OPTIONS)) (C (SETQ RCFLG NIL) (CDR OPTIONS)) (RC (CDR OPTIONS)) OPTIONS)) do (MAKEFILE1 (OR (MISSPELLED? (CAR X) 70 FILELST NIL X) (CAR X)) RCFLG OPTS X)))
)

(CONTINUEDIT
(LAMBDA (FILE) (* bvm%: "30-Aug-86 15:09") (PROG (STREAM FL TEM FC ENV) (RESETLST (RESETSAVE NIL (LIST (QUOTE CLOSEF) (SETQ STREAM (OPENSTREAM FILE (QUOTE INPUT))))) (SETQ FILE (FULLNAME STREAM)) (SETFILEPTR STREAM 0) (CL:MULTIPLE-VALUE-SETQ (ENV FC) (\PARSE-FILE-HEADER STREAM (QUOTE RETURN)))) (COND ((NOT (fetch FILEPROP of (SETQ FL (ROOTFILENAME FILE)))) (LOADFROM FILE) (* ; "also calls addfile to notice the file."))) (/replace FILECHANGES of FL with (FILECHANGES FC)) (/replace FILEDATES of FL with (LIST (create FILEDATEPAIR FILEDATE _ (CADR FC) DATEFILENAME _ FILE) (create FILEDATEPAIR FILEDATE _ (CAR (SETQ TEM (CDR (MEMB (QUOTE date%:) FC)))) DATEFILENAME _ (CADR TEM)))) (RETURN FILE)))
)

(MAKEFILE
  [LAMBDA (FILE OPTIONS REPRINTFNS SOURCEFILE)           (* ; "Edited 29-Aug-89 11:46 by bvm")

    (* ;; "OPTIONS: FAST means dump with PRETTYFLG set to NIL;  LIST means list the FILE;  RC means RECOMPILE, C means COMPILEL;  --- for C AND RC assume ST unless next option is F.")

    (PROG ((PRETTYFLG (AND [NOT (MEMB 'FAST (SETQ OPTIONS (MKLIST OPTIONS]
                           PRETTYFLG))
           (*PRINT-BASE* (if (EQ *PRINT-BASE* 8)
                             then 8
                           else                          (* ; "make sure radix is either 8 or 10, because all others don't read in like they print.  Maybe obsolete now with makefile environments")
                                 10))
           FILETYPE ROOTNAME FILEPROP CHANGES FILEDATES (Z (ADDFILE FILE)))
          (DECLARE (CL:SPECIAL PRETTYFLG))
          (SETQ FILE (CAR Z))                                (* ; 
                                               "Necessary because FILE might have been misspelled.")
          (SETQ ROOTNAME (CADR Z))                           (* ; "result of (ROOTFILENAME FILE), or if FILE is corrected, result of applying ROOTFILENAME to correct value.")
          (SETQ FILEPROP (CDDR Z))
          (UPDATEFILES)                                  (* ; "Want updating done after file is added to filelst, so any functions that are being dumped are marked as having been dumped.")
          (SETQ CHANGES (fetch TOBEDUMPED of FILEPROP))
          (SETQ FILEDATES (LISTP (fetch FILEDATES of ROOTNAME)))
          (SETQ FILETYPE (GETPROP ROOTNAME 'FILETYPE))
      LP0 (if (AND (NULL (fetch LOADTYPE of FILEPROP))
                       (NULL FILEDATES))
              then                                       (* ; 
                   "File has never been loaded and never dumped i.e. user just set up COMS in core")
            elseif [OR (EQMEMB 'NEW OPTIONS)
                           (AND (NULL MAKEFILEREMAKEFLG)
                                (NOT (MEMB 'REMAKE OPTIONS]
              then (COND
                          ((AND (fetch LOADTYPE of FILEPROP)
                                (NEQ T (fetch LOADTYPE of FILEPROP)))
                           (LISPXPRIN2 FILE T T)
                           (LISPXPRIN1 (SELECTQ (fetch LOADTYPE of FILEPROP)
                                           (LOADCOMP 
                                                  "the file was loaded for compilation purposes only")
                                           ((compiled Compiled COMPILED) 
                                                " -- only the compiled file has been loaded
")
                                           ((loadfns LOADFNS) 
                                                " -- only some of its symbolics have been loaded
")
                                           (SHOULDNT))
                                  T)
                           (COND
                              ((NEQ (ASKUSER DWIMWAIT 'Y "Go ahead and MAKEFILE anyway? ")
                                    'Y)                      (* ; 
            "E.g. user loads a .com file and then resets the COMS or defines the functons by hand.")
                               (GO OUT)))
                           (/replace LOADTYPE of FILEPROP with NIL)))
                    (SETQ SOURCEFILE NIL)
                    (SETQ REPRINTFNS NIL)
            elseif SOURCEFILE
              then                                       (* ; "source file given")
            elseif [AND FILEDATES (OR [AND (SETQ SOURCEFILE (FINDFILE ROOTNAME T))
                                               (EQUAL (FILEDATE SOURCEFILE)
                                                      (fetch FILEDATE of (CAR FILEDATES]
                                          (AND [NOT (STRING-EQUAL SOURCEFILE (SETQ SOURCEFILE
                                                                              (fetch DATEFILENAME
                                                                                 of (CAR 
                                                                                            FILEDATES
                                                                                             ]
                                               (INFILEP SOURCEFILE)
                                               (EQUAL (FILEDATE SOURCEFILE)
                                                      (fetch FILEDATE of (CAR FILEDATES]
              then (/replace DATEFILENAME of (CAR FILEDATES) with SOURCEFILE)
                    (OR REPRINTFNS (SETQ REPRINTFNS (FILEPKG.CHANGEDFNS CHANGES)))
            elseif [AND (CDR FILEDATES)
                            [SETQ SOURCEFILE (INFILEP (fetch DATEFILENAME of (CADR FILEDATES]
                            (EQUAL (FILEDATE SOURCEFILE)
                                   (fetch FILEDATE of (CADR FILEDATES]
              then 

                    (* ;; "prevous version file is gone, drop back to original daddy file and dump everything that has been changed.")

                    (SETQ CHANGES (FILEPKG.MERGECHANGES (fetch TOBEDUMPED of FILEPROP)
                                         (fetch FILECHANGES of ROOTNAME)))
                    (SETQ REPRINTFNS (FILEPKG.CHANGEDFNS CHANGES))
            else (LISPXPRIN1 
                            '"can't find either the previous version or the original version of 
" T)
                  (LISPXPRIN2 FILE T T)
                  (LISPXPRIN1 '", so it will have to be written anew
" T)
                  (SETQ SOURCEFILE NIL)
                  (SETQ REPRINTFNS NIL)
                  (push OPTIONS 'NEW)
                  (SETQ CHANGES (fetch FILECHANGES of ROOTNAME))
                  (GO LP0))
          (COND
             ((AND SOURCEFILE (SETQ Z (SELECTQ (fetch LOADTYPE of FILEPROP)
                                          (LOADCOMP          (* ; 
                                                   "only loaded via LOADCOMP.  Need to do LOADFROM")
                                                    (LIST 'N SOURCEFILE "was loaded with LOADCOMP"
                                                          '- "LOADFROM it to obtain VARS/COMS"))
                                          (Compiled (AND (INFILECOMS? 'DONTCOPY 'DECLARE%:
                                                                (fetch COMSNAME of FILEPROP))
                                                         (LIST 'Y "only compiled version of" ROOTNAME
                                                               
                                        "was loaded; LOADVARS the (DECLARE .. DONTCOPY ) expressions"
                                                               )))
                                          ((compiled loadfns) 
                                               (LIST 'N "Only some functions from" SOURCEFILE 
                                             "loaded via LOADFNS. Load all other expressions from it"
                                                     ))
                                          NIL)))
              (SELECTQ [ASKUSER DWIMWAIT (CAR Z)
                              (CDR Z)
                              '((Y "es
")
                                (N "o
")
                                (A "bort MAKEFILE
"]
                  (Y (SELECTQ (fetch LOADTYPE of FILEPROP)
                         (LOADCOMP                           (* ; 
                               "file was never actually loaded, just loadcomped.  thus no filecoms")
                                   (LOADFROM SOURCEFILE))
                         (Compiled 

                                 (* ;; "This is going to be a remake.  If it was originally loaded as a compiled file, must first do a LOADFROM in order to get the properties set up by declare: etc.")

                                   (LOADVARS 'DONTCOPY SOURCEFILE)
                                   (/replace LOADTYPE of FILEPROP with 'COMPILED)
                                                             (* ; "So wont have to be done again.")

                                 (* ;; "These are the only DECLARE:'s that are not also on the compiled file.  Note that a DECLARE: DONTEVAL@LOAD will be found and evaluated, but the corresponding expressions won't be evaluated from within the DECLARE:  Not worthwhile to bother setting up a complicated edit pattern to screen these out, especially if you consider expressions like (DECLARE: -- DONTEVAL@LOAD -- DOEVAL@LOAD --)")

                                   )
                         ((loadfns compiled) 

                                 (* ;; "This is going to be a remake, but the original call to LOADFNS didnt specify all the VARS, so some expressions may not have been loaded.")

                              (LOADVARS T SOURCEFILE))
                         NIL))
                  (A (GO OUT))
                  NIL)))
          (RESETLST
              [COND
                 ((MEMB 'NOCLISP OPTIONS)
                  (RESETSAVE PRETTYTRANFLG T))
                 ((MEMB 'CLISP%  OPTIONS)
                  (RESETSAVE PRETTYTRANFLG 'BOTH]
              (RESETSAVE %#UNDOSAVES)
              [COND
                 ((OR (MEMB 'CLISPIFY OPTIONS)
                      (MEMB 'CLISP OPTIONS))
                  (RESETSAVE CLISPIFYPRETTYFLG T))
                 ((OR (EQ FILETYPE 'CLISP)
                      (MEMB 'CLISP (LISTP FILETYPE)))
                  (RESETSAVE CLISPIFYPRETTYFLG 'CHANGES]
              (for X in MAKEFILEFORMS do (ERSETQ (EVAL X)))
              (SETQ FILE (PRETTYDEF NIL FILE (fetch COMSNAME of FILEPROP)
                                REPRINTFNS SOURCEFILE CHANGES)))
          (SETQ LASTFILE ROOTNAME)
          (/replace TOBEDUMPED of FILEPROP with NIL)
          (COND
             ((NOT (EQMEMB 'DON'TLIST FILETYPE))
              (pushnew NOTLISTEDFILES ROOTNAME)))
          (COND
             ((NOT (EQMEMB 'DON'TCOMPILE FILETYPE))
              (pushnew NOTCOMPILEDFILES ROOTNAME)))
          [for TAIL OPT on OPTIONS do (SETQ OPT (CAR TAIL))
                                                 (SELECTQ OPT
                                                     (RC (AND (MEMB ROOTNAME NOTCOMPILEDFILES)
                                                              (MAKEFILE1 FILE T (CDR TAIL))))
                                                     (C (AND (MEMB ROOTNAME NOTCOMPILEDFILES)
                                                             (MAKEFILE1 FILE NIL (CDR TAIL))))
                                                     (LIST (AND (MEMB ROOTNAME NOTLISTEDFILES)
                                                                (APPLY 'LISTFILES (LIST FILE))))
                                                     (COND
                                                        ((MEMB OPT MAKEFILEOPTIONS))
                                                        ((FIXSPELL OPT NIL MAKEFILEOPTIONS NIL 
                                                                OPTIONS)
                                                         (GO $$LP))
                                                        (T (ERROR "Unrecognized MAKEFILE option" OPT]
          (RETURN FILE)
      OUT (RETURN (LIST FILE "-- MAKEFILE not performed."])

(FILECHANGES
(LAMBDA (FILE TYPE) (* bvm%: "30-Aug-86 15:08") (* ;; "If FILE is a list, it is assumed to be a file-created expressions;  otherwise, the filecreated expression is read from FILE.  If TYPE, returns the list of changed items of that type from the changes expression.  If TYPE=NIL, returns the whole list of typed change-lists") (PROG ((FCEXPR (OR (LISTP FILE) (AND FILE (RESETLST (LET (OLDPTR STREAM) (if (SETQ STREAM (OPENP FILE (QUOTE INPUT))) then (SETQ OLDPTR (GETFILEPTR STREAM)) (SETFILEPTR STREAM 0) else (RESETSAVE NIL (LIST (QUOTE CLOSEF) (SETQ STREAM (OPENSTREAM FILE (QUOTE INPUT)))))) (CL:MULTIPLE-VALUE-BIND (ENV FC) (\PARSE-FILE-HEADER STREAM (QUOTE RETURN)) (if OLDPTR then (SETFILEPTR STREAM OLDPTR)) FC)))))) FNS CHANGES) (SETQ CHANGES (LDIFF (SETQ CHANGES (CDR (MEMB (QUOTE to%:) FCEXPR))) (MEMB (QUOTE previous) CHANGES))) (if (AND TYPE (NEQ TYPE (QUOTE FNS))) then (RETURN (CDR (ASSOC TYPE CHANGES)))) (SETQ FNS (SUBSET CHANGES (FUNCTION LITATOM))) (* ; "Old style changes expression listed FNS by name and other things by type") (RETURN (if TYPE then (* ; "TYPE=FNS cause of test above.") (NCONC FNS (CDR (ASSOC (QUOTE FNS) CHANGES))) elseif FNS then (CONS (CONS (QUOTE FNS) FNS) (SUBSET CHANGES (FUNCTION LISTP))) else CHANGES))))
)

(FILEPKG.MERGECHANGES
(LAMBDA (C1 C2) (* rmk%: "24-MAY-82 23:09") (* ;; "Merges 2 changes lists into a single one.  Treat LITATOM's as FNS, to accomodate old-style format on files.") (for E2 TEMP (VAL _ (for E1 in C1 when (CDR (LISTP E1)) collect (APPEND E1))) in C2 do (COND ((SETQ TEMP (ASSOC (CAR E2) VAL)) (NCONC TEMP (for X in (CDR E2) unless (MEMBER X (CDR TEMP)) collect X))) (T (SETQ VAL (NCONC1 VAL (APPEND E2))))) finally (RETURN VAL)))
)

(FILEPKG.CHANGEDFNS
(LAMBDA (CHANGES) (* rmk%: "20-MAY-82 22:00") (* ;; "Returns list of function names from a file-changes list.  Interprets old format (functions are atoms) and new format (with explicit type headers)") (CDR (ASSOC (QUOTE FNS) CHANGES)))
)

(MAKEFILE1
  [LAMBDA (FILE RECOMPFLG OPTIONS OTHERFILES)            (* ; "Edited 29-Aug-89 11:46 by bvm")
    (PROG* ((ROOTNAME (ROOTFILENAME FILE))
            (COMPILER (COMPILE-FILE? ROOTNAME))
            GROUP)
           (COND
              ((AND (OR (EQ COMPILER 'BCOMPL)
                        (EQ COMPILER 'TCOMPL))
                    (NOT (FILEFNSLST ROOTNAME)))         (* ; 
                 "No FNS on this file, and we're told to use Interlisp compiler, so nothing to do.")
               (/SETTOPVAL 'NOTCOMPILEDFILES (REMOVE ROOTNAME NOTCOMPILEDFILES))
               (RETURN NIL)))
           (COND
              ([find X in (SETQ GROUP (GETPROP ROOTNAME 'FILEGROUP))
                  suchthat (AND (NEQ X ROOTNAME)
                                    (OR (fetch TOBEDUMPED of (fetch FILEPROP of
                                                                                         X))
                                        (MEMB X OTHERFILES]

               (* ;; "The file in question must be recompiled with other files, and one of the remaining files still needs to be dumped, or else one of the other file is further down the list of files being compiled.  Wait.")

               (RETURN)))
           (LISPXPRIN1 '"
compiling " T)
           (LISPXPRINT (OR GROUP FILE)
                  T T)
           (LISPXPRINT (LET [[REDEFINE? (OR (EQ (CAR OPTIONS)
                                                'ST)
                                            (EQ (CAR OPTIONS)
                                                'STF]
                             (FORGET-EXPRS? (EQ (CAR OPTIONS)
                                                'STF]
                            (SELECTQ COMPILER
                                ((FAKE-COMPILE-FILE)         (* ; 
                                               "The old CommonLispy interface to the ByteCompiler.")
                                     (FAKE-COMPILE-FILE FILE :REDEFINE REDEFINE? :SAVE-EXPRS
                                            (AND REDEFINE? (NOT FORGET-EXPRS?))))
                                ((CL:COMPILE-FILE)           (* ; "The new, improved (?) compiler")
                                     (CL:COMPILE-FILE FILE :LOAD (COND
                                                                    ((AND REDEFINE? (NOT 
                                                                                        FORGET-EXPRS?
                                                                                         ))
                                                                     :SAVE)
                                                                    (REDEFINE? T)
                                                                    (T NIL))))
                                ((TCOMPL BCOMPL)             (* ; "The old ByteCompiler")
                                     [IF (MEMB (CAR OPTIONS)
                                                   '(ST F S STF))
                                         THEN (LISPXUNREAD (LIST (CAR OPTIONS]
                                     [IF GROUP
                                         THEN 

                                               (* ;; 
                                   "File contained in FILEGROUP.  Therefore must be blockcompiled.")

                                               (IF RECOMPFLG
                                                   THEN (BRECOMPILE GROUP)
                                                 ELSE (BCOMPL GROUP))
                                       ELSEIF (EQ COMPILER 'TCOMPL)
                                         THEN (IF RECOMPFLG
                                                      THEN (RECOMPILE FILE)
                                                    ELSE (TCOMPL (LIST FILE)))
                                       ELSE (IF RECOMPFLG
                                                    THEN (BRECOMPILE FILE)
                                                  ELSE (BCOMPL (LIST FILE])
                                (SHOULDNT "Non-existent compiler returned from COMPILE-FILE?...")))
                  T T])

(COMPILE-FILE?
(LAMBDA (ROOTNAME) (* ; "Edited 19-Jan-87 21:12 by Pavel") (* ;;; "Which compiler should CLEANUP use?") (LET ((TYPE (GET ROOTNAME (QUOTE FILETYPE))) (UNKNOWN NIL)) (FOR X INSIDE TYPE DO (SELECTQ X ((TCOMPL :TCOMPL) (RETURN (QUOTE TCOMPL))) ((BCOMPL :BCOMPL) (RETURN (QUOTE BCOMPL))) ((:FAKE-COMPILE-FILE CL:COMPILE-FILE COMPILE-FILE) (RETURN (QUOTE FAKE-COMPILE-FILE))) ((:COMPILE-FILE :XCL-COMPILE-FILE) (RETURN (QUOTE CL:COMPILE-FILE))) ((CLISP) NIL) (SETQ UNKNOWN T)) FINALLY (IF UNKNOWN THEN (CL:FORMAT T "~2%%**Warning: unknown FILETYPE value ~S~2%%" TYPE)) (RETURN *DEFAULT-CLEANUP-COMPILER*))))
)

(MAKEFILES
(LAMBDA (OPTIONS FILES) (* rmk%: "23-FEB-83 21:20") (RESETVARS (%#UNDOSAVES) (* ; "Willing to save arbitrary amounts of undo info") (UPDATEFILES) (COND ((NULL FILES) (for TYPE FLG in FILEPKGTYPES when (FILES?1 TYPE (COND ((NULL FLG) (* ; "Gets printed the first time") (QUOTE "****NOTE: the following are not contained on any file:
    ")) (T (QUOTE "    ")))) do (SETQ FLG T) finally (AND FLG (ADDTOFILES?))))) (SETQ OPTIONS (MKLIST OPTIONS)) (RETURN (for FILE inside (OR FILES FILELST) when (fetch TOBEDUMPED of (LISTP (fetch FILEPROP of (ROOTFILENAME FILE)))) collect (LISPXPRIN2 FILE T T) (LISPXPRIN1 (QUOTE |...|) T) (PROG1 (MAKEFILE FILE OPTIONS) (LISPXTERPRI T))))))
)

(ADDFILE
(LAMBDA (FILE LOADTYPE PRLST FCLST) (* bvm%: "29-Aug-86 12:22") (* ;; "PRLST is the FILEPKGCHANGES prior to this file operation, FCLST is a list of file-created arguments, a singleton for a symbolic file, and a list whose car represents the compiled file and whose cdr represent symbolic files compiled into it, for compiled files.") (PROG ((ROOTNAME (ROOTFILENAME FILE)) FLST VAL) (COND ((NOT FCLST) (SETQ VAL (ADDFILE0 ROOTNAME LOADTYPE FILE))) ((NULL (CDR FCLST)) (* ; "A simple symbolic file") (SETQ FCLST (CAR FCLST)) (SETQ VAL (ADDFILE0 (COND ((LITATOM (CADR FCLST)) (ROOTFILENAME (CADR FCLST))) (T ROOTNAME)) LOADTYPE FILE (CAR FCLST)))) (T (* ;; "A compiled file, skip the first expression representing the compiled file itself, look at the cdr representing the symbolic files.") (SELECTQ LOADTYPE ((T LOADFNS) (SETQ LOADTYPE (QUOTE Compiled))) (loadfns (SETQ LOADTYPE (QUOTE compiled))) (LOADCOMP (* ; "loadcomp on compiled file.  Don't notice since we don't know what its state is") NIL) (SHOULDNT)) (for X in (CDR FCLST) when (LITATOM (CADR X)) do (push FLST (CADR X)) (OR (EQ LOADTYPE (QUOTE LOADCOMP)) (ADDFILE0 (ROOTFILENAME (CADR X)) LOADTYPE (CADR X) (CAR X)))))) (UPDATEFILES PRLST (OR FLST (LIST FILE))) (AND LOADTYPE (for TYPE CHANGED in FILEPKGTYPES when (AND (LITATOM TYPE) (SETQ CHANGED (fetch CHANGED of TYPE))) do (/replace CHANGED of TYPE with (INTERSECTION (CDR (ASSOC TYPE PRLST)) CHANGED)))) (AND ADDSPELLFLG (ADDSPELL ROOTNAME USERWORDS)) (RETURN VAL)))
)

(ADDFILE0
(LAMBDA (ROOTNAME LOADTYPE FULLNAME DAT) (* lmm "28-Nov-84 16:47") (PROG (COMS X FILEPROP FLG TEM) TOP (SETQ COMS (FILECOMS ROOTNAME)) (COND ((SETQ FILEPROP (fetch FILEPROP of ROOTNAME)) (COND ((AND LOADTYPE (FMEMB LOADTYPE (CDR (FMEMB (fetch LOADTYPE of FILEPROP) (QUOTE (LOADCOMP loadfns compiled Compiled LOADFNS COMPILED NIL T)))))) (/replace LOADTYPE of FILEPROP with LOADTYPE) (* ;; "This call to ADDFILE reflects a 'higher' degree of loading, so upgrade property.  'loadfns' means just some information from file, if go to do makefile, must do loadfrom, 'compiled' is like 'loadfns' but for compiled files e.g. user does LOADFNS on compiled file.  'Compiled' means all but DECLARE: expressions are in.  e.g. user does LOAD of a compiled file.  COMPILED means everything is in, e.g. user does LOADDFROM a compiled file.  LOADFNS means everything in, e.g. user des LOADFROM symbolic file.  COMPILED and LOADFNS are equivalent in that means dont have to do any more loading when go to do a makefile but makefile NEW isnt permitted.  NIL is a makefile when coms were set up in core.  T is full load of symbolic file.  The check on TYPE=NIL is bcause dont want to upgrade as result of call from makefile, i.e. no new information there.") (* ;; "LOADCOMP means file was loadcomp'ed.  note that the actual structure is a tree, not a list, and the above is only an approximation.  if you do a loadcomp, and then load the compiled file, the state will be left with latter, but then loadcomp? will loadcomp again because compiled files might not contain all the declare: EVAL@COMPILE expressions, e.g. macros, records etc.  however, in most cases, loadcomp is used independently of other loading, e.g. for compilation purposes only, so this will at least permit loadcomp? to work.") (GO OUT)) (T (GO OUT1))))) (COND ((OR LOADTYPE (LISTP (GETTOPVAL COMS))) (SETQ FILEPROP (/replace FILEPROP of ROOTNAME with (create FILEPROP COMSNAME _ COMS LOADTYPE _ LOADTYPE)))) (FLG (GO ERROR)) ((AND DWIMFLG (EQ ROOTNAME FULLNAME) (SETQ ROOTNAME (MISSPELLED? ROOTNAME 70 FILELST T))) (* ;; "The EQ check is so as not to try correcting if the user has specified a version number or directory, as it is too messy trying to take them out, and then put them back in on the corrected root name.") (SETQ FULLNAME ROOTNAME) (SETQ FLG T) (* ; "so wont try to spelling correct again if file isnt there") (GO TOP)) (T (GO ERROR))) OUT (AND LOADTYPE DAT (/replace FILEDATES of ROOTNAME with (LIST (create FILEDATEPAIR FILEDATE _ DAT DATEFILENAME _ FULLNAME)))) (AND (EQ LOADTYPE T) (/replace TOBEDUMPED of FILEPROP with NIL)) OUT1 (COND ((AND (LISTP (GETTOPVAL COMS)) (NOT (FMEMB ROOTNAME (GETTOPVAL (QUOTE FILELST))))) (* ; "coms wuld not be set up on a loadccomp.") (/SETTOPVAL (QUOTE FILELST) (CONS ROOTNAME (GETTOPVAL (QUOTE FILELST)))))) (RETURN (COND ((NULL LOADTYPE) (* ; "call from makefile.") (CONS FULLNAME (CONS ROOTNAME FILEPROP))) (T FILEPROP))) ERROR (ERROR FULLNAME "not file name." T)))
)

(LISTFILES
(NLAMBDA FILES (* rmk%: " 3-Dec-84 08:58") (DECLARE (GLOBALVARS NOTLISTEDFILES)) (* ; "LISTFILES1 is machinedependent") (for FILE FULLNAME OPTIONS in (COND (FILES (SETQ FILES (NLAMBDA.ARGS FILES))) (T NOTLISTEDFILES)) when (COND ((LISTP FILE) (SETQ OPTIONS (APPEND FILE OPTIONS)) NIL) ((SETQ FULLNAME (FINDFILE FILE)) FULLNAME) (T (printout T FILE " not found." T) NIL)) collect (COND ((LISTFILES1 FULLNAME OPTIONS) (SETQ NOTLISTEDFILES (REMOVE (NAMEFIELD FULLNAME T) NOTLISTEDFILES)))) FULLNAME))
)
)

(RPAQ? *DEFAULT-CLEANUP-COMPILER* 'CL:COMPILE-FILE)

(RPAQ? FILELST )

(RPAQ? LOADEDFILELST )

(RPAQ? NOTLISTEDFILES )

(RPAQ? NOTCOMPILEDFILES )

(RPAQ? MAKEFILEFORMS )

(RPAQ? NILCOMS )

(ADDTOVAR MAKEFILEOPTIONS RC C LIST FAST CLISP CLISPIFY NIL REMAKE NEW NOCLISP CLISP%  F ST STF
                                 (REC . RC)
                                 (BREC . RC)
                                 (TC . C)
                                 (BC . C)
                                 (TCOMPL . C)
                                 (BCOMPL . C))

(RPAQ? MAKEFILEREMAKEFLG T)

(RPAQ? CLEANUPOPTIONS '(RC))



(* ;; "scanning file coms")

(DEFINEQ

(FILEPKGCHANGES
(LAMBDA N (* Pavel " 7-Oct-86 19:22") (COND ((EQ N 0) (PROG (TEM) (RETURN (for X in FILEPKGTYPES when (AND (LITATOM X) (SETQ TEM (FILEPKGCHANGES X))) collect (CONS X TEM))))) ((EQ (ARG N 1) T) (for X in FILEPKGTYPES when (LITATOM X) collect (CONS X (FILEPKGCHANGES X)))) ((EQ N 1) (COND ((LISTP (ARG N 1)) (for X in (ARG N 1) when (FMEMB (CAR X) FILEPKGTYPES) do (/replace CHANGED of (CAR X) with (CDR X)))) (T (for Y on (fetch CHANGED of (ARG N 1)) when (AND (CAR Y) (NOT (for Z in (CDR Y) thereis (CL:EQUAL (CAR Y) Z)))) collect (CAR Y))))) (T (/replace CHANGED of (ARG N 1) with (ARG N 2)))))
)

(GETFILEPKGTYPE
(LAMBDA (TYPE ONLY NOERROR NAME) (* lmm "20-Nov-86 23:10") (* ;; "Coerce TYPE to a well defined definition type (FILEPKG type) or a command. ONLY is an indicator of which is acceptable; if NIL, either one is acceptable, if COMS, only commands are acceptable, and if TYPES, only types should be returned. If none is found, will signal an error if NOERROR is NIL, otherwise return NIL. ") (COND ((LISTP TYPE) (* ;; " given a list of types, coerce them all or return NIL") (for X in TYPE collect (OR (GETFILEPKGTYPE X ONLY NOERROR NAME) (RETURN)))) ((EQ TYPE (QUOTE ?)) (* ;; "odd case, may be obsolete: if given IL:?, return all known types of NAME. Maybe used by EDITDEF(NAME ?)?? ") (AND NAME (TYPESOF NAME))) ((AND (NEQ ONLY (QUOTE COMS)) (OR (SELECTQ TYPE (NIL (QUOTE FNS)) (T (QUOTE VARS)) NIL) (for X in FILEPKGTYPES do (if (EQ TYPE X) then (* ;; "type matched exactly") (RETURN TYPE) elseif (AND (LISTP X) (EQ TYPE (CAR X))) then (RETURN (CDR X))))))) ((AND (NEQ ONLY (QUOTE TYPE)) (LITATOM TYPE) (PROG1 (CAR (FMEMB TYPE FILEPKGCOMSPLST)) (* ; "Prefer an exact match quickly")))) ((AND (NEQ ONLY (QUOTE COMS)) (LITATOM TYPE) (for X in FILEPKGTYPES bind NAME do (SETQ NAME (if (NLISTP X) then X else (CAR X))) (* ;; "see if spelled the same or 1 char shorter; assume all FILEPKGTYPE names end with S. This handles package conversions and also pluralization") (AND (<= 0 (- (NCHARS NAME) (NCHARS TYPE)) 1) (STRPOS TYPE NAME) (RETURN (if (EQ X NAME) then X else (CDR X))))))) ((FIXSPELL TYPE NIL (SELECTQ ONLY (TYPE FILEPKGTYPES) (COMS FILEPKGCOMSPLST) (UNION FILEPKGTYPES FILEPKGCOMSPLST)))) ((NOT NOERROR) (ERROR (SELECTQ ONLY (TYPE "unrecognized manager definition type") (COMS "unrecognized manager command") "unrecognized manager definition-type/command") TYPE))))
)

(MARKASCHANGED
(LAMBDA (NAME TYPE REASON) (* ; "Edited 25-May-88 15:37 by drc:") (COND (FILEPKGFLG (SETQ REASON (SELECTQ REASON ((CLISP LOAD CHANGED DEFINED DELETED) REASON) (NIL (QUOTE CHANGED)) (T (QUOTE DEFINED)) (ERROR "bad REASON in MARKASCHANGED" REASON))) (SETQ TYPE (GETFILEPKGTYPE TYPE (QUOTE TYPE))) (for FN inside (fetch WHENCHANGED of TYPE) do (APPLY* FN NAME TYPE REASON)) (for FN in MARKASCHANGEDFNS do (APPLY* FN NAME TYPE REASON)) (COND ((EQ REASON (QUOTE DELETED)) (for L on (fetch CHANGED of TYPE) when (EQUAL (CAR L) NAME) do (/RPLACA L NIL)) (* ; "unmark as changed and remove from files") (DELFROMFILES NAME TYPE)) (T (LET ((LST (push (fetch CHANGED of TYPE) NAME))) (AND LISPXHIST (UNDOSAVE (LIST (QUOTE /RPLACA) LST) LISPXHIST)) (* ; "UNDO by smashing with NIL;  makes calls to MARKASCHANGED independent")))) NAME)))
)

(FILECOMS
(LAMBDA (FILE X) (* rmk%: "19-FEB-83 13:55") (COND ((AND (NULL FILE) (NULL X)) (QUOTE NILCOMS)) ((AND (OR (NULL X) (EQ X (QUOTE COMS))) (fetch COMSNAME of (LISTP (fetch FILEPROP of FILE))))) (T (PACK* (COMSNAME FILE) (OR X (QUOTE COMS))))))
)

(WHEREIS
  [LAMBDA (NAME TYPE FILES FN)                        (* ; "Edited 12-Jul-88 17:14 by MASINTER")

    (* ;; "T as a NAME has a special meaning to INFILECOMS?  so don't pass through.")

    (CL:UNLESS (EQ NAME T)
        (LET [(IN-FILES (UNION [SUBSET (OR (LISTP FILES)
                                           FILELST)
                                      (FUNCTION (LAMBDA (FILE)
                                                  (INFILECOMS? NAME TYPE (FILECOMS FILE]
                               (AND (EQ FILES T)
                                    (CL:FBOUNDP 'XCL::HASH-FILE-WHERE-IS)
                                    (LET ((FILES NIL))
                                         (for TY inside TYPE
                                            do (for FILE-NAME
                                                      in (XCL::HASH-FILE-WHERE-IS NAME
                                                                    (GETFILEPKGTYPE TYPE))
                                                      do (CL:PUSHNEW (MKATOM (U-CASE FILE-NAME))
                                                                    FILES)))
                                         (REVERSE FILES]
             (CL:IF FN
                 [MAPC IN-FILES (FUNCTION (LAMBDA (FILE)
                                            (APPLY* FN NAME FILE]
                 IN-FILES)))])

(SMASHFILECOMS
(LAMBDA (FILE) (* rmk%: "19-FEB-83 22:15") (for X in (FILECOMSLST FILE (QUOTE FILEVARS)) when (LITATOM X) do (SETTOPVAL X (QUOTE NOBIND))) FILE)
)

(FILEFNSLST
  [LAMBDA (FILE)                                         (* ; "Edited 14-Jun-90 19:30 by jds")
    (FILECOMSLST FILE '(FUNCTIONS FNS])

(FILECOMSLST
(LAMBDA (FILE TYPE FLG) (* JonL "24-Jul-84 19:48") (* ; "TYPE is coerced in the innards of INFILECOMS?") (COND ((EQ FLG (QUOTE UPDATE)) (CDR (INFILECOMS? NIL TYPE (FILECOMS FILE) FLG))) (T (INFILECOMS? NIL TYPE (FILECOMS FILE) FLG))))
)

(UPDATEFILES
(LAMBDA (PRLST FLST) (* rmk%: "19-FEB-83 14:27") (* ;; "PRLST may be the value of FILEPKGCHANGES before some operation (e.g.  LOAD, LOADFNS) involving the files in FLST began.") (for TYPE CHANGED in FILEPKGTYPES when (SETQ CHANGED (fetch CHANGED of TYPE)) do (COND ((NULL (SETQ CHANGED (FILEPKGCHANGES TYPE))) (* ; "FILEPKGCHANGES eliminates duplicates") (/replace CHANGED of TYPE with NIL)) (T (for FILE FOUND FILEPROP COMS LST TYPEDPROP PCHANGES (PREVITEMS _ (CDR (ASSOC TYPE PRLST))) in FILELST first (SETQ LST (INFILECOMS? CHANGED TYPE (QUOTE NILCOMS) (QUOTE UPDATE))) (* ;; "First check NIL=Nowhere.  LST:1 contains variables whose values are on the file literally.  These are `found' but not marked.  LST::1 contains all other items.") (SETQ FOUND (NCONC (CAR LST) (CDR LST) FOUND)) do (SETQ PCHANGES (COND ((FMEMB (fetch DATEFILENAME of (CAR (fetch FILEDATES of FILE))) FLST) (* ;; "PREVITEMS are changed items that were previously on the changed list, before PRLST was computed as this LOAD/LOADFNS began.  Thus, by this intersection we only worry about items that were previously changed;  any items that were only changed during this operation are ignored.") (INTERSECTION CHANGED PREVITEMS)) (T CHANGED))) (COND ((AND PCHANGES (SETQ COMS (fetch COMSNAME of (SETQ FILEPROP (LISTP (fetch FILEPROP of FILE))))) (SETQ LST (INFILECOMS? PCHANGES TYPE COMS (QUOTE UPDATE)))) (* ;; "LST:1 is a list of the times that literally appear on this file, LST::1 is a list of those whose literal values are not in the coms") (COND ((CDR LST) (* ; "CDR items must be distributed") (COND ((NULL (fetch TOBEDUMPED of FILEPROP)) (* ;; "Only finagle global lists the first time an item is added to PROP, when PROP::1 goes from NIL to non-NIL") (/SETTOPVAL (QUOTE NOTLISTEDFILES) (REMOVE FILE (GETTOPVAL (QUOTE NOTLISTEDFILES)))) (/SETTOPVAL (QUOTE NOTCOMPILEDFILES) (REMOVE FILE (GETTOPVAL (QUOTE NOTCOMPILEDFILES)))))) (* ; "Get the (possibly new) TYPE item list to smash") (COND ((SETQ TYPEDPROP (ASSOC TYPE (fetch TOBEDUMPED of FILEPROP)))) (T (/NCONC1 FILEPROP (SETQ TYPEDPROP (CONS TYPE))))) (* ; "Now distribute items to the file property") (for Y in (CDR LST) unless (MEMBER Y (CDR TYPEDPROP)) do (/NCONC1 TYPEDPROP Y)))) (SETQ FOUND (NCONC (CAR LST) (CDR LST) FOUND)))) finally (/replace CHANGED of TYPE with (LDIFFERENCE CHANGED FOUND)))))))
)

(INFILECOMS?
  [LAMBDA (NAME TYPE COMS ONFILETYPE)                 (* ; "Edited 12-Jul-88 17:42 by MASINTER")

    (* ;; "Returns T if NAME is 'CONTAINED' in COMS.  If NAME is NIL, then value is a list of all of the functions contained in COMS.  If NAME=T, value is T if there are any elements of type TYPE, otherwise NIL (this feature is used for deciding whether or not (and how) to compile files.)  Called by FILEFNSLST (which is used by BRECOMPILE) and by NEWFILE1.  while elements are the subset of NAME which are on the file in other case")

    (* ;; "if ONFILETYPE is UPDATE, then NAME is a list of elements, and INFILECOMS?  returns the dotted pair of (literals  . elements) where literals are those which are `literally' on the file (e.g.  (VARS (X 3))) --- if ONEFILETYPE is EDIT, then NAME is interpreted as for ONFILETYPE=NIL, but only those elements which are not on the file literally and which are not subparts of other types are returned")

    (* ;; "if ONFILETYPE is TYPESOF, type can be a list of types, and returns a list of types suitable for EDITDEF ")

    (PROG (VAL LITERALS ORIGFLG)
          (SETQ TYPE (GETFILEPKGTYPE TYPE))
          (SELECTQ ONFILETYPE
              (EDIT (SELECTQ TYPE
                        (FILEVARS (RETURN))
                        NIL))
              NIL)
          [COND
             ((LITATOM COMS)
              (SELECTQ TYPE
                  ((VARS FILEVARS)                           (* ; 
                                                           "the COMS of a file are also on it")
                       (INFILECOMSVAL COMS))
                  NIL)
              (SETQ COMS (EVALV COMS]
          (INFILECOMS COMS)
          (SETQ VAL (DREVERSE VAL))
          (RETURN (COND
                     ((EQ ONFILETYPE 'UPDATE)
                      (CONS LITERALS VAL))
                     (T VAL])

(INFILECOMTAIL
  [LAMBDA (COM FLG)                                   (* ; "Edited  2-Aug-88 02:15 by masinter")
    [SETQ COM (COND
                 ((EQ (CADR COM)
                      '*)
                  (COND
                     [(LITATOM (CADDR COM))
                      (LISTP (EVALV (CADDR COM]
                     (T [RESETVARS (DWIMLOADFNSFLG)
                                   (NLSETQ (SETQ COM (EVAL (CADDR COM]
                        COM)))
                 (T (CDR COM]
    (if (NOT FLG)
        then (for X in COM
                    do [if (AND (LISTP X)
                                        (EQ (CAR X)
                                            COMMENTFLG))
                               then (RETURN (SUBSET COM (FUNCTION (LAMBDA (X)
                                                                        (OR (NLISTP X)
                                                                            (NEQ (CAR X)
                                                                                 COMMENTFLG]
                    finally (RETURN COM))
      else COM])

(INFILECOMS
(LAMBDA (COMS) (* rmk%: "19-FEB-83 22:17") (for X in COMS do (INFILECOM X))))

(INFILECOM
  [LAMBDA (COM)                                       (* ; "Edited  2-Aug-88 02:27 by masinter")
    (COND
       [(NLISTP COM)
        (COND
           ((EQ TYPE 'VARS)
            (INFILECOMSVAL COM]
       ((EQ (CAR COM)
            COMMENTFLG)

        (* ;; 
"must be special case'd first so that (* * values) doesn't make it look like `values' is a variable")
                                                             (* ; 
  "don't know why I should bother, but someone might want to know all of the comments on a file???")
        (COND
           ((EQ TYPE COMMENTFLG)
            (INFILECOMSVAL COM T)))
        NIL)
       (T
        (PROG ((COMNAME (CAR COM))
               (TAIL (CDR COM))
               CFN TEM)
              (COND
                 [[COND
                     ((SETQ CFN (fetch (FILEPKGCOM CONTENTS) of COMNAME))
                      (SETQ TEM (APPLY* CFN COM (COND
                                                   ((AND (NULL ONFILETYPE)
                                                         (NOT (CL:SYMBOLP NAME)))
                                                             (* ; 
                                                "call from WHEREIS of a name which is not a symbol")
                                                    (LIST NAME))
                                                   (T NAME))
                                       TYPE ONFILETYPE)))
                     ((SETQ CFN (fetch (FILEPKGCOM PRETTYTYPE) of COMNAME))
                                                             (* ; "for compatability")
                      (SETQ TEM (APPLY* CFN COM TYPE NAME]
                  (COND
                     [(NLISTP TEM)
                      (COND
                         ((EQ TEM T)
                          (COND
                             ((OR (EQ NAME T)
                                  (NULL ONFILETYPE))
                              (RETFROM 'INFILECOMS? T]
                     (T (INFILECOMSVALS TEM]
                 ((LISTP TAIL)

                  (* ;; "this SELECTQ handles the `exceptional cases' for the built in types.  There is an explicit RETURN in the SELECTQ clause if the default is handled")

                  (SELECTQ COMNAME
                      ((PROP IFPROP) 
                           (SETQ TAIL (CDR TAIL)))
                      NIL)
                  [COND
                     ((EQ (CAR TAIL)
                          '*)
                      (COND
                         ((LITATOM (CADR TAIL))
                          (SELECTQ TYPE
                              ((VARS FILEVARS) 
                                   (INFILECOMSVAL (CADR TAIL)))
                              NIL))
                         ((AND (LISTP (CADR TAIL))
                               (EQ ONFILETYPE 'UPDATE)
                               (EQ TYPE 'VARS)
                               (EQ (CAADR TAIL)
                                   'PROGN)
                               (FMEMB (CAR (LAST (CADR TAIL)))
                                      NAME))
                          (SETQ VAL (CONS (CADR TAIL)
                                          VAL]
                  (SELECTQ COMNAME
                      ((COMS EXPORT) 
                           (INFILECOMS (INFILECOMTAIL COM T)))
                      (CL:EVAL-WHEN (INFILECOMS (INFILECOMTAIL (CDR COM)
                                                           T)))
                      (DECLARE%:                             (* ; "skip over DECLARE: tags")
                                 [RETURN (AND (NOT (FMEMB 'COMPILERVARS COM))
                                              (IFCDECLARE (INFILECOMTAIL COM)
                                                     (EQ TYPE 'DECLARE%:])
                      (ORIGINAL                              (* ; "dont expand macros")
                                (PROG ((ORIGFLG T))
                                      (INFILECOMS (INFILECOMTAIL COM T))))
                      ((PROP IFPROP)                         (* ; 
                                       "this currently does not handle `pseudo-types' of PROPNAMES")
                           (SELECTQ TYPE
                               (PROPS (IFCPROPSCAN (INFILECOMTAIL (CDR COM)
                                                              T)
                                             (CADR COM)))
                               (MACROS (INFILECOMSMACRO (INFILECOMTAIL (CDR COM))
                                              (CADR COM)))
                               NIL))
                      (PROPS (RETURN (IFCPROPS COM)))
                      (MACROS (RETURN (SELECTQ TYPE
                                          (PROPS (IFCPROPSCAN (INFILECOMTAIL COM T)
                                                        MACROPROPS))
                                          (MACROS (INFILECOMSVALS (INFILECOMTAIL COM T)))
                                          NIL)))
                      (ALISTS                                (* ; 
                      "sigh.  This should probably also `coerce' when asking for LISPXMACROS, etc.")
                              (RETURN (SELECTQ TYPE
                                          (ALISTS (INFILEPAIRS (INFILECOMTAIL COM)))
                                          NIL)))
                      (P [RETURN (SELECTQ TYPE
                                     ((EXPRESSIONS P) 
                                          (INFILECOMSVALS (INFILECOMTAIL COM T)
                                                 T))
                                     (COND
                                        ((NULL ONFILETYPE)   (* ; "for WHEREIS and FILECOMSLST")
                                         (SELECTQ TYPE
                                             (I.S.OPRS (IFCEXPRTYPE COM 'I.S.OPR))
                                             (TEMPLATES (IFCEXPRTYPE COM 'SETTEMPLATE))
                                             NIL])
                      ((ADDVARS APPENDVARS) 
                           (SELECTQ TYPE
                               (VARS [RETURN (AND (NULL ONFILETYPE)
                                                  (for X in (INFILECOMTAIL COM T)
                                                     do (INFILECOMSVAL (CAR X)
                                                                   T])
                               (ALISTS [RETURN (for X in (INFILECOMTAIL COM T)
                                                  when (EQMEMB 'ALIST (GETPROP (CAR X)
                                                                                 'VARTYPE))
                                                  do (for Z in (CDR X)
                                                            do (INFILECOMSVAL
                                                                    (LIST (CAR X)
                                                                          (CAR Z))
                                                                    T])
                               (OR (EQ TYPE COMNAME)
                                   (RETURN))))
                      ((VARS INITVARS FILEVARS UGLYVARS HORRIBLEVARS CONSTANTS ARRAY) 
                           [RETURN (COND
                                      ((EQ TYPE 'EXPRESSIONS)
                                       (for X in (INFILECOMTAIL COM T)
                                          when (AND (LISTP X)
                                                        (NEQ (CAR X)
                                                             COMMENTFLG))
                                          do (INFILECOMSVAL (CONS 'SETQ X)
                                                        T)))
                                      ((OR (EQ TYPE 'VARS)
                                           (EQ TYPE COMNAME))(* ; 
                   "either want all VARS, or else want all FILEVARS and this is a FILEVARS command")
                                       (for X in (INFILECOMTAIL COM T)
                                          do (COND
                                                    ((LISTP X)
                                                     (AND (CAR X)
                                                          (NEQ (CAR X)
                                                               COMMENTFLG)
                                                          (INFILECOMSVAL (CAR X)
                                                                 T)))
                                                    (X (INFILECOMSVAL X (EQ COMNAME 'INITVARS])
                      (DEFS [RETURN (for X in (INFILECOMTAIL COM T)
                                       when (EQ TYPE (CAR X)) do (INFILECOMSVALS
                                                                          (CDR X])
                      (FILES (RETURN))
                      NIL)

                  (* ;; "Exceptional cases now handled.  If TYPE matches (CAR COM) then scan the tail as usual.  Else expand the com's MACRO, if it has one, unless there was a CONTENTS function")

                  (COND
                     ((EQ COMNAME TYPE)
                      (INFILECOMSVALS (INFILECOMTAIL COM T)))
                     [(AND (LISTP TYPE)
                           (FMEMB COMNAME TYPE))
                      (LET ((TYPE COMNAME))
                           (INFILECOMSVALS (INFILECOMTAIL COM T]
                     ((AND (OR (NULL CFN)
                               (AND (EQ CFN T)
                                    (NULL ONFILETYPE)))
                           (NULL ORIGFLG)
                           (SETQ TEM (fetch (FILEPKGCOM MACRO) of COMNAME)))
                      (INFILECOMS (SUBPAIR (CAR TEM)
                                             (INFILECOMTAIL COM T)
                                             (CDR TEM])

(INFILECOMSVALS
  [LAMBDA (X FLG)                                     (* ; "Edited  2-Aug-88 02:21 by masinter")
    (for Y in X when (NOT (AND (LISTP Y)
                                           (EQ (CAR Y)
                                               COMMENTFLG))) do (INFILECOMSVAL Y FLG])

(INFILECOMSVAL
  [LAMBDA (X FLG)                                     (* ; "Edited 12-Jul-88 17:56 by MASINTER")
    (COND
       [(EQ ONFILETYPE 'UPDATE)
        (AND (OR (NULL NAME)
                 (MEMBER X NAME))
             (COND
                (FLG (SETQ LITERALS (CONS X LITERALS)))
                (T (SETQ VAL (CONS X VAL]
       ((AND (EQ ONFILETYPE 'EDIT)
             FLG)                                            (* ; 
                                        "literals should not be edited as they are on the fileCOMS")
        NIL)
       ((EQ ONFILETYPE 'TYPESOF)
        (AND (COND
                ((LITATOM NAME)
                 (EQ NAME X))
                (T (EQUAL NAME X)))
             (CL:PUSHNEW TYPE VAL)))
       ([OR (EQ NAME T)
            (COND
               ((LITATOM NAME)
                (EQ NAME X))
               (T (EQUAL NAME X]
        (RETFROM (FUNCTION INFILECOMS?)
               T))
       ((NULL NAME)
        (SETQ VAL (CONS X VAL])

(INFILECOMSPROP
(LAMBDA (AT PROP) (* lmm "25-SEP-81 17:15") (COND ((EQ ONFILETYPE (QUOTE UPDATE)) (AND (OR (NULL NAME) (find X in NAME suchthat (AND (EQ (CAR X) AT) (EQ (CADR X) PROP)))) (SETQ VAL (CONS (LIST AT PROP) VAL)))) ((OR (EQ NAME T) (AND (EQ (CAR NAME) AT) (EQ (CADR NAME) PROP))) (RETFROM (FUNCTION INFILECOMS?) T)) ((NULL NAME) (SETQ VAL (CONS (LIST AT PROP) VAL)))))
)

(IFCPROPS
(LAMBDA (COM) (* bvm%: " 2-Dec-83 14:24") (* ;;; "Examine a PROPS com for objects of specified TYPE") (SELECTQ TYPE (PROPS (* ; "the PROPS command can actually take (PROPNAME at1 at2 ...)") (INFILEPAIRS (INFILECOMTAIL COM))) (PROP (* ; "return the atoms which have any properties at all") (for PAIR in (INFILECOMTAIL COM) do (for ATNAME inside (CAR PAIR) do (INFILECOMSVAL ATNAME)))) (MACROS (* ; "only MACRO properties") (for PAIR in (INFILECOMTAIL COM) do (INFILECOMSMACRO (CAR PAIR) (CDR PAIR)))) NIL))
)

(IFCEXPRTYPE
(LAMBDA (COM FN) (* ; "Edited  6-Apr-87 20:20 by Pavel") (* ;;; "Recognizes expressions in COM (a P com) that are calls to function FN") (for SUBCOM in (INFILECOMTAIL COM) when (AND (EQ (CAR SUBCOM) FN) (EQ (CAR (LISTP (CADR SUBCOM))) (QUOTE QUOTE))) do (INFILECOMSVAL (CADR (CADR SUBCOM)) T)))
)

(IFCPROPSCAN
  [LAMBDA (ATOMS PROPNAMES)                           (* ; "Edited  2-Aug-88 02:20 by masinter")

(* ;;; 
"Recognizes members of ATOMS as being names (atom prop) of type PROPS for any prop in PROPNAMES")

    (for AT in ATOMS WHEN (LITATOM AT) unless [COND
                                                                 [(EQ ONFILETYPE 'UPDATE)
                                                                  (COND
                                                                     (NAME (NOT (ASSOC AT NAME]
                                                                 ((LISTP NAME)
                                                                  (NEQ AT (CAR NAME]
       do (COND
                 ((EQ PROPNAMES 'ALL)
                  (for PROP in (GETPROPLIST AT) by (CDDR PROP)
                     when (NOT (FMEMB PROP SYSPROPS)) collect (INFILECOMSPROP AT PROP)))
                 (T (for PROP inside PROPNAMES do (INFILECOMSPROP AT PROP])

(IFCDECLARE
  [LAMBDA (TAIL WANTDECLARE)                          (* ; "Edited  8-Jun-90 18:11 by teruuchi")
    (PROG ((TAIL TAIL))
      LP  (COND
             ((LISTP TAIL)
              [SELECTQ (CAR TAIL)
                  ((EVAL@LOADWHEN EVAL@COMPILEWHEN COPYWHEN) 
                       [AND WANTDECLARE (INFILECOMSVAL (LIST (CAR TAIL)
                                                                 (CADR TAIL]
                       (SETQ TAIL (CDR TAIL)))
                  (DONTEVAL@LOAD [COND
                                    ((OR (\STKSCAN 'DOFILESLOAD)
                                         (\STKSCAN 'LOAD))
                                                  (* ; "Edited by TT (8-June-90 : for AR#9376) In loading, discard the following contents in DECLARE tag %"DONTEVAL@LOAD%"")
                                     (RETURN))
                                    (WANTDECLARE (INFILECOMSVAL (CAR TAIL])
                  (COMPILERVARS (RETURN))
                  (COND
                     [(FMEMB (CAR TAIL)
                             DECLARETAGSLST)
                      (COND
                         (WANTDECLARE (INFILECOMSVAL (CAR TAIL]
                     (T (INFILECOM (CAR TAIL]
              (SETQ TAIL (CDR TAIL))
              (GO LP])

(INFILEPAIRS
(LAMBDA (LST) (* lmm " 4-DEC-78 09:51") (for LL in LST do (for X inside (CAR LL) do (for Y inside (CDR LL) do (INFILECOMSVAL (LIST X Y))))))
)

(INFILECOMSMACRO
(LAMBDA (ATS PROPS) (* lmm "28-SEP-78 18:35") (* ;; "this function is used, given a PROP or PROPS command, to tell which MACROS are contained in it.  --- Normally (e.g.  for WHEREIS and FILECOMSLST) it wants to return if the command contains any of the MACROPROPS for the given atom.  However, for UPDATE, it only wants a `hit' if the command contains ALL of the macro properties") (for AT inside ATS do (AND (OR (NEQ ONFILETYPE (QUOTE UPDATE)) (EVERY (PROPNAMES AT) (FUNCTION (LAMBDA (X) (OR (NOT (FMEMB X MACROPROPS)) (EQMEMB X PROPS)))))) (SOME MACROPROPS (FUNCTION (LAMBDA (PROP) (EQMEMB PROP PROPS)))) (INFILECOMSVAL AT))))
)
)



(* ;; "adding to a file")

(DEFINEQ

(FILES?
(LAMBDA NIL (* bvm%: "27-Oct-86 18:14") (* ;;; "Display each file needing dumping, etc.  For files needing dumping, display details of why.") (UPDATEFILES) (LET (FILES CHANGES PRINTED) (for FILE in FILELST when (SETQ CHANGES (fetch TOBEDUMPED of (LISTP (fetch FILEPROP of FILE)))) do (if (NOT PRINTED) then (LISPXPRIN1 "To be dumped:
" T) (SETQ PRINTED T)) (LISPXPRIN2 FILE T) (LISPXPRIN1 " ...changes to " T) (for CH in CHANGES bind TB do (COND ((LISTP CH) (COND (TB (LISPXTAB TB NIL T)) (T (SETQ TB (POSITION T)))) (LISPXPRIN2 (CAR CH) T) (FILES?PRINTLST (CDR CH))) (T (* ; "old style") (LISPXPRIN2 CH T) (LISPXSPACES 1 T)))) (LISPXTERPRI T)) (for TYPE FLG in FILEPKGTYPES when (FILES?1 TYPE (AND PRINTED "    plus ")) do (SETQ FLG T) finally (if FLG then (OR PRINTED (LISPXPRIN1 "...to be dumped.  " T)) (ADDTOFILES?))) (if (SETQ FILES NOTCOMPILEDFILES) then (FILES?PRINTLST FILES "To be compiled: ") (LISPXTERPRI T)) (if (SETQ FILES NOTLISTEDFILES) then (FILES?PRINTLST FILES "To be listed: ") (LISPXTERPRI T)) (CL:VALUES)))
)

(FILES?1
(LAMBDA (TYPE FIRST) (* bvm%: "27-Oct-86 18:17") (* ;; "If there are changed objects of TYPE, then print them out, preceded by FIRST (if given) plus a descriptive string, and return T.") (LET (STR LST) (COND ((AND (LITATOM TYPE) (SETQ STR (fetch DESCRIPTION of TYPE)) (LISTP (SETQ LST (fetch CHANGED of TYPE)))) (AND FIRST (LISPXPRIN1 FIRST T)) (LISPXPRIN1 (QUOTE "the ") T) (LISPXPRIN1 STR T) (FILES?PRINTLST LST) (LISPXTERPRI T) T))))
)

(FILES?PRINTLST
(LAMBDA (LST STR) (* bvm%: "27-Oct-86 18:15") (* ;; "Print elements of LST separated by commas and indenting new lines a bunch.  If MAPRINT had a left margin arg, this would be simpler.") (MAPRINT LST T (OR STR ": ") NIL ", " (FUNCTION (LAMBDA (STR) (COND ((> (+ (POSITION T) (NCHARS STR T T) 3) (LINELENGTH NIL T)) (LISPXTERPRI T) (LISPXPRIN1 "         " T))) (LISPXPRIN2 STR T T))) T))
)

(ADDTOFILES?
  [LAMBDA (NOASKSTR)                                     (* ; "Edited 21-Aug-91 10:13 by jds")

    (* ;; "ask user about all of the things that need to be dumped, and distribute them to the files that he says")

    (ERSETQ
     (PROG [BUFS (VARSCHANGES (fetch (FILEPKGTYPE CHANGED) of 'VARS]

      (* ;; "Save VARS list at the beginning, so that changes that might occur from adding things to files (e.g.  changing NILCOMS) will not be processed differently depending on the order of elements in FILEPKGTYPES")

           [COND
              (NOASKSTR (PRIN1 NOASKSTR T))
              (T (DOBE)
                 (SETQ BUFS (READP T))
                 (SELECTQ (ASKUSER DWIMWAIT 'N '("want to say where the above go")
                                 '((Y "es
")
                                   (N "o
")
                                   (%] "Nowhere
" EXPLAINSTRING "] - nowhere, all items will be marked as dummy
" NOECHOFLG T))
                                 T)
                     (N (RETURN))
                     (%] (for TYPE in FILEPKGTYPES
                            do (for NAME in (fetch (FILEPKGTYPE CHANGED)
                                                           of TYPE)
                                      do (ADDTOFILE NAME TYPE NIL)))
                         (RETURN))
                     NIL)                                    (* ; 
                              "if there was type-ahead BEFORE the askuser, then don't allow it now")
                 (COND
                    (BUFS (SETQ BUFS (COND
                                        ((READP T)
                                         (LINBUF)
                                         (SYSBUF)
                                         (SETQ BUFS (CLBUFS NIL T READBUF]
           [for TYPE STR LST in FILEPKGTYPES
              when [AND (SETQ STR (fetch DESCRIPTION of TYPE))
                            (LISTP (SETQ LST (COND
                                                ((EQ TYPE 'VARS)
                                                 VARSCHANGES)
                                                (T (fetch (FILEPKGTYPE CHANGED) of TYPE]
              do
              (printout T "(" STR ")" T)
              (for NAME TEM FILE in LST when NAME
                 do
                 (PROG NIL
                   LP  (PRIN2 NAME T)
                       (SPACES 2 T)

                  (* ;; "if user typed ahead before entering addtofiles??  then dont allow typeahead here, because it will justgobble his earlier typeahead.")

                       (SELECTQ (SETQ TEM (ASKUSER NIL NIL NIL ADDTOFILEKEYLST T))
                           (%[ (ERSETQ (PROGN (SHOWDEF NAME TYPE T)

                                 (* ;; "the DOBE is so that if the user control-E's after the printout is done but before it appears on the screen that the control-E will merely clear output buffer")

                                              (DOBE)))
                               (GO LP))
                           (%] (SETQ FILE))
                           (%                                (* ; "space.  means no action")
                               (RETURN))
                           (%
 (PRINT (OR (SETQ FILE LASTFILE)
                                          'Nowhere)
                                      T))
                           (SETQ FILE TEM))
                       (OR (ERSETQ (PROG (TEM COMSNAME PLACE LISTNAME NEAR)
                                         (SETQ PLACE (WHATIS FILE NIL TYPE))
                                         [COND
                                            ((LITATOM PLACE) (* ; "file name")
                                             (SETQ FILE PLACE)
                                             (OR (ADDTOCOMS (SETQ COMSNAME (FILECOMS FILE))
                                                        NAME TYPE NEAR LISTNAME)
                                                 (ADDNEWCOM COMSNAME NAME TYPE NIL FILE))
                                             (for F in (fetch WHENFILED of TYPE)
                                                do (APPLY* F NAME TYPE FILE))

                                          (* ;; "This isn't factored to the end, cause ADDTOLISTNAME might have to deal with a set of old elements on the listname.")

                                             )
                                            ((EQ (CAR PLACE)
                                                 'Near%:)
                                             (SETQ NEAR (CADR PLACE))
                                             (COND
                                                ([SOME FILELST (FUNCTION (LAMBDA (FL)
                                                                           (ADDTOCOMS
                                                                            (FILECOMS (SETQ FILE
                                                                                           FL))
                                                                            NAME TYPE NEAR LISTNAME]
                                                 (PRINT (LIST 'on FILE)
                                                        T T))
                                                (T (PRINT (LIST (CADR PLACE)
                                                                'not
                                                                'found)
                                                          T T)
                                                   (ERROR!)))
                                             (for F in (fetch WHENFILED of TYPE)
                                                do (APPLY* F NAME TYPE FILE)))
                                            ([OR [UNDONLSETQ (PROGN (SAVESET
                                                                     (SETQ LISTNAME (CAR PLACE))
                                                                     (MERGEINSERT
                                                                      NAME
                                                                      (LISTP (GETTOPVAL LISTNAME))
                                                                      T)
                                                                     T
                                                                     'NOPRINT)
                                                                    (OR (SETQ FILE
                                                                         (CAR (WHEREIS NAME TYPE
                                                                                     FILELST)))
                                                                        (ERROR!]
                                                 (SOME FILELST (FUNCTION (LAMBDA (X)
                                                                           (ADDTOCOMS
                                                                            (FILECOMS (SETQ FILE
                                                                                           X))
                                                                            NAME TYPE NEAR LISTNAME]
                                             (PRIN1 "  value is filed on " T)
                                             (PRINT FILE T T)
                                             (for F in (fetch WHENFILED of TYPE)
                                                do (APPLY* F NAME TYPE FILE))

                                 (* ;; "Only have to notice the single new item here, unlike the case in ADDNEWCOM below, cause other items on the list already belong and were previously noticed")

                                             )
                                            (T (PRIN1 "    put list " T)
                                               (PRIN2 (CAR PLACE)
                                                      T T)
                                               (SETQ FILE
                                                (WHATIS (ASKUSER NIL NIL " on file: "
                                                                   '(("" "" EXPLAINSTRING 
                                                                         "a file name" KEYLST ()))
                                                                   T)
                                                       'FILE))
                                               (SAVESET (CAR PLACE)
                                                      (MERGEINSERT NAME
                                                             (LISTP (GETTOPVAL (CAR PLACE)))
                                                             T)
                                                      T
                                                      'NOPRINT)

                                     (* ;; "Add new item before new command, so that user's new command function can inspect (CAR PLACE) and see all the items involved.")

                                               (ADDNEWCOM (FILECOMS FILE)
                                                      NAME TYPE (CAR PLACE)
                                                      FILE)
                                               (for F in (fetch WHENFILED of TYPE)
                                                  do (for I in (GETTOPVAL (CAR PLACE))
                                                            do (APPLY* F I TYPE FILE]
                                         (AND FILE (ADDFILE FILE))
                                         (SETQ LASTFILE PLACE)))
                           (GO LP]
           (AND BUFS (BKBUFS BUFS))
           (UPDATEFILES])

(ADDTOFILE
(LAMBDA (NAME TYPE FILE NEAR LISTNAME) (* lmm "21-Nov-84 11:43") (* ; "adds NAME to the file FILE") (PROG (TEM COMSNAME) (SETQ TYPE (OR (GETFILEPKGTYPE TYPE NIL T) (COND ((FMEMB TYPE FILELST) (GETFILEPKGTYPE (swap TYPE FILE))) (T (GETFILEPKGTYPE TYPE))))) (SETQ FILE (WHATIS FILE (QUOTE FILE))) (OR (ADDTOCOMS (SETQ COMSNAME (FILECOMS FILE)) NAME TYPE NEAR LISTNAME) (ADDNEWCOM COMSNAME NAME TYPE NIL FILE)) (for F in (fetch WHENFILED of TYPE) do (APPLY* F NAME TYPE FILE)) (AND FILE (NOT (FMEMB FILE FILELST)) (ADDFILE FILE)) (RETURN FILE)))
)

(WHATIS
(LAMBDA (USERINPUT ONLY) (* lmm "28-Nov-84 16:49") (* ;; "decides whether USERINPUT is a file or a list name --- if ONLY is nil, means either a listname or a filename is accepatble;  if ONLY is LIST then only a listname is acceptable and if ONLY is FILE then only a file name is acceptable") (PROG (TEM UCASE) (RETURN (COND ((NULL USERINPUT) (* ; "nowhere") NIL) ((LISTP USERINPUT) (COND (ONLY (ERROR!)) (T (SELECTQ (CAR USERINPUT) ((@ Near%:) (CONS (QUOTE Near%:) (CDR USERINPUT))) (WHATIS (CAR USERINPUT) (QUOTE LIST)))))) ((AND (NEQ ONLY (QUOTE LIST)) (OR (FMEMB (SETQ TEM (SETQ UCASE (U-CASE USERINPUT))) FILELST) (LISTP (GETTOPVAL (FILECOMS UCASE))) (SETQ TEM (FIXSPELL UCASE NIL FILELST T)))) TEM) ((AND (NEQ ONLY (QUOTE FILE)) (LISTP (GETTOPVAL USERINPUT))) (LIST USERINPUT)) ((AND (NEQ ONLY (QUOTE LIST)) (EQ (ASKUSER NIL NIL (LIST "create new file" UCASE) NIL T) (QUOTE Y))) UCASE) ((AND (NEQ ONLY (QUOTE FILE)) (EQ (ASKUSER NIL NIL (LIST "create new list" USERINPUT) NIL T) (QUOTE Y))) (LIST USERINPUT)) (T (* ; "none of above") (ERROR!))))))
)

(ADDTOCOMS
(LAMBDA (COMS NAME TYPE NEAR LISTNAME) (* rmk%: "10-JUN-82 22:53") (* ;; "try to insert NAME of type TYPE command list COMS (either a coms name, or a just a list of coms);  return NIL if unsuccessful.  If LISTNAME is given, then only insert by adding to LISTNAME.  If NEAR is given, only insert near it") (COND ((NULL COMS) NIL) ((LITATOM COMS) (* ; "given a name of a command;  rebind COMSNAME to current variable and try to add to its value") (OR (PROG ((COMSNAME COMS)) (RETURN (ADDTOCOMS (LISTP (GETTOPVAL COMSNAME)) NAME TYPE NEAR (AND (NEQ COMS LISTNAME) LISTNAME)))) (AND (EQ COMS LISTNAME) (ADDNEWCOM COMS NAME TYPE)))) (T (SETQ TYPE (GETFILEPKGTYPE TYPE)) (for TAIL on COMS do (COND ((LISTP (CAR TAIL)) (COND ((ADDTOCOM (CAR TAIL) NAME TYPE NEAR LISTNAME) (RETURN T)))) (T (SELECTQ (CAR TAIL) ((EVAL@LOADWHEN EVAL@COMPILEWHEN COPYWHEN) (SETQ TAIL (CDR TAIL))) NIL)))))))
)

(ADDTOCOM
(LAMBDA (COM NAME TYPE NEAR LISTNAME) (* ; "Edited  2-May-87 19:04 by Pavel") (* ; "tries to insert NAME into the prettycom COM;  returns NIL if unsuccessful") (PROG (TEM) (COND ((AND NEAR (NOT (INFILECOMS? NEAR TYPE (LIST COM)))) (RETURN))) (COND ((SETQ TEM (fetch ADD of (CAR COM))) (RETURN (COND ((OR (NULL LISTNAME) (INFILECOMS? LISTNAME (QUOTE FILEVARS) (LIST COM))) (AND (SETQ TEM (APPLY* TEM COM NAME TYPE NEAR)) (MARKASCHANGED COMSNAME (QUOTE VARS))) TEM))))) (RETURN (SELECTQ (CAR COM) (FNS (AND (EQ TYPE (QUOTE FNS)) (ADDTOCOM1 COM NAME NEAR LISTNAME))) ((VARS INITVARS) (COND ((OR (EQ (CAR COM) (QUOTE VARS)) NEAR LISTNAME) (* ; "Don't stick on INITVARS unless NEAR or LISTNAME says we should.") (SELECTQ TYPE (EXPRESSIONS (COND ((EQ (CAR NAME) (QUOTE SETQ)) (ADDTOCOM1 COM (CDR NAME) NEAR LISTNAME)))) (VARS (ADDTOCOM1 COM NAME NEAR LISTNAME)) NIL)))) (COMS (ADDTOCOMS (COND ((EQ (CADR COM) (QUOTE *)) (COND ((LITATOM (CADDR COM)) (CADDR COM)) (T (RETURN)))) (T (CDR COM))) NAME TYPE NEAR LISTNAME)) (DECLARE%: (AND (OR LISTNAME NEAR) (ADDTOCOMS (COND ((EQ (CADR COM) (QUOTE *)) (COND ((LITATOM (CADDR COM)) (CADDR COM)) (T (RETURN)))) (T (CDR COM))) NAME TYPE NEAR LISTNAME))) (CL:EVAL-WHEN (AND (OR LISTNAME NEAR) (ADDTOCOMS (COND ((EQ (CL:THIRD COM) (QUOTE *)) (COND ((LITATOM (CL:FOURTH COM)) (CL:FOURTH COM)) (T (RETURN)))) (T (CDDR COM))) NAME TYPE NEAR LISTNAME))) ((PROP IFPROP) (SELECTQ TYPE (PROPS (COND ((EQ (CADR COM) (CADR NAME)) (ADDTOCOM1 (CDR COM) (CAR NAME) NEAR LISTNAME)) ((AND (EQ (CAR NAME) (CADDR COM)) (NULL (CDDDR COM))) (/RPLACA (CDR COM) (UNION (MKLIST (CDR NAME)) (MKLIST (CADR COM)))) (MARKASCHANGED COMSNAME (QUOTE VARS)) T))) (MACROS (COND ((AND (for PROP inside (CADR COM) always (EQMEMB PROP MACROPROPS)) (for PROP in MACROPROPS always (OR (EQMEMB PROP (CADR COM)) (NOT (GETPROP NAME PROP))))) (* ;; "every property in the command is a macro prop and, either this is an IFPROP or else the MACROS are changed") (ADDTOCOM1 (CDR COM) NAME NEAR LISTNAME)))) NIL)) ((PROPS ALISTS) (AND (EQ TYPE (CAR COM)) (ADDTOCOM1 COM (/NCONC1 (OR (ASSOC (CAR NAME) (COND ((EQ (CADR COM) (QUOTE *)) (COND ((LITATOM (CADDR COM)) (AND (OR (NULL LISTNAME) (EQ (CADDR COM) LISTNAME)) (GETTOPVAL (CADDR COM)))) (T (RETURN)))) (T (CDR COM)))) (LIST (CAR NAME))) (CADR NAME)) NEAR LISTNAME))) (P (COND ((AND (EQ TYPE (QUOTE EXPRESSIONS)) (NEQ (CAR NAME) (QUOTE SETQ))) (ADDTOCOM1 COM NAME NEAR LISTNAME)))) (AND (EQ (CAR COM) TYPE) (ADDTOCOM1 COM NAME NEAR LISTNAME))))))
)

(ADDTOCOM1
(LAMBDA (COM NAME NEAR LISTNAME) (* rmk%: " 3-JAN-82 22:53") (COND ((EQ (CADR COM) (QUOTE *)) (* ; "add to list name") (AND (COND (LISTNAME (EQ (CADDR COM) LISTNAME)) (T (LITATOM (CADDR COM)))) (SAVESET (CADDR COM) (PROGN (SETQ COM (LISTP (GETTOPVAL (CADDR COM)))) (COND ((AND NEAR (SETQ NEAR (MEMBER NEAR COM))) (/RPLACD NEAR (CONS NAME (CDR NEAR))) COM) (T (MERGEINSERT NAME COM T)))) T (QUOTE NOPRINT)))) ((NULL LISTNAME) (* ; "add to standard com") (AND (NOT (MEMBER NAME (CDR COM))) (COND ((SETQ NEAR (MEMBER NEAR COM)) (/RPLACD NEAR (CONS NAME (CDR NEAR)))) (T (/RPLACD COM (MERGEINSERT NAME (CDR COM)))))) (MARKASCHANGED COMSNAME (QUOTE VARS)) T)))
)

(ADDNEWCOM
(LAMBDA (COMSNAME NAME TYPE LISTNAME FILE) (* rmk%: " 3-JAN-82 22:53") (* ;; "Adds to COMSNAME a new command that will dump NAME as a TYPE on FILE.  --- if LISTNAME is given, then use it as the listname") (PROG (NEWCOM OLDCOM TAIL) (SETQ NEWCOM (MAKENEWCOM NAME TYPE LISTNAME FILE)) (COND ((NLISTP (SETQ TAIL (GETTOPVAL COMSNAME))) (RETURN (SAVESET COMSNAME (LIST NEWCOM) T (QUOTE NOPRINT))))) LP (COND ((OR (NLISTP (SETQ OLDCOM (CAR TAIL))) (SELECTQ (CAR OLDCOM) ((LOCALVARS SPECVARS BLOCKS) T) (DECLARE%: (FMEMB (QUOTE COMPILERVARS) (CDR OLDCOM))) NIL)) (/ATTACH NEWCOM TAIL)) ((LISTP (CDR TAIL)) (SETQ TAIL (CDR TAIL)) (GO LP)) (T (/RPLACD TAIL (LIST NEWCOM)))) (MARKASCHANGED COMSNAME (QUOTE VARS))))
)

(MAKENEWCOM
(LAMBDA (NAME TYPE LISTNAME FILE) (* ; "Edited  8-Apr-87 14:55 by Pavel") (SETQ TYPE (GETFILEPKGTYPE TYPE)) (PROG (TEM) (* ;; "the user function MUST (a) check if FILE = T and not do anything destructive (since this is only for showdef) and (b) if LISTNAME is given, then use it rather than generating a different listname") (AND (LISTP NAME) (SETQ NAME (COPY NAME))) (RETURN (OR (AND (SETQ TEM (fetch NEWCOM of TYPE)) (APPLY* TEM NAME TYPE LISTNAME FILE)) (SELECTQ TYPE (PROPS (AND (NULL LISTNAME) (CONS (QUOTE PROP) (CONS (COND ((AND (LISTP (CDR NAME)) (NULL (CDDR NAME))) (CADR NAME)) (T (CDR NAME))) (OR (LISTP (CAR NAME)) (LIST (CAR NAME))))))) (EXPRESSIONS (COND ((EQ (CAR NAME) (QUOTE SETQ)) (MAKENEWCOM (CDR NAME) (QUOTE VARS) LISTNAME FILE)) (T (CONS (QUOTE P) (COND (LISTNAME (LIST (QUOTE *) LISTNAME)) (T (LIST NAME))))))) NIL) (DEFAULTMAKENEWCOM NAME TYPE LISTNAME FILE)))))
)

(DEFAULTMAKENEWCOM
(LAMBDA (NAME TYPE LISTNAME FILE) (* lmm "20-OCT-82 22:48") (COND ((NOT (OR (FMEMB TYPE FILEPKGCOMSPLST) (fetch MACRO of TYPE) (fetch GETDEF of TYPE))) (ERROR "no defined way to dump or obtain the definition of " (OR (fetch DESCRIPTION of TYPE) TYPE) T)) ((NULL DEFAULTCOMHASFILEFLG) (* ; "disable FOOFNS FOOVARS junk") (LIST TYPE NAME)) ((EQ FILE T) (* ; "FILE=T only when called from SHOWDEF") (LIST TYPE NAME)) ((OR LISTNAME (AND FILE (SAVESET (SETQ LISTNAME (FILECOMS FILE TYPE)) (MERGEINSERT NAME (LISTP (GETTOPVAL LISTNAME)) T) T (QUOTE NOPRINT)))) (* ; "The check (AND FILE --) is so that it will not bother with making listnames just for deleting items") (LIST TYPE (QUOTE *) LISTNAME)) (T (LIST TYPE NAME))))
)
)

(RPAQ? DEFAULTCOMHASFILEFLG )

(ADDTOVAR MARKASCHANGEDFNS )
(DEFINEQ

(MERGEINSERT
(LAMBDA (NEW LST ONEFLG) (* lmm "30-Jun-86 18:11") (* ;; "searches LST to find the most reasonable place to insert NEW.  Does nothing if ONEFLG is T and NEW is already a member of LST") (COND ((AND ONEFLG (MEMBER NEW LST)) LST) ((LISTP NEW) (/NCONC1 LST NEW)) (T (PROG ((N 0) LST1 PLACE TEM) (SETQ LST1 LST) LP (* ;; "finds the function with the longest leading common substring.  The idea is that if the list is only paatially sorted, want to insert the new thing in among those function that look like they are related.") (COND ((NULL LST1) (GO OUT)) ((OR (LISTP (CAR LST1)) (SETQ TEM (STRPOS (CAR LST1) NEW 1 NIL T T))) (* ;; "this takes precedence over even a longer string so that for example in the list (ADDTOFILES? ADDTOFILE), ADDTOFILE1 will be inserted aater ADDTOFILE") (SETQ PLACE LST1) (GO OUT)) ((IGREATERP (SETQ TEM (MERGEINSERT1 (CAR LST1) NEW)) N) (SETQ N TEM) (SETQ PLACE LST1))) (SETQ LST1 (CDR LST1)) (GO LP) OUT (SETQ TEM (CAR PLACE)) (OR (SOME (OR PLACE LST) (FUNCTION (LAMBDA (X LST) (COND ((OR (ALPHORDER NEW X) (AND PLACE (NOT (ALPHORDER TEM X)))) (* ;; "for example, if the FNS list is something like (...  FOO FOO1 ...) where the ...  may or may not be in order, e.g.  (ZAP FOO FOO1 BLAH), then want to insert FOO2 after FOO1, i.e. before BLAH, even though FOO2 wold not come before BLAH in a sorted list.") (/ATTACH NEW LST)) (T (SETQ TEM X) NIL))))) (SETQ LST (/NCONC1 LST NEW))) (RETURN LST)))))
)

(MERGEINSERT1
(LAMBDA (X Y) (* rmk%: "24-MAY-82 00:05") (* ;; "value is the number of leading characters of X and Y that agree.") (PROG ((N 1) C1 C2) LP (COND ((OR (NULL (SETQ C1 (NTHCHARCODE X N))) (NULL (SETQ C2 (NTHCHARCODE Y N))) (NEQ C1 C2)) (RETURN (SUB1 N)))) (SETQ N (ADD1 N)) (GO LP)))
)
)

(RPAQ? ADDTOFILEKEYLST
       `((%[ "" EXPLAINSTRING "[ -- prettyprint the item to terminal and then ask again" NOECHOFLG T)
         ((MKSTRING (CHARACTER (CHARCODE "^J")))
          "" EXPLAINSTRING "{line-feed} - same as previous response" NOECHOFLG T)
         (%  " 
" EXPLAINSTRING "{space} - no action" NOECHOFLG T)
         (%] "Nowhere
" EXPLAINSTRING "] - nowhere, item is marked as a dummy
" NOECHOFLG T)
         [%( "List:  (" EXPLAINSTRING "(list name)" NOECHOFLG T KEYLST (( "" CONFIRMFLG
                                                                           (%) %] %  %
)
                                                                           RETURN
                                                                           (CDR ANSWER]
         (@ "Near: " EXPLAINSTRING "@ other-item   -- put the item near the other item" NOECHOFLG T 
                  KEYLST (( "" CONFIRMFLG (%
)
                             RETURN ANSWER)))
         (%
 "" RETURN '% )
         ("" "File name: " EXPLAINSTRING "a file name" KEYLST ())))

(RPAQ? LASTFILE )



(* ;; "deleting an item from a file")

(DEFINEQ

(DELFROMFILES
(LAMBDA (NAME TYPE FILES) (* rmk%: " 6-MAR-82 13:16") (* ;; "Eliminates NAME as an item of type TYPE in COMS.") (PROG (COMS) (SETQ TYPE (GETFILEPKGTYPE TYPE)) (RETURN (for FILE inside (OR FILES FILELST) when (PROG1 (DELFROMCOMS (SETQ COMS (FILECOMS FILE)) NAME TYPE) (COND ((INFILECOMS? NAME TYPE COMS) (printout T "(could not delete " NAME " from " FILE ")" T)))) collect (for FN in (fetch WHENUNFILED of TYPE) do (APPLY* FN NAME TYPE FILE)) FILE))))
)

(DELFROMCOMS
(LAMBDA (COMS NAME TYPE) (* bvm%: " 1-Oct-86 22:02") (* ;; "delete NAME of type TYPE from the coms COMS (either the name of some coms or a list).  Returns T if it does anything") (* ;; "If COMS is not a symbol, caller is required to bind COMSNAME to the symbol whose value we are deleting from, for benefit of marking it changed.") (COND ((LITATOM COMS) (LET ((COMSNAME COMS)) (DECLARE (SPECVARS COMS)) (AND (LISTP (SETQ COMS (GETTOPVAL COMSNAME))) (DELFROMCOMS COMS NAME TYPE)))) (T (PROG (DONE) (SETQ TYPE (GETFILEPKGTYPE TYPE)) LP (COND ((NLISTP COMS) (RETURN DONE))) (COND ((LISTP (CAR COMS)) (SELECTQ (DELFROMCOM (CAR COMS) NAME TYPE) (ALL (/RPLNODE2 COMS (CDR COMS)) (SETQQ DONE ALL) (GO LP)) (NIL) (SETQ DONE T))) (T (SELECTQ (CAR COMS) ((EVAL@LOADWHEN EVAL@COMPILEWHEN COPYWHEN) (SETQ COMS (CDR COMS))) (COND ((AND (EQ TYPE (QUOTE VARS)) (EQ NAME (CAR COMS))) (/RPLNODE2 COMS (CDR COMS)) (SETQ DONE T) (GO LP)))))) (SETQ COMS (CDR COMS)) (GO LP)))))
)

(DELFROMCOM
(LAMBDA (COM NAME TYPE) (* ; "Edited  2-May-87 19:02 by Pavel") (* ; "Tries to delete NAME from COM") (PROG (TEM VAR NEW) (COND ((SETQ TEM (fetch DELETE of (CAR COM))) (AND (SETQ TEM (APPLY* TEM COM NAME TYPE)) (MARKASCHANGED COMSNAME (QUOTE VARS))) (RETURN TEM))) (RETURN (SELECTQ (CAR COM) ((DECLARE%: COMS) (DELFROMCOMS (COND ((EQ (CADR COM) (QUOTE *)) (COND ((LITATOM (CADDR COM)) (CADDR COM)) (T (RETURN)))) (T (CDR COM))) NAME TYPE)) ((CL:EVAL-WHEN) (DELFROMCOMS (COND ((EQ (CL:THIRD COM) (QUOTE *)) (COND ((LITATOM (CL:FOURTH COM)) (CL:FOURTH COM)) (T (RETURN)))) (T (CDDR COM))) NAME TYPE)) ((ALISTS PROPS) (AND (EQ TYPE (CAR COM)) (COND ((EQ (CADR COM) (QUOTE *)) (COND ((AND (LITATOM (SETQ VAR (CADDR COM))) (SETQ TEM (ASSOC (CAR NAME) (GETTOPVAL VAR))) (NEQ (CDR TEM) (SETQ TEM (REMOVEITEM (CADR NAME) (CDR TEM))))) (SAVESET VAR TEM T (QUOTE NOPRINT)) T))) ((AND (CDR (SETQ TEM (ASSOC (CAR NAME) (CDR COM)))) (NEQ (CDR TEM) (SETQ NEW (REMOVEITEM (CADR NAME) (CDR TEM))))) (/RPLACD TEM NEW) (MARKASCHANGED COMSNAME (QUOTE VARS)) T)))) (BLOCKS (* ;; "Remove function name from blocks declarations.  This isn't entirely correctly, since in removing the name from the block variables, it will hit homonyms in globalvars, specvars, etc.") (AND (EQ TYPE (QUOTE FNS)) (for BLOCK in (INFILECOMTAIL COM T) do (AND (MEMB NAME BLOCK) (/DREMOVE NAME BLOCK)) (for X in BLOCK when (AND (LISTP X) (MEMB NAME (CDR X))) do (/RPLACD X (REMOVE NAME (CDR X))))))) ((PROP IFPROP) (SELECTQ TYPE (PROPS (RETURN (COND ((EQ (CADR COM) (CADR NAME)) (DELFROMCOM1 (CDR COM) (CAR NAME))) ((AND (EQMEMB (CADR NAME) (CADR COM)) (NULL (CDR (SETQ TEM (PRETTYCOM1 (CDR COM))))) (EQ (CAR TEM) (CAR NAME))) (/RPLACA (CDR COM) (REMOVE (CADR NAME) (MKLIST (CADR COM)))) (MARKASCHANGED COMSNAME (QUOTE VARS)) T)))) (COND ((for PROP inside (CADR COM) always (EQ TYPE (GETPROP PROP (QUOTE PROPTYPE)))) (DELFROMCOM1 (CDR COM) NAME))))) ((RECORDS INITRECORDS SYSRECORDS) (AND (EQ TYPE (QUOTE RECORDS)) (DELFROMCOM1 COM NAME))) (P (AND (EQ TYPE (QUOTE EXPRESSIONS)) (DELFROMCOM1 COM NAME))) ((VARS INITVARS) (AND (EQ TYPE (QUOTE VARS)) (DELFROMCOM1 COM NAME T))) (AND (EQ TYPE (CAR COM)) (DELFROMCOM1 COM NAME))))))
)

(DELFROMCOM1
(LAMBDA (COM NAME FLG) (* rmk%: "10-JUN-82 22:44") (* ;; "FLG is passed on to REMOVEITEM, determines whether lists whose CAR is NAME will be removed") (LET (TEM VAL) (COND ((EQ (CADR COM) (QUOTE *)) (COND ((AND (LITATOM (SETQ TEM (CADDR COM))) (NEQ (SETQ VAL (GETTOPVAL TEM)) (SETQ VAL (REMOVEITEM NAME VAL FLG)))) (SAVESET TEM VAL T (QUOTE NOPRINT)) T))) ((NEQ (CDR COM) (SETQ TEM (REMOVEITEM NAME (CDR COM) FLG))) (/RPLACD COM TEM) (MARKASCHANGED COMSNAME (QUOTE VARS)) T))))
)

(REMOVEITEM
(LAMBDA (X LST FLG) (* ; "Edited 25-May-88 17:52 by drc:") (* lmm "10-FEB-78 17:29") (* ;; "returns a subset of LST with X deleted;  if FLG is set, also remove elements whose CAR is X") (COND ((OR (MEMBER X LST) (AND FLG (SOME LST (FUNCTION (LAMBDA (Y) (EQUAL (CAR (LISTP Y)) X)))))) (SUBSET LST (FUNCTION (LAMBDA (Y) (AND (NOT (EQUAL Y X)) (OR (NOT FLG) (NLISTP Y) (NOT (EQUAL (CAR Y) X)))))))) (T LST)))
)

(MOVETOFILE
(LAMBDA (TOFILE NAME TYPE FROMFILE) (* rmk%: "18-OCT-79 19:51") (* ; "To move items between files") (SETQ TYPE (GETFILEPKGTYPE TYPE)) (COND ((OR (EQ TYPE (QUOTE FNS)) FROMFILE) (* ; "FNS definition can reside on file if LOADFNS was done.  This guarantees that it is loaded.") (PUTDEF NAME TYPE (GETDEF NAME TYPE FROMFILE (QUOTE (NOCOPY NODWIM)))))) (AND (EQ TYPE (QUOTE FNS)) (MARKASCHANGED NAME TYPE)) (* ; "FNS won't get dumped unless they are `changed'") (DELFROMFILES NAME TYPE FROMFILE) (ADDTOFILE NAME TYPE TOFILE))
)
)

(MOVD? 'DELFROMFILES 'DELFROMFILE NIL T)

(MOVD? 'MOVETOFILE 'MOVEITEM NIL T)

(ADDTOVAR SYSPROPS PROPTYPE VARTYPE)



(* ; "functions for doing things and marking them changed and auxiliary functions")

(DEFINEQ

(SAVEPUT
(LAMBDA (ATM PROP VAL) (* lmm " 7-May-84 16:56") (* ;; "analogous to SAVESET but also marks changed property lists;  LISPXFNS are marked to change PUT and PUTPROP to SAVEPUT") (COND ((NOT (LITATOM ATM)) (ERRORX (LIST 14 ATM)))) (PROG ((X (GETPROPLIST ATM)) X0 TEM OLDFLG) LOOP (COND ((NLISTP X) (COND ((AND (NULL X) X0) (* ; "typical case.  property list ran out on an even parity position.  e.g.  (A B C D)") (SETQ TEM (LIST PROP VAL)) (AND LISPXHIST (UNDOSAVE (LIST (QUOTE /PUT-1) ATM TEM) LISPXHIST)) (FRPLACD (CDR X0) TEM) (GO RET))) (* ;; "property list was initially NIL or a non-list, or else it ended in a non-list following an even parity position, e.g. (A B . C) fall through and add new property at beginning")) ((NLISTP (CDR X)) (* ;; "property list runs out on an odd parity, or ends in an odd list following an odd parity, e.g.  (A B C) or (A B C . D) fall through and add at beginning.")) ((EQ (CAR X) PROP) (SETQ OLDFLG (NEQ (EQUALN (CADR X) VAL 400) T)) (* ; "i.e. it probably changed") (/RPLACA (CDR X) VAL) (COND ((NOT OLDFLG) (GO RET1)) (T (OR (EQ DFNFLG T) (LISPXPRINT (LIST (QUOTE new) PROP (QUOTE property) (QUOTE for) ATM) T T)) (GO RET)))) (T (SETQ X (CDDR (SETQ X0 X))) (GO LOOP))) (SETQ TEM (CONS PROP (CONS VAL (GETPROPLIST ATM)))) (SETPROPLIST ATM TEM) (AND LISPXHIST (UNDOSAVE (LIST (QUOTE /PUT-1) ATM TEM) LISPXHIST)) RET (MARKASCHANGED (LIST ATM PROP) (QUOTE PROPS) (NOT OLDFLG)) RET1 (AND ADDSPELLFLG (ADDSPELL ATM 0)) (RETURN VAL)))
)
)
(DECLARE%: DONTEVAL@LOAD DOCOPY 

(OR (CHANGENAME 'PUTPROPS 'PUTPROP 'SAVEPUT)
    (CHANGENAME 'PUTPROPS '/PUT 'SAVEPUT))
)
(DEFINEQ

(UNMARKASCHANGED
(LAMBDA (NAME TYPE) (* JonL "24-Jul-84 19:59") (* ;; "says to remove NAME from TYPE's changedlst, and also to remove it from any FILE properties.  Value is name if anything is done") (PROG (ANYFLG) (bind TAIL (CHANGED _ (fetch CHANGED of (SETQ TYPE (GETFILEPKGTYPE TYPE (QUOTE TYPE))))) while (SETQ TAIL (MEMBER NAME CHANGED)) do (/RPLACA TAIL) (SETQ ANYFLG T)) (for F TAIL PROP TYPEDPROP in FILELST when (SETQ TAIL (MEMBER NAME (CDR (SETQ TYPEDPROP (ASSOC TYPE (fetch TOBEDUMPED of (SETQ PROP (fetch FILEPROP of F)))))))) do (SETQ ANYFLG T) (COND ((SETQ TAIL (REMOVE (CAR TAIL) (CDR TYPEDPROP))) (/RPLACD TYPEDPROP TAIL)) (T (/replace TOBEDUMPED of PROP with (REMOVE TYPEDPROP (fetch TOBEDUMPED of PROP)))))) (RETURN (AND ANYFLG NAME))))
)

(PREEDITFN
(LAMBDA (ATM TYPE EDITCHANGES) (* rmk%: "18-FEB-82 21:49") (* ; "EDITL is advised to call this before editing something") (AND FILEPKGFLG (SELECTQ TYPE (PROPLST (AND (OR CLISPARRAY (PROGN (CLISPTRAN (CONS) (CONS)) CLISPARRAY)) (for X in (GETPROPLIST ATM) do (OR (NLISTP X) (GETHASH X CLISPARRAY) (PUTHASH X (CONS (CAR X) (CDR X)) CLISPARRAY)))) (* ;; "note that if CLISPARRAY is disabled that ALL properties of an edited prop list will get marked as changed if any destructive edit is made") (RESETSAVE NIL (LIST (FUNCTION POSTEDITPROPS) EDITCHANGES (APPEND (GETPROPLIST ATM))))) (VARS (COND ((EQMEMB (QUOTE ALIST) (GETPROP ATM (QUOTE VARTYPE))) (AND (OR CLISPARRAY (PROGN (CLISPTRAN (CONS) (CONS)) CLISPARRAY)) (for X in (EVALV ATM) do (OR (NLISTP X) (GETHASH X CLISPARRAY) (PUTHASH X (CONS (CAR X) (CDR X)) CLISPARRAY)))) (RESETSAVE NIL (LIST (FUNCTION POSTEDITALISTS) EDITCHANGES (for X in (EVALV ATM) collect (CAR X))))))) NIL)))
)

(POSTEDITPROPS
(LAMBDA (EDITCHANGES OLDPROPS) (* rmk%: "18-FEB-82 21:50") (* ; "was RESETSAVE'd from PREEDITFN") (PROG (OV FOUNDCHANGE) (OR FILEPKGFLG (RETURN)) (COND ((CADR EDITCHANGES) (for NEWPROP on (GETPROPLIST (CAR EDITCHANGES)) by (CDDR NEWPROP) when (for OLDPROP on OLDPROPS by (CDDR OLDPROP) do (COND ((EQ (CAR OLDPROP) (CAR NEWPROP)) (* ; "Found the property") (AND (EQ (CADR OLDPROP) (CADR NEWPROP)) (COND ((NLISTP (CADR OLDPROP)) (* ; "value is same") (RETURN)) ((AND CLISPARRAY (SETQ OV (GETHASH (CADR NEWPROP) CLISPARRAY)) (EQ (CAADR NEWPROP) (CAR OV)) (EQ (CDADR NEWPROP) (CDR OV))) (PUTHASH (CADR NEWPROP) NIL CLISPARRAY) (* ; "value has been edited (CLISPARRAY translation went away)") (RETURN)))) (RETURN T))) finally (* ; "didn't find the property") (RETURN T)) do (MARKASCHANGED (LIST (CAR EDITCHANGES) (CAR NEWPROP)) (QUOTE PROPS) NIL) (SETQ FOUNDCHANGE T)) (AND FOUNDCHANGE (RPLACA (CDR EDITCHANGES) NIL))))))
)

(POSTEDITALISTS
(LAMBDA (EDITCHANGES OLDTOKENS) (* rmk%: " 4-JAN-82 10:14") (PROG (OV FOUNDCHANGE (NEWENTRIES (GETTOPVAL (CAR EDITCHANGES)))) (* ; "called after an ALIST has been edited") (OR FILEPKGFLG (RETURN)) (COND ((CADR EDITCHANGES) (for X in OLDTOKENS when (NOT (FASSOC X NEWENTRIES)) do (MARKASCHANGED (LIST (CAR EDITCHANGES) X) (QUOTE ALISTS) NIL) (SETQ FOUNDCHANGE T)) (for NEWENTRY in NEWENTRIES do (COND ((AND (LISTP NEWENTRY) (NOT (AND CLISPARRAY (SETQ OV (GETHASH NEWENTRY CLISPARRAY)) (EQ (CAR NEWENTRY) (CAR OV)) (EQ (CDR NEWENTRY) (CDR OV))))) (PUTHASH NEWENTRY NIL CLISPARRAY) (MARKASCHANGED (LIST (CAR EDITCHANGES) (CAR NEWENTRY)) (QUOTE ALISTS) NIL) (SETQ FOUNDCHANGE T)))) (AND FOUNDCHANGE (RPLACA (CDR EDITCHANGES) NIL))))))
)
)

(ADDTOVAR LISPXFNS (PUT . SAVEPUT)
                       (PUTPROP . SAVEPUT))



(* ; "sub-functions for file package commands & types")

(DEFINEQ

(ALISTS.GETDEF
(LAMBDA (NAME TYPE OPTIONS) (* Pavel " 7-Oct-86 17:24") (AND (LISTP NAME) (CL:SYMBOLP (CAR NAME)) (LET ((ASSOCIATION (ASSOC (CADR NAME) (GETTOPVAL (CAR NAME))))) (AND ASSOCIATION (LIST (QUOTE ADDTOVAR) (CAR NAME) ASSOCIATION)))))
)

(ALISTS.WHENCHANGED
(LAMBDA (NAME TYPE NEWFLG) (* lmm "16-OCT-78 20:02") (* ; "called by MARKASCHANGED when an ALIST entry has changed") (PROG ((VARTYPE (GETPROP (CAR NAME) (QUOTE VARTYPE)))) (AND (LISTP VARTYPE) (EQ (CAR VARTYPE) (QUOTE ALIST)) (RETFROM (QUOTE MARKASCHANGED) (MARKASCHANGED (CADR NAME) (CADR VARTYPE) NEWFLG)))))
)

(CLEARCLISPARRAY
(LAMBDA (NAME TYPE REASON) (DECLARE (SPECVARS NAME TYPE REASON)) (* lmm "14-Aug-84 15:03") (AND CLISPARRAY (MAPHASH CLISPARRAY (COND ((EQ TYPE (QUOTE I.S.OPRS)) (FUNCTION (LAMBDA (TRAN FORM) (AND (MEMB NAME FORM) (PUTHASH FORM NIL CLISPARRAY))))) (T (* ; "MACRO changed") (FUNCTION (LAMBDA (TRAN FORM) (COND ((OR (EQ NAME (CAR FORM)) (EQ (CAR (GETPROP (CAR FORM) (QUOTE CLISPWORD))) (QUOTE CHANGETRAN))) (PUTHASH FORM NIL CLISPARRAY))))))))))
)

(EXPRESSIONS.WHENCHANGED
(LAMBDA (EXPR) (* ; "Edited  6-Apr-87 20:21 by Pavel") (SELECTQ (CAR EXPR) ((SETQ SETQQ) (UNMARKASCHANGED (CADR EXPR) (QUOTE VARS))) ((PROGN PROG) (for X in (CDR EXPR) do (EXPRESSIONS.WHENCHANGED X))) NIL))
)

(MAKEALISTCOMS
(NLAMBDA X (* rmk%: "14-OCT-83 13:34") (* ;; "make command to dump prettydefmacros") (LIST (CONS (QUOTE ADDVARS) (for PR in X join (for ALISTNAME inside (CAR PR) collect (CONS ALISTNAME (for ATNAME inside (CDR PR) bind ENTRY when (SETQ ENTRY (OR (SASSOC ATNAME (GETTOPVAL ALISTNAME)) (PROGN (LISPXPRINT (LIST (QUOTE no) ATNAME (QUOTE entry) (QUOTE on) ALISTNAME) T T) NIL))) collect ENTRY)))))))
)

(MAKEFILESCOMS
(NLAMBDA FILES (* JonL "12-FEB-83 19:02") (* ;; "This scans the command just to warn the user about any errors.  Must match up with the big SELECTQ in FILESLOAD NIL") (for FILE in FILES do (OR (LITATOM FILE) (while (LISTP FILE) do (SELECTQ (CAR (OR (LISTP FILE) (RETURN))) ((LOADCOMP LOADFROM)) (FROM (pop FILE) (if (OR (EQ (CAR FILE) (QUOTE VALUEOF)) (if (AND (EQ (CAR FILE) (QUOTE VALUE)) (EQ (CADR FILE) (QUOTE OF))) then (pop FILE))) then (pop FILE))) ((COMPILED LOAD EXTENSION EXT SOURCE SYMBOLIC IMPORT NOERROR)) (OR (FMEMB (CAR FILE) LOADOPTIONS) (PRINT (CONS (CAR FILE) (QUOTE (-- unrecognized FILES option))) T))) (pop FILE)))) (CONS (QUOTE FILESLOAD) FILES))
)

(MAKELISPXMACROSCOMS
(NLAMBDA X (* lmm " 5-SEP-78 23:15") (PROG (TEM TEM2) (RETURN (CONS (CONS (QUOTE ALISTS) (SETQ TEM (NCONC (AND (SETQ TEM (SUBSET X (FUNCTION (LAMBDA (Z) (FASSOC Z LISPXHISTORYMACROS))))) (LIST (CONS (QUOTE LISPXHISTORYMACROS) TEM))) (AND (SETQ TEM (SUBSET X (FUNCTION (LAMBDA (Z) (FASSOC Z LISPXMACROS))))) (LIST (CONS (QUOTE LISPXMACROS) TEM)))))) (SETQ TEM2 (NCONC (AND (SETQ TEM2 (SUBSET X (FUNCTION (LAMBDA (Z) (FMEMB Z LISPXCOMS))))) (LIST (LIST (QUOTE ADDVARS) (CONS (QUOTE LISPXCOMS) TEM2)))) (AND (SETQ TEM2 (SUBSET X (FUNCTION (LAMBDA (Z) (FMEMB Z HISTORYCOMS))))) (LIST (LIST (QUOTE ADDVARS) (CONS (QUOTE HISTORYCOMS) TEM2))))))))))
)

(MAKEPROPSCOMS
(NLAMBDA X (* lmm "26-FEB-78 17:10") (* ;; "make command to dump PROPS") (for PAIR in X collect (CONS (QUOTE PROP) (CONS (COND ((AND (LISTP (CDR PAIR)) (NULL (CDDR PAIR))) (CADR PAIR)) (T (CDR PAIR))) (OR (LISTP (CAR PAIR)) (LIST (CAR PAIR)))))))
)

(MAKEUSERMACROSCOMS
(NLAMBDA X (* rmk%: " 3-JAN-82 23:20") (PROG (TEM) (COND (X (for Y in X do (OR (FASSOC Y USERMACROS) (FASSOC Y EDITMACROS) (LISPXPRINT (CONS Y (QUOTE (-- no entry on USERMACROS))) T T)))) (T (SETQ X (INTERSECTION (SETQ X (MAPCAR USERMACROS (QUOTE CAR))) X)))) (RETURN (LIST (CONS (QUOTE ADDVARS) (NCONC (for VAR in (QUOTE (USERMACROS EDITMACROS)) when (SETQ TEM (for Y in (GETTOPVAL VAR) when (FMEMB (CAR Y) X) collect Y)) collect (CONS VAR TEM)) (for LST in (QUOTE (EDITCOMSA EDITCOMSL COMPACTHISTORYCOMS DONTSAVEHISTORYCOMS)) when (SETQ TEM (SUBSET (GETTOPVAL LST) (FUNCTION (LAMBDA (Y) (OR (FMEMB Y X) (AND (LISTP Y) (FMEMB (CAR Y) X))))))) collect (CONS LST TEM))))))))
)

(PROPS.WHENCHANGED
(LAMBDA (NAME TYPE NEWFLG) (* lmm " 7-SEP-78 22:08") (PROG ((PROPTYPE (GETPROP (CADR NAME) (QUOTE PROPTYPE)))) (COND (PROPTYPE (RETFROM (QUOTE MARKASCHANGED) (COND ((NEQ PROPTYPE (QUOTE IGNORE)) (MARKASCHANGED (CAR NAME) PROPTYPE NEWFLG))))) (T (SELECTQ (CADR NAME) (CLISPWORD (CLEARCLISPARRAY (CAR NAME))) NIL)))))
)

(FILEGETDEF.LISPXMACROS
(LAMBDA (NAME TYPE SOURCE OPTIONS) (* lmm " 4-Jul-85 15:12") (MKPROGN (for X in (LOADFNS NIL SOURCE (QUOTE GETDEF) (QUOTE (LAMBDA (FIRST SECOND) (AND (EQ FIRST (QUOTE ADDTOVAR)) (MEMB SECOND (QUOTE (LISPXMACROS LISPXCOMS))) T)))) when (SELECTQ (CADR X) (LISPXMACROS (* ; "Rebuild the expressions cause there might be other elements in the ADDTOVAR") (AND (SETQ X (ASSOC NAME (CDDR X))) (SETQ X (LIST (QUOTE ADDTOVAR) (QUOTE LISPXMACROS) X)))) (LISPXCOMS (COND ((MEMB NAME (CDDR X)) (SETQ X (LIST (QUOTE ADDTOVAR) (QUOTE LISPXCOMS) NAME))) ((SETQ X (ASSOC NAME (CDDR X))) (* ; "For synonym pairs") (SETQ X (LIST (QUOTE ADDTOVAR) (QUOTE LISPXCOMS) X))))) NIL) collect X)))
)

(FILEGETDEF.ALISTS
(LAMBDA (NAME TYPE SOURCE OPTIONS) (* lmm " 4-Jul-85 15:13") (for X in (LOADFNS NIL SOURCE (QUOTE GETDEF) (QUOTE (LAMBDA (FIRST SECOND) (AND (EQ FIRST (QUOTE ADDTOVAR)) (EQ SECOND (CAR NAME)))))) when (SETQ X (ASSOC (CADR NAME) (CDDR X))) collect X finally (RETURN (COND ($$VAL (CONS (QUOTE ADDTOVAR) (CONS (CAR NAME) $$VAL)))))))
)

(FILEGETDEF.RECORDS
(LAMBDA (NAME TYPE SOURCE OPTIONS NOTFOUND) (* lmm "26-Jun-86 15:56") (LET ((VAL (LOADFNS NIL SOURCE (QUOTE GETDEF) (QUOTE (LAMBDA (FIRST SECOND) (AND (MEMB FIRST CLISPRECORDTYPES) (OR (EQ SECOND NAME) (AND (MEMB SECOND (QUOTE (%( %[))) (PROGN (RATOM) (RATOM) (RATOM) (EQ NAME (RATOM))))))))))) (if (EQ (CAAR VAL) (QUOTE NOT-FOUND%:)) then NOTFOUND elseif (CDR VAL) then (CONS (QUOTE PROGN) VAL) else (CAR VAL))))
)

(FILEGETDEF.PROPS
(LAMBDA (NAME TYPE SOURCE OPTIONS) (* lmm " 4-Jul-85 15:13") (for X in (LOADFNS NIL SOURCE (QUOTE GETDEF) (QUOTE (LAMBDA (FIRST SECOND) (AND (EQ FIRST (QUOTE PUTPROPS)) (EQ SECOND (CAR NAME)))))) join (for TAIL on (CDDR X) by (CDDR TAIL) when (EQ (CAR TAIL) (CADR NAME)) join (LIST (CAR TAIL) (CADR TAIL))) finally (RETURN (COND ($$VAL (CONS (QUOTE PUTPROPS) (CONS (CAR NAME) $$VAL)))))))
)

(FILEGETDEF.MACROS
(LAMBDA (NAME TYPE SOURCE OPTIONS) (* lmm "28-May-86 09:51") (MKPROGN (for X in (LOADFNS NIL SOURCE (QUOTE GETDEF) (QUOTE (LAMBDA (FIRST SECOND) (AND (FMEMB FIRST (QUOTE (PUTPROPS DEFMACRO))) (EQ SECOND NAME))))) join (if (EQ (CAR X) (QUOTE DEFMACRO)) then (LIST X) else (for TAIL on (CDDR X) by (CDDR TAIL) when (FMEMB (CAR TAIL) MACROPROPS) collect (LIST (QUOTE PUTPROPS) (CADR X) (CAR TAIL) (CADR TAIL)))))))
)

(FILEGETDEF.VARS
(LAMBDA (NAME TYPE SOURCE OPTIONS) (* lmm " 4-Jul-85 15:14") (for X in (LOADFNS NIL SOURCE (QUOTE GETDEF) NAME) do (SELECTQ (CAR X) ((RPAQQ SETQQ) (RETURN (CADDR X))) ((RPAQ SETQ RPAQ?) (RETURN (EVAL (CADDR X)))) NIL) finally (RETURN (QUOTE NOBIND))))
)

(FILEGETDEF.FNS
(LAMBDA (NAME TYPE SOURCE OPTIONS) (* bvm%: "29-Aug-86 22:30") (LET (MAP ENV) (COND ((AND (EQMEMB (QUOTE FAST) OPTIONS) (PROGN (CL:MULTIPLE-VALUE-SETQ (ENV MAP) (GET-ENVIRONMENT-AND-FILEMAP SOURCE)) MAP)) (for PAIR MAPLOC in (CDR MAP) when (SETQ MAPLOC (CADR (ASSOC NAME (CDDR PAIR)))) do (OR (OPENP SOURCE) (RESETSAVE NIL (LIST (QUOTE CLOSEF?) (SETQ SOURCE (OPENSTREAM SOURCE (QUOTE INPUT) (QUOTE OLD)))))) (SETFILEPTR SOURCE MAPLOC) (RETURN (WITH-READER-ENVIRONMENT ENV (COND ((EQMEMB (QUOTE ARGLIST) OPTIONS) (RATOM SOURCE) (READ SOURCE) (RATOM SOURCE) (LIST (READ SOURCE) (READ SOURCE))) (T (CADR (READ SOURCE)))))))) (T (CADR (FASSOC NAME (LOADEFS NAME SOURCE)))))))
)

(FILEPKGCOMS.PUTDEF
(LAMBDA (NAME TYPE DEFINITION REASON) (* lmm "15-Jul-85 11:29") (PROG (COM TYP) (SELECTQ (CAR (LISTP DEFINITION)) (COM (SETQ COM (CDR DEFINITION))) (TYPE (SETQ TYP (CDR DEFINITION))) (PROGN (SETQ COM (CDR (ASSOC (QUOTE COM) DEFINITION))) (SETQ TYP (CDR (ASSOC (QUOTE TYPE) DEFINITION))))) (* ;; "Check properties first, so that we don't smash some and then get an error in a later call to FILEPKGCOM/TYPE") (for I in COM by (CDDR I) do (SELECTQ I ((ADD DELETE MACRO CONTENTS CONTAIN COM)) (ERROR I "not file package command property"))) (* ; "COM merely adds to spelling list, for builtins") (FILEPKGCOM NAME (QUOTE CONTENTS) (OR (LISTGET COM (QUOTE CONTENTS)) (LISTGET COM (QUOTE CONTAIN)))) (* ; "Until CONTAIN is de-documented.") (for PROP in (QUOTE (ADD DELETE MACRO COM)) do (FILEPKGCOM NAME PROP (LISTGET COM PROP))) (for I in TYP by (CDDR I) do (OR (FMEMB I FILEPKGTYPEPROPS) (SELECTQ I ((DESCRIPTION TYPE)) (ERROR I "not file package type/command property")))) (* ; "TYPE merely adds to spelling list, for builtins") (for PROP in (UNION (QUOTE (DESCRIPTION TYPE)) FILEPKGTYPEPROPS) do (FILEPKGTYPE NAME PROP (LISTGET TYP PROP)))))
)

(FILES.PUTDEF
(LAMBDA (NAME TYPE DEFINITION REASON) (* lmm "15-Jul-85 17:13") (PROGN (PUTDEF (FILECOMS NAME) (QUOTE VARS) (CAR DEFINITION) REASON) (* ; "DEFINE THE COMS") (ADDFILE NAME) (* ; "MAKE SURE IT IS A FILE PACKAGE ENTITY") (/replace TOBEDUMPED of (fetch FILEPROP of NAME) (FILEPKG.MERGECHANGES (CADR DEFINITION) (fetch TOBEDUMPED of (fetch FILEPROP of NAME)))) (OR (fetch FILEDATES of NAME) (/replace FILEDATES of NAME with (CADDR DEFINITION)))))
)

(VARS.PUTDEF
(LAMBDA (NAME TYPE DEFINITION REASON) (* lmm "29-Jul-85 20:59") (/SETTOPVAL NAME DEFINITION T)))

(FILES.WHENCHANGED
(LAMBDA (NAME TYPE REASON) (MARKASCHANGED (FILECOMS NAME) (QUOTE VARS) REASON)))
)

(ADDTOVAR MACROPROPS MACRO BYTEMACRO DMACRO)

(ADDTOVAR SYSPROPS PROPTYPE)

(PUTPROPS I.S.OPR PROPTYPE I.S.OPRS)

(PUTPROPS SUBR PROPTYPE IGNORE)

(PUTPROPS LIST PROPTYPE IGNORE)

(PUTPROPS CODE PROPTYPE IGNORE)

(PUTPROPS FILEDATES PROPTYPE IGNORE)

(PUTPROPS FILE PROPTYPE IGNORE)

(PUTPROPS FILEMAP PROPTYPE IGNORE)

(PUTPROPS EXPR PROPTYPE FNS)

(PUTPROPS VALUE PROPTYPE VARS)

(PUTPROPS COPYRIGHT PROPTYPE FILES)

(PUTPROPS FILETYPE PROPTYPE FILES)

(PUTPROPS BAKTRACELST VARTYPE ALIST)

(PUTPROPS BREAKMACROS VARTYPE ALIST)

(PUTPROPS COMPILETYPELST VARTYPE ALIST)

(PUTPROPS EDITMACROS VARTYPE (ALIST USERMACROS))

(PUTPROPS ERRORTYPELST VARTYPE ALIST)

(PUTPROPS FONTDEFS VARTYPE ALIST)

(PUTPROPS LISPXHISTORYMACROS VARTYPE (ALIST LISPXMACROS))

(PUTPROPS LISPXMACROS VARTYPE (ALIST LISPXMACROS))

(PUTPROPS PRETTYDEFMACROS VARTYPE (ALIST FILEPKGCOMS))

(PUTPROPS PRETTYEQUIVLST VARTYPE ALIST)

(PUTPROPS PRETTYPRINTMACROS VARTYPE ALIST)

(PUTPROPS PRETTYPRINTYPEMACROS VARTYPE ALIST)

(PUTPROPS USERMACROS VARTYPE (ALIST USERMACROS))



(* ; "Define the commands below AFTER the various properties have been established.")


(ADDTOVAR USERMACROS
          (M (X . Y)
             (E (MARKASCHANGED (COND ((LISTP 'X)
                                      (CAR 'X))
                                     (T 'X))
                       'USERMACROS)
                T)
             (ORIGINAL (M X . Y)))
          (M NIL (MAKE FILE FILE)))

(ADDTOVAR EDITMACROS
          (M (X . Y)
             (E (MARKASCHANGED (COND ((LISTP 'X)
                                      (CAR 'X))
                                     (T 'X))
                       'USERMACROS)
                T)
             (ORIGINAL (M X . Y))))

(ADDTOVAR EDITCOMSA M)

(ADDTOVAR EDITCOMSL M)



(* ; "GETDEF methods")

(DEFINEQ

(RENAME
(LAMBDA (OLD NEW TYPES FILES METHOD) (* JonL "24-Jul-84 20:01") (PROG ((TYPES (GETFILEPKGTYPE TYPES (QUOTE TYPE) NIL OLD))) (* ;; "special kludge: change the callers BEFORE if we are changing a field;  this is so the CHANGECALLERS won't get an UNABLE TO DWIMIFY message") (for TYPE inside TYPES when (NEQ TYPE (QUOTE FIELDS)) do (COPYDEF OLD NEW TYPE NIL (COND ((EQ TYPE (QUOTE VARS)) (QUOTE NOERROR))))) (CHANGECALLERS OLD NEW TYPES FILES METHOD) (for TYPE inside TYPES do (COND ((AND (EQ TYPE (QUOTE FIELDS)) (HASDEF OLD (QUOTE FIELDS))) (* ;; "The HASDEF test is because the rename might already have been done in EDITFROMFILE in the CHANGECALLERS, if it found a record with the field on a file.  Otherwise, COPYDEF essentially will just do the necessary substitution in the existing record declarations, given that definitions for FIELDS are mutually exclusive.") (COPYDEF OLD NEW (QUOTE FIELDS))) (T (DELDEF OLD TYPE)))) (RETURN NEW)))
)

(CHANGECALLERS
(LAMBDA (OLD NEW AS-TYPES FILES METHOD) (* ; "Edited  6-Dec-86 01:25 by lmm") (PROG ((AS-TYPES (GETFILEPKGTYPE AS-TYPES)) REL TEM EDITCOMS FNS) (OR METHOD (SETQ METHOD DEFAULTRENAMEMETHOD)) (SETQ EDITCOMS (LIST (COND ((OR (EQMEMB (QUOTE CAREFUL) METHOD) (PROGN (SETQ TEM (TYPESOF OLD NIL AS-TYPES)) (printout T "Warning --" OLD " is also defined as " TEM T))) (* ;; "This creates a `command' that searches like EXAM, but interrogates the user about whether to do the Rename.  Y means do it, No means skip, anything else goes into TTY.") (SUBPAIR (QUOTE (OLD NEW)) (LIST OLD NEW) (QUOTE (BIND (LPQ (F OLD N) (MARK %#1) (ORR (1 !0 P) NIL) (MARK %#2) (COMS (SELECTQ (ASKUSER NIL NIL "   Replace ? " (QUOTE ((Y "Yes
") (N "No
") (%
 "") (%  "") (%
 "") (& ""))) NIL NIL (QUOTE (NOECHOFLG T))) (Y (QUOTE (R1 OLD NEW))) (N NIL) (QUOTE TTY%:))) (MARK %#3) (IF (EQ (%## (\ %#3)) (%## (\ %#2))) ((\ %#1)) NIL)))))) (T (LIST (QUOTE R) OLD NEW))))) (SELECTQ (COND ((AND (EQMEMB (QUOTE MASTERSCOPE) METHOD) MSDATABASELST (for TYPE inside AS-TYPES do (COND ((SETQ TEM (SELECTQ TYPE ((FNS FUNCTIONS SPECIAL-FORMS OPTIMIZERS) (QUOTE CALL)) (MACROS (QUOTE (CALL DIRECTLY))) ((VARS VARIABLES) (QUOTE (USE OR BIND))) ((RECORDS FIELDS I.S.OPRS) (LIST (QUOTE USE) (QUOTE AS) TYPE)) (RETURN NIL))) (COND (REL (SETQ REL (LIST TEM (QUOTE OR) REL))) (T (SETQ REL TEM))))) FINALLY (RETURN REL))) (* ;; "can only use masterscope if (a) we say to, (b) something's been analyzed, and (c) the types the function is are known") (QUOTE MASTERSCOPE)) ((EQMEMB (QUOTE EDITCALLERS) METHOD) (QUOTE EDITCALLERS)) (T (QUOTE SEARCH))) (MASTERSCOPE (MAPC (SETQ FNS (NCONC (COND ((NULL FILES) (UPDATEFILES) (FILEPKGCHANGES (QUOTE FNS)))) (for FILE inside (OR FILES FILELST) join (FILEFNSLST FILE)))) (FUNCTION UPDATEFN)) (SETQ FNS (INTERSECTION (GETRELATION OLD (SETQ REL (PARSERELATION REL)) T) FNS))) (EDITCALLERS (SETQ FILES (for X inside (OR FILES FILELST) when (SETQ TEM (EDITCALLERS OLD X T)) collect (PROGN (SETQ FNS (NCONC FNS (CDR TEM))) X)))) (SEARCH (SETQ FNS (for X inside (OR FILES FILELST) join (FILEFNSLST X)))) (ERROR "UNRECOGNIZED RENAME METHOD" METHOD)) (AND (EQMEMB (QUOTE FNS) AS-TYPES) (FMEMB OLD FNS) (SETQ FNS (REMOVE OLD FNS))) (EDITFROMFILE FNS FILES OLD EDITCOMS) (for TYPE inside AS-TYPES do (for FILE in (WHEREIS OLD TYPE FILES) do (AND (ADDTOFILE NEW TYPE FILE) (DELFROMFILES OLD TYPE FILE) (printout T OLD " changed to " NEW " on " FILE))) (COND ((SETQ TEM (WHEREIS OLD TYPE FILES)) (printout T "Couldn't change " OLD " to " NEW " as " TYPE " on " TEM)))) (COND (REL (UPDATECHANGED) (COND ((AND (SETQ TEM (GETRELATION OLD REL T)) (WHEREIS TEM (QUOTE FNS) FILES)) (printout T "Couldn't find where " OLD " is referenced in " TEM T)))))))
)
)
(DEFINEQ

(SHOWDEF
(LAMBDA (NAME TYPE FILE) (* lmm " 3-Jan-85 17:32") (* ; "prettyprint NAME as it would be dumped as a TYPE") (RESETLST (PROG (ORIGFLG FNSLST FL PRETTYCOMSLST) (DECLARE (SPECVARS . T)) (AND FILE (NEQ FILE (OUTPUT)) (if (SETQ FL (OPENP FILE (QUOTE OUTPUT))) then (RESETSAVE (OUTPUT FL)) else (OUTFILE FILE) (RESETSAVE NIL (LIST (FUNCTION CLOSEF?) (OUTPUT))))) (PRETTYCOM (MAKENEWCOM NAME TYPE)))))
)

(COPYDEF
(LAMBDA (OLD NEW TYPE SOURCE OPTIONS) (* lmm "14-Aug-84 18:38") (* ; "like MOVD, but takes a type.") (PROG (TEM DEF) (SETQ TYPE (GETFILEPKGTYPE TYPE (QUOTE TYPE))) (SETQ DEF (GETDEF OLD TYPE SOURCE (COND ((EQ OPTIONS (QUOTE NOCOPY)) NIL) (T (REMOVE (QUOTE NOCOPY) (MKLIST OPTIONS)))))) (* ; "The default is for GETDEF to return a COPY.  Make sure that NOCOPY isn't in options though.") (SELECTQ TYPE (VARS) (FILES (for X in (CAR DEF) do (* ; "change all the listnames which are of form filenameTYPE") (SELECTQ (CAR X) ((PROP IFPROP) (SETQ X (CDR X))) NIL) (COND ((EQ (CADR X) (QUOTE *)) (SETQ X (CDDR X)) (COND ((AND (LITATOM (CAR X)) (SETQ TEM (STRPOS OLD (CAR X) 1 NIL T T))) (SAVESET (SETQ TEM (PACK* NEW (SUBATOM (CAR X) TEM -1))) (COPY (GETTOPVAL (CAR X))) T) (FRPLACA X TEM))))))) ((PROPS ALISTS) (OR (EQ (CAR NEW) (CAR OLD)) (DSUBST (CAR NEW) (CAR OLD) DEF)) (OR (EQ (CADR NEW) (CADR OLD)) (DSUBST (CADR NEW) (CADR OLD) DEF))) (DSUBST NEW OLD DEF)) (PUTDEF NEW TYPE DEF) (RETURN NEW)))
)

(GETDEF
(LAMBDA (NAME TYPE SOURCE OPTIONS) (* lmm "13-Jul-85 04:10") (* ;; "returns the definition of NAME as a TYPE from SOURCE;  cause ERROR if not found unless OPTIONS is NOERROR --- usually returns a copy unless OPTIONS is NOCOPY in which case it tries not to return a copy --- FLG=NOCOPY is currently only used from SAVEDEF where SOURCE is always 0 --- If options is or contains a string, returns that string instead of causing error if no def found.  The caller can figure out what happened, even for types for which NIL/NOBIND might have defs.") (PROG (DEF TEM (NOCOPY (EQMEMB (QUOTE NOCOPY) OPTIONS))) (DECLARE (SPECVARS NOCOPY)) (SELECTQ OPTIONS (0 (SETQQ OPTIONS (NOERROR NODWIM)) (SETQ NOCOPY T)) (1 (SETQQ OPTIONS (NOERROR NODWIM FAST ARGLIST)) (SETQ NOCOPY T)) (T (SETQQ OPTIONS SPELL)) NIL) (SETQ TYPE (GETFILEPKGTYPE TYPE (QUOTE TYPE))) (SELECTQ SOURCE (0 (SETQQ SOURCE CURRENT)) (T (SETQQ SOURCE SAVED)) (NIL (SETQQ SOURCE ?)) NIL) (SELECTQ SOURCE (CURRENT (SETQ DEF (GETDEFCURRENT NAME TYPE OPTIONS))) (? (LET ((NOERROR (CONS (QUOTE NOERROR) (MKLIST OPTIONS)))) (OR (NEQ (SETQ DEF (GETDEFCURRENT NAME TYPE NOERROR)) (fetch NULLDEF of TYPE)) (NEQ (SETQ DEF (GETDEFSAVED NAME TYPE NOERROR)) (fetch NULLDEF of TYPE)) (SETQ DEF (GETDEFFROMFILE NAME TYPE (QUOTE FILE) OPTIONS))))) (SAVED (SETQ DEF (GETDEFSAVED NAME TYPE OPTIONS))) (COND ((AND (LISTP SOURCE) (EQ (CAR SOURCE) (QUOTE =))) (SETQ DEF (CDR SOURCE))) (T (SETQ DEF (GETDEFFROMFILE NAME TYPE SOURCE OPTIONS)) (SETQ NOCOPY T)))) (OR NOCOPY (SETQ DEF (COPY DEF))) (COND ((AND (EQ TYPE (QUOTE FNS)) (NOT (EQMEMB (QUOTE NODWIM) OPTIONS))) (DWIMDEF DEF NAME SOURCE))) (RETURN DEF)))
)

(GETDEFCOM
(LAMBDA (X) (* lmm " 4-Jul-85 13:31") (* ;; "In the case where GETDEF doesn't know how to get the definition of something, it resorts to asking the file package to print it out to a file and then reading the file back in.  Actually, though, that is a two stage process where the `command' to print out the datum is first macro expanded and then executed.  --- In some cases, you can tell what would be printed without printing it by looking at the prettydef-macro expansion.  That is what GETDEFCOM does: it takes a list of prettydef commands and returns what Would be printed by those commands (or NIL if it is `too hard' to figure out.) --- A few of the commands are special-cased inside GETDEFCOM0 because they occur frequently or are simple.") (* ; "a RETFROM point") (for Y in X join (GETDEFCOM0 Y)))
)

(GETDEFCOM0
(LAMBDA (COM) (* wt%: " 7-FEB-79 23:28") (PROG (TEM) (RETURN (COND ((SETQ TEM (fetch MACRO of (CAR COM))) (* COND ((fetch CONTENTS of (CAR COM)) (* ; "if it has a CONTENTS function, generally means it is not safe to evaluate") (RETFROM (QUOTE GETDEFCOM)))) (for Y in (SUBPAIR (CAR TEM) (PRETTYCOM1 COM) (CDR TEM)) join (GETDEFCOM0 Y))) (T (SELECTQ (CAR COM) (COMS (for X in (PRETTYCOM1 COM) join (GETDEFCOM0 X))) (ADDVARS (for Y in (PRETTYCOM1 COM) collect (CONS (QUOTE ADDTOVAR) Y))) (APPENDVARS (for Y in (PRETTYCOM1 COM) collect (CONS (QUOTE APPENDTOVAR) Y))) (P (APPEND (PRETTYCOM1 COM))) (RETFROM (QUOTE GETDEFCOM))))))))
)

(GETDEFCURRENT
(LAMBDA (NAME TYPE OPTIONS) (* ; "Edited  2-May-87 19:00 by Pavel") (* ; "Gets the current definition--source=0") (LET (DEF) (COND ((AND (SETQ DEF (fetch GETDEF of TYPE)) (NEQ DEF T)) (* ;; "We assign T to types whose GETDEF is normally handled in the SELECTQ below but whose MACRO is to be defaulted to the PUTDEF/GETDEF in PRETTYCOM.") (OR (NEQ (SETQ DEF (APPLY* DEF NAME TYPE OPTIONS)) (fetch NULLDEF of TYPE)) (GETDEFERR NAME TYPE OPTIONS)) DEF) (T (OR (NEQ (SETQ DEF (SELECTQ TYPE (FNS (AND (LITATOM NAME) (EXPRP (SETQ DEF (VIRGINFN NAME))) DEF)) (VARS (if (LITATOM NAME) then (GETTOPVAL NAME) else (QUOTE NOBIND))) ((FIELDS RECORDS) (if (LITATOM NAME) then (SETQ DEF (SELECTQ TYPE (RECORDS (RECLOOK NAME)) (MKPROGN (FIELDLOOK NAME)))) (if (EQMEMB (QUOTE EDIT) OPTIONS) then (COPY DEF) else DEF))) (FILES (* ; "what is the `definition' of a file?  -- I guess the COMS which say what it contains") (if (LITATOM NAME) then (if (SETQ DEF (GETFILEDEF NAME)) then (UPDATEFILES) (LIST (LISTP (GETTOPVAL (FILECOMS DEF))) (fetch TOBEDUMPED of (fetch FILEPROP of DEF)) (LISTP (fetch FILEDATES of DEF)))))) (TEMPLATES (if (AND (LITATOM NAME) (SETQ DEF (GETTEMPLATE NAME))) then (LIST (QUOTE SETTEMPLATE) (KWOTE NAME) (KWOTE DEF)))) (MACROS (if (AND (LITATOM NAME) (SETQ DEF (for X on (GETPROPLIST NAME) by (CDDR X) when (FMEMB (CAR X) MACROPROPS) join (LIST (CAR X) (CADR X))))) then (BQUOTE (PUTPROPS (\, NAME) (\,@ DEF))))) (EXPRESSIONS (LISTP NAME)) (PROPS (AND (LISTP NAME) (AND (SETQ DEF (SOME (GETPROPLIST (CAR NAME)) (FUNCTION (LAMBDA (X) (EQ X (CADR NAME)))) (FUNCTION CDDR))) (LIST (QUOTE PUTPROPS) (CAR NAME) (CADR NAME) (CADR DEF))))) (FILEPKGCOMS (AND (LITATOM NAME) (PROG ((COM (FILEPKGCOM NAME)) (TYP (FILEPKGTYPE NAME))) (RETURN (COND ((AND COM TYP) (LIST (CONS (QUOTE COM) COM) (CONS (QUOTE TYPE) TYP))) (COM (LIST (CONS (QUOTE COM) COM))) (TYP (LIST (CONS (QUOTE TYPE) TYP)))))))) (FILEVARS (COND ((AND (LITATOM NAME) (LISTP (SETQ DEF (GETTOPVAL NAME))) (WHEREIS NAME (QUOTE FILEVARS))) DEF) (T (QUOTE NOBIND)))) (LET ((COMS (LIST (MAKENEWCOM NAME TYPE))) FILE) (COND ((NOT (SETQ DEF (GETDEFCOM COMS))) (WITH-READER-ENVIRONMENT *OLD-INTERLISP-READ-ENVIRONMENT* (RESETLST (RESETSAVE PRETTYFLG) (RESETSAVE FONTCHANGEFLG) (RESETSAVE (OUTPUT (SETQ FILE (OPENSTREAM (QUOTE {NODIRCORE}) (QUOTE BOTH))))) (PRETTYDEFCOMS COMS) (SETFILEPTR FILE 0) (SETQ DEF (for X in (READFILE FILE) join (SELECTQ (CAR X) ((*) NIL) (DECLARE%: (for Y on (CDR X) unless (SELECTQ (CAR Y) ((COPYWHEN EVAL@LOADWHEN EVAL@COMPILEWHEN) (RETURN (LIST Y))) (FMEMB (CAR Y) DECLARETAGSLST)) collect (CAR Y))) (CL:EVAL-WHEN (CDDR X)) (PROGN (CDR X)) (LIST X)))) (SETQ NOCOPY T))))) (MKPROGN DEF)))) (fetch NULLDEF of TYPE)) (GETDEFERR NAME TYPE OPTIONS)) DEF))))
)

(GETDEFERR
(LAMBDA (NAME TYPE OPTIONS MSG) (* lmm "13-Jul-85 04:11") (DECLARE (USEDFREE NODEF)) (* ; "Message non-null if looking for saved or filed definition.") (PROG (TEM) (RETURN (COND ((EQMEMB (QUOTE NOERROR) OPTIONS) (* ; "We want to do the string search in the HASDEF case") (RETURN (fetch NULLDEF of TYPE))) ((AND (NULL MSG) (EQMEMB (QUOTE SPELL) OPTIONS) (SETQ TEM (HASDEF NAME TYPE NIL (OR (LISTGET1 (LISTP OPTIONS) (QUOTE SPELL)) T))) (NEQ TEM NAME)) (RETFROM (QUOTE GETDEF) (GETDEF TEM TYPE (QUOTE ?) (CONS (QUOTE NOERROR) (MKLIST OPTIONS))))) (T (for O inside OPTIONS when (STRINGP O) do (RETFROM (QUOTE GETDEF) O) finally (ERROR NAME (CONS TYPE (QUOTE (definition not found))) T)))))))
)

(GETDEFFROMFILE
(LAMBDA (NAME TYPE SOURCE OPTIONS) (* bvm%: " 1-Oct-86 22:10") (* ;; "Tries to get definition from source file.  If successful, returns the definition.  Otherwise returns the NULLDEF of the type if OPTIONS contains NOERROR.") (DECLARE (SPECVARS NAME)) (bind (NOTFOUND _ "not found") DEF SOURCE TEM2 for FILE inside (COND ((EQ SOURCE (QUOTE FILE)) (WHEREIS NAME TYPE T)) (T SOURCE)) when (AND (SETQ SOURCE (FINDFILE FILE T)) (NEQ (SETQ DEF (COND ((SETQ TEM2 (fetch FILEGETDEF of TYPE)) (APPLY* TEM2 NAME TYPE SOURCE OPTIONS NOTFOUND)) (T (SELECTQ TYPE (FNS (FILEGETDEF.FNS NAME TYPE SOURCE OPTIONS NOTFOUND)) ((VARS FILEVARS) (FILEGETDEF.VARS NAME TYPE SOURCE OPTIONS NOTFOUND)) (MACROS (FILEGETDEF.MACROS NAME TYPE SOURCE OPTIONS NOTFOUND)) (PROPS (FILEGETDEF.PROPS NAME TYPE SOURCE OPTIONS NOTFOUND)) (RECORDS (FILEGETDEF.RECORDS NAME TYPE SOURCE OPTIONS NOTFOUND)) (ALISTS (FILEGETDEF.ALISTS NAME TYPE SOURCE OPTIONS NOTFOUND)) (LISPXMACROS (FILEGETDEF.LISPXMACROS NAME TYPE SOURCE OPTIONS NOTFOUND)) (COND ((SETQ DEF (GET TYPE (QUOTE DEFINERS))) (LET ((VAL (LOADFNS NIL SOURCE (QUOTE GETDEF) (BQUOTE (LAMBDA (FIRST SECOND) (AND (MEMB FIRST (QUOTE (\, DEF))) (OR (EQ SECOND NAME) (AND (MEMB SECOND (QUOTE (%( %[))) (PROGN (RATOM) (RATOM) (RATOM) (EQ NAME (RATOM))))))))))) (* ; "ick!  Should use real closure") (if (EQ (CAAR VAL) (QUOTE NOT-FOUND)) then NOTFOUND elseif (CDR VAL) then (CONS (QUOTE PROGN) VAL) else (CAR VAL)))) (T (RESETLST (RESETSAVE (RESETUNDO)) (LET (LOAD-VERBOSE-STREAM) (DECLARE (SPECVARS LOAD-VERBOSE-STREAM)) (* ; "just in case we get a PRETTYCOMPRINT in here") (LOADFNS NIL SOURCE (QUOTE PROP) (COND ((LITATOM NAME) (* ; "If an atom, only bother with expressions that contain it") (CONS (LIST (QUOTE &) (QUOTE |..|) NAME))) (T T)))) (GETDEFCURRENT NAME TYPE (CONS (QUOTE NOERROR) (MKLIST OPTIONS)))))))))) NOTFOUND)) do (AND (EQ SOURCE (QUOTE FILE)) (OR (FMEMB FILE FILELST) (CL:FORMAT T "(from ~A)~%%" SOURCE))) (* ; "Copying and dwimifying are done in GETDEF") (RETURN DEF) finally (RETURN (GETDEFERR NAME TYPE OPTIONS (APPEND (QUOTE (no definition on)) (MKLIST SOURCE))))))
)

(GETDEFSAVED
(LAMBDA (NAME TYPE OPTIONS) (* ; "Edited 11-Aug-87 18:14 by cutting") (* ; "Gets the `saved' definition--source=T") (SELECTQ TYPE (FNS (OR (GETPROP NAME (QUOTE EXPR)) (GETDEFERR NAME TYPE OPTIONS "no saved definition for"))) (VARS (* ; "The value of a variable is never substituted into and never COPIED") (for X on (GETPROPLIST NAME) by (CDDR X) when (EQ (CAR X) (QUOTE VALUE)) do (RETURN (CADR X)) finally (RETURN (GETDEFERR NAME TYPE OPTIONS "no saved value for ")))) (OR (CDR (SASSOC NAME (FASSOC TYPE SAVEDDEFS))) (GETDEFERR NAME TYPE OPTIONS "no saved definition for "))))
)

(PUTDEF
(LAMBDA (NAME TYPE DEFINITION REASON) (* ; "Edited  8-Apr-87 12:52 by Pavel") (SETQ TYPE (GETFILEPKGTYPE TYPE (QUOTE TYPE))) (LET ((PUTDEF.METHOD (fetch PUTDEF of TYPE))) (COND (PUTDEF.METHOD (APPLY* PUTDEF.METHOD NAME TYPE DEFINITION REASON)) (T (SELECTQ TYPE (FNS (FNS.PUTDEF NAME TYPE DEFINITION REASON)) (VARS (VARS.PUTDEF NAME TYPE DEFINITION REASON)) (FILES (FILES.PUTDEF NAME TYPE DEFINITION REASON)) (FILEPKGCOMS (FILEPKGCOMS.PUTDEF NAME TYPE DEFINITION REASON)) (EVAL DEFINITION)) NAME))))
)

(EDITDEF
(LAMBDA (NAME TYPE SOURCE EDITCOMS OPTIONS) (DECLARE (LOCALVARS . T) (SPECVARS SOURCE)) (* ; "Edited 27-Jul-87 11:04 by cutting") (* ;; "lets you edit anything.  Given name and type, call editor on the definition (loading it in from SOURCE if necessary).  If you change it, then the definition gets unsaved.  OPTIONS is passed through from ED to the editor.") (SETQ TYPE (GETFILEPKGTYPE TYPE (QUOTE TYPE))) (COND ((AND (fetch EDITDEF of TYPE) (APPLY* (fetch EDITDEF of TYPE) NAME TYPE SOURCE EDITCOMS OPTIONS))) ((AND (EQ TYPE (QUOTE FNS)) (NULL SOURCE)) (* ; "special hack for EDITDEF of FNS because of ability to EDITLOADFNS") (EDITDEF.FNS NAME EDITCOMS OPTIONS)) (T (DEFAULT.EDITDEF NAME TYPE SOURCE EDITCOMS OPTIONS))) NAME)
)

(DEFAULT.EDITDEF
  [LAMBDA (NAME TYPE SOURCE EDITCOMS OPTIONS)                (* ; "Edited 11-Jun-92 16:26 by cat")
    (PROG [(DEF (COND
                   [SOURCE (GETDEF NAME TYPE SOURCE '(EDIT NOCOPY]
                   [(GETDEF NAME TYPE 'CURRENT '(EDIT NOCOPY NOERROR]
                   [(GETDEF NAME TYPE 'SAVED '(EDIT NOCOPY NOERROR]
                   (T (LET ((FILES (WHEREIS NAME TYPE T)))
                           (CL:IF (NULL FILES)
                               (CL:FORMAT T "~S has no ~A definition.~%%" NAME TYPE)
                               [LET [(FILE (PROGN (CL:FORMAT T "~S is contained on~{ ~S~}.~%%" NAME 
                                                         FILES)
                                                  (CL:IF (CL:ENDP (CDR FILES))
                                                      (CL:IF (CL:Y-OR-N-P 
                                                                    "Shall I load this file PROP? ")
                                                             (CAR FILES))
                                                      (ASKUSER NIL NIL 
                                                             "indicate which file to load PROP: "
                                                             (MAKEKEYLST FILES)
                                                             T))]
                                    (CL:WHEN FILE
                                        (LOAD FILE 'PROP)
                                        (GETDEF NAME TYPE '? '(EDIT NOCOPY)))])]

     (* ;; "the EDIT option says to return a COPY if editing this structure isn't enough, and some installation is necessary.")

          (DECLARE (SPECVARS RETRY))

     (* ;; "what is RETRY ???")

          (SETQ RETRY)
          (CL:WHEN DEF
              (EDITE DEF EDITCOMS NAME TYPE [FUNCTION (LAMBDA (NAME DEF TYPE EXITFLG)
                                                             (* ; 
                                             "this function is called when there were changes made")
                                                        (FIXEDITDATE DEF)
                                                             (* ; "fix the edit date first - jtm")
                                                        (PUTDEF NAME TYPE DEF)
                                                        (MARKASCHANGED NAME TYPE 'CHANGED)

                                 (* ;; "woz 1/25/91 MARKASCHANGED must be called after PUTDEF, so sedit's markaschangedfn will see the new definition.  doc for PUTDEF says it calls MARKASCHANGED, but it doesn't always, so do it here.  this sometimes results in MARKASCHANGED getting called twice.")

                                                        ]
                     OPTIONS))])

(EDITDEF.FILES
(LAMBDA (NAME TYPE SOURCE EDITCOMS OPTIONS) (* ; "Edited 18-Mar-87 16:07 by woz") (EDITDEF (FILECOMS NAME) (QUOTE VARS) SOURCE EDITCOMS OPTIONS))
)

(LOADDEF
(LAMBDA (NAME TYPE SOURCE) (* lmm "13-SEP-78 01:34") (PUTDEF NAME TYPE (GETDEF NAME TYPE SOURCE (QUOTE (NODWIM NOCOPY)))))
)

(DWIMDEF
(LAMBDA (DEF FN SOURCE) (* lmm " 6-Jun-86 17:23") (AND (OR (EQ DWIMIFYCOMPFLG T) (EQ CLISPIFYPRETTYFLG T) (EQ (CAR (CADDR DEF)) (QUOTE CLISP%:)) (SELECTQ SOURCE ((CURRENT SAVED FILE ?) NIL) (AND (LITATOM SOURCE) (EQMEMB (QUOTE CLISP) (GETPROP SOURCE (QUOTE FILETYPE)))))) (LET ((NOSPELLFLG T) (DWIMESSGAG T) FILEPKGFLG LISPXHIST) (DECLARE (CL:SPECIAL NOSPELLFLG DWIMESSGAG FILEPKGFLG LISPXHIST)) (DWIMIFY0 DEF (COND ((OR (LISTP FN) (NULL FN)) (QUOTE ?)) (T FN)) NIL DEF))))
)

(DELDEF
(LAMBDA (NAME TYPE) (* ; "Edited  5-Dec-86 06:20 by lmm") (PROG (TEM) (SETQ TYPE (GETFILEPKGTYPE TYPE (QUOTE TYPE))) LP (COND ((SETQ TEM (fetch DELDEF of TYPE)) (APPLY* TEM NAME TYPE)) (T (SELECTQ TYPE (FNS (* ; "special because GETDEF of a FNS is only its EXPR definition, and DELDEF should only remove such") (AND (EXPRP NAME) (/PUTD NAME)) (REMPROP NAME (QUOTE EXPR)) (AND MSDATABASELST (MASTERSCOPE (LIST (QUOTE ERASE) (KWOTE NAME))))) (VARS (/SETTOPVAL NAME (QUOTE NOBIND))) (FILES (for LST in (QUOTE (FILELST NOTCOMPILEDFILES NOTLISTEDFILES)) do (/SETTOPVAL LST (REMOVE NAME (GETTOPVAL LST)))) (/replace FILEPROP of NAME with NIL) (/replace FILECHANGES of NAME with NIL) (/replace FILEDATES of NAME with NIL) (FLUSHFILEMAPS NAME)) (FILEPKGCOMS (DELFROMLIST (QUOTE FILEPKGCOMSPLST) NAME) (DELFROMLIST (QUOTE FILEPKGTYPES) NAME) (for FIELD on (FILEPKGCOM NAME) by (CDDR FIELD) do (FILEPKGCOM NAME (CAR FIELD) NIL)) (for FIELD on (FILEPKGTYPE NAME) by (CDDR FIELD) do (FILEPKGTYPE NAME (CAR FIELD) NIL)) (/replace ALLFIELDS of NAME with NIL)) (ALISTS (AND (LISTP NAME) (DELFROMLIST (CAR NAME) (FASSOC (CADR NAME) (GETTOPVAL (CAR NAME)))))) (MACROS (for P in MACROPROPS do (/REMPROP NAME P))) (PROPS (AND (LISTP NAME) (/REMPROP (CAR NAME) (CADR NAME)))) (LISPXMACROS (DELFROMLIST (QUOTE LISPXMACROS) (FASSOC NAME LISPXMACROS)) (DELFROMLIST (QUOTE LISPXHISTORYMACROS) (FASSOC NAME LISPXHISTORYMACROS)) (DELFROMLIST (QUOTE LISPXCOMS) NAME) (DELFROMLIST (QUOTE HISTORYCOMS) NAME)) (PRIN1 (LIST "Note: deleting" TYPE "not implemented yet") T)))) (MARKASCHANGED NAME TYPE (QUOTE DELETED)) (RETURN NAME)))
)

(DELFROMLIST
(LAMBDA (VAR VAL) (* rmk%: " 3-JAN-82 23:22") (AND (FMEMB VAL (GETTOPVAL VAR)) (/SETTOPVAL VAR (SUBSET (GETTOPVAL VAR) (FUNCTION (LAMBDA (X) (AND (NEQ X VAL) (OR (NLISTP X) (NEQ (CDR X) VAL)))))))))
)

(HASDEF
(LAMBDA (NAME TYPE SOURCE SPELLFLG) (* ; "Edited 31-Aug-87 18:02 by drc:") (* ;; "is NAME the name of something of type TYPE?  NIL SOURCE means 0, not ?") (DECLARE (SPECVARS TYPE)) (COND ((OR (LISTP TYPE) (LISTP (SETQ TYPE (GETFILEPKGTYPE TYPE (QUOTE TYPE))))) (* ; "ignore SPELLFLG") (for TY in TYPE do (AND (SETQ $$VAL (HASDEF NAME TY SOURCE)) (RETURN $$VAL)))) (T (PROG ((NODEF (fetch NULLDEF of TYPE)) (OPTS (QUOTE (NODWIM NOCOPY NOERROR HASDEF)))) (COND ((NULL SOURCE) (SETQQ SOURCE CURRENT))) (RETURN (SELECTQ SOURCE ((CURRENT 0) (COND ((OR (MEMBER NAME (fetch CHANGED of TYPE)) (LET ((TM (fetch HASDEF of TYPE))) (COND (TM (APPLY* TM NAME TYPE SOURCE)) ((NOT (LITATOM NAME)) (SELECTQ TYPE (PROPS (AND (LISTP NAME) (GETPROP (CAR NAME) (CADR NAME)))) ((FILES TEMPLATES MACROS LISPXMACROS VARS I.S.OPRS FNS FIELDS USERMACROS FILEVARS FILEPKGCOMS) NIL) (NEQ NODEF (GETDEF NAME TYPE (QUOTE CURRENT) OPTS)))) (T (* ;; "symbol definitions") (SELECTQ TYPE (FILES (LET ((SYMBOL (CL:FIND-SYMBOL (CONCAT NAME "COMS") "INTERLISP"))) (AND SYMBOL (BOUNDP SYMBOL)))) (TEMPLATES (GETTEMPLATE NAME)) (MACROS (GETLIS NAME MACROPROPS)) (LISPXMACROS (OR (FASSOC NAME LISPXMACROS) (FASSOC NAME LISPXHISTORYMACROS))) (VARS (AND (NOT (CL:KEYWORDP NAME)) (NEQ (GETTOPVAL NAME) (QUOTE NOBIND)))) (RECORDS (RECLOOK NAME)) (I.S.OPRS (PROG ((TEM (GETPROP NAME (QUOTE CLISPWORD)))) (RETURN (AND TEM (EQ (CAR TEM) (QUOTE FORWORD)) (GETPROP (CDR TEM) (QUOTE I.S.OPR)))))) (FNS (AND (OR (AND (GETD NAME) (EXPRP (GETD NAME))) (GET NAME (QUOTE EXPR))) (NOT (HASDEF NAME (QUOTE FUNCTIONS) SOURCE)))) (FIELDS (RECORDFIELD? NAME)) (USERMACROS (FASSOC NAME USERMACROS)) (FILEVARS) ((PROPS ALISTS DEFS EXPRESSIONS) NIL) (FILEPKGCOMS (OR (FMEMB NAME FILEPKGCOMSPLST) (FMEMB NAME FILEPKGTYPES))) (NEQ NODEF (GETDEF NAME TYPE (QUOTE CURRENT) OPTS))))))) (OR NAME T)) (SPELLFLG (CL:WHEN (CL:SYMBOLP NAME) (FIXSPELL NAME NIL (SELECTQ TYPE (FILES FILELST) (FILEPKGCOMS (UNION FILEPKGCOMSPLST FILEPKGTYPES)) (FIELDS (for X in USERRECLST join (APPEND (RECORDFIELDNAMES X)))) (RECORDS (for X in USERRECLST when (LITATOM (CADR X)) collect (CADR X))) (LISPXMACROS LISPXCOMS) (I.S.OPRS I.S.OPRLST) (USERMACROS (MAPCAR USERMACROS (FUNCTION CAR))) USERWORDS) NIL (LISTP SPELLFLG) (FUNCTION (LAMBDA (X) (HASDEF X TYPE (QUOTE CURRENT)))) NIL T))))) (? (OR (HASDEF NAME TYPE (QUOTE CURRENT)) (AND (LITATOM NAME) (HASDEF NAME TYPE (QUOTE SAVED) SPELLFLG)) (WHEREIS NAME TYPE T))) ((SAVED T) (NEQ NODEF (GETDEF NAME TYPE (QUOTE SAVED) OPTS))) (NEQ NODEF (GETDEF NAME TYPE SOURCE OPTS))))))))
)

(GETFILEDEF
(LAMBDA (FILENAME) (* lmm " 4-Jul-85 13:25") (* ;; "returns the official file name from a file name if NAME is FOO, look for FOO.LSP on FILELST") (COND ((FMEMB FILENAME FILELST) FILENAME) (T (for FILE in FILELST when (STRPOS FILENAME FILE 1 NIL T) do (COND ((EQ (FILENAMEFIELD FILE (QUOTE NAME)) FILENAME) (RETURN FILE)))))))
)

(SAVEDEF
(LAMBDA (NAME TYPE DEFINITION) (* JonL "24-Jul-84 20:11") (COND ((AND (LISTP NAME) (NULL TYPE)) (MAPCAR NAME (FUNCTION (LAMBDA (I) (SAVEDEF I (QUOTE FNS)))))) (T (SELECTQ (SETQ TYPE (GETFILEPKGTYPE TYPE (QUOTE TYPE))) (FNS (AND (OR DEFINITION (SETQ DEFINITION (GETD NAME))) (/PUT NAME (SETQ TYPE (COND ((SUBRP DEFINITION) (QUOTE SUBR)) ((EXPRP DEFINITION) (QUOTE EXPR)) ((CCODEP DEFINITION) (QUOTE CODE)) (T (QUOTE LIST)))) DEFINITION))) (VARS (AND (NEQ (OR DEFINITION (SETQ DEFINITION (GETTOPVAL NAME))) (QUOTE NOBIND)) (EQ DEFINITION (GETTOPVAL NAME)) (/PUT NAME (SETQ TYPE (QUOTE VALUE)) DEFINITION))) (AND (OR DEFINITION (SETQ DEFINITION (GETDEF NAME TYPE (QUOTE CURRENT) (QUOTE (NOCOPY NOERROR NODWIM))))) (/PUTASSOC NAME DEFINITION (OR (CDR (FASSOC TYPE SAVEDDEFS)) (CAR (SETQ SAVEDDEFS (CONS (LIST TYPE (CONS NAME)) SAVEDDEFS))))))) TYPE)))
)

(UNSAVEDEF
(LAMBDA (NAME TYPE DEF) (* lmm " 6-Jun-86 17:24") (SELECTQ TYPE ((NIL EXPR CODE SUBR LIST) (COND ((LISTP NAME) (* ; "for compatibility") (MAPCAR NAME (FUNCTION (LAMBDA (X) (UNSAVED1 X TYPE))))) (T (UNSAVED1 NAME TYPE)))) (PROG NIL (OR DEF (SETQ DEF (GETDEF NAME (SETQ TYPE (GETFILEPKGTYPE TYPE (QUOTE TYPE))) (QUOTE SAVED) 0)) (RETURN (CONS TYPE (QUOTE (not found))))) (COND ((NEQ DFNFLG T) (SAVEDEF NAME TYPE) (LET ((DFNFLG T)) (PUTDEF NAME TYPE DEF))) (T (PUTDEF NAME TYPE DEF))) (RETURN TYPE))))
)

(COMPAREDEFS
(LAMBDA (NAME TYPE SOURCES) (* lmm " 4-Jul-85 14:37") (COND ((AND (LISTP TYPE) (GETFILEPKGTYPE SOURCES NIL T)) (swap TYPE SOURCES))) (SETQ TYPE (GETFILEPKGTYPE TYPE (QUOTE TYPE))) (PROG (DEF DEFS (SRCS (OR SOURCES (WHEREIS NAME TYPE T)))) (COND ((NULL SOURCES) (AND (OR (MEMBER NAME (FILEPKGCHANGES TYPE)) (SOME SRCS (FUNCTION (LAMBDA (FILE) (MEMBER NAME (CDR (ASSOC TYPE (fetch TOBEDUMPED of (fetch FILEPROP of FILE))))))))) (push SRCS (QUOTE CURRENT))))) (SETQ SRCS (for SRC in SRCS when (COND ((NEQ (SETQ DEF (GETDEF NAME TYPE SRC (QUOTE (NOERROR NOCOPY)))) (fetch NULLDEF of TYPE)) (OR (SOME DEFS (FUNCTION (LAMBDA (DP) (COMPARELST DEF (CDR DP))))) (push DEFS (CONS SRC DEF))) T) (T (PRINTOUT T "No " SRC " definition found for " NAME T) NIL)) collect SRC)) (RETURN (COND ((NULL SRCS) (QUOTE (no definitions found))) ((NULL (CDR SRCS)) (QUOTE (only one definition found))) ((CDR DEFS) (for S1 on (DREVERSE DEFS) do (for S2 on (CDR S1) do (PRIN2 NAME T T) (AND (CAAR S1) (PRIN1 " from " T) (PRIN2 (CAAR S1) T T)) (PRIN1 " and " T) (PRIN2 NAME T T) (COND ((CAAR S2) (PRIN1 " from " T) (PRIN2 (CAAR S2) T T))) (PRIN1 " differ:" T) (TERPRI T) (COMPARELISTS (CDAR S1) (CDAR S2)))) (QUOTE DIFFERENT)) (T (QUOTE SAME))))))
)

(COMPARE
(LAMBDA (NAME1 NAME2 TYPE SOURCE1 SOURCE2) (* lmm " 5-SEP-78 13:37") (PROG ((DEF1 (GETDEF NAME1 TYPE SOURCE1 (QUOTE (NOERROR NOCOPY)))) (DEF2 (GETDEF NAME2 TYPE SOURCE2 (QUOTE (NOERROR NOCOPY))))) (COND ((COMPARELST DEF1 DEF2) (RETURN))) (PRIN2 NAME1 T T) (COND (SOURCE1 (PRIN1 " from " T) (PRIN2 SOURCE1 T T))) (PRIN1 " and " T) (PRIN2 NAME2 T T) (COND (SOURCE2 (PRIN1 " from " T) (PRIN2 SOURCE2 T T))) (PRIN1 " differ:" T) (TERPRI T) (COMPARELISTS DEF1 DEF2) (RETURN T)))
)

(TYPESOF
  [LAMBDA (NAME POSSIBLETYPES IMPOSSIBLETYPES SOURCE FILTER)
                                                          (* ; "Edited  2-Aug-88 02:08 by masinter")

    (* ;; "return list of all known types which NAME names")

    (LET
     (FOUND SHADOWED)
     (if (FMEMB SOURCE '(? NIL))
         then (CL:FLET [(RSHADOW NIL (for X in FOUND
                                            do (for Y in (CDR (FASSOC X SHADOW-TYPES))
                                                      do (if (FMEMB Y FOUND)
                                                                 then 
                                                             (* ; "shadower found before shadowed")
                                                                       (SETQ FOUND (REMOVE Y FOUND]
                         (LET (NOTFOUND NEWTYPES)
                              (for TYPE inside (OR POSSIBLETYPES FILEPKGTYPES)
                                 when [AND (LITATOM TYPE)
                                               (NOT (EQMEMB TYPE IMPOSSIBLETYPES))
                                               (OR (NULL FILTER)
                                                   (CL:FUNCALL FILTER TYPE))
                                               (NOT (find X in FOUND
                                                       suchthat (FMEMB TYPE
                                                                           (CDR (FASSOC X 
                                                                                       SHADOW-TYPES]
                                 do (if [OR (HASDEF NAME TYPE 'CURRENT)
                                                    (AND (LITATOM NAME)
                                                         (HASDEF NAME TYPE 'SAVED]
                                            then (push FOUND TYPE)
                                          else (push NOTFOUND TYPE)))
                              (RSHADOW)
                              [for FILE in FILELST while NOTFOUND
                                 when [NEQ T (fetch LOADTYPE of (GETPROP FILE
                                                                                   'FILE]
                                 do (if (SETQ NEWTYPES (INFILECOMS? NAME NOTFOUND
                                                                      (FILECOMS FILE)
                                                                      'TYPESOF))
                                            then [bind X for TYPE in NEWTYPES
                                                        when (FMEMB TYPE NOTFOUND)
                                                        do (push FOUND TYPE)
                                                              (if (SETQ X (FASSOC TYPE 
                                                                                     SHADOW-TYPES))
                                                                  then (SETQ NOTFOUND
                                                                            (LDIFFERENCE NOTFOUND X))
                                                                else (SETQ NOTFOUND
                                                                          (REMOVE TYPE NOTFOUND]
                                                  (SETQ NOTFOUND (LDIFFERENCE NOTFOUND NEWTYPES]
                              (if (AND NOTFOUND (GETD 'XCL::HASH-FILE-TYPES-OF))
                                  then (SETQ NEWTYPES (XCL::HASH-FILE-TYPES-OF NAME NOTFOUND))
                                        (SETQ FOUND (UNION NEWTYPES FOUND)))
                              (RSHADOW)
                              FOUND))
       else (for TYPE inside (OR POSSIBLETYPES FILEPKGTYPES)
                   when (AND (LITATOM TYPE)
                                 (NOT (EQMEMB TYPE IMPOSSIBLETYPES))
                                 (OR (NULL FILTER)
                                     (CL:FUNCALL FILTER TYPE))
                                 (HASDEF NAME TYPE SOURCE)) do (push FOUND TYPE)))
     FOUND])
)

(RPAQ? WHEREIS.HASH )



(* ; "Must come after PUTDEF")

(DEFINEQ

(FIXEDITDATE
  [LAMBDA (EXPR)                                             (* ; "Edited 17-Jul-89 11:13 by jtm:")
                                                             (* NOBIND "18-JUL-78 21:11")
                                                             (* Inserts or replaces previous edit 
                                                           date)
    (AND INITIALS (LISTP EXPR)
         (LISTP (CDR EXPR))
         (PROG (E)
               (COND
                  ((FMEMB (CAR EXPR)
                          LAMBDASPLST)

                   (* ;; "insert the edit date after the argument list")

                   (SETQ E (CDDR EXPR)))
                  [(FMEMB (GETPROP (CAR EXPR)
                                 ':DEFINER-FOR)
                          EDITDATE-ARGLIST-DEFINERS)

                   (* ;; "insert the edit date after the argument list")

                   (SETQ E (CDDR EXPR))
                   (while (NOT (CL:LISTP (CAR E))) do (SETQ E (CDR E))
                      finally (SETQ E (CDR E]
                  ((FMEMB (GETPROP (CAR EXPR)
                                 ':DEFINER-FOR)
                          EDITDATE-NAME-DEFINERS)

                   (* ;; "insert the edit date after the name")

                   (SETQ E (CDDR EXPR)))
                  (T (RETURN)))
           RETRY
               [COND
                  ((NLISTP E)
                   (RETURN))
                  ((LISTP (CAR E))
                   (SELECTQ (CAAR E)
                       ((CLISP%: DECLARE) 
                            (SETQ E (CDR E))
                            (GO RETRY))
                       (BREAK1 (COND
                                  ((EQ (CAR (CADAR E))
                                       'PROGN)
                                   (SETQ E (CDR (CADAR E)))
                                   (GO RETRY))))
                       (ADV-PROG                             (* No easy way to mark cleanly the 
                                                           date of an advised function)
                                 (RETURN))
                       (COND
                          ((AND (EQ (CAAR E)
                                    COMMENTFLG)
                                (EQ (CADAR E)
                                    'DECLARATIONS%:))
                           (SETQ E (CDR E))
                           (GO RETRY]
               (COND
                  ([for TAIL on E while (AND (LISTP (CAR TAIL))
                                                         (EQ (CAAR TAIL)
                                                             COMMENTFLG))
                      do (COND
                                ((AND (LISTP (CDR TAIL))
                                      (EDITDATE? (CAR TAIL)))
                                 (/RPLACA TAIL (EDITDATE (CAR TAIL)
                                                      INITIALS))
                                 (RETURN T]                  (* scans the comments for a 
                                                           timestamp for this user.)
                   NIL)
                  (T                                         (* attach the new timestamp at the 
                                                           beginning of the comments.)
                     (/ATTACH (EDITDATE NIL INITIALS)
                            E)))
               (RETURN EXPR])

(EDITDATE?
  [LAMBDA (COMMENT)                                          (* ; "Edited 11-Jun-92 16:44 by cat")
                                                             (* ; "Edited 13-Jul-89 09:30 by jtm:")
                                                             (* lmm "21-Mar-85 08:45")

         (* Tests to see if a given common is in fact an edit date --
       this has to be general enough to recognize the most comment comment forms while 
       specific enough to not recognize things that are not edit dates)

    (DECLARE (LOCALVARS . T))                            (* jtm%: changed test so that it 
                                                           creates one timestamp per user.)
    (COND
       [(LISTP COMMENT)
        (COND
           ((EQ (CAR COMMENT)
                COMMENTFLG)
            [COND
               (NIL (NULL NORMALCOMMENTSFLG)
                      (SETQ COMMENT (GETCOMMENT COMMENT]
            (COND
               ([OR (NOT (LISTP (CDR COMMENT)))
                    (NOT (LISTP (CDDR COMMENT]
                NIL)
               [(EQ (CADR COMMENT)
                    ';)                                      (* ; "CL style comment")
                (STRPOS INITIALS (CADDR COMMENT)
                       (IMINUS (NCHARS INITIALS]
               (T                                            (* ; "IL style comment")
                  (EQ (CADR COMMENT)
                      INITIALS]
       ((STRINGP COMMENT])
)



(* ; "Edit date support for all kinds of definers (from PARC 6/10/92)")


(RPAQQ EDITDATE-ARGLIST-DEFINERS (FUNCTIONS TYPES))

(RPAQQ EDITDATE-NAME-DEFINERS (STRUCTURES VARIABLES))
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS EDITDATE-ARGLIST-DEFINERS EDITDATE-NAME-DEFINERS)
)



(* ;; 
"how to dump FILEPKGCOMS. The SPLST must be initialized to contain FILEPKGCOMS in order to get started."
)

(DEFINEQ

(FILEPKGCOM
(LAMBDA N (* JonL "10-Jul-84 19:38") (PROG (TEM (COM (ARG N 1))) (RETURN (COND ((EQ N 1) (OR (for FIELD in (QUOTE (MACRO CONTENTS DELETE ADD)) when (SETQ TEM (FILEPKGCOM COM FIELD)) join (LIST FIELD TEM)) (AND (FMEMB COM (GETTOPVAL (QUOTE FILEPKGCOMSPLST))) (LIST (QUOTE COM) T)) (AND (SETQ TEM (CDR (ASSOC COM (GETTOPVAL (QUOTE FILEPKGCOMSPLST))))) (LIST (QUOTE COM) TEM)))) ((EQ N 2) (SELECTQ (ARG N 2) (ADD (fetch ADD of COM)) (DELETE (fetch DELETE of COM)) (MACRO (fetch MACRO of COM)) ((CONTENTS CONTAIN) (OR (fetch (FILEPKGCOM CONTENTS) of COM) (COND ((SETQ COM (fetch (FILEPKGCOM PRETTYTYPE) of COM)) (COND ((EQ COM (QUOTE NILL)) COM) ((EQ (CAR COM) (QUOTE LAMBDA)) (CONS (CAR COM) (CONS (CONS (CAADR COM) (CONS (OR (CADDR (CADR COM)) (QUOTE NAME)) (CONS (CADR (CADR COM)) (CDDDR (CADR COM))))) (SUBST (QUOTE INFILECOMTAIL) (QUOTE PRETTYCOM1) (CDDR COM))))) (T (LIST (QUOTE LAMBDA) (QUOTE (COM TYPE NAME)) (CONS COM (QUOTE (COM TYPE NAME)))))))))) (COM (OR (AND (FMEMB COM (GETTOPVAL (QUOTE FILEPKGCOMSPLST))) T) (CDR (ASSOC COM (GETTOPVAL (QUOTE FILEPKGCOMSPLST)))))) (ERROR (ARG N 2) "not file package command property"))) (T (for I TEM2 from 2 to N by 2 do (SETQ TEM (ARG N (ADD1 I))) (COND ((EQ (ARG N I) (QUOTE COM)) (SELECTQ TEM (NIL) (T (OR (FMEMB COM (GETTOPVAL (QUOTE FILEPKGCOMSPLST))) (/SETTOPVAL (QUOTE FILEPKGCOMSPLST) (CONS COM (GETTOPVAL (QUOTE FILEPKGCOMSPLST)))))) (COND ((SETQ TEM2 (ASSOC COM (GETTOPVAL (QUOTE FILEPKGCOMSPLST)))) (/RPLACD TEM2 TEM)) (T (/SETTOPVAL (QUOTE FILEPKGCOMSPLST) (CONS (CONS COM TEM) (GETTOPVAL (QUOTE FILEPKGCOMSPLST)))))))) (T (AND TEM (OR (FMEMB COM (GETTOPVAL (QUOTE FILEPKGCOMSPLST))) (/SETTOPVAL (QUOTE FILEPKGCOMSPLST) (CONS COM (GETTOPVAL (QUOTE FILEPKGCOMSPLST)))))) (SELECTQ (ARG N I) (ADD (/replace (FILEPKGCOM ADD) of COM with TEM)) (DELETE (/replace (FILEPKGCOM DELETE) of COM with TEM)) (MACRO (/replace (FILEPKGCOM MACRO) of COM with TEM)) ((CONTENTS CONTAIN) (/replace (FILEPKGCOM CONTENTS) of COM with TEM)) (ERROR (ARG N I) "not file package command property"))))) (MARKASCHANGED COM (QUOTE FILEPKGCOMS)))))))
)

(FILEPKGTYPE
(LAMBDA N (* lmm " 5-Jul-85 09:07") (PROG ((TYPE (ARG N 1)) TEM) (RETURN (COND ((EQ N 1) (OR (for FIELD in (UNION (QUOTE (DESCRIPTION)) FILEPKGTYPEPROPS) when (SETQ TEM (FILEPKGTYPE TYPE FIELD)) join (LIST FIELD TEM)) (AND (FMEMB TYPE (GETTOPVAL (QUOTE FILEPKGTYPES))) (LIST (QUOTE TYPE) T)) (AND (SETQ TEM (CDR (ASSOC TYPE (GETTOPVAL (QUOTE FILEPKGTYPES))))) (LIST (QUOTE TYPE) TEM)))) ((EQ N 2) (if (FMEMB (ARG N 2) FILEPKGTYPEPROPS) then (GETPROP TYPE (ARG N 2)) else (SELECTQ (ARG N 2) (DESCRIPTION (fetch DESCRIPTION of TYPE)) (TYPE (OR (AND (FMEMB TYPE (GETTOPVAL (QUOTE FILEPKGTYPES))) T) (CDR (ASSOC TYPE (GETTOPVAL (QUOTE FILEPKGTYPES)))))) (ERROR (ARG N 2) "not file package type property")))) (T (for I TEM2 from 2 to N by 2 do (SETQ TEM (ARG N (ADD1 I))) (COND ((EQ (ARG N I) (QUOTE TYPE)) (SELECTQ TEM (NIL) (T (OR (FMEMB TYPE FILEPKGTYPES) (/SETTOPVAL (QUOTE FILEPKGTYPES) (CONS TYPE FILEPKGTYPES)))) (COND ((SETQ TEM2 (ASSOC TYPE FILEPKGTYPES)) (/RPLACD TEM2 TEM)) (T (/SETTOPVAL (QUOTE FILEPKGTYPES) (CONS (CONS TYPE TEM) FILEPKGTYPES)))))) (T (AND TEM (OR (FMEMB TYPE FILEPKGTYPES) (/SETTOPVAL (QUOTE FILEPKGTYPES) (CONS TYPE FILEPKGTYPES)))) (if (FMEMB (ARG N I) FILEPKGTYPEPROPS) then (if TEM then (/PUTPROP TYPE (ARG N I) TEM) else (/REMPROP TYPE (ARG N I))) else (SELECTQ (ARG N I) (DESCRIPTION (/replace DESCRIPTION of TYPE with TEM)) (ERROR (ARG N I) "not file package command/type property")))))) (MARKASCHANGED TYPE (QUOTE FILEPKGCOMS)))))))
)
)

(PUTPROPS FILEPKGCOM ARGNAMES (COMMANDNAME (KEYWORDS%: MACRO ADD DELETE CONTENTS)))

(ADDTOVAR FILEPKGCOMSPLST FILEPKGCOMS)

(ADDTOVAR FILEPKGTYPES FILEPKGCOMS)
(PUTDEF (QUOTE FILEPKGCOMS) (QUOTE FILEPKGCOMS) '([COM CONTENTS (LAMBDA (COM NAME TYPE)
                                                                       (* Revert to NILL when no 
                                                                          longer coercing 
                                                                          PRETTYDEFMACROS to 
                                                                          FILEPKGCOMS)
                                                                       (AND (EQ TYPE 'FILEPKGCOMS)
                                                                            (INFILECOMTAIL COM]
                                                  (TYPE DESCRIPTION "file package commands/types" 
                                                        GETDEF T PUTDEF FILEPKGCOMS.PUTDEF)))
(PUTDEF (QUOTE ALISTS) (QUOTE FILEPKGCOMS) '([COM MACRO (X (COMS * (MAKEALISTCOMS . X]
                                             (TYPE DESCRIPTION "alist entries" GETDEF ALISTS.GETDEF 
                                                   WHENCHANGED (ALISTS.WHENCHANGED))))
(PUTDEF (QUOTE DEFS) (QUOTE FILEPKGCOMS) '[(COM MACRO (X (COMS . X])
(PUTDEF (QUOTE EDITMACROS) (QUOTE FILEPKGCOMS) '((TYPE TYPE USERMACROS)))
(PUTDEF (QUOTE EXPRESSIONS) (QUOTE FILEPKGCOMS) '((TYPE DESCRIPTION "expressions" WHENCHANGED (
                                                                              EXPRESSIONS.WHENCHANGED
                                                                                               )
                                                        EDITDEF NILL)))
(PUTDEF (QUOTE FIELDS) (QUOTE FILEPKGCOMS) '((TYPE EDITDEF NILL)))
(PUTDEF (QUOTE FILEPKGTYPES) (QUOTE FILEPKGCOMS) '((COM COM FILEPKGCOMS)
                                                   (TYPE TYPE FILEPKGCOMS)))
(PUTDEF (QUOTE FILES) (QUOTE FILEPKGCOMS) '([COM MACRO [X (P * (CONS (MAKEFILESCOMS . X]
                                                 CONTENTS
                                                 (LAMBDA (COM NAME TYPE)
                                                        (AND (EQ TYPE 'FILES)
                                                             (SUBSET (INFILECOMTAIL COM)
                                                                    (FUNCTION LITATOM]
                                            (TYPE PUTDEF FILES.PUTDEF WHENCHANGED (FILES.WHENCHANGED)
                                                  EDITDEF EDITDEF.FILES)))
(PUTDEF (QUOTE FILEVARS) (QUOTE FILEPKGCOMS) '((COM MACRO (X (VARS . X)))
                                               (TYPE NULLDEF NOBIND EDITDEF NILL)))
(PUTDEF (QUOTE FNS) (QUOTE FILEPKGCOMS) '((COM MACRO
                                               (X [E (MAPC 'X (FUNCTION (LAMBDA
                                                                         (FN)
                                                                         (AND (GETPROP FN
                                                                                     'FUNCTIONS)
                                                                              (CL:WARN 
                                                                      "~A has a FUNCTIONS definition"
                                                                                     FN]
                                                  (ORIGINAL (FNS . X)))
                                               CONTENTS NILL)
                                          (TYPE DESCRIPTION "functions" PUTDEF FNS.PUTDEF CANFILEDEF
                                                T)))
(PUTDEF (QUOTE INITRECORDS) (QUOTE FILEPKGCOMS) '[(COM MACRO (X (P * (RECORDALLOCATIONS . X)))
                                                       CONTENTS
                                                       (LAMBDA (COM NAME TYPE ONFILETYPE)
                                                              (AND (NULL ONFILETYPE)
                                                                   (EQ TYPE 'RECORDS)
                                                                   (INFILECOMTAIL COM])
(PUTDEF (QUOTE INITVARS) (QUOTE FILEPKGCOMS) '((COM COM T)))
(PUTDEF (QUOTE LISPXCOMS) (QUOTE FILEPKGCOMS) '((TYPE TYPE LISPXMACROS)))
(PUTDEF (QUOTE LISPXMACROS) (QUOTE FILEPKGCOMS) '((COM MACRO (X (COMS * (MAKELISPXMACROSCOMS . X)))
                                                       CONTENTS NILL)
                                                  (TYPE DESCRIPTION "LISPX commands")))
(PUTDEF (QUOTE MACROS) (QUOTE FILEPKGCOMS) '((COM
                                              MACRO
                                              [X
                                               (DECLARE%:
                                                EVAL@COMPILE
                                                (P
                                                 *
                                                 (MAPCAR
                                                  'X
                                                  (FUNCTION
                                                   (LAMBDA (Y)
                                                          (LET [[FNDEF (GETDEF Y 'FUNCTIONS
                                                                              'CURRENT
                                                                              '(NOCOPY NOERROR]
                                                                (MACDEF (GETDEF Y 'MACROS
                                                                               'CURRENT
                                                                               '(NOCOPY NOERROR]
                                                               (COND
                                                                ((AND FNDEF (EQ (CAR FNDEF)
                                                                                'DEFMACRO))
                                                                 (CL:WARN 
                           "Need to change MACROS to FUNCTIONS for writing out Common Lisp macro ~S."
                                                                        FNDEF)
                                                                 (LIST 'PROGN FNDEF MACDEF))
                                                                (T (OR MACDEF (CL:CERROR 
                                                          "Go ahead and finish writing out the file."
                                                                                     
                                                                       "No MACROS definition for ~A."
                                                                                     Y)
                                                                       (GETDEF Y 'MACROS 'CURRENT]
                                              CONTENTS NILL)
                                             (TYPE DESCRIPTION "Interlisp macros" GETDEF 
                                                   MACROS.GETDEF WHENCHANGED (CLEARCLISPARRAY))))
(PUTDEF (QUOTE PRETTYDEFMACROS) (QUOTE FILEPKGCOMS) '((COM COM FILEPKGCOMS)))
(PUTDEF (QUOTE PROPS) (QUOTE FILEPKGCOMS) '([COM MACRO (X (COMS * (MAKEPROPSCOMS . X]
                                            (TYPE DESCRIPTION "property lists" WHENCHANGED (
                                                                                    PROPS.WHENCHANGED
                                                                                            ))))
(PUTDEF (QUOTE RECORDS) (QUOTE FILEPKGCOMS) '[[COM
                                               MACRO
                                               (X [E (MAPC 'X (FUNCTION (LAMBDA
                                                                         (RECORD)
                                                                         (AND (GETPROP RECORD
                                                                                     'STRUCTURES)
                                                                              (CL:WARN 
                                                                     "~A has a STRUCTURES definition"
                                                                                     RECORD]
                                                  (E (RECORDECLARATIONS . X))
                                                  (INITRECORDS . X))
                                               CONTENTS
                                               (LAMBDA (COM NAME TYPE ONFILETYPE)
                                                      (AND (EQ TYPE 'FIELDS)
                                                           (NULL ONFILETYPE)
                                                           (MAPCONC (INFILECOMTAIL COM)
                                                                  (FUNCTION (LAMBDA
                                                                             (X)
                                                                             (APPEND (
                                                                                     RECORDFIELDNAMES
                                                                                      X]
                                              (TYPE DESCRIPTION "records" DELDEF
                                                    (LAMBDA (X)
                                                           (/SETTOPVAL 'USERRECLST
                                                                  (REMOVE (RECLOOK X)
                                                                         USERRECLST])
(PUTDEF (QUOTE OLDRECORDS) (QUOTE FILEPKGCOMS) '((COM COM T)))
(PUTDEF (QUOTE SYSRECORDS) (QUOTE FILEPKGCOMS) '[(COM MACRO (X (E (SAVEONSYSRECLST . X)))
                                                      CONTENTS
                                                      (LAMBDA (COM NAME TYPE ONFILETYPE)
                                                             (AND (NULL ONFILETYPE)
                                                                  (EQ TYPE 'RECORDS)
                                                                  (INFILECOMTAIL COM])
(PUTDEF (QUOTE USERMACROS) (QUOTE FILEPKGCOMS) '((COM MACRO (X (COMS * (MAKEUSERMACROSCOMS . X)))
                                                      CONTENTS NILL)
                                                 (TYPE DESCRIPTION "edit macros")))
(PUTDEF (QUOTE VARS) (QUOTE FILEPKGCOMS) '((COM MACRO
                                                (X [E (MAPC 'X (FUNCTION (LAMBDA
                                                                          (VAR)
                                                                          (AND (GETPROP VAR
                                                                                      'VARIABLES)
                                                                               (CL:WARN 
                                                                 "~A also has a VARIABLES definition"
                                                                                      VAR]
                                                   (ORIGINAL (VARS . X)))
                                                CONTENTS NILL)
                                           (TYPE DESCRIPTION "variables" NULLDEF NOBIND PUTDEF 
                                                 VARS.PUTDEF)))
(PUTDEF (QUOTE *) (QUOTE FILEPKGCOMS) '((COM CONTENTS NILL)))
(PUTDEF (QUOTE CONSTANTS) (QUOTE FILEPKGCOMS) '[(COM MACRO (X (DECLARE%: EVAL@COMPILE (VARS . X)
                                                                     (P (CONSTANTS . X])

(ADDTOVAR SHADOW-TYPES (FUNCTIONS FNS)
                           (VARIABLES VARS CONSTANTS))

(RPAQ? SAVEDDEFS )



(* ; "EDITCALLERS")

(DEFINEQ

(FINDCALLERS
(LAMBDA (ATOMS FILES) (* lmm "30-SEP-78 01:36") (PROG ((X (EDITCALLERS ATOMS FILES T))) (RETURN (NCONC (DREVERSE (CDR X)) (AND (CAR X) (LIST (CONS (COND ((CDR X) (QUOTE "plus other places on")) (T (QUOTE on))) (CAR X))))))))
)

(EDITCALLERS
(LAMBDA (ATOMS FILES COMS) (* bvm%: " 3-Nov-86 17:30") (LET (FFILEPOSPATTERNS FNS OTHERSFILES EDITPATTERN) (SETQ EDITPATTERN (EDITFPAT (CONS (QUOTE *ANY*) (SETQ ATOMS (MKLIST ATOMS))))) (for FILE in (COND ((NULL FILES) FILELST) ((EQ FILES T) (UNION SYSFILES FILELST)) ((LISTP FILES) FILES) (T (LIST FILES))) do (RESETLST (PROG (PATTERNS CA RDTBL MAP NOMAPFLG FULL FILESTREAM PRINTFLG ENV DUMMY TOP I) (OR (SETQ FULL (FINDFILE FILE)) (RETURN (LISPXPRINT (CONS FILE (QUOTE (not found))) T T))) (RESETSAVE NIL (LIST (QUOTE CLOSEF) (SETQ FILESTREAM (OPENSTREAM FULL (QUOTE INPUT))))) (CL:FORMAT T "~A: " (SETQ FULL (FULLNAME FILESTREAM))) (CL:MULTIPLE-VALUE-SETQ (ENV MAP TOP) (OR (GET-ENVIRONMENT-AND-FILEMAP FULL) (\PARSE-FILE-HEADER FILESTREAM))) (* ;; "Get reader environment of file.  The call to GET-ENVIRONMENT-AND-FILEMAP with the filename will get cached info if it exists.  Otherwise, read the top of the file") (SETQ RDTBL (AND ENV (fetch (READER-ENVIRONMENT REREADTABLE) of ENV))) (SETQ CA (SEPRCASE DWIMIFYCOMPFLG RDTBL)) (OR (SETQ PATTERNS (CDR (ASSOC RDTBL FFILEPOSPATTERNS))) (push FFILEPOSPATTERNS (CONS RDTBL (SETQ PATTERNS (for ATOM in ATOMS collect (CONCAT (COND ((EQ (CHCON1 ATOM) (CHARCODE ESCAPE)) (SETQ ATOM (SUBSTRING ATOM 2 -1)) "") (T " ")) (COND ((SETQ I (STRPOS (QUOTE ) ATOM)) (SUBSTRING ATOM 1 (SUB1 I))) (T (LET ((*PACKAGE* (CL:SYMBOL-PACKAGE ATOM))) (* ; "Keep MKSTRING from putting a prefix on") (MKSTRING ATOM T RDTBL)))) (COND (I "") (T " ")))))))) (for PATTERN in PATTERNS do (SETFILEPTR FILESTREAM (SETQ I (OR TOP 0))) (while (SETQ I (FFILEPOS PATTERN FILESTREAM I NIL NIL T CA)) do (COND ((NULL PRINTFLG) (* ; "cause the printing of the filename to be saved on history list") (SETQ PRINTFLG T) (LISPXPRIN2 FULL T T T) (* ;; "print with NODOFLG=T means just to record the printing;  the idea is that only those files in which something is found will be remembered on the history list") (LISPXPRIN1 ": " T NIL T))) (OR (AND (NEQ MAP T) (for X in (CDR (OR MAP (PROGN (SETFILEPTR FILESTREAM 0) (SETQ MAP (OR (GETFILEMAP FILESTREAM) (LOADFILEMAP FILESTREAM)))) (PROGN (* ; "file has no filemap") (SETQ MAP (SETQ NOMAPFLG T)) (LISPXPRIN1 " no filemap!" T) NIL))) thereis (AND (ILESSP (CAR X) I) (IGREATERP (CADR X) I) (for Z in (CDDR X) thereis (COND ((AND (ILESSP (CADR Z) I) (IGREATERP (CDDR Z) I)) (COND ((NOT (FMEMB (CAR Z) FNS)) (SETQ FNS (CONS (LISPXPRIN2 (CAR Z) T T) FNS)))) (SETQ I (CDDR Z)) T)))))) (PROGN (LISPXPRIN2 I T T) (OR (FMEMB FILE OTHERSFILES) (SETQ OTHERSFILES (CONS FILE OTHERSFILES))))) (LISPXSPACES 1 T))) (COND (PRINTFLG (LISPXTERPRI T)) (T (TERPRI T))) (COND ((NEQ COMS T) (COND ((OR FNS OTHERSFILES) (EDITFROMFILE (OR NOMAPFLG (DREVERSE FNS)) FULL EDITPATTERN COMS (NULL OTHERSFILES)) (SETQ OTHERSFILES) (SETQ FNS)))))))) (COND ((EQ COMS T) (CONS OTHERSFILES FNS)))))
)

(EDITFROMFILE
(LAMBDA (FNS FILES EDITPATTERN EDITCOMS ONLYTYPES) (* rmk%: "14-Mar-85 21:51") (RESETVARS ((EDITLOADFNSFLG (COND ((EQ EDITLOADFNSFLG T) (QUOTE (T . NO))) (T EDITLOADFNSFLG)))) (PROG NIL (OR EDITCOMS (SETQ EDITCOMS (LIST (LIST (QUOTE EXAM) EDITPATTERN)))) (AND (SETQ FILES (for FILE inside (OR FILES FILELST) when (OR (AND EDITLOADFNSFLG (FMEMB (ROOTFILENAME FILE) FILELST)) (COND ((EQ (QUOTE Y) (ASKUSER DWIMWAIT (QUOTE Y) (LIST "load from" FILE) NIL T)) (LOADFROM FILE FNS (QUOTE ALLPROP)) T))) collect FILE)) (for TYPE in (COND ((LISTP ONLYTYPES)) (ONLYTYPES (QUOTE (FNS))) (T (* ;; "Move FNS to the front.  This means that all the fns will be dwimified and edited before anything else (like a rename of fields) is done.") (CONS (QUOTE FNS) (REMOVE (QUOTE FNS) FILEPKGTYPES)))) when (AND (LITATOM TYPE) (NEQ (fetch EDITDEF of TYPE) (QUOTE NILL))) do (PROG (SEEN) (for FILE inside FILES do (for NAME in (COND ((AND (EQ TYPE (QUOTE FNS)) (NEQ FNS T)) (* ; "for this type, we are given the list of items") (PROG1 FNS (SETQ FNS NIL))) (T (* ; "only want the values of `TYPE' which are not part of some other type") (FILECOMSLST FILE TYPE (QUOTE EDIT)))) unless (MEMBER NAME SEEN) do (ERSETQ (PROG ((DEF (OR (GETDEF NAME TYPE (QUOTE CURRENT) (QUOTE (NOCOPY NOERROR))) (GETDEF NAME TYPE (QUOTE SAVED) (QUOTE (NOCOPY NOERROR)))))) (* ;; "If definition has been loaded, it may have been editted.  Work on that explicitly instead of bringing in a file definition to smash the users previous changes.  Perhaps we should query the user about this, but until the interaction is worked out, it is better to avoid trashing his in core edits, given that he can always get the file definition from permanent storage with LOADFNS.  --- We might also be more discriminating about this: if the user specified a root file name, then he means the definition from the definition group, not the physical file.  But ...  rmk") (COND ((OR (AND (EQ TYPE (QUOTE FNS)) (NEQ FNS T)) (AND (LISTP DEF) (LOOKIN DEF EDITPATTERN))) (COND ((NULL SEEN) (LISPXPRIN1 "editing the " T) (LISPXPRIN1 (OR (fetch DESCRIPTION of TYPE) TYPE) T) (LISPXSPACES 1 T))) (SETQ SEEN (CONS NAME SEEN)) (LISPXPRIN2 NAME T T) (LISPXPRIN1 ":
" T) (COND ((NOT (ERSETQ (EDITDEF NAME TYPE (OR (AND DEF (CONS (QUOTE =) DEF)) FILE) EDITCOMS))) (LISPXPRIN1 "failed" T))) (LISPXTERPRI T)))))))))))))
)

(FINDATS
(LAMBDA (X L) (* lmm "11-FEB-78 16:03") (COND ((NLISTP X) (FMEMB X L)) (T (OR (FINDATS (CAR X) L) (FINDATS (CDR X) L)))))
)

(LOOKIN
(LAMBDA (X PAT) (* lmm "11-MAR-78 14:20") (COND ((AND (EQ (CAR PAT) (QUOTE *ANY*)) (EVERY (CDR PAT) (FUNCTION (LAMBDA (X) (AND (LITATOM X) (NOT (STRPOS (QUOTE ) X))))))) (FINDATS X (CDR PAT))) (T (EDITFINDP X PAT T))))
)
)
(DEFINEQ

(SEPRCASE
(LAMBDA (CLFLG RDTBL) (* bvm%: "24-Oct-86 18:16") (* ;; "make a case array for FFILEPOS in which all of the seprs, breaks, and (possibly) clisp chars are all equivalent.  Based on FILERDTBL, but others are close with respect to breaks and seprs") (OR RDTBL (SETQ RDTBL FILERDTBL)) (OR (ARRAYP (CDR (ASSOC RDTBL (COND (CLFLG CLISPCASEARRAYS) (T SEPRCASEARRAYS))))) (LET ((CA (CASEARRAY))) (if (READTABLEPROP RDTBL (QUOTE CASEINSENSITIVE)) then (* ; "map upper into lower case") (for I from (CHARCODE A) to (CHARCODE Z) do (SETCASEARRAY CA I (+ I (- (CHARCODE a) (CHARCODE A)))))) (for X in (NCONC (AND CLFLG (for Y in CLISPCHARS collect (CHCON1 Y))) (GETSEPR RDTBL) (GETBRK RDTBL)) do (SETCASEARRAY CA X 0)) (if *PACKAGE* then (* ; "symbols qualified with package prefix will otherwise be unfindable") (SETCASEARRAY CA (READTABLEPROP RDTBL (QUOTE PACKAGECHAR)) 0)) (SETQ CA (CONS RDTBL CA)) (COND (CLFLG (push CLISPCASEARRAYS CA)) (T (push SEPRCASEARRAYS CA))) (CDR CA))))
)
)

(RPAQ? DEFAULTRENAMEMETHOD '(EDITCALLERS CAREFUL))

(RPAQ? SEPRCASEARRAYS )

(RPAQ? CLISPCASEARRAYS )

(MOVD? 'INFILEP 'FINDFILE)

                                                             (* ; "or else from SPELLFILE")
(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY

(BLOCK%: EDITFROMFILE EDITFROMFILE LOOKIN (GLOBALVARS EDITLOADFNSFLG)
       (NOLINKFNS LOADFROM))
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS SYSFILES CLISPCASEARRAYS SEPRCASEARRAYS CLISPCHARS)
)



(* ; "EXPORT")

(DEFINEQ

(IMPORTFILE
(LAMBDA (FILE RETURNFLG) (* lmm " 6-Jun-86 17:43") (RESETLST (RESETSAVE NIL (LIST (QUOTE CLOSEF) (SETQ FILE (OPENSTREAM FILE (QUOTE INPUT))))) (RESETSAVE (INPUT FILE)) (* ; "Reset INPUT in case some form on the file's action is to read the next expression") (NCONC (COND ((EQ RETURNFLG T) (* ; "Just creating EXPORTS.ALL, don't side-effect the world") (IMPORTFILESCAN FILE RETURNFLG)) (T (LET (FILEPKGFLG DFNFLG) (IMPORTFILESCAN FILE RETURNFLG)))) (IMPORTEVAL (LIST (QUOTE PUTPROP) (KWOTE (ROOTFILENAME FILE)) (QUOTE (QUOTE IMPORTDATE)) (LIST (QUOTE IDATE) (GETFILEINFO FILE (QUOTE CREATIONDATE)))) RETURNFLG))))
)

(IMPORTEVAL
(LAMBDA (FORM RETURNFLG) (* ; "Edited  2-May-87 18:57 by Pavel") (* ;; "Ignore DONTEVAL@LOAD'S --- If RETURNFLG is on, return list of forms") (AND (LISTP FORM) (SELECTQ (CAR FORM) (DECLARE%: (FOR Z IN (CDR FORM) JOIN (IMPORTEVAL Z RETURNFLG))) (CL:EVAL-WHEN (FOR Z IN (CDDR FORM) JOIN (IMPORTEVAL Z RETURNFLG))) (/DECLAREDATATYPE (* ; "Ignore datatype initializations -- we only need the record declaration itself") NIL) (PROGN (* ; "default: eval and/or return it") (AND (NEQ RETURNFLG T) (EVAL FORM)) (AND RETURNFLG (LIST FORM))))))
)

(IMPORTFILESCAN
(LAMBDA (FILE RETURNFLG) (* bvm%: "24-Oct-86 19:31") (WITH-READER-ENVIRONMENT (GET-ENVIRONMENT-AND-FILEMAP FILE) (while (FFILEPOS BEGINEXPORTDEFSTRING FILE NIL NIL NIL T) bind DEF join (until (EQUAL (SETQ DEF (READ FILE)) ENDEXPORTDEFFORM) join (IMPORTEVAL DEF RETURNFLG)))))
)

(CHECKIMPORTS
(LAMBDA (FILES NOASKFLG) (* rmk%: "19-FEB-83 16:31") (* ; "Loads exported definitions from new versions of FILES.") (COND ((AND (SETQ FILES (for FILE inside FILES bind FULLFILENAME DATE when (AND (SETQ FULLFILENAME (FINDFILE FILE T)) (OR (NOT (SETQ DATE (GETPROP (ROOTFILENAME FILE) (QUOTE IMPORTDATE)))) (NOT (IEQP DATE (GETFILEINFO FULLFILENAME (QUOTE ICREATIONDATE)))))) collect (LIST FILE FULLFILENAME))) (OR NOASKFLG (SELECTQ (ASKUSER 5 (QUOTE Y) (LIST "load new exports from " (MAPCAR FILES (FUNCTION CAR))) (QUOTE ((Y "es
") (N "o
"))) T) (N NIL) T))) (for FILE in FILES do (IMPORTFILE (CADR FILE)))))))

(GATHEREXPORTS
(LAMBDA (FROMFILES TOFILE FLG) (* bvm%: "14-Oct-86 23:12") (* ; "Copies all exported definitions from FROMFILES to TOFILE.") (RESETLST (RESETSAVE NIL (LIST (FUNCTION CLOSE-AND-MAYBE-DELETE) (SETQ TOFILE (OPENSTREAM TOFILE (QUOTE OUTPUT))))) (RESETSAVE (OUTPUT TOFILE)) (LET ((ENV *DEFAULT-MAKEFILE-ENVIRONMENT*)) (SETQ ENV (if ENV then (\DO-DEFINE-FILE-INFO NIL ENV) else *OLD-INTERLISP-READ-ENVIRONMENT*)) (WITH-READER-ENVIRONMENT ENV (PRINT-READER-ENVIRONMENT ENV) (printout NIL "(LISPXPRIN1 %"EXPORTS GATHERED FROM " (DIRECTORYNAME T) " ON " (DATE) "%"  T)" T "(LISPXTERPRI T)" T) (for F inside FROMFILES do (MAPC (IMPORTFILE F (OR FLG T)) (FUNCTION PRINT)) (TERPRI)) (PRINT (QUOTE STOP)) (TERPRI) (FULLNAME TOFILE)))))
)

(\DUMPEXPORTS
(NLAMBDA COMS (* bvm%: "24-Oct-86 19:42") (* ;;; "Dumps an EXPORT form.  IMPORTFILE looks for a string announcing imports, but we must print it in a way that lets the file be loaded ok.") (PRIN1 "(") (PRIN2 (QUOTE *)) (PRIN1 (SUBSTRING BEGINEXPORTDEFSTRING 2)) (* ; "BEGINEXPORTDEFSTRING starts with a * for benefit of IMPORTFILE") (for TAIL on COMS do (PRETTYCOM (CAR TAIL))) (TERPRI) (PRINT ENDEXPORTDEFFORM) (TERPRI))
)
)
(PUTDEF (QUOTE EXPORT) (QUOTE FILEPKGCOMS) '[(COM MACRO (X (E (\DUMPEXPORTS . X])

(RPAQ? BEGINEXPORTDEFSTRING "* %"FOLLOWING DEFINITIONS EXPORTED%")")

(RPAQ? ENDEXPORTDEFFORM '(* "END EXPORTED DEFINITIONS"))
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS BEGINEXPORTDEFSTRING ENDEXPORTDEFFORM)
)



(* ; "for GAINSPACE")

(DEFINEQ

(CLEARFILEPKG
(LAMBDA (FLG) (* bvm%: "29-Aug-86 13:02") (PROG NIL (COND ((SELECTQ FLG ((E T) T) (Y (TERPRI T) (PRIN1 "you can delete just the filemaps -
" T) (PROG1 (ASKUSER NIL NIL "are you sure you want to delete EVERYTHING ? " (QUOTE ((Y "es - everything" RETURN T) (N "o - just the filemaps" RETURN NIL) (E "verything" RETURN T) (F "ilemaps only" RETURN NIL)))) (TERPRI T))) NIL) (UPDATEFILES) (SETQ FILELST (SUBSET FILELST (FUNCTION (LAMBDA (FILE) (COND ((fetch TOBEDUMPED of (fetch FILEPROP of FILE)) (PRINT FILE T T) (PRIN1 " has changes, not wiped." T) (TERPRI T) T) (T (replace FILEPROP of FILE with NIL) (replace FILECHANGES of FILE with NIL) (SMASHFILECOMS FILE) (NCONC1 SYSFILES FILE) NIL)))))) (SETQ LOADEDFILELST))) (SELECTQ FLG ((NIL T)) (CLRHASH *FILEMAP-HASH*))))
)
)

(ADDTOVAR GAINSPACEFORMS (FILELST "erase filepkg information" (CLEARFILEPKG RESPONSE)
                                    ((Y "es")
                                     (N "o")
                                     (E . "verything")
                                     (F "ilemaps only
"))))
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS SMASHPROPSLST1)
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS %#UNDOSAVES ADDTOFILEKEYLST CLEANUPOPTIONS CLISPIFYPRETTYFLG COMPILE.EXT DECLARETAGSLST 
       DEFAULTRENAMEMETHOD FILEPKGCOMSPLST FILERDTBL HISTORYCOMS HISTSTR0 I.S.OPRLST LISPXCOMS 
       LISPXHISTORY LISPXHISTORYMACROS LISPXMACROS MACROPROPS MAKEFILEOPTIONS MAKEFILEREMAKEFLG 
       MSDATABASELST PRETTYHEADER PRETTYTRANFLG SAVEDDEFS SYSPROPS USERMACROS USERRECLST USERWORDS 
       FILEPKGTYPEPROPS)
)
(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY

(BLOCK%: DELFROMCOMS DELFROMCOMS DELFROMCOM DELFROMCOM1 REMOVEITEM (NOLINKFNS . T)
       (SPECVARS COMSNAME))

(BLOCK%: ADDTOFILEBLOCK ADDTOFILES? ADDTOFILE WHATIS ADDTOCOMS ADDTOCOM ADDTOCOM1 ADDNEWCOM
       (NOLINKFNS . T)
       (SPECVARS COMSNAME)
       (ENTRIES ADDTOFILE ADDTOCOMS ADDTOFILES? ADDTOCOM1))

(BLOCK%: INFILECOMS? INFILECOMS? INFILECOMTAIL INFILECOMS INFILECOM INFILECOMSVAL INFILECOMSVALS 
       INFILEPAIRS INFILECOMSMACRO IFCPROPS IFCEXPRTYPE IFCPROPSCAN IFCDECLARE
       (LOCALFREEVARS NAME LITERALS VAL TYPE ONFILETYPE ORIGFLG)
       INFILECOMSPROP)

(BLOCK%: NIL MAKEFILE (LOCALVARS . T)
       (SPECVARS FILE OPTIONS REPRINTFNS SOURCEFILE FILETYPE FILEDATES CHANGES))

(BLOCK%: ADDFILE ADDFILE ADDFILE0)

(BLOCK%: FILEPKGCHANGES FILEPKGCHANGES (NOLINKFNS . T))

(BLOCK%: NIL ALISTS.WHENCHANGED CHANGECALLERS CLEANUP CLEARCLISPARRAY COMPARE COMPAREDEFS 
       COMPILEFILES COMPILEFILES0 CONTINUEDIT COPYDEF DEFAULTMAKENEWCOM DELFROMFILES EDITDEF 
       EXPRESSIONS.WHENCHANGED FILECOMS FILECOMSLST FILEFNSLST FILEPKGCOM FILEPKGCOMPROPS FILEPKGTYPE
       FILES? FILES?1 GETFILEPKGTYPE HASDEF INFILECOMTAIL LOADDEF MAKEALISTCOMS MAKEFILE1 MAKEFILES 
       MAKEFILESCOMS MAKELISPXMACROSCOMS MAKENEWCOM MAKEPROPSCOMS MAKEUSERMACROSCOMS MARKASCHANGED 
       MOVETOFILE POSTEDITPROPS PREEDITFN PRETTYDEFMACROS PROPS.WHENCHANGED PUTDEF RENAME SAVEDEF 
       SAVEPUT SEARCHPRETTYTYPELST SHOWDEF SMASHFILECOMS TYPESOF UNMARKASCHANGED UNSAVEDEF 
       UPDATEFILES (GLOBALVARS %#UNDOSAVES SYSFILES MARKASCHANGEDSTATS COMPILE.EXT EDITMACROS 
                          EDITLOADFNSFLG LOADOPTIONS)
       (LOCALVARS . T))

(BLOCK%: DELDEF DELDEF DELFROMLIST (NOLINKFNS . T))

(BLOCK%: GETDEF GETDEF DWIMDEF GETDEFCOM GETDEFCOM0 GETDEFERR GETDEFCURRENT GETDEFFROMFILE 
       GETDEFSAVED (RETFNS GETDEFCOM)
       (NOLINKFNS . T)
       (GLOBALVARS NOT-FOUNDTAG))
)
(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 

(ADDTOVAR NLAMA \DUMPEXPORTS MAKEUSERMACROSCOMS MAKEPROPSCOMS MAKELISPXMACROSCOMS MAKEFILESCOMS 
                          MAKEALISTCOMS LISTFILES COMPILEFILES CLEANUP FILEPKGCOMPROPS 
                          PRETTYDEFMACROS)

(ADDTOVAR NLAML )

(ADDTOVAR LAMA FILEPKGTYPE FILEPKGCOM FILEPKGCHANGES)
)
(PUTPROPS FILEPKG COPYRIGHT ("Venue & Xerox Corporation" T 1982 1983 1984 1985 1986 1987 1988 1989 
1990 1991 1992 1993))
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (21965 22767 (SEARCHPRETTYTYPELST 21975 . 22397) (PRETTYDEFMACROS 22399 . 22586) (
FILEPKGCOMPROPS 22588 . 22765)) (23573 49781 (CLEANUP 23583 . 24321) (COMPILEFILES 24323 . 24507) (
COMPILEFILES0 24509 . 24830) (CONTINUEDIT 24832 . 25550) (MAKEFILE 25552 . 37194) (FILECHANGES 37196
 . 38466) (FILEPKG.MERGECHANGES 38468 . 38920) (FILEPKG.CHANGEDFNS 38922 . 39183) (MAKEFILE1 39185 . 
43455) (COMPILE-FILE? 43457 . 44079) (MAKEFILES 44081 . 44771) (ADDFILE 44773 . 46270) (ADDFILE0 46272
 . 49263) (LISTFILES 49265 . 49779)) (50471 77462 (FILEPKGCHANGES 50481 . 51098) (GETFILEPKGTYPE 51100
 . 52893) (MARKASCHANGED 52895 . 53740) (FILECOMS 53742 . 53998) (WHEREIS 54000 . 55420) (
SMASHFILECOMS 55422 . 55587) (FILEFNSLST 55589 . 55751) (FILECOMSLST 55753 . 56006) (UPDATEFILES 56008
 . 58367) (INFILECOMS? 58369 . 60272) (INFILECOMTAIL 60274 . 61414) (INFILECOMS 61416 . 61509) (
INFILECOM 61511 . 71720) (INFILECOMSVALS 71722 . 72049) (INFILECOMSVAL 72051 . 73053) (INFILECOMSPROP 
73055 . 73440) (IFCPROPS 73442 . 73963) (IFCEXPRTYPE 73965 . 74278) (IFCPROPSCAN 74280 . 75333) (
IFCDECLARE 75335 . 76646) (INFILEPAIRS 76648 . 76807) (INFILECOMSMACRO 76809 . 77460)) (77497 97479 (
FILES? 77507 . 78549) (FILES?1 78551 . 79002) (FILES?PRINTLST 79004 . 79413) (ADDTOFILES? 79415 . 
89396) (ADDTOFILE 89398 . 89957) (WHATIS 89959 . 91025) (ADDTOCOMS 91027 . 91923) (ADDTOCOM 91925 . 
94430) (ADDTOCOM1 94432 . 95104) (ADDNEWCOM 95106 . 95827) (MAKENEWCOM 95829 . 96733) (
DEFAULTMAKENEWCOM 96735 . 97477)) (97549 99307 (MERGEINSERT 97559 . 99003) (MERGEINSERT1 99005 . 99305
)) (100438 105565 (DELFROMFILES 100448 . 100919) (DELFROMCOMS 100921 . 101897) (DELFROMCOM 101899 . 
104099) (DELFROMCOM1 104101 . 104597) (REMOVEITEM 104599 . 105022) (MOVETOFILE 105024 . 105563)) (
105783 107276 (SAVEPUT 105793 . 107274)) (107401 110819 (UNMARKASCHANGED 107411 . 108172) (PREEDITFN 
108174 . 109124) (POSTEDITPROPS 109126 . 110063) (POSTEDITALISTS 110065 . 110817)) (110968 120538 (
ALISTS.GETDEF 110978 . 111228) (ALISTS.WHENCHANGED 111230 . 111566) (CLEARCLISPARRAY 111568 . 112033) 
(EXPRESSIONS.WHENCHANGED 112035 . 112272) (MAKEALISTCOMS 112274 . 112690) (MAKEFILESCOMS 112692 . 
113381) (MAKELISPXMACROSCOMS 113383 . 114052) (MAKEPROPSCOMS 114054 . 114321) (MAKEUSERMACROSCOMS 
114323 . 115022) (PROPS.WHENCHANGED 115024 . 115364) (FILEGETDEF.LISPXMACROS 115366 . 116066) (
FILEGETDEF.ALISTS 116068 . 116423) (FILEGETDEF.RECORDS 116425 . 116864) (FILEGETDEF.PROPS 116866 . 
117278) (FILEGETDEF.MACROS 117280 . 117716) (FILEGETDEF.VARS 117718 . 117992) (FILEGETDEF.FNS 117994
 . 118687) (FILEPKGCOMS.PUTDEF 118689 . 119853) (FILES.PUTDEF 119855 . 120316) (VARS.PUTDEF 120318 . 
120431) (FILES.WHENCHANGED 120433 . 120536)) (122562 126276 (RENAME 122572 . 123526) (CHANGECALLERS 
123528 . 126274)) (126277 154034 (SHOWDEF 126287 . 126696) (COPYDEF 126698 . 127705) (GETDEF 127707 . 
129362) (GETDEFCOM 129364 . 130186) (GETDEFCOM0 130188 . 130832) (GETDEFCURRENT 130834 . 133591) (
GETDEFERR 133593 . 134298) (GETDEFFROMFILE 134300 . 136425) (GETDEFSAVED 136427 . 137024) (PUTDEF 
137026 . 137538) (EDITDEF 137540 . 138283) (DEFAULT.EDITDEF 138285 . 141125) (EDITDEF.FILES 141127 . 
141293) (LOADDEF 141295 . 141432) (DWIMDEF 141434 . 141922) (DELDEF 141924 . 143539) (DELFROMLIST 
143541 . 143758) (HASDEF 143760 . 146314) (GETFILEDEF 146316 . 146659) (SAVEDEF 146661 . 147523) (
UNSAVEDEF 147525 . 148040) (COMPAREDEFS 148042 . 149280) (COMPARE 149282 . 149770) (TYPESOF 149772 . 
154032)) (154101 159142 (FIXEDITDATE 154111 . 157614) (EDITDATE? 157616 . 159140)) (159561 163157 (
FILEPKGCOM 159571 . 161668) (FILEPKGTYPE 161670 . 163155)) (175194 181027 (FINDCALLERS 175204 . 175447
) (EDITCALLERS 175449 . 178292) (EDITFROMFILE 178294 . 180652) (FINDATS 180654 . 180790) (LOOKIN 
180792 . 181025)) (181028 182027 (SEPRCASE 181038 . 182025)) (182544 185856 (IMPORTFILE 182554 . 
183184) (IMPORTEVAL 183186 . 183738) (IMPORTFILESCAN 183740 . 184037) (CHECKIMPORTS 184039 . 184667) (
GATHEREXPORTS 184669 . 185412) (\DUMPEXPORTS 185414 . 185854)) (186194 186992 (CLEARFILEPKG 186204 . 
186990)))))
STOP
