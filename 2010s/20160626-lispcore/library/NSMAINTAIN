(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)(FILECREATED "12-Jun-90 10:29:28" {DSK}<usr>local>lde>lispcore>library>NSMAINTAIN.;3 46263        changes to%:  (FILES DES)                    (VARS NSMAINTAINCOMS)      previous date%: "21-Aug-89 18:30:21" {DSK}<usr>local>lde>lispcore>library>NSMAINTAIN.;2)(* ; "Copyright (c) 1985, 1986, 1987, 1989, 1990 by Venue & Xerox Corporation.  All rights reserved.")(PRETTYCOMPRINT NSMAINTAINCOMS)(RPAQQ NSMAINTAINCOMS       ((COMS                                                (* ; "Main entry and utility fns")              (FNS NSMAINTAIN \NSMT.HELP \NSMT.READFNAME \NSMT.LOOKUP \NSMT.COLLECT.NAMES                    \NSMT.GET.REMARK \NSMT.GET.PASSWORD \NSMT.LOGIN \NSMT.CHANGE.DOMAIN                    \NSMT.PRINT.LIST \NSMT.PRINT.OBJECTS \NSMT.PROCESS.LIST \NSMT.SHOW.RESULT))        (COMS                                                (* ; "Ordinary user commands")              (FNS \NSMT.CHANGE.PASSWORD \NSMT.DESCRIBE.GROUP \NSMT.DESCRIBE.OBJECT                    \NSMT.DESCRIBE.PROPERTY \NSMT.LIST.OBJECTS \NSMT.LIST.CLEARINGHOUSES                    \NSMT.LIST.SERVERS \NSMT.SHOW.DETAILS \NSMT.GROUP.FILTER \NSMT.LIST.ADMINISTRATORS                   \NSMT.LIST.DOMAINS \NSMT.TYPE.ENTRY \NSMT.TYPE.MEMBERS))        (COMS                                                (* ; "Administrator commands")              (FNS \NSMT.ADD.ALIAS \NSMT.ADD.GROUP \NSMT.ADD.USER \NSMT.CHANGE.ADMINISTRATORS                    \NSMT.CHANGE.FORWARDING \NSMT.CHANGE.GROUP.COMPONENT \NSMT.CHANGE.REMARK                    \NSMT.DESCRIPTIVE.PROPS \NSMT.REMOVE.ALIAS \NSMT.REMOVE.OBJECT \NSMT.REMOVE.USER))        (FILES (SYSLOAD)               DES AUTHENTICATION)        (VARS *NSMAINTAIN-COMMANDS* *NSMAINTAIN-ABORT-ITEM*)        (ADDVARS (CH.PROPERTIES (ALIAS 1))               (*NSMAINTAIN-DESCRIPTIVE-PROPERTIES* 10000 10001 10002 10003 10004 10005 10006 10007                       10008 10009 10010 10011 10012 10013 10014 10015 10016 10017 10018 10019 10020                       10021 10023 10024)               (*NSMAINTAIN-IGNORE-PROPERTIES* 6 7 10027 20003 20002 20101)               (*NSMAINTAIN-PROPERTY-FORMATS* (4 CLEARINGHOUSE . NETWORK.ADDRESS.LIST)                      (8 RECORD (SIMPLE BOOLEAN)                         (STRONG BOOLEAN))                      (30 . NSNAME)                      (31 CLEARINGHOUSE . MAILBOX.VALUES)                      (10000 . STRING)                      (10001 . STRING)                      (10002 . STRING)                      (10003 . STRING)                      (10004 . STRING)                      (10005 . STRING)                      (10006 . STRING)                      (10007 . STRING)                      (10008 . STRING)                      (10009 . STRING)                      (10010 . STRING)                      (10011 . STRING)                      (10012 . STRING)                      (10013 . STRING)                      (10014 . STRING)                      (10015 . STRING)                      (10016 . STRING)                      (10017 . STRING)                      (10018 . STRING)                      (10019 . STRING)                      (10020 . STRING)                      (10021 . STRING)                      (10022 . STRING)                      (10023 . STRING)                      (10024 . STRING)                      (10029 . STRING)                      (10030 . STRING)                      (10032 . STRING)                      (10034 . STRING)                      (10035 . STRING)                      (15002 . STRING)                      (20000 CLEARINGHOUSE . USERDATA.VALUE)                      (20001 GAP . RS232CData)                      (20006 SEQUENCE NSNAME)                      (20007 . NSNAME)                      (20102 GAP . RS232CBack)                      (29965 . STRING)                      (30005 . NSNAME))               (*NSMAINTAIN-MEMBER-PROPERTIES* 20006))        (DECLARE%: EVAL@COMPILE DONTCOPY (GLOBALVARS *NSMAINTAIN-COMMANDS* *NSMAINTAIN-ABORT-ITEM*                                                 *NSMAINTAIN-DESCRIPTIVE-PROPERTIES*                                                 *NSMAINTAIN-IGNORE-PROPERTIES*                                                 *NSMAINTAIN-PROPERTY-FORMATS*                                                 *NSMAINTAIN-MEMBER-PROPERTIES* CH.PROPERTIES)               [P (CL:PROCLAIM '(CL:SPECIAL *USER* *LASTDOMAIN* *LASTNAME* *LASTGROUP* *LASTLIST*                                        *LASTSTRING* *SERVERTYPES* *ALLTYPES* *DEFAULTDOMAIN*                                        *REAL-NAME-CACHE*]               (LOCALVARS . T))))(* ; "Main entry and utility fns")(DEFINEQ(NSMAINTAIN(LAMBDA NIL (* ; "Edited 21-Aug-89 16:36 by bvm") (PROG ((*STANDARD-OUTPUT* (\GETSTREAM T (QUOTE OUTPUT))) (CREDS (\INTERNAL/GETPASSWORD (QUOTE |NS::|))) (*REAL-NAME-CACHE* (HASHARRAY 10 NIL (FUNCTION (LAMBDA (OBJECT) (* ; "Use first part of name to produce hash bits") (STRING-EQUAL-HASHBITS (fetch NSOBJECT of OBJECT)))) (FUNCTION EQUAL.CH.NAMES))) *USER* *LASTNAME* *DEFAULTDOMAIN* *LASTDOMAIN* *LASTGROUP* *LASTSTRING* *LASTLIST* *SERVERTYPES* *ALLTYPES* FULLNAME) (* ; "*STANDARD-OUTPUT* setting is to make sure T for FORMAT and PRINTOUT are the same (yecch).") (SETQ FULLNAME (CH.LOOKUP.OBJECT (SETQ *USER* (PARSE.NSNAME (CAR CREDS))))) (CL:FORMAT T "[Default login:  ~A~:[ (not a valid name)~;~];~%% Default domain: ~A]~%%" (NSNAME.TO.STRING (OR FULLNAME *USER*) T) FULLNAME (NSNAME.TO.STRING (SETQ *LASTDOMAIN* (SETQ *DEFAULTDOMAIN* (create NSNAME NSDOMAIN _ CH.DEFAULT.DOMAIN NSORGANIZATION _ CH.DEFAULT.ORGANIZATION))) T)) (if (AND (SETQ *LASTNAME* FULLNAME) (NOT (EQUAL.CH.NAMES *USER* FULLNAME))) then (* ; "Canonical name different from current login, so be helpful and canonize") (RPLACA CREDS (NSNAME.TO.STRING (SETQ *LASTNAME* (SETQ *USER* FULLNAME)) T))) (NILL (SETQ CREDS NIL)) (* ; "Just to avoid leaving these on the stack (NILL so compiler doesn't throw it away)") (do (TERPRI T) repeatwhile (NULL (ERSETQ (bind CMD while (SETQ CMD (ASKUSER NIL NIL "CH: " *NSMAINTAIN-COMMANDS* T NIL (QUOTE (AUTOCOMPLETEFLG T)))) do (COND ((LISTP CMD) (APPLY (CAR CMD) (CDR CMD))) (T (CL:FUNCALL CMD))) (TERPRI T))))))))(\NSMT.HELP(LAMBDA NIL (* ; "Edited 21-Aug-89 18:14 by bvm") (* ;; "Give more compact help than ASKUSER's default") (PRINTOUT T T T "  You need type only the initial letters of most command words.  Use Control-E to abort a command." T T) (LET ((LINELEN (LINELENGTH NIL T)) *LASTSTRING* LASTN EXPLAINSTRING UNPRINTED CMD LEN TAB) (for ITEM in *NSMAINTAIN-COMMANDS* unless (EQ (CHCON1 (SETQ CMD (CAR ITEM))) (CHARCODE ?)) do (* ; "Handle all commands but ?") (if (AND (NOT (SETQ EXPLAINSTRING (LISTGET ITEM (QUOTE EXPLAINSTRING)))) *LASTSTRING* (> (SETQ LEN (NCHARS CMD)) LASTN) (STRING-EQUAL *LASTSTRING* CMD :END1 LASTN :END2 LASTN)) then (* ; "This command has same prefix as previous one") (if UNPRINTED then (PRINTOUT T (SUBSTRING *LASTSTRING* 1 LASTN) "{" (SUBSTRING *LASTSTRING* (ADD1 LASTN))) (SETQ UNPRINTED NIL) (SETQ TAB (ADD1 (POSITION T))) (* ; "An aesthetically pleasing tab stop puts command directly under next command")) (PRIN1 "," T) (if (> (+ (POSITION T) (- LEN LASTN) 3) LINELEN) then (* ; "No room left on this line, so tab to reasonable place.") (TERPRI T) (TAB TAB NIL T)) (PRIN1 (SUBSTRING CMD LASTN) T) else (* ; "New prefix.") (if *LASTSTRING* then (* ; "Clean up previous command") (PRINTOUT T (if UNPRINTED then *LASTSTRING* else "}") T)) (if EXPLAINSTRING then (* ; "Explicit thing here for ?") (PRINTOUT T EXPLAINSTRING T) (SETQ *LASTSTRING* NIL) elseif (SETQ LASTN (STRPOS " " CMD)) then (SETQ *LASTSTRING* CMD) (SETQ UNPRINTED T) else (PRINTOUT T CMD T) (SETQ *LASTSTRING* NIL)))) (if *LASTSTRING* then (* ; "Take care of the last line") (PRINTOUT T (if UNPRINTED then *LASTSTRING* else "}") T)))))(\NSMT.READFNAME(LAMBDA (PROMPT DEFAULT DOMAINFLG ...FLG CHECK *OK) (* ; "Edited 21-Aug-89 17:31 by bvm") (PROG ((COLON ":") NAME COLPOS FULLNAME REALNAME) RETRY (COND ((NULL (SETQ NAME (PROMPTFORWORD PROMPT (COND ((AND DEFAULT (TYPENAMEP DEFAULT (QUOTE NSNAME))) (* ; "Make it fully qualified") (NSNAME.TO.STRING DEFAULT T)) (T DEFAULT)) NIL T NIL NIL (CHARCODE (EOL))))) (printout T " xxx" T) (* ; "aborted") (RETURN NIL))) (SETQ FULLNAME (COND ((AND (SETQ COLPOS (STRPOS COLON NAME)) (NEQ COLPOS (NCHARS NAME))) (SETQ COLPOS (STRPOS COLON NAME (ADD1 COLPOS))) (* ; "Find second colon") (COND (DOMAINFLG (* ; "Wants domain name--a 2-part name") (COND (COLPOS (* ; "too many colons") (PRINTOUT T " Invalid domain" T) (RETURN NIL)) (T (PARSE.NSNAME NAME 2 *DEFAULTDOMAIN*)))) (T (COND ((NOT COLPOS) (* ; "Org defaulted") (printout T COLON (fetch NSORGANIZATION of *DEFAULTDOMAIN*))) ((EQ COLPOS (NCHARS NAME)) (* ; "Trailing colon after domain") (printout T (fetch NSORGANIZATION of *DEFAULTDOMAIN*)))) (PARSE.NSNAME NAME 3 *DEFAULTDOMAIN*)))) (T (* ; "Completely unqualified (or only a trailing colon)") (COND (COLPOS (* ; "User typed, e.g., %"Fred:%"") (SETQ NAME (SUBSTRING NAME 1 -2))) (T (PRIN1 COLON T))) (COND (DOMAINFLG (printout T (fetch NSORGANIZATION of *DEFAULTDOMAIN*)) (create NSNAME using *DEFAULTDOMAIN* NSDOMAIN _ NAME)) (T (printout T (fetch NSDOMAIN of *DEFAULTDOMAIN*) COLON (fetch NSORGANIZATION of *DEFAULTDOMAIN*)) (create NSNAME using *DEFAULTDOMAIN* NSOBJECT _ NAME)))))) (COND ((STRPOS "*" NAME) (COND ((SELECTQ *OK (:ANY (* ; "Any old * is ok") NIL) (NIL (* ; "No * is ok") T) (PROGN (* ; "* permitted in first part only") (OR (STRPOS "*" (fetch NSORGANIZATION of FULLNAME)) (AND (NOT DOMAINFLG) (STRPOS "*" (fetch NSDOMAIN of FULLNAME)))))) (PRINTOUT T " ... Invalid use of *" T) (SETQ DEFAULT FULLNAME) (GO RETRY)))) (CHECK (* ; "Canonicalize the name") (SETQ REALNAME (\NSMT.LOOKUP FULLNAME)) (COND ((NULL REALNAME) (COND ((EQ CHECK :OK) (printout T " (non-existent name)")) (T (printout T " ... No such name.") (COND ((NOT (COND ((NEQ CHECK :CONFIRM) (* ; "Must be valid name") (TERPRI T) NIL) (T (* ; "Accept non-names") (CL:Y-OR-N-P " Use it anyway? ")))) (SETQ DEFAULT FULLNAME) (GO RETRY)))))) ((NOT (EQUAL.CH.NAMES FULLNAME REALNAME)) (* ; " show real name") (printout T " = " (NSNAME.TO.STRING (SETQ FULLNAME REALNAME) T)))))) (COND (...FLG (PRIN1 " ... " T))) (RETURN FULLNAME))))(\NSMT.LOOKUP(LAMBDA (NAME) (* ; "Edited 21-Aug-89 17:31 by bvm") (* ;; "Like CH.LOOKUP.OBJECT but caches results (well, at least the positive ones).") (OR (TYPEP NAME (QUOTE NSNAME)) (SETQ NAME (PARSE.NSNAME NAME))) (LET ((CACHE (GETHASH NAME *REAL-NAME-CACHE*)) FULLNAME) (if CACHE then (if (EQ CACHE T) then NIL else CACHE) elseif (SETQ FULLNAME (CH.LOOKUP.OBJECT NAME)) then (PUTHASH NAME FULLNAME *REAL-NAME-CACHE*) FULLNAME))))(\NSMT.COLLECT.NAMES(LAMBDA (PROMPT CHECK *OK) (* ; "Edited 14-Aug-87 15:14 by bvm:") (* ;; "Prompt for an arbitrary number of names.  CHECK and *OK are the corresponding args to \nsmt.readfname.") (bind NAME while (SETQ NAME (PROGN (TERPRI T) (\NSMT.READFNAME PROMPT NIL NIL NIL CHECK *OK))) collect NAME)))(\NSMT.GET.REMARK(LAMBDA (DEFAULT) (* ; "Edited 11-Aug-87 12:24 by bvm:") (* ;; "Prompt for a remark (an arbitrary string used to describe an object).  DEFAULT if any is usually the previous remark.") (PROMPTFORWORD "Remark (terminate with CR):" DEFAULT NIL T NIL NIL (CHARCODE (CR)))))(\NSMT.GET.PASSWORD(LAMBDA (PROMPT) (* ; "Edited 11-Aug-87 13:39 by bvm:") (* ;; "Read a password, prompting with PROMPT.  Ask user to retry password to verify that it was typed correctly.  Loop if the retype mismatches the original.  Return NIL if user declines to enter a password in the first place.") (PROG (PASS) LP (COND ((NULL (SETQ PASS (PROMPTFORWORD PROMPT NIL NIL T (QUOTE *)))) (RETURN NIL)) ((STREQUAL PASS (PROMPTFORWORD " (retype password)" NIL NIL T (QUOTE *))) (RETURN PASS)) (T (PRINTOUT T T "Mismatch.  Try again." T) (SETQ PROMPT "Password:") (GO LP))))))(\NSMT.LOGIN(LAMBDA NIL (* ; "Edited 18-Aug-89 17:20 by bvm") (bind LOGINFO FULLNAME until (OR (NULL (SETQ LOGINFO (\INTERNAL/GETPASSWORD (QUOTE |NS::|) T))) (COND ((SETQ FULLNAME (CH.LOOKUP.OBJECT (SETQ *USER* (PARSE.NSNAME (CAR LOGINFO) 3 *DEFAULTDOMAIN*)))) (RPLACA LOGINFO (NSNAME.TO.STRING (SETQ *USER* FULLNAME) T)) (* ; "Make login canonical") (\NSMT.SHOW.RESULT (NS.AUTHENTICATE (NS.MAKE.SIMPLE.CREDENTIALS LOGINFO)))) (T (CL:FORMAT T "  Invalid name ~A~%%" (NSNAME.TO.STRING *USER* T)) NIL))))))(\NSMT.CHANGE.DOMAIN(LAMBDA NIL (* ; "Edited 18-Aug-89 17:12 by bvm") (LET ((DOMAIN (\NSMT.READFNAME " (for name entry) to be:" *DEFAULTDOMAIN* T))) (COND (DOMAIN (TERPRI T) (COND ((CL:Y-OR-N-P "Set this default globally as well (i.e. for use outside Maintain)? ") (SETQ CH.DEFAULT.DOMAIN (fetch NSDOMAIN of DOMAIN)) (SETQ CH.DEFAULT.ORGANIZATION (fetch NSORGANIZATION of DOMAIN)))) (SETQ *LASTDOMAIN* (SETQ *DEFAULTDOMAIN* DOMAIN)))))))(\NSMT.PRINT.LIST(LAMBDA (LST PREFIX) (* ; "Edited 27-Jul-87 13:10 by bvm:") (COND ((EQ (CAR LST) (QUOTE ERROR)) (\NSMT.SHOW.RESULT LST)) (T (COND (PREFIX (PRINTOUT T .FONT BOLDFONT PREFIX .FONT DEFAULTFONT))) (COND ((NULL LST) (PRINTOUT T "(none)")) (T (MAPRINT LST T NIL NIL ", "))) (TERPRI T)))))(\NSMT.PRINT.OBJECTS(LAMBDA (OBJECTS) (* ; "Edited 18-Aug-89 17:12 by bvm") (for OBJ in OBJECTS bind *LASTDOMAIN* LASTORG do (COND ((AND *LASTDOMAIN* (STRING-EQUAL (fetch NSDOMAIN of OBJ) *LASTDOMAIN*) (STRING-EQUAL (fetch NSORGANIZATION of OBJ) LASTORG)) (PRINTOUT T ", ")) (T (PRINTOUT T T "[In " .FONT BOLDFONT (SETQ *LASTDOMAIN* (fetch NSDOMAIN of OBJ)) ":" (SETQ LASTORG (fetch NSORGANIZATION of OBJ)) .FONT DEFAULTFONT "] "))) (PRIN1 (fetch NSOBJECT of OBJ) T))))(\NSMT.PROCESS.LIST(LAMBDA (ITEMS DOMAIN LISTFN) (* ; "Edited 18-Aug-89 17:12 by bvm") (* ;; "Display a list of Clearinghouse objects.  OBJECTS is the result of some sort of listing call.  If the result is a list of strings, DOMAIN is supplied so that future %"Show Details%" commands can use it.  LISTFN is a function to call to print the list; it returns a possibly new list of objects to be saved for later.") (COND ((EQ (CAR ITEMS) (QUOTE ERROR)) (\NSMT.SHOW.RESULT ITEMS)) (T (COND (LISTFN (SETQ ITEMS (CL:FUNCALL LISTFN ITEMS))) (T (\NSMT.PRINT.LIST ITEMS))) (COND (ITEMS (* ; "Save list for Show Details command.") (SETQ *LASTLIST* (CONS (AND DOMAIN (SETQ *LASTDOMAIN* (create NSNAME using DOMAIN NSOBJECT _ NIL))) ITEMS))))))))(\NSMT.SHOW.RESULT(LAMBDA (RESULT PART FIRST SECOND) (* ; "Edited 21-Aug-89 17:14 by bvm") (* ;; "Used to show the outcome of a typical clearinghouse operation.  If RESULT is T or NIL, it succeeded, otherwise we print an error code.  FIRST and SECOND, if non-NIL, are the actual names we used in the call, in case error has a FIRST or SECOND identification.") (COND ((OR (EQ RESULT T) (NULL RESULT)) (printout T " done" T) (* ; "Return T for success") T) (T (COND (PART (PRINTOUT T " " PART))) (PRINTOUT T " failed: ") (if (EQ (CAR (LISTP RESULT)) (QUOTE ERROR)) then (PRINTOUT T (CADDR RESULT)) (LET ((CULPRIT (CASE (CADDDR RESULT) (FIRST FIRST) (SECOND SECOND)))) (if CULPRIT then (PRINTOUT T " " CULPRIT))) else (PRINTOUT T RESULT)) (TERPRI T) NIL)))))(* ; "Ordinary user commands")(DEFINEQ(\NSMT.CHANGE.PASSWORD(LAMBDA NIL (* ; "Edited 18-Aug-89 17:23 by bvm") (LET ((NAME (\NSMT.READFNAME " for user:" (NSNAME.TO.STRING *USER* T))) PASS) (COND ((NULL NAME) NIL) ((NULL (SETQ PASS (\NSMT.GET.PASSWORD " to be:"))) (printout T " xxx" T)) (T (PRIN1 "..." T) (COND ((NULL (SETQ NAME (CH.LOOKUP.OBJECT NAME))) (PRINTOUT T " no such name." T)) ((EQUAL.CH.NAMES *USER* (SETQ *LASTNAME* (SETQ *LASTSTRING* NAME))) (* ; "Changing own password") (COND ((\NSMT.SHOW.RESULT (AS.CHANGE.OWN.PASSWORDS (\ENCRYPT.PWD (CONCAT PASS)))) (\INTERNAL/SETPASSWORD (QUOTE |NS::|) (CONS (NSNAME.TO.STRING NAME T) PASS))))) (T (* ; "Changing someone else's password.  Only way to do this is to delete the old keys and create new ones.") (\NSMT.SHOW.RESULT (AS.REPLACE.PASSWORDS NAME (\ENCRYPT.PWD (CONCAT PASS)))))))))))(\NSMT.DESCRIBE.GROUP(LAMBDA (NAME PROPS EXTRA BRIEFLY) (* ; "Edited 31-Jul-87 11:36 by bvm:") (COND (EXTRA (PRINTOUT T T T NAME " is also a ")) (T (PRINTOUT T " is a "))) (LET ((P (CONSTANT (CH.PROPERTY (QUOTE USERGROUP))))) (COND ((MEMB P PROPS) (CL:FORMAT T "User Group (~A)" (CADR (CH.RETRIEVE.ITEM NAME P (QUOTE STRING)))) (SETQ PROPS (CL:DELETE P PROPS))) (T (PRINTOUT T "group")))) (COND ((NOT BRIEFLY) (TERPRI T) (\NSMT.PRINT.LIST (CH.RETRIEVE.PROPERTY.ACL NAME (QUOTE MEMBERS) (QUOTE Administrators)) "Owners: ") (\NSMT.PRINT.LIST (CH.RETRIEVE.PROPERTY.ACL NAME (QUOTE MEMBERS) (QUOTE selfControllers)) "Friends: "))) PROPS))(\NSMT.DESCRIBE.OBJECT(LAMBDA (NAME BRIEFLY) (* ; "Edited 18-Aug-89 17:12 by bvm") (* ;; "Identify name by type and show its interesting properties.") (PROG ((NAME&PROPS (CH.LIST.PROPERTIES NAME)) MAINPROPS PROPS ALIASES DESCR FORWARD GROUPP) (COND ((EQ (CAR NAME&PROPS) (QUOTE ERROR)) (RETURN (\NSMT.SHOW.RESULT NAME&PROPS))) (T (SETQ NAME (CAR NAME&PROPS)))) (FRESHLINE T) (printout T T .FONT BOLDFONT (NSNAME.TO.STRING NAME T) .FONT DEFAULTFONT) (SETQ PROPS (CL:NSET-DIFFERENCE (CADR NAME&PROPS) *NSMAINTAIN-IGNORE-PROPERTIES*)) (for P in (SETQ MAINPROPS (CL:INTERSECTION PROPS *NSMAINTAIN-DESCRIPTIVE-PROPERTIES*)) bind GOTSOME do (COND (GOTSOME (printout T T NAME " is also")) (T (* ; "First prop") (printout T " is"))) (printout T " a " (CL:STRING-CAPITALIZE (STRING (OR (CH.NUMBER.TO.PROPERTY P) P)))) (COND ((SETQ DESCR (CADR (CH.RETRIEVE.ITEM NAME P))) (* ;; "Description of object is stored as string on this descriptive property.  Sometimes the value is null, which is why we didn't pass STRING to CH.RETRIEVE.ITEM.  CONCAT is so that we don't get an ugly line break after the open paren.") (printout T (CONCAT " (" (COURIER.READ.REP DESCR NIL (QUOTE STRING)) ")")))) (SETQ PROPS (CL:DELETE P PROPS))) (COND ((MEMB (CONSTANT (CH.PROPERTY (QUOTE MEMBERS))) PROPS) (COND ((MEMB (CONSTANT (CH.PROPERTY (QUOTE USER))) MAINPROPS) (* ; "Both USER and group?  This is kludge to get NS mail forwarding.") (SETQ PROPS (CL:DELETE (CONSTANT (CH.PROPERTY (QUOTE USERGROUP))) PROPS)) (* ; "describes the forwarding, but is pretty uninteresting") (SETQ FORWARD T)) ((NULL MAINPROPS) (SETQ PROPS (\NSMT.DESCRIBE.GROUP NAME PROPS NIL BRIEFLY)) (SETQ GROUPP 0)) (T (SETQ GROUPP T))) (SETQ PROPS (CL:DELETE (CONSTANT (CH.PROPERTY (QUOTE MEMBERS))) PROPS)))) (COND ((NOT BRIEFLY) (TERPRI T) (COND ((SETQ ALIASES (CH.LIST.ALIASES.OF NAME)) (\NSMT.PRINT.LIST ALIASES "Aliases: "))) (for P in PROPS do (\NSMT.DESCRIBE.PROPERTY NAME P)) (COND (FORWARD (\NSMT.PRINT.LIST (CH.RETRIEVE.MEMBERS NAME) "Forwarding: "))))) (COND ((EQ GROUPP T) (\NSMT.DESCRIBE.GROUP NAME PROPS T BRIEFLY))) (RETURN (SETQ *LASTSTRING* (COND (GROUPP (SETQ *LASTGROUP* NAME)) (T (SETQ *LASTNAME* NAME))))))))(\NSMT.DESCRIBE.PROPERTY(LAMBDA (FNAME CHP) (* ; "Edited 13-Apr-89 11:34 by Briggs") (* ;; "Called by \NSMT.TYPE.ENTRY to show one particular property.") (LET ((PROPNAME (CH.NUMBER.TO.PROPERTY CHP)) (VAL (COND ((MEMB CHP *NSMAINTAIN-MEMBER-PROPERTIES*) (CH.RETRIEVE.MEMBERS FNAME CHP)) (T (CADR (CH.RETRIEVE.ITEM FNAME CHP))))) PGM HOW) (PRINTOUT T .FONT BOLDFONT (COND (PROPNAME (CL:STRING-CAPITALIZE (STRING PROPNAME))) (T (PRINTOUT T "Property ") CHP)) ": " .FONT DEFAULTFONT) (COND ((AND (SETQ HOW (CDR (ASSOC CHP *NSMAINTAIN-PROPERTY-FORMATS*))) (NLSETQ (bind PGM while (AND (LISTP HOW) (LITATOM (CDR HOW)) (CDR HOW)) do (* ; "Reduce to a less qualified name") (SETQ HOW (\GET.COURIER.TYPE (SETQ PGM (CAR HOW)) (CDR HOW))) finally (SETQ VAL (COURIER.READ.REP VAL PGM HOW)) (COND ((EQ (CAR (LISTP HOW)) (QUOTE RECORD)) (* ; "make records humanly intelligible") (for PAIR in (CDR HOW) as V in VAL bind (PREFIX _ "[") do (PRIN1 PREFIX T) (PRINTOUT T (CL:STRING-CAPITALIZE (STRING (CAR PAIR))) ": " (SELECTQ (CADR PAIR) (BOOLEAN (CL:IF V "true" "false")) (TIME (GDATE V)) V)) (SETQ PREFIX "; ") finally (PRIN1 "]" T))) (T (PRINTOUT T VAL))))))) (T (* ; "if all else fails, print raw numbers") (PRINTOUT T VAL))) (TERPRI T))))(\NSMT.LIST.OBJECTS(LAMBDA (PROP LISTFN) (* ; "Edited 18-Aug-89 17:12 by bvm") (* ;;; "given a clearinghouse property, lookup all objects with a user-specified pattern that have that property.  Default pattern is * in recent domain.") (LET (PATTERN) (COND ((AND (OR PROP (SETQ PROP (ASKUSER NIL NIL " having property " (OR *ALLTYPES* (SETQ *ALLTYPES* (CONS (QUOTE ("" "any" EXPLAINSTRING "<cr> - list ALL objects" RETURN (QUOTE ALL))) (CONS (QUOTE (* "" EXPLAINSTRING "* - list ALL objects" CONFIRMFLG T RETURN (QUOTE ALL))) (SORT (DREMOVE (QUOTE ALL) (MAPCAR CH.PROPERTIES (FUNCTION CAR)))))))) T))) (SETQ PATTERN (\NSMT.READFNAME " by pattern:" (AND *LASTNAME* (create NSNAME using *LASTNAME* NSOBJECT _ "*")) NIL T NIL T))) (\NSMT.PROCESS.LIST (CH.LIST.OBJECTS PATTERN PROP) PATTERN LISTFN))))))(\NSMT.LIST.CLEARINGHOUSES(LAMBDA NIL (* ; "Edited 21-Aug-89 17:10 by bvm") (DECLARE (USEDFREE *LASTDOMAIN*)) (LET ((DOMAIN (\NSMT.READFNAME " serving domain:" *LASTDOMAIN* T)) (CHSPART "CHServers") SERVERS) (COND (DOMAIN (SETQ *LASTDOMAIN* DOMAIN) (TERPRI T) (SETQ SERVERS (LISTP (CH.RETRIEVE.MEMBERS (create NSNAME NSOBJECT _ (fetch NSDOMAIN of DOMAIN) NSDOMAIN _ (fetch NSORGANIZATION of DOMAIN) NSORGANIZATION _ CHSPART)))) (COND ((EQ (CAR SERVERS) (QUOTE ERROR)) (\NSMT.SHOW.RESULT (COND ((EQ (CADDR SERVERS) (QUOTE NoSuchObject)) (* ; "translate this error") "No Such Domain") (T SERVERS)))) ((SETQ SERVERS (for S in SERVERS collect (COND ((AND (STRING-EQUAL (fetch NSDOMAIN of S) CHSPART) (STRING-EQUAL (fetch NSORGANIZATION of S) CHSPART)) (* ;; "Clearinghouse names are usually of the form server:CHServers:CHServers.  The domain here is thus junk--print the name only.  Hope for not too much confusion if user tries to type name by hand, rather than using Show Details command.") (fetch NSOBJECT of S)) (T (* ; "An aberrant name--punt by printing all full names") (\NSMT.PROCESS.LIST SERVERS) (RETURN NIL))))) (* ; "Show short names, preserve domain for Show Details") (\NSMT.PROCESS.LIST SERVERS (create NSNAME NSDOMAIN _ CHSPART NSORGANIZATION _ CHSPART)))))))))(\NSMT.LIST.SERVERS(LAMBDA NIL (* ; "Edited 18-Aug-89 17:12 by bvm") (* ;; "List Objects specialized to servers.  We offer as choices those properties with SERVICE in their name, plus the oddly generic %"SERVER%".  CLEARINGHOUSE.SERVICE is excluded because its name space doesn't work as you'd expect.") (LET (PROP) (AND (SETQ PROP (ASKUSER NIL NIL " of type " (OR *SERVERTYPES* (SETQ *SERVERTYPES* (CONS *NSMAINTAIN-ABORT-ITEM* (SORT (CONS (QUOTE ("Server" "" RETURN (QUOTE SERVER))) (for P in CH.PROPERTIES when (AND (STRPOS "SERVICE" (CAR P) -7) (NEQ (CAR P) (QUOTE CLEARINGHOUSE.SERVICE))) collect (BQUOTE ((\, (CL:STRING-CAPITALIZE (SUBSTRING (CAR P) 1 -9))) "" RETURN (QUOTE (\, (CAR P))))))) T)))) T)) (\NSMT.LIST.OBJECTS PROP)))))(\NSMT.SHOW.DETAILS(LAMBDA NIL (* ; "Edited 18-Aug-89 17:12 by bvm") (COND ((NULL *LASTLIST*) (PRINTOUT T " (no previous list)" T)) (T (DESTRUCTURING-BIND (DOMAIN . OBJECTS) *LASTLIST* (COND ((NULL (CDR OBJECTS)) (* ; "only one, describe it straight away") (TERPRI T) (\NSMT.DESCRIBE.OBJECT (COND (DOMAIN (create NSNAME using DOMAIN NSOBJECT _ (CAR OBJECTS))) (T (CAR OBJECTS))))) (T (COND ((NOT (STRINGP (CAR OBJECTS))) (* ; "Turn ns names into strings") (RPLACD *LASTLIST* (SETQ OBJECTS (for N in OBJECTS collect (NSNAME.TO.STRING N T)))))) (bind (CMDS _ (CONS *NSMAINTAIN-ABORT-ITEM* OBJECTS)) NAME while (SETQ NAME (PROGN (TERPRI T) (ASKUSER NIL NIL "  name: " CMDS T))) do (\NSMT.DESCRIBE.OBJECT (COND (DOMAIN (create NSNAME using DOMAIN NSOBJECT _ NAME)) (T NAME)))))))))))(\NSMT.GROUP.FILTER(LAMBDA (NAMES) (* ; "Edited 11-Aug-87 15:47 by bvm:") (* ;; "List function for List Objects -- NAMES is a list of objects that have a members prop.  Filter out those that also have a USER prop, assuming that these %"groups%" are merely for forwarding, and print the rest.") (COND ((for NAME in NAMES bind (PREFIX _ " ") unless (CH.RETRIEVE.ITEM NAME (QUOTE USER)) collect (PRINTOUT T PREFIX NAME) (SETQ PREFIX ", ") NAME)) (T (* ; "Print %"none%"") (\NSMT.PRINT.LIST) NIL))))(\NSMT.LIST.ADMINISTRATORS(LAMBDA NIL (* ; "Edited 18-Aug-89 17:12 by bvm") (LET ((DOMAIN (\NSMT.READFNAME " of domain:" *LASTDOMAIN* T T))) (COND (DOMAIN (\NSMT.PROCESS.LIST (CH.RETRIEVE.DOMAIN.ACL (SETQ *LASTDOMAIN* DOMAIN) (QUOTE Administrators))))))))(\NSMT.LIST.DOMAINS(LAMBDA NIL (* ; "Edited 18-Aug-89 17:12 by bvm") (LET ((DOMAIN (\NSMT.READFNAME " by pattern:" (create NSNAME using *LASTDOMAIN* NSDOMAIN _ "*") T T NIL T))) (COND (DOMAIN (\NSMT.PRINT.LIST (CH.LIST.DOMAINS DOMAIN)))))))(\NSMT.TYPE.ENTRY(LAMBDA NIL (* ; "Edited 18-Aug-89 17:12 by bvm") (LET (NAME) (COND ((SETQ NAME (\NSMT.READFNAME " name:" *LASTSTRING* NIL T NIL T)) (\NSMT.DESCRIBE.OBJECT NAME))))))(\NSMT.TYPE.MEMBERS(LAMBDA NIL (* ; "Edited 18-Aug-89 17:12 by bvm") (LET (NAME ITEMS) (DECLARE (USEDFREE *LASTGROUP* *LASTSTRING*)) (COND ((SETQ NAME (\NSMT.READFNAME " of group:" *LASTGROUP* NIL T)) (SETQ *LASTSTRING* NAME) (SETQ ITEMS (LISTP (CH.RETRIEVE.MEMBERS NAME (QUOTE MEMBERS)))) (COND ((EQ (CAR ITEMS) (QUOTE ERROR)) (* ; "Failure.  Translate the %"Missing%" error into English") (\NSMT.SHOW.RESULT (COND ((EQ (CADDR ITEMS) (QUOTE Missing)) "Not A Group") (T ITEMS)))) (T (SETQ *LASTGROUP* NAME) (COND ((NULL ITEMS) (PRIN1 "(No members)" T)) (T (COND ((CDR ITEMS) (CL:FORMAT T " (~D members)~%%" (LENGTH ITEMS)) (\NSMT.PRINT.OBJECTS ITEMS)) (T (* ; "Just one") (PRINTOUT T (CAR ITEMS) T))) (* ; "Save list for Show Details command.") (SETQ *LASTLIST* (CONS NIL ITEMS))))))))))))(* ; "Administrator commands")(DEFINEQ(\NSMT.ADD.ALIAS(LAMBDA NIL (* ; "Edited 18-Aug-89 17:12 by bvm") (LET (OBJECT ALIAS) (COND ((AND (SETQ OBJECT (\NSMT.READFNAME " for object:" *LASTSTRING*)) (LET ((*DEFAULTDOMAIN* (create NSNAME using OBJECT NSOBJECT _ NIL))) (DECLARE (CL:SPECIAL *DEFAULTDOMAIN*)) (* ; "Read the alias by default in the same domain as object") (TERPRI T) (SETQ ALIAS (\NSMT.READFNAME " Alias:" NIL NIL T)))) (OR (\NSMT.SHOW.RESULT (LISTP (SETQ *LASTSTRING* (CH.CREATE.ALIAS ALIAS OBJECT)))) (SETQ *LASTSTRING* OBJECT)))))))(\NSMT.ADD.GROUP(LAMBDA NIL (* ; "Edited 18-Aug-89 17:25 by bvm") (* ;; "Create a new group") (LET (GROUP REMARK RESULT MEMBERS OWNERS FRIENDS) (COND ((NOT (SETQ GROUP (\NSMT.READFNAME "  New group name:" NIL NIL T)))) ((LISTP (SETQ RESULT (CH.CREATE.OBJECT (SETQ *LASTSTRING* (SETQ *LASTGROUP* GROUP))))) (* ; "Failed to create object") (\NSMT.SHOW.RESULT RESULT)) (T (* ;; "Assume if user had access rights to create the object, then calls below don't fail.  Gather all the info before taking the time to call the Clearinghouse, since sometimes these update calls are very slow.") (TERPRI T) (SETQ REMARK (\NSMT.GET.REMARK)) (CL:FORMAT T "~%%~%%Enter names of members, owners and friends, one per line, terminated with a blank line.~%%") (SETQ MEMBERS (\NSMT.COLLECT.NAMES "Member:" :CONFIRM :ANY)) (CL:FORMAT T "~%%(If you enter no owners, the group will be owned by the administrators of ~A.)~%%" (create NSNAME using GROUP NSOBJECT _ NIL)) (SETQ OWNERS (\NSMT.COLLECT.NAMES "Owner:" T :ANY)) (SETQ FRIENDS (\NSMT.COLLECT.NAMES "Friend:" T :ANY)) (TERPRI T) (CH.ADD.ITEM.PROPERTY GROUP (QUOTE USERGROUP) REMARK (QUOTE STRING)) (COND (MEMBERS (PRINTOUT T "Adding members...") (\NSMT.SHOW.RESULT (LISTP (CH.ADD.GROUP.PROPERTY GROUP (QUOTE MEMBERS) MEMBERS T))))) (COND (OWNERS (PRINTOUT T "Adding owners...") (LET ((SELF *USER*)) (* ;; "Have to make user be first owner, because as soon as we add one administrator, we override the default administrators, which means user is no longer empowered to add the rest of the owners!  Stupid @#&#!!@ Clearinghouse design.") (for NAME in OWNERS when (EQUAL.CH.NAMES NAME SELF) do (COND ((NEQ NAME (CAR OWNERS)) (* ; "make it first") (SETQ OWNERS (CONS NAME (REMOVE NAME OWNERS))))) (RETURN) finally (CL:FORMAT T " (including ~A)" (NSNAME.TO.STRING SELF T)) (push OWNERS SELF))) (\NSMT.SHOW.RESULT (for NAME in OWNERS thereis (SETQ $$VAL (LISTP (CH.ADD.MEMBER.TO.PROPERTY.ACL GROUP (QUOTE MEMBERS) (QUOTE Administrators) NAME T))))))) (COND (FRIENDS (PRINTOUT T "Adding friends...") (\NSMT.SHOW.RESULT (for NAME in FRIENDS thereis (SETQ $$VAL (LISTP (CH.ADD.MEMBER.TO.PROPERTY.ACL GROUP (QUOTE MEMBERS) (QUOTE selfControllers) NAME T))))))))))))(\NSMT.ADD.USER(LAMBDA NIL (* ; "Edited 18-Aug-89 17:12 by bvm") (* ;; "Create new user") (LET (NAME PASS ERROR DESC ALIASES) (DECLARE (USEDFREE *LASTNAME* *LASTSTRING*)) (TERPRI T) (COND ((SETQ NAME (\NSMT.READFNAME "New user's name:" *LASTNAME* NIL T)) (SETQ *LASTSTRING* (SETQ *LASTNAME* NAME)) (COND ((LISTP (SETQ ERROR (CH.CREATE.OBJECT NAME))) (* ; "Error") (\NSMT.SHOW.RESULT ERROR)) (T (* ;; "Having created the object, get all the other parts.  We assume that if the creation succeeded, we'll be able to do the rest, so gather all the info first, then do the calls.") (TERPRI T) (SETQ DESC (\NSMT.GET.REMARK)) (SETQ ALIASES (LET ((*DEFAULTDOMAIN* (create NSNAME using NAME NSOBJECT _ NIL))) (DECLARE (CL:SPECIAL *DEFAULTDOMAIN*)) (* ; "Read the aliases by default in the same domain as user") (\NSMT.COLLECT.NAMES "Alias:"))) (COND ((NULL (SETQ PASS (\NSMT.GET.PASSWORD "Initial password:"))) (printout T " (no password stored; use Change Password to create one)" T))) (PRIN1 "... " T) (COND ((SETQ ERROR (LISTP (CH.ADD.ITEM.PROPERTY NAME (QUOTE USER) DESC (QUOTE STRING)))) (\NSMT.SHOW.RESULT ERROR "remark"))) (COND ((for A in ALIASES thereis (SETQ ERROR (LISTP (CH.CREATE.ALIAS A NAME)))) (\NSMT.SHOW.RESULT ERROR "alias"))) (\NSMT.SHOW.RESULT (AND PASS (AS.CREATE.PASSWORDS NAME (\ENCRYPT.PWD PASS))) "password creation"))))))))(\NSMT.CHANGE.ADMINISTRATORS(LAMBDA (CHACCESSFN OPERATION) (* ; "Edited 18-Aug-89 17:12 by bvm") (* ;; "Add/remove a domain administrator") (LET (DOMAIN INDIVIDUAL) (DECLARE (USEDFREE *LASTNAME* *LASTDOMAIN* *LASTSTRING*)) (COND ((AND (SETQ INDIVIDUAL (\NSMT.READFNAME " name:" *LASTNAME*)) (SETQ DOMAIN (\NSMT.READFNAME (SELECTQ OPERATION (ADD " to domain:") (REMOVE " from domain:") (SHOULDNT)) *LASTDOMAIN* T T))) (\NSMT.SHOW.RESULT (CL:FUNCALL CHACCESSFN DOMAIN (QUOTE Administrators) INDIVIDUAL)) (SETQ *LASTSTRING* (SETQ *LASTNAME* INDIVIDUAL)) (SETQ *LASTDOMAIN* DOMAIN))))))(\NSMT.CHANGE.FORWARDING(LAMBDA NIL (* ; "Edited 18-Aug-89 17:12 by bvm") (* ;; "Change the %"Forwarding%" list for a user.  Since NS doesn't really have forwarding, it is faked by giving an object a MEMBERS property--the mail system, finding no mailbox, looks at the members and sends the message to all of them.") (PROG (PROPS GOODPROPS NAME REALNAME RESULT OLDFORWARDING NEWFORWARDING) (DECLARE (USEDFREE *LASTSTRING* *LASTNAME* *LASTGROUP*)) (if (SETQ NAME (\NSMT.READFNAME " for user:" *LASTNAME*)) then (TERPRI T) (SETQ PROPS (CH.LIST.PROPERTIES NAME)) (* ; "returns (realname props)") (if (EQ (SETQ REALNAME (CAR PROPS)) (QUOTE ERROR)) then (* ; "Object does not exist, probably") (RETURN (\NSMT.SHOW.RESULT PROPS))) (if (MEMB (CONSTANT (CH.PROPERTY (QUOTE USER))) (SETQ PROPS (CADR PROPS))) then (* ; "Ok, it's a user") else (PRINTOUT T T REALNAME " is not a User") (if (NULL (SETQ GOODPROPS (\NSMT.DESCRIPTIVE.PROPS PROPS))) then (RETURN (PRINTOUT T ", or any other type I know about." T)) else (PRINTOUT T ", but a " (OR (FIXP (CAR GOODPROPS)) (CL:STRING-CAPITALIZE (CAR GOODPROPS)))) (if (CDR GOODPROPS) then (PRINTOUT T " (also " (CONCATLIST (CDR (for P in (CDR GOODPROPS) join (LIST ", " (OR (FIXP P) (CL:STRING-CAPITALIZE P)))))) ")")) (if (EQ (CAR GOODPROPS) (QUOTE USERGROUP)) then (RETURN (PRINTOUT T "  Groups %"forward%" to their members." T)) elseif (NOT (CL:Y-OR-N-P "Are you sure you want to change the Forwarding? ")) then (RETURN)))) (if (MEMB (CONSTANT (CH.PROPERTY (QUOTE MEMBERS))) PROPS) then (* ; "There's already forwarding, so fetch it") (SETQ OLDFORWARDING (CH.RETRIEVE.MEMBERS REALNAME)) else (PRINTOUT T REALNAME " does not yet have Forwarding." T)) (SETQ *LASTSTRING* (SETQ *LASTNAME* REALNAME)) (PRINTOUT T "Type one or more NS names, separated by commas." T) (SETQ NEWFORWARDING (TTYIN "Forward to: " NIL NIL (QUOTE (STRING NORAISE)) NIL NIL (AND OLDFORWARDING (CONCATLIST (CDR (for NAME in OLDFORWARDING join (LIST ", " (NSNAME.TO.STRING NAME T)))))))) (if (OR (NULL NEWFORWARDING) (NULL (SETQ NEWFORWARDING (bind (START _ 1) COMMA when (> (NCHARS (SETQ NAME (CL:STRING-TRIM (QUOTE (#\Space)) (SUBSTRING NEWFORWARDING START (COND ((SETQ COMMA (STRPOS "," NEWFORWARDING START)) (SUB1 COMMA))))))) 0) collect (* ; "Parse names out from between the commas") (PARSE.NSNAME NAME) repeatwhile (COND (COMMA (SETQ START (ADD1 COMMA)))))))) then (* ; "No new forwarding...delete old?") (if (NULL OLDFORWARDING) then (PRINTOUT T " (not changed)" T) elseif (CL:Y-OR-N-P "Remove forwarding for ~A? " REALNAME) then (SETQ RESULT (CH.DELETE.PROPERTY REALNAME (QUOTE MEMBERS))) (if (EQ (CAR RESULT) (QUOTE ERROR)) then (\NSMT.SHOW.RESULT RESULT) else (PRINTOUT T "Forwarding removed") (if (AND (MEMB (CONSTANT (CH.PROPERTY (QUOTE USERGROUP))) PROPS) (EQ (CAR (SETQ RESULT (CH.DELETE.PROPERTY REALNAME (QUOTE USERGROUP)))) (QUOTE ERROR))) then (* ; "Failed to delete the %"group%" comment") (PRINTOUT T ", but failed to remove the forwarding comment because: " (CADDR RESULT) T) else (PRINTOUT T "." T)))) elseif (AND (EQ (LENGTH OLDFORWARDING) (LENGTH NEWFORWARDING)) (for O in OLDFORWARDING as N in NEWFORWARDING always (* ; "See if the lists are the same.  Could use EQUAL.CH.NAMES, but want to be able to recognize case differences") (AND (CL:STRING= (fetch NSOBJECT of O) (fetch NSOBJECT of N)) (CL:STRING= (fetch NSDOMAIN of O) (fetch NSDOMAIN of N)) (CL:STRING= (fetch NSORGANIZATION of O) (fetch NSORGANIZATION of N))))) then (PRINTOUT T " (not changed)") else (* ;; "Change membership.  There is no command to replace group membership, so the easiest thing when prop already existed is to delete the old one and add the new one") (if (OR (NULL OLDFORWARDING) (NEQ (CAR (SETQ RESULT (CH.DELETE.PROPERTY REALNAME (QUOTE MEMBERS)))) (QUOTE ERROR))) then (SETQ RESULT (CH.ADD.GROUP.PROPERTY REALNAME (QUOTE MEMBERS) NEWFORWARDING T))) (if (EQ (CAR RESULT) (QUOTE ERROR)) then (\NSMT.SHOW.RESULT RESULT) else (PRINTOUT T "Done, forwarding set to ") (\NSMT.PRINT.LIST NEWFORWARDING) (TERPRI T)))))))(\NSMT.CHANGE.GROUP.COMPONENT(LAMBDA (CHACCESSFN OPERATION SELF/LIST) (* ; "Edited 21-Aug-89 17:40 by bvm") (* ;; "Add or remove a member from to/from a group.  CHACCESSFN is the CH function that will make the change, OPERATION is ADD or REMOVE, and SELF/LIST is one of T (self), NIL (general member) or the name of an access list property.") (LET (GROUP INDIVIDUAL RESULT FULLNAME ORIGINAL) (if (AND (OR (EQ SELF/LIST T) (SETQ INDIVIDUAL (\NSMT.READFNAME " name:" *LASTNAME* NIL NIL (COND ((EQ OPERATION (QUOTE REMOVE)) (* ; "Want to be able to remove bogus names if they got on there somehow, so let's do the processing ourselves") NIL) (SELF/LIST (* ; "must be valid ns name") T) (T (* ; "use canonical name, but foreign names ok") :CONFIRM)) :ANY))) (PROGN (if (AND (EQ OPERATION (QUOTE REMOVE)) (NEQ SELF/LIST T)) then (* ; "Do name fixing ourselves so we can keep track of the original (below)") (if (NOT (SETQ FULLNAME (\NSMT.LOOKUP INDIVIDUAL))) then (PRINTOUT T " (non-existent name)") elseif (NOT (EQUAL.CH.NAMES FULLNAME INDIVIDUAL)) then (* ; "name is an alias. ") (SETQ ORIGINAL INDIVIDUAL) (printout T " = " (NSNAME.TO.STRING (SETQ INDIVIDUAL FULLNAME) T)))) (SETQ GROUP (\NSMT.READFNAME (SELECTQ OPERATION (ADD " to group:") (REMOVE " from group:") (SHOULDNT)) *LASTGROUP* NIL T)))) then (* ;; "Ok, here's a name and a group, try the desired operation") (SETQ RESULT (SELECTQ SELF/LIST (T (* ; "adding/removing self") (CL:FUNCALL CHACCESSFN GROUP (QUOTE MEMBERS))) (NIL (* ; "adding/removing member") (CL:FUNCALL CHACCESSFN GROUP (QUOTE MEMBERS) INDIVIDUAL T)) (PROGN (* ; "Adding/removing from access list") (CL:FUNCALL CHACCESSFN GROUP (QUOTE MEMBERS) SELF/LIST INDIVIDUAL T)))) (if (if (AND (LISTP RESULT) (EQ (CADDR RESULT) (QUOTE NoChange)) ORIGINAL (OR SELF/LIST (CH.ISMEMBER GROUP (QUOTE MEMBERS) NIL ORIGINAL)) (NLISTP (SETQ RESULT (CL:FUNCALL CHACCESSFN GROUP (QUOTE MEMBERS) (SETQ INDIVIDUAL ORIGINAL) T)))) then (* ;; "Command was to remove something.  We first tried the full name, but CH said it didn't work.  Then tried the original, after checking that the other name is in the group (for group hacking.  For Remove Friend/Owner, where is InPropertyACL?") (PRINTOUT T " removed " (NSNAME.TO.STRING ORIGINAL T) T) T else (\NSMT.SHOW.RESULT (LISTP RESULT) NIL GROUP INDIVIDUAL)) then (* ; "Success") (SETQ *LASTGROUP* RESULT) (SETQ *LASTSTRING* *LASTGROUP*)) (SETQ *LASTNAME* INDIVIDUAL)))))(\NSMT.CHANGE.REMARK(LAMBDA NIL (* ; "Edited 18-Aug-89 17:12 by bvm") (PROG (PROPS GOODPROPS MAINPROP NAME REALNAME RESULT REMARK) (DECLARE (USEDFREE *LASTSTRING* *LASTNAME* *LASTGROUP*)) (COND ((SETQ NAME (\NSMT.READFNAME " for object:" *LASTSTRING*)) (SETQ PROPS (CH.LIST.PROPERTIES NAME)) (* ; "returns (realname props)") (COND ((EQ (SETQ REALNAME (CAR PROPS)) (QUOTE ERROR)) (* ; "Object does not exist, probably") (\NSMT.SHOW.RESULT PROPS)) ((NULL (SETQ GOODPROPS (\NSMT.DESCRIPTIVE.PROPS (CADR PROPS)))) (printout T T (SETQ *LASTSTRING* REALNAME) " has no remarkable properties." T)) (T (COND ((NULL (CDR GOODPROPS)) (* ; "only one, the normal case") (PRINTOUT T (CONCAT " (" (COND ((EQUAL.CH.NAMES REALNAME NAME) "") (T (CONCAT (NSNAME.TO.STRING REALNAME) " -- "))) "a " (CL:STRING-CAPITALIZE (STRING (SETQ MAINPROP (CAR GOODPROPS)))) ")"))) (T (PRINTOUT T T (NSNAME.TO.STRING REALNAME) " has the descriptive properties ") (\NSMT.PRINT.LIST GOODPROPS) (COND ((NULL (SETQ MAINPROP (CAR (TTYIN "Specify property to modify: " GOODPROPS T (QUOTE (FIX RAISE)))))) (RETURN))))) (TERPRI T) (COND ((SETQ REMARK (CADR (CH.RETRIEVE.ITEM REALNAME MAINPROP))) (* ; "Retrieve carefully in case the prop is null") (SETQ REMARK (COURIER.READ.REP REMARK NIL (QUOTE STRING))))) (COND ((SETQ REMARK (\NSMT.GET.REMARK REMARK)) (PRIN1 "..." T) (\NSMT.SHOW.RESULT (LISTP (CH.CHANGE.ITEM REALNAME MAINPROP REMARK (QUOTE STRING))))) (T (PRINTOUT T " xxx" T))) (SETQ *LASTSTRING* (COND ((EQ MAINPROP (QUOTE USERGROUP)) (SETQ *LASTGROUP* REALNAME)) (T (SETQ *LASTNAME* REALNAME)))))))))))(\NSMT.DESCRIPTIVE.PROPS(LAMBDA (PROPS) (* ; "Edited 18-Aug-89 14:28 by bvm") (* ;; "PROPS is a list of property numbers.  Return the subset, translated to english, that are %"descriptive%" properties, i.e., whose value is a remark string.") (COND ((for P in PROPS collect (OR (CH.NUMBER.TO.PROPERTY P) P) when (MEMB P *NSMAINTAIN-DESCRIPTIVE-PROPERTIES*))) ((MEMB (CONSTANT (CH.PROPERTY (QUOTE USERGROUP))) PROPS) (* ; "Treat USERGROUP specially, as it is the property conventionally holding a group remark, but we ignore it if object has other props (like USER).") (LIST (QUOTE USERGROUP))))))(\NSMT.REMOVE.ALIAS(LAMBDA NIL (* ; "Edited 18-Aug-89 17:12 by bvm") (LET (ALIAS) (COND ((NULL (SETQ ALIAS (\NSMT.READFNAME " alias:" NIL NIL T)))) ((NLISTP (SETQ ALIAS (CH.DELETE.ALIAS ALIAS))) (* ; "Success, returned canonical name") (CL:FORMAT T "done, alias was removed from ~S~%%" (SETQ *LASTSTRING* ALIAS))) (T (\NSMT.SHOW.RESULT ALIAS))))))(\NSMT.REMOVE.OBJECT(LAMBDA (NAME) (* ; "Edited 18-Aug-89 17:12 by bvm") (COND ((AND (OR NAME (SETQ NAME (\NSMT.READFNAME ":" *LASTSTRING* NIL T))) (SETQ NAME (\NSMT.DESCRIBE.OBJECT NAME T)) (CL:Y-OR-N-P " Confirm deletion (y or n): ")) (\NSMT.SHOW.RESULT (LISTP (CH.DELETE.OBJECT NAME)))))))(\NSMT.REMOVE.USER(LAMBDA NIL (* ; "Edited 18-Aug-89 17:12 by bvm") (LET (USER INFO) (COND ((NULL (SETQ USER (\NSMT.READFNAME ":" *LASTNAME* NIL T)))) ((NULL (SETQ INFO (CH.RETRIEVE.ITEM USER (QUOTE USER)))) (PRINTOUT T " not a user." T)) (T (PRINTOUT T T (NSNAME.TO.STRING (CAR INFO) T)) (COND ((CADR INFO) (CL:FORMAT T " (~A)" (COURIER.READ.REP (CADR INFO) NIL (QUOTE STRING))))) (COND ((CL:Y-OR-N-P " Confirm deletion (y or n): ") (\NSMT.SHOW.RESULT (LISTP (CH.DELETE.OBJECT USER)))))))))))(FILESLOAD (SYSLOAD)       DES AUTHENTICATION)(RPAQQ *NSMAINTAIN-COMMANDS*       (("?" "" RETURN (FUNCTION \NSMT.HELP))        ("Add Alias" "" RETURN (FUNCTION \NSMT.ADD.ALIAS))        ("Add Domain Administrator" "" RETURN '(\NSMT.CHANGE.ADMINISTRATORS                                                       CH.ADD.MEMBER.TO.DOMAIN.ACL ADD))        ("Add Friend" "" RETURN '(\NSMT.CHANGE.GROUP.COMPONENT CH.ADD.MEMBER.TO.PROPERTY.ACL ADD                                         selfControllers))        ("Add Group" "" RETURN (FUNCTION \NSMT.ADD.GROUP))        ("Add Member" "" RETURN '(\NSMT.CHANGE.GROUP.COMPONENT CH.ADD.MEMBER ADD))        ("Add Owner" "" RETURN '(\NSMT.CHANGE.GROUP.COMPONENT CH.ADD.MEMBER.TO.PROPERTY.ACL ADD                                        Administrators))        ("Add Self" "" RETURN '(\NSMT.CHANGE.GROUP.COMPONENT CH.ADD.SELF ADD T))        ("Add User" "" RETURN (FUNCTION \NSMT.ADD.USER))        ("Remove Alias" "" RETURN (FUNCTION \NSMT.REMOVE.ALIAS))        ("Remove Domain Administrator" "" RETURN '(\NSMT.CHANGE.ADMINISTRATORS                                                          CH.DELETE.MEMBER.FROM.DOMAIN.ACL REMOVE))        ("Remove Friend" "" RETURN '(\NSMT.CHANGE.GROUP.COMPONENT CH.DELETE.MEMBER.FROM.PROPERTY.ACL                                           REMOVE selfControllers))        ("Remove Member" "" RETURN '(\NSMT.CHANGE.GROUP.COMPONENT CH.DELETE.MEMBER REMOVE))        ("Remove Owner" "" RETURN '(\NSMT.CHANGE.GROUP.COMPONENT CH.DELETE.MEMBER.FROM.PROPERTY.ACL                                           REMOVE Administrators))        ("Remove Registered Object" "" RETURN (FUNCTION \NSMT.REMOVE.OBJECT))        ("Remove Self" "" RETURN '(\NSMT.CHANGE.GROUP.COMPONENT CH.DELETE.SELF REMOVE T))        ("Remove User" "" RETURN (FUNCTION \NSMT.REMOVE.USER))        ("Change Default Domain" "" RETURN (FUNCTION \NSMT.CHANGE.DOMAIN))        ("Change Forwarding" "" RETURN (FUNCTION \NSMT.CHANGE.FORWARDING))        ("Change Login" "" RETURN (FUNCTION \NSMT.LOGIN))        ("Change Password" "" RETURN (FUNCTION \NSMT.CHANGE.PASSWORD))        ("Change Remark" "" RETURN (FUNCTION \NSMT.CHANGE.REMARK))        ("Describe" "" RETURN (FUNCTION \NSMT.TYPE.ENTRY))        ("List Aliases" "" RETURN '(\NSMT.LIST.OBJECTS ALIAS))        ("List Administrators" "" RETURN (FUNCTION \NSMT.LIST.ADMINISTRATORS))        ("List Clearinghouses" "" RETURN (FUNCTION \NSMT.LIST.CLEARINGHOUSES))        ("List Domains" "" RETURN (FUNCTION \NSMT.LIST.DOMAINS))        ("List Groups" "" RETURN '(\NSMT.LIST.OBJECTS MEMBERS))        ("List Members" "" RETURN (FUNCTION \NSMT.TYPE.MEMBERS))        ("List Objects" "" RETURN (FUNCTION \NSMT.LIST.OBJECTS))        ("List Servers" "" RETURN (FUNCTION \NSMT.LIST.SERVERS))        ("List True Groups" "" RETURN '(\NSMT.LIST.OBJECTS MEMBERS \NSMT.GROUP.FILTER))        ("List Users" "" RETURN '(\NSMT.LIST.OBJECTS USER))        ("Show Details of previously listed names" "" RETURN (FUNCTION \NSMT.SHOW.DETAILS))        ("Type Entry" "" RETURN (FUNCTION \NSMT.TYPE.ENTRY)               EXPLAINSTRING "Type Entry -- same as Describe")        ("Type Members" "" RETURN (FUNCTION \NSMT.TYPE.MEMBERS)               EXPLAINSTRING "Type Members -- same as List Members")        ("Quit" " [confirm]" CONFIRMFLG T RETURN NIL)))(RPAQQ *NSMAINTAIN-ABORT-ITEM* ("" "" EXPLAINSTRING "<cr> - abort" RETURN NIL))(ADDTOVAR CH.PROPERTIES (ALIAS 1))(ADDTOVAR *NSMAINTAIN-DESCRIPTIVE-PROPERTIES* 10000 10001 10002 10003 10004 10005 10006 10007                                                         10008 10009 10010 10011 10012 10013 10014                                                         10015 10016 10017 10018 10019 10020 10021                                                         10023 10024)(ADDTOVAR *NSMAINTAIN-IGNORE-PROPERTIES* 6 7 10027 20003 20002 20101)(ADDTOVAR *NSMAINTAIN-PROPERTY-FORMATS*          (4 CLEARINGHOUSE . NETWORK.ADDRESS.LIST)          (8 RECORD (SIMPLE BOOLEAN)             (STRONG BOOLEAN))          (30 . NSNAME)          (31 CLEARINGHOUSE . MAILBOX.VALUES)          (10000 . STRING)          (10001 . STRING)          (10002 . STRING)          (10003 . STRING)          (10004 . STRING)          (10005 . STRING)          (10006 . STRING)          (10007 . STRING)          (10008 . STRING)          (10009 . STRING)          (10010 . STRING)          (10011 . STRING)          (10012 . STRING)          (10013 . STRING)          (10014 . STRING)          (10015 . STRING)          (10016 . STRING)          (10017 . STRING)          (10018 . STRING)          (10019 . STRING)          (10020 . STRING)          (10021 . STRING)          (10022 . STRING)          (10023 . STRING)          (10024 . STRING)          (10029 . STRING)          (10030 . STRING)          (10032 . STRING)          (10034 . STRING)          (10035 . STRING)          (15002 . STRING)          (20000 CLEARINGHOUSE . USERDATA.VALUE)          (20001 GAP . RS232CData)          (20006 SEQUENCE NSNAME)          (20007 . NSNAME)          (20102 GAP . RS232CBack)          (29965 . STRING)          (30005 . NSNAME))(ADDTOVAR *NSMAINTAIN-MEMBER-PROPERTIES* 20006)(DECLARE%: EVAL@COMPILE DONTCOPY (DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS *NSMAINTAIN-COMMANDS* *NSMAINTAIN-ABORT-ITEM* *NSMAINTAIN-DESCRIPTIVE-PROPERTIES*        *NSMAINTAIN-IGNORE-PROPERTIES* *NSMAINTAIN-PROPERTY-FORMATS* *NSMAINTAIN-MEMBER-PROPERTIES*        CH.PROPERTIES))(CL:PROCLAIM '(CL:SPECIAL *USER* *LASTDOMAIN* *LASTNAME* *LASTGROUP* *LASTLIST* *LASTSTRING*                      *SERVERTYPES* *ALLTYPES* *DEFAULTDOMAIN* *REAL-NAME-CACHE*))(DECLARE%: DOEVAL@COMPILE DONTCOPY(LOCALVARS . T)))(PUTPROPS NSMAINTAIN COPYRIGHT ("Venue & Xerox Corporation" 1985 1986 1987 1989 1990))(DECLARE%: DONTCOPY  (FILEMAP (NIL (4822 15320 (NSMAINTAIN 4832 . 6374) (\NSMT.HELP 6376 . 8012) (\NSMT.READFNAME 8014 . 10438) (\NSMT.LOOKUP 10440 . 10879) (\NSMT.COLLECT.NAMES 10881 . 11195) (\NSMT.GET.REMARK 11197 . 11489) (\NSMT.GET.PASSWORD 11491 . 12072) (\NSMT.LOGIN 12074 . 12584) (\NSMT.CHANGE.DOMAIN 12586 . 13029) (\NSMT.PRINT.LIST 13031 . 13336) (\NSMT.PRINT.OBJECTS 13338 . 13813) (\NSMT.PROCESS.LIST 13815 . 14556) (\NSMT.SHOW.RESULT 14558 . 15318)) (15360 25860 (\NSMT.CHANGE.PASSWORD 15370 . 16182) (\NSMT.DESCRIBE.GROUP 16184 . 16824) (\NSMT.DESCRIBE.OBJECT 16826 . 19002) (\NSMT.DESCRIBE.PROPERTY 19004 . 20236) (\NSMT.LIST.OBJECTS 20238 . 21042) (\NSMT.LIST.CLEARINGHOUSES 21044 . 22324) (\NSMT.LIST.SERVERS 22326 . 23070) (\NSMT.SHOW.DETAILS 23072 . 23857) (\NSMT.GROUP.FILTER 23859 . 24360) (\NSMT.LIST.ADMINISTRATORS 24362 . 24623) (\NSMT.LIST.DOMAINS 24625 . 24871) (\NSMT.TYPE.ENTRY 24873 . 25062) (\NSMT.TYPE.MEMBERS 25064 . 25858)) (25900 40356 (\NSMT.ADD.ALIAS 25910 . 26424) (\NSMT.ADD.GROUP 26426 . 28620) (\NSMT.ADD.USER 28622 . 29969) (\NSMT.CHANGE.ADMINISTRATORS 29971 . 30559) (\NSMT.CHANGE.FORWARDING 30561 . 34591) (\NSMT.CHANGE.GROUP.COMPONENT 34593 . 37018) (\NSMT.CHANGE.REMARK 37020 . 38596) (\NSMT.DESCRIPTIVE.PROPS 38598 . 39199) (\NSMT.REMOVE.ALIAS 39201 . 39554) (\NSMT.REMOVE.OBJECT 39556 . 39854) (\NSMT.REMOVE.USER 39856 . 40354)))))STOP