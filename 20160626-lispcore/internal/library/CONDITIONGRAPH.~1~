(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "IL")(filecreated " 9-Dec-87 16:48:03" {eris}<lispcore>internal>library>conditiongraph.\;8 8770         |changes| |to:|  (xcl:file-environments :conditiongraph)                       (vars conditiongraphcoms)                       (functions conditions::edit-conditions condition-subgraph-recursion                               edit-conditions recompute-condition-graph-sexpr                               count-condition-types-recursion graph-conditions condition-subgraph                               count-condition-types)                       (props (conditiongraph filechanges))                       (variables *condition-graph-window* *condition-graph-sexpr*)      |previous| |date:| "25-Nov-86 17:28:06" {eris}<lispcore>internal>library>conditiongraph.\;6); Copyright (c) 1986, 1987 by Xerox Corporation.  All rights reserved.(prettycomprint conditiongraphcoms)(rpaqq conditiongraphcoms ((declare\: doeval@load doeval@compile dontcopy (xcl:file-environments                                                                               :conditiongraph))                               (variables *condition-graph-window* *condition-graph-sexpr*)                               (functions edit-conditions graph-conditions condition-subgraph                                       condition-subgraph-recursion recompute-condition-graph-sexpr                                       count-condition-types count-condition-types-recursion)                               (prop conditiongraph)))(declare\: doeval@load doeval@compile dontcopy (xcl:define-file-environment :conditiongraph :readtable "XCL" :package "IL" :compiler                                                        :compile-file))(cl:defvar *condition-graph-window* nil                                           "Window in which to display the condition hierarchy graph.")(cl:defvar *condition-graph-sexpr* nil                                   "Tree structure representing last calculated condition type graph.")(cl:defun edit-conditions (root) (cl:labels ((edit-conditions-recursion                                                  (graph)                                                  (cl:unless (null graph)                                                         (ed (cl:first graph)                                                             :structures)                                                         (cl:mapc #'edit-conditions-recursion                                                                (cl:rest graph)))))                                            (edit-conditions-recursion (condition-subgraph root nil))                                            ))(cl:defun graph-conditions (&optional (root 'condition)                                      (recompute (null *condition-graph-sexpr*))                                      w) (let ((neww (showgraph (layoutsexpr (condition-subgraph                                                                              root recompute)                                                                       '(horizontal))                                                            (or w *condition-graph-window*                                                                (cl:format nil                                                                       "Condition type graph from: ~S"                                                                        root))                                                            nil nil t)))                                              (windowprop neww 'title (cl:format nil                                                                       "Condition type graph from: ~S"                                                                              root))                                              (or w *condition-graph-window* (cl:setf                                                                              *condition-graph-window*                                                                                     neww))))(cl:defun condition-subgraph (root recompute &aux (once nil)                                       result) (cl:unless (cl:subtypep root 'condition)                                                      (cl:error "~S is not a condition type."))                                               (cl:loop (cl:when recompute (                                                                      recompute-condition-graph-sexpr                                                                            ))                                                      (cl:setf result (condition-subgraph-recursion                                                                       root *condition-graph-sexpr*))                                                      (cl:when (or once result)                                                             (cl:return-from condition-subgraph                                                                     result))                                                      (cl:format *error-output*                                                              "Couldn't find ~S in current graph.")                                                      (cl:setq once t recompute t)))(cl:defun condition-subgraph-recursion (target tree) (cond                                                            ((null tree)                                                             nil)                                                            ((eq target (cl:first tree))                                                             tree)                                                            (t (cl:dolist                                                                (subtree (cl:rest tree))                                                                (let ((found? (                                                                         condition-subgraph-recursion                                                                               target subtree)))                                                                     (cl:when found? (return found?))                                                                     )))))(cl:defun recompute-condition-graph-sexpr   nil (let ((cghash (cl:make-hash-table)))            (cl:format *error-output* " Computing condition hierarchy graph.")            (mapcar (datatypes)                   #'(cl:lambda (symbol)                            (block)                            (cl:when (and (not (cl:gethash symbol cghash))                                          (cl:subtypep symbol 'condition))                                   (cl:do ((type symbol (condition-parent type))                                           (chain nil))                                          ((cond                                              ((null type)                                               (cl:setf *condition-graph-sexpr* chain))                                              ((cl:gethash type cghash)                                               (nconc (cl:gethash type cghash)                                                      (list chain)))                                              (t nil)))                                          (cl:princ ".")                                          (cl:setf (cl:gethash type cghash)                                                 (cl:setf chain (cl:if (null chain)                                                                       (list type)                                                                       (list type chain))))))))))(cl:defun count-condition-types nil (count-condition-types-recursion (condition-subgraph                                                                          'condition nil)))(cl:defun count-condition-types-recursion (tree) (cond                                                        ((null tree)                                                         0)                                                        ((cl:symbolp tree)                                                         1)                                                        (t (for subtree in tree                                                              sum (                                                                      count-condition-types-recursion                                                                       subtree)))))(putprops conditiongraph copyright ("Xerox Corporation" 1986 1987))(declare\: dontcopy  (filemap (nil)))stop