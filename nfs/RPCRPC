(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "RPC2")
(IL:FILECREATED "16-Jun-94 14:13:09" IL:|{DSK}<project>medley2.1>nfs>RPCRPC.;2| 66372  

      IL:|changes| IL:|to:|  (IL:FUNCTIONS DEF-RPC-ARG-TAIL)

      IL:|previous| IL:|date:| "13-Nov-89 18:50:29" IL:|{DSK}<project>medley2.1>nfs>RPCRPC.;1|)


; Copyright (c) 1987, 1988, 1989, 1994 by Stanford University and Xerox Corporation.  All rights reserved.

(IL:PRETTYCOMPRINT IL:RPCRPCCOMS)

(IL:RPAQQ IL:RPCRPCCOMS 
          ((IL:PROPS (IL:RPCRPC IL:MAKEFILE-ENVIRONMENT IL:FILETYPE))
           (EVAL-WHEN (EVAL COMPILE)
                  (IL:FILES IL:RPCDECLS))
           (IL:COMS                                          (IL:* IL:\; "Public variables")
                  (IL:VARIABLES *DEBUG* *MSEC-UNTIL-TIMEOUT* *MSEC-BETWEEN-TRIES* *RPC-OK-TO-CACHE* 
                         *RPC-SOCKET-CACHE* *RPC-WELL-KNOWN-SOCKETS*)
                                                             (IL:* IL:\; "Internal")
                  (IL:VARIABLES *RPC-PROTOCOL-TYPES* *RPC-PROGRAMS* *RPC-PROTOCOLS* *XID-COUNT* 
                         *XID-MAX* *STREAM* *PROGRAM* *PROCEDURE*)
                  (IL:VARIABLES *RPC-ACCEPT-STATS*))
           (IL:COMS                                          (IL:* IL:\; "Defining RPC Programs")
                  (IL:FUNCTIONS DEFINE-REMOTE-PROGRAM DEFINE-PROGRAM-INTERNAL DEFINE-REMOTE-PROG 
                         CONS-UP-RPC-PROCS CLEAR-ANY-NAME-CONFLICTS DEF-RPC-TYPES DEF-RPC-INHERITS 
                         DEF-RPC-PROCEDURES DEF-RPC-PROCEDURE DEF-RPC-ARG-TAIL DEF-RPC-CONSTANTS 
                         UNDEFINE-REMOTE-PROGRAM XDR-GENCODE-INLINE)
                                                             (IL:* IL:\; "Utilities")
                  (IL:FUNCTIONS FORMAT-T FIND-RPC-TYPEDEF FIND-RPC-TYPENAME FIND-XDR-CONSTANT)
                                                             (IL:* IL:\; 
                                                           "User entries to data structures")
                  (IL:FUNCTIONS LIST-REMOTE-PROGRAMS FIND-RPC-PROGRAM FIND-RPC-PROCEDURE 
                         FIND-RPC-HOST))
           (IL:COMS                                          (IL:* IL:\; "RPC Streams")
                  (IL:FUNCTIONS OPEN-RPCSTREAM RPC-CREATE-SOME-UDP-STREAM CLOSE-RPCSTREAM)
                  (IL:VARIABLES *STRING-RPC-METHODS*)
                  (IL:FUNCTIONS CREATE-STRING-RPC-STREAM RPC-GET-STRING-RESULT)
                                                             (IL:* IL:\; "Debugging")
                  (IL:VARIABLES *TTY-RPC-METHODS*)
                  (IL:FUNCTIONS CREATE-TTY-RPC-STREAM))
           (IL:COMS                                          (IL:* IL:\; "Bignum support")
                  (IL:FUNCTIONS PUTBASE-BIGNUM BIGNUM-MAKE-NUMBER))
           (IL:COMS                                          (IL:* IL:\; "Remote Procedure Call")
                  (IL:FUNCTIONS REMOTE-PROCEDURE-CALL CALL-VIA-PORTMAPPER SETUP-RPC PERFORM-RPC 
                         RPC-RESOLVE-HOST RPC-RESOLVE-PROG RPC-RESOLVE-PROC RPC-FIND-SOCKET 
                         ENCODE-RPC-ARGS PARSE-RPC-REPLY DECODE-RPC-ARGS RPC-HANDLE-TIMEOUT 
                         RPC-SIGNAL-ERROR RPC-ARGUMENT-ERROR CREATE-XID)
                                                             (IL:* IL:\; "RPC Utility Functions")
                  (IL:FUNCTIONS FIND-CACHED-SOCKET CACHE-SOCKET CLEAR-CACHE IPADDRESS-TO-STRING))
           (IL:COMS                                          (IL:* IL:\; "Authentication")
                  (IL:VARIABLES *AUTHENTICATION-TYPEDEF* *NULL-AUTHENTICATION*)
                  (IL:FUNCTIONS CREATE-UNIX-AUTHENTICATION ENCODE-AUTHENTICATION 
                         DECODE-AUTHENTICATION))
           (IL:COMS                                          (IL:* IL:\; 
                                                           "Interface to RESTART.ETHER")
                  (IL:FUNCTIONS RPC-RESTART)
                  (IL:APPENDVARS (IL:RESTARTETHERFNS RPC-RESTART)))))

(IL:PUTPROPS IL:RPCRPC IL:MAKEFILE-ENVIRONMENT (:READTABLE "XCL" :PACKAGE "RPC2"))

(IL:PUTPROPS IL:RPCRPC IL:FILETYPE :COMPILE-FILE)
(EVAL-WHEN (EVAL COMPILE)

(IL:FILESLOAD IL:RPCDECLS)
)



(IL:* IL:\; "Public variables")


(DEFGLOBALPARAMETER *DEBUG* NIL
   "T for printout, NUMBER for even more.")

(DEFPARAMETER *MSEC-UNTIL-TIMEOUT* 10000
   "Total time in msec before giving up on UDP exchange with remote host")

(DEFPARAMETER *MSEC-BETWEEN-TRIES* 500
   "Time in msec between UDP retries")

(DEFPARAMETER *RPC-OK-TO-CACHE* T
   "
If NIL, does not attempt to cache socket numbers for non-well-known sockets
")

(DEFVAR *RPC-SOCKET-CACHE* NIL
   "
A list of (<iphost-address> <remote-program-name> <remote-program-version>
           <protocol> <ipsocket-number>) quintuples.")

(DEFGLOBALVAR *RPC-WELL-KNOWN-SOCKETS* '((* 100000 2 UDP 111)
                                             (* 100000 2 TCP 111))
                                           "List of well-known RPC programs and their sockets.
Each element is a list:
  (host-address prog-number prog-version protocol socket-number)

Host-address may be *, in which case it matches any host address.
Protocol should be either rpc2:UDP or rpc2:TCP.")



(IL:* IL:\; "Internal")


(DEFGLOBALPARAMETER *RPC-PROTOCOL-TYPES* '((UDP . RPC-CREATE-SOME-UDP-STREAM)
                                               (TCP . RPC-CREATE-TCP-STREAM))
                                             "Association list mapping protocol names into functions that create the corresponding type of RPC stream."
)

(DEFGLOBALVAR *RPC-PROGRAMS* NIL
   "
A list of RPC-PROGRAM structs.

This list is consulted by various routines to find infomation about known
remote programs.

It is assumed that a given NAME field uniquely identifies a (NUMBER, VERSION, PROTOCOL).
On the other hand, there may be several NAMEs (and hence, several RPC-STRUCTs) for
a given (NUMBER, VERSION, PROTOCOL).

")

(DEFGLOBALPARAMETER *RPC-PROTOCOLS* '((TCP . 6)
                                          (UDP . 17))
                                        "Portmapper codes for various RPC transports")

(DEFGLOBALVAR *XID-COUNT* 0
   "Contains the  XID stamp of the next remote procedure call")

(DEFGLOBALPARAMETER *XID-MAX* 2147483647
   "Upper bound on XID's for transactions.  See CREATE-XID for discussion.")

(DEFVAR *STREAM* NIL
   "The stream on which an RPC is being performed (for debugging and error recovery).")

(DEFVAR *PROGRAM* NIL
   "The rpc program object involved in current call (for debugging and error recovery).")

(DEFVAR *PROCEDURE* NIL
   "The rpc procedure object involved in current call (for debugging and error recovery).")

(DEFCONSTANT *RPC-ACCEPT-STATS* '((0 . SUCCESS)
                                      (1 . PROGRAM-UNAVAILABLE)
                                      (2 . PROGRAM-MISMATCH)
                                      (3 . PROCEDURE-UNAVAILABLE)
                                      (4 . GARBAGE-ARGUMENTS)
                                      (5 . SYSTEM-ERROR))
                                    "
Assoc list for internal use by PARSE-RPC-REPLY.
")



(IL:* IL:\; "Defining RPC Programs")


(DEFMACRO DEFINE-REMOTE-PROGRAM (NAME NUMBER VERSION PROTOCOL &KEY CONSTANTS TYPES INHERITS 
                                          PROCEDURES)
   "
This macro expands into code to add a new RPC-PROGRAM struct to *RPC-PROGRAMS*.  The generated code checks first to see that there are no name conflicts with existing remote programs and then adds the new structure to *RPC-PROGRAMS*."
   (LET ((ENAME (EVAL NAME))
         (ENUMBER (EVAL NUMBER))
         (EVERSION (EVAL VERSION))
         (EPROTOCOL (OR (EVAL PROTOCOL)
                        'UDP))
         (ECONSTANTS (EVAL CONSTANTS))
         (ETYPES (EVAL TYPES))
         (EINHERITS (EVAL INHERITS))
         (EPROCEDURES (EVAL PROCEDURES)))
        (CHECK-TYPE ENAME SYMBOL)
        (CHECK-TYPE ENUMBER NUMBER)
        (CHECK-TYPE EVERSION NUMBER)
        (SETQ EPROTOCOL (COND
                           ((STRING-EQUAL EPROTOCOL "UDP")
                            'UDP)
                           ((STRING-EQUAL EPROTOCOL "TCP")
                            (WHEN *USE-OS-NETWORKING* (WARN 
                                                "TCP is an unsupported RPC protocol on this machine."
                                                            ))
                            'TCP)
                           ((ERROR "~a is an unknown RPC protocol." EPROTOCOL))))
        (LET ((RPROG (DEFINE-REMOTE-PROG ENAME ENUMBER EVERSION EPROTOCOL ECONSTANTS ETYPES 
                            EINHERITS EPROCEDURES)))
             `(DEFINE-PROGRAM-INTERNAL ',ENAME ,ENUMBER ,EVERSION ',EPROTOCOL
                     ',(RPC-PROGRAM-CONSTANTS RPROG)
                     ',(RPC-PROGRAM-TYPES RPROG)
                     ',(RPC-PROGRAM-INHERITS RPROG)
                     ,(CONS-UP-RPC-PROCS (RPC-PROGRAM-PROCEDURES RPROG))))))

(DEFUN DEFINE-PROGRAM-INTERNAL (NAME NUMBER VERSION PROTOCOL CONSTANTS TYPES INHERITS PROCEDURES)

   (IL:* IL:|;;| "Called by the macro expansion of DEFINE-REMOTE-PROGRAM, arguments having been suitably error checked and the procedures turned into code.")

   (LET ((NEWPROG (MAKE-RPC-PROGRAM :NUMBER NUMBER :VERSION VERSION :NAME NAME :PROTOCOL PROTOCOL 
                         :TYPES TYPES :CONSTANTS CONSTANTS :INHERITS INHERITS :PROCEDURES PROCEDURES)
                )
         MINEISNEWEST NEWERVERSION V OLDPROG OLDPROG2)

        (IL:* IL:|;;| "Note: the functions MAKE-RPC-PROGRAM, CLEAR-ANY-NAME-CONFLICTS, UNDEFINE-REMOTE-PROGRAM and the variable *RPC-PROGRAMS* are referred to directly in the old macro-expansion of DEFINE-REMOTE-PROGRAM, so please leave them alone unless/until you are willing to refuse to load old code.")

        (DOLIST (PGM *RPC-PROGRAMS*)
            (WHEN (EQ (RPC-PROGRAM-NAME PGM)
                      NAME)                                  (IL:* IL:\; 
                      "Same name--only allowed to have one of these, so will delete this other one")
                (SETQ OLDPROG PGM))
            (WHEN (AND (EQL (RPC-PROGRAM-NUMBER PGM)
                            NUMBER)
                       (EQ (RPC-PROGRAM-PROTOCOL PGM)
                           PROTOCOL))                        (IL:* IL:\; 
                                                       "Existing program of same number & protocol")
                (SETQ V (RPC-PROGRAM-VERSION PGM))
                (COND
                   ((EQL V VERSION)                          (IL:* IL:\; 
                                                           "Same version--overwrite it")
                    (RETURN (SETQ OLDPROG2 PGM)))
                   ((< V VERSION)                            (IL:* IL:\; 
                                                           "Our version is newer than this one")
                    (UNLESS NEWERVERSION (SETQ MINEISNEWEST T))
                    (RETURN NIL))
                   (T                                        (IL:* IL:\; 
                                                       "Remember a version that is newer than ours")
                      (SETQ NEWERVERSION PGM)))))
        (FORMAT *DEBUG-IO* 
               "~:[D~;Red~]efining remote program ~A, version ~D~@[ (~:[old~;new~] version)~]~%"
               (OR OLDPROG OLDPROG2)
               NAME VERSION (OR MINEISNEWEST NEWERVERSION)
               MINEISNEWEST)
        (WHEN OLDPROG
            (SETQ *RPC-PROGRAMS* (DELETE OLDPROG *RPC-PROGRAMS*)))
        (WHEN (AND OLDPROG2 (NOT (EQ OLDPROG2 OLDPROG)))
            (SETQ *RPC-PROGRAMS* (DELETE OLDPROG2 *RPC-PROGRAMS*)))
        (IF NEWERVERSION
            (PUSH NEWPROG (CDR (MEMBER NEWERVERSION *RPC-PROGRAMS*)))
            (PUSH NEWPROG *RPC-PROGRAMS*))
        NAME))

(DEFUN DEFINE-REMOTE-PROG (NAME NUMBER VERSION PROTOCOL CONSTANTS TYPES INHERITS PROCEDURES)

   (IL:* IL:|;;| 
 "This guy does the work, so that DEFINE-REMOTE-PROGRAM can cons up the macro easily.")

   (IL:* IL:|;;| "An RPC-PROGRAM struct RPROG is passed back to DEFINE-REMOTE-PROGRAM. Its innards are then used by DEFINE-REMOTE-PROGRAM to build up the big cons that will cons up the proper RPC-PROGRAM later.")

   (FORMAT-T "Building XDR routines for remote program ~a, version ~a~%" NAME VERSION)
   (LET ((RPROG (MAKE-RPC-PROGRAM :NUMBER NUMBER :VERSION VERSION :NAME NAME :PROTOCOL PROTOCOL)))

        (IL:* IL:|;;| "Slightly clumsy structure here, because the def-rpc-xxx routines (curently just DEF-RPC-PROCEDURES) might want to be able to get at the other pieces of the definition.")

        (SETF (RPC-PROGRAM-INHERITS RPROG)
              (DEF-RPC-INHERITS RPROG INHERITS))
        (SETF (RPC-PROGRAM-CONSTANTS RPROG)
              (DEF-RPC-CONSTANTS RPROG CONSTANTS))
        (SETF (RPC-PROGRAM-TYPES RPROG)
              (DEF-RPC-TYPES RPROG TYPES))
        (SETF (RPC-PROGRAM-PROCEDURES RPROG)
              (DEF-RPC-PROCEDURES RPROG PROCEDURES))
        RPROG))

(DEFUN CONS-UP-RPC-PROCS (PROCS)
   "Given a list of RPC-PROCEDURE structs, conses up code to produce that set of RPC-PROCEDURE structs."
   `(LIST ,@(MAPCAR #'(LAMBDA (PROC)
                             `(MAKE-RPC-PROCEDURE :NAME ',(RPC-PROCEDURE-NAME PROC)
                                     :PROCNUM
                                     ',(RPC-PROCEDURE-PROCNUM PROC)
                                     :ARGTYPES
                                     ,(RPC-PROCEDURE-ARGTYPES PROC)
                                     :RESULTTYPES
                                     ,(RPC-PROCEDURE-RESULTTYPES PROC)))
                   PROCS)))

(DEFUN CLEAR-ANY-NAME-CONFLICTS (NAME NUMBER VERSION PROTOCOL)
   "
Determines whether a proposed (NAME, NUMBER, VERSION, PROTOCOL) would violate
the assumption that a NAME uniquely specifies the other three components.

If there exists a violation, the user is given a chance to remove the old program.

Returns T if no violation of assumption (or violation is resolved by removing old program),
Returns NIL if there is an unresolved violation.

"
   (LET (OLDRPC)
        (COND
           ((AND (SETQ OLDRPC (FIND-RPC-PROGRAM :NAME NAME))
                 (OR (/= NUMBER (RPC-PROGRAM-NUMBER OLDRPC))
                     (/= VERSION (RPC-PROGRAM-VERSION OLDRPC))
                     (NOT (EQL PROTOCOL (RPC-PROGRAM-PROTOCOL OLDRPC)))))
            (FORMAT *QUERY-IO* "Remote program name conflict with existing program:~%   Name ~a, Protocol ~A, Number ~a, Version ~a~%"
                   NAME (RPC-PROGRAM-PROTOCOL OLDRPC)
                   (RPC-PROGRAM-NUMBER OLDRPC)
                   (RPC-PROGRAM-VERSION OLDRPC))
            (AND (YES-OR-NO-P "Do you want to remove the old program? ")
                 (UNDEFINE-REMOTE-PROGRAM (RPC-PROGRAM-NAME OLDRPC)
                        (RPC-PROGRAM-NUMBER OLDRPC)
                        (RPC-PROGRAM-VERSION OLDRPC)
                        (RPC-PROGRAM-PROTOCOL OLDRPC))))
           (T T))))

(DEFUN DEF-RPC-TYPES (CONTEXT TYPEDEFS)
   "
Essentially a no-op, as typedefs are copied directly from the DEFINE-REMOTE-PROGRAM
into the RPC-PROGRAM struct. Just prints out the name of each type as it is encountered.
"
   (IF TYPEDEFS (FORMAT-T "    Types~%"))
   (DOLIST (I TYPEDEFS)
       (FORMAT-T "        ~A~%" (FIRST I)))
   TYPEDEFS)

(DEFUN DEF-RPC-INHERITS (CONTEXT PROGLIST)
   "
Checks remote program inherited by this one to make sure that it exists.
Issues a warning if it cannot find the program to be inherited.
"
   (IF PROGLIST (FORMAT-T "    Inherits~%"))
   (DOLIST (PRG PROGLIST PROGLIST)
       (FORMAT-T "        ~A~%" PRG)
       (IF (NOT (AND (SYMBOLP PRG)
                     (FIND-RPC-PROGRAM :NAME PRG)))
           (WARN "Trying to inherit from remote program ~a, but ~a not found.~%" PRG PRG))))

(DEFUN DEF-RPC-PROCEDURES (CONTEXT PROCS)
   "Returns a list of RPC-PROCEDURE structs returned by DEF-RPC-PROCEDURE."
   (CHECK-TYPE PROCS LIST "A list of RPC procedure declarations")
   (IF PROCS (FORMAT-T "    Procedures~%"))
   (MAPCAR #'(LAMBDA (PROC)
                    (DEF-RPC-PROCEDURE CONTEXT PROC))
          PROCS))

(DEFUN DEF-RPC-PROCEDURE (CONTEXT PROC)
   "For a procedure specified to DEFINE-REMOTE-PROGRAM's :PROCEDURES argument, creates and returns an RPC-PROCEDURE struct.

XDR procedure code is generated via the call to XDR-GENCODE-MAKEFCN.
"
   (CHECK-TYPE (FIRST PROC)
          (AND SYMBOL (NOT NULL))
          "a non-null symbol naming the RPC procedure.")
   (CHECK-TYPE (SECOND PROC)
          (INTEGER 0 *)
          "a non-negative integer RPC procedure number")
   (CHECK-TYPE (THIRD PROC)
          LIST)
   (LET ((NAME (FIRST PROC))
         (ARGTYPES (THIRD PROC))
         (RESULTS (FOURTH PROC)))
        (FORMAT-T "        ~A~%" NAME)
        (MAKE-RPC-PROCEDURE :NAME NAME :PROCNUM (SECOND PROC)
               :ARGTYPES
               (AND ARGTYPES `#'(LAMBDA (XDR-STREAM ARGS)
                                       (PROG ((ARGTAIL ARGS))
                                             ,(DEF-RPC-ARG-TAIL ARGTYPES CONTEXT T)

                                        (IL:* IL:|;;| 
                                      "Fall thru here if some sort of argument mismatch")

                                             (RPC-ARGUMENT-ERROR ARGS ,(LENGTH ARGTYPES)))))
               :RESULTTYPES
               (AND RESULTS (LIST 'FUNCTION (XDR-CODEGEN CONTEXT (IF (CONSP RESULTS)
                                                             (IL:* IL:\; 
                                                           "Implicitly get a list back")
                                                                     (CONS ':LIST RESULTS)
                                                                     RESULTS)
                                                   'READ))))))

(DEFUN DEF-RPC-ARG-TAIL (ARGTYPES CONTEXT &OPTIONAL FIRSTTIME)

   (IL:* IL:|;;| "Generates code that writes each of the elements of the variable ARGTAIL per the types in ARGTYPES, with a final RETURN if no arg mismatch.  This is recursive, producing fragments that looks like (when (setq argtail (cdr argtail)) (write-somehow (car argtail)) (when ...) ...).  If FIRSTTIME, we don't pop ARGTAIL.")

   (IL:* IL:|;;| "This could have been written non-recursively with rplacd's, or by producing code with jumps.  The latter turns out to compile worse in xcl.")

   (IF ARGTYPES
       `(WHEN ,(IF FIRSTTIME
                   'ARGTAIL
                   '(SETQ ARGTAIL (CDR ARGTAIL)))            (IL:* IL:\; 
                                                           "Test that we have an argument")
            ,(XDR-CODEGEN-1 CONTEXT (CAR ARGTYPES)
                    'WRITE
                    `(XDR-STREAM (CAR ARGTAIL))
                    NIL)

            (IL:* IL:|;;| 
"NOTE:  last NIL arg inserted to stop arg mismatch error.  Should it be a real STK????  Ron Kaplan")
                                                             (IL:* IL:\; 
                                                           "Generate code to write it")
            ,(DEF-RPC-ARG-TAIL (CDR ARGTYPES)
                    CONTEXT)                                 (IL:* IL:\; 
                                                           "Finally, generate code to do the rest")
            )
       '(WHEN (NULL (CDR ARGTAIL))                           (IL:* IL:\; 
                         "Having written all the args accounted for, verify that there are no more")
            (RETURN))))

(DEFUN DEF-RPC-CONSTANTS (CONTEXT PAIRS)
   "
Checks that constants specified to DEFINE-REMOTE-PROGRAM are syntactically
reasonable.
"
   (IF PAIRS (FORMAT-T "    Constants~%"))
   (DOLIST (PAIR PAIRS)
       (CHECK-TYPE (FIRST PAIR)
              (AND (NOT NULL)
                   SYMBOL))
       (CHECK-TYPE (SECOND PAIR)
              (AND (NOT NULL)
                   NUMBER))
       (FORMAT-T "        ~A~%" (FIRST PAIR)))
   PAIRS)

(DEFUN UNDEFINE-REMOTE-PROGRAM (NAME NUMBER VERSION &OPTIONAL PROTOCOL)
   "
If finds NAME-NUMBER-VERSION-PROTOCOL match in *RPC-PROGRAMS*, deletes.
If finds NUMBER-VERSION match with NAME mismatch, asks first.
If deletes something, returns NAME of DELETED program, otherwise NIL."
                                                             (IL:* IL:\; "")
   (LET ((RPC (FIND-RPC-PROGRAM :NUMBER NUMBER :VERSION VERSION :NAME NAME :PROTOCOL PROTOCOL)))
        (WHEN (AND RPC (OR (EQL NAME (RPC-PROGRAM-NAME RPC))
                           (YES-OR-NO-P "Do you really want to remove/overwrite RPC program ~a?"
                                  (RPC-PROGRAM-NAME RPC))))
            (SETQ *RPC-PROGRAMS* (DELETE RPC *RPC-PROGRAMS*))
            (RPC-PROGRAM-NAME RPC))))

(DEFMACRO XDR-GENCODE-INLINE (CONTEXT TYPEDEF OPER &REST VARS)

   (IL:* IL:|;;| "Expands into code that reads/writes the rpc encoding following context/typedef.  Note that using a NIL context is valid here. It just means that no typedefs from other Remote Program Definitions are available.")
                                                             (IL:* IL:\; 
                                                          "XDR-CODEGEN returns a lambda expression")
   `(,(XDR-CODEGEN (IF (AND CONTEXT (SYMBOLP CONTEXT))
                       (RPC-RESOLVE-PROG CONTEXT)
                       CONTEXT)
             (EVAL TYPEDEF)
             (EVAL OPER))
     ,.VARS))



(IL:* IL:\; "Utilities")


(DEFMACRO FORMAT-T (&REST ARGS)
   "
Use in low-level code in place of (FORMAT T ...) to avoid disaster. 

The problem is that Xerox Common Lisp, when given (FORMAT <stream> ...), rebinds
*STANDARD-OUTPUT* to <stream> under the assumption that none of the
implementation of FORMAT will ever use *STANDARD-OUTPUT*.  Thus, if you try to 
write to *STANDARD-OUTPUT* in any code called by COMMON LISP I/O routines writing
to another stream, the output goes into the other stream rather than the original 
*STANDARD-OUTPUT*.  This routine is a quick fix for a lot of (FORMAT T ...) calls to 
send their output to *DEBUG-IO*, which is where the output should have gone in the
 first place.  
"
   `(FORMAT *DEBUG-IO* ,@ARGS))

(DEFUN FIND-RPC-TYPEDEF (CONTEXT TYPE)
   "Returns the type definition for TYPE defined in RPC CONTEXT
(CONTEXT may be a name or RPC-PROGRAM structure) if any, or else
returns NIL.
"
   (LET ((PRGSTR (ETYPECASE CONTEXT
                     (SYMBOL (FIND-RPC-PROGRAM :NAME CONTEXT))
                     (RPC-PROGRAM CONTEXT))))
        (SECOND (ASSOC TYPE (RPC-PROGRAM-TYPES PRGSTR)))))

(DEFUN FIND-RPC-TYPENAME (CONTEXT TYPE)
   "
Returns TYPE, if TYPE defined in RPC CONTEXT
(CONTEXT may be a name or RPC-PROGRAM structure) if any, or else
returns NIL.
"
   (LET ((PRGSTR (ETYPECASE CONTEXT
                     (SYMBOL (FIND-RPC-PROGRAM :NAME CONTEXT))
                     (RPC-PROGRAM CONTEXT))))
        (FIRST (ASSOC TYPE (RPC-PROGRAM-TYPES PRGSTR)))))

(DEFUN FIND-XDR-CONSTANT (CONTEXT CONSTANT)
   "Find (and return) the constant definition for symbol CONSTANT among the constants for RPC-PROGRAM structure CONTEXT. "
   (CHECK-TYPE CONSTANT SYMBOL)
   (SECOND (ASSOC CONSTANT (RPC-PROGRAM-CONSTANTS CONTEXT))))



(IL:* IL:\; "User entries to data structures")


(DEFUN LIST-REMOTE-PROGRAMS ()

   (IL:* IL:|;;| "Return list of (name number version protocol)  for each defined remote program.")

   (MAPCAR #'(LAMBDA (R)
                    (LIST (RPC-PROGRAM-NAME R)
                          (RPC-PROGRAM-NUMBER R)
                          (RPC-PROGRAM-VERSION R)
                          (RPC-PROGRAM-PROTOCOL R)))
          *RPC-PROGRAMS*))

(DEFUN FIND-RPC-PROGRAM (&KEY NAME NUMBER VERSION PROTOCOL)
   "Returns the RPC-PROGRAM struct for the given identifiers from among all the remote programs defined.  VERSION defaults to the highest existing version."
   (COND
      (NAME                                                  (IL:* IL:\; 
               "Name uniquely identifies it, so if we find one, just check that version, etc match")
            (DOLIST (PGM *RPC-PROGRAMS*)
                (WHEN (EQ NAME (RPC-PROGRAM-NAME PGM))
                    (RETURN (AND (OR (NULL NUMBER)
                                     (EQL NUMBER (RPC-PROGRAM-NUMBER PGM)))
                                 (OR (NULL VERSION)
                                     (EQL VERSION (RPC-PROGRAM-VERSION PGM)))
                                 (OR (NULL PROTOCOL)
                                     (EQ PROTOCOL (RPC-PROGRAM-PROTOCOL PGM)))
                                 PGM)))))
      (NUMBER (LET ((BESTPROTOCOL (OR PROTOCOL 'UDP))
                    FIRSTONEFOUND)                           (IL:* IL:\; 
                                                           "If PROTOCOL not given, we prefer UDP.")
                   (DOLIST (PGM *RPC-PROGRAMS* FIRSTONEFOUND)(IL:* IL:\; "Programs are sorted by highest version first, so if VERSION is omitted we can just take the first one")
                       (WHEN (AND (EQL NUMBER (RPC-PROGRAM-NUMBER PGM))
                                  (OR (NULL VERSION)
                                      (EQL VERSION (RPC-PROGRAM-VERSION PGM))))
                           (COND
                              ((EQ BESTPROTOCOL (RPC-PROGRAM-PROTOCOL PGM))
                                                             (IL:* IL:\; 
                                          "Protocol match, or a UDP program when caller didn't say")
                               (RETURN PGM))
                              ((AND (NULL PROTOCOL)
                                    (NULL FIRSTONEFOUND))    (IL:* IL:\; 
                                            "Remember this one in case we don't find a UDP version")
                               (SETQ FIRSTONEFOUND PGM)))))))
      (T (ERROR 
   "Invalid RPC Program Specifier: ~@[ Name: ~a~]~@[ Number: ~a~]~@[ Version: ~a~]~@[ Protocol: ~a~]"
                NAME NUMBER VERSION PROTOCOL))))

(DEFUN FIND-RPC-PROCEDURE (PROGRAM PROCID)
   "Finds (and returns) RPC-PROCEDURE structure specified by PROCID from among the procedures of PROGRAM, an rpc-program object. PROCID may be either an integer or a symbol."
   (LET ((PROCS (IF (CONSP PROGRAM)                          (IL:* IL:\; 
                                                           "Backward compatibility with old def")
                    PROGRAM
                    (RPC-PROGRAM-PROCEDURES PROGRAM))))
        (CTYPECASE PROCID (INTEGER (DOLIST (P PROCS)
                                       (WHEN (EQL PROCID (RPC-PROCEDURE-PROCNUM P))
                                             (RETURN P))))
               (SYMBOL (DOLIST (P PROCS)
                           (WHEN (EQ PROCID (RPC-PROCEDURE-NAME P))
                                 (RETURN P)))))))

(DEFUN FIND-RPC-HOST (DESTINATION)
   
  "Returns an IP host address (a number) for specified DESTINATION, or NIL if not known destination."
   (ETYPECASE DESTINATION
       (NUMBER DESTINATION)
       ((OR SYMBOL STRING) (IF *USE-OS-NETWORKING*
                               (OS-RESOLVE-HOST DESTINATION)
                               (IL:IPHOSTADDRESS DESTINATION)))))



(IL:* IL:\; "RPC Streams")


(DEFUN OPEN-RPCSTREAM (PROTOCOL DESTADDR DESTSOCKET &OPTIONAL CREDENTIALS TIMEOUT-HANDLER)
   "Create and return a new RPC-STREAM."
   (LET ((HANDLER (CDR (ASSOC PROTOCOL *RPC-PROTOCOL-TYPES*)))
         STREAM)
        (UNLESS HANDLER (ERROR "Not a recognized RPC protocol: ~S" PROTOCOL))
        (SETQ STREAM (FUNCALL HANDLER DESTADDR DESTSOCKET))
        (SETF (RPC-STREAM-PROTOCOL STREAM)
              PROTOCOL)
        (SETF (RPC-STREAM-MONITORLOCK STREAM)
              (IL:CREATE.MONITORLOCK "RPC"))
        (SETF (RPC-STREAM-TIMEOUT-HANDLER STREAM)
              TIMEOUT-HANDLER)
        (SETF (RPC-STREAM-CREDENTIALS STREAM)
              CREDENTIALS)
        STREAM))

(DEFUN RPC-CREATE-SOME-UDP-STREAM (DESTADDR DESTSOCKET)
   (IF *USE-OS-NETWORKING*
       (CREATE-OS-UDP-STREAM DESTADDR DESTSOCKET)
       (RPC-CREATE-UDP-STREAM DESTADDR DESTSOCKET)))

(DEFUN CLOSE-RPCSTREAM (RPCSTREAM)
   "Deallocate an RPC Stream. Tries to cleanup after itself."
   (RPC-CALL-METHOD CLOSE RPCSTREAM))

(DEFGLOBALPARAMETER *STRING-RPC-METHODS*
   (MAKE-RPC-METHODS :PROTOCOL 'STRING :INITIALIZE #'(LAMBDA (RPCSTREAM)
                                                            (LET ((S (RPC-STREAM-OUTSTREAM RPCSTREAM)
                                                                     ))
                                                             (IL:* IL:\; "Erase the core stream.")
                                                                 (FILE-POSITION S 0)
                                                                 (IL:SETFILEINFO S 'IL:LENGTH 0)))
          :PUTBYTE
          #'(LAMBDA (RPCSTREAM VALUE)
                   (WRITE-BYTE VALUE (RPC-STREAM-OUTSTREAM RPCSTREAM)))
          :PUTCELL
          #'(LAMBDA (RPCSTREAM VALUE)
                   (LET ((OUTSTREAM (RPC-STREAM-OUTSTREAM RPCSTREAM)))
                        (WRITE-BYTE (LDB (BYTE 8 24)
                                         VALUE)
                               OUTSTREAM)
                        (WRITE-BYTE (LDB (BYTE 8 16)
                                         VALUE)
                               OUTSTREAM)
                        (WRITE-BYTE (LDB (BYTE 8 8)
                                         VALUE)
                               OUTSTREAM)
                        (WRITE-BYTE (LDB (BYTE 8 0)
                                         VALUE)
                               OUTSTREAM)))
          :PUTRAWBYTES
          #'(LAMBDA (RPCSTREAM BASE OFFSET NBYTES)
                   (IL:\\BOUTS (RPC-STREAM-OUTSTREAM RPCSTREAM)
                          BASE OFFSET NBYTES))
          :ZEROBYTES
          #'(LAMBDA (RPCSTREAM NBYTES)
                   (LET ((STREAM (RPC-STREAM-OUTSTREAM RPCSTREAM)))
                        (DOTIMES (I NBYTES)
                            (IL:\\BOUT STREAM 0))))
          :GETBYTE
          #'(LAMBDA (RPCSTREAM)

                   (IL:* IL:|;;| 
                 "These input functions assume user has stored some sort of stream in the INSTREAM")

                   (READ-BYTE (RPC-STREAM-INSTREAM RPCSTREAM)))
          :GETCELL
          #'(LAMBDA (RPCSTREAM)
                   (LET ((INSTREAM (RPC-STREAM-INSTREAM RPCSTREAM)))
                        (INTEGER-FROM-BYTES (IL:BIN INSTREAM)
                               (IL:BIN INSTREAM)
                               (IL:BIN INSTREAM)
                               (IL:BIN INSTREAM))))
          :GETUNSIGNED
          #'(LAMBDA (RPCSTREAM)
                   (LET ((INSTREAM (RPC-STREAM-INSTREAM RPCSTREAM)))
                        (UNSIGNED-FROM-BYTES (IL:BIN INSTREAM)
                               (IL:BIN INSTREAM)
                               (IL:BIN INSTREAM)
                               (IL:BIN INSTREAM))))
          :GETRAWBYTES
          #'(LAMBDA (RPCSTREAM BASE OFFSET NBYTES)
                   (IL:\\BINS (RPC-STREAM-INSTREAM RPCSTREAM)
                          BASE OFFSET NBYTES))
          :SKIPBYTES
          #'(LAMBDA (RPCSTREAM NBYTES)
                   (LET ((INSTREAM (RPC-STREAM-INSTREAM RPCSTREAM)))
                        (DOTIMES (I NBYTES)
                            (IL:BIN INSTREAM))))
          :CLOSE
          #'IDENTITY))

(DEFUN CREATE-STRING-RPC-STREAM (&OPTIONAL INSTRING)
   "Create RPC STREAM that writes data to a string, retrievable as (RPC-GET-STRING-RESULT stream).  If you supply INSTRING, or store a string input stream in the INSTREAM slot, it will also read."
   (MAKE-RPC-STREAM :METHODS *STRING-RPC-METHODS* :INSTREAM (AND INSTRING (MAKE-STRING-INPUT-STREAM
                                                                           INSTRING))
          :OUTSTREAM
          (OPEN "{nodircore}" :DIRECTION :IO)))

(DEFUN RPC-GET-STRING-RESULT (RPC-STREAM)

   (IL:* IL:|;;| "For a string RPC stream, retrieve the result string")

   (IL:* IL:|;;| "We might have wanted to use MAKE-STRING-OUTPUT-STREAM and then retrieved it via (get-output-stream-string (rpc-stream-outstream rpc-stream)), but in this implementation, you can't write such strings with 255's in them, since there is no such character.  So instead we use a core stream and create the string at the very end.")

   (LET* ((S (RPC-STREAM-OUTSTREAM RPC-STREAM))
          (NBYTES (FILE-POSITION S))
          (STR (MAKE-STRING NBYTES)))
         (FILE-POSITION S 0)
         (IL:\\BINS S (VECTOR-BASE STR)
                0 NBYTES)
         STR))



(IL:* IL:\; "Debugging")


(DEFGLOBALPARAMETER *TTY-RPC-METHODS*
   (MAKE-RPC-METHODS :PUTCELL #'(LAMBDA (RPCSTREAM VALUE)
                                       (FORMAT (RPC-STREAM-OUTSTREAM RPCSTREAM)
                                              "~D,~D,~D,~D~%"
                                              (LDB (BYTE 8 24)
                                                   VALUE)
                                              (LDB (BYTE 8 16)
                                                   VALUE)
                                              (LDB (BYTE 8 8)
                                                   VALUE)
                                              (LDB (BYTE 8 0)
                                                   VALUE)))
          :PUTRAWBYTES
          #'(LAMBDA (RPCSTREAM BASE OFFSET NBYTES)
                   (LET ((OUT (RPC-STREAM-OUTSTREAM RPCSTREAM)))
                        (DOTIMES (I NBYTES)
                            (FORMAT OUT "~D," (IL:\\GETBASEBYTE BASE (+ OFFSET I))))
                        (TERPRI OUT)))
          :PUTBYTE
          #'(LAMBDA (RPCSTREAM VAL)
                   (FORMAT (RPC-STREAM-OUTSTREAM RPCSTREAM)
                          "~D~%" VAL))
          :ZEROBYTES
          #'(LAMBDA (RPCSTREAM NBYTES)
                   (FORMAT (RPC-STREAM-OUTSTREAM RPCSTREAM)
                          "~D*0~%" NBYTES))))

(DEFUN CREATE-TTY-RPC-STREAM ()
   "For debugging using the TTY as the output device."
   (MAKE-RPC-STREAM :METHODS *TTY-RPC-METHODS* :OUTSTREAM *STANDARD-OUTPUT*))



(IL:* IL:\; "Bignum support")


(DEFUN PUTBASE-BIGNUM (BASE VALUE)

   (IL:* IL:|;;| "Store the 32-bit bignum VALUE at BASE")

   (UNLESS (TYPEP VALUE 'BIGNUM)
       (ERROR 'TYPE-MISMATCH :EXPECTED-TYPE 'INTEGER :NAME VALUE :VALUE VALUE))
   (DESTRUCTURING-BIND (LO MID HI . REST)
          (IL:\\GETBASEPTR (IL:\\DTEST VALUE 'BIGNUM)
                 0)
          (WHEN (OR (NULL HI)
                    (> HI 15)
                    (< HI 0)
                    (NOT (NULL REST)))
                (ERROR "Unsigned value ~S exceeds 32 bits" VALUE))
          (IL:\\PUTBASE BASE 1 (+ LO (IL:LLSH (LOGAND MID 3)
                                            14)))
          (IL:\\PUTBASE BASE 0 (+ (IL:LLSH HI 12)
                                  (IL:LRSH MID 2)))))

(DEFUN BIGNUM-MAKE-NUMBER (HIWORD LOWORD)

   (IL:* IL:|;;| "Create the number HIWORD*2^16 + LOWORD, where HIWORD is greater than 2^15-1 and hence will not make a FIXP.")

   (IL:* IL:|;;| "Representation of BIGNUMs in Xerox Lisp: pointer to a list of 14-bit integers, least significant first.")

   (LET ((N (IL:NCREATE 'BIGNUM)))
        (IL:\\RPLPTR N 0 (LIST (LOGAND LOWORD 16383)
                               (+ (IL:LRSH LOWORD 14)
                                  (IL:LLSH (LOGAND HIWORD 4095)
                                         2))
                               (IL:LRSH HIWORD 12)))
        N))



(IL:* IL:\; "Remote Procedure Call")


(DEFUN REMOTE-PROCEDURE-CALL (DESTINATION PROGRAM PROCID ARGLIST &REST KEYS &KEY PROTOCOL VERSION
                                        REMOTESOCKET CREDENTIALS TIMEOUT-HANDLER DYNAMIC-PROGNUM 
                                        DYNAMIC-VERSION ERRORFLG MSEC-UNTIL-TIMEOUT 
                                        MSEC-BETWEEN-TRIES RETRY-UNTIL-SUCCESS NOTE-ADDRESS 
                                        &ALLOW-OTHER-KEYS)
   "This is the high-level way of making a remote procedure call (PERFORM-RPC is the low-level
way).

REMOTE-PROCEDURE-CALL resolves all the arguments, creates a new RPC-STREAM, makes the call, optionally closes the RPC-STREAM, and returns the results of the call.

The resolution of arguments is designed such that all arguments may be either
unresolved (e.g., a remote host name), or already resolved (e.g., an IP address).
"
   (LET (RPCSTREAM)
        (UNWIND-PROTECT
            (LET* ((PROGRAM (RPC-RESOLVE-PROG PROGRAM VERSION PROTOCOL))
                   (PROCEDURE (RPC-RESOLVE-PROC (COND
                                                       (DYNAMIC-PROGNUM (SETF PROGRAM (
                                                                                     COPY-RPC-PROGRAM
                                                                                       PROGRAM))
                                                              (SETF (RPC-PROGRAM-NUMBER PROGRAM)
                                                                    DYNAMIC-PROGNUM)
                                                              (SETF (RPC-PROGRAM-VERSION PROGRAM)
                                                                    (OR DYNAMIC-VERSION 1))
                                                              PROGRAM)
                                                       (T PROGRAM))
                                     PROCID)))
                  (SETQ RPCSTREAM (OPEN-RPCSTREAM (RPC-PROGRAM-PROTOCOL PROGRAM)
                                         DESTINATION
                                         (OR REMOTESOCKET PROGRAM)
                                         CREDENTIALS TIMEOUT-HANDLER))
                  (APPLY 'PERFORM-RPC NIL NIL PROGRAM PROCEDURE RPCSTREAM ARGLIST CREDENTIALS KEYS))
            (WHEN RPCSTREAM                                  (IL:* IL:\; "Discard the stream now")
                (CLOSE-RPCSTREAM RPCSTREAM)))))

(DEFUN CALL-VIA-PORTMAPPER (DESTINATION PROGRAM PROCEDURE ARGLIST &OPTIONAL CREDENTIALS)

   (IL:* IL:|;;| "Do a remote procedure call without knowing the port to use.  The standard use for this is broadcast for servers (i.e., DESTINATION = 0 + some net).  Returns 3 values: the results of the procedure call, the socket used, and the address of the server that answered.")

   (LET* ((*PROGRAM* (IF (TYPEP PROGRAM 'RPC-PROGRAM)
                         PROGRAM
                         (RPC-RESOLVE-PROG PROGRAM)))
          (*PROCEDURE* (IF (TYPEP PROCEDURE 'RPC-PROCEDURE)
                           PROCEDURE
                           (RPC-RESOLVE-PROC *PROGRAM* PROCEDURE)))
          (RETTYPES (RPC-PROCEDURE-RESULTTYPES *PROCEDURE*))
          (RPC-STREAM (CREATE-STRING-RPC-STREAM)))
         (MULTIPLE-VALUE-BIND (RESULTS SERVER-ADDRESS)
                (LET (RPCSTREAM)
                     (UNWIND-PROTECT
                         (LET* ((PMAPPERPROG (RPC-RESOLVE-PROG 'PORTMAPPER))
                                (PMAPPERPROC (RPC-RESOLVE-PROC PMAPPERPROG 'INDIRECT)))
                               (SETQ RPCSTREAM (OPEN-RPCSTREAM (RPC-PROGRAM-PROTOCOL PMAPPERPROG)
                                                      DESTINATION *PORTMAPPER-SOCKET*))
                               (PERFORM-RPC NIL NIL PMAPPERPROG PMAPPERPROC RPCSTREAM
                                      (LIST (RPC-PROGRAM-NUMBER *PROGRAM*)
                                            (RPC-PROGRAM-VERSION *PROGRAM*)
                                            (RPC-PROCEDURE-PROCNUM *PROCEDURE*)
                                            (PROGN           (IL:* IL:\; "Args to INDIRECT are the prog#, version, proc#, and a string encoding the arguments as if we had called it directly.")
                                                   (ENCODE-RPC-ARGS RPC-STREAM ARGLIST 
                                                          *PROCEDURE*)
                                                   (RPC-GET-STRING-RESULT RPC-STREAM)))
                                      CREDENTIALS :NOTE-ADDRESS T))
                         (WHEN RPCSTREAM                     (IL:* IL:\; "Discard the stream now")
                             (CLOSE-RPCSTREAM RPCSTREAM))))

                (IL:* IL:|;;| "RESULTS = (address socket string), where string is an encoding of the results of the procedure call.  Address was consed on the front by virtue of the :NOTE-ADDRESS key.")

                (SETF (RPC-STREAM-INSTREAM RPC-STREAM)
                      (MAKE-STRING-INPUT-STREAM (THIRD RESULTS)))
                (VALUES (DECODE-RPC-ARGS RPC-STREAM RETTYPES)
                       (SECOND RESULTS)
                       (FIRST RESULTS)))))

(DEFUN SETUP-RPC (DESTINATION PROGRAM PROCID &OPTIONAL DESTSOCKET VERSION DYNAMIC-PROGNUM 
                            DYNAMIC-VERSION PROTOCOL)
   "
Resolves arguments to REMOTE-PROCEDURE-CALL. Takes arguments in more or less
any reasonable form and returns multiple values (destination-address, socket-number,
RPC-PROGRAM struct, RPC-PROCEDURE struct).
 
See individual RPC-RESOLVE-* programs for details on what inputs are acceptable.
"
   (LET* ((DESTADDR (RPC-RESOLVE-HOST DESTINATION))
          (RPROG (RPC-RESOLVE-PROG PROGRAM VERSION PROTOCOL))
          (RPROC (RPC-RESOLVE-PROC (COND
                                          (DYNAMIC-PROGNUM (SETF RPROG (COPY-RPC-PROGRAM RPROG))
                                                 (SETF (RPC-PROGRAM-NUMBER RPROG)
                                                       DYNAMIC-PROGNUM)
                                                 (SETF (RPC-PROGRAM-VERSION RPROG)
                                                       DYNAMIC-VERSION)
                                                 RPROG)
                                          (T RPROG))
                        PROCID))
          (SOCKET (OR DESTSOCKET (RPC-FIND-SOCKET DESTADDR RPROG (RPC-PROGRAM-PROTOCOL RPROG)))))
         (VALUES DESTADDR SOCKET RPROG RPROC)))

(DEFUN PERFORM-RPC (DESTADDR DESTSOCKET *PROGRAM* *PROCEDURE* *STREAM* ARGLIST CREDENTIALS &KEY
                              (ERRORFLG T)
                              ((:MSEC-UNTIL-TIMEOUT *MSEC-UNTIL-TIMEOUT*)
                               *MSEC-UNTIL-TIMEOUT*)
                              ((:MSEC-BETWEEN-TRIES *MSEC-BETWEEN-TRIES*)
                               *MSEC-BETWEEN-TRIES*)
                              NOTE-ADDRESS &ALLOW-OTHER-KEYS)
   "The low-level remote procedure call function.  *STREAM* must be an rpc stream."
   (UNLESS (RPC-PROGRAM-P *PROGRAM*)
       (SETQ *PROGRAM* (RPC-RESOLVE-PROG *PROGRAM*)))
   (UNLESS (RPC-PROCEDURE-P *PROCEDURE*)
       (SETQ *PROCEDURE* (RPC-RESOLVE-PROC *PROGRAM* *PROCEDURE*)))
   (IL:WITH.MONITOR (RPC-STREAM-MONITORLOCK *STREAM*)
       (MACROLET ((PUTN (N)                                  (IL:* IL:\; 
                                                 "A small optimization, since we call this so much")
                        `(FUNCALL PUTFN *STREAM* ,N)))
              (LET ((PUTFN (RPC-METHOD PUTCELL *STREAM*))
                    (XID (CREATE-XID))
                    RESULT)
                   (REINITIALIZE-RPCSTREAM *STREAM* DESTADDR DESTSOCKET)
                   (PUTN XID)
                   (PUTN *RPC-MSG-CALL*)
                   (PUTN *RPC-VERSION*)
                   (PUTN (RPC-PROGRAM-NUMBER *PROGRAM*))
                   (PUTN (RPC-PROGRAM-VERSION *PROGRAM*))
                   (PUTN (RPC-PROCEDURE-PROCNUM *PROCEDURE*))
                   (ENCODE-AUTHENTICATION *STREAM* (OR CREDENTIALS (RPC-STREAM-CREDENTIALS 
                                                                              *STREAM*)))
                   (ENCODE-AUTHENTICATION *STREAM* *NULL-AUTHENTICATION*)
                   (ENCODE-RPC-ARGS *STREAM* ARGLIST *PROCEDURE*)
                   (WHEN *DEBUG*
                       (FORMAT *DEBUG-IO* "~&RPC[~A]: ~A.~A" (IPADDRESS-TO-STRING DESTADDR)
                              (RPC-PROGRAM-NAME *PROGRAM*)
                              (RPC-PROCEDURE-NAME *PROCEDURE*))
                       (LET ((*PRINT-LENGTH* 5)
                             (*PRINT-LEVEL* 2)
                             (SEPR "["))
                            (DOLIST (A ARGLIST)
                                (PRINC SEPR *DEBUG-IO*)
                                (PRIN1 A *DEBUG-IO*)
                                (SETQ SEPR ", ")))
                       (PRINC "]" *DEBUG-IO*))
                   (COND
                      ((EQ (SETQ RESULT (RPC-CALL-METHOD EXCHANGE *STREAM* ERRORFLG XID))
                           T)                                (IL:* IL:\; "Got a reply")
                       (SETQ RESULT (PARSE-RPC-REPLY *STREAM* (RPC-PROCEDURE-RESULTTYPES 
                                                                         *PROCEDURE*)
                                           ERRORFLG))
                       (WHEN *DEBUG* (FORMAT *DEBUG-IO* " => ~S~%" RESULT))
                       (WHEN NOTE-ADDRESS

                           (IL:* IL:|;;| "Hack for call-via-portmapper")

                           (PUSH (IL:|fetch| IL:IPSOURCEADDRESS IL:|of| (RPC-STREAM-INSTREAM
                                                                                 *STREAM*))
                                 RESULT))))
                   RESULT))))

(DEFUN RPC-RESOLVE-HOST (DESTINATION)
   "Takes an IPADDRESS, symbol, or string and tries to find an IPADDRESS for a remote host.  Signals an error if it cannot resolve the host."
   (OR (FIND-RPC-HOST DESTINATION)
       (ERROR "Could not find an IP address for destination ~A" DESTINATION)))

(DEFUN RPC-RESOLVE-PROG (PROGRAM &OPTIONAL VERSION PROTOCOL)
   "Takes an RPC-PROGRAM, a number, a symbol, or a string along with an optional VERSION and PROTOCOL and tries to find the matching RPC-PROGRAM.
Signals an error if it cannot find the intended program."
   (OR (TYPECASE PROGRAM
           (RPC-PROGRAM PROGRAM)
           (SYMBOL (FIND-RPC-PROGRAM :NAME PROGRAM :VERSION VERSION :PROTOCOL PROTOCOL))
           (NUMBER (FIND-RPC-PROGRAM :NUMBER PROGRAM :VERSION VERSION :PROTOCOL PROTOCOL))
           (STRING (FIND-RPC-PROGRAM :NAME (INTERN PROGRAM)
                          :VERSION VERSION :PROTOCOL PROTOCOL)))
       (ERROR "Could not find definition for program ~A~@[, version ~D~]~@[, protocol ~a~]." PROGRAM
              VERSION PROTOCOL)))

(DEFUN RPC-RESOLVE-PROC (PROGRAM PROCID)
   "Given an RPC-PROGRAM struct PROGRAM, tries to find and return an RPC-PROCEDURE in RPROG specified by a number, string,  symbol, or RPC-PROCEDURE.

Signals an error if it cannot find the intended rpc-procedure."
   (COND
      ((TYPEP PROCID 'RPC-PROCEDURE)
       PROCID)
      ((FIND-RPC-PROCEDURE PROGRAM PROCID))
      (T (ERROR "Could not find definition for procedure ~a of program ~a~%" PROCID (RPC-PROGRAM-NAME
                                                                                     PROGRAM)))))

(DEFUN RPC-FIND-SOCKET (DESTADDR PROGRAM PROTOCOL &OPTIONAL ERRORFLG)
   "Tries to find and return a remote socket number.

(1) Looks in *RPC-WELL-KNOWN-SOCKETS*,
(2) Looks in *RPC-SOCKET-CACHE*, but only if *RPC-OK-TO-CACHE*,
(3) Requests socket number via remote procedure call to Portmapper on remote machine. If found and *RPC-OK-TO-CACHE*, caches the new socket number on *RPC-SOCKET-CACHE*.
(4) If all the above have failed, signals an error."
   (LET ((PROGNUM (RPC-PROGRAM-NUMBER PROGRAM))
         (PROGVERS (RPC-PROGRAM-VERSION PROGRAM))
         (DEBUG (AND (NUMBERP *DEBUG*)
                     (> *DEBUG* 1)))
         SKT ERROR)
        (COND
           ((SETQ SKT (FIND-CACHED-SOCKET '* PROGNUM PROGVERS PROTOCOL *RPC-WELL-KNOWN-SOCKETS*))
            (WHEN DEBUG
                (FORMAT-T "~&Using well-known socket ~D for program ~A~%" SKT (RPC-PROGRAM-NAME
                                                                                   PROGRAM)))
            SKT)
           ((AND *RPC-OK-TO-CACHE* (SETQ SKT (FIND-CACHED-SOCKET DESTADDR PROGNUM PROGVERS 
                                                    PROTOCOL *RPC-SOCKET-CACHE*)))
            (WHEN DEBUG
                (FORMAT-T "~&Using cached socket ~D for program ~A~%" SKT (RPC-PROGRAM-NAME
                                                                               PROGRAM)))
            SKT)
           ((SETQ ERROR
                  (PROGN (WHEN DEBUG
                             (FORMAT-T "~&Looking up socket for program ~a on ~a..." (
                                                                                     RPC-PROGRAM-NAME
                                                                                          PROGRAM)
                                    (IPADDRESS-TO-STRING DESTADDR)))
                         (COND
                            ((NULL (SETQ SKT (REMOTE-PROCEDURE-CALL
                                              DESTADDR
                                              'PORTMAPPER
                                              'LOOKUP
                                              `(,PROGNUM ,PROGVERS
                                                      ,(OR (CDR (ASSOC PROTOCOL *RPC-PROTOCOLS*))
                                                           (ERROR "Unknown protocol ~S" PROTOCOL))
                                                      0)
                                              :REMOTESOCKET *PORTMAPPER-SOCKET* :ERRORFLG ERRORFLG)))
                                                             (IL:* IL:\; 
                                                           "No reply?  Or ERRORFLG is :NOERRORS")
                             '("No reply from Portmapper"))
                            ((EQ (FIRST SKT)
                                 'ERROR)                     (IL:* IL:\; "Error return ")
                             (CDR SKT))
                            ((<= (SETQ SKT (FIRST SKT))
                                 0)                          (IL:* IL:\; 
                                                           "This is really an error reply")
                             `(PROGRAM-UNAVAILABLE ,PROGRAM "per portmapper")))))
            (RPC-SIGNAL-ERROR ERRORFLG ERROR))
           (T (WHEN DEBUG (FORMAT-T "found ~D.~%" SKT))
              (WHEN *RPC-OK-TO-CACHE* (CACHE-SOCKET PROGRAM DESTADDR SKT))
              SKT))))

(DEFUN ENCODE-RPC-ARGS (STREAM ARGLIST *PROCEDURE*)
   "Takes a list of arguments and the corresponding XDR procedure definition and converts the arguments into XDR, writing them into the RPC-STREAM."
   (LET ((ENCODEFN (RPC-PROCEDURE-ARGTYPES *PROCEDURE*)))
        (COND
           ((NULL ENCODEFN)
            (UNLESS (NULL ARGLIST)                           (IL:* IL:\; 
                                                           "Expected no args, got some")
                (RPC-ARGUMENT-ERROR ARGLIST 0)))
           ((AND (CONSP ENCODEFN)
                 (NOT (EQ (CAR ENCODEFN)
                          'LAMBDA)))                         (IL:* IL:\; 
                                                           "Old style, one procedure per arg")
            (DO ((XDR-FNS ENCODEFN (REST XDR-FNS))
                 (ARGS ARGLIST (REST ARGS)))
                ((OR (NULL ARGS)
                     (NULL XDR-FNS))
                 (IF (OR XDR-FNS ARGS)
                     (RPC-ARGUMENT-ERROR ARGLIST (LENGTH ENCODEFN))))
              (FUNCALL (FIRST XDR-FNS)
                     STREAM
                     (FIRST ARGS))))
           (T                                                (IL:* IL:\; 
                                                           "New style: call a single function")
              (FUNCALL ENCODEFN STREAM ARGLIST)))))

(DEFUN PARSE-RPC-REPLY (RPCSTREAM RETTYPES &OPTIONAL ERRORFLG)
   "Parses a reply message.  If all goes well, returns a list of the values returned (or T if RETTYPES is NIL).

If RPC was REJECTED, or ACCEPTED but with an ACCEPT-STAT other than SUCCESS, then (Following Courier) the response depends on the value of ERRORFLG:
	If ERRORFLG = 'NOERROR, then returns NIL
	If ERRORFLG = 'RETURNERRORS, then returns a list of the form
		(ERROR reply-stat accept-or-reject-stat otherinfo)
	If ERRORFLG = anything else, signals Lisp error."

   (IL:* IL:|;;| "Most of what goes on here could be one big XDR-GENCODE-INLINE of the reply structure, except that in the normal success case, the inside is procedure-dependent.  So this is a hand-coding of the reply structure.")

   (MACROLET ((GETUNSIGNED NIL                               (IL:* IL:\; "Small optimization")
                     '(FUNCALL UFN RPCSTREAM)))
          (LET* ((UFN (RPC-METHOD GETUNSIGNED RPCSTREAM))
                 MSGTYPE REPLY-STAT)
                (COND
                   ((NOT (EQL (SETQ MSGTYPE (GETUNSIGNED))
                              *RPC-MSG-REPLY*))
                    (RPC-SIGNAL-ERROR ERRORFLG `(NOT-A-REPLY ,MSGTYPE)))
                   ((EQL (SETQ REPLY-STAT (GETUNSIGNED))
                         *RPC-REPLY-ACCEPTED*)
                    (LET ((VERF (DECODE-AUTHENTICATION RPCSTREAM))
                          (ACCEPT-STAT (GETUNSIGNED)))
                         (COND
                            ((NOT (EQL ACCEPT-STAT *RPC-ACCEPT-SUCCESS*))
                             (RPC-SIGNAL-ERROR ERRORFLG
                                    (CONS (SETQ ACCEPT-STAT (OR (CDR (ASSOC ACCEPT-STAT 
                                                                            *RPC-ACCEPT-STATS*))
                                                                ACCEPT-STAT))
                                          (CASE ACCEPT-STAT
                                              (PROGRAM-MISMATCH 
                                                             (IL:* IL:\; 
                                                          "Includes high and low accepted versions")
                                                 (LIST (GETUNSIGNED)
                                                       (GETUNSIGNED)))))))
                            (T (DECODE-RPC-ARGS RPCSTREAM RETTYPES)))))
                   ((EQL REPLY-STAT *RPC-REPLY-REJECTED*)
                    (RPC-SIGNAL-ERROR ERRORFLG (XDR-GENCODE-INLINE
                                                    NIL
                                                    '(:UNION (:ENUMERATION :NOERRORS (
                                                                                 RPC-VERSION-MISMATCH
                                                                                      0)
                                                                    (AUTHENTICATION 1))
                                                            (RPC-VERSION-MISMATCH (:LIST :UNSIGNED 
                                                                                         :UNSIGNED))
                                                            (AUTHENTICATION (:ENUMERATION
                                                                             :NOERRORS
                                                                             (BAD-CREDENTIALS 1)
                                                                             (REJECTED-CREDENTIALS
                                                                              2)
                                                                             (BAD-VERIFIER 3)
                                                                             (REJECTED-VERIFIER
                                                                              4)
                                                                             (TOO-WEAK 5))))
                                                    'READ RPCSTREAM)))
                   (T (RPC-SIGNAL-ERROR ERRORFLG `(ILLEGAL-REPLY-TYPE ,REPLY-STAT)))))))

(DEFMACRO DECODE-RPC-ARGS (RPCSTREAM RETTYPES)

   (IL:* IL:|;;| "This encapsulates how we read procedure-dependent reply data from RPCSTREAM")

   `(COND
       ((NULL ,RETTYPES)                                     (IL:* IL:\; 
                     "Returns nothing.  We return T to distinguish this from a :NOERROR NIL return")
        T)
       ((AND (CONSP ,RETTYPES)
             (NOT (EQ (CAR ,RETTYPES)
                      'LAMBDA)))                             (IL:* IL:\; 
                                                     "Old style: Call one function per result type")
        (MAPCAR #'(LAMBDA (FN)
                         (FUNCALL FN ,RPCSTREAM))
               ,RETTYPES))
       (T                                                    (IL:* IL:\; 
                                       "New style: Call a single function to read all the results.")
          (FUNCALL ,RETTYPES ,RPCSTREAM))))

(DEFUN RPC-HANDLE-TIMEOUT (STREAM TIMEOUT-COUNT ERRORFLG)

   (IL:* IL:|;;| "Called when an RPC call times out on STREAM.  TIMEOUT-COUNT is number from 1... indicating how many times we have timed out on this call.  ERRORFLG is the arg to perform-rpc.  If this procedure returns, it is either a value to return from the call, or :CONTINUE to keep trying.")

   (LET ((HANDLER (RPC-STREAM-TIMEOUT-HANDLER STREAM)))
        (CASE HANDLER
            ((NIL :NOERRORS :RETURNERRORS) (RPC-SIGNAL-ERROR (OR HANDLER ERRORFLG)
                                                  '(RPC-TIMEOUT)))
            (OTHERWISE                                       (IL:* IL:\; 
                 "Call the handler and return what it returns, or keep trying if it says :CONTINUE")
               (IF (EQ (SETQ HANDLER (FUNCALL HANDLER STREAM TIMEOUT-COUNT))
                       T)                                    (IL:* IL:\; 
  "Synonym for :continue -- T is \"successful return\" from exchange, so don't want that confusion")
                   :CONTINUE
                   HANDLER)))))

(DEFUN RPC-SIGNAL-ERROR (ERRORFLG ERRORFORM)
   (CASE ERRORFLG
       (:NOERRORS NIL)
       (:RETURNERRORS (CONS 'ERROR ERRORFORM))
       (OTHERWISE                                            (IL:* IL:\; 
                                                           "Signal the appropriate kind of error.")
          (CASE (CAR ERRORFORM)
              (RPC-TIMEOUT (ERROR 'RPC-TIMEOUT))
              (OTHERWISE (ERROR 'RPC-ERROR-REPLY :TYPE (CAR ERRORFORM)
                                :ARGS
                                (CDR ERRORFORM)))))))

(DEFUN RPC-ARGUMENT-ERROR (ACTUALS EXPECTED#)

   (IL:* IL:|;;| "Called when rpc call got wrong number of args")

   (ERROR "Wrong number of arguments to procedure ~A.~A:  Expected ~D, got ~D." (IF *PROGRAM*
                                                                                    (RPC-PROGRAM-NAME
                                                                                     *PROGRAM*)
                                                                                    "?")
          (IF *PROCEDURE*
              (RPC-PROCEDURE-NAME *PROCEDURE*)
              "?")
          EXPECTED#
          (LENGTH ACTUALS)))

(DEFUN CREATE-XID ()
   "Returns a number to use as the ID of a given transmisssion."

   (IL:* IL:|;;| "ID's are 32 bits, but we want to stick to less than 2^31 to avoid touching bignums.  To be really tense, we could stick to less than 2^16, which is probably safe, though at a sustained a rate of 100 transactions per second (a wild rate), it would take little over 10 minutes to cycle thru them all.  At 2^26 it would take a week at that rate. ")

   (IF (> (INCF *XID-COUNT*)
          *XID-MAX*)
       (SETQ *XID-COUNT* 1)
       *XID-COUNT*))



(IL:* IL:\; "RPC Utility Functions")


(DEFUN FIND-CACHED-SOCKET (DESTADDR PROGNUM PROGVERS PROTOCOL CACHE)
   "Looks up a given (DESTADDR, PROGNUM, PROGVERS, PROTOCOL) in the specified CACHE."
   (DOLIST (ENTRY CACHE)
       (WHEN (AND (EQL (CAR ENTRY)
                       DESTADDR)
                  (EQL (CAR (SETQ ENTRY (CDR ENTRY)))
                       PROGNUM)
                  (EQL (CAR (SETQ ENTRY (CDR ENTRY)))
                       PROGVERS)
                  (EQ (CAR (SETQ ENTRY (CDR ENTRY)))
                      PROTOCOL))                             (IL:* IL:\; 
                                                      "Found it-fifth element is the socket number")
           (RETURN (CADR ENTRY)))))

(DEFUN CACHE-SOCKET (PROGRAM ADDRESS SKT)

   (IL:* IL:|;;| "Add this info to socket cache")

   (UNLESS (INTEGERP ADDRESS)
       (SETQ ADDRESS (RPC-RESOLVE-HOST ADDRESS)))
   (CHECK-TYPE SKT INTEGER)
   (PUSH `(,ADDRESS ,(RPC-PROGRAM-NUMBER PROGRAM)
                 ,(RPC-PROGRAM-VERSION PROGRAM)
                 ,(RPC-PROGRAM-PROTOCOL PROGRAM)
                 ,SKT)
         *RPC-SOCKET-CACHE*))

(DEFUN CLEAR-CACHE (&OPTIONAL PROGRAM ADDRESS)

   (IL:* IL:|;;| 
 "Clear cache of any info about port for PROGRAM at ADDRESS.  NIL for either arg means \"any\".")

   (SETQ *RPC-SOCKET-CACHE* (COND
                               ((OR PROGRAM ADDRESS)
                                (WHEN PROGRAM
                                    (SETQ PROGRAM (RPC-RESOLVE-PROG PROGRAM)))
                                (WHEN ADDRESS
                                    (SETQ ADDRESS (RPC-RESOLVE-HOST ADDRESS)))
                                (DELETE-IF #'(LAMBDA (ENTRY)
                                                    (AND (OR (NULL ADDRESS)
                                                             (EQL (FIRST ENTRY)
                                                                  ADDRESS))
                                                         (OR (NULL PROGRAM)
                                                             (AND (EQ (SECOND ENTRY)
                                                                      (RPC-PROGRAM-NUMBER PROGRAM))
                                                                  (EQ (THIRD ENTRY)
                                                                      (RPC-PROGRAM-VERSION PROGRAM)))
                                                             )))
                                       *RPC-SOCKET-CACHE*))))
   T)

(DEFUN IPADDRESS-TO-STRING (IPADDRESS)
   "Render IPADDRESS in the canonical printed representation of i.j.k.l"
   (FORMAT NIL "~D.~D.~D.~D" (LDB (BYTE 8 24)
                                  IPADDRESS)
          (LDB (BYTE 8 16)
               IPADDRESS)
          (LDB (BYTE 8 8)
               IPADDRESS)
          (LDB (BYTE 8 0)
               IPADDRESS)))



(IL:* IL:\; "Authentication")


(DEFCONSTANT *AUTHENTICATION-TYPEDEF*
   '(:STRUCT AUTHENTICATION (TYPE (:ENUMERATION (:NULL 0)
                                         (:UNIX 1)
                                         (:SHORT 2)))
           (STRING :STRING)))

(DEFCONSTANT *NULL-AUTHENTICATION* (MAKE-AUTHENTICATION :TYPE :NULL :STRING ""))

(DEFUN CREATE-UNIX-AUTHENTICATION (STAMP MACHINE-NAME UID GID GIDS)
   "Given the fields of a Unix authentication, creates an AUTHENTICATION struct with these fields encoded as a string."
   (LET ((TEMPSTREAM (CREATE-STRING-RPC-STREAM)))
        (PUTUNSIGNED TEMPSTREAM STAMP)
        (XDR-STRING TEMPSTREAM MACHINE-NAME)
        (PUTUNSIGNED TEMPSTREAM UID)
        (PUTUNSIGNED TEMPSTREAM GID)
        (XDR-GENCODE-INLINE NIL '(:LIST-OF :UNSIGNED)
               'WRITE TEMPSTREAM GIDS)
        (MAKE-AUTHENTICATION :TYPE :UNIX :STRING (RPC-GET-STRING-RESULT TEMPSTREAM))))

(DEFUN ENCODE-AUTHENTICATION (RPCSTREAM AUTH)
   "
Given an AUTHENTICATION struct, converts the struct to its XDR encoding and writes it to
the RPC-STREAM specified.
"
   (IF (NULL AUTH)
       (SETQ AUTH *NULL-AUTHENTICATION*))
   (CHECK-TYPE AUTH AUTHENTICATION)
   (XDR-GENCODE-INLINE NIL *AUTHENTICATION-TYPEDEF* 'WRITE RPCSTREAM AUTH))

(DEFUN DECODE-AUTHENTICATION (RPCSTREAM)
   "Reads an authentication from specified RPC-STREAM and returns it as an AUTHENTICATION struct."

   (IL:* IL:|;;| "Used to do this as (xdr-gencode-inline nil *authentication-typedef* 'read rpcstream), but that conses a string and authentication object on every rpc reply, even though virtually always it is the null authentication.  We expect: authtype (integer) followed by string.")

   (LET ((TYPE (GETCELL RPCSTREAM))
         (LEN (GETUNSIGNED RPCSTREAM)))
        (COND
           ((AND (EQL TYPE 0)
                 (EQL LEN 0))                                (IL:* IL:\; "The null authentication")
            NIL)
           (T                                                (IL:* IL:\; 
                                           "Go ahead and make one, and read the rest of the string")
              (MAKE-AUTHENTICATION :TYPE (CASE TYPE
                                             (0 :NULL)
                                             (1 :UNIX)
                                             (2 :SHORT)
                                             (OTHERWISE NIL))
                     :STRING
                     (XDR-READ-ARRAY RPCSTREAM LEN))))))



(IL:* IL:\; "Interface to RESTART.ETHER")


(DEFUN RPC-RESTART (EVENT)

   (IL:* IL:|;;| "Called by RESTART.ETHER")

   (SETQ *RPC-SOCKET-CACHE* NIL))

(IL:APPENDTOVAR IL:RESTARTETHERFNS RPC-RESTART)
(IL:PUTPROPS IL:RPCRPC IL:COPYRIGHT ("Stanford University and Xerox Corporation" 1987 1988 1989 1994))
(IL:DECLARE\: IL:DONTCOPY
  (IL:FILEMAP (NIL)))
IL:STOP
