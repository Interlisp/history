(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "RPC2")
(il:filecreated "17-Nov-88 15:29:51" il:|{NB:PARC:XEROX}<NFS>SOURCES>RPCXDR.;3| 31720  

      il:|changes| il:|to:|  (il:functions xdr-enumeration-fault)

      il:|previous| il:|date:| "11-Nov-88 18:45:06" il:|{NB:PARC:XEROX}<NFS>SOURCES>RPCXDR.;2|)


; Copyright (c) 1987, 1988 by Stanford University and Xerox Corporation.  All rights reserved.

(il:prettycomprint il:rpcxdrcoms)

(il:rpaqq il:rpcxdrcoms ((il:props (il:rpcxdr il:makefile-environment il:filetype)) (eval-when (eval compile) (il:files il:rpcdecls)) (il:coms (il:* il:\; "Useful Constants") (il:variables twoto31minusone twoto31st twoto32nd twoto32minusone twoto63minusone twoto64minusone twoto64th minus2to31 minus2to63)) (il:variables *xdr-primitive-types* *xdr-constructed-types* *xdr-codegen-recursivelst*) (il:structures typstk) (il:coms (il:* il:\; "Miscellaneous XDR Utility Functions") (il:functions access-fcn-name constructor-fcn-name find-in-type-stack)) (il:coms (il:* il:\; "Type Declarations and Predicates") (il:types xdr-integer xdr-unsigned xdr-hyperinteger xdr-hyperunsigned) (il:functions xdr-integer-p xdr-unsigned-p xdr-hyperinteger-p xdr-hyperunsigned-p)) (il:coms (il:* il:\; "XDR Code Generation for Constructed Functions") (il:functions xdr-codegen-comment xdr-codegen xdr-codegen-1 xdr-codegen-2 xdr-codegen-3 xdr-codegen-recursion xdr-codegen-constant xdr-codegen-enumeration xdr-codegen-union xdr-codegen-union-cases xdr-codegen-list xdr-codegen-struct xdr-codegen-fixed-array xdr-codegen-counted-array xdr-codegen-list-of xdr-codegen-opaque xdr-codegen-skip xdr-codegen-sequence)) (il:coms (il:* il:\; "XDR run-time primitives") (il:functions xdr-read-integer xdr-write-integer xdr-read-boolean xdr-write-boolean xdr-read-unsigned xdr-write-unsigned xdr-read-hyperinteger xdr-write-hyperinteger xdr-read-hyperunsigned xdr-write-hyperunsigned xdr-read-string xdr-write-string xdr-read-float xdr-write-float xdr-read-string-pointer xdr-read-array xdr-write-array xdr-write-string-pointer xdr-skip-primitive xdr-zero-primitive xdr-read-write-void xdr-enumeration-fault xdr-make-opaque) (il:* il:\; "These are for backward compatibility") (il:functions xdr-boolean xdr-integer xdr-unsigned xdr-hyperinteger xdr-hyperunsigned xdr-string xdr-string-pointer xdr-float xdr-void xdr-opaque-primitive))))

(il:putprops il:rpcxdr il:makefile-environment (:readtable "XCL" :package "RPC2"))

(il:putprops il:rpcxdr il:filetype :compile-file)
(eval-when (eval compile)

(il:filesload il:rpcdecls)
)



(il:* il:\; "Useful Constants")


(defconstant twoto31minusone 2147483647)

(defconstant twoto31st 2147483648)

(defconstant twoto32nd 4294967296)

(defconstant twoto32minusone 4294967295)

(defconstant twoto63minusone 9223372036854775807)

(defconstant twoto64minusone 18446744073709551615)

(defconstant twoto64th 18446744073709551616)

(defconstant minus2to31 -2147483648)

(defconstant minus2to63 -9223372036854775808)

(defparameter *xdr-primitive-types* (quote ((:integer xdr-read-integer . xdr-write-integer) (:boolean xdr-read-boolean . xdr-write-boolean) (:unsigned xdr-read-unsigned . xdr-write-unsigned) (:hyperinteger xdr-read-hyperinteger . xdr-write-hyperinteger) (:hyperunsigned xdr-read-hyperunsigned . xdr-write-hyperunsigned) (:string xdr-read-string . xdr-write-string) (:void . xdr-read-write-void) (:float xdr-read-float . xdr-write-float) (:double . xdr-double) (:string-pointer xdr-read-string-pointer . xdr-write-string-pointer))) "An alist of XDR primitive types and the function(s) that encodes/decodes that type.  If CDR is a list, it is (readfn . writefn).")

(defparameter *xdr-constructed-types* (quote ((:enumeration . xdr-codegen-enumeration) (:union . xdr-codegen-union) (:struct . xdr-codegen-struct) (:list . xdr-codegen-list) (:fixed-array . xdr-codegen-fixed-array) (:counted-array . xdr-codegen-counted-array) (:opaque . xdr-codegen-opaque) (:skip . xdr-codegen-skip) (:sequence . xdr-codegen-sequence) (:list-of . xdr-codegen-list-of))) "Association list of XDR constructed types and the functions that create functions to read/write them")

(defglobalvar *xdr-codegen-recursivelst* nil "
Place for XDR-CODEGEN to save recursive functions it found in making an expansion.
A list of TYPSTK structs
")

(defstruct typstk "Element on stack of types for which code already generated." prog type xdrproc oper args)



(il:* il:\; "Miscellaneous XDR Utility Functions")


(defun access-fcn-name (struct field) "
Maps struct name and field name (strings or symbols) into the
access function name for that slot." (il:* il:\; "") (intern (concatenate (quote string) (string struct) "-" (string field)) (symbol-package struct)))

(defun constructor-fcn-name (struct) "
Maps a symbol or string naming a defstruct into the constructor function symbol
for that defstruct type" (intern (concatenate (quote string) "MAKE-" (string struct)) (symbol-package struct)))

(defun find-in-type-stack (prg typ stack) "
Find the first element in a list of TYPSTK's such that PRG and TYP
match the PROG and TYPE fields of the TYPSTK.
" (dolist (el stack) (if (and (eql prg (typstk-prog el)) (eql typ (typstk-type el))) (return el))))



(il:* il:\; "Type Declarations and Predicates")


(deftype xdr-integer nil (quote (and integer (satisfies xdr-integer-p))))

(deftype xdr-unsigned nil (quote (and integer (satisfies xdr-unsigned-p))))

(deftype xdr-hyperinteger nil (quote (and integer (satisfies xdr-hyperinteger-p))))

(deftype xdr-hyperunsigned nil (quote (and integer (satisfies xdr-hyperunsigned-p))))

(defun xdr-integer-p (i) (and (>= i minus2to31) (< i twoto31st)))

(defun xdr-unsigned-p (i) (or (and (typep i (quote fixnum)) (>= (the fixnum i) 0)) (and (>= i 0) (< i twoto32nd))))

(defun xdr-hyperinteger-p (i) (and (>= i minus2to63) (<= i twoto63minusone)))

(defun xdr-hyperunsigned-p (i) (and (>= i 0) (<= i twoto64minusone)))



(il:* il:\; "XDR Code Generation for Constructed Functions")


(defun xdr-codegen-comment nil "
***************************************************
**** Code Generation for XCL Constructed Types ****
***************************************************
The following functions generate code for translating between Common Lisp
and XDR. For each function,
    CONTEXT is an RPC-PROGRAM structure with respect to which a
            typedef is being constructed.
    TYPEDEF is an XDR type definition, and
    OPER is either READ (decode) or WRITE (encode).
For all functions except XDR-CODEGEN, a third argument ARGS is a list of
arguments to the code being generated. It always begins with an XDR-stream argument
and for OPER=WRITE is usually followed by the object to be written.

WARNINGS:

(1) DO NOT, REPEAT DO NOT pass an (XDR-CODEGEN-xxx) as the argument of an
(XDR-CODEGEN-xxx). If you do, you might cause the  code generated for
the argument to be evaluated multiple times in the code for the resulting 
expression.

(2) The XDR-CODEGEN-xxx functions code in-line rather than wrap themselves
in LET's or LAMBDA's or whatever. To avoid complications with functions
that require a location-specifier (CHECK-TYPE or CCASE, for example), an
XDR-CODEGEN-xxx function may ***not*** generate code that assumes that its
arguments ARGS or various COUNTs are legitimate location-specifiers. If a 
CHECK-TYPE or similar function is to be done, a LET (or other binding
mechanism) should be generated to create a legal location-specifier." nil)

(defun xdr-codegen (context typedef oper) "
Top-level XDR Code Generation function. Returns code to read/write
an XDR element of type TYPEDEF.

CONTEXT is an RPC-PROGRAM structure with respect to which the
TYPEDEF is interpreted (in terms of inheritance).

TYPEDEF is an XDR Type or Type definition.

OPER is either 'RPC2::READ or 'RPC::WRITE.

See documentation of XDR-CODEGEN-COMMENT.
" (setq *xdr-codegen-recursivelst* nil) (let* ((args (ecase oper (read (quote (xdr-stream))) (write (quote (xdr-stream xdr-toplevel-item))))) (fcn (xdr-codegen-1 context typedef oper args nil))) (if fcn (if (null *xdr-codegen-recursivelst*) (list (quote lambda) args fcn) (list (quote lambda) args (il:bquote (labels (il:\\\, (xdr-codegen-3 *xdr-codegen-recursivelst*)) (il:\\\, fcn))))) (error "Could not parse XDR Type ~S" typedef))))

(defun xdr-codegen-1 (context typedef oper args stk) "Generates code to read or write an element of type TYPEDEF.

CONTEXT, TYPEDEF, and OPER are as in XDR-CODEGEN.

ARGS is a list of the arguments forms for the generated code.
For OPER=READ it will (<rpc-stream-name>), and
For OPER=WRITE it will be (<rpc-stream-name> <element>).

STK is a list of TYPSTK elements, one for each named type above this one in this expansion." (or (cond ((symbolp typedef) (il:* il:\; "Primitive, local or inherited type") (let ((tem (cdr (assoc typedef *xdr-primitive-types*)))) (cond (tem (il:* il:\; "Here's how to read/write it.") (cons (cond ((not (consp tem)) (il:* il:\; "Old way is single fn") tem) ((eq oper (quote read)) (il:* il:\; "New way is (read . write)") (car tem)) (t (cdr tem))) args)) ((setq tem (find-rpc-typename context typedef)) (il:* il:\; "It's defined in this program") (xdr-codegen-2 context tem oper args stk)) (t (il:* il:\; "Try to inherit it") (some (function (lambda (progname) (let ((prg (find-rpc-program :name progname)) td) (and prg (setq td (find-rpc-typename prg typedef)) (xdr-codegen-2 prg td oper args stk))))) (rpc-program-inherits context)))))) ((consp typedef) (il:* il:\; "Constructed or qualified type") (let ((fn (cdr (assoc (car typedef) *xdr-constructed-types*))) prg td) (cond (fn (il:* il:\; "Here's a function to generate code") (funcall fn context typedef oper args stk)) ((and (symbolp (car typedef)) (symbolp (cdr typedef)) (setq prg (find-rpc-program :name (car typedef))) (setq td (find-rpc-typedef prg (cdr typedef)))) (il:* il:\; "Qualified def (prgname . type)") (xdr-codegen-2 prg td oper args stk)))))) (error "Could not resolve XDR Type Definition: ~S" typedef)))

(defun xdr-codegen-2 (context typename oper args stk) "
Expands named types. 

(1) Sees whether type already seen above here in this expansion.
Otherwise,
(2) Notes the name on TYPESTK,
(3) Finds the definition of this type,
(4) Calls XDR-CODEGEN-1 to expand the type definition.
(5) Sees whether the XDR-CODEGEN-1 call found this type below,
     if so, notes this on *XDR-CODEGEN-RECURSIVELST* and returns
     call to the recursive function for this type.
     otherwise just returns the code.
" (il:* il:|;;| "Every named type expansion passes through here and gets expanded. Since it is only named types that can be recursive,  this is the only place we check for recursion") (or (xdr-codegen-recursion context typename oper args stk) (let (td code top) (il:* il:\; "No") (push (make-typstk :prog context :type typename :oper oper :args (if (eql oper (quote read)) args (quote (rpcstream rvalue)))) stk) (il:* il:\; "Push type on stack") (unless (setq td (find-rpc-typedef context typename)) (error "Null type definition for Program ~A, Type ~A" (and context (rpc-program-name context)) typename)) (setq code (xdr-codegen-1 context td oper args stk)) (il:* il:\; "Generate code") (setq top (car stk)) (il:* il:\; "\"Pop\" stack") (if (null (typstk-xdrproc top)) (il:* il:\; "Was this type called recursively?") code (il:* il:\; "No, just return code") (progn (push top *xdr-codegen-recursivelst*) (il:* il:\; "Yes, save recursive type") (il:bquote ((il:\\\, (typstk-xdrproc top)) (il:\\\,@ args))) (il:* il:\; "Return call to recursive function"))))))

(defun xdr-codegen-3 (rlist) (il:* il:|;;| "Generate the set of function definitions for LABELS. RLIST is a list of TYPSTK structs.") (mapcar (function (lambda (typstk) (il:bquote ((il:\\\, (typstk-xdrproc typstk)) (il:\\\, (typstk-args typstk)) (il:\\\, (xdr-codegen-1 (typstk-prog typstk) (or (find-rpc-typedef (typstk-prog typstk) (typstk-type typstk)) (error "No typedef for Program ~A, Type ~A" (rpc-program-name (typstk-prog typstk)) (typstk-type typstk))) (typstk-oper typstk) (typstk-args typstk) rlist)))))) rlist))

(defun xdr-codegen-recursion (prg typ oper args stack) (il:* il:|;;| " If type has already be seen, mark as recursive and return code calling that function") (let ((instack (find-in-type-stack prg typ stack))) (when instack (il:* il:\; "Seen it before") (setf (typstk-xdrproc instack) (or (typstk-xdrproc instack) (intern (symbol-name (gensym (concatenate (quote string) "XDR-" (symbol-name oper) "-" (symbol-name typ) "-")))))) (il:bquote ((il:\\\, (typstk-xdrproc instack)) (il:\\\,@ args))))))

(defun xdr-codegen-constant (context constant) (cond ((null constant) (error "Could not resolve nil constant definition from RPC program ~a~%" (rpc-program-name context))) ((integerp constant) constant) (il:* il:\; " Immediate Constant Definition") ((and (symbolp constant) (or (find-xdr-constant context constant) (il:* il:\; " Local Constant Definition") (some (function (lambda (cntx) (find-xdr-constant (find-rpc-program :name cntx) constant))) (rpc-program-inherits context)) (il:* il:\; " Inherited Constant Definition")))) ((and (consp constant) (il:* il:\; "Qualified Constant Definition ") (symbolp (cdr constant)) (find-xdr-constant (find-rpc-program :name (car constant)) (cdr constant)))) ((error "Could not resolve XDR constant ~a~%" constant))))

(defun xdr-codegen-enumeration (context typedef oper args stk) (let ((cases (cdr typedef)) (selector (if (eq oper (quote read)) (quote key) (cadr args))) default parent) (cond ((eq (first cases) :noerrors) (il:* il:\; "Means allow values other than shown here, which we will just represent by the integer value") (setq cases (cdr cases)) (setq default selector)) (t (il:* il:\; "Generate error clause if selector invalid.  Inlcude the type that produced this enumeration if it's simple") (setq default (il:bquote (xdr-enumeration-fault (il:\\\, selector) (quote (il:\\\, oper)) (il:\\\,@ (and (consp stk) (symbolp (setq parent (typstk-type (first stk)))) (il:bquote ((quote (il:\\\, parent))))))))))) (if (eq oper (quote read)) (il:bquote (let ((key (xdr-read-integer (il:\\\, (car args))))) (case key (il:\\\,. (mapcar (function (lambda (x) (il:bquote ((il:\\\, (xdr-codegen-constant context (cadr x))) (quote (il:\\\, (car x))))))) cases)) (otherwise (il:\\\, default))))) (il:bquote (xdr-write-integer (il:\\\, (car args)) (case (il:\\\, selector) (il:\\\,. (mapcar (function (lambda (x) (list (car x) (xdr-codegen-constant context (cadr x))))) cases)) (otherwise (il:\\\, default))))))))

(defun xdr-codegen-union (context typedef oper args stk) "
(UNION <discriminant-type> (<enumeration-element> <arm-type>) ...(<> <>))
Read Calling Sequence: XDR-UNION(xdrstream)
Read Input: An integer followed by the encoding of that arm.
Read Output: The enumeration element from the type of the discriminant
             The discriminant and arm are returned as a dotted pair.
Write Input: An enumeration element and an unencoded arm.
Write calling sequence: XDR-UNION(xdrstream,discriminant,arm)
Write Output: The (integer) encoding of the discriminant and the encoded arm.
" (let ((discrim-type (second typedef)) (xdrstream (first args)) (unionlist (second args))) (if (eq oper (quote read)) (il:bquote (let ((discriminant (il:\\\, (xdr-codegen-1 context discrim-type oper args stk)))) (list discriminant (case discriminant (il:\\\,. (xdr-codegen-union-cases context typedef oper args stk)))))) (il:bquote (progn (il:\\\, (xdr-codegen-1 context discrim-type oper (il:bquote ((il:\\\, xdrstream) (car (il:\\\, unionlist)))) stk)) (case (car (il:\\\, unionlist)) (il:\\\,. (xdr-codegen-union-cases context typedef oper args stk))))))))

(defun xdr-codegen-union-cases (context typedef oper args stk) (il:* il:|;;| "Generate the clauses for a CASE statement which resolves the cases of TYPEDEF = (:UNION enum . cases).") (do ((pairs (cddr typedef) (cdr pairs)) (recurargs (if (eq oper (quote read)) args (il:* il:\; "For WRITE, ARGS = (stream item).  Recursive calls will write (stream (cadr item)).") (il:bquote ((il:\\\, (first args)) (cadr (il:\\\, (second args))))))) (arms) (pair)) ((null pairs) (nreverse arms)) (setq pair (car pairs)) (push (il:bquote ((il:\\\, (if (or (eq (car pair) (quote otherwise)) (and (symbolp (car pair)) (string= (car pair) (quote default)))) (quote otherwise) (il:* il:\; "Default arm turns into OTHERWISE case.") (il:bquote ((il:\\\, (car pair)))))) (il:\\\, (xdr-codegen-1 context (cadr pair) oper recurargs stk)))) arms)))

(defun xdr-codegen-list (context typedef oper args stk) "TYPEDEF = (LIST <typedef-1> ... <typedef-n>)" (if (eq oper (quote read)) (il:bquote (list (il:\\\,. (mapcar (function (lambda (td) (xdr-codegen-1 context td oper args stk))) (cdr typedef))))) (let ((xdrstream (first args)) (thelist (second args)) (firsttime t)) (il:* il:|;;| "Walk down the list we're printing, generating code to write the CAR by the appropriate type def.") (il:bquote (let ((thelist (il:\\\, (second args)))) (il:\\\,@ (mapcar (function (lambda (type) (xdr-codegen-1 context type oper (il:bquote ((il:\\\, xdrstream) (car (il:\\\, (cond (firsttime (setq firsttime nil) (quote thelist)) (t (il:* il:\; "Get next tail") (quote (setq thelist (cdr thelist))))))))) stk))) (cdr typedef))))))))

(defun xdr-codegen-struct (context typedef oper args stk) "(STRUCT <defstruct-type> (<field-name> <type>) ... (<field-name> <type>))" (let ((struct-type (cadr typedef)) (xdrstream (first args)) (thestruct (second args))) (if (eq oper (quote read)) (il:bquote ((il:\\\, (constructor-fcn-name struct-type)) (il:* il:\; "Call the constructor with list of key val ...") (il:\\\,@ (mapcan (function (lambda (x) (il:* il:\; "X = (slotname type)") (list (intern (symbol-name (car x)) (find-package "KEYWORD")) (xdr-codegen-1 context (cadr x) oper args stk)))) (cddr typedef))))) (il:bquote (progn (il:\\\,@ (mapcar (function (lambda (x) (xdr-codegen-1 context (cadr x) oper (il:bquote ((il:\\\, xdrstream) ((il:\\\, (access-fcn-name struct-type (car x))) (il:\\\, thestruct)))) stk))) (cddr typedef))))))))

(defun xdr-codegen-fixed-array (context typedef oper args stk &optional run-time-count) "typedef is (:fixed-array elttype count), or (:counted-array elttype) with RUN-TIME-COUNT giving a run-time expression." (il:* il:|;;| "Read or write a sequence of exactly COUNT objects of type ELTTYPE") (let* ((element-type (second typedef)) (count (cond (run-time-count) (t (il:* il:\; "For FIXED-ARRAY, the count is a constant known at compile time and not encoded in the stream") (xdr-codegen-constant context (third typedef))))) (xdrstream (first args))) (unless run-time-count (check-type count (integer 0 *))) (if (eq oper (quote read)) (il:bquote (let* ((thecount (il:\\\, count)) (thearray (make-array thecount))) (dotimes (i thecount thearray) (setf (aref thearray i) (il:\\\, (xdr-codegen-1 context element-type oper args stk)))))) (il:bquote (let ((thearray (il:\\\, (second args)))) (dotimes (i (il:\\\, count) thearray) (il:\\\, (xdr-codegen-1 context element-type oper (il:bquote ((il:\\\, xdrstream) (aref thearray i))) stk))))))))

(defun xdr-codegen-counted-array (context typedef oper args stk) "typedef is (:counted-array element-type)" (il:* il:|;;| "Counted arrays are just like fixed arrays, except that they are preceded by their length (unsigned).") (if (eq oper (quote read)) (xdr-codegen-fixed-array context typedef oper args stk (xdr-codegen-1 context :unsigned oper args stk)) (let ((xdrstream (first args))) (il:bquote (let* ((thearray (il:\\\, (second args))) (thecount (length thearray))) (il:\\\, (xdr-codegen-1 context :unsigned oper (il:bquote ((il:\\\, xdrstream) thecount)) stk)) (il:\\\, (xdr-codegen-fixed-array context typedef oper (il:bquote ((il:\\\, xdrstream) thearray)) stk (quote thecount))))))))

(defun xdr-codegen-list-of (context typedef oper args stk) "typedef is (:list-of element-type)" (il:* il:|;;| "Read or write a list of elements all of the same type.  Stream encoding is the length of the list followed by the elements.") (let ((element-type (second typedef)) (xdrstream (first args))) (if (eq oper (quote read)) (il:bquote (il:to (il:\\\, (xdr-codegen-1 context :unsigned oper args stk)) il:collect (il:\\\, (xdr-codegen-1 context element-type oper args stk)))) (il:bquote (let* ((thelist (il:\\\, (second args))) (thecount (list-length thelist))) (il:\\\, (xdr-codegen-1 context :unsigned oper (il:bquote ((il:\\\, xdrstream) thecount)) stk)) (mapc (function (lambda (obj) (il:\\\, (xdr-codegen-1 context element-type oper (il:bquote ((il:\\\, xdrstream) obj)) stk)))) thelist))))))

(defun xdr-codegen-opaque (context typedef oper args stk) "Declaration is (opaque <bytecount> <array-type>)" (let ((bytecount (xdr-codegen-constant context (second typedef))) (element-type (third typedef)) (xdrstream (first args))) (check-type bytecount (integer 0 *) "Opaque size must be integral") (il:* il:\; "Might want to check ELEMENT-TYPE here, too") (if (eq oper (quote read)) (il:bquote (xdr-read-array (il:\\\, xdrstream) (il:\\\, bytecount) (quote (il:\\\, element-type)))) (il:bquote (xdr-write-array (il:\\\, xdrstream) (il:\\\, bytecount) (quote (il:\\\, element-type)) (il:\\\, (second args)))))))

(defun xdr-codegen-skip (context typedef oper args stk) (let ((bytecount (xdr-codegen-constant context (second typedef)))) (check-type bytecount (integer 0 *)) (il:bquote ((il:\\\, (if (eql oper (quote read)) (quote xdr-skip-primitive) (quote xdr-zero-primitive))) (il:\\\, (first args)) (il:\\\, (logand (+ bytecount 3) -4))))))

(defun xdr-codegen-sequence (context typedef oper args stk) (il:* il:|;;| "Non-recursive way of handling a recursive type.  Each item is preceded on the stream with a boolean T, than a boolean NIL follows the last arg.  In Lisp, we represent this as a simple list.") (let ((stream (first args)) (elttype (second typedef))) (if (eq oper (quote read)) (il:bquote (il:while (xdr-read-boolean (il:\\\, stream)) il:collect (il:\\\, (xdr-codegen-1 context elttype oper args stk)))) (il:bquote (dolist (el (il:\\\, (second args)) (xdr-boolean (il:\\\, stream) nil)) (xdr-write-boolean (il:\\\, stream) t) (il:\\\, (xdr-codegen-1 context elttype oper (il:bquote ((il:\\\, stream) el)) stk)))))))



(il:* il:\; "XDR run-time primitives")


(defun xdr-read-integer (xdrstream) (getcell xdrstream))

(defun xdr-write-integer (xdrstream value) (check-type value integer) (putcell xdrstream value))

(defun xdr-read-boolean (xdrstream) (let ((value (getcell xdrstream))) (case value (0 nil) (1 t) (otherwise (rpc-signal-error t (il:bquote (illegal-boolean (il:\\\, value))))))))

(defun xdr-write-boolean (xdrstream value) (putcell xdrstream (if (null value) 0 1)))

(defun xdr-read-unsigned (xdrstream) (getunsigned xdrstream))

(defun xdr-write-unsigned (xdrstream value) (putunsigned xdrstream value))

(defun xdr-read-hyperinteger (xdrstream) (let ((value (+ (ash (getunsigned xdrstream) 32) (getunsigned xdrstream)))) (if (> value twoto63minusone) (- value twoto64th) value)))

(defun xdr-write-hyperinteger (xdrstream value) (check-type value xdr-hyperinteger) (putunsigned xdrstream (ash value -32)) (putunsigned xdrstream (logand value twoto32minusone)))

(defun xdr-read-hyperunsigned (xdrstream) (+ (ash (getunsigned xdrstream) 32) (getunsigned xdrstream)))

(defun xdr-write-hyperunsigned (xdrstream value) (check-type value xdr-hyperunsigned) (putunsigned xdrstream (ash value -32)) (putunsigned xdrstream (logand value twoto32minusone)))

(defun xdr-read-string (xdrstream) (let* ((nbytes (xdr-unsigned xdrstream)) (string (il:allocstring nbytes))) (getrawbytes xdrstream (vector-base string) 0 nbytes) (skipbytes xdrstream (padding-bytes nbytes)) string))

(defun xdr-write-string (xdrstream string) (check-type string string) (when (and (il:%fat-string-array-p string) (il:%fat-string-array-p (setq string (copy-seq string)))) (il:* il:\; "Only 8-bit chars supported in xdr.  COPY-SEQ is just in case it was all thin chars in a formerly fat string.") (error "XDR string contains NS characters: ~S" string)) (let ((nbytes (il:nchars string))) (xdr-unsigned xdrstream nbytes) (putrawbytes xdrstream (vector-base string) (vector-offset string) nbytes) (zerobytes xdrstream (padding-bytes nbytes))))

(defun xdr-read-float (xdrstream) (il:* il:|;;| "Read a single-precision IEEE floating point number.  Fortunately, that's our internal format as well.") (let ((value (il:ncreate (quote il:floatp)))) (getrawbytes xdrstream value 0 4)))

(defun xdr-write-float (xdrstream v) (il:* il:|;;| "Write a single-precision IEEE floating point number.  Fortunately, that's our internal format as well.") (putrawbytes xdrstream (il:\\dtest v (quote floatp)) 0 4))

(defun xdr-read-string-pointer (xdrstream) "This is a gross hack to handle what amounts to bulk data." (let* ((nbytes (xdr-unsigned xdrstream)) (place (getoffset xdrstream)) (packet (car place)) (byteoffset (cdr place))) (il:* il:|;;| "This only works for UDP!!") (il:* il:|;;| "Returns ((packet . byteoffset) . number-of-bytes))") (prog1 (cons (cons packet byteoffset) nbytes) (skipbytes xdrstream (padding-bytes nbytes)))))

(defun xdr-read-array (xdrstream bytecount element-type) "Read an opaque array of bytecount bytes." (let ((quadbytecount (logand (+ bytecount 3) -4))) (il:* il:|;;| "QUADBYTECOUNT is BYTECOUNT rounded up to multiple of 4, which is the number of actual bytes on the stream.  Note that we will always be able to read the extra bytes, if any, in the same operation because arrays in this system are always a multiple of 4 bytes long.") (if (eq element-type :unboxed) (let ((array (il:\\allocblock (ash quadbytecount -2)))) (il:* il:\; "Just get into raw array block") (getrawbytes xdrstream array 0 quadbytecount) array) (let ((array (make-array bytecount :element-type (or element-type (quote string-char))))) (il:* il:\; "Read into array of specified type. We assume the type packs tensely") (getrawbytes xdrstream (il:|fetch| (il:oned-array il:base) il:|of| array) 0 quadbytecount) array))))

(defun xdr-write-array (xdrstream bytecount element-type array) "Write an opaque array of bytecount bytes." (cond ((null array) (il:* il:\; "Convenient shorthand: write all zeros") (zerobytes xdrstream bytecount)) ((eq element-type :unboxed) (putrawbytes xdrstream array 0 bytecount)) (t (putrawbytes xdrstream (il:|fetch| (il:oned-array il:base) il:|of| array) (il:|fetch| (il:oned-array il:offset) il:|of| array) bytecount))))

(defun xdr-write-string-pointer (xdrstream value) "This is a gross hack to handle what amounts to bulk data." (il:* il:|;;| "Value is ((buffer . offset) . nbytes), where the first element can be just buffer if offset is zero.") (let* ((buffer (car value)) (nbytes (cdr value)) (outstream (rpc-stream-outstream xdrstream)) (offset 0)) (when (consp buffer) (setq offset (cdr buffer) buffer (car buffer))) (xdr-unsigned xdrstream nbytes) (putrawbytes xdrstream buffer offset nbytes) (zerobytes xdrstream (padding-bytes nbytes))))

(defun xdr-skip-primitive (xdrstream n) (skipbytes xdrstream n))

(defun xdr-zero-primitive (xdrstream n) (zerobytes xdrstream n))

(defmacro xdr-read-write-void (&rest ignore) "VOID type compiles into this" (quote (progn nil)))

(defun xdr-enumeration-fault (key oper type) (il:* il:|;;| "Called when you try to read/write (per OPER) the value KEY, which is not valid for an enumeration.  TYPE may be the parent type.") (case oper (read (cerror "Return the integer ~D as the value" "Read unrecognized value ~D for enumeration type~@[ ~S~]~@[ in program ~A~]" key type (and *program* (rpc-program-name *program*))) key) (write (error "~S not a valid value for enumeration type~@[ ~S~]~@[ in program ~A~]" key type (and *program* (rpc-program-name *program*))))))

(defun xdr-make-opaque (bytecount &optional element-type) "Create an XDR object of type (:opaque bytecount element-type) initialized to zero." (if (eq element-type :unboxed) (il:\\allocblock (ash (+ bytecount 3) -2)) (make-array bytecount :element-type (or element-type (quote string-char)))))



(il:* il:\; "These are for backward compatibility")


(defun xdr-boolean (xdrstream &optional (value t writep)) (cond (writep (putcell xdrstream (if (null value) 0 1))) (t (setq value (getcell xdrstream)) (ccase value (0 nil) (1 t)))))

(defun xdr-integer (xdrstream &optional (value nil writep)) (cond (writep (check-type value integer) (putcell xdrstream value)) (t (getcell xdrstream))))

(defun xdr-unsigned (xdrstream &optional (value nil writep)) (if writep (putunsigned xdrstream value) (getunsigned xdrstream)))

(defun xdr-hyperinteger (xdrstream &optional (value nil writep)) (cond (writep (xdr-write-hyperinteger xdrstream value)) (t (xdr-read-hyperinteger xdrstream))))

(defun xdr-hyperunsigned (xdrstream &optional (value nil writep)) (cond (writep (xdr-write-hyperunsigned xdrstream value)) (t (xdr-read-hyperunsigned xdrstream))))

(defun xdr-string (xdrstream &optional (string nil writep)) (cond (writep (check-type string string) (when (and (il:%fat-string-array-p string) (il:%fat-string-array-p (setq string (copy-seq string)))) (il:* il:\; "Only 8-bit chars supported in xdr.  COPY-SEQ is just in case it was all thin chars in a formerly fat string.") (error "XDR string contains NS characters: ~S" string)) (let ((nbytes (il:nchars string))) (xdr-unsigned xdrstream nbytes) (putrawbytes xdrstream (vector-base string) (vector-offset string) nbytes) (zerobytes xdrstream (padding-bytes nbytes)))) (t (let* ((nbytes (xdr-unsigned xdrstream)) (string (il:allocstring nbytes))) (getrawbytes xdrstream (vector-base string) 0 nbytes) (skipbytes xdrstream (padding-bytes nbytes)) string))))

(defun xdr-string-pointer (xdrstream &optional (value t writep)) "This is a gross hack to handle what amounts to bulk data." (if writep (let* ((buffer (car value)) (nbytes (cdr value)) (outstream (rpc-stream-outstream xdrstream)) (offset 0)) (il:* il:\; "Value is ((buffer . offset) . nbytes), where the first element can be just buffer if offset is zero.") (when (consp buffer) (setq offset (cdr buffer) buffer (car buffer))) (xdr-unsigned xdrstream nbytes) (putrawbytes xdrstream buffer offset nbytes) (zerobytes xdrstream (padding-bytes nbytes))) (let* ((nbytes (xdr-unsigned xdrstream)) (place (getoffset xdrstream)) (packet (car place)) (byteoffset (cdr place))) (il:* il:|;;| "This only works for UDP!!") (il:* il:|;;| "Returns ((packet . byteoffset) . number-of-bytes))") (prog1 (cons (cons packet byteoffset) nbytes) (skipbytes xdrstream (padding-bytes nbytes))))))

(defun xdr-float (xdrstream &optional (v nil writep)) (il:* il:|;;| "Read or write a single-precision IEEE floating point number.  Fortunately, that's our internal format as well.") (if writep (putrawbytes xdrstream (il:\\dtest v (quote floatp)) 0 4) (let ((value (il:ncreate (quote il:floatp)))) (getrawbytes xdrstream value 0 4))))

(defun xdr-void (xdrstream &optional (value t writep)) nil)

(defun xdr-opaque-primitive (xdrstream nbytes &optional (string nil writep)) (il:* il:|;;| "Strictly for backward-compatibility with old compiled rpc code") (cond (writep (putrawbytes xdrstream (il:|fetch| (il:stringp il:base) il:|of| string) (il:|fetch| (il:stringp il:offst) il:|of| string) nbytes) (unless (eql (setq nbytes (logand nbytes 3)) 0) (dotimes (i (- 4 nbytes)) (putbyte xdrstream 0)))) (t (let ((string (il:allocstring nbytes))) (getrawbytes xdrstream (il:|fetch| (il:stringp il:base) il:|of| string) (il:|fetch| (il:stringp il:offst) il:|of| string) nbytes) (unless (eql (setq nbytes (logand nbytes 3)) 0) (dotimes (i (- 4 nbytes)) (getbyte xdrstream))) string))))
(il:putprops il:rpcxdr il:copyright ("Stanford University and Xerox Corporation" 1987 1988))
(il:declare\: il:dontcopy
  (il:filemap (nil)))
il:stop
