SCREENOP	display interface for simple terminals

SCREENOP is an interface for simple display hacking on semi-smart
terminals.  The basic paradigm is to give the terminal operations
to perform at the level of "move cursor" "clear line" and so on.

SCREENOP is in a preliminary and incomplete state, its primary purpose
being support of LED.

MAKING SCREENOP RECOGNISE "YOUR" TERMINAL
-----------------------------------------

If you are using Interlisp-VAX, the a SCREENOP driver will be constructed
automagicaly if the environment variables TERM and TERMCAP are set up to
reflect your terminal.  The newly created driver will be noticed so FILES?
will ask you to save it.

	SYSTEMTERMTYPES is an ALIST whose CAR's are your system's raw types.

	For UNIX, this is (MKATOM (GETENV 'TERM)) for tops-20 and tenex
	it is the terminal number returned by the appropriate MTOPR jsys.

	(DISPLAYTERMTYPE) reads the raw type and translates it into a
			  canonical form.
	
	The "translation" of the raw type is 
		(SETQ X (FASSOC raw-type SYSTEMTERMTYPES))
		(COND ((LISTP (CDR X)) (EVAL (CDR X)))
		      (T (CDR X)))

	You should edit SYSTEMTERMTYPES to translate your raw type info into
	something known to the rest of screenop.

	(DISPLAYTERMP)	gets the translated type from (DISPLAYTERMTYPE) and
			searches the list of known screen drivers for the
			first driver whose (SCREENOP 'TYPELIST) includes
			the translated type.

	DISPLAYTERMP	(the variable) is the value of the last call to
			(DISPLAYERMP), and should be used as the test
			of a display terminal being in use.

	an entry on AFTERSYSOUTFORMS performs (DISPLAYTERMP), so normally
	one can safely assume DISPLAYTERMP is accurate.

USING SCREENOP
---------------

	A file which is to use screenop should include
	(DECLARE: EVAL@COMPILE DONTEVAL@LOA (CHECKIMPORTS SCREENOP T))
	(FILES (SYSLOAD COMPILED) SCREENOP)

	you then simply call (SCREENOP 'ACTION arg1 arg2 ..)


ADDING A NEW DRIVER
-------------------

	Under Interlisp-VAX, a screendriver is build automatically
from termcap information by BUILDDRIVER.  You could call BUILDDRIVER
with a TERMCAP-like string and let it do the work for you under other
operating systems.

Othewise:
	All the information particular to a terminal is imbedded in
a record of type SCREENDRIVER.  All the elements of a SCREENDRIVER
record are functions that are applied with appropriate arguments.

I recommend copying one of the existing drivers and modifying it
to use your terminal's magic control codes.  The recommended tweaks
to add a driver are:

	1) Copy an existing driver, or the prototype driver
	   (COPYDEF 'CreatePrototypeDriver 'CreateNewDriver 'SCREENDRIVERS)
	   ... and tweak it to drive your screen.

	2) add an entry on SYSTEMTERMTYPES that will translate your
	system's type code for that terminal into something that will
	match your driver's TYPELIST entry.

	For Support of LED, only a subset of the defined functions
	have to be supported. See the driver for HAZELTINE terminals
	as an example of the simplest thing that will support LED.
