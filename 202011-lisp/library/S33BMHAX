(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)
(FILECREATED "31-Aug-89 15:57:58" "{ansel/n}<ansel04>system33>src>medley>S33BMHAX;3" 30204  

      changes to%:  (FNS TRIM.BITMAP.FIND.COLUMN TRIM.BITMAP.FIND.ROW TRIM.BITMAP.FIND.REGION) (VARS S33BMHAXCOMS)

      previous date%: "25-Jan-89 19:22:58" "{ansel/n}<ansel04>system33>src>medley>S33BMHAX;1")


(* "
Copyright (c) 1988, 1989 by Xerox Corporation.  All rights reserved.
")

(PRETTYCOMPRINT S33BMHAXCOMS)

(RPAQQ S33BMHAXCOMS ((* ;; "Functions for scaling and otherwise handling large bitmaps") (FNS BMSCALEBY2 BMSCALEBY4 BMSCALEFN) (COMS (* ; "An image object for handling oversize bitmaps") (FNS BIGBMOBJ.CREATE BIGBMOBJ.CREATE.MENU BIGBMOBJ.DISPLAYFN BIGBMOBJ.EDITBM BIGBMOBJ.IMAGEBOXFN BIGBMOBJ.IMAGES BIGBMOBJ.SHRINKBITMAP BIGBMOBJ.BUTTONEVENTINFN BIGBMOBJ.COPYFN BIGBMOBJ.GETFN BIGBMOBJ.PUTFN BIGBMOBJ.INIT) (FNS NEW.TRIM.BITMAP BIGBMOBJ.TRIM.BITMAP TRIM.BITMAP.FIND.REGION TRIM.BITMAP.FIND.COLUMN TRIM.BITMAP.FIND.ROW) (GLOBALVARS BIGBMOBJFNS BIGBMOBJ.MENU) (VARS (BIGBMOBJ.MENU)) (DECLARE%: DONTEVAL@LOAD DOCOPY (P (BIGBMOBJ.INIT)))) (COMS (* ; "EDITBM fixes.  Too bad we had to copy this huge function just to fix its PAINTW command") (FNS EDITBMBUTTONFN EDITBM.PAINTW) (DECLARE%: EVAL@COMPILE DONTCOPY (MACROS UPDATE/BM/DISPLAY))) (LOCALVARS . T)))



(* ;; "Functions for scaling and otherwise handling large bitmaps")

(DEFINEQ

(BMSCALEBY2
(LAMBDA (SOURCEBM DESTBM DESTBOTTOM DESTHEIGHT DESTWIDTH NONDESTRUCTIVE) (* ; "Edited 25-Jan-89 14:37 by bvm") (* ;; "Copy SOURCEBM into DESTBM, shrinking in each dimension by factor of 2 on the way.  Optional remaining 3 args default to bottom of zero and height and width of DESTBM.  We always blt the bottom of SOURCEBM, in case DESTHEIGHT*2 is less than height of SOURCEBM.") (* ;; "Method is trivial thresholding: if any bit in the source 2x2 pixel is on, the destination bit is on.") (OR DESTBOTTOM (SETQ DESTBOTTOM 0)) (OR DESTWIDTH (SETQ DESTWIDTH (BITMAPWIDTH DESTBM))) (OR DESTHEIGHT (SETQ DESTHEIGHT (BITMAPHEIGHT DESTBM))) (LET* ((SOURCEWIDTH (fetch BITMAPWIDTH of SOURCEBM)) (HALFWIDTH (CEIL SOURCEWIDTH 16)) (STRETCHEDBM (create BITMAP using SOURCEBM BITMAPRASTERWIDTH _ (LLSH (fetch BITMAPRASTERWIDTH of SOURCEBM) 1) BITMAPWIDTH _ (LLSH SOURCEWIDTH 1) BITMAPHEIGHT _ (LRSH (fetch BITMAPHEIGHT of SOURCEBM) 1))) SCRATCHBM) (* ;; "STRETCHEDBM is a bitmap header onto the same bits but twice as wide and half as high.  This means the left half of the new bm and the right half are similar pictures at half height.  Note that if SOURCEWIDTH is not a multiple of 16, there is a gap of (rem sourcewidth 16) pixels between the left and right half") (if NONDESTRUCTIVE then (* ; "Need to make a scratch bm to hold intermediate results--it will start out as copy of the left half") (SETQ SCRATCHBM (BITMAPCREATE HALFWIDTH DESTHEIGHT)) (BITBLT STRETCHEDBM 0 0 SCRATCHBM 0 0 HALFWIDTH DESTHEIGHT (QUOTE INPUT) (QUOTE PAINT)) else (* ; "We're allowed to destroy the source") (SETQ SCRATCHBM STRETCHEDBM)) (BITBLT STRETCHEDBM HALFWIDTH 0 STRETCHEDBM 0 0 HALFWIDTH DESTHEIGHT (QUOTE INPUT) (QUOTE PAINT)) (* ; "OR the right half onto the left half") (BITBLT SCRATCHBM 1 0 SCRATCHBM 0 0 (SUB1 SOURCEWIDTH) DESTHEIGHT (QUOTE INPUT) (QUOTE PAINT)) (* ; "OR the bitmap onto itself one column leftwards") (* ;; "OK, now all the bits we are about are the even-numbered bits in SCRATCHBM.  We need to copy every other column into the destination.  I don't know a clever way to do this") (for I from 0 to (SUB1 DESTWIDTH) as J from 0 by 2 do (BITBLT SCRATCHBM J 0 DESTBM I DESTBOTTOM 1 DESTHEIGHT (QUOTE INPUT) (QUOTE REPLACE)))))
)

(BMSCALEBY4
(LAMBDA (SOURCEBM DESTBM DESTBOTTOM DESTHEIGHT DESTWIDTH NONDESTRUCTIVE) (* ; "Edited 24-Jan-89 14:40 by bvm") (* ;; "Copy SOURCEBM into DESTBM, shrinking in each dimension by factor of 4 on the way.  Optional remaining 3 args default to bottom of zero and height and width of DESTBM.  We always blt the bottom of SOURCEBM, in case DESTHEIGHT*4 is less than height of SOURCEBM.") (* ;; "Method is trivial thresholding: if any bit in the source 4x4 pixel is on, the destination bit is on.") (OR DESTBOTTOM (SETQ DESTBOTTOM 0)) (OR DESTWIDTH (SETQ DESTWIDTH (BITMAPWIDTH DESTBM))) (OR DESTHEIGHT (SETQ DESTHEIGHT (BITMAPHEIGHT DESTBM))) (LET* ((SOURCEWIDTH (fetch BITMAPWIDTH of SOURCEBM)) (QUARTERWIDTH (CEIL SOURCEWIDTH 16)) (STRETCHEDBM (create BITMAP using SOURCEBM BITMAPRASTERWIDTH _ (LLSH (fetch BITMAPRASTERWIDTH of SOURCEBM) 2) BITMAPWIDTH _ (LLSH SOURCEWIDTH 2) BITMAPHEIGHT _ (LRSH (fetch BITMAPHEIGHT of SOURCEBM) 2))) SCRATCHBM) (* ;; "STRETCHEDBM is a bitmap header onto the same bits but 4 times as wide and 1/4 as high.  This means that each of the 4 quarters of the new bm left to right are similar pictures at 1/4 height.  Note that if SOURCEWIDTH is not a multiple of 16, there is a gap of (rem sourcewidth 16) pixels between quarters") (if NONDESTRUCTIVE then (* ; "Need to make a scratch bm to hold intermediate results--it will start out as copy of the lefthand quarter") (SETQ SCRATCHBM (BITMAPCREATE QUARTERWIDTH DESTHEIGHT)) (BITBLT STRETCHEDBM 0 0 SCRATCHBM 0 0 QUARTERWIDTH DESTHEIGHT (QUOTE INPUT) (QUOTE PAINT)) else (* ; "We're allowed to destroy the source") (SETQ SCRATCHBM STRETCHEDBM)) (BITBLT STRETCHEDBM QUARTERWIDTH 0 SCRATCHBM 0 0 QUARTERWIDTH DESTHEIGHT (QUOTE INPUT) (QUOTE PAINT)) (BITBLT STRETCHEDBM (LLSH QUARTERWIDTH 1) 0 SCRATCHBM 0 0 QUARTERWIDTH DESTHEIGHT (QUOTE INPUT) (QUOTE PAINT)) (BITBLT STRETCHEDBM (+ QUARTERWIDTH (LLSH QUARTERWIDTH 1)) 0 SCRATCHBM 0 0 QUARTERWIDTH DESTHEIGHT (QUOTE INPUT) (QUOTE PAINT)) (* ; "OR the 2nd, 3rd and 4th quarters into the 1st") (BITBLT SCRATCHBM 1 0 SCRATCHBM 0 0 (SUB1 SOURCEWIDTH) DESTHEIGHT (QUOTE INPUT) (QUOTE PAINT)) (* ; "OR the bitmap onto itself one column leftwards") (BITBLT SCRATCHBM 2 0 SCRATCHBM 0 0 (- SOURCEWIDTH 2) DESTHEIGHT (QUOTE INPUT) (QUOTE PAINT)) (* ; "And now two leftwards") (* ;; "OK, now all the bits we care about are every fourth bit in SCRATCHBM.  Copy columns into the destination.  I don't know a clever way to do this") (for I from 0 to (SUB1 DESTWIDTH) as J from 0 by 4 do (BITBLT SCRATCHBM J 0 DESTBM I DESTBOTTOM 1 DESTHEIGHT (QUOTE INPUT) (QUOTE REPLACE)))))
)

(BMSCALEFN
(LAMBDA (FACTOR) (* ; "Edited 21-Sep-88 17:53 by bvm") (CASE FACTOR (2 (FUNCTION BMSCALEBY2)) (4 (FUNCTION BMSCALEBY4))))
)
)



(* ; "An image object for handling oversize bitmaps")

(DEFINEQ

(BIGBMOBJ.CREATE
(LAMBDA (BITMAPS SCALE) (* ; "Edited 23-Jan-89 12:52 by bvm") (IMAGEOBJCREATE (CONS (OR SCALE 1.0) BITMAPS) BIGBMOBJFNS))
)

(BIGBMOBJ.CREATE.MENU
(LAMBDA NIL (* ; "Edited 25-Jan-89 14:40 by bvm") (* ;; "Creates the menu that comes up when you button in a bitmap image object.") (if (type? MENU BIGBMOBJ.MENU) then BIGBMOBJ.MENU else (SETQ BIGBMOBJ.MENU (create MENU TITLE _ "Operations on bitmaps" ITEMS _ (QUOTE (("Change Scale" (QUOTE CHANGE.SCALE) "Change the scale factor used when displaying/printing the bitmap.") ("Hand Edit" (QUOTE HAND.EDIT) "Run the bitmap editor on a portion of the bitmap") ("Trim" (QUOTE TRIM) "Remove the white space from around the edges, compacting the bitmap"))) CENTERFLG _ T CHANGEOFFSETFLG _ (QUOTE Y) MENUOFFSET _ (create POSITION XCOORD _ -1 YCOORD _ 0)))))
)

(BIGBMOBJ.DISPLAYFN
(LAMBDA (IMAGEOBJ IMAGE.STREAM) (* ; "Edited 25-Jan-89 15:12 by bvm") (DESTRUCTURING-BIND (FACTOR . BITMAPS) (IMAGEOBJPROP IMAGEOBJ (QUOTE OBJECTDATUM)) (CASE (IMAGESTREAMTYPE IMAGE.STREAM) (INTERPRESS (* ; "Printing to an Interpress stream, so use the specialized method.") (LET* ((ORIGY (DSPYPOSITION NIL IMAGE.STREAM)) (Y ORIGY) (X (DSPXPOSITION NIL IMAGE.STREAM))) (for BM in BITMAPS do (SHOWBITMAP.IP IMAGE.STREAM BM NIL FACTOR 0) (MOVETO X (add Y (FIXR (TIMES FACTOR (FQUOTIENT 2540 75) (BITMAPHEIGHT BM)))) IMAGE.STREAM)) (DSPYPOSITION ORIGY IMAGE.STREAM))) (T (* ; "This is the default case, press display and everyone else prints the junky shrunk bitmap") (for BM in (BIGBMOBJ.IMAGES IMAGEOBJ BITMAPS FACTOR) bind (X _ (DSPXPOSITION NIL IMAGE.STREAM)) (Y _ (DSPYPOSITION NIL IMAGE.STREAM)) HEIGHT do (BITBLT BM NIL NIL IMAGE.STREAM X Y (BITMAPWIDTH BM) (SETQ HEIGHT (BITMAPHEIGHT BM))) (add Y HEIGHT))))))
)

(BIGBMOBJ.EDITBM
(LAMBDA (OBJ) (* ; "Edited 25-Jan-89 14:31 by bvm") (LET ((PART (MENU (create MENU ITEMS _ (for BM in (REVERSE (BIGBMOBJ.IMAGES OBJ)) bind (I _ 0) collect (LIST BM (add I 1) "Edit this piece of the bitmap")) TITLE _ "Edit which part?")))) (if PART then (DESTRUCTURING-BIND (FACTOR . BITMAPS) (IMAGEOBJPROP OBJ (QUOTE OBJECTDATUM)) (EDITBM (CL:NTH (- (LENGTH BITMAPS) PART) BITMAPS))))))
)

(BIGBMOBJ.IMAGEBOXFN
(LAMBDA (IMAGEOBJ IMAGE.STREAM CURRENT.X RIGHT.MARGIN) (* ; "Edited 25-Jan-89 15:12 by bvm") (* ;; "returns an imagebox describing the size of the whole bitmap, scaled as ordered") (DESTRUCTURING-BIND (FACTOR . BITMAPS) (IMAGEOBJPROP IMAGEOBJ (QUOTE OBJECTDATUM)) (LET ((WIDTH 0) (HEIGHT 0) (SCALE (DSPSCALE NIL IMAGE.STREAM))) (for BM in BITMAPS do (add HEIGHT (BITMAPHEIGHT BM)) (SETQ WIDTH (MAX WIDTH (BITMAPWIDTH BM)))) (if (NOT (= SCALE 1)) then (SETQ FACTOR (TIMES FACTOR SCALE))) (if (NOT (= FACTOR 1.0)) then (SETQ WIDTH (FIXR (FTIMES FACTOR WIDTH))) (SETQ HEIGHT (FIXR (FTIMES FACTOR HEIGHT)))) (create IMAGEBOX XSIZE _ WIDTH YSIZE _ HEIGHT YDESC _ 0 XKERN _ 0))))
)

(BIGBMOBJ.IMAGES
(LAMBDA (IMAGEOBJ BITMAPS FACTOR) (* ; "Edited 23-Jan-89 18:18 by bvm") (* ;; "Compute or return the set of bitmaps that cache the image of this bit bitmap.  If BITMAPS is NIL, we'll extract it and FACTOR from the object.") (LET ((CACHE (IMAGEOBJPROP IMAGEOBJ (QUOTE CACHED.BITMAP)))) (if (NULL BITMAPS) then (SETQ FACTOR (IMAGEOBJPROP IMAGEOBJ (QUOTE OBJECTDATUM))) (SETQ BITMAPS (CDR FACTOR)) (SETQ FACTOR (CAR FACTOR))) (if (NOT (= FACTOR 1.0)) then (if (NULL (SETQ CACHE (IMAGEOBJPROP IMAGEOBJ (QUOTE CACHED.BITMAP)))) then (* ; "Compute different image") (IMAGEOBJPROP IMAGEOBJ (QUOTE CACHED.BITMAP) (SETQ CACHE (for BM in BITMAPS bind (MAKER _ (if (< FACTOR 1.0) then (SETQ FACTOR (FQUOTIENT 1.0 FACTOR)) (FUNCTION BIGBMOBJ.SHRINKBITMAP) else (FUNCTION EXPANDBITMAP))) collect (CL:FUNCALL MAKER BM FACTOR FACTOR)))))) CACHE))
)

(BIGBMOBJ.SHRINKBITMAP
(LAMBDA (BM WIDTHFACTOR HEIGHTFACTOR) (* ; "Edited 24-Jan-89 14:41 by bvm") (LET (INTFACTOR FASTFN DESTBM) (if (AND (= WIDTHFACTOR HEIGHTFACTOR) (= WIDTHFACTOR (SETQ INTFACTOR (ROUND WIDTHFACTOR))) (SETQ FASTFN (BMSCALEFN INTFACTOR))) then (CL:FUNCALL FASTFN BM (SETQ DESTBM (BITMAPCREATE (IQUOTIENT (BITMAPWIDTH BM) INTFACTOR) (IQUOTIENT (BITMAPHEIGHT BM) INTFACTOR))) NIL NIL NIL T) DESTBM else (SHRINKBITMAP BM WIDTHFACTOR HEIGHTFACTOR))))
)

(BIGBMOBJ.BUTTONEVENTINFN
(LAMBDA (IMAGEOBJ WINDOW SELECTION X Y SELWINDOW TEXTSTREAM BUTTON OPERATION) (* ; "Edited 25-Jan-89 14:44 by bvm") (* ;;; "the user has pressed a button inside the bitmap object IMAGEOBJ.  Bring up a menu of bitmap edit operations.") (* ;; "If he's extending a selection, or is selecting for move/copy/delete, DON'T bring up the bitmap editing menu!") (if (AND (NEQ BUTTON (QUOTE RIGHT)) (OR (NULL OPERATION) (EQ OPERATION (QUOTE NORMAL))) (SELECTQ (MENU (BIGBMOBJ.CREATE.MENU)) (CHANGE.SCALE (* ; "Change the scale on the bitmap.") (LET* ((OBJ (IMAGEOBJPROP IMAGEOBJ (QUOTE OBJECTDATUM))) (PWINDOW (GETPROMPTWINDOW WINDOW)) (NEWSCALE (PROGN (CLEARW PWINDOW) (TTYINPROMPTFORWORD "Scale Factor:  " (CAR OBJ) NIL PWINDOW NIL (QUOTE TTY) (CHARCODE (CR)))))) (if (NULL NEWSCALE) then (* ; "aborted") NIL elseif (NOT (NUMBERP (SETQ NEWSCALE (MKATOM NEWSCALE)))) then (PRINTOUT PWINDOW " ... bad scale") NIL else (RPLACA OBJ NEWSCALE)))) (HAND.EDIT (BIGBMOBJ.EDITBM IMAGEOBJ)) (TRIM (LET ((OBJ (IMAGEOBJPROP IMAGEOBJ (QUOTE OBJECTDATUM)))) (RPLACD OBJ (BIGBMOBJ.TRIM.BITMAP (CDR OBJ))))) NIL)) then (* ; "Something changed, so flush our cache and tell caller it changed") (IMAGEOBJPROP IMAGEOBJ (QUOTE CACHED.BITMAP) NIL) (QUOTE CHANGED)))
)

(BIGBMOBJ.COPYFN
(LAMBDA (IMAGEOBJ) (* ; "Edited 23-Jan-89 13:03 by bvm") (* ;; "makes a copy of a bitmap image object.") (DESTRUCTURING-BIND (FACTOR . BITMAPS) (IMAGEOBJPROP IMAGEOBJ (QUOTE OBJECTDATUM)) (BIGBMOBJ.CREATE (for BM in BITMAPS collect (BITMAPCOPY BM)) FACTOR)))
)

(BIGBMOBJ.GETFN
(LAMBDA (STREAM) (* rrb "17-Jul-84 11:46") (* this is an old version of the get function for bitmap image objects. It is left around so old tedit documents will still work. |17/7/84|) (RESETFORM (INPUT STREAM) (PROG ((FIELDS (READ STREAM)) (BITMAP (READBITMAP))) (RETURN (BITMAPTEDITOBJ BITMAP (CAR FIELDS) (CADR FIELDS))))))
)

(BIGBMOBJ.PUTFN
(LAMBDA (IMAGEOBJ STREAM) (* ; "Edited 23-Jan-89 12:56 by bvm") (* ;; "Put a description of a bitmap object into the file.") (DESTRUCTURING-BIND (FACTOR . BITMAPS) (IMAGEOBJPROP IMAGEOBJ (QUOTE OBJECTDATUM)) (SETQ FACTOR (FLOAT FACTOR)) (\WOUT STREAM (fetch (FLOATP HIWORD) of FACTOR)) (* ; "write raw floatp") (\WOUT STREAM (fetch (FLOATP LOWORD) of FACTOR)) (for BM in BITMAPS do (\PRINTBINARYBITMAP BM STREAM))))
)

(BIGBMOBJ.INIT
(LAMBDA NIL (* ; "Edited 23-Jan-89 12:21 by bvm") (SETQ BIGBMOBJFNS (IMAGEFNSCREATE (FUNCTION BIGBMOBJ.DISPLAYFN) (FUNCTION BIGBMOBJ.IMAGEBOXFN) (FUNCTION BIGBMOBJ.PUTFN) (FUNCTION BIGBMOBJ.GETFN) (FUNCTION BIGBMOBJ.COPYFN) (FUNCTION BIGBMOBJ.BUTTONEVENTINFN) (FUNCTION NILL) (FUNCTION NILL) (FUNCTION NILL) (FUNCTION NILL) (FUNCTION NILL) (FUNCTION NILL) (FUNCTION NILL))))
)
)
(DEFINEQ

(NEW.TRIM.BITMAP
(LAMBDA (BITMAP) (* ; "Edited 25-Jan-89 14:33 by bvm") (LET* ((TOP (OR (TRIM.BITMAP.FIND.ROW BITMAP) (ERROR "Can't trim bitmap--it's blank!"))) (BOTTOM (TRIM.BITMAP.FIND.ROW BITMAP T)) (LEFT (TRIM.BITMAP.FIND.COLUMN BITMAP)) (RIGHT (TRIM.BITMAP.FIND.COLUMN BITMAP T)) (NEW.BITMAP (BITMAPCREATE (ADD1 (- RIGHT LEFT)) (ADD1 (- TOP BOTTOM))))) (BITBLT BITMAP LEFT BOTTOM NEW.BITMAP 0 0 (ADD1 (- RIGHT LEFT)) (ADD1 (- TOP BOTTOM)) (QUOTE INPUT) (QUOTE REPLACE)) NEW.BITMAP))
)

(BIGBMOBJ.TRIM.BITMAP
(LAMBDA (BITMAPS) (* ; "Edited 25-Jan-89 14:29 by bvm") (* ;; "Trim whitespace from around edges of each of BITMAPS.  First bitmap is the bottom one.  Returns a list of new bitmaps.") (LET (TOP BOTTOM LEFT LASTBM) (until (SETQ TOP (TRIM.BITMAP.FIND.ROW (SETQ LASTBM (CAR (LAST BITMAPS))))) do (if (NULL (SETQ BITMAPS (CL:BUTLAST BITMAPS))) then (* ; "All blank!") (ERROR "Can't trim bitmap--it's blank!"))) (until (SETQ BOTTOM (TRIM.BITMAP.FIND.ROW (CAR BITMAPS) T)) do (* ; "We already know we have to win eventually") (SETQ BITMAPS (CDR BITMAPS))) (for BM in BITMAPS bind TMP do (if (AND (SETQ TMP (TRIM.BITMAP.FIND.COLUMN BM NIL LEFT)) (OR (NULL LEFT) (< TMP LEFT))) then (SETQ LEFT TMP))) (for BM in BITMAPS collect (LET* ((THISBOTTOM (if (EQ BM (CAR BITMAPS)) then BOTTOM else 0)) (THISTOP (if (EQ BM LASTBM) then TOP else (fetch (BITMAP BITMAPHEIGHT) of BM))) (RIGHT (OR (TRIM.BITMAP.FIND.COLUMN BM T) (PROGN (* ; "Note that if this bm is completely blank, still need it to be at least a pixel wide") 1))) (NEW.BITMAP (BITMAPCREATE (ADD1 (- RIGHT LEFT)) (ADD1 (- THISTOP THISBOTTOM))))) (BITBLT BM LEFT THISBOTTOM NEW.BITMAP 0 0 (ADD1 (- RIGHT LEFT)) (ADD1 (- THISTOP THISBOTTOM)) (QUOTE INPUT) (QUOTE REPLACE)) NEW.BITMAP))))
)

(TRIM.BITMAP.FIND.REGION
(LAMBDA (BITMAPS) (* ; "Edited 30-Aug-89 15:42 by bvm") (* ;; "Return a region that includes all the black pixels of BITMAPS.  First bitmap is the bottom one.") (PROG ((BASE 0) TOP BOTTOM LEFT RIGHT LASTBM) (until (SETQ BOTTOM (TRIM.BITMAP.FIND.ROW (CAR BITMAPS) T)) do (add BASE (BITMAPHEIGHT (CAR BITMAPS))) (if (NULL (SETQ BITMAPS (CDR BITMAPS))) then (RETURN))) (if (NULL BITMAPS) then (* ; "All blank!") (RETURN (CREATEREGION 0 0 0 0))) (until (SETQ TOP (TRIM.BITMAP.FIND.ROW (SETQ LASTBM (CAR (LAST BITMAPS))))) do (* ; "We already know we have to win eventually") (SETQ BITMAPS (CL:BUTLAST BITMAPS))) (for BM in BITMAPS bind TMP do (if (AND (SETQ TMP (TRIM.BITMAP.FIND.COLUMN BM NIL LEFT)) (OR (NULL LEFT) (< TMP LEFT))) then (SETQ LEFT TMP)) (if (AND (SETQ TMP (TRIM.BITMAP.FIND.COLUMN BM T RIGHT)) (OR (NULL RIGHT) (> TMP RIGHT))) then (SETQ RIGHT TMP)) (if (NEQ BM LASTBM) then (add TOP (BITMAPHEIGHT BM)))) (RETURN (CREATEREGION LEFT (+ BASE BOTTOM) (ADD1 (- RIGHT LEFT)) (ADD1 (- TOP BOTTOM))))))
)

(TRIM.BITMAP.FIND.COLUMN
(LAMBDA (BITMAP RIGHT-TO-LEFT MAXCOLUMN) (* ; "Edited 31-Aug-89 15:56 by bvm") (* ;; "Find the first nonzero column of the bitmap.  If RIGHT-TO-LEFT, find the rightmost such column.  Assumes that we have already verified the bitmap to be nonempty") (LET* ((BASE (fetch (BITMAP BITMAPBASE) of BITMAP)) (HEIGHT (fetch (BITMAP BITMAPHEIGHT) of BITMAP)) (RASTERWIDTH (fetch (BITMAP BITMAPRASTERWIDTH) of BITMAP)) (MAXX (FOLDLO (OR MAXCOLUMN (SUB1 (fetch (BITMAP BITMAPWIDTH) of BITMAP))) BITSPERWORD)) BITS EXCESSWIDTH) (for COLUMN from (if RIGHT-TO-LEFT then MAXX else 0) by (if RIGHT-TO-LEFT then -1 else 1) do (if (if RIGHT-TO-LEFT then (< COLUMN 0) else (> COLUMN MAXX)) then (* ; "This happens if bitmap is empty (could occur on an interior bitmap of a multiple set) or we have not yet found any 1 bits by the time caller said to give up") (RETURN NIL)) (SETQ BITS 0) (* ; "Compute the logical OR of all bits in this 16-wide column") (to HEIGHT as (BASE0 _ (\ADDBASE BASE COLUMN)) by (\ADDBASE BASE0 RASTERWIDTH) do (SETQ BITS (LOGOR (\GETBASE BASE0 0) BITS))) (if (AND (NEQ BITS 0) (OR (< COLUMN MAXX) (EQ (SETQ EXCESSWIDTH (IMOD (fetch (BITMAP BITMAPWIDTH) of BITMAP) BITSPERWORD)) 0) (NEQ (SETQ BITS (LOGAND BITS (CL:ASH -1 (- 16 EXCESSWIDTH)))) 0))) then (* ;; "Found bits in this 16-wide column--narrow down to the extreme one.  The second clause handles the right-most word, which we have to mask if the bitmap width is not a multiple of 16.") (RETURN (+ (UNFOLD COLUMN BITSPERWORD) (if RIGHT-TO-LEFT then (* ; "Find rightmost 1") (for I from 15 by -1 until (ODDP BITS) do (SETQ BITS (LRSH BITS 1)) finally (RETURN I)) else (* ; "Find leftmost 1") (for I from 0 until (> BITS 32767) do (SETQ BITS (LLSH BITS 1)) finally (RETURN I)))))))))
)

(TRIM.BITMAP.FIND.ROW
(LAMBDA (BITMAP BOTTOM-TO-TOP) (* ; "Edited 31-Aug-89 15:56 by bvm") (* ;; "Return the first row of the bitmap containing a non-zero bit.  If BOTTOM-TO-TOP, find the last such.  If bitmap is all zero, return NIL.") (LET* ((BASE (fetch (BITMAP BITMAPBASE) of BITMAP)) (HEIGHT (fetch (BITMAP BITMAPHEIGHT) of BITMAP)) (BMWIDTH (fetch (BITMAP BITMAPWIDTH) of BITMAP)) (WIDTH (FOLDLO BMWIDTH BITSPERWORD)) (EXCESSWIDTH (IMOD BMWIDTH BITSPERWORD)) (MASK (AND (> EXCESSWIDTH 0) (CL:ASH -1 (- 16 EXCESSWIDTH)))) (RASTERWIDTH (fetch (BITMAP BITMAPRASTERWIDTH) of BITMAP)) (INCREMENT (if BOTTOM-TO-TOP then (- RASTERWIDTH) else RASTERWIDTH))) (to HEIGHT as ROW from (if BOTTOM-TO-TOP then 0 else (SUB1 HEIGHT)) by (if BOTTOM-TO-TOP then 1 else -1) as (BASE0 _ (if BOTTOM-TO-TOP then (\ADDBASE BASE (TIMES RASTERWIDTH (SUB1 HEIGHT))) else BASE)) by (\ADDBASE BASE0 INCREMENT) when (LET ((END (\ADDBASE BASE0 WIDTH))) (* ;; "First WIDTH words we can test a whole word at a time.  The last word has to be masked in case there is garbage in the bits beyond BMWIDTH.  END points at the word with the leftover bits") (OR (for (BASEX _ BASE0) by (\ADDBASE BASEX 1) until (EQ BASEX END) thereis (NOT (EQ (\GETBASE BASEX 0) 0))) (AND MASK (NOT (EQ (LOGAND (\GETBASE END 0) MASK) 0))))) do (* ;; "Found a word with a bit on.  ") (RETURN ROW))))
)
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS BIGBMOBJFNS BIGBMOBJ.MENU)
)

(RPAQQ BIGBMOBJ.MENU NIL)
(DECLARE%: DONTEVAL@LOAD DOCOPY 

(BIGBMOBJ.INIT)
)



(* ; "EDITBM fixes.  Too bad we had to copy this huge function just to fix its PAINTW command")

(DEFINEQ

(EDITBMBUTTONFN
(LAMBDA (W) (* ; "Edited 25-Jan-89 18:48 by bvm") (* ;; "inner function of bitmap editor.") (DECLARE (GLOBALVARS \CURRENTCURSOR)) (PROG (GRIDX0 GRIDY0 BITMAPWIDTH BITMAPHEIGHT NEWGRIDSIZE ORIGBM GRIDSPEC GRIDINTERIOR BM BITSWIDE BITSHIGH WREGION XOFFSET YOFFSET DXOFFSET DYOFFSET DISPLAYREGION EXTENT BITSPERPIXEL CURSORBM) (SETQ GRIDSPEC (WINDOWPROP W (QUOTE GRIDSPEC))) (SETQ GRIDINTERIOR (WINDOWPROP W (QUOTE GRIDINTERIOR))) (SETQ BM (WINDOWPROP W (QUOTE BM))) (SETQ BITSWIDE (WINDOWPROP W (QUOTE BITSWIDE))) (SETQ BITSHIGH (WINDOWPROP W (QUOTE BITSHIGH))) (SETQ WREGION (WINDOWPROP W (QUOTE REGION))) (SETQ XOFFSET (WINDOWPROP W (QUOTE XOFFSET))) (SETQ YOFFSET (WINDOWPROP W (QUOTE YOFFSET))) (SETQ DXOFFSET (WINDOWPROP W (QUOTE DXOFFSET))) (SETQ DYOFFSET (WINDOWPROP W (QUOTE DYOFFSET))) (SETQ DISPLAYREGION (WINDOWPROP W (QUOTE DISPLAYREGION))) (SETQ EXTENT (WINDOWPROP W (QUOTE EXTENT))) (SETQ GRIDX0 (fetch (REGION LEFT) of GRIDSPEC)) (SETQ GRIDY0 (fetch (REGION BOTTOM) of GRIDSPEC)) (SETQ BITMAPWIDTH (fetch (BITMAP BITMAPWIDTH) of BM)) (SETQ BITMAPHEIGHT (fetch (BITMAP BITMAPHEIGHT) of BM)) (SETQ BITSPERPIXEL (fetch (BITMAP BITMAPBITSPERPIXEL) of BM)) (SETQ COLOR (WINDOWPROP W (QUOTE COLOR))) (* ;; "mark the region of the bitmap that is being editted.") (COND ((INSIDE? GRIDINTERIOR (LASTMOUSEX W) (LASTMOUSEY W)) (* ;; "if cursor is inside, shade it.") (\SHADEBITS BM GRIDSPEC GRIDINTERIOR W BITSWIDE BITSHIGH COLOR)) ((INSIDE? DISPLAYREGION (LASTMOUSEX W) (LASTMOUSEY W)) (* ;; "Run the menu foe re-windowing into the whole bitmap") (SELECTQ (MENU (COND ((type? MENU EDITBMWINDOWMENU) EDITBMWINDOWMENU) ((SETQ EDITBMWINDOWMENU (create MENU ITEMS _ (QUOTE ((Move (QUOTE Move) "Selects a different part of the bitmap to edit."))) CENTERFLG _ T))))) (Move (* ; "move the editing window's location on the bitmap.") (PROG (POS) (SETQ POS (GETBOXPOSITION BITSWIDE BITSHIGH (IPLUS 4 (fetch (REGION LEFT) of WREGION) (- XOFFSET (WINDOWPROP W (QUOTE DXOFFSET)))) (IPLUS (WINDOWPROP W (QUOTE BMDISPLAYBOTTOM)) (- YOFFSET (WINDOWPROP W (QUOTE DYOFFSET))) 4 (fetch (REGION BOTTOM) of WREGION)))) (WINDOWPROP W (QUOTE XOFFSET) (SETQ XOFFSET (IMIN (IDIFFERENCE BITMAPWIDTH BITSWIDE) (IMAX (IPLUS (WINDOWPROP W (QUOTE DXOFFSET)) (- (fetch (POSITION XCOORD) of POS) (IPLUS 4 (fetch (REGION LEFT) of WREGION)))) 0)))) (WINDOWPROP W (QUOTE YOFFSET) (SETQ YOFFSET (IMAX 0 (IMIN (- BITMAPHEIGHT BITSHIGH) (- (IPLUS (WINDOWPROP W (QUOTE DYOFFSET)) (- (fetch (POSITION YCOORD) of POS) (IPLUS (fetch (REGION BOTTOM) of WREGION) 4))) (WINDOWPROP W (QUOTE BMDISPLAYBOTTOM))))))) (replace (REGION LEFT) of EXTENT with (IMINUS (QUOTIENT (TIMES XOFFSET (fetch (REGION WIDTH) of EXTENT)) BITMAPWIDTH))) (replace (REGION BOTTOM) of EXTENT with (IMINUS (QUOTIENT (TIMES YOFFSET (fetch (REGION HEIGHT) of EXTENT)) BITMAPHEIGHT))) (COND ((OR (ILESSP XOFFSET DXOFFSET) (ILESSP YOFFSET DYOFFSET) (IGREATERP (IPLUS XOFFSET BITSWIDE) (IPLUS DXOFFSET (WINDOWPROP W (QUOTE BMDISPLAYWIDTH)))) (IGREATERP (IPLUS YOFFSET BITSHIGH) (IPLUS DYOFFSET (WINDOWPROP W (QUOTE BMDISPLAYHEIGHT))))) (* ;; "Adjust the display region left lower corner so the selected region is near the center.") (WINDOWPROP W (QUOTE DXOFFSET) (SETQ DXOFFSET (IMAX 0 (IMIN (- (fetch (BITMAP BITMAPWIDTH) of BM) (WINDOWPROP W (QUOTE BMDISPLAYWIDTH))) (- (IPLUS XOFFSET (LRSH BITSWIDE 1)) (LRSH (WINDOWPROP W (QUOTE BMDISPLAYWIDTH)) 1)))))) (WINDOWPROP W (QUOTE DYOFFSET) (SETQ DYOFFSET (IMAX 0 (IMIN (- (fetch (BITMAP BITMAPHEIGHT) of BM) (WINDOWPROP W (QUOTE BMDISPLAYHEIGHT))) (- (IPLUS YOFFSET (LRSH BITSHIGH 1)) (LRSH (WINDOWPROP W (QUOTE BMDISPLAYHEIGHT)) 1)))))))) (* DSPFILL GRIDINTERIOR WHITESHADE (QUOTE REPLACE) W) (UPDATE/BM/DISPLAY BM W) (* ;; "FS: More useless code: (COND ((WINDOWPROP W 'GRIDON) (GRID GRIDSPEC BITSWIDE BITSHIGH 'POINT W)))") (RESETGRID.NEW BM GRIDSPEC BITSWIDE BITSHIGH 0 0 W T))) NIL)) ((LASTMOUSESTATE LEFT) (UPDATE/BM/DISPLAY/SELECTED/REGION W) (SETQ CURSORBM (BITMAPCREATE 16 16 (BITSPERPIXEL BM))) (BITBLT BM NIL NIL CURSORBM) (RESETFORM (CURSOR (CURSORCREATE CURSORBM NIL (fetch (CURSOR CUHOTSPOTX) of \CURRENTCURSOR) (fetch (CURSOR CUHOTSPOTY) of \CURRENTCURSOR))) (until (MOUSESTATE (NOT LEFT)))) (UPDATE/BM/DISPLAY/SELECTED/REGION W)) (T (* ;; "the region being editted is inverted while the menu is active.  Each command must make sure that it is recomplemented.") (UPDATE/BM/DISPLAY/SELECTED/REGION W) (SELECTQ (MENU (COND ((type? MENU EDITBMMENU) EDITBMMENU) (T (SETQ EDITBMMENU (create MENU ITEMS _ (APPEND (COND ((COLORDISPLAYP) (QUOTE ((Color (QUOTE Color) "Choose color to set bits with")))) (T NIL)) (QUOTE ((Paint (QUOTE Paint) "Calls the window PAINT command on the bitmap.") (ShowAsTile (QUOTE ShowAsTile) "tiles the upper part of the edit window with the bitmap.") (Grid% On/Off (QUOTE GridOnOff) "Grid On/Off Switch") (GridSize_ (QUOTE GridSize_) "Allows setting of the size of a bit in the edit area.") (Reset (QUOTE Reset) "Sets the bitmap back to the state at the start of this edit session.") (Clear (QUOTE Clear) "Sets the entire bitmap to 0") (Cursor_ (QUOTE Cursor_) "Puts the bitmap into the cursor and exits the editor.") (OK (QUOTE OK) "Leaves the edit session.") (Abort (QUOTE Abort) "Restores the bitmap to its original values and leaves the editor.")))) CENTERFLG _ T))))) (OK (WINDOWPROP W (QUOTE FINISHEDFLG) T)) (Abort (WINDOWPROP W (QUOTE FINISHEDFLG) (QUOTE KILL))) (Reset (* ;; "allow the user to choose between everything or just visible part.  This also give the user a chance to change their mind.") (COND ((SELECTQ (\EDITBMHOWMUCH BM BITSWIDE BITSHIGH "RESET how much?") (VISIBLE (COND ((SETQ ORIGBM (WINDOWPROP W (QUOTE ORIGINALBITMAP))) (COND ((REGIONP ORIGBM) (BITBLT \CURSORDESTINATION (IPLUS XOFFSET (fetch (REGION LEFT) of ORIGBM)) (IPLUS YOFFSET (fetch (REGION BOTTOM) of ORIGBM)) BM XOFFSET YOFFSET BITSWIDE BITSHIGH (QUOTE INPUT) (QUOTE REPLACE))) (T (BITBLT ORIGBM XOFFSET YOFFSET BM XOFFSET YOFFSET BITSWIDE BITSHIGH)))) (T (BLTSHADE WHITESHADE BM XOFFSET YOFFSET BITSWIDE BITSHIGH (QUOTE REPLACE)))) T) (WHOLE (COND ((SETQ ORIGBM (WINDOWPROP W (QUOTE ORIGINALBITMAP))) (COND ((REGIONP ORIGBM) (BITBLT \CURSORDESTINATION (fetch (REGION LEFT) of ORIGBM) (fetch (REGION BOTTOM) of ORIGBM) BM)) (T (BITBLT ORIGBM NIL NIL BM)))) (T (BLTSHADE WHITESHADE BM NIL NIL NIL NIL (QUOTE REPLACE)))) T) (PROGN (UPDATE/BM/DISPLAY/SELECTED/REGION W) NIL)) (\EDITBM/PUTUP/DISPLAY W BM GRIDSPEC GRIDINTERIOR BITSWIDE BITSHIGH)))) (Clear (* ;; "allow the user to choose between everything or just visible part.  This also give the user a chance to change their mind.") (COND ((SELECTQ (\EDITBMHOWMUCH BM BITSWIDE BITSHIGH "CLEAR how much?") (VISIBLE (BLTSHADE WHITESHADE BM XOFFSET YOFFSET BITSWIDE BITSHIGH (QUOTE REPLACE)) T) (WHOLE (\CLEARBM BM) T) (PROGN (UPDATE/BM/DISPLAY/SELECTED/REGION W) NIL)) (DSPFILL GRIDINTERIOR WHITESHADE (QUOTE REPLACE) W) (COND ((WINDOWPROP W (QUOTE GRIDON)) (GRID GRIDSPEC BITSWIDE BITSHIGH (QUOTE POINT) W))) (UPDATE/BM/DISPLAY BM W)))) (GridOnOff (COND ((NOT (WINDOWPROP W (QUOTE GRIDON))) (* ; "Turn Grid On") (WINDOWPROP W (QUOTE GRIDON) T) (GRID GRIDSPEC BITSWIDE BITSHIGH (QUOTE POINT) W) (* ;; "FS:  The update here was unnecessary.  (UPDATE/BM/DISPLAY BM W)") NIL) (T (* ; "Turn off grid") (WINDOWPROP W (QUOTE GRIDON) NIL) (* DSPFILL (create REGION LEFT _ 0 BOTTOM _ 0 WIDTH _ (ADD1 (fetch (REGION WIDTH) of GRIDINTERIOR)) HEIGHT _ (ADD1 (fetch (REGION HEIGHT) of GRIDINTERIOR))) WHITESHADE (QUOTE REPLACE) W) (RESETGRID.NEW BM GRIDSPEC BITSWIDE BITSHIGH 0 0 W T) (* ;; "FS:  The update here was unnecessary.  (UPDATE/BM/DISPLAY BM W)") NIL))) (GridSize_ (* ; "sets the grid square size and calls the reshapefn.") (COND ((SETQ NEWGRIDSIZE (NUMBERP (MENU (COND ((TYPENAMEP GRIDSIZEMENU (QUOTE MENU)) GRIDSIZEMENU) (T (SETQ GRIDSIZEMENU (create MENU ITEMS _ (QUOTE (3 4 5 6 7 8 12 16 20 24 28 32)) MENUROWS _ 4))))))) (WINDOWPROP W (QUOTE GRIDSQUARE) NEWGRIDSIZE) (EDITBMRESHAPEFN W)))) (ShowAsTile (* ; "tiles the upper part of the window with the bitmap so the user can see what it would be as a shade.") (UPDATE/SHADE/DISPLAY BM W)) (Paint (* ; "call the window paint command on the contents of the bitmap.") (if (EDITBM.PAINTW W BM BITMAPWIDTH BITMAPHEIGHT) then (* ; "Update our view") (\EDITBM/PUTUP/DISPLAY W BM GRIDSPEC GRIDINTERIOR BITSWIDE BITSHIGH))) (Cursor_ (* ; "Stuffs lower left part of image into the cursor and sets the hotspot.") (READHOTSPOT BM GRIDSPEC GRIDINTERIOR W) (WINDOWPROP W (QUOTE FINISHEDFLG) T)) (Color (WINDOWPROP W (QUOTE COLOR) (OR (MENU (COLORMENU BITSPERPIXEL)) COLOR))) (UPDATE/BM/DISPLAY/SELECTED/REGION W))))))
)

(EDITBM.PAINTW
(LAMBDA (W BM BITMAPWIDTH BITMAPHEIGHT) (* ; "Edited 25-Jan-89 19:06 by bvm") (* ;; "Use PAINTW on BM.  Return T if we did anything.  ") (LET ((LEFT 0) (BOTTOM 0) (WIDTH BITMAPWIDTH) (HEIGHT BITMAPHEIGHT) (WWIDTH (WIDTHIFWINDOW BITMAPWIDTH)) (WHEIGHT (HEIGHTIFWINDOW BITMAPHEIGHT NIL)) PW) (if (> WWIDTH SCREENWIDTH) then (* ;; "Wider than screen--that's a waste.  The extra bits won't be paintable, and a bug in BITBLT will prevent us from making use of painting anywhere beyond x = SCREENWIDTH in the bitmap") (SETQ WIDTH (- SCREENWIDTH (- WWIDTH WIDTH))) (SETQ WWIDTH SCREENWIDTH) (* ; "Now make sure our part of the window is visible") (SETQ LEFT (MIN (WINDOWPROP W (QUOTE XOFFSET)) (- BITMAPWIDTH WIDTH)))) (if (> WHEIGHT SCREENHEIGHT) then (* ; "Similarly for y") (SETQ HEIGHT (- SCREENHEIGHT (- WHEIGHT HEIGHT))) (SETQ WHEIGHT SCREENHEIGHT) (SETQ BOTTOM (MIN (WINDOWPROP W (QUOTE YOFFSET)) (- BITMAPHEIGHT HEIGHT)))) (SETQ PW (CREATEW (create REGION LEFT _ (IQUOTIENT (- SCREENWIDTH WWIDTH) 2) BOTTOM _ (IQUOTIENT (- SCREENHEIGHT WHEIGHT) 2) WIDTH _ WWIDTH HEIGHT _ WHEIGHT))) (OPENW PW) (BITBLT BM LEFT BOTTOM PW 0 0 WIDTH HEIGHT) (PAINTW PW) (PROG1 (COND ((MENU (create MENU ITEMS _ (QUOTE ((YES T "Will put the newly painted bits back in the bitmap being editted.") (NO NIL "Will discard the painted bits, not changing the bitmap being editted."))) TITLE _ "Put change into bitmap?" CENTERFLG _ T)) (BITBLT PW 0 0 BM LEFT BOTTOM WIDTH HEIGHT) T)) (CLOSEW PW))))
)
)
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(PUTPROPS UPDATE/BM/DISPLAY MACRO ((BM W) (BITBLT BM (WINDOWPROP W (QUOTE DXOFFSET)) (WINDOWPROP W (QUOTE DYOFFSET)) W 0 (WINDOWPROP W (QUOTE BMDISPLAYBOTTOM)) (WINDOWPROP W (QUOTE BMDISPLAYWIDTH)) 1000 NIL (QUOTE REPLACE))))
)
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(LOCALVARS . T)
)
(PUTPROPS S33BMHAX COPYRIGHT ("Xerox Corporation" 1988 1989))
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (1423 6418 (BMSCALEBY2 1433 . 3674) (BMSCALEBY4 3676 . 6276) (BMSCALEFN 6278 . 6416)) (
6481 13437 (BIGBMOBJ.CREATE 6491 . 6635) (BIGBMOBJ.CREATE.MENU 6637 . 7315) (BIGBMOBJ.DISPLAYFN 7317
 . 8257) (BIGBMOBJ.EDITBM 8259 . 8668) (BIGBMOBJ.IMAGEBOXFN 8670 . 9370) (BIGBMOBJ.IMAGES 9372 . 10226
) (BIGBMOBJ.SHRINKBITMAP 10228 . 10699) (BIGBMOBJ.BUTTONEVENTINFN 10701 . 11967) (BIGBMOBJ.COPYFN 
11969 . 12250) (BIGBMOBJ.GETFN 12252 . 12599) (BIGBMOBJ.PUTFN 12601 . 13038) (BIGBMOBJ.INIT 13040 . 
13435)) (13438 19379 (NEW.TRIM.BITMAP 13448 . 13941) (BIGBMOBJ.TRIM.BITMAP 13943 . 15203) (
TRIM.BITMAP.FIND.REGION 15205 . 16244) (TRIM.BITMAP.FIND.COLUMN 16246 . 18022) (TRIM.BITMAP.FIND.ROW 
18024 . 19377)) (19640 29775 (EDITBMBUTTONFN 19650 . 28279) (EDITBM.PAINTW 28281 . 29773)))))
STOP
