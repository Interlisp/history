(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE (DEFPACKAGE "S33" (USE "LISP" "XCL" "RPC2")))
(il:filecreated "21-Nov-90 11:13:44" "{IE:PARC:Xerox}<LispUsers>medley>SYSTEM33.;2" 36292  

      il:|changes| il:|to:|  (il:variables *use-exact-mode*) (il:functions open-exact-file)

      il:|previous| il:|date:| " 2-Apr-90 10:13:49" "{IE:PARC:Xerox}<LispUsers>medley>SYSTEM33.;1")


; Copyright (c) 1988, 1989, 1990 by Xerox Corporation.  All rights reserved.

(il:prettycomprint il:system33coms)

(il:rpaqq il:system33coms ((il:files il:tedit il:s33def il:aisblt il:tablebrowser il:s33bmhax il:s33browser il:s33convert) (il:p (export (quote (locate open-exact-file copy-exact-file display-ais-file *good-document-formats* *presentation-methods* *inter-call-wait* *max-inter-call-wait* *system-33-host* *use-exact-mode* *desc-fields-parse-table*)))) (il:advise (il:lastchpos :in il:unpackfilename.string)) (il:variables *system-33-host* *good-document-formats* *presentation-methods* *description-window-size*) (il:addvars (il:\\systemcachevars *local-host-name*)) (il:coms (il:* il:\; "The main routine") (il:functions locate encode-result-type) (il:variables *inter-call-wait* *max-inter-call-wait* *buffer-size* *result-types* *retrieve-result-types* *null-doc-handle*)) (il:coms (il:* il:\; "File handle conversion") (il:functions doc-id-from-string string-from-doc-id) (il:functions file-name-from-location date-from-time-limit open-exact-file copy-exact-file) (il:variables *use-exact-mode* *local-host-name*)) (il:coms (il:* il:\; "Finding out info about server") (il:variables *server-options-checked*) (il:functions query-server-options list-server-options change-server)) (il:coms (il:* il:\; "Retrieving") (il:functions map-presentations map-presentations-1 retrieve-by-id tedit-display-from-id tedit-display-subcom display-from-descr prompt-for-format show-presentation major-format)) (il:coms (il:* il:\; "Presenting AIS") (il:functions show-ais display-ais-file read-large-ais-file read-and-scale-ais-file scrolling-bitmap-window) (il:variables *bitmap-reduction-method* *max-bits-per-bitmap* *max-unscaled-width* *max-unscaled-height* *min-words-per-aisblt*)) (il:coms (il:* il:\; "Parsing descriptions") (il:functions description-from-id-loc parse-description fetch-index-line) (il:variables *desc-fields-parse-table*)) (il:coms (il:* il:\; "Access from background menu") (il:addvars (il:|BackgroundMenuCommands| ("System 33" (quote (make-browser)) "Open a System 33 browser." (il:subitems ("System 33 Browser" (quote (make-browser)) "Open a System 33 browser.") ("File Converter" (quote (make-converter)) "Open a tool to use System 33 to convert file formats."))))) (il:vars (il:|BackgroundMenu|)) (il:* il:\; " And from TEdit") (il:p (let ((newitem (quote ("Retrieve via ID" (quote tedit-display-from-id) "Retrieve from System 33 the document whose ID is selected, and display it" (il:subitems ("Display as image" (tedit-display-subcom (quote ("RS:75(64-80).PZ:1.ais"))) "Display document as an image at screen resolution (75 pixels per inch)." (il:subitems ("Scaled by 2" (quote (tedit-display-subcom 2)) "Display the image scaled down by 2 in each dimension.") ("Scaled by 4" (quote (tedit-display-subcom 4)) "Display the image scaled down by 4 in each dimension.") ("Full size" (tedit-display-subcom (quote ("PZ:1.ais"))) "Display the image full scale.") ("Screen Resolution" (tedit-display-subcom (quote ("RS:75(64-80).PZ:1.ais"))) "Display the image at screen resolution (75 pixels per inch).") ("Thumbnail Sketch" (tedit-display-subcom (quote ("PX:100[64-200]:100[64-200].PZ:1.ais"))) "View a tiny image of the selected document"))) ("Display as text" (tedit-display-subcom (quote ("text" "tedit"))) "Display document as text (may do text recognition).") ("Specify Format" (tedit-display-subcom :ask) "Prompts for the format in which to retrieve the document.")))))) (il:tedit.add.menuitem il:tedit.default.menu newitem) (setq il:lafite.extra.display.commands (cons newitem (and (boundp (quote il:lafite.extra.display.commands)) il:lafite.extra.display.commands)))))) (il:declare\: il:eval@compile il:dontcopy (il:p (proclaim (quote (special il:italicfont)))) (il:files (il:source) il:tablebrowserdecls)) (il:prop (il:filetype il:makefile-environment) il:system33)))

(il:filesload il:tedit il:s33def il:aisblt il:tablebrowser il:s33bmhax il:s33browser il:s33convert)

(export (quote (locate open-exact-file copy-exact-file display-ais-file *good-document-formats* *presentation-methods* *inter-call-wait* *max-inter-call-wait* *system-33-host* *use-exact-mode* *desc-fields-parse-table*)))

(reinstall-advice (quote (il:lastchpos :in il:unpackfilename.string)) :after (quote ((:last (cond ((and (eq il:ch (il:charcode ":")) il:!value (il:strpos "." (il:substring il:str il:start (il:sub1 il:!value)))) (il:* il:|;;| "Ignore colons that appear after any dot in the file name.  This is for the benefit of Maiko, which uses generic file parsing code (device included), which screws up on System 33 files with transformations in the name.") (return nil)))) (:last (cond ((and (eq il:ch (il:charcode ":")) il:!value (il:strpos "." (il:substring il:str il:start (il:sub1 il:!value)))) (return nil)))))))

(il:readvise (il:lastchpos :in il:unpackfilename.string))

(defvar *system-33-host* "system33" "Default host to talk to for System 33 enquiries")

(defglobalparameter *good-document-formats* (quote ("PX:900[16-1000]:700[16-1000].PZ:1.ais" "tedit" "text" "sketch" "crtext")) "Document formats we can read.  First one must be AIS (we sometimes hack it).  There must exist corresponding entries in *PRESENTATION-METHODS*.")

(defglobalparameter *presentation-methods* (quote (("ais" show-ais) ("text" show-text "text" t) ("crtext" show-text "crtext" t) ("tedit" show-text "tedit") ("sketch" show-text "sketch"))) "Methods for displaying docs of various formats.  Each is (format method . extra).  Method is called with args (file format descr browserwindow . extra)")

(defvar *description-window-size* (quote (500 . 300)) "Default size of window in which to view System 33 description files.")

(il:addtovar il:\\systemcachevars *local-host-name*)



(il:* il:\; "The main routine")


(defun locate (progname args &key mapfn progressfn handle servers formats time-limit result-types host username) (let (ophandle) (unwind-protect (prog* ((rtypes (cond ((null result-types) (il:* il:\; "Return doc handles and file locations, offsets allowed") 67) ((integerp result-types) (il:* il:\; "Somebody encoded it already") result-types) (t (encode-result-type result-types)))) (matches-only (eql rtypes 0)) (result (and matches-only 0)) defaultwait once newmatches progress n) (setq once (il:* il:\; "Make the first call, then loop calling for more") (remote-procedure-call (or host *system-33-host*) (quote system-33) (quote locate) (list (make-locate-args :username (or username (il:username nil nil t)) :locate-spec (cons progname args) :doc-id (or handle *null-doc-handle*) :loc-filter (make-file-loc-filter :servers servers :formats formats :time-limit (or time-limit 0)) :buffer-size *buffer-size* :result-type rtypes)))) lp (unless (and once (eql (car (setq once (car once))) 0)) (il:* il:\; "Some sort of failure") (return once)) (setq once (cadr once)) (il:* il:\; "A LocateResult structure") (setq ophandle (locate-result-handle once)) (setq progress (locate-result-progress once)) (when (and progressfn (eq (funcall progressfn progress) :abort)) (il:* il:\; "Let caller show feedback.  Quit now if requested abort") (setq result (list "User abort." nil)) (go done)) (setq n (locate-result-nmatches once)) (il:* il:\; "Number of matches this time") (cond (matches-only (il:* il:\; "Just counting the matches") (setq result (+ result n))) (t (il:* il:\; "Call mapfn on each idloc and collect the results") (mapc (function (lambda (loc) (when (or (null mapfn) (setq loc (funcall mapfn loc))) (cond ((eq loc :abort) (il:* il:\; "Abort requested") (go done)) (t (push loc result)))))) (locate-result-id-locs once)))) (unless (eql (progress-report-work-pending progress) 0) (il:* il:\; "There is more to do") (cond ((eql n 0) (il:* il:\; "If no results this pass, wait before calling again") (let ((waittime (progress-report-time-wait progress))) (unless (eql waittime 0) (il:* il:\; "Server guesses this long til next result available") (il:dismiss (cond ((> waittime 0) (* waittime 1000)) (defaultwait (il:* il:\; "Back off a little more") (setq defaultwait (min (+ defaultwait (ash defaultwait -2)) *max-inter-call-wait*))) (t (il:* il:\; "First time we wait, guess this") (setq defaultwait *inter-call-wait*))))))) (t (il:* il:\; "don't wait yet (if we got any results, there may be more), and restart the backoff interval") (setq defaultwait nil))) (setq once (remote-procedure-call *system-33-host* (quote system-33) (quote locate-more) (list (make-locate-more-args :handle ophandle :buffer-size *buffer-size* :result-type rtypes)))) (go lp)) done (return (if matches-only result (nreverse result)))) (il:* il:|;;| "Cleanup: release the op handle") (when ophandle (remote-procedure-call *system-33-host* (quote system-33) (quote release-op) (list ophandle))))))

(defun encode-result-type (flags) (il:* il:|;;| "FLAGS is list of result-type flags.  Turn into integer for Locate call.") (let ((bits 0)) (dolist (f (if (listp flags) flags (list flags))) (setq bits (logior bits (cond ((cdr (assoc f *result-types*))) (t (cerror "Ignore the flag" "Unknown result type ~S" f) 0))))) bits))

(defvar *inter-call-wait* 500 "Milliseconds to wait between calls to LocateMore")

(defvar *max-inter-call-wait* 10000 "As we back off, the longest (in msecs) we should wait between calls to LocateMore.")

(defvar *buffer-size* 400 "Largest UDP body we can receive.  Artificially low now to compensate for server bug")

(defvar *result-types* (quote ((:matches-only . 0) (:handles . 1) (:file-locations . 2) (:estimate-only . 4) (:include-lengths . 8) (:once-only . 16) (:multiple-attributes . 32) (:offset-allowed . 64))) "Names for the flag bits in Locate's ResultType argument")

(defconstant *retrieve-result-types* 35 "result-types arg in calls to retrieve.  #x23 = handles, files locations, multiple attributes.")

(defglobalparameter *null-doc-handle* (make-array *doc-id-size* :element-type (quote (unsigned-byte 8)) :initial-element 0) "Doc handle of all zeroes")



(il:* il:\; "File handle conversion")


(defun doc-id-from-string (str &optional noerror) (il:* il:|;;| "Convert a human-sensible string to a System 33 document handle.  The string is hexidecimal digits.  Handle is a 32-byte object.  If noerror is true, returns NIL is string is malformed, otherwise errors") (let ((nc (length str))) (when (oddp nc) (when noerror (return-from doc-id-from-string nil)) (cerror "Append a zero to the string" "System 33 document handle doesn't have even number of characters: ~A" str) (setq nc (1+ nc)) (setq str (concatenate (quote string) str "0"))) (let ((handle (make-array *doc-id-size* :element-type (quote (unsigned-byte 8)) :initial-element 0)) (strindex -1) (hindex -1)) (decf nc) (il:* il:\; "for bounds check") (loop (when (>= strindex nc) (il:* il:\; "Finished conversion") (return handle)) (let ((l (digit-char-p (aref str (incf strindex)) 16)) (r (digit-char-p (aref str (incf strindex)) 16))) (cond ((and l r) (setf (aref handle (incf hindex)) (+ (ash l 4) r))) (noerror (return-from doc-id-from-string nil)) (t (error "Invalid character '~A' in Doc ID" (aref str (if l strindex (1- strindex)))))))))))

(defun string-from-doc-id (handle) (il:* il:|;;| "Turn a System 33 handle into a human-sensible string.  HANDLE is 32 bytes long.  String has 2 hex digits for each byte.  Trailing zeros are discarded.") (let ((i (1- *doc-id-size*)) str n) (loop (setq n (aref handle i)) (il:* il:\; "Next byte (= 2 characters)") (when (or str (cond ((not (eql 0 n)) (il:* il:\; "This is the last significant char, so now we know how long to make the string") (setq str (make-string (* (1+ i) 2)))))) (il:* il:\; "Fill in next 2 characters") (setf (aref str (* i 2)) (digit-char (ash n -4) 16)) (setf (aref str (1+ (* i 2))) (digit-char (logand n 15) 16))) (when (< (decf i) 0) (il:* il:\; "Done") (return (or str "00"))))))

(defun file-name-from-location (fileloc) (il:* il:|;;| "Returns the full filename given in FILE-LOCATION fileloc") (or (file-location-full-name fileloc) (setf (file-location-full-name fileloc) (let* ((server (file-location-file-server fileloc)) (hostname (subseq server 1)) (filename (file-location-file-name fileloc))) (case (char server 0) (#\N (il:* il:\; "NFS server name ") (cond ((not *use-os-networking*) (il:* il:\; "D machine via NFS--turn server into name/n") (concatenate (quote string) "{" hostname "/n}" filename)) ((string-equal hostname (or *local-host-name* (setq *local-host-name* (or (il:unix-getparm "HOSTNAME") "//noname//")))) (il:* il:\; "File is actually on this machine, so refer to it directly") (concatenate (quote string) "{unix}" filename)) (t (il:* il:\; "{unix}/net/name on non-local Maiko") (concatenate (quote string) "{unix}/net/" hostname filename)))) (t (il:* il:\; "Assume we can figure out other types") (concatenate (quote string) "{" hostname "}" filename)))))))

(defun date-from-time-limit (time-limit) (il:gdate (+ time-limit *time-limit-origin*) (il:dateformat il:no.seconds)))

(defun open-exact-file (file &optional access parameters) (il:* il:|;;| "Open for input the specified FILE, whose unix name we know exactly") (when (typep file (quote file-location)) (setq file (file-name-from-location file))) (unless access (setq access (quote il:input))) (il:openstream file access (if *use-exact-mode* (quote il:exact) (quote il:old)) parameters))

(defun copy-exact-file (srcfil dstfil &optional exact-direction destparameters) (il:* il:|;;| "A simple COPYFILE that opens either the source or destination or both in \"exact\" mode.  EXACT-DIRECTION is one of :input (srcfil is exact), :output (dstfil is exact), or :io (both), default being :io.  NOTE: This is simple COPYBYTES.  Does not do eol conversion like COPYFILE.") (let ((infile (case exact-direction (:output (il:openstream srcfil (quote il:input))) (t (open-exact-file srcfil (quote il:input))))) outfile success) (unwind-protect (let ((parms (il:bquote ((il:icreationdate (il:\\\, (il:getfileinfo infile (quote il:icreationdate)))) (il:\\\,. destparameters))))) (setq outfile (case exact-direction (:output (open-exact-file dstfil (quote il:output) parms)) (t (il:openstream dstfil (quote il:output) nil parms)))) (il:copybytes infile outfile) (setq success (il:fullname outfile))) (il:* il:\; "Cleanup now") (close infile) (when outfile (close outfile :abort (null success))))))

(defvar *use-exact-mode* t "True if we should use il:openstream's EXACT mode when opening files.  If you set this to NIL, you'd better hope your file system can figure out mixed case in directory names.")

(defglobalvar *local-host-name* nil "Name of local machine on Sun.")



(il:* il:\; "Finding out info about server")


(defvar *server-options-checked* nil "Time when we last asked server for options, or NIL if we haven't yet.")

(defun query-server-options (&optional always pwindow) (il:* il:|;;| "Asks the System33 server for some info") (il:allow.button.events) (il:* il:\; "In case called by mouse") (or pwindow (setq pwindow il:promptwindow)) (when (or always (not *server-options-checked*)) (format pwindow "~&Checking System33 server options...") (let ((domains (list-server-options "listsearchdomains")) (formats (list-server-options "listallformats"))) (when domains (setq *search-domains* domains)) (when formats (setq *format-values* formats) (let* ((label "DocFormat") (old (assoc label *attribute-values* :test (quote string-equal)))) (if old (rplacd old formats) (push (cons label formats) *attribute-values*))))) (format pwindow " done.") (setq *server-options-checked* (il:idate))))

(defun list-server-options (operation &optional args) (il:* il:|;;| "Handles those server calls whose \"result\" is a file containing strings, one per line.  OPERATION and optional ARGS are the program and its arguments.  Returns a list of strings.") (let ((result (locate operation args))) (and result (id-loc-p (car result)) (let ((stream (open-exact-file (file-name-from-location (car (id-loc-file-loc (car result))))))) (unwind-protect (il:|bind| tmp il:|while| (> (length (setq tmp (read-line stream nil ""))) 0) il:|collect| tmp) (close stream))))))

(defun change-server (window browser) (let ((s (browser-prompt-for-input window "Set System33 Server to be: " *system-33-host*))) (when s (setq *system-33-host* s))))



(il:* il:\; "Retrieving")


(defun map-presentations (fn descr window &optional formats) (il:* il:|;;| "show document referred to by descr ") (let* ((props (description-props descr)) (id (cadr (assoc :data-id props)))) (cond ((null id) (il:* il:\; "No image for this") (browser-prompt window "~%~A has no document id!" (or (cadr (assoc :title (description-props descr))) "Item"))) (t (map-presentations-1 (browser-locate window "retrieve" nil (il:* il:\; " no program arguments") "Retrieval" :handle (doc-id-from-string id) :formats (or formats *good-document-formats*) :result-types *retrieve-result-types*) fn descr window)))))

(defun map-presentations-1 (presentations fn &optional descr window) (il:* il:|;;| "Take a list of presentations that came back from retrieve, and apply fn to the best one") (cond ((not presentations) (il:* il:\; "Retrieve returned NIL?  Dunno how this happens") (browser-prompt window "Retrieve from System 33 returned no file!")) ((not (consp presentations)) (il:* il:\; "Error was handled") nil) ((integerp (car presentations)) (il:* il:\; "Error case") (browser-prompt window "Retrieval failed because ~A" (cadr presentations))) (t (il:* il:|;;| "Success.  For now, apply fn to all") (dolist (p presentations) (let* ((pre (car (id-loc-file-loc p))) (file (file-name-from-location pre)) (format (file-location-file-format pre))) (funcall fn file format descr window))))))

(defun retrieve-by-id (id &optional fn window formats) (il:* il:|;;| "Given a document ID, retrieve the image, applying fn (as in map-presentations).  id can be either description id (in which case we index thru it) or doc id.") (browser-prompt window "Retrieving document... ") (let* ((presentations (locate "retrieve" nil (il:* il:\; " no program arguments") :handle id :formats (cons "desc" (or formats (if nil *good-document-formats* (remove "text" *good-document-formats* :test (quote string=)) (il:* il:\; "Kludge around server bug")))) :result-types *retrieve-result-types*)) (firstone (car presentations))) (cond ((and (id-loc-p firstone) (search "desc" (file-location-file-format (car (id-loc-file-loc firstone))))) (il:* il:\; "It was a description ID, so make like we do with browser results.") (let* ((descr (description-from-id-loc firstone)) (title (cadr (assoc :title (description-props descr))))) (when title (browser-prompt window "(~A)... " title)) (display-from-descr descr window formats))) (t (il:* il:\; "Must have been a doc ID, so display whatever came back") (map-presentations-1 presentations (or fn (function show-presentation)) nil window)))))

(defun tedit-display-from-id (textstream &optional fn formats) (let ((sel (il:tedit.sel.as.string textstream)) (window (car (record-fetch textobj \\window (il:textobj textstream)))) id) (when window (setq window (il:mainwindow window)) (browser-prompt-clear window)) (cond ((eql (length sel) 0) (browser-prompt window "Nothing is selected!")) ((not (setq id (doc-id-from-string sel t))) (browser-prompt window "'~A' is not a System 33 document-id" sel)) ((or (not (eq formats :ask)) (setq formats (prompt-for-format window))) (if (il:windowprop window (quote il:textobj)) (il:resetform (il:ttydisplaystream (il:getpromptwindow window)) (il:* il:|;;| "Gross kludge.  Force TEdit's prompt window to expand if we print more than one line's worth to it.") (retrieve-by-id id fn window formats)) (retrieve-by-id id fn window formats))))))

(defun tedit-display-subcom (formats) (il:* il:|;;| "What we return to TEdit to make it call one of the \"Retrieve by ID\" subcommands") (function (lambda (textstream) (tedit-display-from-id textstream nil formats))))

(defun display-from-descr (descr &optional window formats) (cond ((integerp formats) (il:* il:\; "A scale factor") (let* ((props (description-props descr)) (width (cadr (assoc :pixel-width props))) (height (cadr (assoc :pixel-height props)))) (cond ((and width height) (setq formats (list (format nil "PX:~D:~D.PZ:1.ais" (round width formats) (round height formats))))) (t (browser-prompt window "Can't scale image because its dimensions are unknown") (return-from display-from-descr))))) ((eq formats :ask) (il:* il:\; "Prompt for a format") (unless (setq formats (prompt-for-format window)) (return-from display-from-descr))) (nil (il:* il:\; "Currently we don't ask for resolution conversion--scaling to screen is better.") (setq formats (let ((resolution (cadr (assoc :resolution (description-props descr))))) (if (and resolution (> resolution 75)) (cons "RS:75.PZ:1.ais" (cdr *good-document-formats*)) *good-document-formats*))))) (map-presentations (function show-presentation) descr window formats))

(defun prompt-for-format (&optional window) (let ((result (browser-prompt-for-input window "Format: " (or (and window (il:windowprop window (quote format))) (find "ais" *good-document-formats* :test (quote string-equal) :key (quote major-format)))))) (when result (when window (il:windowprop window (quote format) result)) (il:* il:\; "Remember for next time") (list result))))

(defun show-presentation (file format descr browserwindow) (let* ((major-format (major-format format)) (how (assoc major-format *presentation-methods* :test (quote string-equal)))) (cond (how (il:* il:\; "Each entry = (format fn . extrainfo)") (apply (cadr how) file format descr browserwindow (cddr how))) (t (browser-prompt browserwindow "Don't know how to display ~A format." format)))))

(defun major-format (format) (il:* il:|;;| "Returns the \"major format\" component of format, i.e., the thing after the last dot") (let ((dot (position #\. format :from-end t))) (if dot (subseq format (1+ dot)) format)))



(il:* il:\; "Presenting AIS")


(defun show-ais (file format descr browserwindow) (il:* il:|;;| "Presentation method for format AIS.") (display-ais-file file (cadr (assoc :title (description-props descr))) browserwindow nil nil nil descr))

(defun display-ais-file (file &optional title browserwindow asbitmap scalefactor expectedscale description) (il:* il:|;;| "Display AIS file in its own window with specified title.  Return the window.  If ASBITMAP is true, instead read it into a bitmap and return the bitmap.") (when browserwindow (browser-prompt browserwindow "Reading AIS file... ")) (with-open-stream (s (open-exact-file file)) (let* ((info (cadr (assoc :raster (il:aisfileheader s)))) (width (getf info :scan-length)) (origwidth width) (height (getf info :scan-count)) (origheight height) (sourcebits (getf info :bits-per-sample)) (destbits 1) (method (or (and browserwindow (il:windowprop browserwindow (quote bitmap-reduction-method))) *bitmap-reduction-method*)) bm actualscale) (when (eq scalefactor :none) (il:* il:\; "How auto-scale is overridden") (setq scalefactor nil)) (when (integerp asbitmap) (setq destbits asbitmap)) (when (and browserwindow (not (eql sourcebits destbits))) (browser-prompt browserwindow "~%Converting ~D bits per pixel to ~D... " sourcebits destbits)) (when (and description (null scalefactor)) (il:* il:|;;| "See how much it was actually scaled by.  Average scale in both dimensions in case something funny, round to .1.") (let ((props (description-props description)) fixed) (setq origwidth (or (cadr (assoc :pixel-width props)) origwidth)) (setq origheight (or (cadr (assoc :pixel-height props)) origheight)) (setq actualscale (/ (+ (round (* origwidth 10) width) (round (* origheight 10) height)) 20.0)) (when (= actualscale (setq fixed (floor actualscale))) (il:* il:\; "Turn round floats into integers") (setq actualscale fixed)) (when (and browserwindow expectedscale (not (= actualscale expectedscale))) (browser-prompt browserwindow "(actual scale = ~A) " actualscale)))) (cond ((and scalefactor (eql sourcebits 1) (or (not (eq scalefactor t)) (> width *max-unscaled-width*) (> height *max-unscaled-height*))) (il:* il:\; "Need to make it smaller") (multiple-value-setq (bm scalefactor) (read-and-scale-ais-file s scalefactor width height method browserwindow))) ((<= (* width height destbits) *max-bits-per-bitmap*) (il:* il:\; "Hurray, it all fits in one bitmap") (setq bm (il:bitmapcreate width height destbits)) (il:aisblt.bitmap s 0 0 bm 0 0 width height method)) (t (il:* il:\; "Need to read it into multiple bitmaps") (setq bm (read-large-ais-file s width height destbits method browserwindow)))) (when browserwindow (browser-prompt browserwindow "done.")) (if asbitmap bm (let ((w (scrolling-bitmap-window bm (and title (format nil "~A (~Dx~D~@[x~D~]~@[, scaled by ~D~])" title origwidth origheight (and (not (eql sourcebits 1)) sourcebits) (let ((s (or actualscale scalefactor))) (and s (not (= s 1)) s))))))) (il:windowprop w (quote description) description) (il:windowprop w (quote scalefactor) actualscale))))))

(defun read-large-ais-file (stream width height destbits method browserwindow) (il:* il:|;;| "Read AIS file STREAM into a list of bitmaps of width WIDTH whose heights add up to HEIGHT.  The first bitmap is the bottom one.") (let* ((maxheight (floor *max-bits-per-bitmap* (logand (+ (* width destbits) 15) -16))) (bottom height) bitmaps) (il:* il:\; "Each bitmap no more than MAXHEIGHT bits high") (il:while (> bottom 0) il:do (il:* il:\; "Read from the top down, because that's the order in which the file is stored.") (let* ((h (min bottom maxheight)) (subbm (il:bitmapcreate width h destbits))) (decf bottom h) (il:aisblt.bitmap stream 0 bottom subbm 0 0 width h method) (push subbm bitmaps))) bitmaps))

(defun read-and-scale-ais-file (stream scalefactor width height method browserwindow) (il:* il:|;;| "Read AIS file of specified dimensions and scale it in each dimension by SCALEFACTOR, a power of 2 (or t for auto-scaling).") (let (scaledwidth scaledheight sampleheight bigbm scalefn maxheight scaledbottom bigbottom scaledsampleheight bitmaps scaleshift) (cond ((eq scalefactor t) (il:* il:\; "Auto-scale: choose the power of 2 that comes closest to getting the image approximately fitting on the screen.") (setq scalefactor (ash 1 (setq scaleshift (max (log (/ (float width) il:screenwidth) 2) (log (/ (float height) il:screenheight) 2) 1))))) ((not (eql scalefactor (ash 1 (setq scaleshift (1- (integer-length scalefactor)))))) (il:* il:\; "Not a power of 2") (error "Scale factor ~D is not a power of 2." scalefactor))) (il:while (null (setq scalefn (il:bmscalefn scalefactor))) il:do (il:* il:\; "No scaling routine this big!") (setq scalefactor (ash scalefactor -1)) (decf scaleshift)) (il:* il:\; "SCALESHIFT is the amount to give to ASH to multiply by SCALEFACTOR") (when browserwindow (browser-prompt browserwindow "(scaling by ~D) " scalefactor)) (setq scaledwidth (ash width (- scaleshift))) (setq scaledheight (ash height (- scaleshift))) (setq height (ash scaledheight scaleshift)) (setq width (ash scaledwidth scaleshift)) (il:* il:\; "This may chop off top and right if width/height not multiple of SCALEFACTOR") (setq bigbm (il:bitmapcreate width (setq sampleheight (min height (* (ceiling (floor *min-words-per-aisblt* (ceiling width 16)) scalefactor) scalefactor))))) (il:* il:\; "This is scratch bitmap into which we will read chunks of the file") (setq scaledsampleheight (ash sampleheight (- scaleshift))) (setq maxheight (floor *max-bits-per-bitmap* (logand (+ scaledwidth 15) -16))) (il:* il:\; "This is how tall we can make a bitmap") (when (< maxheight scaledheight) (il:* il:\; "Will have to compose more than one piece, so want the piece size to be a multiple of SAMPLEHEIGHT") (setq maxheight (* (floor maxheight sampleheight) sampleheight))) (setq bigbottom height) (setq scaledbottom scaledheight) (il:while (> scaledbottom 0) il:do (let* ((subheight (min scaledbottom maxheight)) (subbottom subheight) (subbm (il:bitmapcreate scaledwidth subheight))) (il:* il:\; "Read from the top down, because that's the order in which the file is stored.") (il:|while| (> subbottom 0) il:|do| (let* ((subh (min subbottom scaledsampleheight)) (bigh (ash subh scaleshift))) (decf subbottom subh) (decf bigbottom bigh) (il:aisblt.bitmap stream 0 bigbottom bigbm 0 0 width bigh method) (funcall scalefn bigbm subbm subbottom subh scaledwidth))) (decf scaledbottom subheight) (push subbm bitmaps))) (values (if (cdr bitmaps) bitmaps (car bitmaps)) scalefactor)))

(defun scrolling-bitmap-window (bm title) (let (goodregion goodheight goodwidth height width w) (setq goodregion (cond ((consp bm) (il:* il:\; "A list of bitmaps, all the same width") (setq width 0) (setq height 0) (dolist (b bm) (setq width (max width (il:bitmapwidth b))) (incf height (il:bitmapheight b))) (il:trim.bitmap.find.region bm)) (t (il:* il:\; "A single bitmap") (setq height (il:bitmapheight bm)) (setq width (il:bitmapwidth bm)) (il:trim.bitmap.find.region (list bm))))) (setq goodheight (record-fetch region height goodregion)) (setq goodwidth (record-fetch region width goodregion)) (il:* il:\; "Dimensions trimmed of border white space") (setq w (il:createw (il:getboxregion (il:widthifwindow (if (< goodwidth (floor (* il:screenwidth 7) 8)) goodwidth (floor il:screenwidth 2))) (il:heightifwindow (if (< goodheight (floor (* il:screenheight 7) 8)) goodheight (floor il:screenheight 2)) title)) title)) (il:wxoffset (- (record-fetch region left goodregion)) w) (il:* il:\; "Fix origin to hide whitespace") (il:wyoffset (- (record-fetch region bottom goodregion)) w) (il:windowprop w (quote whole-bitmap) bm) (il:windowprop w (quote il:extent) (il:createregion 0 0 width height)) (il:windowprop w (quote il:scrollextentuse) (quote il:limit)) (il:* il:\; "Tell scroll handler the true dimensions, and that it should not let you past the visible parts") (il:windowprop w (quote il:maxsize) (cons width height)) (il:windowprop w (quote il:repaintfn) (function (lambda (window region &rest ignore) (il:* il:|;;| "Repaint by blting the whole bitmap.  Clipping code in bitblt does the rest.  Silly argument list: extra args are spurious ones from DOUSERFNS2") (let ((bm (il:windowprop window (quote whole-bitmap)))) (if (consp bm) (let ((bottom 0)) (il:* il:\; "Have to blt from several bitmaps.  Could optimize this some by noticing REGION") (dolist (b bm) (il:bitblt b 0 0 window 0 bottom (il:bitmapwidth b) (il:bitmapheight b) nil nil nil region) (incf bottom (il:bitmapheight b)))) (il:bitblt bm 0 0 window 0 0 (il:bitmapwidth bm) (il:bitmapheight bm) nil nil nil region)))))) (il:windowprop w (quote il:scrollfn) (quote il:scrollbyrepaintfn)) (il:redisplayw w) w))

(defvar *bitmap-reduction-method* :fsa "Method for converting N-bit-per-pixel map to a 1 bpp.  Choices are :FSA for Floyd-Steinberg dithering and :THRESHOLD for simple-minded thrsholding.")

(defconstant *max-bits-per-bitmap* (* 65533 32) "The most bits you can have in a bitmap (after rounding width up modulo 16)")

(defvar *max-unscaled-width* 1024 "Bitmaps wider than this are reduced if auto-scale on.")

(defvar *max-unscaled-height* 1300 "Bitmaps taller than this are reduced if auto-scale on")

(defvar *min-words-per-aisblt* 7680 "Minimum size chunk (in 16-bit words) to read from an AIS file at a time.  Bigger uses more storage but incurs less fixed overhead in AISBLT.")



(il:* il:\; "Parsing descriptions")


(defun description-from-id-loc (loc) (il:* il:|;;| "Given a id-loc result from some locate call, construct a description object.") (make-description :id (id-loc-doc-id loc) :file-locations (id-loc-file-loc loc) :props (parse-description (car (id-loc-file-loc loc)))))

(defun parse-description (fileloc &optional parse-table) (il:* il:|;;| "Given a file location, read the file and parse interesting fields, as specified by PARSE-TABLE (defaults to *DESC-FIELDS-PARSE-TABLE*).  Returns a list of (fieldname value) pairs.") (with-open-stream (s (open-exact-file fileloc)) (il:* il:|;;| "A fix 'til the parser handles eof more gracefully....") (il:setfileinfo s (quote il:endofstreamop) (function (lambda (stream) (case (il:getfileinfo stream (quote il:eol)) (il:cr (il:charcode il:cr)) (t (il:charcode il:lf)))))) (let* ((start (file-location-start-byte fileloc)) (nbytes (file-location-nbytes fileloc)) (props (il:lafite.parse.header s (or parse-table *desc-fields-parse-table*) start (and (>= nbytes 0) (+ start nbytes)) nil t)) w h d) (when (and (setq w (cadr (assoc :pixel-width props))) (setq h (cadr (assoc :pixel-height props)))) (push (list :dimensions (format nil "~Dx~D~@[x~D~]" w h (and (setq d (cadr (assoc :pixel-depth props))) (not (eql d 1)) d))) props)) props)))

(defun fetch-index-line (stream args) (declare (special il:parseresult)) (il:* il:|;;| "Called from parse table.  ARGS = (fieldname [:INTEGER]).  Read rest of line and associate it with fieldname in result.  If :INTEGER specified, read it") (push (list (car args) (let ((value (il:lafite.read.to.eol stream))) (or (and (eq (cadr args) :integer) (parse-integer value :junk-allowed t)) value))) il:parseresult))

(defparameter *desc-fields-parse-table* (il:lafite.make.parse.table (quote (("DocID:" fetch-index-line :data-id) ("DescID:" fetch-index-line :desc-id) ("DocCreateDate:" fetch-index-line :creation-date) ("DocCreator:" fetch-index-line :author) ("Title:" fetch-index-line :title) ("DocType:" fetch-index-line :doc-type) ("DocFormat:" fetch-index-line :format) ("PixelWidth:" fetch-index-line :pixel-width :integer) ("PixelHeight:" fetch-index-line :pixel-height :integer) ("PixelDepth:" fetch-index-line :pixel-depth :integer) ("PixelsPerInch:" fetch-index-line :resolution :integer) ("Keyword:" fetch-index-line :keyword)))))



(il:* il:\; "Access from background menu")


(il:addtovar il:|BackgroundMenuCommands| ("System 33" (quote (make-browser)) "Open a System 33 browser." (il:subitems ("System 33 Browser" (quote (make-browser)) "Open a System 33 browser.") ("File Converter" (quote (make-converter)) "Open a tool to use System 33 to convert file formats."))))

(il:rpaqq il:|BackgroundMenu| nil)



(il:* il:\; " And from TEdit")


(let ((newitem (quote ("Retrieve via ID" (quote tedit-display-from-id) "Retrieve from System 33 the document whose ID is selected, and display it" (il:subitems ("Display as image" (tedit-display-subcom (quote ("RS:75(64-80).PZ:1.ais"))) "Display document as an image at screen resolution (75 pixels per inch)." (il:subitems ("Scaled by 2" (quote (tedit-display-subcom 2)) "Display the image scaled down by 2 in each dimension.") ("Scaled by 4" (quote (tedit-display-subcom 4)) "Display the image scaled down by 4 in each dimension.") ("Full size" (tedit-display-subcom (quote ("PZ:1.ais"))) "Display the image full scale.") ("Screen Resolution" (tedit-display-subcom (quote ("RS:75(64-80).PZ:1.ais"))) "Display the image at screen resolution (75 pixels per inch).") ("Thumbnail Sketch" (tedit-display-subcom (quote ("PX:100[64-200]:100[64-200].PZ:1.ais"))) "View a tiny image of the selected document"))) ("Display as text" (tedit-display-subcom (quote ("text" "tedit"))) "Display document as text (may do text recognition).") ("Specify Format" (tedit-display-subcom :ask) "Prompts for the format in which to retrieve the document.")))))) (il:tedit.add.menuitem il:tedit.default.menu newitem) (setq il:lafite.extra.display.commands (cons newitem (and (boundp (quote il:lafite.extra.display.commands)) il:lafite.extra.display.commands))))
(il:declare\: il:eval@compile il:dontcopy 

(proclaim (quote (special il:italicfont)))


(il:filesload (il:source) il:tablebrowserdecls)
)

(il:putprops il:system33 il:filetype :compile-file)

(il:putprops il:system33 il:makefile-environment (:readtable "XCL" :package (defpackage "S33" (:use "LISP" "XCL" "RPC2"))))
(il:putprops il:system33 il:copyright ("Xerox Corporation" 1988 1989 1990))
(il:declare\: il:dontcopy
  (il:filemap (nil)))
il:stop
