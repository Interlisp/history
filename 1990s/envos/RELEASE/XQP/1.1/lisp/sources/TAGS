(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(FILECREATED "26-Jun-87 14:05:06" {ERIS}<PROLOGCORE>PDS>TAGS.\;1 23236        |changes| |to:|  (FUNCTIONS XQP::|tag.of| XQP::|arity.of| XQP::|atom.of| XQP::|untag.anything|                               XQP::|is.unbound|)      |previous| |date:| "25-Jun-87 14:48:19" {ERIS}<PROLOGCORE>LYRIC>LISP>TAGS.\;6); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(PRETTYCOMPRINT TAGSCOMS)(RPAQQ TAGSCOMS ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>TAGS.LSP;2, loaded 16-Jun-87 11:31:21")                                     (* |;;| "SCCS   : @(#)TAGS.LSP	3.8 1/31/86 File   : $xerox/tags.lsp Author : Richard A. O'Keefe Purpose: define the tags, tagging, and untagging")                 (* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")                                     (* |;;| "To start off with, we define the tag values. They come in two flavours.  The X.tag.8 numbers are used in SELECTCs where we do a 4- or 16-way dispatch on the tag coded in the top 8 bits of a tagged 32-bit cell.  The X.tag.16 numbers are used in forming those cells, so that we don't have to do any shifts at run time.  It is intended that all the dispatches will be done by micro-code 4-way dispatches (on X0,X4) and/or 16-way dispatches (on X0..X3 rotated to lie in X12..X15).  To make this as explicit as possible, there are no tests for any specific tag. ALL tag testing is done via select.4 or select.16 or an explict SELECTC (in unify and compare).")                 (CONSTANTS XQP::|ref.tag.8|)                                                             (* \; "16r_00_")                 (CONSTANTS XQP::|ref.tag.16|)                                                             (* \; "variables")                 (CONSTANTS XQP::|struct.tag.8|)                                                             (* \; "16r_48_")                 (CONSTANTS XQP::|struct.tag.16|)                                                             (* \; "compounds (except lists)")                 (CONSTANTS XQP::|list.tag.8|)                                                             (* \; "16r_80_")                 (CONSTANTS XQP::|list.tag.16|)                                                             (* \; "lists")                 (CONSTANTS XQP::|symbol.tag.8|)                                                             (* \; "16r_C8_")                 (CONSTANTS XQP::|symbol.tag.16|)                                                             (* \; "LITATOMs")                 (CONSTANTS XQP::|immed.tag.8|)                                                             (* \; "16r_D9_")                 (CONSTANTS XQP::|immed.tag.16|)                                                             (* \; "SMALLPs")                 (CONSTANTS XQP::|other.tag.8|)                                                             (* \; "16r_DA_")                 (CONSTANTS XQP::|other.tag.16|)                                                             (* \; "other Lisp objects")                 (CONSTANTS XQP::|boxed.tag.8|)                                                             (* \; "16r_E9_")                 (CONSTANTS XQP::|boxed.tag.16|)                                                             (* \; "FIXPs")                 (CONSTANTS XQP::|float.tag.8|)                                                             (* \; "16r_F8_")                 (CONSTANTS XQP::|float.tag.16|)                                                             (* \; "FLOATPs")                                     (* |;;| "Once upon a time all the functions in this file were OPENLAMBDAs. However, in order to prepare for the mixed Lisp/micro-code version, we have to be ready for the \"Prolog machine\" registers to be held in Lisp registers, which means that they can no longer be accessed as Lisp variables.  Hence the {get,put}.{16,24,32} macros.  In order to minimise the use of those macros and keep the source code as legible as possible, these functions, which were supposed to take register arguments anyway, still do, and implicitly quote them. E.g. (tag.of T0) implicitly quotes T0, in the mixed version T0 will turn into some register number.")                                     (* |;;| "Val is a 32-bit register holding a tagged cell. Return its tag field (byte 0 in big-endian notation)")                 (FUNCTIONS XQP::|tag.of|)                                     (* |;;| "Val is a 32-bit register holding a tagged cell. Return its arity field (byte 1 in big-endian notation)")                 (FUNCTIONS XQP::|arity.of|)                                     (* |;;|           "Ptr is a 24-bit pointer to a tagged cell. Return the arity field of that cell, i.e.")                 (FUNCTIONS XQP::|arity.of.cell|)                                     (* |;;| "Val is a 32-bit register holding a tagged cell. Return its datum field as a machine pointer. This macro is actually used for all untags.")                 (FUNCTIONS XQP::|untag.anything|)                                     (* |;;| "Val is a 32-bit tagged cell, either a functor or atom cell. Return the bottom 16 bits as a Lisp pointer to an atom.  As there is a non-zero tag, Val must be a 32-bit box.  In the micro-code, we need only fetch the bottom 16 bits, and can supply 0 for the top address byte.  Here we have to throw the top 8 bits away and then put 0 back.  Oh well.")                 (FUNCTIONS XQP::|atom.of|)                                     (* |;;| "Ptr is a 24-bit pointer to a tagged (functor or atom) cell. Return the bottom 16 bits of that cell as a Lisp atom pointer.")                 (FUNCTIONS XQP::|atom.of.cell|)                                     (* |;;| "For each kind of tag, there are functions (tag.foo X)	-- combine foo.tag and pointer X (untag.foo X)	-- strip tag foo off X")                 (FUNCTIONS XQP::|tag.ref|)                                     (* |;;| "The micro-code should be able to exploit the fact that the tag of a reference is 0.  When we do (put.24 X (untag.ref Y)) we can just move the contents of Y unmodified to X. Since the Lisp code can move 24-bit quantities around but not 32-bit ones, we do not exploit this opportunity.")                 (FUNCTIONS XQP::|untag.ref|)                                     (* |;;| "(is.unbound Ti Ri) is true when Ti holds (tag.ref Ri).  This macro assumes, and it is an assumption made elsewhere, that the extra 8 bits of a 24-bit register held in a pair of 16-bit registers are always zero. S is allowed just for INDEX.LSP; everything else uses R or C.")                 (FUNCTIONS XQP::|is.unbound|)                 (DEFINE-TYPES PROPERTIES)                 (FUNCTIONS XQP::|def.tag|)                 (PROPERTIES XQP::|tag.struct| XQP::|tag.list| XQP::|tag.symbol| XQP::|tag.boxed|                         XQP::|tag.float| XQP::|tag.stack|)                                     (* |;;| "(tag.stack B) and (untag.stack T0) are used in CUT.LSP. This tag name is used to emphasise the fact that the pointer which is being tagged or untagged is a pointer into Prolog's local stack, and also to give me the freedom to change it.")                 (FUNCTIONS XQP::|untag.stack|)                                     (* |;;| "The following function is used when (LET ((x y)) b) would be correct, but we'd like to optimise it a bit when y is a constant or a litatom.")                 (FUNCTIONS XQP::|let.macro|)                 (PROPERTIES XQP::|tag.immed| XQP::|tag.number| XQP::|tag.other|)                 (FUNCTIONS XQP::|untag.struct| XQP::|untag.list|)                 (PROPERTIES XQP::|tag.symbol.fast|)                                     (* |;;| "untag.symbol is used when Val is known to contain a symbol. BUT: it is ALSO used when Val is known to contain a functor cell.  So we must NOT use ReadPrologPtr directly, as that would include the arity of a functor cell in what is meant to be the address of an atom, quite wrong.  Hence this code. We could use (\\LOLOC (ReadPrologPtr ,Val)), but that would not be an improvement.")                 (FUNCTIONS XQP::|untag.symbol| XQP::|untag.immed| XQP::|untag.boxed|                         XQP::|untag.float|)                 (PROP MAKEFILE-ENVIRONMENT)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>TAGS.LSP;2, loaded 16-Jun-87 11:31:21")(* |;;| "SCCS   : @(#)TAGS.LSP	3.8 1/31/86 File   : $xerox/tags.lsp Author : Richard A. O'Keefe Purpose: define the tags, tagging, and untagging")(* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")(* |;;| "To start off with, we define the tag values. They come in two flavours.  The X.tag.8 numbers are used in SELECTCs where we do a 4- or 16-way dispatch on the tag coded in the top 8 bits of a tagged 32-bit cell.  The X.tag.16 numbers are used in forming those cells, so that we don't have to do any shifts at run time.  It is intended that all the dispatches will be done by micro-code 4-way dispatches (on X0,X4) and/or 16-way dispatches (on X0..X3 rotated to lie in X12..X15).  To make this as explicit as possible, there are no tests for any specific tag. ALL tag testing is done via select.4 or select.16 or an explict SELECTC (in unify and compare).")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|ref.tag.8| 0)(CONSTANTS XQP::|ref.tag.8|))(* \; "16r_00_")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|ref.tag.16| 0)(CONSTANTS XQP::|ref.tag.16|))(* \; "variables")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|struct.tag.8| 72)(CONSTANTS XQP::|struct.tag.8|))(* \; "16r_48_")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|struct.tag.16| 18432)(CONSTANTS XQP::|struct.tag.16|))(* \; "compounds (except lists)")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|list.tag.8| 128)(CONSTANTS XQP::|list.tag.8|))(* \; "16r_80_")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|list.tag.16| 32768)(CONSTANTS XQP::|list.tag.16|))(* \; "lists")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|symbol.tag.8| 200)(CONSTANTS XQP::|symbol.tag.8|))(* \; "16r_C8_")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|symbol.tag.16| 51200)(CONSTANTS XQP::|symbol.tag.16|))(* \; "LITATOMs")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|immed.tag.8| 217)(CONSTANTS XQP::|immed.tag.8|))(* \; "16r_D9_")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|immed.tag.16| 55552)(CONSTANTS XQP::|immed.tag.16|))(* \; "SMALLPs")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|other.tag.8| 218)(CONSTANTS XQP::|other.tag.8|))(* \; "16r_DA_")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|other.tag.16| 55808)(CONSTANTS XQP::|other.tag.16|))(* \; "other Lisp objects")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|boxed.tag.8| 233)(CONSTANTS XQP::|boxed.tag.8|))(* \; "16r_E9_")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|boxed.tag.16| 59648)(CONSTANTS XQP::|boxed.tag.16|))(* \; "FIXPs")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|float.tag.8| 248)(CONSTANTS XQP::|float.tag.8|))(* \; "16r_F8_")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|float.tag.16| 63488)(CONSTANTS XQP::|float.tag.16|))(* \; "FLOATPs")(* |;;| "Once upon a time all the functions in this file were OPENLAMBDAs. However, in order to prepare for the mixed Lisp/micro-code version, we have to be ready for the \"Prolog machine\" registers to be held in Lisp registers, which means that they can no longer be accessed as Lisp variables.  Hence the {get,put}.{16,24,32} macros.  In order to minimise the use of those macros and keep the source code as legible as possible, these functions, which were supposed to take register arguments anyway, still do, and implicitly quote them. E.g. (tag.of T0) implicitly quotes T0, in the mixed version T0 will turn into some register number.")(* |;;| "Val is a 32-bit register holding a tagged cell. Return its tag field (byte 0 in big-endian notation)")(XQP::|def.macro| XQP::|tag.of| (XQP::|Val|) (|if| (NOT (MEMB XQP::|Val| XQP::QP.32))                                                 |then| (SHOULDNT 'XQP::|tag.of|))                                             `(XQP::|ReadPrologTag| ,XQP::|Val|))(* |;;| "Val is a 32-bit register holding a tagged cell. Return its arity field (byte 1 in big-endian notation)")(XQP::|def.macro| XQP::|arity.of| (XQP::|Val|) (|if| (NOT (MEMB XQP::|Val| XQP::QP.32))                                                   |then| (SHOULDNT 'XQP::|arity.of|))                                               `(\\HILOC (XQP::|ReadPrologPtr| ,XQP::|Val|)))(* |;;| "Ptr is a 24-bit pointer to a tagged cell. Return the arity field of that cell, i.e.")(XQP::|def.open| XQP::|arity.of.cell| (XQP::|Ptr|) (\\GETBASEBYTE XQP::|Ptr| 1))(* |;;| "Val is a 32-bit register holding a tagged cell. Return its datum field as a machine pointer. This macro is actually used for all untags.")(XQP::|def.macro| XQP::|untag.anything| (XQP::|Val|) (|if| (NOT (MEMB XQP::|Val| XQP::QP.32))                                                         |then| (SHOULDNT 'XQP::|untag.anything|))                                                     `(XQP::|ReadPrologPtr| ,XQP::|Val|))(* |;;| "Val is a 32-bit tagged cell, either a functor or atom cell. Return the bottom 16 bits as a Lisp pointer to an atom.  As there is a non-zero tag, Val must be a 32-bit box.  In the micro-code, we need only fetch the bottom 16 bits, and can supply 0 for the top address byte.  Here we have to throw the top 8 bits away and then put 0 back.  Oh well.")(XQP::|def.macro| XQP::|atom.of| (XQP::|Val|) (|if| (NOT (MEMB XQP::|Val| XQP::QP.32))                                                  |then| (SHOULDNT 'XQP::|atom.of|))                                              `(\\VAG2 0 (XQP::\\GET.LO.16 ,XQP::|Val|)))(* |;;| "Ptr is a 24-bit pointer to a tagged (functor or atom) cell. Return the bottom 16 bits of that cell as a Lisp atom pointer.")(XQP::|def.open| XQP::|atom.of.cell| (XQP::|Ptr|) (\\VAG2 0 (\\GETBASE XQP::|Ptr| 1)))(* |;;| "For each kind of tag, there are functions (tag.foo X)	-- combine foo.tag and pointer X (untag.foo X)	-- strip tag foo off X")(XQP::|def.macro| XQP::|tag.ref| (XQP::|Ptr|) XQP::|Ptr|     (* \;                                                              "exploit the fact that the ref tag is 0"))(* |;;| "The micro-code should be able to exploit the fact that the tag of a reference is 0.  When we do (put.24 X (untag.ref Y)) we can just move the contents of Y unmodified to X. Since the Lisp code can move 24-bit quantities around but not 32-bit ones, we do not exploit this opportunity.")(XQP::|def.macro| XQP::|untag.ref| (XQP::|Val|) `(XQP::|untag.anything| ,XQP::|Val|))(* |;;| "(is.unbound Ti Ri) is true when Ti holds (tag.ref Ri).  This macro assumes, and it is an assumption made elsewhere, that the extra 8 bits of a 24-bit register held in a pair of 16-bit registers are always zero. S is allowed just for INDEX.LSP; everything else uses R or C.")(XQP::|def.macro| XQP::|is.unbound| (XQP::|Val| XQP::|Ptr|)   (|if| (NOT (AND (MEMB XQP::|Val| XQP::QP.32)                   (MEMB XQP::|Ptr| '(R C S))))       |then| (SHOULDNT 'XQP::|is.unbound|))   `(AND (EQ (XQP::|ReadPrologTag| ,XQP::|Val|)             0)                                              (* \; "reference tag")         (EQ (XQP::|ReadPrologPtr| ,XQP::|Val|)             (XQP::|ReadPrologPtr| ,XQP::|Ptr|)))            (* \; "same address")   )(DEF-DEFINE-TYPE PROPERTIES "XQP symbol properties" )(DEFDEFINER XQP::|def.tag| PROPERTIES (F XQP::|Tag|)                                 `(XQP::|def.props| (\\\, F) XQP::|Tag| (LAMBDA (XQP::|Ptr|)                                                                          ,XQP::|Tag|)                                                                   XQP::|Ptr|                                                                   (LAMBDA (XQP::|Ptr|)                                                                     `(XQP::|get.24| ,XQP::|Ptr|))))(XQP::|def.tag| XQP::|tag.struct| XQP::|struct.tag.8|)(XQP::|def.tag| XQP::|tag.list| XQP::|list.tag.8|)(XQP::|def.tag| XQP::|tag.symbol| XQP::|symbol.tag.8|)(XQP::|def.tag| XQP::|tag.boxed| XQP::|boxed.tag.8|)(XQP::|def.tag| XQP::|tag.float| XQP::|float.tag.8|)(XQP::|def.tag| XQP::|tag.stack| XQP::|other.tag.8|)(* |;;| "(tag.stack B) and (untag.stack T0) are used in CUT.LSP. This tag name is used to emphasise the fact that the pointer which is being tagged or untagged is a pointer into Prolog's local stack, and also to give me the freedom to change it.")(XQP::|def.macro| XQP::|untag.stack| (XQP::|Val|) `(XQP::|untag.anything| ,XQP::|Val|))(* |;;| "The following function is used when (LET ((x y)) b) would be correct, but we'd like to optimise it a bit when y is a constant or a litatom.")(XQP::|def.subr| XQP::|let.macro| (XQP::|Tag| XQP::|Val| FORM)   (|if| (LISTP XQP::|Val|)       |then|                                                (* \; "only lists are expressions")             `(LET ((,XQP::|Tag| ,XQP::|Val|))                   ,FORM)     |else|                                                  (* \; "variable or constant")           (SUBST XQP::|Val| XQP::|Tag| FORM)                (* \; "Tag -> Val")))(XQP::|def.props| XQP::|tag.immed| XQP::|Ptr| (LAMBDA (XQP::|Ptr|)                                                XQP::|Ptr|)                                         XQP::|Tag|                                         (LAMBDA (XQP::|Ptr|)                                           XQP::|immed.tag.8|))(XQP::|def.props| XQP::|tag.number| XQP::|Ptr| (LAMBDA (XQP::|Ptr|)                                                 XQP::|Ptr|)                                          XQP::|Tag|                                          (LAMBDA (XQP::|Ptr|)                                            (XQP::|let.macro| 'XQP::|Ptr| XQP::|Ptr|                                                   '(|if| (SMALLP XQP::|Ptr|)                                                        |then| XQP::|immed.tag.8|                                                      |elseif| (FIXP XQP::|Ptr|)                                                        |then| XQP::|boxed.tag.8|                                                      |elseif| (FLOATP XQP::|Ptr|)                                                        |then| XQP::|float.tag.8|                                                      |else| (SHOULDNT 'XQP::|tag.number|)))))(XQP::|def.props| XQP::|tag.other| XQP::|Ptr| (LAMBDA (XQP::|Ptr|)                                                XQP::|Ptr|)                                         XQP::|Tag|                                         (LAMBDA (XQP::|Ptr|)                                           (XQP::|let.macro| 'XQP::|Ptr| XQP::|Ptr|                                                  '(|if| (SMALLP XQP::|Ptr|)                                                       |then| XQP::|immed.tag.8|                                                     |elseif| (FIXP XQP::|Ptr|)                                                       |then| XQP::|boxed.tag.8|                                                     |elseif| (FLOATP XQP::|Ptr|)                                                       |then| XQP::|float.tag.8|                                                     |elseif| (LITATOM XQP::|Ptr|)                                                       |then| XQP::|symbol.tag.8|                                                     |else| XQP::|other.tag.8|))))(XQP::|def.macro| XQP::|untag.struct| (XQP::|Val|) `(XQP::|untag.anything| ,XQP::|Val|))(XQP::|def.macro| XQP::|untag.list| (XQP::|Val|) `(XQP::|untag.anything| ,XQP::|Val|))(XQP::|def.props| XQP::|tag.symbol.fast| HI (LAMBDA (I)                                              XQP::|symbol.tag.16|)                                            LO                                            (LAMBDA (I)                                              `(XQP::|get.16| ,I))                                            XQP::|Tag|                                            (LAMBDA (I)                                              XQP::|symbol.tag.8|)                                            XQP::|Ptr|                                            (LAMBDA (I)                                              `(\\VAG2 0 (XQP::|get.16| ,I))))(* |;;| "untag.symbol is used when Val is known to contain a symbol. BUT: it is ALSO used when Val is known to contain a functor cell.  So we must NOT use ReadPrologPtr directly, as that would include the arity of a functor cell in what is meant to be the address of an atom, quite wrong.  Hence this code. We could use (\\LOLOC (ReadPrologPtr ,Val)), but that would not be an improvement.")(XQP::|def.macro| XQP::|untag.symbol| (XQP::|Val|) (|if| (NOT (MEMB XQP::|Val| 32))                                                       |then| (SHOULDNT 'XQP::|untag.symbol|))                                                   `(\\VAG2 0 (XQP::\\GET.LO.16 ,XQP::|Val|)))(XQP::|def.macro| XQP::|untag.immed| (XQP::|Val|) `(XQP::|untag.anything| ,XQP::|Val|))(XQP::|def.macro| XQP::|untag.boxed| (XQP::|Val|) `(XQP::|untag.anything| ,XQP::|Val|))(XQP::|def.macro| XQP::|untag.float| (XQP::|Val|) `(XQP::|untag.anything| ,XQP::|Val|))(PUTPROPS TAGS COPYRIGHT ("Quintus Computer Systems, Inc" 1987))(DECLARE\: DONTCOPY  (FILEMAP (NIL)))STOP