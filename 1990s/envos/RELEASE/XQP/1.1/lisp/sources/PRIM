(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "INTERLISP")(filecreated "20-Oct-87 11:13:44" {dsk}<lispfiles>dcoms>prim.\;7 11680        |changes| |to:|  (vars primcoms)                       (functions xqp::init.byte.buffer)      |previous| |date:| "19-Oct-87 14:00:23" {dsk}<lispfiles>dcoms>prim.\;6); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(prettycomprint primcoms)(rpaqq primcoms        ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>PRIM.LSP;1, loaded 15-Jun-87 17:18:02")                    (* |;;| "@(#)PRIM.LSP	3.13                             2/22/86 PRIM.LSP BAK		 ; --------------------------------------------------------; ; WARNING: This material is CONFIDENTIAL and proprietary ; to Quintus Computer Systems Inc.		 ; ; ; Copyright (C) 1985,  Quintus Computer Systems, Inc.   ; All rights reserved.					 ; ; --------------------------------------------------------; ;")                    (* |;;| "Copyright (c) 1985 by Quintus Computer Systems, Inc. All rights reserved.")        (variables xqp::byte.buffer xqp::byte.buffer.base xqp::byte.buffer.has.fatchars                xqp::byte.buffer.length xqp::byte.buffer.offset xqp::xqp-package)                    (* |;;|           "In the ALLOCSTRING below, I supply 256 as the initial char to force the string to be fat.")        (functions xqp::chars.from.byte.buffer xqp::clear.byte.buffer xqp::put.byte                xqp::init.byte.buffer xqp::intern.symbol xqp::float.from.byte.buffer                xqp::float.to.byte.buffer xqp::float.to.string xqp::symbol.to.byte.buffer                xqp::symbol.length xqp::symbol.char xqp::symbol.compare xqp::atom.number                xqp::instr.fields xqp::left.op.code xqp::clause.alloc xqp::load.gc.protect                xqp::raw.free.space xqp::p.token.type)        (p (xqp::init.byte.buffer))        (prop makefile-environment)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>PRIM.LSP;1, loaded 15-Jun-87 17:18:02")(* |;;| "@(#)PRIM.LSP	3.13                             2/22/86 PRIM.LSP BAK		 ; --------------------------------------------------------; ; WARNING: This material is CONFIDENTIAL and proprietary ; to Quintus Computer Systems Inc.		 ; ; ; Copyright (C) 1985,  Quintus Computer Systems, Inc.   ; All rights reserved.					 ; ; --------------------------------------------------------; ;")(* |;;| "Copyright (c) 1985 by Quintus Computer Systems, Inc. All rights reserved.")(defglobalvar xqp::byte.buffer )(defglobalvar xqp::byte.buffer.base )(defglobalvar xqp::byte.buffer.has.fatchars )(xqp::|def.var| xqp::byte.buffer.length 0)(defglobalvar xqp::byte.buffer.offset )(defglobalparameter xqp::xqp-package (cl:find-package "XQP") "var holding the XQP package" )(* |;;| "In the ALLOCSTRING below, I supply 256 as the initial char to force the string to be fat.")(xqp::defunc xqp::chars.from.byte.buffer nil                     (* |;;| "Return all the characters in the byte buffer as a list of character codes.")                                             (for i from 1 to xqp::byte.buffer.length                                                collect (nthcharcode xqp::byte.buffer i)))(xqp::defunc xqp::clear.byte.buffer nil (setq xqp::byte.buffer.length 0))(xqp::defunc xqp::put.byte (char) (setq xqp::byte.buffer.length (iplus xqp::byte.buffer.length 1))                                  (rplcharcode xqp::byte.buffer xqp::byte.buffer.length char)                                  t)(cl:defun xqp::init.byte.buffer nil (* |;;;| "Initialize the input atom name buffer BYTE.BUFFER, as well as BYTE.BUFFER.BASE and BYTE.BUFFER.OFFSET.  The CL compiler screws up if these initializations are done directly in the file.")                                    (setq xqp::byte.buffer (allocstring 4096 256 nil t))                                    (setq xqp::byte.buffer.base (|ffetch| (stringp base) |of|                                                                                      xqp::byte.buffer                                                                       ))                                    (setq xqp::byte.buffer.offset (|ffetch| (stringp offst)                                                                     |of| xqp::byte.buffer)))(xqp::defunc xqp::intern.symbol nil (intern* xqp::byte.buffer.base xqp::byte.buffer.offset                                            xqp::byte.buffer.length t xqp::byte.buffer.has.fatchars                                            xqp::xqp-package nil))(xqp::defunc xqp::float.from.byte.buffer nil                     (* |;;| "why not call (FLOAT (SUBATOM BYTE.BUFFER 1 BYTE.BUFFER.LENGTH)) ?")                                             (let* ((str (openstringstream (substring                                                                                   xqp::byte.buffer 1                                                                               xqp::byte.buffer.length                                                                                  )                                                                'input))                                                    (obj (read str)))                                                   (cond                                                      ((floatp obj)                                                       obj)                                                      (t (pack)))))(xqp::defunc xqp::float.to.byte.buffer (float) (cond                                                  ((floatp float)                                                   (setq xqp::byte.buffer.length                                                    (idifference (xqp::float.to.string float                                                                         xqp::byte.buffer)                                                           1)))                                                  (t (setq xqp::byte.buffer.length 0))))(xqp::defunc xqp::float.to.string (float string)                     (* |;;| "Get <lisp float> <CR> into qp scratch string") (let ((xqp::oldformat (fltfmt))       (stream (openstringstream xqp::scratch.string 'output)))      (fltfmt t)      (print float stream)                                   (* \;                                                         "Leaves a newline for STRPOS after the float")      (closef stream)      (fltfmt xqp::oldformat)) (let* ((pos (strpos '\ xqp::scratch.string 1))        (scratch (substring xqp::scratch.string 1 pos)))                    (* |;;| "scratch is the text of the float alone, less the <CR>")       (if (eq (nthcharcode scratch 1)               46)           then                                              (* \; "46 = `.`")                (rplcharcode string 1 48)                    (* \; "48 = `0`")                (rplstring string 2 scratch)                (add1 pos)         else (rplstring string 1 scratch)              pos)))(xqp::defunc xqp::symbol.to.byte.buffer (symbol) (rplstring xqp::byte.buffer (add1                                                                               xqp::byte.buffer.length                                                                                   )                                                        symbol)                                                 (setq xqp::byte.buffer.length (iplus                                                                               xqp::byte.buffer.length                                                                                      (nchars symbol)                                                                                      )))(xqp::defunc xqp::symbol.length (symbol) (nchars symbol))(xqp::defunc xqp::symbol.char (index symbol) (nthcharcode symbol index))(xqp::defunc xqp::symbol.compare (xqp::symbol1 xqp::symbol2) (cond                                                                ((eq xqp::symbol1 xqp::symbol2)                                                                 0)                                                                ((alphorder xqp::symbol1 xqp::symbol2                                                                        )                                                                 -1)                                                                (t 1)))(xqp::defunc xqp::atom.number (atom) (\\loloc atom))(xqp::defunc xqp::instr.fields (xqp::instruction) (cdr (gethash (gethash xqp::instruction                                                                        xqp::instruction.harray)                                                              xqp::instruction.harray)))(xqp::defunc xqp::left.op.code (xqp::instruction) (setq xqp::instruction (xqp::op.code                                                                                 xqp::instruction))                                                  (cond                                                     ((geq xqp::instruction 256)                                                      xqp::instruction)                                                     (t (llsh xqp::instruction 8))))(xqp::defunc xqp::clause.alloc (length)                      (* \; "Clauses are augmented word arrays.  An array consists of two words, the first of which points to the block in memory storing the array. We use the first two words of this array to store a back pointer to the array header.  A pointer to the third word of the block (first useful location) is returned.  The reference count of the array is set to 1.") (let* ((array (array length 'word))        (block (\\getbaseptr array 0)))                      (* \; "(ADDREF BLOCK)")       (xqp::load.gc.protect array)       block))(xqp::defunc xqp::load.gc.protect (cell)                     (* \; "THIS FUNCTION MUST BE COMPILED") (\\addref cell))(xqp::defunc xqp::raw.free.space (ignore cell)                     (* |;;|        "This is a hairy sort of thing, and maybe we can fix it later. THIS FUNCTION MUST BE COMPILED") (\\delref cell))(xqp::defunc xqp::p.token.type (atom) (if (numberp atom)                                          then 1                                        else                 (* \; "always a digit at end, -> 1")                                             (let ((char (nthcharcode atom -1)))                                                  (if (null char)                                                      then 1                                                    else (selectq (chartype char)                                                             ((xqp::|small_letter|                                                                      xqp::|capital_letter|                                                                      xqp::|digit| xqp::|underbar|)                                                                   1)                                                             (xqp::|agglutinating|                                                                   2)                                                             3)))))(xqp::init.byte.buffer)(putprops prim copyright ("Quintus Computer Systems, Inc" 1987))(declare\: dontcopy  (filemap (nil)))stop