(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(filecreated "20-Oct-87 17:58:00" {dsk}<lispfiles>dcoms>load.\;2 45235        |changes| |to:|  (functions xqp::initialize.prolog)      |previous| |date:| "15-Jul-87 19:41:19" {dsk}<lispfiles>dcoms>load.\;1); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(prettycomprint loadcoms)(rpaqq loadcoms        ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>LOAD.LSP;1, loaded 15-Jun-87 17:14:50")                    (* |;;| "@ (#) LOAD.LSP 8204.1 3/25/87 LOAD.LSP BAK		 ; --------------------------------------------------------; ; WARNING: This material is CONFIDENTIAL and proprietary ; to Quintus Computer Systems Inc.		 ; ; ; Copyright (C) 1985,  Quintus Computer Systems, Inc.   ; All rights reserved.					 ; ; --------------------------------------------------------; ;")                    (* |;;| "Copyright (c) 1985 by Quintus Computer Systems, Inc. All rights reserved.")        (variables xqp::failure.clause xqp::undefined.clause xqp::interpret.clause xqp::debug.clause                xqp::dummy.clause xqp::clause.offset)        (variables xqp::scratch.string)                    (* |;;| "The following two macros are now used only in this file.")        (functions xqp::\\leftbyte xqp::\\rightbyte)                    (* |;;| "---------------------------------------------------------------------- Called to initialize the Prolog world ----------------------------------------------------------------------")        (functions xqp::trap.clause xqp::unit.clause xqp::initialize.prolog)                    (* |;;| "----------------------------------------------------------------------")        (functions xqp::assemble.clause)                    (* |;;| "---------------------------------------------------------------------- RECONSULT can be used for loading .DNG files, but ensures that old definitions are abolished first. ----------------------------------------------------------------------")        (functions xqp::reconsult)                    (* |;;| "---------------------------------------------------------------------- In-core compiler support  Essentially the same code is used to implement the in-core compiler as the out-of-line compiler on the D-machine.  The next few functions implement the interface to the Prolog code for the in-core compiler. ----------------------------------------------------------------------")        (variables xqp::last.clause.record)        (functions xqp::allocate.clause.record xqp::store.incore xqp::attach.clause.record)                    (* |;;| "---------------------------------------------------------------------- Storing instructions in the clause record ----------------------------------------------------------------------")        (functions xqp::add.clause xqp::obj.tag)        (macros xqp::register.or.memory.1)        (functions xqp::areg.register xqp::store.index xqp::store.instr)                    (* |;;| "(DEFUNC STORE.INSTR.GET.PVAR (CLAUSEPTR PVAR)		;DEAD; (LET ((PVAR.ADDRESS 					;DEAD; (IPLUS (LSH (\\HILOC membot) 16)			;DEAD; (\\LOLOC membot)				;DEAD; (GETPROP PVAR 'pvarno))))		;DEAD; (STORE.INSTR.EXTEND.CELL				;DEAD; CLAUSEPTR 'load.constant PVAR.ADDRESS)))		;DEAD;")        (functions xqp::store.instr.byte xqp::store.instr.areg xqp::store.instr.extend                xqp::store.instr.extend.word xqp::store.instr.extend.cell xqp::store.instr.byte.byte                xqp::store.instr.byte.cell xqp::store.instr.byte.atom xqp::store.instr.byte.functor                xqp::store.instr.size.procedure xqp::store.instr.size.offset xqp::store.instr.offset                xqp::store.instr.procedure xqp::store.instr.cell xqp::store.instr.atom                xqp::store.instr.functor xqp::store.instr.null)        (prop makefile-environment)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>LOAD.LSP;1, loaded 15-Jun-87 17:14:50")(* |;;| "@ (#) LOAD.LSP 8204.1 3/25/87 LOAD.LSP BAK		 ; --------------------------------------------------------; ; WARNING: This material is CONFIDENTIAL and proprietary ; to Quintus Computer Systems Inc.		 ; ; ; Copyright (C) 1985,  Quintus Computer Systems, Inc.   ; All rights reserved.					 ; ; --------------------------------------------------------; ;")(* |;;| "Copyright (c) 1985 by Quintus Computer Systems, Inc. All rights reserved.")(xqp::|def.global| xqp::failure.clause )(xqp::|def.global| xqp::undefined.clause )(xqp::|def.global| xqp::interpret.clause )(xqp::|def.global| xqp::debug.clause )(xqp::|def.global| xqp::dummy.clause )(xqp::|def.global| xqp::clause.offset )(xqp::|def.global| xqp::scratch.string )(* |;;| "The following two macros are now used only in this file.")(xqp::|def.macro| xqp::\\leftbyte (base offset) `(\\getbasebyte ,base (xqp::|Twice| ,offset 0)))(xqp::|def.macro| xqp::\\rightbyte (base offset) `(\\getbasebyte ,base (xqp::|Twice| ,offset 1)))(* |;;| "---------------------------------------------------------------------- Called to initialize the Prolog world ----------------------------------------------------------------------")(xqp::|def.nlambda| xqp::trap.clause (clause name xqp::arity xqp::module)                     (* |;;| "This function creates a clause ((trap module:name/arity)) without any linkage instructions, and assigns it to the global variable whose name is passed as CLAUSE.  The way this is coded is twisted to ensure that UNDEFINED.CLAUSE is created before it is used; the other traps don't need it.") (setq clause (settopval clause (\\makenumber 2 0))) (\\putbaseptr clause 0 (xqp::local.predicate name xqp::arity xqp::module)) (\\putbasebyte clause 0 (xqp::op.code 'xqp::|trap|)))(xqp::|def.nlambda| xqp::unit.clause (opcode name xqp::arity xqp::module)                     (* |;;| "This function creates a clause containing a single special instruction without any linkage instructions, and assigns it to the given predicate.  The result is the clause.") (setq name (xqp::local.predicate name xqp::arity xqp::module)) (setq opcode (\\makenumber (xqp::left.op.coe opcode)                     0)) (\\addref opcode) (cl:setf (xqp::proc.clauses name)        opcode) (cl:setf (xqp::proc.lastclause name)        xqp::failure.clause) (cl:setf (xqp::proc.loflag name)        1)                                                   (* \; "\"compiled\"") opcode)(xqp::defunc xqp::initialize.prolog nil (xqp::init.procedures)                                                             (* \; "initialise PROCS.LSP")                                        (setq xqp::byte.buffer.length 0)                                        (xqp::init.io)                                        (setq xqp::scratch.string (allocstring 256))                    (* |;;| "Here is the dummy clause used by the assert/clause/retract code.")                                        (prog ((x (\\allocblock 5)))                                                             (* \; "the clause")                                              (\\putbase x 0 (xqp::op.code 'xqp::|ignore.me|))                                              (\\putbase x 1 (xqp::op.code 'xqp::|fail.on.retry|))                                              (\\putbaseptr x 2 nil)                                                             (* \; "next clause")                                              (\\putbaseptr x 4 nil)                                                             (* \; "prev clause")                                              (\\putbaseptr x 6 0)                                                             (* \; "dead clause count")                                              (\\putbaseptr x 8 0)                                                             (* \; "dead clause chain")                                              (setq xqp::dummy.clause x))                    (* |;;| "Here are the special trap clauses.")                                        (xqp::trap.clause xqp::undefined.clause                                                xqp::|$interpreter_hook|                                               2 xqp::|interp|)                                        (xqp::trap.clause xqp::interpret.clause                                                xqp::|$interpreter_hook|                                               2 xqp::|interp|)                                        (xqp::trap.clause xqp::debug.clause xqp::|$debug_trap|                                               2 xqp::|interp|)                    (* |;;| "Here are clauses for some built in predicates. user:portray/1 will eventually be handled by other means.")                                        (xqp::unit.clause |apply| |apply| 3 xqp::|si|)                                        (xqp::unit.clause xqp::|store.skeleton| xqp::|store_skeleton|                                               1 xqp::|si|)                                        (setq xqp::failure.clause (xqp::unit.clause xqp::|fail|                                                                          xqp::|fail| 0 xqp::|si|))                                        (xqp::assemble.clause (xqp::|portray| 1 |user|)                                               1                                               (xqp::|fail|))                                        t)(* |;;| "----------------------------------------------------------------------")(xqp::defunc xqp::assemble.clause fexpr xqp::theargs         (* \; "Called with a procedure, clause size, and list of instructions. A series of these function calls is produced by the out-of-line compiler.")                                        (let* ((xqp::proclist (car xqp::theargs))                                               (proc (xqp::local.predicate (car xqp::proclist)                                                            (cadr xqp::proclist)                                                             (caddr xqp::proclist)))                                               (length (cadr xqp::theargs))                                               (instrs (cddr xqp::theargs))                                               (xqp::clauseptr (xqp::clause.alloc (iplus 3 length))))                                                             (* \; "We add 3 onto the length for the following purposes: 2 words for representing the trivial index instrs. 1 word for a 0 final word (not strictly necessary)	   ")                                              (setq xqp::clause.offset 2)                                              (prog ((instrs instrs))                                                lp  (cond                                                       ((null instrs)                                                        (return nil))                                                       (t (let ((instr (car instrs)))                                                               (setq instrs (cdr instrs))                                                               (xqp::store.instr xqp::clauseptr                                                                      (car instr)                                                                      (cadr instr)                                                                      (caddr instr)                                                                      (cadddr instr)                                                                      (car (cddddr instr))))                                                          (go lp))))                                              (|if| xqp::indexp                                                  |then| (xqp::add.clause xqp::clauseptr proc)                                                |else| (xqp::assert.indexed proc xqp::clauseptr nil))                                              (xqp::set.predicate.state proc 1)                                                             (* \; "compiled")                                              ))(* |;;| "---------------------------------------------------------------------- RECONSULT can be used for loading .DNG files, but ensures that old definitions are abolished first. ----------------------------------------------------------------------")(xqp::defunc xqp::reconsult (file) (let ((form nil)                                         (table (hasharray 500 1.5))                                         (stream (openstream file 'input))                                         (*package* (cl:find-package "XQP")))                                        (|until| (eq (setq form (read stream (find-readtable                                                                              'interlisp)))                                                     'stop)                                           |do| (progn (cond                                                          ((eq (car form)                                                               'xqp::assemble.clause)                                                           (let* ((proc (cadr form))                                                                  (name (car proc))                                                                  (xqp::arity (cadr proc))                                                                  (xqp::module (caddr proc))                                                                  (xqp::procrec (xqp::local.predicate                                                                                 name xqp::arity                                                                                  xqp::module)))                                                                 (cond                                                                    ((not (gethash xqp::procrec table                                                                                 ))                                                                     (puthash xqp::procrec t table)                                                                     (xqp::abolish name xqp::arity                                                                             xqp::module)))                                                                 (eval form)))                                                          (t (eval form)))))                                        (print (closef stream))))(* |;;| "---------------------------------------------------------------------- In-core compiler support  Essentially the same code is used to implement the in-core compiler as the out-of-line compiler on the D-machine.  The next few functions implement the interface to the Prolog code for the in-core compiler. ----------------------------------------------------------------------")(xqp::|def.var| xqp::last.clause.record nil)(xqp::defunc xqp::allocate.clause.record (size)              (* \; "This function is called from Prolog and creates a clause record of the given size.  In the future a pointer to this clause record will be returned to Prolog.  At the current time, it sets the global variable LAST.CLAUSE.RECORD to it.") (setq xqp::clause.offset 2) (setq xqp::last.clause.record (xqp::clause.alloc (iplus size 3))))(xqp::defunc xqp::store.incore (instr arg1 arg2 arg3 arg4)   (* \;               "This function is called from Prolog with a symbolic instruction and up to 4 arguments") (xqp::store.instr xqp::last.clause.record instr arg1 arg2 arg3 arg4))(xqp::defunc xqp::attach.clause.record (proc) (|if| xqp::indexp                                                  |then| (xqp::add.clause xqp::last.clause.record                                                                 proc)                                                |else| (xqp::assert.indexed proc                                                               xqp::last.clause.record)))(* |;;| "---------------------------------------------------------------------- Storing instructions in the clause record ----------------------------------------------------------------------")(xqp::defunc xqp::add.clause (clause xqp::procrecord) (cond                                                         ((eq (xqp::get.predicate.state                                                                      xqp::procrecord)                                                              0)                                                             (* \; "predicate is undefined.")                                                          (cl:setf (xqp::proc.clauses xqp::procrecord                                                                          )                                                                 clause)                                                          (cl:setf (xqp::proc.loflag xqp::procrecord)                                                                 1)                                                             (* \; "compiled")                                                          (xqp::store.index clause '                                                                 xqp::|just.me.else|))                                                         ((eq (\\getbasebyte (xqp::proc.lastclause                                                                              xqp::procrecord)                                                                     0)                                                              (xqp::op.code 'xqp::|just.me.else|))                                                          (xqp::store.index (xqp::proc.lastclause                                                                             xqp::procrecord)                                                                 'xqp::|try.me.else| clause)                                                          (xqp::store.index clause '                                                                 xqp::|trust.me.else|))                                                         ((eq (\\getbasebyte (xqp::proc.lastclause                                                                              xqp::procrecord)                                                                     0)                                                              (xqp::op.code 'xqp::|trust.me.else|))                                                          (xqp::store.index (xqp::proc.lastclause                                                                             xqp::procrecord)                                                                 'xqp::|retry.me.else| clause)                                                          (xqp::store.index clause '                                                                 xqp::|trust.me.else|)))                                                      (cl:setf (xqp::proc.lastclause xqp::procrecord)                                                             clause))(xqp::|def.subr| xqp::obj.tag (obj)                     (* |;;| "Given a Lisp object pointer OBJ, this function works out what tag should be prefixed to it to make a Prolog tagged cell. Note that while lists can be passed between Prolog and Lisp, they can never appear *here*.") (selectq (typename obj)     (litatom xqp::|symbol.tag.16|)     (smallp xqp::|immed.tag.16|)     (fixp xqp::|boxed.tag.16|)     (floatp xqp::|float.tag.16|)     (bignum xqp::|boxed.tag.16|)     (shouldnt 'xqp::obj.tag)))(declare\: eval@compile (putprops xqp::register.or.memory.1 macro (xqp::**macroarg**                                           (let ((xqp::areg (car (nth xqp::**macroarg** 1)))                                                 (opcode (car (nth xqp::**macroarg** 2))))                                                `(cond ((greaterp ,xqp::areg 4)                                                             (* \; "If the aregister index is greater than 4, we use a memory version of the instruction.  This means the index stays the same and we increase the opcode by 2 and mask off the low bit. WARNING:  This is a hack.  Since the addition of singlemode instructions, it is no longer the case that it is sufficient to  add 2 to an Ai/Xn opcode to get the corresponding AiM/XnM opcode, since in the case of singlemode instructions, the difference between adjacent opcodes is 1.  Therefore, as a quick hack, this code assumes that all Ai/Xn singlemode instructions are on ODD opcodes.  This code adds 1 to odd opcodes and 2 to even ones.  If it proves desirable to have AiM/XnM singlemode instructions on the opcode BEFORE the corresponding Ai/Xn instruction, here is code that will work: (SETQ ,OPCODE (IPLUS 512 ,OPCODE (ITIMES -3 (LOGAND ,OPCODE 256)))) I decided to use the other scheme because I thought it was more important to keep the rule that AiM/XnM instructions immediately FOLLOW the corresponding Ai/Xn instruction than to pack the singlemode instructions a little better.")                                                        (setq ,opcode (logand (iplus 512 ,opcode)                                                              ))                                                                             (CONSTANT (LOGNOT 256)))                                                       (T    (* \; "Otherwise the slow register version of the index is substituted for it and the opcode is left the same.")                                                          (setq ,xqp::areg (xqp::areg.register                                                                            ,XQP::AREG))))))))(XQP::DEFUNC XQP::AREG.REGISTER (XQP::AREG) (ITIMES 2 (IDIFFERENCE XQP::AREG 1)))(xqp::defunc xqp::store.index (clause instr xqp::nextclause) (\\putbaseptr clause 0 (or                                                                                       xqp::nextclause                                                                                         ))                                                                                  XQP::FAILURE.CLAUSE                                                             (\\putbase clause 0                                                                    (iplus (\\getbase clause 0)                                                                           (XQP::LEFT.OP.CODE INSTR))                                                                    ))(XQP::DEFUNC XQP::STORE.INSTR ARGLIST                        (* \; "Called with the first argument being the CLAUSE record, the second argument being the instruction symbolic name, and the remaining arguments being the arguments to that particular instruction.")                                    (let* ((clause (arg arglist 1))                                           (instr (arg arglist 2))                                           (opcode (gethash instr xqp::instruction.harray))                                           (fields (cadr (gethash opcode xqp::instruction.harray))))                                          (cond                                             ((EQUAL INSTR 'XQP::|load.pvar.address|)                    (* |;;| "(STORE.INSTR.GET.PVAR CLAUSE (ARG ARGLIST 3))	;DEAD;")                                              (shouldnt 'xqp::|load.pvar.address|))                                             ((equal opcode xqp::extension.opcode)                                              (let ((type (caddr (gethash (gethash instr                                                                                  )                                                                                XQP::EXTENSION.HARRAY                                                                        xqp::extension.harray))))                                                   (cond                                                      ((eq type '|word|)                                                       (xqp::store.instr.extend.word clause instr                                                              (arg arglist 3)))                                                      ((eq type '|cell|)                                                       (xqp::store.instr.extend.cell clause instr                                                              (arg arglist 3)))                                                      (t (xqp::store.instr.extend clause instr)))))                                             (t (selectq fields                                                    (nil (xqp::store.instr.null clause instr))                                                    (|a1.cell| (xqp::store.instr.byte.cell                                                                clause instr (arg arglist 3)                                                                (arg arglist 4)))                                                    (|a1.atom| (xqp::store.instr.byte.atom                                                                clause instr (arg arglist 3)                                                                (arg arglist 4)))                                                    (|a1.functor| (xqp::store.instr.byte.functor                                                                   clause instr (arg arglist 3)                                                                   (arg arglist 4)                                                                   (arg arglist 5)))                                                    (|a1.y2| (xqp::store.instr.byte.byte clause instr                                                                    (arg arglist 3)                                                                    (arg arglist 4)                                                                    '\y2))                                                                    'XQP::\a1                                                    (|a2.y1| (xqp::store.instr.byte.byte clause instr                                                                    (arg arglist 3)                                                                    (arg arglist 4)                                                                    '\y1))                                                                    'XQP::\a2                                                    (|a2.a1| (xqp::store.instr.byte.byte clause instr                                                                    (arg arglist 3)                                                                    (arg arglist 4)                                                                    'xqp::\a2                                                                    'xqp::\a1))                                                    (|a1.a2| (xqp::store.instr.byte.byte clause instr                                                                    (arg arglist 3)                                                                    (arg arglist 4)                                                                    'xqp::\a1                                                                    'xqp::\a2))                                                    (xqp::\a1 (xqp::store.instr.areg clause instr                                                                     (arg arglist 3)))                                                    (\y1 (xqp::store.instr.byte clause instr                                                                '\y1))                                                                (ARG ARGLIST 3)                                                    (|byte| (xqp::store.instr.byte clause instr                                                                   '|byte|))                                                                   (ARG ARGLIST 3)                                                    (|cell| (xqp::store.instr.cell clause instr                                                                   (arg arglist 3)))                                                    (xqp::|functor|                                                          (xqp::store.instr.functor clause instr                                                                (arg arglist 3)                                                                (arg arglist 4)))                                                    (|atom| (xqp::store.instr.atom clause instr                                                    (|size.procedure|                                                                    (ARG ARGLIST 3)))                                                         (xqp::store.instr.size.procedure                                                          clause instr (arg arglist 3)                                                          (arg arglist 4)                                                          (arg arglist 5)                                                          (arg arglist 6)))                                                    (|size.offset| (xqp::store.instr.size.offset                                                                    clause instr (arg arglist 3)                                                                    (arg arglist 4)))                                                    (|offset| (xqp::store.instr.offset clause instr                                                                     (arg arglist 3)))                                                    (xqp::|procedure|                                                          (xqp::store.instr.procedure clause instr                                                                (arg arglist 3)                                                                (arg arglist 4)                                                                (arg arglist 5)))                                                    (progn (print (list opcode instr fields))                                                           (SHOULDNT)))))))(* |;;| "(DEFUNC STORE.INSTR.GET.PVAR (CLAUSEPTR PVAR)		;DEAD; (LET ((PVAR.ADDRESS 					;DEAD; (IPLUS (LSH (\\HILOC membot) 16)			;DEAD; (\\LOLOC membot)				;DEAD; (GETPROP PVAR 'pvarno))))		;DEAD; (STORE.INSTR.EXTEND.CELL				;DEAD; CLAUSEPTR 'load.constant PVAR.ADDRESS)))		;DEAD;")(xqp::defunc xqp::store.instr.byte (xqp::clauseptr instr byte type)   (\\putbase xqp::clauseptr xqp::clause.offset (iplus (selectq type                                                           ((xqp::\a1 |byte|)                                                                 byte)                                                           (\y1 (iplus byte xqp::permanent.offset))                                                           (shouldnt))                                                       (xqp::left.op.code instr)))   (CL:INCF XQP::CLAUSE.OFFSET 1))(xqp::defunc xqp::store.instr.areg (xqp::clauseptr instr byte) (let ((opcode (xqp::left.op.code                                                                              instr)))                                                                    (xqp::register.or.memory.1 byte                                                                            opcode)                                                                    (\\putbase xqp::clauseptr                                                                            xqp::clause.offset                                                                           (iplus byte opcode))                                                                    (CL:INCF XQP::CLAUSE.OFFSET 1)))(xqp::defunc xqp::store.instr.extend (xqp::clauseptr instr) (let ((xqp::secondary (gethash instr                                                                                          )))                                                                                XQP::EXTENSION.HARRAY                                                                 (\\putbase xqp::clauseptr                                                                         xqp::clause.offset                                                                        (iplus (llsh                                                                                      8)                                                                                XQP::EXTENSION.OPCODE                                                                                xqp::secondary))                                                                 (CL:INCF XQP::CLAUSE.OFFSET 1)))(xqp::defunc xqp::store.instr.extend.word (xqp::clauseptr instr word)   (let ((xqp::secondary (gethash instr xqp::extension.harray)))        (\\putbase xqp::clauseptr xqp::clause.offset (iplus (llsh xqp::extension.opcode 8)                                                            xqp::secondary))        (\\putbase xqp::clauseptr (add1 xqp::clause.offset)               (\\loloc word))        (CL:INCF XQP::CLAUSE.OFFSET 2)))(xqp::defunc xqp::store.instr.extend.cell (xqp::clauseptr instr cell)   (let ((xqp::secondary (gethash instr xqp::extension.harray)))        (\\putbase xqp::clauseptr xqp::clause.offset (iplus (llsh xqp::extension.opcode 8)                                                            xqp::secondary))        (xqp::load.gc.protect cell)        (\\putbase xqp::clauseptr (add1 xqp::clause.offset)               (iplus (xqp::obj.tag cell)                      (\\hiloc cell)))        (\\putbase xqp::clauseptr (iplus xqp::clause.offset 2)               (\\loloc cell))        (CL:INCF XQP::CLAUSE.OFFSET 3)))(xqp::defunc xqp::store.instr.byte.byte (xqp::clauseptr instr xqp::byte1 xqp::byte2 xqp::field1                                                xqp::field2)   (let ((opcode (xqp::left.op.code instr))         (xqp::has.y.reg (or (member xqp::field1 '(\y1 \y2))                             (member xqp::field2 '(\y1 \y2)))))        (cond           ((eq xqp::field1 'xqp::\a1)            (cond               ((greaterp xqp::byte1 4)                (cl:incf opcode 512))               (t (setq xqp::byte1 (xqp::areg.register xqp::byte1)))))           ((eq xqp::field2 'xqp::\a1)            (cond               ((greaterp xqp::byte2 4)                (cl:incf opcode 512))               (t (setq xqp::byte2 (xqp::areg.register xqp::byte2))))))        (cond           ((eq xqp::field1 'xqp::\a2)            (cond               ((member xqp::field2 '(\y1 \y2))                (cond                   ((greaterp xqp::byte1 4)                    (cl:incf opcode 512))                   (t (setq xqp::byte1 (xqp::areg.register xqp::byte1)))))               (t (cond                     ((greaterp xqp::byte1 4)                      (cl:incf opcode 1024))                     (t (setq xqp::byte1 (xqp::areg.register xqp::byte1)))))))           ((eq xqp::field2 'xqp::\a2)            (cond               ((member xqp::field2 '(\y1 \y2))                (cond                   ((greaterp xqp::byte2 4)                    (cl:incf opcode 512))                   (t (setq xqp::byte2 (xqp::areg.register xqp::byte2)))))               (t (cond                     ((greaterp xqp::byte2 4)                      (cl:incf opcode 1024))                     (t (setq xqp::byte2 (xqp::areg.register xqp::byte2))))))))        (let (xqp::dest1 xqp::dest2)             (cond                ((member xqp::field2 '(\y1 \y2))                 (setq xqp::byte2 (iplus xqp::byte2 xqp::permanent.offset))))             (cond                ((eq xqp::field1 'xqp::\a2)                 (setq xqp::dest1 xqp::byte2)                 (setq xqp::dest2 xqp::byte1))                ((eq xqp::field1 'xqp::\a1)                 (setq xqp::dest1 xqp::byte1)                 (setq xqp::dest2 xqp::byte2))                (t (shouldnt)))             (\\putbase xqp::clauseptr xqp::clause.offset (iplus xqp::dest1 opcode))             (\\putbase xqp::clauseptr (add1 xqp::clause.offset)                    xqp::dest2)             (CL:INCF XQP::CLAUSE.OFFSET 2))))(xqp::defunc xqp::store.instr.byte.cell (xqp::clauseptr instr byte cell)   (let ((opcode (xqp::left.op.code instr)))        (xqp::register.or.memory.1 byte opcode)        (\\putbase xqp::clauseptr xqp::clause.offset (iplus byte opcode))        (let ((next (add1 xqp::clause.offset)))             (xqp::load.gc.protect cell)             (\\putbase xqp::clauseptr next (plus (xqp::obj.tag cell)                                                  (\\hiloc cell)))             (\\putbase xqp::clauseptr (add1 next)                    (\\loloc cell))             (CL:INCF XQP::CLAUSE.OFFSET 3))))(xqp::defunc xqp::store.instr.byte.atom (xqp::clauseptr instr byte atom) (let ((opcode (                                                                                    xqp::left.op.code                                                                              (                                                                                        INSTR)))                                                                            xqp::register.or.memory.1                                                                               byte opcode)                                                                              (\\putbase                                                                                      xqp::clauseptr                                                                                    xqp::clause.offset                                                                                     (iplus byte                                                                                             opcode))                                                                              (\\putbase                                                                                      xqp::clauseptr                                                                                     (add1                                                                                            )                                                                                   XQP::CLAUSE.OFFSET                                                                                     (\\loloc atom))                                                                              (cl:incf                                                                                    XQP::CLAUSE.OFFSET                                                                                      2)))(xqp::defunc xqp::store.instr.byte.functor (xqp::clauseptr instr byte name xqp::arity)   (let ((place (\\addbase xqp::clauseptr xqp::clause.offset))         (opcode (xqp::left.op.code instr)))        (xqp::register.or.memory.1 byte opcode)        (\\putbase place 0 (plus byte opcode))        (\\putbase place 1 (plus xqp::|symbol.tag.16| xqp::arity))        (\\putbase place 2 (\\loloc name)))   (CL:INCF XQP::CLAUSE.OFFSET 3))(xqp::defunc xqp::store.instr.size.procedure (xqp::clauseptr instr size name xqp::arity xqp::module)   (let ((proc (xqp::local.predicate name xqp::arity xqp::module)))        (\\putbase xqp::clauseptr xqp::clause.offset (iplus (xqp::left.op.code instr)                                                            (\\hiloc proc)))        (\\putbase xqp::clauseptr (add1 xqp::clause.offset)               (\\loloc proc))        (\\putbase xqp::clauseptr (iplus xqp::clause.offset 2)               (itimes 2 size))        (CL:INCF XQP::CLAUSE.OFFSET 3)))(xqp::defunc xqp::store.instr.size.offset (xqp::clauseptr instr size offset)   (let* ((xqp::clause.hiloc (\\hiloc xqp::clauseptr))          (xqp::clause.loloc (\\loloc xqp::clauseptr))          (address (iplus offset (llsh xqp::clause.hiloc 16)                          xqp::clause.loloc))          (xqp::address.hiloc (lrsh address 16))          (xqp::address.loloc (logand address 65535)))         (\\putbase xqp::clauseptr xqp::clause.offset (iplus (xqp::left.op.code instr)                                                             xqp::address.hiloc))         (\\putbase xqp::clauseptr (add1 xqp::clause.offset)                xqp::address.loloc)         (\\putbase xqp::clauseptr (iplus xqp::clause.offset 2)                (itimes 2 size))         (CL:INCF XQP::CLAUSE.OFFSET 3)))(xqp::defunc xqp::store.instr.offset (xqp::clauseptr instr offset)   (let* ((xqp::clause.hiloc (\\hiloc xqp::clauseptr))          (xqp::clause.loloc (\\loloc xqp::clauseptr))          (address (iplus offset (llsh xqp::clause.hiloc 16)                          xqp::clause.loloc))          (xqp::address.hiloc (lrsh address 16))          (xqp::address.loloc (logand address 65535)))         (\\putbase xqp::clauseptr xqp::clause.offset (iplus (xqp::left.op.code instr)                                                             xqp::address.hiloc))         (\\putbase xqp::clauseptr (add1 xqp::clause.offset)                xqp::address.loloc)         (CL:INCF XQP::CLAUSE.OFFSET 2)))(xqp::defunc xqp::store.instr.procedure (xqp::clauseptr instr name xqp::arity xqp::module)   (let ((proc (xqp::local.predicate name xqp::arity xqp::module))         (place (\\addbase xqp::clauseptr xqp::clause.offset)))        (\\putbase place 0 (plus (xqp::left.op.code instr)                                 (\\hiloc proc)))        (\\putbase place 1 (\\loloc proc)))   (CL:INCF XQP::CLAUSE.OFFSET 2))(xqp::defunc xqp::store.instr.cell (xqp::clauseptr instr cell) (xqp::load.gc.protect cell)                                                               (let ((place (\\addbase xqp::clauseptr                                                                                    )))                                                                                   XQP::CLAUSE.OFFSET                                                                    (\\putbase place 0 (                                                                                    xqp::left.op.code                                                                                        instr))                                                                    (\\putbase place 1                                                                           (plus (xqp::obj.tag cell)                                                                                 (\\hiloc cell)))                                                                    (\\putbase place 2 (\\loloc                                                                                        cell)))                                                               (CL:INCF XQP::CLAUSE.OFFSET 3))(xqp::defunc xqp::store.instr.atom (xqp::clauseptr instr atom) (let ((place (\\addbase xqp::clauseptr                                                                                    )))                                                                                   XQP::CLAUSE.OFFSET                                                                    (\\putbase place 0 (                                                                                    xqp::left.op.code                                                                                        instr))                                                                    (\\putbase place 1 (\\loloc                                                                                        atom)))                                                               (CL:INCF XQP::CLAUSE.OFFSET 2))(xqp::defunc xqp::store.instr.functor (xqp::clauseptr instr name xqp::arity)   (let ((place (\\addbase xqp::clauseptr xqp::clause.offset)))        (\\putbase place 0 (xqp::left.op.code instr))        (\\putbase place 1 (iplus xqp::|symbol.tag.16| xqp::arity))        (\\putbase place 2 (\\loloc name)))   (CL:INCF XQP::CLAUSE.OFFSET 3))(xqp::defunc xqp::store.instr.null (xqp::clauseptr instr) (\\putbase xqp::clauseptr                                                                  xqp::clause.offset (                                                                                    xqp::left.op.code                                                                                     instr))                                                          (CL:INCF XQP::CLAUSE.OFFSET 1))(putprops load copyright ("Quintus Computer Systems, Inc" 1987))(declare\: dontcopy  (filemap (nil)))STOP