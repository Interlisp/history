(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(FILECREATED "11-Sep-87 17:18:03" {DSK}<LISPFILES>DCOMS>INTERPRET.\;6 15484        |changes| |to:|  (FUNCTIONS XQP::PROLOG.INIT.REGISTERS)      |previous| |date:| "12-Aug-87 10:06:35" {DSK}<LISPFILES>DCOMS>INTERPRET.\;5); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(PRETTYCOMPRINT INTERPRETCOMS)(RPAQQ INTERPRETCOMS ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>INTERPRET.LSP;1, loaded 12-Jun-87 13:54:00")                                          (* |;;| "SCCS   : @(#)INTERPRET.LSP	8202.2 1/16/87 File   : $xerox/interpret.lsp Author : Richard A. O'Keefe Purpose: Define the top level of the Prolog-1108 interpreter.")                      (* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")                                          (* |;;| "(def.opcode name mode body) defines the function prefix.name to be (LAMBDA () .body) where prefix is \"R\" for read mode (0) and \"W\" for write mode (1) and puts the atom prefix.name into the appropriate slot of QP.opcode")                                          (* |;;| "Ordinary opcodes have numbers in the range 0..254. Extended opcodes have numbers in the range 512 .. 1022. These are 2x256 + x.  The (read,write)-mode versions of extended opcode x are stored at 256+(0,1)+x in opcode.")                      (FUNCTIONS XQP::|def.opcode|)                      (DEFINE-TYPES INSTRUCTIONS XQP::WRITE-INSTRUCTIONS)                                          (* |;;| "(def.{read,write,both}.mode <name> <args> .<body>) is used to define instructions.  At the moment they are defined as plain argument-less lambdas; there may be some which will have to have PROG bodies.")                      (FUNCTIONS XQP::|def.read.mode| XQP::|def.write.mode|)                                          (* |;;| "Now both.mode instructions have only one function, prefaced by 'B.' and stored in both even and odd opcodes.  This should save some space.")                      (FUNCTIONS XQP::|def.both.mode|)                                          (* |;;| "New feature:  singlemode instructions will only be executed in read mode so no write-mode version is needed.  Thus two singlemode instructions can be \"packed\" into a single \"opcode\" by using the low order bit, which usually is 0 for the read mode and 1 for the write mode version of the instruction.")                      (FUNCTIONS XQP::|def.singlemode|)                                          (* |;;| "The \"extend\" instruction handlers do not contain *continue* forms; this is because the handlers for the individual  instructions (see META.LSP and ARITH.LSP) have their own.")                      (INSTRUCTIONS XQP::|extend|)                      (XQP::WRITE-INSTRUCTIONS XQP::|extend|)                                          (* |;;| "Register initialisation to be done every time the Prolog emulator is run.  The argument X is the name of the predicate to be executed, if X = 'start we will run si:start/0.")                      (FUNCTIONS XQP::PROLOG.INIT.REGISTERS)                      (PROP MAKEFILE-ENVIRONMENT)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>INTERPRET.LSP;1, loaded 12-Jun-87 13:54:00")(* |;;| "SCCS   : @(#)INTERPRET.LSP	8202.2 1/16/87 File   : $xerox/interpret.lsp Author : Richard A. O'Keefe Purpose: Define the top level of the Prolog-1108 interpreter.")(* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")(* |;;| "(def.opcode name mode body) defines the function prefix.name to be (LAMBDA () .body) where prefix is \"R\" for read mode (0) and \"W\" for write mode (1) and puts the atom prefix.name into the appropriate slot of QP.opcode")(* |;;| "Ordinary opcodes have numbers in the range 0..254. Extended opcodes have numbers in the range 512 .. 1022. These are 2x256 + x.  The (read,write)-mode versions of extended opcode x are stored at 256+(0,1)+x in opcode.")(XQP::|def.subr| XQP::|def.opcode| (|name| XQP::|functionname| |mode|)   (LET ((XQP::|opcode| (XQP::OP.CODE |name|)))                    (* |;;| "If opcode is greater than 255, it is an extended opcode.")        (|if| (NOT (SMALLP XQP::|opcode|))            |then|                                           (* \; "undefined opcode")                  (PRIN1 "Undefined opcode: ")                  (PRINT |name|)          |elseif| (ILESSP XQP::|opcode| 256)            |then|                                           (* \; "ordinary opcode")                  (SETA XQP::|QP.opcode| (IPLUS XQP::|opcode| |mode|)                        XQP::|functionname|)          |else|                                             (* \; "extended opcode")                (SETA XQP::|QP.opcode| (IPLUS XQP::|opcode| |mode| -256)                      XQP::|functionname|))))(DEF-DEFINE-TYPE INSTRUCTIONS "Prolog instructions" )(DEF-DEFINE-TYPE XQP::WRITE-INSTRUCTIONS "write mode Prolog instructions" )(* |;;| "(def.{read,write,both}.mode <name> <args> .<body>) is used to define instructions.  At the moment they are defined as plain argument-less lambdas; there may be some which will have to have PROG bodies.")(DEFDEFINER (XQP::|def.read.mode| (:PROTOTYPE (LAMBDA (NAME)                                                (AND (CL:SYMBOLP NAME)                                                     `(XQP::|def.read.mode| (\\\, NAME) (                                                                                       "declarations"                                                                                         ) "body"                                                         ))))) INSTRUCTIONS (NAME DECLARATIONS &REST BODY)           (LET ((FNNAME (PACK* "R." NAME)))                (XQP::|def.opcode| NAME FNNAME 0)            (* \; "Put FNNAME in the table.")                `(CL:DEFUN (\\\, FNNAME) NIL ,@BODY)                                                             (* \; "return function def'n")                ))(DEFDEFINER (XQP::|def.write.mode| (:PROTOTYPE (LAMBDA (NAME)                                                 (AND (CL:SYMBOLP NAME)                                                      `(XQP::|def.write.mode| (\\\, NAME) (                                                                                       "declarations"                                                                                           ) "body"                                                          ))))) XQP::WRITE-INSTRUCTIONS (NAME DECLARATIONS &REST BODY)           (LET ((FNNAME (PACK* "W." NAME)))                (XQP::|def.opcode| NAME FNNAME 1)            (* \; "Put FNNAME in the table.")                `(CL:DEFUN (\\\, FNNAME) NIL ,@BODY)                                                             (* \; "return function def'n")                ))(* |;;| "Now both.mode instructions have only one function, prefaced by 'B.' and stored in both even and odd opcodes.  This should save some space.")(DEFDEFINER (XQP::|def.both.mode| (:PROTOTYPE (LAMBDA (NAME)                                                (AND (CL:SYMBOLP NAME)                                                     `(XQP::|def.both.mode| (\\\, NAME) (                                                                                       "declarations"                                                                                         ) "body"                                                         ))))) INSTRUCTIONS (NAME DECLARATIONS &REST BODY)           (LET ((FNNAME (PACK* "B." NAME)))                (XQP::|def.opcode| NAME FNNAME 0)            (* \; "Put FNNAME in the table.")                (XQP::|def.opcode| NAME FNNAME 1)            (* \; "for both modes")                `(CL:DEFUN (\\\, FNNAME) NIL ,@BODY)                                                             (* \; "return function def'n")                ))(* |;;| "New feature:  singlemode instructions will only be executed in read mode so no write-mode version is needed.  Thus two singlemode instructions can be \"packed\" into a single \"opcode\" by using the low order bit, which usually is 0 for the read mode and 1 for the write mode version of the instruction.")(DEFDEFINER (XQP::|def.singlemode| (:PROTOTYPE (LAMBDA (NAME)                                                 (AND (CL:SYMBOLP NAME)                                                      `(XQP::|def.singlemode| (\\\, NAME) (                                                                                       "declarations"                                                                                           ) "body"                                                          ))))) INSTRUCTIONS (NAME DECLARATIONS &REST BODY)           (LET ((FNNAME (PACK* "S." NAME)))                (XQP::|def.opcode| NAME FNNAME 0)            (* \; "Put FNNAME in the table.")                `(CL:DEFUN (\\\, FNNAME) NIL ,@BODY)                                                             (* \; "return function def'n")                ))(* |;;| "The \"extend\" instruction handlers do not contain *continue* forms; this is because the handlers for the individual  instructions (see META.LSP and ARITH.LSP) have their own.")(XQP::|def.read.mode| XQP::|extend| (|byte|) (SPREADAPPLY* (\\VAG2 0 (\\GETBASE XQP::|extendR|                                                                            (XQP::|get.16| N)))))(XQP::|def.write.mode| XQP::|extend| (|byte|) (SPREADAPPLY* (\\VAG2 0 (\\GETBASE XQP::|extendW|                                                                             (XQP::|get.16| N)))))(* |;;| "Register initialisation to be done every time the Prolog emulator is run.  The argument X is the name of the predicate to be executed, if X = 'start we will run si:start/0.")(XQP::|def.subr| XQP::PROLOG.INIT.REGISTERS (X)                     (* |;;| "We start with one-time initialisation which has to be done after the \"QP.PROLOG\" function has been loaded (from either FASTPROLOG.DCOM or SLOWPROLOG.DCOM) but before anything else. It is in fact safe to do all of this more than once, now that PROLOG.INIT.MEMORY has been hacked, but why waste time? We check whether the initialisation needs doing by checking whether the garbage collector hook has been installed, as that cannot be installed until after memory has been allocated.") (|if| (NOT (CCODEP (GETD '\\GCSCANPROLOG)))     |then|                     (* |;;| "Allocate the 4Mb of Prolog memory.  This function ensures that the micro-code knows where to find the Lisp versions.")           (PROLOG.INIT.MEMORY)                     (* |;;| "Initialise the Lisp/micro-code interface table base regs. This could (& should) be in PROLOG.INIT.TABLES in PUTIL. 15-Dec-86:  Now it is. (WritePrologPtrAnd0Tag LMBase (MakeUCodeRealBaseAddr (fetch (ARRAYP BASE) of PROLOG.ENABLE.PUFN.TABLE))) (WritePrologPtrAnd0Tag PUfnTableBase (MakeUCodeRealBaseAddr (fetch (ARRAYP BASE) of PROLOG.PUFN.TABLE)))")           (XQP::|WritePrologPtrAnd0Tag| XQP::|LispEmuCodeBase| (\\GET-COMPILED-CODE-BASE                                                                 'QP.PROLOG))                     (* |;;| "Start in debug-careless mode.")           (XQP::|WritePrologPtrAnd0Tag| |Debug| 0)                     (* |;;|   "Initialise the Prolog memory bounds (membot is set by PROLOG.INIT.MEMORY).  These *never* change.")           (SETQ XQP::|init.H| (\\ADDBASE XQP::|membot| 768))           (SETQ XQP::|init.E| (\\ADDBASE XQP::|membot| 1572864))           (SETQ XQP::|memtop| (\\ADDBASE XQP::|membot| 2097152))                     (* |;;| "Ensure that \\GCSCANPROLOG\\ has been compiled.")           (|if| (NOT (CCODEP (GETD 'XQP::\\GCSCANPROLOG\\)))               |then| (CL:COMPILE 'XQP::\\GCSCANPROLOG\\))                     (* |;;| "Only now can the garbage collector hook be installed safely.")           (MOVD 'XQP::\\GCSCANPROLOG\\ '\\GCSCANPROLOG)           (PROMPTPRINT "One-time Prolog initialization completed.")) (XQP::|WritePrologPtrAnd0Tag| XQP::|PFCont| 0)              (* \; "initialize the Prolog continuation register to 0 in case Prolog aborted during a Prolog garbage collection") (XQP::|put.24| H XQP::|init.H|) (XQP::|put.24| XQP::HB XQP::|init.H|) (XQP::|put.24| S XQP::|init.H|) (XQP::|put.24| TR XQP::|init.E|) (XQP::|put.24| E XQP::|init.E|) (XQP::|put.24| B XQP::|init.E|) (XQP::|put.24| B0 XQP::|init.E|) (XQP::|put.24| R NIL) (XQP::|put.24| C X) (XQP::|put.32| XQP::T0 (XQP::|tag.ref| NIL)) (XQP::|put.32| T1 (XQP::|tag.ref| NIL))                    (* |;;| "CP must point to a 16-bit word containing 0 we have to hang onto that word as CP will not always point to it We now use \"A-register 0\" to hold this 0, as it is guaranteed to exist and be used by nothing else.") (\\PUTBASEPTR XQP::|membot| 0 NIL)                          (* \; "this happens to store [0,,0]") (XQP::|put.24| CP XQP::|membot|)                    (* |;;|           "create a dummy choice point see create.choice.point in INDEX.LSP to see how this works") (XQP::|put.addr| B 0 (XQP::|get.24| B0)) (XQP::|put.addr| B 1 (XQP::|get.24| E)) (XQP::|put.addr| B 2 (XQP::|get.24| CP)) (XQP::|put.addr| B 3 (XQP::|get.24| B)) (XQP::|put.addr| B 4 XQP::FAILURE.CLAUSE) (XQP::|put.addr| B 5 (XQP::|get.24| TR)) (XQP::|put.addr| B 6 (XQP::|get.24| H)) (XQP::|increment.cell.pointer| B 7) (XQP::|put.24| B0 (XQP::|get.24| B)) (XQP::|put.24| E (XQP::|get.24| B)) (XQP::|put.24| P (XQP::PROC.CLAUSES (XQP::|get.24| C))) (XQP::|put.4| W READ) (XQP::|put.16| I 0)                    (* |;;| "initialise the debugger") (|if| (GETD 'XQP::|init.windows|)     |then|                                                  (* \; "the debugger is installed")           (XQP::|init.windows|)                             (* \; "so start it up.")))(PUTPROPS INTERPRET COPYRIGHT ("Quintus Computer Systems, Inc" 1987))(DECLARE\: DONTCOPY  (FILEMAP (NIL)))STOP