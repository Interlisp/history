(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(FILECREATED "29-Jun-87 18:54:47" {ERIS}<PROLOGCORE>LYRIC>LISP>SKEL.\;5 69075        |changes| |to:|  (FUNCTIONS XQP::|QP.functor|)      |previous| |date:| "25-Jun-87 18:53:47" {ERIS}<PROLOGCORE>LYRIC>LISP>SKEL.\;4); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(PRETTYCOMPRINT SKELCOMS)(RPAQQ SKELCOMS ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>SKEL.LSP;1, loaded 18-Jun-87 14:03:36")                                     (* |;;| "SCCS   : @(#)SKEL.LSP	8204.13 5/27/87 File   : $xerox/skel.lsp Author : Richard A. O'Keefe & Peter Schachte Purpose: Basic interpreter support")                 (* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")                 (* |;;;| "This instruction is  +--------+--------------------------+ |  Trap  |    address of proc/2     | +--------+--------------------------+  when it is executed, the C register (in the Sun/Vax emulators, PR) points to a procdeure record, which has the format  +-----------------------------------+ C+ 0	| link to next predicate in chain   | +--------+--------+-----------------+ C+ 2	|FuncTag | Arity  |  symbol number  | +--------+--------+-----------------+ C+ 4	|AtomTag |    0   |  module number  | +--------+--------+-----------------+	 C+ 6	|  arity again as an unboxed FIXP   | +--------+--------------------------+ C+ 8	|        |  pointer to first clause | +--------+--------------------------+ C+10	|        |  pointer to last clause  | +--------+--------+-----------------+ C+12	|  flag word one  |  flag word two  | +-----------------+-----------------+  the symbol number is the InterLisp atom number of the name of the predicate; C+2 is a tagged functor cell.  The module number is the InterLisp atom number of the name of the module this predicate is defined in; C+4 is a tagged atom cell.  Some of these fields are not used in the Prolog-1108 implementation; the layout is identical to the layout used on the Sun and Vax so that the amount of system- dependent code is minimised.  If we need a scaled version of the arity, say arity*2, C+6 is a good place to put it, and then we can use word access (C+7) rather than byte access (C+5bytes) to get at it.  The point of the trap instruction is to convert a call on foo(X1,...,Xn)		arity=n, symbol=foo, module=whatever into a call on proc(foo(X1,...,Xn), C') where C' is a coded form of the address of the procedure record. It is not sufficient to pass just the term foo(X1,...,Xn), as there could be any number of procedures with that name, all in different modules.  On the Sun and Vax, C' is the address represented as an integer.  That works well because only 29-bit integers are needed. It will not work well on the Dandelion, as large integers have to be boxed.  We'll see later that addresses of this form have to be passed around a lot in the interpreter, so we'll want another way of hacking them.  So we shall represent C' as the adress itself with a slightly different \"immed\" tag, one which is clearly an immediate constant but is not a number.")                 (FUNCTIONS XQP::|QP.functor|)                 (INSTRUCTIONS XQP::|trap|)                                     (* |;;| "This file is obliged to explicitly take into account the fact that cells are pairs of half-words.  I get up to a very sneaky trick: the most significant half-word is effectively all tag (except for constants), and the right half-word is a half-word offset.  These macros do addressy things for half-words.  The conditions on them are not necessary for them to be well behaved; they are there to ensure that I haven't used them anywhere I didn't mean to.")                 (FUNCTIONS XQP::|get.half| XQP::|put.half| XQP::|add.half|)                                     (* |;;| "---------------------------------------------------------------- Interpreted Clause Layout ----------------------------------------------------------------  words from top of clause ----- ---- --- -- ----- +=======+=======+ 0	| instr	| size	|	interpret_me unindexed.offset +-------+-------+ 2	| next clause	|	last has pointer to procedure record +---------------+ 4	| prev clause	|	first has pointer to last +===============+ 6	| index key	|	for dynamic_index +-------+-------+ 8	| instr	| 0	|	interpret_me indexed.offset +-------+-------+ 10	| next in index	|	last has pointer to index block +---------------+ 12	| prev in index	|	first has pointer to last +===============+ 14	| procedure rec |	maintained for all clauses +---------------+ 16	| born clock	|	as a Lisp integer +---------------+ 18	| died clock	|	as a Lisp integer +===============+ 20	| :-/2		|	start of skel term 22	| ptr to head	| 24	| ptr to body	| 26	| head= fn/arity| 28	| arg 1		|	this determines the key  Note that words 6 through 12 of the clause are only needed for indexable clauses, but are always allocated to simplify life. interpret_me now has a byte as well as an address argument. The byte indicates how many words after the interpret_me instruction the born time for the clause can be found.  This allows the same instruction to serve for both indexed and non-indexed paths through the clause.")                                     (* |;;| "size of clause header (from top down to start of skeleton)")                 (CONSTANTS XQP::|clauseheader.words| XQP::|clauseheader.cells|)                                     (* |;;| "We tend to manipulate pointers to three different places in a clause. We generally point to the unindexed interpret.me instruction at the top of a clause; in fact, Prolog only ever holds onto such pointers.  This is IMPORTANT, becuase Prolog will reference count any such pointers that it puts into the Prolog stacks. When we have such a pointer, we refer to it as a clause. For indexed linkage through clauses, we have pointers to the indexed interpret.me instruction.  Such a pointer is said to point to a subitem.  Lastly, the pointer from an index bucket points to the key field of a clause, so that the dynamic.index instruction can quickly check whether this clause could match the call.  These pointers are said to point to a guarded subitem, called a guardedsubitem below.  There is one other pertinent place that we could point.  Sometimes we want to be able to deal with fields common to clauses and indexes. In such cases, we say we have a pointer to a dyn.  Following are constants defining field offsets to the various parts of each of these parts of the clause data structure.  All offsets are given in 16-bit words, except where indicated.")                                     (* |;;| "clause structure fields")                 (CONSTANTS XQP::|clause.instr| XQP::|clause.size| XQP::|clause.next|                         XQP::|clause.next.tagbyte|)                                                             (* \; "a byte offset")                 (CONSTANTS XQP::|clause.prev| XQP::|clause.guardedsubitem|)                                                             (* \; "guarded subitem part of clause")                 (CONSTANTS XQP::|clause.key| XQP::|clause.key.low|)                                                             (* \; "sometimes want just low 16 bits")                 (CONSTANTS XQP::|clause.subitem|)                                                             (* \; "subitem part of the clause")                 (CONSTANTS XQP::|clause.indexed.instr| XQP::|clause.indexed.next|                         XQP::|clause.indexed.next.tagbyte|)                                                             (* \; "a byte offset")                 (CONSTANTS XQP::|clause.indexed.prev| XQP::|clause.procedure| XQP::|clause.born|                         XQP::|clause.died| XQP::|clause.skel| XQP::|clause.skel.head.ptr|                         XQP::|clause.skel.head|)                                                             (* \; "skel must be a term of arity 2")                 (CONSTANTS XQP::|clause.skel.arg1|)                                                             (* \;                                                              "assuming head is term of arity > 0")                 (CONSTANTS XQP::|clause.skel.arg1.low|)                                                             (* \;                                                              "assuming head is term of arity > 0")                                     (* |;;| "subitem fields")                 (CONSTANTS XQP::|subitem.guardedsubitem| XQP::|subitem.key| XQP::|subitem.key.low|)                                                             (* \; "sometimes want just low 16 bits")                 (CONSTANTS XQP::|subitem.instr| XQP::|subitem.next| XQP::|subitem.next.tagbyte|)                                                             (* \; "a byte offset")                 (CONSTANTS XQP::|subitem.prev|)                                     (* |;;| "guardedsubitem fields")                 (CONSTANTS XQP::|guardedsubitem.key| XQP::|guardedsubitem.key.low|)                                                             (* \; "sometimes want just low 16 bits")                 (CONSTANTS XQP::|guardedsubitem.subitem| XQP::|guardedsubitem.instr|                         XQP::|guardedsubitem.next| XQP::|guardedsubitem.next.tagbyte|)                                                             (* \; "a byte offset")                 (CONSTANTS XQP::|guardedsubitem.prev|)                                     (* |;;| "common linkage fields for clauses and indexes")                 (CONSTANTS XQP::|dyn.next| XQP::|dyn.next.tagbyte|)                                                             (* \; "a byte offset")                 (CONSTANTS XQP::|dyn.prev|)                                     (* |;;| "word offsets from interpret.me instruction to timestamp for both the indexed and the unindexed instruction.  For convenience, the dynamic.index instruction always has the same byte argument as the unindexed interpret.me instruction.")                 (CONSTANTS XQP::|indexed.offset| XQP::|unindexed.offset|)                                     (* |;;| " ---------------- WARNING!  BEWARE! -------------------------------- It is NOT a coincidence that dynindex.{born|died} = clause.{born|died}!! This fact, plus the fact that the dynamic.index instruction will never be seen in an indexed clause chain, implies that (next.applicable.clause) can assume that the distance between an instruction and the corresponding timestamp.  This offset is placed as the byte argument to dynamic.index and interpret.me, so that the offset can be found in register N. -------------------------------------------------------------------")                                     (* |;;| "---------------------------------------------------------------- interpret.me ----------------------------------------------------------------  interpret.me is always called in WRITE mode.  This tells us that there is no choicepoint for this call.  When we fail into interpret.me, it is in READ mode, in which case we know that there is a choicepoint.  In either case, N is set up to be the offset from the current P value to find the timestamp, size, and the actual skeleton term at.")                 (INSTRUCTIONS XQP::|interpret.me|)                                     (* |;;| "On initial entry to interpret.me (in WRITE mode, from apply), A1 holds the skeleton term to unify with, CurClause holds the call clock value, and T0 holds the key for indexing.  ALL of these must be preserved until (maybe.create.interpreted.choicepoint) is through with them. Of course, A1 will be needed by the (interpret.me) macro.")                 (XQP::WRITE-INSTRUCTIONS XQP::|interpret.me|)                                     (* |;;| "(next.applicable.clause) Find the next clause whose timestamp indicates that the clause is alive for this call.  On call, CurClause contains the call clock, C points to an interpret.me or dynamic.index instruction; and N contains an offset relative to C to find the timestamp of each clause. If the cell C points to has a nonzero high byte, then you've found the end of the line.  On completion, C points after the instruction of the next clause (or index) to try, else C is NIL. CurClause and T0 are live.")                 (FUNCTIONS XQP::|next.applicable.clause|)                                     (* |;;| "(this.clause.is.alive) C+N points to the timestamp of a clause.  CurClause contains a clock value to check it against.  Check to see if this clause is alive for that call clock.  R is used as a temp. CurClause and T0 are live.")                 (FUNCTIONS XQP::|this.clause.is.alive|)                                     (* |;;| "(maybe.create.interpreted.choicepoint) C points to the instruction of the next applicable clause (or index), if there is one.  If so, set up a choicepoint to point to it.")                 (FUNCTIONS XQP::|maybe.create.interpreted.choicepoint|)                                     (* |;;| "(maybe.reuse.interpreted.choicepoint) There is a choicepoint for this call, and we just failed back into it.  C points after the instruction of the next clause (or index) to try if there is one.  If there IS a next clause, set choicepoint to point to it, otherwise kill choicepoint.")                 (FUNCTIONS XQP::|maybe.reuse.interpreted.choicepoint|)                                     (* |;;| "(interpret.me) is the common part of the read and write modes of the (interpret.me) instruction.  It is also used by the (apply) instruction when getting a single clause (case 2). P points after the interpret.me instruction of an interpreted clause (so the clause's address is P-1).  We are to copy this term to the heap, and unify it with A1.  At this point CurClause and T0 are no longer needed for anything.  On exit, CurClause must point to the clause.")                 (FUNCTIONS XQP::|interpret.me|)                                     (* |;;| "CLOCK.TIME is the call clock used for timestamping in 2.0. It COULD be moved to a slow register if this seems expedient. That would, though, require new instructions to read and set it.")                 (VARIABLES XQP::CLOCK.TIME)                                     (* |;;| "---------------------------------------------------------------- store.skeleton ----------------------------------------------------------------  (len.term) calculates the size of the term represented by A1, and returns that size in register N.  If the size would exceed 32767 cells, including the list cell header, it aborts. N	is 32767 - the size of the CLAUSE in cells H	is the stack top (as in unify.one, compare) S	is the stack base (as in unify.one, compare) T0, R	are the current term, as usual")                 (FUNCTIONS XQP::|len.term| XQP::HI.CODE)                                     (* |;;| "(put.term) is called with the term to be stored in A1, the size of the term in N, and the address of a block to store it in in C.  It manages a stack of (next thing to copy, next place to put a copy, count of arguments still to be copied) triples like unify.one and compare. S points to the cell that the current term is to be copied into, while N counts the number of cells which have been filled in. This code is only correct when the term to be stored is always a \"struct\".  Since the present Prolog system only stores :-(H,B) and $record(T) terms, we are safe for now.  A tagged pointer to the first data cell of the clause will be left in the \"next clause\" field, but that is about to be smashed anyway, so who cares?")                 (FUNCTIONS XQP::|put.term|)                 (INSTRUCTIONS XQP::|store.skeleton| XQP::|load.cur.clause|)                 (PROP MAKEFILE-ENVIRONMENT)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>SKEL.LSP;1, loaded 18-Jun-87 14:03:36")(* |;;| "SCCS   : @(#)SKEL.LSP	8204.13 5/27/87 File   : $xerox/skel.lsp Author : Richard A. O'Keefe & Peter Schachte Purpose: Basic interpreter support")(* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")(* |;;;| "This instruction is  +--------+--------------------------+ |  Trap  |    address of proc/2     | +--------+--------------------------+  when it is executed, the C register (in the Sun/Vax emulators, PR) points to a procdeure record, which has the format  +-----------------------------------+ C+ 0	| link to next predicate in chain   | +--------+--------+-----------------+ C+ 2	|FuncTag | Arity  |  symbol number  | +--------+--------+-----------------+ C+ 4	|AtomTag |    0   |  module number  | +--------+--------+-----------------+	 C+ 6	|  arity again as an unboxed FIXP   | +--------+--------------------------+ C+ 8	|        |  pointer to first clause | +--------+--------------------------+ C+10	|        |  pointer to last clause  | +--------+--------+-----------------+ C+12	|  flag word one  |  flag word two  | +-----------------+-----------------+  the symbol number is the InterLisp atom number of the name of the predicate; C+2 is a tagged functor cell.  The module number is the InterLisp atom number of the name of the module this predicate is defined in; C+4 is a tagged atom cell.  Some of these fields are not used in the Prolog-1108 implementation; the layout is identical to the layout used on the Sun and Vax so that the amount of system- dependent code is minimised.  If we need a scaled version of the arity, say arity*2, C+6 is a good place to put it, and then we can use word access (C+7) rather than byte access (C+5bytes) to get at it.  The point of the trap instruction is to convert a call on foo(X1,...,Xn)		arity=n, symbol=foo, module=whatever into a call on proc(foo(X1,...,Xn), C') where C' is a coded form of the address of the procedure record. It is not sufficient to pass just the term foo(X1,...,Xn), as there could be any number of procedures with that name, all in different modules.  On the Sun and Vax, C' is the address represented as an integer.  That works well because only 29-bit integers are needed. It will not work well on the Dandelion, as large integers have to be boxed.  We'll see later that addresses of this form have to be passed around a lot in the interpreter, so we'll want another way of hacking them.  So we shall represent C' as the adress itself with a slightly different \"immed\" tag, one which is clearly an immediate constant but is not a number.")(XQP::|def.macro| XQP::|QP.functor| (C) (|if| (NEQ C 'C)                                            |then| (SHOULDNT "QP.functor"))                                        `(XQP::|get.cell| ,C 1))(XQP::|def.both.mode| XQP::|trap| (|address|)   (XQP::|put.16| I (XQP::PROC.ARITY (XQP::|get.24| C)))   (|if| (|zero| I)       |then| (XQP::|put.Aval| 1 (XQP::|QP.functor| C))     |else|                     (* |;;| "dump the A registers into memory")           (XQP::|put.Amem| 1 (XQP::|get.Aval| 1))           (XQP::|put.Amem| 2 (XQP::|get.Aval| 2))           (XQP::|put.Amem| 3 (XQP::|get.Aval| 3))           (XQP::|put.Amem| 4 (XQP::|get.Aval| 4))           (XQP::|put.Aval| 1 (XQP::|tag.struct| H))           (XQP::|put.cell| H 0 (XQP::|QP.functor| C))           (XQP::|increment.cell.pointer| H)           (XQP::|put.24| S (XQP::|loc.Amem| 1))           (|until| (|zero| I)                  (XQP::|put.32| XQP::T0 (XQP::|get.cell| S 0))                  (XQP::|increment.cell.pointer| S)                  (XQP::|select.4| XQP::T0 (XQP::|ref.tag.8| (XQP::|put.24| R (XQP::|untag.ref|                                                                               XQP::T0))                                                  (XQP::|put.32| XQP::T0 (XQP::|get.cell| R 0))                                                  (XQP::|reselect.when.bound| XQP::T0 R)                                                  (|if| (|before| H R)                                                      |then| (* \; "variable is local")                                                            (XQP::|put.32| XQP::T0 (XQP::|tag.ref|                                                                                    H))                                                            (XQP::|bind.local| R XQP::T0)))                         (PROGN))                  (XQP::|put.cell| H 0 (XQP::|get.32| XQP::T0))                  (XQP::|increment.cell.pointer| H)                  (XQP::|decrement.counter| I)))   (XQP::|put.Aval| 2 (XQP::|tag.other| (XQP::|get.24| C)))   (XQP::|put.24| C (XQP::|address.operand|))   (XQP::|do.execute|))(* |;;| "This file is obliged to explicitly take into account the fact that cells are pairs of half-words.  I get up to a very sneaky trick: the most significant half-word is effectively all tag (except for constants), and the right half-word is a half-word offset.  These macros do addressy things for half-words.  The conditions on them are not necessary for them to be well behaved; they are there to ensure that I haven't used them anywhere I didn't mean to.")(XQP::|def.macro| XQP::|get.half| (XQP::|Base| |Offset|) (|if| (OR (NEQ XQP::|Base| 'S)                                                                   (NOT (SMALLP |Offset|)))                                                             |then| (SHOULDNT 'XQP::|get.half|))                                                         `(\\GETBASE (XQP::|get.24| ,XQP::|Base|)                                                                 ,|Offset|))(XQP::|def.macro| XQP::|put.half| (XQP::|Base| |Offset| XQP::|Val|)   (|if| (NOT (AND (MEMB XQP::|Base| '(H S C))                   (SMALLP |Offset|)))       |then| (SHOULDNT 'XQP::|put.half|))   `(\\PUTBASE (XQP::|get.24| ,XQP::|Base|)           ,|Offset|           ,XQP::|Val|))(XQP::|def.macro| XQP::|add.half| (XQP::|Base| |Offset|) (|if| (OR (NEQ XQP::|Base| 'C)                                                                   (NEQ |Offset| 'N))                                                             |then| (SHOULDNT 'XQP::|add.half|))                                                         `(\\ADDBASE (XQP::|get.24| ,XQP::|Base|)                                                                 (XQP::|get.16| ,|Offset|)))(* |;;| "---------------------------------------------------------------- Interpreted Clause Layout ----------------------------------------------------------------  words from top of clause ----- ---- --- -- ----- +=======+=======+ 0	| instr	| size	|	interpret_me unindexed.offset +-------+-------+ 2	| next clause	|	last has pointer to procedure record +---------------+ 4	| prev clause	|	first has pointer to last +===============+ 6	| index key	|	for dynamic_index +-------+-------+ 8	| instr	| 0	|	interpret_me indexed.offset +-------+-------+ 10	| next in index	|	last has pointer to index block +---------------+ 12	| prev in index	|	first has pointer to last +===============+ 14	| procedure rec |	maintained for all clauses +---------------+ 16	| born clock	|	as a Lisp integer +---------------+ 18	| died clock	|	as a Lisp integer +===============+ 20	| :-/2		|	start of skel term 22	| ptr to head	| 24	| ptr to body	| 26	| head= fn/arity| 28	| arg 1		|	this determines the key  Note that words 6 through 12 of the clause are only needed for indexable clauses, but are always allocated to simplify life. interpret_me now has a byte as well as an address argument. The byte indicates how many words after the interpret_me instruction the born time for the clause can be found.  This allows the same instruction to serve for both indexed and non-indexed paths through the clause.")(* |;;| "size of clause header (from top down to start of skeleton)")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|clauseheader.words| 20)(RPAQQ XQP::|clauseheader.cells| 10)(CONSTANTS XQP::|clauseheader.words| XQP::|clauseheader.cells|))(* |;;| "We tend to manipulate pointers to three different places in a clause. We generally point to the unindexed interpret.me instruction at the top of a clause; in fact, Prolog only ever holds onto such pointers.  This is IMPORTANT, becuase Prolog will reference count any such pointers that it puts into the Prolog stacks. When we have such a pointer, we refer to it as a clause. For indexed linkage through clauses, we have pointers to the indexed interpret.me instruction.  Such a pointer is said to point to a subitem.  Lastly, the pointer from an index bucket points to the key field of a clause, so that the dynamic.index instruction can quickly check whether this clause could match the call.  These pointers are said to point to a guarded subitem, called a guardedsubitem below.  There is one other pertinent place that we could point.  Sometimes we want to be able to deal with fields common to clauses and indexes. In such cases, we say we have a pointer to a dyn.  Following are constants defining field offsets to the various parts of each of these parts of the clause data structure.  All offsets are given in 16-bit words, except where indicated.")(* |;;| "clause structure fields")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|clause.instr| 0)(RPAQQ XQP::|clause.size| 1)(RPAQQ XQP::|clause.next| 2)(RPAQQ XQP::|clause.next.tagbyte| 4)(CONSTANTS XQP::|clause.instr| XQP::|clause.size| XQP::|clause.next| XQP::|clause.next.tagbyte|))(* \; "a byte offset")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|clause.prev| 4)(RPAQQ XQP::|clause.guardedsubitem| 6)(CONSTANTS XQP::|clause.prev| XQP::|clause.guardedsubitem|))(* \; "guarded subitem part of clause")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|clause.key| 6)(RPAQQ XQP::|clause.key.low| 7)(CONSTANTS XQP::|clause.key| XQP::|clause.key.low|))(* \; "sometimes want just low 16 bits")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|clause.subitem| 8)(CONSTANTS XQP::|clause.subitem|))(* \; "subitem part of the clause")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|clause.indexed.instr| 8)(RPAQQ XQP::|clause.indexed.next| 10)(RPAQQ XQP::|clause.indexed.next.tagbyte| 20)(CONSTANTS XQP::|clause.indexed.instr| XQP::|clause.indexed.next| XQP::|clause.indexed.next.tagbyte|))(* \; "a byte offset")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|clause.indexed.prev| 12)(RPAQQ XQP::|clause.procedure| 14)(RPAQQ XQP::|clause.born| 16)(RPAQQ XQP::|clause.died| 18)(RPAQQ XQP::|clause.skel| 20)(RPAQQ XQP::|clause.skel.head.ptr| 22)(RPAQQ XQP::|clause.skel.head| 26)(CONSTANTS XQP::|clause.indexed.prev| XQP::|clause.procedure| XQP::|clause.born| XQP::|clause.died|        XQP::|clause.skel| XQP::|clause.skel.head.ptr| XQP::|clause.skel.head|))(* \; "skel must be a term of arity 2")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|clause.skel.arg1| 28)(CONSTANTS XQP::|clause.skel.arg1|))(* \; "assuming head is term of arity > 0")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|clause.skel.arg1.low| 29)(CONSTANTS XQP::|clause.skel.arg1.low|))(* \; "assuming head is term of arity > 0")(* |;;| "subitem fields")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|subitem.guardedsubitem| -2)(RPAQQ XQP::|subitem.key| -2)(RPAQQ XQP::|subitem.key.low| -1)(CONSTANTS XQP::|subitem.guardedsubitem| XQP::|subitem.key| XQP::|subitem.key.low|))(* \; "sometimes want just low 16 bits")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|subitem.instr| 0)(RPAQQ XQP::|subitem.next| 2)(RPAQQ XQP::|subitem.next.tagbyte| 4)(CONSTANTS XQP::|subitem.instr| XQP::|subitem.next| XQP::|subitem.next.tagbyte|))(* \; "a byte offset")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|subitem.prev| 4)(CONSTANTS XQP::|subitem.prev|))(* |;;| "guardedsubitem fields")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|guardedsubitem.key| 0)(RPAQQ XQP::|guardedsubitem.key.low| 1)(CONSTANTS XQP::|guardedsubitem.key| XQP::|guardedsubitem.key.low|))(* \; "sometimes want just low 16 bits")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|guardedsubitem.subitem| 2)(RPAQQ XQP::|guardedsubitem.instr| 2)(RPAQQ XQP::|guardedsubitem.next| 4)(RPAQQ XQP::|guardedsubitem.next.tagbyte| 8)(CONSTANTS XQP::|guardedsubitem.subitem| XQP::|guardedsubitem.instr| XQP::|guardedsubitem.next|        XQP::|guardedsubitem.next.tagbyte|))(* \; "a byte offset")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|guardedsubitem.prev| 6)(CONSTANTS XQP::|guardedsubitem.prev|))(* |;;| "common linkage fields for clauses and indexes")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|dyn.next| 2)(RPAQQ XQP::|dyn.next.tagbyte| 4)(CONSTANTS XQP::|dyn.next| XQP::|dyn.next.tagbyte|))(* \; "a byte offset")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|dyn.prev| 4)(CONSTANTS XQP::|dyn.prev|))(* |;;| "word offsets from interpret.me instruction to timestamp for both the indexed and the unindexed instruction.  For convenience, the dynamic.index instruction always has the same byte argument as the unindexed interpret.me instruction.")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|indexed.offset| 8)(RPAQQ XQP::|unindexed.offset| 16)(CONSTANTS XQP::|indexed.offset| XQP::|unindexed.offset|))(* |;;| " ---------------- WARNING!  BEWARE! -------------------------------- It is NOT a coincidence that dynindex.{born|died} = clause.{born|died}!! This fact, plus the fact that the dynamic.index instruction will never be seen in an indexed clause chain, implies that (next.applicable.clause) can assume that the distance between an instruction and the corresponding timestamp.  This offset is placed as the byte argument to dynamic.index and interpret.me, so that the offset can be found in register N. -------------------------------------------------------------------")(* |;;| "---------------------------------------------------------------- interpret.me ----------------------------------------------------------------  interpret.me is always called in WRITE mode.  This tells us that there is no choicepoint for this call.  When we fail into interpret.me, it is in READ mode, in which case we know that there is a choicepoint.  In either case, N is set up to be the offset from the current P value to find the timestamp, size, and the actual skeleton term at.")(XQP::|def.read.mode| XQP::|interpret.me| NIL (XQP::|put.24| C (XQP::|add.code| P -1))                                                             (* \; "point to clause or subitem")                                              (XQP::|put.Aval| 1 (XQP::|get.cell| B -8))                                                             (* \;                                                      "saved skeleton -9 = saved key, not needed here")                                              (XQP::|put.24| XQP::|CurClause| (XQP::|get.addr| B -10)                                                     )       (* \; "saved call clock")                                              (XQP::|next.applicable.clause|)                                              (XQP::|maybe.reuse.interpreted.choicepoint|)                                              (XQP::|interpret.me|))(* |;;| "On initial entry to interpret.me (in WRITE mode, from apply), A1 holds the skeleton term to unify with, CurClause holds the call clock value, and T0 holds the key for indexing.  ALL of these must be preserved until (maybe.create.interpreted.choicepoint) is through with them. Of course, A1 will be needed by the (interpret.me) macro.")(XQP::|def.write.mode| XQP::|interpret.me| NIL (XQP::|put.24| C (XQP::|add.code| P -1))                                                             (* \; "point to clause or subitem")                                               (|if| (XQP::|this.clause.is.alive|)                                                   |then| (XQP::|next.applicable.clause|)                                                         (XQP::|maybe.create.interpreted.choicepoint|                                                          )                                                         (XQP::|interpret.me|)                                                 |elseif| (ZEROP (XQP::|get.code.byte| C                                                                         XQP::|dyn.next| 0))                                                   |then|                     (* |;;| "this clause is dead, but there is a next clause: try it")                                                         (XQP::|continue.writing.at| (                                                                          XQP::|next.address.operand|                                                                                      ))                                                 |else|                     (* |;;| "the end of the line.  nothing for it but to fail.")                                                       (XQP::|fast.fail|)))(* |;;| "(next.applicable.clause) Find the next clause whose timestamp indicates that the clause is alive for this call.  On call, CurClause contains the call clock, C points to an interpret.me or dynamic.index instruction; and N contains an offset relative to C to find the timestamp of each clause. If the cell C points to has a nonzero high byte, then you've found the end of the line.  On completion, C points after the instruction of the next clause (or index) to try, else C is NIL. CurClause and T0 are live.")(XQP::|def.open| XQP::|next.applicable.clause| NIL (PROG NIL                                                     L   (|if| (NOT (ZEROP (XQP::|get.code.byte|                                                                            C XQP::|dyn.next| 0)))                                                             |then| (XQP::|put.24| C NIL)                                                                   (RETURN))                                                         (XQP::|put.24| C (XQP::|get.code.ptr| C                                                                                  XQP::|dyn.next|))                                                             (* \; "point to instr of next")                                                         (|if| (XQP::|this.clause.is.alive|)                                                             |then| (RETURN))                                                         (GO L)))(* |;;| "(this.clause.is.alive) C+N points to the timestamp of a clause.  CurClause contains a clock value to check it against.  Check to see if this clause is alive for that call clock.  R is used as a temp. CurClause and T0 are live.")(XQP::|def.open| XQP::|this.clause.is.alive| NIL (PROGN (XQP::|put.24| R (XQP::|get.code.ptr|                                                                          C                                                                          (IPLUS (XQP::|get.16|                                                                                  N)                                                                                 2)))                                                        (AND (OR (NULL (XQP::|get.24| R))                                                                 (ILEQ (XQP::|get.24|                                                                               XQP::|CurClause|)                                                                       (XQP::|get.24| R)))                                                             (PROGN (XQP::|put.24|                                                                     R                                                                     (XQP::|get.code.ptr|                                                                      C                                                                      (XQP::|get.16| N)))                    (* |;;| "This field won't be NIL")                                                                    (IGREATERP (XQP::|get.24|                                                                                      XQP::|CurClause|                                                                                      )                                                                           (XQP::|get.24| R))))))(* |;;| "(maybe.create.interpreted.choicepoint) C points to the instruction of the next applicable clause (or index), if there is one.  If so, set up a choicepoint to point to it.")(XQP::|def.open| XQP::|maybe.create.interpreted.choicepoint| NIL (|if| (XQP::|get.24| C)                                                                     |then|                                                              (* \;                                                              "if there IS a next set up choicepoint")                                                                           (XQP::|set.top.of.stack|)                                                              (* \; "sets R")                                                                           (XQP::|put.addr|                                                                            R 0 (XQP::|get.24|                                                                                      XQP::|CurClause|                                                                                       ))                                                              (* \; "save call clock")                                                                           (XQP::|put.cell|                                                                            R 1 (XQP::|get.32|                                                                                        XQP::T0))                                                              (* \; "save index key")                                                                           (XQP::|put.cell|                                                                            R 2 (XQP::|get.Aval|                                                                                 1))                                                              (* \; "save skeleton to match")                                                                           (XQP::|put.addr|                                                                            R 3 (XQP::|get.24| B0))                                                              (* \; "\\")                                                                           (XQP::|put.addr|                                                                            R 4 (XQP::|get.24| E))                                                              (* \; "\\")                                                                           (XQP::|put.addr|                                                                            R 5 (XQP::|get.24| CP))                                                              (* \; "\\")                                                                           (XQP::|put.addr|                                                                            R 6 (XQP::|get.24| B))                                                              (* \; "create.choice.point")                                                                           (XQP::|put.addr|                                                                            R 7 (XQP::|get.24| C))                                                              (* \; "<---- except this is different")                                                                           (XQP::|put.addr|                                                                            R 8 (XQP::|get.24| TR))                                                              (* \; "/")                                                                           (XQP::|put.addr|                                                                            R 9 (XQP::|get.24| H))                                                              (* \; "/")                                                                           (XQP::|put.24|                                                                            B                                                                            (XQP::|add.cell| R 10))                                                              (* \; "/")                                                                           (XQP::|put.24|                                                                            XQP::HB                                                                            (XQP::|get.24| H))                                                              (* \; "/")                                                                           (XQP::|check.stack| B)                                                              (* \;                                                              "/ otherwise no choicepoint is needed")))(* |;;| "(maybe.reuse.interpreted.choicepoint) There is a choicepoint for this call, and we just failed back into it.  C points after the instruction of the next clause (or index) to try if there is one.  If there IS a next clause, set choicepoint to point to it, otherwise kill choicepoint.")(XQP::|def.open| XQP::|maybe.reuse.interpreted.choicepoint| NIL (|if| (XQP::|get.24| C)                                                                    |then|                                                              (* \; "still need choicepoint")                                                                          (XQP::|put.24| XQP::HB                                                                                 (XQP::|get.24|                                                                                  H))                                                                          (XQP::|put.addr|                                                                           B XQP::|saved.BP|                                                                           (XQP::|get.24| C))                                                              (* \; "store next in choicepoint")                                                                  |else|                                                              (* \; "don't need choicepoint")                                                                        (XQP::|put.24| B                                                                               (XQP::|get.addr|                                                                                B XQP::|saved.B|))                                                                        (XQP::|put.24| XQP::HB                                                                               (XQP::|get.addr|                                                                                B XQP::|saved.H|))))(* |;;| "(interpret.me) is the common part of the read and write modes of the (interpret.me) instruction.  It is also used by the (apply) instruction when getting a single clause (case 2). P points after the interpret.me instruction of an interpreted clause (so the clause's address is P-1).  We are to copy this term to the heap, and unify it with A1.  At this point CurClause and T0 are no longer needed for anything.  On exit, CurClause must point to the clause.")(XQP::|def.open| XQP::|interpret.me| NIL (XQP::|put.24| C (XQP::|get.24| H))                                                             (* \; "base of skeleton on heap")                                         (XQP::|put.24| XQP::|CurClause|                                                              (* \; "save clause address")                                                (XQP::|add.code| P (IDIFFERENCE (XQP::|get.16| N)                                                                          (ADD1 XQP::|clause.born|)))                                                )                                         (XQP::|put.24| S (XQP::|add.code| XQP::|CurClause|                                                                  XQP::|clause.skel|))                                                             (* \;                                                              "S now points to first cell of skel")                                         (XQP::|put.16| I (IDIFFERENCE (XQP::|get.code|                                                                               XQP::|CurClause|                                                                               XQP::|clause.size|)                                                                 XQP::|clauseheader.cells|))                                                             (* \; "number of cells to copy")                                         (XQP::|check.heap| 24)                                                             (* \;                                                              "ensure room for term EV_OVHEAPINTERPME")                                         (XQP::|put.Aval| 2 (XQP::|tag.struct| H))                                                             (* \; "always a compound term")                                         (|until| (|zero| I)                                            |do| (XQP::|put.16| N (XQP::|get.half| S 0))                                                              (* \; "the super-tag")                                                 (|if| (ILESSP (XQP::|get.16| N)                                                              XQP::|symbol.tag.16|)                                                     |then|  (* \; "pointer")                                                           (\\PUTBASEPTR (XQP::|get.24| H)                                                                  0                                                             (* \; "bottom 24 bits")                                                                  (\\ADDBASE (XQP::|get.24| C)                                                                         (XQP::|get.half| S 1)))                                                           (\\PUTBASEBYTE (XQP::|get.24| H)                                                                  0                                                             (* \; "top 8 bits")                                                                  (LRSH (XQP::|get.16| N)                                                                        8))                                                   |else|    (* \; "atomic")                                                         (XQP::|put.half| H 0 (XQP::|get.16| N))                                                         (XQP::|put.half| H 1 (XQP::|get.half| S 1)))                                                 (XQP::|increment.cell.pointer| H)                                                 (XQP::|increment.cell.pointer| S)                                                 (XQP::|decrement.counter| I))                                         (XQP::|put.32| XQP::T0 (XQP::|get.Aval| 1))                                         (XQP::|put.32| T1 (XQP::|get.Aval| 2))                                         (XQP::|unify.and.continue| 3)                                                             (* \; "**HACK** (3 is a special case)")                                         )(* |;;| "CLOCK.TIME is the call clock used for timestamping in 2.0. It COULD be moved to a slow register if this seems expedient. That would, though, require new instructions to read and set it.")(XQP::|def.var| XQP::CLOCK.TIME MIN.SMALLP)(* |;;| "---------------------------------------------------------------- store.skeleton ----------------------------------------------------------------  (len.term) calculates the size of the term represented by A1, and returns that size in register N.  If the size would exceed 32767 cells, including the list cell header, it aborts. N	is 32767 - the size of the CLAUSE in cells H	is the stack top (as in unify.one, compare) S	is the stack base (as in unify.one, compare) T0, R	are the current term, as usual")(XQP::|def.open| XQP::|len.term| NIL (PROG NIL                                           (XQP::|put.16| N (IDIFFERENCE 32767                                                                    XQP::|clauseheader.cells|))                                           (XQP::|check.heap| 20)                                                             (* \;                                                      "check that H stack can't overflow EV_OVCHKHEAP")                                           (XQP::|put.24| S (XQP::|get.24| H))                                           (XQP::|put.word| H 2 0)                                           (XQP::|put.32| XQP::T0 (XQP::|get.Aval| 1))                                                             (* \; "term to find size of")                                       L   (XQP::|select.4| XQP::T0 (XQP::|ref.tag.8|                                                                     (XQP::|put.24| R (                                                                                     XQP::|untag.ref|                                                                                       XQP::T0))                                                                     (XQP::|put.32| XQP::T0                                                                            (XQP::|get.cell| R 0))                                                                     (XQP::|reselect.when.bound|                                                                      XQP::T0 R)                                                                     NIL)                                                  (XQP::|struct.tag.8|                                                   (XQP::|put.24| R (XQP::|untag.struct| XQP::T0))                                                   (XQP::|put.32| XQP::T0 (XQP::|get.cell| R 0))                                                   (XQP::|put.16| I (XQP::|arity.of| XQP::T0))                                                   (|if| (ILEQ (XQP::|get.16| N)                                                               (XQP::|get.16| I))                                                       |then| (XQP::|put.24| H (XQP::|get.24| S))                                                             (XQP::QP.OVERFLOW 30))                                                   (XQP::|put.16| N (IDIFFERENCE (IDIFFERENCE                                                                                  (XQP::|get.16|                                                                                   N)                                                                                  (XQP::|get.16|                                                                                   I))                                                                           1))                                                   (XQP::|put.16| I (SUB1 (XQP::|get.16| I)))                                                   (|if| (NOT (|zero| I))                                                       |then| (XQP::|increment.cell.pointer| H 3)                                                             (XQP::|put.addr| H 0 (XQP::|add.cell|                                                                                   R 2))                                                             (XQP::|put.word| H 2 (XQP::|get.16|                                                                                   I)))                                                   (XQP::|put.32| XQP::T0 (XQP::|get.cell| R 1))                                                   (XQP::|reselect|))                                                  (XQP::|list.tag.8| (XQP::|put.24| R (                                                                                    XQP::|untag.list|                                                                                       XQP::T0))                                                         (|if| (ILEQ (XQP::|get.16| N)                                                                     1)                                                             |then| (XQP::|put.24| H (XQP::|get.24|                                                                                      S))                                                                   (XQP::QP.OVERFLOW 30))                                                         (XQP::|put.16| N (IDIFFERENCE (XQP::|get.16|                                                                                        N)                                                                                 2))                                                         (XQP::|increment.cell.pointer| H 3)                                                         (XQP::|put.addr| H 0 (XQP::|add.cell| R 1))                                                         (XQP::|put.word| H 2 1)                                                         (XQP::|put.32| XQP::T0 (XQP::|get.cell|                                                                                 R 0))                                                         (XQP::|reselect|))                                                  (PROGN))                                           (XQP::|put.16| I (XQP::|get.word| H 2))                                           (|if| (|zero| I)                                               |then| (XQP::|put.16| N (IDIFFERENCE 32767                                                                              (XQP::|get.16| N)))                                                     (RETURN))                                           (XQP::|put.24| R (XQP::|get.addr| H 0))                                           (XQP::|decrement.counter| I)                                           (|if| (|zero| I)                                               |then| (XQP::|decrement.cell.pointer| H 3)                                                              (* \; "pop completed frame")                                             |else| (XQP::|put.addr| H 0 (XQP::|add.cell| R 1))                                                   (XQP::|put.word| H 2 (XQP::|get.16| I)))                                           (XQP::|put.32| XQP::T0 (XQP::|get.cell| R 0))                                           (GO L)))(XQP::|def.subr| XQP::HI.CODE (INSTR ARG) (LET ((OP (XQP::OP.CODE INSTR)))                                               (|if| (LESSP OP 256)                                                   |then| (IPLUS (LLSH OP 8)                                                                 (OR ARG 0))                                                 |elseif| ARG                                                   |then|    (* \; "extended opcodes don't take args")                                                         (ERROR "Opcode doesn't take a byte argument"                                                                 INSTR)                                                 |else| OP   (* \; "extended opcodes"))                                                            (* \; "are returned as is")                                               ))(* |;;| "(put.term) is called with the term to be stored in A1, the size of the term in N, and the address of a block to store it in in C.  It manages a stack of (next thing to copy, next place to put a copy, count of arguments still to be copied) triples like unify.one and compare. S points to the cell that the current term is to be copied into, while N counts the number of cells which have been filled in. This code is only correct when the term to be stored is always a \"struct\".  Since the present Prolog system only stores :-(H,B) and $record(T) terms, we are safe for now.  A tagged pointer to the first data cell of the clause will be left in the \"next clause\" field, but that is about to be smashed anyway, so who cares?")(XQP::|def.open| XQP::|put.term|   NIL (PROG NIL             (XQP::|put.code.ptr| XQP::|CurClause| XQP::|clause.key| NIL)                                                             (* \; "initialize key field with ref tagged 0.  We only care about tag (put.code.byte CurClause	; this doesn't need to be done, since clause.key 0 ref.tag.8)	; ref.tag.8 = 0, and put.code.ptr ; puts 0 in the high byte")             (XQP::|put.code| XQP::|CurClause| XQP::|clause.indexed.instr| (CONSTANT                                                                            (XQP::HI.CODE                                                                             'XQP::|interpret.me|                                                                              XQP::|indexed.offset|)))             (XQP::|put.code| XQP::|CurClause| XQP::|clause.instr| (CONSTANT (XQP::HI.CODE                                                                              'XQP::|interpret.me|                                                                               XQP::|unindexed.offset|                                                                              )))             (XQP::|put.code.ptr| XQP::|CurClause| XQP::|clause.born| XQP::CLOCK.TIME)                                                             (* \; "current clock value")             (XQP::|put.code.ptr| XQP::|CurClause| XQP::|clause.died| NIL)                                                             (* \; "means not dead yet")             (XQP::|put.code| XQP::|CurClause| XQP::|clause.size| (XQP::|get.16| N))                                                             (* \; "size of CLAUSE in cells")             (XQP::|put.24| S (XQP::|add.code| XQP::|CurClause| XQP::|clause.prev|))                                                             (* \; "can safely be clobbered")             (XQP::|put.24| C (XQP::|add.code| XQP::|CurClause| XQP::|clause.skel|))                                                             (* \; "point to place to put skel")             (XQP::|put.16| N 0)                             (* \; "(halfword) offset for arguments")             (XQP::|put.32| XQP::T0 (XQP::|get.Aval| 1))     (* \; "the term to be stored")         L   (XQP::|select.4|              XQP::T0              (XQP::|ref.tag.8|               (|if| (EQ (XQP::\\GET.HI.16 XQP::T0)                         XQP::|ref.tag.16|)                   |then|                     (* |;;| "this variable has already been bound to an offset")                         (XQP::|put.cell| S 0 (XQP::|get.32| XQP::T0))                 |else| (XQP::|put.24| R (XQP::|untag.ref| XQP::T0))                       (XQP::|put.32| XQP::T0 (XQP::|get.cell| R 0))                       (|if| (XQP::|is.unbound| XQP::T0 R)                           |then|                     (* |;;| "this variable is not yet bound The arithmetic expression *does* yield 0..2^16-1!")                                 (XQP::|put.24| B0 (\\VAG2 0 (IPLUS (LLSH (IDIFFERENCE (                                                                                     XQP::\\GET.HI.16                                                                                        S)                                                                                 (XQP::\\GET.HI.16                                                                                  C))                                                                          16)                                                                    (IDIFFERENCE (XQP::\\GET.LO.16                                                                                  S)                                                                           (XQP::\\GET.LO.16 C)))))                                 (XQP::|put.32| XQP::T0 (XQP::|tag.ref| B0))                                 (XQP::|put.cell| S 0 (XQP::|get.32| XQP::T0))                                 (XQP::|bind.trail| R XQP::T0)                         |else| (XQP::|reselect|))))              (XQP::|struct.tag.8| (XQP::|put.24| R (XQP::|untag.struct| XQP::T0))                     (XQP::|put.32| XQP::T0 (XQP::|get.cell| R 0))                     (XQP::|put.16| I (SUB1 (XQP::|arity.of| XQP::T0)))                     (XQP::|put.half| S 0 XQP::|struct.tag.16|)                     (XQP::|put.half| S 1 (XQP::|get.16| N))                     (XQP::|put.24| S (XQP::|add.half| C N))                     (XQP::|put.cell| S 0 (XQP::|get.32| XQP::T0))                     (|if| (NOT (|zero| I))                         |then| (XQP::|increment.cell.pointer| H 3)                               (XQP::|put.addr| H 0 (XQP::|add.cell| R 2))                               (XQP::|put.addr| H 1 (XQP::|add.cell| S 2))                               (XQP::|put.word| H 2 (XQP::|get.16| I)))                     (XQP::|put.32| XQP::T0 (XQP::|get.cell| R 1))                     (XQP::|increment.cell.pointer| S)                     (XQP::|put.16| N (IPLUS (XQP::|get.16| N)                                             (LLSH (XQP::|get.16| I)                                                   1)                                             4))                     (XQP::|reselect|))              (XQP::|list.tag.8| (XQP::|put.half| S 0 XQP::|list.tag.16|)                     (XQP::|put.half| S 1 (XQP::|get.16| N))                     (XQP::|put.24| S (XQP::|add.half| C N))                     (XQP::|put.16| N (IPLUS (XQP::|get.16| N)                                             4))                     (XQP::|put.24| R (XQP::|untag.list| XQP::T0))                     (XQP::|put.32| XQP::T0 (XQP::|get.cell| R 0))                     (XQP::|increment.cell.pointer| H 3)                     (XQP::|put.addr| H 0 (XQP::|add.cell| R 1))                     (XQP::|put.addr| H 1 (XQP::|add.cell| S 1))                     (XQP::|put.word| H 2 1)                     (XQP::|reselect|))              (PROGN (|if| (IGEQ (XQP::|super.tag.of| XQP::T0)                                 XQP::|other.tag.16|)                         |then| (\\ADDREF (XQP::|untag.immed| XQP::T0)))                     (XQP::|put.cell| S 0 (XQP::|get.32| XQP::T0))))             (XQP::|put.16| I (XQP::|get.word| H 2))             (|if| (|zero| I)                 |then| (RETURN))             (XQP::|put.24| R (XQP::|get.addr| H 0))             (XQP::|put.24| S (XQP::|get.addr| H 1))             (XQP::|decrement.counter| I)             (|if| (|zero| I)                 |then| (XQP::|decrement.cell.pointer| H 3)  (* \; "pop completed frame")               |else| (XQP::|put.addr| H 0 (XQP::|add.cell| R 1))                     (XQP::|put.addr| H 1 (XQP::|add.cell| S 1))                     (XQP::|put.word| H 2 (XQP::|get.16| I)))             (XQP::|put.32| XQP::T0 (XQP::|get.cell| R 0))             (GO L)))(XQP::|def.read.mode| XQP::|store.skeleton| (XQP::|extend|)   (XQP::|put.24| XQP::|CurClause| 0)                        (* \; "in case len.term fails")   (XQP::|len.term|)                                         (* \; "puts length in N")   (XQP::|put.24| XQP::|CurClause| (\\ALLOCBLOCK (XQP::|get.16| N)))   (\\ADDREF (XQP::|get.24| XQP::|CurClause|))               (* \; "nail it down!")   (XQP::|put.24| C (XQP::|get.24| XQP::|CurClause|))   (XQP::|put.term|)                                         (* \; "the following code has been simplified by assuming that the term to be stored will ALWAYS be of arity 2.  This hack is shared with the non-Xerox ports.")   (|if| (EQ XQP::|struct.tag.16| (XQP::|get.code| XQP::|CurClause| XQP::|clause.skel.head.ptr|))       |then|                                                (* \; "predicate arity > 0")             (LET ((TAG (XQP::|get.code.byte| XQP::|CurClause| XQP::|clause.skel.arg1| 0)))                                                             (* \; "get arg 1 tag")                  (SELECTC TAG                      (XQP::|ref.tag.8|                            NIL)                      (* \; "do nothing for variables")                      (XQP::|struct.tag.8|                   (* \; "struct:  find functor")                           (LET ((XQP::FNPTR (XQP::|add.code| XQP::|CurClause|                                                    (IPLUS XQP::|clause.skel| (XQP::|get.code|                                                                                      XQP::|CurClause|                                                                           XQP::|clause.skel.arg1.low|                                                                                     )))))                                (XQP::|put.code| XQP::|CurClause| XQP::|clause.key| (\\GETBASE                                                                                            XQP::FNPTR                                                                                            0))                                (XQP::|put.code| XQP::|CurClause| XQP::|clause.key.low|                                       (\\GETBASE XQP::FNPTR 1))))                      (XQP::|list.tag.8|                     (* \; "list:  tag key as list")                           (XQP::|put.code.byte| XQP::|CurClause| XQP::|clause.key| 0 TAG))                      (PROGN                                 (* \; "everything else:")                             (|if| (ILEQ TAG XQP::|immed.tag.8|)                                 |then|                      (* \; "index SMALLPs & atoms")                                       (XQP::|put.code.ptr| XQP::|CurClause| XQP::|clause.key|                                              (XQP::|get.code.ptr| XQP::|CurClause|                                                      XQP::|clause.skel.arg1|))                                       (XQP::|put.code.byte| XQP::|CurClause| XQP::|clause.key| 0 TAG                                              )              (* \; "else not indexable"))))))   (XQP::|fast.fail|)                                        (* \;                                        "always fails to unbind any variables bound by store.skeleton")   )(XQP::|def.both.mode| XQP::|load.cur.clause| NIL (XQP::|put.32| T1 (XQP::|get.32| XQP::T0))                                                 (XQP::|put.32| XQP::T0 (XQP::|tag.stack|                                                                                XQP::|CurClause|))                                                 (XQP::|continue.reading| 0))(PUTPROPS SKEL COPYRIGHT ("Quintus Computer Systems, Inc" 1987))(DECLARE\: DONTCOPY  (FILEMAP (NIL)))STOP