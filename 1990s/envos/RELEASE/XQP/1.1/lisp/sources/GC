(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(FILECREATED "25-Jun-87 16:46:58" {ERIS}<PROLOGCORE>LYRIC>LISP>GC.\;5 14620        |previous| |date:| "25-Jun-87 09:35:41" {ERIS}<PROLOGCORE>LYRIC>LISP>GC.\;4); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(PRETTYCOMPRINT GCCOMS)(RPAQQ GCCOMS ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>GC.LSP;1, loaded 16-Jun-87 17:46:31")                                   (* |;;| "SCCS   : @(#)GC.LSP	8203.1 3/6/87 File   : $xerox/gc.lsp Author : Richard A. O'Keefe Purpose: Provide a hook so the Lisp GC can see the Prolog stacks.")               (* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")               (* |;;;| "The function (\\GCSCANPROLOG) is called by the InterLisp garbage collector when it wants to find references from the Lisp stack and other small volatile areas.  It checks for references to Lisp objects other than LITATOMs and SMALLPs from the Prolog registers T0 and T1.  It is not necessary at check A registers, as ADD.REF does.  We can't define it directly, and then compile it later, as the Lisp garbage collector checks for (NOT (NULL (GETD '\\GCSCANPROLOG))) instead of checking for (CCODEP (GETD '\\GCSCANPROLOG)) which would have made life simpler. Instead, we have to compile it first and then define it.  In some languages, an easy task, just compile the lambda-expression.  But not in InterLoss!  What we do now is to define \\GCSCANPROLOG\\ here, then move it to \\GCSCANPROLOG in INITIALIZE.PROLOG after we've initialised Prolog memory.")               (FUNCTIONS XQP::\\GCSCANPROLOG\\)               (VARIABLES XQP::REF.TABLE XQP::REF.COUNT XQP::REF.LIMIT)               (FUNCTIONS XQP::ADD.REF)                                   (* |;;| "(SWEEP LO HI) scans through a block of tagged cells, starting at P, and ending with Q (which *is* scanned).  So the range is [P,Q]. References are collected when they satisfy the same test that ADD.REF applies, except that since we check the tag first, there is no need to filter out LITATOMs and SMALLPs.")                                   (* |;;| "BEWARE!!  The load.choice.point instruction creates cells with tag \"other\" whose datum points into the Prolog local stack. I have verified that all such pointers satisfy the Lisp test (\\BLOCKDATAP prolog-local-stack-pointer).  If that changes, it will be necessary to add another test to SWEEP.")               (FUNCTIONS XQP::SWEEP)                                   (* |;;| "(TRIMCORE X) rebuilds the external reference hash table.  It ensures that X is safe in the new state table, so that it can be called from ADD.REF when the current table gets full.  The function is called with X=NIL from Prolog, but that's ok too, as it will be scanned but not included in the new table.")               (FUNCTIONS XQP::TRIMCORE)               (PROP MAKEFILE-ENVIRONMENT)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>GC.LSP;1, loaded 16-Jun-87 17:46:31")(* |;;| "SCCS   : @(#)GC.LSP	8203.1 3/6/87 File   : $xerox/gc.lsp Author : Richard A. O'Keefe Purpose: Provide a hook so the Lisp GC can see the Prolog stacks.")(* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")(* |;;;| "The function (\\GCSCANPROLOG) is called by the InterLisp garbage collector when it wants to find references from the Lisp stack and other small volatile areas.  It checks for references to Lisp objects other than LITATOMs and SMALLPs from the Prolog registers T0 and T1.  It is not necessary at check A registers, as ADD.REF does.  We can't define it directly, and then compile it later, as the Lisp garbage collector checks for (NOT (NULL (GETD '\\GCSCANPROLOG))) instead of checking for (CCODEP (GETD '\\GCSCANPROLOG)) which would have made life simpler. Instead, we have to compile it first and then define it.  In some languages, an easy task, just compile the lambda-expression.  But not in InterLoss!  What we do now is to define \\GCSCANPROLOG\\ here, then move it to \\GCSCANPROLOG in INITIALIZE.PROLOG after we've initialised Prolog memory.")(XQP::|def.subr| XQP::\\GCSCANPROLOG\\ NIL (|if| (AND (IGREATERP (XQP::|ReadPrologTag| XQP::T0)                                                             XQP::|immed.tag.8|)                                                      (NOT (SMALLP (XQP::|ReadPrologPtr| XQP::T0))))                                               |then|                     (* |;;| "T0 points to a collectable Lisp object. Sometimes SMALLPs have a BOXED tag.")                                                     (\\STKREF (XQP::|ReadPrologPtr| XQP::T0)))                                           (|if| (AND (IGREATERP (XQP::|ReadPrologTag| T1)                                                             XQP::|immed.tag.8|)                                                      (NOT (SMALLP (XQP::|ReadPrologPtr| T1))))                                               |then|                     (* |;;| "T1 points to a collectable Lisp object.")                                                     (\\STKREF (XQP::|ReadPrologPtr| T1))))(XQP::|def.var| XQP::REF.TABLE (HARRAY 40)                   (* \; "was 1000") )(XQP::|def.var| XQP::REF.COUNT 0)(XQP::|def.var| XQP::REF.LIMIT                               (* \; "The time to expand the table") (FIX (TIMES (HARRAYSIZE XQP::REF.TABLE)             0.8)))(XQP::|def.subr| XQP::ADD.REF (X) (|if| (NOT (OR             (* \; "don't worry about:")                                                 (LITATOM X) (* \;                                                              "symbols (Lisp doesn't collect them)")                                                 (SMALLP X)  (* \; "small integers (ditto)")                                                 (TYPENAMEP X 'XQP::PROCEDURE.RECORD)                                                 (\\BLOCKDATAP X)                                                             (* \; "our clauses")                                                 (GETHASH X XQP::REF.TABLE)                                                             (* \; "things we've already seen")                                                 ))                                      |then|                     (* |;;| "X is collectable, and not already in REF.TABLE")                                            (PUTHASH X T XQP::REF.TABLE)                                            (SETQ XQP::REF.COUNT (ADD1 XQP::REF.COUNT))                                            (|if| (IGEQ XQP::REF.COUNT XQP::REF.LIMIT)                                                |then| (XQP::TRIMCORE X)))                                  X                    (* |;;| "look like identity function")                                  )(* |;;| "(SWEEP LO HI) scans through a block of tagged cells, starting at P, and ending with Q (which *is* scanned).  So the range is [P,Q]. References are collected when they satisfy the same test that ADD.REF applies, except that since we check the tag first, there is no need to filter out LITATOMs and SMALLPs.")(* |;;| "BEWARE!!  The load.choice.point instruction creates cells with tag \"other\" whose datum points into the Prolog local stack. I have verified that all such pointers satisfy the Lisp test (\\BLOCKDATAP prolog-local-stack-pointer).  If that changes, it will be necessary to add another test to SWEEP.")(XQP::|def.subr| XQP::SWEEP (P Q TABLE COUNT) (PROG (Y)                                                L   (|if| (NOT (OR (ILESSP (\\GETBASE P 0)                                                                          XQP::|other.tag.16|)                                                                   (TYPENAMEP (SETQ Y                                                                               (\\GETBASEPTR P 0))                                                                          'XQP::PROCEDURE.RECORD)                                                                   (\\BLOCKDATAP Y)                                                                   (GETHASH Y TABLE)))                                                        |then|                     (* |;;| "Y is collectable, and not already in TABLE")                                                              (PUTHASH Y T TABLE)                                                              (SETQ COUNT (ADD1 COUNT)))                                                    (|if| (EQ P Q)                                                        |then| (RETURN COUNT))                                                    (SETQ P (\\ADDBASE P 2))                                                    (GO L)))(* |;;| "(TRIMCORE X) rebuilds the external reference hash table.  It ensures that X is safe in the new state table, so that it can be called from ADD.REF when the current table gets full.  The function is called with X=NIL from Prolog, but that's ok too, as it will be scanned but not included in the new table.")(XQP::|def.subr| XQP::TRIMCORE (X) (PROG (TABLE COUNT LIMIT)                    (* |;;| "Create the new table.")                                         (SETQ LIMIT (HARRAYSIZE XQP::REF.TABLE))                                         (SETQ TABLE (HARRAY LIMIT))                                         (SETQ COUNT 0)                    (* |;;| "dump the four A registers into their memory slots.")                                         (XQP::|put.Amem| 1 (XQP::|get.Aval| 1))                                         (XQP::|put.Amem| 2 (XQP::|get.Aval| 2))                                         (XQP::|put.Amem| 3 (XQP::|get.Aval| 3))                                         (XQP::|put.Amem| 4 (XQP::|get.Aval| 4))                    (* |;;| "trace all references from the A registers")                                         (SETQ COUNT (XQP::SWEEP (XQP::|loc.Amem| 1)                                                            (XQP::|loc.Amem| 255)                                                            TABLE COUNT))                    (* |;;| "put X in the heap")                                         (XQP::|put.cell| H 0 (XQP::|tag.other| X))                    (* |;;| "trace all references from the heap")                                         (SETQ COUNT (XQP::SWEEP XQP::|init.H| (XQP::|get.24| H)                                                            TABLE COUNT))                    (* |;;| "find the top of the stack")                                         (SETQ COUNT (XQP::SWEEP XQP::|init.E|                                                            (|if| (|before| E B)                                                                |then| (XQP::|get.24| B)                                                              |else| (XQP::|E.plus.env.size.from.CP|)                                                                  )                                                            TABLE COUNT))                    (* |;;| "!!! DANGER !!! HORROR !!! ATROCITY !!! begin")                    (* |;;| "This function works when the following statement is included.  It does not work when it is omitted.  The failure mode is that REF.LIMIT ends up set to 0, even though the expression evaluates to 896.")                    (* |;;| "(PROMPTPRINT \"\")")                    (* |;;| "!!! DANGER !!! HORROR !!! ATROCITY !!! end")                    (* |;;| "Now replace the table")                                         (SETQ XQP::REF.COUNT COUNT)                                         (SETQ XQP::REF.LIMIT                                          (|if| (GREATERP COUNT (TIMES LIMIT 0.75))                                              |then|                     (* |;;| "The table is 75% full or more.")                                                    (FIX (TIMES LIMIT 1.5))                                            |elseif| (AND (LESSP COUNT (TIMES LIMIT 0.25))                                                          (IGREATERP LIMIT 40))                                              |then|                     (* |;;| "The table is nearly empty and too big.")                                                    (FIX (TIMES LIMIT 0.7))                                            |else| LIMIT))                                         (|if| (EQ XQP::REF.LIMIT LIMIT)                                             |then| (SETQ XQP::REF.TABLE TABLE)                                           |else| (SETQ XQP::REF.TABLE (HARRAY XQP::REF.LIMIT))                                                 (MAPHASH TABLE (FUNCTION (LAMBDA (VAL KEY)                                                                            (PUTHASH KEY VAL                                                                                    XQP::REF.TABLE))))                                               )                                         (SETQ XQP::REF.LIMIT (FIX (TIMES (HARRAYSIZE XQP::REF.TABLE)                                                                          0.8))))                                   X)(PUTPROPS GC COPYRIGHT ("Quintus Computer Systems, Inc" 1987))(DECLARE\: DONTCOPY  (FILEMAP (NIL)))STOP