(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(FILECREATED "26-Jun-87 15:23:14" {ERIS}<PROLOGCORE>LYRIC>LISP>ASSERT.\;6 30442        |changes| |to:|  (FUNCTIONS XQP::ASSERT.INDEXED)      |previous| |date:| "25-Jun-87 16:47:35" {ERIS}<PROLOGCORE>LYRIC>LISP>ASSERT.\;5); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(PRETTYCOMPRINT ASSERTCOMS)(RPAQQ ASSERTCOMS ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>ASSERT.LSP;1, loaded 16-Jun-87 18:04:49")                                       (* |;;| "SCCS   : @(#)ASSERT.LSP	8203.1 3/9/87 File   : $xerox/assert.lsp Author : Richard A. O'Keefe Purpose: Add a clause to an indexed procedure")                   (* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")                   (VARIABLES XQP::INDEXP)                                                             (* \; "by default, don't index")                                       (* |;;| "Clause pointers point either to proper clauses (which start with a try.me.else, retry.me.else, trust.me.else, or just.me.else instruction) or to index blocks (which start with a try.index.else, retry.index.else, trust.index.else, or just.index.else instruction).")                   (STRUCTURES XQP::INDEX.BLOCK)                   (CONSTANTS XQP::QX.L)                                                             (* \; "List")                   (CONSTANTS XQP::QX.S)                                                             (* \; "Singleton")                   (CONSTANTS XQP::QX.C)                                                             (* \; "Crowded")                                       (* |;;| "When several clauses in an index block have the same key, there are extra linkage instructions created just for them.  There is a cell, which the index block can point to, just as if there were a get.A1.xxx instruction there, there are some linkage instructions, and there is a pointer to the last clause in the block which has this key.")                   (STRUCTURES XQP::INDEX.HEADER)                                       (* |;;| "Subsequent clauses in a cluster with the same key are linked together with index.link blocks.  Only the first has an index.header block.")                   (STRUCTURES XQP::INDEX.LINK)                                       (* |;;| "Given a procedure record, (QP.CLAUSES PROC) returns a list of all the ordinary clauses in that predicate.  Index blocks are skipped.")                   (FUNCTIONS XQP::QP.CLAUSES)                                       (* |;;| "Given a 16-bit value Tag and a 24-bit pointer Ptr, store them both at word offset Offset from pointer Base.  This is used to store tagged pointers in hash tables and to store branch instructions.")                   (FUNCTIONS XQP::|put.pair|)                                       (* |;;| "Given a clause pointer, an instruction name, and an address, store a branch instruction at the beginning of the clause.")                   (FUNCTIONS XQP::|store.branch|)                                       (* |;;| "(ADD1.INDEX BLOCK) increments the population count of a given index block.  If this count is too big for its current mask (and hence too big for its current table), a new table twice the size is allocated and the old one copied into it, and the value T is returned, indicating that any key will have to be looked up again.  Otherwise NIL is returned.  Note that the order of entries within a bucket alters but that this has no effect on the behaviour of the predicate as a whole, only on the speed with which certain keys are found.")                   (FUNCTIONS XQP::ADD1.INDEX)                                       (* |;;| "Given a clause or index.header record whose guard matches that of the new clause, add the new clause to the end of this chain. This function is now used for lists (KEY=0) and other functors (KEY=2), and the tag of the LIST slot is no longer used at all. D is the offset to be added to the header, 2 for lists, 0 else.")                   (FUNCTIONS XQP::ADD.TO.CHAIN XQP::ASSERT.INDEXED)                   (PROP MAKEFILE-ENVIRONMENT)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>ASSERT.LSP;1, loaded 16-Jun-87 18:04:49")(* |;;| "SCCS   : @(#)ASSERT.LSP	8203.1 3/9/87 File   : $xerox/assert.lsp Author : Richard A. O'Keefe Purpose: Add a clause to an indexed procedure")(* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")(XQP::|def.var| XQP::INDEXP NIL)(* \; "by default, don't index")(* |;;| "Clause pointers point either to proper clauses (which start with a try.me.else, retry.me.else, trust.me.else, or just.me.else instruction) or to index blocks (which start with a try.index.else, retry.index.else, trust.index.else, or just.index.else instruction).")(XQP::|def.struct| XQP::INDEX.BLOCK (NEXT FIXP)              (* \;                                                              "alternative address =(address.operand)") (MASK BITS 16)                                              (* \; "hash mask") (COUNT BITS 16)                                             (* \; "population") (FIRST POINTER)                                             (* \; "first clause") (LAST POINTER)                                              (* \; "last clause") (LIST POINTER)                                              (* \; "list clauses") (TABLE POINTER)                                             (* \; "the actual hash table") )(DECLARE\: EVAL@COMPILE (RPAQQ XQP::QX.L 8)(CONSTANTS XQP::QX.L))(* \; "List")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::QX.S 2048)(CONSTANTS XQP::QX.S))(* \; "Singleton")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::QX.C 32768)(CONSTANTS XQP::QX.C))(* \; "Crowded")(* |;;| "When several clauses in an index block have the same key, there are extra linkage instructions created just for them.  There is a cell, which the index block can point to, just as if there were a get.A1.xxx instruction there, there are some linkage instructions, and there is a pointer to the last clause in the block which has this key.")(XQP::|def.struct| XQP::INDEX.HEADER (CELL FIXP)             (* \; "room for a tagged cell") (LINK POINTER)                                              (* \; "the xxx.me.else instruction") (JUMP FIXP)                                                 (* \; "the jump instruction") (LAST POINTER)                                              (* \; "points to last cell of chain") )(* |;;| "Subsequent clauses in a cluster with the same key are linked together with index.link blocks.  Only the first has an index.header block.")(XQP::|def.struct| XQP::INDEX.LINK (LINK POINTER)            (* \; "the xxx.me.else instruction") (JUMP FIXP)                                                 (* \; "the jump instruction") )(* |;;| "Given a procedure record, (QP.CLAUSES PROC) returns a list of all the ordinary clauses in that predicate.  Index blocks are skipped.")(XQP::|def.subr| XQP::QP.CLAUSES (PROC CLAUSE CHAIN)                     (* |;;| "Initially, CLAUSE and CHAIN are ARITY and MODULE.") (|if| (NOT (TYPENAMEP PROC 'XQP::PROCEDURE.RECORD))     |then| (SETQ PROC (XQP::LOCAL.PREDICATE PROC (OR CLAUSE 0)                              (OR CHAIN 'XQP::|si|)))) (SETQ CHAIN NIL) (SETQ CLAUSE (XQP::PROC.CLAUSES PROC)) (|until| (ATOM CLAUSE)        (|if| (TYPENAMEP CLAUSE 'XQP::INDEX.BLOCK)            |then| (SETQ CLAUSE (|fetch| (XQP::INDEX.BLOCK FIRST) |of| CLAUSE))          |else| (SETQ CHAIN (CONS CLAUSE CHAIN))                (SETQ CLAUSE (\\GETBASEPTR CLAUSE 0))                (|if| (EQ CLAUSE XQP::FAILURE.CLAUSE)                    |then| (SETQ CLAUSE NIL)))) (DREVERSE CHAIN))(* |;;| "Given a 16-bit value Tag and a 24-bit pointer Ptr, store them both at word offset Offset from pointer Base.  This is used to store tagged pointers in hash tables and to store branch instructions.")(XQP::|def.open| XQP::|put.pair| (XQP::|Base| |Offset| XQP::|Tag| XQP::|Ptr|)   (\\PUTBASE XQP::|Base| |Offset| (IPLUS (\\HILOC XQP::|Ptr|)                                          XQP::|Tag|))   (\\PUTBASE XQP::|Base| (ADD1 |Offset|)          (\\LOLOC XQP::|Ptr|)))(* |;;| "Given a clause pointer, an instruction name, and an address, store a branch instruction at the beginning of the clause.")(XQP::|def.macro| XQP::|store.branch| (XQP::|Base| |Offset| XQP::|Tag| XQP::|Ptr|)   `(XQP::|put.pair| ,XQP::|Base| ,|Offset| (CONSTANT (XQP::LEFT.OP.CODE ,XQP::|Tag|))           ,XQP::|Ptr|))(* |;;| "(ADD1.INDEX BLOCK) increments the population count of a given index block.  If this count is too big for its current mask (and hence too big for its current table), a new table twice the size is allocated and the old one copied into it, and the value T is returned, indicating that any key will have to be looked up again.  Otherwise NIL is returned.  Note that the order of entries within a bucket alters but that this has no effect on the behaviour of the predicate as a whole, only on the speed with which certain keys are found.")(XQP::|def.subr| XQP::ADD1.INDEX (BLOCK)   (PROG (MASK COUNT TABLE NEW BITS CHAIN K LINK NEXT)         (SETQ MASK (|fetch| (XQP::INDEX.BLOCK MASK) |of| BLOCK))         (SETQ COUNT (|fetch| (XQP::INDEX.BLOCK COUNT) |of| BLOCK))         (|replace| (XQP::INDEX.BLOCK COUNT) |of| BLOCK |with| (ADD1 COUNT))         (|if| (ILEQ COUNT MASK)             |then|                                          (* \;                                                              "if the count didn't overflow, there is")                   (RETURN NIL))                             (* \; "nothing more to do, old index &c valid the old mask was 2^k-1, so the old count must have been 2^k.  It couldn't have been any higher.")         (SETQ COUNT (LLSH COUNT 1))         (SETQ MASK (SUB1 COUNT))         (|replace| (XQP::INDEX.BLOCK MASK) |of| BLOCK |with| MASK)         (SETQ TABLE (|fetch| (XQP::INDEX.BLOCK TABLE) |of| BLOCK))         (SETQ NEW (\\ALLOCBLOCK COUNT))         (|replace| (XQP::INDEX.BLOCK TABLE) |of| BLOCK |with| NEW)                    (* |;;| "note that this block is NOT assumed to contain pointers!")         (|until| (EQ COUNT 0)                (SETQ COUNT (IDIFFERENCE COUNT 2))                (SETQ BITS (\\GETBASE TABLE COUNT))                (|if| (IGEQ BITS XQP::QX.C)                    |then|                     (* |;;| "this entry in the old table is crowded.")                          (SETQ CHAIN (\\GETBASEPTR TABLE COUNT))                          (\\DELREF CHAIN)                          (|until| (NULL CHAIN)                                 (SETQ NEXT (|fetch| (XQP::INDEX.LINK LINK) |of| CHAIN))                                 (SETQ K (LLSH (LOGAND (\\GETBASE (\\GETBASEPTR CHAIN 2)                                                              1)                                                      MASK)                                               1))                     (* |;;|           "^^^ this is the pointer in the JUMP field. K was doubled to make it a word offset.")                                 (SETQ BITS (\\GETBASE NEW K))                                 (|if| (IGEQ BITS XQP::QX.C)                                     |then|                     (* |;;| "there is already a chain at the new place")                                           (SETQ LINK (\\GETBASEPTR NEW K))                                           (|replace| (XQP::INDEX.LINK LINK) |of| CHAIN                                              |with| (|fetch| (XQP::INDEX.LINK LINK) |of| LINK))                                           (|replace| (XQP::INDEX.LINK LINK) |of| LINK |with| CHAIN)                                   |elseif| (IGEQ BITS XQP::QX.S)                                     |then|                     (* |;;| "there was a singleton at the new place")                                           (SETQ LINK (CREATE XQP::INDEX.LINK                                                             LINK _ CHAIN))                                           (\\PUTBASEPTR LINK 2 (\\GETBASEPTR NEW K))                                           (XQP::|put.pair| NEW K XQP::QX.C LINK)                                           (\\ADDREF LINK)                                           (|replace| (XQP::INDEX.LINK LINK) |of| CHAIN |with| NIL)                                   |else|                     (* |;;| "there was nothing there")                                         (XQP::|put.pair| NEW K XQP::QX.S (\\GETBASEPTR CHAIN 2)))                                 (SETQ CHAIN NEXT))                  |elseif| (IGEQ BITS XQP::QX.S)                    |then|                     (* |;;| "this entry in the old table is a singleton")                          (SETQ LINK (\\GETBASEPTR TABLE COUNT))                          (SETQ K (LLSH (LOGAND (\\GETBASE LINK 1)                                               MASK)                                        1))                     (* |;;| "K was doubled to make it a word offset.")                          (XQP::|put.pair| NEW K XQP::QX.S LINK)                  |else|                     (* |;;| "this entry was empty, nothing to do")                        NIL))         (RETURN T)))(* |;;| "Given a clause or index.header record whose guard matches that of the new clause, add the new clause to the end of this chain. This function is now used for lists (KEY=0) and other functors (KEY=2), and the tag of the LIST slot is no longer used at all. D is the offset to be added to the header, 2 for lists, 0 else.")(XQP::|def.subr| XQP::ADD.TO.CHAIN (CHAIN CLAUSE KEY D)   (PROG (LINK HEAD)         (SETQ LINK (CREATE XQP::INDEX.LINK))         (\\ADDREF LINK)         (XQP::|store.branch| LINK 0 'XQP::|trust.me.else| XQP::FAILURE.CLAUSE)         (XQP::|store.branch| LINK 2 'XQP::|jump.to| (\\ADDBASE (\\ADDBASE CLAUSE 3)                                                            KEY))         (|if| (TYPENAMEP CHAIN 'XQP::INDEX.HEADER)             |then| (SETQ CHAIN (\\ADDBASE CHAIN (MINUS D)))                   (XQP::|store.branch| (|fetch| (XQP::INDEX.HEADER LAST) |of| CHAIN)                          0                          'XQP::|retry.me.else| LINK)           |else| (SETQ HEAD (CREATE XQP::INDEX.HEADER))                     (* |;;| "The guard cell which goes into the first slot is utter rubbish for list clauses, but it is harmless rubbish.")                 (\\PUTBASE HEAD 0 (\\GETBASE CLAUSE 3))     (* \; "key")                 (\\PUTBASE HEAD 1 (\\GETBASE CLAUSE 4))     (* \; "key")                 (XQP::|store.branch| HEAD 2 'XQP::|try.me.else| LINK)                 (XQP::|store.branch| HEAD 4 'XQP::|jump.to| (\\ADDBASE CHAIN KEY))                 (\\ADDREF HEAD)                 (SETQ CHAIN HEAD))         (|replace| (XQP::INDEX.HEADER LAST) |of| CHAIN |with| LINK))   (\\ADDBASE CHAIN D))(XQP::|def.subr| XQP::ASSERT.INDEXED (PROC CLAUSE XQP::FRONT)   (PROG (KEY TABLE BLOCK LAST BITS LINK CHAIN K)                    (* |;;| "Indicate that the procedure is compiled: (this is now done by the caller!!!) (SET.PREDICATE.STATE PROC 1) KEY has values NIL : this clause has no key T   : this clause has a key at CLAUSE+[3,4] CONS: this clause has ./2 as its key LEFT.OP.CODE implicitly supplies argument \"A1\".")         (SELECTC (\\GETBASE CLAUSE 2)             ((XQP::LEFT.OP.CODE 'XQP::|get.Ai.constant|)                   (SETQ KEY T))             ((XQP::LEFT.OP.CODE 'XQP::|get.Ai.structure|)                   (SETQ KEY T))             ((XQP::LEFT.OP.CODE 'XQP::|get.Ai.list|)                   (SETQ KEY 'CONS))             (PROGN                                          (* \; "large FIXP, FLOATP, or variable")                    (SETQ KEY NIL)))         (|if| (EQ (XQP::PROC.CLAUSES PROC)                   XQP::UNDEFINED.CLAUSE)             |then| (XQP::|store.branch| CLAUSE 0 'XQP::|just.me.else| XQP::FAILURE.CLAUSE)                   (|if| KEY                       |then| (SETQ TABLE (\\ALLOCBLOCK 1))                             (|if| (EQ KEY 'CONS)                                 |then| (SETQ BLOCK                                         (CREATE XQP::INDEX.BLOCK                                                MASK _ 0                                                COUNT _ 0                                                FIRST _ CLAUSE                                                LAST _ CLAUSE                                                TABLE _ TABLE))                                       (\\PUTBASEPTR BLOCK XQP::QX.L (\\ADDBASE CLAUSE 3))                               |elseif| KEY                                 |then| (XQP::|put.pair| TABLE 0 XQP::QX.S (\\ADDBASE CLAUSE 3))                                       (SETQ BLOCK                                        (CREATE XQP::INDEX.BLOCK                                               MASK _ 0                                               COUNT _ 1                                               FIRST _ CLAUSE                                               LAST _ CLAUSE                                               TABLE _ TABLE))                                       (\\PUTBASEPTR BLOCK XQP::QX.L XQP::FAILURE.CLAUSE))                             (\\ADDREF BLOCK)                     (* |;;| "We have to note the reference to this block explicitly, as Lisp isn't told that procedure records contain ptrs.")                             (XQP::|store.branch| BLOCK 0 'XQP::|just.index.else| XQP::FAILURE.CLAUSE                                    )                             (SETQ CLAUSE BLOCK))                   (CL:SETF (XQP::PROC.CLAUSES PROC)                          CLAUSE)                   (CL:SETF (XQP::PROC.LASTCLAUSE PROC)                          CLAUSE)           |elseif| XQP::FRONT             |then| (SHOULDNT "c_asserta is not implemented yet")           |else|                    (* |;;| "add clause at end of predicate")           (XQP::|store.branch| CLAUSE 0 'XQP::|trust.me.else| XQP::FAILURE.CLAUSE)           (SETQ LAST (XQP::PROC.LASTCLAUSE PROC))           (|if| (NOT (TYPENAMEP LAST 'XQP::INDEX.BLOCK))               |then|                     (* |;;| "add a clause after an unkeyed clause.")                     (|if| KEY                         |then| (SETQ TABLE (\\ALLOCBLOCK 1))                               (|if| (EQ KEY 'CONS)                                   |then| (SETQ BLOCK                                           (CREATE XQP::INDEX.BLOCK                                                  MASK _ 0                                                  COUNT _ 0                                                  FIRST _ CLAUSE                                                  LAST _ CLAUSE                                                  TABLE _ TABLE))                                         (\\PUTBASEPTR BLOCK XQP::QX.L (\\ADDBASE CLAUSE 3))                                 |elseif| KEY                                   |then| (XQP::|put.pair| TABLE 0 XQP::QX.S (\\ADDBASE CLAUSE 3))                                         (SETQ BLOCK                                          (CREATE XQP::INDEX.BLOCK                                                 MASK _ 0                                                 COUNT _ 1                                                 FIRST _ CLAUSE                                                 LAST _ CLAUSE                                                 TABLE _ TABLE))                                         (\\PUTBASEPTR BLOCK XQP::QX.L XQP::FAILURE.CLAUSE))                               (\\ADDREF BLOCK)                     (* |;;| "The table is safe because the block references it via a field Lisp knows is a POINTER.  The block itself is NOT safe because Lisp doesn't know that linkage ops contain pointers, hence this addref. We don't initialise the LIST field in the CREATE for a similar reason, we don't want that addref done.")                               (XQP::|store.branch| BLOCK 0 'XQP::|trust.index.else|                                       XQP::FAILURE.CLAUSE)                               (SETQ CLAUSE BLOCK))                     (CL:SETF (XQP::PROC.LASTCLAUSE PROC)                            CLAUSE)             |else|                     (* |;;| "add a clause after an index block")                   (SETQ BLOCK LAST)                   (SETQ LAST (|fetch| (XQP::INDEX.BLOCK LAST) |of| BLOCK))                   (|if| (NULL KEY)                       |then| (|if| (EQ (\\GETBASEBYTE BLOCK 0)                                        (CONSTANT (XQP::OP.CODE 'XQP::|just.index.else|)))                                  |then|                     (* |;;| "just.index.else -> try.index.else")                                        (XQP::|store.branch| BLOCK 0 'XQP::|try.index.else| CLAUSE)                                |else|                     (* |;;| "trust.index.else -> retry.index.else")                                      (XQP::|store.branch| BLOCK 0 'XQP::|retry.index.else| CLAUSE))                             (CL:SETF (XQP::PROC.LASTCLAUSE PROC)                                    CLAUSE)                     |elseif| (EQ KEY 'CONS)                       |then| (|replace| (XQP::INDEX.BLOCK LAST) |of| BLOCK |with| CLAUSE)                             (SETQ CHAIN (|fetch| (XQP::INDEX.BLOCK LIST) |of| BLOCK))                             (|if| (EQ CHAIN XQP::FAILURE.CLAUSE)                                 |then|                     (* |;;| "there weren't any list clauses before")                                       (\\PUTBASEPTR BLOCK XQP::QX.L (\\ADDBASE CLAUSE 3))                               |else|                     (* |;;| "there was at least one clause, now a chain")                                     (\\PUTBASEPTR BLOCK XQP::QX.L (XQP::ADD.TO.CHAIN CHAIN CLAUSE 0                                                                           2)))                     (* |;;| "we used \\PUTBASEPTR above rather than the more obvious (replace (INDEX.BLOCK LIST) of BLOCK with (if ...)) to avoid the reference count decrement that the more beautiful code would do.")                     |else|                     (* |;;| "There is a key, and it isn't a list.")                           (|replace| (XQP::INDEX.BLOCK LAST) |of| BLOCK |with| CLAUSE)                           (SETQ TABLE (|fetch| (XQP::INDEX.BLOCK TABLE) |of| BLOCK))                     (* |;;| "There is already a hash table.")                           (SETQ K (LLSH (LOGAND (\\GETBASE CLAUSE 4)                                                (|fetch| (XQP::INDEX.BLOCK MASK) |of| BLOCK))                                         1))                     (* |;;| "K was doubled to serve as a word offset.")                           (SETQ BITS (\\GETBASE TABLE K))                           (|if| (IGEQ BITS XQP::QX.C)                               |then|                     (* |;;| "this is a crowded slot")                                     (SETQ CHAIN (\\GETBASEPTR TABLE K))                                     (|until| (NULL CHAIN)                                            (SETQ LINK (\\GETBASEPTR CHAIN 2))                                            (|if| (AND (EQ (\\GETBASE CLAUSE 3)                                                           (\\GETBASE LINK 0))                                                       (EQ (\\GETBASE CLAUSE 4)                                                           (\\GETBASE LINK 1)))                                                |then| (\\PUTBASEPTR CHAIN 2                                                              (XQP::ADD.TO.CHAIN LINK CLAUSE 2 0))                                                      (RETURN (SETQ BITS -1)))                                            (SETQ CHAIN (|fetch| (XQP::INDEX.LINK LINK) |of| CHAIN)))                             |elseif| (IGEQ BITS XQP::QX.S)                               |then|                     (* |;;| "this is a singleton slot")                                     (SETQ LINK (\\GETBASEPTR TABLE K))                                     (|if| (AND (EQ (\\GETBASE CLAUSE 3)                                                    (\\GETBASE LINK 0))                                                (EQ (\\GETBASE CLAUSE 4)                                                    (\\GETBASE LINK 1)))                                         |then| (XQP::|put.pair| TABLE K XQP::QX.S                                                       (XQP::ADD.TO.CHAIN LINK CLAUSE 2 0))                                               (SETQ BITS -1)))                           (|if| (IGEQ BITS 0)                               |then|                     (* |;;| "The previous lookup didn't find the key.")                                     (|if| (XQP::ADD1.INDEX BLOCK)                                         |then|                     (* |;;| "The table overflowed.")                                               (SETQ TABLE (|fetch| (XQP::INDEX.BLOCK TABLE)                                                              |of| BLOCK))                                               (SETQ K (LLSH (LOGAND (\\GETBASE CLAUSE 4)                                                                    (|fetch| (XQP::INDEX.BLOCK MASK)                                                                       |of| BLOCK))                                                             1))                     (* |;;| "K was doubled to serve as a word offset.")                                               (SETQ BITS (\\GETBASE TABLE K)))                                     (|if| (ILESSP BITS XQP::QX.S)                                         |then|                     (* |;;| "empty -> singleton")                                               (XQP::|put.pair| TABLE K XQP::QX.S (\\ADDBASE CLAUSE 3                                                                                         ))                                       |elseif| (ILESSP BITS XQP::QX.C)                                         |then|                     (* |;;| "singleton -> crowded")                                               (SETQ LINK (CREATE XQP::INDEX.LINK                                                                 LINK _ NIL))                                               (\\PUTBASEPTR LINK 2 (\\ADDBASE CLAUSE 3))                                               (SETQ LINK (CREATE XQP::INDEX.LINK                                                                 LINK _ LINK))                                               (\\PUTBASEPTR LINK 2 (\\GETBASEPTR TABLE K))                                               (\\ADDREF LINK)                                               (XQP::|put.pair| TABLE K XQP::QX.C LINK)                                       |else|                     (* |;;| "crowded -> crowded pattern will be 1 ... 4 3 2")                                             (SETQ CHAIN (\\GETBASEPTR TABLE K))                                             (SETQ LINK (CREATE XQP::INDEX.LINK                                                               LINK _ (|fetch| (XQP::INDEX.LINK                                                                                LINK) |of| CHAIN)))                                             (\\PUTBASEPTR LINK 2 (\\ADDBASE CLAUSE 3))                                             (|replace| (XQP::INDEX.LINK LINK) |of| CHAIN                                                |with| LINK)))))           (|if| (EQ (\\GETBASEBYTE LAST 0)                  (* \; "the linkage opcde")                     (CONSTANT (XQP::OP.CODE 'XQP::|just.me.else|)))               |then|                     (* |;;| "just.me.else -> try.me.else")                     (XQP::|store.branch| LAST 0 'XQP::|try.me.else| CLAUSE)             |else|                     (* |;;| "trust.me.else ->retry.me.else")                   (XQP::|store.branch| LAST 0 'XQP::|retry.me.else| CLAUSE)))))(PUTPROPS ASSERT COPYRIGHT ("Quintus Computer Systems, Inc" 1987))(DECLARE\: DONTCOPY  (FILEMAP (NIL)))STOP