(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "INTERLISP")(filecreated "17-Dec-87 18:15:21" {dsk}<lispfiles>dcoms>io.\;12 79864        |changes| |to:|  (functions xqp::new.stream read.number xqp::read.string xqp::read.char.escape                               xqp::read.string.list xqp::next.token xqp::hex.digit xqp::stream.tell                               xqp::stream.seek)                       (vars iocoms)      |previous| |date:| "17-Dec-87 17:30:03" {dsk}<lispfiles>dcoms>io.\;11); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(prettycomprint iocoms)(rpaqq iocoms        ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>IO.LSP;1, loaded 16-Jun-87 16:26:09")                    (* |;;| "@(#)IO.LSP	8202.1                             2/20/87 IO.LSP BAK		 ; --------------------------------------------------------; ; WARNING: This material is CONFIDENTIAL and proprietary ; to Quintus Computer Systems Inc.		 ; ; ; Copyright (C) 1985,  Quintus Computer Systems, Inc.   ; All rights reserved.					 ; ; --------------------------------------------------------; ;")                    (* |;;| "Copyright (c) 1987 by Quintus Computer Systems, Inc. All rights reserved.")        (functions xqp::do.forever xqp::hex.digit xqp::read.char.escape xqp::read.string                xqp::stream.seek xqp::stream.tell)        (structures xqp::io.record)        (variables xqp::newline.last xqp::current.input xqp::current.output input.token                xqp::io.channel.limit xqp::io.table xqp::permanent.streams xqp::standard.input                xqp::standard.output xqp::standard.error xqp::put.token.string xqp::null.atom)                                                             (* \;        "Added to hold a pointer to the bit bucket.  This is a real Interlisp stream, not a IO.RECORD")        (variables xqp::null.stream)        (functions xqp::io.channel xqp::key.check xqp::in.key.check xqp::out.key.check xqp::init.io                xqp::reset.user.streams xqp::open.read xqp::open.write xqp::open.append                xqp::open.null.write xqp::new.stream xqp::p.flush xqp::p.close xqp::close.stream                xqp::p.set.input xqp::p.set.output xqp::p.current.input xqp::p.current.output                xqp::pchar.count xqp::pline.count xqp::pline.position xqp::str.opened xqp::qp.get0                xqp::get0.2 xqp::unget0 xqp::get.char)                    (* |;;| "When TEdit must send hidden input to Prolog, the input term is made into a list of (CONS functor args), and is sent to Prolog by the function SEND.PROLOG in the file TELLEDITOR.LSP. SEND.PROLOG sends a term to Prolog by setting the global var BUFFERED.HIDDEN.INPUT to the term to be passed.  GET.STREAM no longer checks for hidden input, because the new function LOOK.FOR.EMACS.PACKET does the checking.  It is a new primitive called by Prolog at the start of each read-execute-print loop. READ.FROM.LISP, the mate of SEND.TO.PROLOG, is called to actually read the term from Lisp.  The term is never turned into a string or list of character codes, and so never has to be parsed. This should be more efficient than the old way.")        (functions xqp::get.stream xqp::qp.readccode xqp::qp.put xqp::put.2 xqp::put.stream                xqp::put.token xqp::put.token.symbol xqp::put.token.ref xqp::put.token.float                xqp::put.token.quoted xqp::put.token.simple xqp::put.token.string)        (variables xqp::saved.prompt)        (functions xqp::setprompt xqp::getprompt xqp::qp.prompt xqp::time.statistic xqp::p.alphameric                xqp::get.char.token xqp::gobble./*comment xqp::gobble.pct.comment                xqp::output.key.check xqp::input.key.check nextchar xqp::notzerop)                    (* |;;| "Now the tokenizer is written in Lisp.  This provides a substantial speedup, by avoiding the overhead of going between Prolog and Lisp so often.")        (functions xqp::next.token xqp::qp.trusted.charset read.number xqp::end.of.stream                xqp::past.end.of.file xqp::read.agglutinating xqp::read.fraction xqp::read.string.atom                xqp::read.string.list xqp::read.token.period xqp::read.var)        (prop makefile-environment)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>IO.LSP;1, loaded 16-Jun-87 16:26:09")(* |;;| "@(#)IO.LSP	8202.1                             2/20/87 IO.LSP BAK		 ; --------------------------------------------------------; ; WARNING: This material is CONFIDENTIAL and proprietary ; to Quintus Computer Systems Inc.		 ; ; ; Copyright (C) 1985,  Quintus Computer Systems, Inc.   ; All rights reserved.					 ; ; --------------------------------------------------------; ;")(* |;;| "Copyright (c) 1987 by Quintus Computer Systems, Inc. All rights reserved.")(xqp::defmacroc xqp::do.forever (&rest body) `(prog nil                                                tag ,@body                                                    (go tag)))(cl:defun xqp::hex.digit (char) (if (and (igeq char (charcode 0))                                         (ileq char (charcode 9)))                                    then (idifference char (charcode 0))                                  elseif (and (igeq char (charcode a))                                              (ileq char (charcode f)))                                    then (iplus 10 (idifference char (charcode a)))                                  elseif (and (igeq char (charcode \a))                                              (ileq char (charcode \f)))                                    then (iplus 10 (idifference char (charcode \a)))))(cl:defun xqp::read.char.escape   nil (* |;;;| "In the middle of reading a quoted thing for Prolog (delimited either by \\' or \\\"), we found a \\\\, and we know character escapes are enabled.  So we read the following character(s) and return what should be the next character code Prolog thinks it read.")(* |;;;| "Supported escape codes are:")                    (* |;;| "\\a -> audible alarm (BEL)")                    (* |;;| "\\b -> backspace (BS)")                    (* |;;| "\\t -> tab (TAB)")                    (* |;;| "\\n -> new-line")                    (* |;;| "\\v -> vertical tab (VT)")                    (* |;;| "\\f -> form-feed (FF)")                    (* |;;| "\\r -> carriage return (CR)")                    (* |;;| "\\e ->escape (ESC)")                    (* |;;| "\\d ->delete (DEL)")                    (* |;;| "\\ooo -> 1-3 octal digits (but still an 8-bit value)")                    (* |;;| "\\xhh -> 1-2 hex digits")                    (* |;;| " \\^X -> ASCII control character ^X (^? == DEL).")                    (* |;;| "\\<any layout character> is ignored.")                    (* |;;| "\\c<any layout character>* are ignored.")                    (* |;;| "\\' -> anything not listed above is returned as itself.")(* |;;;| "alphabetic case is ignored")       (let ((char (xqp::get.stream xqp::current.input)))            (|if| (and (igeq char (charcode \a))                       (ileq char (charcode \z)))                |then| (setq char (idifference char (constant (idifference (charcode \a)                                                                     (charcode a))))))            (if (eq char (charcode a))                then (charcode xqp::bell)              elseif (eq char (charcode b))                then (charcode xqp::bell)              elseif (eq char (charcode t))                then (charcode tab)              elseif (eq char (charcode n))                then (charcode eol)              elseif (eq char (charcode v))                then 11              elseif (eq char (charcode f))                then (charcode ff)              elseif (eq char (charcode r))                then (charcode cr)              elseif (eq char (charcode e))                then (charcode esc)              elseif (eq char (charcode d))                then (charcode del)              elseif (and (igeq char (charcode 0))                          (ileq char (charcode 7)))                then (let ((xqp::digit1 (idifference char (charcode 0)))                           (xqp::char2 (xqp::get.stream xqp::current.input)))                          (if (and (igeq xqp::char2 (charcode 0))                                   (ileq xqp::char2 (charcode 7)))                              then (let ((xqp::digit2 (idifference xqp::char2 (charcode 0)))                                         (xqp::char3 (xqp::get.stream xqp::current.input)))                                        (if (and (igeq xqp::char3 (charcode 0))                                                 (ileq xqp::char3 (charcode 7)))                                            then (iplus (idifference xqp::char3 (charcode 0))                                                        (llsh xqp::digit2 3)                                                        (llsh xqp::digit1 6))                                          else (xqp::unget0 xqp::char3)                                               (iplus xqp::digit2 (llsh xqp::digit1 3))))                            else (xqp::unget0 xqp::char2)                                 xqp::digit1))              elseif (eq char (charcode x))                then (let* ((xqp::char2 (xqp::get.stream xqp::current.input))                            (xqp::digit1 (xqp::hex.digit xqp::char2)))                           (if xqp::digit1                               then (let* ((xqp::char3 (xqp::get.stream xqp::current.input))                                           (xqp::digit2 (xqp::hex.digit xqp::char3)))                                          (if xqp::digit2                                              then (iplus xqp::digit2 (llsh xqp::digit1 4))                                            else (xqp::unget0 xqp::char3)                                                 xqp::digit1))                             else (xqp::unget0 xqp::char2)                                  0))              elseif (eq char (charcode ^))                |then| (logand 127 (idifference (logand 31 (iplus (xqp::get.stream xqp::current.input                                                                         )                                                                  1))                                          1))              |elseif| (or (eq char (charcode sp))                           (eq char (charcode tab))                           (eq char (charcode eol)))                then nil              elseif (eq char (charcode c))                then (bind ch do (setq ch (xqp::get.stream xqp::current.input))                        repeatwhile (or (eq ch (charcode sp))                                        (eq ch (charcode tab))                                        (eq ch (charcode eol))) finally (xqp::unget0 ch)                                                                      (return nil))              else char)))(defmacro xqp::read.string (xqp::quotechar) (* |;;;| "This macro is a bizzare way to try to share code for two different loops.  The structure of the two loops is the same, but the initialization, iteration, and result code are different.") (let ((xqp::setupcode                                       (* \;                                                  "code to set up GLOBAL data structures for the read")              nil)       (xqp::setuploopcode                                   (* \;                                                              "code to set up LOCAL data structures")              nil)       (xqp::loopcode                                        (* \;                                                      "code to store each character in the order seen")              nil)       (xqp::resultcode                                      (* \;                                                              "code to extract and return the result")              nil))      (if (eq xqp::quotechar '\')          then (setq xqp::setupcode `((setq xqp::byte.buffer.length 0)                                      (setq xqp::byte.buffer.has.fatchars nil)))               (setq xqp::setuploopcode nil)               (setq xqp::loopcode `((rplcharcode xqp::byte.buffer (setq xqp::byte.buffer.length                                                                    (iplus xqp::byte.buffer.length 1)                                                                    )                                            thischar)                                     (|if| (igreaterp thischar \\maxthinchar)                                         |then| (setq xqp::byte.buffer.has.fatchars t))))               (setq xqp::resultcode `((xqp::intern.symbol)))        elseif (eq xqp::quotechar '\")          then (setq xqp::setupcode nil)               (setq xqp::setuploopcode `((buffer _ (cons))))               (setq xqp::loopcode `((tconc buffer thischar)))               (setq xqp::resultcode `((car buffer)))        else (error "Invalid Prolog quote character" xqp::quotechar))                    (* |;;| "Ok, here's the actual loop.  Note we must contrive not to test of the end-of-string character when we've just read an escaped character, since users may want to escape a quote character.")      `(progn ,@xqp::setupcode (|bind| thischar ,@xqp::setuploopcode                                  |while| (and (neq (chartype (setq thischar (xqp::get.stream                                                                                    xqp::current.input                                                                                    )))                                                    'xqp::|end_of_file|)                                               (or (and (eq thischar (charcode \\))                                                        (neq 0 xqp::character.escapes)                                                        (setq thischar (xqp::read.char.escape))                                                             (* \;                                       "returns NIL when we read a sequence to be ignored (e.g., \\c)")                                                        t    (* \; "but keep looping regardless")                                                        )                                                   (neq thischar (charcode ,xqp::quotechar))                                                   (eq (setq thischar (xqp::get.stream                                                                              xqp::current.input))                                                       (charcode ,xqp::quotechar))))                                  |do| (if thischar                                           then ,@xqp::loopcode) |finally| (xqp::unget0 thischar)                                                                       (return ,@xqp::resultcode)))))(xqp::defunc xqp::stream.seek (xqp::streamnum charpos linenum xqp::linepos)   (let ((strm (elt xqp::io.table (logand xqp::streamnum 31))))        (cl:setf (xqp::qio.charpos strm)               charpos)        (cl:setf (xqp::qio.linenum strm)               linenum)        (cl:setf (xqp::qio.linepos strm)               xqp::linepos)        (setfileptr (xqp::qio.stream strm)               charpos)))(xqp::defunc xqp::stream.tell (xqp::streamnum) (let ((strm (elt xqp::io.table (logand xqp::streamnum                                                                                      31))))                                                    (cl:values (xqp::qio.charpos strm)                                                           (xqp::qio.linenum strm)                                                           (xqp::qio.linepos strm))))(xqp::defrecord xqp::io.record datatype xqp::qio.stream      (* \; "actual Interlisp stream object")                                     xqp::qio.name           (* \;                                                  "string associated with stream.  (Usually filename)")                                     xqp::qio.pushback       (* \;                                                              "one deep queue of unget characters")                                     (xqp::qio.charpos fixp) (* \;                                                              "total characters so far on this stream")                                     (xqp::qio.linenum fixp) (* \;                                                              "total lines so far on this stream")                                     (xqp::qio.linepos fixp) (* \;                                                         "total characters so far on the current line")                                     (xqp::qio.key fixp)     (* \;                                                            "\"high level\" unique integer for stream")                                     (xqp::qio.channel fixp) (* \;                                                 "\"low level\" index - corresponds to array position")                                     (xqp::qio.mode nil)     (* \;                                                 "one of READ, WRITE, APPEND, NIL (available channel)")                                     xqp::qio.eof            (* \;                                                    "is T iff the stream has (previously) reached EOF")                                     )(xqp::|def.global| xqp::newline.last )(xqp::|def.global| xqp::current.input )(xqp::|def.global| xqp::current.output )(defglobalvar input.token )(xqp::|def.global| xqp::io.channel.limit )(xqp::|def.global| xqp::io.table )(xqp::|def.global| xqp::permanent.streams )(xqp::|def.global| xqp::standard.input )(xqp::|def.global| xqp::standard.output )(xqp::|def.global| xqp::standard.error )(xqp::|def.global| xqp::put.token.string )(xqp::|def.global| xqp::null.atom )(* \; "Added to hold a pointer to the bit bucket.  This is a real Interlisp stream, not a IO.RECORD")(xqp::|def.global| xqp::null.stream )(xqp::defmacroc xqp::io.channel (number) `(elt xqp::io.table ,number))(xqp::defmacroc xqp::key.check (key xqp::channel error)   `(cond       ((or (lessp ,xqp::channel 0)            (greaterp ,xqp::channel 19)            (neq (xqp::qio.key (xqp::io.channel ,xqp::channel))                 ,key))        (xqp::nerror ,error ,key))))(xqp::defmacroc xqp::in.key.check (key xqp::channel error)   `(progn (xqp::key.check ,key ,xqp::channel ,error)           (cond              ((neq (xqp::qio.mode (xqp::io.channel ,xqp::channel))                    'read)               (xqp::nerror ,error ,key)))))(xqp::defmacroc xqp::out.key.check (key xqp::channel error)   `(progn (xqp::key.check ,key ,xqp::channel ,error)           (cond              ((eq (xqp::qio.mode (xqp::io.channel ,xqp::channel))                   'read)               (xqp::nerror ,error ,key)))))(xqp::defunc xqp::init.io nil (setq xqp::buffered.hidden.input nil)                              (setq xqp::null.atom (mkatom ""))                                                             (* \; "Prolog's   ''")                              (setq xqp::put.token.string (allocstring 100))                                                             (* \; "a scratch string")                              (setq xqp::newline.last nil)   (* \;                              "Value is T if the last character output was a newline.  NIL otherwise.")                              (setq xqp::io.channel.limit 20)(* \; "maximum number of open streams")                              (setq xqp::io.table (array xqp::io.channel.limit 'pointer nil 0))                              (for i from 3 to (sub1 xqp::io.channel.limit)                                 do (seta xqp::io.table i                                          (create xqp::io.record                                                 xqp::qio.channel _ i                                                 xqp::qio.key _ 0                                                 xqp::qio.pushback _ nil                                                 xqp::qio.charpos _ 0                                                 xqp::qio.linenum _ 0                                                 xqp::qio.linepos _ 0)))                              (setq xqp::standard.input                               (create xqp::io.record                                      xqp::qio.key _ -1                                      xqp::qio.channel _ 0                                      xqp::qio.charpos _ 0                                      xqp::qio.linenum _ 0                                      xqp::qio.linepos _ 0                                      xqp::qio.stream _ (\\getstream t 'input)                                      xqp::qio.pushback _ nil                                      xqp::qio.name _ 'user                                      xqp::qio.mode _ 'read))                              (seta xqp::io.table 0 xqp::standard.input)                              (setq xqp::standard.output                               (create xqp::io.record                                      xqp::qio.key _ -1                                      xqp::qio.channel _ 1                                      xqp::qio.charpos _ 0                                      xqp::qio.linenum _ 0                                      xqp::qio.linepos _ 0                                      xqp::qio.stream _ (\\getstream t 'output)                                      xqp::qio.pushback _ nil                                      xqp::qio.name _ 'user                                      xqp::qio.mode _ 'write))                              (seta xqp::io.table 1 xqp::standard.output)                              (setq xqp::standard.error                               (create xqp::io.record                                      xqp::qio.key _ -1                                      xqp::qio.channel _ 2                                      xqp::qio.charpos _ 0                                      xqp::qio.linenum _ 0                                      xqp::qio.linepos _ 0                                      xqp::qio.stream _ (\\getstream t 'output)                                      xqp::qio.pushback _ nil                                      xqp::qio.name _ 'xqp::user_error                                      xqp::qio.mode _ 'write))                              (seta xqp::io.table 2 xqp::standard.error)                              (setq xqp::current.input xqp::standard.input)                              (setq xqp::current.output xqp::standard.output)                              (setq xqp::permanent.streams (list xqp::standard.input                                                                  xqp::standard.output                                                                  xqp::standard.error))                              (setq xqp::null.stream (openstream '{null} 'output))                              t)(xqp::defunc xqp::reset.user.streams nil (cl:setf (xqp::qio.stream xqp::standard.input)                                                (\\getstream t 'input))                                         (cl:setf (xqp::qio.stream xqp::standard.output)                                                (\\getstream t 'output))                                         (cl:setf (xqp::qio.stream xqp::standard.error)                                                (\\getstream t 'output)))(xqp::defunc xqp::open.read (filename key) (cl:multiple-value-bind (structure status)                                                  (xqp::new.stream filename 'read)                                                  (cond                                                     ((eq status 0)                                                      (cl:setf (xqp::qio.key structure)                                                             key)                                                      (cl:values status (xqp::qio.channel structure))                                                      )                                                     (t (cl:values status nil)))))(xqp::defunc xqp::open.write (filename key) (cl:multiple-value-bind (structure status)                                                   (xqp::new.stream filename 'write)                                                   (cond                                                      ((eq status 0)                                                       (cl:setf (xqp::qio.key structure)                                                              key)                                                       (cl:values status (xqp::qio.channel structure)                                                              ))                                                      (t (cl:values status nil)))))(xqp::defunc xqp::open.append (filename key) (cl:multiple-value-bind (structure status)                                                    (xqp::new.stream filename 'append)                                                    (cond                                                       ((eq status 0)                                                        (cl:setf (xqp::qio.key structure)                                                               key)                                                        (cl:values status (xqp::qio.channel structure                                                                                 )))                                                       (t (cl:values status nil)))))(xqp::defunc xqp::open.null.write (key) (cl:multiple-value-bind (structure status)                                               (xqp::new.stream '{null} 'null)                                               (cond                                                  ((eq status 0)                                                   (cl:setf (xqp::qio.key structure)                                                          key)                                                   (cl:values status (xqp::qio.channel structure)))                                                  (t (cl:values status nil)))))(xqp::defunc xqp::new.stream (name mode)   (|bind| xqp::struct xqp::realstream |for| str |from| 3 |to| 19      |until| (null (|fetch| xqp::qio.mode |of| (setq xqp::struct (elt xqp::io.table str))))      |finally|      (return (|if| (<= str 19)                  |then|                                     (* \;                                                     "STR is the place in the table to put the stream")(* |;;;| "The Prolog code is not smart enough to get a stream here, so there's no point for this code, for now.  Someday...")(* |;;;| "(|if| (streamp name) |then| (setq realstream name) (|if| (eq mode 'read) |then| (|replace| (stream endofstreamop) |of| realstream |with| #'end.of.stream)) |else| ...)")                        (condition-case                         (progn (selectq mode                                    (read (|if| (streamp (setq xqp::realstream (openstream                                                                                name                                                                                'input)))                                              |then| (|replace| (stream endofstreamop) |of|                                                                                       xqp::realstream                                                        |with| #'xqp::end.of.stream)))                                    (write (|if| (streamp (setq xqp::realstream (openstream                                                                                 name                                                                                 'output)))                                               |then| (|replace| (stream linelength) |of|                                                                                       xqp::realstream                                                         |with| max.smallp)))                                    (append (setq xqp::realstream (openstream name 'append)))                                    (null                    (* \; "null stream is handled specially")                                          (setq xqp::realstream xqp::null.stream))                                    (shouldnt))                                (|if| (streamp xqp::realstream)                                    |then| (cl:setf (xqp::qio.stream xqp::struct)                                                  xqp::realstream)                                          (cl:setf (xqp::qio.mode xqp::struct)                                                 mode)                                          (cl:setf (xqp::qio.name xqp::struct)                                                 name)                                          (cl:setf (xqp::qio.charpos xqp::struct)                                                 0)                                          (cl:setf (xqp::qio.linenum xqp::struct)                                                 1)                                          (cl:setf (xqp::qio.linepos xqp::struct)                                                 0)                                          (cl:setf (xqp::qio.eof xqp::struct)                                                 nil)                                          (cl:values xqp::struct 0)))                         (xcl:invalid-pathname nil (cl:values nil (gethash 'xqp::io_noname                                                                          xqp::error.table)))                         (xcl:fs-protection-violation nil (cl:values nil (gethash 'xqp::io_noperm                                                                                 xqp::error.table)))                         (cl:error nil (cl:values nil (gethash 'xqp::io_nofile xqp::error.table))))                |else|                                       (* \;                                                             "There were not enough available streams")                      (cl:values nil (gethash 'xqp::io_toomany xqp::error.table))))))(xqp::defunc xqp::p.flush (key xqp::channel) (xqp::out.key.check key xqp::channel 'xqp::io_flush)                                             (flushoutput (xqp::qio.stream (elt xqp::io.table                                                                                 xqp::channel))                                                    t))(xqp::defunc xqp::p.close (key xqp::channel) (xqp::key.check key xqp::channel 'xqp::io_close)                                             (xqp::close.stream (elt xqp::io.table xqp::channel)))(xqp::defunc xqp::close.stream (stream) (cond                                           ((fmemb stream xqp::permanent.streams)                                                             (* \;                                                           "If the stream is permanent, we do nothing")                                            )                                           (t (|replace| xqp::qio.mode |of| stream |with| nil)                                              (|if| (neq (xqp::qio.stream stream)                                                         xqp::null.stream)                                                  |then| (closef? (xqp::qio.stream stream)))))                                        (cond                                           ((eq stream xqp::current.input)                                            (setq xqp::current.input xqp::standard.input))                                           ((eq stream xqp::current.output)                                            (setq xqp::current.output xqp::standard.output))))(xqp::defunc xqp::p.set.input (key xqp::channel) (xqp::in.key.check key xqp::channel 'xqp::io_setin)                                                 (setq xqp::current.input (elt xqp::io.table                                                                                xqp::channel)))(xqp::defunc xqp::p.set.output (key xqp::channel) (xqp::out.key.check key xqp::channel '                                                         xqp::io_setout)                                                  (setq xqp::current.output (elt xqp::io.table                                                                                  xqp::channel)))(xqp::defunc xqp::p.current.input nil (let ((number (xqp::qio.channel xqp::current.input))                                            (key (xqp::qio.key xqp::current.input)))                                           (cl:values number key)))(xqp::defunc xqp::p.current.output nil (let ((number (xqp::qio.channel xqp::current.output))                                             (key (xqp::qio.key xqp::current.output)))                                            (cl:values number key)))(xqp::defunc xqp::pchar.count (key xqp::channel) (xqp::key.check key xqp::channel 'xqp::io_chcount)                                                 (xqp::qio.charpos (xqp::io.channel xqp::channel)))(xqp::defunc xqp::pline.count (key xqp::channel) (xqp::key.check key xqp::channel 'xqp::io_lncount)                                                 (xqp::qio.linenum (xqp::io.channel xqp::channel)))(xqp::defunc xqp::pline.position (key xqp::channel) (xqp::key.check key xqp::channel 'xqp::io_lnpos)                                                    (xqp::qio.linepos (xqp::io.channel xqp::channel)))(xqp::defunc xqp::str.opened (xqp::chan.index)   (|bind| stream mode |for| i |from| xqp::chan.index |to| 19      |do| (setq stream (elt xqp::io.table i))           (|if| (setq mode (xqp::qio.mode stream))               |then| (return (cl:values 1 (xqp::qio.key stream)                                     (xqp::qio.channel stream)                                     (xqp::qio.name stream)                                     (selectq mode                                         (read 0)                                         (write 1)                                         (append 2)))))      |finally| (return (cl:values 0 nil nil nil nil))))(xqp::defunc xqp::qp.get0 nil (xqp::get.stream xqp::current.input))(xqp::defunc xqp::get0.2 (key xqp::channel) (xqp::in.key.check key xqp::channel 'xqp::io_get0)                                            (xqp::get.stream (elt xqp::io.table xqp::channel)))(xqp::defunc xqp::unget0 (ch)                                (* \; "The C code corresponding to this checks to make sure PUSHBACK is NIL.  (This should never happen in a properly functioning system). I've left this test out for efficiency reasons.") (cl:setf (xqp::qio.pushback xqp::current.input)        ch))(xqp::defunc xqp::get.char nil (let ((char (xqp::get.stream xqp::current.input)))                                    (cl:values (chartype char)                                           char)))(* |;;| "When TEdit must send hidden input to Prolog, the input term is made into a list of (CONS functor args), and is sent to Prolog by the function SEND.PROLOG in the file TELLEDITOR.LSP. SEND.PROLOG sends a term to Prolog by setting the global var BUFFERED.HIDDEN.INPUT to the term to be passed.  GET.STREAM no longer checks for hidden input, because the new function LOOK.FOR.EMACS.PACKET does the checking.  It is a new primitive called by Prolog at the start of each read-execute-print loop. READ.FROM.LISP, the mate of SEND.TO.PROLOG, is called to actually read the term from Lisp.  The term is never turned into a string or list of character codes, and so never has to be parsed. This should be more efficient than the old way.")(xqp::defunc xqp::get.stream (stream)                        (* \; "This is the primary input function.  All input goes through here. GET.STREAM simulates the Prolog EOF model, takes care of prompts, and maintains the line and character counts.") (let (hold (xqp::il.stream (xqp::qio.stream stream)))      (cond         ((setq hold (xqp::qio.pushback stream))          (cl:setf (xqp::qio.pushback stream)                 nil)          hold)                    (* |;;| "((QIO.EOF STREAM) (CLOSE.STREAM STREAM) (COND ((NOT (EQ STREAM STANDARD.INPUT)) (NERROR 'IO_EOF (QIO.NAME STREAM)))))")                    (* |;;| "((AND (EOFP IL.STREAM) (NEQ STREAM STANDARD.INPUT)) (INCF (QIO.CHARPOS STREAM)) (INCF (QIO.LINEPOS STREAM)) (SETF (QIO.EOF STREAM) T) -1)")         (t (cond               ((and xqp::newline.last (eq stream xqp::standard.input))                (xqp::qp.prompt)))            (let ((char (xqp::qp.readccode xqp::il.stream)))                 (cl:incf (xqp::qio.charpos stream))                 (cond                    ((eq char 13)                            (* \; "newline")                     (setq xqp::newline.last t)                     (cl:incf (xqp::qio.linenum stream))                     (cl:setf (xqp::qio.linepos stream)                            0)                     13)                    ((and (eq char 4)                        (* \; "EOF typed from terminal")                          (eq stream xqp::standard.input)                          (not (zerop xqp::editor.state)))                     (cl:incf (xqp::qio.linepos stream))                     -1)                    (t (cl:incf (xqp::qio.linepos stream))                       char)))))))(definline xqp::qp.readccode (stream) (* |;;;| " returns a 16 bit character code. \\INCHAR does the EOL conversion and this function converts to a 16 bit value") (let ((|\\RefillBufferFn| (function \\readcrefill)))      (declare (specvars |\\RefillBufferFn|))      ((lambda (cha0647 eolca0646)         (declare (localvars cha0647 eolca0646))                    (* |;;| "Subtracts number of bytes read from COUNTERVAR, which may be NIL.  In fact, should be NIL if PEEKBINFLG is T.")         (selcharq cha0647              (cr (selectc eolca0646                      (cr.eolc (charcode eol))                      (crlf.eolc (cond                                    ((eq (charcode lf)                                         (\\peekbin stream t))                                     (\\bin stream)                                     (charcode eol))                                    (t (charcode cr))))                      (charcode cr)))              (lf (cond                     ((eq eolca0646 lf.eolc)                      (charcode eol))                     (t (charcode lf))))              cha0647))       (progn (* |;;;| "returns a 16 bit character code.  SHIFTEDCSET is STREAM's char set left shifted 8, SHIFTEDCSETVAR if non-NIL is the variable to set if char set changes.  COUNTERVAR if non-NIL is decremented by number of bytes read.  Doesn't do EOL conversion -- \\INCHAR does that.")              (let ((char (\\bin stream))                    scset)                   (cond                      ((eq char nscharsetshift)              (* \; "Shifting character sets")                       (xqp::qp.trusted.charset stream (setq scset (cond                                                                      ((neq nscharsetshift                                                                            (setq char (\\bin stream)                                                                             ))                                                                       char)                                                                      ((eq 0 (\\bin stream))                                                                       \\noruncode)                                                                      (t (\\nsin.24bitencoding.error                                                                          stream)))))                       (setq char (\\bin stream))                       (setq scset (unfold scset 256)))                      (t (setq scset (unfold (let ((c-set (xqp::qp.trusted.charset stream)))                                                  (cond                                                     ((eq c-set t)                                                      255)                                                     (t c-set)))                                            256))))                   (cond                      ((eq scset (constant (unfold \\noruncode 256)))                                                             (* \;                                              "just read two bytes and combine them to a 16 bit value")                       (logor (unfold char 256)                              (\\bin stream)))                      (char (and char (logor scset char))))))       (|ffetch| eolconvention |of| stream))))(xqp::defunc xqp::qp.put (char) (xqp::put.stream xqp::current.output char))(xqp::defunc xqp::put.2 (key xqp::channel char) (xqp::out.key.check key xqp::channel 'xqp::io_put)                                                (xqp::put.stream (xqp::io.channel xqp::channel)                                                       char))(xqp::defunc xqp::put.stream (stream char) (cond                                              ((eq char 13)  (* \; "newline")                                               (cl:incf (xqp::qio.linenum stream))                                               (cl:setf (xqp::qio.linepos stream)                                                      0)                                               (cond                                                  ((eq stream xqp::standard.output)                                                   (setq xqp::newline.last t))))                                              (t (cl:incf (xqp::qio.linepos stream))                                                 (cond                                                    ((eq stream xqp::standard.output)                                                     (setq xqp::newline.last nil)))))                                           (cl:incf (xqp::qio.charpos stream))                                           (printccode char (xqp::qio.stream stream)))(xqp::|def.subr| xqp::put.token (token xqp::quoteflag) (selectq (typename token)                                                           (litatom (xqp::put.token.symbol                                                                            xqp::current.output token                                                                            xqp::quoteflag))                                                           ((smallp fixp bignum)                                                                 (xqp::put.token.simple                                                                        xqp::current.output                                                                       (mkstring token)))                                                           (floatp (xqp::put.token.float                                                                           xqp::current.output token))                                                           (nil                                                              (* \;       "Indicates something cons'd in the Prolog stack space. Can only be a variable in this context.")                                                                (xqp::put.token.ref                                                                        xqp::current.output token))                                                           (progn                     (* |;;| "Otherwise, the object is a non-Prolog object that is printed using the normal Interlisp-D print routines")                                                                  (xqp::put.token.simple                                                                          xqp::current.output                                                                         (mkstring token)))))(xqp::|def.open| xqp::put.token.symbol (stream token xqp::quoteflag)                     (* |;;| "This is an OPENLAMBDA because it is only called once.") (|if| (eq token xqp::null.atom)     |then| (|if| (neq xqp::quoteflag 0)                |then| (xqp::put.token.simple stream "''"))   |elseif| (eq token nil)     |then| (xqp::put.token.simple stream "[]")   |elseif| (eq xqp::quoteflag 0)     |then| (xqp::put.token.string stream token)   |elseif| (let ((length (nchars token)))                   (* \; "A token DOES NOT need to be quoted if  (1) QUOTEFLAG is 0; or (2) The characters are all letters, digits, and underbars, and the first character is not a capital letter, digit or underbar; or (3) The characters are all agglutinating.")                 (selectq (chartype (nthcharcode token 1))                     (xqp::|small_letter|                           (|for| i |from| 2 |to| length |always| (selectq (chartype (nthcharcode                                                                                     token i))                                                                     ((xqp::|small_letter|                                                                              xqp::|capital_letter|                                                                              xqp::|underbar|                                                                              xqp::|digit|)                                                                           t)                                                                     nil)))                     (xqp::|agglutinating|                           (|for| i |from| 2 |to| length |always| (eq (chartype (nthcharcode token i))                                                                     'xqp::|agglutinating|)))                     (progn nil)))     |then| (xqp::put.token.string stream token)   |else| (xqp::put.token.quoted stream token)))(xqp::|def.open| xqp::put.token.ref (stream token)                     (* |;;| "This is an OPENLAMBDA because it is only called once.") (xqp::put.stream stream (charcode _)) (xqp::put.token.simple stream (mkstring (iplus (llsh (idifference (\\hiloc token)                                                             (\\hiloc xqp::|membot|))                                                      15)                                                (lrsh (idifference (\\loloc token)                                                             (\\loloc xqp::|membot|))                                                      1)))))(xqp::defunc xqp::put.token.float (stream token) (let ((length (xqp::float.to.string token                                                                       xqp::put.token.string)))                                                      (for i from 1 to length                                                         do (let ((char (nthcharcode                                                                                xqp::put.token.string                                                                                i)))                                                                 (cond                                                                    ((eq char 13)                                                                     (return))                                                                    (t (xqp::put.stream stream char))                                                                    )))))(xqp::|def.open| xqp::put.token.quoted (stream string)                     (* |;;| "This is an OPENLAMBDA because it is only called once. It is called to print an atom with quotes.  This means then quotes are added fore and aft, and inner quotes are doubled. The original code printed a quote to start with, then the text, and then another quote, and added 2 to the positions. That was incorrect on two counts: internal quotes might need doubling, and if there were newlines in the string, the final positions would be one too high.") (let ((xqp::ilisp.stream (xqp::qio.stream stream)))      (xqp::put.stream stream 39)      (for i from 1 to (nchars string) do (let ((char (nthcharcode string i)))                                               (xqp::put.stream stream char)                                               (if (eq char 39)                                                   then (xqp::put.stream stream char))))      (xqp::put.stream stream 39)))(xqp::|def.subr| xqp::put.token.simple (stream string)                     (* |;;| "This is called to print a string which doesn't need quoting and doesn't contain any funny characters.  It is only used for numbers, literal strings, and things we KNOW to be safe. It is not an OPENLAMBDA because STRING is often an expr.") (prin1 string (xqp::qio.stream stream)) (let ((length (nchars string)))      (cl:incf (xqp::qio.linepos stream)             length)      (cl:incf (xqp::qio.charpos stream)             length)      (|if| (eq stream xqp::standard.output)          |then| (setq xqp::newline.last nil))))(xqp::|def.open| xqp::put.token.string (stream string)                     (* |;;| "This is called to print a string which doesn't need quoting but which might contain funny characters.  Despite being called in more than one place, it is an OPENLAMBDA because the arguments are always simple and it is called so often that efficiency matters.") (let ((length (nchars string)))      (|if| (not (strpos "" string))          |then|                                             (* \; "simple")                (prin1 string (xqp::qio.stream stream))                (cl:incf (xqp::qio.linepos stream)                       length)                (cl:incf (xqp::qio.charpos stream)                       length)                (|if| (eq stream xqp::standard.output)                    |then| (setq xqp::newline.last nil))        |else| (|for| i |from| 1 |to| length |do|            (* \; "hairy")                                                  (xqp::put.stream stream (nthcharcode string i))))))(xqp::|def.var| xqp::saved.prompt )(xqp::defunc xqp::setprompt (atom) (setq xqp::saved.prompt atom))(xqp::defunc xqp::getprompt nil xqp::saved.prompt)(xqp::defunc xqp::qp.prompt nil (xqp::put.token.simple xqp::standard.output xqp::saved.prompt))(xqp::defunc xqp::time.statistic nil (let ((xqp::prev.time xqp::previous.time)                                           (xqp::this.time (clock 0)))                                          (setq xqp::previous.time xqp::this.time)                                          (cl:values xqp::this.time (idifference xqp::this.time                                                                            xqp::prev.time))))(definline xqp::p.alphameric (char) (|bind| type |while| (or (eq (setq type (chartype char))                                                                 'xqp::|small_letter|)                                                             (eq type 'xqp::|capital_letter|)                                                             (eq type 'xqp::|digit|)                                                             (eq type 'xqp::|underbar|))                                       |do| (rplcharcode xqp::byte.buffer (setq                                                                            xqp::byte.buffer.length                                                                           (iplus                                                                               xqp::byte.buffer.length                                                                                   1))                                                   char)                                            (|if| (igreaterp char \\maxthinchar)                                                |then| (setq xqp::byte.buffer.has.fatchars t))                                            (setq char (xqp::get.stream xqp::current.input))                                       |finally| (xqp::unget0 char)))(xqp::defunc xqp::get.char.token   nil (xqp::clear.byte.buffer)       (let ((ch (xqp::get.stream xqp::current.input)))            (selectq ch                (40                                          (* \; "left parenthesis")                    (cl:values 'xqp::|individual_char| 40))                (-1 (cl:values 'xqp::|end_of_stream| -1))                (progn (xqp::unget0 ch)                       (xqp::do.forever (let* ((ch (xqp::get.stream xqp::current.input))                                               (type (chartype ch)))                                              (selectq type                                                  (xqp::|white_space|                                                        nil)                                                  (xqp::|individual_char|                                                        (selectq ch                                                           (40                                                              (* \; "left parenthesis")                                                               (xqp::unget0 40)                                                               (return (cl:values 'xqp::|white_space|                                                                               32)))                                                           (return (cl:values type ch))))                                                  (xqp::|agglutinating|                                                        (cond                                                          ((eq ch (charcode /))                                                           (let ((ch1 (xqp::get.stream                                                                              xqp::current.input)))                                                                (cond                                                                   ((eq ch1 (charcode *))                                                                    (xqp::gobble./*comment))                                                                   (t (xqp::unget0 ch1)                                                                      (return (cl:values type ch)))))                                                           )                                                          (t (return (cl:values type ch)))))                                                  (xqp::|percent|                                                        (xqp::gobble.pct.comment))                                                  (return (cl:values type ch)))))))))(xqp::defmacroc xqp::gobble./*comment nil '(xqp::do.forever (cond                                                               ((eq (xqp::get.stream                                                                            xqp::current.input)                                                                    (charcode *))                                                                (let ((ch (xqp::get.stream                                                                                  xqp::current.input))                                                                      )                                                                     (cond                                                                        ((eq ch (charcode /))                                                                         (return))                                                                        (t (xqp::unget0 ch)))))                                                               (t nil))))(xqp::defmacroc xqp::gobble.pct.comment nil '(xqp::do.forever (let ((char (xqp::get.stream                                                                                  xqp::current.input))                                                                    )                                                                   (cond                                                                      ((eq char (charcode eol))                                                                       (xqp::unget0 (charcode eol))                                                                       (return))                                                                      ((eq char -1)                                                                       (xqp::unget0 -1)                                                                       (return))                                                                      (t nil)))))(xqp::defunc xqp::output.key.check nil                       (* \;  "This is a dummy and is TEMPORARY.  It should be replaced when the error stuff has been moved over.")                                       t)(xqp::defunc xqp::input.key.check nil                        (* \;  "This is a dummy and is TEMPORARY.  It should be replaced when the error stuff has been moved over.")                                      t)(xqp::defmacroc nextchar (str) `(chcon1 (readc ,str)))(xqp::defmacroc xqp::notzerop (n) `(not (zerop ,n)))(* |;;| "Now the tokenizer is written in Lisp.  This provides a substantial speedup, by avoiding the overhead of going between Prolog and Lisp so often.")(cl:defun xqp::next.token   nil (|bind| (char _ (xqp::get.stream xqp::current.input))              (xqp::whiteskipped _ nil)          |while| (|if| (eq (chartype char)                            'xqp::|white_space|)                      |then| t                    |elseif| (eq char (charcode %))                      |then|                                 (* \; "skip % comment")                            (|do| (setq char (xqp::get.stream xqp::current.input))                               |repeatuntil| (or (eq char (charcode eol))                                                 (ileq char 0)))                            t                    |elseif| (eq char (charcode /))                      |then|                                 (* \; "might be a /* */ comment")                            (setq char (xqp::get.stream xqp::current.input))                            (|if| (eq char (charcode *))                                |then| (setq char (xqp::get.stream xqp::current.input))                                      (|do| (|until| (or (eq char (charcode *))                                                         (ileq char 0)) |do| (setq char (                                                                                      xqp::get.stream                                                                                                                                                                            xqp::current.input                                                                                         )))                                            (setq char (xqp::get.stream xqp::current.input))                                         |repeatuntil| (or (eq char (charcode /))                                                           (ileq char 0)))                                      t                              |else| (xqp::unget0 char)                                    (setq char (charcode /))                                    nil)) |do| (setq char (xqp::get.stream xqp::current.input))                                               (setq xqp::whiteskipped t)          |finally| (return (selectq (chartype char)                                (xqp::|small_letter|                                      (setq xqp::byte.buffer.length 0)                                     (setq xqp::byte.buffer.has.fatchars nil)                                     (xqp::p.alphameric char)                                     (setq input.token (xqp::intern.symbol))                                     '|atom|)                                ((xqp::|capital_letter| xqp::|underbar|)                                      (setq input.token (xqp::read.var char))                                     'xqp::|var|)                                (xqp::|agglutinating|                                      (|if| (eq char (charcode \.))                                         |then| (xqp::read.token.period)                                       |else| (setq input.token (xqp::read.agglutinating char))                                             '|atom|))                                (xqp::|digit| (setq input.token (read.number char))                                              'xqp::|integer|)                                (xqp::|single_quote|                                      (setq input.token (xqp::read.string \'))                                     '|atom|)                                (xqp::|double_quote|                                      (setq input.token (xqp::read.string \"))                                     '|string|)                                (xqp::|individual_char|                                      (|if| (and (eq char (charcode \())                                                xqp::whiteskipped)                                         |then| (setq input.token 'xqp::| (|)                                               '|individual|                                       |else| (setq input.token (character char))                                             '|individual|))                                (xqp::|individual_atom|                                      (setq input.token (character char))                                     '|atom|)                                (xqp::|end_of_stream|                                      (|if| (ileq char 0)                                         |then| (setq input.token nil)                                               'xqp::|end_of_stream|                                       |elseif| (eq char (charcode /))                                         |then| (xqp::nerror 'xqp::io_eof (xqp::qio.name                                                                                  xqp::current.input))                                           ))                                (shouldnt)))))(defmacro xqp::qp.trusted.charset (stream &optional characterset)                     (* |;;| "This is a faster, macro  version of CHARSET, a standard Lisp function.  It assumes that STREAM is indeed a stream, and so doesn't call \\GETSTREAM on it, as does CHARSET.  STREAM will be evaluated twice, so it should be variable in the call.  This is not true of CHARACTERSET.")                    (* |;;| "invoke the stream's device's get/set charset method on the stream, which will set or return the current character set for stream.")                    (* |;;| "If CHARACTERSET is either 255 or T, set the stream so that it's non run-coded, i.e., you read 2 bytes for each character read.") (if characterset     then `(let ((cset ,characterset))                (cond                   ((eq cset nscharsetshift)                    (setq cset t)))                (or (eq cset nil)                    (eq cset t)                    (and (igeq cset 0)                         (ileq cset \\maxcharset)                         (neq cset nscharsetshift))                    (\\illegal.arg cset))                (fdevop 'charsetfn (|fetch| (stream device) |of| ,stream)                       ,stream cset))   else `(fdevop 'charsetfn (|fetch| (stream device) |of| ,stream)                ,stream nil)))(cl:defun read.number (digit)   (|bind| (number _ (idifference digit (charcode 0)))          (nextchar _ (xqp::get.stream xqp::current.input))          (lst _ (list (idifference digit (charcode 0)))) |while| (and (igeq nextchar (charcode                                                                                       0))                                                                       (ileq nextchar (charcode                                                                                       9)))      |do| (setq number (iplus (itimes number 10)                               (idifference nextchar (charcode 0))))           (push lst (idifference nextchar (charcode 0)))           (setq nextchar (xqp::get.stream xqp::current.input))      |finally|      (return       (|if| (and (eq nextchar (charcode \'))                  (ileq number 36))           |then| (|if| (igeq number 1)                      |then| (|bind| xqp::thisdigit (base _ number)                                    (xqp::basedchar _ (xqp::get.stream xqp::current.input))                                |first| (setq number 0)      (* \; "start number again") |while| (igreaterp base (setq xqp::thisdigit (selectq (chartype xqp::basedchar)                                                  (xqp::|digit| (idifference xqp::basedchar                                                                       (charcode 0)))                                                  (xqp::|small_letter|                                                        (idifference xqp::basedchar                                                              (constant (idifference (charcode \a)                                                                               10))))                                                  (xqp::|capital_letter|                                                        (idifference xqp::basedchar                                                              (constant (idifference (charcode a)                                                                               10))))                                                  36))) |do| (setq number (iplus (itimes number base)                                                                                 xqp::thisdigit))                                                             (setq xqp::basedchar (xqp::get.stream                                                                                   xqp::current.input                                                                                   ))                                |finally| (xqp::unget0 xqp::basedchar)                                      (return number))                    |else|                                   (* \; "radix 0:  return ascii code of following character.  The catch is that we must consider character escapes.")                          (bind char do (if (and (eq (charcode \\)                                                     (setq char (xqp::get.stream xqp::current.input))                                                     )                                                 (neq 0 xqp::character.escapes))                                            then (setq char (xqp::read.char.escape))) repeatuntil                                                                                      char                             finally (return char)))         |else| (xqp::unget0 nextchar)               lst))))(cl:defun xqp::end.of.stream (stream) (replace (stream endofstreamop) of stream with #'                                                                                xqp::past.end.of.file                                             )                                      -1)(cl:defun xqp::past.end.of.file (stream) (|bind| xqp::struct |for| str |from| 0 |to| 19                                            |until| (eq (xqp::qio.stream (setq xqp::struct                                                                          (elt xqp::io.table str)))                                                        stream)                                            |finally| (|if| (<= str 19)                                                          |then| (xqp::close.stream xqp::struct)                                                                (|if| (neq xqp::struct                                                                            xqp::standard.input)                                                                    |then| (xqp::nerror 'xqp::io_eof                                                                                  (xqp::qio.name                                                                                   xqp::struct))))))(cl:defun xqp::read.agglutinating (firstchar) (setq xqp::byte.buffer.length 0)                                              (setq xqp::byte.buffer.has.fatchars nil)                                              (|bind| thischar _ firstchar                                                 |do| (rplcharcode xqp::byte.buffer                                                             (setq xqp::byte.buffer.length                                                              (iplus xqp::byte.buffer.length 1))                                                             thischar)                                                      (|if| (igreaterp thischar \\maxthinchar)                                                          |then| (setq xqp::byte.buffer.has.fatchars                                                                   t))                                                      (setq thischar (xqp::get.stream                                                                             xqp::current.input))                                                 |repeatwhile| (eq (chartype thischar)                                                                   'xqp::|agglutinating|)                                                 |finally| (xqp::unget0 thischar)                                                       (return (xqp::intern.symbol))))(cl:defun xqp::read.fraction (firstchar) (|bind| (char _ firstchar)                                                xqp::prevchar |collect| (setq xqp::prevchar char)                                                                    char                                            |repeatwhile| (or (and (igeq (setq char (xqp::get.stream                                                                                                                                                                        xqp::current.input                                                                                     ))                                                                         (charcode 0))                                                                   (ileq char (charcode 9)))                                                              (eq char (charcode e))                                                              (and (eq char (charcode \e))                                                                   (setq char (charcode e)))                                                              (and (or (eq char (charcode +))                                                                       (eq char (charcode -)))                                                                   (eq xqp::prevchar (charcode e))))                                            |finally| (xqp::unget0 char)))(cl:defun xqp::read.string.atom (char) (setq xqp::byte.buffer.length 0)                                       (setq xqp::byte.buffer.has.fatchars nil)                                       (|bind| thischar _ (xqp::get.stream xqp::current.input)                                          |while| (and (neq (chartype thischar)                                                            'xqp::|end_of_file|)                                                       (or (neq thischar char)                                                           (eq (setq thischar (xqp::get.stream                                                                                    xqp::current.input                                                                                     ))                                                               char)))                                          |do| (rplcharcode xqp::byte.buffer (setq                                                                               xqp::byte.buffer.length                                                                              (iplus                                                                               xqp::byte.buffer.length                                                                                      1))                                                      thischar)                                               (|if| (igreaterp thischar \\maxthinchar)                                                   |then| (setq xqp::byte.buffer.has.fatchars t))                                               (setq thischar (xqp::get.stream xqp::current.input))                                          |finally| (xqp::unget0 thischar)                                                (return (xqp::intern.symbol))))(cl:defun xqp::read.string.list (xqp::quotechar)   (cdr (|bind| char lst           |join| (cons xqp::quotechar (if (zerop xqp::character.escapes)                                           then (|bind| char |eachtime| (setq char (xqp::get.stream                                                                                                                                                                       xqp::current.input                                                                                    ))                                                   |until| (eq char xqp::quotechar) |collect| char)                                         else (|bind| char                                                 |eachtime| (setq char (xqp::get.stream                                                                               xqp::current.input))                                                       (|if| (eq char (charcode \\))                                                           |then| (setq char (xqp::read.char.escape))                                                             ) |until| (eq char xqp::quotechar)                                                 |when| char |collect| char)))           |repeatuntil| (neq (setq char (xqp::get.stream xqp::current.input))                              xqp::quotechar) |finally| (xqp::unget0 char))))(cl:defun xqp::read.token.period nil (let* ((char (xqp::get.stream xqp::current.input))                                            (type (chartype char)))                                           (selectq type                                               ((xqp::|white_space| xqp::|end_of_stream|)                                                     (xqp::unget0 char)                                                    (setq input.token nil)                                                    'xqp::|end_of_clause|)                                               (xqp::|digit| (setq input.token (xqp::read.fraction                                                                                char))                                                             'xqp::|fraction|)                                               (xqp::|agglutinating|                                                     (setq xqp::byte.buffer.length 0)                                                    (setq xqp::byte.buffer.has.fatchars nil)                                                    (xqp::put.byte (charcode \.))                                                    (setq input.token (xqp::read.agglutinating char))                                                    '|atom|)                                               (progn (xqp::unget0 char)                                                      (setq input.token '\.)                                                      '|atom|))))(cl:defun xqp::read.var (char) (|bind| type (xqp::thisnum _ char)                                      (lst _ nil)                                      (cnt _ 1)                                      (xqp::varchar _ (xqp::get.stream xqp::current.input))                                  |while| (or (eq (setq type (chartype xqp::varchar))                                                  'xqp::|small_letter|)                                              (eq type 'xqp::|capital_letter|)                                              (eq type 'xqp::|digit|)                                              (eq type 'xqp::|underbar|))                                  |do| (setq xqp::thisnum (iplus (llsh xqp::thisnum 7)                                                                 xqp::varchar))                                       (|if| (eq (setq cnt (iplus cnt 1))                                                 4)                                           |then| (setq lst (nconc1 lst xqp::thisnum))                                                 (setq cnt 0)                                                 (setq xqp::thisnum 0))                                       (setq xqp::varchar (xqp::get.stream xqp::current.input))                                  |finally| (xqp::unget0 xqp::varchar)                                        (|if| (eq cnt 0)                                            |then| (return lst)                                          |else| (return (nconc1 lst xqp::thisnum)))))(putprops io copyright ("Quintus Computer Systems, Inc" 1987))(declare\: dontcopy  (filemap (nil)))stop