(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(filecreated " 2-Dec-87 19:36:51" {dsk}<lispfiles>dcoms>toplevel.\;2 13056        |changes| |to:|  (fns xqp::run.quintus.prolog)      |previous| |date:| " 5-Oct-87 11:00:36" {dsk}<lispfiles>dcoms>toplevel.\;1); Copyright (c) 1985, 1986, 1987 by Quintus Computer Systems.  All rights reserved.(prettycomprint toplevelcoms)(rpaqq toplevelcoms (                                        (* \;                "Outer wrapper code for Prolog.  RUN.QUINTUS.PROLOG starts up the prolog interpreter.")                     (fns prolog prolog.is.ready xqp::careful.gettopval xqp::forever.do.prolog                           xqp::run.quintus.prolog xqp::signal.prolog.finished)                     (initvars (xqp::top.trace.state 1)                            (xqp::trace.state 1)                            (xqp::prolog.monitor (create.monitorlock 'xqp::|Prolog-monitor|))                            (xqp::prolog.finished.event (create.event 'xqp::|Prolog-finished-event|))                            xqp::lisp.call.prolog.goal xqp::lisp.call.prolog.result                             xqp::last.prolog.exitmode)                     (globalvars xqp::top.trace.state xqp::trace.state xqp::prolog.monitor                             xqp::lisp.call.prolog.goal xqp::lisp.call.prolog.result                             xqp::last.prolog.exitmode)                     (prop makefile-environment)))(* \; "Outer wrapper code for Prolog.  RUN.QUINTUS.PROLOG starts up the prolog interpreter.")(defineq(PROLOG  (LAMBDA (PREDICATE ARGS WAITFLG)                           (* \; "Edited  5-Oct-87 10:29 by pds")(* |;;;| "Call Xerox Quintus Prolog from INTERLISP.  PREDICATE is the predicate to call, and ARGS are the arguments to call it with.  Each occurrance of *VALUE* on ARGS then is passed to Prolog as a variable, and the bindings of those variables are returned from PROLOG as a list if PREDICATE returns.  If PREDICATE fails, NIL is returned.  If there is no *VALUE* on the list and PREDICATE succeeds, then T is returned.")(* |;;;| "If some process is running Prolog when PROLOG is called, an error is signaled unless WAITFLG it non-NIL, in which case the PROLOG waits for the running Prolog to finish.  If the running Prolog happens to be the Prolog interpreter, then an error is signaled regardless of WAITFLG.")    (|if| (OR (NULL PREDICATE)              (NOT (LITATOM PREDICATE)))        |then| (ERROR "PRED is not a symbol" PREDICATE)      |elseif| (AND ARGS (NOT (LISTP ARGS)))        |then| (ERROR "ARGLIST is not a list" ARGS)      |else| (LET ((PROC-OR-T (PROLOG.IS.READY)))                  (|if| PROC-OR-T                      |then| (|if| (PROCESSP PROC-OR-T)                                 |then| (SETQ XQP::BUFFERED.HIDDEN.INPUT (CONS PREDICATE ARGS))                                       (SETQ XQP::LAST.PROLOG.EXITMODE NIL)                                                              (* \;                                                      "indicate that Prolog hasn't really exited yet.")                                       (PROCESS.EVAL PROC-OR-T '(RETFROM 'XQP::WAIT.FOR.EVENT))                                       (TTY.PROCESS PROC-OR-T)                                       (|until| XQP::LAST.PROLOG.EXITMODE |do|                                                              (* \; "must wait until LAST.PROLOG.EXITMODE is non-NIL, since AWAIT.EVENT may return before the event is really signalled.  Sad but true.")                                                                               (AWAIT.EVENT                                                                            XQP::PROLOG.FINISHED.EVENT                                                                                      ))                               |else| (SETQ XQP::LISP.CALL.PROLOG.GOAL (CONS PREDICATE ARGS))                                     (RESETLST (|if| (NOT (OBTAIN.MONITORLOCK XQP::PROLOG.MONITOR                                                                 (NOT WAITFLG)                                                                 T))                                                   |then| (ERROR "Prolog is already running")                                                 |else| (XQP::INIT.IO)                                                       (SETQ XQP::LAST.PROLOG.EXITMODE                                                        (QP.PROLOG 'XQP::|lisp_call_prolog| 0                                                               'XQP::|si|)))))                            (|if| (EQ XQP::LAST.PROLOG.EXITMODE 3)                                |then|                       (* \;                                                            "3 means Prolog exited cleanly, via halt.")                                      (GETTOPVAL 'XQP::LISP.CALL.PROLOG.RESULT)                              |else| (ERROR "Ungraceful exit from Prolog" XQP::LAST.PROLOG.EXITMODE))                    |else| (ERROR                             "The Prolog interpreter is running, you can't call Prolog from LISP now."                                  ))))))(PROLOG.IS.READY  (LAMBDA NIL                                                (* \; "Edited  5-Sep-87 17:01 by pds")(* |;;;| "Returns non-NIL iff Prolog is ready for a call to the function PROLOG.  This means that Prolog is either waiting at the top level or in the debugger, or is not running at all.  If the Prolog toplevel is running, PROLOG.IS.READY returns the Prolog process, if no Prolog is running, returns T.")    (LET ((PROC (FIND.PROCESS XQP::PROLOG.NAME)))         (|if| XQP::AT.TOP.LEVEL             |then| PROC           |else| (NOT PROC)))))(XQP::CAREFUL.GETTOPVAL  (LAMBDA (VAR)                                              (* XQP::|pds:| "16-Jan-86 08:41")    (LET ((VAL (GETTOPVAL VAR)))         (|if| (EQ VAL 'NOBIND)             |then| (ERROR "UNBOUND ATOM" VAR)           |else| VAL))))(XQP::FOREVER.DO.PROLOG  (LAMBDA (XQP::EVENT-NUMBER)                                (* \; "Edited  5-Sep-87 16:55 by pds")(* |;;;| "Start prolog in the appropriate place given the MODE argument.  The name is really a misnomer;  it should be more like do.prolog.once.")(* |;;;| "Note that the interrupt and event handling code will RETFROM PROLOG with the appropriate exit condition.  This is the only way out of PROLOG, which, we hope, is an infinite loop.")    (XQP::|WritePrologPtrAnd0Tag| XQP::|PFCont| 0)    (SELECTQ XQP::EVENT-NUMBER        (0                                                   (* \; "NULL")           (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (1                                                   (* \; "NOTHING")           (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (2                                                   (* \; "START")           (QP.PROLOG 'XQP::|first_top_level| 0 'XQP::|si|))        (3                                                   (* \; "DIE")           'EXIT)        (4                                                   (* \; "ERROR")           (QP.PROLOG 'XQP::|error_top_level| 0 'XQP::|si|))        (5                                                   (* \; "ARITH")           (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (8                                                   (* \; "ABORT")           (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (9                                                   (* \; "REINIT")           (QP.PROLOG 'XQP::|reinit_top_level| 0 'XQP::|si|))        (10                                                  (* \; "RESTORE")            (QP.PROLOG 'XQP::|restore_top_level| 0 'XQP::|si|))        (11                                                  (* \; "OVSTACK")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (12                                                  (* \; "OVHEAP")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (13                                                  (* \; "OVTRAIL")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (14                                                  (* \; "OVPDL")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (15                                                  (* \; "OVATOMSYM")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (16                                                  (* \; "OVPROCSYM")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (17                                                  (* \; "OVCODE")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (18                                                  (* \; "BADEVAL")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (19                                                  (* \; "CONTROL_C")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (20                                                  (* \; "OVCHKHEAP")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (21                                                  (* \; "OVHEAPFUNCTOR")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (22                                                  (* \;                                                              "OVHEAPGC <this should never happen>")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (23                                                  (* \; "OVHEAPUNIFY")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (24                                                  (* \; "OVHEAPINTERPME")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (25                                                  (* \; "OVHEAPPROLOGIFY")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (26                                                  (* \; "MAYBE_GC")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (30                                                  (* \; "CLAUSE TOO BIG")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (31                                                  (* \; "CAN'T PASS TO LISP")            (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (3947188                                             (* \; "NIRVANA")                 (QP.PROLOG 'XQP::|abort_top_level| 0 'XQP::|si|))        (ERROR "Unrecognized event number" XQP::EVENT-NUMBER))))(xqp::run.quintus.prolog  (lambda (restartflg)                                       (* \; "Edited  2-Dec-87 19:35 by pds")(* |;;;| "The top level prolog interpreter kick-start function.")    (xqp::signal.prolog.finished)    (|bind| (xqp::exitmode _ (|if| restartflg                                 |then| 8                               |else| 2)) |do| (setq xqp::exitmode (setq xqp::last.prolog.exitmode                                                                    (with.monitor xqp::prolog.monitor                                                                           (xqp::forever.do.prolog                                                                            xqp::exitmode))))                                               (notify.event xqp::prolog.finished.event)       |until| (eq xqp::exitmode 3) |finally| (printout t "[ End of Prolog execution ]" t))))(XQP::SIGNAL.PROLOG.FINISHED  (LAMBDA NIL                                                (* \; "Edited  8-Sep-87 12:40 by pds")                    (* |;;| "this is a hack to tell the PROLOG function that the goal was executed properly (it may have failed, but it didn't abort).")    (SETQ XQP::LAST.PROLOG.EXITMODE 3)                    (* |;;| "Now tell PROLOG that we're done")    (NOTIFY.EVENT XQP::PROLOG.FINISHED.EVENT))))(rpaq? xqp::top.trace.state 1)(rpaq? xqp::trace.state 1)(rpaq? xqp::prolog.monitor (create.monitorlock 'xqp::|Prolog-monitor|))(rpaq? xqp::prolog.finished.event (create.event 'xqp::|Prolog-finished-event|))(rpaq? xqp::lisp.call.prolog.goal nil)(rpaq? xqp::lisp.call.prolog.result nil)(rpaq? xqp::last.prolog.exitmode nil)(declare\: doeval@compile dontcopy(globalvars xqp::top.trace.state xqp::trace.state xqp::prolog.monitor xqp::lisp.call.prolog.goal        xqp::lisp.call.prolog.result xqp::last.prolog.exitmode))(putprops toplevel copyright ("Quintus Computer Systems" 1985 1986 1987))(declare\: dontcopy  (filemap (nil (1589 12397 (prolog 1599 . 5342) (prolog.is.ready 5344 . 5935) (xqp::careful.gettopval 5937 . 6217) (xqp::forever.do.prolog 6219 . 10993) (xqp::run.quintus.prolog 10995 . 11938) (xqp::signal.prolog.finished 11940 . 12395)))))stop