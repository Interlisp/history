(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(FILECREATED "26-Jun-87 15:49:50" {ERIS}<PROLOGCORE>LYRIC>LISP>PROCS.\;7 24320        |changes| |to:|  (FUNCTIONS XQP::SET.PREDICATE.STATE XQP::MAKE.PROCEDURE.RECORD XQP::ABOLISH                               XQP::PREDINFO)      |previous| |date:| "25-Jun-87 14:41:30" {ERIS}<PROLOGCORE>LYRIC>LISP>PROCS.\;6); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(PRETTYCOMPRINT PROCSCOMS)(RPAQQ PROCSCOMS ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>PROCS.LSP;1, loaded 15-Jun-87 16:34:14")                                      (* |;;| "SCCS   : @(#)PROCS.LSP	8204.1 3/13/87 File   : $xerox/procs.lsp Authors: Bill A. Kornfeld & Richard A. O'Keefe Defines: Procedure records and procedure symbol table")                  (* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")                  (CONSTANTS XQP::EMPTY.PROC.ADDRESS)                  (* |;;;| "The layout of a procedure record is +-----------------------------------+ C+ 0    | Link to next predicate in chain   | +--------+--------+-----------------+ C+ 2    |FuncTag | Arity  |  symbol number  | +--------+--------+-----------------+ C+ 4    |AtomTag |    0   |  module number  | +--------+--------+-----------------+	 C+ 6    |  arity again as an unboxed FIXP   | +--------+--------------------------+ C+ 8    |        |  pointer to first clause | +--------+--------------------------+ C+10    |        |  pointer to last clause  | +--------+--------+-----------------+ C+12    |  flag word one  |  flag word two  | +-----------------+-----------------+ ")                  (STRUCTURES XQP::PROCEDURE.RECORD)                  (FUNCTIONS XQP::PROC.ARITY XQP::PROC.NAME XQP::PROC.MODULE XQP::PROC.CLAUSES)                  (PROP XQP::SETFDEF XQP::PROC.CLAUSES)                  (FUNCTIONS XQP::PROC.LASTCLAUSE)                  (PROP XQP::SETFDEF XQP::PROC.LASTCLAUSE)                  (FUNCTIONS XQP::PROC.HIFLAG)                  (PROP XQP::SETFDEF XQP::PROC.HIFLAG)                  (FUNCTIONS XQP::PROC.LOFLAG)                  (PROP XQP::SETFDEF XQP::PROC.LOFLAG)                  (FUNCTIONS XQP::GET.PREDICATE.STATE XQP::SET.PREDICATE.STATE XQP::PREDINFO)                                      (* |;;| "Printing a procedure record should be a very simple thing; all we have to do is write module:symbol/arity. But in InterLOSS a completely different mechanism is used when printing to a string from that used when printing to a stream. The DEFPRINT form tells InterLOSS to use this function when printing a procedure record.")                  (FUNCTIONS XQP::PROC.PRINT)                  (P (DEFPRINT 'XQP::PROCEDURE.RECORD 'XQP::PROC.PRINT))                                      (* |;;| "P.PROCEDURE just returns the name of a predicate, in the form which ASSEMBLE.CLAUSES recognises as input.  This is used, for example, in LOOK.")                  (FUNCTIONS XQP::P.PROCEDURE)                                      (* |;;| "---------------------------------------------------------------------- The following two functions are called from curpred.pl to enumerate all the atoms in the system.  They exploit the fact that atoms in InterLOSS are numbered consecutively, starting from 0 (NIL).  We start with the youngest atom, and work our way down to NIL.  This cannot diverge.  (current_predicate, alas, can.)")                  (FUNCTIONS XQP::FIRST.SYMBOL)                                                             (* \; "the last atom")                  (FUNCTIONS XQP::NEXT.SYMBOL)                                      (* |;;| "---------------------------------------------------------------------- Variables and functions for the procedure symbol table.  See procs.pl and curpred.pl.")                  (VARIABLES XQP::FIRST.PREDICATE)                                                             (* \; "start of chain")                  (VARIABLES XQP::ATOM.PREDICATE)                                                             (* \; "atom->pred")                  (VARIABLES XQP::FUNCTOR.PREDICATE)                                                             (* \; "atom/int -> pred")                  (FUNCTIONS XQP::INIT.PROCEDURES XQP::FIRST.PREDICATE XQP::ATOM.PREDICATE)                                      (* |;;| "This function looks up a NAME and ARITY in a list of (VALUE NAME . ARITY) triples.  It is like SASSOC, except that it is specialised to this task.  If the NAME and ARITY are not found, it returns EMPTY.PROC.ADDRESS")                  (FUNCTIONS XQP::QP.SASSOC XQP::FUNCTOR.PREDICATE XQP::P.CHECK.PREDICATE                          XQP::MAKE.PROCEDURE.RECORD)                                      (* |;;| "This function copies a procedure record.  The duplicate is NOT linked into the chain of procedure records.  It is only used when a compiled predicate has a spy-point placed on it. (See trap.pl for details.)  Since the record will not be linked anywhere, we have to manually adjust its ref-count.")                  (FUNCTIONS XQP::COPY.PROCEDURE.RECORD)                                      (* |;;| "This function releases a procedure record which was made by COPY.PROCEDURE.RECORD.  It is only used when a spy-point is removed from a compiled predicate.  The record won't go away until the Prolog->Lisp exit vector is next flushed.")                  (FUNCTIONS XQP::FREE.PROCEDURE.RECORD)                  (* |;;;| "Parts of this may need to be critical regions.")                  (FUNCTIONS XQP::LOCAL.PREDICATE)                                      (* |;;| "---------------------------------------------------------------------- The following four functions are for debugging, and probabily shouldn't be in the final release.")                  (FUNCTIONS XQP::QP.PREDICATE XQP::ABOLISH XQP::EMPTY.CLAUSES XQP::UNDEF)                  (PROP MAKEFILE-ENVIRONMENT)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>PROCS.LSP;1, loaded 15-Jun-87 16:34:14")(* |;;| "SCCS   : @(#)PROCS.LSP	8204.1 3/13/87 File   : $xerox/procs.lsp Authors: Bill A. Kornfeld & Richard A. O'Keefe Defines: Procedure records and procedure symbol table")(* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::EMPTY.PROC.ADDRESS 0)(CONSTANTS XQP::EMPTY.PROC.ADDRESS))(* |;;;| "The layout of a procedure record is +-----------------------------------+ C+ 0    | Link to next predicate in chain   | +--------+--------+-----------------+ C+ 2    |FuncTag | Arity  |  symbol number  | +--------+--------+-----------------+ C+ 4    |AtomTag |    0   |  module number  | +--------+--------+-----------------+	 C+ 6    |  arity again as an unboxed FIXP   | +--------+--------------------------+ C+ 8    |        |  pointer to first clause | +--------+--------------------------+ C+10    |        |  pointer to last clause  | +--------+--------+-----------------+ C+12    |  flag word one  |  flag word two  | +-----------------+-----------------+ ")(XQP::|def.struct| XQP::PROCEDURE.RECORD (LINK POINTER)      (* \; "really POINTER") (XQP::FUNCTOR FIXP)                                         (* \; "tagged functor cell") (XQP::MODULE FIXP)                                          (* \; "tagged atom cell") (XQP::ARITY FIXP)                                           (* \; "unboxed arity") (FIRST FIXP)                                                (* \; "pointer to first clause") (LAST FIXP)                                                 (* \; "pointer to last clause") (FLAGS FIXP)                                                (* \; "two 16-bit flag words") )(XQP::|def.macro| XQP::PROC.ARITY (PROC) `(\\GETBASE ,PROC 7))(XQP::|def.macro| XQP::PROC.NAME (PROC) `(\\VAG2 0 (\\GETBASE ,PROC 3)))(XQP::|def.macro| XQP::PROC.MODULE (PROC) `(\\GETBASEPTR ,PROC 4))(XQP::|def.macro| XQP::PROC.CLAUSES (PROC) `(\\GETBASEPTR ,PROC 8))(PUTPROPS XQP::PROC.CLAUSES XQP::SETFDEF (\\PUTBASEPTR DATUM 8 NEWVALUE))(XQP::|def.macro| XQP::PROC.LASTCLAUSE (PROC) `(\\GETBASEPTR ,PROC 10))(PUTPROPS XQP::PROC.LASTCLAUSE XQP::SETFDEF (\\PUTBASEPTR DATUM 10 NEWVALUE))(XQP::|def.macro| XQP::PROC.HIFLAG (PROC) `(\\GETBASE ,PROC 12))(PUTPROPS XQP::PROC.HIFLAG XQP::SETFDEF (\\PUTBASE DATUM 12 NEWVALUE))(XQP::|def.macro| XQP::PROC.LOFLAG (PROC) `(\\GETBASE ,PROC 13))(PUTPROPS XQP::PROC.LOFLAG XQP::SETFDEF (\\PUTBASE DATUM 13 NEWVALUE))(XQP::|def.macro| XQP::GET.PREDICATE.STATE (PROC) `(LOGAND (XQP::PROC.LOFLAG ,PROC)                                                          3))(XQP::|def.macro| XQP::SET.PREDICATE.STATE (PROC NEWVALUE)   `(LET ((RECORD ,PROC))         (CL:SETF (XQP::PROC.LOFLAG RECORD)                (LOGOR (LOGAND (XQP::PROC.LOFLAG RECORD)                              65532)                       ,NEWVALUE))))(XQP::|def.subr| XQP::PREDINFO (PROC) (|if| (TYPENAMEP PROC 'XQP::PROCEDURE.RECORD)                                          |then| (CL:VALUES (XQP::PROC.NAME PROC)                                                        (XQP::PROC.ARITY PROC)                                                        (XQP::PROC.MODULE PROC)                                                        (XQP::PROC.LOFLAG PROC))                                        |else|               (* \; "end of chain")                                              (CL:VALUES 0 0 0 0)))(* |;;| "Printing a procedure record should be a very simple thing; all we have to do is write module:symbol/arity. But in InterLOSS a completely different mechanism is used when printing to a string from that used when printing to a stream. The DEFPRINT form tells InterLOSS to use this function when printing a procedure record.")(XQP::|def.subr| XQP::PROC.PRINT (PROC STREAM) (|if| STREAM                                                   |then| (PRINTOUT STREAM (XQP::PROC.MODULE PROC)                                                                 ":"                                                                 (XQP::PROC.NAME PROC)                                                                 "/"                                                                 (XQP::PROC.ARITY PROC))                                                         T                                                 |else| (CONS (CONCAT (XQP::PROC.MODULE PROC)                                                                     ":"                                                                     (XQP::PROC.NAME PROC)                                                                     "/")                                                              (XQP::PROC.ARITY PROC))))(DEFPRINT 'XQP::PROCEDURE.RECORD 'XQP::PROC.PRINT)(* |;;| "P.PROCEDURE just returns the name of a predicate, in the form which ASSEMBLE.CLAUSES recognises as input.  This is used, for example, in LOOK.")(XQP::|def.subr| XQP::P.PROCEDURE (PROC) (LIST (XQP::PROC.NAME PROC)                                               (XQP::PROC.ARITY PROC)                                               (XQP::PROC.MODULE PROC)))(* |;;| "---------------------------------------------------------------------- The following two functions are called from curpred.pl to enumerate all the atoms in the system.  They exploit the fact that atoms in InterLOSS are numbered consecutively, starting from 0 (NIL).  We start with the youngest atom, and work our way down to NIL.  This cannot diverge.  (current_predicate, alas, can.)")(XQP::|def.subr| XQP::FIRST.SYMBOL NIL (\\VAG2 0 (SUB1 |\\AtomFrLst|)))(* \; "the last atom")(XQP::|def.subr| XQP::NEXT.SYMBOL (SYMBOL) (COND                                              ((NULL SYMBOL)                                               0)            (* \; "NIL is the oldest symbol")                                              (T (\\VAG2 0 (SUB1 (\\LOLOC SYMBOL))))))(* |;;| "---------------------------------------------------------------------- Variables and functions for the procedure symbol table.  See procs.pl and curpred.pl.")(XQP::|def.global| XQP::FIRST.PREDICATE )(* \; "start of chain")(XQP::|def.global| XQP::ATOM.PREDICATE )(* \; "atom->pred")(XQP::|def.global| XQP::FUNCTOR.PREDICATE )(* \; "atom/int -> pred")(XQP::|def.subr| XQP::INIT.PROCEDURES NIL (SETQ XQP::FIRST.PREDICATE XQP::EMPTY.PROC.ADDRESS)                                          (SETQ XQP::ATOM.PREDICATE (HASHARRAY 500 1.5))                                          (SETQ XQP::FUNCTOR.PREDICATE (HASHARRAY 4000 1.5)))(XQP::|def.subr| XQP::FIRST.PREDICATE NIL XQP::FIRST.PREDICATE)(XQP::|def.subr| XQP::ATOM.PREDICATE (NAME) (OR (GETHASH NAME XQP::ATOM.PREDICATE)                                                XQP::EMPTY.PROC.ADDRESS))(* |;;| "This function looks up a NAME and ARITY in a list of (VALUE NAME . ARITY) triples.  It is like SASSOC, except that it is specialised to this task.  If the NAME and ARITY are not found, it returns EMPTY.PROC.ADDRESS")(XQP::|def.subr| XQP::QP.SASSOC (NAME XQP::ARITY ALIST) (FOR X IN ALIST                                                           WHEN (AND (EQ (CADR X)                                                                         NAME)                                                                     (EQ (CDDR X)                                                                         XQP::ARITY))                                                           DO (RETURN (CAR X))                                                           FINALLY (RETURN XQP::EMPTY.PROC.ADDRESS)))(XQP::|def.subr| XQP::FUNCTOR.PREDICATE (NAME XQP::ARITY) (XQP::QP.SASSOC NAME XQP::ARITY                                                                 (GETHASH (LOGXOR (\\LOLOC NAME)                                                                                 XQP::ARITY)                                                                        XQP::FUNCTOR.PREDICATE)))(XQP::|def.subr| XQP::P.CHECK.PREDICATE (NAME XQP::ARITY XQP::MODULE)   (PROG (PROC)         (SETQ PROC (XQP::QP.SASSOC NAME XQP::ARITY (GETHASH (LOGXOR (\\LOLOC NAME)                                                                    XQP::ARITY)                                                           XQP::FUNCTOR.PREDICATE)))     L   (|if| (OR (EQ PROC XQP::EMPTY.PROC.ADDRESS)                   (NEQ (XQP::PROC.NAME PROC)                        NAME)                   (NEQ (XQP::PROC.ARITY PROC)                        XQP::ARITY))             |then| (RETURN XQP::EMPTY.PROC.ADDRESS))        (* \; "not found")         (|if| (EQ (XQP::PROC.MODULE PROC)                   XQP::MODULE)             |then| (RETURN PROC))                           (* \; "found")         (SETQ PROC (|fetch| (XQP::PROCEDURE.RECORD LINK) |of| PROC))         (GO L)))(XQP::|def.subr| XQP::MAKE.PROCEDURE.RECORD (NAME XQP::ARITY XQP::MODULE)   (LET ((RECORD (NCREATE 'XQP::PROCEDURE.RECORD)))        (\\PUTBASEPTR RECORD 0 NIL)                          (* \; "predicate chain link")        (\\PUTBASEPTR RECORD 2 NAME)        (\\PUTBASE RECORD 2 (IPLUS XQP::ARITY XQP::|symbol.tag.16|))        (\\PUTBASEPTR RECORD 4 XQP::MODULE)        (\\PUTBASE RECORD 4 XQP::|symbol.tag.16|)        (\\PUTBASE RECORD 6 0)                               (* \; "arity high bits")        (\\PUTBASE RECORD 7 XQP::ARITY)                      (* \; "arity low  bits")        (CL:SETF (XQP::PROC.CLAUSES RECORD)               XQP::UNDEFINED.CLAUSE)        (CL:SETF (XQP::PROC.LASTCLAUSE RECORD)               XQP::UNDEFINED.CLAUSE)        (CL:SETF (XQP::PROC.HIFLAG RECORD)               0)        (CL:SETF (XQP::PROC.LOFLAG RECORD)               0)        RECORD))(* |;;| "This function copies a procedure record.  The duplicate is NOT linked into the chain of procedure records.  It is only used when a compiled predicate has a spy-point placed on it. (See trap.pl for details.)  Since the record will not be linked anywhere, we have to manually adjust its ref-count.")(XQP::|def.subr| XQP::COPY.PROCEDURE.RECORD (PROC) (LET ((RECORD (NCREATE 'XQP::PROCEDURE.RECORD PROC                                                                        )))                                                        (\\ADDREF RECORD)                                                        RECORD))(* |;;| "This function releases a procedure record which was made by COPY.PROCEDURE.RECORD.  It is only used when a spy-point is removed from a compiled predicate.  The record won't go away until the Prolog->Lisp exit vector is next flushed.")(XQP::|def.subr| XQP::FREE.PROCEDURE.RECORD (PROC) (|if| (TYPENAMEP PROC 'XQP::PROCEDURE.RECORD)                                                       |then| (\\DELREF PROC)                                                     |else| (SHOULDNT 'XQP::FREE.PROCEDURE.RECORD)))(* |;;;| "Parts of this may need to be critical regions.")(XQP::|def.subr| XQP::LOCAL.PREDICATE (NAME XQP::ARITY XQP::MODULE)   (PROG (HASH RECORD PROC NEXT)         (OR XQP::ARITY (SETQQ XQP::ARITY 0))         (OR XQP::MODULE (SETQQ XQP::MODULE XQP::|si|))         (SETQ HASH (LOGXOR (\\LOLOC NAME)                           XQP::ARITY))         (SETQ RECORD (XQP::QP.SASSOC NAME XQP::ARITY (GETHASH HASH XQP::FUNCTOR.PREDICATE)))         (SETQ PROC RECORD)     L   (|if| (AND (NEQ PROC XQP::EMPTY.PROC.ADDRESS)                    (EQ (XQP::PROC.NAME PROC)                        NAME)                    (EQ (XQP::PROC.ARITY PROC)                        XQP::ARITY))             |then| (|if| (EQ (XQP::PROC.MODULE PROC)                              XQP::MODULE)                        |then| (RETURN PROC))                (* \; "found")                   (SETQ PROC (|fetch| (XQP::PROCEDURE.RECORD LINK) |of| PROC))                   (GO L)                                    (* \; "not found, keep looking"))                   (* |;;| "The (NAME ARITY MODULE) triple was not found Create a new procedure record.")         (SETQ PROC (XQP::MAKE.PROCEDURE.RECORD NAME XQP::ARITY XQP::MODULE))                    (* |;;| "Try to link it into the chain.")         (|if| (NEQ RECORD XQP::EMPTY.PROC.ADDRESS)             |then|                     (* |;;| "Stitch in after same functor/different module case")                   (|replace| (XQP::PROCEDURE.RECORD LINK) |of| PROC |with| (|fetch| (                                                                                XQP::PROCEDURE.RECORD                                                                                      LINK)                                                                               |of| RECORD))                   (|replace| (XQP::PROCEDURE.RECORD LINK) |of| RECORD |with| PROC)                   (RETURN PROC))                    (* |;;| "No predicate with this functor, so insert it in the functor hash table.")         (PUTHASH HASH (CONS (CONS PROC (CONS NAME XQP::ARITY))                             (GETHASH HASH XQP::FUNCTOR.PREDICATE))                XQP::FUNCTOR.PREDICATE)                    (* |;;| "Insert the record after first one with same name.	")         (SETQ RECORD (GETHASH NAME XQP::ATOM.PREDICATE))         (|if| (NOT (NULL RECORD))             |then|                     (* |;;| "There is a predicate with this name (other arity)")                   (SETQ XQP::ARITY (XQP::PROC.ARITY RECORD))                   (SETQ NEXT (|fetch| (XQP::PROCEDURE.RECORD LINK) |of| RECORD))                   (|while| (AND (NEQ NEXT XQP::EMPTY.PROC.ADDRESS)                                 (EQ (XQP::PROC.NAME NEXT)                                     NAME)                                 (EQ (XQP::PROC.ARITY NEXT)                                     XQP::ARITY))                          (SETQ RECORD NEXT)                          (SETQ NEXT (|fetch| (XQP::PROCEDURE.RECORD LINK) |of| NEXT)))                   (|replace| (XQP::PROCEDURE.RECORD LINK) |of| PROC |with| NEXT)                   (|replace| (XQP::PROCEDURE.RECORD LINK) |of| RECORD |with| PROC)                   (RETURN PROC))                    (* |;;| "No predicate with this name, even.")         (|replace| (XQP::PROCEDURE.RECORD LINK) |of| PROC |with| XQP::FIRST.PREDICATE)         (SETQ XQP::FIRST.PREDICATE PROC)         (PUTHASH NAME PROC XQP::ATOM.PREDICATE)         (RETURN PROC)))(* |;;| "---------------------------------------------------------------------- The following four functions are for debugging, and probabily shouldn't be in the final release.")(XQP::|def.subr| XQP::QP.PREDICATE (NAME XQP::ARITY XQP::MODULE) (|if| (LITATOM NAME)                                                                     |then| (XQP::LOCAL.PREDICATE                                                                             NAME XQP::ARITY                                                                              XQP::MODULE)                                                                   |else| NAME                                                              (* \; "had better be a procedure record")))(XQP::|def.subr| XQP::ABOLISH (NAME XQP::ARITY XQP::MODULE)  (* \;                                  "This is for debugging purposes only.  It is NOT called from Prolog") (LET ((PROC (XQP::LOCAL.PREDICATE NAME XQP::ARITY XQP::MODULE)))                                                             (* \;                                                            "Indicate that the procedure is undefined")      (CL:SETF (XQP::PROC.LOFLAG PROC)             0)                                              (* \; "forget EVERYTHING")      (CL:SETF (XQP::PROC.CLAUSES PROC)             XQP::UNDEFINED.CLAUSE)      (CL:SETF (XQP::PROC.LASTCLAUSE PROC)             XQP::UNDEFINED.CLAUSE)))(XQP::|def.subr| XQP::EMPTY.CLAUSES (PROC) (EQ (XQP::PROC.CLAUSES PROC)                                               XQP::UNDEFINED.CLAUSE))(XQP::|def.subr| XQP::UNDEF NIL (PROG (PROC)                                      (SETQ PROC XQP::FIRST.PREDICATE)                                      (|until| (NULL PROC)                                             (|if| (XQP::EMPTY.CLAUSES PROC)                                                 |then| (PRIN3 "No clauses for: ")                                                       (PRINT PROC)))))(PUTPROPS PROCS COPYRIGHT ("Quintus Computer Systems, Inc" 1987))(DECLARE\: DONTCOPY  (FILEMAP (NIL)))STOP