%   Module : negation%   Author : Richard A. O'Keefe%   Updated: 3/26/87%   Purpose: "suspicious" negation, and inequality.%   Adapted from shared code written by the same author; all changes%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved./*  This file defines a version of 'not' which checks that there are    no free variables in the goal it is given to "disprove".  Bound    variables introduced by the existential quantifier ^ or set/bag    dummy variables are accepted.  If any free variables are found,     a message is printed on the terminal and a break level entered.    It is intended purely as a debugging aid, though it shouldn't slow    interpreted code down much.  There are several other debugging    aids that you might want to use as well, particularly	unknown(_, trace)    which will detect calls to undefined predicates (as opposed to    predicates which have clauses that don't happen to match).    Note: in Dec-10 Prolog you should normally use "\+ Goal" instead    of "not(Goal)".  In C-Prolog you can use either, and would have to    do some surgery on pl/init to install this version of "not".  The    reason that I have called this predicate "not" is so that people    can choose whether to use the library predicate not/1 (in Invoca.Pl)    or this debugging one, not because I like the name.  Quintus Prolog    is like Dec-10 Prolog except that the Quintus compiler thoroughly    understands \+ (and other control structures like ->;).    Two versions of inequality are defined here.	X \= Y		is identical in effect to \+(X=Y)	X ~= Y		is "suspicious"    If you care about your programs bearing some relation to logic, you    would be better to use ~=, which succeeds if the two terms can never    become equal, fails if they can never become unequal, and in case of    doubt *warns* you.  The name of this predicate is copied from MU    Prolog, in which lovely language it will delay if it can neither    succeed nor fail just yet.  Since Dec-10, C, and Quintus Prolog do    not have the ability to delay, they produce a warning message.*/:- module(negation, [	(\=)/2,			%   unsound inequality	(~=)/2,	once/1,	(not)/1			%   new checking denial   ]).:- meta_predicate	once(0),	not(0).:- use_module(library(freevars), [	free_variables/4   ]).sccs_id('"@(#)87/03/26 not.pl	98.1"').:- op(900, fy, [not,once]).	%  same as \+:- op(700, xfx, [\=,~=]).	%  same as = or ==%   X \= Y (X does not unify with Y)%   is true when no substitution can be found to make X and Y the same.  It%   is not quite the same as true inequality: if X\=Y succeeds, then some%   difference was found, so X and Y are genuinely different, but if X\=Y%   fails that only means they can be unified NOW, it doesn't mean that a%   further instantiation can't make them different.  For example, if X &%   Y are new variables, \+(X \= Y), X = a, Y = b will succeed!  MU Prolog%   has a sound version of this called ~=; the idea is that if X and Y can%   be unified but that instantiates some variables, X ~= Y will be delayed%   until some more variables are bound.  X ~= Y will only fail when X and%   Y are identical (and in that it is like \==).  Unfortunately, this is%   not MU Prolog, so you have to put up with \='s little quirks.X \= X :- !,			%   This clause might be too eager,	fail.			%   a later binding might have changed things._ \= _.X ~= Y :-	(   X == Y, !, fail	%   identical, can't ever be different	;   X \= Y, !, true	%   can't be made the same	;   format(user_error,		'~N! Can''t yet tell whether ~p ~~= ~p~n', [X,Y]),	    break,	    fail		%   if user okays it, act like X \= Y	).not(Goal) :-	free_variables(Goal, [], [], Vars),	Vars \== [], !,	format(user_error,	    '~N! free variables ~p~n! in goal not(~p)~n', [Vars,Goal]),	break,	call(Goal),	!, fail.not(Goal) :-	call(Goal),	!, fail.not(_).%   once(Goal)%   makes Goal determinate.  In a later release of Quintus Prolog,%   this and forall/2 are likely to be macros.  You can obtain the%   effect of once(G) yourself by writing (G->true;fail).once(Goal) :-	call(Goal),	!.