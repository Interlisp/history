%   Module : lists%   Authors: Bob Welham, Lawrence Byrd, and Richard A. O'Keefe%   Updated: 3/26/87%   Defines: list processing utilities%   SeeAlso: library(flatten)%   Adapted from shared code written by the same authors; all changes%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved.:- module(lists, [	append/5,			%   List x List x List x List x List	correspond/4,			%   Elem <- List x List -> Elem	delete/3,			%   List x Elem -> List	is_list/1,			%   List ->	keys_and_values/3,		%   KeyValList -> KeyList x ValList	last/2,				%   List -> Elem	nextto/3,			%   Elem, Elem <- List	nmember/3,			%   Elem <- Set -> Integer	nth0/3,				%   Integer x List -> Elem	nth0/4,				%   Integer x List -> Elem x List	nth1/3,				%   Integer x List -> Elem	nth1/4,				%   Integer x List -> Elem x List	perm/2,				%   List -> List	perm2/4,			%   Elem x Elem -> Elem x Elem	permutation/2,			%   List <-> List	remove_dups/2,			%   List -> Set	rev/2,				%   List -> List	reverse/2,			%   List -> List	same_length/2,			%   List x List ->	same_length/3,			%   List x List x Integer ->	select/4,			%   Elem x List x Elem -> List	shorter_list/2,			%   List x List ->	subseq/3,			%   List -> List x List	subseq0/2,			%   List -> List	subseq1/2,			%   List -> List	sumlist/2			%   List -> Integer   ]).:- use_module(library(sets), [	select/3			%   *NOT* exported further.   ]),   use_module(library(types), [	must_be_integer/3   ]).:- mode	append(?, ?, ?, ?, ?),	correspond(?, +, +, ?),	delete(+, +, -),	is_list(?),	is_list_(+),	keys_and_values(?, ?, ?),	last(?, ?),	nextto(?, ?, ?),	nmember(?, +, ?),	nth0(+, +, ?),	nth0(+, ?, ?, ?),	nth1(+, +, ?),	nth1(+, ?, ?, ?),	one_longer(?, ?),	perm(?, ?),	perm2(?,?, ?,?),	remove_dups(+, ?),	rev(?, ?),	reverse(?, ?),	reverse(?, +, ?),	same_length(?, ?),	same_length(?, ?, ?),	    'same length'(+, ?, ?),	    'same length'(?, ?, +, -),	select(?, ?, ?, ?),	shorter_list(?, +),	subseq(?, ?, ?),	subseq0(+, ?),	subseq1(+, ?),	sumlist(+, ?),	sumlist(+, +, ?).sccs_id('"@(#)87/03/26 lists.pl	98.1"')./*  Several of the comments below indicate that a particular predicate    only works when a particular argument "is a proper list".  In    general, an instance of a recursively defined data type "foo" is    said to be "a proper foo" when it is a non-variable and all its    "foo" components are proper foos.  For example, consider	:- type tree(K,V) = {} | node(K,V,tree(K,V),tree(K,V)).    X is said to be "a proper tree" if X is {} or if X is node(_,_,L,R)    where both L and R are proper trees.  Similarly, X is a proper list    if and only if X is [] or X is [_|L] where L is a proper list.    The point is that a recursive procedure working its way down a    proper whatever will not be creating new structure.  The predicate    is_list/1 recognises proper lists.*/%   append(Prefix, Tail1, List1, Tail2, List2)%   is true when append(Prefix, Tail1, List1) and append(Prefix, Tail2, List2)%   are both true.  You could call append/3 twice, but that is order-%   dependent.  This will terminate if Prefix is a proper list or if%   either List1 or List2 is a proper list.append([], List1, List1, List2, List2).append([H|T], Tail1, [H|List1], Tail2, [H|List2]) :-	append(T, Tail1, List1, Tail2, List2).%   correspond(X, Xlist, Ylist, Y)%   is true when Xlist and Ylist are lists, X is an element of Xlist, Y is%   an element of Ylist, and X and Y are in similar places in their lists.%   For a similar predicate without the cut, see select/4 below.correspond(X, [X|_], [Y|_], Y) :- !.correspond(X, [_|T], [_|U], Y) :-	correspond(X, T, U, Y).%   delete(List, Elem, Residue)%   is true when List is a list, in which Elem may or may not occur, and%   Residue is a copy of List with all elements equal to Elem deleted.%   To extract a single copy of Elemn, use select(Elem, List, Residue).delete([], _, []) :- !.delete([Kill|Tail], Kill, Rest) :- !,	delete(Tail, Kill, Rest).delete([Head|Tail], Kill, [Head|Rest]) :-	delete(Tail, Kill, Rest).%   is_list(List)%   is true when List is instantiated to a list of definite length; that%   is, it is nil or a cons cell whose tail is a list of definite length.%   A variable, or a list whose final tail is a variable, will fail this%   test.is_list(List) :-	nonvar(List),	is_list_(List).is_list_([]).is_list_([_|Tail]) :-	nonvar(Tail),	is_list(Tail).%   keys_and_values({K1-V1,...,Kn-Vn], [K1,...,Kn], [V1,...,Vn])%   is true when its arguments look like the picture above.  It is meant%   for splitting a list of Key-Value pairs (such as keysort/2 wants and%   produces) into separate lists of Keys and of Values.  It may just as%   well be used for building a list of pairs from a pair of lists.   In%   fact one usually wants just the keys or just the values, but you can%   supply _ as the other argument.   For example, suppose you wanted to%   sort a list without having duplicates removed.  You could do%	keys_and_values(RawPairs, RawKeys, _),%	keysort(RawPairs, OrdPairs),%	keys_and_values(OrdPairs, OrdKeys, _).%   (In fact this operation is msort/2 and should be available somewhere.)keys_and_values([], [], []) :- !.keys_and_values([Key-Value|Pairs], [Key|Keys], [Value|Values]) :-	keys_and_values(Pairs, Keys, Values).%   last(Last, List)%   is true when List is a List and Last is its last element.  This could%   be defined as last(X,L) :- append(_, [X], L).  The hackery is to%   avoid leaving an extra choice-point when List is proper.last(Last, [Head|Tail]) :-	(   atom(Tail) -> Tail = [], Last = Head	;   Tail = [], Last = Head	% note no cut or arrow!	;   last(Last, Tail)	).%   nextto(X, Y, List)%   is true when X and Y appear side-by-side in List.  It could be written as%	nextto(X, Y, List) :- append(_, [X,Y], List).%   It may be used to enumerate successive pairs from the list.nextto(X,Y, [X,Y|_]).nextto(X,Y, [_|List]) :-	nextto(X,Y, List).%   nmember(Elem, List, Index)%   is true when Elem is the Indexth member of List.  Could be written as%	nmember(X, L, N) :- append(B, [X|_], L), length(B, M), N is M+1.%   It may be used to select a particular element, or to find where some%   given element occurs, or to enumerate the elements and indices together.%   It is now an alias for nth1/3, which should be used in new programs.nmember(Element, List, Index) :-	nth1(Index, List, Element).%   nth0(N, List, Elem) is true when Elem is the Nth member of List,%   counting the first as element 0.  (That is, throw away the first%   N elements and unify Elem with the next.)  It can be used any%   way around.%   nth1(N, List, Elem) is the same as nth0, except that it counts from%   1, that is nth(1, [H|_], H).  Note that nth1(N,L,E) and nmember(E,L,N)%   are basically the same, but nth1 should be used when N is known, and%   nmember should be used when N is not known.nth0(Index, List, Element) :-		% or Element?	integer(Index),	!,	Index >= 0,	nth0i(Index, List, Element).nth0(Index, List, Element) :-		% are we finding Index?	var(Index),	!,	nth0v(List, Element, 0, Index).nth0(Index, List, Element) :-	must_be_integer(Index, 1, nth0(Index,List,Element)).%   nth0v: find the Index of an Element in the given List.%   The Element might occur more than once, find each place.nth0v([Element|_], Element, Index, Index).nth0v([_|Tail], Element, M, Index) :-	N is M+1,	nth0v(Tail, Element, N, Index).%   nth0i: find an Element in the given List at a known Index >= 0.nth0i(0, [Head|_Tail], Head) :- !.nth0i(N, [_Head|Tail], Elem) :-	M is N-1,			% should be succ(M, N)	nth0i(M, Tail, Elem).%   nth1(Index, List, Element)%   is just like nth0 except that the counting starts at 1.nth1(Index, List, Element) :-		% or Element?	integer(Index),	!,	Index >= 1,	N is Index-1,	nth0i(N, List, Element).nth1(Index, List, Element) :-		% are we finding Index?	var(Index),	!,	nth0v(List, Element, 1, Index).nth1(Index, List, Element) :-	must_be_integer(Index, 1, nth1(Index,List,Element)).%   nth0(N, List, Elem, Rest) unifies Elem with the Nth element of List,%   counting from 0, and Rest with the other elements.  It can be used%   to select the Nth element of List (yielding Elem and Rest), or to %   insert Elem before the Nth (counting from 1) element of Rest, when%   it yields List, e.g. nth0(2, List, c, [a,b,d,e]) unifies List with%   [a,b,c,d,e].  nth1 is the same except that it counts from 1.  nth1/4%   can be used to insert Elem after the Nth element of Rest.nth0(Index, List, Elem, Rest) :-	integer(Index),	!,	Index >= 0,	nth0i(Index, List, Elem, Rest).nth0(Index, List, Elem, Rest) :-	var(Index),	!,	one_longer(List, Rest),	nth0v(List, Elem, 0, Index, Rest).nth0(Index, List, Elem, Rest) :-	must_be_integer(Index, 1, nth0(Index,List,Elem,Rest)).nth0i(0, [Head|Tail], Head, Tail) :- !.nth0i(N, [Head|Tail], Elem, [Head|Rest]) :-	M is N-1,		% succ(M, N); should fail if N < 1	nth0i(M, Tail, Elem, Rest).nth0v([Head|Tail], Head, Index, Index, Tail).nth0v([Head|Tail], Elem, M, Index, [Head|Rest]) :-	N is M+1,	nth0v(Tail, Elem, N, Index, Rest).nth1(Index, List, Elem, Rest) :-	integer(Index),	!,	Index >= 1,	N is Index-1,	nth0i(N, List, Elem, Rest).nth1(Index, List, Elem, Rest) :-	var(Index),	!,	one_longer(List, Rest),	nth0v(List, Elem, 1, Index, Rest).nth1(Index, List, Elem, Rest) :-	must_be_integer(Index, 1, nth1(Index,List,Elem,Rest)).%   one_longer(Longer, Shorter)%   is true when length(Longer,N) & length(Shorter,M) & succ(M,N)%   for some integers M, N.  This is not exported (yet).  It was%   written to make {nth0,nth1}/4 able to find the index, just as%   same_length/2 is useful for making things invertible.one_longer([_|RestLonger], Shorter) :-	same_length(RestLonger, Shorter).%   perm(List, Perm)%   is true when List and Perm are permutations of each other.  The main%   use of perm/2 is to generate permutations.  You should not use this%   predicate in new programs; use permutation/2 instead.perm([], []).perm(List, [First|Perm]) :-	select(First, List, Rest),	%  tries each List element in turn	perm(Rest, Perm).%   permutation(List, Perm)%   is true when List and Perm are permuations of each other.%   Unlike perm/2, it will work even when List is not a proper list.%   It even acts in a marginally sensible way when Perm isn't proper%   either, but it will still backtrack forever.%   Be careful: this is quite efficient, but the number of permutations of an%   N-element list is N!, even for a 7-element list that is 5040.permutation(List, Perm) :-	same_length(List, Perm),	perm(List, Perm).%   perm2(A,B, C,D)%   is true when {A,B} = {C,D}.  It is very useful for writing pattern%   matchers over commutative operators.  It is used more than perm is.perm2(X,Y, X,Y).perm2(X,Y, Y,X).%   remove_dups(List, Pruned)%   removes duplicated elements from List, which should be a proper list.%   If List has non-ground elements, Pruned may contain elements which%   unify; two elements will remain separate iff there is a substitution%   which makes them different.  E.g. [X,X] -> [X] but [X,Y] -> [X,Y].remove_dups(List, Pruned) :-	sort(List, Pruned).%   reverse(List, Reversed)%   is true when List and Reversed are lists with the same elements%   but in opposite orders.  Either List or Reversed should be a%   proper list: given either argument the other can be found.  If%   both are incomplete reverse/2 can backtrack forever trying ever%   longer lists.  rev/2 is a version of reverse/2 which only works%   one way around: its List argument must be a proper list.%   You should use reverse/2 in new programs.rev(List, Reversed) :-	reverse(List, [], Reversed).reverse(List, Reversed) :-	same_length(List, Reversed),	reverse(List, [], Reversed).reverse([], Reversed, Reversed).reverse([Head|Tail], Sofar, Reversed) :-	reverse(Tail, [Head|Sofar], Reversed).%   same_length(List1, List2)%   is true when List1 and List2 are both lists and have the same number%   of elements.  No relation between the values of their elements is%   implied.  It may be used to generate either list given the other,%   or indeed to generate two lists of the same length, in which case%   the arguments will be bound to lists of length 0, 1, 2, ... %   As you have seen with reverse/2 and permutation/2, it is a good%   device for making Prolog find more (correct) solutions that its%   simple control rules would normally lead it to.same_length([], []).same_length([_|List1], [_|List2]) :-	same_length(List1, List2).%   same_length(List1, List2, Length)%   is true when List1 and List2 are both lists, Length is a non-negative%   integer, and both List1 and List2 have exactly Length elements.  No%   relation between the elements of the lists is implied.  If Length%   is instantiated, or if either List1 or List2 is bound to a proper%   list, same_length is determinate and terminating.  This is based on%   len/2 in basics.pl, q.v.same_length(List1, List2, Length) :-	integer(Length),	!,	Length >= 0,	'same length'(Length, List1, List2).same_length(List1, List2, Length) :-	nonvar(Length),	!,	must_be_integer(Length, 3, same_length(List1,List2,Length)).same_length(List1, List2, Length) :-	var(List1),			% swap List1 and List2 around to	!,				% get indexing in 'same length'/4.	'same length'(List2, List1, 0, Length).same_length(List1, List2, Length) :-	'same length'(List1, List2, 0, Length).'same length'(0, List1, List2) :- !,	% delay unification	List1 = [],			% to block infinite loops	List2 = [].'same length'(N, [_|Rest1], [_|Rest2]) :-	M is N-1,			% N > 0, M >= 0	'same length'(M, Rest1, Rest2).'same length'([], [], N, N).'same length'([_|Rest1], [_|Rest2], I, N) :-	J is I+1,	'same length'(Rest1, Rest2, J, N).%   select(X, Xlist, Y, Ylist)%   is true when X is the Kth member of Xlist and Y the Kth element of Ylist%   for some K, and apart from that Xlist and Ylist are the same.  You can%   use it to replace X by Y or vice versa.select(X, [X|Tail], Y, [Y|Tail]).select(X, [Head|Xlist], Y, [Head|Ylist]) :-	select(X, Xlist, Y, Ylist).%   shorter_list(Short, Long)%   is true when Short is a list is strictly shorter than Long.  Long%   doesn't have to be a proper list provided it is long enough.  This%   can be used to generate lists shorter than Long, lengths 0, 1, 2...%   will be tried, but backtracking will terminate with a list that is%   one element shorter than Long.  It cannot be used to generate lists%   longer than Short, because it doesn't look at all the elements of the%   longer list.shorter_list([], [_|_]).shorter_list([_|Short], [_|Long]) :-	shorter_list(Short, Long).	%   subseq(Sequence, SubSequence, Complement)%   is true when SubSequence and Complement are both subsequences of the%   list Sequence (the order of corresponding elements being preserved)%   and every element of Sequence which is not in SubSequence is in the%   Complement and vice versa.  That is,%   length(Sequence) = length(SubSequence)+length(Complement), e.g.%   subseq([1,2,3,4], [1,3,4], [2]).  This was written to generate subsets%   and their complements together, but can also be used to interleave two%   lists in all possible ways.  Note that if S1 is a subset of S2, it will%   be generated *before S2 as a SubSequence and *after it as a Complement.subseq([], [], []).subseq([Head|Tail], Sbsq, [Head|Cmpl]) :-	subseq(Tail, Sbsq, Cmpl).subseq([Head|Tail], [Head|Sbsq], Cmpl) :-	subseq(Tail, Sbsq, Cmpl).%   subseq0(Sequence, SubSequence)%   is true when SubSequence is a subsequence of Sequence, but may%   be Sequence itself.   Thus subseq0([a,b], [a,b]) is true as well%   as subseq0([a,b], [a]).%   subseq1(Sequence, SubSequence)%   is true when SubSequence is a proper subsequence of Sequence,%   that is it contains at least one element less.%   ?- setof(X, subseq0([a,b,c],X), Xs).%   Xs = [[],[a],[a,b],[a,b,c],[a,c],[b],[b,c],[c]] %   ?- bagof(X, subseq0([a,b,c,d],X), Xs).%   Xs = [[a,b,c,d],[b,c,d],[c,d],[d],[],[c],[b,d],[b],[b,c],[a,c,d],%	  [a,d],[a],[a,c],[a,b,d],[a,b],[a,b,c]] subseq0(List, List).subseq0(List, Rest) :-	subseq1(List, Rest).subseq1([_Head|Tail], Rest) :-	subseq0(Tail, Rest).subseq1([ Head|Tail], [Head|Rest]) :-	subseq1(Tail, Rest).%   sumlist(Numbers, Total)%   is true when Numbers is a list of integers, and Total is their sum.%   Note that in Dec-10 compiled Prolog this will only work as stated;%   interpreters will almost certainly accept integer expressions.  Also%   note here as elsewhere in Prolog arithmetic that machine arithmetic%   wraps round in Quintus Prolog: (2^28 - 1)+1 = -2^28 .sumlist(Numbers, Total) :-	sumlist(Numbers, 0, Total).sumlist([], Total, Total).sumlist([Head|Tail], Sofar, Total) :-	Next is Sofar+Head,	sumlist(Tail, Next, Total).