%   Package: list_parts%   Author : Richard A. O'Keefe%   Updated: 3/26/87%   Defines: names for parts of lists.%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved.:- module(list_parts, [	head/2,	tail/2,	prefix/2,	suffix/2,	sublist/2,	proper_prefix/2,	proper_suffix/2,	proper_sublist/2   ])./* pred	head(T, list(T)),	tail(list(T), list(T)),	prefix(list(T), list(T)),	suffix(list(T), list(T)),	sublist(list(T), list(T)),	proper_prefix(list(T), list(T)),	proper_suffix(list(T), list(T)),	proper_sublist(list(T), list(T)).*/sccs_id('"@(#)87/03/26 listparts.pl	98.1"')./*  The main purpose of this file is to establish a common vocabulary    for names of parts of lists among Prolog programmers.  You will    seldom have occasion to use head/2 or tail/2 in your programs    -- pattern matching is clearer and faster -- but you will often    use these words when talking about your programs, and we shall    all benefit if we use the same words with the same meanings.    "sublists" are often called "segments".  I find this confusing,    because I expected "segments" to be repeated units, as in the    segments of a myriapod.  "sublist" might have been ambiguous,    but it is disambiguated by the fact that library(lists) uses    "subseq" (an abbreviation of "subsequence") for the discontiguous    subcollection.    Please send in your suggestions for other parts of lists (or of    other standard data structures) which need agreed names, and for    what those names should be.*/%   All of the predicates defined in this file are binary,%   and <part>(X, Y) is to be read as X is the/a <part> of Y.%   When both <part>/2 and proper_<part>/2 exist, proper <part>s%   are strictly smaller than Y, whereas Y may be a <part> of itself.%   Note that the argument order of basics:member/2 is compatible%   with these predicates.  prefix/2 and proper_prefix/2 benefit from%   indexing if the Prefix argument is instantiated.  In the comments,%   N is the length of the List argument, assumed proper.%   The predicates bear their indicated meanings only when their%   arguments are of the right types.  They are undefined for other%   terms.  Thus tail(g, [e|g]) succeeds despite the fact that 'g'%   isn't any sort of list.  Similarly, prefix([], g) succeeds.%   This is not a bug!  'g' not being a list, the behaviour of%   prefix/2 in that case is not defined.%   head(Head, List)%   is true when List is a non-empty list and Head is its head.%   A list has only one head.  No restrictions.head(Head, [Head|_]).%   tail(Tail, List)%   is true when List is a non-empty list and Tail is its tail.%   A list has only one tail.  No restrictions.tail(Tail, [_|Tail]).%   prefix(Prefix, List)%   is true when Prefix and List are lists and Prefix is a prefix of List.%   It terminates if either argument is proper, and has at most N+1 solutions.prefix([], _).prefix([Head|Prefix], [Head|List]) :-	prefix(Prefix, List).%   proper_prefix(Prefix, List)%   is true when Prefix and List are lists and Prefix is a proper prefix%   of List.  That is, Prefix is a prefix of List but is not List itself.%   It terminates if either argument is proper, and has at most N solutions.proper_prefix([], [_|_]).proper_prefix([Head|Prefix], [Head|List]) :-	proper_prefix(Prefix, List).%   suffix(Suffix, List)%   is true when Suffix and List are lists and Suffix is a suffix of List.%   It terminates only if List is proper, and has at most N+1 solutions.suffix(List, List).suffix(Suffix, [_|List]) :-	suffix(Suffix, List).%   proper_suffix(Suffix, List)%   is true when Suffix and List are lists and Suffix is a proper suffix%   of List.  That is, Suffix is a suffix of List but is not List itself.%   It terminates only if List is proper, and has at most N solutions.proper_suffix(Suffix, [_|List]) :-	suffix(Suffix, List).%   sublist(SubList, List)%   is true when SubList and List are lists and SubList is a sublist of%   List.  That is, List = _ <> SubList <> _ .  Note that the structure%   of this predicate is the same as the structure of suffix/2, so it%   too terminates only if List is proper.  If SubList is proper it%   enumerates all solutions.  If neither argument is proper, it would%   have to diagonalise to find all solutions, but it doesn't, so it is%   then incomplete.  Problem: SubList=[] is found N+1 times.%   If SubList is proper, it has at most N+1 solutions.%   Otherwise, it has at most (1/2)(N+1)(N+2) solutions.sublist(SubList, List) :-	prefix(SubList, List).sublist(SubList, [_|List]) :-	sublist(SubList, List).%   proper_sublist(SubList, List)%   is true when SubList and List are lists and SubList is a proper%   sublist of List.  It terminates only if List is proper.  The only%   solution of sublist/2 which is not a solution of proper_sublist/2%   is sublist(List,List).  So proper_sublist/2 has one solution less.proper_sublist(SubList, List) :-	proper_prefix(SubList, List).proper_sublist(SubList, [_|List]) :-	sublist(SubList, List).