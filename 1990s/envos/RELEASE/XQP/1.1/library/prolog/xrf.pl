%  File   : xrf.pl%  Author : Dave Bowen%  Updated: @(#)xrf.pl	97.1%  Purpose: Main module of XREF, the Prolog Cross-Reference Program.%declarations%:- module(xrf, [	crecord/2,	mark_interpreted/1,	go/0   ]).:- use_module(xrfcol, [	collect/1   ]),   use_module(xrfdef, [	load_file/1,	load_list/1,	is_system/1   ]),   use_module(xrfout, [	writes/1,	do_output/1   ]),   use_module(xrftty, [	get_crf/2,	get_title/1,	get_width/1,	get_globals_file/1,	get_update_module_declarations/1,	readtonl/1,	expand_file_name/2,	see_chek/1,	warn/2   ]),   use_module(library(basics), [	append/3,	member/2   ]),   use_module(library(lists), [	reverse/2   ]).%end%% ----------------------------------------------------------------------/******************************************************************************Data   $caller(Called_Predicate, Calling_Functor, Calling_Arity, Where_Defined)			  Held on key: Called_Predicate.			  $caller(A:P, F, N, I, M) means A:P is called by					 	   F/N in module M, file I.   $defn(File, Module, Predicate)			  Held on key: Predicate.			  $defn(I,M,P) means P is defined in module M, file I.   $file(File, Module)			  Held on key: $file(_,_).			  $file(F,M) means F is a file of module M.   Predicate			  Held on key: $pred			  $pred(M:G) means MGT G was defined OR used,				     and its module is M.******************************************************************************/				/* Top level */% Ask user for all input before xref-ing anything.  A.V.G.go :-	tidy,	load_applies,	promptandRead(String),	askFiles(String, InFiles),	get_crf(_File, _),		%  Get filename for cross-ref listing	get_title(_Title),	get_width(_Width),	get_globals_file(_Globals),	%  Are we to write a globals file?	get_update_module_declarations(_),   % Are we to update them?	(	    member(F, InFiles),	    getfrom(F),	    fail	|	    connect_foreign,	    collect(L1),	    do_output(L1)	).askFiles("", []) :- !.		% CR only = no more input filesaskFiles([C|Cs], AllFs) :-	getDecls([C|Cs], Fs1),	% Immed process indirect/def file.	append(Fs1, Fs, AllFs),	promptandRead(String),	!,	askFiles(String, Fs).askFiles([C|Cs], [[C|Cs] | Fs]) :-	% Accum files to xref.	\+ getDecls([C|Cs], _),	promptandRead(String),	!,	askFiles(String, Fs).promptandRead(String) :-	ttynl, display('Next file: '), ttyflush,	readtonl(String).getFiles(end_of_file, []) :- !.getFiles([C|Cs], AllFs) :-	display('File: '),		% (S is char list)	writes([C|Cs]), ttynl,		% Echo on terminal	getDecls([C|Cs], Fs1),	% Immed process indirect/def file.	append(Fs1, Fs, AllFs),	indirectRead(String),	!,	getFiles(String, Fs).getFiles([C|Cs], [[C|Cs] | Fs]) :-	% Accum files to xref.	\+ getDecls([C|Cs], _),	indirectRead(String),	!,	getFiles(String, Fs)./* Skip over blank lines, return eof when readtonl fails.  */indirectRead(String) :-	readtonl(S),	!,	(    \+ S = "" ->		String = S	|		indirectRead(String)	).indirectRead(end_of_file).				/* Prolog, indirect or definition file? */getDecls([64 /* @ */|S], Fs) :- !,	% Indirect file (@prefix)	do_file_indirect(S, Fs).getDecls([42 /* * */|S], []) :- !,	% Definition file (*prefix)	do_file_load_file(S).getDecls(S, Fs) :-			% Indirect file (.ccl suffix)	has_ext(S, ".ccl"),	!,	do_file_indirect(S, Fs).getDecls(S, []) :-			% Definition file (.def suffix)	has_ext(S, ".def"),	!,	do_file_load_file(S).do_file_indirect(String, Fs) :-	name(File1, String),		% Convert char list to atom (File)	expand_file_name(File1,File), % Use the full file name	seeing(Old_file),		% Save currently open file	see_chek(File),			% Open required file (may fail)	indirectRead(S1),	getFiles(S1, Fs),	seen,				% Close file	ttynl,				% Tell user when indirect file finished	display('Indirect file '),	display(File),	display(' processed'), ttynl,	see(Old_file).			% Re-open original filedo_file_indirect(_, []).		% Always succeeddo_file_load_file(String) :-	name(File1, String),		% Convert char list to atom (File)	expand_file_name(File1,File), % Use the full file name	seeing(Old_file),		% Save currently open file	see_chek(File),			% Open required file (may fail)	load_file(File),	seen,				% Close file	see(Old_file).			% Re-open original filedo_file_load_file( _).			% Always succeedtidy :-	erase_database_except([]).erase_database_except(Preds) :-	current_key(_, K),	recorded(K, T, R),	\+ member(T, Preds),	erase(R),	fail.erase_database_except(_Preds).load_applies :-	load_list([		applies(call(Goal), Goal),		applies(phrase(Nonterminal, _List), Nonterminal+2),		applies(bagof(_Vars,Test,_Bag), Test),		applies(setof(_Vars,Test,_Set), Test),		applies((P->Q), (P,Q)),		applies(_X^P, P),		applies(\+G, G)		]).getfrom(S) :-				% Must be Prolog file for cross ref	do_file(xrf, S).				/* Takes two character lists as arguments, and				   tests whether the 1st ends with the 2nd */has_ext(Ext, Ext) :- !.has_ext([_|L], Ext) :-	has_ext(L, Ext).				/* Open up the file, call processing procedure,				   and close file again. Calls indirect(File)				   load_file(File) or xrf(File). */do_file(xrf, String) :-	nameWithLib(File1, String),	% Convert char list to atom (File)	peekAtModule(File1, M, _U),	expand_file_name(File1,File),	% Use the full file name	seeing(Old_file),		% Save currently open file	see_chek(File),			% Open required file (may fail)	xrf(File1,M,[M:_P],_,_),	% Top level call to xrf	seen,				% Close file	see(Old_file).			% Re-open original filenameWithLib(Term, String) :-	nonvar(String),	append("library(", Suffix, String),	append(Name, ")", Suffix) ->		name(File, Name),		Term = library(File)	|		name(Term, String).				/* Cross reference processing for a particular				   file F */xrf(library(F), M, Uin, Uout, ' seen.') :- !,   	recordz('$file'(_,_), '$file'(library(F),M), _),	recordz('$module', file_to_module(library(F), F), _),	exhaust(library(F), M, Uin, Uout).xrf(F, M, Uin, Uout, ' seen.') :-	recordz('$file'(_,_),'$file'(F,M), _),	  % record F under $file	recordz('$module',file_to_module(F,F),_), % for now file = mod	exhaust(F, M, Uin, Uout).		  % go through F term by term				/* Process each clause, T, in file I */exhaust(I, M, Uin, Uout) :-	read(T),	exhaust(T, I, M, Uin, Uout).exhaust(end_of_file, _I, _M, U, U) :- !.				/* module decl starts its own "use" list  */				/* with the default binding to itself.    */exhaust( (:-module(ModOut,_)), I, _ModIn, Uin, Uin) :-        change_module_name(ModOut, I),	read(NextT),			% Read next clause	!,	exhaust(NextT, I, ModOut, [ModOut:_P], _Uout).exhaust(T, I, M, Uin, Uout) :-	T \== end_of_file,	expand_term(T, T1),		% Pre-translation of grammar rules	(   process(T1, I, M, Uin, U1) ->	% Cross-ref processing		true	|		U1 = Uin	),	read(NextT),				% Read next clause	!,	exhaust(NextT, I, M, U1, Uout).				/* Process clause (1st arg). 2nd arg is file */				/* module (3rd arg), "use" lists (args 4-5)  */process((P:-Q), I, M, U, U) :- !, 	% Non-unit clause	head(P, I, M, F, N), !,	goal(Q, U, M, G),		% Process successive goals by	caller(G, F, N, I, M),		%   backtracking.	fail.process((:-multifile Args),I, M, U, U) :- !,        process_multi_file(Args,I,M).process((:-dynamic Args),I, M, U, U) :- !,	process_dynamic(Args,I,M).process((:-meta_predicate Args),I, _M, U, U) :- !,	process_meta_pred(Args,I,U).				/* directives may contain use_module, which  */				/* updates the "use" list.                   */process((:-G),_, M, Uin, Uout) :- !,	% goal clause, call it.	do_directives(G, M, Uin, Uout).process((?-G),_, M, Uin, Uout) :- !,	% question, ditto	do_directives(G, M, Uin, Uout).process(P, _I, _M, U, U) :-		% process the foreign_file statements	functor(P,foreign_file,_), !,	process_foreign_file(P).process(P,File, M, U, U) :-		% process each foreign statement	P =.. [foreign, C_function_name, Prolog_function_form], !,	process_foreign(C_function_name, Prolog_function_form, c, File, M).process(P,File, M, U, U) :-		% process each foreign statement	P =.. [foreign, C_function_name, Lang, Prolog_function_form], !,	process_foreign(C_function_name, Prolog_function_form, Lang, File, M).process(P, I, M, U, U) :-			% unit clause	head(P, I, M, _, _).process_foreign(C_function_name, Prolog_function_form, Lang, _File, M) :-   	functor(Prolog_function_form,F,N),	functor(P,F,N),			% most general Prolog term	crecord('$foreign_pred', pred_to_module(P,C_function_name,Lang,M)),	(   is_system(P) ->		warn(P, 'already defined as a system predicate')	|		true	).process_foreign_file(foreign_file(Obj_file, C_function_list)) :-	member(C_function_name, C_function_list),	crecord('$foreign_file', func_obj(C_function_name, Obj_file)),	fail.process_foreign_file(foreign_file(_Obj_file, _C_function_list)).change_module_name(Module, File) :-	recorded('$module', file_to_module(File,_), Ref),	erase(Ref),	recordz('$module', file_to_module(File,Module), _).% ------------------------------------------------------------------------process_multi_file((Arg1,Arg2), I, M) :- !,	process_multi_file(Arg1, I, M),	process_multi_file(Arg2, I, M).process_multi_file(Arg/Arity, I, M) :- !,	functor(Arg1, Arg, Arity),	process_multi_file(Arg1, I, M).process_multi_file(Pred, I, M) :-	recorded('$dynamic', d(M:Pred,J), _),	I \== J,	warn(M:Pred, 	  'declared multifile but is declared dynamic in another file'),	!.process_multi_file(Pred, I, M) :-	crecord('$multi_file', m(M:Pred,I)),	head(Pred, I, M, _, _).process_dynamic((Arg1,Arg2), I, M) :- !,	process_dynamic(Arg1, I, M),	process_dynamic(Arg2, I, M).process_dynamic(Arg/Arity, I, M) :- !,	functor(Arg1, Arg, Arity),	process_dynamic(Arg1, I, M).process_dynamic(Pred, I, M) :-	recorded('$multi_file', m(M:Pred,J), _),	I \== J,	warn(M:Pred, 	  'declared dynamic but is declared multifile in another file'),	!.process_dynamic(Pred, I, M) :-	crecord('$dynamic', d(M:Pred,I)),	head(Pred, I, M, _, _)./*  The code for meta_predicates here should accept both of the following;	:- meta_predicate foo(...)		foo is defined herein	:- meta_predicate mmm:foo(...)		foo is defined in module mmm    $applies records foo's module.*/process_meta_pred((Arg1,Arg2), I, U) :- !,	process_meta_pred(Arg1, I, U),	process_meta_pred(Arg2, I, U).process_meta_pred(M:P, I, _U) :- !,	P =.. [MetaPred | MetaArgs],	length(MetaArgs, Nargs),	functor(MetaSkel, MetaPred, Nargs),	record_meta(MetaArgs, MetaSkel, 0, I, M).process_meta_pred(MetaDecl, I, U) :-	MetaDecl =.. [MetaPred | MetaArgs],	MetaPred \== ':',	length(MetaArgs, Nargs),	functor(MetaSkel, MetaPred, Nargs),	(   member(M:T, U),	    \+ \+ MetaSkel = T ->	% If MetaSkel unifies, undo it		true			% and commit to M.	),	record_meta(MetaArgs, MetaSkel, 0, I, M).record_meta([], _MetaSkel, _N, _I, _M) :- !.record_meta([MArg | MetaArgs], MetaSkel, N, I, M) :-	N1 is N+1,	(   MArg = ':' ->		arg(N1, MetaSkel, G),		crecord(MetaSkel, '$applies'(M:MetaSkel,G))	|	    integer(MArg),	    MArg >= 0  ->		arg(N1, MetaSkel, G),		crecord(MetaSkel, '$applies'(M:MetaSkel,G+MArg))	|   otherwise  ->		true	),	!,	record_meta(MetaArgs, MetaSkel, N1, I, M).% ------------------------------------------------------------------------do_directives((X,Y),M,Uin,Uout) :- !,	do_directives(X,M,Uin,U1),	do_directives(Y,M,U1,Uout).do_directives((X;Y),M,Uin,Uout) :- !,	do_directives(X,M,Uin,U1),	do_directives(Y,M,U1,Uout).do_directives(X,M,Uin,Uout) :-	do_directive(X,M,Uin,Uout).do_directive(dynamic(_),_M,U,U) :- !.		% Quintus declarationdo_directive(meta_predicate(_),_M,U,U) :- !.	% Quintus declarationdo_directive(public(_),_M,U,U) :- !.		% DEC-10 declarationdo_directive(mode(_),_M,U,U) :- !.		% DEC-10 declarationdo_directive(type(_),_M,U,U) :- !.		% type checker declarationdo_directive(pred(_),_M,U,U) :- !.		% type checker declarationdo_directive(rule(_),_M,U,U) :- !.		% type checker declarationdo_directive(use_module([X|T]),M,Uin,Uout) :- !,	do_directive(use_module(X),M,Uin,U1),	do_directive(use_module(T),M,U1,Uout).do_directive(use_module(X),_M,Uin,Uout) :- !,	peekAtModule(X, XMname, Ps),	update_module_use(Ps, XMname, Uin, Uout),	ensure_file(X,XMname,[XMname:_],_).do_directive(use_module(X, Ps),_M,Uin,Uout) :- !,	peekAtModule(X, XMname, _),	update_module_use(Ps, XMname, Uin, Uout),	ensure_file(X,XMname,[XMname:_],_).do_directive(ensure_loaded(X),M,Uin,Uout) :- !,	ensure_files(X,M,Uin,Uout).do_directive(compile(X),M,Uin,Uout) :- !,	do_files(X,M,Uin,Uout).do_directive(consult(X),M,Uin,Uout) :- !,	do_files(X,M,Uin,Uout).do_directive([H|T],M,Uin,Uout) :- !,	do_files([H|T],M,Uin,Uout).do_directive(op(P,T,O),_M,U,U) :- !,	op(P,T,O).do_directive(_,_M,U,U).	/* The use list is of the form [M1:G1, M2:G2, ..., Mn:_]   where each Mi is instantiated to a module name,   each Gi is a most general term for a predicate,   Mn is the "current module", which catches anything that gets there.*/update_module_use([], _Mname, Uin, Uin) :- !.update_module_use([F/N | Ps], Mname, Uin, Uout) :-	functor(G, F, N),	update_module_use(Ps, Mname, [Mname:G | Uin], Uout).library_defn([], library(_X), _XMname) :- !.library_defn([F/N | Ps], library(X), XMname) :-	functor(G, F, N),	crecord(G, '$defn'(library(X),XMname,G)),	!,	library_defn(Ps, library(X), XMname).% ------------------------------------------------------------------------do_files([],_M,U,U) :- !.do_files([H|T],M,U,Uout) :- !,	do_files(H,M,U,U1),	do_files(T,M,U1,Uout).do_files(library(X), _M,Uin,Uout) :- !,	peekAtModule(library(X), XMname, Ps),	update_module_use(Ps, XMname, Uin, Uout).do_files(X1,M,Uin,Uout) :-	do_xrf(X1, M, Uin, Uout).ensure_files([],_M,U,U) :- !.ensure_files([H|T],M,U,Uout) :- !,	ensure_files(H,M,U,U1),	ensure_files(T,M,U1,Uout).ensure_files(F,M,Uin,Uout) :-	peekAtModule(F, FMname, Ps),	(   FMname = user ->				% Not a module		ensure_file(F,M,Uin,Uout)	|	    otherwise ->		update_module_use(Ps, FMname, Uin, Uout),		ensure_file(F,FMname,[FMname:_],_)	).ensure_file(library(X), _M,Uin,Uout) :- !,	peekAtModule(library(X), XMname, Ps),	library_defn(Ps, library(X), XMname),	update_module_use(Ps, XMname, Uin, Uout).ensure_file(F,M,Uin,Uout) :-	expand_file_name(F, Ffull),        recorded('$file'(_,_), '$file'(F1,M), _),	expand_file_name(F1, Ffull)		->		Uout = Uin	|		do_xrf(F, M, Uin, Uout).do_xrf(X1, M, Uin, Uout) :-	seeing(OldFile),	(   expand_file_name(X1,X),	    see_chek(X) ->		xrf(X1, M, Uin, Uout, Msg),		write('		'), write(X), write(Msg), nl,		seen	|		true	),	see(OldFile).peekAtModule(X1, XMname, Exports) :-	seeing(OldFile),	(   expand_file_name(X1,X),	    see_chek(X) ->		read(ModDecl),		( ModDecl = ( :- module(XMname, Exports)) ->		    true		|		    XMname = user, Exports = []		),		seen	|		XMname = user, Exports = []	),	see(OldFile).% ------------------------------------------------------------------------/*  Record the fact that P is a predicate & that it is defined in file I.    Return the principal functor of P as separate symbol(F) and arity(N).*/head(P, I, M, F, N) :-	functor(P, F, N),		% P has name F and arity N	functor(G, F, N),		% G is most general term F/N	definition(G, I, M).		% Record F/N is pred & defined in Igoal(G, _U, _M, _) :-			% fail if goal is a variable	var(G), !,	fail.goal(_A:G, _U, _M, _) :-			% fail if goal is a variable	var(G), !,	fail.goal(G, U, M, G1) :-	goal0(G, U, M, G1)./*  goal0 returns the most general term (???) having the principal functor    of each goal in the clause (successively on backtracking).    It ignores system predicates and variables (see above).*/goal0((G,_), U, M, G1) :-	goal(G, U, M, G1).goal0((_,G), U, M, G1) :- !,	goal(G, U, M, G1).goal0((G ; _), U, M, G1) :-	goal(G, U, M, G1).goal0((_ ; G), U, M, G1) :- !,	goal(G, U, M, G1).goal0(A:G1, U, M, G2) :-	recorded(G1, '$applies'(A:G1,P), _),	widen(P, A, P1),	goal(P1, U, M, G2).goal0(G1, U, M, G2) :-	member(A:T, U),	\+ \+ G1 = T ->		% If G1 unifies, undo it and commit to A.		recorded(G1, '$applies'(A:G1,P), _),		widen(P, A, P1),		goal(P1, U, M, G2).goal0(G, _U, _M, _) :-	is_system(G), !,	fail.goal0(A:G, _U, _M, A:G) :- !.goal0(G, U, _M, G1) :-	member(A:T, U),	\+ \+ G = T ->		% If G unifies, undo it and commit to A.		G1 = A:G.% ------------------------------------------------------------------------				/* Lie and say Prolog name that maps to 				   C-name is def'ed in the Object file. A.V.G.				*/connect_foreign :-	recorded('$foreign_pred', pred_to_module(P, Fname, _L, M), _),	recorded('$foreign_file', func_obj(Fname, Obj), _),	definition(P, Obj, M),	fail.connect_foreign.% ------------------------------------------------------------------------				/* Record that P is a predicate and that it is				   defined in file I */definition(P, _, _M) :-	is_system(P),		% But first warn if P is a system predicate	warn(P, 'already defined as a system predicate'),	fail.definition(P, I, M) :-	crecord('$pred', M:P),	crecord(P, '$defn'(I,M,P)).				/* Record that A:P is a predicate called by				   M:F/N in file I */caller(A:P, F, N, I, M) :-	functor(P, Pf, Pn),	functor(P1, Pf, Pn),	crecord('$pred', A:P1),	crecord(P1, '$caller'(A:P1,F,N,I,M)).				/* Record that P is called by the user or				   outside its file of definition, and hence				   must be public. */mark_interpreted(P) :-	caller(P, '<user>', 0, 'UNDEFINED', user).				/* Record term Q on key P unless already				   recorded. */crecord(P, Q) :-	recorded(P, Q, _), !.crecord(P, Q) :-	recordz(P, Q, _).				/* Increase arity of predicate by specified				   amount */widen(P+_, _, _) :-		% NB also covers variable as first arg	var(P), !,	fail.widen(M:P+Offset, _A, M:P1) :- !,	nonvar(M),	nonvar(P),	widen(P+Offset, P1).widen(P+Offset, A, A:P1) :- !,	functor(P,F, N1),	N2 is N1+Offset,	functor(P1, F, N2).widen(P, A, A:P).	