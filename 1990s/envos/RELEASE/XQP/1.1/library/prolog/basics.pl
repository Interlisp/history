%   Module : basics%   Author : by now, nobody knows%   Updated: 8/17/87%   Defines: the basic list processing predicates%   Adapted from shared code written by the same author(s); all changes%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved.:- module(basics, [	append/3,	member/2,	memberchk/2,	nonmember/2   ]).:- mode	append(?, ?, ?),	member(?, ?),	memberchk(+, +),	nonmember(+, +).sccs_id('"@(#)87/08/17 basics.pl	10.1"').%   append(?Prefix, ?Suffix, ?Combined)%   is true when all three arguments are lists, and the members of Combined%   are the members of Prefix followed by the members of Suffix.  It may be%   used to form Combined from a given Prefix and Suffix, or to take a given%   Combined apart.  For example, we could define member/2 as%	member(X, L) :- append(_, [X|_], L).append([], L, L).append([H|T], L, [H|R]) :-	append(T, L, R).%   member(?Element, ?Set)%   is true when Set is a list, and Element occurs in it.  It may be used%   to test for an element or to enumerate all the elements by backtracking.%   Indeed, it may be used to generate the Set!member(Element, [Element|_]).member(Element, [_|Rest]) :-	member(Element, Rest).%   memberchk(+Element, +Set)%   means the same thing, but may only be used to test whether a known%   Element occurs in a known Set.  In return for this limited use, it%   is more efficient than member/2 when it is applicable.memberchk(Element, [Element|_]) :- !.memberchk(Element, [_|Rest]) :-	memberchk(Element, Rest).%   nonmember(+Element, +Set)%   means that Element does not occur in Set.  It does not make sense%   to instantiate Element in any way, as there are infinitely many%   terms which do not occur in any given set.  Nor can we generate%   Set; there are infinitely many sets not containing a given Element.%   Read it as "the given Element does not occur in the given list Set".%   This code was suggested by Bruce Hakami; seven versions of this%   operation were benchmarked and this found to be the fastest.%   The old code was for DEC-10 Prolog, which did not compile (\+)/1.nonmember(Element, Set) :-	\+ member(Element, Set)./*  The code we would really like to have isnonmember(_, []).nonmember(X, [Element|Set]) :-	X ~= Element,	nonmember(X, Set).%   which would be sound.	*//*  The following definition used to be provided, but the built-in    predicate length/2 now has this effect in Quintus Prolog, so    there is no longer any point in having len/2.%   len(?List, ?Length)%   is true when List is a list, and Length is the length of that list%   (an integer).  It tries to be both faithful to the obvious logical%   definition and also reasonably efficient.  To this end it uses two%   auxiliary predicates.  len_/2 is used when the length is known and%   the list is to be generated or checked, while len_/3 is used to get%   the unknown length of a list, and may generate the list as well.%   This predicate really should be called length/2 rather than len/2,%   and is only abbreviated because Dec-10 Prolog already has a length%   predicate which isn't quite right.len(List, Length) :-	var(Length),	!,	len_(List, 0, Length).len(List, Length) :-	integer(Length),	Length >= 0,	len_(Length, List).len_(0, X) :- !, X = [].	% delay X unification to block loops.len_(N, [_|Tail]) :-		% len_(N,L) generates a list N long	M is N-1,       	% use succ(M, N) when available.	len_(M, Tail)		% N > 0, so M >= 0.len_([], Length, Length).	% len_/3 backtracks over ever longer listslen_([_|Tail], SoFar, Length) :-	Next is SoFar+1,	% use succ(SoFar, Next) when available.	len_(Tail, Next, Length).*/