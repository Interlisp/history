%   Module : files%   Author : Richard A. O'Keefe%   Updated: 3/26/87%   Purpose: file-handling commands and predicates.%   SeeAlso: files.c, library(directory), library(errno)%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved.:- module(files, [	can_open_file/2,	can_open_file/3,	close_all_streams/0,	current_dec10_stream/2,	delete_file/1,	file_exists/1,	file_exists/2,	file_must_exist/1,	file_must_exist/2,	open_file/3,	dec10_rename/2,		% 1.6 library compatibility	rename/2,		% Dec-10 compatibility	rename_file/2   ]).:- use_module(library(types), [	must_be_oneof/4,	must_be_symbol/3   ]).sccs_id('"@(#)87/03/26 files.pl	98.1"').%   rename_file(+OldName, +NewName)%   OldName and NewName must be text objects which are well formed%   file names.  OldName must identify an existing file, which will%   be renamed to NewName.  The details of just when this can be%   done are operating-system dependent.  Either the operation%   succeeds, or it prints an error message and fails.  If the%   file is associated with a stream, the effect is system-dependent.rename_file(OldName, NewName) :-	Goal = rename_file(OldName, NewName),	must_be_symbol(OldName, 1, Goal),	must_be_symbol(NewName, 2, Goal),	'Qrename'(OldName, NewName, ErrorCode),	errno(ErrorCode, Goal).%   delete_file(+OldName)%   OldName must be a text object which is a well formed file name,%   and it must identify an existing file, which will be deleted.%   Either the operation succeeds, or it prints an error message%   and fails.  Some day we'll accept path records too.  If the%   file is associated with a stream, the effect is system-dependent;%   under UNIX you can still use the stream.delete_file(OldName) :-	Goal = delete_file(OldName),	must_be_symbol(OldName, 1, Goal),	'Qdelete'(OldName, ErrorCode),	errno(ErrorCode, Goal).%   The following two commands are identical.  The name dec10_rename/2%   was used in the 1.6 library, but it was always intended to be the%   operation known as rename/2 in Dec-10 Prolog and C Prolog.  In%   Dec-10 Prolog, you had to open a file before you could rename it,%   and renaming closed the file.  C Prolog closed the file, but did not%   demand that it be open.  Similarly, the Quintus version will close%   any DEC-10 compatible stream connected to the file (but it wil NOT%   close any streams opened by open/3; they continue to see the file).%   If the file doesn't exist or can't be renamed, an error message will%   be printed and execution will be aborted if file errors are enabled;%   you'll get a quiet failure if file errors are disabled.  Note that%   close(OldName) doesn't mind a bit if OldName isn't open!  These%   operations are only provided to help convert old code; new programs%   should use rename_file/2 or delete_file/1.dec10_rename(OldName, NewName) :-	Goal = dec10_rename(OldName, NewName),	must_be_symbol(OldName, 1, Goal),	must_be_symbol(NewName, 2, Goal),	(   current_dec10_stream(OldName, _) -> close(OldName)	;   true % for C Prolog compatibility, do not insist on	),       % the file being open beforehand.	(   NewName = [] -> 'Qdelete'(OldName, ErrorCode)	;   'Qrename'(OldName, NewName, ErrorCode)	),	fileerrno(ErrorCode, Goal).rename(OldName, NewName) :-	Goal = rename(OldName, NewName),	must_be_symbol(OldName, 1, Goal),	must_be_symbol(NewName, 2, Goal),	(   current_dec10_stream(OldName, _) -> close(OldName)	;   true % for C Prolog compatibility, do not insist on	),       % the file being open beforehand.	(   NewName = [] -> 'Qdelete'(OldName, ErrorCode)	;   'Qrename'(OldName, NewName, ErrorCode)	),	fileerrno(ErrorCode, Goal).%   current_dec10_stream(?FileName, ?See_or_Tell)%   is true when See_or_Tell is 'see' and FileName is a file which%   was opened by see(FileName) and has not yet been closed, or%   when See_or_Tell is 'tell' and FileName is a file which was%   opened by tell(FileName) and has not yet been closed.  It is%   a version of current_stream/3 which just tells you about the%   Dec-10-compatible streams.  It relies on two facts:%   (1) *all* the streams you opened are in the current_stream/3 table.%   (2) seeing/1 (telling/1) return an atom if and only if the%   current input (output) stream was opened by see/1 (tell/1), and%   the atom it returns is that which was given to see/1 (tell/1).current_dec10_stream(FileName, see) :-	current_stream(_, read, Stream),	current_input(OldStream),	set_input(Stream),	seeing(Thingy),	set_input(OldStream),	atom(Thingy),	FileName = Thingy.current_dec10_stream(FileName, tell) :-	current_stream(_, write, Stream),	current_output(OldStream),	set_output(Stream),	telling(Thingy),	set_output(OldStream),	atom(Thingy),	FileName = Thingy.%   file_exists(+File[, +Mode])%   is true when File is a well formed file name which can be%   accessed according to Mode.  Mode is an atom, an integer,%   or a list of atoms and/or integers, where integers are%	4	read permission%	2	write permission%	0	mere existence.file_exists(File) :-	atom(File),	!,	'Qaccess'(File, 0, []).file_exists(File) :-	must_be_symbol(File, 1, file_exists(File)).file_exists(File, Mode) :-	atom(File),	'mode bits'(Mode, 0, Bits),	!,	'Qaccess'(File, Bits, []).file_exists(File, Mode) :-	Goal = file_exists(File,Mode),	must_be_symbol(File, 1, Goal),	format(user_error, '~N! Invalid access mode ~q~n! Goal: ~q~n',	    [Mode,Goal]),	fail.'mode bits'(-, _, _) :- !, fail.	% catches variables'mode bits'([], Bits, Bits) :- !.'mode bits'([Head|Tail], Bits0, Bits) :- !,	'mode bits'(Head, Bits0, Bits1),	'mode bits'(Tail, Bits1, Bits).'mode bits'(read,   Bits0, Bits) :- !, Bits is Bits0 \/ 4.'mode bits'(write,  Bits0, Bits) :- !, Bits is Bits0 \/ 2.'mode bits'(append, Bits0, Bits) :- !, Bits is Bits0 \/10.'mode bits'(exists, Bits,  Bits) :- !.'mode bits'(Integer, Bits0, Bits) :-	integer(Integer),	Bits is (Integer/\7)\/Bits0.%   file_must_exist(+File[, +Mode])%   is like file_exists(File[, Mode]) except that if the file is NOT%   accessible it reports an error using errno.file_must_exist(File) :-	atom(File),	'Qaccess'(File, 0, []),	!.file_must_exist(File) :-	Goal = file_must_exist(File),	must_be_symbol(File, 1, Goal),	'Qaccess'(File, 0, ErrorCode),	errno(ErrorCode, Goal).file_must_exist(File, Mode) :-	atom(File),	'mode bits'(Mode, 0, Bits),	'Qaccess'(File, Bits, []),	!.file_must_exist(File, Mode) :-	Goal = file_must_exist(File,Mode),	must_be_symbol(File, 1, Goal),	(   'mode bits'(Mode, 0, Bits) ->	    'Qaccess'(File, Bits, ErrorCode),	    errno(ErrorCode, Goal)	;   format(user_error, '~N! Invalid access mode ~q~n! Goal: ~q~n',		[Mode,Goal]),	    fail	)./*  can_open_file(FileName, Mode, Quiet)    checks whether it is possible to open the file called FileName in Mode.    Mode is one of	read	- FileName must exist and be readable	write	- FileName must exist and be writable or else		  be non-existent in a writable directory	append	- same as write    The possible values for Quiet are	fail	- just quietly fail if the file is not openable	warn	- print an error message if the file won't open.    All things considered, the simplest way to do this is to just try to    open the file.  This has a defect: it might indeed be possible to open    the file, but if too many files are open already it won't work.  But    the error message for that is intelligible, and if we really want to    open the file that is something we'd like to know about.    open_file(File, Mode, Stream) does the same checks, and goes ahead    and does open the file.  This does better error reporting than the    existing open/3 (which it uses).    The "standard" modes are	read	- input	write	- output, creates a new file	append	- output, extends an existing file or creates a new one    These two predicates understand a fourth mode	backup	- output, any existing file F.EXT is renamed to F.BAK.	This is for use with remote UNIX file systems.    There is no way of overwriting an existing file.*/can_open_file(FileName, Mode) :-	can_open_file(FileName, Mode, fail).can_open_file(FileName, Mode, Quiet) :-	Goal = can_open_file(FileName,Mode,Quiet),	must_be_symbol(FileName, 1, Goal),	'file mode'(Mode, Goal, LispMode, _),	must_be_oneof(Quiet, [fail,warn], 3, Goal),	'Qcanopen'(FileName, LispMode, ErrorCode),	(   ErrorCode = [] -> true	% all went well	;   Quiet = fail -> fail	% fail quietly	;   format(user_error,		% fail with warning message		'~N! Can''t open ''~w'' in ~w mode.~n',		[FileName,Mode]),	    fail	).'file mode'(read,	_, 'INPUT',   read)   :- !.'file mode'(write,	_, 'OUTPUT',  write)  :- !.'file mode'(append,	_, 'APPEND',  append) :- !.'file mode'(backup,	_, 'OUTPUT',  write)  :- !.'file mode'(Mode, Goal, _, _) :-		% fails	must_be_oneof(Mode, [read,write,append,backup], 2, Goal).open_file(FileName, Mode, Stream) :-	Goal = open_file(FileName,Mode,Stream),	must_be_symbol(FileName, 1, Goal),	'file mode'(Mode, Goal, LispMode, NewMode),	'Qcanopen'(FileName, LispMode, ErrorCode),	errno(ErrorCode, Goal),	'back file'(Mode, FileName),	open(FileName, NewMode, Stream).'back file'(backup, FileName) :- !,	'Qbackup'(FileName, _).'back file'(_, _)./*  close_all_streams closes all the streams (other than the standard input    and output) which are currently open.  The time to call this is after    an abort/0.  Note that current_stream does not notice the standard    input or output.    DEBATABLE POINT: this closes all and only the *Prolog* streams, not the    Lisp streams.  It would be a simple matter to call (CLOSEALL).*/close_all_streams :-	current_stream(_, _, Stream),	close(Stream),	fail    ;	true.%   See FILES.LSP for the implementation of these functions.%   In the UNIX/VMS versions, the result is an error code (0 for%   success, non-zero for error).  Here the result is NIL for%   success, non-NIL for failure.  Eventually, we would like to%   have the failure codes say what went wrong, but often this%   information is not available.:- lisp_predicate('QP.RENAME.FILE', 'Qrename'(+,+,[-])).:- lisp_predicate('QP.BACKUP.FILE', 'Qbackup'(+,[-])).:- lisp_predicate('QP.DELETE.FILE', 'Qdelete'(+,[-])).:- lisp_predicate('QP.ACCESS.FILE', 'Qaccess'(+,+,[-])).:- lisp_predicate('QP.CANOPEN.FILE','Qcanopen'(+,+,[-])).:- load_foreign_files([library('FILES')], []).%   errno(Result, Goal)%   report an error in Goal if the Result indicates failure.errno([], _).errno(_, Goal) :- !,	format(user_error,	    '~N! A file-system goal failed~n! Goal: ~q~n', [Goal]),	fail.%   fileerrno(Result, Goal)%   report an error in Goal if the Result indicates failure%   and 'fileerrors' is in effect (rather than 'nofileerrors').fileerrno([], _) :-	prolog_flag(fileerrors, off),	!,	fail.fileerrno(Errno, Goal) :- !,	errno(Errno, Goal).