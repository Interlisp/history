%   Module : strings%   Author : Richard A. O'Keefe%   Updated: 4/10/87%   Purpose: define string_size/2, string_char/3, substring/5.%   SeeAlso: STRINGS.LSP%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved.:- module(strings, [	atom_chars1/2,		% atom_chars/2 is now built in	atom_string/2,		% new for XQP	cgensym/2,	char_atom/2,	char_string/2,		% new for XQP	compare_strings/3,	compare_strings/4,	concat/3,	concat_atom/2,	concat_atom/3,	concat_chars/2,	concat_chars/3,	concat_string/2,	concat_string/3,	gensym/1,	gensym/2,	index/3,	midstring/3,	midstring/4,	midstring/5,	midstring/6,	name/1,	name1/2,	nth_char/3,	number_chars1/2,	% number_chars/2 is now built in	number_string/2,	% new for XQP	span_left/3,	span_left/4,	span_left/5,	span_right/3,	span_right/4,	span_right/5,	span_trim/2,	span_trim/3,	span_trim/5,	string/1,	string_append/3,	string_char/3,	string_chars/2,	string_length/2,	string_search/3,	string_size/2,	subchars/4,	subchars/5,	substring/4,	substring/5,	system/1   ]).:- use_module(library(types)),   use_module(library(basics)).sccs_id('"@(#)87/04/10 strings.pl	99.1"').:- dynamic	gensym_counter/2./*  Xerox Quintus Prolog supports strings, so that it can do something    sensible when Lisp gives it a string.  Strings are in fact pretty    pointless in Prolog.  If you want to perform the classical string    operations, this library provides everything you I've seen suggested    for Prolog using atoms (and Prolog atoms are isomorphic to Snobol    strings).  If you want to do pattern matching, the power and clarity    of grammar rules operating on lists of character codes (the "chars"    data type) have only been equalled by Snobol and have never been    surpassed in any language.  Accordingly, Quintus Prolog doesn't have    a separate string data type except when sharing the world with    another language which has them, and currently Xerox Quintus Prolog    is the only such share.  We can do much fancier things using    character lists and grammar rules.  So we really do recommend that    you should look for almost any alternative before using these    predicates, otherwise you may be seriously underusing Prolog.    Some of the predicates are provided for Arity/Prolog compatibility.    nth_char/3 is a variant of string_char/3.    string_length/2 is a variant of string_size/2.    string_search/3 is a variant of substring/5.    These three predicates are included as a gesture of courtesy    to Arity/Prolog.  substring/4 is already close enough.*/%   string(+Constant)%   is true when Constant is bound to a Lisp string.  As strings are%   foreign to Prolog (and indeed, pointless in a language which has%   efficient implementations of lists and atoms), there's no native%   test we can use, and we have to use TYPENAME.  This is how all%   such tests should be coded.string(Constant) :-	atomic(Constant),	% number, atom, random Lisp object	'TYPENAME'(Constant, 'STRINGP').%   character(+Constant)%   is true when Constant is bound to a Common Lisp character object.%   As strings are foreign to Prolog (see above), there's no native%   test we can use, and we have to use TYPENAME.%   This predicate is *not* exported from this module, and is here%   mainly for self-defence.character(Constant) :-	atomic(Constant),	% number, atom, random Lisp object	'TYPENAME'(Constant, 'CHARACTER').%   name(+Constant)%   is true when Constant has a name.  That is, when it is a string%   or an atom.  Most predicates in this package are happy with either.name(Constant) :-	atomic(Constant),	% number, atom, random Lisp object	'TYPENAME'(Constant, Type),	lisp_name_type(Type).lisp_name_type('LITATOM').lisp_name_type('STRINGP').%   text(+Constant)%   is true when Constant is an atom, a string, or a Common Lisp%   character object.  Some of the predicates in this file (such as%   compare_strings/[3,4] and concat_{atom,string,chars}/[2,3]) are%   happy with these objects as well as strings and atoms.%   This predicate is *not* exported from this module, and is here%   mainly for self-defence.  No attempt has been made to make all%   the operations that might handle Common Lisp characters do so.text(Constant) :-	atomic(Constant),	% number, atom, random Lisp object	'TYPENAME'(Constant, Type),	lisp_text_type(Type).lisp_text_type('LITATOM').lisp_text_type('STRINGP').lisp_text_type('CHARACTER').%   must_be_name/3 should eventually move into library(types),%   but it is so machine-dependent that I've kept it here for%   the moment.  Note that it is NOT exported to users!must_be_name(Arg, _N, _Goal) :-	name(Arg),	!.must_be_name(Arg, N, Goal) :-	types:must_be_('symbol or string', Arg, N, Goal).must_be_string(Arg, _N, _Goal) :-	string(Arg),	!.must_be_string(Arg, N, Goal) :-	types:must_be_(string, Arg, N, Goal).%   proper_chars(Chars, Length, State)%   checks an argument which is supposed to be a list of character codes.%   There are four successful cases:%	State = -1 : Chars ends with a variable%	State =  0 : Chars is a proper list, but some elements are vars%	State =  1 : Chars is a proper list of thin characters%	State =  2 : Chars is a proper list of fat characters%   In the last three cases, Length is bound to the length of the list.proper_chars(Chars, Length, State) :-	proper_chars(Chars, 0, Length, 1, S),	State = S.proper_chars(Chars, _, _, _, -1) :-	var(Chars),	!.proper_chars([], Length, Length, State, State).proper_chars([Char|Chars], L, Length, State0, State) :-	integer(Char),	Char >= 0, Char =< 65535,	!,	(   Char >= 256, State0 >= 1 -> State1 = 2	;   /* thin or had vars */      State1 = State0	),	M is L+1,	proper_chars(Chars, M, Length, State1, State).proper_chars([Char|Chars], L, Length, _, State) :-	var(Char),	M is L+1,	proper_chars(Chars, M, Length, 0, State).%   system(ListOfTextObjects)%   is a version of unix(shell(_)) or vms(dcl(_)).%   Since the D-machines have no equivalent "command language interpreter",%   system/1 prints an error message and fails.%   We could always make a string, read an S-expr from it, and EVAL that,%   so that e.g. system(['PRINT ',2]) would have the effect of printing 2.%   But this hardly seems worth while.system(Texts) :-	format(user_error,	    '~N! There is no "shell" on D-machines.  Use lisp_apply.~n! Goal: ~q~n',	    system(Texts)),	fail.%   concat_atom(+ListOfTextObjects, -Combined)%   concatenates the names of all the text objects in the list%   and returns an atom whose name is the combined characters.%   Valid text objects are either character lists, atoms or numbers.%   Note that these predicates accept Common Lisp CHARACTERs, both%   directly and in lists of character codes.%   Xerox Quintus Prolog implements concat_string/2 non-trivially.%   concat_chars/2 returns a list of character codes.concat_atom(Texts, Atom) :-	collect_texts(Texts, Items),	!,	'QP.PACK'(Items, Atom).concat_atom(Texts, Atom) :-	concat_error(concat_atom(Texts,Atom)).concat_string(Texts, String) :-	collect_texts(Texts, Items),	!,	'CONCATLIST'(Items, String).concat_string(Texts, String) :-	concat_error(concat_string(Texts,String)).concat_chars(Texts, Chars) :-	collect_texts_1(Texts, Codes),	!,	Chars = Codes.concat_chars(Texts, Chars) :-	concat_error(concat_chars(Texts,Chars)).%   collect_texts(Texts, Items)%   succeeds when Texts is a proper list of constants or non-empty%   lists of character codes, binding Items to a list of atoms,%   strings, and other constants, suitable for handing off to%   QP.PACK or CONCATLIST.  Note that any constant is accepted as an%   element of Texts, including Common Lisp character objects.%   The Interlisp functions will typically accept anything, but a%   list of character codes such as "ABC" will turn into the%   characters "(65 66 67)" which is not what we want, so we have%   to catch such lists and turn them into strings using CONCATCODELIST.%   collect_texts_1(Text, Codes)%   is similar, but returns a list of character codes.collect_texts([], []).collect_texts([Text|Texts], [Text|Items]) :-	atomic(Text),	!,	collect_texts(Texts, Items).collect_texts([Codes|Texts], [Text|Items]) :-	collect_chars(Codes, Chars),	'CONCATCODELIST'(Chars, Text),	collect_texts(Texts, Items).collect_texts_1([], []).collect_texts_1([Text|Texts], Chars) :-	collect_text_1(Text, Codes),	append(Codes, Chars1, Chars),	collect_texts_1(Texts, Chars1).collect_text_1(Text, Codes) :-	(   atomic(Text) ->	    'CHCON'(Text, Codes)	;   collect_chars(Text, Codes)	).%   collect_chars(Texts, Chars)%   succeeds when Texts is a list of character codes or other constants%   (we only really want to recognise Common Lisp CHARACTERS, but it is%   easier to accept any constant) and binds Chars to a list of the%   character codes involved.collect_chars(-, _) :- !, fail.collect_chars([], []).collect_chars([Char|Texts], [Char|Chars]) :-	integer(Char),	Char >= 0, Char =< 65535,	collect_chars(Texts, Chars).collect_chars([Text|Texts], Chars) :-	atomic(Text),	'CHCON'(Text, Codes),	append(Codes, Chars1, Chars),	collect_chars(Texts, Chars1).concat_error(Goal) :-	arg(1, Goal, Arg),	types:must_be_('proper list of texts', Arg, 1, Goal).%   concat_atom(+ListOfTextObjects, +Separator, -Combined)%   concatenates the names of all the text objects in the list%   and returns an atom whose name is the combined characters.%   The Separator is inserted between elements of ListOfTextObjects,%   so that concat_atom([a,b,c], +, X) binds X + 'a+b+c'.%   Valid text objects are either character lists, atoms or numbers.%   Xerox Quintus Prolog implements concat_string/3 non-trivially.%   concat_chars/3 returns a list of character codes.concat_atom(Texts, Separator, Atom) :-	interleave(Texts, Separator, FullTexts),	collect_texts(FullTexts, Items),	!,	'QP.PACK'(Items, Atom).concat_atom(Texts, Separator, Atom) :-	concat_error(concat_atom(Texts,Separator,Atom), Separator).concat_string(Texts, Separator, String) :-	interleave(Texts, Separator, FullTexts),	collect_texts(FullTexts, Items),	!,	'CONCATLIST'(Items, String).concat_string(Texts, Separator, String) :-	concat_error(concat_string(Texts,Separator,String), Separator).concat_chars(Texts, Separator, Chars) :-	interleave(Texts, Separator, FullTexts),	collect_texts_1(FullTexts, Codes),	!,	Chars = Codes.concat_chars(Texts, Separator, Chars) :-	concat_error(concat_chars(Texts,Separator,Chars), Separator).interleave([], _, []).interleave([Head|Tail], Sep, [Head|Rest]) :-	interleave1(Tail, Sep, Rest).interleave1([], _, []).interleave1([Head|Tail], Sep, [Sep,Head|Rest]) :-	interleave1(Tail, Sep, Rest).concat_error(Goal, Separator) :-	collect_text_1(Separator, _),		!,	concat_error(Goal).concat_error(Goal, Separator) :-	types:must_be_(text, Separator, 2, Goal).	%   concat(?Name1, +Name2, ?Name3)%   is like append on atoms.  That is, it appends the name of%   Name1 and the name of Name2, and binds Name3 to the atom named%   by the result.  It can be used to find either Name1 or Name3,%   but not to find Name2.  The reason for that is that%   concat('a', X, 'a1') has two solutions:  X = 0 and X = '0',%   and there is no easy way to find the latter.  Examples:%   concat(a, b, ab), concat(10, 23, 1023), concat(gs, 46, gs46).%   Name2 may be numeric, but Name1 and Name3 may not be.%   Since XQP has strings, Name1 and Name3 may both be(come)%   strings or may both be(come) atoms, but mixing is not allowed.%   Name2 may be a string, which is yet another ambiguity, X = $0$.%   For rather hacky reasons having to do with avoiding append/3,%   you can now pass a non-empty chars as the second argument.concat(A, Z, AZ) :-	(   atom(A) ->		concat_atom([A,Z], AZ)	;   string(A) ->		concat_string([A,Z], AZ)	;   nonvar(A) ->		fail	;   atom(AZ) ->		collect_text_1(Z, ZChars),		'CHCON'(AZ, AZChars),		append(AChars, ZChars, AZChars),		!,		'QP.PACKC'(AChars, A)	;   string(AZ) ->		collect_text_1(Z, ZChars),		'CHCON'(AZ, AZChars),		append(AChars, ZChars, AZChars),		!,		'CONCATCODELIST'(AChars, A)	).%   string_append(A, Z, AZ)%   is true when A, Z, and AZ are all three atoms or (Lisp) strings,%   and the name of AZ is the concatenation of the names of A and Z.%   We could define this as%   string_append(A, Z, AZ) :-%	midstring(AZ, A, Z, 0).%   but doing it this way is a bit faster and produces a better%   error message.string_append(A, Z, AZ) :-	var(AZ),	atom(A),	atom(Z),	!,	'QP.PACK2'(A, Z, 'NIL', AZ).string_append(A, Z, AZ) :-	var(AZ),	string(A),	string(Z),	!,	'QP.PACK2'(A, Z, 'T',  AZ).string_append(A, Z, AZ) :-	atom(AZ),	string_size(AZ, AZ_len),	(   atom(A) ->	    string_size(A, A_len),	    (   atom(Z) ->		string_size(Z, Z_len),		!,		Z_len is AZ_len-A_len,		subequal(AZ, 0,     A_len, A),		subequal(AZ, A_len, Z_len, Z)	    ;   var(Z) ->		!,		Z_len is AZ_len-A_len,		subequal(AZ, 0,     A_len, A),		subthing(AZ, A_len, Z_len, Z)	    )	;   var(A) ->	    (   atom(Z) ->		!,		string_size(Z, Z_len),		A_len is AZ_len-Z_len,		subequal(AZ, A_len, Z_len, Z),		subthing(AZ, 0,     A_len, A)	    ;   var(Z) ->		!,		'Enum'(0, AZ_len, A_len),				Z_len is AZ_len-A_len,		subthing(AZ, 0,     A_len, A),		subthing(AZ, A_len, Z_len, Z)	    )	).string_append(A, Z, AZ) :-	string(AZ),	string_size(AZ, AZ_len),	(   string(A) ->	    string_size(A, A_len),	    (   string(Z) ->		string_size(Z, Z_len),		!,		Z_len is AZ_len-A_len,		subequal(AZ, 0,     A_len, A),		subequal(AZ, A_len, Z_len, Z)	    ;   var(Z) ->		!,		Z_len is AZ_len-A_len,		subequal(AZ, 0,     A_len, A),		subthing(AZ, A_len, Z_len, Z)	    )	;   var(A) ->	    (   string(Z) ->		!,		string_size(Z, Z_len),		A_len is AZ_len-Z_len,		subequal(AZ, A_len, Z_len, Z),		subthing(AZ, 0,     A_len, A)	    ;   var(Z) ->		!,		'Enum'(0, AZ_len, A_len),				Z_len is AZ_len-A_len,		subthing(AZ, 0,     A_len, A),		subthing(AZ, A_len, Z_len, Z)	    )	).string_append(A, Z, AZ) :-	Goal = string_append(A,Z,AZ),	(   atom(AZ) ->	    must_be_symbol(A, 1, Goal),	    must_be_symbol(Z, 2, Goal)	;   string(AZ) ->	    must_be_string(A, 1, Goal),	    must_be_string(Z, 2, Goal)	;   nonvar(AZ) ->	    must_be_name(AZ, 3, Goal)	;   atom(Z) ->	% var(AZ)	    must_be_symbol(A, 1, Goal)	;   string(Z) ->	    must_be_string(A, 1, Goal)	;   nonvar(Z) ->	    must_be_name(Z, 2, Goal)	;   atom(A) -> % var(Z), var(AZ)	    must_be_symbol(Z, 2, Goal)	;   string(A) ->	    must_be_string(Z, 2, Goal)	;   must_be_name(A, 1, Goal)	).%   string_size(+StringOrAtom, ?Length)%   is true when Length = (NCHARS StringOrAtom), that is it unifies%   Length with the number of characters in (the name of) StringOrAtom.%   Note that fat characters count as 1 character each.%   string_length/2 is included as a courtesy to Arity; it is slower but%   does better checking.string_length(StringOrAtom, Length) :-	name(StringOrAtom),	!,	string_size(StringOrAtom, Length).string_length(StringOrAtom, Length) :-	Goal = string_length(StringOrAtom, Length),	must_be_name(StringOrAtom, 1, Goal).%   string_char(?Index, +StringOrAtom, ?Char)%   unifies Char with the XNS code of the Indexth character of StringOrAtom.%   If Index is not an integer, is less than one, or exceeds the length of%   StringOrAtom, it just fails quietly.  If StringOrAtom is not an atom,%   it just fails quietly.  It should report an error if StringOrAtom is%   unbound, and it would be good in other non-atom cases too.string_char(Index, StringOrAtom, Char) :-	name(StringOrAtom),	(   integer(Index), !,	% first two arguments well formed	    'NTHCHARCODE'(Index, StringOrAtom, C),	    integer(C),		% NTHCHARCODE returns NIL on failure	    Char = C	;   var(Index), !,	% first two arguments well formed	    string_size(StringOrAtom, Size),	    'Enum'(1, Size, Index),	    'NTHCHARCODE'(Index, StringOrAtom, Char)	).string_char(Index, StringOrAtom, Char) :-	%   The first two arguments are not well formed.	Goal = string_char(Index, StringOrAtom, Char),	(   name(StringOrAtom) ->	    must_be_integer(Index, 1, Goal)	;   must_be_name(StringOrAtom, 2, Goal)	).%   nth_char(?Index, +StringOrAtom, ?Char)%   is identical to string_char, except that Index counts from 0, which%   is inconsistent with almost every other string package including%   this one, and doesn't fit well into the algebra of strings.%   Read it as, "if you throw away the first Index characters%   of StringOrAtom, the XNS code of the next character is Char".nth_char(Index, StringOrAtom, Char) :-	name(StringOrAtom),	(   integer(Index), !,	% first two arguments well formed	    K is Index+1,	    'NTHCHARCODE'(K, StringOrAtom, C),	    integer(C),		% NTHCHARCODE returns NIL on failure	    Char = C	;   var(Index), !,	% first two arguments well formed	    string_size(StringOrAtom, Size),	    'Enum'(1, Size, K),	    'NTHCHARCODE'(K, StringOrAtom, Char),	    Index is K-1	).nth_char(Index, StringOrAtom, Char) :-	%   The first two arguments are not well formed.	Goal = nth_char(Index, StringOrAtom, Char),	(   name(StringOrAtom) ->	    must_be_integer(Index, 1, Goal)	;   must_be_name(StringOrAtom, 2, Goal)	).%   char_atom(Char, Atom)%   is true when Char is the XNS code of some character and Atom is an%   atom whose name is that single character, e.g. char_atom(46, .).%   BEWARE: the other ports will enumerate Char=0..255, but the Xerox%   port will NOT enumerate the possible characters, because it is not%   possible.  There are 65536 plausible character codes (actually,%   XNS has restrictions which mean that there are only 35,532 codes%   available) but there can be at most 65536 atoms in Interlisp-D,%   so we'd run out of atoms if we tried to enumerate the characters.%   This restriction does not apply to char_string/2.char_atom(Char, Atom) :-	(   nonvar(Atom) ->	    atom(Atom),	    string_size(Atom, 1),	    'NTHCHARCODE'(Atom, 1, Char)	;   integer(Char) ->	    Char >= 0, Char =< 65535,	% Koto has "fat" characters	    'QP.PACKC'([Char], Atom)	;   var(Char) ->	    must_be_between(0, 65535, Char, 1, char_atom(Char,Atom))	).'Enum'(L, U, X) :-	(   L =:= U -> X = L	;   L < U, ( X = L ; M is L+1, 'Enum'(M, U, X) )	).%   char_string(Char, String)%   is true when Char is the XNS code of some character and String is a%   string whose name is that single character, e.g. char_string(46, $.$).%   This *will* enumerate all characters and one-character strings, as%   there is no limit on the number of strings and they are garbage%   collected, unlike atoms.char_string(Char, String) :-	(   nonvar(String) ->	    string(String),	    string_size(String, 1),	    'NTHCHARCODE'(String, 1, Char)	;   integer(Char) ->	    Char >= 0, Char =< 65535,	% Koto has "fat" characters	    'CONCATCODELIST'([Char], String)	;   var(Char) ->	    'Enum'(0, 65535, Char),	    'CONCATCODELIST'([Char], String)	).%   index(Pattern, String, Offset)%   is true when Pattern occurs in String after skipping Offset characters.%   Apart from the fact that String cannot be generated (because there are%   generally infinitely many suitable values) this is fully relational;%   index(Pattern, String, 0) is not only an easy way to check whether%   Pattern is a prefix of String, it is an efficient way too.index(Pattern, String, Offset) :-	substring(String, Pattern, Offset, _, _).%   string_search(Pattern, String, Offset)%   is identical to index/3; and is included as a courtesy to Arity.string_search(Pattern, String, Offset) :-	substring(String, Pattern, Offset, _, _).%   substring(StringOrAtom, SubString, Offset, Length)%   unifies SubString with the substring of StringOrAtom starting Offset%   characters from the beginning and continuing for Length characters.%   For example, substring(lamentation, mentat, 2, 6).substring(StringOrAtom, SubString, Offset, Length) :-	substring(StringOrAtom, SubString, Offset, Length, _).%   substring(StringOrAtom, SubString, F, S, B)%   unifies SubString with the substring of StringOrAtom which contains%   S(elect) characters, is preceded by F(ront) characters in StringOr-%   Atom, and is followed by B(ack) characters in StringOrAtom.  For%   example, substring(othello, hell, _, 4, 1).  Only StringOrAtom has%   to be supplied; this predicate is capable of generating the rest.substring(Whole, Part, DropFromHead, LengthOfPart, DropFromTail) :-	var(Part),	!,	string_size(Whole, LengthOfWhole),	% checks that name(Whole)	'Plus'(DropFromHead, LengthOfPart, DropFromTail, LengthOfWhole),	subthing(Whole, DropFromHead, LengthOfPart, Part).substring(Whole, Part, DropFromHead, LengthOfPart, DropFromTail) :-	string_size(Part, LengthOfPart),	% checks that name(Part)	!,	string_size(Whole, LengthOfWhole),	% checks that name(Whole)	same_type_of_constant(Whole, Part),	LengthOfPart =< LengthOfWhole,	(   nonvar(DropFromHead) ->		DropFromTail is LengthOfWhole-LengthOfPart-DropFromHead,		subequal(Whole, DropFromHead, LengthOfPart, Part)	;   nonvar(DropFromTail) ->		DropFromHead is LengthOfWhole-LengthOfPart-DropFromTail,		subequal(Whole, DropFromHead, LengthOfPart, Part)	;   /* otherwise we must search */		'MKSTRING'(Whole, String),		'MKSTRING'(Part, Pattern),		'Enum'(Pattern, String, 0, DropFromHead),		DropFromTail is LengthOfWhole-LengthOfPart-DropFromHead	).%   subthing(+Whole, +Drop, +Take, -Part)%   is called when Whole is known to be an atom or a string,%   Drop and Take are known to be integers (but not necessarily in range),%   and Part is known to be a variable.%   We want Part = take(Take, drop(Drop, Whole)).%   The Lisp function QP.SUBTHING is called to do this.%   It signals a range failure by returning Part=0, which we catch here.subthing(Whole, Drop, Take, Part) :-	'QP.SUBTHING'(Whole, Drop, Take, Part),	\+ (Part = 0).%   subequal(+Whole, +Drop, +Take, +Part)%   is called when Whole is known to be an atom or a string,%   Drop and Take are known to be integers (but not necessarily in range),%   and Part is known to be a a constant.%   We want Part = take(Take, drop(Drop, Whole)).%   The Lisp function QP.SUBEQUAL is called to test this.%   It returns T or NIL; NIL indicates range failure as well as false.subequal(Whole, Drop, Take, Part) :-	'QP.SUBEQUAL'(Whole, Drop, Take, Part, 'T').%   subchars(StringOrAtom, Chars, Offset, Length)%   unifies Chars with the substring of StringOrAtom starting Offset%   characters from the beginning and continuing for Length characters.%   For example, substring(lamentation, "mentat", 2, 6).%   More generally, this will accept ANY kind of string as first%   argument, and always takes a chars second argument.subchars(StringOrAtom, Chars, Offset, Length) :-	subchars(StringOrAtom, Chars, Offset, Length, _).%   subchars(StringOrAtom, Chars, F, S, B)%   unifies Chars with the substring of StringOrAtom which contains%   S(elect) characters, is preceded by F(ront) characters in StringOr-%   Atom, and is followed by B(ack) characters in StringOrAtom.  For%   example, subchars(othello, "hell", _, 4, 1).  Only StringOrAtom has%   to be supplied; this predicate is capable of generating the rest.%   More generally, this will accept ANY kind of string as first%   argument, and always takes a chars second argument.subchars(Whole, Chars, DropFromHead, LengthOfPart, DropFromTail) :-	string_size(Whole, LengthOfWhole),	% checks that name(Whole)	proper_chars(Chars, LengthOfPart, Flag),	(   nonvar(DropFromHead), Flag >= 0 ->		DropFromTail is LengthOfWhole-LengthOfPart-DropFromHead,		DropFromTail >= 0,		'SUBCHARCODES'(Whole, DropFromHead, LengthOfPart, Chars)	;   nonvar(DropFromTail), Flag >= 0 ->		DropFromTail >= 0,		DropFromHead is LengthOfWhole-LengthOfPart-DropFromTail,		DropFromHead >= 0,		'SUBCHARCODES'(Whole, DropFromHead, LengthOfPart, Chars)	;   Flag > 0 ->				% fully specified		string_chars(Pattern, Chars),	% so we can do this!		'MKSTRING'(Whole, String),		'Enum'(Pattern, String, 0, DropFromHead),		DropFromTail is LengthOfWhole-LengthOfPart-DropFromHead	;   /* otherwise, we don't know what Chars looks like */		'Plus'(DropFromHead, LengthOfPart, DropFromTail, LengthOfWhole),		'SUBCHARCODES'(Whole, DropFromHead, LengthOfPart, Chars)	).%   midstring(Whole, Part, Fringes, Before, Length, After)%   is true when Whole, Part, and Fringes are all three atoms or are%   all three strings,%	Whole = Alpha || Part || Omega,%	Fringes = Alpha || Omega,%	string_size(Alpha, Before),%	string_size(Part,  Length),%	string_size(Omega, After)%   midstring/[5,4,3] leave the trailing arguments unspecified.%   This family has many uses.%   To divide Whole into a Front and Back from the left:%	midstring(Whole, Front, Back, 0, FrontLength, _)%   To divide Whole into a Front and Back from the right:%	midstring(Whole, Front, Back, 0, _, BackLength)%   To concatenate Front and Back giving Whole:%	midstring(Whole, Front, Back, 0)%   To insert Part into Fringes at a given Position, yielding Whole:%	midstring(Whole, Part, Fringes, Position)%   To delete Drop characters from Whole, yielding Fringes:%	midstring(Whole, _, Fringes, Take, Drop)%   Either Whole must be a non-variable, or%   both Part and Fringes must be non-variables.%   If neither is the case, an instantiation fault is reported.%   If either is the case, the relation can go ahead.midstring(Whole, Part, Fringes) :-	midstring(Whole, Part, Fringes, _, _, _).midstring(Whole, Part, Fringes, Before) :-	midstring(Whole, Part, Fringes, Before, _, _).midstring(Whole, Part, Fringes, Before, Length) :-	midstring(Whole, Part, Fringes, Before, Length, _).midstring(Whole, Part, Fringes, DropFromHead, LengthOfPart, DropFromTail) :-	var(Whole),	!,	string_size(Part, LengthOfPart),	string_size(Fringes, LengthOfFringes),	same_type_of_constant(Part, Fringes),	(   integer(DropFromHead) ->	    DropFromTail is LengthOfFringes-DropFromHead,	    DropFromTail >= 0,	    DropFromHead >= 0	;   integer(DropFromTail) ->	    DropFromHead is LengthOfFringes-DropFromTail,	    DropFromHead >= 0,	    DropFromTail >= 0	;   var(DropFromHead), var(DropFromTail) ->	    'Enum'(LengthOfFringes, DropFromTail),	    DropFromHead is LengthOfFringes-DropFromTail	),	'QP.INSERT'(Fringes, DropFromHead, Part, Whole).midstring(Whole, Part, Fringes, DropFromHead, LengthOfPart, DropFromTail) :-	var(Part),	!,	string_size(Whole, LengthOfWhole),	% checks that name(Whole)	(   var(Fringes) -> true	;   string_size(Fringes, LengthOfFringes),	    LengthOfPart is LengthOfWhole-LengthOfFringes,	    LengthOfPart >= 0	),	'Plus'(DropFromHead, LengthOfPart, DropFromTail, LengthOfWhole),	subthing(Whole, DropFromHead, LengthOfPart, Part),	'Qoutstr'(Whole, DropFromHead, LengthOfPart, Fringes).midstring(Whole, Part, Fringes, DropFromHead, LengthOfPart, DropFromTail) :-	string_size(Part, LengthOfPart),	% checks that name(Part)	!,	string_size(Whole, LengthOfWhole),	% checks that name(Whole)	LengthOfFringes is LengthOfWhole-LengthOfPart,	LengthOfFringes >= 0,	(   var(Fringes) -> true	;   string_size(Fringes, LengthOfFringes)	),	(   nonvar(DropFromHead) ->		DropFromTail is LengthOfWhole-LengthOfPart-DropFromHead,		subequal(Whole, DropFromHead, LengthOfPart, Part)	;   nonvar(DropFromTail) ->		DropFromHead is LengthOfWhole-LengthOfPart-DropFromTail,		subequal(Whole, DropFromHead, LengthOfPart, Part)	;   /* otherwise we must search */		'MKSTRING'(Whole, String),		'MKSTRING'(Part, Pattern),		'Enum'(Pattern, String, 0, DropFromHead),		DropFromTail is LengthOfWhole-LengthOfPart-DropFromHead	),	'Qoutstr'(Whole, DropFromHead, LengthOfPart, Fringes).'Qoutstr'(Whole, DropFromHead, LengthOfPart, Fringes) :-	nonvar(Fringes),	!,	'QP.OUTEQUAL'(Whole, DropFromHead, LengthOfPart, Fringes, 'T').'Qoutstr'(Whole, DropFromHead, LengthOfPart, Fringes) :-	'QP.DELETE'(Whole, DropFromHead, LengthOfPart, Fringes),	name(Fringes).%   'Enum'(Pattern, String, Offset, Place)%   is true when Pattern occurs in String starting at Place (i.e.%   after Place characters have been dropped) and Place >= Offset,'Enum'(Pattern, String, Offset, Place) :-	X is Offset+1,	'STRPOS'(Pattern, String, X, 'NIL', 'NIL', Y),	integer(Y),		% STRPOS didn't fail	(   Place is Y-1	% shift origin	;   'Enum'(Pattern, String, Y, Place)	).%   'Plus'(A, B, C, T)  is true when, for a fixed value T,%   A, B, and C are non-negative integers and A+B+C = T.%   If they have to be generated, A is enumerated before%   B, which is in turn enumerated before C.'Plus'(A, B, C, T) :-	(   nonvar(A) ->		A >= 0,		(   nonvar(B) ->			B >= 0, C is T-A-B, C >= 0		;   nonvar(C) ->			C >= 0, B is T-A-C, B >= 0		;   /* otherwise */			D is T-A, D >= 0, 'Enum'(D, C), B is D-C		)	;   nonvar(B) ->		B >= 0,		(   nonvar(C) ->			C >= 0, A is T-B-C, A >= 0		;   /* otherwise */			D is T-B, D >= 0, 'Enum'(D, C), A is D-C		)	;   nonvar(C) ->		D is T-C, D >= 0, 'Enum'(D, B), A is D-B	;   /* otherwise */		'Enum'(T, D), A is T-D, 'Enum'(D, C), B is D-C	).'Enum'(X, X).'Enum'(U, X) :-	U > 0, V is U-1,	'Enum'(V, X).%   span_left(String, Set, Before, Length, After)%   succeeds when name(String) &%   Set is an atom (or a string) or a character (ASCII code) or a%   non-empty list of character codes, or not(X) where X is one of%   those permitted forms, and String can be decomposed as%	String = Protos ^ Mesos ^ Eschatos%	string_size(Protos, Before)%	string_size(Mesos, Length)%	string_size(Eschatos, After)%	no character in Protos belongs to Set%	every character in Mesos belongs to Set%	Protos and Mesos are as long as possible%	and Mesos is non-empty.%   This predicate is functional in the first two arguments.%   span_left(String, Set, Before, After) and%   span_left(String, Set, Before)%   are identical to span_left/5 except that they lack the parameter or two.%   Thus to skip leading spaces, one might do%	span_left(String, " ", Before),%	substring(String, Trimmed, Before, _, 0).%   while to extract a single blank-delimited token, one might do%	span_left(String, " ", Before, Length, After),%	substring(String, Token, Before, Length, After).span_left(String, Set, Before) :-	span_left(String, Set, Before, _, _).span_left(String, Set, Before, Length) :-	span_left(String, Set, Before, Length, _).span_left(String, Set, Before, Length, After) :-	name(String),	collect_set(Set, Chars, 'T', 'NIL', Flag),	!,	'QP.SPAN'(Chars, String, Flag, 'LEFT', [Before,Length,After]).span_left(String, Set, Before, Length, After) :-	span_error(String, Set, span_left(String,Set,Before,Length,After)).%   span_right(String, Set, Before, Length, After),%   span_right(String, Set,         Length, After), and%   span_right(String, Set,                 After)%   are similar to span_left/[3,4,5], except that they scan the string from the%   right to the left.  So the meaning of span_right/5 is that%	String = Protos ^ Mesos ^ Eschatos%	string_size(Protos, Before)%	string_size(Mesos, Length)%	string_size(Eschatos, After)%	no character in Eschatos belongs to Set%	every character in Mesos belongs to Set%	Protos and Mesos are as long as possible%	and Mesos is non-empty.%   Thus to remove trailing spaces, one might do%	span_right(String, " ", After),%	substring(String, Trimmed, 0, _, After)%   while to trim a string at both ends one would do%   span_trim(String, Trimmed) :-%	span_left(String, " ", Before), !,%	span_right(String, " ", After),%	substring(String, Trimmed, Before, _, After).%   span_trim(String, Trimmed) :-%	substring(String, Trimmed, 0, 0).span_right(String, Set, After) :-	span_right(String, Set, _, _, After).span_right(String, Set, Length, After) :-	span_right(String, Set, _, Length, After).span_right(String, Set, Before, Length, After) :-	name(String),	collect_set(Set, Chars, 'T', 'NIL', Flag),	!,	'QP.SPAN'(Chars, String, Flag, 'RIGHT', [Before,Length,After]).span_right(String, Set, Before, Length, After) :-	span_error(String, Set, span_right(String,Set,Before,Length,After)).span_trim(String, Trimmed) :-	span_trim(String, " ", Trimmed).span_trim(String, Set, Trimmed) :-	span_trim(String, Set, Before, Length, After),	substring(String, Trimmed, Before, Length, After).span_trim(String, Set, Before, Length, After) :-	name(String),	collect_set(Set, Chars, 'T', 'NIL', Flag),	!,	'QP.SPAN'(Chars, String, Flag, 'TRIM', [Before,Length,After]).span_trim(String, Set, Before, Length, After) :-	span_error(String, Set, span_trim(String,Set,Before,Length,After)).span_error(String, Set, Goal) :-	name(String),	!,	types:must_be_('character set', Set, 2, Goal).span_error(String, _, Goal) :-	types:must_be_('symbol or string', String, 1, Goal).collect_set(not(Set), Chars, True, False, Flag) :- !,	nonvar(Set),	collect_set(Set, Chars, False, True, Flag).collect_set(Table, Table, True, _, True) :-	atomic(Table),	'TYPENAME'(Table, 'CHARTABLE'),	!.collect_set(Set, Chars, True, _, True) :-	collect_text_1(Set, Chars).%   gensym(V)%   unifies V with a new atom.  The prefix used is '%'.gensym(V) :-	gensym('%', V).%   gensym(Prefix, V)%   unifies V with a new atom whose name begins with Prefix and ends%   with a number.  E.g. gensym(a,X), gensym(a,Y), gensym(a,Z) might%   bind X to a1, Y to a2, Z to a3.  It only succeeds once per call,%   to get another binding for V you have to call it again.  There's%   a separate counter for each prefix.gensym(Prefix, V) :-	var(V),	atomic(Prefix),	(   retract(gensym_counter(Prefix, M))	;   M = 0	),	!,	N is M+1,	asserta(gensym_counter(Prefix, N)),	'QP.PACK2'(Prefix, N, 'NIL', V).%   cgensym(Prefix, V)%   binds V to a new atom unless it is already bound.  Thus%   cgensym(a, fred) would succeed, but cgensym(a, X) would bind%   X to a new atom, maybe a4.  "c" standard for "conditional".cgensym(Prefix, V) :-	nonvar(V), !,	atomic(V),	atomic(Prefix).cgensym(Prefix, V) :-	gensym(Prefix, V).%   In Xerox Quintus Prolog, there is a difference between%   compare_strings(R, S1, S2) and compare(R, S1, S2).%   compare_strings/3 accepts atoms and strings, but doesn't%   care which, so that compare_strings(=, 'a', $a$).%   In other versions of Quintus Prolog, the only difference%   between compare_strings/3 and compare/3 is that the former%   reports an error if its last two arguments are not atoms.%   compare_strings(R, S1, S2) and%   compare_strings(R, S1, S2, -1) have the same effect,%   except for the wording of the error message.  A typical%   padding character for compare_strings/4 is "0' " = 32.compare_strings(Rel, String1, String2) :-	text(String1),	text(String2),	!,	'QP.STRCOMPARE'(String1, String2, -1, Rel).compare_strings(Rel, String1, String2) :-	Goal = compare_strings(Rel,String1,String2),	must_be_name(String1, 2, Goal),	must_be_name(String2, 3, Goal).compare_strings(Rel, String1, String2, Pad) :-	text(String1),	text(String2),	(   integer(Pad),	    Pad >= -1, Pad < 65535,	    PadCode is Pad	;   character(Pad),	    'NTHCHARCODE'(Pad, PadCode)	),	!,	'QP.STRCOMPARE'(String1, String2, PadCode, Rel).compare_strings(Rel, String1, String2, Pad) :-	Goal = compare_strings(Rel,String1,String2,Pad),	must_be_name(String1, 2, Goal),	must_be_name(String2, 3, Goal),	must_be_between(-1, 65535, Pad, 4, Goal).%   The  following members of the "name"/2 family differ from the ones%   in the system only in the thoroughness of their error reporting./*  name1(Atomic, Chars)    is supposed to have exactly the same effect as the built in    predicate name(Atomic, Chars).  The errors are	arg 1 is not an atom (a number, a constant)	arg 2 is not a list of at most 255 character codes	instantiation fault*/name1(Atomic, Chars) :-	(   number(Atomic) ->	    'RADIX'(10, Old),	    'CHCON'(Atomic, Text),	    'RADIX'(Old, _),	    Chars = Text	;   name(Atomic) ->	    'CHCON'(Atomic, Chars)	;   var(Atomic),	    'interlisp proper chars'(Chars),	    (   signed_nbr(Chars, []) ->		correct_exponent(Chars, Corrected),		'PACKC'(Corrected, Atomic),		number(Atomic)	    ;   'QP.PACKC'(Chars, Atomic)	    )	;   /* wrong type of constant, or bad character list */	    name_error(name1, atomic, Atomic, Chars)	).%   atom_chars(Atom, Chars)%   is true when Atom is an atom, and Chars is a list of integers being%   the XNS codes of the name of Atom.%   In 2.0, this is a built-in predicate.  atom_chars1/2 is the old version.atom_chars1(Atom, Chars) :-	(   atom(Atom)	->  'CHCON'(Atom, Chars)	;   var(Atom),	    'interlisp proper chars'(Chars)	->  'QP.PACKC'(Chars, Atom),	    atom(Atom)	;   /* too long or too many variables */	    name_error(atom_chars, atom, Atom, Chars)	).number_chars1(Number, Chars) :-	(   number(Number)	->  'RADIX'(10, Old),	    'CHCON'(Number, Text),	    'RADIX'(Old, _),	    Chars = Text	;   var(Number),	    'interlisp proper chars'(Chars)	->  signed_nbr(Chars, []),	    correct_exponent(Chars, Corrected),	    'PACKC'(Corrected, Number),	    number(Number)	;   /* too long or too many variables */	    name_error(number_chars, number, Number, Chars)	).'interlisp proper chars'(Chars) :-	proper_chars(Chars, Length, Flag),	Flag > 0,		% all thin(1) or fat(2) character codes	Length < 256.		% InterLisp limit for PACKCstring_chars(String, Chars) :-	(   string(String)	->  'CHCON'(String, Chars)	;   var(String),	    proper_chars(Chars, Length, Flag),	    Flag > 0,	    Length < 65535	% Interlisp limit for string length	->  'CONCATCODELIST'(Chars, String)	;   name_error(string_chars, string, String, Chars)	)./*  name_error(PredicateName, TypeName, Thing, Chars)    is called when one of the three name/2-style predicates is unhappy    with its arguments.   If Thing is a variable, Chars should be a    proper_chars.  Otherwise, Thing should satisfy the type test    named by TypeName.  TypeName/1 should be a Prolog predicate!*/name_error(PredicateName, TypeName, Thing, Chars) :-	(   nonvar(Thing) ->		format(user_error,		    '~N! Type failure in argument 1 of ~w/2~n',		    [PredicateName]),		format(user_error,		    '! ~w expected, but found ~q~n',		    [TypeName, Thing])	;   proper_chars(Chars, _, State) ->	    (   State > 0 ->		format(user_error,		    '~N! Argument 2 of ~w/2 is too long~n',		    [PredicateName])	    ;   format(user_error,		    '~N! Instantiation fault in argument 2 of ~w/2~n',		    [PredicateName])	    )	;   /* var Goal, not proper chars Thing */		format(user_error,		    '~N! Type failure in argument 2 of ~w/2~n',		    [PredicateName]),		format(user_error,		    '! List of character codes expected, but found ~q~n',		    [Chars])	),	Goal =.. [PredicateName,Thing,Chars],	format(user_error, '! Goal: ~q~n', [Goal]),	fail.%   signed_nbr(S0,S) is true when the characters in the difference list%   S0-S look like a Prolog number.  There is a problem: Prolog allows%   either case of "e", whereas Interlisp only likes upper-case "E".%   We patch around that with correct_exponent.signed_nbr --> optional_sign, unsigned_nbr.	optional_sign --> ( "+" | "-" | "" ), !.unsigned_nbr --> digits1, ( "." -> digits1, optional_exponent | "" ).digits1 --> [C], {C >= "0", C =< "9"}, !, digits0.digits0 --> [C], {C >= "0", C =< "9"}, !, digits0.digits0 --> "".optional_exponent --> ( "e" | "E" ), !, optional_sign, digits1.optional_exponent --> "".correct_exponent([], []).correct_exponent([101 /* e */|Cs], Cs) :- !.correct_exponent([D|Ds], [D|Cs]) :-	correct_exponent(Ds, Cs).%   atom_string(?Atom, ?String)%   converts between atoms and strings.  The only errors it%   reports are instantiation faults.atom_string(Atom, String) :-	(   atom(Atom) ->	    'MKSTRING'(Atom, String)	;   var(Atom), string(String) ->		'MKATOM'(String, Atom),		atom(Atom)	;   var(Atom), var(String) ->		must_be_symbol(Atom, 1, atom_string(Atom,String))	).%   number_string(?Number, ?String)%   converts between numbers and strings.  The only errors it%   reports are instantiation faults.  number_string(X, $fred$)%   is not an error, it is just plain false, so is not reported.%   We have the same problem here that we have with name1/2,%   namely that Interlisp-D (Koto) absolutely and inflexibly%   demands a capital E for the exponent.  We use the same code%   to check and correct for this problem as number_chars1/2.%   OOPS: there is an incompatibility!  Xerox Quintus Prolog will%   always yield a capital "E" when name*/2, number_chars*/2, or%   number_string/2 is given a floating point number as first argument,%   but UNIX/VMS Quintus Prolog will always yield a lower case "e".%   This code has the additional merit of not even trying to call%   PACKC (or MKATOM or whatever) if the string argument doesn't%   look like a number.number_string(Number, String) :-	(   string(String) ->		'CHCON'(String, Chars),		signed_nbr(Chars, []),		correct_exponent(Chars, Corrected),		'PACKC'(Corrected, Number),		number(Number)	;   var(String), number(Number) ->		'RADIX'(10, Old),		'MKSTRING'(Number, String),		'RADIX'(Old, _)	;   var(String), var(Number) ->		must_be_number(Number, 1, number_string(Number,String))	).%   same_type_of_constant(X, Y)%   is true when X and Y are both atomic and are the same type.%   E.g. both integers, both floats, both atoms, both strings.%   Lisp distinguishes several kinds of integer; Prolog doesn't.same_type_of_constant(X, Y) :-	(   integer(X) -> integer(Y)	;   atomic(X), atomic(Y),	    'TYPENAME'(X, Type),	    'TYPENAME'(Y, Type)	).%   string_size(+StringOrAtom, ?Length)%   unifies Length with the number of characters in (the name of) StringOrAtom.%   This version of the predicate relies on the Lisp interface to catch bad%   arguments; a later version may check more thoroughly.  I put the other%   Lisp functions here just to have them all in one place.:- lisp_predicate('NCHARS',		string_size(+,[-])).:- lisp_predicate('NTHCHARCODE',	'NTHCHARCODE'(+,+,[-])).:- lisp_predicate('CONCATCODELIST',	'CONCATCODELIST'(+,[-])).:- lisp_predicate('MKATOM', 		'MKATOM'(+,[-])).:- lisp_predicate('MKSTRING',		'MKSTRING'(+,[-])).:- lisp_predicate('PACKC',		'PACKC'(+,[-])).:- lisp_predicate('CHCON',		'CHCON'(+,[-])).:- lisp_predicate('QP.PACK',		'QP.PACK'(+,[-])).:- lisp_predicate('QP.PACK2',		'QP.PACK2'(+,+,+,[-])).:- lisp_predicate('QP.PACKC',		'QP.PACKC'(+,[-])).:- lisp_predicate('CONCATLIST',		'CONCATLIST'(+,[-])).:- lisp_predicate('RADIX',		'RADIX'(+,[-])).:- lisp_predicate('SUBCHARCODES',	'SUBCHARCODES'(+,+,+,[-])).:- lisp_predicate('QP.INSERT',		'QP.INSERT'(+,+,+,[-])).:- lisp_predicate('QP.DELETE',		'QP.DELETE'(+,+,+,[-])).:- lisp_predicate('QP.OUTEQUAL',	'QP.OUTEQUAL'(+,+,+,+,[-])).:- lisp_predicate('QP.SUBTHING',	'QP.SUBTHING'(+,+,+,[-])).:- lisp_predicate('QP.SUBEQUAL',	'QP.SUBEQUAL'(+,+,+,+,[-])).:- lisp_predicate('QP.STRCOMPARE',	'QP.STRCOMPARE'(+,+,+,[-])).:- lisp_predicate('TYPENAME',		'TYPENAME'(+,[-])).:- lisp_predicate('STRPOS',		'STRPOS'(+,+,+,+,+,[-])).:- lisp_predicate('QP.SPAN',		'QP.SPAN'(+,+,+,+,[-])).:- load_foreign_files([library('STRINGS')], []).