%   Package: aggregate%   Author : Richard A. O'Keefe%   Updated: 3/26/87%   Defines: an aggregation operator for data-base-style queries%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved.:- module(aggregate, [	aggregate/3   ]).:- meta_predicate	aggregate(+, 0, ?)./*----------------------------------------------------------------------    Data base query languages usually provide so-called "aggregation"    operations.  Given a relation, aggregation specifies	(a) a column of the relation	(b) an operation, one of {sum,max,min,ave,var} or more    One might, for example, ask	PRINT DEPT,SUM(AREA) WHERE OFFICE(_ID,DEPT,AREA,_OCCUPANT)    and get a table of <Department,TotalArea> pairs.  The Prolog    equivalent of this might be	dept_office_area(Dept, TotalArea) :-		aggregate(sum(Area),		    I^O^office(I,Dept,Area,O), TotalArea).    where Area is the column and sum(_) is the aggregation operator.    We can also ask who has the smallest office in each department:	smallest_office(Dept, Occupant) :-		aggregate(min(Area),			I^O^office(I,Dept,Area,O), MinArea),		office(_, Dept, MinArea, Occupant).    This module provides an aggregation operator in Prolog:	    aggregate(Template, Generator, Results)    where Template is	    <operator>(<expression>)    or	<constructor>(<arg>,...,<arg>)    where	each <arg> is <operator>(<expression>)    and	<operator> is sum | min | max 		{for now}    and	<expression> is an arithmetic expression    Results is unified with a form of the same structure as Template.    Things like mean and standard deviation can be calculated from    sums, e.g. to find the average population of countries (defined    as "if you sampled people at random, what would be the mean    size of their answers to the question 'what is the population    of your country?'?") we could do    ?-	aggregate(x(sum(Pop),sum(Pop*Pop)),		  Country^population(Country,Pop),		  x(People,PeopleTimesPops)),	AveragePop is PeopleTimesPops/People.    Note that according to this definition, aggregate/3 FAILS if    there are no solutions.  For max(_), min(_), and many other    operations (such as mean(_)) this is the only sensible    definition (which is why bagof/3 works that way).  Even if    bagof/3 yielded an empty list, aggregate/3 would still fail.    Concerning the minimum and maximum, it is convenient at times to    know Which term had the minimum or maximum value.  So we write	min(Expression, Term)	max(Expression, Term)    and in the constructed term we will have	min(MinimumValue, TermForThatValue)	max(MaximumValue, TermForThatValue)    So another way of asking who has the smallest office is	smallest_office(Dept, Occupant) :-		aggregate(min(Area,O),			I^office(I,Dept,Area,O), min(_,Occupant)).----------------------------------------------------------------------*/:- mode	aggregate(+, +, ?),	    first_result(+, -),		first_result(+, +, +),	    next_result(+, +, -),		next_result(+, +, +, +),	    rest_results(+, +, ?).sccs_id('"@(#)87/03/26 aggregate.pl	98.2"').aggregate(Template, Generator, Results) :-	bagof(Template, Generator, [First|Rest]),	first_result(First, Result0),	rest_results(Rest, Result0, Results).first_result(sum(E), X) :- !,	call(X is E).first_result(min(E), X) :- !,	call(X is E).first_result(max(E), X) :- !,	call(X is E).first_result(min(E,T), min(X,T)) :- !,	call(X is E).first_result(max(E,T), max(X,T)) :- !,	call(X is E).first_result(Pat, Ans) :-	functor(Pat, F, N),	functor(Ans, F, N),	first_result(N, Pat, Ans).first_result(0, _, _) :- !.first_result(N, Pat, Ans) :-	arg(N, Pat, PatArg),	first_result(PatArg, AnsArg),	arg(N, Ans, AnsArg),	M is N-1,	first_result(M, Pat, Ans).rest_results([], Acc, Results) :- !,	Results = Acc.rest_results([Head|Tail], Acc, Results) :-	next_result(Head, Acc, Next),	rest_results(Tail, Next, Results).next_result(sum(E), X, Next) :- !,	call(Next is X+E).next_result(min(E), X, Next) :- !,	call(V is E),	(   V < X -> Next = V | Next = X   ).next_result(max(E), X, Next) :- !,	call(V is E),	(   V > X -> Next = V | Next = X   ).next_result(min(E,T), min(Y,U), min(Z,V)) :- !,	call(X is E),	(   X < Y -> Z=X,V=T | Z=Y,V=U   ).next_result(max(E,T), max(Y,U), max(Z,V)) :- !,	call(X is E),	(   X > Y -> Z=X,V=T | Z=Y,V=U   ).next_result(Pat, Acc, Next) :-	functor(Pat,  F, N),	functor(Next, F, N),	next_result(N, Pat, Acc, Next).next_result(0, _, _, _) :- !.next_result(N, Pat, Acc, Next) :-	arg(N, Pat, PatArg),	arg(N, Acc, AccArg),	next_result(PatArg, AccArg, NextArg),	arg(N, Next, NextArg),	M is N-1,	next_result(M, Pat, Acc, Next)./*  Note: call(Ans is Expr) is used to evaluate expressions;    this avoids the problem that compiled Dec-10 Prolog and    all modes of Quintus Prolog demand that source variables    must be bound to numbers in "is" calls not so protected.*/