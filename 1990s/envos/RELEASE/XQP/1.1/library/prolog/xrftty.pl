%  File   : XRFTTY.PL%  Author : Dave Bowen%  Updated: 6/24/86%  Purpose: Terminal interaction for XREF%----------------------------------------------------------------------%declarations%:- module(xrftty, [get_crf/2,                   get_globals_file/1,                   get_title/1,                   get_update_module_declarations/1,                   get_width/1,                   readtonl/1,		   expand_file_name/2,                   see_chek/1,                   tell_chek/1,                   warn/2]).:- use_module(xrfdef, [check_filename/1,                       check_width/1]).%end%% ----------------------------------------------------------------------% Various "gets" do not erase anymore.  "tidy" does that.% Instead, they record new values, after verifying files are writable.  A.V.G.				/* Get name for cross-refs file: instantiate				   both File and Chars */get_crf(File, Chars) :- 			%  Name specified in DEF file?	recorded('$define', cross_ref_file(File), _Ref) ->		tell_chek(File), told,		!,		name(File, Chars).get_crf(File, Chars) :-	repeat,	    ttynl, display('Filename for Cross-Reference listing: '), ttyflush, 	    readtonl(Chars),	    name(File, Chars),			%  Read file name from terminal	    check_filename(File),		%  Check name is appropriate	    tell_chek(File), told,	!,	recorda('$define', cross_ref_file(File), _Ref).				/* Get required page width */get_width(W) :- 	recorded('$define', width(W), _Ref) ->	% Was it specified in DEF file?		check_width(W),		!.get_width(W) :-					% No, prompt for it. 	repeat,	    ttynl, display('Width: '), ttyflush,	    readtonl(Chars),	    name(W, Chars),	    check_width(W),	!,	recorda('$define',width(W),_Ref).				/* Get title for Cross-Reference listing */get_title(T) :-	recorded('$define',title(T),_Ref),	% Specified in a DEF file?	!.get_title(T) :-	ttynl, display('Title: '), ttyflush,	% Not in DEF file, ask for it.	readtonl0(T),				% Empty line is allowed.	recorda('$define',title(T),_Ref).			/* Gets filename (or "no") for import/export lists */get_globals_file(File) :-			% Specified in DEF file?	recorded('$define', globals_file(File), _Ref) ->		(   File == no -> true		|   File \== no -> tell_chek(File), told		),		!.get_globals_file(File) :-			% No, ask for it.	repeat,	    yesno('Do you want a listing of imports/exports', Ans),	    (   Ans = no ->		    File = no	    |		otherwise ->		    ttynl, display('Filename for imports/exports: '), ttyflush, 		    readtonl(Chars),		    name(File, Chars),		    tell_chek(File), told	    ),	!,	recorda('$define', globals_file(File), _Ref).				/* Does the user want us to update the				   Import/Export lists in all the files? */get_update_module_declarations(Yes_or_No) :-	recorded('$define', update_module_declarations(Y_or_N), _Ref) ->		( Y_or_N == yes ; Y_or_N == no ),		Yes_or_No = Y_or_N.get_update_module_declarations(Yes_or_No) :-	yesno('Alter the module/use_module declarations in your files',	      Yes_or_No),	recorda('$define', update_module_declarations(Yes_or_No), _Ref).yesno(Question, Answer) :-	repeat,	    ttynl, display(Question), display('? '), ttyflush,	    readtonl(Ans),	    (   Ans = [ 89 /* Y */|_], !, Answer = yes	    ;   Ans = [121 /* y */|_], !, Answer = yes	    ;   Ans = [ 78 /* N */|_], !, Answer = no	    ;	Ans = [110 /* n */|_], !, Answer = no	    ;   display('! Answer y(es) or n(o)'), fail	    ).			/* Give a warning about a predicate */warn(M:Pred, State) :-	functor(Pred, F, N),	telling(File), tell(user),	write('** WARNING: '), write(M:F/N is State), nl,	tell(File).warn(Pred, State) :-	functor(Pred, F, N),	F \== ':',	telling(File), tell(user),	write('** WARNING: '), write(F/N is State), nl,	tell(File)./* Expand file name w/o abort if it is library(something) & doesn't exist.   Fail quietly if 2nd arg doesn't unify with full name.   Complain and fail if 1st arg is library(something) and is not found.*/expand_file_name(File,FullName) :-	prolog_flag(fileerrors, OldFE, off),	(   absolute_file_name(File,ExpName) ->		prolog_flag(fileerrors, _, OldFE),		FullName = ExpName	|	    otherwise ->		prolog_flag(fileerrors, _, OldFE),		display('! Can''t find '), display(File), ttynl,		fail	).				/* See file or complain if it doesn't exist */see_chek(File) :-	prolog_flag(fileerrors, OldFE, off),	(   open(File,read,S) ->		prolog_flag(fileerrors, _, OldFE),		set_input(S)	|	    otherwise ->		prolog_flag(fileerrors, _, OldFE),		display('! Can''t read '), display(File), ttynl,		fail	).				/* Open file for output or complain */tell_chek('TTY:') :- !,		% Dec-10 hack around a Dec-10 bug	tell(user).tell_chek(File) :-	prolog_flag(fileerrors, OldFE, off),	(   tell(File) ->		prolog_flag(fileerrors, _, OldFE)	|	    otherwise ->		prolog_flag(fileerrors, _, OldFE),		display('! Can''t write '), display(File), ttynl,		fail	).% Low level input routines				/* Read a line, returning character list */readtonl(Cs) :-	readln(ignore_blanks, Cs).		% - for reading file namesreadtonl0(Cs) :-	readln(keep_blanks, Cs).		% - for reading textreadln(Flag, Cs) :- 	get0(C),	actionchar(Flag, C, Cs).actionchar(_, 13, []) :- !.			% end of line: return []actionchar(_, -1, _) :- !, fail.		% EOF: failactionchar(ignore_blanks, C, Cs) :-		% ignore layout characters	C =< 32, !, 				%  (incl. space) if reqd	readln(ignore_blanks, Cs).actionchar(Flag, C, [C|Crest]) :-		% other: construct list	readln(Flag, Crest).			% on Dec-10: convert to UPPER