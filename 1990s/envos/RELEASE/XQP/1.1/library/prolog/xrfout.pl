%  File   : XRFOUT.PL%  Author : Dave Bowen%  Updated: 6/10/86%  Purpose: Output module for XREF.% do_export_modules and do_import_modules added by Vince Pecora July 1986%----------------------------------------------------------------------%declarations%:- module(xrfout, [do_export_modules/2,                   do_import_modules/1,                   do_output/1,                   writes/1]).:- use_module(xrf, [crecord/2]).:- use_module(xrfcol, [defn_file/2]).:- use_module(xrfmod, [update_declarations/3]).:- use_module(xrftty, [get_crf/2,                       get_globals_file/1,                       get_title/1,                       get_update_module_declarations/1,                       get_width/1,                       tell_chek/1]).:- use_module(library(basics), [append/3,                                member/2]).%end%% ----------------------------------------------------------------------				/* O/P cross-ref listing in reqd format.*/do_output(Dbase) :-	get_crf(File, _),		%  Get filename for cross-ref listing	tell_chek(File), !,		%  Get another if can't 'tell' it	get_title(Title),	get_width(Width),	write_centre('**********************************', Width), nl,	write_centre('* PROLOG CROSS REFERENCE LISTING *', Width), nl,	write_centre('**********************************', Width), nl,	nl,	write_centre(Title, Width), nl,	nl, nl,	write('PREDICATE               FILE          CALLED BY'), nl,	nl, nl,	process_for_multifile_entries(Dbase),	f_output(Dbase, Width), !,	%  Output cross-reference list	told,	nl, write('Cross-reference listing written to '), write(File), nl,	out_globals.			%  Output import/export lists if reqdprocess_for_multifile_entries(Dbase) :-   gather_multifile_preds(Dbase, Pred_list), % Pred_list = list of name/arity   save_reordered_preds(Pred_list, Dbase).gather_multifile_preds(Data, Pred_list):-   setof(Name_arity, get_multifile(Data, Name_arity), Pred_list), !.gather_multifile_preds(_, []).get_multifile(Data, F/N):-   member(e(F, M, N, f(_, _)), Data),   functor(Pred, F, N),   recorded('$multi_file', m(M:Pred,_), _).save_reordered_preds([],_) :- !.save_reordered_preds([N/A|Rest], Data) :-   save_reordered_terms(N/A, Data),   save_reordered_preds(Rest,Data).save_reordered_terms(Name/Arity, Data):-   gather_duplicate_terms(Name/Arity, Data, Term_list),   sort_terms_for_printing(Term_list, Sorted_term_list),   crecord('$duplicate_multifile', sorted(Name/Arity, Sorted_term_list)).gather_duplicate_terms(F/N, Data, Term_list) :-   setof(Term, get_term_from_list(F,N,Data,Term), Term_list).get_term_from_list(F, N, Data, e(F, M, N, f(I, Cs))) :-   member(e(F, M, N, f(I, Cs)), Data).sort_terms_for_printing(Terms_in, Terms_out) :-   gather_non_nulls(Terms_in, Terms1),   gather_nulls(Terms_in, Terms2),   append(Terms1, Terms2, Terms_out).gather_non_nulls(Terms_in, Non_null_term_list) :-   setof(Non_null, get_non_null_term(Terms_in, Non_null),   	 Non_null_term_list), !.gather_non_nulls(_, []).gather_nulls(Terms_in, Null_term_list) :-   setof(Null, get_null_term(Terms_in, Null), Null_term_list), !.gather_nulls(_, []).get_non_null_term(Terms, e(F, M, N, f(I, Cs))) :-   member(e(F, M, N, f(I, Cs)), Terms),   Cs \== [].get_null_term(Terms, e(F, M, N, f(I, []))) :-   member(e(F, M, N, f(I, [])), Terms).				/* formatted output of cross refs */f_output(Dbase, Width) :-	member(e(F,M,N,f(I,Cs)), Dbase),	write_front_and_back_filter(F, M, N, I, Width, Cs, 38),	fail.f_output(_, _).write_front_and_back_filter(F, _M, N, _I, Width, _Cs, Pad_cols) :-   recorded('$duplicate_multifile', sorted(F/N, List), Key), !,   erase(Key),   crecord('duplicate_multifile', written(F/N)),   write_front_and_back_list(List, Width, Pad_cols).write_front_and_back_filter(F, _M, N, _I, _Width, _Cs, _Pad_cols) :-   recorded('duplicate_multifile', written(F/N), _), !.write_front_and_back_filter(F, M, N, I, Width, Cs, Pad_cols) :-   write_front_and_back(F, M, N, I, Width, Cs, Pad_cols).write_front_and_back_list([],_,_) :- nl,!.write_front_and_back_list([e(F, M, N, f(I, Cs))|Tail], Width, Pad_cols) :-   functor(Pred, F, N),   f_front(F, M, N, I, Width),   f_back(Cs, M:Pred, I, Pad_cols, _, Width), nl,   write_front_and_back_list(Tail, Width, Pad_cols).write_front_and_back(F, M, N, I_obj, Width, Cs, Pad_cols) :-   functor(Pred,F,N),   recorded('$foreign_pred',   	    pred_to_module(Pred, C_fcn, Lang, Module_name),_), !,   recorded('$module',file_to_module(File_name, Module_name),_),   write_front_and_back1(F, M, N, File_name, Width, Cs, Pad_cols),   write_front_and_back1(C_fcn, '', foreign(Lang), I_obj, Width, [c(F, M, N)],   			 Pad_cols).write_front_and_back(F, M, N, I, Width, Cs, Pad_cols) :-   write_front_and_back1(F, M, N, I, Width, Cs, Pad_cols).   write_front_and_back1(F, '', foreign(Lang), I, Width, Cs, Pad_cols) :- !,	f_front(F, '', foreign(Lang), I, Width),	f_back(Cs, _, I, Pad_cols, _, Width),	nl, nl.write_front_and_back1(F, M, N, I, Width, Cs, Pad_cols) :-   	functor(Pred, F, N),	f_front(F, M, N, I, Width),	f_back(Cs, M:Pred, I, Pad_cols, _, Width),	nl, nl.				/* Write predicate and file where defined */f_front(F, _M, N, I, W) :-	f_write_pred(F, N, 0, C1, W),	pos(C1, 24),	f_write(I, 24, C2, W),	pos(C2, 38).				/* Either write callers or 'NOT CALLED' */f_back([], M:Pred, _, C1, C2, W) :-   	nonvar(Pred),   	recorded('$multi_file',m(M:Pred, _), _), !,	f_write('MULTIFILE', C1, C2, W).f_back([], M:Pred, File, C1, C2, W) :-   	nonvar(Pred),   	recorded('$dynamic',d(M:Pred, File), _), !,	f_write('NOT CALLED (but is declared dynamic)', C1, C2, W).f_back([], _, _, C1, C2, W) :- !,	f_write('NOT CALLED', C1, C2, W).f_back([H|T], _, _, C1, C2, W) :-	sort([H|T], Sorted),	write_callers(Sorted, C1, C2, W).				/* List callers of the predicate */write_callers([], C, C, _) :- !.write_callers([c(F,A,N)|Zs], C1, C4, W) :-	f_write_pred(A:F, N, C1, C2, W),	put(32),	C3 is C2+1,	write_callers(Zs, C3, C4, W).				/* L is the length in chars of X */charlength(X, L) :-	atomic(X), !,			% Is X an atom or integer?	name(X, Chars),	length(Chars, L).charlength(A:F/N, L) :-			% Is it of the form A:F/N	atom(A),			% with A a plausible module name	atom(F), integer(N), !,		% and  F/N a plausible functor?	name(A, S0),	length(S0, L0),	name(F, S1),	length(S1, L1),	name(N, S2),	length(S2, L2),	L is L0+L1+L2+2.charlength(F/N, L) :-			% Is it of the form F/N	atom(F), integer(N), !,		% with F/N a plausible functor?	name(F, S1),	length(S1, L1),	name(N, S2),	length(S2, L2),	L is L1+L2+1.charlength(X, L) :-			%Handle arity one terms also   X =.. [Name, Arg], !,   charlength(Name, L1),   charlength(Arg, L2),   L is L1 + L2 + 2.charlength(X, L) :-			% Must be a list (string)	length(X, L).			% is this used at all?					% Will need to cap the word.capword(Word_in, Word_out) :-   name(Word_in, [First|L]),   First >= "a",   First =< "z", !,   First1 is First - 32,   name(Word_out, [First1|L]).capword(X,X).   				/* Write predicate remembering format info */f_write_pred('<user>', 0, C1, C2, W) :- !,	makeroom(6, C1, C2, W),	write('<user>').f_write_pred(F, foreign(Lang), C1, C2, W) :- !,	charlength(F,L),	charlength(Lang,L1),	L2 is L + L1 + 6,	makeroom(L2, C1, C2, W),	capword(Lang, Lang1),	format('~a (in ~a)',[F,Lang1]).f_write_pred(A:F, N, C1, C2, W) :-	functor(P, F, N),	setof(M, R^recorded('$pred1', M:P, R), DefList),	length(DefList, Ndefs),	Ndefs > 1,	!,	charlength(A:F/N, L),	makeroom(L, C1, C2, W),	write(A:F), put(47), write(N).f_write_pred(_A:F, N, C1, C2, W) :-	!,	charlength(F/N, L),	makeroom(L, C1, C2, W),	write(F), put(47), write(N).f_write_pred(F, N, C1, C2, W) :-	charlength(F/N, L),	makeroom(L, C1, C2, W),	write(F), put(47), write(N).				/* Write atom ditto */f_write(X, C1, C2, W) :-	charlength(X, L),	makeroom(L, C1, C2, W),	write(X).				/* Make sure there is room to write L */ makeroom(L, C1, C2, W) :-	(   L+C1 < W, C2 is C1+L	;   C1 =< 38, C2 is C1+L	;   nl, tab(38), C2 is L+38	),  !.				/* Write X in the centre of current line */write_centre(X, W) :-	charlength(X, L),	Space is (W-L) >> 1,	tab(Space),	writes(X).				/* Move from column From to To */pos(From, To) :-	(   To > From, Space is To-From	;   nl, Space = To	),  !,	tab(Space).				/* Write out list of chars (string), or atom */writes([]) :- !.writes([C|Cs]) :- !,	put(C),	writes(Cs).writes(X) :-	write(X).%	do_export_modules was substituted for do_publics in order to %	produce module declarations instead of the old DEC-10 public %	declarations - Vince Pecora 23 May 86%	#OLD VERSION# do_publics(Exports),	% write the exported predicates%	do_import_modules was substituted for do_imports in order to produce%	use_module declarations instead of the old DEC-10 import %	comments - Vince Pecora 23 May 86%	#OLD VERSION# do_imports(Imports),	% and imported predicatesout_globals :-	setof(File, erase_file_record(File), Files),	(   get_globals_file(Globals),	% if we are to write a globals file	    Globals \== no,	    tell_chek(Globals),		% and we can open it	    !,				% commit to that file	    (   member(file(FileName,Exports,Imports), Files),		write('%   FILE:  '), write(FileName), nl, nl,		do_export_modules(FileName,Exports),		do_import_modules(Imports),		nl, fail		% for each File we've read	    ;   true			% this'd be "forall" but the Dec-10	    ),				% compiler doesn't understand that	    told,			% close the Globals file	    write('Globals listing written to '), write(Globals), nl	|	   true			% do nothing if no file wanted	),	( get_update_module_declarations(Ans) ->	% if we are to update	    ( Ans == yes ->		% declarations in each source file	      ( member(file(FileName,Exports,Imports), Files),		update_declarations(FileName, Exports, Imports),		fail	      |		true	      ),	      write('Source files updated.'), nl	    |	      true	    )	|	    true	),	!.out_globals./*  erase_file_record(File)    enumerates triples file(FileName,Exports,Imports) where FileName is the    name of a file that XREF has looked at, Exports is a list of    export(Functor,Arity) pairs naming predicates exported from that File,    and imports is a list of import(Functor,Arity,FromFile) triples naming    predicates imported from other files and indicating which.    It has the side effect of erasing all this information from the data    base, which only matters if you're using XREF inside something else.*/erase_file_record(file(FileName,Exports,Imports)) :-	recorded('$file'(_,_), '$file'(FileName,_Module), Ref),	erase(Ref),	export_records(FileName, Exports),	import_records(FileName, Imports).export_records(FileName, Exports) :-	setof(Export, erase_export_record(FileName,Export), Exports), !.export_records(_, []).erase_export_record(FileName, export(Symbol,Arity)) :-	recorded(FileName, '$entry'(FileName, _M, Pred), Ref),	erase(Ref),	functor(Pred, Symbol, Arity).import_records(FileName, Imports) :-	setof(Import, erase_import_record(FileName,Import), Imports), !.import_records(_, []).erase_import_record(FileName, import(Symbol,Arity,FromFile)) :-	recorded(FileName, '$ext'(FileName, _, Pred), Ref),	erase(Ref),	functor(Pred, Symbol, Arity),	defn_file(_M:Pred, FromFile).				/* Output public decls (exports) for a file */do_publics([]) :- !.do_publics(L) :-	do_publics(L, ':- public').do_publics([], _) :- !,		put(46), nl, nl.do_publics([export(F,N)|L], Atom) :-	write(Atom), nl,	put(9), writeq(F/N),	do_publics(L, (',')).			/* Output export module declarations for a file */% No.  Do this for [] too. A.V.G.   do_export_modules(_,[]) :- !.do_export_modules(File_name,L) :-	create_module_name(File_name,Module_name), !,	format(':- module(~q, [', [Module_name]),	current_output(S),	line_position(S,Tab),	do_export_modules1(L,Tab), nl, nl.do_export_modules(_,[export(F,N)|Rest]) :-  % File not a module, 	functor(P,F,N),				    % must be foreign.	recorded('$foreign_pred',pred_to_module(P, _, _, Module_name),_), !,	strip_name(Module_name, Module_name1),   	format(':- module(~q, [', [Module_name1]),	current_output(S),	line_position(S,Tab),	do_export_modules1([export(F,N)|Rest],Tab), nl, nl.create_module_name('UNDEFINED','UNDEFINED').create_module_name(File_name, Module_name) :-   recorded('$module',file_to_module(File_name,Module_name1),_), !,   strip_name(Module_name1,Module_name).strip_name(Module_name1,Module_name) :-   name(Module_name1,L),   strip(L,L1),   name(Module_name,L1).strip(Full_name,Name) :-   strip1(Full_name,Name1),   strip2(Name1,Name).strip1(With_pl,Name) :-   append(Name,".pl",With_pl), !.strip1(X,X).strip2(With_slashes,Name) :-   append(_,[47|Name1],With_slashes), !,   strip2(Name1,Name).strip2(X,X).do_export_modules1([],_) :- !,   	format('~a~n', [']).']).do_export_modules1([export(F,N)|L],Tab) :-	writeq(F/N),	(  L \== []  ->  format('~a~n~*|',[',',Tab])	|  otherwise ->  true	),	do_export_modules1(L,Tab).calculate_tab(File_name,Increment,Tab) :-   name(File_name,List),   length(List,Tab1),   Tab is Tab1 + Increment.				/* Output import decls for a file */do_imports([]) :- !.do_imports(L) :-	do_imports(L, '%- import').do_imports([], _) :- !,	put(46), nl, nl.do_imports([import(F,N,I)|L], Atom) :-	write(Atom), nl,	put(37), put(9), writeq(F/N),	charlength(F/N, W), Space is 32-W,	tab(Space), write('from '), write(I),	do_imports(L, (',')).			/* Output import module declarations for a file */do_import_modules([]) :- !.do_import_modules(Import_list) :-   translate_foreign_filenames(Import_list, New_imports), !,   get_file_list(New_imports, File_list),   make_import_statements(File_list, New_imports).translate_foreign_filenames([], []) :- !.translate_foreign_filenames([import(Name, Arity, File)|L],   			    [import(Name, Arity, New_file)|L1]) :-   translate_obj_filenames(File, Name, Arity, New_file),   translate_foreign_filenames(L, L1).translate_obj_filenames(_, Name, Arity, Output_file_name):-   functor(P, Name, Arity),   recorded('$foreign_pred', pred_to_module(P, _, _, M), _), !,   recorded('$module',file_to_module(Output_file_name, M),_).translate_obj_filenames(File, _, _, File).get_file_list(Import_list, File_list) :-   setof(File, get_file(File, Import_list), File_list),   asserta(file_list(File_list)).get_file(File, Import_list) :-   member(import(_,_,File), Import_list).make_import_statements(File_list, Import_list) :-   member(File,File_list),   collect_predicates(File, Import_list, Predicate_list),   output_import_statement(File, Predicate_list),   fail.make_import_statements(_,_) :- nl, nl.collect_predicates(File, Import_list, Predicate_list):-   setof(Pred, get_pred(File, Import_list, Pred), Predicate_list).get_pred(File, Import_list, predicate(Name,Arity)) :-   member(import(Name,Arity,File), Import_list).output_import_statement(_,[]) :- !.output_import_statement(_,[predicate(N,A)|Rest]) :-   functor(P,N,A),   recorded('$foreign_pred',pred_to_module(P, _, _, Module_name),_),    recorded('$module', file_to_module(File, Module_name),_), !,   format(':- use_module(~q, [', [File]),   current_output(S),   line_position(S,Tab),   output_import_statement1([predicate(N,A)|Rest],Tab).output_import_statement(File_name, L) :-   format(':- use_module(~q, [', [File_name]),   current_output(S),   line_position(S,Tab),   output_import_statement1(L,Tab).output_import_statement1([],_) :- !,   format('~a~n', [']).']).output_import_statement1([predicate(Name,Arity)|L],Tab) :-   writeq(Name/Arity),   (  L \== []  ->  format('~a~n~*|',[',',Tab])   |  otherwise ->  true   ),   output_import_statement1(L,Tab).