%   Package: maplist%   Author : Lawrence Byrd + Richard A. O'Keefe%   Updated: 3/26/87%   Purpose: Various "function" application routines based on library(call).%   Adapted from shared code written by the same authors; all changes%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved.:- module(maplist, [	checklist/2,	convlist/3,	exclude/3,	include/3,	maplist/3,	scanlist/4,	some/2,	somechk/2,	sublist/3   ]).:- meta_predicate	checklist(1, +),	    check_list(+, 1),	convlist(2, +, ?),	    conv_list(+, ?, 2),	exclude(1, +, ?),	    exclude_list(+, ?, 1),	include(1, +, ?),	    include_list(+, ?, 1),	maplist(2, ?, ?),	    map_list(?, ?, 2),	scanlist(3, +, ?, ?),	    scan_list(+, ?, ?, 3),	some(1, ?),	somechk(1, +),	sublist(1, +, ?).:- use_module(library(call), [	call/2,	call/3,	call/4   ]).sccs_id('"@(#)87/03/26 maplist.pl	98.1"')./* pred	checklist(void(T), list(T)),	    check_list(list(T), void(T)),	convlist(void(T,U), list(T), list(U)),	    conv_list(list(T), list(U), void(T,U)),	exclude(void(T), list(T), list(T)),	    exclude_list(list(T), list(T), void(T)),	include(void(T), list(T), list(T)),	    include_list(list(T), list(T), void(T)),	maplist(void(T,U), list(T), list(U)),	    map_list(list(T), list(U), void(T,U)),	scanlist(void(U,T,U), list(T), U, U),	    scan_list(list(T), U, U, void(U,T,U)),	some(void(T), list(T)),	somechk(void(T), list(T)),	sublist(void(T), list(T), list(T)).    The <foo>list predicates are retained for backwards compatibility with    the Dec-10 Prolog library.  They all take a void(...) argument as their    first argument.  The <foo>_list predicates take the void(...)    argument *last* so as to exploit indexing on the first argument.    Putting the Pred argument first is still considered to be the better    style as far as human reading and comprehension is concerned, and    putting it last is not recommended for exported predicates.*/%   checklist(Pred, List)%   suceeds when Pred(Elem) succeeds for each Elem in the List.%   In InterLisp, this is EVERY.  It is also MAPC.%   List should be a proper list.checklist(Pred, List) :-	check_list(List, Pred).check_list([], _).check_list([Head|Tail], Pred) :-	call(Pred, Head),	check_list(Tail, Pred).%   convlist(Rewrite, OldList, NewList)%   is a sort of hybrid of maplist/3 and sublist/3.%   Each element of NewList is the image under Rewrite of some%   element of OldList, and order is preserved, but elements of%   OldList on which Rewrite is undefined (fails) are not represented.%   Thus if foo(X,Y) :- integer(X), Y is X+1.%   then convlist(foo, [1,a,0,joe(99),101], [2,1,102]).%   Either OldList or NewList should be a proper list.convlist(Pred, Olds, News) :-	conv_list(Olds, News, Pred).conv_list([], [], _).conv_list([Old|Olds], NewList, Pred) :-	call(Pred, Old, New),	!,	NewList = [New|News],	conv_list(Olds, News, Pred).conv_list([_|Olds], News, Pred) :-	conv_list(Olds, News, Pred).%   exclude(Pred, List, SubList)%   succeeds when SubList is the SubList of List containing all the%   elements for which Pred(Elem) is *false*.  That is, it removes%   all the elements satisfying Pred.  List should be a proper list.exclude(Pred, List, SubList) :-	exclude_list(List, SubList, Pred).exclude_list([], [], _).exclude_list([Head|Tail], SubList, Pred) :-	call(Pred, Head),	!,	exclude_list(Tail, SubList, Pred).exclude_list([Head|Tail], [Head|SubTail], Pred) :-	exclude_list(Tail, SubTail, Pred).%   include(Pred, List, SubList)%   succeeds when SubList is the SubList of List containing all the%   elements for which Pred(Elem) is *true*.  That is, it retains%   all the elements satisfying Pred.  List should be a proper list.include(Pred, List, SubList) :-	include_list(List, SubList, Pred).include_list([], [], _).include_list([Head|Tail], SubList, Pred) :-	call(Pred, Head),	!,	SubList = [Head|SubTail],	include_list(Tail, SubTail, Pred).include_list([_|Tail], SubList, Pred) :-	include_list(Tail, SubList, Pred).%   maplist(Pred, OldList, NewList)%   succeeds when Pred(Old,New) succeeds for each corresponding%   Old in OldList, New in NewList.  In InterLisp, this is MAPCAR. %   It is also MAP2C.  Isn't bidirectionality wonderful?%   Either OldList or NewList should be a proper list.maplist(Pred, Olds, News) :-	map_list(Olds, News, Pred).map_list([], [], _).map_list([Old|Olds], [New|News], Pred) :-	call(Pred, Old, New),	map_list(Olds, News, Pred).%   scanlist(Pred, List, Init, Answer)%   maps a ternary relation Pred down a list.  If the list is%   [X1,X2,...,Xn], the computation is%   Pred(Init,X1,Y2), Pred(Y2,X2,Y3), ..., Pred(Yn,Xn,Answer)%   So if Pred is plus/3, scanlist(plus,List,0,Answer) puts the%   sum of the list elements in Answer.%   List should be a proper list.scanlist(Pred, List, Init, Answer) :-	scan_list(List, Init, Answer, Pred).scan_list([], Answer, Answer, _).scan_list([Head|Tail], SoFar, Answer, Pred) :-	call(Pred, SoFar, Head, Next),	scan_list(Tail, Next, Answer, Pred).%   some(Pred, List)%   succeeds when Pred(Elem) succeeds for some Elem in List.  It will%   try all ways of proving Pred for each Elem, and will try each Elem%   in the List.  somechk/2 is to some/2 as memberchk/2 is to member/2;%   you are more likely to want somechk with its single solution.%	member(X,L)	<-> some(=(X), L).%	memberchk(X, L)	<-> somechk(=(X), L).%	some(Pred,L)    <-> member(X, L), call(Pred,X).%   In InterLisp this is SOME.%   This acts on backtracking like member/2; List should be a proper list.some(Pred, [Head|_]) :-	call(Pred, Head).some(Pred, [_|Tail]) :-	some(Pred, Tail).somechk(Pred, [Head|_]) :-	call(Pred, Head),	!.somechk(Pred, [_|Tail]) :-	somechk(Pred, Tail).%   sublist(Pred, List, SubList)%   succeeds when SubList is the sub-sequence of the List containing all%   the Elems of List for which Pred(Elem) succeeds.%   List should be a proper list.sublist(Pred, List, SubList) :-	include_list(List, SubList, Pred)./*  Example:	maplist(sublist(atom), [[a,1,2,b],[3,c],[4,5,6],[d,e]], L)    binds L = [[a,b],[c],[],[d,e]].*/