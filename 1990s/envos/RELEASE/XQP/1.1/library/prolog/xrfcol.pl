/* XRFCOL.PL :  Collecting up module of XREF.						Dave Bowen						Updated: 7/8/86*/%----------------------------------------------------------------------%declarations%:- module(xrfcol, [	collect/1,	defn_file/2   ]).:- use_module(xrf, [	crecord/2   ]),   use_module(xrfout, [	do_output/1   ]),   use_module(xrftty, [	warn/2   ]).%end%% ----------------------------------------------------------------------/******************************************************************************Data for collecting up   $ext(File, Module, Predicate)			  Held on key: File.			  $ext(I, M, P) means P is an external (import)					of module M, file I   $entry(File, Module, Predicate)			  Held on key: File.			  $entry(I, M, P) means P is an entry (export)					  of module M, file I******************************************************************************/collect(L1) :-	fentries(L),	%  Make list of all predicates with all associated data	qsort(L, L1, []).	%  Sort them				/* Find entries. Search through all encountered				   predicates */fentries([e(F,M,N,f(I,Cs))|L]) :- 	recorded('$pred', M:P, Ptr),	% Find a predicate P	erase(Ptr),			% prevent looping when looking	crecord('$pred1', M:P),		%  for multiply defined preds	functor(P, F, N),		% P is F/N	defn_file(M:P, I),		% M:P is defined in file I	callers(M:P, I, Cs),		% Cs is list of callers c(F,A,N)	(   I = 'UNDEFINED', maybe_warn(M:P, _, 'not defined')	;   true	),	(   Cs = [], maybe_warn(M:P, I, 'not called')	;   true	),	multiple_defn(M:P, [I], L, L1),		% Any multiple definitions?	(   nonvar(L), maybe_warn(M:P, I, 'multiply defined')	;   true	),	!,	fentries(L1).fentries([]).maybe_warn(M:P, I, _) :-	recorded('$dynamic', d(M:P,I), _),	!,	warn(M:P, 'not called but is declared dynamic').maybe_warn(M:P, _, _) :-	recorded('$multi_file', m(M:P,_), _),	!.maybe_warn(M:P, _, Msg) :-	warn(M:P, Msg)./* Find I where M:P is defined, or else set I='UNDEFINED'.*/defn_file(M:P, I) :-	got_defn(M:P, I),	!.defn_file(_, 'UNDEFINED')./* Is M:P defined in a file, or is it known? */got_defn(M:P, I) :- 	recorded(P, '$defn'(I,M,P), _).got_defn(M:P, I) :- 	recorded(P, '$known'(I,M), _).				/* Look for multiple defns of P. List contains				   all places P is already known to be defined.				   3rd arg is var & tail of e-list. Instantiate				   its head to any multiple defn, and return				   4th arg as new var tail of e-list */multiple_defn(M:P, List, [e(F,M,N,f(I,[]))|L], L1) :-	got_defn(M:P, I),	notin(I, List),	!,	functor(P, F, N),	multiple_defn(M:P, [I|List], L, L1).multiple_defn(_, _, L, L).				/* True if X is not in List */notin(_, []).notin(X, [H|T]) :-	X \== H,	notin(X, T).				/* Return a (possibly empty) list of all				   callers of the procedure P */callers(M:P, I, [c(F,A,N)|Cs]) :-	recorded(P, '$caller'(M:P,F,N,J,A), Ptr),	erase(Ptr), !,	exts(I, J, A, M:P),	callers(M:P, I, Cs).callers(_, _, [])./*  Record externals.    M:P is defined in I (entry/export), used in J (external/import).*/exts(_, J, A, _:P) :-	recorded('$foreign_pred', pred_to_module(P,_,_,M), _),	recorded('$module', file_to_module(File,M), _),	!,	exts1(File, J, A, M:P).exts(I, J, A, M:P) :-	exts1(I, J, A, M:P).exts1(I, I, _, _) :- !.			% Do nothing if defn & use in same fileexts1(I, 'UNDEFINED', user, M:P) :- !,	% Get here if P was mark_interpreted	entries(I, M, P).		% Record P is exported from Iexts1(I, J, A, M:P) :-	entries(I, M, P),		% Record P is exported from I	crecord(J, '$ext'(J,A,P)).	% Record P is imported to J/* Record exports */entries('UNDEFINED', user, _) :- !.entries(I, M, P) :-   crecord(I, '$entry'(I,M,P)).				/* Quick sort of functor entries. qsort(A,B,C)				   returns B as the concatenation of sorted				   A and C (which should already be sorted). */qsort([X|L], R, R0) :-	partition(L, X, L1, L2),	qsort(L2, R1, R0),	qsort(L1, R, [X|R1]).qsort([], R, R).				/* Partition list arg1 on the value of Y				   into arg3 and arg4 */partition([X|L], Y, [X|L1], L2) :-	lte(X, Y), !,	partition(L, Y, L1, L2).partition([X|L], Y, L1, [X|L2]) :-	partition(L, Y, L1, L2).partition([], _, [], []).				/* Comparison predicate for sort */lte(e(F1,M1,N1,_), e(F2,M2,N2,_)) :-	lt3(F1, M1, N1, F2, M2, N2).				/* Order by functor name, module, then arity */lt3(F, M, N1, F, M, N2) :- !,	N1 =< N2.lt3(F, M1, _N1, F, M2, _N2) :- !,	M1 @=< M2.lt3(F1, _, _, F2, _, _) :-	F1 @=< F2.