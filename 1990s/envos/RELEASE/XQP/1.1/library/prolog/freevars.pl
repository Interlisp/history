%   Package: free_variables%   Author : Richard A. O'Keefe%   Updated: 8/28/87%   Purpose: SUPPORT for not.pl,setof.pl,foreach.pl%   Adapted from shared code written by the same author; all changes%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved./*  In earlier releases of the Dec-10 Prolog, C Prolog, and Quintus    Prolog libraries, the predicate free_variables/4 was defined    elsewhere (typically not.pl), and used freely by any library    file which included that one.  However, I don't really want to    make free_variables/4 a public predicate of library(not), so    this predicate has been split out into its own file.    This is support for not.pl, setof.pl, and foreach.pl.  It is    not meant for general use.    In August 1987, term_variables/3 was added to support the new    grouped_{bag,set}_of/4 predicates.*/:- module(free_variables, [	free_variables/4,	term_variables/3   ]).:- mode	explicit_binding(+, +, -, -),	free_variables(+, +, +, -),	    free_variables(+, +, +, +, -),	list_is_free_of(+, +),	term_is_free_of(+, +),	    term_is_free_of(+, +, +),	term_variables(+, +, -),	    term_variables(+, +, +, -).sccs_id('"@(#)87/08/28 freevars.pl	10.1"').%   In order to handle variables properly, we have to find all the %   universally quantified variables in the Generator.  All variables%   as yet unbound are universally quantified, unless%	a)  they occur in the template%	b)  they are bound by X^P, setof, or bagof%   free_variables(Generator, Template, OldList, NewList)%   finds this set, using OldList as an accumulator.free_variables(Term, Bound, VarList, [Term|VarList]) :-	var(Term),	term_is_free_of(Bound, Term),	list_is_free_of(VarList, Term),	!.free_variables(Term,_Bound, VarList, VarList) :-	var(Term),	!.free_variables(Term, Bound, OldList, NewList) :-	explicit_binding(Term, Bound, NewTerm, NewBound),	!,	free_variables(NewTerm, NewBound, OldList, NewList).free_variables(Term, Bound, OldList, NewList) :-	functor(Term, _, N),	free_variables(N, Term, Bound, OldList, NewList).free_variables(0,_Term,_Bound, VarList, VarList) :- !.free_variables(N, Term, Bound, OldList, NewList) :-	arg(N, Term, Argument),	free_variables(Argument, Bound, OldList, MidList),	M is N-1, !,	free_variables(M, Term, Bound, MidList, NewList).%   explicit_binding checks for goals known to existentially quantify%   one or more variables.  In particular \+ is quite common.  This%   table is supposed to contain all the library predicates which act%   roughly like bagof; you should not use these names yourself.explicit_binding(\+ _Goal,			Bound, fail,	 Bound).explicit_binding(not(_Goal),			Bound, fail,	 Bound).explicit_binding(forall(_,_),			Bound, fail,	 Bound).explicit_binding(Var^Goal,			Bound, Goal,	 Bound+Var).explicit_binding(setof(Var,Goal,Set),		Bound, Goal-Set, Bound+Var).explicit_binding(bagof(Var,Goal,Bag),		Bound, Goal-Bag, Bound+Var).explicit_binding(set_of(Var,Goal,Set),		Bound, Goal-Set, Bound+Var).explicit_binding(bag_of(Var,Goal,Bag),		Bound, Goal-Bag, Bound+Var).explicit_binding(set_of_all(Var,Goal,Set),	Bound, Goal-Set, Bound+Var).explicit_binding(bag_of_all(Var,Goal,Bag),	Bound, Goal-Bag, Bound+Var).explicit_binding(findall(Var,_Goal,List),	Bound, List,	 Bound+Var).explicit_binding(findall(Var,_Goal,List0,List),	Bound, List0+List, Bound+Var).explicit_binding(aggregate(Var,Goal,Sum),	Bound, Goal-Sum, Bound+Var)./*    These three are not quite right.  They implicitly existentially    quantify some variables.  Yuck.*/explicit_binding(grouped_bag_of(_,V,G,S),	Bound, G-S,      Bound+V).explicit_binding(grouped_set_of(_,V,G,S),	Bound, G-S,      Bound+V).explicit_binding(grouped_aggregate(_,V,G,S),	Bound, G-S,      Bound+V).term_is_free_of(Term, Var) :-	var(Term), !,	Term \== Var.term_is_free_of(Term, Var) :-	functor(Term, _, N),	term_is_free_of(N, Term, Var).term_is_free_of(0,_Term,_Var) :- !.term_is_free_of(N, Term, Var) :-	arg(N, Term, Argument),	term_is_free_of(Argument, Var),	M is N-1, !,	term_is_free_of(M, Term, Var).list_is_free_of([], _).list_is_free_of([Head|Tail], Var) :-	Head \== Var,	!,	list_is_free_of(Tail, Var).%   term_variables(Term, Vars0, Var)%   binds Var to a union of Vars0 and the variables which occur in Term.%   This doesn't take quantifiers into account at all.term_variables(Term, Vars0, Vars) :-	nonvar(Term),	!,	functor(Term, _, N),	term_variables(N, Term, Vars0, Vars).term_variables(Term, Vars0, [Term|Vars0]) :-	list_is_free_of(Vars0, Term),	!.term_variables(_, Vars, Vars).term_variables(0, _, Vars, Vars) :- !.term_variables(N, Term, Vars0, Vars) :-	arg(N, Term, Arg),	term_variables(Arg, Vars0, Vars1),	M is N-1,	term_variables(M, Term, Vars1, Vars).