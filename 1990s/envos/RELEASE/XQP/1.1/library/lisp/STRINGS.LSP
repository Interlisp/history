;;; File   : STRINGS.LSP;;; Author : Richard A. O'Keefe;;; Purpose: support for library(strings);;; Updated: Wednesday September 16th, 1987.(CL:IN-PACKAGE "IL")(CL:DEFUN CONCATCODELIST (LIST)    (LET ((STRING (ALLOCSTRING (LENGTH LIST)) ))	(for CHAR in LIST as INDEX from 1 do	    (SETQ STRING (RPLCHARCODE STRING INDEX CHAR))	)	STRING    ))(CL:DEFUN QP.PACK (ITEMS)    ;;  The InterLisp function (PACK ITEMS) is like the Prolog operation    ;;  name/2: it will make a number if it can.  We don't always (or    ;;  even often) want that, so QP.PACK is a version of PACK which is    ;;  sure to make an atom (in the XQP package).    (CL:INTERN (CONCATLIST ITEMS) "XQP"))(CL:DEFUN QP.PACK2 (FRONT BACK STRINGP)    ;;  Concatenate two constants yielding a string or atom    ;;  Note that we can't use PACK* as it might yield a number.    (if STRINGP then	(CONCAT FRONT BACK)    else	(CL:INTERN (CONCAT FRONT BACK) "XQP")    ))(CL:DEFUN QP.PACKC (CHARS)    ;;  Concatenate a list of characters and return them as an atom    ;;  in the INTERLISP package.  We can't quite use PACKC for this,    ;;  as that might return a number.  Actually, this seems to be a    ;;  wee bit faster in the cases I've tried...    (CL:INTERN (CONCATCODELIST CHARS) "XQP"))(CL:DEFUN SUBCHARCODES (ATOM DROP TAKE)    ;;  Return TAKE .take DROP .drop .name ATOM as a list of codes    (for N from (ADD1 DROP) to (PLUS DROP TAKE) collect (NTHCHARCODE ATOM N)))(CL:DEFUN QP.SUBTHING (WHOLE DROP TAKE)    ;;  Return TAKE .take DROP .drop WHOLE, with same type as WHOLE    ;;  I.e., take SUBATOM of a LITATOM, SUBSTRING of other constants    ;;  Work around stupid InterLOSS defn that can't yield ''     (if (OR (LESSP DROP 0)	    (LESSP TAKE 0)	    (GREATERP (PLUS DROP TAKE) (NCHARS WHOLE))) then	0    elseif (EQ TAKE 0) then	(if (LITATOM WHOLE) then (CONSTANT (MKATOM "")) else "")    elseif (LITATOM WHOLE) then	(SUBATOM WHOLE (ADD1 DROP) (PLUS DROP TAKE))    else	(SUBSTRING WHOLE (ADD1 DROP) (PLUS DROP TAKE))    ))(CL:DEFUN QP.SUBEQUAL (WHOLE DROP TAKE PART)    ;;  Given that WHOLE and PART are both LITATOMs or both STRINGs    ;;  test whether PART = TAKE .take DROP .drop WHOLE    (AND	(GEQ DROP 0)	(GEQ TAKE 0)	(LEQ (PLUS DROP TAKE) (NCHARS WHOLE))	(for P from 1 to TAKE as Q from (ADD1 DROP) always	    (EQ (NTHCHAR WHOLE Q) (NTHCHAR PART P))	)    ))(CL:DEFUN QP.STRCOMPARE (X Y P)    ;;  Compare X and Y, using P as the pad character    (LET* ((L (NCHARS X))	   (M (NCHARS Y))	   (N (MIN L M))	  )	(if (AND (OR (MINUSP P) (EQ L M))	;; no padding		 (OR (LITATOM X) (STRINGP X))	;; X not a character		 (OR (LITATOM Y) (STRINGP Y))	;; Y not a character	     ) then	    (SELECTQ (ALPHORDER X Y)		(LESS  (QUOTE <))		(EQUAL (QUOTE =))		(PROGN (QUOTE >))	    )	 else	    (for I from 1 to N when (NEQ (NTHCHARCODE X I) (NTHCHARCODE Y I)) do		(if (LESSP (NTHCHARCODE X I) (NTHCHARCODE Y I)) then		    (RETURN (QUOTE <))		 else		    (RETURN (QUOTE >))		)	     finally (RETURN		(if (GREATERP L M) then		    (for J from (ADD1 N) to L when (NEQ (NTHCHARCODE X J) P) do			(if (LESSP (NTHCHARCODE X J) P) then			    (RETURN (QUOTE <))			 else			    (RETURN (QUOTE >))			)		     finally (RETURN (QUOTE =))		    )		 else if (LESSP L M) then		    (for J from (ADD1 N) to M when (NEQ P (NTHCHARCODE Y J)) do			(if (LESSP P (NTHCHARCODE Y J)) then			    (RETURN (QUOTE <))			 else			    (RETURN (QUOTE >))			)		     finally (RETURN (QUOTE =))		    )		 else (QUOTE =)		))	    )	)    ))(CL:DEFUN QP.OUTEQUAL (WHOLE DROP TAKE FRINGES)    ;;  Given that WHOLE and FRINGES are both LITATOMS or both STRINGS    ;;  test whether FRINGES = (DROP .take WHOLE) ++ (DROP+TAKE .drop WHOLE)    (LET ((N (NCHARS WHOLE))) (AND	(GEQ DROP 0)	(GEQ TAKE 0)	(LEQ (PLUS DROP TAKE) N)	(EQ  (PLUS (NCHARS FRINGES) TAKE) N)	(for P from 1 to DROP always	    (EQ (NTHCHAR WHOLE P) (NTHCHAR FRINGES P))	)	(for P from (PLUS DROP TAKE 1) to N as Q from (ADD1 DROP) always	    (EQ (NTHCHAR WHOLE P) (NTHCHAR FRINGES Q))	)    )))(CL:DEFUN QP.DELETE (WHOLE DROP TAKE)    ;;  Given that WHOLE is a LITATOM or a STRING,    ;;  return (DROP .take WHOLE) ++ (DROP+TAKE .drop WHOLE)    ;;  as the same sort of constant, if possible.    ;;  If the arguments are invalid, return 0.    ;;  We have to watch out for '' and $$.    (LET* ((N (NCHARS WHOLE))	   (LEFT (DIFFERENCE N (PLUS DROP TAKE)))	   S	  )	(if (OR (LESSP DROP 0) (LESSP TAKE 0) (LESSP LEFT 0)) then 0	else if (EQ TAKE N) then	    (if (LITATOM WHOLE) then (CONSTANT (MKATOM "")) else "")	else if (EQ DROP 0) then	    (QP.SUBTHING WHOLE TAKE LEFT)	else if (EQ LEFT 0) then	    (QP.SUBTHING WHOLE 0 DROP)	else	    (SETQ S (CONCAT		(SUBSTRING WHOLE 1 DROP)		(SUBSTRING WHOLE (PLUS DROP TAKE 1) N) ))	    (if (LITATOM WHOLE) then (MKATOM S) else S)	)    ))(CL:DEFUN QP.INSERT (WHOLE DROP PART)    ;;  Given that WHOLE is a LITATOM or a STRING,    ;;  and that 0 <= DROP <= (NCHARS WHOLE)    ;;  insert PART into it after the first DROP characters    ;;  (i.e. return (DROP .take WHOLE) ++ PART ++ (DROP .drop WHOLE))    ;;  and return the result as the same sort of constant as WHOLE.    (LET ((N (NCHARS WHOLE)) S)	(if  (EQ (NCHARS PART) 0) then WHOLE	elseif (EQ DROP 0) then	    (if (LITATOM WHOLE) then (PACK* PART WHOLE) else (CONCAT PART WHOLE))	elseif (EQ DROP N) then	    (if (LITATOM WHOLE) then (PACK* WHOLE PART) else (CONCAT WHOLE PART))	else	    (SETQ S (CONCAT		(SUBSTRING WHOLE 1 DROP)		PART		(SUBSTRING WHOLE (ADD1 DROP) N) ))	    (if (LITATOM WHOLE) then (MKATOM S) else S)	)    ))(CL:DEFUN QP.SPAN (CHARS WHOLE FLAG DIRECTION)    ;;  This function is the guts of the span_{left,right,middle} family.    ;;  CHARS is a list of integer character codes.    ;;  WHOLE is a string or atom.    ;;  FLAG is T (the set is CHARS) or NIL (the set is all_chars\CHARS)    ;;  DIRECTION is LEFT, RIGHT, or MIDDLE    ;;  We return either NIL or a list (LenA LenB LenC).    ;;  According to the manual, MAKEBITTABLE would not be useful here.    (PROG (N A B C)	(SETQ N (ADD1 (NCHARS WHOLE)))	(SELECTQ DIRECTION	    (LEFT		(SETQ A (STRPOSL CHARS WHOLE 1 FLAG NIL))		(if (NULL A) then (RETURN NIL))		(SETQ B (STRPOSL CHARS WHOLE A (NOT FLAG) NIL))		(if (NULL B) then (SETQ B N))		(RETURN (LIST		    (DIFFERENCE A 1) (DIFFERENCE B A) (DIFFERENCE N B)) ))	    (RIGHT		(SETQ C (STRPOSL CHARS WHOLE (SUB1 N) FLAG T))		(if (NULL C) then (RETURN NIL))		(SETQ B (STRPOSL CHARS WHOLE C (NOT FLAG) T))		(if (NULL B) then (SETQ B 0))		(RETURN (LIST		    B (DIFFERENCE C B) (DIFFERENCE N C)) ))	    (TRIM		(SETQ A (STRPOSL CHARS WHOLE 1 FLAG NIL))		(if (NULL A) then (RETURN NIL))		(SETQ C (STRPOSL CHARS WHOLE (SUB1 N) FLAG T))		(if (NULL C) then (RETURN NIL))		(RETURN (LIST		    (SUB1 A) (DIFFERENCE (ADD1 C) A) (DIFFERENCE N C)) ))	    (PROGN		(RETURN NIL))	)    ))