lib-7-2-2                     Xerox Quintus Prolog Library Manual                    Section 7-2-2: Summary of the Packagesaggregate.pl            library(aggregate) defines aggregate/3, an operation similar to            bagof/3 which lets you calculate sums.  For example, given a table            pupil(Name, Class, Age), to calculate the average age of the pupils            in each class, one would write            | ?- aggregate( sum(Age)/sum(1),                            Name^pupil(Class, Name, Age),                            Expr),                 call(Average_Age is Expr).arrays.pl   library(arrays) provides constant-time access and update to arrays.            It involves a fairly unpleasant hack.  You would be better off            using library(logarr) or library(trees).assoc.pl    library(assoc) A binary tree implementation of "association lists".bags.pl     library(bags) provides support for the data type 'bag'.between.pl  library(between) provides routines for generating integers on            backtracking.call.pl     library(call) provides a number of predicates which are useful in            programs which pass goals as arguments.caseconv.pl library(caseconv) is mainly intended as an example of the use of            library(ctypes).  Here you'll find predicates to test whether text            is in all lowercase, all uppercase, or mixed-case, and to convert            from one case to another.ctr.{{pl,DFASL}}            library(ctr) provides an array of 32 global integer variables.  It            was written some time ago for compatibility with another dialect.            The operations provided on these variables arectr_set(+Ctr, +N)           -- ctr[Ctr] := Nctr_set(+Ctr, +N, ?Old)     -- Old is ctr[Ctr], ctr[Ctr] := Nctr_inc(+Ctr)               -- ctr[Ctr] += 1ctr_inc(+Ctr, +N)           -- ctr[Ctr] += Nctr_inc(+Ctr, +N, ?Old)     -- Old is ctr[Ctr], ctr[Ctr] += Nctr_dec(+Ctr)               -- ctr[Ctr] -= 1ctr_dec(+Ctr, +N)           -- ctr[Ctr] -= Nctr_dec(+Ctr, +N, ?Old)     -- Old is ctr[Ctr], ctr[Ctr] -= Nctr_is( +Ctr, ?Old)         -- Old is ctr[Ctr]If you want to use these counters in a nestable construct, don't forget to            reset them properly; for example,            count_solutions(Goal, Count) :-                    ctr_set(17, 0, Old),                    (    call(Goal), ctr_inc(17), fail ; true   ),                    ctr_set(17, Old, X),                    Count = X.            This will work if Goal contains a call to count_solutions/2, but if            you used ctr_set(17, 0) and ctr_is(Ctr, X) it would not work,            because the inner call would clobber the counter of the outer call.The main point of this file is to let you experience (by doing your own timing            tests) that the foreign interface is the tool for hacking global            variables in Prolog, NOT the data base.decons.pl   library(decons) provides a set of routines for recognizing and            building Prolog control structures.  The only predicate which is            likely to be useful is prolog_clause(Clause, Head, Body).  >)findall.pl  library(findall) provides an all-solutions predicate which is an            alternative to the built-in bagof/3.flatten.pl  library(flatten) provides predicates for flattening binary trees            into lists.foreach.pl  library(foreach) defines two iteration forms.                        forall(Generator, Test)            is the standard double-negation "there is no proof of Generator for            which Test is not provable", coded as "\+ (Generator, \+ Test)."                        foreach(Generator, Test)            works in two phases:  first each provable instance of Generator is            found, then each corresponding instance of Test is collected in a            conjunction, and finally the conjunction is executed.            If, by the time a Test is called, it is always ground -- apart from            explicitly existentially quantified variables -- the two forms of            iteration are equivalent, and forall/2 is cheaper.  But if you want            Test to bind some variables, you must use foreach/2.freevars.pl This is an internal support package.  Users will probably have no            direct use for it.fromonto.pl library(fromonto) defines some "pretty" operators for input/output            redirection.  Examples:                        | ?- (repeat, read(X), process(X))                             from_file 'fred.dat'.                        | ?- read(X) from_chars "example. ".                        X = example                        | ?- write(273.4000) onto_chars X.                        X = "273.4"heaps.pl    library(heaps) provides support for the data type 'heap' (heaps are            also known as priority queues).knuth_b_1.pl            library(knuth_b_1) is a table of constants taken from Appendix B1            of D.E.Knuth's The Art of Computer Programming, Volume 1.  The            point is not to provide the constants -- you could have calculated            them yourselves easily enough -- but to illustrate the recommended            way of building such constants into your programs.logarr.pl   library(logarr) is an implementation of "arrays" as 4-way trees.            See also library(trees).long.pl     This is a rational arithmetic package.            rational(N) recognizes arbitrary-precision rational numbers:  this            includes integers, 'infinity', 'neginfinity', & 'undefined'.            whole(N) recognizes arbitrary precision integers.            eval(Expr, Result) evaluates an expression using arbitrary            precision rational arithmetic; it does not accept floats at all.            {eq,ge,gt,le,lt,ne}/2 are infix predicates like '<'/2 that compare            rationals (or integers, not expressions).  succ/2, plus/3, and            times/3 are relational forms of arithmetic which work on rational            numbers (not floats).  To have rational numbers printed nicely, put            the command            :- assert((portray(X) :- portray_number(X)))            in your code.  See long.doc and the comments in long.pl.mapand.pl   library(mapand) provides mapping routines over &-trees.  See also            maplist.pl.maplist.pl  library(maplist) is built on top of library(call), and provides a            collection of meta-predicates for applying predicates to elements            of lists.maps.pl     library(maps) implements functions over finite domains, which            functions are represented by an explicit data structure.math.{{pl,DFASL}}            library(math) provides an interface to the UNIX math library.multil.pl   library(multil) provides multiple-list routines.note.pl     The built-in predicates and commands pertaining to the "recorded"            (or "internal" data base) have an argument called the "key".  All            that matters about this key is its principal functor.  That is,            fred(a, b) and fred(97, 46) are regarded as the same key.            library(note) defines a complete set of storing, fetching, and            deleting commands where the "key" is a ground term all of which is            significant, using the existing recorded data base.  Note that this            package is no better indexed than the existing recorded data base.ordered.pl  library(ordered) is a collection of predicates for doing things            with a list and an ordering predicate.  See also library(ordsets)            ({manual(lib-1-7)}, library(ordprefix) below, and library(samsort)            ({manual(lib-7-2-2)}).ordprefix.pl            library(ordprefix) is for extracting initial runs from lists,            perhaps with a user-supplied ordering predicate.  See also            library(ordered) above.pptree.pl   This file defines pretty-printers for (parse) trees represented in            the form            <tree> --> <node label>/[<son>,...<son>]                    |  <leaf label>         -- anything else            Two forms of output are provided:  a human-readable form and a            Prolog term form for reading back into Prolog.                        pp_tree(+Tree)            prints the version intended for human consumption, and                        pp_term(+Tree)            prints the Prolog-readable version.  There is a new command            ps_tree/1 which prints trees represented in the form            <tree> --> <node label>(<son>,...,<son>)                    |  <leaf>               -- constants            The output of ps_tree/1 is readable by Prolog and people both.  You            may find it useful for things other than parse trees.printchars.pl            library(print_chars) is not a module, and it would be pointless to            load it into any module but 'user'.  It defines portray/1 so that            lists of character codes are written by print/1, by the top level,            and by the debugger, between double quotes.                        | ?- X = "fred".                        X = [102,114,101,100]                        | ?- ensure_loaded(library(print_chars)),                             X = "fred".                        X = "fred"qsort.pl    library(qsort) provides a stable version of quicksort.  Note that            quicksort is not a good sorting method for a language like Prolog.            If you want a good sorting method, see library(samsort) below.queues.pl   library(queues) provides support for the 'queue' data type.random.{{pl,DFASL}}            library(random) provides a random number generator and several            handy interface routines.  The random number generators supplied by            various operating systems are all different.  It is useful to have            a random number generator which will give the same results in all            versions of Quintus Prolog, and this is the one.retract.pl  This file adds more predicates for accessing dynamic clauses and            the recorded data base.  The built-in predicate retract/1 will            backtrack through a predicate, expunging each matching clause until            the caller is satisfied.  This is not a bug.  That is the way            retract/1 is supposed to work.  But it is also useful to have a            version that does not backtrack.  library(retract) defines, among            many other commands, retract_first/1, which is identical to            retract/1 except that it expunges only the first matching clause,            and fails if asked for another solution.samsort.pl  library(samsort) provides a stable sorting routine which exploits            existing order, both ascending and descending.  (It is a            generalization of the natural merge.)  samsort(Raw, Sorted) is like            sort(Raw, Sorted) except that it does not discard duplicate            elements.  samsort(Order, Raw, Sorted) lets you specify your own            comparison predicate, which the built-in sorting predicates sort/2            and keysort/2 do not.  This file also exports two predicates for            merging already-sorted lists:  merge/3 and merge/4.  See also            library(ordered) and library(qsort).setof.pl    library(setof) provides additional predicates related to the            built-in predicate setof/3.  Note that the built-in predicates            bagof/3 and setof/3 are much more efficient than the predicates in            this file.  See also library(findall).show.pl     The built-in command listing/1 displays dynamic predicates.  But            there is no built-in command for displaying the terms recorded            under a given key.  library(show) defines two predicates:            show(Key) displays all the terms recorded under the given Key, and            show/0 displays all the Keys and terms in the recorded data base.showmodule.pl            library(show_module) provides a command for displaying information            about a loaded module.  show_module(Module) prints a description of            the Module, what it exports, and what it imports.  The command                        | ?- show_module(_), fail ; true.            will print a description of every loaded module.  To backtrack            through all current modules and print information about the            predicates they define, import, and export, use                        | ?- ensure_loaded(library(show_module)),                             show_module(Module).To print information about a particular module m, use                        | ?- show_module(m).trees.pl    library(trees) is an implementation of arrays as binary trees.types.pl    This file is support for the rest of the library, and is not really            meant for general use.  The type tests it defines are almost            certain to remain in the library or to migrate to the system.  The            error checking and reporting code is certain to change.  The            library predicates must_be_compound/3, must_be_proper_list/3,            must_be_var/3, and proper_list/1 are new in this release.update.pl   library(update) provides utilities for updating "data base"            relations.