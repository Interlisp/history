sysdep-2-5            Xerox Quintus Prolog System-Dependent Features Manual                    Section 2-5: Calling Prolog from LispIt is possible to call Prolog procedures from Lisp.  Data items passed fromLisp to Prolog (and back) are coerced using the same rules as in Prolog's Lispinterface.  Since only one Prolog process can be in existence at a time it isimpossible for two different Lisp processes to be running Prolog concurrently.Prolog must be called deterministically.  If more than one solution to a goalis desired, the solutions must be collected in Prolog using setof/3 or bagof/3and returned as a list.The format of a call to Prolog from Lisp is as follows:            (PROLOG PrologPredicate PrologArguments WAITFLG)The first argument, PrologPredicate, is the name of the Prolog predicate beingcalled.  Its arity must correspond to the length of the second argument,PrologArguments.  PrologPredicate is called with arguments specified byPrologArguments.  Variables may be passed to Prolog goals by using the atom*VALUE* where a variable is to be passed.A call to PROLOG will return a list of the bindings of variables passed in as*VALUE*, in the order they appear in the call to PROLOG.  If no *VALUE*arguments are passed in and the goal succeeds, then PROLOG returns T. If thegoal fails, then PROLOG returns NIL.If the third argument, WAITFLG, is NIL, an error will be signalled if PROLOG iscalled while Prolog is being executed concurrently from another Lisp process.If WAITFLG is T and another Prolog is running simultaneously, this call toPROLOG will block until the other has completed.Examples:Suppose we have an English/French translation program written in Prolog.English_to_french(Eng, Fre), will succeed with its second argument being aFrench equivalent to its first argument in English.            (PROLOG               (QUOTE english_to_french)                  (LIST                     (QUOTE                        (I am going home))                     (QUOTE *VALUE*)))will return:            (Je vais chez moi)and            (PROLOG               (QUOTE english_to_french)                  (LIST                     (QUOTE *VALUE*)                     (QUOTE                        (Je vais chez moi)))will return:            (I am going home)The APPEND function in Lisp could be defined:            (DEFINEQ               (APPEND                  (LAMBDA (X Y)                     (PROLOG                        (QUOTE append)                        (LIST X Y                           (QUOTE *VALUE*))))Finally, if we have a Prolog predicate foo/6 defined by:            foo(A, B, C, D, E, F) :-               B is A*2,               D is C*2,               F is E*2.then            (PROLOG (QUOTE foo)                    (QUOTE (5 *VALUE* 6 *VALUE* 7 *VALUE*)))would return the list            (10 12 14)and            (PROLOG (QUOTE foo)                    (QUOTE (5 10 6 12 7 14)))would return            Tand            (PROLOG (QUOTE foo)                    (QUOTE (5 11 6 13 7 15)))would return            NIL