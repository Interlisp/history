ref-12-5                    Xerox Quintus Prolog Reference Manual                        Section 12-5: Loading a ModuleTo gain access to the public predicates of a module-file, load it as you wouldany other file -- using consult/1, compile/1, or ensure_loaded/1 asappropriate.  For example, if your code contains a directive such as             :- ensure_loaded(File).this directive will load the appropriate file File whether or not File is amodule-file.  The only difference is that if File is a module-file any privatepredicates which it defines will not be visible to your program.The predicates consult/1, compile/1, and ensure_loaded/1 are adequate for useat Prolog's top level, or when the file being loaded is a utility such as alibrary file.  However, there is another predicate that is more useful thanthese when you are writing modules of your own:              :- use_module(FileSpecList).use_module/1 is similar to ensure_loaded/1, with the following differences:     1. For use_module/1, it is an error if any of the files in FileSpecList      is not a module-file.   2. If the use_module/1 directive appears in a file that is being      consulted, those files in FileSpecList which have not already been      loaded are consulted, rather than compiled.   3. use_module/1 always tries to import all the public predicates of the      loaded module-file.  In contrast, if a module-file is loaded into a      module via ensure_loaded/1, compile/1, or consult/1, ({manual(ref-3)) and some predicates from the module-file have already been imported into themodule, then no attempt is made to import the newly-loaded module.  This ishelpful when loading a module-file at the top level if you have previouslyimported only selected predicates from the module-file (see use_module/2below).}An attempt to import a predicate may fail or require intervention by the userbecause a predicate with the same name and arity has already been defined in,or imported into, the current module.  Details of what happens in the event ofsuch a name clash are given in {manual(ref-12-12)}.There is another predicate for importing modules:              :- use_module(FileSpec, ImportPredList).This is like use_module(FileSpec) except that it imports only the predicatesspecified in the ImportPredList.  For example,:- use_module(library(basics), [append/3, member/2]).will load the module-file 'basics.pl' from the library, unless it is alreadyloaded, but only the two named predicates will be imported.use_module/2 is preferred to use_module/1 unless you are importing a largenumber of predicates from a module.  Its advantages are:   1. use_module/1 may import more predicates into the source module than      will be used, thus increasing the probability of a name clash.   2. The use_module/2 directives make it easier for someone reading the      program to understand exactly what the module interfaces are.   3. If you change the public predicate list of a module that you are      importing via use_module/1, you will be warned that the module      containing the use_module/1 statement should be reloaded.  This is      necessary because the set of predicates being imported has changed.      If you use use_module/2 instead you will not get such warnings,      because the set of predicates being imported is explicit.WARNING:  If a non-module-file is loaded into more than one module, a separatecopy of each procedure in the file will be made for each module into which itis loaded.  This wastes space and has the further drawback that a change to onecopy of a procedure will not affect the other copies.  It is thereforerecommended that any file which may be loaded by more than one module shoulditself be made into a module-file.