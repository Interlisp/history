ref-12-5-1                    Xerox Quintus Prolog Reference Manual                    Section 12-5-1: Basic Control Options<CR>    (the Return key)        This is the same as the 'c' (creep) option but is reduced to a single        keystroke for convenience.c       creep        This causes the debugger to single-step to the next port and display        its goal.  Then, if the port is leashed, you are prompted for further        interaction.  Otherwise, the debugger continues creeping and showing        goals until it reaches a leashed port.  If leashing has been completely        disabled, the debugger will no longer stop at the debugging ports, but        a complete trace of all goals will be displayed.l       leap        This causes the debugger to resume running your program, stopping only        when the next spypoint is reached, or when the program terminates.        Spypoints are not affected by leashing, so you will always be prompted        for interaction when a spypoint is reached.  Leaping can be used to        follow the program's execution at a higher level than exhaustive        tracing through creeping.  This is done by setting spypoints on a set        of pertinent procedures, then following the control flow through these        by leaping from one to the next.s       skip        At a Call or Redo port, this skips over the entire execution of the        procedure.  That is, you will not see anything until control comes back        to this procedure (at either the Exit port or the Fail port).  At an        Exit or Fail port, this is equivalent to the 'c' (creep) option.  Skip        is particularly useful while creeping since it guarantees that control        will be returned after the (possibly complex) execution within the box.        If you skip, then no debugging messages at all will appear until        control returns.  This includes calls to procedures with spypoints set:        they will be masked out during the skip.r       retry        This can be used at any of the four ports (although at the Call port it        has no effect).  Control is transferred back to the Call port of the        box.  This allows you to restart an invocation when, for example, you        find yourself leaving with some incorrect result.  The state of        execution is exactly the same as when you originally called the        procedure, except that clauses that have been changed by the data base        modification predicates will not be changed back to their original        state.  When a retry is performed, the invocation counter is reset so        that counting will continue from the current invocation number        regardless of what happened before the retry.  This is in accord with        the fact that execution has returned to the state it was in at the time        of the original call.  The message                    [Debugger:  retry goal]        is displayed to indicate where this occurred, in case you wish to        follow these numbers later.