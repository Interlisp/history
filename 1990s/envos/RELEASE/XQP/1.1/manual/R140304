ref-14-3-4                    Xerox Quintus Prolog Reference Manual                     Section 14-3-4: abolish(+Predicates)abolish(Predicates) abolishes all the predicates specified by Predicates.  Thatis, Prolog wipes out all their clauses and all the information it has aboutthem.  After this command is executed, the program functions as if theabolished predicates had never existed.The Predicates argument is just like the argument of listing/1, spy/1, ornospy/1 -- that is:   - an atom Name, specifying all predicates in the current module with     that name;   - a Name/Arity pair, specifying all predicates in the current module     with that name and number of arguments;   - a Module:Spec pair, where Module overrides the current module name     and Spec is of one of the above forms; or   - a list of predicate specifications [Spec1, ..., Specn] of any of the     above forms, the set of all predicates specified by any of Spec1     through Specn.For example, you will often use            abolish([foreign_file/2,foreign/2,foreign/3])after loading foreign code.You may abolish any of your own predicates, regardless of whether they aredynamic, static, compiled, interpreted, or foreign.  You cannot abolish systempredicates.Specifying an undefined predicate is not an error.  However, if any item inPredicates is not a valid predicate specification, an error message is sent tothe standard error stream, abolish/1 fails, and the system enters the debuggerin trace mode.As with the other data base modification predicates, predicates which have beenabolished do not become invisible to a currently running procedure.  Forexample,            | ?- compile(user).            | :- dynamic q/1.            | q(1).            | q(2).            | q(3).            | end_of_file.            [user compiled 0.117 sec 260 bytes]            yes            | ?- q(N), write(N), nl, abolish(q/1), fail.            1            2            3            no            | ?- q(N).            [Warning: The procedure q/1 is undefined]               (1) 0 Call: q(_432) ?               (1) 0 Fail: q(_432) ?            no            | ?-Space occupied by abolished predicates is reclaimed.  The space occupied bydynamic and interpreted predicates is reclaimed almost at once; static compiledcode's space is only reclaimed at top level, if at all (see the chapter onmemory use in the Xerox Quintus Prolog System-dependent Features Manual).One can only abolish dynamic predicates which are defined in the source module.An attempt to abolish a dynamic predicate which is imported into the sourcemodule will simply succeed without affecting the predicate.Abolishing a foreign predicate destroys only the link between that Prologpredicate and the associated foreign code.  The foreign code that was loadedremains in memory.  This is necessary because Prolog cannot tell whichsubsequently-loaded foreign files may have links to the foreign code.  TheProlog part of the foreign predicate is destroyed and reclaimed.