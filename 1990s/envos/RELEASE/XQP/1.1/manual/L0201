lib-2-1                     Xerox Quintus Prolog Library Manual                          Section 2-1: IntroductionThere are two ways of looking at Prolog data structures.  One is the proper"object-level" logical way, in which you think of arguments as values.  Theother is the "meta-logical" way, in which you see them not as lists or trees(or whatever your object-level data types are), but as "terms".Prolog has the following built-in operations which operate on terms as such:functor(?Term, ?Symbol, ?Arity)            is true when Term is a term, and the principal function symbol of            Term is Symbol, and the arity (number of arguments) of Term is            Arity.  Alternatively, you may think of this as being true when            Term is a term and the principal functor of Term is Symbol/Arity.            All constants, including numbers, are their own principal function            symbols, so functor(1.3, 1.3, 0) is true.  This may be used to find            the functor of a given term, or to construct a term having a given            functor.arg(+Index, +Term, ?Arg)            is true when Term is a non-variable, Index is a positive integer,            and Arg is the Indexth argument of Term.  Argument numbering starts            at 1.  This can only be used to find Arg; Index and Term must be            given.?Term =.. [?Symbol |?Args]            is true when Term is a term, Symbol is its principal function            symbol, and Args is a list of the remaining arguments.  Use of            '=..'/2 can nearly always be avoided, and should be whenever            possible, as it is very slow and uses memory unnecessarily.copy_term(+OldTerm, -NewTerm)            unifies NewTerm with an alphabetic variant of OldTerm that contains            all new variables (see {manual(lib-2-8)}).  That is, copy_term/2            makes a copy of OldTerm by replacing each distinct variable in            OldTerm by a new variable that occurs nowhere else in the system,            and unifies NewTerm with the result.compare(?Order, ?Term1, ?Term2)            compares Term1 and Term2 with respect to Order, which may be one of            '<', '>', or '='.  If Order is '=', the comparison is actually done            with respect to the '=='/2 operator on terms.The system also includes the term comparison predicates '=='/2, '\=='/2,'@<'/2, '@>'/2, '@>'/2, '@=<'/2.  See the Xerox Quintus Prolog Reference Manualfor more details.