ref-2-4-1                    Xerox Quintus Prolog Reference Manual                        Section 2-4-1: Operator TypesXerox Quintus Prolog provides the same set of operator types as DEC-10 Prologand C-Prolog, namely       fy associative prefix       fx non-associative prefix     yfx  left-associative infix     xfx  non-associative infix     xfy  right-associative infix     xf   non-associative postfix     yf   associative postfixThe names of the operator types have been designed to be mnemonic pictogramsfor the shape of an expression.  In each pictogram,     f stands for the operator     y stands for an expression of                  the same or weaker precedence than f     x stands for an expression of                  strictly weaker precedence than fFor example, an operator 'op1' of type 'xfy' may be written in an expression            A op1 Bwhose first operand A must be of weaker precedence than 'op1' (x), but whosesecond operand B may be of the same or weaker precedence than 'op1' (y).  Thusthe declaration            :- op(400, yfx, *).declares '*' to be an operator of precedence 400 with 'yfx' precedence, meaningthat in an expression of the form            E * Gwhere E and G are expressions, the expression E may be of the same precedenceas '*', whereas G must have weaker precedence than '*'.  (Note that in anexpression of the form 'A f B', where f is the principal functor, the entireexpression 'A f B' has the same precedence as f.)  So, given the declarationabove, the expression            A * B * Cwhere A, B, and C are constants, must be interpreted as                        (A * B)  *  C            precedence:   400   400 0rather than as                         A  *  (B * C)            precedence:  0 400   400Similarly, the declaration            :- op(200, xfy, ^).means that            X ^ Y ^ p(X,Y)is allowed and is equivalent to the expression            X ^ (Y ^ p(X,Y)).As another example, say that we are considering defining the list constructor,'.'/2, as an operator.  In a definition of '.'/2 as an operator, the expression            a . b . []should be parsed as            a . (b . [])meaning that the right-hand operand of '.'/2 can be another expression of thesame precedence, whereas the left-hand operand must be of weaker precedence.Thus the operator declaration of '.'/2 should declare it to be of type 'xfy'.Hence the operator declaration for '.'/2 would be            :- op(600, xfy, .).Operator precedence is also associated with a simple rule:  the larger thenumber associated with an operator, the larger the subexpression of anexpression it will dominate.  For example, given the two operators '@' and '#',declared as            :- op(450, xfx, @).            :- op(470, xfx, #).the expression            a @ b # cis parsed as            (a @ b) # csince '#' has the stronger precedence, and thus dominates a largersubexpression than '@'.  In fact, in Prolog this example is as follows:            | ?- op(450, xfx, @), op(470, xfx, #).            yes            | ?- display(a @ b # c).            #(@(a,b),c).            yesNote that if an operator 'op' is of type 'xfx', attempting to evaluate theexpression 'A op B op C' will have the following result:            | ?- A op B op C.            ** Syntax error:  **            A op B            ** here **            op CAs an example, if 'not' were declared as a prefix operator of type 'fy', then             not not Pwould be a permissible way to write "not(not(P))". If the type were 'fx', thepreceding expression would not be legal, although             not Pwould still be a permissible form for "not(P)".If these precedence and associativity rules seem rather complex, remember thatyou can always use parentheses when in any doubt.