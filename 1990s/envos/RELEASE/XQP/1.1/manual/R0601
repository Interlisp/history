ref-6-1                    Xerox Quintus Prolog Reference Manual                     Section 6-1: Arithmetic ExpressionsArithmetic evaluation and testing is performed by predicates that takearithmetic expressions as arguments.  An arithmetic expression is a term builtfrom numbers, variables, and functors that represent arithmetic functions.These expressions are evaluated to yield an arithmetic result which may beeither an integer or a float; the type is determined by the rules describedbelow.At the time of evaluation, each variable in an arithmetic expression must bebound to a number; otherwise, an error message is written to the standard errorstream.  In particular, note that a variable in an arithmetic expression maynot be bound to another arithmetic expression.The most common way to do arithmetic in Prolog is to use the built-in predicateis/2 ({manual(ref-6-2)}).Only certain functors are permitted in arithmetic expressions.  These arelisted below, together with a description of their arithmetical meanings.  Forthe rest of the section, X and Y are considered to be arithmetic expressions.X + Y       Evaluates to the sum of X and Y.  If both operands are integers,            the result is an integer; otherwise, the result is a float.X - Y       Evaluates to the difference of X and Y.  If both operands are            integers, the result is an integer; otherwise, the result is a            float.X * Y       Evaluates to the product of X and Y.  If both operands are            integers, the result is an integer; otherwise, the result is a            float.- X         Evaluates to the negative of X.  The type of the result, integer or            float, is the same as the type of the operand.X / Y       Evaluates to the quotient of X and Y.  The result is always a            float, regardless of the types of the operands X and Y.X // Y      Evaluates to the integer quotient of X and Y.  X and Y must both be            integers.  The result is truncated to the nearest integer that is            between it and 0.X mod Y     Evaluates to the remainder after the integer division of X by Y.  X            and Y must both be integers.  The result always has the same sign            as X.integer(X)  Evaluates to X if X is an integer.  Otherwise (if X is a float) the            result is the nearest integer that is between it and 0.float(X)    Evaluates to X if X is a float.  Otherwise (if X is an integer) the            result is the floating-point equivalent of X.The following bit-vector operations apply to integer arguments only.  Supplyingnon-integer arguments results in an error signal. These operations are subjectto the same precision limitations as arithmetic on non-negative integers.  Forthe bit-string limit on your system, see the Xerox Quintus PrologSystem-dependent Features Manual.  The bit-vector operations in Prolog aresimilar to the "logical operations on numbers" described in section 12.7 of thebook Common Lisp (G. L. Steele, 1984).  In particular, the left shift operation(<<) is similar to the 'ash' function.X /\ Y      Evaluates to the bitwise conjunction of X and Y.X \/ Y      Evaluates to the bitwise disjunction of X and Y.\ (X)       Evaluates to the complement of the bits in X.X << Y      X is shifted left Y places.X >> Y      X is shifted right Y places with sign extension.The following operation is included in order to allow integer arithmetic oncharacter codes.[X]         Evaluates to X for numeric X.  This is relevant because character            strings in Prolog are lists of character codes, that is, integers.            Thus, for those integers which correspond to character codes, the            user can write a string of one character in place of that integer            in an arithmetic expression.  For example, the expression                         X is "c" - "a"            is equivalent to                         X is [99] - [97]            which in turn becomes                         X is 99 - 97            in which case X is unified with 2.  A cleaner way to do the same            thing is                        X is 0'c - 0'a