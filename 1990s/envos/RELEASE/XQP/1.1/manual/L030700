lib-3-7-0                     Xerox Quintus Prolog Library Manual                         Section 3-7-0: IntroductionThe beauty of Prolog as a text processing language is that definite clausegrammars (DCG's) are not only part of it, but almost an inevitable part, andmay be used for constructing and decomposing pieces of text as well as matchingthem.As an example of the power of definite clause grammars, suppose we want to takeAmerican-style dates apart.  Here is a grammar:usa_date(Y, M, D, MDY) :-        usa_date(Y, M, D, MDY, "").usa_date(Y, M, D) -->        digits(M), "/", digits(D), "/", digits(Y).digits([D|Ds]) -->        [D], {is_digit(D)},        (   digits(Ds)        ;   {Ds = []}        ).With this definition, we can take dates apart:            | ?- usa_date(Y, M, D, "12/25/86").            Y = "86",            M = "12",            D = "25"            | ?- usa_date(Y, M, D, "2/1/87").            Y = "87",            M = "2",            D = "1".            | ?- usa_date(Y, M, D, "1-feb-87").            noWe can also put dates together:            | ?- usa_date("86", "12", "25", Date).            Date = "12/25/86"            | ?- usa_date("87", "2", "1", Date).            Date = "2/1/87"Thanks to the fact that non-terminals in a DCG can take arguments, and with alittle care, you can write quite complicated grammars that can be used forcomposition as well as decomposition.If you want to do any sort of text processing in Prolog, you should learn howto use grammar rules.  A well-written grammar requires less mental decodingthan a program using the operations in library(strings).  Here are versions ofusa_date/4 written using the operations in library(strings).  cons_date/4 canonly build a date, and dest_date/4 can only take one apart.  Both aresimplified, and do not check that Y, M, and D are made of digits.cons_date(Y, M, D, Date) :-        concat_atom([Y,/,M,/,D], Date).dest_date(Y, M, D, Date) :-        substring(Date, /, I, 1),       % find left /        substring(Date, /, J, 1, R),    % find right /        J > I,        substring(Date, Y, 0, I),       % extract Y        substring(Date, D, _, R, 0),    % extract D        P is I+1, Q is R+1,             % widen fringes        substring(Date, M, P, _, Q).    % extract MIt is not immediately obvious what this does, whereas the version using grammarrules is considerably clearer.The argument is sometimes raised that, while grammar rules may be more elegant,string operations are more efficient.  However, it is the daily experience ofProlog programmers that "clean" and "efficient" tend to describe the same code.The following relative times were measured using Xerox Quintus Prolog onan 1186:            cons_date('86', '12', '25', _)            ------------------------------ = 10            usa_date( "86", "12", "25", _)            dest_date(_, _, _, '86/12/25')            ------------------------------ = 10            usa_date( _, _, _, "86/12/25")In both cases, processing lists of character codes using grammar rules was muchmore efficient than using "string" operations.  It might have been the casethat these high ratios in favor of grammar rules meant only thatlibrary(strings) was uncommonly slow, or that using atoms instead of Lispstrings was a bad idea.  We encourage you to do your own tests in Lisp.  Weactually found using lists in Lisp to be 1.5 to 3 times faster than usingLisp's built-in operations on strings or atoms, and as Prolog list processingtends to be rather faster than Lisp list processing, it seems that these ratiosreflect a genuine advantage to doing text processing with grammar rules inProlog rather than with Lisp string operations.] ###subsection###3-7-1###midstring/[3-6]The principal routine for taking apart an atom or a string is midstring/6.midstring(?ABC, ?B, ?AC, ?LenA, ?LenB, ?LenC)            is true when               - ABC, B, and AC are all text objects of the same type,               - ABC can be broken into three pieces A, B, and C,               - AC is the concatenation of A and C,               - LenA is the length of A,               - LenB is the length of B, and               - LenC is the length of C.Either ABC or both B and AC should be instantiated.  Apart from thisrestriction, midstring/6 is a genuine relation, and all the other arguments canbe solved for.How can you be expected to remember all these arguments?  The arguments fallinto two groups:  three text objects and three integers.  The three integersform a little picture of what you want.                        |   LenA    |     LenB    |  LenC   |                ABC=     a a a a a a B B B B B B B c c c c cSo the order of the three integer arguments is the same as the order of thesubstrings whose lengths they are.  Note that none of these arguments is a"position" in any string:  all three of them are to be understood as lengths ofstrings.The order of the text arguments was chosen to extend the order used bysubstring/5 (see {manual(lib-3-7-2)}).  Generally, you are more likely to knowABC than B or AC, and you are more likely to know B than AC.  For example, acommon use of the midstring/[3-6] family is to ask "if B is deleted from ABC,what results?", which can be done by asking            | ?- midstring(this_is_abc, is, AC, _, _, _).            AC = this__abcThe midstring/N family has four members:midstring(ABC, B, AC, LenA, LenB, LenC)midstring(ABC, B, AC, LenA, LenB)midstring(ABC, B, AC, LenA)midstring(ABC, B, AC)Earlier in this chapter we saw midstring/4 used to append two strings.  Now wecan see how that works:            | ?- midstring(BC, B, C, 0).is true when BC can be broken into three parts, A, B, and C, such that 0 is thelength of A, the lengths of B and C are unconstrained, and C is theconcatenation of A and C.Another way to see this is that            | ?- midstring (ABC, B, AC, N).is true when ABC is obtained by inserting B just after the Nth character of AC.Some other examples using the midstring/N family:   - To delete 7 characters from 'I"m going, Tom', retaining the first 4     characters:     | ?- midstring('I''m going, Tom', _, Answer, 4, 7).     Answer = 'I''m Tom'   - To search for the text 'ab' in 'abracadabra':                 | ?- midstring(abracadabra, ab, _, Offset).                 Offset = 0 ;                 Offset = 7 ;                 no   - To divide Whole into Front and Back, where the length of Front is     known:     | ?- midstring(Whole, Front, Back, 0, FrontLength).   - To divide Whole into Front and Back, where the length of Back is     known:     | ?- midstring(Whole, Front, Back, 0, _, BackLength).   - To insert Part into Fringes at a given Offset from the left, yielding     Whole:     | ?- midstring(Whole, Part, Fringes, Offset).   - To insert Part into Fringes at a given Offset from the right,     yielding Whole:     | ?- midstring(Whole, Part, Fringes, _, _, Offset).   - To delete Drop characters from Whole, starting at a given Offset from     the left, yielding Short:     | ?- midstring(Whole, _, Short, Offset, Drop).   - To delete Drop characters from Whole, starting at a given Offset from     the right, yielding Short:     | ?- midstring(Whole, _, Short, _, Drop, Offset).   - To determine the Length of Text:     | ?- midstring(Text, Text, '', 0, Length, 0).It would not be useful to try to memorize these examples.  Instead, rememberthe picture:            ABC,  B,  AC,  LenA,  LenB,  LenCmidstring/[3-6] has been carefully designed so that you can extract and insertfrom either the left or the right with equal facility, and so that successivecalls to extract related fragments will require a minimum of arithmetic.  Forexample, suppose we want to break a text ABCD into four pieces, where thelengths of B and D are known.  We think about the picture                    ABCD = '' (ABC) D                    ABC  = A (B) C                    AC   = A (C) ''and then write            four_parts(ABCD, A, B, C, D, LenB, LenD) :-                    /* this is an example */                    midstring(ABCD, ABC, D, 0, _, LenD),                    midstring(ABC, B, AC, LenA, LenB),                    midstring(AC, C, A, LenA, _, 0).] ###subsection###3-7-2###substring/[4,5]Very often you are not interested in the third argument which midstring/[3-6]return you.  substring/[4,5] do not return (and do not construct) thisargument.  In fact, substring/[4,5] were designed first, and midstring/[3-6]were developed from it to provide string insertion and deletion.substring(+ABC, ?B, ?LenA, ?LenB, ?LenC)substring(+ABC, ?B, ?LenA, ?LenB)            are true when               - ABC and B are both text objects of the same type,               - ABC can be broken into three pieces A, B, and C,               - LenA is the length of A,               - LenB is the length of B, and               - LenC is the length of C.The ABC argument must be instantiated.  The B argument may be instantiated(this provides a string search facility) but need not be.  This is the reasonfor the argument order:  arguments which are strict inputs should precede otherarguments, and substring/5 has precisely one strict input.The point of substring/5 is to let you work from the right-hand end of the textas easily as from the left-hand end.  But the fact that Prolog is based onrelations rather than functions means that this one operation can replace bothsubstring and string search operations.Thus to determine where 'a' occurs in 'abracadabra',            | ?- substring(abracadabra, a, Offset, _).            Offset = 0 ;            Offset = 3 ;            Offset = 5 ;            Offset = 7 ;            Offset = 10 ;            noThis is the preferred way of searching for a substring in Quintus Prolog.  Notethat if you use substring/5 to search for a substring, you can then extract thepreceding or following characters thus:| ?- substring(Text, Pattern, L_Before, L_Pattern, L_After),|    substring(Text, Before, 0, L_Before, _),|    substring(Text, After, _, L_After, 0).Again, this is not guesswork, but is arrived at by thinking about the picture            Text = Before (Pattern) After                 = '' (Before) Pattern After                 = Before Pattern (After) ''There are two other predicates in this family:            index(Pattern, String, Offset) :-                    substring(String, Pattern, Offset, _).            string_search(Pattern, String, Offset) :-                    substring(String, Pattern, Offset, _).index/3 is retained for compatibility with earlier (unsupported) releases oflibrary(strings).  It will be withdrawn in a future release.  If you have codewhich uses index/3, you should replace calls to index/3 by calls tostring_search/3, which is an exact synonym for it.] ###subsection###3-7-3###subchars/[4,5]subchars/[4,5] are identical to substring/[4,5] ({manual(lib-3-7-2)}) exceptthat the second argument, B, is a list of character codes, not a text object.subchars(+ABC, ?B, ?LenA, ?LenB, ?LenC)subchars(+ABC, ?B, ?LenA, ?LenB)            are true when               - ABC is a text object,               - B is a list of character codes (it may be empty),               - ABC can be broken into three pieces A, B, and C,               - LenA is the length of A,               - LenB is the length of B, and               - LenC is the length of C.            | ?- subchars(frederica, Name, 4, 4).            Name = "eric"These predicates avoid constructing a string or atom which you may have nofurther use for.