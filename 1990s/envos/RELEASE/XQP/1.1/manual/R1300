ref-13-0                    Xerox Quintus Prolog Reference Manual                          Section 13-0: IntroductionThe family of assertion and retraction predicates described below enables youto modify a Prolog program by adding or deleting clauses while it is running.These predicates should not be overused.  Often people who are experienced withother programming languages have a tendency to think in terms of global datastructures, as opposed to data structures which are passed as procedurearguments, and hence they make too much use of assertion and retraction.  Thisleads to less readable and less efficient programs.An interesting question in Prolog is what happens if a procedure modifiesitself, by asserting or retracting a clause, and then fails.  On backtracking,does the current execution of the procedure use new clauses which are added tothe bottom of the procedure?In earlier releases of Xerox Quintus Prolog, changes to the Prolog data basebecame globally visible upon the success of the built-in predicate modifyingthe data base.  An unsettling consequence was that the definition of aprocedure could change while it was being run.  This could lead to code thatwas difficult to understand.  Furthermore, the memory performance of theinterpreter implementing these semantics was poor.  Worse yet, the semanticsrendered ineffective the added determinacy detection available through indexing(see {manual(ref-19-4)}, for more information on determinacy detection).Beginning with Release 2.0, the definition of an interpreted procedure that isto be visible to a call is effectively frozen when the call is made.  Aprocedure always contains, as far as a call to it is concerned, exactly theclauses it contained when the call was made.For the purposes of explanation, a call to an interpreted procedure makes avirtual copy of the procedure, then runs the copy rather than the originalprocedure.  Any changes to the procedure made by the call are immediatelyreflected in the Prolog data base, but not in the copy being run.  Thus,changes to a running procedure will not be visible on backtracking.  Asubsequent call, however, makes and runs a virtual copy of the modified Prologdata base.  Any changes to the procedure that were made by an earlier call willbe visible to the new call.In addition to being more intuitive and easy to understand, the new semanticsallow interpreted code to execute with the same determinacy detection (andexcellent memory performance) as static compiled code.  Virtually allinterpreted code developed on previous Xerox Quintus Prolog releases will rununder Xerox Quintus Prolog Release 2.0 without any noticeable differences.However, the new semantics can be demonstrated when modifying the Prolog database.