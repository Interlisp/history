sysdep-2-4            Xerox Quintus Prolog System-Dependent Features Manual                       Section 2-4: The Lisp InterfaceThe commands :- lisp_predicate(LispFunction, PrologPredicate).:- lisp_predicate(LispFunction, PackageName, PrologPredicate).links a Lisp function (denoted by the atoms LispFunction and PackageName) and aProlog predicate (denoted by the term PrologPredicate) so that, whenPrologPredicate is called, PackageName::LispFunction will be executed withappropriate arguments.  When using lisp_predicate/2, LispFunction will becalled in the INTERLISP package.  The arguments of the Prolog predicate areexpressed in terms of +'s (input arguments) and -'s (output arguments).  One ofthe -'s may optionally be enclosed within square brackets to denote the(unique) return value of the Lisp function.If there is more than one output argument, The Lisp function returns thearguments to Prolog by executing the CL:VALUES function as the last form in thebody of the function.  CL:VALUES takes any number of arguments which, in turn,are used to supply the output arguments of the Prolog predicate.Note that the lisp_predicate/2 and lisp_predicate/3 commands must be placed ina file.  lisp_predicate/2 and lisp_predicate/3 will not work when typeddirectly to Prolog.Following are some examples.:- lisp_predicate('MOVEW', move_window(+,+,+,[-])).This command links the Xerox Lisp primitive MOVEW with the Prolog predicatemove_window/4.  MOVEW takes three arguments and returns one value, representedin the above example by [-].  Note that leaving off the square brackets wouldproduce the same effect because there is only one output argument.:- lisp_predicate('FOO', 'XCL-USER', foo(+,-,+,-,+,-)).foo/6 is associated with the Lisp function XCL-USER::FOO.  XCL-USER::FOO takesthree arguments which are specified as arguments 1, 3, and 5 of the predicatefoo/6.  The last evaluated form of XCL-USER::FOO is a CL:VALUES function takingthree arguments which are returned as output arguments 2, 4, and 6.XCL-USER::FOO could have been defined:            (DEFINEQ               (XCL-USER::FOO (LAMBDA (X Y Z)                       (CL:VALUES                          (ITIMES 2 X)                          (ITIMES 2 Y)                          (ITIMES 2 Z)))))Then the following could happen:            | ?- foo(5, X, 6, Y, 7, Z).            X=10,            Y=12,            Z=14Some properties of the CL:VALUES function:   - If too many values are returned, the extra ones will be ignored.   - If too few values are returned, the behavior is undefined.   - There is no way to detect how many values were actually returned.The Prolog predicate append/3 could be defined:            :- lisp_predicate('APPEND', append(+,+,-)).relying on the Lisp function APPEND to do the computation.  Note that thisversion of append/3 is deterministic because Lisp is deterministic.Any Lisp object may be passed in either direction across the foreign interface.The following table expresses the correspondences:            ___________________________________________________________________            Lisp                    Prolog            NIL                     []            Lisp symbol             Prolog atom            Lisp float              Prolog float            Lisp integer            Prolog integer            (a b . c)               [a, b | c]            object of type          Prolog term            PROLOG.TERM            any other object        that same object, which                                    is atomic to Prolog            ___________________________________________________________________The Lisp datatype PROLOG.TERM is used for passing Prolog terms between Prologand Lisp.  This datatype has just two fields:  PROLOG.FUNCTOR, which must be anatom, and PROLOG.ARGS, which must be a proper list.  PROLOG.TERMs may becreated with 'create' and accessed with 'fetch'; TYPENAME and TYPENAMEP may beused to determine if a lisp object is a PROLOG.TERM.  See the section of theInterlisp-D Reference Manual on records for more information.Note that PROLOG.TERMs in the Lisp world print as a vertical bar and opensquare bracket followed by the functor, all the arguments, and a close squarebracket.  For example, the Prolog term             foo(a, b, c)will be printed as             |[foo a b c]by the Lisp printer.  The Lisp reader cannot read this form, however.  It isonly meant to enable human readers to see the contents of a PROLOG.TERM.Example:  the following two functions implement a printer for Prolog terms.Note that this code is similar to Prolog's write/1, not writeq/1, except thatit does not handle operators.(DEFINEQ(PRINT.PROLOG  (LAMBDA (X)    (if (NULL X)        then (PRIN1 "[]")      elseif (ATOM X)        then (PRIN1 X)      elseif (LISTP X)        then (PRIN1 "[")               (PRINT.PROLOG (CAR X))               (PRINT.PROLOG.LIST.TAIL (CDR X))               (PRIN1 "]")      elseif (TYPENAMEP X (QUOTE PROLOG.TERM))        then (PRIN1 (fetch (PROLOG.TERM PROLOG.FUNCTOR) of X))               (PRIN1 "(")               (PRINT.PROLOG                 (CAR (fetch (PROLOG.TERM PROLOG.ARGS) of X)))               (PRINT.PROLOG.LIST.TAIL                 (CDR (fetch (PROLOG.TERM PROLOG.ARGS) of X)))               (PRIN1 ")")      else (PRIN1 X))    X))(PRINT.PROLOG.LIST.TAIL  (LAMBDA (LST)    (if (LISTP LST)        then (PRIN1 ",")               (PRINT.PROLOG (CAR LST))               (PRINT.PROLOG.LIST.TAIL (CDR LST))      elseif LST        then (PRIN1 "|")               (PRINT.PROLOG LST)))))Other notes:   - All predicates defined using the Lisp interface are determinate.   - Prolog variables may not be passed between Lisp and Prolog.