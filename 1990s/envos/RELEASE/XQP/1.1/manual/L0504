lib-5-4                     Xerox Quintus Prolog Library Manual                Section 5-4: Checking to See if a File ExistsNo matter what programming language you are using, all multiple-access filesystems have the problem that the system may correctly report that a file doesexist, and then when you attempt to use it you may find that it does not,because someone has deleted or renamed it in the meantime.  Also, for a file toexist is not always sufficient for you to be able to open it, even if you haveall the access rights needed.  Prolog limits you to having a maximum of 20 openstreams at any one time, and if you have 20 open streams, you will not be ableto open another file.  The operations below can help you avoid such problems,but in the final analysis, the only way to tell whether you can open a file isto try to open it.file_exists(+FileName)            FileName must be an atom.  file_exists/1 succeeds if a file of that            name exists.  If there is something of that name, but it is a            directory, file_exists/1 fails.  You need sufficient rights to the            file to be able to determine whether it is a directory.  Named            pipes and devices are accepted as files.In Xerox Quintus Prolog, a file is deemed to "exist" if INFILEP likes it.            file_exists(+FileName, +Permissions)            FileName must be an atom, and Permissions must be one of the            following, or a list of them:            exists          -- does the file exist            read            -- can the file be read            write           -- can the file be over-written            file_exists/2 succeeds when there is a file (not a directory) named            FileName and you have each of the Permissions you named.            If Permission is an integer, it is interpreted the way that the            argument to the UNIX system call access(2) is interpreted, namely            (the file must exist)                            + 1 * ('execute' permission is wanted)                            + 2 * ('write' permission is wanted)                            + 4 * ('read' permission is wanted)>            This is allowed so that a C programmer who is used to writing                        if (!access(FileName, 6)) {                            can_read_and_write(FileName);                        } else {                            cannot_access_file(FileName);                        }            can write                        (   file_exists(FileName, 6) ->                            can_read_and_write(FileName)                        ;    /* otherwise */                            cannot_access_file(FileName)                        )            We recommend, however, that you code this example as                        (   file_exists(FileName, [read,write]) ->                            can_read_and_write(FileName)                        ;       /* otherwise */                            cannot_access_file(FileName)                        )            Under operating systems which support version numbers in file names            (VMS and Interlisp-D) there is an important distinction between                        | ?- file_exists('FRED', write).            which asks the question "is there already a version of FRED and do            I have permission to write into that existing file", and                        | ?- can_open_file('FRED', write).            which asks the question "would it be possible for be to open a new            file called FRED for output?"file_must_exist(+FileName)            succeeds when file_exists(FileName) succeeds; however, when it            fails, it prints an error message.            | ?- file_must_exist(fred).            ! A file-system goal failed            ! Goal: file_must_exist(fred)            nofile_must_exist(+FileName, +Permission)            succeeds when file_exists(FileName, Permission) succeeds; however,            when it fails, it prints an error message.can_open_file(+FileName, +Mode, +Quiet)            FileName is a file name.  Mode is 'read', 'write', or 'append',            just as for the open/3 command.  can_open_file/2 fails quietly if            the file cannot be opened.  The Quiet parameter controls the            printing of an error message when the file cannot be opened:  if            Quiet is 'fail', can_open_file/3 fails quietly, whereas if Quiet is            'warn', it prints an error message before failing.  If Mode is               - 'read':  FileName must exist and be readable               - 'append':  FileName must exist and you must have                 permission to append to it, or FileName must be                 nonexistent in a directory in which you have permission                 to create a new file               - 'write':  FileName must pertain to a directory in which                 you have permission to create a new version of FileName            This predicate actually attempts to open the file.  It will, for            example, create a file in order to determine whether it can create            it.  But if that happens, it immediately deletes the file again, so            there should be no permanent effect on the file system.can_open_file(+FileName, +Mode)            equivalent to can_open_file(FileName, Mode, fail).open_file(+FileName, +Mode, -Stream)            is the same as the built-in predicate open/3 (which is described in            the Xerox Quintus Prolog Reference Manual), except that it always            prints an error message before failing if it cannot open the file,            and is not sensitive to the 'fileerrors' flag.close_all_streams            closes all the current streams except the standard streams.None of the predicates described in this section is affected by the'fileerrors' flag.  Indeed, they exist so that you can check for errors beforethey happen.See the summary description of library(ask) ({manual(lib-6)}) for two usefulpredicates which use can_open_file/3.