lib-2-4                     Xerox Quintus Prolog Library Manual         Section 2-4: Altering Term Arguments -- library(change_arg)The predicates in library(change_arg) allow you to construct a new term whichis identical to an old term except that one of its elements has been replacedor two of its elements have been swapped.  Using these operations, you coulduse terms as one-dimensional arrays; however, though the elements of sucharrays can be accessed in O(1) time using arg/3, changing an element takes O(N)time, where N is the arity of the term.  See library(logarr) for a moreefficient way of implementing arrays in Prolog.Why then are these operations provided?  To aid in the construction ofterm-rewriting systems.  For example, suppose you have a set of rewrite rulesexpressed as a table            rewrite_rule(X*0, 0).            rewrite_rule(X*1, X).            rewrite_rule(K*X, X*K) :- integer(K).            rewrite_rule(X*(Y*Z), (X*Y)*Z).               .               .               .which you want exhaustively applied to a term.  You could writewaterfall(Expr, Final) :-        path_arg(Path, Expr, Lhs),        rewrite_rule(Lhs, Rhs),        change_path_arg(Path, Expr, Modified, Rhs),        !,        waterfall(Modified, Final).waterfall(Expr, Expr).Then| ?- waterfall((a*b)*(c*0)*d, X).X = 0| ?- waterfall((1*a)*(2*b), X).X = a*2*bThe predicates supplied by library(change_arg) are as follows:change_arg(+Index, ?OldTerm, ?OldArg, ?NewTerm, ?NewArg)            is true when OldTerm and NewTerm are identical except that the            Indexth argument of OldTerm is OldArg and the Indexth argument of            NewTerm is NewArg.  Either OldTerm or NewTerm should be supplied;            the other term can then be found.  change_arg/5 is actually quite            symmetric:                        change_arg(K, O, X, N, Y)            and                        change_arg(K, N, Y, O, X)            have exactly the same effect.  For example:                        | ?- change_arg(1, c(o,l,t), X, N, u).                        X = o,                        N = c(u,l,t)                        | ?- change_arg(1, N, u, c(o,l,t), X).                        N = c(u,l,t),                        X = o                        | ?- change_arg(3, SALE, E, s(a,l,t), T).                        SALE = s(a,l,E),                        E = _755,                        T = t                        | ?- change_arg(3, a+b, b, X, c).                        nochange_arg(+Index, ?OldTerm, ?NewTerm, ?NewArg)            is identical to change_arg/5 except that the OldArg argument is            omitted.  Note:  this argument order may be surprising if you think            about this predicate on its own; however, it makes sense in the            context of the entire group.swap_args(+Index1, +Index2, ?OldTerm, ?Arg1, ?NewTerm, ?Arg2)            is true when OldTerm and NewTerm are identical except that                                        at Index1       at Index2                        in OldTerm         Arg1            Arg2                        in NewTerm         Arg2            Arg1            that is, the arguments at Index1 and Index2 have been swapped.  As            with change_arg/5, swap_args/6 is symmetric;                        swap_args(I, J, O, X, N, Y)            and                        swap_args(I, J, N, Y, O, X)            have exactly the same effect.            | ?- swap_args(1, 4, f(X,e,a,Y,e,r), r, T, d).            X = r,            Y = d,            T = f(d,e,a,r,e,r)swap_args(+Index1, +Index2, ?OldTerm, ?NewTerm)            is identical to swap_args/6 except that the Arg1 and Arg2 arguments            are omitted.                        | ?- swap_args(1, 4, f(r,e,a,d), X).                        X = f(d,e,a,r)change_path_arg(+Path, ?OldTerm, ?OldSub, ?NewTerm, ?NewSub)            is true when OldTerm and NewTerm are identical terms except that                        path_arg(Path, OldTerm, OldSub),                        path_arg(Path, NewTerm, NewSub)            That is, the subterm of OldTerm at Path was OldSub and is replaced            by NewSub in NewTerm, and there are no other differences between            OldTerm and NewTerm.  This is to change_arg/5 as path_arg/3 is to            arg/3.change_path_arg(+Path, ?OldTerm, ?NewTerm, ?NewSub)            is identical to change_path_arg/5 except that the OldSub argument            is omitted.            | ?- OldTerm = this*is+an*example,            |    path_arg(Path, OldTerm, this),            |    change_path_arg(Path, OldTerm, NewTerm, it).            OldTerm = this*is+an*example,            Path = [1,1],            NewTerm = it*is+an*example