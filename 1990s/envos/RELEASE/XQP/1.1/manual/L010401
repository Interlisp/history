lib-1-4-1                     Xerox Quintus Prolog Library Manual              Section 1-4-1: append(?Prefix, ?Suffix, ?Combined)append(?Prefix, ?Suffix, ?Combined) is true when all three arguments are lists,and the members of Combined are the members of Prefix followed by the membersof Suffix.  It may be used to append a given Prefix and Suffix to yieldCombined, or to take a given Combined list apart.  For example,            | ?- append([a,b], [a,d], X).            X = [a,b,a,d]            | ?- append([a], [a], [a]).            no            | ?- append(2, [a], X).            no            | ?- append(X, [e], [b,e,e]).            X = [b,e]            | ?- append([b|X], [e,r], [b,o,r,e,r]).            X = [o,r]            | ?- append(X, Y, [h,i]).            X = [],            Y = [h,i] ;            X = [h],            Y = [i] ;            X = [h,i],            Y = [] ;            noSuppose L is bound to a proper list (see {manual(lib-1-2)}).  That is, it hasthe form [T1,...,Tn] for some n.  Then   1. append(L, X, Y) has at most one solution, whatever X and Y are, and      cannot backtrack at all.   2. append(X, Y, L) has at most n+1 solutions, whatever X and Y are, and      though it can backtrack over these it cannot run away without      finding a solution.   3. append(X, L, Y), however, can backtrack indefinitely if X and Y are      variables.append/3 is a very versatile predicate.  The following examples may surpriseyou, but they are perfectly ordinary uses of append/3.To enumerate adjacent pairs of elements from a list:            next_to(X, Y, /*in*/ List) :-                    append(_, [X,Y|_], List).To check whether Word1 and Word2 are the same except for a singletransposition.  (append/5 in library(lists) would be better for this task.)            one_transposition(Word1, Word2) :-                    append(Prefix, [X,Y|Suffix], Word1),                    append(Prefix, [Y,X|Suffix], Word2).            | ?- one_transposition("fred", X).            X = "rfed" ;            X = "ferd" ;            X = "frde" ;            noGiven a list of words and commas, to backtrack through the phrases delimited bycommas:comma_phrase(List, Phrase) :-        append(F, [','|Rest], List),        !,        (   Phrase = F        ;   comma_phrase(Rest, Phrase)        ).comma_phrase(List, List).| ?- comma_phrase([this,is,',',um,',',an,example], X).X = [this,is] ;X = [um] ;X = [an,example] ;no