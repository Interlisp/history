(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "ROOMS")(il:filecreated "15-Aug-88 13:23:08" il:|{POGO:AISNORTH:XEROX}<ROOMS>NEXT>SOURCES>ROOMS-PLACEMENT-EDITOR.;14| 27422        il:|changes| il:|to:|  (il:vars il:rooms-placement-editorcoms)      il:|previous| il:|date:| "15-Aug-88 12:14:19" il:|{POGO:AISNORTH:XEROX}<ROOMS>NEXT>SOURCES>ROOMS-PLACEMENT-EDITOR.;13|); Copyright (c) 1987, 1988 by Xerox Corporation.  All rights reserved.(il:prettycomprint il:rooms-placement-editorcoms)(il:rpaqq il:rooms-placement-editorcoms ((file-environments il:rooms-placement-editor) (il:p (require "ROOMS") (export (quote (get-pe print-pep-title-string)) "ROOMS")) (il:structures placement-editor pe-placement) (il:variables *placement-editors* *pe-inhibit-redisplay*) (il:functions get-pe make-pe find-pe pe-window-p pe-closefn pe-repaintfn pe-reshapefn pe-totopfn update-pe? update-pe update-peps update-pep-save-bitmap update-pe-window placed-region) (il:coms (il:* il:\; "display") (il:variables *default-icon-size* *pe-title-font* *pep-title-font* *pep-included-shade* *pe-border*) (il:functions display-peps save-pep-image display-pe-title display-pe-border display-pep print-pep-title print-pep-title-string) (il:variables *display-pe-depth*) (il:window-types :placement-editor)) (il:functions pe-rightbuttonfn (il:* il:\; "mouse trackers") pe-buttoneventfn pe-buttoneventfn-internal pe-track-mouse pe-getmousestate pe-track-left-button pe-track-middle-button pep-getboxposition pep-getboxposition-internal) (il:coms (il:* il:\; "editing") (il:functions pe-room-changed-fn pep-selected expand-placement pep-selected-copy-or-move pe-room-selected) (eval-when (load) (il:p (pushnew (quote pe-room-changed-fn) *room-changed-functions*)))) (il:globalvars il:tinyfont il:crosshairs)))(define-file-environment il:rooms-placement-editor :compiler :compile-file :package "ROOMS" :readtable "XCL")(require "ROOMS")(export (quote (get-pe print-pep-title-string)) "ROOMS")(defstruct (placement-editor (:conc-name "PE-") (:constructor make-pe-internal) (:print-function (lambda (pe stream depth) (format stream "#<Placement Editor for ~S>" (pe-room-name pe))))) (changed? t :type (member t nil :placements)) (room-name nil) (scale *one-to-one* :type scale) (peps nil :type list) (window nil) (title-text nil :type text) (clipping-region nil))(defstruct (pe-placement (:conc-name "PEP-") (:print-function (lambda (pep stream depth) (format stream "#<PEP ~O,~O>" (il:\\hiloc pep) (il:\\loloc pep))))) (placement nil :type placement) (scaled-region nil :type region) (immediate? nil :type (member t nil)) (open? nil :type (member t nil)) (save-bitmap nil) (unscaled-region nil :type region))(defglobalvar *placement-editors* (make-hash-table :test (quote equal)))(defvar *pe-inhibit-redisplay* nil)(defun get-pe (room-name &optional region) (il:* il:|;;;| "returns the PE for ROOM, creating one if required.  if REGION is provided then the PE will occupy it.") (let ((pe (find-pe room-name))) (if pe (il:* il:|;;| "this code optimized so there is never more than one redisplay when entering overview") (let* ((window (pe-window pe)) (icon (window-icon window)) shaped?) (il:* il:|;;| "this gets smashed when window closed") (il:windowprop window :placement-editor pe) (let ((*pe-inhibit-redisplay* t)) (un-hide-window window) (il:openw window) (il:totopw window) (when region (shape-window window region))) (update-pe? pe) pe) (make-pe room-name region))))(defun make-pe (room-name &optional region) (il:* il:|;;;| "don't call this.  call GET-PE instead.  we depend on there only being on PE per room.") (let* ((window (il:createw region nil 0)) (pe (make-pe-internal :room-name room-name :window window :title-text (make-text :string (if (stringp room-name) room-name (princ-to-string room-name)) :shadows t :font *pe-title-font*)))) (il:windowprop window (quote il:closefn) (quote pe-closefn)) (il:windowprop window :placement-editor pe) (il:windowprop window (quote il:buttoneventfn) (quote pe-buttoneventfn)) (il:windowprop window (quote il:rightbuttonfn) (quote pe-rightbuttonfn)) (il:windowprop window (quote il:repaintfn) (quote pe-repaintfn)) (il:windowprop window (quote il:reshapefn) (quote pe-reshapefn)) (il:windowprop window (quote il:totopfn) (quote pe-totopfn)) (il:windowprop window (quote il:aftermovefn) (quote pe-totopfn)) (il:windowprop window (quote il:openfn) (quote pe-totopfn)) (il:dspfont *pep-title-font* window) (setf (find-pe room-name) pe) (il:* il:|;;| "update things") (update-pe-window pe) (update-pe pe) pe))(defmacro find-pe (room-name) (il:bquote (gethash (il:\\\, room-name) *placement-editors*)))(defun pe-window-p (window) (placement-editor-p (il:windowprop window :placement-editor)))(defun pe-closefn (window) (il:* il:|;;| "remove circularity") (il:windowprop window :placement-editor nil))(defun pe-repaintfn (window &rest ignore) (let ((pe (il:windowprop window :placement-editor))) (display-pe-title pe) (display-pe-border pe) (setf (pe-changed? pe) t) (update-pe pe)))(defun pe-reshapefn (window &rest ignore) (let ((pe (il:windowprop window :placement-editor))) (update-pe-window pe) (setf (pe-changed? pe) t) (unless *pe-inhibit-redisplay* (update-pe pe))))(defun pe-totopfn (window) (il:totopw window t) (let ((pe (il:windowprop window :placement-editor))) (when pe (display-pe-title pe) (unless *pe-inhibit-redisplay* (update-pe? pe)))))(defun update-pe? (pe) (when (pe-changed? pe) (update-pe pe)))(defun update-pe (pe) (il:* il:|;;;| "update PE per the current state of rooms") (let ((*pe-inhibit-redisplay* t) (il:* il:|;;| "don't want TOTOP to update too") (room (room-named (pe-room-name pe)))) (when room (let ((dsp (il:getstream (pe-window pe)))) (case (pe-changed? pe) (:placements (il:* il:\; "incremental redisplay") (let ((old-peps (pe-peps pe))) (update-peps pe old-peps) (display-peps pe dsp old-peps))) (t (il:* il:\; "total redisplay") (update-peps pe) (paint-background room dsp :scale (pe-scale pe) :no-text t :clipping-region (pe-clipping-region pe)) (display-peps pe dsp))) (setf (pe-changed? pe) nil)))))(defun update-peps (pe &optional old-peps) (il:* il:|;;| "build a new list of PEPs for PE.") (il:* il:|;;| "the redisplay code depends upon us leaving EQ peps only when the placement hasn't changed.") (let ((room (room-named (pe-room-name pe)))) (when room (let ((immediate-placements (room-placements room)) (scale (pe-scale pe))) (do* ((all (find-placements room)) (tail all (cdr tail))) ((null tail) (setf (pe-peps pe) all)) (setf (first tail) (let* ((placement (first tail)) (immediate? (member placement immediate-placements :test (quote eq))) (scaled-region (placed-region placement))) (or (dolist (pep old-peps) (il:* il:|;;| "try to find an old PEP for placement") (when (eq (pep-placement pep) placement) (il:* il:|;;| "found it") (when (eq pep (first old-peps)) (il:* il:|;;| "speed future searches") (pop old-peps)) (return (when (and (if (pep-immediate? pep) immediate? (not immediate?)) (equal (pep-unscaled-region pep) scaled-region)) (il:* il:\; "ok to use it") pep)))) (update-pep-save-bitmap (make-pe-placement :placement placement :immediate? immediate? :scaled-region (scale-region scaled-region scale) :unscaled-region scaled-region))))))))))(defun update-pep-save-bitmap (pep) (let* ((scaled-region (pep-scaled-region pep)) (save (il:bitmapcreate (region-width scaled-region) (region-height scaled-region))) (dsp (il:loadtimeconstant (il:dspcreate)))) (il:dspdestination save dsp) (il:dspxoffset (- (region-left scaled-region)) dsp) (il:dspyoffset (- (region-bottom scaled-region)) dsp) (display-pep pep dsp) (setf (pep-save-bitmap pep) save) (setf (pep-open? pep) nil) pep))(defun update-pe-window (pe) (let* ((window (pe-window pe)) (dsp (il:getstream window)) (window-region (window-region window)) (window-height (region-height window-region)) (text (pe-title-text pe)) (height (- window-height (text-%height text))) (twice-border (* *pe-border* 2)) (clipping-region (make-region :left *pe-border* :bottom *pe-border* :width (- (region-width window-region) twice-border) :height (- height twice-border)))) (il:* il:|;;| "update scale & clipping region") (setf (pe-clipping-region pe) clipping-region) (setf (pe-scale pe) (make-scale clipping-region)) (setf (text-position text) (make-position *pe-border* height)) (display-pe-title pe) (display-pe-border pe)))(defun placed-region (placement) (il:* il:|;;;| "returns the region PLACEMENT would occupy on the screen.  for non-shrunken placements this is just the PLACEMENT-REGION, but for shrunken placements we need to figure what the region of the icon would be.") (if (placement-shrunken? placement) (let* ((icon-position (placement-icon-position placement)) (icon (window-icon (placement-window placement))) (icon-region (if icon (window-region icon)))) (make-region :left (position-x icon-position) :bottom (position-y icon-position) :width (if icon (region-width icon-region) *default-icon-size*) :height (if icon (region-height icon-region) *default-icon-size*))) (placement-region placement)))(il:* il:\; "display")(defvar *default-icon-size* (il:* il:|;;;| "when we draw a placement for a non-existant icon, we draw it as a square with this many (scaled) pixels per side.") 75)(defglobalvar *pe-title-font* (il:fontcreate (quote il:helvetica) 36 (quote (il:bold il:regular il:regular)) nil (quote il:display)))(defglobalparameter *pep-title-font* (il:fontcreate il:tinyfont nil nil nil (quote il:display)))(defglobalparameter *pep-included-shade* 4680)(defglobalparameter *pe-border* 4)(defun display-peps (pe dsp &optional old-peps) (il:* il:|;;;| "displays PE on DSP.  Should be called DISPLAY-PE-INTERNAL.") (let ((old old-peps) (new (pe-peps pe))) (loop (il:* il:|;;| "pop off the EQ peps on the bottom of window stack") (when (or (null old) (null new) (not (eq (first old) (first new)))) (return)) (pop old) (pop new)) (il:* il:|;;| "remove image of remaining old peps") (dolist (pep (reverse old)) (save-pep-image dsp pep pe)) (il:* il:|;;| "display remaining new peps") (dolist (pep new) (save-pep-image dsp pep pe))))(defun save-pep-image (dsp pep pe) (il:* il:|;;;| "switch contents of PEP's save & its region of DSP.") (let* ((region (pep-scaled-region pep)) (left (pop region)) (bottom (pop region)) (width (pop region)) (height (pop region)) (clipping (pe-clipping-region pe)) (clipping-left (pop clipping)) (clipping-bottom (pop clipping)) (clipping-width (pop clipping)) (clipping-height (pop clipping)) (save (pep-save-bitmap pep))) (il:uninterruptably (il:bitblt save 0 0 dsp left bottom width height (quote il:input) (quote il:invert) nil clipping) (il:bitblt dsp (max left clipping-left) (max bottom clipping-bottom) save 0 0 (min width (- (+ clipping-width clipping-left) left)) (min height (- (+ clipping-height clipping-bottom) bottom)) (quote il:input) (quote il:invert)) (il:bitblt save 0 0 dsp left bottom width height (quote il:input) (quote il:invert) nil clipping)) (setf (pep-open? pep) (not (pep-open? pep)))))(defun display-pe-title (pe) (let* ((window (pe-window pe)) (window-region (window-region window)) (dsp (il:getstream window)) (text (pe-title-text pe)) (window-height (region-height window-region)) (bottom (- window-height (text-%height text)))) (il:* il:|;;| "blt the background into the title bar") (il:bitblt (il:windowprop window (quote il:imagecovered)) 0 bottom dsp 0 bottom (region-width window-region) (- window-height bottom)) (if (equal (pe-room-name pe) *back-door-room-name*) (il:* il:|;;| "the title of the back door room gets special shadows ") (when (eq (text-shadows text) t) (setf (text-shadows text) (maplist (function (lambda (tail) (if (rest tail) (first tail) (il:constant (make-text-shadow :source-type (quote il:merge) :texture 42405 :operation (quote il:invert)))))) (get-text-shadows-internal *pe-title-font*))) (update-text-caches text)) (unless (eq (text-shadows text) t) (il:* il:|;;| "used to be back-door room") (setf (text-shadows text) t) (update-text-caches text))) (display-text text dsp)))(defun display-pe-border (pe) (let* ((window (pe-window pe)) (window-region (window-region window))) (il:* il:|;;| "draw the window border & clear inside it") (draw&fill-box-within (make-region :left 0 :bottom 0 :width (region-width window-region) :height (- (region-height window-region) (text-%height (pe-title-text pe)))) (il:getstream window) :border-width (floor *pe-border* 2))))(defun display-pep (pep dsp) (il:* il:|;;;| "displays a PE-PLACEMENT") (il:* il:|;;| "draw a box around the region & fill it if it represents an immediate placement in the room of this PEP.") (draw&fill-box-within (pep-scaled-region pep) dsp :border-width 1 :shade (if (pep-immediate? pep) il:whiteshade *pep-included-shade*)) (print-pep-title pep dsp))(defun print-pep-title (pep dsp) (il:* il:|;;| "print something within the box drawn for PEP on DSP ") (let* ((window-type (window-type (placement-window (pep-placement pep)) t))) (when window-type (let ((title (window-type-prop window-type :title))) (il:* il:|;;| "interpret the TITLE property of the window type of the placement this PEP represents") (cond ((null title) (il:* il:|;;| "if none specified, just print the name of the type") (print-pep-title-string (string (window-type-name window-type)) (pep-scaled-region pep) dsp :no-title-bar? (placement-shrunken? (pep-placement pep)))) ((stringp title) (il:* il:|;;| "if it's a string, print it") (print-pep-title-string title (pep-scaled-region pep) dsp :no-title-bar? (placement-shrunken? (pep-placement pep)))) (t (il:* il:|;;| "otherwise assume it's a function & call it") (funcall title (pep-placement pep) (pep-scaled-region pep) dsp)))))))(defun print-pep-title-string (string region dsp &key (font *pep-title-font*) no-title-bar?) (il:* il:|;;;| "prints STRING in the top left corner of REGION if it will fit.") (let* ((string (if (stringp string) string (princ-to-string string))) (font-height (il:fontheight font)) (title-y (- (+ (region-bottom region) (region-height region)) font-height (if no-title-bar? 1 0))) (string-width (il:stringwidth string font))) (when (and (< string-width (- (region-width region) 2)) (< font-height (- (region-height region) 2))) (unless no-title-bar? (il:bltshade il:blackshade dsp (region-left region) (1- title-y) (region-width region) font-height (quote il:paint))) (il:dspoperation (if no-title-bar? (quote il:paint) (quote il:invert)) dsp) (il:dspfont font dsp) (il:moveto (+ (region-left region) (if no-title-bar? (- (floor (region-width region) 2) (floor string-width 2)) 2)) (if no-title-bar? (+ (region-bottom region) (- (floor (region-height region) 2) (floor font-height 2)) (il:fontdescent font)) (+ title-y (il:fontdescent font))) dsp) (check-type dsp stream) (il:\\sout string dsp) (il:dspoperation (quote il:replace) dsp))))(defparameter *display-pe-depth* 1 "Depth to recursivly display placement editors within placement editors")(def-window-type :placement-editor :recognizer (lambda (window) (placement-editor-p (il:windowprop window :placement-editor))) :abstracter (lambda (window) (let ((pe (il:windowprop window :placement-editor))) (when pe (il:bquote (:region (il:\\\, (externalize-region (window-region (pe-window pe)))) :room-name (il:\\\, (pe-room-name (il:windowprop window :placement-editor)))))))) :reconstituter (lambda (plist) (pe-window (get-pe (getf plist :room-name) (internalize-region (getf plist :region))))) :title (lambda (placement region dsp) (let ((pe (il:windowprop (placement-window placement) :placement-editor))) (when pe (print-pep-title-string (let ((name (pe-room-name pe))) (if (stringp name) name (princ-to-string name))) region dsp) (il:* il:\| "(when (> *display-pe-depth* 0) (let ((*display-pe-depth* (1- *display-pe-depth*)) (old-scale (pe-scale pe)) (old-peps (pe-peps pe)) (old-clipping-region (pe-clipping-region pe)) (new-clipping-region (make-region :left (+ (region-left region) 1) :bottom (+ (region-bottom region) 1) :width (- (region-width region) 2) :height (- (region-height region) 2 (il:fontheight *pep-title-font*))))) (unwind-protect (progn (setf (pe-scale pe) (make-scale new-clipping-region)) (setf (pe-changed? pe) t) (setf (pe-clipping-region pe) new-clipping-region) (update-peps pe) (il:* il:|;;| \"recursively display pictogram\") (display-peps pe dsp)) (setf (pe-scale pe) old-scale) (setf (pe-peps pe) old-peps) (setf (pe-clipping-region pe) old-clipping-region))))")))))(defun pe-rightbuttonfn (window) (unless (eq *current-room* *overview-room*) (il:dowindowcom window)))(defun pe-buttoneventfn (window) (il:totopw window) (let ((pe (il:windowprop window :placement-editor))) (if (il:insidep (pe-clipping-region pe) (il:lastmousex window) (il:lastmousey window)) (pe-buttoneventfn-internal pe window) (unless (eq *current-room* *overview-room*) (case (menu (quote (("ReFetch" :re-fetch)))) (:re-fetch (update-placements)))))))(defun pe-buttoneventfn-internal (pe window) (let ((window window) (pe pe)) (loop (when (and (placement-editor-p pe) (pe-track-mouse pe window)) (return)) (pe-getmousestate) (unless (il:lastmousestate (or il:left il:middle)) (return)) (setq window (il:whichw)) (setq pe (when window (il:windowprop window :placement-editor))))))(defun pe-track-mouse (pe window) (let ((*timer* (il:setuptimer *button-help-delay*))) (declare (special *timer*)) (cond ((il:lastmousestate (il:only il:left)) (let ((selected-pep (pe-track-left-button pe))) (when selected-pep (pep-selected selected-pep pe) (il:* il:|;;| "return true when something's been selected") t))) ((il:lastmousestate il:middle) (let ((room-selected? (pe-track-middle-button pe))) (when room-selected? (pe-room-selected pe) (il:* il:|;;| "return true when something's been selected") t))))))(defun pe-getmousestate nil (il:* il:|;;| "call GETMOUSESTATE, and if the mouse hasn't moved, block.  This is in case we're in the Overview, so the keyboard watcher will run.") (let ((x il:lastmousex) (y il:lastmousey)) (il:getmousestate) (when (and (= x il:lastmousex) (= y il:lastmousey)) (il:block))))(defun pe-track-left-button (pe) (declare (special *timer*)) (let ((selected-pep nil) (clipping-region (pe-clipping-region pe)) (window (pe-window pe)) (il:* il:|;;| "need PEPS in top down order to handle occlusion correctly") (peps (reverse (pe-peps pe)))) (macrolet ((invert-selected-pep nil (il:bquote (let ((region (pep-scaled-region selected-pep))) (il:bltshade il:blackshade window (region-left region) (region-bottom region) (region-width region) (region-height region) (quote il:invert) clipping-region))))) (loop (unless (and (il:lastmousestate (il:only il:left)) (il:insidep clipping-region (il:lastmousex window) (il:lastmousey window))) (return (when selected-pep (il:* il:|;;| "restore the display") (invert-selected-pep) (when (and (not (il:lastmousestate il:middle)) (il:insidep clipping-region (il:lastmousex window) (il:lastmousey window))) (il:* il:|;;| "return the PEP if there's one selected & the button event fn should be exited.") selected-pep)))) (dolist (il:* il:|;;| "look down the occlusion stack") (pep peps (when selected-pep (il:* il:|;;| "bottomed out -- must be in the background") (il:* il:|;;| "have to de-select selection") (invert-selected-pep) (setq selected-pep nil))) (when (il:insidep (pep-scaled-region pep) (il:lastmousex window) (il:lastmousey window)) (il:* il:|;;| "we're in a PEP") (unless (eq pep selected-pep) (il:* il:|;;| "it's a new selection") (when selected-pep (il:* il:|;;| "unselect the current selection") (invert-selected-pep)) (il:* il:|;;| "select the new one") (setq selected-pep pep) (invert-selected-pep)) (il:* il:|;;| "pop to the outer loop") (return))) (when (and *timer* (il:timerexpired? *timer*)) (notify-user "Use LEFT to select placements, MIDDLE Rooms.") (il:totopw window t) (setq *timer* nil)) (pe-getmousestate)))))(defun pe-track-middle-button (pe) (declare (special *timer*)) (let* ((window (pe-window pe)) (region (window-region window))) (unwind-protect (progn (il:invertw window) (loop (unless (il:insidep region il:lastmousex il:lastmousey) (il:* il:|;;| "return NIL if mouse leaves clipping region") (return nil)) (unless (il:lastmousestate il:middle) (il:* il:|;;| "return true iff room was selected") (return (not (il:lastmousestate (or il:left il:right))))) (when (and *timer* (il:timerexpired? *timer*)) (notify-user "Use LEFT to select placements, MIDDLE Rooms.") (il:totopw window t) (setq *timer* nil)) (pe-getmousestate))) (il:invertw window))))(defun pep-getboxposition (pe pep) (il:* il:|;;;| "called when a placement is MOVE or COPY selected to get the new position for the placement.") (il:* il:|;;;| "returns two values - a position and a PE - or NIL") (let* ((old-cursor (il:cursor)) (old-tty (il:tty.process))) (unwind-protect (progn (il:cursor il:crosshairs) (il:tty.process (il:this.process)) (il:cursorposition (make-position (region-left (pep-scaled-region pep)) (region-bottom (pep-scaled-region pep))) (pe-window pe)) (do* ((placed-region (placed-region (pep-placement pep))) (height (region-height placed-region)) (width (region-width placed-region)) (window nil (il:* il:|;;| "the window the cursor is over (if any)") (il:whichw)) (pe nil (il:* il:|;;| "the PE the cursor is over (if any)") (if (and window (pe-window-p window)) (il:windowprop window :placement-editor))) (position nil (il:* il:|;;| "the selected position within PE (if any)") (if pe (let ((clipping-region (pe-clipping-region pe)) (scale (pe-scale pe))) (if (il:insidep clipping-region (il:lastmousex window) (il:lastmousey window)) (il:* il:|;;| "have to rescale box for each PE") (pep-getboxposition-internal (scale-width width scale) (scale-height height scale) (pe-clipping-region pe) window) (il:getmousestate))) (il:getmousestate)))) ((or position (il:lastmousestate (or il:left il:middle il:right))) (when position (values (un-scale-position position (pe-scale pe)) pe))))) (il:cursor old-cursor) (il:tty.process old-tty))))(defun pep-getboxposition-internal (width height clipping-region window) (il:* il:|;;;| "track a box WIDTH by HEIGHT within CLIPPING-REGION in WINDOW.  if a button goes down return the X,Y position.  if cursor goes outside CLIPPING-REGION then return NIL.") (let* ((dsp (il:getstream window)) (old-operation (il:dspoperation nil dsp)) (last-x (il:lastmousex dsp)) (last-y (il:lastmousey dsp))) (macrolet ((invert-box nil (il:bquote (il:drawgraybox last-x last-y (+ last-x width) (+ last-y height) dsp il:grayshade)))) (unwind-protect (progn (il:totopw window) (il:dspoperation (quote il:invert) dsp) (invert-box) (tagbody loop (unless (il:insidep clipping-region last-x last-y) (return-from pep-getboxposition-internal)) (when (il:mousestate (or il:left il:middle il:right)) (return-from pep-getboxposition-internal (make-position last-x last-y))) (unless (and (= (il:lastmousex dsp) last-x) (= (il:lastmousey dsp) last-y)) (il:uninterruptably (il:* il:|;;| "un-draw old") (invert-box) (setq last-x (il:lastmousex dsp)) (setq last-y (il:lastmousey dsp)) (il:* il:|;;| "re-draw new") (invert-box))) (go loop))) (invert-box) (il:dspoperation old-operation dsp)))))(il:* il:\; "editing")(defun pe-room-changed-fn (room reason) (when (eq reason :deleted) (il:* il:|;;| "if ROOM has been deleted then delete the placement editor") (let ((pe (find-pe (room-name room)))) (when pe (let ((window (pe-window pe))) (il:* il:|;;| "delete the placement editor") (un-hide-window window) (close-window window) (remhash (room-name room) *placement-editors*))))) (let ((includers (room-includers room t))) (il:* il:|;;| "ensure PE's for all rooms which include ROOM will be redisplayed") (dolist (includer includers) (let ((pe (find-pe (room-name includer)))) (when pe (il:* il:|;;| "otherwise mark it as needing update") (unless (eq (pe-changed? pe) t) (il:* il:|;;| "OK to upgrade :PLACEMENTS to T, but not vice versa") (setf (pe-changed? pe) (if (eq reason :placements) reason t))) (let ((window (pe-window pe))) (when (and (il:openwp window) (not (window-hidden? window))) (il:* il:|;;| "update the PE if it's visible") (update-pe pe))))))))(defun pep-selected (pep pe) (il:* il:|;;;| "called when a placement is selected in PE") (let ((op (cond ((copy-key-down-p) :copy) ((move-key-down-p) :move) ((delete-key-down-p) :delete) ((expand-key-down-p) :expand) (t (ov-operation))))) (case op ((:copy :move) (pep-selected-copy-or-move op pep pe)) (:delete (interactive-close-window (placement-window (pep-placement pep)) (room-named (pe-room-name pe)))) (:expand (expand-placement (pep-placement pep))) (t (notify-user "Use a modifier (eg. COPY, MOVE or DELETE)")))))(defun expand-placement (placement) (let ((window (placement-window placement))) (if (window-hidden? window) (progn (notify-user "Click LEFT when finished") (place-placement placement) (loop (when (il:mousestate il:left) (return))) (hide-window window)) (il:flashwindow (if (shrunken? window) (window-icon window) window)))))(defun pep-selected-copy-or-move (op pep pe) (multiple-value-bind (destination-pos destination-pe) (pep-getboxposition pe pep) (if destination-pos (let* ((old-placement (pep-placement pep)) (new-placement (copy-placement old-placement))) (il:* il:|;;| "adjust the position of the new placement") (if (placement-shrunken? new-placement) (setf (placement-icon-position new-placement) destination-pos) (setf (placement-region new-placement) (make-region :left (position-x destination-pos) :bottom (position-y destination-pos) :width (region-width (placement-region new-placement)) :height (region-height (placement-region new-placement))))) (il:* il:|;;| "do the move/copy") (let ((pe-room (room-named (pe-room-name pe))) (destination-room (room-named (pe-room-name destination-pe)))) (multiple-value-bind (placement source-room) (il:* il:|;;| "find the room this placement is due to") (find-placement (placement-window old-placement) pe-room) (ecase op (:move (if (eq pe destination-pe) (il:* il:|;;| "Allow inherited placements to be moved in place -- w/o moving them to the room they're visible in.") (setq destination-room source-room) (unless (eq destination-room source-room) (il:* il:|;;| "We don't bother deleting first when source & destination are same, as we know ADD-PLACEMENT will delete the old & we only want to redisplay once") (delete-placement placement source-room))) (add-placement new-placement destination-room)) (:copy (add-placement new-placement destination-room)))))) (notify-user "Invalid destination."))))(defun pe-room-selected (pe) (il:* il:|;;;| "called when a room is selected in PE") (let ((room (room-named (pe-room-name pe))) (op (cond ((il:keydownp (quote il:space)) :enter) ((edit-key-down-p) :edit) ((copy-key-down-p) :copy) ((move-key-down-p) :move) ((delete-key-down-p) :delete) (t (if (eq *current-room* *overview-room*) (ov-operation) :enter))))) (case op (:edit (edit-room room)) (:copy (interactive-copy-room room)) (:move (interactive-rename-room room)) (:delete (interactive-delete-room room)) (:enter (go-to-room room)) (t (notify-user "Use a modifier (eg. COPY, DELETE or GO TO).")))))(eval-when (load)(pushnew (quote pe-room-changed-fn) *room-changed-functions*))(il:declare\: il:doeval@compile il:dontcopy(il:globalvars il:tinyfont il:crosshairs))(il:putprops il:rooms-placement-editor il:copyright ("Xerox Corporation" 1987 1988))(il:declare\: il:dontcopy  (il:filemap (nil)))il:stop