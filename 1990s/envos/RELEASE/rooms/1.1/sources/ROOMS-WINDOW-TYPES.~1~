(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "ROOMS")(il:filecreated "15-Jun-88 14:16:12" il:|{POGO:AISNORTH:XEROX}<ROOMS>NEXT>SOURCES>ROOMS-WINDOW-TYPES.;3| 6286         il:|changes| il:|to:|  (il:functions abstract-window)      il:|previous| il:|date:| "24-May-88 18:43:46" il:|{POGO:AISNORTH:XEROX}<ROOMS>NEXT>SOURCES>ROOMS-WINDOW-TYPES.;2|); Copyright (c) 1987, 1988 by Xerox Corporation.  All rights reserved.(il:prettycomprint il:rooms-window-typescoms)(il:rpaqq il:rooms-window-typescoms ((file-environments il:rooms-window-types) (il:p (export (quote (def-window-type window-type window-type-prop))) (require "ROOMS")) (il:structures window-type) (il:functions window-type-prop) (il:define-types il:window-types) (il:variables *window-types*) (il:functions def-window-type window-type-named window-type window-type-internal abstract-window reconstitute-window) (il:sedit-formats def-window-type)))(define-file-environment il:rooms-window-types :compiler :compile-file :package "ROOMS" :readtable "XCL")(export (quote (def-window-type window-type window-type-prop)))(require "ROOMS")(defstruct (window-type (:print-function (lambda (window-type stream depth) (format stream "#<Window Type ~S>" (window-type-name window-type))))) (name nil :type string) (dependencies nil :type list) (recognizer nil :type function) (abstracter nil :type function) (reconstituter nil :type function) (placer nil :type function) (updater nil :type function) (props nil :type list))(defmacro window-type-prop (window-type prop &optional (new-value nil new-value-supplied)) (if new-value-supplied (il:bquote (setf (getf (window-type-props (il:\\\, window-type)) (il:\\\, prop)) (il:\\\, new-value))) (il:bquote (getf (window-type-props (il:\\\, window-type)) (il:\\\, prop)))))(def-define-type il:window-types "Window types" :undefiner (lambda (name) (remhash name *window-types*)))(defglobalvar *window-types* (make-hash-table :test (quote eq)) "Hash table mapping from window type names to window type objects.")(defdefiner def-window-type il:window-types (name &rest rest-keys &key dependencies recognizer abstracter reconstituter placer updater &allow-other-keys) (il:* il:|;;;| "defines a window type") (flet ((kwote (x) (il:* il:|;;| "we want lambda expressions wrapped in FUNCTION and named functions just quoted") (typecase x (cons (list (case (first x) ((lambda il:lambda) (quote function)) (t (quote quote))) x)) ((satisfies constantp) x) (t (list (quote quote) x))))) (il:bquote (setf (gethash (quote (il:\\\, name)) *window-types*) (make-window-type :name (quote (il:\\\, name)) :dependencies (quote (il:\\\, dependencies)) :recognizer (il:\\\, (kwote recognizer)) (il:\\\,@ (when abstracter (il:bquote (:abstracter (il:\\\, (kwote abstracter)))))) (il:\\\,@ (when reconstituter (il:bquote (:reconstituter (il:\\\, (kwote reconstituter)))))) (il:\\\,@ (when updater (il:bquote (:updater (il:\\\, (kwote updater)))))) (il:\\\,@ (when placer (il:bquote (:placer (il:\\\, (kwote placer)))))) :props (list (il:\\\,@ (mapcar (function kwote) (let ((props (copy-list rest-keys))) (dolist (keyword (quote (:dependencies :recognizer :abstracter :reconstituter :placer :updater))) (remf props keyword)) props)))))))))(defun window-type-named (name &optional no-error?) (or (gethash name *window-types*) (unless no-error? (error "No window type named ~S." name))))(defun window-type (window &optional no-error?) (il:* il:|;;;| "return the window type object for WINDOW.") (let ((cached-type-name (il:windowprop window (quote window-type)))) (if cached-type-name (let ((type (window-type-named cached-type-name t))) (if (and type (funcall (window-type-recognizer type) window)) type (progn (il:* il:|;;| "invalidate cache") (il:windowprop window (quote window-type) nil) (il:* il:|;;| "try again") (window-type window no-error?)))) (let ((type (window-type-internal window no-error?))) (il:* il:|;;| "should cache misses here too") (when type (il:* il:\; "cache it") (il:windowprop window (quote window-type) (window-type-name type)) (il:* il:\; "return it") type)))))(defun window-type-internal (window no-error?) (il:* il:|;;;| "We only want the most specific type -- that which no others are dependent upon.  We find this by first enumerating all the types whose recognizer fires on WINDOW.  We then delete from this list any types upon which others in the list are dependent.  The remaining list should have only one element -- the right type.") (let* ((all-types (with-collection (maphash (function (lambda (name type) (when (funcall (window-type-recognizer type) window) (collect type)))) *window-types*))) (remaining-types (copy-list all-types))) (dolist (type all-types) (dolist (dependency (window-type-dependencies type)) (setq remaining-types (delete (window-type-named dependency) remaining-types)))) (cond ((null remaining-types) (unless no-error? (error "Can't find window type for ~S." window))) ((endp (rest remaining-types)) (first remaining-types)) (t (unless no-error? (error "Type conflict: ~S is of types ~S." window (mapcar (function window-type-name) remaining-types)))))))(defun abstract-window (window &optional shh) (il:* il:|;;;| "returns an abstraction suitable for passing to RECONSTITUTE-WINDOW, or NIL if it can't find one.") (let* ((type (window-type window t)) (abstracter (and type (window-type-abstracter type)))) (if abstracter (list* :type (window-type-name type) (funcall abstracter window)) (unless shh (fresh-line *error-output*) (if type (format *error-output* "Can't abstract windows of type ~S." (window-type-name type)) (format *error-output* "~S has no type." window)) (let ((hidden? (window-hidden? window))) (when hidden? (un-hide-window window)) (il:flashwindow (if (shrunken? window) (window-icon window) window) 2) (when hidden? (hide-window window))) (format *error-output* "  Ignoring.~%") nil))))(defun reconstitute-window (type-name arg) (let ((type (window-type-named type-name t))) (if type (funcall (window-type-reconstituter type) arg) (prog1 nil (warn "Can't reconstitute windows of type ~A." type-name)))))(sedit:def-list-format def-window-type :args (nil :keyword nil) :indent (1))(il:putprops il:rooms-window-types il:copyright ("Xerox Corporation" 1987 1988))(il:declare\: il:dontcopy  (il:filemap (nil)))il:stop