/* @(#) cell.h Version 2.12 (6/4/90). copyright Venue & Fuji Xerox  *//* *	Author	:	Takeshi Shimizu *			Hiroshi Hayata *//************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************//**********************************************************************//*		File Name :	cell.h		Cell Manipulate Macros				Date :		December 16, 1986				Edited by :	Takeshi Shimizu*//**********************************************************************//*  CONS CELL (LISTP) definitions moved to lispemulater.h */  /* This Macro may produce the CDR code */#define  CDRCODE(x)     LRSH (((int)x & 0x0ff000000) , 24)  /* This Macro may produce a pointer that points CAR cell */  /* On 68010,68000 This Macro does not effect *#define  CARFIELD(x)    ((int)x & 0x00ffffff)/* CDR-Codes defs */#define CDR_ONPAGE		128#define CDR_NIL			128#define CDR_INDIRECT		0#define CDR_MAXINDIRECT	127short  CarCdrError ;#ifndef BYTESWAPstruct  conspage    {      unsigned    count : 8   ;      unsigned    next_cell :8 ;      DLword  next_page ;    };#else/* byte-swapped version */struct  conspage    {      DLword  next_page ;      unsigned    next_cell :8 ;      unsigned    count : 8   ;    };#endif BYTESWAP/* Following MACROs for Conspage *//* lisp_ptr is LISP pointer, returns 68k ptr points struct conspage obj */#define Get_ConsPageBase(lisp_ptr)	(struct conspage *)Addr68k_from_LPAGE(POINTER_PAGEBASE(lisp_ptr))#define GetNewCell_68k(conspage68k)	 (ConsCell *)(((DLword *)(conspage68k)) + (unsigned)((conspage68k)->next_cell) )/* page : LISP page */#define GetCONSCount(page)	(((struct conspage *)Addr68k_from_LPAGE(page))->count)#ifndef BYTESWAP	/************************************************/	/*  Definitions for normal byte-order machines	*/	/************************************************//* DEFs for DEFINITIONCELL */typedef  struct definition_cell    {      unsigned	ccodep	:	1 ;      unsigned	fastp	:	1 ;      unsigned	argtype	:	2 ;      unsigned	pseudocodep :	1 ;      unsigned	nil	:	3 ;      unsigned	defpointer :	24;    } DefCell ;typedef  struct pname_cell    {      unsigned	pkg_index : 8 ;      unsigned	pnamebase : 24 ;    } PNCell ;typedef  struct proplist_cell    {      unsigned unused: 1;      unsigned gensymp: 1;      unsigned fatpnamep: 1;      unsigned nil: 5;      unsigned propbase: 24;    } PLCell;struct xpointer{	unsigned	flags:8;	unsigned	addr:24;};#else	/************************************************/	/*  Definitions for byte-swapped machines	*/	/************************************************//* DEFs for DEFINITIONCELL */typedef  struct definition_cell    {      unsigned	defpointer :	24;      unsigned	nil	:	3 ;      unsigned	pseudocodep :	1 ;      unsigned	argtype	:	2 ;      unsigned	fastp	:	1 ;      unsigned	ccodep	:	1 ;    } DefCell ;typedef  struct pname_cell    {      unsigned	pnamebase : 24 ;      unsigned	pkg_index : 8 ;    } PNCell ;typedef  struct proplist_cell    {       unsigned propbase: 24;      unsigned nil: 5;      unsigned fatpnamep: 1;      unsigned gensymp: 1;     unsigned unused: 1;    } PLCell;struct xpointer  {    unsigned	addr:24;    unsigned	flags:8;  };#endif BYTESWAPstruct  cadr_cell    {      LispPTR car_cell;	/* Lisp address (word addressing) */      LispPTR cdr_cell;	/* Lisp address (word addressing) */    };#define GetDEFCELL68k(index)	((LispPTR *)Defspace + (index) )#define GetVALCELL68k(index)	((LispPTR *)Valspace + (index))#define GetPnameCell(index)	((LispPTR *)Pnamespace + (index))#define GetPropCell(index)	((LispPTR *)Plistspace + (index))/* When cadr() function is called, type check should be done. */#define	S_N_CHECKANDCADR(sour, dest, tos)			\		{register LispPTR parm = sour;			\		 if(GetTypeNumber(parm) != TYPE_LISTP){		\			ERROR_EXIT(tos);			\		}else						\			dest = cadr(parm);			\		}