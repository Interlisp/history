/* @(#) colorbltchar.c Version 1.3 (4/20/90). copyright venue & Fuji Xerox  */static char *id = "@(#) colorbltchar.c	1.3 4/20/90	(venue & Fuji Xerox)";#include <sys/types.h>#include "lispemul.h"#include "lispglobal.h"#include "lispmap.h"#include "lisptypes.h"#include "address68k.h"#include "address.h"#include "stream.h"#include "displaydata.h"#include "pilotbbt.h"#include "debug.h"#include "arith.h"#include "bitblt.h"typedef struct {		LispPTR		FONTDEVICE;		LispPTR		SFObsolete1;		LispPTR		FONTFAMILY;		LispPTR		FONTSIZE;		LispPTR		FONTFACE;		LispPTR		SFObsolete2;		LispPTR		SFObsolete3;		LispPTR		SFObsolete4;		DLword		SFObsolete5;		DLword		SFObsolete6;		DLword		SFAscent;		DLword		SFDescent;		DLword		SFHeight;		DLword		ROTATION;		short		FBBOX;		short		FBBOY;		short		FBBDX;		short		FBBDY;		unsigned	SFFACECODE		: 8;		unsigned	SFLKerns		:24;		LispPTR		SFRWidths;		LispPTR		FONTDEVICESPEC;		LispPTR		OTHERDEVICEFONTPROPS;		LispPTR		FONTSCALE;		DLword		FONTAVGCHARWIDTH;		DLword		dum;		LispPTR		FONTIMAGEWIDTHS;		LispPTR		FONTCHARSETVECTOR;		LispPTR		FONTEXTRAFIELD2;} FONTDESC;typedef struct {		LispPTR	WIDTHS;		LispPTR	OFFSETS;		LispPTR	IMAGEWIDTHS;		LispPTR	CHARSETBITMAP;		LispPTR	YWIDTHS;		DLword	CHARSETASCENT;		DLword	CHARSETDESCENT;		LispPTR	LEFTKERN } CHARSETINFO;typedef struct {		LispPTR SCONOFF;		LispPTR SCDESTINATION;		LispPTR SCWIDTH;		LispPTR SCHEIGHT;		LispPTR SCTOPW;		LispPTR SCTOPWDS;		LispPTR SCTITLEDS;		LispPTR SCFDEV;		LispPTR SCDS;		LispPTR SCDATA; } SCREEN;#define IMIN(x,y)  (((x) > (y)) ? (y) : (x))#define IMAX(x,y)  (((x) > (y)) ? (x) : (y))LispPTR SLOWBLTCHAR_index;#define SLOWBLTCHAR_argnum 2#define PUNT_TO_SLOWBLTCHAR {\	if(SLOWBLTCHAR_index==0xffffffff)\  	SLOWBLTCHAR_index= get_package_atom("\\PUNT.SLOWBLTCHAR", \	17, "INTERLISP", 9, NIL);\	if(SLOWBLTCHAR_index==0xffffffff)\	  {error("SLOWBLTCHAR install fail"); return;} \	CurrentStackPTR +=(SLOWBLTCHAR_argnum-1)*DLWORDSPER_CELL; \	ccfuncall(SLOWBLTCHAR_index,SLOWBLTCHAR_argnum,3);return;}/***********************************************************//*		C_slowbltchar		by Takeshi		June 6, 1989*//***********************************************************//* I'll merge this macro with  FGetNum later */#define SFGetNum(ptr, place) { \	     if(((ptr) & 0xff0000)== S_POSITIVE) {(place) = ((ptr) & 0xffff);}\	else if(((ptr) & 0xff0000)== S_NEGATIVE) {(place) = (int)((ptr)| 0xffff0000);}\	else {PUNT_TO_SLOWBLTCHAR;}}/* place:		native pointer     val:		native value(should be smallp)   puntcase:	punt descriptions */#define FReplaceSmallp(place,val,puntcase) 	{\	if ((0 <= (val)) && ((val) <= MAX_SMALL)) \		(LispPTR)(place) = (LispPTR)(S_POSITIVE | (val));\ 	else if(MIN_SMALL <= val)\		(LispPTR)(place) = (LispPTR)(S_NEGATIVE | (0xffff & (val)));\	else {puntcase;}}/* charcode should be pos. smallp */#define charcode		(args[0] & 0xffff)#define displaystream	args[1]#define Char8Code(x)		((u_char)((x) & 0xff))#define CharSet(x)		((x) >> 8)#define PSEUDO_BLACK 255#define PSEUDO_WHITE 0LispPTR *SCREENBITMAPS68k; /* Initialized in initsysout.c */LispPTR	*COLORSCREEN68k;   /* Initialized in initsysout.c */LispPTR COLORSCREEN_index; /* if it's 0xffffffff, not yet initialized */C_slowbltchar(args)register LispPTR *args;/* args[0]		charcode 	*//* args[1]		displaystream */{  Stream		*n_dstream;  DISPLAYDATA	*n_dd;  FONTDESC		*n_fontd;  CHARSETINFO	*n_csinfo;  BITMAP		*n_destbitmap;  int			dest_bpp;  LispPTR csinfo;  int curx,cury,newx,rmargin,lmargin,xoff,yoff; DLword left,right;	  u_char forecolor,backcolor;	  register int displayflg;  extern LispPTR *TOPWDS68k; n_dstream=(Stream*)Addr68k_from_LADDR(displaystream); n_dd=(DISPLAYDATA*)Addr68k_from_LADDR(n_dstream->IMAGEDATA); n_fontd=(FONTDESC*)Addr68k_from_LADDR(n_dd->ddfont); n_destbitmap=(BITMAP*)Addr68k_from_LADDR(n_dd->dddestination);/* dest_bpp =n_destbitmap->BITMAPBITSPERPIXEL;*/ if(GetTypeNumber( n_dd->dddestination ) != TYPE_BITMAP)	{PUNT_TO_SLOWBLTCHAR} if((n_fontd->ROTATION & 0xffff) == 0) {	if((csinfo=		*(((LispPTR*)Addr68k_from_LADDR(n_fontd->FONTCHARSETVECTOR)) 		+ CharSet(charcode) )) == NIL ){	 PUNT_TO_SLOWBLTCHAR; /* CSINFO is not cached */	}	n_csinfo =(CHARSETINFO*)Addr68k_from_LADDR(csinfo);		SFGetNum(n_dd->ddxposition, curx);	SFGetNum(n_dd->ddyposition, cury);	SFGetNum(n_dd->ddrightmargin, rmargin);	SFGetNum(n_dd->ddleftmargin, lmargin);	SFGetNum(n_dd->ddxoffset, xoff);	SFGetNum(n_dd->ddyoffset, yoff); 	newx = curx + *(DLword*)Addr68k_from_LADDR	(n_dd->ddwidthscache + Char8Code(charcode) ); 	if(newx > rmargin) 	  PUNT_TO_SLOWBLTCHAR; /* do \DSPPRINTCR/LF *//* If we care about TOPW then it's too slow to create Menu etc.	But,if we don't,it causes some error  **/{ int deb;	if(COLORSCREEN_index==0xffffffff) { /* Make sure COLOR lives? */		COLORSCREEN_index = MAKEATOM("\\COLORSCREEN");	 COLORSCREEN68k = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +	 (COLORSCREEN_index << 1));	}	if(((n_dd->dddestination) != (((SCREEN*)COLORSCREEN68k)->SCTOPW)) &&		(displaystream != *TOPWDS68k) && 		((deb=fmemb(n_dd->dddestination,*SCREENBITMAPS68k)) != NIL))	 {PUNT_TO_SLOWBLTCHAR;}  }	FReplaceSmallp(n_dd->ddxposition,newx,PUNT_TO_SLOWBLTCHAR);	/* make curx abs coord */ 	curx += xoff;	left =  IMAX(n_dd->ddclippingleft,curx);	right = IMIN(n_dd->ddclippingright, newx + xoff);	{ register PILOTBBT *pbt; 	  register BITMAP   *n_destBM,*n_srcBM;	  register int destYOffset;	  register int width,sourceBitOffset;	  /*u_char forecolor,backcolor;	  register int displayflg; */	  extern int ScreenLocked;	  extern int DisplayHeight;	  pbt = (PILOTBBT*)Addr68k_from_LADDR(n_dd->ddpilotbbt);	  if((left <right) && (pbt->pbtheight != 0)) {		width = right - left;		sourceBitOffset = 		  *((DLword*)Addr68k_from_LADDR(n_dd->ddoffsetscache +Char8Code(charcode)))		  + left - curx;		n_destBM=(BITMAP*)Addr68k_from_LADDR(n_dd->dddestination);		destYOffset = n_destBM->bmheight -( cury+yoff 			+n_csinfo->CHARSETASCENT/*+ n_csinfo->CHARSETDESCENT+1*/);		if(n_dd->ddcolor ==NIL_PTR) {		   forecolor = PSEUDO_BLACK;		   backcolor = PSEUDO_WHITE;		}		else {		   backcolor = 0xff & cdr(n_dd->ddcolor);		   forecolor = 0xff & car(n_dd->ddcolor);		}		   n_srcBM=(BITMAP*)Addr68k_from_LADDR(n_csinfo->CHARSETBITMAP);		   ScreenLocked=T;		    /*  xposition is shifted 3 Kludge for cursorin			 in color(8bpp) ** x's meaning  is different from 			bitbltsub's. For now,I use this func with Kludge */		   displayflg=n_new_cursorin(			Addr68k_from_LADDR(n_destBM->bmbase),left<<3,				/* Kludge:YCoordination upside down*/				DisplayHeight-(cury+yoff),width,n_srcBM->bmheight); 		   if(displayflg) HideCursor;	/*************		   ColorizeFont8(n_srcBM,			sourceBitOffset,width,			n_destBM,			destYOffset,left,backcolor,forecolor,			n_dd->ddsourcetype,n_dd->ddoperation);	*************/			pbt->pbtsourcebit = sourceBitOffset;			pbt->pbtdestbit = left;			pbt->pbtwidth = width;		newColorizeFont8(pbt,			backcolor,forecolor,			n_dd->ddsourcetype,n_dd->ddoperation);		   if(displayflg) ShowCursor;		   ScreenLocked=NIL;			  } /* otherwise return */	} } else { /* ROTATE case ,do-PUNT */	PUNT_TO_SLOWBLTCHAR; } } /* end C_slowbltchar */#define MAXFONTHEIGHT 48#define MAXFONTWIDTH  48#define BITSPERNIBBLE  4#define BITSPERDLWORD 16#define BPP		  8u_int ColorizedFont8CACHE[MAXFONTHEIGHT/BITSPERNIBBLE *		MAXFONTWIDTH/BITSPERNIBBLE];/****************************************************//*	ColorizeFont8	Expand 1bbp font bitmap to 8bpp colorized 	font bitmap by referencing col1,col0	Assume dbm is BITMAP and BPP is 8	by Takeshi(June 6, 1989)	This func will be inlined???*//****************************************************/ColorizeFont8(sBM,sXOffset,width,dBM,dYOffset,dXOffset,col0,col1,sourcetype,operation)register BITMAP *sBM;register DLword sXOffset,width;register BITMAP *dBM;DLword dYOffset,dXOffset;u_char col0,col1;LispPTR sourcetype;LispPTR operation;{  register DLword *nbase;  register u_char *dbase;  register int i; nbase=(DLword*)Addr68k_from_LADDR(sBM->bmbase); (DLword*)dbase= (DLword*)Addr68k_from_LADDR(dBM->bmbase)		+ (dBM->bmrasterwidth * dYOffset); for(i=0, dbase += dXOffset;/* 8bpp */     i < sBM->bmheight;     i++,nbase += sBM->bmrasterwidth , ((DLword*)dbase) += dBM->bmrasterwidth) {	lineBlt8(nbase,sXOffset,dbase,width,col0,col1,sourcetype,operation); } /* for end */} /* ColorizeFont8 end */newColorizeFont8(pbt,backcolor,forecolor,srctype,ope)  PILOTBBT *pbt;  u_char backcolor,forecolor;  LispPTR srctype,ope;{    register DLword *nbase;    register u_char *dbase;    register int i;    nbase=(DLword*)Addr68k_from_LADDR		((pbt->pbtsourcehi << 16 ) | (pbt->pbtsourcelo)) ;    (DLword*)dbase= (DLword*)Addr68k_from_LADDR(		(pbt->pbtdesthi << 16 ) | (pbt->pbtdestlo)) ;    dbase += pbt->pbtdestbit; for(i=0; i < pbt->pbtheight;     i++,nbase += pbt->pbtsourcebpl/16	 , dbase += pbt->pbtdestbpl/8) {	lineBlt8(nbase,pbt->pbtsourcebit,dbase,pbt->pbtwidth,backcolor,forecolor,srctype,ope); } /* for end */}