/* @(#) unixfork.c Version 1.4 (9/18/90). copyright venue & Fuji Xerox  */static char *id = "@(#) unixfork.c	1.4 9/18/90	(venue & Fuji Xerox)";/*Unix Interface Communications Subprocess Code*//************************************************************************//*									*//*	Copyright 1989, 1990 Venue.  All Rights Reserved		*//*									*//************************************************************************/#ifndef OS4#include <sys/ioctl.h>#else#include <sys/termios.h>#endif OS4#include <stdio.h>#include <sys/file.h>#include <signal.h>#include <sys/wait.h>#include <errno.h>#include "dbprint.h"#include <sys/types.h>#include <sys/socket.h>#include <sys/un.h>/* The following globals are used to communicate between Unix   subprocesses and LISP */long StartTime;			/* Time, for creating pipe filenames */char shcom[150];		/* Here because I'm suspicious of */				/* large allocations on the stack *//* fork_Unix is the secondary process spawned right after LISP is   started, to avoid having TWO 8 mbyte images sitting around. It listens   to the pipe LispToUnix waiting for requests, and responds on UnixToLisp.   The data passed through this pipe is in 4 byte packets, of the form:   Byte 0:   Command character, one of:                   S: Fork PTY (shell) process. This is used for CHAT windows.		   P: New version of S, takes 2 string args.		   F: Fork piped shell, takes 1 string arg.		   K: Kill process		   E: Exit (kill all subprocesses)		   C: Close stdin to subprocess		   W: call WAIT3 & get one process's close info.   Byte 1:   Process number (0 to NPROCS - 1)             Not used for S, F, and E commands	     [For S&P, pty letter]	     [For F, process # for pipe naming]   Byte 2:   Value, used as follows:             Only used for W command, contains byte to write	     [For S&P, pty number]   Byte 3:   Slot number.In the case of F & P commands, additional data follows the 4 byte packet.This consists of one byte representing the length of the shell commandstring, and the string itself.fork_Unix will return another 4 byte packet. The bytes are the same as thoseof the packet received except:   F:        Byte 2 is job number             Byte 3 is 1 if successful, 0 if not   S:     €   Byte 2 is job number             Byte 3 is 1 if successful, 0 if not   R:        Byte 2 is value of byte read from stdin, if any             Byte 3 is 1 if successful, 2 if EOF, 0 if nothing waiting   W:        Bytes 0 & 1 are the Process ID of the terminated process	     Bytes 2 & 3 are the high & low bytes of the exit status.   K:        Bytes 1 and 2 are the high and low bytes of the exit status             of the process.	     Byte 3 is 1 if an exit status was available.   E:        Always the same   C:        Always the same*/fork_Unix(){  int LispToUnix[2],		/* Incoming pipe from LISP */      UnixToLisp[2],		/* Outgoing pipe to LISP */	 UnixPID,      LispPipeIn, LispPipeOut, res, pid, slot;  char IOBuf[4], tmp[2];  /* Pipes between LISP subr and process */  if (pipe(LispToUnix) == -1) {    perror("pipe");    exit(-1);  }  if (pipe(UnixToLisp) == -1) {    perror("pipe");    exit(-1);  }  StartTime = time(0);		/* Save the time, to create filenames with */  StartTime &= 0xFFFFFF;	/* as a positive number! *//* interrupts need to be blocked here so subprocess won't see them */  sigblock(sigmask(SIGVTALRM) | sigmask(SIGIO)	     | sigmask(SIGALRM)  | sigmask(SIGXFSZ) 		 | sigmask(SIGFPE)		);  if ((UnixPID = fork()) == -1) {  /* Fork off small version of the emulator */    perror("fork");    exit(-1);  }  if (UnixPID != 0) {    /* JRB - fork_Unix is now called in ldeboot; leave UnixPipe{In,Out} open       and put their numbers in the environment so parent can find them */    /* JDS - NB that sprintf doesn't always return a string! */    char* tempstring;    tempstring = (char *) malloc(30);    sprintf(tempstring, "LDEPIPEIN=%d", UnixToLisp[0]);    putenv(tempstring);    tempstring = malloc(30);    sprintf(tempstring, "LDEPIPEOUT=%d", LispToUnix[1]);    putenv(tempstring);    tempstring = malloc(30);    sprintf(tempstring, "LDESTARTTIME=%d", StartTime);    putenv(tempstring);    tempstring = malloc(30);    sprintf(tempstring, "LDEUNIXPID=%d", UnixPID);    putenv(tempstring);    close(LispToUnix[0]);    close(UnixToLisp[1]);    return(1);  }  LispPipeIn = LispToUnix[0];  LispPipeOut = UnixToLisp[1];  close(LispToUnix[1]);  close(UnixToLisp[0]);  res = fcntl(LispPipeIn, F_GETFL, 0);  res &= (65535-FNDELAY);  res = fcntl(LispPipeIn, F_SETFL, res);  while (1) {    int len;    len = 0;    while (len != 4)    {      if ((len = read(LispPipeIn, IOBuf, 4)) <0)	{	/* Get packet */	  perror("Packet read by slave");	  /*      kill_comm_processes(); */	  exit(0);	}      if (len != 4)	{	  DBPRINT(("Input packet wrong length:  %d.\n", len));	  exit(0);	}    }    slot = IOBuf[3];    IOBuf[3] = 1;    switch(IOBuf[0]) {    case 'S': case 'P':			/* Fork PTY shell */      if (slot >= 0)	{ /* Found a free slot */	  char termtype[32];	  if (IOBuf[0] == 'P')	    {			/* The new style, which takes term type & command to csh */	      if(read(LispPipeIn, tmp, 1) < 0) perror("Slave reading cmd length");	      if(read(LispPipeIn, termtype, *tmp) < 0) perror("Slave reading termtype");	      if(read(LispPipeIn, tmp, 1) < 0) perror("Slave reading cmd length");	      if(read(LispPipeIn, shcom, *tmp) < 0) perror("Slave reading shcom");	    }	    else		/* old style, no args */	      { termtype[0] = 0; shcom[0] = 0; }	  /* Alloc a PTY and fork  */	  pid = ForkUnixShell(slot, IOBuf[1], IOBuf[2], termtype, shcom);	  if (pid == -1)	    {	      printf("Impossible failure from ForkUnixShell??\n");	      fflush(stdout);	      IOBuf[3] = 0;	    }	  else	    {	      /* ForkUnixShell sets the pid and standard in/out variables */	      IOBuf[1] = (pid >> 8)& 0xFF;	      IOBuf[2] = pid & 0xFF;	    }        }      else 	{	  printf("Can't get process slot for PTY shell.\n");	  fflush(stdout);	  IOBuf[3] = 0;	}       break;    case 'F':			/* Fork pipe command */      if (slot >= 0) 		{	/* Read in the length of the shell command, and then the command */	if(read(LispPipeIn, tmp, 1)<0) perror("Slave reading cmd length");	if(read(LispPipeIn, shcom, *tmp)<0) perror("Slave reading cmd");	DBPRINT(("Cmd len = %d.\n", *tmp));	DBPRINT(("Rev'd cmd string: %s\n", shcom));	pid = fork(); /* Fork */	if (pid == 0)	  {	    int i;	    int status, sock;	    struct sockaddr_un addr;	    char PipeName[40];	    sock = socket(AF_UNIX, SOCK_STREAM, 0);	    if (sock < 0) {perror("slave socket"); exit(0);}	    sprintf(PipeName, "/tmp/LispPipe%d-%d", StartTime, slot);	    addr.sun_family = AF_UNIX;	    strcpy(addr.sun_path, PipeName);	    status = connect(sock, (struct sockaddr *)&addr,			     strlen(PipeName)+sizeof(addr.sun_family));	    if(status<0)	      {		perror("slave connect");		printf("Name = %s.\n", PipeName); fflush(stdout);		exit(0);	      }	    else	      {		DBPRINT(("Slave connected on %s.\n", PipeName));	      }	    /* Copy the pipes onto stdin, stdout, and stderr */	    dup2(sock,0);	    dup2(sock,1);	    dup2(sock,2); 	    /* Make sure everything else is closed */	    for (i = 3; i < getdtablesize(); i++)	      close(i);	    /* Run the shell command and get the result */	    status = system(shcom);	    unlink(PipeName);	    _exit((status & ~0xff) ? (status >> 8) : status);	  }	/* Check for error doing the fork */	if (pid == -1)	  {	    perror("unixcomm: fork");	    IOBuf[3] = 0;	  }	else	  {	    IOBuf[1] = (pid >> 8)& 0xFF;	    IOBuf[2] = pid & 0xFF;	  }      } else IOBuf[3] = 0; /* Couldn't get a process slot */      break;    case 'W':			/* Wait for a process to die. */      {	int pid;	union wait status;	int slot;	status.w_status = 0;	IOBuf[0] = 0; IOBuf[1] = 0;	DBPRINT(("About to wait for processes.\n"));	if (((pid = wait3(&status, WNOHANG, 0)) != 0))	  {	    /* Ignore processes which are suspended but haven't exited	       (this shouldn't happen) */	    if (status.w_stopval == WSTOPPED) break;	    IOBuf[3] = status.w_T.w_Retcode;	    IOBuf[2] = status.w_T.w_Termsig;	    IOBuf[1] = pid & 0xFF;	    IOBuf[0] = (pid>>8) & 0xFF;          }	DBPRINT(("wait3 returned pid = %d.\n", pid));      }      break;    case 'C':			/* Close stdin to subprocess */      break;    case 'K':			/* Kill subprocess */      break;    } /* End of switch */    /* Return the status/data packet */    write(LispPipeOut, IOBuf, 4);  }}/************************************************************************//*									*//*			F o r k U n i x S h e l l			*//*									*//*	Fork a PTY connection to a C-shell process.			*//*	Returns PID of process, or -1 if something failed		*//*									*//*									*//************************************************************************//* Creates a PTY connection to a csh */ForkUnixShell(slot, ltr, numb, termtype, shellarg)  int slot;  char ltr, numb;  char *termtype, *shellarg;  {    char PtySlave[20], buf[1];    int res, PID, MasterFD, SlaveFD;#ifdef OS4    struct termios tio;#else    struct sgttyb tio;#endif OS4    PID = fork();    if (PID == 0)      {	char envstring[64];	char *argvec[4];		/* Divorce ourselves from /dev/tty */	res = open("/dev/tty", O_RDWR);	if (res >= 0)	  {#ifndef HP	    (void) ioctl(res, TIOCNOTTY, (char *)0);#endif	    (void) close(res);	  }	else	  {	    perror("Slave TTY");	    exit(0);	  }	/* Open the slave side */	sprintf(PtySlave, "/dev/tty%c%c", ltr, numb);	SlaveFD = open(PtySlave, O_RDWR);	if (SlaveFD == -1)	  {	    perror("Slave Open");	    exit(0);	  }#ifndef OS4/* This is the old way we set up terminal (OS 3), using an   obsolete ioctl and wrong flags for a display. */	ioctl(SlaveFD, TIOCGETP, (char *)&tio);	tio.sg_flags |= CRMOD;	tio.sg_flags |= ECHO;	ioctl(SlaveFD, TIOCSETP, (char *)&tio);#else	/* Set up as basic display terminal: canonical erase,	   kill processing, echo, backspace to erase, echo ctrl	   chars as ^x, kill line by backspacing */	ioctl(SlaveFD, TCGETS, (char *)&tio);	tio.c_lflag |= ICANON | ECHO | ECHOE | ECHOCTL | ECHOKE;	ioctl(SlaveFD, TCSETS, (char *)&tio);#endif OS4	(void) dup2(SlaveFD, 0);	(void) dup2(SlaveFD, 1);	(void) dup2(SlaveFD, 2);	(void) close(SlaveFD);	/* set the LDESHELL variable so the underlying .cshrc can see it and	   configure the shell appropriately, though this may not be so important any more */	putenv("LDESHELL=YES");	if ((termtype[0] != 0) && (strlen(termtype) < 59))	  { 		/* set the TERM environment var */	    sprintf(envstring, "TERM=%s", termtype);	    putenv(envstring);	  }	/* Start up csh */	argvec[0] = "csh";	if (shellarg[0] != 0)	  {			/* setup to run command */	    argvec[1] = "-c";	/* read commands from next arg */	    argvec[2] = shellarg;	    argvec[3] = (char *) 0;	  }	  else argvec[1] = (char *) 0;	execv("/bin/csh", argvec);	/* Should never get here */	perror("execv");	exit(0);      }    /* Set the process group so all the kids get the bullet too    if (setpgrp(PID, PID) != 0)      perror("setpgrp"); */    return(PID);  }