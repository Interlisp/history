/* @(#) vmemsave.c Version 2.33 (9/13/90). copyright envos & Fuji Xerox  */static char *id = "@(#) vmemsave.c	2.33 9/13/90         (envos & Fuji Xerox)";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************//**	vmemsave.c***/#include <stdio.h>#include <sys/file.h>#include <sys/types.h>#include <sys/stat.h>#include <sys/param.h>#include <sys/dir.h>#ifndef AIX#include <sys/vfs.h>#endif AIX#include <pwd.h>#include <errno.h>#include <signal.h>#include <setjmp.h>#ifndef NOPIXRECT#include <sunwindow/win_cursor.h>#endif NOPIXRECT#include "hdw_config.h"#include "lispemul.h"#include "lispmap.h"#include "lispglobal.h"#include "ifpage.h"#include "vmemsave.h"#include "timeout.h"#include "address68k.h"#include "lisptypes.h"#include "localfile.h"#include "dbprint.h"#define	COMPLETESYSOUT	NIL#define	BADFILENAME	S_POSITIVE | 1	#define	NOFILESPACE	S_POSITIVE | 2	#define FILECANNOTOPEN	S_POSITIVE | 3#define FILECANNOTSEEK	S_POSITIVE | 4#define FILECANNOTWRITE	S_POSITIVE | 5#define FILETIMEOUT	S_POSITIVE | 6struct stat     DEBUG_stat;extern int LispWindowFd;extern struct pixrect *CursorBitMap, *InvisibleCursorBitMap;extern struct cursor CurrentCursor, InvisibleCursor;extern IFPAGE *InterfacePage;char	*rindex();#undef roundup#define roundup( a, b) ((((unsigned)(a)+(b)-1)/(b))*(b))extern int	*Lisp_errno;extern int	Dummy_errno;		/* If errno cell is not provided by Lisp, dummy_errno is used. */extern int      please_fork;/************************************************************************//*									*//*			l i s p s t r i n g p				*//*									*//*	Predicate:  Is the argument (which must be a Lisp 1-d array)	*//*		    a lisp string?  i.e., are its elements char's?	*//*									*//************************************************************************/lispstringP(Lisp)  LispPTR	Lisp;  {    switch( ((OneDArray *)(Addr68k_from_LADDR(Lisp)))->typenumber )      {	case THIN_CHAR_TYPENUMBER:	case FAT_CHAR_TYPENUMBER:   return(1);	default: return(0);      }  }/************************************************************************//*									*//*			v m e m _ s a v e 0				*//*									*//*	Implements the VMEMSAVE subr.  Write out the current lisp	*//*	lisp image to the specified file.  If the sysout file-name	*//*	is explicitly specified, the directory on which the file	*//*	resides is exactly (?) an existing directory.  This is		*//*	guaranteed by the Lisp code, \MAIKO.CHECKFREEPAGE in LLFAULT.	*//*									*//*	If the file argument is nill, the default sysout-file name,	*//*	"~/lisp.virtualmem", is used, subject to override by the	*//*	LDEDESTSYSOUT UNIX-environment variable.			*//*									*//*									*//*									*//*									*//* Argument:	LispPTR	*args	args[0]					*//*			 The file name in Lisp format specifying a	*//*			 file to which the current Lisp image should	*//*			 be flushed or Lisp NIL.			*//*									*//* Value:	If succeed, returns NIL, otherwise one of the		*//*		following Lisp integers, indicating the reason.		*//*									*//*			1	BADFILENAME				*//*			2	NOFILESPACE				*//*			3	FILECANNOTOPEN				*//*			4	FILECANNOTSEEK				*//*			5	FILECANNOTWRITE				*//*			6	FILETIMEOUT				*//*									*//* Side Effect:	None.							*//*									*//************************************************************************/vmem_save0(args)  register LispPTR	*args;  {    register char	*def;    char	pathname[MAXPATHLEN], sysout[MAXPATHLEN], host[MAXNAMLEN];    struct passwd	*pwd;    char		*getenv();    char		*index();        Lisp_errno = &Dummy_errno;	    if((args[0] != NIL) && lispstringP(args[0]))       {	/* Check of lispstringP is safer for LispStringToCString */	LispStringToCString(args[0], pathname, MAXPATHLEN);	separate_host(pathname, host);	if (!unixpathname(pathname, sysout, 0, 0)) return(BADFILENAME);	return(vmem_save(sysout));      }     else       {	if((def = getenv("LDEDESTSYSOUT")) == 0)	  {	    pwd = getpwuid(getuid()); /* NEED TIMEOUT */	    if (pwd == (struct passwd *)NULL) return(FILETIMEOUT);	    strcpy(sysout, pwd->pw_dir);	    strcat(sysout, "/lisp.virtualmem");	  }	else	  {	    strcpy(sysout, def);	  }	return(vmem_save(sysout));      }  }/*		 * Name:	vmem_save * * Argument:	char	*sysout_file_name *			 The file name in UNIX format specifying a file to which *			 the current Lisp image should be flushed. * * Value:	If succeed, returns Lisp NIL, otherwise one of the following Lisp integer *		indicating the reason of failure. * *			1	BADFILENAME *			2	NOFILESPACE *			3	FILECANNOTOPEN *			4	FILECANNOTSEEK *			5	FILECANNOTWRITE *			6	FILETIMEOUT * * Side Effect:	None. * * Description: * * Flush out the current Lisp image to the specified file. */vmem_save(sysout_file_name)  register char	*sysout_file_name;  {    int		sysout;	/* SysoutFile descriptor */    register DLword	*fptovp;	/* FPTOVP */    int	vmemsize;	/* VMEMSIZE */    register int	i;    char	tempname[MAXPATHLEN]; /* * *   struct statfs	fsbuf; * * */    char	*cp;    register int	rval;    DLword *bmptr;    extern int ScreenLocked;    extern DLword *EmCursorX68K;    extern DLword *EmCursorY68K;    extern DLword NullCursor[];	    extern DLword *EmCursorBitMap68K;    InterfacePage->minbversion = 15000; /* Mark this sysout for new emulator */			    /* remove cursor image from screen */#ifdef SUNDISPLAY#ifdef OLD_CURSOR    win_setcursor( LispWindowFd, &InvisibleCursor);#else    ScreenLocked=T;    taking_mouse_down();/*	bmptr = EmCursorBitMap68K;    EmCursorBitMap68K= NullCursor;*/#endif OLD_CURSOR#endif SUNDISPLAY    /* set FPTOVP */    fptovp = FPtoVP + 1;    /* set VMEMSIZE */    vmemsize = InterfacePage->nactivepages;/*	[HH:6-Jan-89]	Sequnce of save image	(1) Sysout image is saved to a temporary file, tempname.	(2) if a specified file, sysout_file_name, is exist, the file is removed.	(3) the temporary file is renamed to the specified file.*/    SETJMP(FILETIMEOUT);    sprintf(tempname, "%s-temp", sysout_file_name);	/* Confirm protection of specified file by open/close */    TIMEOUT(sysout=open(sysout_file_name, O_WRONLY, 0666));    if (sysout == -1)      {	/* No file error skip return. */	if(errno != 2) return(FILECANNOTOPEN); /* No such file error.*/      }    else TIMEOUT( rval = close(sysout) );    /* open temp file */    TIMEOUT(sysout=open(tempname, O_WRONLY | O_CREAT | O_TRUNC, 0666));    if (sysout == -1)      {	err_mess("open", errno);	return(FILECANNOTOPEN);      }    InterfacePage->machinetype = KATANA;/** CHANGES FOR NEW STORAGE **/#ifdef NEW_STORAGE    /* Restore storagefull state */    if(((*STORAGEFULLSTATE_word) & 0xffff)== SFS_NOTSWITCHABLE){	/* This sysout uses only 8 Mbyte lisp space.	   It may be able to use this SYSOUT which has more than	   8 Mbyte lisp space.	   To enable to expand lisp space, \\STORAGEFULLSTATE	   should be NIL.	*/	*STORAGEFULLSTATE_word = NIL;	InterfacePage->storagefullstate=NIL;    }    else {	/*  Otherwise, just restore storagefullstate in IFPAGE */    	InterfacePage->storagefullstate= 		(*STORAGEFULLSTATE_word) & 0xffff ;    }/** CHANGES FOR NEW STORAGE END**/#endif NEW_STORAGE    /*printf("start vmemsave\n"); */    /* store vmem to sysoutfile */    for (i = 0; i < vmemsize; i++)      {	if (GETBASEWORD(fptovp,i) != 0177777)	  {	    register char *base_addr;	    TIMEOUT( rval=lseek(sysout, i * BYTESPER_PAGE, 0) );	    if (rval == -1) 	      {		err_mess("lseek", errno);		return(FILECANNOTSEEK);	      }	    base_addr = (char *)(Lisp_world + (GETBASEWORD(fptovp,i) * DLWORDSPER_PAGE));#ifdef BYTESWAP	    word_swap_page(base_addr,			    BYTESPER_PAGE/4);#endif BYTESWAP	    TIMEOUT( rval=write(sysout,		     base_addr,		     BYTESPER_PAGE) );#ifdef BYTESWAP	    word_swap_page(base_addr,			    BYTESPER_PAGE/4);#endif BYTESWAP	    if (rval == -1)	      {		err_mess("write", errno);		return(FILECANNOTWRITE);	      }	  }      }    /* seek to IFPAGE */    TIMEOUT(rval=lseek(sysout, (long)FP_IFPAGE, 0));    if (rval == -1)      {	err_mess("lseek", errno);	return(FILECANNOTSEEK);      }#ifdef BYTESWAP	    word_swap_page((char *) InterfacePage,			    BYTESPER_PAGE/4);#endif BYTESWAP    TIMEOUT(rval=write(sysout, (char *) InterfacePage, BYTESPER_PAGE) );#ifdef BYTESWAP	    word_swap_page((char *) InterfacePage,			    BYTESPER_PAGE/4);#endif BYTESWAP    if (rval == -1)      {		err_mess("write", errno);		return(FILECANNOTWRITE);	}        TIMEOUT( rval = close(sysout) );    if(rval == -1)      {	return(FILECANNOTWRITE);      }    TIMEOUT(rval = unlink(sysout_file_name));    if (rval == -1)       {	/* No file error skip return. */	if(errno != 2)	/* No such file error.*/ return(FILECANNOTOPEN);      }    TIMEOUT( rval=rename(tempname, sysout_file_name) );    if( rval== -1)      {	fprintf(stderr,"sysout is saved to temp file, %s.", tempname);	return(FILECANNOTWRITE);      }    /* restore cursor image to screen */#ifdef SUNDISPLAY#ifdef OLD_CURSOR    win_setcursor( LispWindowFd, &CurrentCursor);#else    ScreenLocked=T;    /*EmCursorBitMap68K = bmptr ;*/    taking_mouse_up(*EmCursorX68K,*EmCursorY68K);    ScreenLocked=NIL;#endif OLD_CURSOR#endif SUNDISPLAY    /*printf("vmem is saved completely.\n");*/    return(COMPLETESYSOUT);  }/************************************************************************//*									*//*			l i s p _ f i n i s h				*//*									*//*	Kill all forked sub-processes before exiting.			*//*									*//************************************************************************/extern int UnixPID;/* Make sure that we kill off any Unix subprocesses before we go away */lisp_finish()  {    char d[4];    DBPRINT(("finish lisp_finish\n"));    if( please_fork )      {		/* if lde runs with -NF(No fork), */		/* following 5 lines don't work well. */	d[0] = 'E';	d[3] = 1;	/* These only happen if the fork really succeeded:	/* if (UnixPipeOut >= 0) write(UnixPipeOut, d, 4); */	/* if (UnixPipeIn >= 0 read(UnixPipeIn, d, 4);*/	/* Make sure it's finished */	/* if (UnixPID >= 0) kill(UnixPID, SIGKILL);*/	/* Then kill fork_Unix itself */      }    device_before_exit();    exit(1);	  }