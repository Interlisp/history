/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";/* File: xc.c - created by Fuji Xerox. Last edit: *//* masinter:parc:Xerox  5-Jan-88 16:50:48 *//* Copyright (C) 1988 by Xerox Corporation. All rights reserved. */#include <sys/types.h>#include <sys/time.h>#include <stdio.h>#include "lispemul.h"#include "emulglobal.h"#include "address.h"#include "address68k.h"#include "stack.h"#include "lispglobal.h"#include "lisptypes.h"#include "lispmap.h"#include "cell.h"#include "initatoms.h"#include "gc.h"#include "arith.h"#include "opcodefunc.h"typedef struct conspage ConsPage;#define CGETNUMBER(sour,dest)	\{	\		switch(0xFFFF0000 & sour){\		case S_POSITIVE:		\			dest = 0xFFFF & sour;	\			break;			\		case S_NEGATIVE:		\			dest = 0xFFFF0000 | sour;	\			break;			\		default:			\			if(GetTypeNumber( sour ) != TYPE_FIXP){	\				UFN(Get_BYTE(PCMAC));	\			}			\			dest = *((int *)Addr68k_from_LADDR(sour));	\		}	\}#undef PopCStack#undef PopStackTo#undef PushCStack#undef PushStack#undef StackOverflowCheck#undef StackCheck#undef SmashStack#define PCMAC 		pccache#define CSTKPTR  	cspcache#define NEXTOPCODE 	goto nextopcode#ifdef NOTOSCACHE/* No TOS Cache at All */#define CPushStack(x)	{CSTKPTR += 2; *((LispPTR *)CSTKPTR) = x;}#define CPopCStack	{CSTKPTR -= 2;}#define CPushCStack	{}#define TOPOFSTACK	*((LispPTR *)CSTKPTR)#define PREVTOS		*((LispPTR *)(CSTKPTR-2))#define CPush(x)	{CPushStack(x);}#define CPopStore(x)	{*((LispPTR *)--CSTKPTR) = x;}#define CCopyTos	{CPushStack(PREVTOS);}#define StackPtrSave	{CurrentStackPTR = CSTKPTR-2;}#define StackPtrRestore	{CSTKPTR = CurrentStackPTR+2;}#endif#ifdef TOS1/** cached TOPOFSTACK, with CSTKPTR pointing to where cache should be   **/ #define CPushStack(x)	{*((LispPTR *)CSTKPTR++)=x;}#define CPopCStack	{TOPOFSTACK = *((LispPTR *)--CSTKPTR);}#define CPushCStack	{*((LispPTR *)CSTKPTR++) = TOPOFSTACK;}#define TOPOFSTACK 	tscache#define PREVTOS		*((LispPTR *)(CSTKPTR-2))#define POPPREVTOS	*((LispPTR *)--CSTKPTR)#define TOS		*((LispPTR *)(CSTKPTR))#define CPush(x)	{CPushCStack; TOPOFSTACK = x;}#define CPopStore(x)	{CSTKPTR -= 2; TOPOFSTACK = x;}#define CCopyTos	{CPushCStack;}#define StackPtrSave	{CurrentStackPTR = CSTKPTR-2;}#define StackPtrRestore	{CSTKPTR = CurrentStackPTR+2;}#include "tosretmacro.h"#include "tosfuncallmacro.h"#endif#ifdef TOS0/** cached TOPOFSTACK, CSTKPTR points at last item in stack   **/ #define CPushStack(x)	{CSTKPTR += 2; *((LispPTR *)CSTKPTR)=x;}#define CPopCStack	{TOPOFSTACK = *((LispPTR *)CSTKPTR); CSTKPTR -= 2;}#define CPushCStack	{CSTKPTR += 2; *((LispPTR *)CSTKPTR) = TOPOFSTACK;}#define TOPOFSTACK 	tscache#define PREVTOS		*((LispPTR *)(CSTKPTR))#define POPPREVTOS	*((LispPTR *)CSTKPTR--)#define TOS		*((LispPTR *)(CSTKPTR-2))#define CPush(x)	{CPushCStack; TOPOFSTACK = x;}#define CPopStore(x)	{CSTKPTR -= 2; TOPOFSTACK = x;}#define CCopyTos	{CPushCStack;}#define StackPtrSave	{CurrentStackPTR = CSTKPTR;}#define StackPtrRestore	{CSTKPTR = CurrentStackPTR;}#include "retmacro.h"#include "funcallmacro.h"#endif#define NativeCheck	{if (FuncObj->native) {goto gonative ;} nextop0; }extern ByteCode *PC;extern CFuncPTR OPCODE_entries[];extern int Intrdisable;#ifdef	IVARINREG#define EXT	{ PC = pccache;\		  TopOfStack = TOPOFSTACK;\		  StackPtrSave;\		  IVar = IVAR;}#define RET	{ pccache = PC;\		  StackPtrRestore;\		  TOPOFSTACK = TopOfStack;\		  IVAR = IVar; }#else#define	IVAR	MState->ivar#define EXT	{ PC=pccache;\		  TopOfStack=TOPOFSTACK;\		  StackPtrSave; }#define RET	{ pccache=PC;\		  StackPtrRestore;\		  TOPOFSTACK = TopOfStack; } #endif#define NRET	{ RET; nextop0; }#define UFN(x)  { EXT; ufn((x)); NRET; }#define CURRENTFX CurrentFX#define	PVAR	MState->pvar#define  CFnStkOvr(argnum,bytenum) { \				CPushStack(S_POSITIVE | argnum); \				EXT;\				contextsw(SubovFXP,bytenum,1); \				RET; nextop0; }typedef ByteCode *InstPtr;int ctak(x, y, z) { if (x > y)  	{return(ctak( 		 ctak(x-1, y, z),		 ctak(y-1, z, x),		 ctak(z-1, x, y)		)	   );	}  else    return(z);};dispatch(){	InstPtr optable[256]; 	int timevalue;	int takval;	struct timeval time;	unsigned int usec;	printf("timing ctak...\n");	update_timer();	gettimeofday(&time, NULL);	usec = (time.tv_sec * 1000000) + time.tv_usec;	takval = ctak(18, 12, 6);	update_timer();	gettimeofday(&time, NULL);	timevalue = ((time.tv_sec * 1000000) + time.tv_usec) - usec;	printf("ctak(18, 12, 6) = %d, in %f  sec \n",takval,timevalue / 1000000.0);#ifdef OPDISP	doDispatch(0, optable);}doDispatch(pccache, table)	register InstPtr pccache;	register InstPtr *table;{#else    register InstPtr pccache;#endif    register DLword *cspcache;    register LispPTR tscache;    register int SaveD6;    register int LoopCounter=400;#ifdef IVARINREG     register DLword *IVAR;#endif    register  struct state	*mstate;    CFuncPTR *OPtbl_base ;    int save_atom_index;/* changed to --LoopCounter so can subtract then test */#define CHECK_INTERRUPT {if(--LoopCounter<0) goto check_interrupt;} #define registers  register int arg1,arg2, arg3, result; register DLword *wordp; \	register LispPTR *cellp;    extern DLword *createcell68k();#ifdef OPDISPextern void jumpLabel();void LispPTR difference();#define nextop0 {jumpLabel();}#define nextop1 {PCMAC += 1; jumpLabel();}#define nextop2 {PCMAC += 2; jumpLabel();}#define nextop3 {PCMAC += 3; jumpLabel();}#else#define nextop0 {goto nextopcode; }#define nextop1 {PCMAC += 1; goto nextopcode; }#define nextop2 {PCMAC += 2; goto nextopcode; }#define nextop3 {PCMAC += 3; goto nextopcode; }#endif#define	IVARMACRO(x)	{CPush(GetLongWord(IVAR + x )); nextop1;}#define	PVARMACRO(x)	{CPush(GetLongWord(PVAR + x )); nextop1;}#define	PVARSETMACRO(x)	{*((LispPTR *)PVAR + x) = TOPOFSTACK; nextop1;}#define	PUSHATOM(x)	{CPush(x); nextop1;}#define	FJUMPMACRO(x)	{if(TOPOFSTACK != 0) {goto PopNextop1 ; }\			{CPopCStack; PCMAC += x; nextop0;}\			}#define	TJUMPMACRO(x)	{if(TOPOFSTACK == 0) {goto PopNextop1 ; }\			{CPopCStack; PCMAC += x; nextop0;}\			}    OPtbl_base = OPCODE_entries;#ifdef OPDISP	RET; 	goto setup_table;#endifnextopret:    RET;    nextopcode :switch (Get_BYTE(PCMAC)) {  case 000 : case000: { jmpni(); } case 001 : case001: { EXT; OP_car(); NRET; } case 002 : case002: { EXT; OP_cdr(); NRET; } case 003 : case003: { EXT; OP_listp(); NRET; } case 004 : case004: { EXT; OP_ntypex(); NRET; } case 005 : case005: { EXT; OP_typep(); NRET; } case 006 : case006: { EXT; OP_dtest(); NRET; } case 007 : case007: {goto ni; }  /*  case 010 : case010: { goto ni; } case 011 : case011: {goto ni; } case 012 : case012: {goto ni; } case 013 : case013: {goto ni; }  case 014 : case014: {goto ni; }*/ case 010 : case010: {registers; CHECK_INTERRUPT; OPFN(0); nextop0; } case 011 : case011: {registers; CHECK_INTERRUPT; OPFN(1); nextop0; } case 012 : case012: {registers; CHECK_INTERRUPT; OPFN(2); nextop0; }/* case 013 : case013: {registers; CHECK_INTERRUPT; fn3(); NativeCheck; }*/ case 013 : case013: {registers; CHECK_INTERRUPT; OPFN(3); NativeCheck; } case 014 : case014: {registers; CHECK_INTERRUPT; OPFN(4); nextop0; } case 015 : case015: {CHECK_INTERRUPT; EXT; OP_fnx(); RET; nextop0; } case 016 : case016: {CHECK_INTERRUPT; EXT; OP_apply(); RET; nextop0;  } case 017 : case017: { EXT; OP_checkapply(); RET; NativeCheck;} case 020 : case020: {OPRETURN; nextop0; }/* case 020 : case020: {opreturn(); NativeCheck; }*//* case 021 : case021: { goto ni; } case 022 : case022: { goto ni; } case 023 : case023: { goto ni; } case 024 : case024: { goto ni; } case 025 : case025: { goto ni; } case 026 : case026: { goto ni; } case 027 : case027: { goto ni; } case 030 : case030: { goto ni; } case 031 : case031: { goto ni; } case 032 : case032: { goto ni; } case 033 : case033: { goto ni; } case 034 : case034: { goto ni; } case 035 : case035: { goto ni; } case 036 : case036: { goto ni; } case 037 : case037: { goto ni; } case 040 : case040: { goto ni; } case 041 : case041: { goto ni; } case 042 : case042: { goto ni; } case 043 : case043: { goto ni; } case 044 : case044: { goto ni; } case 045 : case045: { goto ni; } case 046 : case046: { goto ni; } case 047 : case047: { goto ni; } case 050 : case050: { goto ni; } case 051 : case051: { goto ni; } case 052 : case052: { goto ni; } case 053 : case053: { goto ni; } case 054 : case054: { goto ni; } case 055 : case055: { goto ni; } case 056 : case056: { goto ni; } case 057 : case057: { goto ni; } case 060 : case060: { goto ni; } case 061 : case061: { goto ni; } case 062 : case062: { goto ni; } case 063 : case063: { goto ni; } case 064 : case064: { goto ni; } case 065 : case065: { goto ni; } case 066 : case066: { goto ni; } case 067 : case067: { goto ni; } case 070 : case070: { goto ni; } case 071 : case071: { goto ni; } case 072 : case072: { goto ni; }  case 073 : case073: { goto ni; }  case 074 : case074: { goto ni; } case 075 : case075: { goto ni; } case 076 : case076: { goto ni; } case 077 : case077: { goto ni; }*/ case 021 : case021: { EXT; OP_bind(); NRET; } case 022 : case022: { EXT; OP_unbind(); NRET; } case 023 : case023: { EXT; OP_dunbind(); NRET; } case 024 : case024: { EXT; OP_rplptr(); NRET; } case 025 : case025: { EXT; OP_gcref(); NRET; } case 026 : case026: { EXT; OP_assoc(); NRET; } case 027 : case027: { EXT; OP_gvar_(); NRET; } case 030 : case030: { EXT; OP_rplaca(); NRET; } case 031 : case031: { EXT; OP_rplacd(); NRET; } case 032 : case032: { EXT; OP_cons(); NRET; } case 033 : case033: { EXT; OP_dbx(); NRET; } case 034 : case034: { EXT; OP_fmemb(); NRET; } case 035 : case035: { goto ni; } case 036 : case036: { EXT; OP_findkey(); NRET; } case 037 : case037: { EXT; OP_createcell(); NRET; } case 040 : case040: { EXT; OP_bin(); NRET; } case 041 : case041: { goto ni; } case 042 : case042: { goto ni; } case 043 : case043: { goto ni; } case 044 : case044: { goto ni; } case 045 : case045: { goto ni; } case 046 : case046: { EXT; OP_rplcons(); NRET; } case 047 : case047: { EXT; OP_listget(); NRET; } case 050 : case050: { goto ni; } case 051 : case051: { goto ni; } case 052 : case052: { goto ni; } case 053 : case053: { goto ni; } case 054 : case054: { EXT; OP_eval(); NRET; } case 055 : case055: { goto ni; } case 056 : case056: { EXT; OP_dtest(); NRET; } case 057 : case057: { EXT; OP_stkscan(); NRET; } case 060 : case060: { goto ni; } case 061 : case061: { goto ni; } case 062 : case062: { EXT; OP_ubfloat3(); NRET; } case 063 : case063: { EXT; OP_typemask(); NRET; } case 064 : case064: { goto ni; } case 065 : case065: { goto ni; } case 066 : case066: { goto ni; } case 067 : case067: { goto ni; } case 070 : case070: { goto ni; } case 071 : case071: { goto ni; } case 072 : case072: { EXT; OP_eqlop(); NRET; } case 073 : case073: { EXT; OP_drawline(); NRET; } case 074 : case074: { EXT; OP_storen(); NRET; } case 075 : case075: { EXT; OP_copyn(); NRET; } case 076 : case076: { goto ni; } case 077 : case077: { goto ni; } case 0100 : case0100: { IVARMACRO ( 0 );  } case 0101 : case0101: { IVARMACRO ( 2 );  } case 0102 : case0102: { IVARMACRO ( 4 );  } case 0103 : case0103: { IVARMACRO ( 6 );  } case 0104 : case0104: { IVARMACRO ( 8 );  } case 0105 : case0105: { IVARMACRO ( 10 );  } case 0106 : case0106: { IVARMACRO ( 12 );  }  case 0110 : case0110: { PVARMACRO (  0 );  } case 0111 : case0111: { PVARMACRO (  2 );  } case 0112 : case0112: { PVARMACRO (  4 );  } case 0113 : case0113: { PVARMACRO (  6 );  } case 0114 : case0114: { PVARMACRO (  8 );  } case 0115 : case0115: { PVARMACRO ( 10 );  } case 0116 : case0116: { PVARMACRO ( 12 );  }  /******** PVarX		********/ case 0117 : case0117: {		CPush(GetLongWord( PVAR + Get_BYTE(1+PCMAC) ));		nextop2;		}		 case 0130 : case0130: { PVARSETMACRO (0); } case 0131 : case0131: { PVARSETMACRO (1); } case 0132 : case0132: { PVARSETMACRO (2); } case 0133 : case0133: { PVARSETMACRO (3); } case 0134 : case0134: { PVARSETMACRO (4); } case 0135 : case0135: { PVARSETMACRO (5); } case 0136 : case0136: { PVARSETMACRO (6); }/******** PvarX_	********/ case 0137 : case0137: {				*((LispPTR *)(PVAR + Get_BYTE(1+PCMAC))) = TOPOFSTACK;		nextop2;		} /******** GVar		********/ case 0140 : case0140: {		CPush(GetLongWord(Valspace + ((Get_DLword(1+PCMAC))<<1)));		nextop3;		}/******** IvarX_	********/ case 0142 : case0142: {		*((LispPTR *)(IVAR + Get_BYTE(1+PCMAC))) = TOPOFSTACK;		nextop2;		}/******** Copy		********/case 0144 : case0144: {	CCopyTos(TOPOFSTACK); nextop1; }/******** Aconst	********/ case 0147 : case0147: { CPush(Get_DLword(PCMAC+1)); nextop3;} case 0150 : case0150: { PUSHATOM(NIL_PTR     ); } case 0151 : case0151: { PUSHATOM(ATOM_T      ); } case 0152 : case0152: { PUSHATOM(S_POSITIVE  ); } case 0153 : case0153: { PUSHATOM(0xE0001     ); }/********* SIC		********/ case 0154 : case0154: {	 		CPush(S_POSITIVE | Get_BYTE(PCMAC+1)); 		nextop2;		}/********* SNIC		********/ case 0155 : case0155: { 			CPush(S_NEGATIVE | 0xff00 | Get_BYTE(PCMAC+1)); 		nextop2;		}/********* SICX		********/ case 0156 : case0156: { 	 		CPush(S_POSITIVE | Get_DLword(PCMAC+1)); 		nextop3;		}/* FJUMP */ case 0220 : case0220: { FJUMPMACRO(2); } case 0221 : case0221: { FJUMPMACRO(3); } case 0222 : case0222: { FJUMPMACRO(4); } case 0223 : case0223: { FJUMPMACRO(5); } case 0224 : case0224: { FJUMPMACRO(6); } case 0225 : case0225: { FJUMPMACRO(7); } case 0226 : case0226: { FJUMPMACRO(8); } case 0227 : case0227: { FJUMPMACRO(9); } case 0230 : case0230: { FJUMPMACRO(10); } case 0231 : case0231: { FJUMPMACRO(11); } case 0232 : case0232: { FJUMPMACRO(12); } case 0233 : case0233: { FJUMPMACRO(13); } case 0234 : case0234: { FJUMPMACRO(14); } case 0235 : case0235: { FJUMPMACRO(15); } case 0236 : case0236: { FJUMPMACRO(16); } case 0237 : case0237: { FJUMPMACRO(17); }/* TJUMP */ case 0240 : case0240: { TJUMPMACRO(2); } case 0241 : case0241: { TJUMPMACRO(3); } case 0242 : case0242: { TJUMPMACRO(4); } case 0243 : case0243: { TJUMPMACRO(5); } case 0244 : case0244: { TJUMPMACRO(6); } case 0245 : case0245: { TJUMPMACRO(7); } case 0246 : case0246: { TJUMPMACRO(8); } case 0247 : case0247: { TJUMPMACRO(9); } case 0250 : case0250: { TJUMPMACRO(10); } case 0251 : case0251: { TJUMPMACRO(11); } case 0252 : case0252: { TJUMPMACRO(12); } case 0253 : case0253: { TJUMPMACRO(13); } case 0254 : case0254: { TJUMPMACRO(14); } case 0255 : case0255: { TJUMPMACRO(15); } case 0256 : case0256: { TJUMPMACRO(16); } case 0257 : case0257: { TJUMPMACRO(17); }/******* JUMPX ********/ case 0260 : case0260: {/*	if ((*(PCMAC+1)) < 0) {CHECK_INTERRUPT;};*//*	It's easier to check interrupt than the branch direction */		CHECK_INTERRUPT;		PCMAC += *(PCMAC+1); nextop0; 		}/******* FJumpx *******/ case 0262 : case0262: {	if(TOPOFSTACK != 0) {goto PopNextop2;}/*	if ((*(PCMAC+1)) < 0) {CHECK_INTERRUPT;};*//*	It's easier to check interrupt than the branch direction */	CHECK_INTERRUPT;	CPopCStack;	PCMAC += *(PCMAC+1);	nextop0; 	}/******** Pop		********/ case 0277 : case0277: { CPopCStack; nextop1; }case 0303 : case0303: { goto ni; }/********  Plus2	********//******** IPlus2	********/	 case 0324 : case0324: 	 case 0330 : case0330:#ifdef TOS1	{CPopStore(plus(TOS, TOPOFSTACK)); nextop1;}#endif#ifdef TOS0	{TOPOFSTACK=plus(PREVTOS, TOPOFSTACK); CSTKPTR-=2; nextop1;}#endif/*	{ register int arg1, arg2; 	CGETNUMBER(PREVTOS, arg1 );	CGETNUMBER(TOPOFSTACK, arg2 );	arg1 = arg1 + arg2;	 	if(0 <= arg1)	  {     if(arg1 <= MAX_SMALL)			{ CPopStore(S_POSITIVE | arg1); }		else{	register DLword *wordp;			wordp = createcell68k(TYPE_FIXP);			*((unsigned int *)wordp) = arg1;			CPopStore(LADDR_from_68k(wordp)); }	  }else{		if(MIN_SMALL <= arg1)			{ CPopStore(S_NEGATIVE | (0xFFFF & arg1)); }		else{	register DLword *wordp;			wordp = createcell68k(TYPE_FIXP);			*((unsigned int *)wordp) = arg1;			CPopStore(LADDR_from_68k(wordp));}		};	nextop1;	}*/	/********  Difference	********//******** IDifference	********/ case 0325 : case0325:  		 case 0331 : case0331: #ifdef TOS1	{CPopStore(difference(TOS, TOPOFSTACK)); nextop1;}#endif#ifdef TOS0	{TOPOFSTACK=difference(PREVTOS, TOPOFSTACK); CSTKPTR-=2; nextop1;}#endif/*	{  register int arg1, arg2; 	CGETNUMBER(PREVTOS , arg1 );	CGETNUMBER(TOPOFSTACK, arg2 );	arg1 = arg1 - arg2;	 	if(0 <= arg1)	  {     if(arg1 <= MAX_SMALL)			{ CPopStore(S_POSITIVE | arg1); }		else{	register DLword *wordp;			wordp = createcell68k(TYPE_FIXP);			*((unsigned int *)wordp) = arg1;			CPopStore(LADDR_from_68k(wordp)); }	  }else{		if(MIN_SMALL <= arg1)			{ CPopStore(S_NEGATIVE | (0xFFFF & arg1)); }		else{	register DLword *wordp;			wordp = createcell68k(TYPE_FIXP);			*((unsigned int *)wordp) = arg1;			CPopStore(LADDR_from_68k(wordp));}		};	nextop1;	}*//******** Eq	********/case 0360 : case0360: {		if(TOPOFSTACK == PREVTOS)			CPopStore(ATOM_T)		else	CPopStore(NIL_PTR);		nextop1;		}/******** IGreaterP	********//********  GreaterP	********/ case 0361 : case0361:  		 case 0363 : case0363: #ifdef TOS1	{CPopStore(greaterp(TOS, TOPOFSTACK)); nextop1;}#endif#ifdef TOS0	{TOPOFSTACK=greaterp(PREVTOS, TOPOFSTACK); CSTKPTR-=2; nextop1;}#endif/*{ register int arg1, arg2; 		CGETNUMBER(PREVTOS,arg1);		CGETNUMBER(TOPOFSTACK ,arg2);		if(arg1 > arg2)			CPopStore(ATOM_T)		else	CPopStore(NIL_PTR);		nextop1;		}*//******* SWAP *******/ case 0375 : case0375: { register int temp; 		 	temp = PREVTOS;			PREVTOS = TOPOFSTACK;		 	TOPOFSTACK = (LispPTR)temp;			nextop1;			} case 0377 : case0377: {goto ni; } default: ni: {     		EXT;		(*(OPtbl_base + Get_BYTE(PCMAC)))(); 		RET; nextop0; 		}	    }	/* switch */ nextop0;{  setfixtosaddr();#ifdef TOS1   CSTKPTR += 2; #endif    setniaddr();   EXT;   (*(OPtbl_base + Get_BYTE(PCMAC)))();   RET;    nextop0; }gonative:	EXT;/*	printf("Frame name: %x, atomindex: %x \n",FuncObj->framename,save_atom_index);*/	PC = (InstPtr)		(  Native_Hash[FuncObj->framename] )			((unsigned int)PCMAC - (unsigned int)FuncObj) 		+ (unsigned int)FuncObj;  	(*(OPtbl_base + Get_BYTE(PC))) ();  	RET;	NativeCheck;/* Common Jump Tails (they have to jump anyway, so use common Tail) */PopNextop1:	CPopCStack; 	nextop1;PopNextop2:	CPopCStack; 	nextop2;check_stack:	if (CSTKPTR >= StkLimO) {EXT; contextsw(SubovFXP,0,0); RET;};check_interrupt:	LoopCounter=400;	if (!Intrdisable) {EXT; update_timer(); RET;};	nextop0;#ifdef OPDISP setup_table:	SaveD6 = 0;	table[000] = (InstPtr) ni;	table[001] = (InstPtr) case001;	table[002] = (InstPtr) case002;	table[003] = (InstPtr) case003;	table[004] = (InstPtr) case004;	table[005] = (InstPtr) case005;	table[006] = (InstPtr) case006;	table[007] = (InstPtr) case007;	table[010] = (InstPtr) case010;	table[011] = (InstPtr) case011;	table[012] = (InstPtr) case012;	table[013] = (InstPtr) case013;	table[014] = (InstPtr) case014;	table[015] = (InstPtr) case015;	table[016] = (InstPtr) case016;	table[017] = (InstPtr) case017;	table[020] = (InstPtr) case020;	table[021] = (InstPtr) case021;	table[022] = (InstPtr) case022;	table[023] = (InstPtr) case023;	table[024] = (InstPtr) case024;	table[025] = (InstPtr) case025;	table[026] = (InstPtr) case026;	table[027] = (InstPtr) case027;	table[030] = (InstPtr) case030;	table[031] = (InstPtr) case031;	table[032] = (InstPtr) case032;	table[033] = (InstPtr) case033;	table[034] = (InstPtr) case034;	table[035] = (InstPtr) ni;	table[036] = (InstPtr) case036;	table[037] = (InstPtr) case037;	table[040] = (InstPtr) case040;	table[041] = (InstPtr) ni;	table[042] = (InstPtr) ni;	table[043] = (InstPtr) ni;	table[044] = (InstPtr) ni;	table[045] = (InstPtr) ni;	table[046] = (InstPtr) case046;	table[047] = (InstPtr) case047;	table[050] = (InstPtr) ni;	table[051] = (InstPtr) ni;	table[052] = (InstPtr) ni;	table[053] = (InstPtr) ni;	table[054] = (InstPtr) case054;	table[055] = (InstPtr) ni;	table[056] = (InstPtr) case056;	table[057] = (InstPtr) case057;	table[060] = (InstPtr) ni;	table[061] = (InstPtr) ni;	table[062] = (InstPtr) case062;	table[063] = (InstPtr) case063;	table[064] = (InstPtr) ni;	table[065] = (InstPtr) ni;	table[066] = (InstPtr) ni;	table[067] = (InstPtr) ni;	table[070] = (InstPtr) ni;	table[071] = (InstPtr) ni;	table[072] = (InstPtr) case072;	table[073] = (InstPtr) case073;	table[074] = (InstPtr) case074;	table[075] = (InstPtr) case075;	table[076] = (InstPtr) ni;	table[077] = (InstPtr) ni;	table[0100] = (InstPtr) case0100;	table[0101] = (InstPtr) case0101;	table[0102] = (InstPtr) case0102;	table[0103] = (InstPtr) case0103;	table[0104] = (InstPtr) case0104;	table[0105] = (InstPtr) case0105;	table[0106] = (InstPtr) case0106;	table[0107] = (InstPtr) ni;	table[0110] = (InstPtr) case0110;	table[0111] = (InstPtr) case0111;	table[0112] = (InstPtr) case0112;	table[0113] = (InstPtr) case0113;	table[0114] = (InstPtr) case0114;	table[0115] = (InstPtr) case0115;	table[0116] = (InstPtr) case0116;	table[0117] = (InstPtr) case0117;	table[0120] = (InstPtr) ni;	table[0121] = (InstPtr) ni;	table[0122] = (InstPtr) ni;	table[0123] = (InstPtr) ni;	table[0124] = (InstPtr) ni;	table[0125] = (InstPtr) ni;	table[0126] = (InstPtr) ni;	table[0127] = (InstPtr) ni;	table[0130] = (InstPtr) case0130;	table[0131] = (InstPtr) case0131;	table[0132] = (InstPtr) case0132;	table[0133] = (InstPtr) case0133;	table[0134] = (InstPtr) case0134;	table[0135] = (InstPtr) case0135;	table[0136] = (InstPtr) case0136;	table[0137] = (InstPtr) case0137;	table[0140] = (InstPtr) case0140;	table[0141] = (InstPtr) ni;	table[0142] = (InstPtr) case0142;	table[0143] = (InstPtr) ni;	table[0144] = (InstPtr) case0144;	table[0145] = (InstPtr) ni;	table[0146] = (InstPtr) ni;	table[0147] = (InstPtr) case0147;	table[0150] = (InstPtr) case0150;	table[0151] = (InstPtr) case0151;	table[0152] = (InstPtr) case0152;	table[0153] = (InstPtr) case0153;	table[0154] = (InstPtr) ni;	table[0155] = (InstPtr) case0155;	table[0156] = (InstPtr) case0156;	table[0157] = (InstPtr) ni;	table[0160] = (InstPtr) ni;	table[0161] = (InstPtr) ni;	table[0162] = (InstPtr) ni;	table[0163] = (InstPtr) ni;	table[0164] = (InstPtr) ni;	table[0165] = (InstPtr) ni;	table[0166] = (InstPtr) ni;	table[0167] = (InstPtr) ni;	table[0170] = (InstPtr) ni;	table[0171] = (InstPtr) ni;	table[0172] = (InstPtr) ni;	table[0173] = (InstPtr) ni;	table[0174] = (InstPtr) ni;	table[0175] = (InstPtr) ni;	table[0176] = (InstPtr) ni;	table[0177] = (InstPtr) ni;	table[0200] = (InstPtr) ni;	table[0201] = (InstPtr) ni;	table[0202] = (InstPtr) ni;	table[0203] = (InstPtr) ni;	table[0204] = (InstPtr) ni;	table[0205] = (InstPtr) ni;	table[0206] = (InstPtr) ni;	table[0207] = (InstPtr) ni;	table[0210] = (InstPtr) ni;	table[0211] = (InstPtr) ni;	table[0212] = (InstPtr) ni;	table[0213] = (InstPtr) ni;	table[0214] = (InstPtr) ni;	table[0215] = (InstPtr) ni;	table[0216] = (InstPtr) ni;	table[0217] = (InstPtr) ni;	table[0220] = (InstPtr) case0220;	table[0221] = (InstPtr) case0221;	table[0222] = (InstPtr) case0222;	table[0223] = (InstPtr) case0223;	table[0224] = (InstPtr) case0224;	table[0225] = (InstPtr) case0225;	table[0226] = (InstPtr) case0226;	table[0227] = (InstPtr) case0227;	table[0230] = (InstPtr) case0230;	table[0231] = (InstPtr) case0231;	table[0232] = (InstPtr) case0232;	table[0233] = (InstPtr) case0233;	table[0234] = (InstPtr) case0234;	table[0235] = (InstPtr) case0235;	table[0236] = (InstPtr) case0236;	table[0237] = (InstPtr) case0237;	table[0240] = (InstPtr) case0240;	table[0241] = (InstPtr) case0241;	table[0242] = (InstPtr) case0242;	table[0243] = (InstPtr) case0243;	table[0244] = (InstPtr) case0244;	table[0245] = (InstPtr) case0245;	table[0246] = (InstPtr) case0246;	table[0247] = (InstPtr) case0247;	table[0250] = (InstPtr) case0250;	table[0251] = (InstPtr) case0251;	table[0252] = (InstPtr) case0252;	table[0253] = (InstPtr) case0253;	table[0254] = (InstPtr) case0254;	table[0255] = (InstPtr) case0255;	table[0256] = (InstPtr) case0256;	table[0257] = (InstPtr) case0257;	table[0260] = (InstPtr) case0260;	table[0261] = (InstPtr) ni;	table[0262] = (InstPtr) case0262;	table[0263] = (InstPtr) ni;	table[0264] = (InstPtr) ni;	table[0265] = (InstPtr) ni;	table[0266] = (InstPtr) ni;	table[0267] = (InstPtr) ni;	table[0270] = (InstPtr) ni;	table[0271] = (InstPtr) ni;	table[0272] = (InstPtr) ni;	table[0273] = (InstPtr) ni;	table[0274] = (InstPtr) ni;	table[0275] = (InstPtr) ni;	table[0276] = (InstPtr) ni;	table[0277] = (InstPtr) case0277;	table[0300] = (InstPtr) ni;	table[0301] = (InstPtr) ni;	table[0302] = (InstPtr) ni;	table[0303] = (InstPtr) case0303;	table[0304] = (InstPtr) ni;	table[0305] = (InstPtr) ni;	table[0306] = (InstPtr) ni;	table[0307] = (InstPtr) ni;	table[0310] = (InstPtr) ni;	table[0311] = (InstPtr) ni;	table[0312] = (InstPtr) ni;	table[0313] = (InstPtr) ni;	table[0314] = (InstPtr) ni;	table[0315] = (InstPtr) ni;	table[0316] = (InstPtr) ni;	table[0317] = (InstPtr) ni;	table[0320] = (InstPtr) ni;	table[0321] = (InstPtr) ni;	table[0322] = (InstPtr) ni;	table[0323] = (InstPtr) ni;	table[0324] = (InstPtr) case0324;	table[0325] = (InstPtr) case0325;	table[0326] = (InstPtr) ni;	table[0327] = (InstPtr) ni;	table[0330] = (InstPtr) case0330;	table[0331] = (InstPtr) case0331;	table[0332] = (InstPtr) ni;	table[0333] = (InstPtr) ni;	table[0334] = (InstPtr) ni;	table[0335] = (InstPtr) ni;	table[0336] = (InstPtr) ni;	table[0337] = (InstPtr) ni;	table[0340] = (InstPtr) ni;	table[0341] = (InstPtr) ni;	table[0342] = (InstPtr) ni;	table[0343] = (InstPtr) ni;	table[0344] = (InstPtr) ni;	table[0345] = (InstPtr) ni;	table[0346] = (InstPtr) ni;	table[0347] = (InstPtr) ni;	table[0350] = (InstPtr) ni;	table[0351] = (InstPtr) ni;	table[0352] = (InstPtr) ni;	table[0353] = (InstPtr) ni;	table[0354] = (InstPtr) ni;	table[0355] = (InstPtr) ni;	table[0356] = (InstPtr) ni;	table[0357] = (InstPtr) ni;	table[0360] = (InstPtr) case0360;	table[0361] = (InstPtr) case0361;	table[0362] = (InstPtr) ni;	table[0363] = (InstPtr) case0363;	table[0364] = (InstPtr) ni;	table[0365] = (InstPtr) ni;	table[0366] = (InstPtr) ni;	table[0367] = (InstPtr) ni;	table[0370] = (InstPtr) ni;	table[0371] = (InstPtr) ni;	table[0372] = (InstPtr) ni;	table[0373] = (InstPtr) ni;	table[0374] = (InstPtr) ni;	table[0375] = (InstPtr) case0375;	table[0376] = (InstPtr) ni;	table[0377] = (InstPtr) ni;     goto nextopcode;#endif     }#define KATANARCLKSECOND 1000000update_timer () {  	int     excess;	unsigned int	usec;        struct  timeval time;	getsignaldata();        gettimeofday(&time, NIL);	usec = time.tv_sec * KATANARCLKSECOND;        MiscStats->rclktemp0 = usec + time.tv_usec;        excess = MiscStats->rclktemp0 - MiscStats->baseclock;        if(excess >= KATANARCLKSECOND | (excess <= 0))                {                MiscStats->baseclock = MiscStats->rclktemp0;                MiscStats->millisecondsclock += 1000;                MiscStats->secondsclock += 1;                }  }