# 1 "../src/xc.c" static char *id = "@(#) xc.c	1.6 3/30/89		(envos & Fuji Xerox)";# 1 "/usr/include/sys/types.h" 1# 1 "/usr/include/sys/stdtypes.h" 1typedef	int		sigset_t;	typedef	unsigned int	speed_t;	typedef	unsigned long	tcflag_t;	typedef	unsigned char	cc_t;		typedef	int		pid_t;		typedef	unsigned short	mode_t;		typedef	short		nlink_t;	typedef	long		clock_t;	typedef	long		time_t;		typedef	int		size_t;		typedef int		ptrdiff_t;	typedef	unsigned short	wchar_t;	# 17 "/usr/include/sys/types.h" 2# 1 "/usr/include/sys/sysmacros.h" 1# 20 "/usr/include/sys/types.h" 2typedef	unsigned char	u_char;typedef	unsigned short	u_short;typedef	unsigned int	u_int;typedef	unsigned long	u_long;typedef	unsigned short	ushort;		typedef	unsigned int	uint;		# 37 "/usr/include/sys/types.h" # 43 "/usr/include/sys/types.h" typedef	struct  _physadr_t { int r[1]; } *physadr_t;typedef	struct label_t {	int	val[2];} label_t;# 55 "/usr/include/sys/types.h" typedef	struct	_quad_t { long val[2]; } quad_t;typedef	long	daddr_t;typedef	char *	caddr_t;typedef	unsigned long	ino_t;typedef	short	dev_t;typedef	long	off_t;typedef	unsigned short	uid_t;typedef	unsigned short	gid_t;typedef	long	key_t;typedef	char *	addr_t;typedef	long	fd_mask;# 85 "/usr/include/sys/types.h" typedef	struct fd_set {	fd_mask	fds_bits[(((256)+(( (sizeof (fd_mask) * 8))-1))/( (sizeof (fd_mask) * 8)))];} fd_set;# 113 "/usr/include/sys/types.h" # 5 "../src/xc.c" 2# 1 "/usr/include/sys/time.h" 1struct timeval {	long	tv_sec;			long	tv_usec;	};struct timezone {	int	tz_minuteswest;		int	tz_dsttime;	};struct	itimerval {	struct	timeval it_interval;		struct	timeval it_value;	};# 1 "/usr/include/time.h" 1# 1 "/usr/include/sys/stdtypes.h" 1# 32 "/usr/include/sys/stdtypes.h" # 7 "/usr/include/time.h" 2struct	tm {	int	tm_sec;	int	tm_min;	int	tm_hour;	int	tm_mday;	int	tm_mon;	int	tm_year;	int	tm_wday;	int	tm_yday;	int	tm_isdst;	char	*tm_zone;	long	tm_gmtoff;};extern	struct tm *gmtime(), *localtime();extern	char *asctime(), *ctime();extern	void tzset(), tzsetwall();extern  int dysize();extern  time_t timelocal(), timegm();# 63 "/usr/include/sys/time.h" 2# 6 "../src/xc.c" 2# 1 "/usr/include/stdio.h" 1extern	struct	_iobuf {	int	_cnt;	unsigned char *_ptr;	unsigned char *_base;	int	_bufsiz;	short	_flag;	char	_file;		} _iob[];# 36 "/usr/include/stdio.h" extern struct _iobuf	*fopen();extern struct _iobuf	*fdopen();extern struct _iobuf	*freopen();extern struct _iobuf	*popen();extern struct _iobuf	*tmpfile();extern long	ftell();extern char	*fgets();extern char	*gets();extern char	*sprintf();extern char	*ctermid();extern char	*cuserid();extern char	*tempnam();extern char	*tmpnam();# 7 "../src/xc.c" 2# 1 "../inc//lispemul.h" 1# 33 "../inc//lispemul.h" # 37 "../inc//lispemul.h" # 41 "../inc//lispemul.h" 	typedef struct {unsigned code : 8;} BYTECODE;typedef char ByteCode;typedef unsigned short  DLword;typedef char  DLbyte;typedef unsigned int  LispPTR;typedef DLword mds_page;  typedef (*CFuncPTR)();typedef struct  consstr  {    unsigned cdr_code  : 8;    unsigned car_field : 24;  } ConsCell;typedef struct ufn_entry  {    DLword atom_name;       unsigned byte_num : 8;     unsigned arg_num  : 8;   } UFN;typedef struct closure_type  {    unsigned nil1    :  8;    unsigned def_ptr : 24;     unsigned nil2    :  8;    unsigned env_ptr : 24;   } Closure;typedef struct interrupt_state  {     unsigned LogFileIO		:1;	    unsigned ETHERInterrupt	:1;	    unsigned IOInterrupt	:1;	    unsigned gcdisabled		:1;    unsigned vmemfull		:1;    unsigned stackoverflow	:1;    unsigned storagefull	:1;    unsigned waitinginterrupt	:1;    unsigned nil2		:8;    DLword   intcharcode;  } INTSTAT;struct state  {    DLword		*ivar;		    DLword		*pvar;		    DLword		*csp;		    LispPTR	 	tosvalue;	    ByteCode 		*currentpc;	    struct fnhead 	*currentfunc;	    DLword 		*endofstack;	    int 		irqcheck;	    int 		irqend;		    LispPTR		scratch_cstk;	    int			errorexit;	  };# 109 "../inc//lispemul.h" typedef	struct wbits  {    unsigned MSB :1;    unsigned B1  :1;    unsigned B2	 :1;    unsigned B3	 :1;    unsigned B4	 :1;    unsigned B5  :1;    unsigned B6	 :1;    unsigned B7	 :1;    unsigned B8	 :1;    unsigned B9	 :1;    unsigned B10 :1;    unsigned B11 :1;    unsigned B12 :1;    unsigned B13 :1;    unsigned B14 :1;    unsigned LSB :1;  }WBITS;typedef	struct lbits  {    unsigned MSB	:1;    unsigned MIDDLE	:30;    unsigned LSB	:1;  }LBITS;# 231 "../inc//lispemul.h" 		extern struct state MachineState;# 1 "../inc//ifpage.h" 1typedef struct ifpage {	DLword    currentfxp;	DLword    resetfxp;	DLword    subovfxp;	DLword    kbdfxp;	DLword    hardreturnfxp;	DLword    gcfxp;	DLword    faultfxp;	DLword    endofstack;	DLword    lversion;	DLword    minrversion;	DLword    minbversion;	DLword    rversion;	DLword    bversion;	DLword    machinetype;	DLword    miscfxp;	DLword    key;	DLword    serialnumber;	DLword    emulatorspace;	DLword    screenwidth;	DLword    nxtpmaddr;	DLword    nactivepages;	DLword    ndirtypages;	DLword    filepnpmp0;	DLword    filepnpmt0;	DLword    teleraidfxp;	DLword    filler1;	DLword    filler2;	DLword    filler3;	DLword    usernameaddr;	DLword    userpswdaddr;	DLword    stackbase;	DLword    faulthi;	DLword    faultlo;	DLword    devconfig;	DLword    rptsize;	DLword    rpoffset;	DLword    wasrptlast;	DLword    embufvp;	DLword    nshost0;	DLword    nshost1;	DLword    nshost2;	DLword    mdszone;	DLword    mdszonelength;	DLword    emubuffers;	DLword    emubuflength;	DLword    lastnumchars;	DLword    sysdisk;	DLword    isfmap;		LispPTR   miscstackfn;	LispPTR   miscstackarg1;	LispPTR   miscstackarg2;	LispPTR   miscstackresult;	DLword    nrealpages;	DLword    lastlockedfilepage;	DLword    lastdominofilepage;	DLword    fptovpstart;	DLword    fakemousebits;	DLword    dl24bitaddressable;	LispPTR   realpagetableptr;	DLword    dllastvmempage;	DLword    fullspaceused;	DLword    fakekbdad4;	DLword    fakekbdad5;} IFPAGE;# 161 "../inc//ifpage.h" # 258 "../inc//lispemul.h" 2# 1 "../inc//iopage.h" 1typedef struct iopage {	DLword	 dummy0[022];	DLword   dlmaintpanel;        DLword   dlfloppycmd;        DLword   dlttyportcmd;        DLword   dlprocessorcmd;        DLword   newmousestate;        DLword   dlbeepcmd;        DLword   dlrs232cmisccommand;        DLword   dlrs232cputflag;	DLword   dlrs232cgetflag;	DLword   dummy1[6];	DLword   dlfloppy;	DLword   dlttyout;	DLword   dummy2;	DLword   dlttyin;	DLword   dummy3;	DLword   dlprocessor2;	DLword   dlprocessor1;	DLword   dlprocessor0;	DLword   newmousex;	DLword   newmousey;	DLword   dlbeepfreq;	DLword   dlrs232cparametercsblo;	DLword   dlrs232cparametercsbhi;	DLword   dlrs232csetrs366status[3];	DLword   dlrs232cputcsblo;	DLword   dlrs232cputcsbhi;	DLword   dlrs232cgetcsblo;	DLword   dlrs232cgetcsbhi;	DLword   dlrs232cdevicestatus;	DLword   dlrs232cparameteroutcome;	DLword   dltodvalid;	DLword   dltodlo;	DLword   dltodhi;	DLword   dltodlo2;	DLword   dlmousex;	DLword   dlmousey;	DLword   dlutilin;	DLword   dlkbdad0;	DLword   dlkbdad1;	DLword   dlkbdad2;	DLword   dlkbdad3;	DLword   dlkbdad4;	DLword   dlkbdad5;	DLword   dllsepimagecsb[040];	DLword   dliophardwareconfig;	DLword   dummy4[013];	DLword   dlrs232cparametercsblo_11;	DLword   dlrs232cparametercsbhi_11;	DLword   dlrs232csetrs366status_11[016] ;	DLword   dummy5[074];	DLword   dlmagtape[4];	DLword   dlethernet[014];	DLword   dummy6[037];	DLword   dldispinterrupt;	DLword   dldispcontrol;	DLword   dldispborder;	DLword   dlcursorx;	DLword   dlcursory;	DLword   dlcursorbitmap[020];} IOPAGE;# 151 "../inc//iopage.h" # 261 "../inc//lispemul.h" 2# 1 "../inc//miscstats.h" 1typedef struct  misc {	int	starttime;	int	totaltime;	int	swapwaittime;	int	pagefaults;	int	swapwrites;	int	diskiotime;	int	diskops;	int	keyboardwaittime;	int	gctime;	int	netiotime;	int	netioops;	int	swaptemp0;	int	swaptemp1;	unsigned int	rclksecond;	unsigned int	secondsclock;	unsigned int	millisecondsclock;	unsigned int	baseclock;	unsigned int	rclktemp0;	unsigned int	secondstmp;	unsigned int	millisecondstmp;	unsigned int	basetmp;	int	excesstimetmp;	int	clocktemp0;	int	disktemp0;	int	disktemp1;	int	teleraidtemp1;	int	teleraidtemp2;	int	teleraidtemp3;	int	lastuseraction;	int	dlmousetimer;	int	dlmousetemp;} MISCSTATS;# 265 "../inc//lispemul.h" 2		# 10 "../src/xc.c" 2# 1 "../inc//emulglobal.h" 1# 11 "../src/xc.c" 2# 1 "../inc//address.h" 1# 12 "../src/xc.c" 2# 1 "../inc//address68k.h" 1# 30 "../inc//address68k.h" # 46 "../inc//address68k.h" # 13 "../src/xc.c" 2# 1 "../inc//stack.h" 1			struct fnhead{	DLword		stkmin;		short		na;		short		pv;		DLword		startpc;				unsigned	native		: 1;		unsigned	nil1		: 1;		unsigned	argtype		: 2;		unsigned	nil2		: 4;		unsigned	framename	:24;		DLword		ntsize;				unsigned	nlocals		: 8;		unsigned	fvaroffset	: 8;				} FNHEAD;typedef struct frameex1{	unsigned	flags	:3;	unsigned	fast	:1;	unsigned	native	:1;		unsigned	incall	:1;	unsigned	validnametable	:1;				unsigned	nopush	:1;	unsigned	usecount :8;	DLword	alink;			DLword	lofnheader;		unsigned hi1fnheader : 8; 	unsigned hi2fnheader : 8; 	DLword	nextblock;		DLword	pc;			DLword	lonametable;		unsigned hi1nametable :8;		unsigned hi2nametable :8;		DLword	blink;			DLword	clink;		} FX;typedef struct frameex2{	unsigned	flags	:3;	unsigned	fast	:1;	unsigned	native	:1;		unsigned	incall	:1;	unsigned	validnametable	:1;				unsigned	nopush	:1;	unsigned	usecount :8;	DLword	alink;			LispPTR	fnheader;		DLword	nextblock;		DLword	pc;			LispPTR	nametable;		DLword	blink;			DLword	clink;		} FX2;typedef struct fxblock {	unsigned	flagbyte	: 8;	unsigned	nil		: 23;	unsigned	slowp		: 1;} FXBLOCK;typedef struct basic_frame {	unsigned	flags	: 3;	unsigned	nil	: 3;	unsigned	residual: 1;	unsigned	padding : 1;	unsigned	usecnt  : 8;	DLword		ivar;} Bframe;typedef struct stkword {		unsigned	flags	 :3;		unsigned	nil	 :5;		unsigned	usecount :8; } StackWord; typedef struct stack_block {		DLword flagword;		DLword size; } STKBLK;typedef struct stackp {		DLword stackp0;		DLword edfxp;} STACKP;			# 290 "../inc//stack.h" # 354 "../inc//stack.h" # 14 "../src/xc.c" 2# 1 "../inc//dbprint.h" 1# 21 "../inc//dbprint.h" # 15 "../src/xc.c" 2# 1 "../inc//lispglobal.h" 1 extern  DLword *Atomspace; 		 extern  DLword *Stackspace;		 extern  DLword *Plistspace;		 extern  DLword *DTDspace;		 extern  DLword *MDStypetbl;		 extern  DLword *AtomHT;		 extern  DLword *Pnamespace;		 extern  DLword *Defspace;		 extern  DLword *Valspace;		 extern  DLword *Spospspace;		 extern  DLword *Snegspace;		 extern DLword *FPtoVP ;extern DLword *PAGEMap;extern DLword *PageMapTBL ;extern DLword *LockedPageTable;extern DLword *IOCBPage ;extern IOPAGE *IOPage ;extern IFPAGE *InterfacePage ;extern MISCSTATS *MiscStats ;extern DLword *UFNTable ; extern  DLword *HTmain; extern  DLword *HToverflow; extern  DLword *HTbigcount; extern  DLword *HTcoll; extern DLword *DisplayRegion ; extern  DLword *Arrayspace;   extern  DLword *MDS_space_bottom;   extern  DLword *PnCharspace ;	 extern  struct dtd *ListpDTD ;	 extern  DLword *Next_Array ;	 extern  DLword *Next_MDSpage;	     extern DLword *Lisp_world;   extern LispPTR *Next_MDSpage_word;extern LispPTR *Next_Array_word;extern LispPTR *MDS_free_page_word;extern LispPTR *Reclaim_cnt_word ;extern int FileIOFlag, TimerFlag;extern LispPTR *GcDisabled_word;extern LispPTR *CdrCoding_word;extern LispPTR *FreeBlockBuckets_word;extern LispPTR *Array_Block_Checking_word;extern LispPTR *ArrayMerging_word;extern LispPTR *ArraySpace_word;extern LispPTR *ArraySpace2_word;extern LispPTR *ArrayFrLst_word;extern LispPTR *ArrayFrLst2_word;extern LispPTR *Hunk_word;extern LispPTR *System_Buffer_List_word;extern LispPTR *GcMess_word;extern LispPTR *ReclaimMin_word;extern LispPTR *GcTime1_word;extern LispPTR *GcTime2_word;extern LispPTR *MaxTypeNumber_word;extern LispPTR *Package_from_Index_word;extern LispPTR *Package_from_Name_word;extern LispPTR *Keyword_Package_word;extern LispPTR *Deleted_Implicit_Hash_Slot_word;extern LispPTR *Closure_Cache_Enabled_word;extern LispPTR *Closure_Cache_word;extern LispPTR First_index;extern LispPTR *STORAGEFULLSTATE_word;extern LispPTR *STORAGEFULL_word;extern LispPTR *PENDINGINTERRUPT_word;extern LispPTR *LeastMDSPage_word;extern LispPTR *SecondMDSPage_word;extern LispPTR *SecondArrayPage_word;extern LispPTR *INTERRUPTSTATE_word;extern LispPTR *SYSTEMCACHEVARS_word;extern LispPTR *MACHINETYPE_word;extern LispPTR STORAGEFULLSTATE_index;extern LispPTR *LASTVMEMFILEPAGE_word;extern LispPTR *VMEM_FULL_STATE_word;extern int native_load_address;extern LispPTR native_closure_env;extern LispPTR *STACKOVERFLOW_word;extern LispPTR *GuardStackAddr_word;extern LispPTR *LastStackAddr_word;extern LispPTR *NeedHardreturnCleanup_word;extern int UnixPipeIn;extern int UnixPipeOut;extern int UnixPID;extern LispPTR MVLIST_index;# 17 "../src/xc.c" 2# 1 "../inc//lisptypes.h" 1	struct dtd {	DLword dtd_name ;	DLword dtd_size ;	LispPTR dtd_free ;	unsigned unuse	:2 ;	unsigned dtd_obsolate :1 ;	unsigned dtd_finalizable :1 ;	unsigned dtd_lockedp : 1 ;	unsigned dtd_hunkp : 1 ;	unsigned dtd_gctype :2 ;	unsigned dtd_descrs : 24;	LispPTR dtd_typespecs ;	LispPTR dtd_ptrs ;	int  dtd_oldcnt;	DLword dtd_cnt0 ;	DLword dtd_nextpage ;	DLword dtd_typeentry ;	DLword dtd_supertype ;};typedef  struct stringp {	unsigned origin			: 1 ;	unsigned substringed		: 1 ;	unsigned readonly		: 1 ;	unsigned nil			: 1 ;	unsigned type			: 4 ;	unsigned base			: 24 ;	DLword   length ;	DLword   offset ; } STRINGP ;typedef struct oned_array {		unsigned int nil1 : 8 ;		unsigned int base : 24  ;		unsigned int readonlyp :1 ;		unsigned int indirectp : 1; 		unsigned int bitp :1 ;		unsigned int stringp : 1;		unsigned int ajustablep : 1; 		unsigned int displacedp : 1;		unsigned int fillpointerp :1;		unsigned int extendablep : 1;		unsigned int typenumber : 8 ;		DLword offset;		DLword fillpointer ;		DLword totalsize ; } OneDArray;typedef struct oned_array NEWSTRINGP;typedef struct general_array {		unsigned int nil1 : 8 ;		unsigned int base : 24  ;		unsigned int readonlyp :1 ;		unsigned int indirectp : 1; 		unsigned int bitp :1 ;		unsigned int stringp : 1;		unsigned int ajustablep : 1; 		unsigned int displacedp : 1;		unsigned int fillpointerp :1;		unsigned int extendablep : 1;		unsigned int typenumber : 8 ;		DLword Dim0;		DLword Dim1 ;		DLword Dim2 ; } LispArray;typedef struct compiled_closure {		unsigned int nil1	: 8 ;		unsigned int def_ptr	: 24; 		unsigned int nil2	: 8 ;		unsigned int env_ptr	: 24;   } CClosure ; struct system_dtd_contents {	char   *dtd_name ;  	DLword  name_len ;  	DLword  dtd_size ;};typedef struct{	LispPTR	bmbase;	DLword	bmrasterwidth;	DLword	bmheight;	DLword	bmwidth;	DLword	bmbitperpixel;}BITMAP;								# 356 "../inc//lisptypes.h" # 407 "../inc//lisptypes.h" 								typedef  struct    {      LispPTR host;      LispPTR device;      LispPTR directory;      LispPTR name;      LispPTR type;      LispPTR version;    } PATHNAME;  								typedef  struct    {      LispPTR real;      LispPTR imaginary;    } COMPLEX;								typedef  struct    {      LispPTR numerator;      LispPTR denominator;    } RATIO;								typedef  struct    {      LispPTR contents;				    } BIGNUM;# 18 "../src/xc.c" 2# 1 "../inc//lispmap.h" 1 # 158 "../inc//lispmap.h" # 19 "../src/xc.c" 2# 1 "../inc//cell.h" 1      short  CarCdrError ;struct  conspage    {      unsigned    count : 8   ;      unsigned    next_cell :8 ;      DLword  next_page ;    };# 56 "../inc//cell.h" 			typedef  struct definition_cell    {      unsigned	ccodep	:	1 ;      unsigned	fastp	:	1 ;      unsigned	argtype	:	2 ;      unsigned	pseudocodep :	1 ;      unsigned	nil	:	3 ;      unsigned	defpointer :	24;    } DefCell ;typedef  struct pname_cell    {      unsigned	pkg_index : 8 ;      unsigned	pnamebase : 24 ;    } PNCell ;typedef  struct proplist_cell    {      unsigned unused: 1;      unsigned gensymp: 1;      unsigned fatpnamep: 1;      unsigned nil: 5;      unsigned propbase: 24;    } PLCell;struct xpointer{	unsigned	flags:8;	unsigned	addr:24;};# 148 "../inc//cell.h" struct  cadr_cell    {      LispPTR car_cell;	      LispPTR cdr_cell;	    };# 20 "../src/xc.c" 2# 1 "../inc//initatoms.h" 1# 21 "../src/xc.c" 2# 1 "../inc//gc.h" 1			struct	 hashentry  {    unsigned	count		:6;    unsigned	stackref	:1;    unsigned	segnum		:8;    unsigned	collision	:1;  };struct  htlinkptr  {	    DLword	contents;  };struct	htcoll  {    DLword	free_ptr ;    DLword	next_free ;  };struct	gc_ovfl  {    LispPTR	  ovfl_ptr ;    unsigned int  ovfl_cnt ;  };struct  htoverflow   {	    unsigned	pcase	:8;    unsigned	ptr	:24;  };# 124 "../inc//gc.h" # 22 "../src/xc.c" 2# 1 "../inc//arith.h" 1# 88 "../inc//arith.h" # 235 "../inc//arith.h" # 23 "../src/xc.c" 2# 1 "../inc//stream.h" 1			typedef struct	stream{	DLword	COFFSET;     DLword	CBUFSIZE;     unsigned	BINABLE	:1;     unsigned	BOUTABLE	:1;     unsigned	EXTENDABLE	:1;     unsigned	CBUFDIRTY	:1;     unsigned	PEEKEDCHARP	:1;	unsigned  ACCESS	:3;     unsigned	CBUFPTR		:24;     DLbyte	BYTESIZE;     DLbyte	CHARSET;     DLword	PEEKEDCHAR;     DLword	CHARPOSITION;     DLword	CBUFMAXSIZE;     unsigned	NONDEFAULTDATEFLG	:1;     unsigned	REVALIDATEFLG	:1;     unsigned	MULTIBUFFERHINT	:1;     unsigned	USERCLOSEABLE	:1;     unsigned	USERVISIBLE	:1;     unsigned	EOLCONVENTION	:2;     unsigned	NIL1	:1;     unsigned	FULLFILENAME	:24;     LispPTR	DEVICE;     LispPTR	VALIDATION;     LispPTR	CPAGE;     LispPTR	EPAGE;     DLword	EOFFSET;     DLword	LINELENGTH;     LispPTR	F1;     LispPTR	F2;     LispPTR	F3;     LispPTR	F4;     LispPTR	F5;     DLword	FW6;     DLword	FW7;     DLword	FW8;     DLword	FW9;     LispPTR	F10;     LispPTR	STRMBINFN;     LispPTR	STRMBOUTFN;     LispPTR	OUTCHARFN;     LispPTR	ENDOFSTREAMOP;     LispPTR	OTHERPROPS;     LispPTR	IMAGEOPS;     LispPTR	IMAGEDATA;     LispPTR	BUFFS;     DLword	MAXBUFFERS;     DLword	NIL2;     LispPTR	EXTRASTREAMOP;}Stream;# 123 "../inc//stream.h" # 24 "../src/xc.c" 2# 1 "../inc//tos1defs.h" 1			# 51 "../inc//tos1defs.h" # 84 "../inc//tos1defs.h" # 26 "../src/xc.c" 2# 1 "../inc//tosretmacro.h" 1# 6 "../inc//tosretmacro.h" # 24 "../inc//tosretmacro.h" # 27 "../src/xc.c" 2# 1 "../inc//tosfuncallmacro.h" 1# 52 "../inc//tosfuncallmacro.h" # 213 "../inc//tosfuncallmacro.h" # 28 "../src/xc.c" 2# 1 "../inc//inlinedefsC.h" 1# 249 "../inc//inlinedefsC.h" # 855 "../inc//inlinedefsC.h" # 29 "../src/xc.c" 2# 35 "../src/xc.c" # 1 "../inc//inlinedefsSPARC.h" 1 # 39 "../src/xc.c" 2# 43 "../src/xc.c" # 1 "../inc//fast_dispatch.h" 1# 40 "../inc//fast_dispatch.h" # 46 "../src/xc.c" 2# 1 "../inc//profile.h" 1# 7 "../inc//profile.h" # 47 "../src/xc.c" 2typedef struct conspage ConsPage;typedef ByteCode *InstPtr;extern DLword *createcell68k();# 63 "../src/xc.c" int	extended_frame;		int n_mask_array[16] = {	1, 3, 7, 0xf, 			0x1f, 0x3f, 0x7f, 0xff,			0x1ff, 0x3ff, 0x7ff, 0xfff,			0x1fff, 0x3fff, 0x7fff, 0xffff};extern int TIMER_INTERVAL;dispatch(){	register InstPtr pccache;# 81 "../src/xc.c"   	register InstPtr *table;	register LispPTR *cspcache;	register LispPTR tscache;	register struct state *stateptrcache = (&MachineState);# 97 "../src/xc.c" # 100 "../src/xc.c" # 105 "../src/xc.c"     DefCell *fn_defcell;    LispPTR fn_atom_index;    int fn_opcode_size;    int fn_num_args;    int fn_apply;    LispPTR fn_loc_defcell;	{ pccache=stateptrcache->currentpc+1; {((LispPTR *) cspcache) = ((LispPTR *) stateptrcache->csp)+1;}; tscache = stateptrcache->tosvalue; }; 	{stateptrcache->irqcheck = ( (int)(stateptrcache->irqend = (int) stateptrcache->endofstack) - (( stateptrcache->currentfunc->stkmin ) << 1) ); };# 121 "../src/xc.c" 	table = (InstPtr *) compute_dispatch_table();# 129 "../src/xc.c" # 133 "../src/xc.c" # 137 "../src/xc.c" 	goto nextopcode;	;	unwind_err: ((LispPTR *) cspcache) = (LispPTR *) stateptrcache->csp; stateptrcache->errorexit = 0; goto op_ufn; ufn_2d: ((LispPTR *) cspcache) += 1; goto fix_tos_ufn; ufn_2d2:((LispPTR *) cspcache) += 1; goto fix_tos_ufn; ufn_2: ((LispPTR *) cspcache) += 1; goto fix_tos_ufn; exception_2 : stateptrcache->errorexit = 0; ((LispPTR *) cspcache) += 1; tscache = stateptrcache->tosvalue; if(!stateptrcache->irqend){ goto check_interrupt; } else goto op_ufn; exception_2C : stateptrcache->errorexit = 0; tscache = stateptrcache->tosvalue; *((LispPTR *) cspcache) = stateptrcache->scratch_cstk; ((LispPTR *) cspcache) += 1; if(!stateptrcache->irqend){ goto check_interrupt; } else { goto op_ufn; } fix_tos_ufn: tscache = stateptrcache->tosvalue; stateptrcache->errorexit = 0; goto op_ufn;;op_ufn:	{ register UFN *entry68k;						   entry68k = (UFN *)(((UFN *)UFNTable) + ((((BYTECODE *)((pccache-1)))->code)));			   fn_num_args = entry68k->arg_num;					   fn_opcode_size = entry68k->byte_num+1;				   fn_atom_index = entry68k->atom_name;					   fn_defcell = (DefCell *) ((LispPTR *)Defspace + (fn_atom_index) );		   fn_apply = 2 + entry68k->byte_num;    goto op_fn_common;							};	op_fn_common: ; { register struct fnhead *LOCFNCELL; register DefCell *defcell;  CClosure *closure; LispPTR closure_env = (LispPTR) 0xffffffff; {register int NEXTBLOCK = 0; defcell = fn_defcell; if( (defcell->ccodep == 0) ) if((( (* (MDStypetbl+((defcell->defpointer)>>9))) ) & 0x7ff)==13) {  closure=(CClosure *)(Lisp_world + (defcell->defpointer)); defcell=(DefCell *)closure;  if(closure->env_ptr ) {closure_env = (LispPTR) (closure->env_ptr); } }  else {  defcell = (DefCell *)((LispPTR *)Defspace + (256) ); NEXTBLOCK = 1; }  LOCFNCELL = (struct fnhead *)(Lisp_world + (defcell->defpointer)); ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->pc = ((unsigned int)(pccache-1) - (unsigned int)stateptrcache->currentfunc) + fn_opcode_size;  if ((int)((LispPTR *) cspcache) > (stateptrcache->irqcheck=(stateptrcache->irqend-((LOCFNCELL->stkmin ) << 1)))) goto check_interrupt;; { switch (fn_apply) { case 0: break;  case 1: tscache = *(--((LispPTR *) cspcache)); tscache = *(--((LispPTR *) cspcache)); break;  case 2: break;  case 3: {*(((LispPTR *) cspcache)++) = tscache; tscache = 0xE0000 | (((BYTECODE *)((pccache-1)+1))->code);}; break; case 4: {*(((LispPTR *) cspcache)++) = tscache; tscache = 0xE0000 | (((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code));}; break; default: error("Storage error: invalid UFN entry"); } if (NEXTBLOCK) {*(((LispPTR *) cspcache)++) = tscache; tscache = fn_atom_index;}; }; {register int newivar; (LispPTR *) newivar = ((LispPTR *) stateptrcache->ivar) = ((LispPTR *) cspcache)+(1-fn_num_args-NEXTBLOCK); ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->nextblock = NEXTBLOCK = (((unsigned int)(newivar) - (unsigned int)Stackspace) >>1); } *(((LispPTR *) cspcache)++) = tscache;  if( LOCFNCELL->na >= 0 ) {register int RESTARGS; RESTARGS = fn_num_args - LOCFNCELL->na; while(RESTARGS <0) { *(((LispPTR *) cspcache)++) = 0; RESTARGS++; } ((LispPTR *) cspcache) -= (RESTARGS); }   *(((LispPTR *) cspcache)++) = 0x80000000 | NEXTBLOCK; }  *((LispPTR *)((LispPTR *) cspcache)) = (0xc000 << 16) | ((((unsigned int)(((LispPTR *) stateptrcache->pvar)) - (unsigned int)Stackspace) >>1)); ((struct frameex2 *)((LispPTR *) cspcache))->fnheader = swapx(defcell->defpointer); ((DLword *) ((LispPTR *) cspcache)) += 10; ((LispPTR *) stateptrcache->pvar) = (LispPTR *) ((LispPTR *) cspcache); {register int result; register LispPTR unboundval; unboundval = (LispPTR) 0xffffffff; result = LOCFNCELL->pv; *(((LispPTR *) cspcache)++) = closure_env; *(((LispPTR *) cspcache)++) = unboundval; for (; --result >= 0;) { *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; } }  ((LispPTR *) cspcache) += 1; pccache = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1; stateptrcache->currentfunc = LOCFNCELL; {if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; };nextopcode :# 170 "../src/xc.c" switch ((((BYTECODE *)((pccache-1)))->code)) {  case 000 : ; case000: { goto op_ufn; }  case 001 : ; case001: if (((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) == 5)) { register ConsCell *DATUM68K = (ConsCell *)((Lisp_world + (tscache))); if (DATUM68K->cdr_code == 0) { tscache = ((LispPTR)((ConsCell *)(Lisp_world + (DATUM68K->car_field)))->car_field); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } else { tscache = ((LispPTR)DATUM68K->car_field); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } } else if (tscache == 0) { { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } else if ( tscache == 0114) { { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } else { goto op_ufn; }; case 002 : ; case002: if (((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) == 5)) {register ConsCell *DATUM68K = (ConsCell *)((Lisp_world + (tscache)));register int CDRCODEX = DATUM68K->cdr_code; if (CDRCODEX == 128) {  tscache = (0); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } else if (CDRCODEX> 128) {  tscache = (((tscache) & 0x0ffff00) + ((CDRCODEX & 127) << 1)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } else if (CDRCODEX == 0) {   tscache = (cdr ((LispPTR)(DATUM68K->car_field))); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } else {  tscache = ((ConsCell *)((Lisp_world + (((tscache) & 0x0ffff00) + (CDRCODEX << 1)))) )->car_field; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } } else if (tscache == 0) { { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } else { goto op_ufn; }; case 003 : ; case003: { if((DLword)(( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) != 5) tscache = 0; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 004 : ; case004: { tscache = 0xE0000 | (DLword)((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 005 : ; case005: { if((DLword)(( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) != (((BYTECODE *)((pccache-1)+1))->code)) tscache = 0; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 056 : ; case056:  case 006 : ; case006: { register int atom_index; register struct dtd *dtd68k ; atom_index = (((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code)); for(dtd68k=(struct dtd *) (DTDspace + (((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff))<<4)); atom_index != dtd68k->dtd_name ; dtd68k=(struct dtd *) (DTDspace + ((dtd68k->dtd_supertype)<<4))) { if( dtd68k->dtd_supertype == 0) { goto op_ufn; } } { { pccache += 3; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 007 : ; case007: { if ((int)(((LispPTR *) cspcache) = (LispPTR *) N_OP_unwind(((LispPTR *) cspcache), tscache, (((BYTECODE *)((pccache-1)+1))->code),  (((BYTECODE *)((pccache-1)+2))->code))) < 0) goto unwind_err; tscache = *(--((LispPTR *) cspcache)); { { pccache += 3; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; };# 188 "../src/xc.c"  case 010 : ; case010: { {  register struct fnhead *LOCFNCELL; register int defcell_word; register int NEXTBLOCK; if((defcell_word = *((int *) ((LispPTR *)Defspace + ((((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code))) ))) >= 0) {  fn_defcell = (DefCell *) ((LispPTR *)Defspace + ((((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code))) ); fn_num_args = 0; fn_opcode_size = 3; fn_atom_index = (((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code)); fn_apply = 0; goto op_fn_common; } LOCFNCELL = (struct fnhead *)(Lisp_world + ((defcell_word &= 0xffffff))); ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->pc = ((unsigned int)(pccache-1) - (unsigned int)stateptrcache->currentfunc) + 3; ; if ((int)((LispPTR *) cspcache) > (stateptrcache->irqcheck=(stateptrcache->irqend-((LOCFNCELL->stkmin ) << 1)))) goto check_interrupt;; {register int newivar; (LispPTR *) newivar = ((LispPTR *) stateptrcache->ivar) = ((LispPTR *) cspcache)-0+1; ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->nextblock = NEXTBLOCK = (((unsigned int)(newivar) - (unsigned int)Stackspace) >>1); } *(((LispPTR *) cspcache)++) = tscache;  if( LOCFNCELL->na >= 0 ) {register int RESTARGS; RESTARGS = 0 - LOCFNCELL->na; while(RESTARGS <0) { *(((LispPTR *) cspcache)++) = 0; RESTARGS++; } ((LispPTR *) cspcache) -= (RESTARGS); }   *(((LispPTR *) cspcache)++) = 0x80000000 | NEXTBLOCK; *((LispPTR *)((LispPTR *) cspcache)) = (0xc000 << 16) | ((((unsigned int)(((LispPTR *) stateptrcache->pvar)) - (unsigned int)Stackspace) >>1)); ((struct frameex2 *)((LispPTR *) cspcache))->fnheader = swapx(defcell_word); ((DLword *) ((LispPTR *) cspcache)) += 10; ((LispPTR *) stateptrcache->pvar) = (LispPTR *) ((LispPTR *) cspcache); {register int result; result = LOCFNCELL->pv; if (result >= 0) {register LispPTR unboundval; unboundval = (LispPTR) 0xffffffff; *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; if (result > 0) {*(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; result-=1; for (; --result >= 0;) { *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; } } } } ((LispPTR *) cspcache) += 1; pccache = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1; stateptrcache->currentfunc = LOCFNCELL; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };# 194 "../src/xc.c"  case 011 : ; case011: { {  register struct fnhead *LOCFNCELL; register int defcell_word; register int NEXTBLOCK; if((defcell_word = *((int *) ((LispPTR *)Defspace + ((((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code))) ))) >= 0) {  fn_defcell = (DefCell *) ((LispPTR *)Defspace + ((((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code))) ); fn_num_args = 1; fn_opcode_size = 3; fn_atom_index = (((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code)); fn_apply = 0; goto op_fn_common; } LOCFNCELL = (struct fnhead *)(Lisp_world + ((defcell_word &= 0xffffff))); ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->pc = ((unsigned int)(pccache-1) - (unsigned int)stateptrcache->currentfunc) + 3; ; if ((int)((LispPTR *) cspcache) > (stateptrcache->irqcheck=(stateptrcache->irqend-((LOCFNCELL->stkmin ) << 1)))) goto check_interrupt;; {register int newivar; (LispPTR *) newivar = ((LispPTR *) stateptrcache->ivar) = ((LispPTR *) cspcache)-1+1; ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->nextblock = NEXTBLOCK = (((unsigned int)(newivar) - (unsigned int)Stackspace) >>1); } *(((LispPTR *) cspcache)++) = tscache;  if( LOCFNCELL->na >= 0 ) {register int RESTARGS; RESTARGS = 1 - LOCFNCELL->na; while(RESTARGS <0) { *(((LispPTR *) cspcache)++) = 0; RESTARGS++; } ((LispPTR *) cspcache) -= (RESTARGS); }   *(((LispPTR *) cspcache)++) = 0x80000000 | NEXTBLOCK; *((LispPTR *)((LispPTR *) cspcache)) = (0xc000 << 16) | ((((unsigned int)(((LispPTR *) stateptrcache->pvar)) - (unsigned int)Stackspace) >>1)); ((struct frameex2 *)((LispPTR *) cspcache))->fnheader = swapx(defcell_word); ((DLword *) ((LispPTR *) cspcache)) += 10; ((LispPTR *) stateptrcache->pvar) = (LispPTR *) ((LispPTR *) cspcache); {register int result; result = LOCFNCELL->pv; if (result >= 0) {register LispPTR unboundval; unboundval = (LispPTR) 0xffffffff; *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; if (result > 0) {*(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; result-=1; for (; --result >= 0;) { *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; } } } } ((LispPTR *) cspcache) += 1; pccache = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1; stateptrcache->currentfunc = LOCFNCELL; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };# 200 "../src/xc.c"  case 012 : ; case012: { {  register struct fnhead *LOCFNCELL; register int defcell_word; register int NEXTBLOCK; if((defcell_word = *((int *) ((LispPTR *)Defspace + ((((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code))) ))) >= 0) {  fn_defcell = (DefCell *) ((LispPTR *)Defspace + ((((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code))) ); fn_num_args = 2; fn_opcode_size = 3; fn_atom_index = (((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code)); fn_apply = 0; goto op_fn_common; } LOCFNCELL = (struct fnhead *)(Lisp_world + ((defcell_word &= 0xffffff))); ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->pc = ((unsigned int)(pccache-1) - (unsigned int)stateptrcache->currentfunc) + 3; ; if ((int)((LispPTR *) cspcache) > (stateptrcache->irqcheck=(stateptrcache->irqend-((LOCFNCELL->stkmin ) << 1)))) goto check_interrupt;; {register int newivar; (LispPTR *) newivar = ((LispPTR *) stateptrcache->ivar) = ((LispPTR *) cspcache)-2+1; ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->nextblock = NEXTBLOCK = (((unsigned int)(newivar) - (unsigned int)Stackspace) >>1); } *(((LispPTR *) cspcache)++) = tscache;  if( LOCFNCELL->na >= 0 ) {register int RESTARGS; RESTARGS = 2 - LOCFNCELL->na; while(RESTARGS <0) { *(((LispPTR *) cspcache)++) = 0; RESTARGS++; } ((LispPTR *) cspcache) -= (RESTARGS); }   *(((LispPTR *) cspcache)++) = 0x80000000 | NEXTBLOCK; *((LispPTR *)((LispPTR *) cspcache)) = (0xc000 << 16) | ((((unsigned int)(((LispPTR *) stateptrcache->pvar)) - (unsigned int)Stackspace) >>1)); ((struct frameex2 *)((LispPTR *) cspcache))->fnheader = swapx(defcell_word); ((DLword *) ((LispPTR *) cspcache)) += 10; ((LispPTR *) stateptrcache->pvar) = (LispPTR *) ((LispPTR *) cspcache); {register int result; result = LOCFNCELL->pv; if (result >= 0) {register LispPTR unboundval; unboundval = (LispPTR) 0xffffffff; *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; if (result > 0) {*(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; result-=1; for (; --result >= 0;) { *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; } } } } ((LispPTR *) cspcache) += 1; pccache = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1; stateptrcache->currentfunc = LOCFNCELL; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };# 206 "../src/xc.c"  case 013 : ; case013: { {  register struct fnhead *LOCFNCELL; register int defcell_word; register int NEXTBLOCK; if((defcell_word = *((int *) ((LispPTR *)Defspace + ((((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code))) ))) >= 0) {  fn_defcell = (DefCell *) ((LispPTR *)Defspace + ((((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code))) ); fn_num_args = 3; fn_opcode_size = 3; fn_atom_index = (((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code)); fn_apply = 0; goto op_fn_common; } LOCFNCELL = (struct fnhead *)(Lisp_world + ((defcell_word &= 0xffffff))); ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->pc = ((unsigned int)(pccache-1) - (unsigned int)stateptrcache->currentfunc) + 3; ; if ((int)((LispPTR *) cspcache) > (stateptrcache->irqcheck=(stateptrcache->irqend-((LOCFNCELL->stkmin ) << 1)))) goto check_interrupt;; {register int newivar; (LispPTR *) newivar = ((LispPTR *) stateptrcache->ivar) = ((LispPTR *) cspcache)-3+1; ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->nextblock = NEXTBLOCK = (((unsigned int)(newivar) - (unsigned int)Stackspace) >>1); } *(((LispPTR *) cspcache)++) = tscache;  if( LOCFNCELL->na >= 0 ) {register int RESTARGS; RESTARGS = 3 - LOCFNCELL->na; while(RESTARGS <0) { *(((LispPTR *) cspcache)++) = 0; RESTARGS++; } ((LispPTR *) cspcache) -= (RESTARGS); }   *(((LispPTR *) cspcache)++) = 0x80000000 | NEXTBLOCK; *((LispPTR *)((LispPTR *) cspcache)) = (0xc000 << 16) | ((((unsigned int)(((LispPTR *) stateptrcache->pvar)) - (unsigned int)Stackspace) >>1)); ((struct frameex2 *)((LispPTR *) cspcache))->fnheader = swapx(defcell_word); ((DLword *) ((LispPTR *) cspcache)) += 10; ((LispPTR *) stateptrcache->pvar) = (LispPTR *) ((LispPTR *) cspcache); {register int result; result = LOCFNCELL->pv; if (result >= 0) {register LispPTR unboundval; unboundval = (LispPTR) 0xffffffff; *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; if (result > 0) {*(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; result-=1; for (; --result >= 0;) { *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; } } } } ((LispPTR *) cspcache) += 1; pccache = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1; stateptrcache->currentfunc = LOCFNCELL; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };# 212 "../src/xc.c"  case 014 : ; case014: { {  register struct fnhead *LOCFNCELL; register int defcell_word; register int NEXTBLOCK; if((defcell_word = *((int *) ((LispPTR *)Defspace + ((((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code))) ))) >= 0) {  fn_defcell = (DefCell *) ((LispPTR *)Defspace + ((((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code))) ); fn_num_args = 4; fn_opcode_size = 3; fn_atom_index = (((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code)); fn_apply = 0; goto op_fn_common; } LOCFNCELL = (struct fnhead *)(Lisp_world + ((defcell_word &= 0xffffff))); ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->pc = ((unsigned int)(pccache-1) - (unsigned int)stateptrcache->currentfunc) + 3; ; if ((int)((LispPTR *) cspcache) > (stateptrcache->irqcheck=(stateptrcache->irqend-((LOCFNCELL->stkmin ) << 1)))) goto check_interrupt;; {register int newivar; (LispPTR *) newivar = ((LispPTR *) stateptrcache->ivar) = ((LispPTR *) cspcache)-4+1; ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->nextblock = NEXTBLOCK = (((unsigned int)(newivar) - (unsigned int)Stackspace) >>1); } *(((LispPTR *) cspcache)++) = tscache;  if( LOCFNCELL->na >= 0 ) {register int RESTARGS; RESTARGS = 4 - LOCFNCELL->na; while(RESTARGS <0) { *(((LispPTR *) cspcache)++) = 0; RESTARGS++; } ((LispPTR *) cspcache) -= (RESTARGS); }   *(((LispPTR *) cspcache)++) = 0x80000000 | NEXTBLOCK; *((LispPTR *)((LispPTR *) cspcache)) = (0xc000 << 16) | ((((unsigned int)(((LispPTR *) stateptrcache->pvar)) - (unsigned int)Stackspace) >>1)); ((struct frameex2 *)((LispPTR *) cspcache))->fnheader = swapx(defcell_word); ((DLword *) ((LispPTR *) cspcache)) += 10; ((LispPTR *) stateptrcache->pvar) = (LispPTR *) ((LispPTR *) cspcache); {register int result; result = LOCFNCELL->pv; if (result >= 0) {register LispPTR unboundval; unboundval = (LispPTR) 0xffffffff; *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; if (result > 0) {*(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; result-=1; for (; --result >= 0;) { *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; } } } } ((LispPTR *) cspcache) += 1; pccache = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1; stateptrcache->currentfunc = LOCFNCELL; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };# 218 "../src/xc.c"  case 015 : ; case015: { { register struct fnhead *LOCFNCELL; register DefCell *defcell;  register int NEXTBLOCK; int num_args = (((BYTECODE *)((pccache-1)+1))->code); defcell = (DefCell *) ((LispPTR *)Defspace + ((((((BYTECODE *)((pccache-1)+2))->code) <<8) | (((BYTECODE *)((pccache-1)+2+1))->code))) ); if( defcell->ccodep == 0 ) { fn_defcell = defcell; fn_num_args = num_args; fn_opcode_size = 4; fn_atom_index = (((((BYTECODE *)((pccache-1)+2))->code) <<8) | (((BYTECODE *)((pccache-1)+2+1))->code)); fn_apply = 0; goto op_fn_common; } LOCFNCELL = (struct fnhead *)(Lisp_world + (defcell->defpointer)); ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->pc = ((unsigned int)(pccache-1) - (unsigned int)stateptrcache->currentfunc) + 4; ; if ((int)((LispPTR *) cspcache) > (stateptrcache->irqcheck=(stateptrcache->irqend-((LOCFNCELL->stkmin ) << 1)))) goto check_interrupt;; {register int newivar; (LispPTR *) newivar = ((LispPTR *) stateptrcache->ivar) = ((LispPTR *) cspcache)-num_args+1; ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->nextblock = NEXTBLOCK = (((unsigned int)(newivar) - (unsigned int)Stackspace) >>1); } *(((LispPTR *) cspcache)++) = tscache;  if( LOCFNCELL->na >= 0 ) {register int RESTARGS; RESTARGS = num_args - LOCFNCELL->na; while(RESTARGS <0) { *(((LispPTR *) cspcache)++) = 0; RESTARGS++; } ((LispPTR *) cspcache) -= (RESTARGS); }   *(((LispPTR *) cspcache)++) = 0x80000000 | NEXTBLOCK; *((LispPTR *)((LispPTR *) cspcache)) = (0xc000 << 16) | ((((unsigned int)(((LispPTR *) stateptrcache->pvar)) - (unsigned int)Stackspace) >>1)); ((struct frameex2 *)((LispPTR *) cspcache))->fnheader = swapx(defcell->defpointer); ((DLword *) ((LispPTR *) cspcache)) += 10; ((LispPTR *) stateptrcache->pvar) = (LispPTR *) ((LispPTR *) cspcache); {register int result; result = LOCFNCELL->pv; if (result >= 0) {register LispPTR unboundval; unboundval = (LispPTR) 0xffffffff; *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; if (result > 0) {*(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; result-=1; for (; --result >= 0;) { *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; } } } } ((LispPTR *) cspcache) += 1; pccache = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1; stateptrcache->currentfunc = LOCFNCELL; }; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; };# 224 "../src/xc.c"  case 016 : ; case016: { { if ( *((DLword *)(((LispPTR *) cspcache) - 1)) == 14 ) { fn_num_args = *((DLword *)(((LispPTR *) cspcache) - 1)+1); fn_opcode_size = 1; fn_apply = 1; fn_atom_index = tscache; if ( (0xffff0000 & tscache) == 0) { fn_defcell = (DefCell *) ((LispPTR *)Defspace + (tscache) ); goto op_fn_common; } else if ((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff)==13) { stateptrcache->tosvalue=tscache; fn_defcell = (DefCell *) &stateptrcache->tosvalue; goto op_fn_common; } else { fn_defcell = (DefCell *) ((LispPTR *)Defspace + (0) ); goto op_fn_common; } } goto op_ufn; };}; case 017 : ; case017: { { register DefCell *defcell; defcell = (DefCell *) ((LispPTR *)Defspace + (tscache & 0xffff) ); if (!( defcell->ccodep && ((tscache & 0xffff0000) == 0) && ( ( defcell->argtype == 0 ) || ( defcell->argtype == 2 ) ) ) ) goto op_ufn; }; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 020 : ; case020: { { register struct frameex2 *returnFX ; register int alink; alink = ((struct frameex2 *) ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10)))->alink; if (alink & 1) { { stateptrcache->currentpc=pccache-1; stateptrcache->tosvalue=tscache; {stateptrcache->csp = (DLword *) (((LispPTR *) cspcache)-1);}; }; if(slowreturn()) goto stackoverflow_help; { pccache=stateptrcache->currentpc+1; {((LispPTR *) cspcache) = ((LispPTR *) stateptrcache->csp)+1;}; tscache = stateptrcache->tosvalue; }; stateptrcache->irqcheck = ( (int)stateptrcache->endofstack - ((stateptrcache->currentfunc->stkmin ) << 1) ); if (((int)(((LispPTR *) cspcache)) > stateptrcache->irqcheck) || (stateptrcache->irqend <= 0)) { ; goto check_interrupt; } stateptrcache->irqend = (int) stateptrcache->endofstack; ; goto retxit; }; ((LispPTR *) cspcache) = (LispPTR *) ((LispPTR *) stateptrcache->ivar); returnFX = (struct frameex2 *) ((DLword *) (((LispPTR *) stateptrcache->pvar) = (LispPTR *) (Stackspace + (alink))) - 10); ((LispPTR *) stateptrcache->ivar) = (LispPTR *) (Stackspace + ((* ((DLword *)returnFX -1))));  pccache = returnFX->pc + (ByteCode *) (stateptrcache->currentfunc = (struct fnhead *) (Lisp_world + (swapx(returnFX->fnheader) & 0x0ffffff))) + 1; stateptrcache->irqcheck = ( (int)stateptrcache->endofstack - ((stateptrcache->currentfunc->stkmin ) << 1) ); if (((int)(((LispPTR *) cspcache)) > stateptrcache->irqcheck) || (stateptrcache->irqend <= 0)) { ; goto check_interrupt; } stateptrcache->irqend = (int) stateptrcache->endofstack; ; retxit: {} }; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; case 021 : ; case021: {register int n1; register int n2; register LispPTR *ppvar; register int i; n1 = (((BYTECODE *)((pccache-1)+1))->code) >> 4; n2 = (((BYTECODE *)((pccache-1)+1))->code) & 0xf; ppvar = (LispPTR *)((LispPTR *) stateptrcache->pvar) + 1 + (((BYTECODE *)((pccache-1)+2))->code); for(i=n1; --i >= 0;){ *--ppvar = 0; } if(n2 == 0){ *((LispPTR *) cspcache)++ = tscache; }else{ *--ppvar = tscache; for(i=1; i<n2; i++) { *--ppvar = *(--((LispPTR *) cspcache)); } } i = ~(n1 + n2); tscache = (i<<16) | ((((BYTECODE *)((pccache-1)+2))->code)<<1); { { pccache += 3; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 022 : ; case022: {register int num; register LispPTR *ppvar; register int i; register LispPTR value; for(; ( ((int)*--((LispPTR *) cspcache)) >= 0 );); value = *((LispPTR *) cspcache); num = (~value)>>16; ppvar = (LispPTR *)((DLword *)((LispPTR *) stateptrcache->pvar) + 2 + ((DLword)(value))); for(i=num; --i >= 0;){*--ppvar = 0xffffffff;} { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 023 : ; case023: {register int num; register LispPTR *ppvar; register int i; register LispPTR value; if((int)tscache < 0){ num =(~tscache)>>16; if(num != 0){ ppvar = (LispPTR *)((DLword *)((LispPTR *) stateptrcache->pvar) + 2 + ((DLword)(tscache))); for(i=num; --i >= 0;) { *--ppvar = 0xffffffff; } } }else{ for(; ( ((int)*--((LispPTR *) cspcache)) >= 0 );); value = *((LispPTR *) cspcache); num = (~value)>>16; ppvar = (LispPTR *)((DLword *)((LispPTR *) stateptrcache->pvar) + 2 + ((DLword)(value))); for(i=num; --i >= 0;) { *--ppvar = 0xffffffff; } } tscache = *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 024 : ; case024: { tscache = N_OP_rplptr(*(--((LispPTR *) cspcache)), tscache, (((BYTECODE *)((pccache-1)+1))->code)); { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 025 : ; case025: {tscache = htfind(tscache, (((BYTECODE *)((pccache-1)+1))->code)); { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 026 : ; case026: {if ((int)((int)tscache = N_OP_assoc(*(--((LispPTR *) cspcache)), tscache)) < 0) goto exception_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 027 : ; case027: { N_OP_gvar_(tscache, (((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code))); { { pccache += 3; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 030 : ; case030: {if ((int)((int)tscache = N_OP_rplaca(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 031 : ; case031: {if ((int)((int)tscache = N_OP_rplacd(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 032 : ; case032: { tscache = N_OP_cons(*(--((LispPTR *) cspcache)), tscache); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 033 : ; case033: {if ((int)((int)tscache = N_OP_classoc(*(--((LispPTR *) cspcache)), tscache)) < 0) goto exception_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 034 : ; case034: {if ((int)((int)tscache = N_OP_fmemb(*(--((LispPTR *) cspcache)), tscache)) < 0) goto exception_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 035 : ; case035: {if ((int)((int)tscache = N_OP_clfmemb(*(--((LispPTR *) cspcache)), tscache)) < 0) goto exception_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 036 : ; case036: { tscache = N_OP_findkey(tscache, (((BYTECODE *)((pccache-1)+1))->code)); { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 037 : ; case037: {if ((int)((int)tscache = N_OP_createcell(tscache)) < 0) goto fix_tos_ufn; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 040 : ; case040: { register Stream *stream68k;  register char *buff68k;  if ( (( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) == 11 ) { stream68k=(Stream *) (Lisp_world + (tscache)); if( ( !stream68k->BINABLE ) || ( stream68k->COFFSET >= stream68k->CBUFSIZE ) ) goto op_ufn;  buff68k =(char *)(Lisp_world + (stream68k->CBUFPTR));  tscache = (0xE0000 | ((((BYTECODE *)(buff68k + (stream68k->COFFSET)++))->code)) ); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } else goto op_ufn; }; case 041 : ; case041: { goto op_ufn; }  case 042 : ; case042: { goto op_ufn; }  case 043 : ; case043: {tscache = N_OP_restlist(*(--((LispPTR *) cspcache)), tscache, (((BYTECODE *)((pccache-1)+1))->code)); { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 044 : ; case044: { { stateptrcache->currentpc=pccache-1; stateptrcache->tosvalue=tscache; {stateptrcache->csp = (DLword *) (((LispPTR *) cspcache)-1);}; }; if (OP_miscn()) { { pccache=stateptrcache->currentpc+1; {((LispPTR *) cspcache) = ((LispPTR *) stateptrcache->csp)+1;}; tscache = stateptrcache->tosvalue; };  goto op_ufn; } { pccache=stateptrcache->currentpc+1; {((LispPTR *) cspcache) = ((LispPTR *) stateptrcache->csp)+1;}; tscache = stateptrcache->tosvalue; }; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; case 045 : ; case045: { goto op_ufn; }   case 046 : ; case046: {if ((int)((int)tscache = N_OP_rplcons(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 047 : ; case047: {if ((int)((int)tscache = N_OP_listget(*(--((LispPTR *) cspcache)), tscache)) < 0) goto exception_2C; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 050 : ; case050: { goto op_ufn; }   case 051 : ; case051: { goto op_ufn; }   case 052 : ; case052: { goto op_ufn; }   case 053 : ; case053: { goto op_ufn; }   case 054 : ; case054: { LispPTR scratch; register LispPTR work; register LispPTR lookuped;  switch(tscache & 0x0ff0000) { case 0xE0000 : case 0xF0000 : { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; case 0x00000 : if((tscache==0)||(tscache==0114)) goto Hack_Label; nnewframe(((struct frameex1 *)(((DLword *) stateptrcache->pvar) - 10)),&scratch,tscache & 0xffff); work = ((scratch & 0xffff0000)>> 16) | ((scratch & 0x00ff) <<16); lookuped = *((LispPTR *)((Lisp_world + (work)))); if(lookuped==1) goto op_ufn; tscache = lookuped; Hack_Label: { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; default : switch((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff)){ case 2 : case 3 : case 7 : case 14 : case 16 : { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; case 5 : fn_atom_index = 248; fn_num_args = 1; fn_opcode_size = 1; fn_defcell = (DefCell *) ((LispPTR *)Defspace + (248) ); fn_apply = 0; goto op_fn_common; default : goto op_ufn; } }  };# 262 "../src/xc.c"  case 055 : ; case055: { { register struct fnhead *LOCFNCELL; register int NEXTBLOCK; register LispPTR closure_env = tscache; register int num_args; register LispPTR Fn_DefCell= *(((LispPTR *) cspcache) - 1); LOCFNCELL = (struct fnhead *)(Lisp_world + (Fn_DefCell)); {  num_args = *(((LispPTR *) cspcache) - 2);  switch(0xFFFF0000 &  num_args){ case 0xE0000:  num_args = 0xFFFF & ( num_args); break; case 0xF0000:  num_args = 0xFFFF0000 | ( num_args); break; default: if ((( (* (MDStypetbl+((  num_args )>>9))) ) & 0x7ff) != 2) { goto  op_ufn; }  num_args = *((int *)(Lisp_world + ( num_args))); } }; ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->pc = ((unsigned int)(pccache-1) - (unsigned int)stateptrcache->currentfunc) + 1; ; if ((int)((LispPTR *) cspcache) > (stateptrcache->irqcheck=(stateptrcache->irqend-((LOCFNCELL->stkmin ) << 1)))) goto check_interrupt;; ((LispPTR *) cspcache) -= 2; {register int newivar; (LispPTR *) newivar = ((LispPTR *) stateptrcache->ivar) = ((LispPTR *) cspcache)-num_args; ((struct frameex2 *)((DLword *) ((LispPTR *) stateptrcache->pvar) - 10))->nextblock = NEXTBLOCK = (((unsigned int)(newivar) - (unsigned int)Stackspace) >>1); } if( LOCFNCELL->na >= 0 ) {register int RESTARGS; RESTARGS = num_args - LOCFNCELL->na; while(RESTARGS <0) { *(((LispPTR *) cspcache)++) = 0; RESTARGS++; } ((LispPTR *) cspcache) -= (RESTARGS); }   *(((LispPTR *) cspcache)++) = 0x80000000 | NEXTBLOCK; *((LispPTR *)((LispPTR *) cspcache)) = (0xc000 << 16) | ((((unsigned int)(((LispPTR *) stateptrcache->pvar)) - (unsigned int)Stackspace) >>1)); ((struct frameex2 *)((LispPTR *) cspcache))->fnheader = swapx(Fn_DefCell); ((DLword *) ((LispPTR *) cspcache)) += 10; ((LispPTR *) stateptrcache->pvar) = (LispPTR *) ((LispPTR *) cspcache); {register int result; result = LOCFNCELL->pv; if (result >= 0) {register LispPTR unboundval; unboundval = (LispPTR) 0xffffffff; if (closure_env == 0) *(((LispPTR *) cspcache)++) = unboundval; else *(((LispPTR *) cspcache)++) = closure_env; *(((LispPTR *) cspcache)++) = unboundval; if (result > 0) {*(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; result-=1; for (; --result >= 0;) { *(((LispPTR *) cspcache)++) = unboundval; *(((LispPTR *) cspcache)++) = unboundval; } } } } ((LispPTR *) cspcache) += 1; pccache = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1; stateptrcache->currentfunc = LOCFNCELL; }; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; case 057 : ; case057: {tscache = N_OP_stkscan(tscache); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 060 : ; case060: { goto op_ufn; }  case 061 : ; case061: { goto op_ufn; }  case 062 : ; case062: {tscache = N_OP_ubfloat3(*(((LispPTR *) cspcache)-2), *(((LispPTR *) cspcache)-1), tscache,  (((BYTECODE *)((pccache-1)+1))->code)); if (stateptrcache->errorexit) goto fix_tos_ufn; ((LispPTR *) cspcache) -= 2; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 063 : ; case063: { if( ( ((DLword)( (* (MDStypetbl+((tscache)>>9))) )) & ( (DLword)(((BYTECODE *)((pccache-1)+1))->code) << 8)) == 0) tscache = 0; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 064 : ; case064: { goto op_ufn; }  case 065 : ; case065: { goto op_ufn; }  case 066 : ; case066: { goto op_ufn; }  case 067 : ; case067: { goto op_ufn; }  case 070 : ; case070: {if ((int)((int)tscache = N_OP_misc7( *(((LispPTR *) cspcache)-6), *(((LispPTR *) cspcache)-5), *(((LispPTR *) cspcache)-4), *(((LispPTR *) cspcache)-3), *(((LispPTR *) cspcache)-2), *(((LispPTR *) cspcache)-1), tscache,  (((BYTECODE *)((pccache-1)+1))->code))) < 0) goto fix_tos_ufn; ((LispPTR *) cspcache) -= 6; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;};	    case 071 : ; case071: { goto op_ufn; }  case 072 : ; case072: {if ((int)((int)tscache = N_OP_eqlop(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 073 : ; case073: {if ((int)((int)tscache = N_OP_drawline( *(((LispPTR *) cspcache)-8), *(((LispPTR *) cspcache)-7), *(((LispPTR *) cspcache)-6), *(((LispPTR *) cspcache)-5), *(((LispPTR *) cspcache)-4), *(((LispPTR *) cspcache)-3), *(((LispPTR *) cspcache)-2), *(((LispPTR *) cspcache)-1), tscache, fix_tos_ufn)) < 0) goto fix_tos_ufn; ((LispPTR *) cspcache) -= 8; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 074 : ; case074: { *(((LispPTR *) cspcache) - (((((BYTECODE *)((pccache-1)+1))->code)+2) >> 1)) = tscache; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 075 : ; case075: { {*(((LispPTR *) cspcache)++) = tscache; tscache = *(((LispPTR *) cspcache) - (((((BYTECODE *)((pccache-1)+1))->code)+2) >> 1));}; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 076 : ; case076: { goto op_ufn; }  case 077 : ; case077: { goto op_ufn; }  case 0100 : ; case100:  { register LispPTR *var = (LispPTR *)stateptrcache->ivar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 0); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };   case 0101 : ; case101:  { register LispPTR *var = (LispPTR *)stateptrcache->ivar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 1); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };   case 0102 : ; case102:  { register LispPTR *var = (LispPTR *)stateptrcache->ivar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 2); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };   case 0103 : ; case103:  { register LispPTR *var = (LispPTR *)stateptrcache->ivar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 3); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };   case 0104 : ; case104:  { register LispPTR *var = (LispPTR *)stateptrcache->ivar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 4); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };   case 0105 : ; case105:  { register LispPTR *var = (LispPTR *)stateptrcache->ivar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 5); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };   case 0106 : ; case106:  { register LispPTR *var = (LispPTR *)stateptrcache->ivar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 6); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };    case 0107 : ; case107:  { {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((DLword *)((LispPTR *) stateptrcache->ivar) + (((BYTECODE *)((pccache-1)+1))->code))));}; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; };    case 0110 : ; case110:  { register LispPTR *var = (LispPTR *)stateptrcache->pvar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 0); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };   case 0111 : ; case111:  { register LispPTR *var = (LispPTR *)stateptrcache->pvar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 1); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };  case 0112 : ; case112:  { register LispPTR *var = (LispPTR *)stateptrcache->pvar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 2); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };   case 0113 : ; case113:  { register LispPTR *var = (LispPTR *)stateptrcache->pvar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 3); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };   case 0114 : ; case114:  { register LispPTR *var = (LispPTR *)stateptrcache->pvar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 4); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };   case 0115 : ; case115:  { register LispPTR *var = (LispPTR *)stateptrcache->pvar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 5); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };   case 0116 : ; case116:  { register LispPTR *var = (LispPTR *)stateptrcache->pvar; *(((LispPTR *) cspcache)++) = tscache; {register unsigned char opcode; opcode = *(unsigned char *)((pccache-1)+1); tscache = *(var + 6); pccache += 1; fast_dispatcher(table, opcode);} goto nextopcode; };     case 0117 : ; case117: { {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((DLword *)((LispPTR *) stateptrcache->pvar) + (((BYTECODE *)((pccache-1)+1))->code))));}; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0120 : ; case120: { register LispPTR *chain; chain = (LispPTR *) (stateptrcache->pvar + 0); if(((WBITS *) (chain))->LSB){ {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + ( 0xFFFFFF & swapx(native_newframe(0 >> 1)))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + (0xFFFFFF & swapx(*chain))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0121 : ; case121: { register LispPTR *chain; chain = (LispPTR *) (stateptrcache->pvar + 2); if(((WBITS *) (chain))->LSB){ {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + ( 0xFFFFFF & swapx(native_newframe(2 >> 1)))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + (0xFFFFFF & swapx(*chain))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0122 : ; case122: { register LispPTR *chain; chain = (LispPTR *) (stateptrcache->pvar + 4); if(((WBITS *) (chain))->LSB){ {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + ( 0xFFFFFF & swapx(native_newframe(4 >> 1)))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + (0xFFFFFF & swapx(*chain))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0123 : ; case123: { register LispPTR *chain; chain = (LispPTR *) (stateptrcache->pvar + 6); if(((WBITS *) (chain))->LSB){ {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + ( 0xFFFFFF & swapx(native_newframe(6 >> 1)))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + (0xFFFFFF & swapx(*chain))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0124 : ; case124: { register LispPTR *chain; chain = (LispPTR *) (stateptrcache->pvar + 8); if(((WBITS *) (chain))->LSB){ {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + ( 0xFFFFFF & swapx(native_newframe(8 >> 1)))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + (0xFFFFFF & swapx(*chain))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0125 : ; case125: { register LispPTR *chain; chain = (LispPTR *) (stateptrcache->pvar + 10); if(((WBITS *) (chain))->LSB){ {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + ( 0xFFFFFF & swapx(native_newframe(10 >> 1)))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + (0xFFFFFF & swapx(*chain))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0126 : ; case126: { register LispPTR *chain; chain = (LispPTR *) (stateptrcache->pvar + 12); if(((WBITS *) (chain))->LSB){ {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + ( 0xFFFFFF & swapx(native_newframe(12 >> 1)))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + (0xFFFFFF & swapx(*chain))))));}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0127 : ; case127: { register LispPTR *chain; chain = (LispPTR *) (stateptrcache->pvar + (((BYTECODE *)((pccache-1)+1))->code)); if(((WBITS *) (chain))->LSB){ {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + ( 0xFFFFFF & swapx(native_newframe((((BYTECODE *)((pccache-1)+1))->code) >> 1)))))));}; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) ((Lisp_world + (0xFFFFFF & swapx(*chain))))));}; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; };		 case 0130 : ; case130: {((LispPTR *) stateptrcache->pvar)[0] = tscache; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };};  case 0131 : ; case131: {((LispPTR *) stateptrcache->pvar)[1] = tscache; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };};  case 0132 : ; case132: {((LispPTR *) stateptrcache->pvar)[2] = tscache; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0133 : ; case133: {((LispPTR *) stateptrcache->pvar)[3] = tscache; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };};  case 0134 : ; case134: {((LispPTR *) stateptrcache->pvar)[4] = tscache; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };};  case 0135 : ; case135: {((LispPTR *) stateptrcache->pvar)[5] = tscache; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };};  case 0136 : ; case136: {((LispPTR *) stateptrcache->pvar)[6] = tscache; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };};  case 0137 : ; case137: { *((LispPTR *)((DLword *)((LispPTR *) stateptrcache->pvar)+(((BYTECODE *)((pccache-1)+1))->code)))=tscache; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };};  case 0140 : ; case140: { {*(((LispPTR *) cspcache)++) = tscache; tscache = (*((int *) (Valspace + ((((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code))<<1))));}; { { pccache += 3; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0141 : ; case141: {if ((int)((int)tscache = N_OP_arg0(tscache)) < 0) goto fix_tos_ufn; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0142 : ; case142: { *((LispPTR *)((DLword *)((LispPTR *) stateptrcache->ivar)+(((BYTECODE *)((pccache-1)+1))->code)))=tscache; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0143 : ; case143: {tscache = N_OP_fvar_(tscache, (((BYTECODE *)((pccache-1)+1))->code)); { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0144 : ; case144: { *(((LispPTR *) cspcache)++) = tscache; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0145 : ; case145: { register int arg_num; if (( ((struct frameex1 *)(((DLword *) stateptrcache->pvar) - 10))->alink & 1) == 0) arg_num = (int)((LispPTR *)(((struct frameex1 *)(((DLword *) stateptrcache->pvar) - 10))) - 1); else arg_num = (int)(Stackspace + ((struct frameex1 *)(((DLword *) stateptrcache->pvar) - 10))->blink); {*(((LispPTR *) cspcache)++) = tscache; tscache =  (DLword)((arg_num - (int)stateptrcache->ivar) >> 2) | 0xE0000;}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0146 : ; case146: { {*(((LispPTR *) cspcache)++) = tscache; tscache = ((( ((struct frameex1 *)(((DLword *) stateptrcache->pvar) - 10))->alink) & 0xfffe)-10) | 0xE0000;}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0147 : ; case147: { {*(((LispPTR *) cspcache)++) = tscache; tscache = (((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code));}; { { pccache += 3; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };} case 0150 : ; case150: { {{*(((LispPTR *) cspcache)++) = tscache; tscache = 0     ;}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; } case 0151 : ; case151: { {{*(((LispPTR *) cspcache)++) = tscache; tscache = 0114      ;}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; } case 0152 : ; case152: { {{*(((LispPTR *) cspcache)++) = tscache; tscache = 0xE0000  ;}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; }  case 0153 : ; case153: { {{*(((LispPTR *) cspcache)++) = tscache; tscache = 0xE0001     ;}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; }  case 0154 : ; case154: {	 		{*(((LispPTR *) cspcache)++) = tscache; tscache = 0xE0000 | (((BYTECODE *)((pccache-1)+1))->code);}; 		{ { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };		} case 0155 : ; case155: { 			{*(((LispPTR *) cspcache)++) = tscache; tscache = 0xF0000 | 0xff00 | (((BYTECODE *)((pccache-1)+1))->code);}; 		{ { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };		} case 0156 : ; case156:{ 	 		{*(((LispPTR *) cspcache)++) = tscache; tscache = 0xE0000 | (((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code));}; 		{ { pccache += 3; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };		} case 0157 : ; case157: {		# 361 "../src/xc.c" {*(((LispPTR *) cspcache)++) = tscache; tscache = 	((((BYTECODE *)((pccache-1) + 1))->code) << 16) |  			((((BYTECODE *)((pccache-1) + 2))->code) << 8) |  			(((BYTECODE *)((pccache-1) +  3))->code);};		{ { pccache += 4; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };		}  case 0160 : ; case160: { goto op_ufn; }  case 0161 : ; case161: { goto op_ufn; }  case 0162 : ; case162: { goto op_ufn; }  case 0163 : ; case163: { goto op_ufn; }  case 0164 : ; case164: { goto op_ufn; }  case 0165 : ; case165: { goto op_ufn; }  case 0166 : ; case166: {tscache = N_OP_pilotbitblt(*(--((LispPTR *) cspcache)), tscache); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0167 : ; case167: { tscache = N_OP_rclk(tscache); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0170 : ; case170: { goto op_ufn; }  case 0171 : ; case171: { goto op_ufn; }  case 0172 : ; case172: { goto op_ufn; }; case 0173 : ; case173: { tscache=gcscan1(tscache & 0xffff); if (tscache) {tscache |= 0xE0000; };{ { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0174 : ; case174: { tscache=gcscan2(tscache & 0xffff); if (tscache) {tscache |=0xE0000; };{ { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0175 : ; case175: { { stateptrcache->currentpc=pccache-1; stateptrcache->tosvalue=tscache; {stateptrcache->csp = (DLword *) (((LispPTR *) cspcache)-1);}; }; OP_subrcall(); { pccache=stateptrcache->currentpc+1; {((LispPTR *) cspcache) = ((LispPTR *) stateptrcache->csp)+1;}; tscache = stateptrcache->tosvalue; }; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; case 0176 : ; case176: { { { stateptrcache->currentpc=pccache-1; stateptrcache->tosvalue=tscache; {stateptrcache->csp = (DLword *) (((LispPTR *) cspcache)-1);}; }; OP_contextsw(); { pccache=stateptrcache->currentpc+1; {((LispPTR *) cspcache) = ((LispPTR *) stateptrcache->csp)+1;}; tscache = stateptrcache->tosvalue; };  {stateptrcache->irqcheck = ( (int)(stateptrcache->irqend = (int) stateptrcache->endofstack) - (( stateptrcache->currentfunc->stkmin ) << 1) ); }; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; } case 0177 : ; case177: { goto op_ufn; }  case 0200 : ; case200: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0201 : ; case201: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 3; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0202 : ; case202: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 4; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0203 : ; case203: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 5; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0204 : ; case204: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 6; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0205 : ; case205: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 7; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0206 : ; case206: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 8; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0207 : ; case207: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 9; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0210 : ; case210: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 10; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0211 : ; case211: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 11; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0212 : ; case212: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 12; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0213 : ; case213: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 13; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0214 : ; case214: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 14; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0215 : ; case215: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 15; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0216 : ; case216: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 16; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0217 : ; case217: { {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; pccache += 17; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };}; } case 0220 : ; case220: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0221 : ; case221: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 3; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0222 : ; case222: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 4; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0223 : ; case223: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 5; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0224 : ; case224: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 6; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0225 : ; case225: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 7; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0226 : ; case226: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 8; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0227 : ; case227: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 9; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0230 : ; case230: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 10; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0231 : ; case231: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 11; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0232 : ; case232: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 12; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0233 : ; case233: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 13; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0234 : ; case234: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 14; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0235 : ; case235: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 15; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0236 : ; case236: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 16; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0237 : ; case237: { {if(tscache != 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 17; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0240 : ; case240: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0241 : ; case241: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 3; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0242 : ; case242: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 4; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0243 : ; case243: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 5; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0244 : ; case244: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 6; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0245 : ; case245: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 7; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0246 : ; case246: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 8; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0247 : ; case247: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 9; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0250 : ; case250: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 10; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0251 : ; case251: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 11; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0252 : ; case252: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 12; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0253 : ; case253: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 13; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0254 : ; case254: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 14; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0255 : ; case255: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 15; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0256 : ; case256: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 16; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0257 : ; case257: { {if(tscache == 0) {goto PopNextop1 ; } {{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;}; tscache = *(--((LispPTR *) cspcache)); pccache += 17; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };} }; } case 0260 : ; case260: {		{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;};		pccache += (* ((pccache-1)+1)); { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; 		} case 0261 : ; case261: {		{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;};		pccache += ((* ((pccache-1)+1))<<8) | (((BYTECODE *)((pccache-1)+2))->code); { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; 		} case 0262 : ; case262: {    if(tscache != 0) {goto PopNextop2;}	{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;};	tscache = *(--((LispPTR *) cspcache));	pccache += (* ((pccache-1)+1));	{ fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; 	} case 0263 : ; case263: {	if(tscache == 0) {goto PopNextop2;}	{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;};	tscache = *(--((LispPTR *) cspcache));	pccache += (* ((pccache-1)+1));	{ fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; 	} case 0264 : ; case264: {	if(tscache != 0) {goto PopNextop2;}	{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;};	pccache += (* ((pccache-1)+1));	{ fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; 	} case 0265 : ; case265: {	if(tscache == 0) {goto PopNextop2;}	{if((int)((LispPTR *) cspcache) > stateptrcache->irqcheck) goto check_interrupt;};	pccache += (* ((pccache-1)+1));	{ fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; 	} case 0266 : ; case266:	{ LispPTR arrayarg; register LispPTR baseL; register int index; register OneDArray *arrayblk; DLword *createcell68k(); ; arrayarg = *(--((LispPTR *) cspcache)); if ((( (* (MDStypetbl+((arrayarg)>>9))) ) & 0x7ff) != 14) goto aref_ufn; arrayblk = (OneDArray *)(Lisp_world + (arrayarg)); if ((tscache & 0xFFFF0000) != 0xE0000) goto aref_ufn; index = tscache & 0xFFFF; if (index >= arrayblk->totalsize) goto aref_ufn; index += arrayblk->offset; baseL = arrayblk->base; switch (arrayblk->typenumber) { case 38:  tscache = *(((int *)(Lisp_world + (baseL))) + index); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; case 20:  tscache = ((* (((DLword *)(Lisp_world + (baseL))) + index))) & 0xFFFF; if (tscache & 0x8000) tscache |= 0xF0000; else tscache |= 0xE0000; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; case 67:  tscache = 0x70000 | (((* (((char *)(Lisp_world + (baseL))) + index))) & 0xFF); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; case 22:  tscache = *(((int *)(Lisp_world + (baseL))) + index); switch(tscache & 0xFFFF0000){ case 0: tscache |= 0xE0000; break; case (unsigned)0xFFFF0000: tscache &= 0xF0000; break; default:{register DLword *wordp; wordp = createcell68k(2); *((int *)wordp) = tscache; (LispPTR)tscache = (((unsigned int)(wordp) - (unsigned int)Lisp_world) >>1); } } { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; case 0:  tscache = 0xE0000 | ((((* (((char *)(Lisp_world + (baseL))) + (index >> 3)))) >> (7 - (index & 7))) & 1); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; case 3:  tscache = 0xE0000 | (((* (((char *)(Lisp_world + (baseL))) + index))) & 0xFF); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; case 4:  tscache = 0xE0000 | (((* (((DLword *)(Lisp_world + (baseL))) + index))) & 0xFFFF); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; case 54: {register DLword *wordp; wordp = createcell68k(3); *((int *)wordp) = *(((int *)(Lisp_world + (baseL))) + index); (LispPTR)tscache = (((unsigned int)(wordp) - (unsigned int)Lisp_world) >>1); } { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; case 68:  tscache = 0x70000 | (((* (((DLword *)(Lisp_world + (baseL))) + index))) & 0xFFFF); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; case 86:  tscache = *(((int *)(Lisp_world + (baseL))) + index); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; default:  goto aref_ufn; } aref_ufn: if ((int)((int)tscache = N_OP_aref1( arrayarg, tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };; }; case 0267 : ; case267:	{if ((int)((int)tscache = N_OP_aset1( *(((LispPTR *) cspcache)-2), *(((LispPTR *) cspcache)-1), tscache)) < 0) goto fix_tos_ufn; ((LispPTR *) cspcache) -= 2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0270 : ; case270:	{((LispPTR *) stateptrcache->pvar)[0] = tscache; tscache = *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0271 : ; case271:	{((LispPTR *) stateptrcache->pvar)[1] = tscache; tscache = *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0272 : ; case272:	{((LispPTR *) stateptrcache->pvar)[2] = tscache; tscache = *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0273 : ; case273:	{((LispPTR *) stateptrcache->pvar)[3] = tscache; tscache = *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0274 : ; case274:	{((LispPTR *) stateptrcache->pvar)[4] = tscache; tscache = *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0275 : ; case275:	{((LispPTR *) stateptrcache->pvar)[5] = tscache; tscache = *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0276 : ; case276:	{((LispPTR *) stateptrcache->pvar)[6] = tscache; tscache = *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0277 : ; case277: 	{ tscache = *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; } case 0300 : ; case300:  {tscache = *(((LispPTR *) cspcache) -= (((((BYTECODE *)((pccache-1)+1))->code))+1)); { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0301 : ; case301: 	{if ((unsigned int)tscache >> 16) {goto op_ufn;} tscache = ((((BYTECODE *)((pccache-1)+1))->code) << 16) + (tscache << 1) ; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0302 : ; case302: 	{switch( (0xFFFF0000 & tscache) ){ case 0xE0000: tscache &= 0x0000FFFF; break; case 0xF0000: tscache |= 0xFFFF0000; break; default: if( (( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) == 2 ) tscache = *((int *)(Lisp_world + (tscache))); else goto op_ufn; } tscache = (0xFF & ((* ((char*)(Lisp_world + ((0xFFFFFF & (*(--((LispPTR *) cspcache)))))) + tscache)))) | 0xE0000; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0303 : ; case303:  { tscache = N_OP_instancep(tscache,(((((BYTECODE *)((pccache-1)+1))->code) <<8) | (((BYTECODE *)((pccache-1)+1+1))->code))); { { pccache += 3; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0304 : ; case304:  {if ((int)((int)tscache = N_OP_blt( *(((LispPTR *) cspcache)-2), *(((LispPTR *) cspcache)-1), tscache)) < 0) goto fix_tos_ufn; ((LispPTR *) cspcache) -= 2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0305 : ; case305:  {goto op_ufn; }  case 0306 : ; case306:  {goto op_ufn; }  case 0307 : ; case307:	{ register int byteoffset; register char *p_data; if(((0xFFFF0000 & tscache) != 0xE0000) || ((unsigned short)tscache >= 256)) goto op_ufn; byteoffset = *(((LispPTR *) cspcache) - 1); switch( (0xFFFF0000 & byteoffset) ){ case 0xE0000: byteoffset &= 0x0000FFFF; break; case 0xF0000: byteoffset |= 0xFFFF0000; break; default: goto op_ufn;  } --((LispPTR *) cspcache); p_data = (char*)(Lisp_world + (0xFFFFFF & (*(--((LispPTR *) cspcache))))) + byteoffset; (* (p_data)) = 0xFF & tscache; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0310 : ; case310:	{ tscache = (0xE0000 | (* ((DLword *) (Lisp_world + ((0xFFFFFF & tscache) + (((BYTECODE *)((pccache-1)+1))->code)))))); { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0311 : ; case311:	{ tscache = (0xFFFFFF & *((LispPTR *) (Lisp_world + ((0xFFFFFF & tscache) + (((BYTECODE *)((pccache-1)+1))->code))))); { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0312 : ; case312:	{register int temp; temp = 0xF &  (((BYTECODE *)((pccache-1)+2))->code); tscache = 0xE0000 | (( ((* ((Lisp_world + (0xFFFFFF & (tscache+(((BYTECODE *)((pccache-1)+1))->code))))))) >> (16 - ( (0xF & ( (((BYTECODE *)((pccache-1)+2))->code) >> 4)) + temp + 1)) ) & n_mask_array[temp] ); { { pccache += 3; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0313 : ; case313:  {goto op_ufn; }  case 0314 : ; case314:	{if ((int)((int)tscache = N_OP_clequal(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0315 : ; case315:	{ register int base; if (((DLword)((tscache)>>16)) != (0xE0000 >> 16)) goto op_ufn; base = 0xffffff & *(--((LispPTR *) cspcache)); (* ((DLword *)(Lisp_world + (base + (((BYTECODE *)((pccache-1)+1))->code))))) = ((DLword)(tscache)); tscache = base; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0316 : ; case316:	{ register int base; base = 0xffffff & *(--((LispPTR *) cspcache)); *((LispPTR *)(Lisp_world + (base + (((BYTECODE *)((pccache-1)+1))->code)))) = tscache; tscache = base; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0317 : ; case317:	{ int base; register DLword *pword; register int shift_size, field_size, fmask; if( (0xFFFF0000 & tscache) != 0xE0000 ){ goto op_ufn; }; base = 0xFFFFFF & *(--((LispPTR *) cspcache)); pword = (DLword*)(Lisp_world + ( base + (((BYTECODE *)((pccache-1)+1))->code) )); field_size = 0xF &  (((BYTECODE *)((pccache-1)+2))->code); shift_size = 15 - (0xF & ( (((BYTECODE *)((pccache-1)+2))->code) >> 4)) - field_size; fmask = n_mask_array[field_size] << shift_size; (* (pword)) = ( (tscache << shift_size) & fmask) | ((* (pword)) & (~fmask)); tscache = base; { { pccache += 3; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0320 : ; case320:	{if ((int)((int)tscache = N_OP_addbase(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0321 : ; case321:	{ tscache = (*(((LispPTR *) cspcache) - 1) << 16) | (0xFFFF & tscache); ((LispPTR *) cspcache)--; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0322 : ; case322:	{ tscache = ((DLword)((tscache)>>16)) | 0xE0000; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0323 : ; case323:	{ tscache = ((DLword)(tscache)) | 0xE0000; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0324 : ; case324: 	{register int arg1, arg2, result; arg1 = *(((LispPTR *) cspcache) - 1);  if(!(((tscache) >> 17) ^ 7) && !(((arg1) >> 17) ^ 7)) { arg2 = ( ((int)tscache << 15) >> 15 ); arg1 = ( ((int)arg1 << 15) >> 15 ); result = arg1 + arg2; { if ((((result << 15) >>15) ^ result)) {register LispPTR *wordp; wordp = (LispPTR *) createcell68k(2); *((int *)wordp) = result;  tscache = ((((unsigned int)(wordp) - (unsigned int)Lisp_world) >>1)); } else  tscache = (( (unsigned)result <<15) >>15) | 0xE0000;}; *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };} if ((int)((int)tscache =  N_OP_plus2(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };; };  case 0325 : ; case325:  {register int arg1, arg2, result; arg1 = *(((LispPTR *) cspcache) - 1);  if(!(((tscache) >> 17) ^ 7) && !(((arg1) >> 17) ^ 7)) { arg2 = ( ((int)tscache << 15) >> 15 ); arg1 = ( ((int)arg1 << 15) >> 15 ); result = arg1 - arg2; { if ((((result << 15) >>15) ^ result)) {register LispPTR *wordp; wordp = (LispPTR *) createcell68k(2); *((int *)wordp) = result;  tscache = ((((unsigned int)(wordp) - (unsigned int)Lisp_world) >>1)); } else  tscache = (( (unsigned)result <<15) >>15) | 0xE0000;}; *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };} if ((int)((int)tscache =  N_OP_difference(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };; };		 case 0326 : ; case326:	{if ((int)((int)tscache = N_OP_times2(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;};  case 0327 : ; case327:  {if ((int)((int)tscache = N_OP_quot(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}  case 0330 : ; case330:  {register int arg1, arg2, result; arg1 = *(((LispPTR *) cspcache) - 1);  if(!(((tscache) >> 17) ^ 7) && !(((arg1) >> 17) ^ 7)) { arg2 = ( ((int)tscache << 15) >> 15 ); arg1 = ( ((int)arg1 << 15) >> 15 ); result = arg1 + arg2; { if ((((result << 15) >>15) ^ result)) {register LispPTR *wordp; wordp = (LispPTR *) createcell68k(2); *((int *)wordp) = result;  tscache = ((((unsigned int)(wordp) - (unsigned int)Lisp_world) >>1)); } else  tscache = (( (unsigned)result <<15) >>15) | 0xE0000;}; *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };} if ((int)((int)tscache =  N_OP_iplus2(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };; };  case 0331 : ; case331:  {register int arg1, arg2, result; arg1 = *(((LispPTR *) cspcache) - 1);  if(!(((tscache) >> 17) ^ 7) && !(((arg1) >> 17) ^ 7)) { arg2 = ( ((int)tscache << 15) >> 15 ); arg1 = ( ((int)arg1 << 15) >> 15 ); result = arg1 - arg2; { if ((((result << 15) >>15) ^ result)) {register LispPTR *wordp; wordp = (LispPTR *) createcell68k(2); *((int *)wordp) = result;  tscache = ((((unsigned int)(wordp) - (unsigned int)Lisp_world) >>1)); } else  tscache = (( (unsigned)result <<15) >>15) | 0xE0000;}; *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };} if ((int)((int)tscache =  N_OP_idifference(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };; };  case 0332 : ; case332:	{if ((int)((int)tscache = N_OP_itimes2(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;};  case 0333 : ; case333:	{if ((int)((int)tscache = N_OP_iquot(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;};  case 0334 : ; case334:	{if ((int)((int)tscache = N_OP_iremainder(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0335 : ; case335:	{if ((int)((int)tscache = N_OP_iplusn(tscache,  (((BYTECODE *)((pccache-1)+1))->code))) < 0) goto fix_tos_ufn;{ { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0336 : ; case336:	{if ((int)((int)tscache = N_OP_idifferencen(tscache,  (((BYTECODE *)((pccache-1)+1))->code))) < 0) goto fix_tos_ufn;{ { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0337 : ; case337:  { goto op_ufn; }  case 0340 : ; case340:  { register int arg, result; { if ((((tscache) >> 17) ^ 7)) if ((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg = *((int *)(Lisp_world + (tscache))); else   arg = ( ((int)tscache << 15) >> 15 );};; result = arg << 1; if ( (arg < 0)) goto op_ufn; { if ((((result << 15) >>15) ^ result)) {register LispPTR *wordp; wordp = (LispPTR *) createcell68k(2); *((int *)wordp) = result;  tscache = ((((unsigned int)(wordp) - (unsigned int)Lisp_world) >>1)); } else  tscache = (( (unsigned)result <<15) >>15) | 0xE0000;}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0341 : ; case341:  { register int arg, result; { if ((((tscache) >> 17) ^ 7)) if ((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg = *((int *)(Lisp_world + (tscache))); else   arg = ( ((int)tscache << 15) >> 15 );};; result = arg << 8; if ( ((arg >> 24)!=0)) goto op_ufn; { if ((((result << 15) >>15) ^ result)) {register LispPTR *wordp; wordp = (LispPTR *) createcell68k(2); *((int *)wordp) = result;  tscache = ((((unsigned int)(wordp) - (unsigned int)Lisp_world) >>1)); } else  tscache = (( (unsigned)result <<15) >>15) | 0xE0000;}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0342 : ; case342:  { register int arg, result; { if ((((tscache) >> 17) ^ 7)) if ((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg = *((int *)(Lisp_world + (tscache))); else   arg = ( ((int)tscache << 15) >> 15 );};; result = (unsigned)arg >> 1; if ( 0) goto op_ufn; { if ((((result << 15) >>15) ^ result)) {register LispPTR *wordp; wordp = (LispPTR *) createcell68k(2); *((int *)wordp) = result;  tscache = ((((unsigned int)(wordp) - (unsigned int)Lisp_world) >>1)); } else  tscache = (( (unsigned)result <<15) >>15) | 0xE0000;}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0343 : ; case343:  { register int arg, result; { if ((((tscache) >> 17) ^ 7)) if ((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg = *((int *)(Lisp_world + (tscache))); else   arg = ( ((int)tscache << 15) >> 15 );};; result = (unsigned)arg >> 8; if ( 0) goto op_ufn; { if ((((result << 15) >>15) ^ result)) {register LispPTR *wordp; wordp = (LispPTR *) createcell68k(2); *((int *)wordp) = result;  tscache = ((((unsigned int)(wordp) - (unsigned int)Lisp_world) >>1)); } else  tscache = (( (unsigned)result <<15) >>15) | 0xE0000;}; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0344 : ; case344:  { register int arg1, arg2, result; arg1 = *(((LispPTR *) cspcache) - 1);  { if ((((tscache) >> 17) ^ 7)) if ((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg2 = *((int *)(Lisp_world + (tscache))); else   arg2 = ( ((int)tscache << 15) >> 15 );};; { if ((((arg1) >> 17) ^ 7)) if ((( (* (MDStypetbl+((arg1)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg1 = *((int *)(Lisp_world + (arg1))); else   arg1 = ( ((int)arg1 << 15) >> 15 );};; result = arg1 | arg2; if ( 0) goto op_ufn; { if ((((result << 15) >>15) ^ result)) {register LispPTR *wordp; wordp = (LispPTR *) createcell68k(2); *((int *)wordp) = result;  tscache = ((((unsigned int)(wordp) - (unsigned int)Lisp_world) >>1)); } else  tscache = (( (unsigned)result <<15) >>15) | 0xE0000;}; *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0345 : ; case345:  { register int arg1, arg2, result; arg1 = *(((LispPTR *) cspcache) - 1);  { if ((((tscache) >> 17) ^ 7)) if ((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg2 = *((int *)(Lisp_world + (tscache))); else   arg2 = ( ((int)tscache << 15) >> 15 );};; { if ((((arg1) >> 17) ^ 7)) if ((( (* (MDStypetbl+((arg1)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg1 = *((int *)(Lisp_world + (arg1))); else   arg1 = ( ((int)arg1 << 15) >> 15 );};; result = arg1 & arg2; if ( 0) goto op_ufn; { if ((((result << 15) >>15) ^ result)) {register LispPTR *wordp; wordp = (LispPTR *) createcell68k(2); *((int *)wordp) = result;  tscache = ((((unsigned int)(wordp) - (unsigned int)Lisp_world) >>1)); } else  tscache = (( (unsigned)result <<15) >>15) | 0xE0000;}; *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0346 : ; case346:  { register int arg1, arg2, result; arg1 = *(((LispPTR *) cspcache) - 1);  { if ((((tscache) >> 17) ^ 7)) if ((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg2 = *((int *)(Lisp_world + (tscache))); else   arg2 = ( ((int)tscache << 15) >> 15 );};; { if ((((arg1) >> 17) ^ 7)) if ((( (* (MDStypetbl+((arg1)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg1 = *((int *)(Lisp_world + (arg1))); else   arg1 = ( ((int)arg1 << 15) >> 15 );};; result = arg1 ^ arg2; if ( 0) goto op_ufn; { if ((((result << 15) >>15) ^ result)) {register LispPTR *wordp; wordp = (LispPTR *) createcell68k(2); *((int *)wordp) = result;  tscache = ((((unsigned int)(wordp) - (unsigned int)Lisp_world) >>1)); } else  tscache = (( (unsigned)result <<15) >>15) | 0xE0000;}; *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0347 : ; case347:  {if ((int)((int)tscache = N_OP_lsh(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0350 : ; case350:  {if ((int)((int)tscache = N_OP_fplus2(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0351 : ; case351:  {if ((int)((int)tscache = N_OP_fdifference(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0352 : ; case352:  {if ((int)((int)tscache = N_OP_ftimes2(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0353 : ; case353:  {if ((int)((int)tscache = N_OP_fquotient(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0354 : ; case354:  {tscache = N_OP_ubfloat2(*(--((LispPTR *) cspcache)), tscache,  (((BYTECODE *)((pccache-1)+1))->code)); if (stateptrcache->errorexit) goto ufn_2d; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0355 : ; case355:  {tscache = N_OP_ubfloat1(tscache,  (((BYTECODE *)((pccache-1)+1))->code)); if (stateptrcache->errorexit) goto fix_tos_ufn; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0356 : ; case356:  {if ((int)((int)tscache = N_OP_aref2( *(((LispPTR *) cspcache)-2), *(((LispPTR *) cspcache)-1), tscache)) < 0) goto fix_tos_ufn; ((LispPTR *) cspcache) -= 2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0357 : ; case357:  {if ((int)((int)tscache = N_OP_aset2( *(((LispPTR *) cspcache)-3), *(((LispPTR *) cspcache)-2), *(((LispPTR *) cspcache)-1), tscache)) < 0) goto fix_tos_ufn; ((LispPTR *) cspcache) -= 3; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0360 : ; case360: {		if(tscache == *(--((LispPTR *) cspcache)))			tscache = 0114;		else	tscache = 0;		{ { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };		} case 0361 : ; case361:  { register int arg1, arg2, result; arg1 = *(((LispPTR *) cspcache) - 1);  { if ((((tscache) >> 17) ^ 7)) if ((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg2 = *((int *)(Lisp_world + (tscache))); else   arg2 = ( ((int)tscache << 15) >> 15 );};; { if ((((arg1) >> 17) ^ 7)) if ((( (* (MDStypetbl+((arg1)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg1 = *((int *)(Lisp_world + (arg1))); else   arg1 = ( ((int)arg1 << 15) >> 15 );};; tscache = (arg1>arg2? 0114 : 0); *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; 	 case 0362 : ; case362:  {if ((int)((int)tscache = N_OP_fgreaterp(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0363 : ; case363:	{ register int arg1, arg2, result; arg1 = *(((LispPTR *) cspcache) - 1);  { if ((((tscache) >> 17) ^ 7)) if ((( (* (MDStypetbl+((tscache)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg2 = *((int *)(Lisp_world + (tscache))); else   arg2 = ( ((int)tscache << 15) >> 15 );};; { if ((((arg1) >> 17) ^ 7)) if ((( (* (MDStypetbl+((arg1)>>9))) ) & 0x7ff) != 2)  goto op_ufn; else   arg1 = *((int *)(Lisp_world + (arg1))); else   arg1 = ( ((int)arg1 << 15) >> 15 );};; tscache = (arg1>arg2? 0114 : 0); *(--((LispPTR *) cspcache)); { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };}; case 0364 : ; case364:  {if ((int)((int)tscache = N_OP_equal(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0365 : ; case365:	{if ((int)((int)tscache = N_OP_makenumber(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0366 : ; case366:	{if ((int)((int)tscache = N_OP_boxiplus(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0367 : ; case367:	{if ((int)((int)tscache = N_OP_boxidiff(*(--((LispPTR *) cspcache)), tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0370 : ; case370:  { goto op_ufn; }  case 0371 : ; case371:  { goto op_ufn; }  case 0372 : ; case372: 	{if ((int)((int)tscache = N_OP_misc3( *(((LispPTR *) cspcache)-2), *(((LispPTR *) cspcache)-1), tscache,  (((BYTECODE *)((pccache-1)+1))->code))) < 0) goto fix_tos_ufn; ((LispPTR *) cspcache) -= 2; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0373 : ; case373: 	{if ((int)((int)tscache = N_OP_misc4( *(((LispPTR *) cspcache)-3), *(((LispPTR *) cspcache)-2), *(((LispPTR *) cspcache)-1), tscache,  (((BYTECODE *)((pccache-1)+1))->code))) < 0) goto fix_tos_ufn; ((LispPTR *) cspcache) -= 3; { { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };;}; case 0374 : ; case374:  { goto op_ufn; }  case 0375 : ; case375: 	{ register LispPTR temp; temp = *(((LispPTR *) cspcache) - 1); *(((LispPTR *) cspcache) - 1) = tscache; tscache = temp; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0376 : ; case376: 	{ { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; }; }; case 0377 : ; case377: 	{ register int arg2; ; arg2 = *(--((LispPTR *) cspcache)); if ((tscache & 0xff0000) == 0xE0000) { if (arg2 == tscache) {tscache = 0114; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };} if ((arg2 & 0xff0000) == 0xE0000) {tscache = 0; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };} } if ((int)((int)tscache = N_OP_eqq( arg2, tscache)) < 0) goto ufn_2; { { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };; };# 596 "../src/xc.c"  	 default: 	error("should not default");	 }	# 663 "../src/xc.c" native_check: # 669 "../src/xc.c" 		goto nextopcode;check_interrupt:# 679 "../src/xc.c" # 682 "../src/xc.c" 	if ( (int)((LispPTR *) cspcache) > (int)stateptrcache->endofstack )		{{ stateptrcache->currentpc=pccache-1; stateptrcache->tosvalue=tscache; {stateptrcache->csp = (DLword *) (((LispPTR *) cspcache)-1);}; };		 error("Unrecoverable Stack Overflow");	         { pccache=stateptrcache->currentpc+1; {((LispPTR *) cspcache) = ((LispPTR *) stateptrcache->csp)+1;}; tscache = stateptrcache->tosvalue; };		}	{register int need_irq; static int period_cnt=60;extern int	KBDEventFlg;extern LispPTR DOBUFFEREDTRANSITION_index;extern LispPTR INTERRUPTFRAME_index;extern LispPTR *KEYBUFFERING68k;extern LispPTR *PENDINGINTERRUPT68k;extern LispPTR ATOM_STARTED;extern LispPTR *PERIODIC_INTERRUPT68k;extern LispPTR *PERIODIC_INTERRUPT_FREQUENCY68k;extern LispPTR PERIODIC_INTERRUPTFRAME_index;extern LispPTR *Reclaim_cnt_word;extern LispPTR DORECLAIM_index;extern int URaid_req;	re_check_stack:	need_irq = 0;	if ( 	((int)(((LispPTR *) cspcache)+1) > stateptrcache->irqcheck) && 		(stateptrcache->irqend > 0) && 		(stateptrcache->irqcheck > 0) )		{	 	 *(((LispPTR *) cspcache)++) = tscache;		 { stateptrcache->currentpc=pccache-1; stateptrcache->tosvalue=tscache; {stateptrcache->csp = (DLword *) (((LispPTR *) cspcache)-1);}; };		 extended_frame = 0;		 if (do_stackoverflow(0)) { stackoverflow_help:			period_cnt=60; need_irq = 1;			error("Stack Overflow, MUST HARDRESET!"); 			{ pccache=stateptrcache->currentpc+1; {((LispPTR *) cspcache) = ((LispPTR *) stateptrcache->csp)+1;}; tscache = stateptrcache->tosvalue; }; tscache = 0; 			}		 else { { pccache=stateptrcache->currentpc+1; {((LispPTR *) cspcache) = ((LispPTR *) stateptrcache->csp)+1;}; tscache = stateptrcache->tosvalue; }; tscache = *(--((LispPTR *) cspcache)); }		 stateptrcache->irqcheck = (int)stateptrcache->endofstack-((stateptrcache->currentfunc->stkmin ) << 1);		 need_irq = (stateptrcache->irqend == 0)  || extended_frame;		 *PENDINGINTERRUPT68k |= extended_frame; 		 stateptrcache->irqend = (int) stateptrcache->endofstack;		}		if ((stateptrcache->irqend <= 0) || (stateptrcache->irqcheck <= 0) || need_irq) {		if ((((unsigned int)(((LispPTR *) cspcache)) - (unsigned int)Stackspace) >>1) > InterfacePage->stackbase) {						getsignaldata();			{ stateptrcache->currentpc=pccache-1; stateptrcache->tosvalue=tscache; {stateptrcache->csp = (DLword *) (((LispPTR *) cspcache)-1);}; }; 			update_timer(); 			if(URaid_req ==1){				URaid_req=0;				error("Call URaid by User Interrupt");			}			else if((KBDEventFlg>0)&&(*KEYBUFFERING68k==0114)) {				*KEYBUFFERING68k= ATOM_STARTED;				cause_interruptcall(DOBUFFEREDTRANSITION_index);				KBDEventFlg --;				}			else if(*Reclaim_cnt_word == 0xE0000) {  				*Reclaim_cnt_word=0;				cause_interruptcall(DORECLAIM_index);				}			else if(*PENDINGINTERRUPT68k!=0) { 				*PENDINGINTERRUPT68k=0;				cause_interruptcall(INTERRUPTFRAME_index);				}			else if(*PERIODIC_INTERRUPT68k!=0) {				if(period_cnt>0)  period_cnt--;				else {					cause_interruptcall(PERIODIC_INTERRUPTFRAME_index);					if(*PERIODIC_INTERRUPT_FREQUENCY68k==0)						period_cnt=0;					else						period_cnt=(*PERIODIC_INTERRUPT_FREQUENCY68k & 0xffff) *(1000000/60) /TIMER_INTERVAL;						}				}			{ pccache=stateptrcache->currentpc+1; {((LispPTR *) cspcache) = ((LispPTR *) stateptrcache->csp)+1;}; tscache = stateptrcache->tosvalue; };			{stateptrcache->irqcheck = ( (int)(stateptrcache->irqend = (int) stateptrcache->endofstack) - (( stateptrcache->currentfunc->stkmin ) << 1) ); };			} 		else {						{stateptrcache->irqcheck = ( (int)(stateptrcache->irqend = (int) stateptrcache->endofstack) - (( stateptrcache->currentfunc->stkmin ) << 1) ); };			goto re_check_stack;			}		}}	{ fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; };PopNextop1:	tscache = *(--((LispPTR *) cspcache)); 	{ { pccache += 1; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };PopNextop2:	tscache = *(--((LispPTR *) cspcache)); 	{ { pccache += 2; { fast_dispatcher(table, (((BYTECODE *)((pccache-1)))->code)); goto nextopcode; }; }; };# 1067 "../src/xc.c"      }int retfun() {return(0);}do_brk() {}