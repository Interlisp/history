/* This is G-file @(#) gvar2.c Version 2.6 (3/21/90). copyright Xerox & Fuji Xerox  */static char *id = "@(#) gvar2.c	2.6 3/21/90";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Author	:	Hiroshi Hayata	 */#include <stdio.h>#include "lispemul.h"#include "lispglobal.h"#include "address68k.h"#include "gc.h"#include "emulglobal.h"#include "cell.h"/************************************************************ N_OP_gvar_	entry		GVAR_		OPCODE[027]	1.	atom_index: offset of argued slot from Valspace.	2.	address of GVAR slot is Valspace+offset.	3.	call gclookup with DELREF and address of GVAR slot.	4.	call gclookup with ADDREF and TopOFStack.	5.	replace GVAR slot with tos.	6.	If Hash Table is overflow, call fn1ext.***********************************************************/ LispPTR N_OP_gvar_(tos, atom_index)	register LispPTR tos;	unsigned int atom_index;{register LispPTR *pslot;	/* pointer to argued GVAR slot */	pslot = (LispPTR *) Valspace + atom_index;#ifdef DEBUG	if (tos&0xFF000000) error("Setting GVAR with high bits on");#endif	FRPLPTR(((struct xpointer*)pslot)->addr, tos);	return(tos);}/************************************************************ N_OP_rplptr	entry		RPLPTR		OPCODE[024]	1.	alpha : offset of argued slot from tos_m_1.	2.	address of slot is tos_m_1+offset.	3.	call gclookup with DELREF and address of slot.	4.	call gclookup with ADDREF and tos.	5.	replace slot with tos.***********************************************************/ LispPTR N_OP_rplptr(tos_m_1, tos, alpha)	register LispPTR tos, tos_m_1;	unsigned int alpha;{register DLword	*pslot;		/* pointer to argued slot (68 address) */	pslot = Addr68k_from_LADDR(tos_m_1 + alpha );	FRPLPTR( ((struct xpointer*)pslot)->addr,tos);	return(tos_m_1);}