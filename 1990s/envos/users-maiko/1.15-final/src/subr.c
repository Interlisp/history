/* @(#) subr.c Version 2.49 (2/12/90). copyright envos & Fuji Xerox  */static char *id = "@(#) subr.c	2.49 2/12/90		(envos & Fuji Xerox)";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Author :  Takeshi Shimizu * *//***********************************************************//*		File Name :	subr.c		Including	:	OP_subrcall		Created	:	May 12, 1987 Takeshi Shimizu		Changed :	May 15 87 take		Changed :	Jun 2 87 NMitani				Jun. 5 87 take				Jun. 29 87 NMitani				Oct. 13 87 Hayata				Oct. 16 87 take				Nov. 18 87 Matsuda				Dec. 17 1987 Tomtom				2/17/89 Sybalsky (Add SXHASH)*//***********************************************************/ #include "lispemul.h"#include "address.h"#include "address68k.h"#include "lisptypes.h"#include "lispmap.h"#include "emulglobal.h"#include "lispglobal.h"#include "cell.h"#include "stack.h"#include "arith.h"#include "subrs.h"#include "profile.h"/***********************************************************//*	Func Name  :	OP_subrcall	Last Modify :	13-Oct 1987 take*//***********************************************************/#ifdef NATIVETRANextern int *c_ret_to_dispatch;extern int *ret_to_dispatch;#endifextern  LispPTR Uraid_mess;LispPTR subr_lisperror(); /* 0377 */char *atom_to_str(atom_index)	LispPTR atom_index;{	PNCell *pnptr;	char *pname_base;	pnptr = (PNCell *) GetPnameCell(atom_index);	pname_base = (char *) Addr68k_from_LADDR(pnptr->pnamebase);	return(pname_base+1);} /*atom_to_str*/#define POP_SUBR_ARGS 							\{	args[0] = NIL_PTR;						\	if (( arg_num = (argnum = (Get_BYTE(PC+2)))) > 0)  {		\		 while(arg_num >0) 					\			 PopStackTo(args[--arg_num]); 			\		}							\}OP_subrcall(){  static LispPTR args[30];  int  arg_num, argnum;  int i;PushCStack; /* save TOS in memory */switch(Get_BYTE(PC+1))  {	case sb_SHOWDISPLAY  :POP_SUBR_ARGS;			DSP_showdisplay(args);			break;/* showdisplay */	case sb_DSPBOUT  :	POP_SUBR_ARGS;			DSP_dspbout( args );			break; /*dspbout */	case  sb_RAID :	POP_SUBR_ARGS;			Uraid_mess= args[0];			PC+= 3; /* for the case of hardreset */			error("URAID Called:");			Uraid_mess=NIL;			TopOfStack =NIL;			return; /* Direct return;avoid to increment PC */		     /* break; */	/* for Local File System */	case  sb_UFS_OPENFILE :	POP_SUBR_ARGS;			TopOfStack = UFS_openfile(args);			break;	case  sb_UFS_CLOSEFILE :	POP_SUBR_ARGS;			TopOfStack = UFS_closefile(args);			break;	case  sb_UFS_GETFILENAME :	POP_SUBR_ARGS;			TopOfStack = UFS_getfilename(args);			break;	case  sb_UFS_DELETEFILE :	POP_SUBR_ARGS;			TopOfStack = UFS_deletefile(args);			break;	case  sb_UFS_RENAMEFILE :	POP_SUBR_ARGS;			TopOfStack = UFS_renamefile(args);			break;	case  sb_UFS_READPAGES :	POP_SUBR_ARGS;			TopOfStack = UFS_readpage(args);			break;	case  sb_UFS_WRITEPAGES :	POP_SUBR_ARGS;			TopOfStack = UFS_writepage(args);			break;	case  sb_UFS_GETSIZE :	POP_SUBR_ARGS;			TopOfStack = UFS_getsize(args);			break;	case  sb_UFS_READDIR :	POP_SUBR_ARGS;			TopOfStack = UFS_readdir(args);			break;	case  sb_UFS_DIRECTORYNAMEP :	POP_SUBR_ARGS;			TopOfStack = UFS_directorynamep(args);			break;	case  sb_UFS_GETFILEINFO :	POP_SUBR_ARGS;			TopOfStack = UFS_getfileinfo(args);			break;	case  sb_UFS_DIRSIZE :	POP_SUBR_ARGS;			TopOfStack = UFS_dirsize(args);			break;	case  sb_UFS_CHANGEDIR :	POP_SUBR_ARGS;			TopOfStack = UFS_changedir(args);			break;	case  sb_UFS_GETFREEBLOCK:	POP_SUBR_ARGS;			TopOfStack = UFS_getfreeblock(args);			break;	case  sb_UFS_SETFILEINFO:	POP_SUBR_ARGS;			TopOfStack = UFS_setfileinfo(args);			break;	/* for Timer */	case  sb_SETUNIXTIME :	POP_SUBR_ARGS;			TopOfStack = subr_settime(args);			break;	case  sb_GETUNIXTIME :	POP_SUBR_ARGS;			TopOfStack = subr_gettime(args);			break;	case sb_COPYTIMESTATS :	POP_SUBR_ARGS;			TopOfStack = subr_copytimestats(args);			break;	/* for Ether */	case sb_CHECK_SUM :POP_SUBR_ARGS;			 TopOfStack = check_sum(args);			break;	case  sb_ETHER_SUSPEND :	POP_SUBR_ARGS;			TopOfStack = ether_suspend(args);			break;	case  sb_ETHER_RESUME :	POP_SUBR_ARGS;			TopOfStack = ether_resume(args);			break;	case  sb_ETHER_AVAILABLE :	POP_SUBR_ARGS;			TopOfStack = ether_ctrlr(args);			break;	case  sb_ETHER_RESET : POP_SUBR_ARGS;				TopOfStack = ether_reset(args);			break;	case  sb_ETHER_GET : POP_SUBR_ARGS;				TopOfStack = ether_get(args);			break;	case  sb_ETHER_SEND : POP_SUBR_ARGS;				TopOfStack = ether_send(args);			break;	case  sb_ETHER_SETFILTER : POP_SUBR_ARGS;				TopOfStack = ether_setfilter(args);			break;	case  sb_ETHER_CHECK: POP_SUBR_ARGS;				TopOfStack = check_ether();			break;	/* for Display */	case sb_DSPCURSOR : POP_SUBR_ARGS;				DSP_Cursor(args, argnum);			break;	case sb_SETMOUSEXY : POP_SUBR_ARGS;				DSP_SetMousePos(args);			break;	case sb_DSP_VIDEOCOLOR : POP_SUBR_ARGS;				TopOfStack = DSP_VideoColor(args);			break;	case sb_DSP_SCREENWIDTH : POP_SUBR_ARGS;				TopOfStack = DSP_ScreenWidth(args);			break;	case sb_DSP_SCREENHEIGHT : POP_SUBR_ARGS;				TopOfStack = DSP_ScreenHight(args);			break;  	/***** for color experiments */	case sb_COLOR_INIT : POP_SUBR_ARGS;			TopOfStack=cgfour_init_color_display(args[0]);			break;	case sb_COLOR_SCREENMODE : POP_SUBR_ARGS;			TopOfStack=cgfour_change_screen_mode(args[0]);			break;	case sb_COLOR_MAP : POP_SUBR_ARGS;			TopOfStack=cgfour_set_colormap(args);			break;	case sb_COLOR_BASE : POP_SUBR_ARGS;			/* retun DLword offsetbetween LISPBASE and Lisp_world */			TopOfStack=S_POSITIVE |(((int)Lisp_world >> 1) & 0xffff);			break;#ifdef COLOR	case sb_C_SlowBltChar : POP_SUBR_ARGS;			/* \\SLOWBLTCHAR for 8BITCOLOR */			C_slowbltchar(args);			break;#endif COLOR	/***  bitbltsub, bltchar ***/	case sb_BITBLTSUB : POP_SUBR_ARGS;			bitbltsub(args);			break;	case sb_BLTCHAR : POP_SUBR_ARGS; /* argnum * DLwordsperCell*/			bltchar(args);				break;	 	case sb_NEW_BLTCHAR :  POP_SUBR_ARGS;			newbltchar(args);			break;	case sb_TEDIT_BLTCHAR  : POP_SUBR_ARGS;			tedit_bltchar(args);			break;	case 209:	case sb_BITBLT_BITMAP: POP_SUBR_ARGS;  /* BITBLT to a bitmap */		  {		    TopOfStack = bitblt_bitmap(args);		    break;		  }		break;	case  0111/*sb_BITSHADE_BITMAP*/: POP_SUBR_ARGS;  /* BITSHADE to a bitmap */		  {		    TopOfStack = bitshade_bitmap(args);		    break;		  }		break;	/* for K/B */	case sb_KEYBOARDBEEP : POP_SUBR_ARGS;				KB_beep(args);			break;	case sb_KEYBOARDMAP : POP_SUBR_ARGS;				KB_setmp(args);			break;	case sb_KEYBOARDSTATE : POP_SUBR_ARGS;				KB_enable(args);			break;	case sb_VMEMSAVE:  POP_SUBR_ARGS;			   TopOfStack = vmem_save0(args);			break;	case sb_LISPFINISH:	case sb_LISP_FINISH : POP_SUBR_ARGS;		if((argnum>0)&&(args[0]==S_POSITIVE))		/* 8/03/88 This branch impossible to take, subr has no args */			{TopOfStack=suspend_lisp(args);}		else	lisp_finish();			break;	case sb_NEWPAGE : POP_SUBR_ARGS;				TopOfStack = newpage(args[0]);			break;	case sb_DORECLAIM : POP_SUBR_ARGS;			doreclaim();       /* top-level GC function */			TopOfStack = NIL_PTR;			break;			/* read & write a abs memory address */	case sb_NATIVE_MEMORY_REFERENCE : POP_SUBR_ARGS;							switch (args[0] & 0xffff) {			case 00: 				{register int iarg;				if (argnum != 2) goto ret_nil;				N_GETNUMBER(args[1], iarg, ret_nil);				ARITH_SWITCH(*((LispPTR *) iarg), TopOfStack);				break;				}						case 01: 				{register int iarg,iarg2;				if (argnum != 3) goto ret_nil;				N_GETNUMBER(args[1], iarg, ret_nil);				N_GETNUMBER(args[2], iarg2, ret_nil);				*((LispPTR *) iarg) = iarg2;				break;				}#ifdef NATIVETRAN			case 02: 	/* get an emulator address */				{register int iarg;				if (argnum != 2) goto ret_nil;				switch (args[1] & 0xffff) {				case 00: iarg = (int) &c_ret_to_dispatch;					 break;				case 01: iarg = (int) &ret_to_dispatch;					 break;				}				ARITH_SWITCH(iarg, TopOfStack);				break;				}#endif			}			break;	ret_nil: 	TopOfStack = NIL_PTR;			break;#ifdef NATIVETRAN			/* old load native (should be superceeded) */	case sb_OLD_COMPILE_LOAD_NATIVE : POP_SUBR_ARGS;				{			TopOfStack = do_system_call(args[0]);			break;			};#endif	case sb_GET_NATIVE_ADDR_FROM_LISP_PTR: POP_SUBR_ARGS;						{ARITH_SWITCH(Addr68k_from_LADDR(args[0]), TopOfStack);			 break;			}	case sb_GET_LISP_PTR_FROM_NATIVE_ADDR: POP_SUBR_ARGS;						{register int iarg;			 N_GETNUMBER(args[0], iarg, ret_nil);			 ARITH_SWITCH(LADDR_from_68k(iarg), TopOfStack);			 break;			};#ifdef NATIVETRAN	case sb_LOAD_NATIVE_FILE: POP_SUBR_ARGS;			 /* to become OBSOLETE */			{TopOfStack = dynamic_load_code(args);		 	 break;			}#endif	case  sb_DSK_OPENFILE : POP_SUBR_ARGS;				TopOfStack = DSK_openfile(args);			break;	case  sb_DSK_CLOSEFILE : POP_SUBR_ARGS;				TopOfStack = DSK_closefile(args);			break;	case  sb_DSK_GETFILENAME : POP_SUBR_ARGS;				TopOfStack = DSK_getfilename(args);			break;	case  sb_DSK_DELETEFILE : POP_SUBR_ARGS;				TopOfStack = DSK_deletefile(args);			break;	case  sb_DSK_RENAMEFILE : POP_SUBR_ARGS;				TopOfStack = DSK_renamefile(args);			break;	case  sb_DSK_READDIR : POP_SUBR_ARGS;				TopOfStack = DSK_readdir(args);			break;	case  sb_DSK_DIRECTORYNAMEP : POP_SUBR_ARGS;				TopOfStack = DSK_directorynamep(args);			break;	case  sb_DSK_GETFILEINFO : POP_SUBR_ARGS;				TopOfStack = DSK_getfileinfo(args);			break;	case  sb_DSK_DIRSIZE : POP_SUBR_ARGS;				TopOfStack = DSK_dirsize(args);			break;	case  sb_DSK_CHANGEDIR : POP_SUBR_ARGS;				TopOfStack = DSK_changedir(args);			break;	case  sb_DSK_SETFILEINFO : POP_SUBR_ARGS;				TopOfStack = DSK_setfileinfo(args);			break;/* Communications with Unix Subprocess */        case sb_UNIX_HANDLECOMM: POP_SUBR_ARGS;			     TopOfStack = Unix_handlecomm(args);		        break;        case 0166: POP_SUBR_ARGS;			 error("called SUBR 0166, not defined!!");			      {register int temp;			 N_GETNUMBER(TopOfStack, temp, badarg);			 temp = (int) Addr68k_from_LADDR(temp);			 ARITH_SWITCH(temp, TopOfStack);			 break;		badarg:	TopOfStack = NIL;			break;			}/* OS message print routines */ 	case sb_MESSAGE_READP: POP_SUBR_ARGS;			      TopOfStack = mess_readp();			break;	case sb_MESSAGE_READ: POP_SUBR_ARGS;			      TopOfStack = mess_read(args);			break;						/* RPC routines */      case sb_RPC_CALL: POP_SUBR_ARGS;			 TopOfStack = rpc(args);			break;/* Unix username/password utilities */      case sb_CHECKBCPLPASSWORD: POP_SUBR_ARGS;			 /* Check Unix username/password */			TopOfStack = check_unix_password(args);			break;      case sb_UNIX_USERNAME: POP_SUBR_ARGS;			  /* Get Unix username */			TopOfStack = unix_username(args);			break;      case sb_UNIX_FULLNAME: POP_SUBR_ARGS;				/* Get Unix person-name (GECOS field) */			TopOfStack = unix_fullname(args);			break;      case sb_UNIX_GETENV: POP_SUBR_ARGS;		/* get value of environment variable, or NIL */		TopOfStack = unix_getenv(args); break;      case sb_UNIX_GETPARM: POP_SUBR_ARGS;		/* get built in parameter */		TopOfStack = unix_getparm(args); break;      case sb_SUSPEND_LISP: POP_SUBR_ARGS;				/* Suspend Maiko */			TopOfStack = suspend_lisp(args);			break;      case sb_MONITOR_CONTROL : POP_SUBR_ARGS;		  /* MONITOR CONTROL STOP(0) or RESUME(1) */#ifdef PROFILE			moncontrol(args[0] & 1);#endif PROFILE			break;      case sb_CHAR_OPENFILE: POP_SUBR_ARGS;  /* Char-device openfile. */		TopOfStack = CHAR_openfile(args); 		break;      case sb_CHAR_BIN: POP_SUBR_ARGS;  /* Char-device bin. */		  {		    TopOfStack = CHAR_bin(args[0], args[1]);		    break;		  }		break;      case sb_CHAR_BOUT: POP_SUBR_ARGS;  /* Char-device bout. */		  {		    TopOfStack = CHAR_bout(args[0], args[1], args[2]);		    break;		  }		break;      case sb_CHAR_IOCTL: POP_SUBR_ARGS;  /* Char-device IOCTL. */		  {		    TopOfStack = CHAR_ioctl(args);		    break;		  }		break;      case sb_CHAR_CLOSEFILE: POP_SUBR_ARGS;  /* Char-device CLOSEFILE. */		  {		    TopOfStack = CHAR_closefile(args);		    break;		  }		break;      case sb_CHAR_BINS: POP_SUBR_ARGS;  /* Char-device \BINS. */		  {		    TopOfStack = CHAR_bins(args);		    break;		  }		break;      case sb_CHAR_BOUTS: POP_SUBR_ARGS;  /* Char-device \BOUTS. */		  {		    TopOfStack = CHAR_bouts(args);		    break;		  }		break;	case sb_TCP_OP:	POP_SUBR_ARGS;	/* TCP operations */		{		  TopOfStack = subr_TCP_ops(args[0], args[1], args[2],					    args[3], args[4], args[5]);		  break;		}		break;/* ******** NOW IN MISCN *********      case sb_USER_SUBR: POP_SUBR_ARGS;			{register LispPTR user_subr, user_args;			 N_GETNUMBER(args[0], user_subr, ret_nil);			 N_GETNUMBER(args[1], user_args, ret_nil);			 TopOfStack = UserSubr(user_subr, user_args, &args[2]);			}			break;********************************** */      case sb_PUPLEVEL1STATE: POP_SUBR_ARGS;  /* Do nothing with PUP on sun */                break;      default :		{		char errtext[200];		sprintf ( errtext,          	    "OP_subrcall: Invalid alpha byte 0%o", ((*(PC+1)) & 0xff));		printf  ( "%s\n", errtext );		error(errtext);		break;		}   }/* switch end */PC += 3;}/* OP_subrcall */