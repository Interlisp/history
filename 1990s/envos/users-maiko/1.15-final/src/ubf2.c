/* @(#) ubf2.c Version 1.6 (4/20/90). copyright envos & Fuji Xerox  */static char *id = "@(#) ubf2.c	1.6 4/20/90";/*	ubf2.c */#include <stdio.h>#include "lispemul.h"#include "fp.h"/************************************************************	OP_ub2  -- op 354  ==  UBFLOAT2354/0	ADD354/1	SUB354/2	ISUB354/3	MULT354/4	DIV354/5	GREAT354/6	MAX354/7	MIN354/8	REM354/9	AREF***********************************************************/N_OP_ubfloat2(a2, a1, alpha)int a1, a2;int alpha;{register float arg1, arg2;float ans;int ret;  arg1 = *(float *)&a1;		/* why?? */  arg2 = *(float *)&a2;  FPCLEAR;  switch (alpha) {    case 0: /* add */  ans = arg1 + arg2; break;    case 1: /* sub */  ans = arg2 - arg1; break;    case 2: /* isub */ ans = arg1 - arg2; break;    case 3: /* mul */  ans = arg1 * arg2; break;    case 4: /* div */  ans = arg2 / arg1; break;    case 5: /* gt */  if (arg2 > arg1) return(ATOM_T); else return(NIL_PTR);    case 6: /* max */ if (arg2 > arg1) return(a2);     else return(a1);    case 7: /* min */ if (arg2 > arg1) return(a1);     else return(a2);    case 8: /* rem */	/* relies on contagion of inf, nan? */      ans = (arg2 / arg1) - (arg1 * ((arg2 / arg1) / 1));      break;    default: ERROR_EXIT(a1);  }/* end switch */  ret = *(int *)&ans;		/* why?? */  if (FPTEST(ans)) ERROR_EXIT(a1);  return(ret);}/* end N_OP_ub2() */	/* end module */