/* @(#) timer.c Version 2.24 (3/1/90). copyright envos & Fuji Xerox  */static char *id = "@(#) timer.c	2.24 3/1/90		(envos & Fuji Xerox)";/************************************************************************//*									*//*				t i m e r . c				*//*									*//*	Timer handling routines, plus set-up for the other interrupts	*//*	Medley uses on Unix.						*//*									*//*									*//*									*//*									*//*	COPYRIGHT (C) 1987, 1989 by Fuji Xerox Co., Ltd.,		*//*				    Venue, and Xerox Corp.		*//*		  All Rights Reserved.					*//*									*//*									*//*									*//************************************************************************/#include	<sys/time.h>#include	<sys/types.h>#include	<stdio.h>#include	<signal.h>#include	<fcntl.h>#include	<sys/resource.h>#include	<setjmp.h>/* Apollo and Sun have different ideas about the name of this field */#ifdef APOLLO#define sv_flags sv_onstack#endif#include	"lispemul.h"#include	"emulglobal.h"#include	"lispglobal.h"#include	"address68k.h"#include	"lisptypes.h"#include	"arith.h"#include	"lispmap.h"#include	"stack.h"#include	"dbprint.h"#define	LISP_UNIX_TIME_DIFF	29969152#define	LISP_ALTO_TIME_MASK	0x80000000#define UNIX_ALTO_TIME_DIFF	2177452800/*	Interlisp time is signed; MIN.FIXP = "01-JAN-01 00:00:00 GMT" *	Interlisp 0 is at	"19-Jan-69 12:14:08 PST" *	Unix begins at		" 1-Jan-70  0:00:00 GMT" *	(CL:- (IL:IDATE	" 1-Jan-70  0:00:00 GMT") *	      (IL:IDATE "19-Jan-69 12:14:08 PST")) *	=> 29969152, amount to add to Lisp time to get Unix time *	Alto time is unsigned; 0 = "01-JAN-01 00:00:00 GMT" *      UNIX_ALTO_TIME_DIFF is amount to add to Unix time *	to get Alto time. */int	TIMEOUT_TIME;	/* For file system timeout */char	*getenv();#ifdef XWINDOW#define FALSE 0#define TRUE  !FALSEint Event_Req = FALSE;#endif XWINDOW/************************************************************************//*									*//*			i n i t _ m i s c s t a t s			*//*									*//*	Called at initialization time to set miscstats words.		*//*	?? and to periodically update them ?? [JDS 11/22/89]		*//*									*//*									*//************************************************************************/init_miscstats()  {    MiscStats->starttime = gettime(0);    MiscStats->gctime = 0;    update_miscstats();  }/************************************************************************//*									*//*		    u p d a t e _ m i s c s t a t s			*//*									*//*	Updates counters and timers in the MISCSTATS "page".		*//*									*//*									*//*									*//************************************************************************/update_miscstats()  {    struct rusage ru;    struct timeval time;    getrusage(RUSAGE_SELF, &ru);    MiscStats->totaltime = ru.ru_utime.tv_sec * 1000			 + ru.ru_utime.tv_usec /1000;    MiscStats->swapwaittime = ru.ru_stime.tv_sec * 1000			    + ru.ru_stime.tv_usec /1000;    MiscStats->pagefaults = ru.ru_minflt + ru.ru_majflt;    MiscStats->swapwrites = ru.ru_majflt;    MiscStats->diskiotime = 0; /* ?? not available ?? */    MiscStats->diskops	= ru.ru_inblock    			 /* ?? this doesn't work ???    			+ ru.ru_outblock   */				;    gettimeofday(&time, NULL);    MiscStats->secondstmp =    MiscStats->secondsclock = (time.tv_sec + UNIX_ALTO_TIME_DIFF);  }/************************************************************************//*									*//*			s u b r _ g e t t i m e				*//*									*//*	Handler for Lisps GETTIME subr call, dispatched thru		*//*	subr.c/miscn.c sub-dispatch.					*//*									*//*	Calls gettime, and returns the result to Lisp as a SMALLP	*//*	or FIXP, as appropriate.					*//*									*//************************************************************************/DLword	*createcell68k();LispPTR subr_gettime(args)  LispPTR	args[];  {    int result;    result = gettime(args[0] & 0xffff);    if (args[1])      {	*((int*)Addr68k_from_LADDR(args[1]) ) = result;	return (args[1]);      }    else N_ARITH_SWITCH(result);}/************************************************************************//*									*//*		    		g e t t i m e				*//*									*//*	Get the value of one of the various time counters, as		*//*	specified by the argument casep.  casep's values & meanings:	*//*									*//*	0 elapsed time, in milliseconds.				*//*	1 start of elapsed-time period, in milliseconds			*//*	2 this process's run time, in milliseconds			*//*	3 total GC time, in milliseconds				*//*	4 current time-of-day, in ALTO format				*//*	5 current time-of-day, in Interlisp format			*//*	6 start of daylight-savings, as day-in-year			*//*	7 end of daylight-savings, as day-in-year			*//*	8 time zone, as hours of offset from GMT (whole hours only)	*//*									*//************************************************************************/int gettime(casep)    int casep;  {    struct	timeval	time;    struct	timezone tz;    switch (casep)      {	case 0: /* elapsed time in alto milliseconds */		gettimeofday(&time, NULL);		return((time.tv_sec + UNIX_ALTO_TIME_DIFF)*1000				    + time.tv_usec/1000);	case 1: /* starting elapsed time in milliseconds */		return(MiscStats->starttime);	case 2: /* run time, this process, in milliseconds */		update_miscstats();		return(MiscStats->totaltime);	case 3: /* total GC time in milliseconds */		return(MiscStats->gctime);	case 4: /* current time of day in Alto format */		gettimeofday(&time, NULL);		return (time.tv_sec + UNIX_ALTO_TIME_DIFF);	case 5:	/* current time of day in Interlisp format */		gettimeofday(&time, NULL);		return(time.tv_sec + LISP_UNIX_TIME_DIFF);	case 6: gettimeofday(&time, &tz);		return (98); /* this is wrong, only works in PST */	case 7: gettimeofday(&time, &tz);		return (305); /* this is wrong, only works in PST */	case 8: gettimeofday(&time, &tz);		return (tz.tz_minuteswest/60); /* only integral timezones work */	default: return (0);      }  }/************************************************************************//*									*//*			s u b r _ s e t t i m e				*//*									*//*	Converts its argument, a time in ALTO seconds, to the		*//*	UNIX time format, and sets the UNIX clock.  You must be		*//*	the super-user for this to work.				*//*									*//*	Implements the SETTIME subr call, sub-dispatched from subr.c	*//*									*//************************************************************************/subr_settime(args)  LispPTR	args[];  {    struct timeval time;    time.tv_sec = *((int*)Addr68k_from_LADDR(args[0]))    		- UNIX_ALTO_TIME_DIFF;    settimeofday(&time, NULL);  } /* end subr_settime *//************************************************************************//*									*//*		    s u b r _ c o p y t i m e s t a t s			*//*									*//*	Given source and destination MISCSTATS structure pointers,	*//*	copy the contents of the source structure into the dest.	*//*									*//*	Also calls update_miscstats, to keep stats current.		*//*									*//************************************************************************/subr_copytimestats(args)  LispPTR args[]; {    MISCSTATS *source;    MISCSTATS *dest;    source = (MISCSTATS*) Addr68k_from_LADDR(args[0]);    dest   = (MISCSTATS*) Addr68k_from_LADDR(args[1]);    update_miscstats();    *dest = *source;  }/************************************************************************//*									*//*			     N _ O P _ r c l k				*//*									*//*	Get the current time in UNIX format, convert it to micro-	*//*	seconds in ALTO format, and store the low 32 bits into		*//*	the FIXP cell passed in to us on the top of stack.		*//*									*//************************************************************************/LispPTR N_OP_rclk(tos)  register LispPTR tos;  {    struct	timeval	time;    unsigned int	usec;    gettimeofday(&time, NULL);    usec = (time.tv_sec * 1000000) + time.tv_usec;    *((unsigned int *)(Addr68k_from_LADDR(tos))) = usec;    return(tos);  } /* end N_OP_rclk *//**********************************************************************/ /* update_timer called periodically *//************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/update_timer()  {    struct  timeval time;    gettimeofday(&time, NIL);    MiscStats->secondstmp = MiscStats->secondsclock			  = (time.tv_sec + UNIX_ALTO_TIME_DIFF);  }/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************//**********************************************************************//* timer interrupt handling system	int_init() should be called before first entering dispatch loop.	int_timer_init() is called by int_init() and arms the timer interrupt.	int_io_init() is called by int_init() and arms the I/O interrupt.	int_timer_service() catches the timer signal and sets		Irq_Stk_Check & Irq_Stk_End to 0		so the rest of the system will see it and respond.	int_block() and int_unblock() block timer interrupts  and release them.	int_io_open(fd) should be called whenever a file that should interrupt		us is opened; it enables the interrupt on that fd.	int_io_close(fd) should be called whenever a file that should interrupt		us is closed; it disables the interrupt on that fd.*//* TIMER_INTERVAL usec ~ 20  per second.  This should live in some	machine-configuration	file somewhere - it can be changed as the -t parameter to lisp*/#ifdef sparcint TIMER_INTERVAL =  100000;#elseint TIMER_INTERVAL =  25000;#endifint FileIOFlag = 0;int TimerFlag = 0;extern u_int LispWindowFd;/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/#ifdef OS4void int_timer_service(sig, code, scp)#elseint int_timer_service(sig, code, scp)#endifint sig, code;struct sigcontext *scp;{/* this may have to do more in the future, like check for nested interrupts,	etc... */	Irq_Stk_Check = 0;	Irq_Stk_End = 0;	TimerFlag = 1;#ifdef XWINDOW	Event_Req = TRUE;#endif}/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/static struct sigvec timerv;void int_timer_init(){struct itimerval timert, tmpt;/* first set up the signal handler */	timerv.sv_handler = int_timer_service;	timerv.sv_mask = timerv.sv_flags = 0;	sigvec(SIGVTALRM, &timerv, 0);/* then attach a timer to it and turn it loose */	timert.it_interval.tv_sec  = timert.it_value.tv_sec = 0;	timert.it_interval.tv_usec = timert.it_value.tv_usec = TIMER_INTERVAL;	timerclear(&tmpt.it_value);	timerclear(&tmpt.it_interval);	setitimer(ITIMER_VIRTUAL, &timert, &tmpt);	getitimer(ITIMER_VIRTUAL, &tmpt);	DBPRINT(("Timer interval set to %d usec\n", timert.it_value.tv_usec));}/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/void int_io_open(fd)int fd;{#ifdef KBINT	DBPRINT(("int_io_opening %d\n", fd));	if(fcntl(fd, F_SETOWN, getpid()) == -1 ) {#ifdef DEBUG		perror("fcntl F_SETOWN ERROR");#endif		};	if(fcntl(fd, F_SETFL, fcntl (fd, F_GETFL, 0) | FASYNC) == -1)		perror("fcntl F_SETFL error");#endif}void int_io_close(fd)int fd;{#ifdef KBINT	fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~FASYNC);#endif}/************************************************************************//*									*//*			i n t _ i o _ i n i t				*//*									*//*	Set up handling for the SIGIO and SIGPOLL signals, in		*//*	support of keyboard event handling and ethernet incoming-	*//*	packet handling.						*//*									*//*									*//************************************************************************/void int_io_init()  {    static struct sigvec timerv;    static struct sigvec poll_timerv;#ifdef OS4    extern void getsignaldata();#else    extern int getsignaldata();#endif    /* first set up the signal handler */#ifdef KBINT    timerv.sv_handler = getsignaldata;    timerv.sv_mask = timerv.sv_flags = 0;    sigvec(SIGIO, &timerv, 0);     poll_timerv.sv_handler = getsignaldata;    poll_timerv.sv_mask = poll_timerv.sv_flags = 0;    sigvec(SIGPOLL, &poll_timerv, 0);    DBPRINT(("I/O interrupts enabled\n"));#endif}int oldmask = 0;/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/void int_block(){/* temporarily turn off interrupts */	oldmask= sigblock(sigmask(SIGVTALRM) | sigmask(SIGIO)  |			  sigmask(SIGALRM)   | sigmask(SIGXFSZ)#ifdef FLTINT 			| sigmask(SIGFPE)#endif);}/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/void int_unblock(){	sigsetmask(oldmask);}int_timer_on () {int_unblock();}int_timer_off() {int_block  ();}/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************//*void int_timer_off(){struct sigvec tmpv, timeroffv;timeroffv.sv_handler = SIG_IGN;timeroffv.sv_mask = timeroffv.sv_flags = 0;sigvec(SIGVTALRM, &timeroffv, &tmpv);}void int_timer_on(){struct sigvec tmpv;sigvec(SIGVTALRM, &timerv, &tmpv);}*/#ifdef FLTINT/************************************************************************//*									*//*  F L O A T I N G - P O I N T   I N T E R R U P T   H A N D L I N G	*//*									*//*	This is the handler for the SIGFPE signal, to catch floating-	*//*	point exceptions.  Sets the global 'FP_error' to the error	*//*	code passed in by the signal; FP_error is checked by the	*//*	Lisp emulator FP code to make sure everything is OK.		*//*									*//************************************************************************//* The global used to signal floating-point errors */int FP_error = 0;void int_fp_service(sig, code, scp)  int sig, code;  struct sigcontext *scp;  {    switch(code)      {	case FPE_FLTDIV_TRAP:	case FPE_FLTUND_TRAP:	case FPE_FLTOVF_TRAP:	case FPE_FLTOPERR_TRAP: FP_error = code;				break;	default:	  {#ifdef DEBUG	    char stuff[100];	    sprintf(stuff, "Unexpected FP error signal code: %d", code);	    perror(stuff);#endif	  }      }  }int_fp_init()  {	/* first set up the signal handler */    if(ieee_handler("set", "all", int_fp_service))      perror("Sigvec for FPE failed");    DBPRINT(("FP interrupts enabled\n"));  }#endif FLTINT/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************//*****************************************************************timeout_error	Error handling routine for SIGALRM.	When TIMEOUT spend TIMEOUT_TIME (10 sec), this rouitne is called.*****************************************************************/jmp_buf	jmpbuf;#ifdef OS4void#endiftimeout_error(){	/* 14 May 91 JDS -- put in segv bug fix from 1.2 for Waara/wbst */	/* printf("File access timed out.\n"); */	longjmp(jmpbuf, 1);}void int_file_init(){static struct sigvec timerv;char	*envtime;int	timeout_time;/* first set up the signal handler */	timerv.sv_handler = timeout_error;	timerv.sv_mask = timerv.sv_flags = 0;	sigvec(SIGALRM, &timerv, 0);/* Set Timeout period */	if((envtime = getenv("LDEFILETIMEOUT")) == NULL){		TIMEOUT_TIME = 10;	}else{		if( (timeout_time = atoi(envtime)) > 0){			TIMEOUT_TIME = timeout_time;		}else{			TIMEOUT_TIME = 10;		}	}	DBPRINT(("File timeout interrupts enabled\n"));}/************************************************************************//*									*//*			    i n t _ i n i t				*//*									*//*	Initialize all the interrupts for Lisp & the emulator.		*//*									*//************************************************************************/void int_init()  {   int_timer_init();	/* periodic interrupt timer */   int_io_init();	/* SIGIO and SIGPOLL async I/O handlers */   int_file_init();	/* file-io TIMEOUT support */#ifdef FLTINT   int_fp_init();	/* Floating-point exception handler */#endif   int_unblock();	/* Turn on interrupts */}