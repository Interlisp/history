/* @(#) dsk.c Version 2.44 (3/8/90). copyright venue & Fuji Xerox  */static char *id = "@(#) dsk.c	2.44 3/8/90		(venue & Fuji Xerox)";#include	<pwd.h>#include	<stdio.h>#include	<sys/file.h>#include	<sys/types.h>#include	<sys/stat.h>#include	<sys/param.h>#include	<sys/time.h>#include	<sys/dir.h>#include	<strings.h>#include 	<setjmp.h>#include	<errno.h>#include	"lispemul.h"#include	"lispmap.h"#include	"address68k.h"#include	"lisptypes.h"#include	"arith.h"#include	"stream.h"#include	"timeout.h"#include	"localfile.h"#include	"osmessage.h"#include	"dbprint.h"#define	LASTVERSIONARRAY	0xFFFFFFFF#define	VERSIONARRAYLENGTH	200extern	int*	Lisp_errno;extern	int	Dummy_errno;typedef struct	filename_entry{	char	name[MAXPATHLEN];	/* With version, foo.~3~ or foo */	int	version_no;}FileName;typedef struct	current_varray{	char	path[MAXPATHLEN];	/* pathname of directory */	char	file[MAXPATHLEN];	/* file name  (down cased name) */	time_t	mtime;}CurrentVArray;FileName	VersionArray[VERSIONARRAYLENGTH];CurrentVArray	VArrayInfo;FileName *GetHighestVersion();FileName *GetNextHighestVersion();FileName *GetLowestVersion();FileName *VersionlessP();DSK_openfile(args)register LispPTR	*args;/* args[0]		fullname *//* args[1]		rec *//* args[2]		acc *//* args[3]		cdate *//* args[4]		size *//* args[5]		errno */{register int	id;	/* return value  of open system call. */register int	flags;	/* open system call's argument */register int	rval;register int	linkflag =0;register int	*bufp;struct stat	statbuf;char	pathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[5]));	#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	RemoveDodNoExtenstion(pathname);	if(checklink_and_changeversion(pathname) == 0)		return(NIL);	LispVersionToUnixVersion(pathname);	flags = 0;#ifdef	FSERROR	ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	TIMEOUT( rval=stat(pathname, &statbuf) );	if(rval == 0){		if((statbuf.st_mode & S_IFREG) == 0){			/* Not regular file, can not open special file */			OSMESSAGE_PRINT( printf("Can not open special file: %s.\nUse UNIX device\n",pathname ) );#ifdef FSERROR			*Lisp_errno = 23;	/* File won't open */#endif			return(NIL);		}	}	switch(args[1]){	case RECOG_OLD:	case RECOG_OLDEST:		break;	case RECOG_NEW_OLD:	case RECOG_NEW:		TIMEOUT( rval=access(pathname, F_OK) );		if( rval == -1 ){			if(errno == 60){  /* Connection time out */#ifdef FSERROR				*Lisp_errno = 60;#endif				return(NIL);			}			linkflag =1;		}		flags = O_CREAT;		break;/**	case RECOG_NEW:		linkflag = 1;		flags = O_CREAT;		break;**/	default:		return(NIL);	}	switch(args[2]){	case	ACCESS_INPUT:			flags |= O_RDONLY;			break;	case	ACCESS_OUTPUT:	case	ACCESS_APPEND:			flags |= (O_RDWR | O_CREAT);			break;	case	ACCESS_BOTH:			flags |= (O_RDWR | O_CREAT);			break;	default:			return(NIL);	}	TIMEOUT( id=open(pathname, flags, 0666) );	if(id == -1){		err_mess("open", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	TIMEOUT( rval=fstat(id, &statbuf) );	if(rval == -1){		err_mess("fstat", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		TIMEOUT( close(id) );		return(NIL);	}	if(linkflag == 1)		if( makenewlink(pathname) == 0){#ifdef	FSERROR			ERRSETJMP(NIL);#else			SETJMP(NIL);#endif			TIMEOUT( close(id) );			return(NIL);		}	bufp = (int *)(Addr68k_from_LADDR(args[3]));	*bufp = ToLispTime(statbuf.st_mtime);	bufp = (int *)(Addr68k_from_LADDR(args[4]));	bufp = (int *)(Addr68k_from_LADDR(args[4]));	*bufp = statbuf.st_size;	return(GetSmallp(id));}DSK_closefile(args)register LispPTR	*args;/* args[0]		pathname	*//* args[1]		id	*//* args[2]		cdate	*//* args[3]		errno */{register int	id;	/* FileID */register int	date;	/* Creatoin Date */register int	rval;static struct timeval time[2];struct stat	statbuf;char	pathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	RemoveDodNoExtenstion(pathname);	if(checklink_and_changeversion(pathname) == 0)		return(NIL);	LispVersionToUnixVersion(pathname);	id = LispNumToCInt(args[1]);	date = LispNumToCInt(args[2]);#ifdef	FSERROR	ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	if(date == 0){ /* just close */		TIMEOUT( rval=close(id) );		if( rval == -1){			err_mess("close", errno);#ifdef FSERROR			*Lisp_errno = errno;#endif			return(NIL);		}		return(ATOM_T);	}	/* set Creation date and close */	TIMEOUT( rval=fstat(id, &statbuf) );		if(rval != 0){		err_mess("fstat", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	time[0].tv_sec = statbuf.st_atime;	time[1].tv_sec = ToUnixTime(date);	TIMEOUT( rval=close(id) );	if( rval == -1){		err_mess("close", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	TIMEOUT( rval=utimes(pathname, time) );	if(rval != 0){		err_mess("utimes", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	return(ATOM_T);}DSK_getfilename(args)register LispPTR	*args;/* args[0]		pathname	*//* args[1]		rec	*//* args[2]		buffer	*//* args[3]		errno	*/{register int	length;register int	version_no;register char	*base;register LispPTR	*naddress;char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];char	path[MAXPATHLEN];char	name[MAXPATHLEN];char	version[VERSIONLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	if( makepathname(pathname, fullpathname) == 0)		return(NIL);	if(parse(fullpathname, path, name, version) == 0)		return(NIL);	if(*version == '\0')		version_no = MAXVERSION;	else		version_no = atoi(version);	switch(args[1]){	case RECOG_OLD:		if(confirmpath(path) == 0)			return(NIL);		if(getoldfile(path, name+1, version_no, version) == 0)			return(NIL);		break;	case RECOG_OLDEST:		if(confirmpath(path) == 0)			return(NIL);		if(version_no == MAXVERSION){			if(getoldestfile(path, name+1) == 0)				return(NIL);		}else{			if(getoldfile(path, name+1, version_no, version) == 0)				return(NIL);		}		break;	case RECOG_NEW_OLD:		if(confirmpath(path) != 0)			if(getoldfile(path, name+1, version_no, version) != 0)				break;		if(createpath(path) == 0)			return(NIL);		if(version_no == MAXVERSION){			if(getnewfile(path, name+1) == 0)				return(NIL);		}else{			strcat(name, ";");			strcat(name, version);		}		break;	case RECOG_NEW:		if(createpath(path) == 0)			return(NIL);		if(version_no == MAXVERSION){			if(getnewfile(path, name+1) == 0)				return(NIL);		}else{			strcat(name, ";");			strcat(name, version);		}		break;	case RECOG_NON:		if(confirmpath(path) == 0)			return(NIL);		naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));		base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));		length = strlen(fullpathname);#ifndef BYTESWAP		strncpy(base, fullpathname, length);#else		StrNCpyFromCToLisp(base, fullpathname ,length);#endif BYTESWAP		return(GetSmallp(length));		default:		return(NIL);	}	strcat(path, name);	/*** CStringToLispString ***/	naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));	length = strlen(path);#ifndef BYTESWAP	strncpy(base, path, length);#else	StrNCpyFromCToLisp(base, path, length);#endif BYTESWAP	return(GetSmallp(length));}DSK_deletefile(args)register LispPTR	*args;/*	args[0]:	Indirect pointer to buffer	*//*	args[1]:	pointer to errno	*/{char	pathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));	#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	RemoveDodNoExtenstion(pathname);	if(checklink_and_changeversion(pathname) == 0)		return(NIL);	LispVersionToUnixVersion(pathname);	if(changelink_and_delete(pathname) == 0)		return(NIL);	return(ATOM_T);}DSK_renamefile(args)register LispPTR	*args;/*	args[0]:	Indirect pointer to buffer (old file name)	*//*	args[1]:	Indirect pointer to buffer (new file name)	*//*	args[2]:	pointer to errno	*/{char	old_pathname[MAXPATHLEN], new_pathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));	#endif	LispStringToCString(args[0], old_pathname, MAXPATHLEN);	RemoveDodNoExtenstion(old_pathname);	if(checklink_and_changeversion(old_pathname) == 0)		return(NIL);	LispVersionToUnixVersion(old_pathname);	LispStringToCString(args[1], new_pathname, MAXPATHLEN);	RemoveDodNoExtenstion(new_pathname);	if(checklink_and_changeversion(new_pathname) == 0)		return(NIL);	LispVersionToUnixVersion(new_pathname);	if(changelink_and_rename(old_pathname, new_pathname) == 0)		return(NIL);	if(makenewlink(new_pathname) == 0)		return(NIL);	return(ATOM_T);}DSK_directorynamep(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to Directory Name *//*	args[1]:	errno */ /** [hh:11/15] It is not passed from LISP **/			/** [hh:12/06] It is passed from new lisp code **/{struct	stat	sbuf;	/* Strucure for FileInfo. */char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));/**	Lisp_errno = &Dummy_errno; **/#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	DBPRINT(("Checking path name:  %s\n", pathname));	if( makepathname(pathname, fullpathname) == 0)		return(NIL);	DBPRINT(("And full path:  %s\n", fullpathname));	if(confirmpath(fullpathname) == 0)		return(NIL);	return(ATOM_T);}DSK_getfileinfo(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to File Name *//*	args[1]:	IndirectPonter to Attribute *//*	args[2]:	IndirectPonter to BUffer *//* args[3]		buf for errno */{register int	rval;register unsigned int	*buffixp;register struct passwd *pwd;LispPTR	*naddress;char	*base;struct stat sbuf;char	pathname[MAXPATHLEN];LispPTR	lisp_addr;#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	RemoveDodNoExtenstion(pathname);	if(checklink_and_changeversion(pathname) == 0)		return(NIL);	LispVersionToUnixVersion(pathname);#ifdef	FSERROR	ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	TIMEOUT(rval=stat(pathname, &sbuf));	if(rval != 0){		err_mess("stat", errno);#ifdef	FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	switch(args[1]){	case SIZE:		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));		*buffixp = sbuf.st_size;		return(ATOM_T);	case WDATE:		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));		*buffixp = ToLispTime(sbuf.st_mtime);		return(ATOM_T);	case RDATE:		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));		*buffixp= ToLispTime(sbuf.st_atime);		return(ATOM_T);	case AUTHOR:		TIMEOUT(pwd=getpwuid(sbuf.st_uid));		if(pwd == NULL){#ifdef FSERROR			*Lisp_errno = errno;#endif		/** changed to return 0 for author's name length -was **/			return(GetSmallp(0));		}			/*** CStringToLispString ***/		naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));		base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));		rval = strlen(pwd->pw_name);#ifndef BYTESWAP		strncpy( base, pwd->pw_name, rval );#else		StrNCpyFromCToLisp( base, pwd->pw_name, rval );#endif BYTESWAP		return(GetSmallp(rval));	case PROTECTION:		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));		*buffixp= sbuf.st_mode;		return(ATOM_T);	case ALL:		/* length */		lisp_addr = cdr(car(args[2]));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp= sbuf.st_size;		/* wdate */		lisp_addr = cdr(car(cdr(args[2])));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp = ToLispTime(sbuf.st_mtime);		/* rdate */		lisp_addr = cdr(car(cdr(cdr(args[2]))));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp= ToLispTime(sbuf.st_atime);		/* protection */		lisp_addr = cdr(car(cdr(cdr(cdr(args[2])))));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp= sbuf.st_mode;		/* author */		TIMEOUT( pwd = getpwuid(sbuf.st_uid) );		if(pwd == NULL){#ifdef FSERROR			*Lisp_errno = errno;#endif				/** changed to return 0 for author's name length -was **/			return(GetSmallp(0));		}		lisp_addr = cdr(car(cdr(cdr(cdr(cdr(args[2]))))));		naddress = (LispPTR *)(Addr68k_from_LADDR(lisp_addr));		base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));		rval = strlen(pwd->pw_name);#ifndef BYTESWAP		strncpy( base, pwd->pw_name, rval );	#else		StrNCpyFromCToLisp( base, pwd->pw_name, rval );#endif BYTESWAP			return(GetSmallp(rval));	default:		return(NIL);	}}DSK_setfileinfo(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to File Name *//*	args[1]:	IndirectPonter to Attribute *//*	args[2]:	IndirectPonter to BUffer *//*	args[3]:	errno */{register int	date;register int	rval;static struct timeval time[2];struct stat	sbuf;char	pathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	RemoveDodNoExtenstion(pathname);	if(checklink_and_changeversion(pathname) == 0)		return(NIL);	LispVersionToUnixVersion(pathname);#ifdef	FSERROR	ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	switch(args[1]){	case WDATE:		TIMEOUT( rval=stat(pathname, &sbuf) );		if(rval != 0){			err_mess("stat", errno);#ifdef FSERROR			*Lisp_errno = errno;#endif			return(NIL);		}		date = LispNumToCInt(args[2]);		time[0].tv_sec = (long)sbuf.st_atime;		time[1].tv_sec = (long)ToUnixTime(date);		TIMEOUT(rval=utimes(pathname, time));		if(rval != 0){			err_mess("utimes", errno);#ifdef FSERROR			*Lisp_errno = errno;#endif			return(NIL);		}		return(ATOM_T);	case PROTECTION:		rval = LispNumToCInt(args[2]);		TIMEOUT( rval=chmod(pathname, rval) );		if(rval != 0){			err_mess("chmod", errno);#ifdef FSERROR			*Lisp_errno = errno;#endif			return(NIL);		}		return(ATOM_T);	default:		return(NIL);	}}DSK_dirsize(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to Directory Name *//*	args[1]:	IndirectPonter to Filter Name *//*	args[2]:	Ponter to errno */{register int	size;char	dirname[MAXPATHLEN];char	fulldirname[MAXPATHLEN];char	filter[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));	#endif	LispStringToCString(args[0], dirname, MAXPATHLEN);	if( makepathname(dirname, fulldirname) == 0)		return(NIL);	if(confirmpath(fulldirname) == 0)		return(NIL);	LispStringToCString(args[1], filter, MAXPATHLEN);	LispVersionToUnixVersion(filter);	size = alldirSize( fulldirname, "", 0, filter);	if(size == -1)		return(NIL);	else		return(GetSmallp(size));}DSK_readdir(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to Directory Name *//*	args[1]:	IndirectPonter to Filter Name *//*	args[2]:	IndirectPonter to BUffer *//*	args[3]:	errno */{register int	size;register LispPTR	*naddress;register char	*base;char	dirname[MAXPATHLEN];char	fulldirname[MAXPATHLEN];char	filter[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	#endif	LispStringToCString(args[0], dirname, MAXPATHLEN);	if( makepathname(dirname, fulldirname) == 0)		return(NIL);	if(confirmpath(fulldirname) == 0)		return(NIL);	/* string in filter is right order even on i386 */	LispStringToCString(args[1], filter, MAXPATHLEN);	LispVersionToUnixVersion(filter);	naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));	size = DSK_readAllDir(fulldirname, "", 0, filter, base);	if(size == -1)		return(NIL);	else		return(GetSmallp(size));}DSK_changedir(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to Directory Name */{register int	rval;char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = &Dummy_errno;	#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	if( makepathname(pathname, fullpathname) == 0)		return(NIL);	SETJMP(0);		/* No errp is passed from Lisp, so ERRSETJMP is not used */	TIMEOUT(rval=chdir(fullpathname));	if(rval != 0){		err_mess("chdir", errno);		return(NIL);	}	return(ATOM_T);}/********************************************	Subroutines********************************************/parse(pathname, path, name, version)register char	*pathname;register char	*path;register char	*name;char	*version;{register char	*cp;	if((cp = rindex(pathname,'/')) == 0)		return(0);	if(cp == pathname)		*path = '\0';	else{		for(;pathname!=cp;)			*path++ = *pathname++;		*path = '\0';	}	if((cp = index(pathname,';')) == 0){		/* No version number */		strcpy(name, pathname);		*version = '\0';		return(1);	}	if(cp == pathname)		*name = '\0';	else{		for(;pathname!=cp;)			*name++ = *pathname++;		*name = '\0';	}	for(++pathname;*pathname!='\0';)		*version++ = *pathname++;	*version = '\0';	return(1);}confirmpath(path)register char	*path;{register char	*cp;register char	*savep;char	save_path[MAXPATHLEN];	for(cp=path, savep=save_path;*cp!='\0';){		*savep++ = *cp++;		if(*cp == '/')			*savep++ = '\0';	}	*savep++ = '\0';	*savep = '@';	*path = '\0';	for(savep = save_path;;){		if(getpathname(path, savep, 0) == 0)			return(0);		for(;*savep!='\0';savep++);		if(*(++savep) == '@')			return(1);	}}		createpath(path)register char	*path;{register char	*cp;register char	*savep;register int	rval;char	save_path[MAXPATHLEN];	for(cp=path, savep=save_path;*cp!='\0';){		*savep++ = *cp++;		if(*cp == '/')			*savep++ = '\0';	}	*savep++ = '\0';	*savep = '@';	*path = '\0';	for(savep = save_path;;){		if(getpathname(path, savep, 0) == 0){			strcat(path,savep);#ifdef	FSERROR			ERRSETJMP(0);#else			SETJMP(0);#endif			TIMEOUT(rval=mkdir(path, 0777));			if(rval == -1){				err_mess("mkdir", errno);#ifdef	FSERROR				*Lisp_errno = errno;#endif				return(0);			}		}		for(;*savep!='\0';savep++);		if(*(++savep) == '@')			return(1);	}}		getpathname(pathname, name, type)register char	*pathname;register char	*name;register int	type;		/* 0: Directory, 1: File */{struct	stat	statbuf;char	newpathname[MAXPATHLEN];char	save_name[MAXPATHLEN];#ifdef	FSERROR	ERRSETJMP(0);#else	SETJMP(0);#endif	strcpy(save_name, name);	switch(type){	case 0:	/* name is directory */		DBPRINT(("DIRP of: %s\n", name));		DIRP(pathname, save_name, newpathname);		DOWNCASE(save_name);		DIRP(pathname, save_name, newpathname);		UPCASE(save_name);		DIRP(pathname, save_name, newpathname);		break;	case 1:	/* name is file */		FILEP(pathname, save_name, newpathname);		DOWNCASE(save_name);		FILEP(pathname, save_name, newpathname);		UPCASE(save_name);		FILEP(pathname, save_name, newpathname);		break;	default:		return(0);	}	if(searchdir(pathname, save_name+1) == 0)		return(0);	else		return(1);}searchdir(path, file)char	*path;register char	*file;	/* UPCASEd name without '/' */{register int	len;register DIR	*dirp;register struct direct	*dp;char	dirname[MAXPATHLEN];#ifdef	FSERROR	ERRSETJMP(0);#else	SETJMP(0);#endif	len = strlen(file);	TIMEOUT( dirp=opendir(path) );	if(dirp == NULL){#ifdef	FSERROR		*Lisp_errno = errno;#endif		return(0);	}	for(S_TOUT(dp=readdir(dirp)); dp!=NULL; S_TOUT(dp=readdir(dirp)) )		if(dp->d_namlen==len){			strcpy(dirname, dp->d_name);			UPCASE(dirname);			if(STREQ(dirname, file)){				sprintf(path, "%s/%s", path, dp->d_name);				TIMEOUT( closedir(dirp) );				return(1);			}		}	TIMEOUT( closedir(dirp) );	return(0);}parseversion(name, version)register char	*name;			/* UNIX format, .~#~ */register char	*version;		/* Result is "123" or "123%%" like this */{register char	*cp, *cp1;register int	length;	for(cp=name;;++cp){		switch(*cp){		case '.':			if(*(cp+1)=='~' && (cp1=index(cp+2, '~'))!=0){				*cp = '\0';				length = (int)cp1 - (int)cp - 2;				if(length == 0){					version[0] = '0';					version[1] = '\0';					return;				}else{					strncpy(version, cp+2, length);					version[length] = '\0';					strcat(version, cp1+1);					return;				}			}else				break;		case '\0':			version[0] = '0';			version[1] = '\0';			return;		}	}}DSK_readpage(){/* Old entry */}DSK_writepage()		{/* Old entry */}DSK_getsize(){/* Old entry */}DSK_currentdir(){/* Old entry */}getoldfile(path, file, version, ver_field)char	*path;register char	*file;		/* file does not have version filed, foo.c */register int	version;	/* version == 0 : file does not have version number */char	*ver_field;	/* Some character may be added after number, like ;2% */{register FileName	*p_version_array;register FileName	*p_version_high;register FileName	*p_version_less;FileName	*p_version;char		name[MAXPATHLEN];char		ver[VERSIONLEN];/* version number is not specified */	if(version == MAXVERSION){		return(getnewestfile(path, file));	}/* version number is specifed */	p_version_array = VersionArray;	if(LookUpFileVersion(path, file, p_version_array, &VArrayInfo) == 0)		return(0);	if(NoFileP(p_version_array)){		/* No file exist */		return(0);	}	p_version_high = GetHighestVersion(p_version_array);	if(p_version_high && (p_version_less=VersionlessP(p_version_array)) && CheckOnlyNumber(ver_field)){			/* version 0 exist, and version shoud be changed */		if(LinkWithVersionlessP(path, p_version_high->name)){			/* Highest link with versionless */			if( version==0 || version==p_version_high->version_no){				/* return highest name */				strcpy(file, p_version_high->name);				UnixVersionToLispVersion(file);				AddDodNoExtention(file);				return(1);			}		}else{			/* Highest does not link with versionleess */					if(version==0 || version==(p_version_high->version_no)+1 ){				/* versionless will be renamed to highest+1 */				sprintf(file, "%s.~%d~", p_version_less->name,(p_version_high->version_no)+1 );				UnixVersionToLispVersion(file);				AddDodNoExtention(file);				return(1);			}		}	}	/* versionless NOT exist, or NOT link, or version is NOT 0 or highest+1 */	for(p_version=p_version_array;p_version->version_no!=LASTVERSIONARRAY;++p_version){		strcpy(name, p_version->name );		parseversion(name, ver);		if( STREQ(ver, ver_field) ){			strcpy(file, p_version->name );			UnixVersionToLispVersion(file);			AddDodNoExtention(file);			return(1);		}	}	return(0);}CheckOnlyNumber(name)char	*name;{register char	*cp;	for(cp=name; *cp!='\0';++cp)		if( *cp>'9' || *cp<'0' )			return(0);	return(1);}getnewestfile(path, file)char	*path;register char	*file;		/* No version field */{register FileName	*p_version_array;register FileName	*p_version_high;register FileName	*p_version_less;	p_version_array = VersionArray;	if(LookUpFileVersion(path, file, p_version_array, &VArrayInfo) == 0)		return(0);	if(NoFileP(p_version_array)){		/* No file exist */		return(0);	}else{		if( (p_version_high = GetHighestVersion(p_version_array)) == 0)			return(0);		if(p_version_less = VersionlessP(p_version_array)){			/* version 0 is newest */			if(LinkWithVersionlessP(path, p_version_high->name)){				/* Highest link with versionless */				strcpy(file, p_version_high->name );				UnixVersionToLispVersion(file);				AddDodNoExtention(file);				return(1);			}else{				/* Versionless has no link */				sprintf(file, "%s;%d", p_version_less->name, p_version_high->version_no+1);				AddDodNoExtention(file);				return(1);			}		}else{			/* highest version is newest */			strcpy(file, p_version_high->name );			UnixVersionToLispVersion(file);			AddDodNoExtention(file);			return(1);		}	}}	getnewfile(path, file)register char	*path;register char	*file;		/* No version name, foo.c */{register FileName	*p_version_high;register FileName	*p_version_array;		p_version_array = VersionArray;	if(LookUpFileVersion(path, file, p_version_array, &VArrayInfo) == 0){		/* new file is versionless */		sprintf(file, "%s;%d", file, 1);		AddDodNoExtention(file);		return(1);	}	if(NoFileP(p_version_array)){		/* new file is versionless */		sprintf(file, "%s;%d", file, 1);		AddDodNoExtention(file);		return(1);	}else{		if( (p_version_high=GetHighestVersion(p_version_array)) == 0 ){			/* new file is versionless */			sprintf(file, "%s;%d", file, 1);			AddDodNoExtention(file);			return(1);		}		if(VersionlessP(p_version_array)){			/* versionless exists  */			if(LinkWithVersionlessP(path, p_version_high->name)){				/* Highest link with versionless */				/* newfile is highest+1 */				sprintf(file, "%s;%d", file, (p_version_high->version_no+1));				AddDodNoExtention(file);				return(1);			}else{				/* Versionless has no link */				/* newfile is highest+2, versionless->highest+1 */				sprintf(file, "%s;%d", file, (p_version_high->version_no+2));				AddDodNoExtention(file);				return(1);			}		}else{			/* new file is highest+1 */			sprintf(file, "%s;%d", file, (p_version_high->version_no+1));			AddDodNoExtention(file);			return(1);		}	}}getoldestfile(path, file)char	*path;register char	*file;{register FileName	*p_version_low;register FileName	*p_version_array;	p_version_array = VersionArray;	if(LookUpFileVersion(path, file, p_version_array, &VArrayInfo) == 0)		return(0);	if(NoFileP(p_version_array)){		/* No file exist */		return(0);	}else{		if(( p_version_low=GetLowestVersion(p_version_array)) == 0 ){			return(0);		}		if( p_version_low->version_no == 0){			sprintf(file, "%s;1", p_version_low->name );			AddDodNoExtention(file);			return(1);		}else{			strcpy(file, p_version_low->name );			UnixVersionToLispVersion(file);			AddDodNoExtention(file);			return(1);		}	}}checklink_and_changeversion(pathname)register char	*pathname;	/* Lisp convetion, /users/hayata/foo.c;3, /foo.c or /foo.c;0 */{register FileName	*p_version_array;register FileName	*p_version;register FileName	*p_version_high;register int	ver_no;char	path[MAXPATHLEN];char	name[MAXPATHLEN];char	file[MAXPATHLEN];char	version[VERSIONLEN];char	version2[VERSIONLEN];	if(parse(pathname, path, file, version) == 0)	/* file: /foo.c, verion: 2 */		return(0);	ver_no = atoi(version);	p_version_array = VersionArray;	if(LookUpFileVersion(path, file+1, p_version_array, &VArrayInfo) == 0){		/* versionless NOT exist. version 1 is specified. It means version1 should be versionless */		if(ver_no == 1 && STREQ("1", version)){			ChangeToVersionless(pathname);			return(1);		}		/* No file not version 1, no need to change */		return(1);	}	if(NoFileP(p_version_array)){		/* versionless NOT exist. version 1 is specified. It means version1 should be versionless */		if(ver_no == 1 && STREQ("1", version)){			ChangeToVersionless(pathname);			return(1);		}		/* No file not version 1, no need to change */		return(1);	}	/* check, specified version file exist. if exist, return 1 */	for(p_version=p_version_array;p_version->version_no!=LASTVERSIONARRAY;++p_version){		if(p_version->version_no == ver_no){			strcpy(name, p_version->name );			parseversion(name, version2);			if( STREQ(version2, version) )				/* The specified file exist */				return(1);		}	}	/* specified version does not exist */	if(VersionlessP(p_version_array)){		if( (p_version_high=GetHighestVersion(p_version_array)) == 0 )			return(0);		if(ver_no == 0 && STREQ("0", version)){			ChangeToVersionless(pathname);			return(1);		}		if(ver_no == 1 && STREQ("1", version)){			if(p_version_high->version_no == 0){				/* versionless exist, versiion 1 NOT exist */				ChangeToVersionless(pathname);				return(1);			}		}		if(ver_no == (p_version_high->version_no)+1){			sprintf(version2, "%d", p_version_high->version_no+1);			if( STREQ(version2, version) ){				if(LinkWithVersionlessP(path, p_version_high->name)){					/* No need to change version */					return(1);				}else{					ChangeToVersionless(pathname);					return(1);				}			}		}	}	/* versionless NOT exist. version 1 is specified. It means version1 should be versionless */	if(ver_no == 1 && STREQ("1", version)){		if(p_version_high->version_no == 0){			ChangeToVersionless(pathname);			return(1);		}	}	/* The specified file does not exist, no need to change */	return(1);}makenewlink(pathname)register char	*pathname;	/* A file to be opend, /users/hayata/foo.c.~3~ */{	register FileName	*p_version_array;register FileName	*p_version_nhigh;register FileName	*p_version_less;register int	rval;char	path[MAXPATHLEN];char	path2[MAXPATHLEN];char	file[MAXPATHLEN];char	version[VERSIONLEN];#ifdef	FSERROR	ERRSETJMP(0);#else	SETJMP(0);#endif	if(parse(pathname, path, file, version) == 0)	/* file is /foo.c.~2~ */		return(0);	parseversion(file, version);	/* file is /foo.c */	if( STREQ(version, "0") ){		/* open versionless file, no need to link */		return(1);	}	p_version_array = VersionArray;	if(LookUpFileVersion(path, file+1, p_version_array, &VArrayInfo) == 0)		return(1);	if(NoFileP(p_version_array)){		/*open versionless file, no need to link */		return(1);	}	if(p_version_less = VersionlessP(p_version_array)){			/* versionless exists  */		if( (p_version_nhigh=GetNextHighestVersion(p_version_array)) == 0 )			return(1);		if(LinkWithVersionlessP(path, p_version_nhigh->name)){			/* Next highest linked with versionless */			/* unlink versionless */			sprintf(path, "%s/%s", path, p_version_less->name);#ifdef	FSERROR			ERRSETJMP(0);#else			SETJMP(0);#endif			TIMEOUT( rval = unlink(path) );			if(rval == -1){				/* can not remove */				err_mess("unlink", errno);				OSMESSAGE_PRINT( printf("Can not unlink %s.\n", path) );				return(0);			}			/* link opening file(next highest+1) with versionless */			LINK(pathname, path);#ifdef	FSMESSAGE			OSMESSAGE_PRINT( printf("%s is linked with %s\n", pathname, path) );#endif			return(1);		}else{			/* Versionless has no link */			/* versionless is moved to next highest+1 */			sprintf(path2, "%s%s.~%d~", path, file, (p_version_nhigh->version_no)+1 );			sprintf(path, "%s/%s", path, p_version_less->name);#ifdef	FSERROR			ERRSETJMP(0);#else			SETJMP(0);#endif			TIMEOUT( rval = rename(path, path2) );			if(rval == -1){				err_mess("rename", errno);				OSMESSAGE_PRINT( printf("Can not rename %s to %s\n", path, path2) );				return(0);			}			/* link opening file(next highest+2) with versionless */			LINK(pathname, path);#ifdef	FSMESSAGE			OSMESSAGE_PRINT( printf("%s is linked with %s\n", pathname, path) );#endif			return(1);		}	}else{		/* link highest with versionless */		sprintf(path, "%s%s", path, file);#ifdef	FSERROR		ERRSETJMP(0);#else		SETJMP(0);#endif		LINK(pathname, path);#ifdef	FSMESSAGE		OSMESSAGE_PRINT( printf("%s is linked with %s\n", pathname, path) );#endif		return(1);	}}changelink_and_delete(pathname)char	*pathname;	/* A file to be removed, /users/hayata/foo.c.~3~ */{	register FileName	*p_version_array;register FileName	*p_version_high;register FileName	*p_version_nhigh;register FileName	*p_version_less;register int	rval;struct stat sbuf;char	path[MAXPATHLEN];char	path2[MAXPATHLEN];char	file[MAXPATHLEN];char	file2[MAXPATHLEN];char	version[VERSIONLEN];#ifdef	FSERROR	ERRSETJMP(0);#else	SETJMP(0);#endif	TIMEOUT(rval=stat(pathname, &sbuf));	if(rval != 0){		err_mess("stat", errno);#ifdef	FSERROR		*Lisp_errno = errno;#endif		return(0);	}	if(sbuf.st_nlink == 1){		/* No link -> no need to change link, just unlink */		UNLINK(pathname);		return(1);	}	if(parse(pathname, path, file, version) == 0)		return(0);	parseversion(file, version);	/* file is /foo.c */	p_version_array = VersionArray;	if(LookUpFileVersion(path, file+1, p_version_array, &VArrayInfo) == 0){		return(0);	}	if(NoFileP(p_version_array)){		return(0);	}#ifdef	FSERROR	ERRSETJMP(0);#else	SETJMP(0);#endif	if(*version == '0'){		/* deleting file is versionless */		p_version_high = GetHighestVersion(p_version_array);		if(p_version_high && VersionlessP(p_version_array)){			/* versionless exists  */			if(LinkWithVersionlessP(path, p_version_high->name)){				/* Highest link with versionless */				/* unlink versionless */#ifdef	FSERROR				ERRSETJMP(0);#else				SETJMP(0);#endif				UNLINK(pathname);				/* unlink highest */				sprintf(path2, "%s/%s", path, p_version_high->name); 				UNLINK(path2);				/* next highest link with versionless */				if( (p_version_nhigh=GetNextHighestVersion(p_version_array)) == 0 )					return(1);				sprintf(path2, "%s/%s", path, p_version_nhigh->name);				LINK(path2, pathname);#ifdef	FSMESSAGE				OSMESSAGE_PRINT( printf("%s is linked with %s\n", path2, pathname) );#endif				return(1);			}else{				/* Versionless has link with another file but highest */				/* unlink versionless, highest link with versionless */#ifdef	FSERROR				ERRSETJMP(0);#else				SETJMP(0);#endif				UNLINK(pathname);				/* highest link with versionless */				sprintf(path2, "%s/%s", path,p_version_high->name); 				LINK(path2, pathname);#ifdef	FSMESSAGE				OSMESSAGE_PRINT( printf("%s is linked with %s\n", path2, pathname) );#endif				return(1);			}		}else{			/* deleting file(versionless) not exist */			return(0);		}	}else{		/* deleting file is not versionless */		if(p_version_less = VersionlessP(p_version_array)){			/* versionless exists  */			sprintf(file2, "%s.~%s~", file+1, version);			if(LinkWithVersionlessP(path, file2)){				/* deleting file link with versionless */				/* unlink deleting file */#ifdef	FSERROR				ERRSETJMP(0);#else				SETJMP(0);#endif				UNLINK(pathname);				/* unlink versionless */				sprintf(path2, "%s/%s", path, p_version_less->name); 				UNLINK(path2);				/* next highest link with versionless */				if( (p_version_nhigh=GetNextHighestVersion(p_version_array)) == 0 )					return(1);				sprintf(path, "%s/%s", path, p_version_nhigh->name);				LINK(path, path2);#ifdef	FSMESSAGE				OSMESSAGE_PRINT( printf("%s is linked with %s\n",path, path2) );#endif				return(1);			}else{				/*deleting file link with another file but versionless */				/* unlink deletingfile */#ifdef	FSERROR				ERRSETJMP(0);#else				SETJMP(0);#endif				UNLINK(pathname);				return(1);			}		}else{			/* versionless not exist, just unlink deleting file */#ifdef	FSERROR			ERRSETJMP(0);#else			SETJMP(0);#endif			UNLINK(pathname);			return(1);		}		}}changelink_and_rename(pathname, newfile)char	*pathname;	/* A file to be renameed, /users/hayata/foo.c.~3~ */register char	*newfile;	/* new file name, /users/hayata/foo.c.~5~ */{	register FileName	*p_version_array;register FileName	*p_version_high;register FileName	*p_version_nhigh;FileName	*p_version_less;register int	rval;struct stat sbuf;char	path[MAXPATHLEN];char	path2[MAXPATHLEN];char	file[MAXPATHLEN];char	file2[MAXPATHLEN];char	version[VERSIONLEN];#ifdef	FSERROR	ERRSETJMP(0);#else	SETJMP(0);#endif	TIMEOUT(rval=stat(pathname, &sbuf));	if(rval != 0){		err_mess("stat", errno);#ifdef	FSERROR		*Lisp_errno = errno;#endif		return(0);	}	if(sbuf.st_nlink == 1){		/* No link -> no need to change link, just rename */		RENAME(pathname, newfile);	return(1);	}	if(parse(pathname, path, file, version) == 0)		return(0);	parseversion(file, version);	/* file is /foo.c */	p_version_array = VersionArray;	if(LookUpFileVersion(path, file+1, p_version_array, &VArrayInfo) == 0)		return(0);	if(NoFileP(p_version_array)){		return(0);	}#ifdef	FSERROR	ERRSETJMP(0);#else	SETJMP(0);#endif	if(*version == '0'){		/* renaming file is versionless */		p_version_high = GetHighestVersion(p_version_array);		if(p_version_high && VersionlessP(p_version_array)){			/* versionless exists  */			if(LinkWithVersionlessP(path, p_version_high->name)){				/* Highest link with versionless */				/* rename versionless */#ifdef	FSERROR				ERRSETJMP(0);#else				SETJMP(0);#endif				RENAME(pathname, newfile);				/* unlink highest */				sprintf(path2, "%s/%s", path, p_version_high->name); 				UNLINK(path2);				/* next highest link with versionless */				if( (p_version_nhigh = GetNextHighestVersion(p_version_array)) == 0)					return(1);				sprintf(path2, "%s/%s", path, p_version_nhigh->name);				LINK(path2, pathname);#ifdef	FSMESSAGE				OSMESSAGE_PRINT( printf("%s is linked with %s\n", path2, pathname) );#endif				return(1);			}else{				/* Versionless has link with another file but highest */				/* rename versionless, highest link with versionless */#ifdef	FSERROR				ERRSETJMP(0);#else				SETJMP(0);#endif				RENAME(pathname, newfile);				/* highest link with versionless */				sprintf(path2, "%s/%s", path,p_version_high->name); 				LINK(path2, pathname);#ifdef	FSMESSAGE				OSMESSAGE_PRINT( printf("%s is linked with %s\n", path2, pathname) );#endif				return(1);			}		}else{			/* renaming file(versionless) not exist */			return(0);		}	}else{		/* renaming file is not versionless */		if(p_version_less = VersionlessP(p_version_array)){			/* versionless exists  */			sprintf(file2, "%s.~%s~", file+1, version);			if(LinkWithVersionlessP(path, file2)){				/* deleting file link with versionless */				/* rename file */#ifdef	FSERROR				ERRSETJMP(0);#else				SETJMP(0);#endif				RENAME(pathname, newfile);				/* unlink versionless */				sprintf(path2, "%s/%s", path, p_version_less->name); 				UNLINK(path2);				/* next highest link with versionless */				if( (p_version_nhigh=GetNextHighestVersion(p_version_array)) == 0 )					return(1);				sprintf(path, "%s/%s", path, p_version_nhigh->name);				LINK(path, path2);#ifdef	FSMESSAGE				OSMESSAGE_PRINT( printf("%s is linked with %s\n",path, path2) );#endif				return(1);			}else{				/*renaming file link with another file but versionless */				/* renam file */#ifdef	FSERROR				ERRSETJMP(0);#else				SETJMP(0);#endif				RENAME(pathname, newfile);				return(1);			}		}else{			/* versionless not exist, just rename file */#ifdef	FSERROR			ERRSETJMP(0);#else			SETJMP(0);#endif			RENAME(pathname, newfile);			return(1);		}		}}						LookUpFileVersion(path, file, version_array, cache)char	*path;char	*file;		/* No version field */register FileName	*version_array;CurrentVArray		*cache;{			register DIR	*dirp;register struct direct	*dp;int	rval;struct stat stat_buf;char	name[MAXPATHLEN];char	ver[VERSIONLEN];char	save_file[MAXPATHLEN];#ifdef	FSERROR	ERRSETJMP(0);#else	SETJMP(0);#endif/* Cache of directory cause error in auto test 22-3-1-WRITE-CHAR *//* So, cacheing mechanisum is masked in the following #ifdef 0... *//* (02-Aug-88:Hayata) */	/* Is cache availabe ? */ 	strcpy(save_file, file);	DOWNCASE(save_file);#ifdef NEVER	STAT(path, &stat_buf);/*** BBob's code#ifdef 0	if((stat_buf.st_mtime == cache->mtime) && STREQ(save_file, cache->file) && STREQ(path, cache->path) ){		return(T);	}#endif***/	if(0 && (stat_buf.st_mtime == cache->mtime) && STREQ(save_file, cache->file) && STREQ(path, cache->path) ){		/* chached version_array is available */		return(T);	}#endif NEVER	/* cached version_array must be updated */	/* JDS 8/23/90 - if path is "", it's really /. */	if (`\0` == *path) TIMEOUT(dirp = opendir("/"));	else TIMEOUT( dirp = opendir(path) );	if(dirp == NULL){#ifdef	FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	for(S_TOUT(dp=readdir(dirp)); dp!=NULL; S_TOUT(dp=readdir(dirp)) ){		strcpy(name, dp->d_name);		parseversion(name, ver);		DOWNCASE(name);		if( STREQ(save_file, name) ){			strcpy(version_array->name, dp->d_name);			if(*ver == '\0')				version_array->version_no = 0;			else				version_array->version_no = atoi(ver) ;			++version_array;		}	}	version_array->version_no = LASTVERSIONARRAY;	/* cache information is also updated */	strcpy(cache->path, path);	strcpy(cache->file, save_file);	cache->mtime = stat_buf.st_mtime;	TIMEOUT( closedir(dirp) );	return(T);}FileName *VersionlessP(version_array)register FileName	*version_array;{char	name[MAXPATHLEN];char	ver[VERSIONLEN];	for(;version_array->version_no != LASTVERSIONARRAY; ++version_array){		if(version_array->version_no == 0){			/* find version 0 */			strcpy(name, version_array->name);			parseversion(name, ver);			if(CheckOnlyNumber(ver)){				return(version_array);			}		}	}	return(NIL);}FileName *GetHighestVersion(version_array)register FileName	*version_array;{register FileName	*p_max;register int	max = -1;char	name[MAXPATHLEN];char	ver[VERSIONLEN];	p_max = 0;	for(;version_array->version_no != LASTVERSIONARRAY; ++version_array){		if(version_array->version_no > max){			/* find large number */			strcpy(name, version_array->name);			parseversion(name, ver);			if(CheckOnlyNumber(ver)){				max = version_array->version_no;				p_max = version_array;			}		}	}	return(p_max);}FileName *GetNextHighestVersion(version_array)register FileName	*version_array;{register FileName	*p_next_max;register FileName	*p_max;register int	max = -1;register int	next_max;char	name[MAXPATHLEN];char	ver[VERSIONLEN];	p_next_max = 0;	for(;version_array->version_no != LASTVERSIONARRAY; ++version_array){		if(version_array->version_no > max){			/* find large number */			strcpy(name, version_array->name);			parseversion(name, ver);			if(CheckOnlyNumber(ver)){				next_max = max;				p_next_max = p_max;				max = version_array->version_no;				p_max = version_array;			}		}else			if(version_array->version_no > next_max){				/* update next max */				strcpy(name, version_array->name);				parseversion(name, ver);				if(CheckOnlyNumber(ver)){					next_max = version_array->version_no;					p_next_max = version_array;				}			}		}	return(p_next_max);}FileName *GetLowestVersion(version_array)register FileName	*version_array;{register FileName	*p_min;register FileName	*p_0;register int	minv = MAXVERSION;char	name[MAXPATHLEN];char	ver[VERSIONLEN];	p_0 = 0;	p_min = 0;	for(;version_array->version_no != LASTVERSIONARRAY; ++version_array){		if(version_array->version_no == 0){			strcpy(name, version_array->name);			parseversion(name, ver);			if(CheckOnlyNumber(ver))				p_0 = version_array;		}else{			if(version_array->version_no < minv){				/* find large number */				strcpy(name, version_array->name);				parseversion(name, ver);				if(CheckOnlyNumber(ver)){					minv = version_array->version_no;					p_min = version_array;				}			}		}	}	if( (minv == MAXVERSION) && (p_0 != 0) )		return(p_0);	else		return(p_min);}LinkWithVersionlessP(path, file)char	*path;char	*file;{register ino_t	ino;register int	rval;register DIR	*dirp;register struct direct	*dp;register char	*cp, *cp1;struct stat sbuf;char	name[MAXPATHLEN];char	save_file[MAXPATHLEN];char	ver[VERSIONLEN];#ifdef	FSERROR	ERRSETJMP(0);#else	SETJMP(0);#endif	sprintf(save_file, "%s/%s", path, file);	if( (cp=rindex(save_file, '~'))!=0 && (cp1=index(save_file, '~'))!=0 && cp1!=cp && *(cp1-1) == '.'){		/* save_file with version */		TIMEOUT(rval=stat(save_file, &sbuf));		if(rval != 0){#ifdef FSERROR			*Lisp_errno = errno;#endif			err_mess("stat", errno);			return(0);		}		if(sbuf.st_nlink == 1){			return(0);		}		ino = sbuf.st_ino;		/* make versionless file */		*(cp1-1) = '\0';		/* get inode of versionless file */		TIMEOUT(rval=stat(save_file, &sbuf));		if(rval != 0){			if(errno != ENOENT){#ifdef FSERROR				*Lisp_errno = errno;#endif				err_mess("stat", errno);				return(0);			}else{				/* check with case in-sensitiveness */				strcpy(save_file, file);				if((cp=index(save_file, '~'))==0)					return(0);				/* make versionless */				*(cp-1) = '\0';				DOWNCASE(save_file);				TIMEOUT(dirp = opendir(path));				if(dirp == (DIR *)NULL){#ifdef FSERROR					*Lisp_errno = errno;#endif					return(0);				}				for(S_TOUT(dp=readdir(dirp)); dp!=(struct direct *)NULL; S_TOUT(dp=readdir(dirp)) ){					strcpy(name, dp->d_name);					parseversion(name, ver);					DOWNCASE(name);					rval = atoi(ver);					if( (rval == 0) && STREQ(save_file, name) ){						/* case in-sensitive versionless file exist */						sprintf(save_file, "%s/%s", path, dp->d_name);						TIMEOUT(rval=stat(save_file, &sbuf));						if(rval != 0){#ifdef FSERROR							*Lisp_errno = errno;#endif							err_mess("stat", errno);							TIMEOUT( closedir(dirp) );							return(0);						}						if(ino == sbuf.st_ino){							TIMEOUT( closedir(dirp) );							return(1);						}else{							TIMEOUT( closedir(dirp) );							return(0);						}						}				}/* end for(dp= .. */				TIMEOUT( closedir(dirp) );				return(0);			}/* end else part of if(errno== .. */			}		if(ino == sbuf.st_ino){			return(1);		}else{			return(0);		}	}else{		/* save_file has no version */		return(0);	}}	