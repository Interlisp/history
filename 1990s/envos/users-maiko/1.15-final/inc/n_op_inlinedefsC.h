/* This is G-file @(#) n_op_inlinedefsC.h Version 2.29 (10/5/88). copyright Xerox & Fuji Xerox  *//* 	n_op_inlinedefsC.h *//* 	Bob Krivacic 2/23/88 *//* 		These use the N_OP interface of the opcodes.	They used to require the fixsp() inline ASSEMBLY routines to operate!*/#undef ATOMCELL_N#undef DIFFERENCE#undef PLUS2	#undef QUOTIENT  #undef TIMES2	 #undef GREATERP#undef IPLUS_N#undef IDIFFERENCE_N#undef MAKENUMBER#undef BOXIPLUS#undef BOXIDIFFERENCE#undef LRSH1#undef LRSH8#undef LLSH1#undef LLSH8							#undef UFN_CALLS#define GCREF(n)							\	{TOPOFSTACK = htfind(TOPOFSTACK, n);				\	nextop2;}#define ATOMCELL_N(n)							\	{if (TOPOFSTACK & 0xffff0000) {goto op_ufn;}			\	TOPOFSTACK = (n << 16) + (TOPOFSTACK << 1) ;			\	nextop2;							\	}#define DIFFERENCE							\	{SV; TOPOFSTACK = N_OP_difference(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;							\	}#define LOGOR {SV; TOPOFSTACK = N_OP_logor(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;							\	}#define LOGAND {SV; TOPOFSTACK = N_OP_logand(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;							\	}#define LOGXOR {SV; TOPOFSTACK = N_OP_logxor(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;							\	}#define PLUS2								\	{SV; TOPOFSTACK = N_OP_plus2(POP_TOS_1, TOPOFSTACK, ufn_2);	\	nextop1;							\	}#define QUOTIENT							\	{SV; TOPOFSTACK = N_OP_quot(POP_TOS_1, TOPOFSTACK, ufn_2); 	\	nextop1;							\	}#define TIMES2								\	{SV; TOPOFSTACK = N_OP_times2(POP_TOS_1, TOPOFSTACK, ufn_2); 	\	nextop1;							\	}#define	GREATERP							\	{SV; TOPOFSTACK = N_OP_greaterp(POP_TOS_1, TOPOFSTACK, ufn_2);	\	nextop1;							\	}#undef IDIFFERENCE#undef IPLUS2	#undef IQUOTIENT  #undef ITIMES2	 #undef IGREATERP#undef IREMAINDER #define IDIFFERENCE							\	{SV; TOPOFSTACK = N_OP_idifference(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;							\	}#define IPLUS2								\	{SV; TOPOFSTACK = N_OP_iplus2(POP_TOS_1, TOPOFSTACK, ufn_2);	\	nextop1;							\	}#define IQUOTIENT							\	{SV; TOPOFSTACK = N_OP_iquot(POP_TOS_1, TOPOFSTACK, ufn_2); 	\	nextop1;							\	}#define ITIMES2								\	{SV; TOPOFSTACK = N_OP_itimes2(POP_TOS_1, TOPOFSTACK, ufn_2); 	\	nextop1;							\	}#define	IGREATERP							\	{SV; TOPOFSTACK = N_OP_igreaterp(POP_TOS_1, TOPOFSTACK, ufn_2);	\	nextop1;							\	}#define IREMAINDER							\	{SV; TOPOFSTACK = N_OP_iremainder(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;							\	}#define IPLUS_N(n)							\	{SV; TOPOFSTACK = N_OP_iplusn(TOPOFSTACK, n, ufn_1d);		\	nextop2;							\	}#define IDIFFERENCE_N(n)						\	{SV; TOPOFSTACK = N_OP_idifferencen(TOPOFSTACK, n, ufn_1d);	\	nextop2;							\	}#define LRSH1								\	{SV; TOPOFSTACK = N_OP_lrsh1(TOPOFSTACK, ufn_1);		\	nextop1;							\	}#define LRSH8								\	{SV; TOPOFSTACK = N_OP_lrsh8(TOPOFSTACK, ufn_1);		\	nextop1;							\	}#define LLSH1								\	{SV; TOPOFSTACK = N_OP_llsh1(TOPOFSTACK, ufn_1);		\	nextop1;							\	}#define LLSH8								\	{SV; TOPOFSTACK = N_OP_llsh8(TOPOFSTACK, ufn_1);		\	nextop1;							\	}#undef LSH#define LSH	{SV;  TOPOFSTACK = N_OP_lsh(POP_TOS_1,TOPOFSTACK,ufn_2); nextop1; }/* removing OPCAR and OPCDR; they are now inline code in inlinedefsC.h *//* #undef OPCAR *//* #define OPCAR	{ TOPOFSTACK = N_OP_car(TOPOFSTACK, ufn_1); nextop1; } *//* #undef OPCDR *//* #define OPCDR	{ TOPOFSTACK = N_OP_cdr(TOPOFSTACK, ufn_1); nextop1; } */#undef RPLACA#define RPLACA								\	{SV; TOPOFSTACK = N_OP_rplaca(POP_TOS_1, TOPOFSTACK, ufn_2);	\	 nextop1;							\	}#undef RPLACD#define RPLACD								\	{SV; TOPOFSTACK = N_OP_rplacd(POP_TOS_1, TOPOFSTACK, ufn_2);	\	 nextop1; 							\	}#undef RPLCONS#define RPLCONS								\	{ SV; TOPOFSTACK = N_OP_rplcons(POP_TOS_1, TOPOFSTACK, ufn_2);	\	  nextop1;							\	}#define MAKENUMBER 							\		{SV; TOPOFSTACK = N_OP_makenumber(POP_TOS_1,TOPOFSTACK,ufn_2);\		 nextop1;						\		}#define BOXIPLUS							\		{SV; TOPOFSTACK = N_OP_boxiplus(POP_TOS_1,TOPOFSTACK,ufn_2);\		nextop1;						\		}#define BOXIDIFFERENCE							\		{SV; TOPOFSTACK = N_OP_boxidiff(POP_TOS_1,TOPOFSTACK,ufn_2);\		nextop1;						\		}#undef EQLOP#define EQLOP	{							\		 SV; TOPOFSTACK = N_OP_eqlop(POP_TOS_1, TOPOFSTACK, ufn_2);	\		 nextop1;						\		}#undef FMEMB#define FMEMB								\		{							\		 SV; TOPOFSTACK = N_OP_fmemb(POP_TOS_1, TOPOFSTACK, exception_2);	\		 nextop1;						\		}#undef LISTGET#define LISTGET								\		{							\		 SV; TOPOFSTACK = N_OP_listget(POP_TOS_1, TOPOFSTACK, exception_2C);\		 nextop1;						\		}#undef DRAWLINE	#define DRAWLINE							\		{							\		 SV; TOPOFSTACK = N_OP_drawline(			\		 *(CSTKPTR-8), *(CSTKPTR-7), *(CSTKPTR-6),		\		 *(CSTKPTR-5), *(CSTKPTR-4), *(CSTKPTR-3), *(CSTKPTR-2),\		 *(CSTKPTR-1), TOPOFSTACK, ufn_9);			\		 CSTKPTR -= 8; nextop1;					\		}#undef ADDBASE#define ADDBASE								\		{ SV; 							\		 TOPOFSTACK = N_OP_addbase(POP_TOS_1, TOPOFSTACK, ufn_2);\		 nextop1;						\		}/*** [HH: 22-Jul-88] Inline code of these opcodes are made in inlinedefsC.h#undef GETBASEBYTE#define GETBASEBYTE							\		{SV; 							\		 TOPOFSTACK = N_OP_getbasebyte(POP_TOS_1, TOPOFSTACK, ufn_2);\		 nextop1;						\		}#undef PUTBASEBYTE#define PUTBASEBYTE							\		{	SV; 						\		 TOPOFSTACK = N_OP_putbasebyte(				\			*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, ufn_3);	\		 CSTKPTR-=2; nextop1;					\		}#undef PUTBITS_N_M#define PUTBITS_N_M(a, b)						\		{	SV; 						\		 TOPOFSTACK = N_OP_putbitsnfd(POP_TOS_1, TOPOFSTACK, a, b, ufn_2d2);\		 nextop3;						\		}****/#undef UNWIND#define UNWIND(n, m)							\		{	SV; 						\		 CSTKPTR = (LispPTR *)					\			N_OP_unwind(CSTKPTR, TOPOFSTACK, n, m, unwind_err);\		 POP;				\		 nextop3;						\		}#undef ARG0#define ARG0								\		{ SV; TOPOFSTACK = N_OP_arg0(TOPOFSTACK, ufn_1);	\		 nextop1;						\		}#undef ASSOC#define ASSOC								\		{SV; TOPOFSTACK = N_OP_assoc(POP_TOS_1, TOPOFSTACK, exception_2);\		 nextop1;						\		}#undef STKSCAN#define STKSCAN								\		{SV; TOPOFSTACK = N_OP_stkscan(TOPOFSTACK, ufn_1);	\		 nextop1;						\		}#undef FVARX_#define FVARX_(n)							\		{TOPOFSTACK = N_OP_fvar_(TOPOFSTACK, n);		\		 nextop2;						\		}#undef BLT#define BLT								\		{SV; TOPOFSTACK = N_OP_blt(*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, ufn_3);\		 CSTKPTR-=2; nextop1;					\		}/* probably doesn't need a UFN case */#undef PILOTBITBLT#define PILOTBITBLT							\		{SV; TOPOFSTACK = N_OP_pilotbitblt(POP_TOS_1, TOPOFSTACK, ufn_2);\		 nextop1;						\		}#undef CREATECELL#define CREATECELL							\		{SV; TOPOFSTACK = N_OP_createcell(TOPOFSTACK, ufn_1);	\		 nextop1;						\		}#undef FPLUS2#define FPLUS2	{SV; TOPOFSTACK = N_OP_fplus2(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef FDIFFERENCE#define FDIFFERENCE	{SV; TOPOFSTACK = N_OP_fdifference(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef FTIMES2#define FTIMES2	{SV; TOPOFSTACK = N_OP_ftimes2(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef FQUOTIENT#define FQUOTIENT	{SV; TOPOFSTACK = N_OP_fquotient(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef FGREATERP#define FGREATERP	{SV; TOPOFSTACK = N_OP_fgreaterp(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef UBFLOAT1(n)#define UBFLOAT1(n)	{SV; TOPOFSTACK = N_OP_ubfloat1(TOPOFSTACK, n, ufn_1d);\	nextop2;}#undef UBFLOAT2(n)#define UBFLOAT2(n)	{SV; TOPOFSTACK = N_OP_ubfloat2(POP_TOS_1, TOPOFSTACK, n, ufn_2d);\	nextop2;}#undef UBFLOAT3(n)#define UBFLOAT3(n)	{SV; TOPOFSTACK = N_OP_ubfloat3(*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n, ufn_3d); CSTKPTR-=2; \	nextop2;}#undef CLFMEMB#define CLFMEMB	{SV; TOPOFSTACK = N_OP_clfmemb(POP_TOS_1, TOPOFSTACK, exception_2);\	nextop1;}#undef CLASSOC#define CLASSOC	{SV; TOPOFSTACK = N_OP_classoc(POP_TOS_1, TOPOFSTACK, exception_2);\	nextop1;}/* NOTE: RESTLIST never punts */#undef RESTLIST(n)#define RESTLIST(n)	{TOPOFSTACK = N_OP_restlist(POP_TOS_1, TOPOFSTACK, n, ufn_2d);\	nextop2;}#undef CLEQUAL#define CLEQUAL	{SV; TOPOFSTACK = N_OP_clequal(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef ILEQUAL#define ILEQUAL	{SV; TOPOFSTACK = N_OP_equal(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef ASET1#define ASET1								\	{SV; TOPOFSTACK = N_OP_aset1(*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, ufn_3);\	CSTKPTR-=2; nextop1;}#undef MISC4(n)#define MISC4(n)							\	{SV; TOPOFSTACK = N_OP_misc4(*(CSTKPTR-3), *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n, ufn_4d); CSTKPTR-=3; nextop2;}#undef MISC3(n)#define MISC3(n)							\	{SV; TOPOFSTACK = N_OP_misc3(*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n, ufn_1d); CSTKPTR-=2; nextop2;}#undef AREF2#define AREF2	{SV; TOPOFSTACK = N_OP_aref2(*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, ufn_1); CSTKPTR-=2;				\		 nextop1;}#undef ASET2#define ASET2	{SV; TOPOFSTACK = N_OP_aset2(*(CSTKPTR-3), *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, ufn_1); CSTKPTR-=3; \		 nextop1;}/* Error Recovery & UFN calls */#ifdef NOASM/* SV needs to save state */#define SV EXT/* no extra code for UFN_CALLS, define labels as constants */#define UFN_CALLS#define ufn_3d 0#define ufn_2 0#define ufn_1 0#define ufn_4 0#define ufn_4d 0#define ufn_3 0#define ufn_1d 0#define ufn_9 0#define ufn_2d2 0#define unwind_err 0#define ufn_2d 0#define exception_2 0#define exception_2C 0/* no opcode fail point necessary */#define OPCODEFAIL#else/* SV need do no work */#define SV/* UFN_CALLS are inserted in xc.c. Note that only ufn_2 calls have decremented the stack at the time the UFN is called *//* ufn_x	there are x args from the Lisp stack   ufn_xd	there are x args from the Lisp stack & 		some from the code stream.*/#define	UFN_CALLS							\									\unwind_err:	 							\	fixspn(5);							\	goto op_ufn;							\ufn_9:	fixspn(10);							\	goto op_ufn;							\ufn_4d:	fixspn(6);							\	goto op_ufn;							\ufn_3d:	fixspn(5);							\	goto op_ufn;							\ufn_2d:	fixspn(4);							\	CSTKPTR += 1;							\	goto op_ufn;							\ufn_2d2:fixspn(5);							\	CSTKPTR += 1;							\	goto op_ufn;							\ufn_1d:	fixsp3();							\	goto op_ufn;							\ufn_d:	fixsp2();							\	goto op_ufn;							\ufn_4:	fixspn(5);							\	goto op_ufn;							\ufn_3:	fixspn(4);							\	goto op_ufn;							\ufn_2:	fixsp3(); 							\	CSTKPTR += 1;							\	goto op_ufn;							\ufn_1:	fixsp2(); 							\	goto op_ufn;							\ufn_0:	fixsp1(); 							\	goto op_ufn;							\exception_2 : fixsp3();							\	CSTKPTR += 1;							\	TOPOFSTACK = TopOfStack;					\	if(!Irq_Stk_End){						\		 goto check_interrupt;					\	}								\	else goto op_ufn;						\exception_2C : fixsp3();						\	*CSTKPTR = Scratch_CSTK;					\	CSTKPTR += 1;							\	if(!Irq_Stk_End){						\		 goto check_interrupt;					\	}								\	else {								\		goto op_ufn;						\	}/* need jump point for inline asm code, e.g., for IPLUS */#define OPCODEFAIL							\									\fixtos1:								\asm("fixtos1:");							\	FIXTOS1;							\	goto op_ufn;#endif NOASM