/* This is G-file @(#) gcclock.c Version 1.2 (3/13/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) gcclock.c	1.2 3/13/88";/*** ADOPTED NEW VERSION ***//*************************************************************************//*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 *//*************************************************************************/#include <stdio.h>#include <sys/time.h>  /* /usr/sys/h/time.h */#include "lispemul.h"#include "lispmap.h"#include "lisptypes.h"#include "emulglobal.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "stack.h"#include "cell.h"#include "gc.h"#include "arith.h"#define OFFSET_MILLISECONDS		2#define MAX_SMALL_INTEGER		65535LispPTR boxiplusingc(box,arg2)LispPTR		box, arg2;{int		src, dest; int		*cell68k;	src = *(LispPTR *)Addr68k_from_LADDR(box);	dest = arg2; /* if this calls UFN, then immidiate return. */	cell68k = (int *)Addr68k_from_LADDR(box);	*cell68k = src + dest;	return(box);} LispPTR boxidifferingc(box,arg2)LispPTR		box,arg2;{int 		src,dest; int		*cell68k;	src = *(LispPTR *)Addr68k_from_LADDR(box);	dest = arg2;	cell68k = (int *)Addr68k_from_LADDR(box);	*cell68k = src - dest;	return(box);}rclkingc(box)LispPTR 	box;{struct timeval time; unsigned int	usec;	gettimeofday(&time, NULL);	usec = time.tv_sec*1000000+time.tv_usec;#ifdef	sparc	*(short *)Addr68k_from_LADDR(box) = usec >> 16;	*((short *)Addr68k_from_LADDR(box)+2) = usec & 0xffff;#else	*((unsigned int *)(Addr68k_from_LADDR(box))) = usec;#endif	return(box);}getinternalclock(clockoffset, box)int 	clockoffset;int    	box;{MISCSTATS	*misc;   misc = (MISCSTATS *)MiscStats;   misc->basetmp = misc->baseclock;   misc->millisecondstmp = misc->millisecondsclock;   misc->secondstmp = misc->secondsclock;   /*   blt(<misc->secondstmp>, <misc->secondsclock>, 6); */   if (clockoffset == 0)	box = misc->secondstmp;   else if (clockoffset == 2)	box = misc->millisecondstmp;   else error("Not implemented in getinternalclock.\n");   /* blt(<box>, (<misc->secondstmp> + clockoffset), WORDSPERCELL); */   /* boxidifferingc(rclkingc((DLword *)LADDR_from_68k(misc)+42)				,misc->basetmp);  */   { struct timeval time;     unsigned int usec;        gettimeofday(&time,NULL);        usec = time.tv_sec*1000000+time.tv_usec;        misc->excesstimetmp = usec;   }   misc->excesstimetmp -= misc->basetmp;                        /* misc->excesstimetmp,	misc->basetmp	*/   return(box);   }LispPTR clock0(box)int     	box;{MISCSTATS	*misc; int 		tmpexcess;   misc = (MISCSTATS *)MiscStats;   box = getinternalclock(OFFSET_MILLISECONDS, box);   tmpexcess = misc->excesstimetmp;   while ((tmpexcess > *RclkSecond_word) || (tmpexcess < 0))	{box += 1000;	 misc->excesstimetmp = (tmpexcess -= *RclkSecond_word);	};   tmpexcess = (tmpexcess > MAX_SMALL_INTEGER)?tmpexcess:LOLOC(tmpexcess);   return(box + (tmpexcess/(*RclkMilliSecond_word)));}clock(n, box)int 		n;LispPTR		box;{MISCSTATS	*misc; int            tempfix;   misc = (MISCSTATS *)MiscStats;   if (GetTypeNumber(box) == TYPE_FIXP)     tempfix = *(int *)Addr68k_from_LADDR(box);   else     tempfix = box;   if (n == 2)	return(clock0(tempfix) - misc->swapwaittime			      - misc->keyboardwaittime			      - misc->starttime			      - misc->gctime);    else	error("Not implemented type in clock of GCCLOCK.\n");}