h42387s 00004/00004/00197d D 2.12 92/04/21 17:01:44 sybalsky 17 16c shortening file names for DOS \nes 00000/00000/00201d D 2.11 90/04/20 01:18:03 sybalsky 16 15c k change.es 00001/00000/00200d D 2.10 90/03/19 11:38:43 takeshi 15 14c Floating mode setes 00010/00012/00190d D 2.9 88/12/01 13:47:38 krivacic 14 13c Add SUN3_OS4_IL & SUN3_OS3_OR_OS4_IL Flags, and move asm labels to inlines.es 00022/00030/00180d D 2.8 88/11/30 19:56:41 shih 13 12c minor cleanupes 00040/00022/00170d D 2.7 88/10/13 19:27:25 krivacic 12 11c new ifdef varses 00029/00030/00163d D 2.6 88/10/12 14:39:16 krivacic 11 10c new out-of-line interfacees 00047/00031/00146d D 2.5 88/10/10 14:03:52 krivacic 10 9c sun3/4 mergees 00000/00214/00177d D 2.4 88/09/27 15:50:51 krivacic 9 8c merginges 00008/00004/00383d D 2.3 88/06/03 17:41:41 krivacic 8 7c have times2 & quotient call floating pt on type errores 00007/00000/00380d D 2.2 88/05/27 14:48:53 krivacic 7 6c C_ONLY ifdefes 00000/00000/00380d D 2.1 88/05/17 09:21:45 hayata 6 5c Version up to 2.1es 00068/00000/00312d D 1.5 88/05/16 11:42:05 krivacic 5 4c N_OP_iremainder itimes etc.es 00000/00000/00312d D 1.4 88/04/22 11:43:53 masinter 4 3c Make working directory consistent with sccses 00092/00000/00220d D 1.3 88/03/14 17:40:22 krivacic 3 2c native interfaceses 00002/00002/00218d D 1.2 88/03/13 14:32:33 hayata 2 1c Add SCCS key id (%Z%)es 00220/00000/00000d D 1.1 88/02/24 16:55:42 hayata 1 0c date and time created 88/02/24 16:55:42 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 13/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 13I 13/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(envos & Fuji Xerox)";E 13E 2/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 13 *	Auther :  Takeshi ShimizuE 13I 13 *	Author :  Takeshi ShimizuE 13 * *//***********************************************************************//*D 13 		File Name :	arith4.cE 13I 13		File Name :	arith4.cE 13D 13		Desc	:	  				Date :		Jul.15, 1987 				Edited by :	Takeshi Shimizu				Changed :	 E 13		Including :	OP_times2 326Q(OP_itimes2 332Q)D 13				E 13I 13E 13				OP_quot 327Q(OP_iquot 333Q)				OP_reminder 334QD 13												E 13I 13E 13*//**********************************************************************/#include "lispemul.h"#include "lispmap.h"D 17#include "emulglobal.h"#include "lispglobal.h"#include "lisptypes.h"E 17I 17#include "emlglob.h"#include "lspglob.h"#include "lsptypes.h"E 17#include "address.h"D 17#include "address68k.h"E 17I 17#include "adr68k.h"E 17D 13#include "cell.h" E 13I 13#include "cell.h"I 15#include "fp.h"E 15E 13I 3#include "arith.h"E 3I 7D 9#ifdef C_ONLYE 9E 7D 9#define TWOS_compl(x) ((0xffff & (~(x)))+1)E 9/**********************************************************************//*D 9		Func name :	OP_times2(itimes2)			Date :		Jul. 15, 1987			Edited by :	Take*//**********************************************************************/OP_times2()  /* including OP_itimes2 */{  register LispPTR arg1 ; 	/* Keep val of CSTK */  register LispPTR res ;  register LispPTR  *cell68k ; 	/* Pointer to FIXP cell */  LispPTR *createcell68k();#ifdef TRACE	printPC();	printf("TRACE : OP_times2 \n");#endif  arg1 = *((LispPTR *)(CurrentStackPTR));  /* CSTK to arg1 without POP */  if((arg1 & 0xFF0000) ==  S_POSITIVE){	if((TopOfStack & 0xFF0000) == S_POSITIVE){	   /* posi * posi */	  res = (0xffff & TopOfStack) * (0xffff & arg1) ;	  goto POS;	}	else if ((TopOfStack & 0xFF0000) == S_NEGATIVE){	   /* posi * nega */	  if((arg1 & 0xffff)==0) goto ZERO; 	  res = (TWOS_compl(TopOfStack & 0xffff)) * (0xffff & arg1) ;	  goto NEG ;	}	else {		ufn(Get_BYTE(PC)); /* ufn case */		return;	     }	    } else if((arg1 & 0xFF0000) ==  S_NEGATIVE) {	  if((TopOfStack & 0xFF0000) == S_POSITIVE){	  /* nega * posi */		if((TopOfStack & 0xffff)==0) goto ZERO; 		res = (0xffff & TopOfStack) * TWOS_compl(0xffff & arg1) ;		goto NEG ;	   }	  else if ((TopOfStack & 0xFF0000) == S_NEGATIVE){		/* neg * neg */		  if(((arg1 & 0xffff)==0)||((TopOfStack & 0xffff)==0))		   {			 ufn(Get_BYTE(PC)); /* ufn case */			  return;		   }			res=TWOS_compl(arg1 & 0xffff)*TWOS_compl(0xffff & TopOfStack) ;			goto POS ;		}	}      else 	{		ufn(Get_BYTE(PC)); /* ufn case */		return;	}POS :	if(res & 0xffff0000) /* ufn case */	{	  if (res & 0x80000000) {		ufn(Get_BYTE(PC));/* MSB on? */ 		return ;	  }	  cell68k = createcell68k(TYPE_FIXP);	  *cell68k = res ;	  TopOfStack = LADDR_from_68k(cell68k);	}	else	TopOfStack=S_POSITIVE| (res&0xffff); 	CurrentStackPTR -= 2 ;	PC++; /* Increment PC */	return;NEG :	if(res & 0xffff0000) {		ufn(Get_BYTE(PC)); /* ufn case */		return;	 }	if((res = TWOS_compl(res))==0) {		ufn(Get_BYTE(PC)); /* ufn case */		return;	 }	TopOfStack=S_NEGATIVE | (res&0xffff); 	CurrentStackPTR -= 2 ;	PC++; /* Increment PC */	return;ZERO : 	TopOfStack=S_POSITIVE; 	CurrentStackPTR -= 2 ;	PC++; /* Increment PC */	return;} /* end OP_times2 *//**********************************************************************//*		Func name :	OP_quot(iquot)			Date :		Jun. 15, 1987			Edited by :	Take*//**********************************************************************/OP_quot(){ LispPTR  arg1 , res; #ifdef TRACE	printPC();	printf("TRACE : OP_quot \n");#endif  arg1 = *((LispPTR *)(CurrentStackPTR));  /* CSTK to arg1 without POP*/  if (((TopOfStack & 0xff0000) != S_POSITIVE) || ((arg1 & 0xff0000) != S_POSITIVE)	|| ((TopOfStack & 0xffff)==0))  {	ufn(Get_BYTE(PC)); /* ufn case */	return;  }  TopOfStack = S_POSITIVE | ((arg1 & 0xffff)/(TopOfStack & 0xffff)) ; 	CurrentStackPTR -= 2 ;	PC++; /* Increment PC */	return;} /* end OP_quot *//**********************************************************************//*		Func name :	OP_remainder			Date :		Jun. 15, 1987			Edited by :	Take*//**********************************************************************/OP_remainder(){ LispPTR  arg1 , res; #ifdef TRACE	printPC();	printf("TRACE : OP_remainder \n");#endif  arg1 = *((LispPTR *)(CurrentStackPTR));  /* CSTK to arg1 without POP*/  if (((TopOfStack & 0xff0000) != S_POSITIVE) || ((arg1 & 0xff0000) != S_POSITIVE)	|| ((TopOfStack & 0xffff)==0)) {	ufn(0334); /* ufn case */	return; }  TopOfStack = S_POSITIVE | ((arg1 & 0xffff)%(TopOfStack & 0xffff)) ; 	CurrentStackPTR -= 2 ;	PC++; /* Increment PC */	return;} /* end OP_remainder */I 3I 7#elseE 7/**********************************************************************//*E 9		Func name :	N_OP_times2(itimes2)*//**********************************************************************/D 11int N_OP_times2(a, b, error_addr)  /* including OP_itimes2 */	int a, b, *error_addr;E 11I 11D 13int N_OP_times2(tosm1, tos) E 13I 13int N_OP_times2(tosm1, tos)E 13	int tosm1, tos;E 11{register int	arg1,arg2;register int	result;D 9#ifdef TRACE	printPC();	printf("TRACE : N_OP_times2 \n");#endifE 9I 10E 10D 11	N_GETNUMBER( a, arg1, doufn );	N_GETNUMBER( b, arg2, doufn );E 11I 11	N_GETNUMBER( tosm1, arg1, doufn );	N_GETNUMBER( tos, arg2, doufn );E 11I 10D 12#ifdef NOASM	result = arg1 * arg2;D 11	if ((arg2 !=0) &&((result / arg2) != arg1) ) {ERROR_EXIT(error_addr);}E 11I 11	if ((arg2 !=0) &&((result / arg2) != arg1) ) goto doufn2;E 11	N_ARITH_SWITCH(result);#elseE 12I 12D 14#ifdef SUN3_OS3_ILE 14I 14#ifdef SUN3_OS3_OR_OS4_ILE 14E 12E 10D 13	result = mpy32(arg1, arg2);	 E 13I 13	result = mpy32(arg1, arg2);E 13	N_ARITH_SWITCH(result);I 10D 14	asm("mpy_err:");E 14I 14dummy:	mpy_err_label();E 14I 12#else	result = arg1 * arg2;	if ((arg2 !=0) &&((result / arg2) != arg1) ) goto doufn2;	N_ARITH_SWITCH(result);E 12#endifE 10D 8	asm("mpy_err:");	doufn:	ERROR_EXIT(error_addr);E 8I 8D 10doufn2:	asm("mpy_err:");		ERROR_EXIT(error_addr);E 8E 10I 10D 11doufn2:	ERROR_EXIT(error_addr);E 10I 8doufn:	return(N_OP_ftimes2(a, b, doufn2));E 11I 11doufn2:	ERROR_EXIT(tos);doufn:	return(N_OP_ftimes2(tosm1, tos));E 11E 8I 8I 10D 11E 11E 10E 8} /* end N_OP_times2 */I 5D 11int N_OP_itimes2(a, b, error_addr)  /* including OP_itimes2 */	int a, b, *error_addr;E 11I 11D 13int N_OP_itimes2(tosm1, tos) E 13I 13int N_OP_itimes2(tosm1, tos)E 13	int tosm1, tos;E 11{register int	arg1,arg2;register int	result;E 5I 5D 9#ifdef TRACE	printPC();	printf("TRACE : N_OP_itimes2 \n");#endifE 9D 11	N_IGETNUMBER( a, arg1, doufn );	N_IGETNUMBER( b, arg2, doufn );E 11I 11	N_IGETNUMBER( tosm1, arg1, doufn );	N_IGETNUMBER( tos, arg2, doufn );E 11I 10D 12#ifdef NOASM	result = arg1 * arg2;	if ((arg2 !=0) &&( (result / arg2) != arg1) ) {goto doufn;}	N_ARITH_SWITCH(result);E 12I 12D 14#ifdef SUN3_OS3_ILE 14I 14#ifdef SUN3_OS3_OR_OS4_ILE 14E 12D 12#elseE 12E 10D 13	result = impy32(arg1, arg2);	 E 13I 13	result = impy32(arg1, arg2);E 13	N_ARITH_SWITCH(result);I 10D 14	asm("impy_err:");E 14I 14dummy:	impy_err_label();E 14E 10I 12#else	result = arg1 * arg2;	if ((arg2 !=0) &&( (result / arg2) != arg1) ) {goto doufn;}	N_ARITH_SWITCH(result);E 12D 10	asm("impy_err:");	E 10I 10#endifE 10D 11doufn:	ERROR_EXIT(error_addr);E 11I 11doufn:	ERROR_EXIT(tos);E 11D 10} /* end N_OP_times2 */E 10I 10} /* end N_OP_itimes2 */E 10E 5/**********************************************************************//*		Func name :	N_OP_quot(iquot)*//**********************************************************************/D 11int N_OP_quot(a, b, error_addr)	int a, b, *error_addr;E 11I 11D 13int N_OP_quot(tosm1, tos) E 13I 13int N_OP_quot(tosm1, tos)E 13	int tosm1, tos;E 11{register int	arg1,arg2;register int	result;D 9#ifdef	TRACE	printPC();	printf("TRACE: N_OP_quot()\n");#endifE 9D 11	N_GETNUMBER( a, arg1, doufn );	N_GETNUMBER( b, arg2, doufn );D 10	if (arg2 == 0) goto doufn;E 10I 10	if (arg2 == 0) ERROR_EXIT(error_addr);E 11I 11	N_GETNUMBER( tosm1, arg1, doufn );	N_GETNUMBER( tos, arg2, doufn );	if (arg2 == 0) goto doufn2;E 11D 12#ifdef NOASM	result = arg1/arg2;	/* lmm: note: no error case!! */	N_ARITH_SWITCH(result);#elseE 12I 12D 14#ifdef SUN3_OS3_ILE 14I 14#ifdef SUN3_OS3_OR_OS4_ILE 14E 12E 10D 13	result = quot32(arg1, arg2);	 E 13I 13	result = quot32(arg1, arg2);E 13	N_ARITH_SWITCH(result);D 10D 8	asm("quot_err:");	doufn:	ERROR_EXIT(error_addr);E 8I 8doufn2:	asm("quot_err:");		ERROR_EXIT(error_addr);E 10I 10D 14	asm("quot_err:");E 14I 14dummy:	quot_err_label();E 14I 12#else	result = arg1/arg2;	/* lmm: note: no error case!! */	N_ARITH_SWITCH(result);E 12#endifD 11doufn2:	ERROR_EXIT(error_addr);E 10doufn:	return(N_OP_fquotient(a, b, doufn2));E 11I 11doufn2:	ERROR_EXIT(tos);doufn:	return(N_OP_fquotient(tosm1, tos));E 11E 8D 13	E 13I 13E 13} /* end N_OP_quot */I 5D 11int N_OP_iquot(a, b, error_addr)	int a, b, *error_addr;E 11I 11D 13int N_OP_iquot(tosm1, tos) E 13I 13int N_OP_iquot(tosm1, tos)E 13	int tosm1, tos;E 11{register int	arg1,arg2;register int	result;D 9#ifdef	TRACE	printPC();	printf("TRACE: N_OP_iquot()\n");#endifE 9D 11	N_IGETNUMBER( a, arg1, doufn );	N_IGETNUMBER( b, arg2, doufn );E 11I 11	N_IGETNUMBER( tosm1, arg1, doufn );	N_IGETNUMBER( tos, arg2, doufn );E 11	if (arg2 == 0) goto doufn;I 10D 12#ifdef NOASM	result = arg1/arg2;E 12I 12D 14#ifdef SUN3_OS3_ILE 14I 14#ifdef SUN3_OS3_OR_OS4_ILE 14D 13	result = iquot32(arg1, arg2);	 E 13I 13	result = iquot32(arg1, arg2);E 13E 12	N_ARITH_SWITCH(result);I 14dummy:	iquot_err_label();E 14I 12D 14	asm("iquot_err:");D 13	E 13I 13E 14E 13E 12#elseE 10D 12	result = iquot32(arg1, arg2);	 E 12I 12	result = arg1/arg2;E 12	N_ARITH_SWITCH(result);D 12	asm("iquot_err:");	E 12I 10#endifI 12E 12E 10D 11doufn:	ERROR_EXIT(error_addr);E 11I 11doufn:	ERROR_EXIT(tos);E 11D 13	E 13I 13E 13} /* end N_OP_quot */E 5/**********************************************************************//*D 10		Func name :	N_OP_remainderE 10I 10		Func name :	N_OP_iremainderE 10*//**********************************************************************/D 10int N_OP_remainder(a, b, error_addr)	int a, b, *error_addr;{register int	arg1,arg2;register int	result;E 10D 9#ifdef	TRACE	printPC();	printf("TRACE: N_OP_remainder()\n");#endifE 9D 10	N_GETNUMBER( a, arg1, doufn );	N_GETNUMBER( b, arg2, doufn );	if (arg2 == 0) goto doufn;	result = rem32(arg1, arg2);	 	N_ARITH_SWITCH(result);	asm("rem_err:");	doufn:	ERROR_EXIT(error_addr);		} /* end N_OP_remainder */I 5E 10D 11int N_OP_iremainder(a, b, error_addr)	int a, b, *error_addr;E 11I 11D 13int N_OP_iremainder(tosm1, tos) E 13I 13int N_OP_iremainder(tosm1, tos)E 13	int tosm1, tos;E 11{register int	arg1,arg2;register int	result;D 9#ifdef	TRACE	printPC();	printf("TRACE: N_OP_iremainder()\n");#endifE 9D 11	N_IGETNUMBER( a, arg1, doufn );	N_IGETNUMBER( b, arg2, doufn );E 11I 11	N_IGETNUMBER( tosm1, arg1, doufn );	N_IGETNUMBER( tos, arg2, doufn );E 11	if (arg2 == 0) goto doufn;I 10D 12#ifdef NOASM	result = arg1 % arg2;	N_ARITH_SWITCH(result);E 12D 12#elseE 12I 12D 14#ifdef SUN3_OS3_ILE 14I 14#ifdef SUN3_OS3_OR_OS4_ILE 14E 12E 10D 13	result = irem32(arg1, arg2);	 E 13I 13	result = irem32(arg1, arg2);E 13	N_ARITH_SWITCH(result);D 14D 10	asm("irem_err:");	E 10I 10	asm("irem_err:");E 14I 14dummy:	irem_err_label();E 14I 12#else	result = arg1 % arg2;	N_ARITH_SWITCH(result);E 12D 13#endif	E 13I 13#endifE 13I 12E 12E 10D 11doufn:	ERROR_EXIT(error_addr);E 11I 11doufn:	ERROR_EXIT(tos);E 11D 13		D 10} /* end N_OP_remainder */E 10I 10} /* end N_OP_iremainder */E 13E 10E 5I 13} /* end N_OP_iremainder */E 13I 7D 9#endifE 9E 7E 3E 1