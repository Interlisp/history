h59010s 00031/00014/00619d D 1.17 93/02/08 14:56:49 sybalsky 17 16c Big VM (and new CDR coding) changes for 3.0 \nes 00015/00002/00618d D 1.16 92/11/10 20:32:12 sybalsky 16 15c Make GC tables be full-cell entries for BIG VM changees 00003/00003/00617d D 1.15 92/07/24 10:46:43 sybalsky 15 14c retrofit of SGI & DEC OSF1 changes \nes 00018/00003/00602d D 1.14 92/06/26 13:49:54 sybalsky 14 13c retrofit of 386 unix changes \nes 00014/00001/00591d D 1.13 92/04/29 12:49:27 nilsson 13 12c Banes fixes to maxpage.es 00001/00001/00591d D 1.12 92/04/23 16:41:44 nilsson 12 11c New short name regimen. Improved X commandline handling.es 00011/00011/00581d D 1.11 92/04/23 10:55:30 sybalsky 11 10c fixing SCCS headers \nes 00004/00004/00588d D 1.10 92/04/21 17:20:08 sybalsky 10 9c shortening file names for DOS \nes 00015/00020/00577d D 1.9 92/04/17 15:01:38 nilsson 9 8c better X resource managementes 00006/00000/00591d D 1.8 92/03/04 19:24:44 nilsson 8 7c Inserted dld_find_executable of the foreign function callses 00003/00000/00588d D 1.7 91/10/15 18:18:57 sybalsky 7 6c ISC changeses 00005/00001/00583d D 1.6 91/09/27 02:46:39 sybalsky 6 5c ISC port changeses 00003/00003/00581d D 1.5 91/06/07 14:04:52 sybalsky 5 4c Make sure UJ table is set up even if we're not running unix fork.es 00005/00000/00579d D 1.4 91/04/09 17:12:03 sybalsky 4 3c Retrofit first round of changes from MIPS porting centeres 00015/00001/00564d D 1.3 91/01/25 17:59:56 sybalsky 3 2c wherees 00127/00108/00438d D 1.2 90/09/12 18:00:01 sybalsky 2 1c Renamed from Ctest.c, for clarity.es 00546/00000/00000d D 1.1 90/09/12 16:26:21 sybalsky 1 0c date and time created 90/09/12 16:26:21 by sybalskyeuUf e 0tTI 1D 9/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 9I 9/* @(#) main.c Version 1.5 (6/7/91). copyright venue & Fuji Xerox  */static char *id = "@(#) main.c	1.5 6/7/91	(venue & Fuji Xerox)";E 9D 2/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 2I 2I 11E 11E 2/************************************************************************//*									*/D 6/*	Copyright 1989, 1990 Venue.  All Rights Reserved.		*/E 6I 6D 9/*	Copyright 1989, 1990, 1991 Venue.  All Rights Reserved.		*/E 9I 9D 11/*	Copyright 1989, 1990 Venue.  All Rights Reserved.		*/E 11I 11/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 11E 9E 6/*									*/D 11/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley,		*//*	further modified outside the scope of that contract, and	*//*	hence the property solely of Venue.				*/E 11I 11/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 11/*									*//************************************************************************/D 11/* *	Copyright (C) 1987,88,89  by Fuji Xerox Co., Ltd. All rights reserved. */E 11/*D 2 *	Ctest.cE 2I 2 *	main.cE 2 *	This file includes main() */#include	<sys/types.h>#include	<sys/param.h>#include        <sys/time.h>#include	<sys/types.h>D 15#ifndef AIXE 15I 15#ifndef NOETHERE 15#include	<net/nit.h>	/* needed for Ethernet stuff below */D 15#endif AIXE 15I 15#endif /* NOETHER */E 15#include	<stdio.h>I 3#ifndef HPUXE 3#include	<strings.h>I 3D 15#endif HPUXE 15I 15#endif /* NOETHER */E 15E 3#include	<sys/file.h>#include	<setjmp.h>#include	<pwd.h>I 4#ifdef RISCOS#include <unistd.h>D 17#endif RISCOSE 17I 17#endif /* RISCOS */E 17I 6D 9#ifdef ISC#include <unistd.h>#include <sys/dirent.h>#endif ISCE 9E 6I 17E 17I 14#ifdef ISC#include <unistd.h>#include <sys/dirent.h>#endifE 14E 4#include	<errno.h>#include "lispemul.h"D 10#include "emulglobal.h"E 10I 10#include "emlglob.h"E 10#include "address.h"D 10#include "address68k.h"E 10I 10#include "adr68k.h"E 10#include "stack.h"#include "return.h"D 10#include "lispglobal.h"#include "lisptypes.h"E 10I 10#include "lspglob.h"#include "lsptypes.h"E 10#include "lispmap.h"#include "ifpage.h"#include "iopage.h"#include "debug.h"#include "profile.h"#include "timeout.h"DLword	*Lisp_world;		/* lispworld *//********** 68k address for Lisp Space **********/DLword	*Atomspace;DLword	*Stackspace;DLword	*Plistspace;DLword	*DTDspace;DLword	*MDStypetbl;DLword	*AtomHT;DLword	*Pnamespace;DLword	*Defspace;DLword	*Valspace;DLword	*Spospspace;DLword	*Snegspace;/********** For Virtual Memory Management **********/D 16DLword	*FPtoVP;E 16I 16#ifdef BIGVMLispPTR *FPtoVP;#elseDLword  *FPtoVP;#endif /* BIGVM */E 16DLword	*PAGEMap;DLword	*PageMapTBL;DLword	*LockedPageTable;/********** For Interface to LispMicro/Device **********/DLword	*IOCBPage;IOPAGE	*IOPage;IFPAGE	*InterfacePage;MISCSTATS	*MiscStats;/********** UFN Table **********/DLword	*UFNTable;/********** Tables for GC **********/I 16#ifdef BIGVMLispPTR	*HTmain;LispPTR	*HToverflow;LispPTR	*HTbigcount;LispPTR	*HTcoll;#elseE 16DLword	*HTmain;DLword	*HToverflow;DLword	*HTbigcount;DLword	*HTcoll;I 16#endif /* BIGVM */E 16/********** Display **********/DLword	*DisplayRegion;int DisplayInitialized = NIL;DLword	*Arrayspace;DLword	*MDS_space_bottom;DLword	*PnCharspace;struct dtd	*ListpDTD;/********** For Lisp Emulator **********/struct	state	MachineState;/**********************************//*** Share val with LISP code ******/DLword *MDS_free_page;DLword *Next_MDSpage;DLword *Next_Array;/*******************************************//** CACHE LISP SYSVAL ***/LispPTR *Next_MDSpage_word;LispPTR *Next_Array_word;LispPTR *MDS_free_page_word;LispPTR *Reclaim_cnt_word ;/*** Cache Values for reclaimer by Tomtom 30-Sep-1987 ***/LispPTR *GcDisabled_word;LispPTR *CdrCoding_word;LispPTR *FreeBlockBuckets_word;LispPTR *Array_Block_Checking_word;LispPTR *ArrayMerging_word;LispPTR *ArraySpace_word;LispPTR *ArraySpace2_word;LispPTR *ArrayFrLst_word;LispPTR *ArrayFrLst2_word;LispPTR *Hunk_word;LispPTR *System_Buffer_List_word;/*** The end of the addition of cache values on reclaimer ***//*** cache values for the top level reclaimer's implementation ***/LispPTR *GcMess_word;LispPTR *ReclaimMin_word;LispPTR *GcTime1_word;LispPTR *GcTime2_word;LispPTR *MaxTypeNumber_word;/*** The end of the addition of cache values for top reclaimer by Tomtom						15-Oct-1987             ***//*  Pointers for closure caching */LispPTR *Package_from_Index_word;LispPTR *Package_from_Name_word;LispPTR *Keyword_Package_word;LispPTR *Closure_Cache_Enabled_word;LispPTR *Closure_Cache_word;LispPTR *Deleted_Implicit_Hash_Slot_word;LispPTR First_index;/*** The end of Pointers for closure caching ***//* CACHE values for 32Mb MDS/Array by Take */LispPTR *STORAGEFULLSTATE_word;LispPTR *STORAGEFULL_word;LispPTR *PENDINGINTERRUPT_word;LispPTR *LeastMDSPage_word;LispPTR *SecondMDSPage_word;LispPTR *SecondArrayPage_word;LispPTR *INTERRUPTSTATE_word;LispPTR *SYSTEMCACHEVARS_word;LispPTR *MACHINETYPE_word;LispPTR STORAGEFULLSTATE_index;D 2/******* 7-Oct-87 take********/E 2LispPTR *LASTVMEMFILEPAGE_word;LispPTR *VMEM_FULL_STATE_word ;/** Array for N-tran **/int native_load_address;LispPTR native_closure_env = NOBIND_PTR;/** Pipes for Unix Interface **/int UnixPipeIn;int UnixPipeOut;int UnixPID;int please_fork = 1;/*** STACK handle staff(Takeshi) **/LispPTR *STACKOVERFLOW_word;LispPTR *GuardStackAddr_word;LispPTR *LastStackAddr_word;LispPTR *NeedHardreturnCleanup_word;/*** Ethernet stuff (JRB) **/#ifndef NOETHERextern int ether_fd;extern u_char ether_host[6];D 17#endif NOETHERE 17I 17#endif /* NOETHER */E 17extern struct sockaddr_nit snit;I 17#ifdef INITint for_makeinit = 1;#elseE 17int	for_makeinit = 0;I 17#endif /* INIT */E 17int	kbd_for_makeinit = 0;int	save_argc;char	**save_argv;int	display_max = 65536*16*2;I 13/* diagnostic flag for sysout dumping */extern int maxpages;E 13/** For call makepathname inside main() **/extern int	*Lisp_errno;extern int	Dummy_errno;		/* If errno cell is not provided by Lisp, dummy_errno is used. */D 9char *getenv();E 9I 9char keystring[128];E 9I 9#define FALSE 0#define TRUE  !FALSEE 9I 2I 9char *getenv();int Lisp_Xinitialized = FALSE;D 14char sysout_name[1024];int sysout_size = 0; /* default 0 */ /* was = 32;*/E 14I 14char sysout_name[1024];	/* Set by read_Xoption, in the X version. */int sysout_size = 0; /* ditto */E 14E 9D 9E 9E 2/************************************************************************//*									*//*		     M A I N   E N T R Y   P O I N T			*//*									*//*									*//************************************************************************/main(argc, argv)  int	argc ;  char	**argv ;  {    int i;D 9    int sysout_size = 0; /* default 0 */ /* was = 32;*/E 9I 9    char *envname;E 9    extern int TIMER_INTERVAL;D 9    char *keystring=NULL, sysout_name[1024], *envname;E 9    char  keytyped [ 255 ];I 9D 11E 11I 11#ifndef NOFORNE 11E 9I 8    if (dld_find_executable (argv[0]) == 0) {      perror("Name of executable not found.");    } else if (dld_init (dld_find_executable (argv[0])) != 0) {      dld_perror( "Can't init DLD." );    };I 11#endif /* NOFORN */E 11I 9D 11E 11E 9E 8#ifdef XWINDOWD 9	read_Xoption( argc, argv );E 9I 9D 11	read_Xoption( &argc, argv );E 11I 11D 12	read_Xoption( argc, argv );E 12I 12	read_Xoption( &argc, argv );E 12E 11E 9D 17#endif XWINDOWE 17I 17#endif /* XWINDOW */E 17I 17E 17    save_argc = argc;    save_argv = argv;#ifdef PROFILE    moncontrol(0); /* initially stop sampling */D 17#endif PROFILEE 17I 17#endif /* PROFILE */E 17I 17E 17/* Sysout is found as follows:	If the first argument doesn't begin with '-', assume it's the sysout	Look at the environment variable LDESRCESYSOUT if that fails	Look for ~/lisp.virtualmem if that fails	Barf and print the command line if tha fails*/#ifdef	FSERROR    /* For call makepathname */    Lisp_errno = &Dummy_errno;#endif    i=1;    if(argc > 1 && argv[1][0] != '-')      {	strcpy(sysout_name, argv[1]);	i++;      }     else if ((envname = getenv("LDESRCESYSOUT")) != NULL)      {	strcpy(sysout_name, envname);      }    else if ((envname = getenv("LDESOURCESYSOUT")) != NULL)      strcpy(sysout_name, envname);    else if( !makepathname("~/lisp.virtualmem", sysout_name)	    || access(sysout_name, R_OK))      {	fprintf(stderr, "Coudn't find a sysout to run;\n");	fprintf(stderr, "either setenv LDESRCESYSOUT or do:\n");	fprintf(stderr, "lde[ether] [sysout] [-k access-key] [-E <ethernet-info>]\n" );I 14#ifdef XWINDOW	print_Xusage(argv[0]);#endifE 14D 9#ifdef XWINDOW	print_Xusage( argv[0] );#endif XWINDOWE 9	exit(1);      }/* OK, sysout name is now in sysout_name, and i is moved past a supplied name */    for ( ; i < argc; i += 1 )      { /* step by 1 in case of typo */I 17	  E 17	/* -t and -m are undocumented and somewhat dangerous... */	if (! strcmp(argv[i], "-t"))	  { /**** timer interval	****/	    if(argc > ++i) TIMER_INTERVAL = atoi(argv[i]);	    else	      {		fprintf(stderr, "Missing argument after -t\n");		exit(1);	      }	  }	else if (! strcmp(argv[i], "-m"))	  { /**** sysout size	****/	    if(argc > ++i) sysout_size = atoi(argv[i]);	    else	      {		fprintf(stderr, "Missing argument after -m\n");		exit(1);	      }	  }	else if (! strcmp(argv[i], "-NF"))	  { /****  Don't fork (for dbxing)	****/	    please_fork = 0;	  }	else if ( ! strcmp(argv[i], "-INIT"))	  { /*** init sysout, no packaged */	    for_makeinit = 1;	  }	else if (! strcmp(argv[i], "-k"))	  { /**** security key	****/D 9	    if(argc > ++i) keystring = argv[i];E 9I 9D 16	    if(argc > ++i) (void)strcpy(keystring, argv[i]);E 16I 16D 17	    printf("hit -k arg.  i = %d, argc = %d. \n", i, argc);	    if(argc > ++i) { (void)strcpy(keystring, argv[i]); printf(" key arg = '%s'\n", argv[i]); }E 17I 17	    	    if(argc > ++i) { (void)strcpy(keystring, argv[i]); }E 17E 16E 9	    else	      {		fprintf(stderr, "Missing argument after -k\n");		exit(1);	      }	  }D 2#ifndef AIXE 2	/* Can only do this under SUNOs, for now */	else if (! strcmp(argv[i], "-E"))	  { /**** ethernet info	****/#ifdef NOETHER#else	    int b0, b1, b2, b3, b4, b5;	    if(argc > ++i && sscanf(argv[i],"%d:%x:%x:%x:%x:%x:%x:%s",&ether_fd,			&b0, &b1, &b2, &b3, &b4, &b5, snit.snit_ifname) == 8)	      {		ether_host[0] = b0; ether_host[1] = b1;		ether_host[2] = b2; ether_host[3] = b3;		ether_host[4] = b4; ether_host[5] = b5;	      }	    else	      {		fprintf(stderr, "Missing or bogus -E argument\n");		ether_fd = -1;		exit(1);	      }D 17#endif NOETHERE 17I 17#endif /* NOETHER */E 17	  }I 13	/* diagnostic flag for big vmem write() calls */	else if (! strcmp(argv[i], "-maxpages"))	  {	    if(argc > ++i) maxpages = atoi(argv[i]);	    else	      {		fprintf(stderr, "Missing argument after -maxpages\n");		exit(1);	      }	  }E 13D 2#endif AIXE 2      }    if ( keystring )		/* key given, so safe to copy */      strcpy ( keytyped, keystring );I 16D 17	  printf("key string = '%s'.\n", keystring);E 17I 17E 17E 16    if ( keytester(keystring) ) { /* keytester destroys keystring */	    fprintf (stderr, "Sorry, invalid or expired access key.\n" );	    fprintf (stderr, "Key tried: %s\n", keytyped );D 13	    exit();E 13I 13D 14	    exit(0);E 14I 14	    exit(-1);E 14E 13	    }#ifndef NOETHERD 2	init_ether();			/* modified by kiuchi Nov. 4 */E 2I 2    init_ether();			/* modified by kiuchi Nov. 4 */E 2D 17#endif NOETHERE 17I 17#endif /* NOETHER */E 17I 17E 17#ifdef FORKCOMMD 2	/* Fork Unix was called in kickstarter; if we forked, look up the */	/* pipe handles to the subprocess and set them up.			    */E 2I 2    /* Fork Unix was called in kickstarter; if we forked, look up the */    /* pipe handles to the subprocess and set them up.		      */E 2D 5    if(please_fork)      {	if(FindUnixPipes())E 5I 5    if(FindUnixPipes()) /* must call the routine to allocate storage, */      {			/* in case we're re-starting a savevm w/open ptys */	if(please_fork)E 5	  fprintf(stderr,		  "Failed to find UNIXCOMM file handles; no processes\n");      }#elseD 2	/* Fork Unix Interface subprocess before we create anything big */	/* interrupts need to be blocked here so subprocess won't see them */	/* This should actually live in the kickstarter... */E 2I 2D 3    /* Fork Unix Interface subprocess before we create anything big */E 3I 3    /* Fork Unix Interface subprocess before we create anything big;   */E 3    /* interrupts need to be blocked here so subprocess won't see them */    /* This should actually live in the kickstarter... */E 2D 2	if(please_fork){int_block(); fork_Unix();}E 2I 2    if(please_fork){int_block(); fork_Unix();}E 2D 17#endif FORKCOMME 17I 17#endif /* FORKCOMM */E 17I 17E 17D 2	/* Load sysout to VM space and returns real sysout_size(not 0) */	sysout_size= sysout_loader(sysout_name, sysout_size); E 2I 2    /* Load sysout to VM space and returns real sysout_size(not 0) */    sysout_size= sysout_loader(sysout_name, sysout_size); E 2D 2	build_lisp_map();		/* built up map */E 2I 2    build_lisp_map();		/* built up map */E 2D 2	init_ifpage(sysout_size);	/* init interface page */	init_iopage();	init_miscstats();E 2I 2    init_ifpage(sysout_size);	/* init interface page */    init_iopage();    init_miscstats();E 2#ifdef NEW_STORAGED 2	init_storage();E 2I 2    init_storage();E 2D 17#endif NEW_STORAGEE 17I 17#endif /* NEW_STORAGE */E 17I 17E 17D 2	set_cursor();			/* modified by osamu Feb. 10 */E 2I 2    set_cursor();E 2D 2        				/* file system directory enumeration stuff */        if (!init_finfo()) {		fprintf(stderr, "Cannot allocate internal data.\n");		exit(1);	}E 2I 2        /* file system directory enumeration stuff */    if (!init_finfo())      {	fprintf(stderr, "Cannot allocate internal data.\n");	exit(1);      }I 14#ifdef RS232	rs232c_init();#endifE 14I 7D 9#ifdef RS232    rs232c_init();#endif RS232E 9E 7E 2D 2      /* Get OS message to ~/lisp.log and print the message to prompt window */        if(!for_makeinit)  {E 2I 2    /* Get OS message to ~/lisp.log and print the message to prompt window */    if(!for_makeinit)      {E 2#ifdef SUNDISPLAY	mess_init();D 17#endif SUNDISPLAYE 17I 17#endif /* SUNDISPLAY */E 17	init_keyboard(0); /* can't turn on the keyboard yet or you will die			     in makeinit.  Pilotbitblt will turn it on if			     you used the proper switches when building LDE.				JDS -- 1/18/90 also BITBLTSUB does it now. */D 2	}E 2I 2      }E 2#ifdef I386/* 80387 initialization */D 2	   asm(".data");	   asm(".align 4");	   asm("__FP_trunc:");	   asm("	.globl __FP_trunc");	   asm(".byte 0x3f");	   asm(".byte 0x0c");	   asm("__FP_round:");	   asm("	.globl	__FP_round");	   asm(".byte 0x3f");	   asm(".byte 0x00");	   asm(".text");	   asm("fldcw __FP_round");	E 2I 2    asm(".data");    asm(".align 4");    asm("__FP_trunc:");    asm("	.globl __FP_trunc");    asm(".byte 0x3f");    asm(".byte 0x0c");    asm("__FP_round:");    asm("	.globl	__FP_round");    asm(".byte 0x3f");    asm(".byte 0x00");    asm(".text");    asm("fldcw __FP_round");	E 2D 17#endif I386E 17I 17#endif /* I386 */E 17I 3I 17E 17#ifdef RS6000    /****************************************************/    /*  For the IBM RS/6000, we have to initialize its	*/    /*  notion of the time zone, so gettimeofday works	*/    /****************************************************/    tzset();D 17#endif RS6000E 17I 17#endif /* RS6000 */E 17I 14#ifdef ISC	tzset();#endifE 14D 9E 9E 3D 2	/* now start up lisp */	start_lisp();}E 2I 2    /* now start up lisp */    start_lisp();  }E 2/************************************************************************//*									*//*		  	   s t a r t _ l i s p				*//*									*//*	This is the function that actually starts up the lisp emulator.	*//*									*//*									*//************************************************************************/start_lisp()  {    DLword *freeptr,*next68k;    TopOfStack=0;    Error_Exit = 0;    MState->pvar = (DLword *) Addr68k_from_LADDR( STK_OFFSET						 | InterfacePage->currentfxp)		              + FRAMESIZE;    freeptr = next68k = Addr68k_from_LADDR(STK_OFFSET | CURRENTFX->nextblock);      if (GETWORD(next68k) != STK_FSB_WORD)      error("Starting Lisp: Next stack block isn't free!");    while(GETWORD(freeptr)==STK_FSB_WORD)      EndSTKP = freeptr = freeptr + GETWORD(freeptr+1);    CurrentStackPTR =next68k -2;    FastRetCALL;    /* JRB - The interrupt intitialization must be done right before */    /*       entering the bytecode dispatch loop; interrupts get     */    /*       unblocked here 					     */    int_init();    dispatch();  }I 2/************************************************************************//*									*//*			m a k e p a t h n a m e				*//*									*//*									*//*									*//************************************************************************/E 2makepathname(src, dst)D 2register char	*src;register char	*dst;				{register int len;register char	*base, *cp;register struct passwd *pwd;char	name[MAXPATHLEN];	base = src;	switch ( *base ) {E 2I 2  register char	*src;  register char	*dst;				  {    register int len;    register char	*base, *cp;    register struct passwd *pwd;    char	name[MAXPATHLEN];    base = src;    switch ( *base )      {E 2	case '.':D 2		if(getwd(dst) == 0){	/* set working directory */E 2I 2	  if(getwd(dst) == 0)	    { /* set working directory */E 2#ifdef FSERRORD 2			*Lisp_errno = errno;E 2I 2	      *Lisp_errno = errno;E 2#endifD 2			return(0);		}		switch ( *(base+1) ){							case '.':			if(*(base+2) == '/'){	/* Now, base == "../xxxx" */				cp = rindex(dst, '/');				if(cp == 0){					return(0);				}				*cp = '\0';				strcat(dst, base+2);				return(1);								}else{									return(0);						}								case '/':			/* Now, base == "./xxx" */			strcat(dst, base+1);						return(1);								default:										return(0);						}E 2I 2	      return(0);	    }	  switch ( *(base+1) )	    {						      case '.':		if(*(base+2) == '/')		  { /* Now, base == "../xxxx" */		    cp = rindex(dst, '/');		    if(cp == 0) return(0);		    *cp = '\0';		    strcat(dst, base+2);		    return(1);							  }		else return(0);				      case '/':		/* Now, base == "./xxx" */		strcat(dst, base+1);					return(1);							      default:									return(0);					    }E 2	case '~':#ifdef FSERRORD 2		ERRSETJMP(0);E 2I 2	  ERRSETJMP(0);E 2#elseD 2		SETJMP(0);E 2I 2	  SETJMP(0);E 2#endifD 2		if( *(base+1) == '/'){			/* path is "~/foo" */			TIMEOUT( pwd = getpwuid( getuid()) );			if(pwd == NULL){				E 2I 2	  if( *(base+1) == '/')	    {	      /* path is "~/foo" */	      TIMEOUT( pwd = getpwuid( getuid()) );	      if(pwd == NULL)		{				E 2#ifdef FSERRORD 2				*Lisp_errno = errno;E 2I 2		  *Lisp_errno = errno;E 2#endifD 2				return(0);			}			sprintf(dst, "%s%s", pwd->pw_dir, base+1);			return(1);		}else{			/* path is "~foo/" */			if((cp=index(base+1, '/')) == 0){				return(0);			}else{				len = (int)cp - (int)base -1;				strncpy(name, base+1, len);				name[len] = '\0';				TIMEOUT( pwd = getpwnam(name) );				if(pwd == NULL){				E 2I 2		  return(0);		}	      sprintf(dst, "%s%s", pwd->pw_dir, base+1);	      return(1);	    }	  else	    {	      /* path is "~foo/" */	      if((cp=index(base+1, '/')) == 0) return(0);	      else		{		  len = (int)cp - (int)base -1;		  strncpy(name, base+1, len);		  name[len] = '\0';		  TIMEOUT( pwd = getpwnam(name) );		  if(pwd == NULL)		    {				E 2#ifdef FSERRORD 2					*Lisp_errno = errno;E 2I 2		      *Lisp_errno = errno;E 2#endifD 2					return(0);				}				sprintf(dst, "%s%s", pwd->pw_dir, cp);				return(1);				}E 2I 2		      return(0);		    }		  sprintf(dst, "%s%s", pwd->pw_dir, cp);		  return(1);	E 2		}I 2	    }E 2	default:D 2		strcpy(dst, src);							return(1);								}}E 2I 2	  strcpy(dst, src);						  return(1);							      }  }E 2E 1