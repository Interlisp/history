h53320s 00009/00005/00070d D 1.10 92/04/22 13:05:43 sybalsky 10 9c SGI portes 00000/00000/00075d D 1.9 92/04/21 17:26:54 sybalsky 9 8c shortening file names for DOS \nes 00014/00008/00061d D 1.8 90/07/04 04:05:35 sybalsky 8 7c fix FP remainder codees 00015/00001/00054d D 1.7 90/06/04 18:09:39 sybalsky 7 6c reformat, copyrightes 00000/00000/00055d D 1.6 90/04/20 01:59:44 sybalsky 6 5c AIX:  shortening file names, bulk change.es 00000/00000/00055d D 1.5 90/03/27 14:29:44 sybalsky 5 4c fp rounding fixes 00015/00044/00040d D 1.4 89/03/29 19:39:13 shih 4 3c changed FPTEST usage, REM was always punting, cleanupes 00013/00021/00071d D 1.3 88/10/12 18:44:01 krivacic 3 2c merge sun3/4 floating ptes 00009/00013/00083d D 1.2 88/10/12 14:45:37 krivacic 2 1c new out-of-line interfacees 00096/00000/00000d D 1.1 88/06/02 11:50:31 charnley 1 0c date and time created 88/06/02 11:50:31 by charnleyeuUf e 0tTI 1D 4/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 4I 4D 7/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 7I 7/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 7E 4static char *id = "%Z% %M%	%I% %G%";/*	ubf2.c */I 7I 10E 10/************************************************************************//*									*/D 10/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 10I 10/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 10/*									*/D 10/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 10I 10/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 10/*									*//************************************************************************/D 10E 10E 7#include <stdio.h>I 8#include <math.h>E 8#include "lispemul.h"I 3#include "fp.h"E 3/************************************************************D 4	OP_ub2  -- op 354  ==  UBFLOAT2[198zE 4I 4	OP_ub2  -- op 354  ==  UBFLOAT2E 4354/0	ADD354/1	SUB354/2	ISUB354/3	MULT354/4	DIV354/5	GREAT354/6	MAX354/7	MIN354/8	REM354/9	AREF***********************************************************/D 3static int constant0 = 0;unsigned int fpstatus_();E 3D 2N_OP_ubfloat2(a2, a1, alpha, error_addr)E 2I 2N_OP_ubfloat2(a2, a1, alpha)E 2int a1, a2;D 2int alpha, *error_addr;E 2I 2int alpha;E 2{D 10register float arg1, arg2;E 10I 10REGISTER float arg1, arg2;E 10float ans;int ret;D 2#ifdef	TRACE   printPC();   printf("TRACE: N_OP_ubfloat2()\n");#endifE 2D 4  arg1 = *(float *)&a1;E 4I 4D 8  arg1 = *(float *)&a1;		/* why?? */E 8I 8/*	Unboxed floating point args (a1, a2) look like float, but	*//*	can't be declared as such because all float args get passed	*//*	as double.  (That can be avoided in ansi C.)  Instead, they	*//*	are declared int and accessed as float through cast pointers.	*//*	The return value is handled similarly.				*/  arg1 = *(float *)&a1;	E 8E 4  arg2 = *(float *)&a2;I 3  FPCLEAR;E 3  switch (alpha) {D 4    case 0: /* add */D 3      fpstatus_(&constant0);E 3      ans = arg1 + arg2;D 2      if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(error_addr);E 2I 2D 3      if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(a1);E 3E 2      ret = *(int *)&ans;D 3      return(ret);E 3I 3      break;E 3    case 1: /* sub */D 3      fpstatus_(&constant0);E 3      ans = arg2 - arg1;D 2      if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(error_addr);E 2I 2D 3      if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(a1);E 3E 2      ret = *(int *)&ans;D 3      return(ret);E 3I 3      break;E 3    case 2: /* isub */D 3      fpstatus_(&constant0);E 3      ans = arg1 - arg2;D 2      if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(error_addr);E 2I 2D 3      if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(a1);E 3E 2      ret = *(int *)&ans;D 3      return(ret);E 3I 3      break;E 3    case 3: /* mul */D 3      fpstatus_(&constant0);E 3      ans = arg1 * arg2;D 2      if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(error_addr);E 2I 2D 3      if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(a1);E 3E 2      ret = *(int *)&ans;D 3      return(ret);E 3I 3      break;E 3    case 4: /* div */D 3      fpstatus_(&constant0);E 3      ans = arg2 / arg1;D 2      if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(error_addr);E 2I 2D 3      if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(a1);E 3E 2      ret = *(int *)&ans;D 3      return(ret);E 3I 3      break;E 3    case 5: /* gt */      if (arg2 > arg1) return(ATOM_T);      else return(NIL_PTR);    case 6: /* max */      if (arg2 > arg1) return(a2);      else return(a1);    case 7: /* min */      if (arg2 > arg1) return(a1);      else return(a2);    case 8: /* rem */E 4I 4    case 0: /* add */  ans = arg1 + arg2; break;    case 1: /* sub */  ans = arg2 - arg1; break;    case 2: /* isub */ ans = arg1 - arg2; break;    case 3: /* mul */  ans = arg1 * arg2; break;    case 4: /* div */  ans = arg2 / arg1; break;D 8    case 5: /* gt */  if (arg2 > arg1) return(ATOM_T); else return(NIL_PTR);    case 6: /* max */ if (arg2 > arg1) return(a2);     else return(a1);    case 7: /* min */ if (arg2 > arg1) return(a1);     else return(a2);    case 8: /* rem */	/* relies on contagion of inf, nan? */E 4D 3      fpstatus_(&constant0);E 3      ans = (arg2 / arg1) - (arg1 * ((arg2 / arg1) / 1));D 2      if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(error_addr);E 2I 2D 3      if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(a1);E 3E 2D 4      ret = *(int *)&ans;E 4I 4      break;E 8I 8    case 5: /* gt */   if (arg2 > arg1) return(ATOM_T); else return(NIL_PTR);    case 6: /* max */  if (arg2 > arg1) return(a2);     else return(a1);    case 7: /* min */  if (arg2 > arg1) return(a1);     else return(a2);    case 8: /* rem */  ans = fmod(arg2,arg1); break;E 8E 4D 3      return(ret);E 3D 2    default: ERROR_EXIT(error_addr);E 2I 2    default: ERROR_EXIT(a1);E 2  }/* end switch */I 3D 4  if (FPTEST) ERROR_EXIT(a1);E 4I 4D 8  ret = *(int *)&ans;		/* why?? */E 8I 8  ret = *(int *)&ans;	/* Convert it back to int for 32 bit storage */E 8  if (FPTEST(ans)) ERROR_EXIT(a1);E 4  return(ret);E 3}/* end N_OP_ub2() */	/* end module */D 4E 4E 1