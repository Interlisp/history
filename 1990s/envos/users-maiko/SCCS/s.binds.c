h36996s 00002/00002/00169d D 2.7 92/04/21 17:05:05 sybalsky 10 9c shortening file names for DOS \nes 00000/00000/00171d D 2.6 90/04/20 01:21:52 sybalsky 9 8c AIX:  shortening file names, bulk change.es 00016/00006/00155d D 2.5 90/03/15 22:02:00 sybalsky 8 7c comments addedes 00076/00072/00085d D 2.4 89/03/27 10:16:54 sybalsky 7 6c Change word-pointer refs to GETWORDes 00008/00008/00149d D 2.3 89/01/09 16:34:08 shih 6 5c minor spelling cleanupes 00000/00174/00157d D 2.2 88/05/25 17:19:45 krivacic 5 4c removed un-referenced bind / unbind opcode routineses 00000/00000/00331d D 2.1 88/05/17 09:22:24 hayata 4 3c Version up to 2.1es 00146/00000/00185d D 1.3 88/03/28 19:19:03 krivacic 3 2c New N_OP interfacees 00002/00002/00183d D 1.2 88/03/13 14:33:21 hayata 2 1c Add SCCS key id (%Z%)es 00185/00000/00000d D 1.1 88/02/24 16:55:51 hayata 1 0c date and time created 88/02/24 16:55:51 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 6/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 6I 6D 8/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 8I 8/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 8E 6static char *id = "%Z% %M%	%I% %G%";E 2D 8/*** ADOPTED NEW VERSION ***/E 8I 8/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 8/*D 8 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.E 8 *D 6 *	Auther	:	Hiroshi Hayata	E 6I 6 *	Author	:	Hiroshi HayataE 6 */I 8E 8#include	<stdio.h>#include	"lispemul.h"D 10#include	"lispglobal.h"#include	"emulglobal.h"E 10I 10#include	"lspglob.h"#include	"emlglob.h"E 10D 5#define RRot1(word)	( ((word & 0x1) << 15) | (word >> 1) )/**************************************************OP_bind	Entry:	BIND		opcode[021]		1. bind PVAR slot to NIL. (n1 times)	2. bind PVAR slot to value of slot in Evaluation stack. (n2 times)	   or push TopOfStack to Evaluation stack.	3. TopOfStack 	[upper word]	1's complement of bind slots			[lower word]	2word offset from PVar	4. increment PC by 3.  ***************************************************/OP_bind(){register short n1;	/* number of slot to bind to NIL (0, 0) */register short n2;	/* number of slot to bind to value of slot in Evaluation stack */register DLword	*ppvar;	/* pointer to argued slot in Pvar area */register int i;	/* temporary for control */#ifdef	TRACE	printPC();	printf("TRACE: OP_bind()\n");#endif	n1 = (Get_BYTE(++PC)) >> 4;	n2 = (*PC) & 0xF;	ppvar = PVar + ((0xFF & (*(++PC)))<<1);	/* beta: *(++PC)	2 word offset from PVar */	for(i=0; i<n1; i++){			*((int *)ppvar) = 0;		/* bind to NIL */		ppvar -= 2;	}		if(n2 == 0){		PushCStack;			/* push TopOfStack to Evaluation stack */	}else{		*((LispPTR *)ppvar) = TopOfStack;			/* bind to TopOfStack */		ppvar -= 2;		for(i=1; i<n2; i++){	/*CSP			--CurrentStackPTR;	*/			*((LispPTR *)ppvar) = *((LispPTR *)CurrentStackPTR);				/* bind to value of slot in Evaluation stack *//*CSP			--CurrentStackPTR;	*/			CurrentStackPTR -= 2;			ppvar -= 2;		}	}	i = ~(n1 + n2);		/* x: 1's complement of number of bind slots */	TopOfStack = (i<<16) | ((*PC)<<1);		/* *PC -- beta */	++PC;}/**************************************************OP_unbind	Entry:	UNBIND		opcode[022]	1. pop CurrentStack until the slot (num, lastpvar) is found	2. unbind lastpvar slot (set to 0xFFFF). (num times)	3. increment PC by 1.  ***************************************************/OP_unbind(){register DLword	num;		/* number of unbind sot */register DLword	lastpvar;	/* last PVAR slot, word offset from Pvar */register DLword	*ppvar;	/* pointer to last PVAR slot. */register DLword	i;		/* temporary for control */#ifdef	TRACE	printPC();	printf("TRACE: OP_unbind()\n");#endif	/* now, CurrentStackPTR points the latter part in slot *//*CSP	for(; !((*(CurrentStackPTR-1)) & 0x8000); CurrentStackPTR -= 2); *//*	for(; !(((WBITS *)CurrentStackPTR)->MSB); CurrentStackPTR -= 2); */	for(; !((*(CurrentStackPTR)) & 0x8000); CurrentStackPTR -= 2);		/* scan (until MSB == 1) *//*CSP	CurrentStackPTR -=2;	num = ~(*(CurrentStackPTR+1));	lastpvar = *(CurrentStackPTR+2);	*/	num = ~(*(CurrentStackPTR));	lastpvar = *(CurrentStackPTR+1);	CurrentStackPTR -=2;	ppvar = PVar + lastpvar;	for(i=0; i<num; i++){			*ppvar = 0xFFFF;		ppvar -= 2;	}	++PC;}/**************************************************OP_dunbind	Entry:	DUNBIND		opcode[023]	1. if TopOfStack is unbound		unbind num slots from PVar.	   if TopOfStack is bound		pop CurrentStack until the slot (num, lastpvar) is found.		unbind num slots from lastpvar.	2. pop the top of CurrentStackPTR to TopOfStack.	3. increment PC by 1.  ***************************************************/OP_dunbind(){register DLword	num;		/* number of unbind sot */register DLword	lastpvar;	/* last PVAR slot, word offset from Pvar */register DLword	*ppvar;	/* pointer to last PVAR slot. */register DLword	i;		/* temporary for control */#ifdef	TRACE	printPC();	printf("TRACE: OP_dunbind()\n");#endif	if(TopOfStack & 0x80000000){ 		/* check MLSB bit of High word in TopOfStack, 1: unbound, 0: bound */	/* TopOfStack is unbound */		num = ~(GetHiWord(TopOfStack));		lastpvar = GetLoWord(TopOfStack);		if(num != 0){			ppvar = PVar + lastpvar;			for(i=0;i<num; ++i){				*ppvar = 0xFFFF;				ppvar -= 2;			}		}		/*if (num == 0) then goto Tail of this function */	}else{	/* TopOfStack is bound */		/* now, CurrentStackPTR points the latter part in slot *//*CSP		for(; !((*(CurrentStackPTR-1)) & 0x8000); CurrentStackPTR -= 2); *//*		for(; !(((WBITS *)CurrentStackPTR)->MSB); CurrentStackPTR -= 2); */		for(; !((*(CurrentStackPTR)) & 0x8000); CurrentStackPTR -= 2);			/* scan (until MSB == 1) *//*CSP		CurrentStackPTR -=2;		num = ~(*(CurrentStackPTR+1));		lastpvar = *(CurrentStackPTR+2);	*/		num = ~(*(CurrentStackPTR));		lastpvar = *(CurrentStackPTR+1);		CurrentStackPTR -=2;		ppvar = PVar + lastpvar;		for(i=0; i<num; i++){				*ppvar = 0xFFFF;			ppvar -= 2;		}	}	PopCStack;	++PC;}		I 3E 5/**************************************************N_OP_bind(stack_pointer, tos, n1, n2)	Entry:	BIND		opcode[021]D 6	E 6I 6E 6	1. bind PVAR slot to NIL. (n1 times)	2. bind PVAR slot to value of slot in Evaluation stack. (n2 times)	   or push TopOfStack to Evaluation stack.D 6	3. Push 	[upper word]	1's complement of bind slotsE 6I 6	3. Push		[upper word]	1's complement of bind slotsE 6			[lower word]	2word offset from PVar***************************************************/LispPTR *N_OP_bind(stack_pointer, tos, byte1, byte2)D 7	register LispPTR *stack_pointer;	register LispPTR tos;	int byte1;	int byte2;{D 6register int n1; 		/* # slots to bind to NIL (0, 0) */E 6I 6register int n1;		/* # slots to bind to NIL (0, 0) */E 6register int n2;		/* # slots to bind to value in stack */register LispPTR *ppvar;	/* pointer to argued slot in Pvar area */register int i;			/* temporary for control */E 7I 7 register LispPTR *stack_pointer;  register LispPTR tos;  int byte1;  int byte2;  {    register int n1;		/* # slots to bind to NIL (0, 0) */    register int n2;		/* # slots to bind to value in stack */    register LispPTR *ppvar;	/* pointer to argued slot in Pvar area */    register int i;		/* temporary for control */E 7#ifdef	TRACED 7	printPC();	printf("TRACE: N_OP_bind()\n");E 7I 7    printPC();    printf("TRACE: N_OP_bind()\n");E 7#endifD 7	n1 = byte1 >> 4;	n2 = byte1 & 0xf;	ppvar = (LispPTR *) PVar + 1 + byte2;E 7I 7    n1 = byte1 >> 4;    n2 = byte1 & 0xf;    ppvar = (LispPTR *) PVar + 1 + byte2;E 7D 7	for(i=0; i<n1; i++)	{ *--ppvar = NIL_PTR; }E 7I 7    for(i=0; i<n1; i++)      {	*--ppvar = NIL_PTR;      }E 7D 6	E 6I 6E 6D 7	if(n2 == 0){		*stack_pointer++ = tos;			/* push TopOfStack to Evaluation stack */	}else{		*--ppvar = tos;			/* bind to TopOfStack */		for(i=1; i<n2; i++) { *--ppvar = *(--stack_pointer); }	}E 7I 7    if(n2 == 0)      {	*stack_pointer++ = tos;  /* push TopOfStack to Evaluation stack */      }    else      {	*--ppvar = tos;	/* bind to TopOfStack */	for(i=1; i<n2; i++) { *--ppvar = *(--stack_pointer); }      }E 7D 7	i = ~(n1 + n2);		/* x: 1's complement of number of bind slots */	*stack_pointer = (i<<16) | (byte2<<1);	return(stack_pointer);}E 7I 7    i = ~(n1 + n2);	/* x: 1's complement of number of bind slots */    *stack_pointer = (i<<16) | (byte2<<1);    return(stack_pointer);  }E 7/**************************************************LispPTR N_OP_unbind(stackpointer)	Entry:	UNBIND		opcode[022]	1. pop stackpointer until the slot (num, lastpvar) is found	   (Note: TOPOFSTACK is ignored)	2. unbind lastpvar slot (set to 0xFFFF). (num times)***************************************************/LispPTR *N_OP_unbind(stack_pointer)D 7	register LispPTR *stack_pointer;{register DLword	num;		/* number of unbind sot */register LispPTR *ppvar;	/* pointer to last PVAR slot. */register DLword	i;		/* temporary for control */register LispPTR value;E 7I 7  register LispPTR *stack_pointer;  {D 8    register DLword	num;		/* number of unbind sot */    register LispPTR *ppvar;	/* pointer to last PVAR slot. */    register DLword	i;		/* temporary for control */E 8I 8    register DLword num;		/* number of unbind sot */    register LispPTR *ppvar;		/* pointer to last PVAR slot. */    register DLword i;			/* temporary for control */E 8    register LispPTR value;E 7#ifdef	TRACED 7	printPC();	printf("TRACE: N_OP_unbind()\n");E 7I 7    printPC();    printf("TRACE: N_OP_unbind()\n");E 7#endifD 7	/* now, stack_pointer points the latter part in slot */	for(; !(*--stack_pointer & 0x80000000); );		/* scan (until MSB == 1) */E 7I 7    /* now, stack_pointer points the latter part in slot */    for(; !(*--stack_pointer & 0x80000000); );	/* scan (until MSB == 1) */E 7D 7	value = *stack_pointer;	num = (DLword) ~(value >> 16);	ppvar = (LispPTR *) (PVar + 2 + GetLoWord(value));	value = 0xffffffff;	for(i=0; i<num; i++)	{ *--ppvar = value; }	return(stack_pointer);}E 7I 7    value = *stack_pointer;    num = (DLword) ~(value >> 16);    ppvar = (LispPTR *) (PVar + 2 + GetLoWord(value));    value = 0xffffffff;    for(i=0; i<num; i++) { *--ppvar = value; }    return(stack_pointer);  }E 7/**************************************************N_OP_dunbind	Entry:	DUNBIND		opcode[023]	1. if TopOfStack is unbound		unbind num slots from PVar.	   if TopOfStack is bound		pop CurrentStack until the slot (num, lastpvar) is found.		unbind num slots from lastpvar.	2. pop the top of CurrentStackPTR to TopOfStack.***************************************************/LispPTR *N_OP_dunbind(stack_pointer, tos)D 7register LispPTR *stack_pointer;register LispPTR tos;{register DLword	num;		/* number of unbind sot */register LispPTR *ppvar;	/* pointer to last PVAR slot. */register DLword	i;		/* temporary for control */register LispPTR value;E 7I 7  register LispPTR *stack_pointer;  register LispPTR tos;  {    register DLword	num;		/* number of unbind sot */    register LispPTR *ppvar;	/* pointer to last PVAR slot. */    register DLword	i;		/* temporary for control */    register LispPTR value;E 7#ifdef	TRACED 7	printPC();	printf("TRACE: N_OP_dunbind()\n");E 7I 7    printPC();    printf("TRACE: N_OP_dunbind()\n");E 7#endifD 6	if(tos & 0x80000000){ E 6I 6D 7	if(tos & 0x80000000){E 6		/* check MSB bit of High word in tos, 1: unbound, 0: bound */E 7I 7    if(tos & 0x80000000)      {	/* check MSB bit of High word in tos, 1: unbound, 0: bound */E 7	/* tos is unbound */D 7		num = ~(GetHiWord(tos));		value = 0xffffffff;		if(num != 0){			ppvar = (LispPTR *) (PVar + 2 + GetLoWord(tos));			for(i=0;i<num; ++i) { *--ppvar = value; }		}	}else{E 7I 7	num = ~(GetHiWord(tos));	value = 0xffffffff;	if(num != 0)	  {	    ppvar = (LispPTR *) (PVar + 2 + GetLoWord(tos));	    for(i=0;i<num; ++i) { *--ppvar = value; }	  }      }    else      {E 7	/* tos is bound */D 7		/* now, stack_pointer points the latter part in slot */		for(; !((*--stack_pointer) & 0x80000000); );E 7I 7	/* now, stack_pointer points the latter part in slot */	for(; !((*--stack_pointer) & 0x80000000); );E 7			/* scan (until MSB == 1) */D 6		E 6I 6E 6	value = *stack_pointer;	num = ~(GetHiWord(value));	ppvar = (LispPTR *) (PVar + 2 + GetLoWord(value));	value = 0xffffffff;D 7	for(i=0; i<num; i++)	{ *--ppvar = value; }E 7I 7	for(i=0; i<num; i++){ *--ppvar = value; }      }E 7D 7	}	return(stack_pointer);}E 7I 7    return(stack_pointer);  }E 7E 3E 1