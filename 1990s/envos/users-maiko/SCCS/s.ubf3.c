h54923s 00001/00001/00058d D 1.10 93/02/08 14:59:53 sybalsky 10 9c Big VM (and new CDR coding) changes for 3.0 \nes 00030/00029/00029d D 1.9 92/04/22 13:05:49 sybalsky 9 8c SGI portes 00002/00002/00056d D 1.8 92/04/21 17:27:08 sybalsky 8 7c shortening file names for DOS \nes 00015/00001/00043d D 1.7 90/06/04 18:09:51 sybalsky 7 6c reformat, copyrightes 00000/00000/00044d D 1.6 90/04/20 01:59:59 sybalsky 6 5c AIX:  shortening file names, bulk change.es 00000/00000/00044d D 1.5 90/03/27 14:29:54 sybalsky 5 4c fp rounding fixes 00007/00016/00037d D 1.4 89/03/29 19:39:29 shih 4 3c changed FPTEST usagees 00004/00010/00049d D 1.3 88/10/12 18:44:07 krivacic 3 2c merge sun3/4 floating ptes 00004/00005/00055d D 1.2 88/10/12 14:45:45 krivacic 2 1c new out-of-line interfacees 00060/00000/00000d D 1.1 88/06/02 11:50:43 charnley 1 0c date and time created 88/06/02 11:50:43 by charnleyeuUf e 0tTI 1D 4/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 4I 4D 7/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 7I 7/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 7E 4static char *id = "%Z% %M%	%I% %G%";/*	ubf3.c */I 7D 9E 9/************************************************************************//*									*/D 9/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 9I 9/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 9/*									*/D 9/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 9I 9/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 9/*									*//************************************************************************/I 9E 9E 7#include <stdio.h>#include "lispemul.h"D 8#include "lispglobal.h"#include "address68k.h"E 8I 8#include "lspglob.h"#include "adr68k.h"E 8#include "lispmap.h"I 3#include "fp.h"E 3/************************************************************	N_OP_ubfloat3  -- op 062062/0	POLY***********************************************************/D 3static int constant0 = 0;unsigned int fpstatus_();E 3D 2N_OP_ubfloat3(arg3, arg2, arg1, alpha, error_addr)int *error_addr;E 2I 2N_OP_ubfloat3(arg3, arg2, arg1, alpha)E 2D 9int arg3;int alpha;LispPTR arg1, arg2;{register float val;register float ans;register float *fptr;register int degree;int ret;float flot;E 9I 9  int arg3;  int alpha;  LispPTR arg1, arg2;  {    REGISTER float val;    REGISTER float ans;    REGISTER float *fptr;    register int degree;    int ret;    float flot;E 9D 3#ifdef	TRACE  printPC();  printf("TRACE: N_OP_ubfloat3()\n");#endifE 3D 4  val = *(float *)&arg3;E 4I 4D 9  val = *(float *)&arg3;		/* why? */E 4D 2  if (alpha) ERROR_EXIT(error_addr);E 2I 2  if (alpha) ERROR_EXIT(arg1);E 2D 3  fpstatus_(&constant0);E 3I 3  FPCLEAR;E 3D 2  if ((arg1 & 0xFF0000) != S_POSITIVE) ERROR_EXIT(error_addr);E 2I 2  if ((arg1 & 0xFF0000) != S_POSITIVE) ERROR_EXIT(arg1);E 2  degree = 0xFFFF & arg1;D 4  fptr = (float *)Addr68k_from_LADDR(arg2); E 4I 4  fptr = (float *)Addr68k_from_LADDR(arg2);E 4  ans = *((float *)fptr);D 4  while (degree--)  ans = (ans * val) + *((float *)(++fptr));D 2  if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(error_addr);E 2I 2D 3  if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(arg1);E 3I 3  if (FPTEST) ERROR_EXIT(arg1);E 4I 4  while (degree--)      ans = (ans * val) + *((float *)(++fptr));  if (FPTEST(ans)) ERROR_EXIT(arg1);	/* relies on contagion of inf, nan? */E 4E 3E 2  flot = ans;D 4  ret = *(int *)&flot;E 4I 4  ret = *(int *)&flot;			/* why? */E 4  return(ret);}/* end N_OP_ubfloat3() */E 9I 9    val = *(float *)&arg3;		/* why? */    if (alpha) ERROR_EXIT(arg1);    FPCLEAR;D 10    if ((arg1 & 0xFF0000) != S_POSITIVE) ERROR_EXIT(arg1);E 10I 10    if ((arg1 & SEGMASK) != S_POSITIVE) ERROR_EXIT(arg1);E 10    degree = 0xFFFF & arg1;    fptr = (float *)Addr68k_from_LADDR(arg2);    ans = *((float *)fptr);    while (degree--) ans = (ans * val) + *((float *)(++fptr));    if (FPTEST(ans)) ERROR_EXIT(arg1);	/* relies on contagion of inf, nan? */    flot = ans;    ret = *(int *)&flot;			/* why? */    return(ret);  }/* end N_OP_ubfloat3() */E 9	/* end module */D 4E 4E 1