h58157s 00004/00004/00540d D 2.51 92/04/21 16:54:30 sybalsky 75 74c shortening file names for DOS \nes 00000/00000/00544d D 2.50 90/09/12 18:01:22 sybalsky 74 73c OBSOLETE, replaced with main.c.es 00016/00004/00528d D 2.49 90/07/04 03:51:56 sybalsky 73 72c Bob Bane changes:  fork unix process here, so it's smaller.es 00009/00002/00523d D 2.48 90/06/22 16:38:35 fuji 72 71c New compile flag NOETHERes 00010/00003/00515d D 2.47 90/06/13 15:22:21 sybalsky 71 70c AIX compatibility changes.es 00006/00000/00512d D 2.46 90/06/04 14:47:02 mitani 70 69c init_finfo addedes 00006/00003/00506d D 2.45 90/05/31 14:49:16 fuji 69 68c Takeshi: Add NEW storage futures.(various process size)es 00000/00000/00509d D 2.44 90/04/20 01:05:27 sybalsky 68 67c AIX:  shortening file names, bulk change.es 00096/00010/00413d D 2.43 90/04/19 18:20:59 mitani 67 66c makepathname is moved from ufs.ces 00010/00009/00413d D 2.42 90/03/27 14:28:54 sybalsky 66 65c fp rounding fixes 00002/00002/00420d D 2.41 90/03/23 11:32:30 takeshi 65 64c val for 387 as 0xc3fes 00003/00001/00419d D 2.40 90/03/19 11:37:25 takeshi 64 63c I386 initialized by 0xffffes 00009/00000/00411d D 2.39 90/03/15 20:57:28 takeshi 63 62c Floating initialization for i386es 00010/00003/00401d D 2.38 90/03/01 12:54:07 osamu 62 61c Mitsunori Matsuda adds XWindow functionality.es 00002/00001/00402d D 2.37 90/02/06 11:43:28 sybalsky 61 60c Cleanup of atom code.es 00140/00093/00263d D 2.36 89/12/28 15:22:02 sybalsky 60 59c commenting, plus code cleanupes 00004/00005/00352d D 2.35 89/03/15 17:59:29 sybalsky 59 58c depends on lisptypes now, and uses GETWORD instead of *(DLword *)es 00013/00023/00344d D 2.34 89/03/02 23:43:55 shih 58 57c minor style cleanupes 00004/00001/00363d D 2.33 89/02/14 13:22:46 snow 57 56c Added global kbd_for_makeinit for making loadups on Sunes 00003/00002/00361d D 2.32 89/01/10 15:40:19 shih 56 55c didn't handle null keystring casees 00003/00001/00360d D 2.31 89/01/10 15:22:08 shih 55 54c need to copy keystring (keytester destroys it) of bad keyes 00002/00002/00359d D 2.30 89/01/06 17:57:46 shih 54 53c changed err msg. to use LDESRCESYSOUT not LDESOURCESYSOUTes 00001/00001/00360d D 2.29 89/01/05 21:59:45 shih 53 52c mistake printing invalid keyes 00002/00001/00359d D 2.28 88/12/19 17:31:14 shih 52 51c echo keystring if invalid keyes 00003/00002/00357d D 2.27 88/12/01 12:01:29 hayata 51 50c put right SCCS ides 00011/00002/00348d D 2.26 88/12/01 12:00:18 hayata 50 49c To fix error message problem (connection time out & too many files open), global var *Lisp_errno is used to keep errno.es 00002/00027/00348d D 2.25 88/11/15 17:26:08 hayata 49 48c To fix "connection timeout" problem, signal is moved to timer.ces 00001/00001/00374d D 2.24 88/10/27 18:03:50 shimizu 48 47c change I/F for init_keyboardes 00001/00001/00374d D 2.23 88/10/14 00:01:16 shih 47 46c typo in previous versiones 00025/00023/00350d D 2.22 88/10/13 23:45:10 shih 46 45c allow LDESRCESYSOUT, cleanup.  jmpbuf set where?es 00002/00002/00371d D 2.21 88/10/12 17:21:01 krivacic 45 44c comment out rs232 & tty inites 00002/00029/00371d D 2.20 88/10/12 14:38:37 krivacic 44 43c new out-of-line interfacees 00078/00053/00322d D 2.19 88/10/10 14:03:27 krivacic 43 42c sun3/4 mergees 00001/00001/00374d D 2.18 88/10/04 15:44:41 sye 42 41c es 00000/00006/00375d D 2.17 88/09/27 15:39:33 krivacic 41 40c merginges 00003/00003/00378d D 2.16 88/07/27 10:56:36 hayata 40 39c mess_init() is called after sysout_loader.es 00004/00000/00377d D 2.15 88/07/26 14:31:12 shimizu 39 38c Add PROFILE option for monitores 00002/00002/00375d D 2.14 88/06/29 10:48:13 hayata 38 37c Add SCCS key ides 00007/00004/00370d D 2.13 88/06/29 10:46:11 hayata 37 36c Change timeout_error to fix Remote Server Time Out Problemes 00006/00001/00368d D 2.12 88/06/27 01:49:04 bane 36 35c Added -NF option for no fork on command linees 00055/00029/00314d D 2.11 88/06/21 21:45:51 bane 35 34c New sysout file lookup procedurees 00000/00000/00343d D 2.10 88/06/15 23:09:17 shih 34 33c no changeses 00001/00001/00342d D 2.9 88/06/15 21:33:26 bane 33 32c Removed & on structure referencees 00001/00001/00342d D 2.8 88/06/15 21:09:41 shih 32 31c typoes 00019/00014/00324d D 2.7 88/06/15 21:07:28 shih 31 30c copy protection enabled, m option disabled on def UNPROTECTEDes 00023/00000/00315d D 2.6 88/06/14 15:13:36 hayata 30 29c Call signal to catch alarm. to fix file access time out problem.es 00022/00012/00293d D 2.5 88/06/13 17:07:49 bane 29 28c Takes -E argument from lispgo net opener programes 00001/00005/00304d D 2.4 88/05/31 19:48:07 masinter 28 27c eliminate obsolete StkLimOes 00000/00001/00309d D 2.3 88/05/24 18:22:13 krivacic 27 26c remove obsolete init_evalform_frame()es 00015/00006/00295d D 2.2 88/05/20 04:03:18 shih 26 25c half-enabled access-key mechanismes 00000/00000/00301d D 2.1 88/05/17 09:21:09 hayata 25 24c Version up to 2.1es 00009/00003/00292d D 1.24 88/05/16 15:15:43 masinter 24 23c Move ether initialization before forking any processeses 00001/00008/00294d D 1.23 88/05/11 12:06:58 shimizu 23 22c refinement for return.hes 00000/00004/00302d D 1.22 88/05/11 11:21:21 shimizu 22 21c remove smashhardreturnes 00003/00000/00303d D 1.21 88/05/10 12:20:57 hayata 21 20c Add mess_init for osmessage.es 00004/00000/00299d D 1.20 88/05/09 20:14:54 shimizu 20 19c Add hardreturn initializees 00021/00005/00278d D 1.19 88/05/06 13:23:28 shih 19 18c Better argument processinges 00004/00001/00279d D 1.18 88/05/04 18:12:21 masinter 18 17c new timeres 00001/00000/00279d D 1.17 88/05/02 09:57:33 krivacic 17 16c add native closure hashes 00004/00000/00275d D 1.16 88/04/29 00:43:45 masinter 16 15c Tomtom's changes for Medley; hook into closure cache mechanismes 00005/00003/00270d D 1.15 88/04/27 09:14:18 bane 15 14c Added int_init for interrupt initialiationes 00007/00037/00266d D 1.14 88/04/22 19:13:05 krivacic 14 13c remove excess stuffes 00006/00000/00297d D 1.13 88/03/20 16:46:16 masinter 13 12c Merge new gc code for closure cachees 00002/00000/00295d D 1.12 88/04/15 10:43:24 bane 12 11c Added third argument to lisp: timer interval in microseconds (< 20000 same as 20000 to system)es 00003/00000/00292d D 1.11 88/03/15 17:15:40 bane 11 10c Added call to timer interrupt init before dispatch()es 00001/00001/00291d D 1.10 88/04/11 18:05:53 hayata 10 9c move init_ether() to fix ether bug.es 00004/00000/00288d D 1.9 88/04/11 17:18:30 masinter 9 8c add NOFORK condition to turn off fork_unix for debugginges 00007/00000/00281d D 1.8 88/04/05 11:10:42 jmturn 8 7c Added Unix Interface Startupes 00005/00002/00276d D 1.7 88/04/01 17:39:25 masinter 7 6c Allow sysout size as parameter in line after sysout namees 00001/00001/00277d D 1.6 88/03/31 10:55:16 shimizu 6 5c Add NeedHardreturnCleanup_wordes 00006/00000/00272d D 1.5 88/03/23 18:02:02 shimizu 5 4c Add global vars for stackhandlinges 00001/00001/00271d D 1.4 88/03/13 15:14:57 hayata 4 3c Change SCCS key ides 00002/00002/00270d D 1.3 88/03/13 15:13:40 hayata 3 2c Add SCCS key ides 00013/00011/00259d D 1.2 88/03/03 11:32:10 krivacic 2 1c Removed global CurrentFX to use CURRENTFX = PVAR - FRAMESIZEes 00270/00000/00000d D 1.1 88/02/23 17:19:34 hayata 1 0c date and time created 88/02/23 17:19:34 by hayataeuUtTI 1D 3/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%W%	%I% %G%";E 3I 3D 37/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */D 4static char *id = "%Z% %W%	%I% %G%";E 4I 4static char *id = "%Z% %M%	%I% %G%";E 37I 37D 38/* This is G-file @(#) Ctest.c Version 2.12 (6/27/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) Ctest.c	2.12 6/27/88";E 38I 38D 50/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 50I 50D 51/* This is G-file @(#) Ctest.c Version 2.25 (11/15/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) Ctest.c	2.25 11/15/88";E 51I 51D 52/* This is G-file %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 52I 52D 66/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 52static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 66I 66D 67/* @(#) Ctest.c Version 2.41 (3/23/90). copyright envos & Fuji Xerox  */static char *id = "@(#) Ctest.c	2.41 3/23/90		(envos & Fuji Xerox)";E 67I 67/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 67E 66I 60D 62E 62/************************************************************************//*									*/D 71/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 71I 71/*	Copyright 1989, 1990 Venue.  All Rights Reserved.		*/E 71/*									*//*	This file is work-product resulting from the Xerox/Venue	*/D 71/*	Agreement dated 18-August-1989 for support of Medley.		*/E 71I 71/*	Agreement dated 18-August-1989 for support of Medley,		*//*	further modified outside the scope of that contract, and	*//*	hence the property solely of Venue.				*/E 71/*									*//************************************************************************/D 69E 69E 60E 51E 50E 38E 37E 4E 3D 58E 58/*D 58 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.E 58I 58 *	Copyright (C) 1987,88,89  by Fuji Xerox Co., Ltd. All rights reserved.E 58 *//* *	Ctest.c *	This file includes main()D 58 *D 14 * 	** MERGED AT AISE 14 *E 58 */I 67#include	<sys/types.h>#include	<sys/param.h>#include        <sys/time.h>#include	<sys/types.h>I 71#ifndef AIXE 71#include	<net/nit.h>	/* needed for Ethernet stuff below */I 71#endif AIXE 71#include	<stdio.h>#include	<strings.h>#include	<sys/file.h>#include	<setjmp.h>#include	<pwd.h>#include	<errno.h>E 67#include "lispemul.h"D 75#include "emulglobal.h"E 75I 75#include "emlglob.h"E 75#include "address.h"D 75#include "address68k.h"E 75I 75#include "adr68k.h"E 75#include "stack.h"I 23#include "return.h"E 23D 75#include "lispglobal.h"I 59#include "lisptypes.h"E 75I 75#include "lspglob.h"#include "lsptypes.h"E 75E 59#include "lispmap.h"#include "ifpage.h"#include "iopage.h"D 14#include "opcodefunc.h"#include "optable.h"E 14#include "debug.h"I 43#include "profile.h"E 43I 67#include "timeout.h"E 67I 43E 43D 67#include        <sys/time.h>I 37D 46#include 	<setjmp.h>E 46I 46D 49#include	<setjmp.h>E 49E 46E 37I 29#include	<sys/types.h>#include	<net/nit.h>	/* needed for Ethernet stuff below */I 49#include	<stdio.h>#include	<sys/file.h>E 49E 29I 30D 49/* For Time Out Service */#include <signal.h>#include <errno.h>I 35#include <stdio.h>#include        <sys/file.h>E 35int	timeout_error();E 49E 67D 49E 49E 30DLword	*Lisp_world;		/* lispworld *//********** 68k address for Lisp Space **********/DLword	*Atomspace;DLword	*Stackspace;DLword	*Plistspace;DLword	*DTDspace;DLword	*MDStypetbl;DLword	*AtomHT;DLword	*Pnamespace;DLword	*Defspace;DLword	*Valspace;DLword	*Spospspace;DLword	*Snegspace;/********** For Virtual Memory Management **********/DLword	*FPtoVP;DLword	*PAGEMap;DLword	*PageMapTBL;DLword	*LockedPageTable;/********** For Interface to LispMicro/Device **********/DLword	*IOCBPage;IOPAGE	*IOPage;IFPAGE	*InterfacePage;MISCSTATS	*MiscStats;/********** UFN Table **********/DLword	*UFNTable;/********** Tables for GC **********/DLword	*HTmain;DLword	*HToverflow;DLword	*HTbigcount;DLword	*HTcoll;/********** Display **********/DLword	*DisplayRegion;int DisplayInitialized = NIL;D 43int loop; /* for contextsw loop count OBSOLATE */E 43DLword	*Arrayspace;DLword	*MDS_space_bottom;DLword	*PnCharspace;struct dtd	*ListpDTD;D 43/********** Display **********/extern int Intrdisable;E 43D 43E 43/********** For Lisp Emulator **********/D 43LispPTR	TopOfStack;DLword	*CurrentStackPTR;D 26/*Change to MachienState and MState:E 26I 26/*Change to MachineState and MState:E 26	DLword	*IVar;	DLword	*PVar; */E 43struct	state	MachineState;D 43struct	state	*MState;ByteCode	*PC;D 2struct frameex1	*CurrentFX;E 2I 2D 41/* struct frameex1	*CurrentFX; */E 41E 2struct fnhead	*FuncObj;DLword *EndSTKP ;D 28DLword *StkLimO ;E 28DLword *LastStackAddr;E 43/**********************************//*** Share val with LISP code ******/DLword *MDS_free_page;DLword *Next_MDSpage;DLword *Next_Array;/*******************************************//** CACHE LISP SYSVAL ***/LispPTR *Next_MDSpage_word;LispPTR *Next_Array_word;LispPTR *MDS_free_page_word;LispPTR *Reclaim_cnt_word ;/*** Cache Values for reclaimer by Tomtom 30-Sep-1987 ***/LispPTR *GcDisabled_word;LispPTR *CdrCoding_word;LispPTR *FreeBlockBuckets_word;LispPTR *Array_Block_Checking_word;LispPTR *ArrayMerging_word;LispPTR *ArraySpace_word;LispPTR *ArraySpace2_word;LispPTR *ArrayFrLst_word;LispPTR *ArrayFrLst2_word;LispPTR *Hunk_word;LispPTR *System_Buffer_List_word;/*** The end of the addition of cache values on reclaimer ***/D 14/** cashe values for code reclaimer by Tomtom 9-Oct-1987 ***/E 14D 41D 14LispPTR *OpCode_Array_word;LispPTR *OpCodes_word;LispPTR  Dopcode_index;		/*** 23-Oct-1987 added by Tomtom ***/E 14I 14/*** UNKNOWN if NEEDED ??? ***/E 14D 14/*** The end of the addition of cache values for code reclaimer ***/E 14I 14LispPTR *RclkMilliSecond_word;LispPTR *RclkSecond_word;E 41E 14D 26/*** cashe values for the top level reclaimer's implementation ***/E 26I 26/*** cache values for the top level reclaimer's implementation ***/E 26LispPTR *GcMess_word;LispPTR *ReclaimMin_word;LispPTR *GcTime1_word;LispPTR *GcTime2_word;LispPTR *MaxTypeNumber_word;D 26/*** The end of the addition of cashe values for top reclaimer by TomtomE 26I 26/*** The end of the addition of cache values for top reclaimer by TomtomE 26						15-Oct-1987             ***/D 14/*** The addition of cashe values for GCClock 26-Oct-1987 by Tomtom ***/LispPTR *RclkSecond_word;LispPTR *RclkMilliSecond_word;E 14I 13/*  Pointers for closure caching */I 16D 58LispPTR *Package_from_Index_word;             /*** added Apr-28,88 Tomtom ***/LispPTR *Package_from_Name_word;              /*** added Apr-28,88 Tomtom ***/LispPTR *Keyword_Package_word;                /*** added Apr-28,88 Tomtom ***/E 58I 58LispPTR *Package_from_Index_word;LispPTR *Package_from_Name_word;LispPTR *Keyword_Package_word;E 58E 16LispPTR *Closure_Cache_Enabled_word;LispPTR *Closure_Cache_word;LispPTR *Deleted_Implicit_Hash_Slot_word;I 16D 46LispPTR First_index;                         /*** added Apr-28,88 Tomtom ***/  E 46I 46D 58LispPTR First_index;                         /*** added Apr-28,88 Tomtom ***/E 58I 58LispPTR First_index;E 58E 46E 16E 13D 14/*** The end of cashe values for GCClock ***/E 14I 14/*** The end of Pointers for closure caching ***/E 14D 46 E 46I 46E 46/* CACHE values for 32Mb MDS/Array by Take */LispPTR *STORAGEFULLSTATE_word;LispPTR *STORAGEFULL_word;LispPTR *PENDINGINTERRUPT_word;LispPTR *LeastMDSPage_word;LispPTR *SecondMDSPage_word;LispPTR *SecondArrayPage_word;LispPTR *INTERRUPTSTATE_word;LispPTR *SYSTEMCACHEVARS_word;LispPTR *MACHINETYPE_word;LispPTR STORAGEFULLSTATE_index;/******* 7-Oct-87 take********/LispPTR *LASTVMEMFILEPAGE_word;LispPTR *VMEM_FULL_STATE_word ;/** Array for N-tran **/D 14CFuncPTR Native_Hash[Native_Hash_Size];E 14I 14int native_load_address;I 17LispPTR native_closure_env = NOBIND_PTR;E 17E 14I 8/** Pipes for Unix Interface **/int UnixPipeIn;int UnixPipeOut;int UnixPID;I 62int please_fork = 1;E 62E 8I 5/*** STACK handle staff(Takeshi) **/LispPTR *STACKOVERFLOW_word;LispPTR *GuardStackAddr_word;LispPTR *LastStackAddr_word;D 6E 6I 6LispPTR *NeedHardreturnCleanup_word;E 6D 23E 5#define FastRetCALL {	/* Get IVar from Retunee's IVAR offset slot(BF) */ \D 2	IVar = Addr68k_from_LADDR(STK_OFFSET | *((DLword *)CurrentFX -1)) ; \E 2I 2	IVar = Addr68k_from_LADDR(STK_OFFSET | *((DLword *)CURRENTFX -1)) ; \E 2	/* Get FuncObj from Retunee's FNHEAD slot in FX */ \D 2	FuncObj = (struct fnhead *)Addr68k_from_LADDR((CurrentFX->hi2fnheader <<16) | CurrentFX->lofnheader) ; \E 2I 2	FuncObj = (struct fnhead *)Addr68k_from_LADDR((CURRENTFX->hi2fnheader <<16) | CURRENTFX->lofnheader) ; \E 2	/* Get PC from Retunee's pc slot in FX */ \D 2	PC = (ByteCode *)FuncObj + CurrentFX->pc ; }E 2I 2	PC = (ByteCode *)FuncObj + CURRENTFX->pc ; }E 2E 23I 29/*** Ethernet stuff (JRB) **/I 72D 73#ifdef NOETHER#elseE 73I 73#ifndef NOETHERE 73E 72extern int ether_fd;extern u_char ether_host[6];I 72#endif NOETHERE 72extern struct sockaddr_nit snit;I 43D 46int 	for_makeinit = 0;E 46I 46int	for_makeinit = 0;I 57int	kbd_for_makeinit = 0;E 57E 46int	save_argc;char	**save_argv;int	display_max = 65536*16*2;I 50/** For call makepathname inside main() **/extern int	*Lisp_errno;extern int	Dummy_errno;		/* If errno cell is not provided by Lisp, dummy_errno is used. */E 50I 46char *getenv();I 58D 60/*  ================================================================  */E 60I 60/************************************************************************//*									*//*		     M A I N   E N T R Y   P O I N T			*//*									*//*									*//************************************************************************/E 60E 58E 46E 43E 29main(argc, argv)D 60int	argc ;char	**argv ;{I 19	int i;E 19D 7	/* load sysout to 4Mbytes VM space */	sysout_loader(argv[1]);E 7I 7	int sysout_size = 32;I 36	int please_fork = 1;E 36I 12	extern int TIMER_INTERVAL;I 26D 35	char *keystring;E 35I 35D 42	char *keystring, sysout_name[1024], *envname, *getenv();E 42I 42D 46	char *keystring=NULL, sysout_name[1024], *envname, *getenv();E 46I 46	char *keystring=NULL, sysout_name[1024], *envname;I 55	char  keytyped [ 255 ];E 60I 60  int	argc ;  char	**argv ;  {    int i;D 69    int sysout_size = 32;E 69I 69D 71    int sysout_size = 0; /* defualt 0 */ /* was = 32;*/E 71I 71    int sysout_size = 0; /* default 0 */ /* was = 32;*/E 71E 69D 62    int please_fork = 1;E 62    extern int TIMER_INTERVAL;    char *keystring=NULL, sysout_name[1024], *envname;    char  keytyped [ 255 ];E 60E 55E 46E 42E 35E 26E 12D 19	if (argc > 2) {sysout_size = atoi(argv[2]);};I 12	if (argc > 3) {TIMER_INTERVAL = atoi(argv[3]);};E 19E 12I 8I 62#ifdef XWINDOW	read_Xoption( argc, argv );#endif XWINDOWE 62I 43D 60	save_argc = argc;	save_argv = argv;E 60I 60    save_argc = argc;    save_argv = argv;E 60E 43I 39#ifdef PROFILED 60	moncontrol(0); /* initially stop sampling */E 60I 60    moncontrol(0); /* initially stop sampling */E 60#endif PROFILEE 39I 19D 26	printf ( "lisp sysout [-t timer-interval] [-m sysout-size] [-k copy-key]\n" );E 26I 26D 29	printf ( "lisp sysout [-t timer-interval] [-m sysout-size] [-k access-key]\n" );E 29I 29D 31	printf ( "lisp sysout [-t timer-interval] [-m sysout-size] [-k access-key] [-E <ethernet-info>]\n" );E 31I 31D 35	printf ( "lisp sysout [-t timer-interval] [-k access-key] [-E <ethernet-info>]\n" );E 35I 35/* Sysout is found as follows:	If the first argument doesn't begin with '-', assume it's the sysoutD 54	Look at the environment variable LDESOURCESYSOUT if that failsE 54I 54	Look at the environment variable LDESRCESYSOUT if that failsE 54	Look for ~/lisp.virtualmem if that fails	Barf and print the command line if tha fails*/I 50#ifdef	FSERRORD 60	/* For call makepathname */	Lisp_errno = &Dummy_errno;E 60I 60    /* For call makepathname */    Lisp_errno = &Dummy_errno;E 60#endifE 50E 35E 31E 29E 26I 24D 29/* INITIALIZE ETHERNET FIRST -- THIS IS BECAUSE IF YOU ARE RUNNING AS ROOT   IT WILL RESET THE UID CORRECTLY - IMPORTANT BEFORE SPAWNING ANY OTHER D 26   PROCESSES  */E 26I 26   PROCESSES [doing this before processing the args seems dumb. why?] */E 26      	init_ether();			/* modified by kiuchi Nov. 4 */E 29E 24D 35	/* assume first arg is sysout.  If it begins with '-',D 31           should use ~/lisp.virtualmem. (not yet implemented) **/E 31I 31           should use ~/lisp.virtualmem?  (not yet implemented) **/E 35I 35D 60	i=1;	if(argc > 1 && argv[1][0] != '-') {		strcpy(sysout_name, argv[1]);		i++;I 46D 47	} else if((envname = getenv("LDESRCESYSOUT")) != NULL)E 47I 47	} else if((envname = getenv("LDESRCESYSOUT")) != NULL) {E 47		strcpy(sysout_name, envname);E 46	} else if((envname = getenv("LDESOURCESYSOUT")) != NULL)		strcpy(sysout_name, envname);	else if(!makepathname("~/lisp.virtualmem", sysout_name)		 || access(sysout_name, R_OK)) {D 46			fprintf(stderr, "Coudn't find a sysout to run; \either setenv LDESOURCESYSOUT or do:\n");D 43			fprintf(stderr, "lisp sysout [-k access-key] [-E <ethernet-info>]\n" );E 43I 43			fprintf(stderr, "lde[ether] [sysout] [-k access-key] [-E <ethernet-info>]\n" );E 43			exit(1);E 46I 46		fprintf(stderr, "Coudn't find a sysout to run;\n");D 54		fprintf(stderr, "either setenv LDESOURCESYSOUT or do:\n");E 54I 54		fprintf(stderr, "either setenv LDESRCESYSOUT or do:\n");E 54		fprintf(stderr, "lde[ether] [sysout] [-k access-key] [-E <ethernet-info>]\n" );		exit(1);E 46		}E 60I 60    i=1;    if(argc > 1 && argv[1][0] != '-')      {	strcpy(sysout_name, argv[1]);	i++;      }     else if ((envname = getenv("LDESRCESYSOUT")) != NULL)      {	strcpy(sysout_name, envname);      }    else if ((envname = getenv("LDESOURCESYSOUT")) != NULL)      strcpy(sysout_name, envname);D 67    else if(  !makepathname("~/lisp.virtualmem", sysout_name)E 67I 67    else if( !makepathname("~/lisp.virtualmem", sysout_name)E 67	    || access(sysout_name, R_OK))      {	fprintf(stderr, "Coudn't find a sysout to run;\n");	fprintf(stderr, "either setenv LDESRCESYSOUT or do:\n");	fprintf(stderr, "lde[ether] [sysout] [-k access-key] [-E <ethernet-info>]\n" );I 62#ifdef XWINDOW	print_Xusage( argv[0] );#endif XWINDOWE 62	exit(1);      }E 60/* OK, sysout name is now in sysout_name, and i is moved past a supplied name */E 35E 31D 31        for ( i = 1; i < argc; i += 1 ) { /* increment by 1 in case of typo */            if (! strcmp(argv[i], "-t")) {	/**** timer interval	****/	       TIMER_INTERVAL = atoi(argv[i+1]);	       }E 31I 31D 35	for ( i = 1; i < argc; i += 1 ) { /* step by 1 in case of typo */E 35I 35D 46E 46D 60	for ( ; i < argc; i += 1 ) { /* step by 1 in case of typo */E 60I 60    for ( ; i < argc; i += 1 )      { /* step by 1 in case of typo */E 60	/* -t and -m are undocumented and somewhat dangerous... */E 35D 43	    if (! strcmp(argv[i], "-t")) {	/**** timer interval	****/D 35		TIMER_INTERVAL = atoi(argv[i+1]);E 35I 35			if(argc > ++i) TIMER_INTERVAL = atoi(argv[i]);			else fprintf(stderr, "Missing argument after -t\n");E 43I 43D 60	if (! strcmp(argv[i], "-t")) {	/**** timer interval	****/		if(argc > ++i) TIMER_INTERVAL = atoi(argv[i]);		else {			fprintf(stderr, "Missing argument after -t\n");			exit(1);			}E 43E 35		}E 60I 60	if (! strcmp(argv[i], "-t"))	  { /**** timer interval	****/	    if(argc > ++i) TIMER_INTERVAL = atoi(argv[i]);	    else	      {		fprintf(stderr, "Missing argument after -t\n");		exit(1);	      }	  }E 60D 35#ifdef UNPROTECTEDE 31            if (! strcmp(argv[i], "-m")) {	/**** sysout size	****/D 31	       sysout_size = atoi(argv[i+1]);	       }E 31I 31		sysout_size = atoi(argv[i+1]);E 35I 35D 43        if (! strcmp(argv[i], "-m")) {	/**** sysout size	****/			if(argc > ++i) sysout_size = atoi(argv[i]);			else fprintf(stderr, "Missing argument after -m\n");E 43I 43D 60	else if (! strcmp(argv[i], "-m")) {	/**** sysout size	****/		if(argc > ++i) sysout_size = atoi(argv[i]);		else {			fprintf(stderr, "Missing argument after -m\n");			exit(1);			}E 43E 35		}E 60I 60	else if (! strcmp(argv[i], "-m"))	  { /**** sysout size	****/	    if(argc > ++i) sysout_size = atoi(argv[i]);	    else	      {		fprintf(stderr, "Missing argument after -m\n");		exit(1);	      }	  }E 60D 35#endifE 31            if (! strcmp(argv[i], "-k")) {	/**** security key	****/D 26	       printf("copy protect not yet implemented: %s\n", argv[i+1]);E 26I 26D 31	       keystring = argv[i+1];D 29E 29	       printf("For now, key only checked if provided: %s\n", keystring);	       if ( keytester(keystring) ) {		  printf ( "Sorry, invalid or expired access key.\n" );		  exit();		  }E 31I 31		keystring = argv[i+1];E 35I 35I 36D 43        if (! strcmp(argv[i], "-NF")) {	/****  Don't fork (for dbxing)	****/			please_fork = 0;E 43I 43D 60	else if (! strcmp(argv[i], "-NF")) {	/****  Don't fork (for dbxing)	****/		please_fork = 0;E 43		}E 60I 60	else if (! strcmp(argv[i], "-NF"))	  { /****  Don't fork (for dbxing)	****/	    please_fork = 0;	  }E 60E 36D 43        if (! strcmp(argv[i], "-k")) {	/**** security key	****/			if(argc > ++i) keystring = argv[i];			else fprintf(stderr, "Missing argument after -k\n");E 43I 43D 60	else if ( ! strcmp(argv[i], "-INIT")) { /*** init sysout, no packaged */		for_makeinit = 1;E 43E 35E 31D 29E 29I 29		}I 43	else if (! strcmp(argv[i], "-k")) {	/**** security key	****/		if(argc > ++i) keystring = argv[i];		else {			fprintf(stderr, "Missing argument after -k\n");			exit(1);			}		}E 60I 60	else if ( ! strcmp(argv[i], "-INIT"))	  { /*** init sysout, no packaged */	    for_makeinit = 1;	  }	else if (! strcmp(argv[i], "-k"))	  { /**** security key	****/	    if(argc > ++i) keystring = argv[i];	    else	      {		fprintf(stderr, "Missing argument after -k\n");		exit(1);	      }	  }E 60E 43I 35I 71#ifndef AIX	/* Can only do this under SUNOs, for now */E 71E 35D 43	    if (! strcmp(argv[i], "-E")) {	/**** ethernet info	****/D 35		int b0, b1, b2, b3, b4, b5;		if(sscanf(argv[++i],"%d:%x:%x:%x:%x:%x:%x:%s", &ether_fd,D 33			&b0, &b1, &b2, &b3, &b4, &b5, &snit.snit_ifname) != 8) {E 33I 33			&b0, &b1, &b2, &b3, &b4, &b5, snit.snit_ifname) != 8) {E 33			printf("Bogus -E argument\n");			ether_fd = -1;		} else {			ether_host[0] = b0; ether_host[1] = b1;			ether_host[2] = b2; ether_host[3] = b3;			ether_host[4] = b4; ether_host[5] = b5;		}	E 29E 26	       }            }E 35I 35			int b0, b1, b2, b3, b4, b5;			if(argc > ++i && sscanf(argv[i],"%d:%x:%x:%x:%x:%x:%x:%s",&ether_fd,				&b0, &b1, &b2, &b3, &b4, &b5, snit.snit_ifname) == 8) {				ether_host[0] = b0; ether_host[1] = b1;				ether_host[2] = b2; ether_host[3] = b3;				ether_host[4] = b4; ether_host[5] = b5;			} else {				fprintf(stderr, "Missing or bogus -E argument\n");				ether_fd = -1;E 43I 43D 60	else if (! strcmp(argv[i], "-E")) {	/**** ethernet info	****/		int b0, b1, b2, b3, b4, b5;		if(argc > ++i && sscanf(argv[i],"%d:%x:%x:%x:%x:%x:%x:%s",&ether_fd,			&b0, &b1, &b2, &b3, &b4, &b5, snit.snit_ifname) == 8) {			ether_host[0] = b0; ether_host[1] = b1;			ether_host[2] = b2; ether_host[3] = b3;			ether_host[4] = b4; ether_host[5] = b5;		} else {			fprintf(stderr, "Missing or bogus -E argument\n");			ether_fd = -1;			exit(1);E 43D 46			}	E 46I 46			}E 46		}	}E 60I 60	else if (! strcmp(argv[i], "-E"))	  { /**** ethernet info	****/I 72#ifdef NOETHER#elseE 72	    int b0, b1, b2, b3, b4, b5;	    if(argc > ++i && sscanf(argv[i],"%d:%x:%x:%x:%x:%x:%x:%s",&ether_fd,			&b0, &b1, &b2, &b3, &b4, &b5, snit.snit_ifname) == 8)	      {		ether_host[0] = b0; ether_host[1] = b1;		ether_host[2] = b2; ether_host[3] = b3;		ether_host[4] = b4; ether_host[5] = b5;	      }	    else	      {		fprintf(stderr, "Missing or bogus -E argument\n");		ether_fd = -1;		exit(1);	      }I 72#endif NOETHERE 72	  }I 71#endif AIXE 71      }E 60E 35I 31D 58#ifdef UNPROTECTEDD 35	printf("Copy protection disabled.", keystring);E 35I 35	fprintf(stderr, "Copy protection disabled.", keystring);E 35D 32#elseifE 32I 32#elseE 58I 58E 58I 55D 56	strcpy ( keytyped, keystring ); /* keytester destroys keystring */E 55E 32	if ( keytester(keystring) ) {E 56I 56D 60	if ( keystring )		/* key given, so safe to copy */	    strcpy ( keytyped, keystring );	if ( keytester(keystring) ) { /* keytester destroys keystring */E 60I 60    if ( keystring )		/* key given, so safe to copy */      strcpy ( keytyped, keystring );    if ( keytester(keystring) ) { /* keytester destroys keystring */E 60E 56D 35	    printf ( "Sorry, invalid or expired access key.\n" );E 35I 35	    fprintf (stderr, "Sorry, invalid or expired access key.\n" );I 52D 53	    fprintf (stderr, "Key tried: $s\n", keystring );E 53I 53D 55	    fprintf (stderr, "Key tried: %s\n", keystring );E 55I 55	    fprintf (stderr, "Key tried: %s\n", keytyped );E 55E 53E 52E 35	    exit();	    }D 58#endifE 58I 58D 72E 72I 72D 73#ifdef NOETHER#elseE 73I 73#ifndef NOETHERE 73E 72E 58E 31I 29D 46   	init_ether();			/* modified by kiuchi Nov. 4 */E 46I 46	init_ether();			/* modified by kiuchi Nov. 4 */E 46E 29D 72E 72I 72#endif NOETHERI 73#ifdef FORKCOMM	/* Fork Unix was called in kickstarter; if we forked, look up the */	/* pipe handles to the subprocess and set them up.			    */    if(please_fork)      {	if(FindUnixPipes())	  fprintf(stderr,		  "Failed to find UNIXCOMM file handles; no processes\n");      }#elseE 73E 72I 21D 40	/* Get OS message to ~/lisp.log and print the message to prompt window */       mess_init();E 40E 21E 19	/* Fork Unix Interface subprocess before we create anything big */I 9D 24/* To debug with dbx, lisp needs to be running as the top process. So, dbx debugging can only work with the following turned off */I 15/* interrupts need to be blocked here so subprocess won't see them */E 24I 24	/* interrupts need to be blocked here so subprocess won't see them */I 29	/* This should actually live in the kickstarter... */E 29E 24D 43	int_block();E 43E 15D 43#ifndef NOFORKE 9D 36	fork_Unix();E 36I 36	if(please_fork) fork_Unix();E 36I 9#endifE 43I 43	if(please_fork){int_block(); fork_Unix();}I 73#endif FORKCOMME 73E 43E 9E 8D 58	/* load sysout to VM space */D 35	sysout_loader(argv[1], sysout_size);E 35I 35	sysout_loader(sysout_name, sysout_size);E 58I 58D 69	sysout_loader(sysout_name, sysout_size); /* load sysout to VM space */E 69I 69	/* Load sysout to VM space and returns real sysout_size(not 0) */	sysout_size= sysout_loader(sysout_name, sysout_size); E 69E 58E 35E 7D 58	/* built up map */	build_lisp_map();E 58I 58	build_lisp_map();		/* built up map */E 58D 58	/* initialize IFPAGE */D 18	init_ifpage();E 18I 18	init_ifpage(sysout_size);E 18	/* initialize IOPAGE */E 58I 58	init_ifpage(sysout_size);	/* init interface page */E 58	init_iopage();I 18D 58	/* initialize MISCSTATS */E 58	init_miscstats();I 69#ifdef NEW_STORAGE	init_storage();#endif NEW_STORAGEE 69E 18D 43	/* device initialize */D 10	init_ether();			/* modified by kiuchi Nov. 4 */E 10	/* init_display(); */		/* modified by osamu Sep. 3 */E 43	set_cursor();			/* modified by osamu Feb. 10 */I 40I 70        				/* file system directory enumeration stuff */        if (!init_finfo()) {		fprintf(stderr, "Cannot allocate internal data.\n");		exit(1);	}E 70D 43	/* Get OS message to ~/lisp.log and print the message to prompt window */        mess_init();E 40E 43I 43      /* Get OS message to ~/lisp.log and print the message to prompt window */D 46        if(!for_makeinit)  { E 46I 46        if(!for_makeinit)  {I 62#ifdef SUNDISPLAYE 62E 46	mess_init();I 62#endif SUNDISPLAYE 62E 43D 48	init_keyboard();E 48I 48D 57	init_keyboard(0); /* initial */E 57I 57	init_keyboard(0); /* can't turn on the keyboard yet or you will die			     in makeinit.  Pilotbitblt will turn it on ifD 61			     you used the proper switches when building LDE. */E 61I 61			     you used the proper switches when building LDE.				JDS -- 1/18/90 also BITBLTSUB does it now. */E 61E 57E 48I 43	}E 43I 10D 24	init_ether();			/* modified by kiuchi Nov. 4 */E 24E 10D 45E 45I 45D 66/* **** DELETE FOR NOW ????? *****E 45	rs232c_init();	tty_init();D 45E 45I 45*/E 66I 66E 66I 63#ifdef I386/* 80387 initialization */	   asm(".data");	   asm(".align 4");D 66	   asm("__temp:");D 64	   asm(".byte 0x7f");E 64I 64	   asm("	.globl __temp");E 66I 66	   asm("__FP_trunc:");	   asm("	.globl __FP_trunc");E 66D 65	   asm(".byte 0xff");	   asm(".byte 0xff");E 65I 65	   asm(".byte 0x3f");	   asm(".byte 0x0c");I 66	   asm("__FP_round:");	   asm("	.globl	__FP_round");	   asm(".byte 0x3f");	   asm(".byte 0x00");E 66E 65E 64	   asm(".text");D 66	   asm("fldcw __temp");	E 66I 66	   asm("fldcw __FP_round");	E 66#endif I386E 63E 45I 30D 46   	/* Set signal for "file access timeout */E 46I 46D 49	/* Set signal for "file access timeout */E 46	if( signal(SIGALRM, timeout_error) == BADSIG){		err_mess("signal", errno);D 35		printf("Time Out Service does not work!!\n");E 35I 35		fprintf(stderr, "Time Out Service does not work!!\n");E 35	}E 49D 46	E 46I 46E 46E 30I 20D 22#ifndef NO_C_HARDRET	smash_hardreturn(); /* call c hardreturn via UFN */#endifE 22E 20D 14	/* For now,N-tran is not available,so commented out this line **		init_native_hash();	****COMMENT OUT *************/E 14D 19	/* now starts the lisp */E 19I 19	/* now start up lisp */E 19	start_lisp();}I 58D 60/*  ================================================================  */E 60E 58I 43D 44jmp_buf ufn_restart_point;int ufn_restart_case;E 44E 43D 43start_lisp()E 43I 43D 44error_exit(n)int n;E 43{I 43	ufn_restart_case = n;	longjmp(ufn_restart_point);}E 43D 43 register int time;E 43E 44I 43D 60start_lisp(){D 46E 46E 43D 59 DLword *tmp; LispPTR func;E 59 DLword *freeptr,*next68k;E 60D 43 MState = &MachineState;E 43D 60 TopOfStack=0;D 2 CurrentFX=(struct frameex1 *)Addr68k_from_LADDR(STK_OFFSET | InterfacePage->currentfxp); /* Change for machinestate: PVar=(DLword *)(CurrentFX  + 1); */ MState->pvar = (DLword *)(CurrentFX  + 1);E 2I 2D 44 E 44I 44 Error_Exit = 0;E 60E 44D 60 MState->pvar=(DLword *)Addr68k_from_LADDR(STK_OFFSET | InterfacePage->currentfxp) + FRAMESIZE;E 60I 60/************************************************************************//*									*//*		  	   s t a r t _ l i s p				*//*									*//*	This is the function that actually starts up the lisp emulator.	*//*									*//*									*//************************************************************************/E 60E 2D 2freeptr = next68k =Addr68k_from_LADDR(STK_OFFSET | CurrentFX->nextblock);E 2I 2D 46freeptr = next68k = Addr68k_from_LADDR(STK_OFFSET | CURRENTFX->nextblock);E 46I 46D 60 freeptr = next68k = Addr68k_from_LADDR(STK_OFFSET | CURRENTFX->nextblock);E 60I 60start_lisp()  {    DLword *freeptr,*next68k;E 60E 46E 2D 43RTNI:	if (*next68k != STK_FSB_WORD)		error("initial: MP9316");E 43I 43D 46if (*next68k != STK_FSB_WORD) error("initial: MP9316");E 46I 46D 59 if (*next68k != STK_FSB_WORD) error("initial: MP9316");E 59I 59D 60 if (GETWORD(next68k) != STK_FSB_WORD) error("initial: MP9316");E 60I 60    TopOfStack=0;    Error_Exit = 0;E 60E 59E 46E 43D 46while(*freeptr==STK_FSB_WORD)  EndSTKP = freeptr = freeptr + *(freeptr+1);E 46I 46D 59 while(*freeptr==STK_FSB_WORD)   EndSTKP = freeptr = freeptr + *(freeptr+1);E 59I 59D 60 while(GETWORD(freeptr)==STK_FSB_WORD)   EndSTKP = freeptr = freeptr + GETWORD(freeptr+1);E 60I 60    MState->pvar = (DLword *) Addr68k_from_LADDR( STK_OFFSET						 | InterfacePage->currentfxp)		              + FRAMESIZE;E 60E 59E 46D 28  StkLimO = EndSTKP- 7 ;  if(next68k >= StkLimO) printf("INIT: Stackoverflow in BOOT seq \n");  CurrentStackPTR =next68k -2 /* -1 */ ;E 28I 28D 46  CurrentStackPTR =next68k -2;E 28I 2	E 2  FastRetCALL;E 46I 46D 60 CurrentStackPTR =next68k -2;E 60I 60    freeptr = next68k = Addr68k_from_LADDR(STK_OFFSET | CURRENTFX->nextblock);      if (GETWORD(next68k) != STK_FSB_WORD)      error("Starting Lisp: Next stack block isn't free!");E 60D 60 FastRetCALL;E 60I 60    while(GETWORD(freeptr)==STK_FSB_WORD)      EndSTKP = freeptr = freeptr + GETWORD(freeptr+1);E 60E 46D 58E 58D 2 LastStackAddr=(DLword *)Addr68k_from_LADDR(STK_OFFSET | 0xffff);E 2I 2D 43  LastStackAddr=(DLword *)Addr68k_from_LADDR(STK_OFFSET | 0xffff);E 43E 2D 2  init_evalform_frame() ;  /* Cache FX for evalform  */E 2I 2D 27  init_evalform_frame() ;   /* Cache FX for evalform  */E 27E 2D 43E 43D 14/*******************************************//**** for(;(*PC)!=0 && !DisplayInitialized;)  {	(*(OPCODE_entries + Get_BYTE(PC)))() ;   }   ****/D 2/*  for(;(Get_BYTE(PC))!=0;)E 2I 2/****  for(;(Get_BYTE(PC))!=0;)E 2	 {(*(OPCODE_entries + Get_BYTE(PC)))() ;} */I 2E 14I 11D 15/* JRB - The timer intitialization must be done right before entering the	bytecode dispatch loop for real */E 15I 15D 19/* JRB - The interrupt intitialization must be done right before entering the	bytecode dispatch loop; interrupts get unblocked here */E 19I 19D 60/* JRB - The interrupt intitialization must be done right before entering   the bytecode dispatch loop; interrupts get unblocked here */E 60I 60    CurrentStackPTR =next68k -2;E 60E 19E 15I 14E 14D 15	int_timer_init();E 15I 15D 60	int_init();I 43D 44	ufn_restart_case = -1;	setjmp(ufn_restart_point);/* currently not used. set up so that hardreturn can just error_exit(-3) */	if (ufn_restart_case == -3) {	MState->pvar = (DLword *) Addr68k_from_LADDR(STK_OFFSET | InterfacePage->currentfxp) + FRAMESIZE;	freeptr = next68k = Addr68k_from_LADDR(STK_OFFSET | CURRENTFX->nextblock);	if (*next68k != STK_FSB_WORD)		error("Initial stack state wrong - no space!");	while (*freeptr == STK_FSB_WORD)		EndSTKP = freeptr = freeptr + *(freeptr + 1);	CurrentStackPTR = next68k - 2;	TopOfStack = *(CurrentStackPTR);	FastRetCALL; /* sets IVar, PC */}E 43E 15E 11E 2E 44	dispatch();D 49}I 30/*****************************************************************timeout_error	Error handling routine for SIGALRM.D 37	When TIMEOUT spend TIMEOUT_TIME (30 sec), this rouitne is called.E 37I 37	When TIMEOUT spend TIMEOUT_TIME (10 sec), this rouitne is called.E 37*****************************************************************/I 37jmp_buf	jmpbuf;E 37timeout_error(){D 37	error("File access timed out.");E 37D 35	printf("File access timed out.\n");E 35I 35	fprintf(stderr, "File access timed out.\n");I 37	longjmp(jmpbuf, 1);E 49E 37E 35}E 60I 60    FastRetCALL;    /* JRB - The interrupt intitialization must be done right before */    /*       entering the bytecode dispatch loop; interrupts get     */    /*       unblocked here 					     */    int_init();    dispatch();  }I 67makepathname(src, dst)register char	*src;register char	*dst;				{register int len;register char	*base, *cp;register struct passwd *pwd;char	name[MAXPATHLEN];	base = src;	switch ( *base ) {	case '.':		if(getwd(dst) == 0){	/* set working directory */#ifdef FSERROR			*Lisp_errno = errno;#endif			return(0);		}		switch ( *(base+1) ){							case '.':			if(*(base+2) == '/'){	/* Now, base == "../xxxx" */				cp = rindex(dst, '/');				if(cp == 0){					return(0);				}				*cp = '\0';				strcat(dst, base+2);				return(1);								}else{									return(0);						}								case '/':			/* Now, base == "./xxx" */			strcat(dst, base+1);						return(1);								default:										return(0);						}	case '~':#ifdef FSERROR		ERRSETJMP(0);#else		SETJMP(0);#endif		if( *(base+1) == '/'){			/* path is "~/foo" */			TIMEOUT( pwd = getpwuid( getuid()) );			if(pwd == NULL){				#ifdef FSERROR				*Lisp_errno = errno;#endif				return(0);			}			sprintf(dst, "%s%s", pwd->pw_dir, base+1);			return(1);		}else{			/* path is "~foo/" */			if((cp=index(base+1, '/')) == 0){				return(0);			}else{				len = (int)cp - (int)base -1;				strncpy(name, base+1, len);				name[len] = '\0';				TIMEOUT( pwd = getpwnam(name) );				if(pwd == NULL){				#ifdef FSERROR					*Lisp_errno = errno;#endif					return(0);				}				sprintf(dst, "%s%s", pwd->pw_dir, cp);				return(1);				}		}	default:		strcpy(dst, src);							return(1);								}}E 67E 60E 30D 14/** Initializa func for N-hash-tbl */init_native_hash(){	int i;	i = 0;	while (i < Native_Hash_Size) Native_Hash[i++] = 0;}E 14E 1