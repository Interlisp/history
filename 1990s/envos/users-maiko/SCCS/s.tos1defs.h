h07877s 00012/00006/00121d D 2.15 92/11/25 20:22:15 sybalsky 26 25c Fixing extra text in endifs => comment.\nes 00000/00000/00127d D 2.14 92/04/21 16:37:33 sybalsky 25 24c shortening file names for DOSes 00009/00009/00118d D 2.13 90/08/30 10:33:44 sybalsky 24 23c AIX changeses 00014/00001/00113d D 2.12 90/06/04 14:47:51 sybalsky 23 22c reformat, copyrightes 00012/00012/00102d D 2.11 89/04/07 20:20:25 shih 22 21c bad sccsides 00000/00000/00114d D 2.10 89/03/30 13:00:07 sybalsky 21 20c Fixed word-pointer refs to use GETWORD.es 00035/00006/00079d D 2.9 89/03/24 13:25:03 sybalsky 20 19c added byte-swapped defnses 00000/00003/00085d D 2.8 88/10/18 10:00:41 krivacic 19 18c remove unused IVAR_REG & PVAR_REG macroses 00003/00003/00085d D 2.7 88/10/13 19:29:51 krivacic 18 17c ifdef cleanuupes 00004/00000/00084d D 2.6 88/10/05 17:03:01 krivacic 17 16c sun 3 / 4 mergees 00013/00005/00071d D 2.5 88/09/16 14:39:21 bane 16 15c Adjusted PC changeses 00002/00002/00074d D 2.4 88/07/29 15:09:28 krivacic 15 14c change native call displacementes 00010/00005/00066d D 2.3 88/07/21 15:55:48 krivacic 14 13c fix return to nativees 00021/00006/00050d D 2.2 88/07/19 16:44:23 krivacic 13 12c new native interface macroses 00000/00000/00056d D 2.1 88/05/17 09:19:28 hayata 12 11c Version up to 2.1es 00001/00000/00055d D 1.11 88/05/04 20:41:01 krivacic 11 10c GET_TOS_2es 00004/00000/00051d D 1.10 88/04/27 13:31:37 krivacic 10 9c define NATIVE_NEXTOP0es 00001/00003/00050d D 1.9 88/04/25 18:32:58 krivacic 9 8c remove LOCFX = BCE_CURRENTFXes 00001/00004/00052d D 1.8 88/04/08 17:21:36 krivacic 8 7c native pc interfacees 00017/00000/00039d D 1.7 88/03/28 11:57:20 krivacic 7 6c new native interfacees 00000/00014/00039d D 1.6 88/03/23 10:13:11 krivacic 6 5c removed IVARINREG stuffes 00003/00001/00050d D 1.5 88/03/15 18:23:42 krivacic 5 4c fix bug in PUSH macro, added GET_TOS_1_HI & GET_TOS_1_LOes 00001/00001/00050d D 1.4 88/03/13 14:17:58 hayata 4 3c Change SCCS key ides 00000/00000/00051d D 1.3 88/03/13 13:27:47 hayata 3 2c Add SCCS key id (%Z%)es 00002/00002/00049d D 1.2 88/03/09 15:44:05 krivacic 2 1c es 00051/00000/00000d D 1.1 88/03/03 11:22:10 krivacic 1 0c date and time created 88/03/03 11:22:10 by krivaciceuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 2I 2D 4/* This is G-file tos1defs.h Version 1.1 (3/3/88). copyright Xerox & Fuji Xerox  */E 4I 4D 16/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 16I 16D 22/* This is G-file @(#) tos1defs.h Version 2.4 (7/29/88). copyright Xerox & Fuji Xerox  */E 22I 22D 23/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 23I 23D 26/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 26I 26/* %Z% %M% Version %I% (%G%). copyright Venue   */E 26I 26E 26/************************************************************************//*									*/D 26/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 26I 26/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 26/*									*/D 26/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 26I 26/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 26/*									*//************************************************************************/E 23E 22E 16E 4E 2D 20/* tos1defs.h definitionsE 20D 26E 26D 20	tos assumptions:		TOPOFSTACK	cached top of stack value.		CSTKPTR		points to where TOPOFSTACK should be stored.*/E 20I 20/************************************************************************//*									*//*		T O P - O F - S T A C K   D E F I N I T I O N S		*//*									*//*	TOPOFSTACK	cached top of stack value.			*//*	CSTKPTR		points to where TOPOFSTACK should be stored.	*//*									*//************************************************************************/E 20I 20#ifndef BYTESWAP	/********************************************************/	/*   Normal byte-order definitions, for e.g., 68020s	*/	/********************************************************/E 20/* These are the TOS manipulation Macros */D 24#define HARD_PUSH(x)	*(CSTKPTR++) = xE 24I 24#define HARD_PUSH(x)	*(CSTKPTRL++) = xE 24D 5#define PUSH(x)		HARD_PUSH(TOPOFSTACK); TOPOFSTACK = x;E 5I 5#define PUSH(x)		{HARD_PUSH(TOPOFSTACK); TOPOFSTACK = x;}E 5D 24#define POP		TOPOFSTACK = *(--CSTKPTR)E 24I 24#define POP		TOPOFSTACK = *(--CSTKPTRL)E 24#define GET_TOS_1	*(CSTKPTR - 1)I 11#define GET_TOS_2	*(CSTKPTR - 2)E 11D 2#define GET_POPPED	*(CSTKPTR + 1)E 2I 2#define GET_POPPED	*CSTKPTRE 2D 24#define POP_TOS_1	*(--CSTKPTR)E 24I 24#define POP_TOS_1	*(--CSTKPTRL)E 24D 22#define TOPOFSTACK 	tscacheE 22I 22#define TOPOFSTACK	tscacheE 22D 24#define FIXTOS1		CSTKPTR++E 24I 24#define FIXTOS1		CSTKPTRL++E 24I 5#define GET_TOS_1_HI	*((DLword *)(CSTKPTR - 1))#define GET_TOS_1_LO	*((DLword *)(CSTKPTR - 1)+1)E 5I 13D 19#define IVAR_REG	((LispPTR *) pccache)#define PVAR_REG	((LispPTR *) table)E 19E 13D 20/* OPCODE interface routines */ E 20I 20#elseE 20I 20	/********************************************************/	/*	Byte-swapped definitions, for e.g., 80386s	*/	/********************************************************//* These are the TOS manipulation Macros */D 24#define HARD_PUSH(x)	*(CSTKPTR++) = xE 24I 24#define HARD_PUSH(x)	*(CSTKPTRL++) = xE 24#define PUSH(x)		{HARD_PUSH(TOPOFSTACK); TOPOFSTACK = x;}D 24#define POP		TOPOFSTACK = *(--CSTKPTR)E 24I 24#define POP		TOPOFSTACK = *(--CSTKPTRL)E 24#define GET_TOS_1	*(CSTKPTR - 1)#define GET_TOS_2	*(CSTKPTR - 2)#define GET_POPPED	*CSTKPTRD 24#define POP_TOS_1	*(--CSTKPTR)E 24I 24#define POP_TOS_1	*(--CSTKPTRL)E 24D 22#define TOPOFSTACK 	tscacheE 22I 22#define TOPOFSTACK	tscacheE 22D 24#define FIXTOS1		CSTKPTR++E 24I 24#define FIXTOS1		CSTKPTRL++E 24#define GET_TOS_1_HI	GETWORD((DLword *)(CSTKPTR - 1))#define GET_TOS_1_LO	GETWORD((DLword *)(CSTKPTR - 1)+1)D 26#endif BYTESWAPE 26I 26#endif /* BYTESWAP */E 26D 22/* OPCODE interface routines */ E 22I 22/* OPCODE interface routines */E 22E 20#define StackPtrSave	{CurrentStackPTR = (DLword *) (CSTKPTR-1);}D 24#define StackPtrRestore	{CSTKPTR = ((LispPTR *) CurrentStackPTR)+1;}E 24I 24#define StackPtrRestore	{CSTKPTRL = ((LispPTR *) CurrentStackPTR)+1;}E 24D 6#ifdef	IVARINREGE 6D 6#define EXT	{ PC = pccache;					\		  TopOfStack = TOPOFSTACK;			\		  StackPtrSave;					\		  /* IVar = (DLword *) IVAR; */}#define RET	{ pccache = PC;					\		  StackPtrRestore;				\		  TOPOFSTACK = TopOfStack;			\		  /* IVAR = (LispPTR *) IVar;*/  }#elseE 6D 16#define EXT	{ PC=pccache;					\E 16I 16#define EXT	{ PC=pccache-1;					\E 16		  TopOfStack=TOPOFSTACK;			\		  StackPtrSave; }D 16#define RET	{ pccache=PC;					\E 16I 16#define RET	{ pccache=PC+1;					\E 16		  StackPtrRestore;				\D 22		  TOPOFSTACK = TopOfStack; } E 22I 22		  TOPOFSTACK = TopOfStack; }E 22D 6#endifE 6#define NRET	{ RET; nextop0; }I 7D 13#define RET_FROM_NATIVE(x)						\E 13I 13#define RET_FROM_NATIVE							\E 13{									\D 13	CSTKPTR = (LispPTR *) CurrentStackPTR;				\E 13	POP;								\I 16	PCMACL += 1;							\E 16	table = optable;						\D 13	Save_D5_shift_amount = 15;					\	SaveD6 = x;							\D 9	{register struct frameex2 *LOCFX = BCE_CURRENTFX;		\D 8	 PCMAC = (InstPtr) 						\		((unsigned int)LOCFX->pc + (unsigned int)		\		 (FuncObj = (struct fnhead *)				\	 Addr68k_from_LADDR(0x0ffffff & swapx(LOCFX->fnheader))));	\E 8I 8	 PCMAC = (InstPtr) PC;						\E 8	}								\E 9I 9	PCMAC = (InstPtr) PC;						\E 13E 9}I 17D 18#ifdef NOASM#define NATIVE_NEXTOP0 nextop0#elseE 18I 18#ifdef NATIVETRANE 18E 17I 10D 22#define NATIVE_NEXTOP0	{ 						\E 22I 22#define NATIVE_NEXTOP0	{						\E 22D 13		if (BCE_CURRENTFX->native)  { goto ret_native; }	\E 13I 13		if (BCE_CURRENTFX->native)  { RET_TO_NATIVE; }		\E 13		nextop0;						\		}I 18#else#define NATIVE_NEXTOP0 nextop0E 18I 17#endifE 17I 13D 22#define CALL_NATIVE(defcell, num_args) 					\E 22I 22#define CALL_NATIVE(defcell, num_args)					\E 22{									\D 22	setivar_pvar_jmp(CSTKPTR + num_args, PVAR, 			\E 22I 22	setivar_pvar_jmp(CSTKPTR + num_args, PVAR,			\E 22D 15		((int *)(GET_NATIVE_ADDR(defcell)))[num_args+(5+3)]);	\E 15I 15D 16		((int *)(GET_NATIVE_ADDR(defcell)))[num_args+(5+2)]);	\E 16I 16		((int *)(GET_NATIVE_ADDR(defcell)))[num_args+(6+2)]);	\E 16E 15}I 16D 22#define CALL_NATIVE2(defcell, num_args) 				\E 22I 22#define CALL_NATIVE2(defcell, num_args)					\E 22{									\D 22	setivar_pvar_jmp(CSTKPTR + num_args, PVAR, 			\E 22I 22	setivar_pvar_jmp(CSTKPTR + num_args, PVAR,			\E 22		((int *)(GET_NATIVE_ADDR(defcell)))			\		[(num_args <= -6) ? ((6+2)-6) : (num_args+(6+2))]);	\}E 16I 16E 16#define RET_TO_NATIVE	{						\D 14	register int args = (int) PCMAC;				\	HARD_PUSH(TOPOFSTACK);						\	setivar_pvar_jmp(IVAR, PVAR,					\		((int *)(GET_NATIVE_ADDR(FuncObj)))			\		[(args - (unsigned int) FuncObj)+(5+3)]);		\E 14I 14	register int native_addr;					\	register struct fnhead *LocFuncObj = FuncObj;			\D 22	if (native_addr = 						\E 22I 22	if (native_addr =						\E 22		((int *)(GET_NATIVE_ADDR(LocFuncObj)))			\D 15		[((int) PCMAC - (unsigned int) LocFuncObj)+(5+3)]) 	\E 15I 15D 16		[((int) PCMAC - (unsigned int) LocFuncObj)+(5+2)]) 	\E 16I 16D 22		[((int) PCMAC - (unsigned int) LocFuncObj)+(6+2)]) 	\E 22I 22		[((int) PCMAC - (unsigned int) LocFuncObj)+(6+2)])	\E 22E 16E 15		{							\		HARD_PUSH(TOPOFSTACK);					\		setivar_pvar_jmp(IVAR, PVAR, native_addr);		\		};							\	nextop0;							\E 14	}E 13E 10E 7E 1