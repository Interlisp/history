h49570s 00112/00024/00154d D 2.15 93/02/08 15:03:54 sybalsky 18 17c Big VM (and new CDR coding) changes for 3.0 \nes 00019/00020/00159d D 2.14 92/04/23 10:58:00 sybalsky 17 16c sfixing SCCS header \nes 00000/00000/00179d D 2.13 92/04/21 16:27:55 sybalsky 16 15c shortening file names for DOSes 00015/00005/00164d D 2.12 90/06/27 16:34:02 mitani 15 14c safety GCLOOKUP and GCLOOKUPVes 00050/00015/00119d D 2.11 90/06/15 17:00:06 mitani 14 13c DecAllocCnt, DelLink, GCLOOKUPes 00012/00002/00122d D 2.10 90/06/04 10:37:54 sybalsky 13 12c reformat, copyrightes 00070/00021/00054d D 2.9 89/03/24 13:26:03 sybalsky 12 11c Added byte-swapped defnses 00001/00001/00074d D 2.8 88/08/01 16:52:34 masinter 11 10c fix GcLOOKUPV typeoes 00021/00010/00054d D 2.7 88/08/01 10:07:50 masinter 10 9c cleanup unused macros, invoke new faster htfind, add FRPLPTRes 00002/00004/00062d D 2.6 88/07/05 12:43:31 masinter 9 8c make overflow table use 32-bit count (part of gchtfind.c cleanup)es 00003/00001/00063d D 2.5 88/07/01 18:27:48 charnley 8 7c added GCLOOKUPV macro, modified GCLOOKUP macro.es 00002/00001/00062d D 2.4 88/06/02 13:45:43 masinter 7 6c add a (currently unused) INVOKE_GC macroes 00002/00002/00061d D 2.3 88/05/31 16:10:36 masinter 6 5c Macro name should be IncAllocCnt for backward compatibilityes 00007/00007/00056d D 2.2 88/05/31 13:00:23 masinter 5 4c Add new macros for manipulating, testing reclaim counteres 00000/00000/00063d D 2.1 88/05/17 09:17:49 hayata 4 3c Version up to 2.1es 00004/00000/00059d D 1.3 88/05/09 19:55:23 shih 3 2c added GCLOOKUP macroes 00001/00001/00058d D 1.2 88/03/13 13:20:34 hayata 2 1c Add SCCS key id (%Z%)es 00059/00000/00000d D 1.1 88/02/23 18:36:31 hayata 1 0c date and time created 88/02/23 18:36:31 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 2I 2D 13/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 13I 13D 14/* This is G-file %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 14I 14D 18/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */E 18I 18/* %Z% %M% Version %I% (%G%). copyright venue   */E 18E 14E 13E 2D 9E 9D 17/*D 13 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.E 13 *D 7 *	Auther	:	Takeshi ShimizuE 7I 7 *	Author	:	Takeshi ShimizuE 7 *			Hiroshi Hayata	 */E 17I 13I 17E 17D 14E 14/************************************************************************//*									*/D 17/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 17I 17/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 17/*									*/D 17/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 17I 17/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 17/*									*//************************************************************************/E 13/**********************************************************************//* 		File Name :  	gc.h		Define  for garbage collector	 D 5 				Date :	March 27 '87 				Edited by :	Takeshi Shimizu				Date :	July-23-1987				Modified by : Tomoru TeruuchiE 5*//**********************************************************************/#define	ADDREF	0	/* for gclookup routine. */#define	DELREF	1	/* for gclookup routine. */#define	STKREF	2	/* for gclookup routine. */#define UNSTKREF	3	/* for htfind function. (T.T.) */I 18#ifdef BIGVM  /* 32-bit HTmain, HTcoll, etc. entries */#define GETGC(x) *((LispPTR *) (x))#define GCENTRY LispPTR#define GCPTR#define MAX_GCCOUNT	0x7FFF 	/* = 32767 */#else  /* Old, 16-bit entries */#define GETGC GETWORD#define GCENTRY DLword#define GCPTR(x) WORDPTR(x)E 18#define MAX_GCCOUNT	0x3F 	/* = 63 */I 18#endif /* BIGVM */E 18D 5#define	ATOMGCSCAN	0371	/* to call LISP \GC.HANDLEOVERFLOW by funcall() */E 5I 5D 6/* RECLAIMCOUNT(n) decrements reclaim countdown by N and signals interruptE 6I 6D 18/* IncAllocCnt(n) decrements reclaim countdown by N and signals interruptE 6   if GC should happen soon */E 18E 5I 14D 18/* IncAllocCnt is called only when *Reclaim_cnt_word != NIL */E 18I 18   /* IncAllocCnt(n) decrements reclaim countdown by N      and signals interrupt if GC should happen soon */   /* IncAllocCnt is called only when *Reclaim_cnt_word != NIL */E 18E 14I 10#define IncAllocCnt(n) {\D 14	if ((*Reclaim_cnt_word != NIL)\	    && ((*Reclaim_cnt_word -= n) <= S_POSITIVE)) {\E 14I 14	if ((*Reclaim_cnt_word -= n) <= S_POSITIVE) {\E 14		/* time for GC */\		Irq_Stk_Check = Irq_Stk_End = 0;\		*Reclaim_cnt_word = S_POSITIVE;\	};\}E 10I 3D 5/* FS: simplify gclookup call */E 5I 5I 14D 18/* DecAllocCnt only called when *Reclaim_cnt_word != NIL */E 18I 18   /* DecAllocCnt only called when *Reclaim_cnt_word != NIL */E 18#define DecAllocCnt(n) { *Reclaim_cnt_word += n; }#define FreeLink(link) {\D 18	GETWORD(link) = 0;\	GETWORD(link+1) = GETWORD(HTcoll);\	GETWORD(HTcoll) = (link - HTcoll);\E 18I 18	GETGC(link) = 0;\	GETGC(link+1) = GETGC(HTcoll);\	GETGC(HTcoll) = (link - HTcoll);\E 18}D 18#define GetLinkptr(entry)	(entry & 0x0fffe)E 18D 18#define DelLink(link, prev, entry) {					     \	if (prev != (DLword *)0) {					     \		GETWORD((DLword *)prev + 1) = GETWORD((DLword *)link + 1);   \	} else {							     \		GETWORD((DLword *)entry) = GETWORD((DLword *)link + 1) | 1;  \	}								     \	FreeLink((DLword *)link);					     \	link = (DLword *)HTcoll + GetLinkptr(GETWORD((DLword *)entry));	     \	if (GETWORD((DLword *)link + 1) == 0) {			     	     \		GETWORD((DLword *)entry) = GETWORD((DLword *)link);	     \		FreeLink((DLword *)link);				     \	}								     \E 18I 18  /* Given the contents of an HTMAIN or HTCOLL entry,	 get the link pointer (i.e., turn off the low bit) */#define GetLinkptr(entry)	(entry & 0x0fffffffe)#define DelLink(link, prev, entry) {					\  if (prev != (GCENTRY *)0)						\    {									\      GETGC((GCENTRY *)prev + 1) = GETGC((GCENTRY *)link + 1);		\    }									\  else									\    {									\      GETGC((GCENTRY *)entry) = GETGC((GCENTRY *)link + 1) | 1;		\    }									\  FreeLink((GCENTRY *)link);						\  link = (GCENTRY *)(HTcoll + GetLinkptr(GETGC((GCENTRY *)entry)));	\  if (GETGC((GCENTRY *)link + 1) == 0)					\    {			     	     					\      GETGC((GCENTRY *)entry) = GETGC((GCENTRY *)link);	     		\      FreeLink((GCENTRY *)link);					\    }									\E 18}D 18#define RefCntP(ptr) (!(GetTypeEntry((ptr)) & TT_NOREF) &&		     \E 18I 18#define RefCntP(ptr) (!(GetTypeEntry((ptr)) & TT_NOREF) &&		\E 18		      (*GcDisabled_word != ATOM_T))D 15#define GCLOOKUP(ptr, case) { if (RefCntP(ptr)) htfind(ptr, case); }E 15I 15#define GCLOOKUP(ptr, case) {						     \	if (RefCntP(ptr)) {						     \		if (*Reclaim_cnt_word != NIL)				     \		  htfind(ptr, case);					     \		else							     \		  rec_htfind(ptr, case);				     \	}							             \}E 15#define GCLOOKUPV(ptr, case, val) {					     \D 15	if (RefCntP(ptr))						     \	  val = htfind(ptr, case);					     \	else								     \	  val = NIL;							     \E 15I 15	if (RefCntP(ptr)) {						     \		if (*Reclaim_cnt_word != NIL)				     \		  val = htfind(ptr, case);				     \		else							     \		  val = rec_htfind(ptr, case);				     \	} else val = NIL;						     \E 15}#define REC_GCLOOKUP(ptr, case) { if (RefCntP(ptr)) rec_htfind(ptr, case); }#define REC_GCLOOKUPV(ptr, case, val) {					     \	if (RefCntP(ptr)) 						     \	  val = rec_htfind(ptr, case);					     \	else								     \	  val = NIL;							     \}E 14I 10#define FRPLPTR(old , new) { \D 14		htfind(new, ADDREF); \		htfind(old, DELREF); \E 14I 14		GCLOOKUP(new, ADDREF); \		GCLOOKUP(old, DELREF); \E 14		(old) = (new) ; }E 10D 6#define RECLAIMCOUNT(n) {if ((*Reclaim_cnt_word != NIL) && ((*Reclaim_cnt_word -= n) <= S_POSITIVE))  { /* time for GC */ Irq_Stk_Check = Irq_Stk_End = 0; *Reclaim_cnt_word = S_POSITIVE; };}E 6I 6D 10#define IncAllocCnt(n) {if ((*Reclaim_cnt_word != NIL) && ((*Reclaim_cnt_word -= n) <= S_POSITIVE))  { /* time for GC */ Irq_Stk_Check = Irq_Stk_End = 0; *Reclaim_cnt_word = S_POSITIVE; };}E 10I 10D 14/*#define FRPLPTR(old, new) { \		if( old != new) {\		if (new > 0x120000) htfind(new, ADDREF);\		if (old > 0x120000) htfind(old, DELREF);\		old = new ; }}*/E 14E 10E 6D 10#define RECLAIMPENDING  (*Reclaim_cnt_word == S_POSITIVE)E 10I 10D 14#define GCLOOKUP(bitset,code,addr) htfind(addr,code)D 11#define GcLOOKUPV(bitset,code,addr) htfind(addr,code)E 11I 11#define GCLOOKUPV(bitset,code,addr) htfind(addr,code)E 14I 12#ifndef BYTESWAP	/********************************************************/	/*   Normal byte-order definitions, for e.g., 68020s	*/	/********************************************************/I 18#ifdef BIGVM  struct	 hashentry  { /* GC hastable entry */    unsigned short count	:15;    unsigned short stackref	:1;    unsigned short segnum	:15;    unsigned short collision	:1;  };E 18E 12E 11E 10E 5I 18struct  htlinkptr  {	/* overlay access method */    LispPTR	contents;  };struct	htcoll  { /* GC collision table entry */    LispPTR	free_ptr ;    LispPTR	next_free ;  };struct	gc_ovfl  {    LispPTR	  ovfl_ptr ;    unsigned int  ovfl_cnt ;  };struct  htoverflow   {	/* July-23-1987 by TT */    unsigned	pcase	:4;    unsigned	ptr	:28;  };#elseE 18I 7D 10#define INVOKE_GC  {*Reclaim_cnt_word == S_POSITIVE | 3000; contextsw(GCFXP , 0 , 0);}E 7D 8#define GCLOOKUP(bitset,code,addr) htfind(addr,code)E 8I 8#define GCLOOKUP(bitset,code,addr) if (addr > 0x120000) htfind(addr,code)#define GCLOOKUPV(bitset,code,addr) htfind(addr,code)E 8E 10E 3D 12struct	 hashentry{		unsigned	count		:6;		unsigned	stackref	:1;D 9		unsigned	segnum	:8;E 9I 9		unsigned	segnum		:8;E 9		unsigned	collision	:1;};E 12I 12struct	 hashentryD 17  {    unsigned	count		:6;    unsigned	stackref	:1;    unsigned	segnum		:8;    unsigned	collision	:1;E 17I 17  { /* GC hastable entry */    unsigned short count	:6;    unsigned short stackref	:1;    unsigned short segnum	:8;    unsigned short collision	:1;E 17  };E 12D 12struct  htlinkptr{			/* overlay access method */		DLword		contents;};E 12I 12struct  htlinkptr  {	/* overlay access method */    DLword	contents;  };E 12D 12struct	htcoll {		DLword		free_ptr ;		DLword		next_free ;};E 12I 12struct	htcollD 17  {E 17I 17  { /* GC collision table entry */E 17    DLword	free_ptr ;    DLword	next_free ;  };E 12D 12struct	gc_ovfl {		LispPTR		ovfl_ptr ;D 9		DLword		ovfl_cnthi ;		DLword		ovfl_cntlo ;E 9I 9		unsigned int	ovfl_cnt ;E 9};E 12I 12struct	gc_ovfl  {    LispPTR	  ovfl_ptr ;    unsigned int  ovfl_cnt ;  };E 12D 12struct  htoverflow {	/* July-23-1987 by TT */		unsigned	pcase	:8;		unsigned	ptr	:24;};E 12I 12struct  htoverflow   {	/* July-23-1987 by TT */    unsigned	pcase	:8;    unsigned	ptr	:24;  };I 18#endif /* BIGVM */E 18#else	/********************************************************/	/*	Byte-swapped definitions, for e.g., 80386s	*/	/********************************************************/I 18#ifdef BIGVMstruct	 hashentry  { /* GC hashtable entry */    unsigned short collision	:1;    unsigned short segnum	:15;    unsigned short stackref	:1;    unsigned short count	:15;  };E 18I 18struct  htlinkptr  {	/* overlay access method */    LispPTR	contents;  };struct	htcoll  { /* GC collision table entry */    LispPTR	next_free ;    LispPTR	free_ptr ;  };struct	gc_ovfl  {    LispPTR	  ovfl_ptr ;    unsigned int  ovfl_cnt ;  };struct  htoverflow   {	/* July-23-1987 by TT */    unsigned	ptr	:28;    unsigned	pcase	:4;  };#elseE 18struct	 hashentryD 17  {    unsigned	collision	:1;    unsigned	segnum		:8;    unsigned	stackref	:1;    unsigned	count		:6;E 17I 17  { /* GC hashtable entry */    unsigned short collision	:1;    unsigned short segnum	:8;    unsigned short stackref	:1;    unsigned short count	:6;E 17  };struct  htlinkptr  {	/* overlay access method */    DLword	contents;  };struct	htcollD 17  {E 17I 17  { /* GC collision table entry */E 17    DLword	next_free ;    DLword	free_ptr ;  };struct	gc_ovfl  {    LispPTR	  ovfl_ptr ;    unsigned int  ovfl_cnt ;  };struct  htoverflow   {	/* July-23-1987 by TT */    unsigned	ptr	:24;    unsigned	pcase	:8;  };I 18#endif /* BIGVM */E 18D 18#endif BYTESWAPE 18I 18#endif /*  BYTESWAP */E 18E 12D 10extern	DLword	GcLov;extern	DLword	GcZero;E 10E 1