h57916s 00002/00002/00310d D 2.18 90/06/13 15:13:48 sybalsky 23 22c Fix more cases of += breaking registerses 00012/00008/00300d D 2.17 90/06/06 13:39:09 sybalsky 22 21c remove += of register variables, fix to make it work with new S_CHECKes 00000/00000/00308d D 2.16 90/04/27 13:06:09 sybalsky 21 20c Work around  compiler bug wrt register vars:  var += const compiles wrong.es 00000/00000/00308d D 2.15 90/04/20 01:38:22 sybalsky 20 19c AIX:  shortening file names, bulk change.es 00058/00054/00250d D 2.14 90/04/19 22:09:17 sybalsky 19 18c AIX:  fix pointer arithmetic.es 00018/00007/00286d D 2.13 90/03/02 21:44:30 sybalsky 18 17c 386 checkses 00000/00001/00293d D 2.12 89/04/07 13:41:47 shih 17 16c sccs id should be first linees 00010/00010/00284d D 2.11 89/03/30 13:15:44 sybalsky 16 15c more word-pointers found.es 00002/00001/00292d D 2.10 89/03/23 12:55:01 sybalsky 15 14c Fixed word-pointer refs to use GETWORD, for 386es 00025/00024/00268d D 2.9 88/11/30 18:51:23 shih 14 13c restore sccs stamp, minor cleanupes 00011/00004/00281d D 2.8 88/11/22 13:17:19 shimizu 13 12c AR10951:slowreturn can notice stackoverflowes 00003/00003/00282d D 2.7 88/11/08 13:11:16 bane 12 11c Commented out blatantly bogus break; statementes 00010/00005/00275d D 2.6 88/09/27 16:52:09 krivacic 11 10c fix for sun 4es 00000/00001/00280d D 2.5 88/08/17 18:39:18 shimizu 10 9c remove a spurious errores 00006/00000/00275d D 2.4 88/06/23 10:49:36 shimizu 9 8c Make as ifdef FLIPCURSORes 00001/00029/00274d D 2.3 88/05/31 16:48:38 masinter 8 7c remove obsolete code dealing with "incall" bit in returnes 00001/00277/00302d D 2.2 88/05/24 18:46:07 shimizu 7 6c delete obsolatecode do_hardreturn.do_hardreturn1,smashlinkes 00000/00000/00579d D 2.1 88/05/17 09:25:07 hayata 6 5c Version up to 2.1es 00010/00000/00569d D 1.5 88/05/13 13:26:11 shimizu 5 4c #define STACKCHECK optes 00009/00008/00560d D 1.4 88/05/12 13:37:43 shimizu 4 3c Add register decles 00022/00044/00546d D 1.3 88/05/11 12:07:21 shimizu 3 2c refinement for return.es 00257/00001/00333d D 1.2 88/05/11 10:50:53 shimizu 2 1c Direct Call I/F for slowreturn-casees 00334/00000/00000d D 1.1 88/05/09 20:06:41 shimizu 1 0c date and time created 88/05/09 20:06:41 by shimizueuUtTI 1D 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 12I 12D 14/* This is G-file @(#) hardreturn.c Version 2.6 (9/27/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) hardreturn.c	2.6 9/27/88";E 14E 12I 3D 17E 17I 14D 18/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(envos & Fuji Xerox)";E 18I 18D 23/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 23I 23/* @(#) hardreturn.c Version 2.17 (6/6/90). copyright venue & Fuji Xerox  */static char *id = "@(#) hardreturn.c	2.17 6/6/90	(venue & Fuji Xerox)";E 23E 18I 18/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 18E 14/********************************************************************//*D 14	File Name : 	hardreturn.c		Edited by 	Takeshi Shimizu	DATE:		10-MAY-88E 14I 14	File Name :	hardreturn.cE 14I 14	Edited by	Takeshi Shimizu	Date:		10-MAY-88E 14I 13	RET VAL: If success: 0		 else (NO SPACE in STACK)  1 -> should cause HARDRESETE 13D 8	do_hardreturn,do_hardreturn1,smashlink are obsolate cade.	They will be removed.E 8*//********************************************************************/E 3#include "lispemul.h"#include "lispmap.h"I 15#include "lisptypes.h"E 15#include "address68k.h"#include "address.h"#include "lispglobal.h"#include "emulglobal.h"#include "cell.h"#include "stack.h"D 3        I 2#define FastRetCALL {							\	/* Get IVar from Retunee's IVAR offset slot(BF) */ 		\	IVar = Addr68k_from_LADDR(STK_OFFSET | *((DLword *)CURRENTFX -1)); \	/* Get FuncObj from Retunee's FNHEAD slot in FX */ 		\	FuncObj = (struct fnhead *)Addr68k_from_LADDR((CURRENTFX->hi2fnheader <<16) | CURRENTFX->lofnheader);						\	/* Get PC from Retunee's pc slot in FX */ 			\	PC = (ByteCode *)FuncObj + CURRENTFX->pc ; }E 3I 3#include "return.h"E 3D 3#define Midpunt(fxnum) 							\	{register DLword midpunt; 					\	midpunt = LOLOC(LADDR_from_68k(CURRENTFX));			\	PVar=(DLword *)							\		Addr68k_from_LADDR(					\			STK_OFFSET | 					\			(*(((DLword *)InterfacePage) +fxnum)))		\		+ FRAMESIZE; 						\	*(((DLword *)InterfacePage) +fxnum) = midpunt ;}E 2#define SET_FASTP_NIL(fx68k) {  \	if(FASTP(fx68k)){ \		((FX*)fx68k)->blink=StkOffset_from_68K(DUMMYBF(fx68k));\		((FX*)fx68k)->clink=((FX*)fx68k)->alink;\		SLOWP(fx68k)=T; }}I 2#define BEFORE_CONTEXTSW	{ CurrentStackPTR += 2; \ 				CURRENTFX->nextblock=StkOffset_from_68K(CurrentStackPTR); \				 *(CurrentStackPTR)=STK_FSB_WORD; \				 *(CurrentStackPTR+1)= (((int)EndSTKP-(int)(CurrentStackPTR))>>1); }#define AFTER_CONTEXTSW		{ DLword *ptr68k,*freeptr; \		ptr68k = (DLword*)Addr68k_from_StkOffset(CURRENTFX->nextblock);\		 if(*ptr68k != STK_FSB_WORD) error("pre_moveframe: MP9316");\		 CHECK_FX(CURRENTFX);\ 		freeptr=ptr68k;\  		while(*freeptr == STK_FSB_WORD)  \			EndSTKP=freeptr=freeptr+  *(freeptr+1);\		StkLimO = EndSTKP - STKLIMOFFSET ;\		 S_CHECK(ptr68k < StkLimO);\		 S_CHECK(CURRENTFX->incall== NIL);\ 		S_CHECK(CURRENTFX->nopush== NIL);\		CurrentStackPTR = ptr68k- 2 ;\		CHECK_FX(CURRENTFX);\		S_CHECK( EndSTKP>= CurrentStackPTR) ; }E 2E 3I 2D 13#define MAKE_FXCOPY(fx68k)	{ BEFORE_CONTEXTSW;\	fx68k=(FX*)make_FXcopy(fx68k);\	AFTER_CONTEXTSW;\E 13I 13#define MAKE_FXCOPY(fx68k)	{ BEFORE_CONTEXTSW;	\	if((fx68k=(FX*)make_FXcopy(fx68k)) == 0){	\D 14	    return(1); /* Whole space exausted */}	\E 14I 14	    return(1); /* Whole space exhausted */}	\E 14	AFTER_CONTEXTSW;				\E 13	CHECK_FX(fx68k);}E 2D 7  void incusecount68k(),decusecount68k(),smashlink();E 7I 7  void incusecount68k(),decusecount68k();E 7I 3/********************************************************************//*D 14	Func Name : 	slowreturn()		Edited by 	Takeshi ShimizuE 14I 14	Func Name :	slowreturn()	Edited by	Takeshi ShimizuE 14	DATE:		10-MAY-88I 13	RET VAL : If 0 success		  If 1  NO STACK SPACE->uraid-> HARDRESETE 13*//********************************************************************/E 3I 2slowreturn(){D 4 DLword *next68k; DLword *freeptr; Bframe *currentBF; FX *returnFX;E 4I 4 register DLword *next68k; register DLword *freeptr; register Bframe *currentBF; register FX *returnFX;E 4 extern FX *make_FXcopy();D 22 S_CHECK(SLOWP(CURRENTFX));E 22I 22 S_CHECK(SLOWP(CURRENTFX), "CURRENTFX not SLOWP");E 22D 14/* Get retunee's FX from CURRENTFX->alink , It's SLOWP case */E 14I 14/* Get returnee's FX from CURRENTFX->alink , It's SLOWP case */E 14returnFX= (FX*)Addr68k_from_StkOffset(CURRENTFX->alink-11);if((CURRENTFX->alink & 0xFFFE) != CURRENTFX->clink) { /* ALINK != CLINK */I 5#ifdef STACKCHECKE 5	printf("A!=C\n");I 5#endifE 5	/* return to CLINK fx */	SETALINK(CURRENTFX,CURRENTFX->clink);	decusecount68k(returnFX);	returnFX = (FX*)Addr68k_from_StkOffset(CURRENTFX->clink - FRAMESIZE); }if(returnFX->usecount !=0)D 14 { /* COPY retunee's FX */E 14I 14 { /* COPY returnee's FX */E 14I 5#ifdef STACKCHECKE 5	printf("returnFX->usecount !=0\n");I 5#endifE 5	MAKE_FXCOPY(returnFX);/* smashes returnFX */D 14 } E 14I 14 }E 14retry :  /* this is retry entry after MAKE_FXCOPY etc */ next68k = Addr68k_from_StkOffset(returnFX->nextblock) ; currentBF = (Bframe *)Addr68k_from_StkOffset(CURRENTFX->blink);D 15if(*next68k == STK_FSB_WORD)E 15I 15if(GETWORD(next68k) == STK_FSB_WORD)E 15D 14 { E 14I 14 {E 14another:freeptr = ((DLword *)CURRENTFX)-2 ;D 18	if( ((Bframe *)freeptr)->residual)E 18I 18	if( BFRAMEPTR(freeptr)->residual)E 18D 14	 {		E 14I 14	 {E 14D 18		if(currentBF->usecnt == 0)E 18I 18		if(BFRAMEPTR(currentBF)->usecnt == 0)E 18		 {			/* make FREEBLOCK for real BF */D 16			*IVar = STK_FSB_WORD;			*(IVar +1) =(((int)currentBF - (int)IVar)>>1 )+2 ;E 16I 16			GETWORD(IVar) = STK_FSB_WORD;			GETWORD(IVar +1) =(((int)currentBF - (int)IVar)>>1 )+2 ;E 16		 }		elseD 18			currentBF->usecnt --;E 18I 18			BFRAMEPTR(currentBF)->usecnt --;E 18	 }	 else		freeptr = IVar ; /* reset free ptr: not residual case */	/* free FX + BF(dummy or real) */D 16	*freeptr = STK_FSB_WORD;	*(freeptr +1)= ((int)EndSTKP - (int)freeptr)>>1 ;E 16I 16	GETWORD(freeptr) = STK_FSB_WORD;	GETWORD(freeptr +1)= ((int)EndSTKP - (int)freeptr)>>1 ;E 16D 22	S_CHECK(EndSTKP >= freeptr);	S_CHECK(FSB_size(freeptr) >= MINEXTRASTACKWORDS);E 22I 22	S_CHECK(EndSTKP >= freeptr, "EndSTKP < freeptr!");	S_CHECK(FSB_size(freeptr) >= MINEXTRASTACKWORDS,		"free block < min size, after deciding it fits.");E 22	PVar=((DLword *)returnFX) + FRAMESIZE ;	/*  Now right CURRENTFX(PVar) is set */D 16	if (*next68k != STK_FSB_WORD)E 16I 16	if (GETWORD(next68k) != STK_FSB_WORD)E 16		error("OP_return: MP9316");	freeptr = next68k ;D 16	while(*freeptr==STK_FSB_WORD)	 EndSTKP = freeptr = freeptr + *(freeptr+1);E 16I 16	while(GETWORD(freeptr)==STK_FSB_WORD)	 EndSTKP = freeptr = freeptr + GETWORD(freeptr+1);E 16D 8	StkLimO = EndSTKP- STKLIMOFFSET ;	if(next68k >= StkLimO)		error("STKOVER in slowret\n");E 8	if(CURRENTFX->incall)	 {  /* this frame is  Interrupted */I 5D 8#ifdef STACKCHECKE 5		printf("SLOW & INCALL ?\n");I 5#endifE 5		CURRENTFX->incall=NIL;		CurrentStackPTR = next68k -2 ;		TopOfStack = *((LispPTR *)CurrentStackPTR) ;		CurrentStackPTR-=2;		FuncObj = (struct fnhead *)			Addr68k_from_LADDR(				(CURRENTFX->hi2fnheader << 16) | 				CURRENTFX->lofnheader);		PC = (ByteCode *)(((DLword *)FuncObj) + CURRENTFX->pc );		OP_apply();  /* CALL Func again */#ifdef LISPTRACE		printf("TRACE: return from ");		print_atomname(fnobj->framename);		printf(" :<= ");print(TopOfStack);printf("\n");#endif		return;E 8I 8		error("Stack error: INCALL bit found in returnee frame");E 8	 }D 14	else 	 E 14I 14	elseE 14	 {		if (CURRENTFX->nopush)		 {			CURRENTFX->nopush =NIL;			CurrentStackPTR = next68k-2 ;			TopOfStack = *((LispPTR *)CurrentStackPTR) ;			CurrentStackPTR-=2;		 }		elseD 14		 	CurrentStackPTR = next68k-2  ; E 14I 14			CurrentStackPTR = next68k-2  ;E 14D 22		S_CHECK(EndSTKP >= freeptr);E 22I 22		S_CHECK(EndSTKP >= freeptr, "EndSTKP < freeptr");E 22		FastRetCALL;#ifdef LISPTRACE		printf("TRACE: return from ");		print(fnobj->framename);		printf(" :<= ");		print(TopOfStack);printf("\n");#endifD 13		return;E 13I 13		return(0); /* normal return */E 13	 }}/* FSB end */else if (next68k != IVar)	{I 5#ifdef STACKCHECKE 5	printf("next68k != IVar and not FSB\n");I 5#endifE 5	MAKE_FXCOPY(returnFX);/* smashes returnFX */	goto retry;	}D 18else if (currentBF->usecnt != 0)E 18I 18else if (BFRAMEPTR(currentBF)->usecnt != 0)E 18	{I 5#ifdef STACKCHECKE 5	printf("currentBF->usecnt != 0");I 5#endifE 5	MAKE_FXCOPY(returnFX);/* smashes returnFX */	goto retry;	}else {D 18	if((next68k == IVar)|| (currentBF->usecnt ==0))E 18I 18	if((next68k == IVar)|| (BFRAMEPTR(currentBF)->usecnt ==0))E 18		goto another;	else error("Shouldn't");     }} /* slowreturn end */I 19E 19FX *make_FXcopy(fx68k)D 4FX *fx68k;E 4I 4D 19register FX *fx68k;E 4{D 4 int size;E 4I 4 register int size;E 4 int nametbl_on_stk=NIL;D 4 DLword *new68k; Bframe *retbf68k;E 4I 4 register DLword *new68k; register Bframe *retbf68k;E 4 extern DLword *freestackblock();E 19I 19  register FX *fx68k;  {    register int size;    int nametbl_on_stk=NIL;    register DLword *new68k;    register Bframe *retbf68k;    extern DLword *freestackblock();E 19I 4I 9#ifdef FLIPCURSORE 9E 4D 19 flip_cursorbar(5);E 19I 19    flip_cursorbar(5);E 19I 9#endifE 9D 19 CHECK_FX(fx68k); size = FX_size(fx68k) + DLWORDSPER_CELL;E 19I 19    CHECK_FX(fx68k);    size = FX_size(fx68k) + DLWORDSPER_CELL;E 19D 19 if(fx68k->validnametable && (fx68k->hi2nametable==STK_HI)) {   /* frame contains a name table, so we care that the alignmentE 19I 19    if(fx68k->validnametable && (fx68k->hi2nametable==STK_HI))      {	/* frame contains a name table, so we care that the alignmentE 19	 of the new block be same as old */#ifdef STACKCHECKD 19        { DLword n;                n=fx68k->lonametable;                if((n <= StkOffset_from_68K(fx68k))E 19I 19	{ DLword n;	  n=fx68k->lonametable;	  if((n <= StkOffset_from_68K(fx68k))E 19                  && (n >= fx68k->nextblock))D 19                        error("hardreturn:nametable check");        }E 19I 19	    error("hardreturn:nametable check");	}E 19#endifD 14 	nametbl_on_stk = T;E 14I 14	nametbl_on_stk = T;E 14	/* Find a free stack block */D 14 	new68k=freestackblock(size,CURRENTFX,E 14I 14	new68k=freestackblock(size,CURRENTFX,E 14           (StkOffset_from_68K(fx68k)-DLWORDSPER_CELL)% DLWORDSPER_QUAD);D 19  } /*if end */ else	new68k=freestackblock(size,CURRENTFX,-1); /* No align */E 19I 19      } /*if end */    else new68k=freestackblock(size,CURRENTFX,-1); /* No align */E 19D 14 E 14I 14E 14D 19if(new68k == 0) return(0); /* No more space for STACK */E 19I 19    if(new68k == 0) return(0); /* No more space for STACK */E 19D 19/* blt(dest,source,size) */  blt(new68k,(((DLword*)fx68k) - DLWORDSPER_CELL),size);E 19I 19    /* blt(dest,source,size) */    blt(new68k,(((DLword*)fx68k) - DLWORDSPER_CELL),size);E 19D 19((Bframe*)new68k)->residual =T;((DLword*)new68k)+= DLWORDSPER_CELL; /* now NEW points to the FX */((FX*)new68k)->nextblock=(StkOffset_from_68K(new68k) + size)-DLWORDSPER_CELL;retbf68k=(Bframe*)Addr68k_from_StkOffset(GETBLINK(fx68k));/* Set true BFptr,not the residual */SETBLINK(new68k,GETBLINK(fx68k));((FX*)new68k)->usecount=0;CHECK_BF(retbf68k);E 19I 19    ((Bframe*)new68k)->residual =T;D 22    new68k += DLWORDSPER_CELL; /* now NEW points to the FX */E 22I 22    new68k = new68k + DLWORDSPER_CELL; /* now NEW points to the FX */E 22    ((FX*)new68k)->nextblock=(StkOffset_from_68K(new68k) + size)-DLWORDSPER_CELL;    retbf68k=(Bframe*)Addr68k_from_StkOffset(GETBLINK(fx68k));    /* Set true BFptr,not the residual */    SETBLINK(new68k,GETBLINK(fx68k));    ((FX*)new68k)->usecount=0;    CHECK_BF(retbf68k);E 19D 19if(nametbl_on_stk)  ((FX*)new68k)->lonametable += (((int)new68k - (int)fx68k)>>1);E 19I 19    if(nametbl_on_stk)      ((FX*)new68k)->lonametable += (((int)new68k - (int)fx68k)>>1);E 19D 14/* increment use count of basic frame of returnee because E 14I 14D 19/* increment use count of basic frame of returnee becauseE 14 we made another FX which points to it */ retbf68k->usecnt ++; SET_FASTP_NIL(fx68k);D 14/* increment use count of CLINK of returnee E 14I 14/* increment use count of CLINK of returneeE 14  because we made a copy of returnee */ incusecount68k(Addr68k_from_StkOffset(GETCLINK(fx68k)));E 19I 19    /* increment use count of basic frame of returnee because    we made another FX which points to it */    retbf68k->usecnt ++;    SET_FASTP_NIL(fx68k);    /* increment use count of CLINK of returnee       because we made a copy of returnee */    incusecount68k(Addr68k_from_StkOffset(GETCLINK(fx68k)));E 19D 19 if(GETCLINK(fx68k) != GETALINK(fx68k)){E 19I 19    if(GETCLINK(fx68k) != GETALINK(fx68k))      {E 19D 10	error("slowret:case 1\n");E 10	incusecount68k(Addr68k_from_StkOffset(GETALINK(fx68k)));D 19 }E 19I 19      }E 19D 19 decusecount68k(fx68k);/* if usecon==0  -> FSB */ SETACLINK(CURRENTFX,StkOffset_from_68K(new68k)); CHECK_FX(new68k); CHECK_FX(CURRENTFX);E 19I 19    decusecount68k(fx68k);/* if usecon==0  -> FSB */    SETACLINK(CURRENTFX,StkOffset_from_68K(new68k));    CHECK_FX(new68k);    CHECK_FX(CURRENTFX);E 19#ifdef STACKCHECKD 19 stack_check(0);E 19I 19    stack_check(0);E 19#endifI 9#ifdef FLIPCURSORE 9D 19 flip_cursorbar(5);E 19I 19    flip_cursorbar(5);E 19I 9#endifE 9D 19 return((FX*)new68k);} /* make_FXcopy end */E 19I 19    return((FX*)new68k);  } /* make_FXcopy end */E 19E 2D 7/********************************************************************//*	Func Name : do_hardreturnE 7I 19E 19D 7	Edited by Takeshi Shimizu*//********************************************************************/void do_hardreturn(hrframe68k)FX *hrframe68k;{  DLword *ptr68k,*freeptr; void do_hardreturn1();/* Setup this frame properly */ CurrentStackPTR += 2;  CURRENTFX->nextblock=StkOffset_from_68K(CurrentStackPTR); /* FSB set */ *(CurrentStackPTR)=STK_FSB_WORD; *(CurrentStackPTR+1)= (((int)EndSTKP-(int)(CurrentStackPTR))>>1); do_hardreturn1(hrframe68k); ptr68k = (DLword*)Addr68k_from_StkOffset(CURRENTFX->nextblock); if(*ptr68k != STK_FSB_WORD) error("pre_moveframe: MP9316"); CHECK_FX(CURRENTFX); freeptr=ptr68k;/* Merging FSB area */  while(*freeptr == STK_FSB_WORD)  	EndSTKP=freeptr=freeptr+  *(freeptr+1);/* Set current Stack Limit */StkLimO = EndSTKP - STKLIMOFFSET ; S_CHECK(ptr68k < StkLimO); S_CHECK(CURRENTFX->incall== NIL); S_CHECK(CURRENTFX->nopush== NIL);	CurrentStackPTR = ptr68k- 2 ;		CHECK_FX(CURRENTFX);D 2		S_CHECK( EndSTKP>= CurrentStackPTR) E 2I 2		S_CHECK( EndSTKP>= CurrentStackPTR) ;E 2		return;}/* end hardreturn *//********************************************************************//*	Func Name : do_hardreturn	Edited by Takeshi Shimizu*//********************************************************************/void do_hardreturn1(hrframe68k)FX *hrframe68k;{  LispPTR atom_index;  struct fnhead *funcobj68k;  int clink,ax;  FX *retuner68k,*retunee68k,*caller68k;  DLword *ax68k,*new68k;  int nametbl_on_stk =NIL;  int size;  FX *alink68k,*clink68k;  Bframe *retbf68k;  DLword *freestackblock(); atom_index = make_atom("\\CONTEXTSWITCH",0,14,0); funcobj68k=(struct fnhead*)Addr68k_from_LADDR(LLSH(hrframe68k->hi2fnheader,16) | hrframe68k->lofnheader); if (funcobj68k->framename ==atom_index) {	printf("HR from CONTEXTSW frame?\n");	clink=GETCLINK(hrframe68k);	hrframe68k= (FX*)Addr68k_from_StkOffset(clink); } clink=GETCLINK(hrframe68k); retuner68k=(FX*)Addr68k_from_StkOffset(clink); /**DEBUG**/  funcobj68k=(struct fnhead*)Addr68k_from_LADDR(LLSH(hrframe68k->hi2fnheader,16) | hrframe68k->lofnheader); if (funcobj68k->framename !=make_atom("\\HARDRETURN",0,11,0))	error("hardreturn: NOT HARDRETURN FX"); clink=GETCLINK(retuner68k); retunee68k=(FX*)Addr68k_from_StkOffset(clink);/* checkes */ CHECK_FX(retuner68k); CHECK_FX(retunee68k); S_CHECK(SLOWP(retuner68k));#ifdef STACKCHECK putchar('h'); if(StkOffset_from_68K(retunee68k) != GETALINK(retuner68k))   goto startHR; else if (retunee68k->usecount !=0)  goto startHR; else if (FSBP(ax68k=Addr68k_from_StkOffset(retunee68k->nextblock)))	  {		if(FSB_size(ax68k) <= MINEXTRASTACKWORDS) goto startHR;		else goto CheckFail;	  }goto startHR;/*******/	 CheckFail:   error("Check fail");startHR:#endif/**** Now start hardreturn routine here ***/ ax=GETALINK(retuner68k); if((DLword*)retunee68k != (ax68k=(DLword*)Addr68k_from_StkOffset(ax)))  {	SETALINK(retuner68k,StkOffset_from_68K(retunee68k));	decusecount68k(ax68k);  } if(retunee68k->usecount != 0)	goto DoMoveFrame; else   {	ax=retunee68k->nextblock;	ax68k=(DLword*)Addr68k_from_StkOffset(ax);	/* retunee is following FSB, Merging FSB */	if(FSBP(ax68k))	{		for(new68k=ax68k + FSB_size(ax68k);FSBP(new68k);			new68k+=FSB_size(new68k) )		 { FSB_size(ax68k) += FSB_size(new68k); }		if(FSB_size(ax68k) <= MINEXTRASTACKWORDS)			goto DoMoveFrame;		else			goto DoSmashLink;	} /*if(FSBP end */	else	{		ax=GETBLINK(retuner68k);		ax68k=(DLword*)Addr68k_from_StkOffset(ax);		if(retunee68k->nextblock==((Bframe*)ax68k)->ivar)		{/* [retunee][retuner-BF][retuner] */		  if(((Bframe*)ax68k)->usecnt !=0)			goto DoMoveFrame;		  else			goto DoSmashLink;		}		else /* Other cases */			goto DoMoveFrame;			}  }DoMoveFrame:  flip_cursorbar(5); S_CHECK(hrframe68k==CURRENTFX);  /* size =  BF+FX+PVAR */  size=FX_size(retunee68k) + DLWORDSPER_CELL; if(retunee68k->validnametable && (retunee68k->hi2nametable==STK_HI)) {   /* frame contains a name table, so we care that the alignment	 of the new block be same as old */#ifdef STACKCHECK        { DLword n;                n=retunee68k->lonametable;                if((n <= StkOffset_from_68K(retunee68k))                  && (n >= retunee68k->nextblock))                        error("hardreturn:nametable check");        }#endif 	nametbl_on_stk = T;	/* Find a free stack block */ 	new68k=freestackblock(size,retuner68k,           (StkOffset_from_68K(retunee68k)-DLWORDSPER_CELL)% DLWORDSPER_QUAD);  } /*if end */ else	new68k=freestackblock(size,retuner68k,-1); /* No align *//* blt(dest,source,size) *//* Copy retuneeFX+DummyBF to new space */  blt(new68k,(((DLword*)retunee68k) - DLWORDSPER_CELL),size);((Bframe*)new68k)->residual =T;((DLword*)new68k)+= DLWORDSPER_CELL; /* now NEW points to the FX */((FX*)new68k)->nextblock=(StkOffset_from_68K(new68k) + size)-DLWORDSPER_CELL;retbf68k=(Bframe*)Addr68k_from_StkOffset(GETBLINK(retunee68k));/* Set true BFptr,not the residual */SETBLINK(new68k,GETBLINK(retunee68k));((FX*)new68k)->usecount=0;CHECK_BF(retbf68k);if(nametbl_on_stk)  ((FX*)new68k)->lonametable += (((int)new68k - (int)retunee68k)>>1);/* increment use count of basic frame of returnee because  we made another FX which points to it */ retbf68k->usecnt ++; SET_FASTP_NIL(retunee68k); ax= GETCLINK(retunee68k);/* increment use count of CLINK of returnee   because we made a copy of returnee */ incusecount68k(Addr68k_from_StkOffset(ax)); if(ax != GETALINK(retunee68k))	incusecount68k(Addr68k_from_StkOffset(GETALINK(retunee68k))); decusecount68k(retunee68k); SETACLINK(retuner68k,StkOffset_from_68K(new68k)); CHECK_FX(new68k); CHECK_FX(retuner68k); retunee68k=(FX*)new68k; flip_cursorbar(5);DoSmashLink: smashlink(hrframe68k,retunee68k);}/* do_hardreturn1 *//* I assume caller must be FASTP in MAIKO */void smashlink(caller68k,link68k)FX *caller68k;FX *link68k;{FX *oldlink68k;Bframe *blink68k;DLword oldlink,blink;/* needless?  if(caller68k==0)	caller68k=PVAR-FRAMESIZE; oldaink=GETALINK(caller68k); oldclink=GETCLINK(caller68k); oldalink68k=(FX*) Addr68k_from_StkOffset(oldalink); oldclink68k= (FX*)Addr68k_from_StkOffset(oldclink);*/ S_CHECK(FASTP(caller68k)); oldlink=GETCLINK(caller68k); oldlink68k=(FX*) Addr68k_from_StkOffset(oldlink); SETALINK(caller68k,StkOffset_from_68K(link68k)); incusecount68k(link68k); SETCLINK(caller68k,StkOffset_from_68K(link68k)); decusecount68k(oldlink68k);  blink=GETBLINK(caller68k); blink68k=(Bframe*)Addr68k_from_StkOffset(blink); if(	(link68k->usecount==0) &&	(blink68k == (Bframe*)DUMMYBF(caller68k)) &&	(blink68k->ivar == link68k->nextblock) &&	(blink68k->usecnt==0) &&	(link68k->nopush ==NIL) &&	(link68k->incall == NIL))	SLOWP(caller68k)=NIL;	return;} /* smashlisk end */E 7#define MAXSAFEUSECOUNT 200void incusecount68k(fx68k)FX *fx68k;{ StackWord *scanptr68k; if(FX_INVALIDP(fx68k)) return;CHECK_FX(fx68k);if((++(fx68k->usecount)) > MAXSAFEUSECOUNT)	error("MP9324:Stack frame use count maximum exceeded");scanptr68k=(StackWord*)Addr68k_from_StkOffset(fx68k->nextblock);D 16switch(scanptr68k->flags)E 16I 16switch(STKWORD(scanptr68k)->flags)E 16	{D 11		case STK_NOTFLG:	while(scanptr68k->flags !=STK_BF)							scanptr68k+=DLWORDSPER_CELL;							break;E 11I 11		case STK_NOTFLG:D 16			while(scanptr68k->flags !=STK_BF)E 16I 16			while(STKWORD(scanptr68k)->flags !=STK_BF)E 16D 19				((DLword *) scanptr68k) += DLWORDSPER_CELL;E 19I 19D 22				scanptr68k += DLWORDSPER_CELL;E 22I 22			  scanptr68k =  (StackWord *)					  (((DLword *)scanptr68k)						 + DLWORDSPER_CELL);E 22E 19			break;E 11		case STK_BF:		break;I 11E 11		default	:		return;D 11						break;E 11I 11D 12					break;E 12I 12				     /* break; */E 12E 11	} /* switch end *//* DEBUG */D 14S_CHECK((((Bframe*)scanptr68k)->residual==T) || E 14I 14S_CHECK((((Bframe*)scanptr68k)->residual==T) ||E 14D 22	( ((Bframe*)scanptr68k)->ivar== fx68k->nextblock) );E 22I 22	( ((Bframe*)scanptr68k)->ivar== fx68k->nextblock) ,	"BF not residual, and IVER /= nextblock of prior frame");E 22D 11scanptr68k+=DLWORDSPER_CELL;E 11I 11D 19/* **** NOTE THIS IS TYPE CASE BECAUSE StackWord IS A 16 BIT STRUCTURE **** */((DLword *) scanptr68k) +=  DLWORDSPER_CELL;E 19I 19D 22scanptr68k +=  DLWORDSPER_CELL;E 22I 22scanptr68k =  (StackWord *) (((DLword *)scanptr68k) + DLWORDSPER_CELL);E 22E 19E 11D 16if(scanptr68k->flags == STK_FX)E 16I 16if(STKWORD(scanptr68k)->flags == STK_FX)E 16{	CHECK_FX(scanptr68k);	SET_FASTP_NIL(scanptr68k);D 14}	E 14I 14}E 14} /* incusecount68k end */D 7smash_hardreturn(){int index;DefCell *defptr;struct fnhead *fnptr;char *start; index= make_atom("\\HARDRETURN",0,11 ,0); defptr=(DefCell*)GetDEFCELL68k(index); fnptr=(struct fnhead *)Addr68k_from_LADDR(defptr->defpointer); start=((char*)fnptr) + fnptr->startpc; start[0]=0175;/*SUBRCALL  NIL*/ start[1]=0201; start[2]=0; start[3]=020; /*RETURN */ start[4]=0; printf("Now hardreturn calls C-code \n");}E 7E 1