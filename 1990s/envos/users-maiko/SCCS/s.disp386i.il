h59137s 00522/00180/01268d D 1.15 90/05/09 15:05:01 sybalsky 15 14c Define FN4 thru FN9 sped-up assembler versions.es 00252/00272/01196d D 1.14 90/05/03 12:56:41 sybalsky 14 13c es 00026/00009/01442d D 1.13 90/04/25 12:28:31 sybalsky 13 12c es 00896/00000/00555d D 1.12 90/04/19 22:50:28 sybalsky 12 11c work on FN opcodeses 00003/00003/00552d D 1.11 90/04/17 17:05:23 sybalsky 11 10c fix get_DLword opcodes, remove xorl ebx,ebx does in .bytes (kills emulator)es 00019/00012/00536d D 1.10 90/04/16 11:00:41 sybalsky 10 9c 386i speed changeses 00328/00017/00220d D 1.9 90/04/02 17:16:56 sybalsky 9 8c 386i arith speedupses 00009/00003/00228d D 1.8 90/03/22 16:34:06 sybalsky 8 7c add fast opcode fetches for 386ies 00024/00004/00207d D 1.7 90/03/22 14:37:24 sybalsky 7 6c pwdes 00006/00006/00205d D 1.6 90/03/22 11:43:24 sybalsky 6 5c make one jmp a jle, so it's conditional.es 00160/00001/00051d D 1.5 90/03/22 10:49:33 sybalsky 5 4c added bit_reverse_region, Get_BYTEPCMACxfn, Get_DLwordPCMACxfnes 00011/00011/00041d D 1.4 90/03/19 18:09:05 sybalsky 4 3c make word_swap_page work right!es 00011/00000/00041d D 1.3 90/03/15 15:14:00 sybalsky 3 2c more speedups (word_swap_page in, but can't do labels, so it's commented out)es 00036/00002/00005d D 1.2 90/03/13 18:56:25 sybalsky 2 1c Added more byte-swapping speed-up code.es 00007/00000/00000d D 1.1 90/03/12 15:55:05 sybalsky 1 0c date and time created 90/03/12 15:55:05 by sybalskyeuUf e 0tTI 1D 15/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 15I 15/* @(#) disp386i.il Version 1.14 (5/3/90). copyright Venue & Fuji Xerox  */E 15D 2/ swap the words in a long-word.E 2I 2////////////////////////////////////////////////////////////////////////////									////			d i s p 3 8 6 i . i l				////									////	INLINE-code definitions specific to the Sun 386i		////									//I 5//	Conventions (empirically discovered):				////									////		Caller pushes args on stack				////			0(%esp) = arg 1					////			4(%esp) = arg 2					////			etc.						////									////		Leave the result in %eax				////									////		YOU CAN'T USE LOCAL LABELS				////									//I 6//		jmp over code makes the code dead for -O???		//E 6//									////									////									//D 6//									//E 6E 5//////////////////////////////////////////////////////////////////////////E 2I 2/************************************************************************//*									*//*	Copyright 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.		*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************// swap the words in a long-word.E 2.inline swapx,1D 2	popl	%eaxE 2I 2	movl	0(%esp),%eaxE 2	rol	$16,%eax.endI 2/ swap the words in a long-word.inline word_swap_longword,1	movl	0(%esp),%eax	rol	$16,%eax.end/swap the bytes in a 16-bit word.inline byte_swap_word,1	movl	0(%esp),%eax	rolw	$8,%ax.endI 3D 4/.inline word_swap_page,2/	movl	4(%esp),%ecx	/ word count into the loop counter/	movl	0(%esp),%edx	/ address of the block to swap/?1:	movl	0(%edx),%eax/	rolw	$8,%ax/	roll	$16,%eax/	rolw	$8,%ax/	movl	%eax,0(%edx)/	add	$4,%edx/	loop	?1/.endE 4I 4D 5.inline XXXword_swap_page,8E 5I 5.inline word_swap_page,8E 5	movl	4(%esp),%ecx	/ word count into the loop counter	movl	0(%esp),%edx	/ address of the block to swap	movl	0(%edx),%eax	rolw	$8,%ax	roll	$16,%eax	rolw	$8,%ax	movl	%eax,0(%edx)	add	$4,%edx	loop	.-20I 5.end.inline bit_reverse_region,16/args: (top width height rasterwidth)D 7	E 7I 7	.nooptE 7	pushl	%edi	pushl	%esi	pushl	%ebx	movl	12(%esp),%edx	/top	movl	%edx,%eax	andl	$-2,%edx	movl	%edx,12(%esp)	andl	$1,%eax	shll	$4,%eax	addl	16(%esp),%eax	/width	movl	20(%esp),%edx	/height/		24(%esp)	/rasterwidth, in words	leal	31(%eax),%eax	sarl	$5,%eax	leal	(%eax,%eax),%eax	movl	%eax,16(%esp)	/ word wid now in width.	cld			/ so we move up thru memory	leal	reversedbits,%ebx / for xlateb	movl	12(%esp),%edi	/ starting init of word ptr	sub	$0,%edxD 6	jmp	.+61		/ .L60/..4:E 6I 6	jle	.+63		/ ..4:E 6	movl	%edi,%esi	/so both edi & esi are at start of line to swap	movl	16(%esp),%ecx	/ byte count to ecx	leal	(%ecx,%ecx),%ecxD 6/..3:E 6I 6/ ..3:E 6	lodsb	xlat	stosb	loop	.-3		/ ..3	movl	16(%esp),%ecx	incl	%ecx	sarl	$1,%ecxD 7	movl	12(%esp),%edi/	andl	$-2,%edi	movl	%edi,%esiE 7I 7	movl	12(%esp),%esi	/ must be into esi, then edi, to/	andl	$-2,%edi	/ defeat the peephole optimizer.	movl	%esi,%ediE 7D 6/..5:E 6I 6/ ..5:E 6	lodsl	rolw	$8,%ax	roll	$16,%eax	rolw	$8,%ax	stosl	loop	.-13		/ ..5	movl	12(%esp),%edi	/ word = word + rasterwidth	addl	24(%esp),%edi	addl	24(%esp),%edi	movl	%edi,12(%esp)	decl	%edxD 6/.L60:	/ at this point, starting word addr is in %ediE 6I 6/ .L60:	/ at this point, starting word addr is in %ediE 6	jg	.-59		/ ..4	popl	%ebx	popl	%esi	popl	%ediI 7	.optimE 7.end/////////////////////////////////	Dispatch loop speedup functions for the 386i////	Register assumptions:////		pccache	  %edi//		TOS	  %ebx//		stk ptr	  %esi/////////////////////////////////	///////////////////	//  Get_BYTE_PCMAC1 -- fetch one byte at PCMAC+1 //	//  (= pccache)	///////////////////.inline Get_BYTE_PCMAC0fn,0	leal	-1(%edi),%eax	xorl	$3,%eax	movzbl	(%eax),%eax.end.inline Get_BYTE_PCMAC1fn,0	movl	%edi,%eax	xorl	$3,%eax	movzbl	(%eax),%eax.end.inline Get_BYTE_PCMAC2fn,0	leal	1(%edi),%eax	xorl	$3,%eax	movzbl	(%eax),%eax.end.inline Get_BYTE_PCMAC3fn,0	leal	2(%edi),%eax	xorl	$3,%eax	movzbl	(%eax),%eax.end.inline Get_DLword_PCMAC0fn,0I 10D 11	.byte	0x33,0xdb	/ xorl %ebx,%ebxE 11I 11/	.byte	0x33,0xdb	/ xorl %ebx,%ebxE 11E 10D 9	xorl	%eax,%eax	/ zero the result registerE 9I 9	leal	0(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eaxE 9	leal	-1(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ahD 9	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%alE 9.end.inline Get_DLword_PCMAC1fn,0I 10D 11	.byte	0x33,0xdb	/ xorl %ebx,%ebxE 11I 11/	.byte	0x33,0xdb	/ xorl %ebx,%ebxE 11E 10D 9	xorl	%eax,%eax	/ zero the result register	movl	%edi,%edx	xorl	$3,%edx	movb	(%edx),%ahE 9	leal	1(%edi),%edx	xorl	$3,%edxD 9	movb	(%edx),%alE 9I 9	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ahE 9.end.inline Get_DLword_PCMAC2fn,0I 10D 11	.byte	0x33,0xdb	/ xorl %ebx,%ebxE 11I 11/	.byte	0x33,0xdb	/ xorl %ebx,%ebxE 11E 10D 9	xorl	%eax,%eax	/ zero the result registerE 9I 9	leal	2(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eaxE 9	leal	1(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ahD 9	leal	2(%edi),%edx	xorl	$3,%edx	movb	(%edx),%alE 9.end.inline Get_DLword_PCMAC3fn,0I 10	.byte	0x33,0xdb	/ xorl %ebx,%ebxE 10D 9	xorl	%eax,%eax	/ zero the result registerE 9I 9	leal	3(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eaxE 9	leal	2(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ahD 9	leal	3(%edi),%edx	xorl	$3,%edx	movb	(%edx),%alE 9E 5.endI 7.inline fast0_dispatcher,0D 8	movzbl	-1(%edi),%eaxE 8I 8	leal	-1(%edi),%eax	xorb	$3,%al	movzbl	(%eax),%eaxE 8	jmp	*optable(,%eax,4).end.inline fast1_dispatcher,0D 8	movzbl	(%edi),%eaxE 8I 8	movl	%edi,%eax	xorb	$3,%al	movzbl	(%eax),%eaxE 8	incl	%edi	jmp	*optable(,%eax,4).end.inline fast2_dispatcher,0D 8	movzbl	1(%edi),%eaxE 8I 8	leal	1(%edi),%eax	xorb	$3,%alE 8	addl	$2,%ediI 8	movzbl	(%eax),%eaxE 8	jmp	*optable(,%eax,4).endI 9	/////////////////////////////	//	//  Arithmetic code speedups	//	// Assume edi & esi are arguments	//	//	  ebx is result.	//	////////////////////////////////.inline Xiplus32,0D 10	leal	(%edi),%eax	addl	%esi,%eaxE 10I 10	addl	%edi,%esiE 10	jo	iplus_errI 10	movl	%esi,%eaxE 10.end.inline Xiplus32n,0	leal	(%edi),%eax	addl	%esi,%eax	jo	iplusn_err.end.inline Xplus32,0	leal	(%edi),%eax	addl	%esi,%eax	jo	plus_err.end.inline Xsub32,0	leal	(%edi),%eax	subl	%esi,%eax	jo	diff_err.end.inline Xisub32,0	leal	(%edi),%eax	subl	%esi,%eax	jo	idiff_err.end.inline Xisub32n,0	leal	(%edi),%eax	subl	%esi,%eax	jo	idiffn_err.end.inline	plus_err_label,0plus_err:.end.inline	iplus_err_label,0iplus_err:.end.inline	diff_err_label,0diff_err:.end.inline	idiff_err_label,0idiff_err:.end.inline	iplusn_err_label,0iplusn_err:.end.inline	 idiffn_err_label,0idiffn_err:.end.inline	fast_op_difference,4	movl	0(%esp),%eax	roll	$15,%ebx	subb	$7,%bl	jne	diff_err	roll	$15,%eax	subb	$7,%al	jne	diff_err	subl	%ebx,%eax	jo	diff_err	rorl	$15,%eax	orl	$917504,%eax	movl	%eax,%ebx.end.inline	fast_op_idifference,4	movl	0(%esp),%eax	roll	$15,%ebx	subb	$7,%bl	jne	idiff_err	roll	$15,%eax	subb	$7,%al	jne	idiff_err	subl	%ebx,%eax	jo	idiff_err	rorl	$15,%eax	orl	$917504,%eax	movl	%eax,%ebx.end.inline fast_op_idifferencen,4	movl	0(%esp),%eax	roll	$15,%eax	roll	$15,%ebx	subb	$7,%bl	jne	idiffn_err	subl	%eax,%ebx	jo	idiffn_err	rorl	$15,%ebx	orl	$917504,%ebx.end/*	***************************************************************	PLUS VERSIONS sp@ + sp@(4)  i.e. (tos-1)  +  (tos)	****************************************************************/.inline	fast_op_plus,4	movl	0(%esp),%eax	roll	$15,%ebx	subb	$7,%bl	jne	plus_err	roll	$15,%eax	subb	$7,%al	jne	plus_errD 10	addl	%eax,%ebxE 10I 10	addl	%ebx,%eaxE 10	jo	plus_errD 10	rorl	$15,%ebx	orl	$917504,%ebxE 10I 10	rorl	$15,%eax	orl	$917504,%eax	movl	%eax,%ebxE 10.end.inline	fast_op_iplus,4	movl	0(%esp),%eax	roll	$15,%ebx	subb	$7,%bl	jne	iplus_err	roll	$15,%eax	subb	$7,%al	jne	iplus_errD 10	addl	%eax,%ebxE 10I 10	addl	%ebx,%eaxE 10	jo	iplus_errD 10	rorl	$15,%ebx	orl	$917504,%ebxE 10I 10	rorl	$15,%eax	orl	$917504,%eax	movl	%eax,%ebxE 10.end.inline	fast_op_iplusn,4	movl	0(%esp),%eax	roll	$15,%eax	roll	$15,%ebx	subb	$7,%bl	jne	iplusn_errD 10	addl	%eax,%ebxE 10I 10	addl	%ebx,%eaxE 10	jo	iplusn_errD 10	rorl	$15,%ebx	orl	$917504,%ebxE 10I 10	rorl	$15,%eax	orl	$917504,%eax	movl	%eax,%ebxE 10.end.inline	fast_op_logor,4	movl	0(%esp),%eax	roll	$15,%ebx	cmpb	$7,%bl	jne	logor_err	roll	$15,%eax	cmpb	$7,%al	jne	logor_err	orl	%eax,%ebx	rorl	$15,%ebx.end.inline	fast_op_logand,4	movl	0(%esp),%eax	roll	$15,%ebx	cmpb	$7,%bl	jne	logand_err	roll	$15,%eax	cmpb	$7,%al	jne	logand_err	andl	%eax,%ebx	rorl	$15,%ebx.end.inline	fast_op_logxor,4	movl	0(%esp),%eax	roll	$15,%ebx	cmpb	$7,%bl	jne	logxor_err	roll	$15,%eax	subb	$7,%al	jne	logxor_err	xorl	%eax,%ebx	rorl	$15,%ebx.end.inline	fast_op_lrsh8,0	movl	%ebx,%eax	roll	$16,%eax	cmpw	$0xe,%ax	jne	lrsh8_err	shrw	$8,%bx.end.inline	fast_op_lrsh1,0	movl	%ebx,%eax	roll	$16,%eax	cmpw	$0xe,%ax	jne	lrsh1_err	shrw	$1,%bx.end.inline	fast_op_llsh8,0	cmpw	$0x0FF,%bx	jg	llsh8_err	movl	%ebx,%eax	roll	$16,%eax	cmpw	$0xe,%eax	jne	llsh8_err	shlw	$8,%bx.end.inline	fast_op_llsh1,0	cmpw	$0x07FFF,%bx	jg	llsh1_err	movl	%ebx,%eax	roll	$16,%eax	cmpw	$0xe,%ax	jne	llsh1_err	shlw	$1,%bx.end.inline	fast_op_greaterp,4	movl	0(%esp),%eax	movl	%ebx,%edx	roll	$15,%edx	subb	$7,%dl	jne	greaterp_err	roll	$15,%eax	subb	$7,%al	jne	greaterp_err	xorl	%ebx,%ebx	cmpl	%edx,%eax	jle	.+7	movl	$76,%ebx.end.inline	fast_op_igreaterp,4	movl	0(%esp),%eax	movl	%ebx,%edx	roll	$15,%edx	subb	$7,%dl	jne	igreaterp_err	roll	$15,%eax	subb	$7,%al	jne	igreaterp_err	xorl	%ebx,%ebx	cmpl	%edx,%eax	jle	.+7	movl	$76,%ebx.end.inline fast_op_addbase,4	movl	0(%esp),%eax	roll	$15,%ebx	subb	$7,%bl	jne	addbase_err	sarl	$15,%ebx	andl	$0xFFFFFF,%eax	addl	%eax,%ebx.end.inline fast_op_loloc,0	andl	$0x0000FFFF,%ebx	orl	$0x000E0000,%ebx.endD 10bE 10I 10E 10.inline	fast_op_hiloc,0	shrl	$16,%ebx	andl	$0x0000FFFF,%ebx	orl	$0x000E0000,%ebx.end/// Unused, because 386i as peephole optimizer removes the shll..inline	fast_op_vag2,4	movl	0(%esp),%eax	shll	$16,%ebx	movw	%ax,%bx	rorl	$16,%ebx.end	E 9I 12.inline	_fast_op_listp,0	movl	d7,d1	lsrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movw	a0@(0,d1:l:1),d1	andw	#0x7FF,d1	cmpw	#5,d1	jeq	110$	clrl	d7110$:.end.inline	_fast_op_ntypex,0	lsrl	#8,d7	andl	#0xFFFE,d7	movl	_MDStypetbl,a0	movw	a0@(0,d7:l:1),d7	andw	#0x7FF,d0	orl	#0x000E0000,d7.end.inline _fast_op_typep,0	movl	d7,d0	lsrl	#8,d0	andl	#0xFFFE,d0	movl	_MDStypetbl,a0	movw	a0@(0,d0:l:1),d0	andw	#0x7FF,d0	moveq	#0,d1	movb	a5@,d1	cmpw	d1,d0	beq	115$	moveq	#0,d7115$:.end///////////////////////////////////////////////////////////////////////	F U N C T I O N   C A L L   S P E E D - U P S////////////////////////////////////////////////////////////////////.inline fast_FN0,0I 14	cld			// so we can use string instructionsE 14	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ah	leal	(,%eax,4),%eaxD 14/	movl	Defspace,%edx/	addl	%eax,%edxE 14	addl	Defspace,%eax	movl	(%eax),%edx	testl	%edx,%edxD 14/	movl	%edx,-40(%ebp)E 14	jl	.LFN0ccodeD 14/	movl	%edx,-40(%ebp)E 14	movl	%eax,-12(%ebp)	movl	$0,-24(%ebp)	movl	$3,-20(%ebp)	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ah	movl	%eax,-16(%ebp)	movl	$0,-28(%ebp)	jmp	fn_common.LFN0ccode:D 14/	movl	-40(%ebp),%eaxE 14	andl	$16777215,%edx	movl	%edx,-40(%ebp)	leal	(%edx,%edx),%ecx	addl	Lisp_world,%ecxD 14/	movl	%edx,%ecxE 14	movl	MachineState+4,%eax	leal	-1(%edi),%edx	subl	MachineState+20,%edx	leal	3(%edx),%edx	movw	%dx,-12(%eax)D 14/	movl	%ecx,%eaxE 14	movzwl	2(%ecx),%eax	leal	(%eax,%eax),%eax	movl	MachineState+32,%edx	subl	%eax,%edx	movl	%edx,MachineState+28	cmpl	%edx,%esi	jg	check_interruptD 14	leal	4(%esi),%eaxE 14I 14	xchg	%edi,%esi	leal	4(%edi),%eaxE 14	movl	%eax,MachineState	movl	%eax,-48(%ebp)	movl	MachineState+4,%eax	movl	-48(%ebp),%edx	subl	Stackspace,%edx	shrl	$1,%edx	movl	%edx,-44(%ebp)	movw	%dx,-10(%eax)D 14	movl	%ebx,(%esi)E 14I 14	movl	%ebx,(%edi)E 14/	movl	%ecx,%eax	movw	(%ecx),%dxD 14	addl	$4,%esiE 14I 14	addl	$4,%ediE 14	testw	%dx,%dx	jl	.FN0noarg1	xorl	%eax,%eax/	movl	%ecx,%edx	movswl	(%ecx),%edx	subl	%edx,%eax	movl	%eax,-48(%ebp)I 14	xorl	%eax,%eax		// for storing NILs.E 14	jmp	.FN0argls1.FN0arglp1:D 14	movl	$0,(%esi)	addl	$4,%esiE 14I 14/	movl	$0,(%edi)/	addl	$4,%edi	stoslE 14	incl	-48(%ebp).FN0argls1:	cmpl	$0,-48(%ebp)	jl	.FN0arglp1	movl	-48(%ebp),%eax	leal	(,%eax,4),%eaxD 14	subl	%eax,%esiE 14I 14	subl	%eax,%ediE 14.FN0noarg1:D 14	movl	%esi,%eax	movl	-44(%ebp),%edx	addl	$4,%esi	orl	$-2147483648,%edx	movl	%edx,(%eax)E 14I 14/	movl	%edi,%eax	movl	-44(%ebp),%eax/	addl	$4,%edi	orl	$-2147483648,%eax/	movl	%edx,(%edi)/	addl	$4,%edi	stoslE 14	movl	MachineState+4,%eax	subl	Stackspace,%eax	shrl	$1,%eax	orl	$-1073741824,%eaxD 14	movl	%eax,(%esi)E 14I 14	movl	%eax,(%edi)E 14/	pushl	-40(%ebp)	movl	-40(%ebp),%eax	rol	$16,%eax/	popl	%ecxD 14	movl	%eax,4(%esi)	addl	$20,%esi	movl	%esi,MachineState+4E 14I 14	movl	%eax,4(%edi)	addl	$20,%edi	movl	%edi,MachineState+4E 14/	movl	%ecx,%eax	movswl	6(%ecx),%eax	movl	%eax,-48(%ebp)	cmpl	$0,-48(%ebp)	jl	.FN0disp/	movl	$-1,-52(%ebp)D 14/	movl	%esi,%eax	movl	$-1,%edx	movl	%edx,(%esi)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 14I 14/	movl	%edi,%eax	movl	$-1,%eax/	movl	%edx,(%edi)/	addl	$4,%edi/	movl	%edx,(%edi)/	addl	$4,%edi	stosl	stoslE 14	cmpl	$0,-48(%ebp)	jle	.FN0disp.FNxxalp:D 14	movl	%edx,(%esi)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 14I 14/	movl	%edx,(%edi)/	addl	$4,%edi/	movl	%edx,(%edi)/	addl	$4,%edi	stosl	stoslE 14	decl	-48(%ebp).FN0xalp:	decl	-48(%ebp)	jl	.FN0dispD 14/	movl	%esi,%eaxE 14I 14/	movl	%edi,%eaxE 14/	movl	-52(%ebp),%edxD 14	movl	%edx,(%esi)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 14I 14/	movl	%edx,(%edi)/	addl	$4,%edi/	movl	%edx,(%edi)/	addl	$4,%edi	stosl	stoslE 14	jmp	.FN0xalp.FN0disp:D 14/	movl	%ecx,%eaxE 14	movzwl	4(%ecx),%eax	movl	%ecx,%edxD 14	addl	$4,%esiE 14I 14	addl	$4,%ediE 14	addl	%eax,%edx	incl	%edxD 14	movl	%edx,%edi/	movl	%ecx,%eaxE 14I 14	movl	%edx,%esiE 14	movl	%ecx,MachineState+20D 14	leal	-1(%edi),%eaxE 14I 14	leal	-1(%esi),%eaxE 14	xorb	$3,%alI 14	xchg	%edi,%esi	/ done using edit to store fast with.E 14	movzbl	(%eax),%eax	jmp	*optable(,%eax,4).end.inline fast_FN1,0I 14	cld			// for string instruction useE 14	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ahI 14	movl	%eax,%ecxE 14	leal	(,%eax,4),%eaxD 14	movl	Defspace,%edx	addl	%eax,%edx	movl	(%edx),%edxE 14I 14	addl	Defspace,%eax	movl	(%eax),%edxE 14	testl	%edx,%edxD 14	movl	%edx,-40(%ebp)E 14	jl	.FN1ccodeD 14	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ah	leal	(,%eax,4),%eax	movl	Defspace,%edx	addl	%eax,%edx	movl	%edx,-12(%ebp)E 14I 14	movl	%eax,-12(%ebp)E 14	movl	$1,-24(%ebp)	movl	$3,-20(%ebp)D 14	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ah	movl	%eax,-16(%ebp)E 14I 14	movl	%ecx,-16(%ebp)E 14	movl	$0,-28(%ebp)	jmp	fn_common.FN1ccode:D 14	movl	-40(%ebp),%eax	andl	$16777215,%eax	movl	%eax,-40(%ebp)	leal	(%eax,%eax),%eax	addl	Lisp_world,%eax	movl	%eax,-36(%ebp)E 14I 14/	movl	-40(%ebp),%eax	andl	$16777215,%edx	movl	%edx,-40(%ebp)	leal	(%edx,%edx),%ecx	addl	Lisp_world,%ecx/	movl	%eax,%ecxE 14	movl	MachineState+4,%eax	leal	-1(%edi),%edx	subl	MachineState+20,%edx	leal	3(%edx),%edx	movw	%dx,-12(%eax)D 14	movl	-36(%ebp),%eax	movzwl	2(%eax),%eaxE 14I 14/	movl	%ecx,%eax	movzwl	2(%ecx),%eaxE 14	leal	(%eax,%eax),%eax	movl	MachineState+32,%edx	subl	%eax,%edx	movl	%edx,MachineState+28	cmpl	%edx,%esi	jg	check_interruptD 14	movl	%esi,%eax	movl	%eax,MachineState	movl	%eax,-48(%ebp)E 14I 14	xchg	%edi,%esi/	movl	%edi,%eax	movl	%edi,MachineState	movl	%edi,-48(%ebp)E 14	movl	MachineState+4,%eaxD 14	movl	-48(%ebp),%edxE 14I 14	movl	%edi,%edxE 14	subl	Stackspace,%edx	shrl	$1,%edx	movl	%edx,-44(%ebp)	movw	%dx,-10(%eax)D 14	movl	%ebx,(%esi)	movl	-36(%ebp),%eax	movw	(%eax),%dx	addl	$4,%esiE 14I 14	movl	%ebx,(%edi)/	movl	%ecx,%eax	movw	(%ecx),%dx	addl	$4,%ediE 14	testw	%dx,%dx	jl	.FN1noarg	movl	$1,%eaxD 14	movl	-36(%ebp),%edx	movswl	(%edx),%edxE 14I 14/	movl	%ecx,%edx	movswl	(%ecx),%edxE 14	subl	%edx,%eax	movl	%eax,-48(%ebp)I 14	xorl	%eax,%eaxE 14	jmp	.FN1lps.FN1lp1:D 14	movl	$0,(%esi)	addl	$4,%esiE 14I 14/	movl	$0,(%edi)/	addl	$4,%edi	stoslE 14	incl	-48(%ebp).FN1lps:	cmpl	$0,-48(%ebp)	jl	.FN1lp1	movl	-48(%ebp),%eax	leal	(,%eax,4),%eaxD 14	subl	%eax,%esiE 14I 14	subl	%eax,%ediE 14.FN1noarg:D 14	movl	%esi,%eaxE 14I 14/	movl	%edi,%eaxE 14	movl	-44(%ebp),%edxD 14	addl	$4,%esiE 14I 14/	addl	$4,%ediE 14	orl	$-2147483648,%edxD 14	movl	%edx,(%eax)E 14I 14	movl	%edx,(%edi)	addl	$4,%ediE 14	movl	MachineState+4,%eax	subl	Stackspace,%eax	shrl	$1,%eax	orl	$-1073741824,%eaxD 14	movl	%eax,(%esi)	pushl	-40(%ebp)	movl	0(%esp),%eaxE 14I 14	movl	%eax,(%edi)	movl	-40(%ebp),%eaxE 14	rol	$16,%eaxD 14	popl	%ecx	movl	%eax,4(%esi)	addl	$20,%esi	movl	%esi,MachineState+4	movl	-36(%ebp),%eax	movswl	6(%eax),%eaxE 14I 14	movl	%eax,4(%edi)	addl	$20,%edi	movl	%edi,MachineState+4	movswl	6(%ecx),%eaxE 14	movl	%eax,-48(%ebp)	cmpl	$0,-48(%ebp)D 13	jl	.FN0dispE 13I 13	jl	.FN1dispE 13D 14	movl	$-1,-52(%ebp)	movl	%esi,%eax	movl	-52(%ebp),%edx	movl	%edx,(%eax)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 14I 14/	movl	$-1,-52(%ebp)/	movl	%edi,%eax/	movl	-52(%ebp),%edx	movl	$-1,%eax/	movl	%eax,(%edi)/	addl	$4,%edi/	movl	%edx,(%edi)/	addl	$4,%edi	stosl	stoslE 14	cmpl	$0,-48(%ebp)D 13	jle	.FN0dispE 13I 13	jle	.FN1dispE 13D 14	movl	%edx,(%esi)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 14I 14/	movl	%edx,(%edi)/	addl	$4,%edi/	movl	%edx,(%edi)/	addl	$4,%edi	stosl	stoslE 14	decl	-48(%ebp).FN1xlp:	decl	-48(%ebp)D 13	jl	.FN0dispE 13I 13	jl	.FN1dispE 13D 14	movl	%esi,%eax	movl	-52(%ebp),%edx	movl	%edx,(%eax)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 14I 14/	movl	%edi,%eax/	movl	-52(%ebp),%edx/	movl	%edx,(%eax)/	addl	$4,%edi/	movl	%edx,(%edi)/	addl	$4,%edi	stosl	stoslE 14	jmp	.FN1xlpI 13	// can be pointed to FN0disp when we do the ecx change here..FN1disp:D 14	movl	-36(%ebp),%eax	movzwl	4(%eax),%eax	movl	-36(%ebp),%edx	addl	$4,%esi	addl	%eax,%edx	incl	%edx	movl	%edx,%edi	movl	-36(%ebp),%eax	movl	%eax,MachineState+20	leal	-1(%edi),%eaxE 14I 14	movzwl	4(%ecx),%eax	movl	%ecx,%esi	addl	$4,%edi	addl	%eax,%esi	incl	%esi/	movl	%edx,%esi	movl	%ecx,MachineState+20	leal	-1(%esi),%eax	xchg	%edi,%esi	/ done using edi to store fast with.E 14	xorb	$3,%al	movzbl	(%eax),%eax	jmp	*optable(,%eax,4)E 13.end.inline fast_FN2,0I 14	cld			// for string ops, so they push upward.E 14	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ahI 14	movl	%eax,%ecxE 14	leal	(,%eax,4),%eaxD 14	movl	Defspace,%edx	addl	%eax,%edx	movl	(%edx),%edxE 14I 14	addl	Defspace,%eax	movl	(%eax),%edxE 14	testl	%edx,%edxD 14	movl	%edx,-40(%ebp)E 14	jl	.FN2ccodeD 14	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ah	leal	(,%eax,4),%eax	movl	Defspace,%edx	addl	%eax,%edx	movl	%edx,-12(%ebp)E 14I 14	movl	%eax,-12(%ebp)E 14	movl	$2,-24(%ebp)	movl	$3,-20(%ebp)D 14	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ah	movl	%eax,-16(%ebp)E 14I 14	movl	%ecx,-16(%ebp)E 14	movl	$0,-28(%ebp)	jmp	fn_common.FN2ccode:D 14	movl	-40(%ebp),%eax	andl	$16777215,%eax	movl	%eax,-40(%ebp)	leal	(%eax,%eax),%eax	addl	Lisp_world,%eax	movl	%eax,-36(%ebp)E 14I 14/	movl	-40(%ebp),%eax	andl	$16777215,%edx	movl	%edx,-40(%ebp)	leal	(%edx,%edx),%ecx	addl	Lisp_world,%ecx/	movl	%eax,%ecxE 14	movl	MachineState+4,%eax	leal	-1(%edi),%edx	subl	MachineState+20,%edx	leal	3(%edx),%edx	movw	%dx,-12(%eax)D 14	movl	-36(%ebp),%eax	movzwl	2(%eax),%eaxE 14I 14/	movl	%ecx,%eax	movzwl	2(%ecx),%eaxE 14	leal	(%eax,%eax),%eax	movl	MachineState+32,%edx	subl	%eax,%edx	movl	%edx,MachineState+28	cmpl	%edx,%esi	jg	check_interruptD 14	movl	%esi,%eaxE 14I 14	xchg	%edi,%esi	movl	%edi,%eaxE 14	subl	$4,%eax	movl	%eax,MachineState	movl	%eax,-48(%ebp)	movl	MachineState+4,%eax	movl	-48(%ebp),%edx	subl	Stackspace,%edx	shrl	$1,%edx	movl	%edx,-44(%ebp)	movw	%dx,-10(%eax)D 14	movl	%ebx,(%esi)	movl	-36(%ebp),%eax	movw	(%eax),%dx	addl	$4,%esiE 14I 14	movl	%ebx,(%edi)/	movl	%ecx,%eax	movw	(%ecx),%dx	addl	$4,%ediE 14	testw	%dx,%dx	jl	.FN2noarg	movl	$2,%eaxD 14	movl	-36(%ebp),%edx	movswl	(%edx),%edxE 14I 14/	movl	%ecx,%edx	movswl	(%ecx),%edxE 14	subl	%edx,%eax	movl	%eax,-48(%ebp)I 14	xorl	%eax,%eaxE 14	jmp	.FN2lps.FN2lp:D 14	movl	$0,(%esi)	addl	$4,%esiE 14I 14/	movl	$0,(%edi)/	addl	$4,%edi	stoslE 14	incl	-48(%ebp).FN2lps:	cmpl	$0,-48(%ebp)	jl	.FN2lp	movl	-48(%ebp),%eax	leal	(,%eax,4),%eaxD 14	subl	%eax,%esiE 14I 14	subl	%eax,%ediE 14.FN2noarg:D 14	movl	%esi,%eax	movl	-44(%ebp),%edx	addl	$4,%esi	orl	$-2147483648,%edx	movl	%edx,(%eax)E 14I 14/	movl	%edi,%eax	movl	-44(%ebp),%eax/	addl	$4,%edi	orl	$-2147483648,%eax/	movl	%edx,(%eax)	stoslE 14	movl	MachineState+4,%eax	subl	Stackspace,%eax	shrl	$1,%eax	orl	$-1073741824,%eaxD 14	movl	%eax,(%esi)	pushl	-40(%ebp)	movl	0(%esp),%eaxE 14I 14	movl	%eax,(%edi)	movl	-40(%ebp),%eaxE 14	rol	$16,%eaxD 14	popl	%ecx	movl	%eax,4(%esi)	addl	$20,%esi	movl	%esi,MachineState+4	movl	-36(%ebp),%eax	movswl	6(%eax),%eaxE 14I 14	movl	%eax,4(%edi)	addl	$20,%edi	movl	%edi,MachineState+4	movswl	6(%ecx),%eaxE 14	movl	%eax,-48(%ebp)	cmpl	$0,-48(%ebp)D 13	jl	.FN0dispE 13I 13	jl	.FN1dispE 13D 14	movl	$-1,-52(%ebp)	movl	%esi,%eax	movl	-52(%ebp),%edx	movl	%edx,(%eax)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 14I 14/	movl	$-1,-52(%ebp)/	movl	%edi,%eax	movl	$-1,%eax/	movl	%edx,(%edi)/	addl	$4,%edi/	movl	%edx,(%edi)/	addl	$4,%edi	stosl	stoslE 14	cmpl	$0,-48(%ebp)D 13	jle	.FN0dispE 13I 13	jle	.FN1dispE 13D 14	movl	%edx,(%esi)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 14I 14/	movl	%edx,(%edi)/	addl	$4,%edi/	movl	%edx,(%edi)/	addl	$4,%edi	stosl	stoslE 14	decl	-48(%ebp).FN2xlp:	decl	-48(%ebp)D 13	jl	.FN0dispE 13I 13	jl	.FN1dispE 13D 14	movl	%esi,%eax	movl	-52(%ebp),%edx	movl	%edx,(%eax)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 14I 14/	movl	%edi,%eax/	movl	-52(%ebp),%edx/	movl	%edx,(%edi)/	addl	$4,%edi/	movl	%edx,(%edi)/	addl	$4,%edi	stosl	stoslE 14	jmp	.FN2xlp.end.inline fast_FN3,0	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ahI 14	movl	%eax,%ecxE 14	leal	(,%eax,4),%eaxD 14	movl	Defspace,%edx	addl	%eax,%edx	movl	(%edx),%edxE 14I 14	addl	Defspace,%eax	movl	(%eax),%edxE 14	testl	%edx,%edxD 14	movl	%edx,-40(%ebp)E 14	jl	.FN3ccodeD 14	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ah	leal	(,%eax,4),%eax	movl	Defspace,%edx	addl	%eax,%edx	movl	%edx,-12(%ebp)E 14I 14	movl	%eax,-12(%ebp)E 14	movl	$3,-24(%ebp)	movl	$3,-20(%ebp)D 14	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ah	movl	%eax,-16(%ebp)E 14I 14	movl	%ecx,-16(%ebp)E 14	movl	$0,-28(%ebp)	jmp	fn_common.FN3ccode:D 14	movl	-40(%ebp),%eax	andl	$16777215,%eax	movl	%eax,-40(%ebp)	leal	(%eax,%eax),%eax	addl	Lisp_world,%eax	movl	%eax,-36(%ebp)E 14I 14	cld			// so string ops work upward./	movl	-40(%ebp),%eax	andl	$16777215,%edx	movl	%edx,-40(%ebp)	leal	(%edx,%edx),%ecx	addl	Lisp_world,%ecx/	movl	%eax,%ecxE 14	movl	MachineState+4,%eax	leal	-1(%edi),%edx	subl	MachineState+20,%edx	leal	3(%edx),%edx	movw	%dx,-12(%eax)D 14	movl	-36(%ebp),%eax	movzwl	2(%eax),%eaxE 14I 14/	movl	%ecx,%eax	movzwl	2(%ecx),%eaxE 14	leal	(%eax,%eax),%eax	movl	MachineState+32,%edx	subl	%eax,%edx	movl	%edx,MachineState+28	cmpl	%edx,%esi	jg	check_interruptD 14	movl	%esi,%eaxE 14I 14	xchg	%edi,%esi	movl	%edi,%eaxE 14	subl	$8,%eax	movl	%eax,MachineState	movl	%eax,-48(%ebp)	movl	MachineState+4,%eax	movl	-48(%ebp),%edx	subl	Stackspace,%edx	shrl	$1,%edx	movl	%edx,-44(%ebp)	movw	%dx,-10(%eax)D 14	movl	%ebx,(%esi)	movl	-36(%ebp),%eax	movw	(%eax),%dx	addl	$4,%esiE 14I 14	movl	%ebx,(%edi)/	movl	%ecx,%eax	movw	(%ecx),%dx	addl	$4,%ediE 14	testw	%dx,%dx	jl	.FN3noarg	movl	$3,%eaxD 14	movl	-36(%ebp),%edx	movswl	(%edx),%edxE 14I 14/	movl	%ecx,%edx	movswl	(%ecx),%edxE 14	subl	%edx,%eax	movl	%eax,-48(%ebp)I 14	xorl	%eax,%eaxE 14	jmp	.FN3lps.FN3lp:D 14	movl	$0,(%esi)	addl	$4,%esiE 14I 14/	movl	$0,(%edi)/	addl	$4,%edi	stoslE 14	incl	-48(%ebp).FN3lps:	cmpl	$0,-48(%ebp)	jl	.FN3lp	movl	-48(%ebp),%eax	leal	(,%eax,4),%eaxD 14	subl	%eax,%esiE 14I 14	subl	%eax,%ediE 14.FN3noarg:D 14	movl	%esi,%eax	movl	-44(%ebp),%edx	addl	$4,%esi	orl	$-2147483648,%edx	movl	%edx,(%eax)E 14I 14/	movl	%edi,%eax	movl	-44(%ebp),%eax/	addl	$4,%edi	orl	$-2147483648,%eax/	movl	%edx,(%eax)	stoslE 14	movl	MachineState+4,%eax	subl	Stackspace,%eax	shrl	$1,%eax	orl	$-1073741824,%eaxD 14	movl	%eax,(%esi)	pushl	-40(%ebp)	movl	0(%esp),%eaxE 14I 14	movl	%eax,(%edi)	movl	-40(%ebp),%eaxE 14	rol	$16,%eaxD 14	popl	%ecx	movl	%eax,4(%esi)	addl	$20,%esi	movl	%esi,MachineState+4	movl	-36(%ebp),%eax	movswl	6(%eax),%eaxE 14I 14	movl	%eax,4(%edi)	addl	$20,%edi	movl	%edi,MachineState+4	movswl	6(%ecx),%eaxE 14	movl	%eax,-48(%ebp)	cmpl	$0,-48(%ebp)D 13	jl	.FN0dispE 13I 13	jl	.FN1dispE 13D 14	movl	$-1,-52(%ebp)	movl	%esi,%eax	movl	-52(%ebp),%edx	movl	%edx,(%eax)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 14I 14/	movl	$-1,-52(%ebp)/	movl	%edi,%eax	movl	$-1,%eax/	movl	%edx,(%eax)/	addl	$4,%edi/	movl	%edx,(%edi)/	addl	$4,%edi	stosl	stoslE 14	cmpl	$0,-48(%ebp)D 13	jle	.FN0dispE 13I 13	jle	.FN1dispE 13D 14	movl	%edx,(%esi)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 14I 14/	movl	%edx,(%edi)/	addl	$4,%edi/	movl	%edx,(%edi)/	addl	$4,%edi	stosl	stoslE 14	decl	-48(%ebp).FN3xlp:	decl	-48(%ebp)D 13	jl	.FN0dispE 13I 13	jl	.FN1dispE 13D 14	movl	%esi,%eax	movl	-52(%ebp),%edx	movl	%edx,(%eax)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 14I 14/	movl	%edi,%eax/	movl	-52(%ebp),%edx/	movl	%edx,(%edi)/	addl	$4,%edi/	movl	%edx,(%edi)/	addl	$4,%edi	stosl	stoslE 14	jmp	.FN3xlp.end.inline fast_FN4,0D 15.L248:.L249:/	.byte	0x33,0xdb	/ xorl %ebx,%ebxE 15	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ahI 15	movl	%eax,%ecxE 15	leal	(,%eax,4),%eaxD 15	movl	Defspace,%edx	addl	%eax,%edx	movl	(%edx),%edxE 15I 15	addl	Defspace,%eax	movl	(%eax),%edxE 15	testl	%edx,%edxI 15	jl	.FN4ccode	movl	%eax,-12(%ebp)	movl	$4,-24(%ebp)	movl	$3,-20(%ebp)	movl	%ecx,-16(%ebp)	movl	$0,-28(%ebp)	jmp	fn_common.FN4ccode:	cld			// so string ops work upward.	andl	$16777215,%edxE 15	movl	%edx,-40(%ebp)D 15	jl	.L250/	.byte	0x33,0xdb	/ xorl %ebx,%ebxE 15I 15	leal	(%edx,%edx),%ecx	addl	Lisp_world,%ecx	movl	MachineState+4,%eax	leal	-1(%edi),%edx	subl	MachineState+20,%edx	leal	3(%edx),%edx	movw	%dx,-12(%eax)	movzwl	2(%ecx),%eax	leal	(%eax,%eax),%eax	movl	MachineState+32,%edx	subl	%eax,%edx	movl	%edx,MachineState+28	cmpl	%edx,%esi	jg	check_interrupt	xchg	%edi,%esi	movl	%edi,%eax	subl	$12,%eax	movl	%eax,MachineState	movl	%eax,-48(%ebp)	movl	MachineState+4,%eax	movl	-48(%ebp),%edx	subl	Stackspace,%edx	shrl	$1,%edx	movl	%edx,-44(%ebp)	movw	%dx,-10(%eax)	movl	%ebx,(%edi)	movw	(%ecx),%dx	addl	$4,%edi	testw	%dx,%dx	jl	.FN4noarg	movl	$4,%eax	movswl	(%ecx),%edx	subl	%edx,%eax	movl	%eax,-48(%ebp)	xorl	%eax,%eax	jmp	.FN4lps.FN4lp:	stosl	incl	-48(%ebp).FN4lps:	cmpl	$0,-48(%ebp)	jl	.FN4lp	movl	-48(%ebp),%eax	leal	(,%eax,4),%eax	subl	%eax,%edi.FN4noarg:	movl	-44(%ebp),%eax	orl	$-2147483648,%eax	stosl	movl	MachineState+4,%eax	subl	Stackspace,%eax	shrl	$1,%eax	orl	$-1073741824,%eax	movl	%eax,(%edi)	movl	-40(%ebp),%eax	rol	$16,%eax	movl	%eax,4(%edi)	addl	$20,%edi	movl	%edi,MachineState+4	movswl	6(%ecx),%eax	movl	%eax,-48(%ebp)	cmpl	$0,-48(%ebp)	jl	.FN1disp	movl	$-1,%eax	stosl	stosl	cmpl	$0,-48(%ebp)	jle	.FN1disp	stosl	stosl	decl	-48(%ebp).FN4xlp:	decl	-48(%ebp)	jl	.FN1disp	stosl	stosl	jmp	.FN4xlp.end.inline fast_FN5,0E 15	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ahI 15	movl	%eax,%ecxE 15	leal	(,%eax,4),%eaxD 15	movl	Defspace,%edx	addl	%eax,%edx	movl	%edx,-12(%ebp)	movl	$4,-24(%ebp)E 15I 15	addl	Defspace,%eax	movl	(%eax),%edx	testl	%edx,%edx	jl	.FN5ccode	movl	%eax,-12(%ebp)	movl	$5,-24(%ebp)E 15	movl	$3,-20(%ebp)D 15/	.byte	0x33,0xdb	/ xorl %ebx,%ebxE 15I 15	movl	%ecx,-16(%ebp)	movl	$0,-28(%ebp)	jmp	fn_common.FN5ccode:	cld			// so string ops work upward.	andl	$16777215,%edx	movl	%edx,-40(%ebp)	leal	(%edx,%edx),%ecx	addl	Lisp_world,%ecx	movl	MachineState+4,%eax	leal	-1(%edi),%edx	subl	MachineState+20,%edx	leal	3(%edx),%edx	movw	%dx,-12(%eax)	movzwl	2(%ecx),%eax	leal	(%eax,%eax),%eax	movl	MachineState+32,%edx	subl	%eax,%edx	movl	%edx,MachineState+28	cmpl	%edx,%esi	jg	check_interrupt	xchg	%edi,%esi	movl	%edi,%eax	subl	$16,%eax	movl	%eax,MachineState	movl	%eax,-48(%ebp)	movl	MachineState+4,%eax	movl	-48(%ebp),%edx	subl	Stackspace,%edx	shrl	$1,%edx	movl	%edx,-44(%ebp)	movw	%dx,-10(%eax)	movl	%ebx,(%edi)	movw	(%ecx),%dx	addl	$4,%edi	testw	%dx,%dx	jl	.FN5noarg	movl	$5,%eax	movswl	(%ecx),%edx	subl	%edx,%eax	movl	%eax,-48(%ebp)	xorl	%eax,%eax	jmp	.FN5lps.FN5lp:	stosl	incl	-48(%ebp).FN5lps:	cmpl	$0,-48(%ebp)	jl	.FN5lp	movl	-48(%ebp),%eax	leal	(,%eax,4),%eax	subl	%eax,%edi.FN5noarg:	movl	-44(%ebp),%eax	orl	$-2147483648,%eax	stosl	movl	MachineState+4,%eax	subl	Stackspace,%eax	shrl	$1,%eax	orl	$-1073741824,%eax	movl	%eax,(%edi)	movl	-40(%ebp),%eax	rol	$16,%eax	movl	%eax,4(%edi)	addl	$20,%edi	movl	%edi,MachineState+4	movswl	6(%ecx),%eax	movl	%eax,-48(%ebp)	cmpl	$0,-48(%ebp)	jl	.FN1disp	movl	$-1,%eax	stosl	stosl	cmpl	$0,-48(%ebp)	jle	.FN1disp	stosl	stosl	decl	-48(%ebp).FN5xlp:	decl	-48(%ebp)	jl	.FN1disp	stosl	stosl	jmp	.FN5xlp.end.inline fast_FN6,0E 15	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ahD 15	movl	%eax,-16(%ebp)E 15I 15	movl	%eax,%ecx	leal	(,%eax,4),%eax	addl	Defspace,%eax	movl	(%eax),%edx	testl	%edx,%edx	jl	.FN6ccode	movl	%eax,-12(%ebp)	movl	$6,-24(%ebp)	movl	$3,-20(%ebp)	movl	%ecx,-16(%ebp)E 15	movl	$0,-28(%ebp)	jmp	fn_commonD 15.L250:	movl	-40(%ebp),%eax	andl	$16777215,%eax	movl	%eax,-40(%ebp)	leal	(%eax,%eax),%eax	addl	Lisp_world,%eaxD 14	movl	%eax,-36(%ebp)E 14I 14	movl	%eax,%ecxE 15I 15.FN6ccode:	cld			// so string ops work upward.	andl	$16777215,%edx	movl	%edx,-40(%ebp)	leal	(%edx,%edx),%ecx	addl	Lisp_world,%ecxE 15E 14	movl	MachineState+4,%eax	leal	-1(%edi),%edx	subl	MachineState+20,%edx	leal	3(%edx),%edx	movw	%dx,-12(%eax)D 14	movl	-36(%ebp),%eaxE 14I 14D 15	movl	%ecx,%eaxE 14	movzwl	2(%eax),%eaxE 15I 15	movzwl	2(%ecx),%eaxE 15	leal	(%eax,%eax),%eax	movl	MachineState+32,%edx	subl	%eax,%edx	movl	%edx,MachineState+28	cmpl	%edx,%esi	jg	check_interruptD 15	movl	%esi,%eax	subl	$12,%eaxE 15I 15	xchg	%edi,%esi	movl	%edi,%eax	subl	$20,%eaxE 15	movl	%eax,MachineState	movl	%eax,-48(%ebp)	movl	MachineState+4,%eax	movl	-48(%ebp),%edx	subl	Stackspace,%edx	shrl	$1,%edx	movl	%edx,-44(%ebp)	movw	%dx,-10(%eax)D 15	movl	%ebx,(%esi)D 14	movl	-36(%ebp),%eaxE 14I 14	movl	%ecx,%eaxE 14	movw	(%eax),%dx	addl	$4,%esiE 15I 15	movl	%ebx,(%edi)	movw	(%ecx),%dx	addl	$4,%ediE 15	testw	%dx,%dxD 15	jl	.L252	movl	$4,%eaxD 14	movl	-36(%ebp),%edxE 14I 14	movl	%ecx,%edxE 14	movswl	(%edx),%edxE 15I 15	jl	.FN6noarg	movl	$6,%eax	movswl	(%ecx),%edxE 15	subl	%edx,%eax	movl	%eax,-48(%ebp)D 15	jmp	.L253..5:	movl	$0,(%esi)	addl	$4,%esiE 15I 15	xorl	%eax,%eax	jmp	.FN6lps.FN6lp:	stoslE 15	incl	-48(%ebp)D 15.L253:E 15I 15.FN6lps:E 15	cmpl	$0,-48(%ebp)D 15	jl	..5E 15I 15	jl	.FN6lpE 15	movl	-48(%ebp),%eax	leal	(,%eax,4),%eaxD 15	subl	%eax,%esi.L252:	movl	%esi,%eax	movl	-44(%ebp),%edx	addl	$4,%esi	orl	$-2147483648,%edx	movl	%edx,(%eax)E 15I 15	subl	%eax,%edi.FN6noarg:	movl	-44(%ebp),%eax	orl	$-2147483648,%eax	stoslE 15	movl	MachineState+4,%eax	subl	Stackspace,%eax	shrl	$1,%eax	orl	$-1073741824,%eaxD 15	movl	%eax,(%esi)	pushl	-40(%ebp)	movl	0(%esp),%eaxE 15I 15	movl	%eax,(%edi)	movl	-40(%ebp),%eaxE 15	rol	$16,%eaxD 15	popl	%ecx	movl	%eax,4(%esi)	addl	$20,%esi	movl	%esi,MachineState+4D 14	movl	-36(%ebp),%eaxE 14I 14	movl	%ecx,%eaxE 14	movswl	6(%eax),%eaxE 15I 15	movl	%eax,4(%edi)	addl	$20,%edi	movl	%edi,MachineState+4	movswl	6(%ecx),%eaxE 15	movl	%eax,-48(%ebp)	cmpl	$0,-48(%ebp)D 15	jl	.L255	movl	$-1,-52(%ebp)	movl	%esi,%eax	movl	-52(%ebp),%edx	movl	%edx,(%eax)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 15I 15	jl	.FN1disp	movl	$-1,%eax	stosl	stoslE 15	cmpl	$0,-48(%ebp)D 15	jle	.L256	movl	%edx,(%esi)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esiE 15I 15	jle	.FN1disp	stosl	stoslE 15	decl	-48(%ebp)D 15.L259:E 15I 15.FN6xlp:E 15	decl	-48(%ebp)D 15	jl	.L258	movl	%esi,%eax	movl	-52(%ebp),%edx	movl	%edx,(%eax)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esi	jmp	.L259E 15I 15	jl	.FN1disp	stosl	stosl	jmp	.FN6xlpE 15.endD 15.inline fast_FN5,0.L260:.L261:	movl	%edi,%eax	xorl	$3,%eax	movzbl	(%eax),%eax	movl	%eax,-48(%ebp)/	.byte	0x33,0xdb	/ xorl %ebx,%ebx	leal	2(%edi),%edxE 15I 15.inline fast_FN7,0	leal	1(%edi),%edxE 15	xorl	$3,%edx	movzbl	(%edx),%eaxD 15	leal	1(%edi),%edxE 15I 15	leal	0(%edi),%edxE 15	xorl	$3,%edx	movb	(%edx),%ahI 15	movl	%eax,%ecxE 15	leal	(,%eax,4),%eaxD 15	movl	Defspace,%edx	addl	%eax,%edx	movl	%edx,-40(%ebp)	movl	(%edx),%eax	shrl	$31,%eax	andl	$1,%eax	jne	.L263	movl	-40(%ebp),%eaxE 15I 15	addl	Defspace,%eax	movl	(%eax),%edx	testl	%edx,%edx	jl	.FN7ccodeE 15	movl	%eax,-12(%ebp)I 15	movl	$7,-24(%ebp)	movl	$3,-20(%ebp)	movl	%ecx,-16(%ebp)	movl	$0,-28(%ebp)	jmp	fn_common.FN7ccode:	cld			// so string ops work upward.	andl	$16777215,%edx	movl	%edx,-40(%ebp)	leal	(%edx,%edx),%ecx	addl	Lisp_world,%ecx	movl	MachineState+4,%eax	leal	-1(%edi),%edx	subl	MachineState+20,%edx	leal	3(%edx),%edx	movw	%dx,-12(%eax)	movzwl	2(%ecx),%eax	leal	(%eax,%eax),%eax	movl	MachineState+32,%edx	subl	%eax,%edx	movl	%edx,MachineState+28	cmpl	%edx,%esi	jg	check_interrupt	xchg	%edi,%esi	movl	%edi,%eax	subl	$24,%eax	movl	%eax,MachineState	movl	%eax,-48(%ebp)	movl	MachineState+4,%eax	movl	-48(%ebp),%edx	subl	Stackspace,%edx	shrl	$1,%edx	movl	%edx,-44(%ebp)	movw	%dx,-10(%eax)	movl	%ebx,(%edi)	movw	(%ecx),%dx	addl	$4,%edi	testw	%dx,%dx	jl	.FN7noarg	movl	$7,%eax	movswl	(%ecx),%edx	subl	%edx,%eax	movl	%eax,-48(%ebp)	xorl	%eax,%eax	jmp	.FN7lps.FN7lp:	stosl	incl	-48(%ebp).FN7lps:	cmpl	$0,-48(%ebp)	jl	.FN7lpE 15	movl	-48(%ebp),%eaxD 15	movl	%eax,-24(%ebp)	movl	$4,-20(%ebp)/	.byte	0x33,0xdb	/ xorl %ebx,%ebx	leal	2(%edi),%edxE 15I 15	leal	(,%eax,4),%eax	subl	%eax,%edi.FN7noarg:	movl	-44(%ebp),%eax	orl	$-2147483648,%eax	stosl	movl	MachineState+4,%eax	subl	Stackspace,%eax	shrl	$1,%eax	orl	$-1073741824,%eax	movl	%eax,(%edi)	movl	-40(%ebp),%eax	rol	$16,%eax	movl	%eax,4(%edi)	addl	$20,%edi	movl	%edi,MachineState+4	movswl	6(%ecx),%eax	movl	%eax,-48(%ebp)	cmpl	$0,-48(%ebp)	jl	.FN1disp	movl	$-1,%eax	stosl	stosl	cmpl	$0,-48(%ebp)	jle	.FN1disp	stosl	stosl	decl	-48(%ebp).FN7xlp:	decl	-48(%ebp)	jl	.FN1disp	stosl	stosl	jmp	.FN7xlp.end.inline fast_FN8,0	leal	1(%edi),%edxE 15	xorl	$3,%edx	movzbl	(%edx),%eaxD 15	leal	1(%edi),%edxE 15I 15	leal	0(%edi),%edxE 15	xorl	$3,%edx	movb	(%edx),%ahD 15	movl	%eax,-16(%ebp)E 15I 15	movl	%eax,%ecx	leal	(,%eax,4),%eax	addl	Defspace,%eax	movl	(%eax),%edx	testl	%edx,%edx	jl	.FN8ccode	movl	%eax,-12(%ebp)	movl	$8,-24(%ebp)	movl	$3,-20(%ebp)	movl	%ecx,-16(%ebp)E 15	movl	$0,-28(%ebp)	jmp	fn_commonD 15.L263:	movl	-40(%ebp),%eax	movl	(%eax),%eax	andl	$16777215,%eax	leal	(%eax,%eax),%eax	addl	Lisp_world,%eaxD 14	movl	%eax,-36(%ebp)E 14I 14	movl	%eax,%ecxE 15I 15.FN8ccode:	cld			// so string ops work upward.	andl	$16777215,%edx	movl	%edx,-40(%ebp)	leal	(%edx,%edx),%ecx	addl	Lisp_world,%ecxE 15E 14	movl	MachineState+4,%eax	leal	-1(%edi),%edx	subl	MachineState+20,%edxD 15	leal	4(%edx),%edxE 15I 15	leal	3(%edx),%edxE 15	movw	%dx,-12(%eax)D 14	movl	-36(%ebp),%eaxE 14I 14D 15	movl	%ecx,%eaxE 14	movzwl	2(%eax),%eaxE 15I 15	movzwl	2(%ecx),%eaxE 15	leal	(%eax,%eax),%eax	movl	MachineState+32,%edx	subl	%eax,%edx	movl	%edx,MachineState+28	cmpl	%edx,%esi	jg	check_interruptI 15	xchg	%edi,%esi	movl	%edi,%eax	subl	$28,%eax	movl	%eax,MachineState	movl	%eax,-48(%ebp)	movl	MachineState+4,%eax	movl	-48(%ebp),%edx	subl	Stackspace,%edx	shrl	$1,%edx	movl	%edx,-44(%ebp)	movw	%dx,-10(%eax)	movl	%ebx,(%edi)	movw	(%ecx),%dx	addl	$4,%edi	testw	%dx,%dx	jl	.FN8noarg	movl	$8,%eax	movswl	(%ecx),%edx	subl	%edx,%eax	movl	%eax,-48(%ebp)	xorl	%eax,%eax	jmp	.FN8lps.FN8lp:	stosl	incl	-48(%ebp).FN8lps:	cmpl	$0,-48(%ebp)	jl	.FN8lpE 15	movl	-48(%ebp),%eax	leal	(,%eax,4),%eaxD 15	movl	%esi,%edxE 15I 15	subl	%eax,%edi.FN8noarg:	movl	-44(%ebp),%eax	orl	$-2147483648,%eax	stosl	movl	MachineState+4,%eax	subl	Stackspace,%eax	shrl	$1,%eax	orl	$-1073741824,%eax	movl	%eax,(%edi)	movl	-40(%ebp),%eax	rol	$16,%eax	movl	%eax,4(%edi)	addl	$20,%edi	movl	%edi,MachineState+4	movswl	6(%ecx),%eax	movl	%eax,-48(%ebp)	cmpl	$0,-48(%ebp)	jl	.FN1disp	movl	$-1,%eax	stosl	stosl	cmpl	$0,-48(%ebp)	jle	.FN1disp	stosl	stosl	decl	-48(%ebp).FN8xlp:	decl	-48(%ebp)	jl	.FN1disp	stosl	stosl	jmp	.FN8xlp.end.inline fast_FN9,0	leal	1(%edi),%edx	xorl	$3,%edx	movzbl	(%edx),%eax	leal	0(%edi),%edx	xorl	$3,%edx	movb	(%edx),%ah	movl	%eax,%ecx	leal	(,%eax,4),%eax	addl	Defspace,%eax	movl	(%eax),%edx	testl	%edx,%edx	jl	.FN9ccode	movl	%eax,-12(%ebp)	movl	$9,-24(%ebp)	movl	$3,-20(%ebp)	movl	%ecx,-16(%ebp)	movl	$0,-28(%ebp)	jmp	fn_common.FN9ccode:	cld			// so string ops work upward.	andl	$16777215,%edx	movl	%edx,-40(%ebp)	leal	(%edx,%edx),%ecx	addl	Lisp_world,%ecx	movl	MachineState+4,%eax	leal	-1(%edi),%edx	subl	MachineState+20,%edx	leal	3(%edx),%edx	movw	%dx,-12(%eax)	movzwl	2(%ecx),%eax	leal	(%eax,%eax),%eax	movl	MachineState+32,%edxE 15	subl	%eax,%edxD 15	leal	4(%edx),%edx	movl	%edx,MachineState	movl	%edx,-52(%ebp)E 15I 15	movl	%edx,MachineState+28	cmpl	%edx,%esi	jg	check_interrupt	xchg	%edi,%esi	movl	%edi,%eax	subl	$32,%eax	movl	%eax,MachineState	movl	%eax,-48(%ebp)E 15	movl	MachineState+4,%eaxD 15	movl	-52(%ebp),%edxE 15I 15	movl	-48(%ebp),%edxE 15	subl	Stackspace,%edx	shrl	$1,%edx	movl	%edx,-44(%ebp)	movw	%dx,-10(%eax)D 15	movl	%ebx,(%esi)D 14	movl	-36(%ebp),%eaxE 14I 14	movl	%ecx,%eaxE 14	movw	(%eax),%dx	addl	$4,%esiE 15I 15	movl	%ebx,(%edi)	movw	(%ecx),%dx	addl	$4,%ediE 15	testw	%dx,%dxD 15	jl	.L265	movswl	(%eax),%eax	movl	-48(%ebp),%edx	subl	%eax,%edx	movl	%edx,-52(%ebp)	jmp	.L266..6:	movl	$0,(%esi)	addl	$4,%esi	incl	-52(%ebp).L266:	cmpl	$0,-52(%ebp)	jl	..6	movl	-52(%ebp),%eaxE 15I 15	jl	.FN9noarg	movl	$9,%eax	movswl	(%ecx),%edx	subl	%edx,%eax	movl	%eax,-48(%ebp)	xorl	%eax,%eax	jmp	.FN9lps.FN9lp:	stosl	incl	-48(%ebp).FN9lps:	cmpl	$0,-48(%ebp)	jl	.FN9lp	movl	-48(%ebp),%eaxE 15	leal	(,%eax,4),%eaxD 15	subl	%eax,%esi.L265:	movl	%esi,%eax	movl	-44(%ebp),%edx	addl	$4,%esi	orl	$-2147483648,%edx	movl	%edx,(%eax)E 15I 15	subl	%eax,%edi.FN9noarg:	movl	-44(%ebp),%eax	orl	$-2147483648,%eax	stoslE 15	movl	MachineState+4,%eax	subl	Stackspace,%eax	shrl	$1,%eax	orl	$-1073741824,%eaxD 15	movl	%eax,(%esi)E 15I 15	movl	%eax,(%edi)E 15	movl	-40(%ebp),%eaxD 15	movl	(%eax),%eax	andl	$16777215,%eax	pushl	%eax	movl	0(%esp),%eaxE 15	rol	$16,%eaxD 15	popl	%ecx	movl	%eax,4(%esi)	addl	$20,%esi	movl	%esi,MachineState+4D 14	movl	-36(%ebp),%eaxE 14I 14	movl	%ecx,%eaxE 14	movswl	6(%eax),%eax	movl	%eax,-52(%ebp)	cmpl	$0,-52(%ebp)	jl	.L268	movl	$-1,-56(%ebp)	movl	%esi,%eax	movl	-56(%ebp),%edx	movl	%edx,(%eax)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esi	cmpl	$0,-52(%ebp)	jle	.L269	movl	%edx,(%esi)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esi	decl	-52(%ebp).L272:	decl	-52(%ebp)	jl	.L271	movl	%esi,%eax	movl	-56(%ebp),%edx	movl	%edx,(%eax)	addl	$4,%esi	movl	%edx,(%esi)	addl	$4,%esi	jmp	.L272E 15I 15	movl	%eax,4(%edi)	addl	$20,%edi	movl	%edi,MachineState+4	movswl	6(%ecx),%eax	movl	%eax,-48(%ebp)	cmpl	$0,-48(%ebp)	jl	.FN1disp	movl	$-1,%eax	stosl	stosl	cmpl	$0,-48(%ebp)	jle	.FN1disp	stosl	stosl	decl	-48(%ebp).FN9xlp:	decl	-48(%ebp)	jl	.FN1disp	stosl	stosl	jmp	.FN9xlpE 15.endI 15E 15////////////////////////////////////////////////////////		assembler label definitions////////////////////////////////////////////////////.inline	asm_label_check_interrupt,0check_interrupt:.end.inline	asm_label_op_fn_common,0op_fn_common:.endE 12E 7E 4E 3E 2E 1