h48443s 00043/00023/00596d D 1.6 93/02/08 14:52:23 sybalsky 6 5c Big VM (and new CDR coding) changes for 3.0 \nes 00003/00003/00616d D 1.5 92/04/21 17:13:19 sybalsky 5 4c shortening file names for DOS \nes 00201/00042/00418d D 1.4 91/03/07 19:41:30 sybalsky 4 3c Add more debugging info to bad-array-block-reclaimed msgs, if ARRAYCHECK is -D.es 00002/00001/00458d D 1.3 90/06/15 16:54:15 mitani 3 2c REC_GCLOOKUPes 00001/00003/00458d D 1.2 90/04/20 01:35:44 sybalsky 2 1c AIX:  shortening file names, bulk change.es 00461/00000/00000d D 1.1 90/04/19 23:18:52 sybalsky 1 0c date and time created 90/04/19 23:18:52 by sybalskyeuUf e 0tTI 1D 6/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 6I 6/* %Z% %M% Version %I% (%G%). copyright venue  */static char *id = "%Z% %M%	%I% %G%	(venue)";E 6D 2/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 2I 6E 6/************************************************************************//*									*/D 4/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 4I 4D 6/*	(C) Copyright 1989, 1990 Venue.  All Rights Reserved.		*/E 6I 6/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 6E 4/*									*/D 4/*	This file is work-product resulting from the Xerox/Venue	*/E 4I 4D 6/*	This file was work-product resulting from the Xerox/Venue	*/E 4/*	Agreement dated 18-August-1989 for support of Medley.		*/E 6I 6/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 6/*									*//************************************************************************//*************************************************************************//*************************************************************************/D 4/*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 *//*************************************************************************/E 4/*                                                                       */D 2/*                       File Name : gcfinalfuncs.c                      */E 2I 2/*                       File Name : gcfinal.c                      */E 2/*                                                                       *//*************************************************************************//*                                                                       */D 6/*                      Creation Date : Sep-25-1987                      *//*                      Written by Tomoru Teruuchi                       */E 6/*                                                                       */D 6/*************************************************************************//*                                                                       */E 6/*           Functions :                                                 *//*                       reclaimstackp();                                *//*                       reclaimarrayblock(ptr);                         *//*                       reclaimcodeblock() is in another file           *//*                       releasingvmempage();                            *//*			 deleteblock();					 *//*			 linkblock();					 *//*			 mergeforward();				 *//*			 mergebackward();				 *//*			 arrayblockmerger();				 *//*			 checkarrayblock();				 *//*			 findptrsbuffer();				 *//*                                                                       *//*                                                                       *//*                                                                       *//*************************************************************************//*           Description :                                               *//*                                                                       *//*  									 *//*                                                                       *//*************************************************************************//*                                                               \Tomtom *//*************************************************************************/#include "lispemul.h"D 5#include "lisptypes.h"E 5I 5#include "lsptypes.h"E 5#include "address.h"D 5#include "address68k.h"#include "lispglobal.h"E 5I 5#include "adr68k.h"#include "lspglob.h"E 5#include "stack.h"#include "cell.h"#include "ifpage.h"#include "gc.h"#include "array.h"D 6#define GetSegnuminColl(entry1) ((entry1 & 0x01fe) >> 1)E 6I 6#ifdef NEVER#define GetSegnuminColl(entry1) ((entry1 & 0x01fe) >> 1) /* segnum field */E 6#define GetLinkptr(entry)	(entry & 0x0fffe)#define GetCountinColl(entry1)  ((entry1 & 0x0fc00) >> 10)#define Oddp(num) (((num % 2) != 0)?1:0)#define Evenp(num) 		(((num % 2) != 0)?0:1)#define STK_HI		1	/* This value also */#define WORDSPERCELL	2#define PADDING	4#define Boundp(frame_field)	((frame_field == 0)?1:0)I 6#endif /* NEVER */E 6I 6E 6#define min(a,b)		((a > b)?b:a)#define Trailer(ldatum,datum68)	(ldatum+2*(datum68->arlen - \					ARRAYBLOCKTRAILERCELLS))#define BucketIndex(n)		min(integerlength(n),MAXBUCKETINDEX)D 6#define FreeBlockChainN(n)	((0xffffff & *FreeBlockBuckets_word)+ \E 6I 6#define FreeBlockChainN(n)	((POINTERMASK & *FreeBlockBuckets_word)+ \E 6					2*BucketIndex(n))#ifndef BYTESWAPI 6#ifdef BIGVME 6struct buf {	LispPTR		filepage;	LispPTR		vmempage;	LispPTR		buffernext;	unsigned	noreference :1;	unsigned	usermapped :1;	unsigned	iodirty :1;I 6	unsigned	unused :1;	unsigned	sysnext :28;};#elsestruct buf {	LispPTR		filepage;	LispPTR		vmempage;	LispPTR		buffernext;	unsigned	noreference :1;	unsigned	usermapped :1;	unsigned	iodirty :1;E 6	unsigned	unused :5;	unsigned	sysnext :24;};I 6#endif /* BIGVM */E 6#elsestruct buf {	LispPTR		filepage;	LispPTR		vmempage;	LispPTR		buffernext;	unsigned	sysnext :24;	unsigned	unused :5;	unsigned	iodirty :1;	unsigned	usermapped :1;	unsigned	noreference :1;};D 6#endif BYTESWAPE 6I 6#endif /* BYTESWAP */E 6I 6E 6/************* The following procedure is common !! **************************/integerlength(n)unsigned int	n;{int	cnt;   if (n <= 2)	return(n);   else     {cnt = 1;      do    	{cnt++;	 n = (n >> 1);	}while(n != 1);      return(cnt);     };}/************* The above procedure is common !! **************************//************************************************************************//*									*//*			f i n d p t r s b u f f e r			*//*									*//*	Given a pointer to a VMEMPAGEP, see if it is pointed to by	*//*	any BUFFER.  If so, return the BUFFER's pointer. Otherwise,	*//*	return NIL.							*//*									*//************************************************************************/LispPTR findptrsbuffer(ptr)LispPTR		ptr;{ struct buf *bptr;	bptr = (struct buf *)Addr68k_from_LADDR(*System_Buffer_List_word);	while(LADDR_from_68k(bptr) != NIL)	  {if (ptr == bptr->vmempage)		return(LADDR_from_68k(bptr));	   else bptr = (struct buf *)Addr68k_from_LADDR(bptr->sysnext);};	return(NIL);}/************************************************************************//*									*//*		    r e l e a s i n g v m e m p a g e			*//*									*//*	Called when ptr, a VMEMPAGEP, is about to be reclaimed by the	*//*	GC.  Returns T if it is NOT OK TO RECLAIM THE VMEMPAGEP.	*//*	Otherwise, returns NIL.  It won't be OK to reclaim when		*//*	the VMEMPAGEP is being used as a buffer.			*//*									*//************************************************************************/LispPTR releasingvmempage(ptr)  LispPTR ptr;  {     register struct buf *bptr;    register LispPTR bufferptr = findptrsbuffer(ptr);    if (bufferptr == NIL) return(NIL); /* Not in use, OK to reclaim it */    bptr = (struct buf *)Addr68k_from_LADDR(bufferptr);    bptr->noreference = T; /* Mark the buffer free to use ?? */    return(ATOM_T);  }/************************************************************************//*									*/I 4/*		      c h e c k a r r a y b l o c k			*/E 4/*									*/I 4/*	Given an array block, do consistency checks on it.		*/E 4/*									*/D 4/*									*//*									*/E 4/************************************************************************/LispPTR checkarrayblock(base,free,onfreelist)LispPTR		base;LispPTR		free;LispPTR		onfreelist;{struct arrayblock 	*bbase, *btrailer; struct arrayblock	*bfwd, *bbwd, *rbase; LispPTR		fbl; LispPTR		*rover, *tmprover;D 4#ifdef CHECKE 4I 4#ifdef ARRAYCHECKE 4   if (T)#else   if (*Array_Block_Checking_word != NIL)#endifD 4	{bbase = (struct arrayblock *)Addr68k_from_LADDR(base);E 4I 4      {	bbase = (struct arrayblock *)Addr68k_from_LADDR(base);E 4	 btrailer=(struct arrayblock *)Addr68k_from_LADDR(Trailer(base,bbase));	 bfwd = (struct arrayblock *)Addr68k_from_LADDR(bbase->fwd);	 bbwd = (struct arrayblock *)Addr68k_from_LADDR(bbase->bkwd);	 if (bbase->password != ARRAYBLOCKPASSWORD)D 4		error("ARRAYBLOCK password wrong\n");E 4I 4	  {	    printarrayblock(base);	    error("ARRAYBLOCK password wrong\n");	  }E 4	 else if (bbase->inuse == free)D 4		error("ARRAYBLOCK INUSE bit set wrong\n");E 4I 4	  {	    printarrayblock(base);	    error("ARRAYBLOCK INUSE bit set wrong\n");	  }E 4	 else if (btrailer->password != ARRAYBLOCKPASSWORD)D 4		error("ARRAYBLOCK trailer password wrong\n");E 4I 4	  {	    printarrayblock(base);	    error("ARRAYBLOCK trailer password wrong\n");	  }E 4	 else if (bbase->arlen != btrailer->arlen)D 4		error("ARRAYBLOCK Header and Trailer length don't match\n");E 4I 4	  {	    printarrayblock(base);	    error("ARRAYBLOCK Header and Trailer length don't match\n");	  }E 4	 else if (btrailer->inuse == free)			/* This is not original source.(in original, 			   btrailer -> bbase) maybe, this is correction. */D 4		error("ARRAYBLOCK Trailer INUSE bit set wrong\n");E 4I 4	  {	    printarrayblock(base);	    error("ARRAYBLOCK Trailer INUSE bit set wrong\n");	  }E 4	 else if (!onfreelist || (bbase->arlen < MINARRAYBLOCKSIZE))			/* Remaining tests only for free list. */		return(NIL);	 else if ((bbwd->fwd != base) || (bfwd->bkwd != base))D 4		error("ARRAYBLOCK links fouled\n");E 4I 4	  {	    error("ARRAYBLOCK links fouled\n");	  }E 4	 else	   {fbl = FreeBlockChainN(bbase->arlen);	    rover = tmprover = (LispPTR *)Addr68k_from_LADDR(fbl);			/* GETBASEPTR */D 6	    if ((*rover & 0x0ffffff) == NIL)E 6I 6	    if ((*rover & POINTERMASK) == NIL)E 6		error("Free Block's bucket empty\n");	    doD 6		{if ((*rover & 0x0ffffff) == base)E 6I 6		{if ((*rover & POINTERMASK) == base)E 6			return(NIL);D 6		 checkarrayblock((*rover & 0x0ffffff), T, NIL);E 6I 6		 checkarrayblock((*rover & POINTERMASK), T, NIL);E 6		 rbase = (struct arrayblock *)Addr68k_from_LADDR(D 6						*rover & 0x0ffffff);		}while(((*rover = rbase->fwd)& 0x0ffffff) != 						(*tmprover & 0x0ffffff));E 6I 6						*rover & POINTERMASK);		}while(((*rover = rbase->fwd)& POINTERMASK) != 						(*tmprover & POINTERMASK));E 6	    return(NIL);	   }; 	};   return(NIL);}I 4/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 4LispPTR deleteblock(base)LispPTR		base;{  struct arrayblock 	*bbase, *fbbase, *bbbase;   LispPTR		fwd,bkwd,fbl,freeblocklsp;   LispPTR		*freeblock;   bbase = (struct arrayblock *)Addr68k_from_LADDR(base);   if ((bbase->arlen >= MINARRAYBLOCKSIZE) && (bbase->fwd != NIL))	{fwd = bbase->fwd;	 fbbase = (struct arrayblock *)Addr68k_from_LADDR(fwd);	 bkwd = bbase->bkwd;	 bbbase = (struct arrayblock *)Addr68k_from_LADDR(bkwd);	 fbl = FreeBlockChainN(bbase->arlen);	 freeblock = (LispPTR *)Addr68k_from_LADDR(fbl);D 6	 freeblocklsp = 0xffffff & *freeblock;E 6I 6	 freeblocklsp = POINTERMASK & *freeblock;E 6	 if (base == fwd)	   {if (base == freeblocklsp)		*freeblock = NIL;		    else error("GC error:deleting last list # FREEBLOCKLIST\n");	    return(NIL);	   }         else	   if (base == freeblocklsp)		*freeblock = fwd;	fbbase->bkwd = bkwd;	bbbase->fwd  = fwd;	}   return(NIL);}I 4/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 4LispPTR linkblock(base)LispPTR		base;{  struct arrayblock 	*bbase,*fbbase,*tmpbase;   LispPTR 		fbl,freeblocklsp;   LispPTR		*freeblock;   if (*FreeBlockBuckets_word != NIL) 	{ bbase = (struct arrayblock *)Addr68k_from_LADDR(base);	  if (bbase->arlen < MINARRAYBLOCKSIZE)		checkarrayblock(base, T, NIL);	  else	    {fbl = FreeBlockChainN(bbase->arlen);D 6	     freeblock = (LispPTR *)Addr68k_from_LADDR(0x0ffffff & fbl);	     freeblocklsp = 0x0ffffff & (*freeblock);E 6I 6	     freeblock = (LispPTR *)Addr68k_from_LADDR(POINTERMASK & fbl);	     freeblocklsp = POINTERMASK & (*freeblock);E 6	     if (freeblocklsp == NIL)		{bbase->fwd = base;		 bbase->bkwd = base;		}	     else		{fbbase = (struct arrayblock *)Addr68k_from_LADDR(freeblocklsp);		 bbase->fwd = freeblocklsp;		 bbase->bkwd = fbbase->bkwd;		 tmpbase = (struct arrayblock *)				Addr68k_from_LADDR(fbbase->bkwd);		 tmpbase->fwd = base;		 fbbase->bkwd = base;		};	     *freeblock = base;	     checkarrayblock(base, T, T);	    };	};	return(base);}I 4/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 4LispPTR makefreearrayblock(block, length)LispPTR		block;DLword		length;{ LispPTR		trailer;  struct arrayblock 	*bbase;  struct abdum		*dbase;   bbase = (struct arrayblock *)Addr68k_from_LADDR(block);   dbase = (struct abdum *)WORDPTR(bbase);   dbase->abflags = FREEARRAYFLAGWORD;   bbase->arlen   = length;   trailer = Trailer(block,bbase);    bbase = (struct arrayblock *)Addr68k_from_LADDR(trailer);   dbase = (struct abdum *)WORDPTR(bbase);   dbase->abflags = FREEARRAYFLAGWORD;   bbase->arlen   = length;   return(block);}I 4/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 4LispPTR arrayblockmerger(base, nbase)LispPTR		base, nbase;{   DLword arlens, narlens, secondbite, minblocksize, shaveback;    struct arrayblock 	*bbase, *bnbase;    bbase = (struct arrayblock *)Addr68k_from_LADDR(base);    bnbase = (struct arrayblock *)Addr68k_from_LADDR(nbase);    arlens = bbase->arlen;    narlens = bnbase->arlen;    secondbite = MAXARRAYBLOCKSIZE - arlens;    if (narlens > secondbite)	{arlens = MAXARRAYBLOCKSIZE;	 narlens = narlens - secondbite;	 minblocksize = ((*Hunk_word == ATOM_T) ? 			   (ARRAYBLOCKOVERHEADCELLS+MAXCELLSPERHUNK) : 			   MINARRAYBLOCKSIZE);	 if (narlens < minblocksize)	    {shaveback = narlens - minblocksize;	     narlens = minblocksize;	     arlens += shaveback;	     secondbite += shaveback;	    };	linkblock(makefreearrayblock(nbase+2*secondbite, narlens));	narlens = 0;	};    return(linkblock(makefreearrayblock(base, arlens+narlens)));}I 4/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 4LispPTR mergebackward(base)LispPTR 	base;{  LispPTR 		pbase;   struct arrayblock 	*ptrailer;    ptrailer = (struct arrayblock *)Addr68k_from_LADDR(base -					ARRAYBLOCKTRAILERWORDS);   if (base == NIL)	return(NIL);   else if ((*ArrayMerging_word == NIL) || ((base == *ArraySpace_word) || 	     ((base == *ArraySpace2_word) || (ptrailer->inuse == T))))	    return(linkblock(base));   pbase = base - 2*ptrailer->arlen;   checkarrayblock(pbase, T,NIL);   deleteblock(pbase);   return(arrayblockmerger(pbase, base));}I 4/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 4LispPTR mergeforward(base)LispPTR 	base;{   LispPTR	nbase, nbinuse;    struct arrayblock 	*bbase, *bnbase;    bbase = (struct arrayblock *)Addr68k_from_LADDR(base);    nbase = base + 2*(bbase->arlen);    bnbase = (struct arrayblock *)Addr68k_from_LADDR(nbase);    if ((*ArrayMerging_word == NIL) || ((base == NIL)	 || (checkarrayblock(base, T, T) || ((nbase == *ArrayFrLst_word) ||	 ((nbase == *ArrayFrLst2_word) || 	 (checkarrayblock(nbase, (! (nbinuse = bnbase->inuse)),NIL) || 	 nbinuse))))))	return(NIL);    deleteblock(nbase);    deleteblock(base);    return(arrayblockmerger(base, nbase));}D 4LispPTR reclaimarrayblock(ptr)LispPTR ptr;{ LispPTR		tmpptr, btrailer;  struct arrayblock 	*base;  LispPTR		*tmpp;  int			reclaim_p;E 4D 4     reclaim_p = T;#ifdef CHECK     checkarrayblock(ptr-ARRAYBLOCKHEADERWORDS, NIL, NIL);#endif     base = (struct arrayblock *)Addr68k_from_LADDR(ptr-ARRAYBLOCKHEADERWORDS);E 4D 4     if ((HILOC(ptr) < FIRSTARRAYSEGMENT) ||E 4I 4/************************************************************************//*									*//*		    r e c l a i m a r r a y b l o c k			*//*									*//*	Reclaim a block of storage in the array-space heap.		*//*									*//************************************************************************/LispPTR reclaimarrayblock(ptr)  LispPTR ptr;  { LispPTR		tmpptr, btrailer;    struct arrayblock 	*base;    LispPTR		*tmpp;    int			reclaim_p;    reclaim_p = T;#ifdef ARRAYCHECK    checkarrayblock(ptr-ARRAYBLOCKHEADERWORDS, NIL, NIL);D 6#endif ARRAYCHECKE 6I 6#endif /* ARRAYCHECK */E 6    base = (struct arrayblock *)Addr68k_from_LADDR(ptr-ARRAYBLOCKHEADERWORDS);#ifdef ARRAYCHECK    if (HILOC(ptr) < FIRSTARRAYSEGMENT)      {	printarrayblock(ptr-ARRAYBLOCKHEADERWORDS);	error("Bad array block reclaimed [not in array space].\nContinue with 'q' but save state ASAP. \n");	return(T);      }     else if (ARRAYBLOCKPASSWORD != base->password)      {	printarrayblock(ptr-ARRAYBLOCKHEADERWORDS);	error("Bad array block reclaimed [password wrong].\nContinue with 'q' but save state ASAP. \n");	return(T);      }     else if (base->inuse == NIL)      {	printarrayblock(ptr-ARRAYBLOCKHEADERWORDS);	error("Bad array block reclaimed [block not in use].\nContinue with 'q' but save state ASAP. \n");	return(T);      } #else    /* Normal case, just tell the guy something's wrong: */    if ((HILOC(ptr) < FIRSTARRAYSEGMENT) ||E 4	   ((ARRAYBLOCKPASSWORD != base->password) ||	    (base->inuse == NIL)))D 4	   {error(          "Bad array block reclaimed--continue with 'Q' but save state ASAP. \n");	    return(T);	   }; E 4I 4      {	error("Bad array block reclaimed--continue with 'q' but save state ASAP. \n");	return(T);      };D 6#endif ARRAYCHECKE 6I 6#endif /* ARRAYCHECK */E 6E 4D 4     switch(base->gctype)E 4I 4    switch(base->gctype)E 4	  {	   case PTRBLOCK_GCT:		{btrailer = (ptr-2)+2*(base->arlen - ARRAYBLOCKTRAILERCELLS);		 tmpptr = ptr;		 do		   {		    tmpp = (LispPTR *)Addr68k_from_LADDR(tmpptr);D 3		    GCLOOKUP(0x8000,DELREF, *tmpp); /* added 8-Oct-87 TT */E 3I 3		    /* GCLOOKUP(0x8000,DELREF, *tmpp);*/ /* added 8-Oct-87 TT */		    REC_GCLOOKUP(*tmpp, DELREF);E 3		    *tmpp = NIL;		    tmpptr += 2;		   } while (tmpptr != btrailer);		 break;			};	   case CODEBLOCK_GCT:		reclaim_p = ((reclaimcodeblock(ptr) == NIL)?T:NIL);        /* default:   No Action */	  };     if (reclaim_p == T)	mergeforward(mergebackward(makefreearrayblock(						ptr-ARRAYBLOCKHEADERWORDS							,base->arlen)));D 4     return(T);}E 4I 4    return(T);  }E 4I 4/************************************************************************//*									*//*		      r e c l a i m s t a c k p				*//*									*//*	Reclaim a STACKP, which contains a stack pointer.		*//*									*//************************************************************************/E 4LispPTR reclaimstackp (ptr)		/* This is the entry function */D 4LispPTR		ptr;			/*  in stack reclaiming */{ register STACKP *stkp; register FX	*fxp; stkp = (STACKP*)Addr68k_from_LADDR(ptr); fxp = (FX*)Addr68k_from_StkOffset( stkp->edfxp ); decusecount68k(fxp); return(NIL);}E 4I 4  LispPTR ptr;				/*  in stack reclaiming */  {    register STACKP *stkp;    register FX	*fxp;    stkp = (STACKP*)Addr68k_from_LADDR(ptr);    fxp = (FX*)Addr68k_from_StkOffset( stkp->edfxp );    decusecount68k(fxp); /* decrement the use-count for the frame it uses */    return(NIL);	 /* and let the normal reclaimer reclaim it */  }E 4I 4/************************************************************************//*									*//*			p r i n t a r r a y b l o c k			*//*									*//*	Print an array block's contents, for debugging work.		*//*									*//************************************************************************/printarrayblock(base)  LispPTR base;  {    struct arrayblock 	*bbase, *btrailer, *ptrailer;    struct arrayblock	*bfwd, *bbwd, *rbase;    LispPTR		*addr, *tmprover;    LispPTR pbase, nbase;    bbase = (struct arrayblock *)Addr68k_from_LADDR(base);    btrailer=(struct arrayblock *)Addr68k_from_LADDR(Trailer(base,bbase));    ptrailer=(struct arrayblock *)Addr68k_from_LADDR(base-ARRAYBLOCKTRAILERWORDS);    bfwd = (struct arrayblock *)Addr68k_from_LADDR(bbase->fwd);    bbwd = (struct arrayblock *)Addr68k_from_LADDR(bbase->bkwd);    nbase = base + 2*bbase->arlen;    pbase = base - 2*ptrailer->arlen;    printf("This array block: 0x%x.  Previous: 0x%x.  Next: 0x%x.\n",	   base, pbase, nbase);    printf("          Length: %d cells.\n\n", bbase->arlen);    addr = ((LispPTR *) bbase) - 20;    for (;addr<(LispPTR *)bbase; addr++)      printf("0x%x	%8x\n", addr, *addr);    printf("0x%x	%8x <- array header\n", addr, *addr++);    for (; addr < (LispPTR *) bbase + 20; addr++)      printf("0x%x	%8x\n", addr, *addr);    printf(". . .\n");    addr = ((LispPTR *) btrailer) - 20;    for (;addr<(LispPTR *)btrailer; addr++)      printf("0x%x	%8x\n", addr, *addr);    printf("0x%x	%8x <- array trailer\n", addr, *addr++);    for (; addr < (LispPTR *) btrailer + 20; addr++)      printf("0x%x	%8x\n", addr, *addr);  }E 4E 1