h28127s 00000/00000/00151d D 1.10 93/02/08 14:41:55 sybalsky 10 9c Big VM (and new CDR coding) changes for 3.0 \nes 00004/00002/00147d D 1.9 92/05/27 19:11:33 sybalsky 9 8c fixing SCCS headers \nes 00006/00006/00143d D 1.8 92/04/27 18:38:57 nilsson 8 7c Fix of Xdisplay deps.es 00000/00000/00149d D 1.7 92/04/21 16:57:50 sybalsky 7 6c shortening file names for DOS \nes 00055/00016/00094d D 1.6 90/11/09 17:17:48 gadener 6 5c Merging of Bob Banes Code /Matsudaes 00061/00043/00049d D 1.5 90/10/23 18:22:04 gadener 5 4c Fixes crash after a week bug in X-versiones 00044/00026/00048d D 1.4 90/09/18 23:28:02 sybalsky 4 3c Retrofit changes from AIX, DEC3100, PS/2es 00000/00000/00074d D 1.3 90/08/30 10:27:27 sybalsky 3 2c nonees 00016/00006/00058d D 1.2 90/04/20 01:12:15 sybalsky 2 1c shortening file names, bulk change.es 00064/00000/00000d D 1.1 90/04/19 23:18:28 sybalsky 1 0c date and time created 90/04/19 23:18:28 by sybalskyeuUf e 0tTI 1D 5/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 5I 5D 6/* @(#) XCursor.c Version 1.2 (4/20/90). copyright venue & Fuji Xerox  */static char *id = "@(#) XCursor.c	1.2 4/20/90	(venue & Fuji Xerox)";E 6I 6/* @(#) XCursor.c Version 1.4 (9/18/90). copyright venue & Fuji Xerox  */static char *id = "@(#) XCursor.c	1.4 9/18/90	(venue & Fuji Xerox)";E 6E 5D 2/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 2I 2/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 2/**** Copyright (C) 1988 by Fuji Xerox co.,Ltd. All rights reserved.**		Author: Mitsunori Matsuda*		Date  : August 12, 1988*/#include <stdio.h>#include <X11/Xlib.h>#include <X11/Xutil.h>#include "lispemul.h"#include "iopage.h"I 4D 5#include "dbprint.h"E 5I 5#include "display.h"I 6#include "dbprint.h"E 6E 5E 4#include "XVersion.h"#include "MyWindow.h"extern IOPAGE   *IOPage;extern Display  *Xdisplay;extern MyWindow Lisp_Window;D 5Cursor LispCursor[2];int    cursor_sw;E 5D 6E 6I 5/* a simple linked list to remember X cursors */struct MXCURSOR {  struct MXCURSOR *next;  DLword bitmap[CURSORHEIGHT];  Cursor Xid;} *cursorlist = NULL;E 5I 4I 6/*Cursor LispCursor[2];int    cursor_sw;*//************************************************************************//*									*//*			I n i t _ X C u r s o r				*//*									*//*	Initial setup for X cursor handling--create an initial		*//*	cursor, and get it displayed.					*//*									*//************************************************************************/E 6D 5/************************************************************************//*									*//*			I n i t _ X C u r s o r				*//*									*//*	Initial setup for X cursor handling--create an initial		*//*	cursor, and get it displayed.					*//*									*//************************************************************************/E 5E 4D 2Init_DisplayCursor()E 2I 2Init_XCursor()E 2D 4{#ifdef TRACE	printf( "TRACE: Init_DisplayCusrosr()\" );#endif	cursor_sw = 0;	set_Xcursor( (char*) (IOPage->dlcursorbitmap)			, 0, 0, &LispCursor[cursor_sw] );	DefineCursor( &Lisp_Window			, &LispCursor[cursor_sw] );	cursor_sw += 1;E 4I 4D 5  {    TPRINT(( "TRACE: Init_DisplayCursor()\n" ));    cursor_sw = 0;    set_Xcursor( (char*) (IOPage->dlcursorbitmap)		 , 0, 0, &LispCursor[cursor_sw], 1 );    DefineCursor( &Lisp_Window, &LispCursor[cursor_sw] );    cursor_sw += 1;E 5I 5D 6{E 6I 6  {E 6  int i;  DLword *newbm = (DLword *) (IOPage->dlcursorbitmap);E 5E 4D 2} /* end Init_DisplayCursor */E 2I 2D 4} /* end Init_XCursor */E 4I 4D 5  } /* end Init_XCursor */E 5I 5D 6#ifdef TRACE  printf( "TRACE: Init_DisplayCusrosr()\n" );#endifE 6I 6    TPRINT(( "TRACE: Init_DisplayCursor()\n" ));/*    cursor_sw = 0;D 8    set_Xcursor( (char*) (IOPage->dlcursorbitmap)E 8I 8    set_Xcursor( Xdisplay, (char*) (IOPage->dlcursorbitmap)E 8		 , 0, 0, &LispCursor[cursor_sw], 1 );    DefineCursor( &Lisp_Window, &LispCursor[cursor_sw] );    cursor_sw += 1;*/E 6E 5E 4E 2I 5  /* this is guaranteed to be our first cursor, isn't it? */  cursorlist = (struct MXCURSOR *) malloc(sizeof(struct MXCURSOR));  cursorlist->next = NULL;  for(i=0; i<CURSORHEIGHT; i++)    cursorlist->bitmap[i] = newbm[i];D 8  set_Xcursor(newbm, 0, 0, &(cursorlist->Xid));  DefineCursor(&Lisp_Window, &(cursorlist->Xid));E 8I 8D 9  set_Xcursor( Xdisplay, newbm, 0, 0, &(cursorlist->Xid));E 9I 9  set_Xcursor( Xdisplay, newbm, 0, 0, &(cursorlist->Xid), 1);E 9  DefineCursor(Xdisplay, &Lisp_Window, &(cursorlist->Xid));E 8  D 6} /* end Init_XCursor */E 6I 6  } /* end Init_XCursor */E 6E 5I 4I 6/************************************************************************//*									*//*			S e t _ X C u r s o r				*//*									*//*	Set the X cursor from the Lisp bitmap, and move it to (x, y).	*//*									*//************************************************************************/E 6I 5Set_XCursor( x, y )D 6int x  , y;{E 6I 6  int x, y;  {/*    Cursor *old_cursor;*/E 6  /* compare cursor in IOPage memory with cursors we've seen before */  register struct MXCURSOR *clp, *clbp;  register DLword *newbm = ((DLword *) (IOPage->dlcursorbitmap));  register int i;E 5I 5D 6#ifdef TRACE	printf( "TRACE: Set_DisplayCusrosr()\n" );#endifE 6I 6    TPRINT(( "TRACE: Set_DisplayCursor()\n" ));/*    old_cursor = Lisp_Window.cursor;E 6E 5I 6D 8    set_Xcursor( (char*) (IOPage->dlcursorbitmap)E 8I 8    set_Xcursor( Xdisplay, (char*) (IOPage->dlcursorbitmap)E 8		 , 0, 0, &LispCursor[cursor_sw], 1 );    DefineCursor( &Lisp_Window, &LispCursor[cursor_sw] );    XFreeCursor( Xdisplay, *old_cursor );    cursor_sw = cursor_sw ? 0 : 1;*/I 9  XLOCK;	/* No signals while setting the cursor */E 9E 6D 5/************************************************************************//*									*//*			S e t _ X C u r s o r				*//*									*//*	Set the X cursor from the Lisp bitmap, and move it to (x, y).	*//*									*//************************************************************************/E 5I 5  for(clp = cursorlist; clp != NULL; clbp = clp, clp = clp->next) {    for(i=0; i< CURSORHEIGHT; i++)      if(clp->bitmap[i] != newbm[i]) break;    if(i == CURSORHEIGHT) break;  }E 5E 4D 2Set_DisplayCursor( x, y )E 2I 2D 5Set_XCursor( x, y )E 2D 4int x  , y;{	Cursor *old_cursor;#ifdef TRACE	printf( "TRACE: Set_DisplayCusrosr()\" );#endif	old_cursor = Lisp_Window.cursor;E 4I 4  int x, y;  {    Cursor *old_cursor;    TPRINT(( "TRACE: Set_DisplayCursor()\n" ));    old_cursor = Lisp_Window.cursor;E 5I 5  if(clp == NULL) {    /* it isn't there, push on a new one */    clp = (struct MXCURSOR *) malloc(sizeof (struct MXCURSOR));    /* and fill it up with the current new cursor */    for(i=0; i< CURSORHEIGHT; i++)      clp->bitmap[i] = newbm[i];D 8    set_Xcursor(newbm, 0, 0, &(clp->Xid));E 8I 8D 9    set_Xcursor( Xdisplay, newbm, 0, 0, &(clp->Xid));E 9I 9    set_Xcursor( Xdisplay, newbm, 0, 0, &(clp->Xid), 1);E 9E 8    clp->next = cursorlist;    cursorlist = clp;  }  else    /* found it, move it to the front of the list       (this should reduce search time on the average by keeping       the popular cursors near the front of the list)       */    if(clp != cursorlist) {  /* don't move if it's already there */      clbp->next = clp->next;      clp->next = cursorlist;      cursorlist = clp;    }D 8    DefineCursor(&Lisp_Window, &(clp->Xid));E 8I 8    DefineCursor(Xdisplay, &Lisp_Window, &(clp->Xid));I 9    XUNLOCK;	/* Signals OK now */E 9E 8E 5E 4D 4	set_Xcursor( (char*) (IOPage->dlcursorbitmap)			, 0, 0, &LispCursor[cursor_sw] );	DefineCursor( &Lisp_Window			, &LispCursor[cursor_sw] );	XFreeCursor( Xdisplay, *old_cursor );E 4I 4D 5    set_Xcursor( (char*) (IOPage->dlcursorbitmap)		 , 0, 0, &LispCursor[cursor_sw], 1 );    DefineCursor( &Lisp_Window, &LispCursor[cursor_sw] );    XFreeCursor( Xdisplay, *old_cursor );E 5I 5D 6} /* end Set_XCursor */E 5E 4E 6I 6  } /* end Set_XCursor */E 6D 4	cursor_sw = cursor_sw ? 0 : 1;E 4I 4D 5    cursor_sw = cursor_sw ? 0 : 1;E 4D 2} /* end Set_DisplayCursor */E 2I 2D 4} /* end Set_XCursor */E 4I 4  } /* end Set_XCursor */E 5E 4E 2E 1