h26509s 00005/00005/00267d D 2.16 93/02/08 15:03:26 sybalsky 25 24c Big VM (and new CDR coding) changes for 3.0 \nes 00013/00013/00259d D 2.15 92/11/25 20:16:44 sybalsky 24 23c Fixing extra text in endifs => comment.\nes 00023/00000/00249d D 2.14 92/05/27 19:14:23 sybalsky 23 22c retrofit of 386 unix changes \nes 00000/00000/00249d D 2.13 92/04/21 16:21:23 sybalsky 22 21c shortening file names for DOSes 00013/00000/00236d D 2.12 90/06/04 10:02:46 sybalsky 21 20c reformat, copyrightes 00017/00002/00219d D 2.11 90/04/02 17:17:19 sybalsky 20 19c arith speedups for 386ies 00002/00001/00219d D 2.10 90/03/27 14:30:15 sybalsky 19 18c fp rounding fixes 00033/00001/00187d D 2.9 90/03/19 11:39:41 takeshi 18 17c N_Igees 00007/00007/00181d D 2.8 88/10/12 14:47:29 krivacic 17 16c new out-of-line interfacees 00001/00001/00187d D 2.7 88/06/16 08:58:35 charnley 16 15c added max negative conversion.es 00001/00001/00187d D 2.6 88/06/15 17:36:59 charnley 15 14c fixed bug in float to int conversion--caused excessive ufn's.es 00002/00002/00186d D 2.5 88/06/06 09:09:36 masinter 14 13c Fix N_GETNUMBER so that it works with array subscriptses 00018/00000/00170d D 2.4 88/06/03 09:54:06 masinter 13 12c Put back GetNumber (used by C_ONLY)es 00007/00020/00163d D 2.3 88/05/31 20:21:21 masinter 12 11c remove obsolete GetNumber (wrong UFN case), add FIXP_ FLOATP_VALUE idiomses 00007/00001/00176d D 2.2 88/05/25 11:38:12 krivacic 11 10c fix N_IGETNUMBER to do a range check when turning a float into an intes 00000/00000/00177d D 2.1 88/05/17 09:16:59 hayata 10 9c Version up to 2.1es 00026/00003/00151d D 1.9 88/05/16 11:40:03 krivacic 9 8c N_IGETNUMBER & N_IARITH_BODY_2es 00014/00000/00140d D 1.8 88/05/04 15:10:53 krivacic 8 7c add N_ARITH_BODY_1_UNSIGNEDes 00003/00000/00137d D 1.7 88/04/20 17:16:11 krivacic 7 6c Add break to ARITH_SWITCHes 00017/00000/00120d D 1.6 88/04/11 11:39:22 krivacic 6 5c ARITH_SWITCH macroes 00002/00002/00118d D 1.5 88/03/14 17:38:53 krivacic 5 4c bug fix in N_ARITH_SWITCHes 00001/00001/00119d D 1.4 88/03/13 13:16:25 hayata 4 3c Add SCCS key id (%Z%)es 00027/00004/00093d D 1.3 88/03/09 18:26:31 krivacic 3 2c Changed macroses 00061/00000/00036d D 1.2 88/03/09 15:41:49 krivacic 2 1c N_GETNUMBER, N_ARITH_SWITCH, N_ARITH_BODY_2 macros / fixeses 00036/00000/00000d D 1.1 88/02/23 18:35:00 hayata 1 0c date and time created 88/02/23 18:35:00 by hayataeuUtTI 1D 4/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 4I 4D 19/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 19I 19D 24/* This is G-file @(#) arith.h Version 2.9 (3/19/90). copyright Xerox & Fuji Xerox  */E 24I 24/* %Z% %M% Version %I% (%G%). copyright Venue  */E 24E 19E 4D 24/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 12 *	Auther	:	Takeshi ShimizuE 12I 12 *	Author	:	Takeshi ShimizuE 12 *			Hiroshi Hayata	 */E 24I 21I 24E 24/************************************************************************//*									*/D 24/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 24I 24/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 24/*									*/D 24/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 24I 24/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 24/*									*//************************************************************************/D 24E 24E 21#define	MAX_SMALL	65535		/* == 0x0000FFFF  */#define	MIN_SMALL	-65536		/* == 0xFFFF0000  */#define MAX_FIXP	2147483647	/* == 0x7FFFFFFF  */#define	MIN_FIXP	-2147483648	/* == 0x80000000  */D 25#define GetSmalldata(x)	(((0xFFFF0000 & x)==S_POSITIVE) ? (0xFFFF & x) : (((0xFFFF0000 & x)==S_NEGATIVE) ? (0xFFFF0000 | x) : error("Not smallp address")))E 25I 25#define GetSmalldata(x)	(((SEGMASK & x)==S_POSITIVE) ? (0xFFFF & x) : (((SEGMASK & x)==S_NEGATIVE) ? (0xFFFF0000 | x) : error("Not smallp address")))E 25#define GetSmallp(x)	((0xFFFF0000 & x) ? (((0xFFFF0000 & x)==0xFFFF0000) ? (S_NEGATIVE | (0xFFFF & x)) : error("Not Smallp data") ) : (S_POSITIVE | (0xFFFF & x)))/* arg sour is Lisp address, arg dest is a box to store the number */I 13#define	GetNumber(sour, dest){		\D 25		switch(0xFFFF0000 & sour){\E 25I 25		switch(SEGMASK & sour){\E 25		case S_POSITIVE:		\			dest = 0xFFFF & sour;	\			break;			\		case S_NEGATIVE:		\			dest = 0xFFFF0000 | sour;	\			break;			\		default:			\			if(GetTypeNumber( sour ) != TYPE_FIXP){	\				ufn(0xFF & (*PC));	\				return;		\			}			\			dest = *((int *)Addr68k_from_LADDR(sour));	\		}				\	}E 13D 12#define	GetNumber(sour, dest){		\		switch(0xFFFF0000 & sour){\		case S_POSITIVE:		\			dest = 0xFFFF & sour;	\			break;			\		case S_NEGATIVE:		\			dest = 0xFFFF0000 | sour;	\			break;			\		default:			\			if(GetTypeNumber( sour ) != TYPE_FIXP){	\				ufn(0xFF & (*PC));	\				return;		\			}			\			dest = *((int *)Addr68k_from_LADDR(sour));	\		}				\	}E 12I 2I 12#define FIXP_VALUE(dest) *((int *)Addr68k_from_LADDR(dest))E 12I 12#define FLOATP_VALUE(dest) *((float *)Addr68k_from_LADDR(dest))E 12#define N_GETNUMBER(sour, dest, label)					\D 3{		dest = sour;	 					\E 3I 3{		dest = sour;	/* access memory once */ 		\E 3D 25		switch(0xFFFF0000 & dest){				\E 25I 25		switch(SEGMASK & dest){				\E 25		case S_POSITIVE:					\D 14			dest = 0xFFFF & dest;				\E 14I 14			dest = 0xFFFF & (dest);				\E 14			break;						\		case S_NEGATIVE:					\D 14			dest = 0xFFFF0000 | dest;			\E 14I 14			dest = 0xFFFF0000 | (dest);			\E 14			break;						\		default:						\			if (GetTypeNumber( dest ) != TYPE_FIXP)		\				{ goto label; }				\D 12			dest = *((int *)Addr68k_from_LADDR(dest));	\E 12I 12			dest = FIXP_VALUE(dest);			\E 12		}							\}D 18E 18I 18#ifdef I386E 18I 9#define N_IGETNUMBER(sour, dest, label)					\{		dest = sour;	/* access memory once */ 		\D 25		switch(0xFFFF0000 & dest){				\E 25I 25		switch(SEGMASK & dest){				\E 25		case S_POSITIVE:					\			dest = 0xFFFF & dest;				\			break;						\		case S_NEGATIVE:					\			dest = 0xFFFF0000 | dest;			\			break;						\		default:						\			switch (GetTypeNumber( dest )) {		\			case TYPE_FIXP:					\D 12			  dest = *((int *)Addr68k_from_LADDR(dest));	\E 12I 12			  dest = FIXP_VALUE(dest);			\E 12			  break;					\			case TYPE_FLOATP:				\D 11			  dest = (int) *((float *)Addr68k_from_LADDR(dest));\E 11I 11			  {register float temp;				\D 12			   temp = *((float *)Addr68k_from_LADDR(dest));	\E 12I 12			   temp = FLOATP_VALUE(dest) ;			\I 18D 20			   I386Reset;							\E 20E 18E 12			   if (	(temp > ((float) 0x7fffffff)) ||	\D 15				(temp < -((float) 0x80000000)) )	\E 15I 15D 16				(temp < -((float) 0x7fffffff)) )	\E 16I 16				(temp < ((float) 0x80000000)) )		\E 16E 15				goto label;				\			   dest = (int) temp;				\I 19D 20			   I386Round;					\E 20E 19			   }						\E 11			  break;					\			default: goto label;				\			}						\			break;						\		}							\}I 18#else#define N_IGETNUMBER(sour, dest, label)					\{		dest = sour;	/* access memory once */ 		\D 25		switch(0xFFFF0000 & dest){				\E 25I 25		switch(SEGMASK & dest){				\E 25		case S_POSITIVE:					\			dest = 0xFFFF & dest;				\			break;						\		case S_NEGATIVE:					\			dest = 0xFFFF0000 | dest;			\			break;						\		default:						\			switch (GetTypeNumber( dest )) {		\			case TYPE_FIXP:					\			  dest = FIXP_VALUE(dest);			\			  break;					\			case TYPE_FLOATP:				\			  {register float temp;				\			   temp = FLOATP_VALUE(dest) ;			\			   if (	(temp > ((float) 0x7fffffff)) ||	\				(temp < ((float) 0x80000000)) )		\				goto label;				\			   dest = (int) temp;				\			   }						\			  break;					\			default: goto label;				\			}						\			break;						\		}							\}D 24#endif I386E 24I 24#endif /* I386 */E 24E 18I 24E 24E 9I 6#define ARITH_SWITCH(arg, result)					\	switch((int) arg & 0xFFFF0000){					\		case 0:							\			result = (S_POSITIVE | (int) arg);		\I 7			break;						\E 7		case 0xFFFF0000:					\			result = (S_NEGATIVE | (0xFFFF & (int) arg));	\I 7			break;						\E 7		default:{register LispPTR *wordp;			\			/* arg is FIXP, call createcell */		\			wordp = (LispPTR *) createcell68k(TYPE_FIXP);	\			*((int *)wordp) = (int) arg;			\			result = (LADDR_from_68k(wordp));		\I 7			break;						\E 7			}						\	}E 6I 3/* *******	NEED to See if this is faster than the N_ARITH_SWITCH macro	if( (MIN_FIXP <= result) && (result <= MAX_FIXP) ){		if(0 <= result){			if(result <= MAX_SMALL)				return(S_POSITIVE | result);			else{				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				return(LADDR_from_68k(wordp));			}		}else{			if(MIN_SMALL <= result)				return(S_NEGATIVE | (0xFFFF & result));			else{				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				return(LADDR_from_68k(wordp));			}		}/ 	}****** */I 6E 6E 3#define N_ARITH_SWITCH(arg)						\	switch(arg & 0xFFFF0000){					\		case 0:							\			return(S_POSITIVE | arg);			\		case 0xFFFF0000:					\			return(S_NEGATIVE | (0xFFFF & arg));		\D 3		default:						\E 3I 3D 5		default:{register DLword	*wordp;			\E 5I 5		default:{register LispPTR *wordp;			\E 5E 3			/* arg is FIXP, call createcell */		\D 5			wordp = createcell68k(TYPE_FIXP);		\E 5I 5			wordp = (LispPTR *) createcell68k(TYPE_FIXP);	\E 5			*((int *)wordp) = arg;				\			return(LADDR_from_68k(wordp));			\I 3			}						\E 3	}I 23	/* Used in ISC asm inlines in arithmetic, to defeat optimizer.	   with INLINE_ERROR_EXIT, we use asm jumps to avoid having	   one or the other eliminated as dead code. */#ifdef ISC#define INLINE_ARITH_SWITCH(arg,retlbl)					\	switch(arg & 0xFFFF0000){					\		case 0:							\			result=(S_POSITIVE | arg);			\			break;						\		case 0xFFFF0000:					\			result=(S_NEGATIVE | (0xFFFF & arg));		\			break;						\		default:{register LispPTR *wordp;			\			/* arg is FIXP, call createcell */		\			wordp = (LispPTR *) createcell68k(TYPE_FIXP);	\			*((int *)wordp) = arg;				\			result=(LADDR_from_68k(wordp));			\			}						\	}								\	asm("jmp " retlbl) D 24#endif ISCE 24I 24#endif /* ISC */E 24E 23D 9#define N_ARITH_BODY_2(a, b, error_addr, op)				\E 9I 9D 17#define N_IARITH_BODY_2(a, b, error_addr, op)				\E 17I 17#define N_IARITH_BODY_2(a, tos, op)					\E 17E 9{									\register int	arg1,arg2;						\D 3register DLword	*wordp;							\E 3									\D 9	N_GETNUMBER( a, arg1, do_ufn);					\	N_GETNUMBER( b, arg2, do_ufn);					\E 9I 9	N_IGETNUMBER( a, arg1, do_ufn);					\D 17	N_IGETNUMBER( b, arg2, do_ufn);					\E 17I 17	N_IGETNUMBER( tos, arg2, do_ufn);				\E 17E 9									\	arg1 = arg1 op arg2;						\									\	N_ARITH_SWITCH(arg1);						\									\D 17do_ufn:	ERROR_EXIT(error_addr);						\E 17I 17do_ufn:	ERROR_EXIT(tos);						\E 17}D 17#define N_ARITH_BODY_1(a, n, error_addr, op)				\E 17I 17#define N_ARITH_BODY_1(a, n, op)					\E 17{									\register int	arg1;							\D 3register DLword	*wordp;							\E 3									\	N_GETNUMBER( a, arg1, do_ufn);					\									\	arg1 = arg1 op n;						\									\N_ARITH_SWITCH(arg1);							\									\D 17do_ufn:	ERROR_EXIT(error_addr);						\E 17I 17do_ufn:	ERROR_EXIT(a);							\E 17}I 8D 17#define N_ARITH_BODY_1_UNSIGNED(a, n, error_addr, op)			\E 17I 17#define N_ARITH_BODY_1_UNSIGNED(a, n, op)				\E 17{									\register unsigned int	arg1;						\									\	N_GETNUMBER( a, arg1, do_ufn);					\									\	arg1 = arg1 op n;						\									\N_ARITH_SWITCH(arg1);							\									\D 17do_ufn:	ERROR_EXIT(error_addr);						\E 17I 17do_ufn:	ERROR_EXIT(a);							\E 17}I 20#ifdef I386	/*********************************************************/	/*							 */	/*  Macros for airthmetic operations, to let inline work */	/*							 */	/*********************************************************/#define iplus32(a,b) Xiplus32()#define plus32(a,b) Xplus32()#define iplus32n(a,b) Xiplus32n()#define sub32(a,b) Xsub32()#define isub32(a,b) Xisub32()#define sub32n(a,b) Xisub32n()#endifE 20E 8E 2E 1