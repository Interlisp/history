h05658s 00064/00021/00617d D 1.16 93/02/08 15:00:28 sybalsky 16 15c Big VM (and new CDR coding) changes for 3.0 \nes 00041/00003/00597d D 1.15 92/07/24 10:47:23 sybalsky 15 14c retrofit of SGI & DEC OSF1 changes \nes 00023/00018/00577d D 1.14 92/04/23 10:56:34 sybalsky 14 13c fixing SCCS headers \nes 00000/00000/00595d D 1.13 92/04/21 17:28:11 sybalsky 13 12c shortening file names for DOS \nes 00001/00001/00594d D 1.12 92/01/16 12:37:34 sybalsky 12 11c 386es 00070/00000/00525d D 1.11 91/10/15 18:28:17 sybalsky 11 10c ISC changeses 00013/00000/00512d D 1.10 91/09/13 15:39:47 sybalsky 10 9c Make it ANSI compatiblees 00015/00003/00497d D 1.9 91/07/05 17:45:30 sybalsky 9 8c make some RISCOS changes be SYSVSIGNALS changeses 00026/00014/00474d D 1.8 91/05/03 14:52:00 sybalsky 8 7c Lengthen longest string arg to CREATE-PROCESS-STREAM to 2048.es 00047/00003/00441d D 1.7 91/04/09 17:14:18 sybalsky 7 6c Retrofit first round of changes from MIPS porting centeres 00007/00019/00437d D 1.6 91/02/05 09:50:50 gadener 6 5c Removed a redundant unlink from fork_unix() /Naoyuki Mitanies 00016/00002/00440d D 1.5 91/01/27 12:20:53 sybalsky 5 4c Retrofit HP9000/RS6000 changeses 00021/00008/00421d D 1.4 90/09/18 23:50:13 sybalsky 4 3c Retrofit changes from AIX, DEC3100, PS/2es 00018/00010/00411d D 1.3 90/07/26 11:31:25 sybalsky 3 2c Change includes to only use termios if we're on OS4.es 00001/00004/00420d D 1.2 90/07/03 18:06:43 sybalsky 2 1c New file (to make forked process smaller); change copyright.es 00424/00000/00000d D 1.1 90/07/03 18:04:44 sybalsky 1 0c date and time created 90/07/03 18:04:44 by sybalskyeuUf e 0tTI 1D 6/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 6I 6/* @(#) unixfork.c Version 1.4 (9/18/90). copyright venue & Fuji Xerox  */static char *id = "@(#) unixfork.c	1.4 9/18/90	(venue & Fuji Xerox)";I 10/************************************************************************//*									*//*		Code to fork a subprocess for Unix communication	*//*									*//*									*//*									*//************************************************************************/E 10E 6D 14/*Unix Interface Communications Subprocess Code*/I 9E 14E 9/************************************************************************//*									*/D 2/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 2I 2D 9/*	Copyright 1989, 1990 Venue.  All Rights Reserved		*/E 9I 9D 14/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*/E 14I 14/*	(C) Copyright 1989-1992 Venue. All Rights Reserved.		*/E 14/*	Manufactured in the United States of America.			*/E 9E 2/*									*/I 9/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*/E 9/************************************************************************/I 14#ifdef OS4#define USETERMIOS#endif#ifdef INDIGO#define USETERMIOS#define TCSETS TCSETA#define TCGETS TCGETA#endifE 14I 9I 16#include <sys/ioctl.h>E 16D 14E 9D 3#ifdef HPE 3I 3#ifndef OS4E 14I 14#ifndef USETERMIOSE 14E 3#include <sys/ioctl.h>D 3#endif#include <stdio.h>E 3I 3#elseI 15#ifdef INDIGO#include <termios.h>#elseE 15E 3#include <sys/termios.h>I 15#endif /* INDIGO */E 15I 3D 14#endif OS4E 14I 14D 16#endif USETERMIOSE 16I 16#endif /* USETERMIOS */E 16E 14I 7I 16E 16I 15#ifdef OSF1#include <sys/resource.h>#endif /* OSF1 */E 15#ifdef HPUX#include <sgtty.h>#include <unistd.h>D 16#endif HPUXE 16I 16#endif /* HPUX */E 16#ifdef RISCOS#include <sgtty.h>#endifE 7I 5D 6#ifdef HPUX#include <sgtty.h>#include <unistd.h>#endif HPUXE 6E 5#include <stdio.h>I 12#include <sys/types.h>E 12E 3#include <sys/file.h>#include <signal.h>#include <sys/wait.h>#include <errno.h>#include "dbprint.h"D 12#include <sys/types.h>E 12#include <sys/socket.h>I 9#ifndef SYSVONLYE 9#include <sys/un.h>I 9D 16#endif SYSVONLYE 16I 16#endif /* SYSVONLY */E 16I 10#ifdef RISCOS#include <sys/un.h>D 16#endif RISCOSE 16I 16#endif /* RISCOS */E 16I 14#ifdef INDIGO#include <sys/un.h>#include <sgtty.h>#endifE 14E 10E 9D 4#ifdef AIX#define FNDELAY O_NONDELAY#endifE 4D 14E 14/* The following globals are used to communicate between Unix   subprocesses and LISP */long StartTime;			/* Time, for creating pipe filenames */D 8char shcom[150];		/* Here because I'm suspicious of */E 8I 8char shcom[512];		/* Here because I'm suspicious of */E 8				/* large allocations on the stack *//* fork_Unix is the secondary process spawned right after LISP is   started, to avoid having TWO 8 mbyte images sitting around. It listens   to the pipe LispToUnix waiting for requests, and responds on UnixToLisp.   The data passed through this pipe is in 4 byte packets, of the form:   Byte 0:   Command character, one of:                   S: Fork PTY (shell) process. This is used for CHAT windows.		   P: New version of S, takes 2 string args.		   F: Fork piped shell, takes 1 string arg.		   K: Kill process		   E: Exit (kill all subprocesses)		   C: Close stdin to subprocess		   W: call WAIT3 & get one process's close info.I 11		   O: Fork OCR process.E 11   Byte 1:   Process number (0 to NPROCS - 1)             Not used for S, F, and E commands	     [For S&P, pty letter]	     [For F, process # for pipe naming]   Byte 2:   Value, used as follows:             Only used for W command, contains byte to write	     [For S&P, pty number]   Byte 3:   Slot number.In the case of F & P commands, additional data follows the 4 byte packet.D 8This consists of one byte representing the length of the shell commandE 8I 8This consists of 2 bytes representing the length of the shell commandE 8string, and the string itself.fork_Unix will return another 4 byte packet. The bytes are the same as thoseof the packet received except:   F:        Byte 2 is job number             Byte 3 is 1 if successful, 0 if notD 4   S:        Byte 2 is job numberE 4I 4D 6   S:     €   Byte 2 is job numberE 6I 6   S:	     Byte 2 is job numberE 6E 4             Byte 3 is 1 if successful, 0 if not   R:        Byte 2 is value of byte read from stdin, if any             Byte 3 is 1 if successful, 2 if EOF, 0 if nothing waiting   W:        Bytes 0 & 1 are the Process ID of the terminated process	     Bytes 2 & 3 are the high & low bytes of the exit status.   K:        Bytes 1 and 2 are the high and low bytes of the exit status             of the process.	     Byte 3 is 1 if an exit status was available.   E:        Always the same   C:        Always the sameI 11   O:	     Byte 3 is 1 if successful, 0 if not   	     Byte 1 and Byte 2 are the process ID of OCR processE 11*/fork_Unix(){  int LispToUnix[2],		/* Incoming pipe from LISP */      UnixToLisp[2],		/* Outgoing pipe to LISP */	 UnixPID,      LispPipeIn, LispPipeOut, res, pid, slot;D 8  char IOBuf[4], tmp[2];E 8I 8  char IOBuf[4];  unsigned short tmp;  char *cmdstring;E 8  /* Pipes between LISP subr and process */  if (pipe(LispToUnix) == -1) {    perror("pipe");    exit(-1);  }  if (pipe(UnixToLisp) == -1) {    perror("pipe");    exit(-1);  }  StartTime = time(0);		/* Save the time, to create filenames with */  StartTime &= 0xFFFFFF;	/* as a positive number! *//* interrupts need to be blocked here so subprocess won't see them */I 7D 9#ifdef RISCOSE 9I 9#ifdef SYSVSIGNALSE 9  sighold(SIGVTALRM);  sighold(SIGIO);  sighold(SIGALRM);  sighold(SIGXFSZ);  sighold(SIGFPE);#elseE 7  sigblock(sigmask(SIGVTALRM) | sigmask(SIGIO)D 5	     | sigmask(SIGALRM)  | sigmask(SIGXFSZ)E 5I 5D 6	     | sigmask(SIGALRM) #ifndef HPUX | sigmask(SIGXFSZ)#endif HPUXE 6I 6D 7	     | sigmask(SIGALRM)  | sigmask(SIGXFSZ)E 6E 5 		 | sigmask(SIGFPE)E 7I 7		| sigmask(SIGALRM)#ifndef HPUX		| sigmask(SIGXFSZ)D 16#endif HPUXE 16I 16#endif /* HPUX */E 16 		| sigmask(SIGFPE)E 7		);I 7D 9#endif RISCOSE 9I 9D 16#endif SYSVSIGNALSE 16I 16#endif /* SYSVSIGNALS */E 16E 9E 7I 16E 16  if ((UnixPID = fork()) == -1) {  /* Fork off small version of the emulator */    perror("fork");    exit(-1);  }  if (UnixPID != 0) {    /* JRB - fork_Unix is now called in ldeboot; leave UnixPipe{In,Out} open       and put their numbers in the environment so parent can find them */D 4    putenv(sprintf(malloc(20), "LDEPIPEIN=%d", UnixToLisp[0]));    putenv(sprintf(malloc(20), "LDEPIPEOUT=%d", LispToUnix[1]));    putenv(sprintf(malloc(30), "LDESTARTTIME=%d", StartTime));    putenv(sprintf(malloc(20), "LDEUNIXPID=%d", UnixPID));E 4I 4    /* JDS - NB that sprintf doesn't always return a string! */    char* tempstring;    tempstring = (char *) malloc(30);    sprintf(tempstring, "LDEPIPEIN=%d", UnixToLisp[0]);    putenv(tempstring);D 16    tempstring = malloc(30);E 16I 16    tempstring = (char *)malloc(30);E 16    sprintf(tempstring, "LDEPIPEOUT=%d", LispToUnix[1]);    putenv(tempstring);D 16    tempstring = malloc(30);E 16I 16    tempstring = (char *)malloc(30);E 16    sprintf(tempstring, "LDESTARTTIME=%d", StartTime);    putenv(tempstring);D 16    tempstring = malloc(30);E 16I 16    tempstring = (char *)malloc(30);E 16    sprintf(tempstring, "LDEUNIXPID=%d", UnixPID);    putenv(tempstring);E 4    close(LispToUnix[0]);    close(UnixToLisp[1]);    return(1);  }  LispPipeIn = LispToUnix[0];  LispPipeOut = UnixToLisp[1];  close(LispToUnix[1]);  close(UnixToLisp[0]);  res = fcntl(LispPipeIn, F_GETFL, 0);  res &= (65535-FNDELAY);  res = fcntl(LispPipeIn, F_SETFL, res);  while (1) {    int len;    len = 0;    while (len != 4)    {      if ((len = read(LispPipeIn, IOBuf, 4)) <0)	{	/* Get packet */	  perror("Packet read by slave");	  /*      kill_comm_processes(); */	  exit(0);	}      if (len != 4)	{	  DBPRINT(("Input packet wrong length:  %d.\n", len));	  exit(0);	}    }    slot = IOBuf[3];    IOBuf[3] = 1;    switch(IOBuf[0]) {    case 'S': case 'P':			/* Fork PTY shell */      if (slot >= 0)	{ /* Found a free slot */	  char termtype[32];I 16#ifdef INDIGO	  char slavepty[32];	/* For slave pty name */	  if (read(LispPipeIn, &tmp, 2) < 0) perror("Slave reading slave pty len");	  if (read(LispPipeIn, slavepty, tmp) < 0) perror("Slave reading slave pty id");#endif /* INDIGO */E 16	  if (IOBuf[0] == 'P')	    {			/* The new style, which takes term type & command to csh */D 8	      if(read(LispPipeIn, tmp, 1) < 0) perror("Slave reading cmd length");	      if(read(LispPipeIn, termtype, *tmp) < 0) perror("Slave reading termtype");	      if(read(LispPipeIn, tmp, 1) < 0) perror("Slave reading cmd length");	      if(read(LispPipeIn, shcom, *tmp) < 0) perror("Slave reading shcom");E 8I 8	      if(read(LispPipeIn, &tmp, 2) < 0) perror("Slave reading cmd length");	      if(read(LispPipeIn, termtype, tmp) < 0) perror("Slave reading termtype");	      if(read(LispPipeIn, &tmp, 2) < 0) perror("Slave reading cmd length");D 16	      if (tmp > 510) cmdstring = malloc(tmp+5);E 16I 16	      if (tmp > 510) cmdstring = (char *)malloc(tmp+5);E 16	      else cmdstring = shcom;	      if(read(LispPipeIn, cmdstring, tmp) < 0) perror("Slave reading shcom");E 8	    }	    else		/* old style, no args */D 8	      { termtype[0] = 0; shcom[0] = 0; }E 8I 8	      { termtype[0] = 0; cmdstring[0] = 0; }E 8	  /* Alloc a PTY and fork  */I 16#ifdef INDIGO	  pid = ForkUnixShell(slot, slavepty, termtype, cmdstring);#elseE 16D 8	  pid = ForkUnixShell(slot, IOBuf[1], IOBuf[2], termtype, shcom);E 8I 8	  pid = ForkUnixShell(slot, IOBuf[1], IOBuf[2], termtype, cmdstring);I 16#endifE 16E 8	  if (pid == -1)	    {	      printf("Impossible failure from ForkUnixShell??\n");	      fflush(stdout);	      IOBuf[3] = 0;	    }	  else	    {	      /* ForkUnixShell sets the pid and standard in/out variables */	      IOBuf[1] = (pid >> 8)& 0xFF;	      IOBuf[2] = pid & 0xFF;	    }        }      else 	{	  printf("Can't get process slot for PTY shell.\n");	  fflush(stdout);	  IOBuf[3] = 0;	}       break;    case 'F':			/* Fork pipe command */      if (slot >= 0) 		{	/* Read in the length of the shell command, and then the command */D 8	if(read(LispPipeIn, tmp, 1)<0) perror("Slave reading cmd length");	if(read(LispPipeIn, shcom, *tmp)<0) perror("Slave reading cmd");	DBPRINT(("Cmd len = %d.\n", *tmp));	DBPRINT(("Rev'd cmd string: %s\n", shcom));E 8I 8	if(read(LispPipeIn, &tmp, 2)<0) perror("Slave reading cmd length");D 16	if (tmp > 510) cmdstring = malloc(tmp+5);E 16I 16	if (tmp > 510) cmdstring = (char *)malloc(tmp+5);E 16	else cmdstring = shcom;	if(read(LispPipeIn, cmdstring, tmp)<0) perror("Slave reading cmd");	DBPRINT(("Cmd len = %d.\n", tmp));	DBPRINT(("Rev'd cmd string: %s\n", cmdstring));E 8	pid = fork(); /* Fork */	if (pid == 0)	  {	    int i;	    int status, sock;I 15#ifndef ISCE 15	    struct sockaddr_un addr;	    char PipeName[40];D 15E 15	    sock = socket(AF_UNIX, SOCK_STREAM, 0);	    if (sock < 0) {perror("slave socket"); exit(0);}D 15	    sprintf(PipeName, "/tmp/LispPipe%d-%d", StartTime, slot);E 15I 15	    sprintf(PipeName, "/tmp/LPU%d-%d", StartTime, slot);E 15	    addr.sun_family = AF_UNIX;	    strcpy(addr.sun_path, PipeName);	    status = connect(sock, (struct sockaddr *)&addr,			     strlen(PipeName)+sizeof(addr.sun_family));	    if(status<0)	      {		perror("slave connect");		printf("Name = %s.\n", PipeName); fflush(stdout);		exit(0);	      }	    else	      {		DBPRINT(("Slave connected on %s.\n", PipeName));	      }	    /* Copy the pipes onto stdin, stdout, and stderr */	    dup2(sock,0);	    dup2(sock,1);	    dup2(sock,2);D 15 E 15I 15#else	/* New, FIFO-based communication regime */	    int down, up;	/* fifo fds */	    char DownFIFO[48], UpFIFO[48];	    sprintf(DownFIFO, "/tmp/LPD%d-%d", StartTime, slot);	    sprintf(UpFIFO, "/tmp/LPU%d-%d", StartTime, slot);	    if ((down = open(DownFIFO, O_RDONLY | O_NDELAY)) < 0)	      {		perror("slave opening down fifo");		exit(0);	      }	    if ((up = open(UpFIFO, O_WRONLY | O_NDELAY)) < 0)	      {		perror("slave opening up fifo");		exit(0);	      }	    /* Copy the fifos onto stdin, stdout, and stderr */	    dup2(down,0);	    dup2(up,1);	    dup2(up,2);	/*	unlink(DownFIFO);		unlink(UpFIFO); */#endif /* oldPIPEway */E 15I 7#ifdef HPUX	    /* Make sure everything else is closed POSIX has no getdtab... */	    for (i = 3; i < sysconf(_SC_OPEN_MAX); i++)	      close(i);#elseE 7I 5D 6#ifdef HPUX	    /* Make sure everything else is closed POSIX has no getdtab... */	    for (i = 3; i < sysconf(_SC_OPEN_MAX); i++)	      close(i);#elseE 6E 5	    /* Make sure everything else is closed */	    for (i = 3; i < getdtablesize(); i++)	      close(i);I 7D 16#endif HPUXE 16I 16#endif /* HPUX */E 16E 7I 5D 6#endif HPUXE 6E 5I 16E 16	    /* Run the shell command and get the result */D 8	    status = system(shcom);E 8I 8	    status = system(cmdstring);	    if (cmdstring != shcom) free(cmdstring);E 8I 6	    /* Comment out to fix USAR 11302 (FXAR 320)E 6	    unlink(PipeName);I 6	    */E 6	    _exit((status & ~0xff) ? (status >> 8) : status);	  }	/* Check for error doing the fork */	if (pid == -1)	  {	    perror("unixcomm: fork");	    IOBuf[3] = 0;	  }	else	  {	    IOBuf[1] = (pid >> 8)& 0xFF;	    IOBuf[2] = pid & 0xFF;	  }      } else IOBuf[3] = 0; /* Couldn't get a process slot */      break;    case 'W':			/* Wait for a process to die. */      {	int pid;I 7#ifdef RISCOS	int status;#elseE 7	union wait status;I 7D 16#endif RISCOSE 16I 16#endif /* RISCOS */E 16E 7	int slot;I 7#ifdef RISCOS	status = 0;#elseE 7	status.w_status = 0;I 7D 16#endif RISCOSE 16I 16#endif /* RISCOS */E 16E 7	IOBuf[0] = 0; IOBuf[1] = 0;	DBPRINT(("About to wait for processes.\n"));I 7#ifdef RISCOS	if (((pid = wait(&status, WNOHANG)) != 0))#elseE 7	if (((pid = wait3(&status, WNOHANG, 0)) != 0))I 7D 16#endif RISCOSE 16I 16#endif /* RISCOS */E 16E 7	  {	    /* Ignore processes which are suspended but haven't exited	       (this shouldn't happen) */I 7#ifdef RISCOS	    if ((status & 0xFF) == 0177) break;	    IOBuf[3] = status >>8;	    IOBuf[2] = status & 0xFF;#elseE 7	    if (status.w_stopval == WSTOPPED) break;	    IOBuf[3] = status.w_T.w_Retcode;	    IOBuf[2] = status.w_T.w_Termsig;I 7D 16#endif RISCOSE 16I 16#endif /* RISCOS */E 16E 7	    IOBuf[1] = pid & 0xFF;	    IOBuf[0] = (pid>>8) & 0xFF;          }	DBPRINT(("wait3 returned pid = %d.\n", pid));      }      break;    case 'C':			/* Close stdin to subprocess */      break;    case 'K':			/* Kill subprocess */      break;I 11#ifdef OCR    case 'w':			/* Wait paticular process to die */      {	      int	pid, res, status;	      pid = IOBuf[1] << 8 | IOBuf[2];	    retry:	      res = waitpid(pid, &status, WNOHANG);	      if (res == -1 && errno == EINTR) goto retry;	      	      if (res == pid) {		      IOBuf[0] = res >> 24 & 0xFF;		      IOBuf[1] = res >> 16 & 0xFF;		      IOBuf[2] = res >> 8 & 0xFF;		      IOBuf[3] = res & 0xFF;	      } else {		      IOBuf[0] = IOBuf[1] = IOBuf[2] = IOBuf[3] = 0;	      }      }      break;    case 'O':			/* Fork OCR process */      if (slot >= 0) {	      pid_t	ppid;	      ppid = getppid();	      pid = fork();	      if (pid == 0) {		      int			i;		      int			status, len;		      struct sockaddr_un	addr;		      char			PipeName[40];		      extern int		OCR_sv;		      OCR_sv = socket(AF_UNIX, SOCK_STREAM, 0);		      if (OCR_sv < 0) {			      perror("slave socket");			      exit(0);		      }		      sprintf(PipeName, "/tmp/LispPipe%d-%d", StartTime, slot);		      addr.sun_family = AF_UNIX;		      strcpy(addr.sun_path, PipeName);		      len = strlen(PipeName)+sizeof(addr.sun_family);		      status = connect(OCR_sv, &addr, len);		      if(status<0) {			      perror("slave connect");			      OCR_sv = -1;			      exit(0);		      }		      (void)ocr_proc(ppid);		      OCR_sv = -1;		      exit(1);	      }	      if (pid == -1) {		      perror("unixcomm: fork OCR");		      IOBuf[3] = 0;	      } else {		      IOBuf[1] = (pid >> 8)& 0xFF;		      IOBuf[2] = pid & 0xFF;	      }      } else IOBuf[3] = 0;      break;D 16#endif OCRE 16I 16#endif /* OCR */E 16E 11I 16E 16    } /* End of switch */    /* Return the status/data packet */    write(LispPipeOut, IOBuf, 4);  }}/************************************************************************//*									*//*			F o r k U n i x S h e l l			*//*									*//*	Fork a PTY connection to a C-shell process.			*/D 3/*	Returns PID of process, or -1 if something failed			*/E 3I 3/*	Returns PID of process, or -1 if something failed		*/E 3/*									*//*									*//************************************************************************//* Creates a PTY connection to a csh */I 16#ifdef INDIGOForkUnixShell(slot, PtySlave, termtype, shellarg)#elseE 16ForkUnixShell(slot, ltr, numb, termtype, shellarg)I 16#endifE 16  int slot;I 16#ifdef INDIGO  char * PtySlave;#elseE 16  char ltr, numb;I 16#endifE 16  char *termtype, *shellarg;  {I 16#ifdef INDIGO    char buf[1];#elseE 16    char PtySlave[20], buf[1];I 16#endifE 16    int res, PID, MasterFD, SlaveFD;I 3D 14#ifdef OS4E 14I 14#ifdef USETERMIOSE 14E 3    struct termios tio;I 3#else    struct sgttyb tio;D 14#endif OS4E 14I 14D 16#endif USETERMIOSE 16I 16#endif /* USETERMIOS */E 16E 14E 3I 16E 16    PID = fork();    if (PID == 0)      {	char envstring[64];	char *argvec[4];	I 16#if (!HPUX && !RISCOS)E 16	/* Divorce ourselves from /dev/tty */	res = open("/dev/tty", O_RDWR);	if (res >= 0)	  {D 5#ifndef HPE 5I 5D 6#ifndef HPUXE 6I 6D 7#ifndef HPE 7I 7D 16#if (!defined(HPUX) && !defined(RISCOS))E 16E 7E 6E 5	    (void) ioctl(res, TIOCNOTTY, (char *)0);D 16#endifE 16	    (void) close(res);	  }	else	  {	    perror("Slave TTY");	    exit(0);	  }I 16#elif HPUX	setsid();	/* create us a new session for tty purposes */#endifE 16	/* Open the slave side */I 16#ifndef INDIGOE 16	sprintf(PtySlave, "/dev/tty%c%c", ltr, numb);I 16#endifE 16	SlaveFD = open(PtySlave, O_RDWR);	if (SlaveFD == -1)	  {	    perror("Slave Open");I 16	    perror(PtySlave);E 16	    exit(0);	  }D 3/* This is the old way we set up terminal, using an   obsolete ioctl and wrong flags for a display.E 3I 3D 14#ifndef OS4E 14I 14#ifndef USETERMIOSE 14/* This is the old way we set up terminal (OS 3), using an   obsolete ioctl and wrong flags for a display. */E 3	ioctl(SlaveFD, TIOCGETP, (char *)&tio);	tio.sg_flags |= CRMOD;	tio.sg_flags |= ECHO;	ioctl(SlaveFD, TIOCSETP, (char *)&tio);D 3*/	/* Set up as basic display terminal: canonical erase, kill processing, echo,	   backspace to erase, echo ctrl chars as ^x, kill line by backspacing */E 3I 3#else	/* Set up as basic display terminal: canonical erase,	   kill processing, echo, backspace to erase, echo ctrl	   chars as ^x, kill line by backspacing */E 3	ioctl(SlaveFD, TCGETS, (char *)&tio);I 14#ifdef INDIGO	tio.c_lflag |= ICANON | ECHO | ECHOE;#elseE 14	tio.c_lflag |= ICANON | ECHO | ECHOE | ECHOCTL | ECHOKE;I 14#endif /* INDIGO */E 14	ioctl(SlaveFD, TCSETS, (char *)&tio);D 3E 3I 3D 14#endif OS4E 14I 14D 16#endif USETERMIOSE 16I 16#endif /* USETERMIOS */E 16E 14E 3	(void) dup2(SlaveFD, 0);	(void) dup2(SlaveFD, 1);	(void) dup2(SlaveFD, 2);	(void) close(SlaveFD);	/* set the LDESHELL variable so the underlying .cshrc can see it and	   configure the shell appropriately, though this may not be so important any more */	putenv("LDESHELL=YES");	if ((termtype[0] != 0) && (strlen(termtype) < 59))	  { 		/* set the TERM environment var */	    sprintf(envstring, "TERM=%s", termtype);	    putenv(envstring);	  }	/* Start up csh */	argvec[0] = "csh";	if (shellarg[0] != 0)	  {			/* setup to run command */	    argvec[1] = "-c";	/* read commands from next arg */	    argvec[2] = shellarg;	    argvec[3] = (char *) 0;	  }	  else argvec[1] = (char *) 0;	execv("/bin/csh", argvec);	/* Should never get here */	perror("execv");	exit(0);I 8      }    else      { /* not the forked process. */	if (shellarg != shcom) free(shellarg);E 8      }    /* Set the process group so all the kids get the bullet too    if (setpgrp(PID, PID) != 0)      perror("setpgrp"); */    return(PID);  }E 1