h09054s 00003/00003/00075d D 2.10 92/04/21 17:03:15 sybalsky 14 13c shortening file names for DOS \nes 00000/00000/00078d D 2.9 90/04/20 01:19:54 sybalsky 13 12c AIX:  shortening file names, bulk change.es 00048/00019/00030d D 2.8 90/02/19 10:00:06 sybalsky 12 11c Fix array-header refs to use structure, for 386ies 00006/00007/00043d D 2.7 88/10/12 14:39:59 krivacic 11 10c new out-of-line interfacees 00003/00085/00047d D 2.6 88/07/06 14:40:00 charnley 10 9c uses new select macro with modified select order.es 00013/00039/00119d D 2.5 88/06/07 16:00:29 charnley 9 8c disallow smallp's to char'ses 00003/00001/00155d D 2.4 88/05/25 17:15:24 charnley 8 7c changed err type.es 00002/00002/00154d D 2.3 88/05/25 16:52:35 charnley 7 6c changed sub name.es 00016/00150/00140d D 2.2 88/05/25 15:44:10 charnley 6 5c removed unused code, fixed bugs in signed 32, signed 16, and fl pt.es 00000/00000/00290d D 2.1 88/05/17 09:22:03 hayata 5 4c Version up to 2.1es 00010/00007/00280d D 1.4 88/05/09 21:49:52 shih 4 3c Use GCLOOKUPes 00006/00009/00281d D 1.3 88/04/21 09:38:10 charnley 3 2c changed aray-type mask, added refcounting to pointer arrayses 00002/00000/00288d D 1.2 88/04/20 14:20:27 masinter 2 1c Temporary patch to turn off non-refcounting aset of pointeres 00288/00000/00000d D 1.1 88/04/05 15:29:17 charnley 1 0c date and time created 88/04/05 15:29:17 by charnleyeuUtTI 1D 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";/*	array4.c */E 12I 12/* This is G-file @(#) array4.c Version 2.7 (10/12/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) array4.c	2.7 10/12/88";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************//************************************************************************//*									*//*				A R R A Y 4 . C				*//*									*//*	Contains:	N_OP_aset1					*//*									*//************************************************************************/E 12#include <stdio.h>#include "lispemul.h"D 14#include "lispglobal.h"#include "address68k.h"E 14I 14#include "lspglob.h"#include "adr68k.h"E 14#include "lispmap.h"D 14#include "lisptypes.h"E 14I 14#include "lsptypes.h"E 14D 9#include "emulglobal.h"I 3#include "gc.h"E 9E 3#include "arith.h"I 9#include "gc.h"E 9#include "my.h"D 9E 9D 3#include "tos1defs.h" #include "tosretmacro.h"#include "tosfuncallmacro.h"#include "inlinedefsC.h"#include "inlinedefs68K.h" #include "fastinlinedefs68K.h"E 3D 10/************************************************************ OP_aset1   -- op 267   (new-value array index)E 10D 6   Array data structure :E 6I 6D 10type    size    typenumber  0       0             0      unsigned  : 1 bit  0       3             3      unsigned  : 8 bits  0       4             4      unsigned  : 16 bits  1       4            20      signed    : 16 bits  1       6            22      signed    : 32 bits  2       6            38      pointer   : 32 bits  3       6            54      float     : 32 bits  4       3            67      character : 8 bits  4       4            68      character : 16 bits  5       6            86      Xpointer  : 32 bitsE 6D 6Word	Content0	Hi word of base pointer1	Low word of base pointer2	Flag (8 bits), Type (4 bits), Size (bits per element, 4 bits)3	Offset4	Fill pointer5	Total size	typenumber:		type = 7 & (typenumber >> 4)		0  unsigned		1  signed		2  pointer		3  float		4  character		5  xpointer		6  illegal		7  illegal		size = 7 & typenumber		0 1 bit   :		1 2 bits  :		2 4 bits  :		3 8 bits  :		4 16 bits : 		5 24 bits :		6 32 bits :		7 64 bits :	E 6***********************************************************/E 10D 6/***	OP_aset1   -- op 267   (new-value array index)   ***/OP_myaset1(){register LispPTR base;register short typenumber;register short index;register LispPTR data;register DLword *array;register int new;LispPTR temp;      /*  verify array  */      temp = *((LispPTR *)(CurrentStackPTR));      if (GetTypeNumber(temp) != TYPE_ONED_ARRAY) gotoufn;      array = Addr68k_from_LADDR(temp);      /*  test and setup index  */      if ((0xFFFF0000 & TopOfStack) != S_POSITIVE) gotoufn;      index = 0xFFFF & TopOfStack;      if (index >= *((DLword *)(array + 5))) gotoufn;      index += *((DLword *)(array + 3));      /*  setup typenumber  */      temp = *((DLword *)(array + 2));      if (temp & 0x8000) gotoufn;      typenumber = 0xFFFF & temp;      /*  setup base  */      base = *((LispPTR *)(array));      /*  fetch data  */      data = *((LispPTR *)(CurrentStackPTR - 2));      /*  disp on type  */    switch (typenumber) {      case 0: /* unsigned : 1 bit per element */        if ((data & 0xFF0000) != S_POSITIVE) gotoufn;         new = data & 0xFFFF;        if (new > 1) gotoufn;        if (new) {          new = (1 << (7 - (index & 7)));          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) |= new;        }        else {          new = 0xFF - (1 << (7 - (index & 7)));          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) &= new;        }        break;      case 3: /* unsigned : 8 bits per element */        if ((data & 0xFF0000) != S_POSITIVE) gotoufn;         new = data & 0xFFFF;        if (new > 0xFF) gotoufn;        *(((char *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 4: /* unsigned : 16 bits per element */        if ((data & 0xFF0000) != S_POSITIVE) gotoufn;         new = data & 0xFFFF;        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 20: /* signed : 16 bits */        if ((((data & 0xFF0000) == S_POSITIVE) && ((data & 0x8000) == 0)) || (((data & 0xFF0000) == S_NEGATIVE) && ((data & 0x8000) != 0)))        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        else gotoufn;        break;      case 22: /* signed : 32 bits */        GetNumber(data, new);        *(((int *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 38: /* pointer : 32 bits */I 2D 3	gotoufn; /* SHOULD REFERENCE COUNT */E 3I 3D 4	gclookup(0x8000|DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));	gclookup(0x8000|ADDREF, data);E 4I 4	GCLOOKUP(0x8000,DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));	GCLOOKUP(0x8000,ADDREF, data);E 4E 3E 2        *(((int *)Addr68k_from_LADDR(base)) + index) = data;        break;      case 54: /* Float : 32 bits */        if (GetTypeNumber(data) != TYPE_FLOATP) gotoufn;        *(((int *)Addr68k_from_LADDR(base)) + index) = *(int *)data;        break;      case 67: /* Character :  8 bits */        if (((data & 0xFF0000) != S_POSITIVE) && ((data & 0xFF0000) != S_CHARACTER)) gotoufn;        new = data & 0xFFFF;        if (new > 0xFF) gotoufn;        *(((char *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 68: /* Character :  16 bits */        if (((data & 0xFF0000) != S_POSITIVE) && ((data & 0xFF0000) != S_CHARACTER)) gotoufn;         new = data & 0xFFFF;        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 86: /* XPointer : 32 bits */        *(((int *)Addr68k_from_LADDR(base)) + index) = data;        break;      default: /* Illegal or Unimplemented */        gotoufn;    }/* end switch typenumber */  TopOfStack = data;  CurrentStackPTR -= 4;  PC++;} /*  end OP_aset1()  */E 6/***	N_OP_aset1   -- op 267   (new-value array index)   ***/I 12/************************************************************************//*									*//*			N _ O P _ a s e t 1				*//*									*//*	1-dimensional array setter.					*//*									*//************************************************************************/E 12D 9N_OP_aset1(data, arrayarg, index, error_addr)E 9I 9D 11N_OP_aset1(data, arrayarg, inx, error_addr)E 9D 6int *error_addr;E 6I 6D 7int error_addr;E 7I 7int *error_addr;E 11I 11N_OP_aset1(data, arrayarg, inx)E 11E 7E 6D 9register int index;E 9I 9D 12register int inx;E 9LispPTR arrayarg;register LispPTR data;{D 6E 6D 10register int typenumber;E 10I 10register int type;E 10register DLword *arrayblk;register LispPTR base;register int new;I 9register int index;E 12I 12  register int inx;  LispPTR arrayarg;  register LispPTR data;  {    register int type;    register OneDArray *arrayblk;    register LispPTR base;    register int new;    register int index;E 12E 9D 10#ifdef	TRACE	printPC();	printf("TRACE: N_OP_aset1()\n");#endifE 10      /*  verify array  */D 11      if (GetTypeNumber(arrayarg) != TYPE_ONED_ARRAY) ERROR_EXIT(error_addr);E 11I 11      if (GetTypeNumber(arrayarg) != TYPE_ONED_ARRAY) ERROR_EXIT(inx);E 11D 12      arrayblk = Addr68k_from_LADDR(arrayarg);E 12I 12      arrayblk = (OneDArray *)Addr68k_from_LADDR(arrayarg);E 12      /*  test and setup index  */D 9      if ((0xFFFF0000 & index) != S_POSITIVE) ERROR_EXIT(error_addr);D 6      index = 0xFFFF & index;E 6I 6      index &= 0xFFFF;E 9I 9D 11      N_GetPos(inx, index, error_addr);E 9E 6      if (index >= *((DLword *)(arrayblk + 5))) ERROR_EXIT(error_addr);E 11I 11      N_GetPos(inx, index, inx);D 12      if (index >= *((DLword *)(arrayblk + 5))) ERROR_EXIT(inx);E 11      index += *((DLword *)(arrayblk + 3));E 12I 12      if (index >= arrayblk->totalsize) ERROR_EXIT(inx);      index += arrayblk->offset;E 12      /*  setup typenumber  */D 3      typenumber = 0xFFFF & *((DLword *)(arrayblk + 2));E 3I 3D 10      typenumber = 0xFF & *((DLword *)(arrayblk + 2));E 10I 10D 12      type = 0xFF & *((DLword *)(arrayblk + 2));E 12I 12      type = 0xFF & arrayblk->typenumber;E 12E 10E 3      /*  setup base  */D 12      base = *((LispPTR *)(arrayblk));E 12I 12      base = arrayblk->base;E 12      /*  disp on type  */D 10    switch (typenumber) {      case 0: /* unsigned : 1 bit per element */D 9        if ((data & 0xFF0000) != S_POSITIVE) ERROR_EXIT(error_addr);         new = data & 0xFFFF;E 9I 9        N_GetPos(data, new, error_addr);E 9        if (new > 1) ERROR_EXIT(error_addr);        if (new) {          new = (1 << (7 - (index & 7)));          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) |= new;        }        else {          new = 0xFF - (1 << (7 - (index & 7)));          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) &= new;        }        return(data);D 9        break;E 9      case 3: /* unsigned : 8 bits per element */D 9        if ((data & 0xFF0000) != S_POSITIVE) ERROR_EXIT(error_addr);         new = data & 0xFFFF;E 9I 9        N_GetPos(data, new, error_addr);E 9        if (new > 0xFF) ERROR_EXIT(error_addr);        *(((char *)Addr68k_from_LADDR(base)) + index) = new;        return(data);D 9        break;E 9      case 4: /* unsigned : 16 bits per element */D 9        if ((data & 0xFF0000) != S_POSITIVE) ERROR_EXIT(error_addr);         new = data & 0xFFFF;E 9I 9        N_GetPos(data, new, error_addr);        if (new > 0xFFFF) ERROR_EXIT(error_addr);E 9        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        return(data);D 9        break;E 9      case 20: /* signed : 16 bits */I 6        new = data & 0xFFFF;E 6D 4        if ((((data & 0xFF0000) == S_POSITIVE) && ((data & 0x8000) == 0)) || (((data & 0xFF0000) == S_NEGATIVE) && ((data & 0x8000) != 0)))E 4I 4D 9        if ((((data & 0xFF0000) == S_POSITIVE) && ((data & 0x8000) == 0)) ||	    (((data & 0xFF0000) == S_NEGATIVE) && ((data & 0x8000) != 0)))E 9I 9        if ((((data & 0xFFFF0000) == S_POSITIVE) && ((data & 0x8000) == 0)) ||	    (((data & 0xFFFF0000) == S_NEGATIVE) && (data & 0x8000)))E 9E 4        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        else ERROR_EXIT(error_addr);        return(data);D 9        break;E 9      case 22: /* signed : 32 bits */D 6        GetNumber(data, new);E 6I 6D 7        N_GetNumber(data, new, error_addr);E 7I 7D 8        N_GETNUMBER(data, new, error_addr);E 8I 8        N_GETNUMBER(data, new, doufn);E 8E 7E 6        *(((int *)Addr68k_from_LADDR(base)) + index) = new;        return(data);E 10I 10D 11      aset_switch(type, error_addr);E 11I 11      aset_switch(type, inx);E 11E 10D 9        break;E 9D 10      case 38: /* pointer : 32 bits */I 2D 3	ERROR_EXIT(error_addr); /* SHOULD REFERENCE COUNT */E 3I 3D 4	gclookup(0x8000|DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));	gclookup(0x8000|ADDREF, data);E 4I 4	GCLOOKUP(0x8000,DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));	GCLOOKUP(0x8000,ADDREF, data);E 4E 3E 2        *(((int *)Addr68k_from_LADDR(base)) + index) = data;        return(data);D 9        break;E 9      case 54: /* Float : 32 bits */        if (GetTypeNumber(data) != TYPE_FLOATP) ERROR_EXIT(error_addr);D 6        *(((int *)Addr68k_from_LADDR(base)) + index) = *(int *)data;E 6I 6        *(((int *)Addr68k_from_LADDR(base)) + index) = *((int *)Addr68k_from_LADDR(data));E 6        return(data);D 9        break;E 9      case 67: /* Character :  8 bits */D 4        if (((data & 0xFF0000) != S_POSITIVE) && ((data & 0xFF0000) != S_CHARACTER)) ERROR_EXIT(error_addr);E 4I 4D 9        if (((data & 0xFF0000) != S_POSITIVE) &&	    ((data & 0xFF0000) != S_CHARACTER)) ERROR_EXIT(error_addr);E 9I 9        if ((data & 0xFFFF0000) != S_CHARACTER) ERROR_EXIT(error_addr);E 9E 4        new = data & 0xFFFF;        if (new > 0xFF) ERROR_EXIT(error_addr);        *(((char *)Addr68k_from_LADDR(base)) + index) = new;        return(data);D 9        break;E 9      case 68: /* Character :  16 bits */D 4        if (((data & 0xFF0000) != S_POSITIVE) && ((data & 0xFF0000) != S_CHARACTER)) ERROR_EXIT(error_addr); E 4I 4D 9        if (((data & 0xFF0000) != S_POSITIVE) &&	    ((data & 0xFF0000) != S_CHARACTER)) ERROR_EXIT(error_addr); E 9I 9        if ((data & 0xFFFF0000) != S_CHARACTER) ERROR_EXIT(error_addr); E 9E 4        new = data & 0xFFFF;        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        return(data);D 9        break;E 9      case 86: /* XPointer : 32 bits */        *(((int *)Addr68k_from_LADDR(base)) + index) = data;        return(data);D 9        break;E 9      default: /* Illegal or Unimplemented */        ERROR_EXIT(error_addr);D 9E 9    }/* end switch typenumber */I 8E 10D 11doufn:		ERROR_EXIT(error_addr);E 11I 11doufn:		ERROR_EXIT(inx);E 11E 8D 12} /*  end N_OP_aset1()  */E 12I 12  } /*  end N_OP_aset1()  */E 12D 10	/*  end module  */E 10E 1