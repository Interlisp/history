h28075s 00048/00018/00395d D 1.38 93/02/08 15:05:48 sybalsky 39 38c Big VM (and new CDR coding) changes for 3.0 \nes 00006/00006/00407d D 1.37 92/10/22 09:46:41 sybalsky 38 37c misc changes and restore other files sans change \nes 00013/00020/00400d D 1.36 92/05/27 19:15:39 sybalsky 37 36c retrofit of 386 unix changes \nes 00000/00000/00420d D 1.35 92/04/21 16:35:53 sybalsky 36 35c shortening file names for DOSes 00000/00000/00420d D 1.34 90/12/07 20:36:35 sybalsky 35 34c es 00009/00000/00411d D 1.33 90/06/13 15:14:17 sybalsky 34 33c More fixing += bugs, looking for causes of stack trashes 00022/00006/00389d D 1.32 90/06/06 13:06:22 sybalsky 33 32c make S_CHECK print an intelligible message when its assertion fails.es 00011/00000/00384d D 1.31 90/06/04 14:46:57 sybalsky 32 31c reformat, copyrightes 00017/00004/00367d D 1.30 90/05/30 11:25:04 sybalsky 31 30c ANSI C, and casting, fixeses 00001/00001/00370d D 1.29 90/03/02 21:47:58 sybalsky 30 29c Remvoed BFRAMEPTR difference between 386 & not -- it's not a 1-word structure (oops!)es 00002/00002/00369d D 1.28 90/02/22 14:14:16 sybalsky 29 28c fix BFRAMEPTR macroes 00016/00000/00355d D 1.27 90/02/22 13:49:31 sybalsky 28 27c Added BFRAMEPTR, STKWORDPTR for byte-swapped Bframe/StackWord refs.es 00066/00075/00289d D 1.26 89/04/07 20:19:56 shih 27 26c bad sccsides 00002/00000/00362d D 1.25 89/03/30 11:02:03 sybalsky 26 25c STKWORD macroes 00000/00000/00362d D 1.24 89/03/27 10:15:49 sybalsky 25 24c more word-order changeses 00046/00042/00316d D 1.23 89/03/23 12:57:14 sybalsky 24 23c More byte-swapped defses 00002/00000/00356d D 1.22 89/03/17 13:33:00 sybalsky 23 22c Added FXPTR macro to encapsulate word-order, maybe.es 00000/00000/00356d D 1.21 89/03/09 14:42:49 sybalsky 22 21c no changeses 00001/00002/00355d D 1.20 88/12/09 21:45:05 sybalsky 21 20c Added byte-swapped definitions for the 386ies 00000/00000/00357d D 1.19 88/12/09 18:55:33 sybalsky 20 19c Adding byte-swapped defns for stackes 00120/00001/00237d D 1.18 88/12/09 18:23:22 sybalsky 19 18c checkpes 00003/00003/00235d D 1.17 88/10/04 13:49:44 krivacic 18 17c parens on macro def & FNHEAD type namees 00006/00000/00232d D 1.16 88/09/29 17:38:15 krivacic 17 16c add GETNAMETABLE macroes 00001/00001/00231d D 1.15 88/08/12 15:44:58 krivacic 16 15c remove the STK_SAFE from stack check (it should be in stkmin)es 00001/00001/00231d D 1.14 88/07/19 16:44:50 krivacic 15 14c nametable LispPTRes 00007/00001/00225d D 1.13 88/06/03 12:18:36 masinter 14 13c add back STK_END_COMPUTE macro; fix possible Irq_Stk_End computationes 00004/00028/00222d D 1.12 88/05/31 20:33:05 masinter 13 12c delete duplicate code, tune macros, add STKMIN vs STK_END_COMPUTEes 00000/00001/00250d D 1.11 88/05/27 15:02:38 krivacic 12 11c remove obsolete FVLOOKUP macroes 00022/00000/00213d D 1.10 88/04/18 19:18:10 shimizu 11 10c add STACKPes 00006/00000/00223d D 1.9 88/05/11 12:08:08 shimizu 10 9c Add FASTP_NILes 00010/00000/00213d D 1.8 88/05/10 19:40:00 krivacic 9 8c STK_END_COMPUTE & CLR_IRQes 00002/00001/00211d D 1.7 88/04/07 14:51:45 shimizu 8 7c Add FX_INVALIDP and fix SETCLINK macroses 00025/00001/00187d D 1.6 88/03/31 11:09:30 shimizu 7 6c Add Stack Check Stuffes 00001/00001/00187d D 1.5 88/03/13 13:26:05 hayata 6 5c Add SCCS key id (%Z%)es 00013/00012/00175d D 1.4 88/03/11 18:22:27 shimizu 5 4c add () arounf MACRO argumentes 00022/00000/00165d D 1.3 88/03/09 13:43:01 krivacic 4 2c Added frameex2 struct for 32 bit access to fnheaderes 00000/00000/00165d R 1.3 88/03/08 18:12:10 krivacic 3 2c Added frameex2 struct for 32 bit access to fnheaderes 00001/00000/00164d D 1.2 88/03/03 11:42:54 krivacic 2 1c Removed global CurrentFX to use CURRENTFX = PVAR - FRAMESIZEes 00164/00000/00000d D 1.1 88/02/23 18:37:15 hayata 1 0c date and time created 88/02/23 18:37:15 by hayataeuUtTI 27D 31/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 31I 31D 37/* @(#) stack.h Version 1.29 (3/2/90). copyright envos & Fuji Xerox  */E 37I 37D 39/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 39I 39/* %Z% %M% Version %I% (%G%). copyright Venue  */E 39E 37E 31E 27I 1D 6/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 6I 6D 19/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 19E 6I 19D 27/* This is G-file @(#) stack.h Version 1.17 (10/4/88). copyright Xerox & Fuji Xerox  */E 27E 19D 37/*D 27 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *E 27D 13 *	Auther	:	Takeshi ShimizuE 13I 13 *	Author	:	Takeshi ShimizuE 13D 27 *			Hiroshi Hayata	E 27I 27 *			Hiroshi HayataE 27D 13 * MERGED AT AISE 13 *//**********************************************************//*		File Name :	stack.hE 37D 27		Changed by :	H.Hayata(22-Apr-87)				take(24-Apr-87)				take(02-Jul-87)				take(06-jul-87)				take(15-Jul-87)				Take(16-Nov-87)				Take(11-Dec-87)E 27I 27D 37		Changed	:	Take(11-Dec-87)E 27				Take(06-Jan-88)I 19				JDS (09-Dec-88)E 37E 19D 37*//**********************************************************/I 32E 37/************************************************************************//*									*/D 37/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 37I 37/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 37/*									*/D 37/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 37I 37/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 37/*									*//************************************************************************/E 32/* ContextSW frame number */#define CurrentFXP	0#define ResetFXP	1#define SubovFXP	2#define KbdFXP		3#define HardReturnFXP	4#define GCFXP		5#define FAULTFXP	6#define STK_FSB_WORD	0xA000#define STK_FSB_32	0xA0000000#define STK_GUARD_WORD	0xE000#define STK_GUARD_32	0xE0000000#define  BF_MARK0	0x8000#define  BF_MARK	0x8000#define  BF_MARK32	0x80000000#define  FX_MARK	0xc000I 2#define  FX_MARK_NATIVE 0xc800E 2#define STK_GUARD	7#define STK_FX		6#define STK_FSB		5#define STK_BF		4#define STK_NOTFLG	0D 13#define STKLIMOFFSET		7#define STK_SAFE		2	/* added with stkmin */E 13I 13#define STK_SAFE		32	/* added with stkmin */E 13#define MINEXTRASTACKWORDS	32#define STACKAREA_SIZE	768/* For Fvar operations */#define FVSTACK		2#define FVGLOBAL	6#define FVUBNBOUND	3#define FVIVAR		0x0#define FVPVAR		0x80#define FVFVAR		0xC0#define ENDSTACKMARK	0xbI 23#define FXPTR(base) ((struct frameex1 *) WORDPTR(base))E 23I 19#ifndef BYTESWAPE 19I 19	/*******************************************************/	/*      Normal definitions for structures on stack     */	/*******************************************************/E 19D 39struct fnhead{E 39I 39typedef struct fnhead{E 39	DLword		stkmin;	/* ?? */	short		na;	/* Numbers of arguments */	short		pv;	/* ?? */	DLword		startpc;			/* head of ByteCodes, DLword offset from stkmin */D 27	unsigned	native :1;	/* native translated? */	unsigned	nil1 :1 ; 	/* not used */	unsigned	argtype : 2;	/* ?? */	unsigned	nil2 :4 ; 	/* not used */	unsigned	framename : 24;	/* index in AtomSpace */	DLword		ntsize;		/* size of NameTable */	unsigned		nlocals :8;	/* ?? */	unsigned		fvaroffset :8;	E 27I 27	unsigned	native		: 1;	/* native translated? */D 39	unsigned	nil1		: 1;	/* not used */	unsigned	argtype		: 2;	/* ?? */D 37	unsigned	nil2		: 4;	/* not used */E 37I 37	unsigned	nil2		: 1;	/* not used */E 39	unsigned	byteswapped	: 1;	/* code was reswapped.	 */I 39	unsigned	argtype		: 2;	/* ?? */#ifdef BIGVM	unsigned	framename	:28;	/* index in AtomSpace */#else	unsigned	nil2		: 2;	/* not used */E 39	unsigned	nil3		: 2;	/* not used */E 37	unsigned	framename	:24;	/* index in AtomSpace */I 39#endif /* BIGVM */E 39	DLword		ntsize;			/* size of NameTable */	unsigned	nlocals		: 8;	/* ?? */	unsigned	fvaroffset	: 8;E 27			/* DLword offset from head of NameTable */	/* NameTable of variavle length is follwing with this structure. */D 18};E 18I 18} FNHEAD;E 18typedef struct frameex1{	unsigned	flags	:3;	unsigned	fast	:1;	unsigned	native	:1;	/* This frame treats N-func */	unsigned	incall	:1;	unsigned	validnametable	:1;D 27			/* 0: look for FunctionHeader E 27I 27			/* 0: look for FunctionHeaderE 27			   1: look for NameTable on this FrameEx */	unsigned	nopush	:1;	unsigned	usecount :8;D 27	DLword	alink;		/* alink pointer (Low addr) */ E 27I 27	DLword	alink;		/* alink pointer (Low addr) */I 39#ifdef BIGVM	LispPTR fnheader;	/* pointer to FunctionHeader (Hi2 addr) */#elseE 39E 27	DLword	lofnheader;	/* pointer to FunctionHeader (Low addr) */	unsigned hi1fnheader : 8; /* pointer to FunctionHeader (Hi1 addr) */	unsigned hi2fnheader : 8; /* pointer to FunctionHeader (Hi2 addr) */I 39#endif /* BIGVM */E 39	DLword	nextblock;	/* pointer to FreeStackBlock */	DLword	pc;		/* Program counter */I 39#ifdef BIGVM	LispPTR nametable;	/* ptr to NameTable of this FrameEx (Hi2 addr) */#elseE 39D 27	DLword	lonametable;	/* pointer to NameTable of this FrameEx (Low addr) */	unsigned hi1nametable :8;	/* pointer to NameTable of this FrameEx (Hi1 addr) */	unsigned hi2nametable :8;	/* pointer to NameTable of this FrameEx (Hi2 addr) */E 27I 27	DLword	lonametable;	/* ptr to NameTable of this FrameEx (Low addr) */	unsigned hi1nametable :8;	/* ptr to NameTable of this FrameEx (Hi1 addr) */	unsigned hi2nametable :8;	/* ptr to NameTable of this FrameEx (Hi2 addr) */I 39#endif /* BIGVM */E 39E 27	DLword	blink;		/* blink pointer (Low addr) */	DLword	clink;		/* clink pointer (Low addr) */D 27} FX ;E 27I 27} FX;E 27I 4typedef struct frameex2{	unsigned	flags	:3;	unsigned	fast	:1;	unsigned	native	:1;	/* This frame treats N-func */	unsigned	incall	:1;	unsigned	validnametable	:1;D 27			/* 0: look for FunctionHeader E 27I 27			/* 0: look for FunctionHeaderE 27			   1: look for NameTable on this FrameEx */	unsigned	nopush	:1;	unsigned	usecount :8;D 27	DLword	alink;		/* alink pointer (Low addr) */ E 27I 27	DLword	alink;		/* alink pointer (Low addr) */E 27D 39	LispPTR	fnheader;	/* pointer to FunctionHeader (swapped) */E 39I 39	LispPTR	fnheader;	/* pointer to FunctionHeader */E 39	DLword	nextblock;	/* pointer to FreeStackBlock */	DLword	pc;		/* Program counter */D 15	LispPTR	nativera;	/* address of native ra */E 15I 15D 39	LispPTR	nametable;	/* address of NameTable (swapped) */E 39I 39	LispPTR	nametable;	/* address of NameTable */E 39E 15	DLword	blink;		/* blink pointer (Low addr) */	DLword	clink;		/* clink pointer (Low addr) */D 27} FX2 ;E 27I 27} FX2;E 27E 4typedef struct fxblock {D 27	unsigned	flagbyte	: 8 ;E 27I 27	unsigned	flagbyte	: 8;E 27	unsigned	nil		: 23;D 27	unsigned	slowp		: 1 ;} FXBLOCK ;E 27I 27	unsigned	slowp		: 1;} FXBLOCK;E 27typedef struct basic_frame {D 27	unsigned	flags : 3 ;	unsigned	nil   : 3 ;	unsigned	residual :1 ;	unsigned	padding  : 1 ;	unsigned	usecnt   : 8 ;	DLword		ivar ;E 27I 27	unsigned	flags	: 3;	unsigned	nil	: 3;	unsigned	residual: 1;	unsigned	padding : 1;	unsigned	usecnt  : 8;	DLword		ivar;E 27D 27} Bframe ;E 27I 27} Bframe;E 27typedef struct stkword {D 38		unsigned	flags	 :3;		unsigned	nil	 :5;		unsigned	usecount :8;E 38I 38		unsigned short flags	 :3;		unsigned short nil	 :5;		unsigned short usecount :8;E 38D 27 } StackWord ;E 27I 27 } StackWord;I 28E 28E 27 typedef struct stack_block {		DLword flagword;D 27		DLword size ;E 27I 27		DLword size;E 27 } STKBLK;I 11/* Lisp DATATYPE STACKP */typedef struct stackp {		DLword stackp0;D 27		DLword edfxp ;E 27I 27		DLword edfxp;E 27} STACKP;I 19I 28	/*************************************************************/	/*  Pointer-dereferencing macros for one-word structure ptrs */	/*************************************************************/#define BFRAMEPTR(ptr) ((Bframe *)(ptr))D 29#define STKWORDPTR(ptr) ((Bframe *)(ptr))E 29I 29#define STKWORDPTR(ptr) ((StackWord *)(ptr))E 29E 28#else	/*******************************************************/	/*    Byte-swapped/Word-swapped definitions of stack   */	/*******************************************************/D 24struct fnhead{	short		na;	/* Numbers of arguments */	DLword		stkmin;	/* ?? */ /* hi word */	DLword		startpc;E 24I 24D 39struct fnheadE 39I 39typedef struct fnheadE 39  {    short	na;	/* Numbers of arguments */D 27    DLword	stkmin;	/* ?? */ E 27I 27    DLword	stkmin;	/* ?? */E 27    DLword	startpc;E 24			/* head of ByteCodes, DLword offset from stkmin */D 24	short		pv;	/* ?? */ /* hi word */	unsigned	framename : 24;	/* index in AtomSpace */	unsigned	native :1;	/* native translated? */ /* hi word */	unsigned	nil1 :1 ; 	/* not used */	unsigned	argtype : 2;	/* ?? */	unsigned	nil2 :4 ; 	/* not used */	unsigned		fvaroffset :8;	E 24I 24D 27    short	pv;	/* ?? */     unsigned	framename : 24;	/* index in AtomSpace */    unsigned	nil2 :4 ; 	/* not used */    unsigned	argtype : 2;	/* ?? */    unsigned	nil1 :1 ; 	/* not used */    unsigned	native :1;	/* native translated? */     unsigned	fvaroffset :8;	E 27I 27    short	pv;	/* ?? */I 39#ifdef BIGVM    unsigned	framename	:28;	/* index in AtomSpace */#elseE 39    unsigned	framename	:24;	/* index in AtomSpace */D 37    unsigned	nil2		: 4;	/* not used */E 37I 37    unsigned	nil3		: 2;	/* not used */D 39    unsigned	byteswapped	: 1;	/* code was reswapped.	*/    unsigned	nil2		: 1;	/* not used */E 39I 39    unsigned	nil2		: 2;	/* not used */#endif /* BIGVM */E 39E 37    unsigned	argtype		: 2;	/* ?? */D 39    unsigned	nil1		: 1;	/* not used */E 39I 39    unsigned	byteswapped	: 1;	/* code was reswapped.	*/E 39    unsigned	native		: 1;	/* native translated? */    unsigned	fvaroffset	: 8;E 27E 24			/* DLword offset from head of NameTable */D 24	unsigned		nlocals :8;	/* ?? */	DLword		ntsize;		/* size of NameTable */ /* hi word */E 24I 24D 27    unsigned	nlocals :8;	/* ?? */    DLword	ntsize;		/* size of NameTable */ E 27I 27    unsigned	nlocals		:8;	/* ?? */    DLword	ntsize;		/* size of NameTable */E 27E 24	/* NameTable of variavle length is follwing with this structure. */D 24} FNHEAD;E 24I 24  } FNHEAD;E 24typedef struct frameex1{D 27	DLword	alink;		/* alink pointer (Low addr) */ E 27I 27	DLword	alink;		/* alink pointer (Low addr) */E 27	unsigned	usecount :8;D 24	unsigned	flags	:3; /* hi word */	unsigned	fast	:1;	unsigned	native	:1;	/* This frame treats N-func */	unsigned	incall	:1;E 24I 24	unsigned	nopush	:1;E 24	unsigned	validnametable	:1;D 27			/* 0: look for FunctionHeader E 27I 27			/* 0: look for FunctionHeaderE 27			   1: look for NameTable on this FrameEx */D 24	unsigned	nopush	:1;E 24I 24	unsigned	incall	:1;	unsigned	native	:1;	/* This frame treats N-func */	unsigned	fast	:1;	unsigned	flags	:3; /* hi word */E 24I 39#ifdef BIGVM	unsigned fnheader; /* pointer to FunctionHeader (Hi2 addr) */#elseE 39	unsigned hi2fnheader : 8; /* pointer to FunctionHeader (Hi2 addr) */	unsigned hi1fnheader : 8; /* pointer to FunctionHeader (Hi1 addr) */	DLword	lofnheader;	/* pointer to FunctionHeader (Low addr) */I 39#endif /* BIGVM */E 39	DLword	pc;		/* Program counter */	DLword	nextblock;	/* pointer to FreeStackBlock */D 39	unsigned hi2nametable :8;	/* pointer to NameTable of this FrameEx (Hi2 addr) */	unsigned hi1nametable :8;	/* pointer to NameTable of this FrameEx (Hi1 addr) */	DLword	lonametable;	/* pointer to NameTable of this FrameEx (Low addr) */E 39I 39#ifdef BIGVM	unsigned nametable;	/* pointer to NameTable of this FX (Hi2 addr) */#else	unsigned hi2nametable :8;	/* pointer to NameTable of this FX (Hi2 addr) */	unsigned hi1nametable :8;	/* pointer to NameTable of this FX (Hi1 addr) */	DLword	lonametable;	/* pointer to NameTable of this FX (Low addr) */#endif /* BIGVM */E 39	DLword	clink;		/* clink pointer (Low addr) */	DLword	blink;		/* blink pointer (Low addr) */D 27} FX ;E 27I 27} FX;E 27typedef struct frameex2{D 27	DLword	alink;		/* alink pointer (Low addr) */ E 27I 27	DLword	alink;		/* alink pointer (Low addr) */E 27	unsigned	usecount :8;D 24	unsigned	flags	:3;	unsigned	fast	:1;	unsigned	native	:1;	/* This frame treats N-func */	unsigned	incall	:1;E 24I 24	unsigned	nopush	:1;E 24	unsigned	validnametable	:1;D 27			/* 0: look for FunctionHeader E 27I 27			/* 0: look for FunctionHeaderE 27			   1: look for NameTable on this FrameEx */D 24	unsigned	nopush	:1;E 24I 24	unsigned	incall	:1;	unsigned	native	:1;	/* This frame treats N-func */	unsigned	fast	:1;	unsigned	flags	:3;E 24	LispPTR	fnheader;	/* pointer to FunctionHeader (swapped) */	DLword	pc;		/* Program counter */	DLword	nextblock;	/* pointer to FreeStackBlock */	LispPTR	nametable;	/* address of NameTable (swapped) */	DLword	clink;		/* clink pointer (Low addr) */	DLword	blink;		/* blink pointer (Low addr) */D 27} FX2 ;E 27I 27} FX2;E 27typedef struct fxblock {D 21	unsigned	nil		: 7 ;E 21I 21D 24	unsigned	nil1		: 7 ;E 24E 21D 27	unsigned	slowp		: 1 ;E 27I 27	unsigned	slowp		: 1;E 27D 24	unsigned	nil		: 16;E 24I 24	unsigned	nil		: 23;E 24D 27	unsigned	flagbyte	: 8 ;} FXBLOCK ;E 27I 27	unsigned	flagbyte	: 8;} FXBLOCK;E 27typedef struct basic_frame {D 27	DLword		ivar ;	unsigned	usecnt   : 8 ;D 24	unsigned	flags : 3 ;	unsigned	nil   : 3 ;	unsigned	residual :1 ;E 24	unsigned	padding  : 1 ;I 24	unsigned	residual :1 ;	unsigned	nil   : 3 ;	unsigned	flags : 3 ;E 27I 27	DLword		ivar;	unsigned	usecnt  : 8;	unsigned	padding : 1;	unsigned	residual: 1;	unsigned	nil	: 3;	unsigned	flags	: 3;E 27E 24D 27} Bframe ;E 27I 27} Bframe;E 27D 24typedef struct stkword {D 21		unsigned	usecount :8;E 21		unsigned	usecount :8;		unsigned	flags	 :3;		unsigned	nil	 :5; } StackWord ; typedef struct stack_block {		DLword size ;		DLword flagword; } STKBLK;E 24I 24typedef struct stkword  {D 38    unsigned	usecount :8;    unsigned	nil	 :5;    unsigned	flags	 :3;E 38I 38    unsigned short usecount :8;    unsigned short nil	    :5;    unsigned short flags    :3;E 38D 27  } StackWord ;E 27I 27  } StackWord;E 27E 24I 24typedef struct stack_block  {D 27    DLword size ;E 27I 27    DLword size;E 27    DLword flagword;  } STKBLK;E 24/* Lisp DATATYPE STACKP */D 24typedef struct stackp {		DLword edfxp ;		DLword stackp0;} STACKP;E 24I 24typedef struct stackp  {D 27    DLword edfxp ;E 27I 27    DLword edfxp;E 27    DLword stackp0;  } STACKP;I 28	/*************************************************************/	/*  Pointer-dereferencing macros for one-word structure ptrs */	/*************************************************************/D 29#define BFRAMEPTR(ptr) ((Bframe *)(2^(ptr)))E 29I 29D 30#define BFRAMEPTR(ptr) ((Bframe *)(2^(int)(ptr)))E 30I 30#define BFRAMEPTR(ptr) ((Bframe *)(ptr))E 30E 29#define STKWORDPTR(ptr) ((StackWord *) (2^(int)(ptr)))E 28E 24#endifE 19I 26#define STKWORD(stkptr) ((StackWord *)WORDPTR(stkptr))E 26E 11I 8#define FX_INVALIDP(fx68k) (((fx68k)==0) || ((DLword*)(fx68k)==Stackspace))E 8#define FX_size(fx68k)	(((FX*)(fx68k))->nextblock - LOLOC(LADDR_from_68k(fx68k)))D 27#define FSBP(ptr68k)	( ((STKBLK*)(ptr68k))->flagword == STK_FSB_WORD ) E 27I 27#define FSBP(ptr68k)	( ((STKBLK*)(ptr68k))->flagword == STK_FSB_WORD )E 27#define FSB_size(ptr68k)	(((STKBLK*)(ptr68k))->size)I 5/** Following suff assumes fx is 68kptr and val is LISP_LO_OFFSET **/E 5#define DUMMYBF(fx)		( ((DLword*)(fx))-DLWORDSPER_CELL )#define SLOWP(fx)	(((FXBLOCK*)(fx))->slowp)#define FASTP(fx)	(!SLOWP(fx))I 11#define SET_FASTP_NIL(fx68k) {  \	if(FASTP(fx68k)){ \		((FX*)fx68k)->blink=StkOffset_from_68K(DUMMYBF(fx68k));\		((FX*)fx68k)->clink=((FX*)fx68k)->alink;\		SLOWP(fx68k)=T; }}E 11I 10D 13#define SET_FASTP_NIL(fx68k) {  \	if(FASTP(fx68k)){ \		((FX*)fx68k)->blink=StkOffset_from_68K(DUMMYBF(fx68k));\		((FX*)fx68k)->clink=((FX*)fx68k)->alink;\		SLOWP(fx68k)=T; }}E 13E 10D 13I 11E 13E 11#define GETALINK(fx)	((((fx)->alink) & 0xfffe)-FRAMESIZE)#define SETALINK(fx,val) {if(FASTP(fx)) \D 5			   {((FX*)fx)->blink=LOLOC(LADDR_from_68k(DUMMYBF(fx));\			    ((FX*)fx)->clink=((FX*)fx)->alink;}\			    ((FX*)fx)->alink=val+FRAMESIZE+1;}E 5I 5			   {((FX*)(fx))->blink=LADDR_from_68k(DUMMYBF(fx));\			    ((FX*)(fx))->clink=((FX*)(fx))->alink;}\			    ((FX*)(fx))->alink=(val)+FRAMESIZE+1;}E 5D 5#define GETBLINK(fx) (SLOWP(fx) ? ((FX*)fx)->blink : LOLOC(LADDR_from_68k(DUMMYBF(fx))))#define SETBLINK(fx,val) { ((FX*)fx)->blink =val;\E 5I 5#define GETBLINK(fx) (SLOWP(fx) ? ((FX*)(fx))->blink : LOLOC(LADDR_from_68k(DUMMYBF(fx))))#define SETBLINK(fx,val) { ((FX*)(fx))->blink =(val);\E 5			   if(FASTP(fx)){\D 5				((FX*)fx)->clink=((FX*)fx)->alink; \E 5I 5				((FX*)(fx))->clink=((FX*)(fx))->alink; \E 5				SLOWP(fx)=1;}}D 5#define GETCLINK(fx) (SLOWP(fx) ? (((FX*)fx)->clink -FRAMESIZE):(((FX*)fx)->alink -FRAMESIZE))#define SETCLINK(fx,val) { ((FX*)fx)->clink = val +FRAMESIZE;\E 5I 5#define GETCLINK(fx) (SLOWP(fx) ? (((FX*)(fx))->clink -FRAMESIZE):(((FX*)(fx))->alink -FRAMESIZE))#define SETCLINK(fx,val) { ((FX*)(fx))->clink = (val) +FRAMESIZE;\E 5D 8			if(FASTP((fx)){\E 8I 8			if(FASTP((fx))){\E 8D 5				((FX*)fx)->blink=LOLOC(LADDR_from_68k(DUMMYBF(fx)));\E 5I 5				((FX*)(fx))->blink=LADDR_from_68k(DUMMYBF(fx));\E 5D 7				SLOWP(fx)=1;}E 7I 7				SLOWP(fx)=1;}}E 7#define SETACLINK(fx,val) {if(FASTP(fx)) \D 5				 ((FX*)fx)->blink=LOLOC(LADDR_from_68k(DUMMYBF(fx)));\				((FX*)fx)->clink= val + FRAMESIZE;\				((FX*)fx)->alink= ((FX*)fx)->clink +1; }E 5I 5				 {((FX*)(fx))->blink=LADDR_from_68k(DUMMYBF(fx));}\				((FX*)(fx))->clink= (val) + FRAMESIZE;\				((FX*)(fx))->alink= ((FX*)(fx))->clink +1; }E 5I 39#ifdef BIGVM#define SWAP_FNHEAD#else#define SWAP_FNHEAD(x) swapx(x)#endif /* BIGVM */E 39I 17D 27#define GETNAMETABLE(fx) 					\E 27I 27#define GETNAMETABLE(fx)					\E 27D 18	(struct fnhead *) Addr68k_from_LADDR(swapx(		\E 18I 18D 39	((struct fnhead *) Addr68k_from_LADDR(swapx(		\E 39I 39	((struct fnhead *) Addr68k_from_LADDR(SWAP_FNHEAD(		\E 39E 18			((((FX2 *)fx)->validnametable)		\			? ((FX2 *)fx)->nametable		\			: ((FX2 *)fx)->fnheader			\D 18			)) & 0x00ffffff)E 18I 18D 39			)) & 0x00ffffff))E 39I 39			)) & POINTERMASK))E 39E 18E 17D 12#define	FVLOOKUP(fx, x, fh)	newframe(fx, x, (*((DLword *)fh + (fh->fvaroffset + ( ((int)x - (int)PVAR)>>2 ) - fh->nlocals))))E 12I 7#define MAKEFREEBLOCK(ptr68k,size)      ( *((LispPTR*)(ptr68k))=STK_FSB_32| ((DLword)(size)) )#define SETUPGUARDBLOCK(ptr68k,size)    ( *((LispPTR*)(ptr68k))=STK_GUARD_32| ((DLword)(size)) )I 31I 33/************************************************************************//*									*//*			   Stack-checking macros			*//*									*//*	Enabled when STACKCHECK compile flag is set.			*//*									*//************************************************************************/E 33E 31#ifdef STACKCHECKI 33E 33D 31#define S_CHECK(condition)	{ if(!(condition)) error("S_Check..");}E 31I 31#define S_CHECK(condition, msg)					\  { 								\    if(!(condition))						\      {								\	printf("\n\nStack check failed:  %s.\n\n", (msg));	\	error("S_Check..");					\I 33      }								\E 33  }I 34#define S_WARN(condition, msg, scanptr)				\  { 								\    if(!(condition))						\      {								\	printf("\n\nStack check failed at 0x%x:  %s.\n\n", (scanptr), (msg));	\      }								\  }E 34E 31#define CHECK_BF(bf68k) check_BF(bf68k)I 33E 33#define CHECK_FX(fx68k) check_FX(fx68k)D 33#define PreMoveFrameCheck(fx68k) { LispPTR *tos_on_stack; \ if(check_stack_rooms(fx68k) > 100){ \    warn("moveframe:there is more than 100 words SPACE for FX"); \E 33I 33#define PreMoveFrameCheck(fx68k)		\  { LispPTR *tos_on_stack; \    if(check_stack_rooms(fx68k) > 100)	\      { \	warn("moveframe:there is more than 100 words SPACE for FX"); \E 33	printf("# When calling "); \D 33    tos_on_stack=(LispPTR*)Addr68k_from_StkOffset((fx68k)->nextblock - 2); \E 33I 33	tos_on_stack=(LispPTR*)Addr68k_from_StkOffset((fx68k)->nextblock - 2); \E 33	print_atomname(*tos_on_stack); \	printf("\n"); \	stack_check(0); \D 33  }}E 33I 33      }			\  }E 33D 31#elseE 31I 31D 39#else STACKCHECKE 39I 39#else /* STACKCHECK */E 39I 39E 39E 31D 33#define S_CHECK(condition)	{}E 33I 33#define S_CHECK(condition,msg)	{}I 34#define S_WARN(condition, msg, scanptr) {}E 34E 33#define PreMoveFrameCheck(fx68k) {}#define CHECK_BF(bf68k) {}#define CHECK_FX(fx68k) {}D 31#endifE 31I 31D 39#endif STACKCHECKE 39I 39#endif /* STACKCHECK */E 39E 31I 11I 13D 16#define STK_MIN(fnobj) ((fnobj->stkmin+STK_SAFE) << 1)E 16I 16#define STK_MIN(fnobj) ((fnobj->stkmin /* NOT NEEDED in stkmin +STK_SAFE */) << 1)E 16E 13D 13#define STK_END_COMPUTE(stk_end,fnobj) 					\		( (int)stk_end - ( (fnobj->stkmin+STK_SAFE) << 1) )#define CLR_IRQ 							\	{Irq_Stk_End = (int) StkLimO;					\	 Irq_Stk_Check = STK_END_COMPUTE(Irq_Stk_End, FuncObj);		\	}E 11I 9#define STK_END_COMPUTE(stk_end,fnobj) 					\		( (int)stk_end - ( (fnobj->stkmin+STK_SAFE) << 1) )#define CLR_IRQ 							\	{Irq_Stk_End = (int) StkLimO;					\	 Irq_Stk_Check = STK_END_COMPUTE(Irq_Stk_End, FuncObj);		\	}E 13I 13D 14#define CLR_IRQ (Irq_Stk_Check=(Irq_Stk_End=(int)EndSTKP-STK_MIN(FuncObj)))E 14I 14D 27#define STK_END_COMPUTE(stk_end,fnobj) 					\E 27I 27#define STK_END_COMPUTE(stk_end,fnobj)					\E 27		( (int)stk_end - STK_MIN(fnobj) )E 14E 13I 14D 27#define CLR_IRQ 							\E 27I 27#define CLR_IRQ								\E 27	{Irq_Stk_Check = STK_END_COMPUTE((Irq_Stk_End = (int) EndSTKP), \					 FuncObj);			\	}E 14E 9E 7E 1