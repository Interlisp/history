h46091s 00002/00008/00114d D 1.3 93/02/08 14:53:05 sybalsky 3 2c Big VM (and new CDR coding) changes for 3.0 \nes 00013/00003/00109d D 1.2 92/04/22 14:51:31 sybalsky 2 1c fix sccses 00112/00000/00000d D 1.1 92/04/21 15:28:36 sybalsky 1 0c date and time created 92/04/21 15:28:36 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";D 2/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 2I 2/************************************************************************//*									*//*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*/D 3/************************************************************************/E 3E 2/*************************************************************************/D 3/*************************************************************************/D 2/*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 */E 2/*************************************************************************/E 3/*                                                                       *//*                       File Name : gcpunt.c                       *//*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : July-8-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions : gc_handleoverflow(arg);                         *//*                       gcmaptable(arg);                                *//*                                                                       *//*************************************************************************//*           Descreption :                                               *//*                                                                       *//*************************************************************************//*                                                               \Tomtom *//*************************************************************************/#include "lispemul.h"#include "lsptypes.h"#include "address.h"#include "adr68k.h"#include "lspglob.h"#include "gc.h"#define MAXSMALLP		65535#define HTBIGENTRYSIZE		4#define WORDSPERPAGE		256#define MAXTYPENUMBER		INIT_TYPENUMD 3#define GetSegnuminColl(entry1) ((entry1 & 0x01fe) >> 1)#define GetCountinColl(entry1)  ((entry1 & 0x0fc00) >> 10)#define GetStkCnt(entry1)		 ((entry1 & 0x0fe00) >> 9)E 3#define Oddp(num) (((num % 2) != 0)?1:0)#define Evenp(num,prim) (((num % prim) == 0)?1:0)#define Increment_Allocation_Count(n)			\    if (*Reclaim_cnt_word != NIL) 			\		if (*Reclaim_cnt_word > n)		\			(*Reclaim_cnt_word) -= n;	\		else { *Reclaim_cnt_word = NIL; 	\			  doreclaim();  		\			};				\gc_handleoverflow(arg)DLword	arg;   { struct htoverflow  *cell;     struct dtd	        *ptr;D 3     DLword		cellcnt;E 3I 3     LispPTR		cellcnt;E 3     LispPTR            addr;	  cell = (struct htoverflow *)HToverflow;			/* This proc. protected from interrupt */	while((addr = cell->ptr) != NIL)	   {		REC_GCLOOKUP(addr, cell->pcase);		cell->ptr = 0;		cell->pcase = 0;		++cell; /* (\ADDBASE CELL WORDSPERCELL) */	   };	ptr = (struct dtd *)GetDTD(TYPE_LISTP);		/* same as "extern struct dtd *ListpDTD" */	if ((cellcnt = ptr->dtd_cnt0) > 1024)	   { Increment_Allocation_Count(cellcnt);		ptr->dtd_oldcnt += cellcnt;		ptr->dtd_cnt0 = 0;	   };	return(arg);   }gcmaptable(arg)DLword	arg;   { struct htoverflow	*cell;	struct dtd	*ptr;D 3	DLword		cellcnt;E 3I 3	LispPTR		cellcnt;E 3	int		typnum;	LispPTR		addr;				cell = (struct htoverflow *)HToverflow;				/* This proc. protected from interrupt */	while((addr = cell->ptr) != NIL)	   {		REC_GCLOOKUP(addr, cell->pcase);		cell->ptr = 0;		cell->pcase = 0;		++cell; /* (\ADDBASE CELL WORDSPERCELL) */	   };	for(typnum = 1; typnum <= *MaxTypeNumber_word; ++typnum)	   /* applied alltype */	   { ptr = (struct dtd *)GetDTD(typnum);		if ((cellcnt = ptr->dtd_cnt0) != 0)		   { ptr->dtd_oldcnt += cellcnt;		     ptr->dtd_cnt0 = 0;		     Increment_Allocation_Count(cellcnt);		   };	   };	return(arg);   }E 1