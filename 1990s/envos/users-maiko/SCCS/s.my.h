h37490s 00011/00009/00183d D 2.15 93/02/08 15:05:21 sybalsky 17 16c Big VM (and new CDR coding) changes for 3.0 \nes 00012/00006/00180d D 2.14 92/11/25 20:20:32 sybalsky 16 15c Fixing extra text in endifs => comment.\nes 00000/00000/00186d D 2.13 92/04/21 16:31:12 sybalsky 15 14c shortening file names for DOSes 00003/00004/00183d D 2.12 90/06/15 17:01:04 mitani 14 13c GCLOOKUPes 00000/00000/00187d D 2.11 90/06/04 14:44:53 sybalsky 13 12c reformat, copyrightes 00030/00002/00157d D 2.10 90/06/01 16:28:25 sybalsky 12 11c For cross-machine compatibility, fix casts in N_MakeFloat so small negp's convert right.es 00025/00001/00134d D 2.9 90/03/21 12:27:00 takeshi 11 10c more 387Resetes 00015/00015/00120d D 2.8 89/03/27 15:14:27 sybalsky 10 9c MDStypetbl word-ptr ref -> GETWORD, many ptr refs -> macros.es 00000/00000/00135d D 2.7 89/03/27 15:03:52 sybalsky 9 8c nonees 00021/00021/00114d D 2.6 88/10/12 14:48:22 krivacic 8 7c new out-of-line interfacees 00125/00027/00010d D 2.5 88/07/06 14:38:14 charnley 7 6c aset and aref select macros with changed order.es 00005/00003/00032d D 2.4 88/06/07 15:24:39 charnley 6 5c fixed ites 00026/00019/00009d D 2.3 88/06/07 14:25:43 charnley 5 4c added N_GetPos macroes 00000/00024/00028d D 2.2 88/05/31 20:29:23 masinter 4 3c remove obsolete macroses 00000/00000/00052d D 2.1 88/05/17 09:18:45 hayata 3 2c Version up to 2.1es 00000/00006/00052d D 1.2 88/04/21 17:35:27 charnley 2 1c modified floating point conversion macroes 00058/00000/00000d D 1.1 88/03/22 14:59:59 charnley 1 0c date and time created 88/03/22 14:59:59 by charnleyeuUtTI 1D 10/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 10I 10D 14/* This is G-file @(#) my.h Version 2.6 (10/12/88). copyright Xerox & Fuji Xerox  */E 10/*  my.h  */E 14I 14D 16/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */E 16I 16/* %Z% %M% Version %I% (%G%). copyright venue   */E 16E 14I 12/************************************************************************//*									*//*				M Y . H					*//*									*//*									*//*									*//************************************************************************/I 16E 16/************************************************************************//*									*/D 16/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 16I 16/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 16/*									*/D 16/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 16I 16/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 16/*									*//************************************************************************/D 16E 16E 12#define S_CHARACTER 0x70000D 4#define gotoufn { ufn(0xFF & (*PC)); return; }E 4D 17E 17I 17#ifdef BIGVM#define IsNumber(address)     ((GETWORD(MDStypetbl +(((address) & 0x0fffff00)>>9))) & 0x1000)#elseE 17D 4E 4D 10#define IsNumber(address)     ((*(MDStypetbl +(((address) & 0x0ffff00)>>9))) & 0x1000)E 10I 10#define IsNumber(address)     ((GETWORD(MDStypetbl +(((address) & 0x0ffff00)>>9))) & 0x1000)I 17#endifE 17E 10D 4#define	MakeFloat(arg, dest){		\D 2int arg;				\float dest;				\E 2	switch (0xFFFF0000 & (int)arg) {	\	case S_POSITIVE:		\		dest = (float)(0xFFFF & (int)arg);	\		break;			\	case S_NEGATIVE:		\		dest = (float)(0xFFFF0000 | (int)arg);\		break;			\	default:			\		switch (GetTypeNumber(arg)) {	\		  case TYPE_FLOATP: 	\		    dest = *((float *)Addr68k_from_LADDR(arg));	\		    break; 			\		  case TYPE_FIXP: 	\		    dest = (float)(*((int *)Addr68k_from_LADDR(arg)));	\		    break;	\		  default: gotoufn;		\		}	\D 2		return;			\E 2	}				\}E 4I 12D 17E 17/************************************************************************//*									*//*			N _ M a k e F l o a t				*//*									*//*	Get a numeric argument as a flowting-point number, converting	*//*	from SMALLP or FIXP, if necessary.				*//*									*//************************************************************************/E 12D 5#define	N_MakeFloat(arg, dest, error_addr){		\D 2int arg, error_addr;				\float dest;				\E 2	switch (0xFFFF0000 & (int)arg) {	\	case S_POSITIVE:		\		dest = (float)(0xFFFF & (int)arg);	\		break;			\	case S_NEGATIVE:		\		dest = (float)(0xFFFF0000 | (int)arg);\		break;			\	default:			\		switch (GetTypeNumber(arg)) {	\		  case TYPE_FLOATP: 	\		    dest = *((float *)Addr68k_from_LADDR(arg));	\		    break; 			\		  case TYPE_FIXP: 	\		    dest = (float)(*((int *)Addr68k_from_LADDR(arg)));	\		    break;	\		  default: ERROR_EXIT(error_addr);		\		}	\D 2		return;			\E 2	}				\E 5I 5D 7#define	N_MakeFloat(arg, dest, error_addr){					\	switch (0xFFFF0000 & (int)arg) {					\	case S_POSITIVE:							\		dest = (float)(0xFFFF & (int)arg);				\		break;								\	case S_NEGATIVE:							\		dest = (float)(0xFFFF0000 | (int)arg);				\		break;								\	default:								\		switch (GetTypeNumber(arg)) {					\		  case TYPE_FLOATP: 						\		    dest = *((float *)Addr68k_from_LADDR(arg));			\		    break; 							\		  case TYPE_FIXP: 						\		    dest = (float)(*((int *)Addr68k_from_LADDR(arg)));		\		    break;							\		  default: ERROR_EXIT(error_addr);				\		}								\	}									\E 7I 7D 8#define	N_MakeFloat(arg, dest, error_addr){				\E 8I 8D 11#define	N_MakeFloat(arg, dest, tos){				\E 11I 11#ifndef I386#define	N_MakeFloat(arg, dest, tos){					\E 11E 8D 17	switch (0xFFFF0000 & (int)arg) {				\E 17I 17	switch (SEGMASK & (int)arg) {				\E 17	case S_POSITIVE:						\		dest = (float)(0xFFFF & (int)arg);			\		break;							\	case S_NEGATIVE:						\D 12		dest = (float)(0xFFFF0000 | (int)arg);			\E 12I 12		dest = (float)((int)(0xFFFF0000 | (int)arg));		\E 12		break;							\	default:							\		switch (GetTypeNumber(arg)) {				\		  case TYPE_FLOATP: 					\		    dest = *((float *)Addr68k_from_LADDR(arg));		\		    break; 						\		  case TYPE_FIXP: 					\		    dest = (float)(*((int *)Addr68k_from_LADDR(arg)));	\		    break;						\D 8		  default: ERROR_EXIT(error_addr);			\E 8I 8		  default: ERROR_EXIT(tos);				\E 8		}							\	}								\E 7E 5}I 11#else#define	N_MakeFloat(arg, dest, tos){		I386Reset;		\D 17	switch (0xFFFF0000 & (int)arg) {				\E 17I 17	switch (SEGMASK & (int)arg) {				\E 17	case S_POSITIVE:						\		dest = (float)(0xFFFF & (int)arg);			\		break;							\	case S_NEGATIVE:						\D 12		dest = (float)(0xFFFF0000 | (int)arg);			\E 12I 12		dest = (float)((int)(0xFFFF0000 | (int)arg));		\E 12		break;							\	default:							\		switch (GetTypeNumber(arg)) {				\		  case TYPE_FLOATP: 	I386Reset;				\		    dest = *((float *)Addr68k_from_LADDR(arg));		\		    break; 						\		  case TYPE_FIXP: 					\		    dest = (float)(*((int *)Addr68k_from_LADDR(arg)));	\		    break;						\		  default: ERROR_EXIT(tos);				\		}							\	}								\}D 16#endif I386E 16I 16#endif /* I386 */E 16E 11I 5D 7#define	N_GetPos(arg, dest, error_addr){					\	if ((arg & 0xFFFF0000) == S_POSITIVE)					\		dest = arg & 0xFFFF;						\D 6	else if (GetTypeNumber(arg) != TYPE_FIXP)				\E 6I 6	else {									\	if (GetTypeNumber(arg) != TYPE_FIXP) ERROR_EXIT(error_addr);		\	if ((dest = *((int *)Addr68k_from_LADDR(arg))) & 0x80000000)		\E 6		ERROR_EXIT(error_addr);						\D 6	else if ((dest = *((int *)Addr68k_from_LADDR(arg))) & 0x80000000)	\		ERROR_EXIT(error_addr);	}E 6I 6		}								\E 7I 7D 8#define	N_GetPos(arg, dest, error_addr){				\E 8I 8#define	N_GetPos(arg, dest, tos){					\E 8D 17	if ((arg & 0xFFFF0000) == S_POSITIVE)				\E 17I 17	if ((arg & SEGMASK) == S_POSITIVE)				\E 17		dest = arg & 0xFFFF;					\	else	{							\D 8	if (GetTypeNumber(arg) != TYPE_FIXP) ERROR_EXIT(error_addr);	\E 8I 8	if (GetTypeNumber(arg) != TYPE_FIXP) ERROR_EXIT(tos);		\E 8	if ((dest = *((int *)Addr68k_from_LADDR(arg))) & 0x80000000)	\D 8		ERROR_EXIT(error_addr);					\E 8I 8		ERROR_EXIT(tos);					\E 8		}							\E 7	}I 7D 8#define aref_switch(type, error_addr)					\E 8I 8#define aref_switch(type, tos)						\E 8{									\    switch (type) {							\      case 38: /* pointer : 32 bits */					\         return(*(((int *)Addr68k_from_LADDR(baseL)) + index));		\      case 20: /* signed : 16 bits */					\D 10         result = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;										\E 10I 10         result = (GETWORD(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;										\E 10         if (result & 0x8000) return(result | S_NEGATIVE);		\         else return(result | S_POSITIVE);				\      case 67: /* Character :  8 bits */				\D 10         return(S_CHARACTER | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF));								\E 10I 10         return(S_CHARACTER | ((GETBYTE(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF));								\E 10      case 22: /* signed : 32 bits */					\         result = *(((int *)Addr68k_from_LADDR(baseL)) + index);	\         N_ARITH_SWITCH(result);					\      case 0: /* unsigned : 1 bit per element */			\D 10         return(S_POSITIVE | (((*(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1));					\E 10I 10         return(S_POSITIVE | (((GETBYTE(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1));					\E 10      case 3: /* unsigned : 8 bits per element */			\D 10         return(S_POSITIVE | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF));								\E 10I 10         return(S_POSITIVE | ((GETBYTE(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF));								\E 10      case 4: /* unsigned : 16 bits per element */			\D 10         return(S_POSITIVE | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF));								\E 10I 10         return(S_POSITIVE | ((GETWORD(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF));								\E 10      case 54: /* Float : 32 bits */					\         wordp = createcell68k(TYPE_FLOATP);				\         *((int *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);										\         return(LADDR_from_68k(wordp));					\      case 68: /* Character :  16 bits */				\D 10         return(S_CHARACTER | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF));								\E 10I 10         return(S_CHARACTER | ((GETWORD(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF));								\E 10      case 86: /* XPointer : 32 bits */					\         return(*(((int *)Addr68k_from_LADDR(baseL)) + index));		\      default: /* Illegal or Unimplemented */				\D 8         ERROR_EXIT(error_addr);					\E 8I 8         ERROR_EXIT(tos);						\E 8    }/* end switch typenumber */					\}D 8#define aset_switch(type, error_addr)					\E 8I 8#define aset_switch(type, tos)						\E 8{									\   switch (type) {							\      case 38: /* pointer : 32 bits */					\D 8	GCLOOKUP(0x8000,DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));										\E 8I 8D 14	GCLOOKUP(0x8000,DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));\E 8	GCLOOKUP(0x8000,ADDREF, data);					\E 14I 14	GCLOOKUP(*(((int *)Addr68k_from_LADDR(base)) + index), DELREF); \	GCLOOKUP(data, ADDREF);						\E 14        *(((int *)Addr68k_from_LADDR(base)) + index) = data;		\        return(data);							\      case 20: /* signed : 16 bits */					\        new = data & 0xFFFF;						\D 17        if ((((data & 0xFFFF0000) == S_POSITIVE) && ((data & 0x8000) == 0)) ||\	    (((data & 0xFFFF0000) == S_NEGATIVE) && (data & 0x8000)))	\E 17I 17        if ((((data & SEGMASK) == S_POSITIVE) && ((data & 0x8000) == 0)) ||\	    (((data & SEGMASK) == S_NEGATIVE) && (data & 0x8000)))	\E 17D 10        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;		\E 10I 10        GETWORD(((DLword *)Addr68k_from_LADDR(base)) + index) = new;		\E 10D 8        else ERROR_EXIT(error_addr);					\E 8I 8        else ERROR_EXIT(tos);						\E 8        return(data);							\      case 67: /* Character :  8 bits */				\D 8        if ((data & 0xFFFF0000) != S_CHARACTER) ERROR_EXIT(error_addr);	\E 8I 8D 17        if ((data & 0xFFFF0000) != S_CHARACTER) ERROR_EXIT(tos);	\E 17I 17        if ((data & SEGMASK) != S_CHARACTER) ERROR_EXIT(tos);	\E 17E 8        new = data & 0xFFFF;						\D 8        if (new > 0xFF) ERROR_EXIT(error_addr);				\E 8I 8        if (new > 0xFF) ERROR_EXIT(tos);				\E 8D 10        *(((char *)Addr68k_from_LADDR(base)) + index) = new;		\E 10I 10        GETBYTE(((char *)Addr68k_from_LADDR(base)) + index) = new;		\E 10        return(data);							\      case 22: /* signed : 32 bits */					\        N_GETNUMBER(data, new, doufn);					\        *(((int *)Addr68k_from_LADDR(base)) + index) = new;		\        return(data);							\      case 0: /* unsigned : 1 bit per element */			\D 8        N_GetPos(data, new, error_addr);				\        if (new > 1) ERROR_EXIT(error_addr);				\E 8I 8        N_GetPos(data, new, tos);					\        if (new > 1) ERROR_EXIT(tos);					\E 8        if (new) {							\          new = (1 << (7 - (index & 7)));				\D 10          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) |= new;	\E 10I 10          GETBYTE(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) |= new;	\E 10        }								\        else {								\          new = 0xFF - (1 << (7 - (index & 7)));			\D 10          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) &= new;	\E 10I 10          GETBYTE(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) &= new;	\E 10        }								\        return(data);							\      case 3: /* unsigned : 8 bits per element */			\D 8        N_GetPos(data, new, error_addr);				\        if (new > 0xFF) ERROR_EXIT(error_addr);				\E 8I 8        N_GetPos(data, new, tos);					\        if (new > 0xFF) ERROR_EXIT(tos);				\E 8D 10        *(((char *)Addr68k_from_LADDR(base)) + index) = new;		\E 10I 10        GETBYTE(((char *)Addr68k_from_LADDR(base)) + index) = new;		\E 10        return(data);							\      case 4: /* unsigned : 16 bits per element */			\D 8        N_GetPos(data, new, error_addr); 				\        if (new > 0xFFFF) ERROR_EXIT(error_addr);			\E 8I 8        N_GetPos(data, new, tos); 					\        if (new > 0xFFFF) ERROR_EXIT(tos);				\E 8D 10        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;		\E 10I 10        GETWORD(((DLword *)Addr68k_from_LADDR(base)) + index) = new;		\E 10        return(data);							\      case 54: /* Float : 32 bits */					\D 8        if (GetTypeNumber(data) != TYPE_FLOATP) ERROR_EXIT(error_addr);	\E 8I 8        if (GetTypeNumber(data) != TYPE_FLOATP) ERROR_EXIT(tos);	\E 8        *(((int *)Addr68k_from_LADDR(base)) + index) = *((int *)Addr68k_from_LADDR(data));								\        return(data);							\      case 68: /* Character :  16 bits */				\D 8        if ((data & 0xFFFF0000) != S_CHARACTER) ERROR_EXIT(error_addr); 										\E 8I 8D 17        if ((data & 0xFFFF0000) != S_CHARACTER) ERROR_EXIT(tos); 	\E 17I 17        if ((data & SEGMASK) != S_CHARACTER) ERROR_EXIT(tos); 	\E 17E 8        new = data & 0xFFFF;						\D 10        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;		\E 10I 10        GETWORD(((DLword *)Addr68k_from_LADDR(base)) + index) = new;		\E 10        return(data);							\      case 86: /* XPointer : 32 bits */					\        *(((int *)Addr68k_from_LADDR(base)) + index) = data;		\        return(data);							\      default: /* Illegal or Unimplemented */				\D 8        ERROR_EXIT(error_addr);						\E 8I 8        ERROR_EXIT(tos);						\E 8    }/* end switch typenumber */					\}E 7E 6E 5E 1