h08401s 00036/00033/00050d D 2.10 93/02/08 14:58:39 sybalsky 14 13c Big VM (and new CDR coding) changes for 3.0 \nes 00004/00004/00079d D 2.9 92/04/21 17:23:13 sybalsky 13 12c shortening file names for DOS \nes 00004/00004/00079d D 2.8 90/06/15 16:56:32 mitani 12 11c GCLOOKUPes 00000/00000/00083d D 2.7 90/04/20 01:52:13 sybalsky 11 10c AIX:  shortening file names, bulk change.es 00002/00003/00081d D 2.6 88/10/12 14:44:48 krivacic 10 9c new out-of-line interfacees 00006/00006/00078d D 2.5 88/10/10 14:09:52 krivacic 9 8c sun3/4 mergees 00001/00001/00083d D 2.4 88/09/27 16:47:11 shih 8 7c sp correctiones 00000/00107/00084d D 2.3 88/09/27 15:36:45 shih 7 6c removed dead codees 00006/00008/00185d D 2.2 88/06/15 21:19:28 krivacic 6 5c make rplcons use an error exites 00000/00000/00193d D 2.1 88/05/17 09:26:27 hayata 5 4c Version up to 2.1es 00006/00006/00187d D 1.4 88/05/09 21:16:41 shih 4 3c Use GCLOOKUPes 00053/00000/00140d D 1.3 88/03/31 11:08:28 krivacic 3 2c native interfacees 00002/00002/00138d D 1.2 88/03/13 14:55:47 hayata 2 1c Add SCCS key id (%Z%)es 00140/00000/00000d D 1.1 88/02/24 16:58:16 hayata 1 0c date and time created 88/02/24 16:58:16 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 12I 12D 14/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 14I 14/* %Z% %M% Version %I% (%G%). copyright venue*/static char *id = "%Z% %M%	%I% %G%		(venue)";E 14E 12E 2D 14/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 8 *	Auther :  Takeshi ShimizuE 8I 8 *	Author :  Takeshi ShimizuE 8 * */E 14I 14/************************************************************************//*									*//*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************/E 14/***********************************************************************//* 		File Name :	rplcons.c		Desc	:	rplcons D 14 				Date :		Jun. 1, 1987 				Edited by :	Takeshi Shimizu				Changed :	Jun. 2 1987 take				Changed :	Jun. 12 1987 take				Changed :	Oct. 22 1987 take E 14		Including :	rplcons				OP_rplcons				*//**********************************************************************/#include "lispemul.h"D 13#include "emulglobal.h"#include "lispglobal.h"#include "lisptypes.h"E 13I 13#include "emlglob.h"#include "lspglob.h"#include "lsptypes.h"E 13#include "address.h"D 13#include "address68k.h"E 13I 13#include "adr68k.h"E 13#include "gc.h"#include "cell.h"    D 7rplcons(list , item) register LispPTR list ; register LispPTR item ;{ register struct conspage *conspage ; register ConsCell *new_cell , *list68k; LispPTR register page; page = POINTER_PAGE(list); list68k=(ConsCell *)Addr68k_from_LADDR(list);/* There are some rest Cell and "list" must be ONPAGE cdr_coded */ if(Listp(list) &&(GetCONSCount(page) != 0) && (list68k->cdr_code > CDR_MAXINDIRECT))  {D 4	gclookup(0x8000|ADDREF,item);	gclookup(0x8000|DELREF,cdr(list));E 4I 4	GCLOOKUP(0x8000,ADDREF,item);	GCLOOKUP(0x8000,DELREF,cdr(list));E 4	conspage = (struct conspage *)Addr68k_from_LPAGE(page);	new_cell =(ConsCell *)GetNewCell_68k(conspage);#ifdef DEBUG	if(new_cell->car_field != NIL) {		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));		error("QUIT from rplcons");	}#endif	conspage->count--;	conspage->next_cell= new_cell->cdr_code;	new_cell->car_field = item ;	new_cell->cdr_code = CDR_NIL;	ListpDTD->dtd_cnt0++;     list68k->cdr_code = CDR_ONPAGE | ((LADDR_from_68k(new_cell) &0xff)>>1) ;  return(LADDR_from_68k(new_cell) );   } /* ANOTHER CASE */ else  {	item = cons(item , NIL_PTR);	rplacd(list,item);	return(item);  }}/***************************************************/OP_rplcons(){ register LispPTR list ; register struct conspage *conspage ; register ConsCell *new_cell , *list68k; LispPTR register page; /* tos == item */ list=GetLongWord(CurrentStackPTR); CurrentStackPTR -= 2;#ifdef TRACE	printPC();	printf("TRACE: OP_rplcons \n");	print(TopOfStack);	print(list);#endif page = POINTER_PAGE(list); list68k=(ConsCell *)Addr68k_from_LADDR(list);/* There are some rest Cell and "list" must be ONPAGE cdr_coded */ if(Listp(list) && (GetCONSCount(page) != 0) && (list68k->cdr_code > CDR_MAXINDIRECT))  {D 4	gclookup(0x8000|ADDREF,TopOfStack);	gclookup(0x8000|DELREF,cdr(list));E 4I 4	GCLOOKUP(0x8000,ADDREF,TopOfStack);	GCLOOKUP(0x8000,DELREF,cdr(list));E 4	conspage = (struct conspage *)Addr68k_from_LPAGE(page);	new_cell =(ConsCell *)GetNewCell_68k(conspage);	conspage->count--;	conspage->next_cell= new_cell->cdr_code;	new_cell->car_field = TopOfStack ;	new_cell->cdr_code = CDR_NIL ;	ListpDTD->dtd_cnt0++;     list68k->cdr_code = CDR_ONPAGE | ((LADDR_from_68k(new_cell) &0xff)>>1) ;  TopOfStack = LADDR_from_68k(new_cell) ;   PC++;  } /* ANOTHER CASE */ else  {	TopOfStack = cons(TopOfStack , NIL_PTR);	rplacd(list,TopOfStack);	PC++;  }}I 3E 7/***************************************************/D 6N_OP_rplcons(list, item)E 6I 6D 10N_OP_rplcons(list, item, error_addr)E 10I 10N_OP_rplcons(list, item)E 10E 6D 14	register LispPTR list;	register LispPTR item;I 6D 10	int *error_addr;E 10E 6{ register struct conspage *conspage ; register ConsCell *new_cell , *list68k;E 14I 14  register LispPTR list;  register LispPTR item;  {    register struct conspage *conspage ;    register ConsCell *new_cell , *list68k;E 14D 14 LispPTR register page;E 14I 14    LispPTR register page;E 14I 9D 10 if(!Listp(list)) ERROR_EXIT(error_addr);E 10I 10D 14 if(!Listp(list)) ERROR_EXIT(item);E 14I 14    if(!Listp(list)) ERROR_EXIT(item);E 14E 10E 9D 6#ifdef TRACE	printf("TRACE: N_OP_rplcons \n");	print(item);	print(list);#endifE 6D 14 page = POINTER_PAGE(list); list68k=(ConsCell *)Addr68k_from_LADDR(list);E 14I 14    page = POINTER_PAGE(list);    list68k=(ConsCell *)Addr68k_from_LADDR(list);E 14D 14/* There are some rest Cell and "list" must be ONPAGE cdr_coded */D 9 if(Listp(list) && (GetCONSCount(page) != 0) && (list68k->cdr_code > CDR_MAXINDIRECT))E 9I 9 if((GetCONSCount(page) != 0) && (list68k->cdr_code > CDR_MAXINDIRECT))E 9  {E 14I 14    /* There are some rest Cell and "list" must be ONPAGE cdr_coded */#ifndef NEWCDRCODING    if((GetCONSCount(page) != 0) && (list68k->cdr_code > CDR_MAXINDIRECT))      {E 14D 4	gclookup(0x8000|ADDREF,item);	gclookup(0x8000|DELREF,cdr(list));E 4I 4D 12	GCLOOKUP(0x8000,ADDREF,item);	GCLOOKUP(0x8000,DELREF,cdr(list));E 12I 12	GCLOOKUP(item, ADDREF);	GCLOOKUP(cdr(list), DELREF);E 12E 4	conspage = (struct conspage *)Addr68k_from_LPAGE(page);	new_cell =(ConsCell *)GetNewCell_68k(conspage);	conspage->count--;D 14	conspage->next_cell= new_cell->cdr_code;E 14I 14	conspage->next_cell= ((freecons *)new_cell)->next_free;E 14	new_cell->car_field = item ;	new_cell->cdr_code = CDR_NIL ;	ListpDTD->dtd_cnt0++;D 9     list68k->cdr_code = CDR_ONPAGE | ((LADDR_from_68k(new_cell) &0xff)>>1) ;E 9I 9	list68k->cdr_code = CDR_ONPAGE | ((LADDR_from_68k(new_cell) &0xff)>>1) ;E 9D 9  return(LADDR_from_68k(new_cell)) ; E 9I 9	return(LADDR_from_68k(new_cell)) ; E 9I 6D 9bad_rplacd: ERROR_EXIT(error_addr);E 9E 6D 14  }D 9 /* ANOTHER CASE */E 9 else  {D 6	rplacd(list, item = cons(item , NIL_PTR));E 6I 6D 9	N_OP_rplacd(list, item = cons(item , NIL_PTR), bad_rplacd);E 9I 9	N_OP_rplacd(list, item = cons(item , NIL_PTR), 0);E 14I 14      }    else#endif /* ndef NEWCDRCODING */      {	N_OP_rplacd(list, item = cons(item , NIL_PTR));E 14E 9E 6	return(item);I 14      }E 14  }D 14}E 14E 3E 1