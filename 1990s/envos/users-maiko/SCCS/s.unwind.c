h47015s 00001/00001/00224d D 2.23 93/02/08 15:00:38 sybalsky 31 30c Big VM (and new CDR coding) changes for 3.0 \nes 00002/00002/00223d D 2.22 92/04/21 17:28:25 sybalsky 30 29c shortening file names for DOS \nes 00000/00000/00225d D 2.21 90/04/20 02:07:43 sybalsky 29 28c AIX:  shortening file names, bulk change.es 00014/00006/00211d D 2.20 90/04/19 22:49:43 sybalsky 28 27c AIX fixeses 00004/00004/00213d D 2.19 89/03/27 23:32:49 sybalsky 27 26c word-ptr refs -> GETWORDes 00033/00033/00184d D 2.18 88/12/23 14:11:35 shih 26 25c wrong sccs id, minor cleanupes 00005/00003/00212d D 2.17 88/10/12 14:45:54 krivacic 25 24c new out-of-line interfacees 00121/00001/00094d D 2.16 88/10/04 14:04:09 krivacic 24 23c temp for merge (started catch/throw)es 00001/00000/00094d D 2.15 88/09/27 19:54:08 shih 23 22c added emulglobal.h back (phasing problem)es 00004/00011/00090d D 2.14 88/09/27 17:02:33 krivacic 22 21c remove unused includeses 00000/00065/00101d D 2.13 88/09/27 15:43:26 shih 21 20c removed dead C_ONLY codedes 00008/00005/00158d D 2.12 88/09/20 11:41:21 krivacic 20 19c fix the comment line for unwindes 00002/00002/00161d D 2.11 88/09/20 11:12:47 krivacic 19 18c fix bug with (keep), it needed to increment cstkptr after doing the assignmentes 00002/00002/00161d D 2.10 88/08/19 15:47:49 krivacic 18 17c fix documentationes 00033/00034/00130d D 2.9 88/08/17 13:08:21 krivacic 17 16c cleanup & fix scan buges 00006/00006/00158d D 2.8 88/08/16 18:09:11 krivacic 16 15c extra code cleanupes 00044/00019/00120d D 2.7 88/08/16 17:54:46 krivacic 15 14c fix AR 10779 (get out of loop 1 sooner)es 00002/00002/00137d D 2.6 88/06/21 19:40:58 shih 14 13c restored SCCSID stampses 00022/00047/00117d D 2.5 88/06/16 11:31:29 charnley 13 12c was missing changes, fixed.es 00002/00002/00162d D 2.4 88/06/14 13:47:43 charnley 12 11c fixed n_op version of unwind.es 00000/00002/00164d D 2.3 88/05/31 20:58:48 shih 11 10c Remove call to obsolete ufn (for LM)es 00015/00016/00151d D 2.2 88/05/31 11:17:43 shimizu 10 9c Change boundary check in N_OP_unwindes 00000/00000/00167d D 2.1 88/05/17 09:27:31 hayata 9 8c Version up to 2.1es 00002/00003/00165d D 1.8 88/05/13 10:13:01 hayata 8 7c Add SCCS keyides 00002/00002/00166d D 1.7 88/05/02 12:28:30 shimizu 7 6c Not changed,Just SCCS problemes 00022/00015/00146d D 1.6 88/04/29 17:59:17 shimizu 6 5c Change boundary condition checkes 00004/00003/00157d D 1.5 88/04/14 10:36:55 krivacic 5 4c fix unwind buges 00002/00002/00158d D 1.4 88/04/13 20:18:56 shimizu 4 3c LispPTR temp -> int temp(signed)es 00074/00000/00086d D 1.3 88/03/31 15:11:27 krivacic 3 2c storen, copyn, arg0, assoces 00002/00002/00084d D 1.2 88/03/13 15:09:27 hayata 2 1c Add SCCS key id (%Z%)es 00086/00000/00000d D 1.1 88/02/24 16:58:57 hayata 1 0c date and time created 88/02/24 16:58:57 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 7/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 7I 7D 8/* This is G-file @(#) unwind.c Version 1.6 (4/29/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) unwind.c	1.6 4/29/88";E 7E 2E 8I 8D 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 12I 12D 14/* This is G-file @(#) unwind.c Version 2.3 (5/31/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) unwind.c	2.3 5/31/88";E 14I 14D 22/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 22I 22D 26/* This is G-file @(#) unwind.c Version 2.12 (9/20/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) unwind.c	2.12 9/20/88";E 26I 26D 28/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 26E 22E 14E 12E 8/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. */E 28I 28/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(Venue & Fuji Xerox)";E 28I 28/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 28/******************************************************************//*		File Name  :	unwind.c		Created    :	jul 17, 1987 by T.ShimizuD 22		Changed	   :	Jan 21 1988  takeshiE 22I 22		Changed	   :	Sept 21 1988  BKE 22*//******************************************************************/#include "lispemul.h"I 23D 30#include "emulglobal.h"E 30I 30#include "emlglob.h"E 30I 24#include "stack.h"D 30#include "lispglobal.h"E 30I 30#include "lspglob.h"E 30E 24E 23D 22#include "address.h"#include "address68k.h"#include "lisptypes.h"#include "lispmap.h"#include "stack.h"#include "emulglobal.h"#include "lispglobal.h"E 22D 6OP_unwind() { int  num ;  /* number of UNBOUND slot */ E 6I 6D 21typedef struct {	DLword bind_negval;	DLword bind_lastpvar; } BINDSLOT;OP_unwind() {   int  num ;  /* number of UNBOUND slot */ E 6  DLword *endptr; /* unwind limit */   DLword *lastpvar; /* points PVar slot that is unbounded. */#ifdef TRACE 	printPC(); printf("TRACE: OP_unwind() \n");#endif I 6endptr = PVar + (2 * (Get_BYTE(PC+1))) - DLWORDSPER_CELL; /* set unwind limit */ E 6D 6endptr = PVar + 2 * (Get_BYTE(PC+1)); /* set unwind limit */ E 6I 6D 11if(endptr > CurrentStackPTR) ufn(07);E 6E 11D 6if((endptr-2) > CurrentStackPTR) ufn(07);E 6 if(0x80000000 & TopOfStack) /* TOS has BIND mark */   {	num = (~(TopOfStack)) >> 16 ; /* get number */ 	lastpvar =PVar +( TopOfStack & 0xffff ); /* get lastpvar */   }  else   { 	while(!( ((WBITS *)CurrentStackPTR)->MSB ))	{ /* searching BIND mark */	  CurrentStackPTR -= 2;D 6	  if(endptr >= CurrentStackPTR) goto UNWSTOP;E 6I 6	  if(endptr > CurrentStackPTR) goto UNWSTOP;E 6	}D 6	num = ~(*CurrentStackPTR); /* get number */	lastpvar =PVar +(*(CurrentStackPTR +1)) ;      /* get lastpvar */E 6I 6	num = ~(((BINDSLOT*)CurrentStackPTR)->bind_negval); /* get number */	lastpvar =PVar +(((BINDSLOT*)CurrentStackPTR)->bind_lastpvar) ;      /* get lastpvar */E 6  }/* UNBUND MARK loop */do { 	for(;D 6		num!=0; lastpvar -= 2,num--)E 6I 6		num>0; lastpvar -= DLWORDSPER_CELL,num--)E 6	 {		*lastpvar = 0xffff ; /* Mark as UNBOUND */	 }D 6      while(!( ((WBITS*)CurrentStackPTR)->MSB ) )E 6I 6	     doE 6	{ /* searching  next BIND mark */D 6	  CurrentStackPTR -= 2;	  if(endptr >= CurrentStackPTR) goto UNWSTOP;	}	num = ~(*(CurrentStackPTR)); /* get number */	lastpvar =PVar + (*(CurrentStackPTR+1));      /* get lastpvar */E 6I 6	  CurrentStackPTR -= DLWORDSPER_CELL;	  if(endptr > CurrentStackPTR) goto UNWSTOP;	}while(!( ((WBITS*)CurrentStackPTR)->MSB ) );	num = ~(((BINDSLOT*)CurrentStackPTR)->bind_negval); /* get number */	lastpvar =PVar + (((BINDSLOT*)CurrentStackPTR)->bind_lastpvar);      /* get lastpvar */E 6   } while(endptr < CurrentStackPTR); UNWSTOP: PC += 3 ;I 6 CurrentStackPTR += DLWORDSPER_CELL;E 6 if(Get_BYTE(PC-1)) /* keep TOS */  {	return;  } else  {	PopCStack;	return;  } } /* OP_unwind */I 3E 21D 22/* ************************************************************ */E 22I 22E 22D 24E 24D 13LispPTR N_OP_unwind(the_cstkptr, tos, n, error_addr) E 13I 13D 17LispPTR N_OP_unwind(the_cstkptr, tos, n, keep, error_addr) E 13	LispPTR *the_cstkptr;E 17I 17D 25LispPTR N_OP_unwind(cstkptr, tos, n, keep, error_addr) E 25I 25D 26LispPTR N_OP_unwind(cstkptr, tos, n, keep) E 26I 26LispPTR N_OP_unwind(cstkptr, tos, n, keep)E 26E 25	register LispPTR *cstkptr;E 17	register LispPTR tos;D 17	register int n;E 17I 17	int n;E 17I 13	int keep;E 13D 25	int *error_addr;E 25D 26{ register int  num ;  /* number of UNBOUND slot */   register LispPTR *endptr; /* unwind limit */ E 26I 26{ register int  num ;  /* number of UNBOUND slot */  register LispPTR *endptr; /* unwind limit */E 26  register LispPTR *lastpvar; /* points PVar slot that is unbounded. */D 17  register LispPTR *cstkptr = the_cstkptr;E 17D 13#ifdef TRACE 	printPC(); printf("TRACE: N_OP_unwind() \n");#endif I 10cstkptr -= 1;		/* adjust to point to where tos should be */endptr = (LispPTR *) (PVar + DLWORDSPER_CELL * (n-1) ); /* set unwind limit */ E 13I 13D 15endptr = (LispPTR *) PVar + (n - 1); /* set unwind limit */ E 15E 13E 10I 15/* Slots:	-----------------	|		|	<- PVar	-----------------	|	.	|	|	.	|	-----------------D 17	|		|	<- endptr (PVar[n-1]) 	-----------------	|		|	<- Result (no keep)	-----------------	|	tos	|	<- Result (keep)	-----------------	|		|	-----------------	|	.	|	|	.	|	-----------------	|		|	<- Start CSTKPTR	-----------------E 17I 17D 20	|		|	 ALL OF THE FOLLOWING LOCATIONS SCANNEDE 20I 20	|		|	 ALL OF THE FOLLOWING LOCATIONS SCANNED:E 20	-----------------------------------------------------------------D 20	|		|	<- endptr (PVar[n]) <- Result (no keep)	|E 20I 20	| tos if keep	|	<- endptr (PVar[n]) <- Result (no keep)	|E 20	-----------------						|D 20	| tos if keep	|	<- Result (keep)			|E 20I 20D 26	| 		|	<- Result (keep)			|E 26I 26	|		|	<- Result (keep)			|E 26E 20	-----------------						|	|		|						|	-----------------						|	|	.	|						|	|	.	|						|	-----------------						|D 18	|		|	<- Start CSTKPTR			|E 18I 18	|   tos pushed	|	<- Start CSTKPTR			|E 18D 20	-----------------						|D 18	|   tos pushed	|						|E 18I 18	|   		|						|E 20E 18	-----------------------------------------------------------------I 20D 26	|   		|	<- CSTKPTR temporarily bumped pushing tos	-----------------					E 26I 26	|		|	<- CSTKPTR temporarily bumped pushing tos	-----------------E 26	NOTE: upon return the emulator does a POP to get the new tos valueE 20E 17*/D 17endptr = -1 + (LispPTR *) PVar + n; 			/* set unwind limit */ E 17I 17D 26endptr = (LispPTR *) PVar + n; 			/* set unwind limit */ E 26I 26endptr = (LispPTR *) PVar + n;			/* set unwind limit */E 26E 17E 15D 10endptr = (LispPTR *) (PVar + 2 * n); /* set unwind limit */ E 10D 13if(endptr > cstkptr) ERROR_EXIT(error_addr);E 13I 13D 25if (endptr > cstkptr) ERROR_EXIT(error_addr);E 25I 25if (endptr > cstkptr) {D 26	(LispPTR *) CurrentStackPTR = cstkptr; E 26I 26D 28	(LispPTR *) CurrentStackPTR = cstkptr;E 28I 28	CurrentStackPTR = (DLword *) cstkptr;E 28E 26	ERROR_EXIT(tos);	}E 25D 17*(cstkptr) = tos;E 17I 17*cstkptr++ = tos;E 17E 13D 10cstkptr -= 1;		/* adjust to point to where tos should be */E 10I 17	/* UNBOUND MARK loop  */E 17D 13 if(0x80000000 & tos) /* TOS has BIND mark */   {	num = (~(tos)) >> 16 ; 	lastpvar = (LispPTR *) (PVar +( tos & 0xffff ));   }  else   { 	while(!( ((WBITS *)cstkptr)->MSB ))	{ /* searching BIND mark */D 10	  cstkptr -= 1;	  if(endptr >= cstkptr) goto UNWSTOP;E 10I 10	  cstkptr --;	  if(endptr > cstkptr) goto UNWSTOP;E 10	}D 4	{register LispPTR temp = *cstkptr;E 4I 4D 10	{register int temp = *cstkptr;E 4 	 num = ~(temp >> 16); 	 lastpvar = (LispPTR *) (PVar +(temp & 0xffff)) ;E 10I 10	{/**register int temp = *cstkptr;**/ 	 num = ~(((BINDSLOT*)cstkptr)->bind_negval); 	 lastpvar = (LispPTR *) (PVar +((BINDSLOT*)CurrentStackPTR)->bind_lastpvar) ;E 10	}  }E 13D 13/* UNBUND MARK loop */E 13I 13D 15/* UNBOUND MARK loop */E 15I 15D 17	/* UNBOUND MARK loop */E 15E 13do {E 17I 17D 26while (cstkptr > endptr)  E 26I 26while (cstkptr > endptr)E 26   {E 17D 13 	for(;D 10		num!=0; lastpvar -= 1,num--)E 10I 10		num>0; lastpvar--,num--)E 10	 {		*lastpvar = 0xffffffff ; /* Mark as UNBOUND */	 }D 10      while(!( ((WBITS*)cstkptr)->MSB ) )E 10I 10      doE 10	{ /* searching  next BIND mark */D 10	  cstkptr -= 1;	  if(endptr >= cstkptr) goto UNWSTOP;	}D 4	{register LispPTR temp = *cstkptr;E 4I 4	{register int temp = *cstkptr;E 4 	 num = ~(temp >> 16); 	 lastpvar = (LispPTR *) (PVar +(temp & 0xffff)) ;E 10I 10	  cstkptr --;	  if(endptr > cstkptr) goto UNWSTOP;	}while(!( ((WBITS*)cstkptr)->MSB ) );	{/**register int temp = *cstkptr;**/E 13I 13D 15      while(!( ((WBITS*)cstkptr)->MSB ) )	{	  if(endptr > --cstkptr) goto UNWSTOP;	}	{E 13 	 num = ~(((BINDSLOT*)cstkptr)->bind_negval); 	 lastpvar = (LispPTR *) (PVar +(((BINDSLOT*)cstkptr)->bind_lastpvar)) ;I 13	 	for(; num > 0; lastpvar--, num--)		 {			*lastpvar = 0xffffffff ; /* Mark as UNBOUND */		 }E 13E 10	}I 13      cstkptr--;   } while(endptr <= cstkptr);E 15I 15		/* Look for the Next BIND marker */E 15E 13D 13   } while(endptr < cstkptr);E 13D 15 UNWSTOP:E 15I 15D 17	while(!( ((WBITS*)cstkptr)->MSB ) )		{ if(endptr >= --cstkptr) goto UNWSTOP; }E 17I 17	if( (num = (int) *--cstkptr) < 0 )	   {E 17E 15D 13 if(n) E 13I 13D 15 cstkptr++;	/* get to where Native CSTKPTR should be */E 15I 15		/* Now UNBIND the PVARS indicated by the BIND marker */E 15I 15D 16	num = ~(((BINDSLOT*)cstkptr)->bind_negval); 	lastpvar = (LispPTR *) (PVar +(((BINDSLOT*)cstkptr)->bind_lastpvar)) ;	for(; num > 0; lastpvar--, num--)E 16I 16D 17	num = (int) *cstkptr; 	lastpvar = (LispPTR *) (PVar + (unsigned short) num) ;	num = ~((unsigned int)num >> 16); 	for(; num > 0; num--)E 16	 {D 16		*lastpvar = 0xffffffff ; /* Mark as UNBOUND */E 16I 16		*lastpvar-- = 0xffffffff ; /* Mark as UNBOUND */E 16	 }	D 16      cstkptr--;			/* get past the BIND marker */   } while(endptr < cstkptr);E 16I 16   } while(endptr < --cstkptr);E 17I 17	    lastpvar = (LispPTR *) (2 + PVar + (unsigned short) num) ;D 26	    num = ~(num >> 16) + 1; E 26I 26	    num = ~(num >> 16) + 1;E 26	    for(; --num > 0; )	     { *--lastpvar = 0xffffffff ; /* Mark as UNBOUND */ }	    };   };E 17E 16D 17 UNWSTOP:E 17I 17D 26 E 26I 26E 26/* endptr = cstkptr */E 17E 15D 26 if(keep) E 13D 5  {	return((LispPTR) (cstkptr + 1));E 5I 5D 19  {	cstkptr++;	*(cstkptr) = tos;E 19I 19  {	E 26I 26 if(keep)  {E 26	*(cstkptr++) = tos;E 19D 13	return((LispPTR) cstkptr);E 13E 5  }D 13 elseD 5  {	*(cstkptr-1) = tos;E 5I 5  {	E 5	return((LispPTR) cstkptr);  } E 13I 13D 15  return((LispPTR) cstkptr);E 15I 15 return((LispPTR) cstkptr);E 15E 13D 13} /* OP_unwind */E 13I 13} /* N_OP_unwind */I 24#ifdef CATCH/******************************************************************//*	SUBR: FIND_THE_BLIPD 26	find the blip down in the stack.  Similar to the LISP 	SI::UNWIND-TO-BLIP, except the target is returned instead E 26I 26	find the blip down in the stack.  Similar to the LISP	SI::UNWIND-TO-BLIP, except the target is returned insteadE 26	of doing the unwinding.  Note that the unwider parameter	must already be properly set by the caller (i.e. to the	alink if necessary).*//******************************************************************/#define SMALLP(x) (((unsigned int)x >> 16) == (S_POSITIVE >> 16))D 26find_the_blip(blip, throwp, unwinder) E 26I 26find_the_blip(blip, throwp, unwinder)E 26	register LispPTR blip;	register LispPTR throwp;	FX *unwinder;{	register LispPTR target;	register FX *target_addr;	register LispPTR pc = NIL_PTR;LispPTR CATCH_RETURN_PC_ATOM = parse_atomstring("SI::*CATCH-RETURN-PC*");LispPTR CHATCH_RETURN_TO_ATOM = parse_atomstring("SI::*CATCH-RETURN-TO*");LispPTR CATCH_RETURN_FROM_ATOM = parse_atomstring("SI::*CATCH-RETURN-FROM*");D 26		for (target = (LispPTR) unwinder; 			FX_INVALIDP(target); E 26I 26	for (target = (LispPTR) unwinder;			FX_INVALIDP(target);E 26			GETCLINK(target_addr)) {	    target_addr = (FX *) Addr68k_from_StkOffset(target);	    if (blip == *target_addr)	{		register LispPTR var_name_in_frame =		    variable_name_in_frame(target_addr, (FVPVAR << 8) + 1);		if (var_name_in_frame == CHATCH_RETURN_TO_ATOM) {		    if (throwp) {			pc = pvar_value_in_frame(target_addr, CATCH_RETURN_PC_ATOM);D 26			if !(SMALLP(pc)) E 26I 26			if !(SMALLP(pc))E 26			    error("Catch return-to frame lacks PC");			}		    goto cons_result;D 26		} else E 26I 26		} elseE 26		if (var_name_in_frame == CATCH_RETURN_FROM_ATOM) {		    if (throwp) {target = GETCLINK(target_addr); };		    goto cons_result;D 26		} E 26I 26		}E 26		} /* if blip */	    }; /* for */no_result:	return(NIL_PTR);cons_result:	return(cons(StkOffset_from_68K(target), pc));}LispPTR variable_name_in_frame(fx_addr, code)	FX *fx_addr;	register LispPTR code;{	register DLword *name_ptr;	register DLword *name_bind_ptr;	register DLword *name_table_base;	register DLword value;	name_table_base = Addr68k_from_LADDR(GETNAMETABLE(fx_addr));	name_ptr = name_table_base + FNHEADSIZE;	name_table_base = name_ptr + ((FNHEAD *) name_table_base)->ntsize;D 26	E 26I 26E 26D 27	while (value = *name_ptr++) do {D 26	    if (code == *name_bind_ptr++) {return(value) } ; E 26I 26	    if (code == *name_bind_ptr++) {return(value) } ;E 27I 27	while (value = GETWORD(name_ptr++)) do {	    if (code == GETWORD(name_bind_ptr++)) {return(value) } ;E 27E 26	    }; /* while */	return(NIL_PTR);}; /* variable_name_in_frame *//******************************************************************//*D 26	pvar_value_in_frame searches through the name table for 	frame_addr looking for the binding of atom_index.  It 	returns the PVAR value of the binding if the PVAR is found E 26I 26	pvar_value_in_frame searches through the name table for	frame_addr looking for the binding of atom_index.  It	returns the PVAR value of the binding if the PVAR is foundE 26	& it is bound.*/D 26/******************************************************************/	E 26I 26/******************************************************************/E 26LispPTR pvar_value_in_frame(frame_addr, atom_index)D 26	register  FX 		*frame_addr;E 26I 26	register  FX		*frame_addr;E 26	register  LispPTR	atom_index;{	register DLword *name_ptr;	register DLword *name_bind_ptr;	register DLword *name_table_base;	register DLword value;	name_table_base = Addr68k_from_LADDR(GETNAMETABLE(frame_addr));	name_ptr = name_table_base + FNHEADSIZE;	name_table_base = name_ptr + ((FNHEAD *) name_table_base)->ntsize;D 26	E 26I 26E 26D 27	while (value = *name_ptr++) do {E 27I 27	while (value = GETWORD(name_ptr++)) do {E 27	    if (value == atom_index) {D 27		register DLword bind_info = *name_bind_ptr;E 27I 27		register DLword bind_info = GETWORD(name_bind_ptr);E 27		if ((bind_info >> 8) == FVPVAR) {		    register LispPTR slot_value =D 26			*((LispPTR *) (FRAMESIZE + (DLword *) frame_addr) + E 26I 26			*((LispPTR *) (FRAMESIZE + (DLword *) frame_addr) +E 26				(bind_info - (FVPVAR << 8)))D 31		    if (slot_value > 0) { return(slot_value & 0xffffff); };E 31I 31		    if (slot_value > 0) { return(slot_value & POINTERMASK); };E 31		    };		};	    name_bind_ptr++;	    }; /* while */	return(NIL_PTR);}; /* pvar_value_in_frame */#endifE 24E 13E 3E 1