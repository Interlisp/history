h08528s 00736/00000/00000d D 2.3 88/04/19 11:47:40 shimizu 6 5c Add O commes 00002/00000/00715d D 2.2 88/05/18 19:12:15 shimizu 5 4c Add C commes 00000/00000/00715d D 2.1 88/05/17 09:27:35 hayata 4 3c Version up to 2.1es 00003/00002/00712d D 1.3 88/05/13 10:13:58 hayata 3 2c Add SCCS keyides 00002/00002/00712d D 1.2 88/05/12 21:26:36 shih 2 1c es 00715/00000/00000d D 1.1 88/05/11 17:49:39 shimizu 1 0c date and time created 88/05/11 17:49:39 by shimizueuUtTI 6/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";#include <stdio.h>#include "lispemul.h"#include "lispmap.h"#include "address68k.h"#include "lisptypes.h"#include "lispglobal.h"#include "emulglobal.h"#include "cell.h"#include "stack.h"#include "ifpage.h"#include "debug.h"#include <sys/file.h>#include <sys/types.h>#include <sys/param.h>#include <sys/ioctl.h>#include <fcntl.h>#include <sundev/kbd.h>#include <sundev/kbio.h>#include <errno.h>#include <sunwindow/window_hs.h>#include <sunwindow/win_ioctl.h>#include <pixrect/pixrect_hs.h>#include <sunwindow/win_cursor.h>#include <sunwindow/cms.h>#include <sys/mman.h>/***********************************************************************//*	File name : uraid.c	Written by : Takeshi Shimizu(Take)	Date:   6-May-1988	This File Supports the following commands:**URAID commands summary**<<Displaying a Stack>>c                       Checks all user stack contentsf number                Displays Frame extention for the number(decimal)k type                  Changes the type of stack link following.(a|c)l [type]                Back Trace for Specified type stack.(k|m|r)<CR>                    Display next frame.<<Displaying the Memory contents>>a litatom               Displays the top-level value of the litatomd litatom               Displays the Definition Cell for the litatomM                       Displays TOS,CSP,PVAR,IVAR,PCm func1 func2           MOVED func1 to func2t Xaddress              Displays the type of this objectp litatom               Displays the Propaty list of the litatomw                       Displays the current function-name and PCx Xaddress [xnum]       Hex-Dump xnum word(16-bits) starting at Xaddress@ litatom val           Sets TOPVAL of litatom to val< Xaddress val          Sets the word(16-bits) at the address to val<<Return or Exit>>e                       Exit to UNIXh                       Context switch to HARDRESETq                       Returns from URAID with NIL<<Misc>>s                       Invoke Shellv filename              Save the current virtual memory on the filename( [num]                 Sets Print level?                       Display this summary*//************************************************************************/extern unsigned int LispReadFds,LispWindowFd,LispKbdFd;extern struct pixrect *ScreenBitMap,*CursorBitMap,*InvisibleCursorBitMap;extern struct screen LispScreen;extern int DisplayWidth,DisplayHeight;extern DLword *DisplayRegion68k;extern int FrameBufferFd,ether_fd,RS232C_Fd;LispPTR RadiAtomIndex;LispPTR RaidPackageIndex;struct pixrect *HideBitMap;char *HideDisp68k;char *URaid_summary = {"**URAID commands summary**\n\<<Displaying a Stack>>\nc\t\t\tChecks all user stack contents\n\f number\t\tDisplays Frame extention for the number(decimal)\n\k type\t\t\tChanges the type of stack link following.(a|c)\n\l [type]\t\tBack Trace for Specified type stack.(k|m|r)\n\<CR>\t\t\tDisplay next frame.\n<<Displaying the Memory contents>>\n\a litatom\t\tDisplays the top-level value of the litatom\n\d litatom\t\tDisplays the Definition Cell for the litatom\n\M\t\t\tDisplays TOS,CSP,PVAR,IVAR,PC\n\m func1 func2\t\tMOVED func1 to func2\n\t Xaddress\t\tDisplays the type of this object\n\p litatom\t\tDisplays the Propaty list of the litatom\n\w\t\t\tDisplays the current function-name and PC\n\x Xaddress [xnum]\tHex-Dump xnum word(16-bits) starting at Xaddress\n@ litatom val\t\tSets TOPVAL of litatom to val\n< Xaddress val\t\tSets the word(16-bits) at the address to val\n<<Return or Exit>>\n\e\t\t\tExit to UNIX\nh\t\t\tContext switch to HARDRESET\nq\t\t\tReturns from URAID with NIL\n<<Misc>>\ns\t\t\tInvoke Shell\n\v filename\t\tSave the current virtual memory on the filename\n( [num]\t\t\tSets Print level\n?\t\t\tDisplay this summary"};#define HEXNUMP(str,err)	if(((*str < '0') || (*str > '9')) \				&&((*str < 'A') || (*str > 'F'))){ \			 	printf("Illegal argument, %s\n",err); \			  	return; }			#define ADD_RANGEP(address)		if((address < 0) || (0xFFFFFF <= address)) \				 { \					printf("Address exceeded.\n"); \					return; \				 }extern int get_package_atom();#define URMAXCOMM		512#define URMAXFXNUM		100#define URSCAN_ALINK		0#define URSCAN_CLINK		1/*** URaid G vals ***/ int URaid_scanlink= URSCAN_ALINK; int URaid_currentFX=URMAXFXNUM +1; FX *URaid_FXarray[URMAXFXNUM]; int URaid_ArrMAXIndex; char URaid_inputstring[URMAXCOMM]; char URaid_comm; char URaid_arg1[URMAXCOMM/2]; char URaid_arg2[URMAXCOMM/2]; int URaid_argnum;	 extern int PrintMaxLevel; /* for print level *//***********************************************************************//*	func name : parse_atomstring(string)	Written by : Takeshi Shimizu	Date:   6-May-1988	Pass the atomstring(e.g. "XCL:EVAL")	 Then Returns atomindex .	If fail to find,return -1	If there is no package prefix,it will be treated as IL:*//***********************************************************************/ parse_atomstring(string) char *string; {  char *start,*packageptr,*nameptr;  int flag=0;  int packagelen=0;  int namelen=0;  int cnt;  int aindex; for(cnt=0,start=string; *string != '\0' ; string++,cnt++)  {	if(*string ==':')	{		packagelen= cnt;		packageptr=start;		nameptr=string+1;		cnt=0;		*string=0;	}  } if(packagelen==0) { /* treat as IL: */	nameptr=start;	namelen = cnt; } else	namelen = cnt-1;if((packagelen == 0) || (compare_chars(packageptr, "IL",packagelen ) == T))  {/* default IL: */	aindex=make_atom(nameptr,0,namelen,T);	if(aindex > 0xffff){ return(-1);} }else	aindex = get_package_atom(nameptr,namelen,packageptr,packagelen,0);printf("INDEX : %d \n",aindex);return(aindex);}/***********************************************************************//*	func name : uraid_commclear()	Written by : Takeshi Shimizu	Date:   6-May-1988		Clear Command buffer	*//***********************************************************************/uraid_commclear(){ register int i;  for(i=0;i <URMAXCOMM ; i++)	URaid_inputstring[i]=0;  for(i=0;i < URMAXCOMM/2 ; i++){	URaid_arg1[URMAXCOMM/2]=0; 	URaid_arg2[URMAXCOMM/2]=0;  }  URaid_comm=0;  URaid_argnum=0;}/***********************************************************************//*	func name : uraid_commands()	Written by : Takeshi Shimizu	Date:   6-May-1988		Execute URaid commands		To continue, return T		To exit, return NIL*//***********************************************************************/uraid_commands(){ int num,address,val,tmp; DLword index; DefCell *defcell68k;  if(URaid_argnum == -1){	/* disp next FX */	if(URaid_currentFX+1 >= URaid_ArrMAXIndex)	{	  printf("There is no more Stack.\n");	  return(T);	}	else	{	  sf(URaid_FXarray[URaid_currentFX++]); 	  return(T);	}  }  switch(URaid_comm)  {	/*** Displaying STACK stuff */	case 'c' :	stack_check(0);			break;	case 'C' :	all_stack_dump(0,0,T);			break;	case 'f' :	if((URaid_arg1[0] < '0') || (URaid_arg1[0] > '9')){			   printf("Illegal argument,Not number\n");			    return(T);			}			sscanf(URaid_arg1,"%d",&num);			if((num > URaid_ArrMAXIndex) || (num < 0))			{			  printf("Such Frame doesn't exist.\n");			  return(T);			}			sf(URaid_FXarray[num]);			URaid_currentFX = num+1;			break;	case 'k' :	if(URaid_arg1[0] == 'A')			URaid_scanlink =URSCAN_ALINK;			else if(URaid_arg1[0] == 'C')				URaid_scanlink = URSCAN_CLINK;			else 				printf("Link type should be A or C\n");			break;	case 'l' :	if(URaid_argnum ==1)			{				bt(); /* default case CURRENTFX */				return(T);			}			switch(URaid_arg1[0])			{			 case 'k' :	printf("IFP->KBDFXP :\n");					bt1(Addr68k_from_StkOffset(InterfacePage->kbdfxp));					break;			 case 'm' :	printf("IFP->MISCFXP :\n");					bt1(Addr68k_from_StkOffset(InterfacePage->miscfxp));					break;			 case 'r' :	printf("IFP->RESETFXP :\n");					bt1(Addr68k_from_StkOffset(InterfacePage->resetfxp));					break;			 default :	printf("2nd argument should be K,M,R or null.\n");					break;			} /* switch end */		break;	/* Displaying the memory contents stuff */	case 'a' :	 /* GETTOPVAL */				if(URaid_argnum != 2)					return(T);				if((index = parse_atomstring(URaid_arg1))<0){					printf("No such atom\n");					return(T);				}				print(*((LispPTR*)GetVALCELL68k(index)));				break;	case 'd' : /* DEFCELL */				if(URaid_argnum != 2){					printf("GETD: d litatom\n");					return(T);				}				if((index = parse_atomstring(URaid_arg1))<0){					printf("No such atom\n");					return(T);				}				defcell68k= (DefCell*)GetDEFCELL68k(index);				if(defcell68k->ccodep) {				  printf("{CCODEP}0x%x \n",defcell68k->defpointer);				  return(T);				}				else{				  print(defcell68k->defpointer);				  return(T);				}				break;	case 'M' :	 /* Machine States */				printf("TOS   : 0x%x \n",TopOfStack);				printf("CSTKP : 0x%x \n",LADDR_from_68k(CurrentStackPTR));				printf("PVAR  : 0x%x \n",LADDR_from_68k(PVar));				printf("IVAR  : 0x%x \n",LADDR_from_68k(IVar));				printPC(); putchar('\n');				break;	case 'm' :	/* MOVED */				if(URaid_argnum != 3){					printf("MOVED: m <from funcname> <to funcname>\n");					return(T);				}				{ DefCell *fromfunc,*tofunc;				  int fromindex,toindex;					if((fromindex = parse_atomstring(URaid_arg1))<0){					printf("No such function(from)\n");					return(T);					}					if((toindex = parse_atomstring(URaid_arg2))<0){					printf("No such function(to)\n");					return(T);					}					fromfunc= (DefCell*)GetDEFCELL68k(fromindex);					tofunc= (DefCell*)GetDEFCELL68k(toindex);					tofunc->defpointer = fromfunc->defpointer;					print(toindex);					printf(" is smashed with ");					print(fromindex);putchar('\n');				}								break;	case 'O' :		{ /* print instance from Laddr. Not documented */					int objaddr;					sscanf(URaid_arg1,"%x",&objaddr);					print(objaddr);				}				break;	case 't' :   /* Object TYPE */				if(URaid_argnum != 2){					printf("PRINTTYPENAME: t xaddress\n");					return(T);				}				HEXNUMP(URaid_arg1,"Not Address");				sscanf(URaid_arg1,"%x",&address);				ADD_RANGEP(address);				switch(address >> 16) {				 case ATOMS_HI : printf("{ATOM}");						 printf("0x%x\n",address);						 break;				 case STK_HI : printf("{STK}");						 printf("0x%x\n",address);						 break;					 case PLIS_HI : printf("{PLIST}");						 printf("0x%x\n",address);						 break;					 case FPTOVP_HI : printf("{FPTOVP}");						 printf("0x%x\n",address);						 break;					 case PNP_HI : printf("{PNP}");						 printf("0x%x\n",address);						 break;					 case DEFS_HI : printf("{DEF}");						 printf("0x%x\n",address);						 break;					 case VALS_HI : printf("{VAL}");						 printf("0x%x\n",address);						 break;				 case DISPALY_HI :				 case DISPALY_HI+1 :printf("{DISPLAY}");						 printf("0x%x\n",address);						 break;				 default:					num= GetTypeNumber(address);					putchar('{');					print_atomname((DLword)GetDTD(num));					putchar('}');					break;				} /* switch end */				break;#define GetPROPCELL68k(index)	((LispPTR *)Plistspace + (index) )	case 'p' :	 /* propaty lisp */				if(URaid_argnum != 2){					printf("GETPROPLIST : p litatom\n");					return(T);				}				if((index = parse_atomstring(URaid_arg1)) <0){					printf("No such atom\n");					return(T);				}				print(*(GetPROPCELL68k(index)) & 0xffffff );				break;	case 'w' :  /* Disp CurrentFunc name & PC */				doko();				break;#define XDUMPW 8	case 'x' :	  /* HEX dump */				HEXNUMP(URaid_arg1,"Not Address");				HEXNUMP(URaid_arg2,"Not number");				sscanf(URaid_arg1,"%x",&address);				if(sscanf(URaid_arg2,"%x",&num)==-1)				 num = 8;				ADD_RANGEP(address);				{ int i;				  DLword *ptr,*endptr;					ptr=(DLword*)Addr68k_from_LADDR(address);					endptr=ptr+num;					while(ptr < endptr)					{						printf("%x : ",LADDR_from_68k(ptr));						for(i=0;							((ptr <endptr)&& (i<XDUMPW)) ;ptr++,i++) 						{							printf("%4x ",*ptr);						}						putchar('\n');					}				}				break;	case '@' :		/* SETTOPVAL */				if(URaid_argnum != 3){					printf("SETTOPVAL: @ litatom val\n");					return(T);				}				if((index = parse_atomstring(URaid_arg1))<0){					printf("No such atom\n");					return(T);				}				if (compare_chars(URaid_arg2, "NIL", 3) == T)					val=NIL;				else if (*URaid_arg2== 'T')  val=ATOM_T;				else { 					if(sscanf(URaid_arg2,"%d",&val) == -1){						printf(" Bad value \n");						return(T);					}					else {						if((val < -65536)||(65535 < val)){							printf("Bad Val range\n"); 							return(T);						}						if(val >=0)							val |= S_POSITIVE;						else							val |= S_NEGATIVE;					}				}				printf("Old value is ");				print(*((LispPTR*)GetVALCELL68k(index)));				putchar('\n');				*((LispPTR*)GetVALCELL68k(index)) =(LispPTR) val;				print(val);				break;		case '<' :		/* Assignment */				HEXNUMP(URaid_arg1,"Not Address");				HEXNUMP(URaid_arg2,"Not Proper Value");				sscanf(URaid_arg1,"%x",&address);				sscanf(URaid_arg2,"%x",&val);				ADD_RANGEP(address);				{ DLword *ptr;					ptr =(DLword*)Addr68k_from_LADDR(address);					*ptr=val;					printf("0x%x : 0x%x\n",address,*ptr);				}				break;/****MISC ****/	case 'q' :		/* return with NIL */				printf("Return to Lisp?[comfirm](Y or N)<");				{int c;				  c= getchar();				  if((c=='Y')||(c=='y')) {					TopOfStack = NIL;					return(NIL);				   }				}				fflush(stdin);				URaid_currentFX=URMAXFXNUM +1;				return(T);				break;	case 'h' :		/* HARDRESET */				printf("HARDRESET?[comfirm](Y or N)<");				{ int c;				  c= getchar();				  if((c=='Y')||(c=='y'))					contextsw(ResetFXP,2,0);				}				fflush(stdin);				return(NIL);				break;	case 'e' :		/* exit to UNIX */				printf("Exit to UNIX?[comfirm](Y or N)<");				{ int c;				  c= getchar();				  if((c=='Y')||(c=='y'))					exit(0);				}				fflush(stdin);				URaid_currentFX=URMAXFXNUM +1;				break;	case 's' :		/* SHELL */				system("/bin/sh -i");				return(T);				break;	case 'v' :		vmem_save(URaid_arg1);				break;	case '(' :		if(URaid_argnum==1) num = 2;								else if((URaid_arg1[0] < '0') || (URaid_arg1[0] > '9')){					printf("Illegal argument,Not number\n");			 		return(T);				}				else 					sscanf(URaid_arg1,"%d",&num);						PrintMaxLevel = num;				printf("PrintLevel is set to %d.",num);				break;	case '?' :		printf("%s\n",URaid_summary);				break;	default :  printf("Not supported command.\n");			break;  } /* switch end */return(T);}/***********************************************************************//*	func name :  device_before_raid()	Written by : Takeshi Shimizu	Date:  	 6-May-1988	This shoul be calld before invoking URaid.*//***********************************************************************/device_before_raid(){	int keytrans;	int size;	int munmapstat;	struct pixrect *fb;	extern char *alloc_hideDISP();	char *valloc();	free();		int_timer_off();	win_setcursor(LispWindowFd, &InvisibleCursorBitMap);	int_io_close(LispWindowFd);	int_io_close(ether_fd);/*	int_io_close(RS232C_Fd);*/	mess_reset();	if( (LispKbdFd = open( LispScreen.scr_kbdname )) == -1){		fprintf( stderr, "can't open %s\n", LispScreen.scr_kbdname);		return( -1 );	}	keytrans = TR_EVENT;	/* keyboard encodes key */	if(ioctl( LispKbdFd, KIOCTRANS, &keytrans)== -1){		fprintf( stderr, "Error at ioctl errnoo =%d\n", errno);		return( -1 );	}	close( LispKbdFd );        close( LispWindowFd ); 	size = ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) ) 			& -getpagesize());	if((HideDisp68k= valloc(size)) == 0){		  printf("can't valloc hide space\n");		  return(-1);	}	HideBitMap= mem_point(DisplayWidth,DisplayHeight,1,HideDisp68k);	pr_rop( HideBitMap, 0,0,DisplayWidth,DisplayHeight,PIX_SRC,		ScreenBitMap,0,0);	pr_rop(ScreenBitMap,0,0,DisplayWidth,DisplayHeight,		PIX_CLR,ScreenBitMap,0,0);	return(0);}/**char *alloc_hideDISP(size)int size;{ char *retaddr; switch(*STORAGEFULLSTATE_word & 0xffff)  {	case SFS_NOTSWITCHABLE :		if((retaddr =valloc(size)) ==0){			fprintf(stderr,"can't alloc hide disp\n");		 }		break;	case 0 :	case SFS_SWITCHABLE :		retaddr = 		 (char*)Addr68k_from_LADDR((*ArraySpace2_word) & 0xffffff);		printf("Hidespace inside Lisp(2)\n");		break;	case SFS_ARRAYSWITCHED :		retaddr=(char*)Addr68k_from_LADDR(*Next_Array_word & 0xffff);;		printf("Hidespace inside Lisp(3)\n");		break;	case SFS_FULLYSWITCHED :		if((int)Addr68k_from_LADDR(*Next_MDSpage_word & 0xffff) 			- (int)Addr68k_from_LADDR(*Next_Array_word & 0xffff)		 >size) {			retaddr= (char*)Addr68k_from_LADDR(*Next_Array_word & 0xffff);			printf("Hidespace inside Lisp(4)\n");		 }		else if((retaddr=valloc(size)) ==0){			fprintf(stderr,"can't alloc hide disp\n");			 }			printf("Hidespace new\n");		break;	default : printf("Illegal data in STORAGEFULLSTATE\n");		  retaddr=0;		 break;  }  return(retaddr);}****//***********************************************************************//*	func name : device_after_raid()	Written by : Takeshi Shimizu	Date:   6-May-1988 	This should be called when returning LISP.	*//***********************************************************************/device_after_raid(){	LispReadFds = 0;	re_init_display(DISPALY_OFFSET,65536 * 16 *2);	set_cursor();	init_keyboard();	init_ether();	int_init(); 	LispReadFds |= (1 << LispWindowFd) ;	int_timer_on();} /* device_after_raid *//***********************************************************************//*	func name :re_init_display(lisp_display_addr, display_max)			int lisp_display_addr, display_max;	Written by : Takeshi Shimizu	Date:   6-May-1988 	This should be called when returning LISP.	Only called by device_after_raid	*//***********************************************************************/re_init_display(lisp_display_addr, display_max)	int lisp_display_addr, display_max;{	int mmapstat, size;	mess_init();	if( (LispWindowFd = win_screennew( &LispScreen )) == -1){		fprintf( stderr, "init_display: can't create LispWindow\n");		return( -1 );	} else  int_io_open(LispWindowFd);	init_cursor(); 	size = ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) ) 			& -getpagesize());	mmapstat = 		mmap( DisplayRegion68k,		      size,		      PROT_READ | PROT_WRITE, MAP_SHARED, FrameBufferFd, 0 );		if(mmapstat != 0){		fprintf( stderr, "re_init_display: ERROR at mmap system call\n");		fprintf( stderr, "errno = %d\n\n", errno );		return( 0 );	}	pr_rop(ScreenBitMap,0,0,DisplayWidth,DisplayHeight,PIX_CLR,		ScreenBitMap,0,0);	pr_rop( ScreenBitMap, 0, 0, DisplayWidth, DisplayHeight,PIX_SRC | PIX_DST,		HideBitMap, 0, 0);	pr_close(HideBitMap);	free(HideDisp68k);	return(0);}E 6I 1D 2/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 2I 2D 3/* This is G-file @(#) uraid.c Version 1.1 (5/11/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) uraid.c	1.1 5/11/88";E 3I 3/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 3E 2#include <stdio.h>#include "lispemul.h"#include "lispmap.h"#include "address68k.h"#include "lisptypes.h"#include "lispglobal.h"#include "emulglobal.h"#include "cell.h"#include "stack.h"#include "ifpage.h"#include "debug.h"#include <sys/file.h>#include <sys/types.h>#include <sys/param.h>#include <sys/ioctl.h>#include <fcntl.h>#include <sundev/kbd.h>#include <sundev/kbio.h>#include <errno.h>#include <sunwindow/window_hs.h>#include <sunwindow/win_ioctl.h>#include <pixrect/pixrect_hs.h>#include <sunwindow/win_cursor.h>#include <sunwindow/cms.h>#include <sys/mman.h>/***********************************************************************//*	File name : uraid.c	Written by : Takeshi Shimizu(Take)	Date:   6-May-1988	This File Supports the following commands:**URAID commands summary**<<Displaying a Stack>>c                       Checks all user stack contentsf number                Displays Frame extention for the number(decimal)k type                  Changes the type of stack link following.(a|c)l [type]                Back Trace for Specified type stack.(k|m|r)<CR>                    Display next frame.<<Displaying the Memory contents>>a litatom               Displays the top-level value of the litatomd litatom               Displays the Definition Cell for the litatomM                       Displays TOS,CSP,PVAR,IVAR,PCm func1 func2           MOVED func1 to func2t Xaddress              Displays the type of this objectp litatom               Displays the Propaty list of the litatomw                       Displays the current function-name and PCx Xaddress [xnum]       Hex-Dump xnum word(16-bits) starting at Xaddress@ litatom val           Sets TOPVAL of litatom to val< Xaddress val          Sets the word(16-bits) at the address to val<<Return or Exit>>e                       Exit to UNIXh                       Context switch to HARDRESETq                       Returns from URAID with NIL<<Misc>>s                       Invoke Shellv filename              Save the current virtual memory on the filename( [num]                 Sets Print level?                       Display this summary*//************************************************************************/extern unsigned int LispReadFds,LispWindowFd,LispKbdFd;extern struct pixrect *ScreenBitMap,*CursorBitMap,*InvisibleCursorBitMap;extern struct screen LispScreen;extern int DisplayWidth,DisplayHeight;extern DLword *DisplayRegion68k;extern int FrameBufferFd,ether_fd,RS232C_Fd;LispPTR RadiAtomIndex;LispPTR RaidPackageIndex;struct pixrect *HideBitMap;char *HideDisp68k;char *URaid_summary = {"**URAID commands summary**\n<<Displaying a Stack>>\nc\t\t\tChecks all user stack contents\nf number\t\tDisplays Frame extention for the number(decimal)\nk type\t\t\tChanges the type of stack link following.(a|c)\nl [type]\t\tBack Trace for Specified type stack.(k|m|r)\n<CR>\t\t\tDisplay next frame.\n<<Displaying the Memory contents>>\na litatom\t\tDisplays the top-level value of the litatom\nd litatom\t\tDisplays the Definition Cell for the litatom\nM\t\t\tDisplays TOS,CSP,PVAR,IVAR,PC\nm func1 func2\t\tMOVED func1 to func2\nt Xaddress\t\tDisplays the type of this object\np litatom\t\tDisplays the Propaty list of the litatom\nw\t\t\tDisplays the current function-name and PC\nx Xaddress [xnum]\tHex-Dump xnum word(16-bits) starting at Xaddress\n@ litatom val\t\tSets TOPVAL of litatom to val\n< Xaddress val\t\tSets the word(16-bits) at the address to val\n<<Return or Exit>>\ne\t\t\tExit to UNIX\nh\t\t\tContext switch to HARDRESET\nq\t\t\tReturns from URAID with NIL\n<<Misc>>\ns\t\t\tInvoke Shell\nv filename\t\tSave the current virtual memory on the filename\n( [num]\t\t\tSets Print level\n?\t\t\tDisplay this summary"};#define HEXNUMP(str,err)	if(((*str < '0') || (*str > '9')) \				&&((*str < 'A') || (*str > 'F'))){ \			 	printf("Illegal argument, %s\n",err); \			  	return; }			#define ADD_RANGEP(address)		if((address < 0) || (0xFFFFFF <= address)) \				 { \					printf("Address exceeded.\n"); \					return; \				 }extern int get_package_atom();#define URMAXCOMM		512#define URMAXFXNUM		100#define URSCAN_ALINK		0#define URSCAN_CLINK		1/*** URaid G vals ***/ int URaid_scanlink= URSCAN_ALINK; int URaid_currentFX=URMAXFXNUM +1; FX *URaid_FXarray[URMAXFXNUM]; int URaid_ArrMAXIndex; char URaid_inputstring[URMAXCOMM]; char URaid_comm; char URaid_arg1[URMAXCOMM/2]; char URaid_arg2[URMAXCOMM/2]; int URaid_argnum;	 extern int PrintMaxLevel; /* for print level *//***********************************************************************//*	func name : parse_atomstring(string)	Written by : Takeshi Shimizu	Date:   6-May-1988	Pass the atomstring(e.g. "XCL:EVAL")	 Then Returns atomindex .	If fail to find,return -1	If there is no package prefix,it will be treated as IL:*//***********************************************************************/ parse_atomstring(string) char *string; {  char *start,*packageptr,*nameptr;  int flag=0;  int packagelen=0;  int namelen=0;  int cnt;  int aindex; for(cnt=0,start=string; *string != '\0' ; string++,cnt++)  {	if(*string ==':')	{		packagelen= cnt;		packageptr=start;		nameptr=string+1;		cnt=0;		*string=0;	}  } if(packagelen==0) { /* treat as IL: */	nameptr=start;	namelen = cnt; } else	namelen = cnt-1;if((packagelen == 0) || (compare_chars(packageptr, "IL",packagelen ) == T))  {/* default IL: */	aindex=make_atom(nameptr,0,namelen,T);	if(aindex > 0xffff){ return(-1);} }else	aindex = get_package_atom(nameptr,namelen,packageptr,packagelen,0);printf("INDEX : %d \n",aindex);return(aindex);}/***********************************************************************//*	func name : uraid_commclear()	Written by : Takeshi Shimizu	Date:   6-May-1988		Clear Command buffer	*//***********************************************************************/uraid_commclear(){ register int i;  for(i=0;i <URMAXCOMM ; i++)	URaid_inputstring[i]=0;  for(i=0;i < URMAXCOMM/2 ; i++){	URaid_arg1[URMAXCOMM/2]=0; 	URaid_arg2[URMAXCOMM/2]=0;  }  URaid_comm=0;  URaid_argnum=0;}/***********************************************************************//*	func name : uraid_commands()	Written by : Takeshi Shimizu	Date:   6-May-1988		Execute URaid commands		To continue, return T		To exit, return NIL*//***********************************************************************/uraid_commands(){ int num,address,val,tmp; DLword index; DefCell *defcell68k;  if(URaid_argnum == -1){	/* disp next FX */	if(URaid_currentFX+1 >= URaid_ArrMAXIndex)	{	  printf("There is no more Stack.\n");	  return(T);	}	else	{	  sf(URaid_FXarray[URaid_currentFX++]); 	  return(T);	}  }  switch(URaid_comm)  {	/*** Displaying STACK stuff */	case 'c' :	stack_check(0);I 5	case 'C' :	all_stack_dump(0,0,T);			break;E 5			break;	case 'f' :	if((URaid_arg1[0] < '0') || (URaid_arg1[0] > '9')){			   printf("Illegal argument,Not number\n");			    return(T);			}			sscanf(URaid_arg1,"%d",&num);			if((num > URaid_ArrMAXIndex) || (num < 0))			{			  printf("Such Frame doesn't exist.\n");			  return(T);			}			sf(URaid_FXarray[num]);			URaid_currentFX = num+1;			break;	case 'k' :	if(URaid_arg1[0] == 'A')			URaid_scanlink =URSCAN_ALINK;			else if(URaid_arg1[0] == 'C')				URaid_scanlink = URSCAN_CLINK;			else 				printf("Link type should be A or C\n");			break;	case 'l' :	if(URaid_argnum ==1)			{				bt(); /* default case CURRENTFX */				return(T);			}			switch(URaid_arg1[0])			{			 case 'k' :	printf("IFP->KBDFXP :\n");					bt1(Addr68k_from_StkOffset(InterfacePage->kbdfxp));					break;			 case 'm' :	printf("IFP->MISCFXP :\n");					bt1(Addr68k_from_StkOffset(InterfacePage->miscfxp));					break;			 case 'r' :	printf("IFP->RESETFXP :\n");					bt1(Addr68k_from_StkOffset(InterfacePage->resetfxp));					break;			 default :	printf("2nd argument should be K,M,R or null.\n");					break;			} /* switch end */		break;	/* Displaying the memory contents stuff */	case 'a' :	 /* GETTOPVAL */				if(URaid_argnum != 2)					return(T);				if((index = parse_atomstring(URaid_arg1))<0){					printf("No such atom\n");					return(T);				}				print(*((LispPTR*)GetVALCELL68k(index)));				break;	case 'd' : /* DEFCELL */				if(URaid_argnum != 2){					printf("GETD: d litatom\n");					return(T);				}				if((index = parse_atomstring(URaid_arg1))<0){					printf("No such atom\n");					return(T);				}				defcell68k= (DefCell*)GetDEFCELL68k(index);				if(defcell68k->ccodep) {				  printf("{CCODEP}0x%x \n",defcell68k->defpointer);				  return(T);				}				else{				  print(defcell68k->defpointer);				  return(T);				}				break;	case 'M' :	 /* Machine States */				printf("TOS   : 0x%x \n",TopOfStack);				printf("CSTKP : 0x%x \n",LADDR_from_68k(CurrentStackPTR));				printf("PVAR  : 0x%x \n",LADDR_from_68k(PVar));				printf("IVAR  : 0x%x \n",LADDR_from_68k(IVar));				printPC(); putchar('\n');				break;	case 'm' :	/* MOVED */				if(URaid_argnum != 3){					printf("MOVED: m <from funcname> <to funcname>\n");					return(T);				}				{ DefCell *fromfunc,*tofunc;				  int fromindex,toindex;					if((fromindex = parse_atomstring(URaid_arg1))<0){					printf("No such function(from)\n");					return(T);					}					if((toindex = parse_atomstring(URaid_arg2))<0){					printf("No such function(to)\n");					return(T);					}					fromfunc= (DefCell*)GetDEFCELL68k(fromindex);					tofunc= (DefCell*)GetDEFCELL68k(toindex);					tofunc->defpointer = fromfunc->defpointer;					print(toindex);					printf(" is smashed with ");					print(fromindex);putchar('\n');				}								break;	case 't' :   /* Object TYPE */				if(URaid_argnum != 2){					printf("PRINTTYPENAME: t xaddress\n");					return(T);				}				HEXNUMP(URaid_arg1,"Not Address");				sscanf(URaid_arg1,"%x",&address);				ADD_RANGEP(address);				switch(address >> 16) {				 case ATOMS_HI : printf("{ATOM}");						 printf("0x%x\n",address);						 break;				 case STK_HI : printf("{STK}");						 printf("0x%x\n",address);						 break;					 case PLIS_HI : printf("{PLIST}");						 printf("0x%x\n",address);						 break;					 case FPTOVP_HI : printf("{FPTOVP}");						 printf("0x%x\n",address);						 break;					 case PNP_HI : printf("{PNP}");						 printf("0x%x\n",address);						 break;					 case DEFS_HI : printf("{DEF}");						 printf("0x%x\n",address);						 break;					 case VALS_HI : printf("{VAL}");						 printf("0x%x\n",address);						 break;				 case DISPALY_HI :				 case DISPALY_HI+1 :printf("{DISPLAY}");						 printf("0x%x\n",address);						 break;				 default:					num= GetTypeNumber(address);					putchar('{');					print_atomname((DLword)GetDTD(num));					putchar('}');					break;				} /* switch end */				break;#define GetPROPCELL68k(index)	((LispPTR *)Plistspace + (index) )	case 'p' :	 /* propaty lisp */				if(URaid_argnum != 2){					printf("GETPROPLIST : p litatom\n");					return(T);				}				if((index = parse_atomstring(URaid_arg1)) <0){					printf("No such atom\n");					return(T);				}				print(*(GetPROPCELL68k(index)) & 0xffffff );				break;	case 'w' :  /* Disp CurrentFunc name & PC */				doko();				break;#define XDUMPW 8	case 'x' :	  /* HEX dump */				HEXNUMP(URaid_arg1,"Not Address");				HEXNUMP(URaid_arg2,"Not number");				sscanf(URaid_arg1,"%x",&address);				if(sscanf(URaid_arg2,"%x",&num)==-1)				 num = 8;				ADD_RANGEP(address);				{ int i;				  DLword *ptr,*endptr;					ptr=(DLword*)Addr68k_from_LADDR(address);					endptr=ptr+num;					while(ptr < endptr)					{						printf("%x : ",LADDR_from_68k(ptr));						for(i=0;							((ptr <endptr)&& (i<XDUMPW)) ;ptr++,i++) 						{							printf("%4x ",*ptr);						}						putchar('\n');					}				}				break;	case '@' :		/* SETTOPVAL */				if(URaid_argnum != 3){					printf("SETTOPVAL: @ litatom val\n");					return(T);				}				if((index = parse_atomstring(URaid_arg1))<0){					printf("No such atom\n");					return(T);				}				if (compare_chars(URaid_arg2, "NIL", 3) == T)					val=NIL;				else if (*URaid_arg2== 'T')  val=ATOM_T;				else { 					if(sscanf(URaid_arg2,"%d",&val) == -1){						printf(" Bad value \n");						return(T);					}					else {						if((val < -65536)||(65535 < val)){							printf("Bad Val range\n"); 							return(T);						}						if(val >=0)							val |= S_POSITIVE;						else							val |= S_NEGATIVE;					}				}				printf("Old value is ");				print(*((LispPTR*)GetVALCELL68k(index)));				putchar('\n');				*((LispPTR*)GetVALCELL68k(index)) =(LispPTR) val;				print(val);				break;		case '<' :		/* Assignment */				HEXNUMP(URaid_arg1,"Not Address");				HEXNUMP(URaid_arg2,"Not Proper Value");				sscanf(URaid_arg1,"%x",&address);				sscanf(URaid_arg2,"%x",&val);				ADD_RANGEP(address);				{ DLword *ptr;					ptr =(DLword*)Addr68k_from_LADDR(address);					*ptr=val;					printf("0x%x : 0x%x\n",address,*ptr);				}				break;/****MISC ****/	case 'q' :		/* return with NIL */				printf("Return to Lisp?[comfirm](Y or N)<");				{int c;				  c= getchar();				  if((c=='Y')||(c=='y')) {					TopOfStack = NIL;					return(NIL);				   }				}				fflush(stdin);				URaid_currentFX=URMAXFXNUM +1;				return(T);				break;	case 'h' :		/* HARDRESET */				printf("HARDRESET?[comfirm](Y or N)<");				{ int c;				  c= getchar();				  if((c=='Y')||(c=='y'))					contextsw(ResetFXP,2,0);				}				fflush(stdin);				return(NIL);				break;	case 'e' :		/* exit to UNIX */				printf("Exit to UNIX?[comfirm](Y or N)<");				{ int c;				  c= getchar();				  if((c=='Y')||(c=='y'))					exit(0);				}				fflush(stdin);				URaid_currentFX=URMAXFXNUM +1;				break;	case 's' :		/* SHELL */				system("/bin/sh -i");				return(T);				break;	case 'v' :		vmem_save(URaid_arg1);				break;	case '(' :		if(URaid_argnum==1) num = 2;								else if((URaid_arg1[0] < '0') || (URaid_arg1[0] > '9')){					printf("Illegal argument,Not number\n");			 		return(T);				}				else 					sscanf(URaid_arg1,"%d",&num);						PrintMaxLevel = num;				printf("PrintLevel is set to %d.",num);				break;	case '?' :		printf("%s\n",URaid_summary);				break;	default :  printf("Not supported command.\n");			break;  } /* switch end */return(T);}/***********************************************************************//*	func name :  device_before_raid()	Written by : Takeshi Shimizu	Date:  	 6-May-1988	This shoul be calld before invoking URaid.*//***********************************************************************/device_before_raid(){	int keytrans;	int size;	int munmapstat;	struct pixrect *fb;	extern char *alloc_hideDISP();	char *valloc();	free();		int_timer_off();	win_setcursor(LispWindowFd, &InvisibleCursorBitMap);	int_io_close(LispWindowFd);	int_io_close(ether_fd);/*	int_io_close(RS232C_Fd);*/	mess_reset();	if( (LispKbdFd = open( LispScreen.scr_kbdname )) == -1){		fprintf( stderr, "can't open %s\n", LispScreen.scr_kbdname);		return( -1 );	}	keytrans = TR_EVENT;	/* keyboard encodes key */	if(ioctl( LispKbdFd, KIOCTRANS, &keytrans)== -1){		fprintf( stderr, "Error at ioctl errnoo =%d\n", errno);		return( -1 );	}	close( LispKbdFd );        close( LispWindowFd ); 	size = ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) ) 			& -getpagesize());	if((HideDisp68k= valloc(size)) == 0){		  printf("can't valloc hide space\n");		  return(-1);	}	HideBitMap= mem_point(DisplayWidth,DisplayHeight,1,HideDisp68k);	pr_rop( HideBitMap, 0,0,DisplayWidth,DisplayHeight,PIX_SRC,		ScreenBitMap,0,0);	pr_rop(ScreenBitMap,0,0,DisplayWidth,DisplayHeight,		PIX_CLR,ScreenBitMap,0,0);	return(0);}/**char *alloc_hideDISP(size)int size;{ char *retaddr; switch(*STORAGEFULLSTATE_word & 0xffff)  {	case SFS_NOTSWITCHABLE :		if((retaddr =valloc(size)) ==0){			fprintf(stderr,"can't alloc hide disp\n");		 }		break;	case 0 :	case SFS_SWITCHABLE :		retaddr = 		 (char*)Addr68k_from_LADDR((*ArraySpace2_word) & 0xffffff);		printf("Hidespace inside Lisp(2)\n");		break;	case SFS_ARRAYSWITCHED :		retaddr=(char*)Addr68k_from_LADDR(*Next_Array_word & 0xffff);;		printf("Hidespace inside Lisp(3)\n");		break;	case SFS_FULLYSWITCHED :		if((int)Addr68k_from_LADDR(*Next_MDSpage_word & 0xffff) 			- (int)Addr68k_from_LADDR(*Next_Array_word & 0xffff)		 >size) {			retaddr= (char*)Addr68k_from_LADDR(*Next_Array_word & 0xffff);			printf("Hidespace inside Lisp(4)\n");		 }		else if((retaddr=valloc(size)) ==0){			fprintf(stderr,"can't alloc hide disp\n");			 }			printf("Hidespace new\n");		break;	default : printf("Illegal data in STORAGEFULLSTATE\n");		  retaddr=0;		 break;  }  return(retaddr);}****//***********************************************************************//*	func name : device_after_raid()	Written by : Takeshi Shimizu	Date:   6-May-1988 	This should be called when returning LISP.	*//***********************************************************************/device_after_raid(){	LispReadFds = 0;	re_init_display(DISPALY_OFFSET,65536 * 16 *2);	set_cursor();	init_keyboard();	init_ether();	int_init(); 	LispReadFds |= (1 << LispWindowFd) ;	int_timer_on();} /* device_after_raid *//***********************************************************************//*	func name :re_init_display(lisp_display_addr, display_max)			int lisp_display_addr, display_max;	Written by : Takeshi Shimizu	Date:   6-May-1988 	This should be called when returning LISP.	Only called by device_after_raid	*//***********************************************************************/re_init_display(lisp_display_addr, display_max)	int lisp_display_addr, display_max;{	int mmapstat, size;	mess_init();	if( (LispWindowFd = win_screennew( &LispScreen )) == -1){		fprintf( stderr, "init_display: can't create LispWindow\n");		return( -1 );	} else  int_io_open(LispWindowFd);	init_cursor(); 	size = ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) ) 			& -getpagesize());	mmapstat = 		mmap( DisplayRegion68k,		      size,		      PROT_READ | PROT_WRITE, MAP_SHARED, FrameBufferFd, 0 );		if(mmapstat != 0){		fprintf( stderr, "re_init_display: ERROR at mmap system call\n");		fprintf( stderr, "errno = %d\n\n", errno );		return( 0 );	}	pr_rop(ScreenBitMap,0,0,DisplayWidth,DisplayHeight,PIX_CLR,		ScreenBitMap,0,0);	pr_rop( ScreenBitMap, 0, 0, DisplayWidth, DisplayHeight,PIX_SRC | PIX_DST,		HideBitMap, 0, 0);	pr_close(HideBitMap);	free(HideDisp68k);	return(0);}E 1