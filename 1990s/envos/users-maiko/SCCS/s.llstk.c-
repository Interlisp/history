h31529s 00004/00004/00657d D 2.3 88/05/19 19:36:17 shimizu 13 12c SCCS trouble!!!!!es 00078/00072/00583d D 2.2 88/04/18 19:16:52 shimizu 12 11c change warn to errores 00000/00000/00661d D 2.1 88/05/17 09:25:43 hayata 11 10c Version up to 2.1es 00027/00019/00634d D 1.10 88/05/12 12:04:17 shimizu 10 9c Code refine(add register)es 00006/00027/00647d D 1.9 88/05/11 12:07:41 shimizu 9 8c refinement for return.hes 00033/00023/00641d D 1.8 88/05/10 19:43:17 krivacic 8 7c new do_stackoverflowes 00012/00003/00652d D 1.7 88/04/21 17:09:20 shimizu 7 6c Change flip_cursorbares 00011/00011/00644d D 1.6 88/04/21 10:53:03 shimizu 6 5c Change CurrentSTKP set nad remove Tos pushes 00073/00025/00582d D 1.5 88/04/13 12:34:46 shimizu 5 4c BUG fix for do_stackoverflowes 00038/00017/00569d D 1.4 88/04/07 14:49:02 shimizu 4 3c Change stack_check(wherever you can call)es 00007/00007/00579d D 1.3 88/04/01 14:45:27 shimizu 3 2c Change i/f to freestackblockes 00076/00029/00510d D 1.2 88/03/31 10:58:51 shimizu 2 1c Add do_stackoverflow()es 00539/00000/00000d D 1.1 88/03/23 18:24:23 shimizu 1 0c date and time created 88/03/23 18:24:23 by shimizueuUtTI 1D 3/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 3I 3D 9D 12/* This is G-file @(#) llstk.c Version 1.2 (3/31/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) llstk.c	1.2 3/31/88";E 12I 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 12E 9I 9/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 9E 3/******************************************************************//*        File Name :     llstk.c        Desc.     :     Low Level stack operations        Including :        Edited by :     Takeshi Shimizu(March 14, 1988)*//******************************************************************/#include <sunwindow/window_hs.h>#include "lispemul.h"#include "lispmap.h"#include "address68k.h"#include "address.h"I 2#include "lisptypes.h"#include "initatoms.h"E 2#include "lispglobal.h"#include "emulglobal.h"#include "cell.h"#include "stack.h"I 12#include "return.h"E 12I 9#include "return.h"E 9        D 2/* The followings will move to lispglobal.h */  extern LispPTR *LastStackAddr_word;extern LispPTR *GuardStackAddr_word;extern LispPTR *STACKOVERFLOW_word;extern LispPTR *PENDINGINTERRUPT_word;E 2D 2#define MAKEFREEBLOCK(ptr68k,size)      ( *((LispPTR*)(ptr68k))=STK_FSB_32| ((DLword)(size)) )#define SETUPGUARDBLOCK(ptr68k,size)    ( *((LispPTR*)(ptr68k))=STK_GUARD_32| ((DLword)(size)) )E 2I 2D 4warn(s)char *s;{ printf("WARN: %s \n",s); }E 4/******************************************************************//*D 8D 12        Func Name :     do_stackoverflow()E 12I 12        Func Name :     do_stackoverflow(incallp)E 12E 8I 8        Func Name :     do_stackoverflow(incallp)E 8E 2I 2D 5		if it is neded to cleanup then return 1E 5I 5D 8D 12		If There is no space for stack then return 1						else return 0E 5        E 12I 12		retval: If There is no space for stack then return 1					else return 0        	incallp:			If Calling during function call,incallp=T			else NILE 12E 8I 8		retval: If There is no space for stack then return 1					else return 0        	incallp:			If Calling during function call,incallp=T			else NILE 8        Edited by :     Take(March 28, 1988)*//******************************************************************/D 8D 12do_stackoverflow()E 12I 12do_stackoverflow(incallp) int incallp;E 12E 8I 8do_stackoverflow(incallp) int incallp;E 8{  register DLword *next68k;D 9D 12  register DLword *freeptr ; /* point to STK to be FSB */E 12E 9D 5  DLword newfx; /* for DEBUG */  DefCell *defcell68k;  CClosure *closure68k;E 5I 5  DLword newfx; I 12  DLword savenext;E 12I 6D 8 DLword savenext;E 8I 8  DLword savenext;E 8E 6E 5  DLword *oldPVar;I 5  int movedistance;D 6D 12  DLword *savecsp;E 6D 8 extern int LoopCounter; LispPTR moveframe();E 12I 12  extern int Irq_Stk_Check, Irq_Stk_End;  LispPTR moveframe();E 12E 8I 8  extern int Irq_Stk_Check, Irq_Stk_End;  LispPTR moveframe();E 8#ifdef STACKCHECK  LispPTR stackcontents;  LispPTR TopIVAR;E 5E 2I 5  stackcontents= *((LispPTR*)CurrentStackPTR);  TopIVAR= *((LispPTR*)IVar);#endifE 5D 2#ifdef STACKCHECK#define S_CHECK(condition)	{ if(!(condition)) error("S_Check..");}#define CHECK_BF(bf68k) check_BF(bf68k)#define CHECK_FX(fx68k) check_FX(fx68k)#define PreMoveFrameCheck(fx68k) { LispPTR *tos_on_stack; \ if(check_stack_rooms(fx68k) > 100){ \    warn("moveframe:there is more than 100 words SPACE for FX"); \	printf("# When calling "); \    tos_on_stack=(LispPTR*)Addr68k_from_StkOffset((fx68k)->nextblock - 2); \	print_atomname(*tos_on_stack); \	printf("\n"); \	stack_check(0); \  }}#else#define S_CHECK(condition)	{}#define PreMoveFrameCheck(fx68k) {}#define CHECK_BF(bf68k) {}#define CHECK_FX(fx68k) {}E 2I 2D 6D 12 /* Don't care PC,FuncObj,	TopOfStack(has atomindex or closure obj) */E 6I 6 /* Don't care PC,FuncObj, */E 6D 8 /* Don't care incall flag */E 12I 12 /* Don't care PC,FuncObj, */ /*if incall flag ON ,Don't care IVar 	,became resudual and it is pointed by copied FX's BLINK*/E 12E 8I 8 /*if incall flag ON ,Don't care IVar 	,became resudual and it is pointed by copied FX's BLINK*/E 8  oldPVar=PVar;E 2D 2#endifE 2I 2 if(*NeedHardreturnCleanup_word)  {D 5	printf("HardreturnCleanup in DOSTACKOVERFLOW\n");	return(1);E 5I 5	warn("HardreturnCleanup in DOSTACKOVERFLOW");E 5  }I 5D 6D 12 savecsp=CurrentStackPTR;E 5 CurrentStackPTR += 2;	/* STK_LIMOFFSET stil needed ? */E 2E 6I 6D 8 savenext=CURRENTFX->nextblock; /* save old nextblock */ CurrentStackPTR += 2;	/* move CSTKP to keep whole currnet STK contents */E 8I 8D 9/* move CSTKP to keep whole currnet STK contents */ CurrentStackPTR += 2;E 9if(incallp){ 	savenext=CURRENTFX->nextblock; /* save old nextblock */ }E 8D 9 /* Now nextblock includes Args for next funcall */E 6D 2warn(s)char *s;{ printf("WARN: %s \n",s); }E 2I 2 CURRENTFX->nextblock=StkOffset_from_68K(CurrentStackPTR); /* FSB set */ *(CurrentStackPTR)=STK_FSB_WORD; *(CurrentStackPTR+1)= (((int)EndSTKP-(int)CurrentStackPTR)>>1);E 12I 12if(incallp){ 	savenext=CURRENTFX->nextblock; /* save old nextblock */ }BEFORE_CONTEXTSW;E 12E 9I 9BEFORE_CONTEXTSW;E 9/* Don't Use MIDPUNT and Don't care IFPAGE *//* Call MOVEFRAME directory */D 5 newfx=(DLword)moveframe(CURRENTFX);/* Return from MOVEFRAME directory */E 5I 5 if((newfx=(DLword)moveframe(CURRENTFX)) == 0xFFFF) {D 8D 12	LoopCounter=0; /* To make immidiately call HARDRESET */E 12I 12	 /* To make immidiately call HARDRESET */	Irq_Stk_Check = 0;	Irq_Stk_End=0; 		E 12E 8I 8	 /* To make immidiately call HARDRESET */	Irq_Stk_Check = 0;	Irq_Stk_End=0; 		E 8	return(1); /* Whole space exausted */ }E 5I 5/* Return from MOVEFRAME directory */ E 5 PVar=(DLword*)Addr68k_from_StkOffset(newfx+FRAMESIZE);I 5 movedistance= ((int)PVar-(int)oldPVar) >>1;E 5D 9D 12 next68k =(DLword*)Addr68k_from_StkOffset(CURRENTFX->nextblock);I 6 CurrentStackPTR=next68k -2;E 6 if(*next68k != STK_FSB_WORD) error("pre_moveframe: MP9316");I 5 CHECK_FX(CURRENTFX);E 5 freeptr=next68k;/* Merging FSB area */  while(*freeptr == STK_FSB_WORD)  	EndSTKP=freeptr=freeptr+  *(freeptr+1);/* Set current Stack Limit */StkLimO = EndSTKP - STKLIMOFFSET ; S_CHECK(next68k < StkLimO);E 9I 9 AFTER_CONTEXTSW;E 9D 6D 5CurrentStackPTR =(DLword *)next68k -2 ;E 5I 5CurrentStackPTR=savecsp +movedistance;E 6I 6D 8/* set next(it pointed to old IVar) with offset */CURRENTFX->nextblock= savenext + movedistance;  /* including Last Arg(kept in TOS */E 6E 5S_CHECK(FuncObj == (struct fnhead *)E 12I 12 AFTER_CONTEXTSW;if(incallp){	/* set next(it pointed to old IVar) with offset */	CURRENTFX->nextblock= savenext + movedistance;  	/* including Last Arg(kept in TOS */	S_CHECK(FuncObj == (struct fnhead *)E 12E 8I 8if(incallp){	/* set next(it pointed to old IVar) with offset */	CURRENTFX->nextblock= savenext + movedistance;  	/* including Last Arg(kept in TOS */	S_CHECK(FuncObj == (struct fnhead *)E 8			Addr68k_from_LADDR(				(CURRENTFX->hi2fnheader << 16) | 				CURRENTFX->lofnheader) );D 8D 12CHECK_FX(CURRENTFX);E 12I 12	CHECK_FX(CURRENTFX);E 12E 8I 8	CHECK_FX(CURRENTFX);E 8D 8D 12 /* We should re-Set up IVAR,CURRENTFX->nextblock */E 12I 12	 /* We should re-Set up IVAR,CURRENTFX->nextblock */	 IVar += movedistance;} /* incallp */E 12D 5 IVar += ((int)PVar-(int)oldPVar) >>1; CURRENTFX->nextblock =StkOffset_from_68K(IVar);E 5D 6E 6I 5D 12 IVar += movedistance;D 6 CURRENTFX->nextblock =StkOffset_from_68K(IVar);E 6I 6D 7 if(!(CURRENTFX->nextblock ==StkOffset_from_68K(IVar)))    printf("do_stack..Ill stackptr & next \n");E 7I 7 /* This will be commented out untill inline code chenged S_CHECK(CURRENTFX->nextblock ==StkOffset_from_68K(IVar)) *******/E 7E 6E 5 return(0); /* Normal return *//* we CAN continue executing FN or APPLY by just returning */E 12I 12  return(0); /* Normal return *//* If  incallp ,we CAN continue executing FN or APPLY by just returning */E 12E 8I 8	 /* We should re-Set up IVAR,CURRENTFX->nextblock */	 IVar += movedistance;} /* incallp */  return(0); /* Normal return *//* If  incallp ,we CAN continue executing FN or APPLY by just returning */E 8/* new PVar will set in funcall */}/* end do_stackoverflow */E 2/******************************************************************//*        Func Name :     moveframe(oldfx68k)                Edited by :     Take(March 14, 1988)*//******************************************************************/D 5moveframe(oldfx68k)E 5I 5LispPTR moveframe(oldfx68k)E 5D 10D 12 FX *oldfx68k;E 12I 12 register FX *oldfx68k;E 12E 10I 10 register FX *oldfx68k;E 10{D 10D 12 int size; DLword *next68k; DLword *new68k;E 12I 12 register int size; register DLword *next68k; register DLword *new68k;E 12E 10I 10 register int size; register DLword *next68k; register DLword *new68k;E 10 DLword *freestackblock(); DLword *extendstack(); int nametbl_on_stk =NIL;D 12 E 12I 12D 13E 13I 13 E 13E 12 PreMoveFrameCheck(oldfx68k); flip_cursorbar(10); size = FX_size(oldfx68k) + DLWORDSPER_CELL;I 5 S_CHECK(size > 0);E 5 next68k=Addr68k_from_StkOffset(oldfx68k->nextblock); if(FSBP(next68k))  {        /* merge free blocks */        for(new68k = next68k + FSB_size(next68k);			FSBP(new68k); new68k+= FSB_size(new68k))                FSB_size(next68k) += FSB_size(new68k);        if(StkOffset_from_68K(new68k) == InterfacePage->endofstack)        {                if(extendstack() != NIL)                 {                        new68k=(DLword *)oldfx68k;                        goto out;                 }I 5			else			 {				/* These lines are different from Original Code */				return(0xFFFF); /* No space */			 }E 5        }          }CHECK_FX(oldfx68k);S_CHECK(oldfx68k->usecount == 0); /* we don't check\INTERRUPTABLE */if(oldfx68k->validnametable && (oldfx68k->hi2nametable==STK_HI)) {   /* frame contains a name table, so we care that the alignment	 of the new block be same as old */D 4/**DEBUG***/E 4I 4#ifdef STACKCHECKE 4        { DLword n;                n=oldfx68k->lonametable;                if((n <= StkOffset_from_68K(oldfx68k))                  && (n >= oldfx68k->nextblock))D 4                        error("moveframe:check!!");E 4I 4D 5                        WARN("moveframe:check!!",						sff(LADDR_from68k(oldfx68k));E 5I 5                        {WARN("moveframe:check!!",						sff(LADDR_from_68k(oldfx68k)));}E 5E 4        }D 4/**DEBUG **/E 4I 4#endifE 4   nametbl_on_stk = T;   /* Find a free stack block */   new68k=freestackblock(size,oldfx68k,        (LADDR_from_68k(oldfx68k)-DLWORDSPER_CELL)% DLWORDSPER_QUAD); }elseD 3  new68k=freestackblock(size,oldfx68k,NIL);E 3I 3  new68k=freestackblock(size,oldfx68k,-1);/* Not needed to align */E 3I 5 if(new68k==0)	return(0xFFFF);  /* exhausted */E 5/* blt(dest,source,size) *//* copy frame and dummy bf pointer too */blt(new68k,(((DLword*)oldfx68k) - DLWORDSPER_CELL),size);((Bframe*)new68k)->residual =T;((DLword*)new68k)+= DLWORDSPER_CELL; /* now NEW points to the FX */D 3((FX*)new68k)->nextblock=(LADDR_from_68k(new68k) + size)-DLWORDSPER_CELL;E 3I 3((FX*)new68k)->nextblock=(StkOffset_from_68K(new68k) + size)-DLWORDSPER_CELL;E 3/* (CHECK (fetch (BF CHECKED) of (fetch (FX BLINK) of OLDFRAME)))*/D 3E 3I 3CHECK_BF(Addr68k_from_StkOffset(GETBLINK(oldfx68k)));E 3/* Set true BFptr,not residual */SETBLINK(new68k,GETBLINK(oldfx68k));if(nametbl_on_stk) {D 5 S_CHECK(( (((int)new68k - (int)oldfx68k)>>1) % DLWORDSPER_QUAD) == 0)E 5I 5 S_CHECK(( (((int)new68k - (int)oldfx68k)>>1) % DLWORDSPER_QUAD) == 0);E 5  ((FX*)new68k)->lonametable += (((int)new68k - (int)oldfx68k)>>1); }if( ((Bframe*)DUMMYBF(oldfx68k))->residual ) {        MAKEFREEBLOCK(((DLword*)oldfx68k)-DLWORDSPER_CELL , size); }else {        MAKEFREEBLOCK(oldfx68k,size - DLWORDSPER_CELL); }out: flip_cursorbar(10); return(S_POSITIVE|StkOffset_from_68K(new68k));} /* moveframe end *//******************************************************************//*        Func Name :     extendstack()        Desc.     :     if LastStackAddr is exceeded,then allocate                         one new lisppage for STACK area.                        Edited by :     Take(March 14, 1988)                        *//******************************************************************/DLword *extendstack(){D 10D 12 LispPTR easp; LispPTR scanptr;E 12I 12 register LispPTR easp; register LispPTR scanptr;E 12E 10I 10 register LispPTR easp; register LispPTR scanptr;E 10 easp = InterfacePage->endofstack; if (easp < LOLOC(*LastStackAddr_word))  {        if((easp > LOLOC(*GuardStackAddr_word)) &&                ((*STACKOVERFLOW_word)== NIL) )         {                ((INTSTAT*)INTERRUPTSTATE_word)->stackoverflow = ATOM_T;                *STACKOVERFLOW_word = *PENDINGINTERRUPT_word=ATOM_T;         }        newpage(STK_OFFSET|(scanptr=easp+2));        /* I don't concern about DOLOCKPAGES */        MAKEFREEBLOCK(Addr68k_from_StkOffset(scanptr),DLWORDSPER_PAGE-2);	   InterfacePage->endofstack = scanptr=easp+DLWORDSPER_PAGE;        SETUPGUARDBLOCK(		Addr68k_from_StkOffset(InterfacePage->endofstack), 2);        MAKEFREEBLOCK(Addr68k_from_StkOffset(easp) , 2);        return((DLword*)Addr68k_from_StkOffset(scanptr));  } else   return(NIL);} /* end extendstack *//******************************************************************//*        Func Name :     freestackblock(n,sart,align)        Desc.     :     Search the FSB has specified size n or more                        Return useful area's ptr.I 5				   If there is no space for STACK,return 0E 5        Edited by :     take(15-Jul-87)D 5                        take(4-Aug-87)E 5I 5                        take(11-Apr-88)E 5*//******************************************************************/DLword *freestackblock( n , start68k , align ) DLword n ;     /* size you want(in DLword) */ StackWord *start68k; /* searching will start68k at here */D 3 DLword align ;E 3I 3 int align ; /* if Negative,it needn't align */E 3{D 10D 12 int wantedsize; int firstfreesize; StackWord *scanptr68k ; StackWord *orig68k ; STKBLK *freeptr68k; StackWord *easp68k; DLword freesize;E 12I 12 register int wantedsize; register StackWord *scanptr68k ; register StackWord *orig68k ; register STKBLK *freeptr68k; register StackWord *easp68k; register DLword freesize;E 12E 10I 10 register int wantedsize; register StackWord *scanptr68k ; register StackWord *orig68k ; register STKBLK *freeptr68k; register StackWord *easp68k; register DLword freesize;E 10 DLword *extendstack(); /* compute actually size you needed */ wantedsize = n + STACKAREA_SIZE + MINEXTRASTACKWORDS ; easp68k =(StackWord*) (Addr68k_from_StkOffset(InterfacePage->endofstack)) ;/*** DEBUG ***/I 5S_CHECK(n>2);E 5S_CHECK(start68k != 0);S_CHECK(start68k >= (StackWord*)Addr68k_from_StkOffset(InterfacePage->stackbase));STARTOVER :   if(start68k) 	scanptr68k =start68k;  else 	scanptr68k = (StackWord *)Addr68k_from_StkOffset(InterfacePage->stackbase);D 4SCAN :  switch(scanptr68k->flags){E 4I 4SCAN :  switch((unsigned)(scanptr68k->flags)){E 4        case STK_FSB :  goto FREESCAN ;                                break;        case STK_GUARD: if(scanptr68k < easp68k)                            goto FREESCAN;                        if (start68k) {                                scanptr68k =(StackWord *)Addr68k_from_StkOffset                                (InterfacePage->stackbase);                                goto SCAN ; }                        else goto NEWPAGE ;                        break;        case STK_FX :   scanptr68k =(StackWord *)Addr68k_from_StkOffset(					((FX*)scanptr68k)->nextblock);                        break ;        default :       orig68k = scanptr68k;                        while(scanptr68k->flags != STK_BF) {D 5                                S_CHECK(scanptr68k->flags==STK_NOTFLG)E 5I 5                                S_CHECK(scanptr68k->flags==STK_NOTFLG);E 5                                ((DLword *)scanptr68k) += DLWORDSPER_CELL ;                          };D 4/*DEBUG*/                        if(((Bframe*)scanptr68k)->residual)E 4I 4D 5#ifdef STACKCHECK                        if(((Bframe*)scanptr68k)->residual)E 5I 5#ifdef STACKCHECK                        				   if(((Bframe*)scanptr68k)->residual)E 5E 4                          { if(scanptr68k != orig68k) D 4                            error("freestackblock:scanptr68k != org");}E 4I 4D 5                            WARN("freestackblock:scanptr68k != org",printf(":0x%x\n",LADDR_from_68k(scanptr68k)));}E 5I 5                             {D 12						 WARN("freestackblock:scanptr68k !=org",E 12I 12D 13						 error("freestackblock:scanptr68k !=org",E 13I 13						 WARN("freestackblock:scanptr68k !=org",E 13E 12						printf(":0x%x\n",LADDR_from_68k(scanptr68k)));					   }					}E 5E 4				   else					{					   if(((Bframe*)scanptr68k)->ivar 						!= StkOffset_from_68K(orig68k))D 4						error("BF doesn't point TopIVAR");E 4I 4D 5						WARN("BF doesn't point TopIVAR",printf(":0x%x\n",LADDR_from_68k(scanptr68k)));E 5I 5						{D 12							WARN("BF doesn't point TopIVAR",printf(":0x%x\n",LADDR_from_68k(scanptr68k)));E 12I 12D 13							error("BF doesn't point TopIVAR",printf(":0x%x\n",LADDR_from_68k(scanptr68k)));E 13I 13							WARN("BF doesn't point TopIVAR",printf(":0x%x\n",LADDR_from_68k(scanptr68k)));E 13E 12						}E 5E 4					}D 4/*DEBUG*/E 4I 4#endifE 4                        ((DLword*)scanptr68k) += DLWORDSPER_CELL ;                        break;      } /* end switch(scanptr68k */NEXT: if(scanptr68k != start68k){         S_CHECK(scanptr68k <=easp68k) ;         goto SCAN ;        }NEWPAGE :       easp68k =(StackWord*)extendstack();			if(easp68k)                	goto STARTOVER;                else  D 5				error("freestackblock:StackFull MP9319");E 5I 5			 {D 12				warn("freestackblock:StackFull MP9319");E 12I 12D 13				error("freestackblock:StackFull MP9319");E 13I 13				warn("freestackblock:StackFull MP9319");E 13E 12				return(0);			 }E 5FREESCAN :      freeptr68k=(STKBLK *)scanptr68k;                freesize=FSB_size(freeptr68k) ;FREE:           scanptr68k = (StackWord *)((DLword *)freeptr68k + freesize);D 4                switch(scanptr68k->flags){E 4I 4                switch((unsigned)(scanptr68k->flags)){E 4                        case STK_FSB : freesize += FSB_size(scanptr68k) ;                                        goto FREE ;                                        break ;                        case STK_GUARD : if(scanptr68k<easp68k){                                                freesize += FSB_size(scanptr68k);                                                goto FREE ;                                         }                                        break;                        default :       break;                                } /* end switch(scanp.. */ if(freesize >= wantedsize){D 3   if((align==NIL) || (align==(LADDR_from_68k(freeptr68k)) % DLWORDSPER_QUAD))E 3I 3   if((align<0) || (align==(StkOffset_from_68K(freeptr68k) % DLWORDSPER_QUAD)))E 3        wantedsize= MINEXTRASTACKWORDS;   else         wantedsize= MINEXTRASTACKWORDS+DLWORDSPER_CELL;   scanptr68k =(StackWord*) (((DLword *)freeptr68k) + wantedsize);   SETUPGUARDBLOCK(scanptr68k, n);   MAKEFREEBLOCK(freeptr68k,wantedsize);   MAKEFREEBLOCK(((DLword*)scanptr68k) + n, freesize - wantedsize -n);   return((DLword*)scanptr68k);  } else    MAKEFREEBLOCK( freeptr68k, freesize);goto NEXT ;} /* freestackblock end *//******************************************************************//*        Func Name :     decusecount68k(frame)        Desc.     :     Search the FSB has specified size n or more                        Return useful are ptr.        Edited by :     take(March 14, 1988)*//******************************************************************/#define BF_size(ptr68k) ((StkOffset_from_68K(ptr68k)) - ((Bframe*)(ptr68k))->ivar + 2)decusecount68k(frame68k)D 10D 12 FX *frame68k ;E 12I 12  register FX *frame68k ;E 12E 10I 10  register FX *frame68k ;E 10{ DLword *alink68k;D 10D 12 Bframe *blink68k;E 12I 12 register Bframe *blink68k;E 12E 10I 10 register Bframe *blink68k;E 10 DLword *clink68k;D 10D 12 DLword *ivar68k; int size;E 12I 12 register DLword *ivar68k; register int size;E 12E 10I 10 register DLword *ivar68k; register int size;E 10I 4if(FX_INVALIDP(frame68k)) return;CHECK_FX(frame68k);E 4/* I don't check if \INTERRUPTABLE is NIL */ while(StkOffset_from_68K(frame68k)) {        if(frame68k->usecount != 0)        {                frame68k->usecount--;                return;         }        else        {                alink68k = Addr68k_from_StkOffset(GETALINK(frame68k));                blink68k =(Bframe*) Addr68k_from_StkOffset(GETBLINK(frame68k));                clink68k = Addr68k_from_StkOffset(GETCLINK(frame68k));                size = FX_size(frame68k);                if(((Bframe*)DUMMYBF(frame68k))->residual)                { /* this frame has dummy BF */                        MAKEFREEBLOCK(((DLword*)frame68k) -DLWORDSPER_CELL,size+DLWORDSPER_CELL);                }                else                {                        MAKEFREEBLOCK(frame68k,size);                }                if(blink68k->usecnt !=0)                {                        blink68k->usecnt--;                }                else                {                    /***    ivar68k=Addr68k_from_StkOffset(blink68k->ivar);                        *ivar68k=STK_FSB_WORD;                        *(ivar68k+1)=ivar68k -(DLword *)blink68k +2 ; **/				MAKEFREEBLOCK(Addr68k_from_StkOffset(blink68k->ivar),							BF_size(blink68k));                }                if(alink68k!= clink68k)                        decusecount68k(alink68k);                frame68k = (FX*)clink68k ;        } /* else end */ }/*while end */} /* decusecount68k end */I 12#ifdef ORG_FILPCORSORBARE 12I 7#ifdef ORG_FILPCORSORBARE 7extern DLword *EmCursorBitMap68K;extern int LispWindowFd;extern struct cursor CurrentCursor; flip_cursorbar(n)int n;{ *(EmCursorBitMap68K +n) = ~(*(EmCursorBitMap68K +n)); win_setcursor(LispWindowFd,&CurrentCursor);}I 12#elseextern struct pixrect *ScreenBitMap; flip_cursorbar(n)int n;{   pr_rop(ScreenBitMap,0,0,16,2*n,	PIX_NOT(PIX_SRC),ScreenBitMap,0,0);/* 16->width 2*n ->height */}#endifE 12D 7E 7I 7#elseextern struct pixrect *ScreenBitMap; flip_cursorbar(n)int n;{   pr_rop(ScreenBitMap,0,0,16,2*n,	PIX_NOT(PIX_SRC),ScreenBitMap,0,0);/* 16->width 2*n ->height */}#endifE 7D 12E 12/**************************************************************//*                blt(dest,source,size)*//**************************************************************/blt(dest68k,source68k,nw)D 10D 12  DLword *source68k;  DLword *dest68k ;E 12I 12 register DLword *source68k; register DLword *dest68k ;E 12E 10I 10 register DLword *source68k; register DLword *dest68k ;E 10  int nw;{I 12/******* OLD def , Due to C compiler's bug, we can't use pre-decriment for register valE 12I 10/******* OLD def , Due to C compiler's bug, we can't use pre-decriment for register valE 10  source68k += nw ;  dest68k += nw ;  while(nw)  {     *(--dest68k)= *(--source68k) ;    nw--;   }I 12**** OLD def ****/  source68k += nw-1 ;  dest68k += nw-1 ;  while(nw--)  {     *(dest68k--)= *(source68k--) ;  }E 12I 10**** OLD def ****/  source68k += nw-1 ;  dest68k += nw-1 ;  while(nw--)  {     *(dest68k--)= *(source68k--) ;  }E 10}/**************************************************************//*		stack_check(start68k)		for DEBUG *//**************************************************************/stack_check(start68k) StackWord *start68k;{   StackWord *scanptr68k ;   StackWord *endstack68k;   DLword *top_ivar;I 4   DLword save_nextblock;   DLword savestack1,savestack2;I 5   DLword setflg=NIL;E 5E 4I 4  if((CURRENTFX->nextblock != StkOffset_from_68K(CurrentStackPTR))	||(!FSBP(CurrentStackPTR)))  {	if((DLword*)CURRENTFX >= CurrentStackPTR)I 5	{E 5		WARN("CURRENTFX >= CurrentStackPTR??\n",		printf("CURRENTFX=0x%x,CurrentStackPTR=0x%x\n",			LADDR_from_68k(CURRENTFX),LADDR_from_68k(CurrentStackPTR)));I 5	}	setflg=T;E 5	printf("set CURRENTFX->nextblock in debugger \n");	save_nextblock=CURRENTFX->nextblock;	savestack1= *(CurrentStackPTR+2);	savestack2= *(CurrentStackPTR+3);	CURRENTFX->nextblock=StkOffset_from_68K(CurrentStackPTR+2);	*(CurrentStackPTR+2)=STK_FSB_WORD;	*(CurrentStackPTR+3)= (((int)EndSTKP-(int)(CurrentStackPTR+2))>>1); }E 4  if(start68k) 	scanptr68k =start68k;  else scanptr68k= (StackWord *)Addr68k_from_StkOffset(InterfacePage->stackbase);endstack68k=(StackWord *)Addr68k_from_StkOffset(InterfacePage->endofstack);if(endstack68k->flags !=STK_GUARD) printf("?? endstack is not GUARD BLK\n");while(scanptr68k <endstack68k){D 4  switch(scanptr68k->flags){E 4I 4  switch((unsigned)(scanptr68k->flags)){E 4        case STK_FSB :	((DLword*)scanptr68k) +=FSB_size(scanptr68k) ;					putchar('F');					break;	   case STK_GUARD:	((DLword*)scanptr68k) +=FSB_size(scanptr68k) ;					putchar('G');					break;        case STK_FX :	CHECK_FX(scanptr68k);					scanptr68k =(StackWord *)Addr68k_from_StkOffset(					((FX*)scanptr68k)->nextblock);					putchar('X');					break;	   default:		top_ivar=(DLword*)scanptr68k;					while(scanptr68k->flags != STK_BF) {						if (scanptr68k->flags!=STK_NOTFLG)I 5						{E 5D 4                                error("StackCheck:!=STK_NOTFLG");E 4I 4                                WARN("StackCheck:!=STK_NOTFLG",printf("content:0x%x\n",*scanptr68k));I 5						}E 5E 4                                ((DLword *)scanptr68k) += DLWORDSPER_CELL ;                            }/* while end */;					CHECK_BF(scanptr68k);					if(((Bframe*)scanptr68k)->residual)					 {						if((DLword*)scanptr68k != top_ivar)							error("Residual has real IVAR");					  }					else					 {					   if(((Bframe*)scanptr68k)->ivar 						!= StkOffset_from_68K(top_ivar))						error("BF doesn't point TopIVAR");					  }					((DLword *)scanptr68k) += DLWORDSPER_CELL ;					putchar('B');					break;  }/*switch end */  if(scanptr68k != start68k)   {	if(scanptr68k >endstack68k)I 5	{E 5D 4		error("scanptr exceeded end stack");E 4I 4		WARN("scanptr exceeded end stack",printf("scanptr68k=0x%x endstack68k=0x%x",scanptr68k,endstack68k));I 5	}E 5E 4  }}/* while end */D 4printf("\nStcak Cehck done\n");E 4I 4printf("\nStack Cehck done\n");D 5CURRENTFX->nextblock=save_nextblock;*(CurrentStackPTR+2)=savestack1;*(CurrentStackPTR+3)=savestack2;E 5I 5 if(setflg) {	CURRENTFX->nextblock=save_nextblock;	*(CurrentStackPTR+2)=savestack1;	*(CurrentStackPTR+3)=savestack2; }E 5E 4}/*stack_check end */check_FX(fx68k)FX *fx68k;{	Bframe *dummybf,*mtmp; 	int mblink; 	if(((FX*)(fx68k))->flags != STK_FX) 		error("CheckFX:NOT FX"); 	dummybf=(Bframe*)DUMMYBF(fx68k); 	if(StkOffset_from_68K(dummybf) == GETBLINK(fx68k)) 			{goto checkfx_OK;} 	mblink=GETBLINK(fx68k); 	mtmp=(Bframe*)Addr68k_from_StkOffset(mblink);	if( ( dummybf->residual != NIL ) && 		( dummybf->ivar == mtmp->ivar ) )			goto checkfx_OK;	else 		error("CheckFX:bad residual case");	checkfx_OK: return;} /* END check_FX */check_BF(bf68k) Bframe *bf68k;{ Bframe *iptr68k;	if(bf68k->flags != STK_BF) 		error("checkBF:not BF1"); 	if(bf68k->residual == T)		return;	else	{	for(iptr68k=(Bframe*)Addr68k_from_StkOffset(bf68k->ivar);		iptr68k <=(Bframe*)(((DLword*)bf68k)-2); 		iptr68k++ ) /* inc 2DLword */ 		{ 		  if(iptr68k->flags!=STK_NOTFLG)  			error("CheckBF:Not BF2"); 		} 	}} /* end check_BF */check_stack_rooms(fx68k)FX *fx68k;{  int size;  DLword *freeptr68k,*endstk68k;  CHECK_FX(fx68k);  freeptr68k=Addr68k_from_StkOffset(fx68k->nextblock); if(!FSBP(freeptr68k))  error("check_stack_rooms:nextblock doesn't point FSB"); /*endstk68k=freeptr68k + FSB_size(freeptr68k); size=((int)endstk68k - (int)CurrentStackPTR) >> 1;*/ return(FSB_size(freeptr68k));  } /* end check_stack_rooms */E 1