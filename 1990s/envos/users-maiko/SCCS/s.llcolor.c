h49626s 00034/00017/00328d D 1.6 92/11/25 21:08:20 sybalsky 6 5c Fixing endif's with extra text => comment. \nes 00005/00005/00340d D 1.5 92/04/21 17:18:53 sybalsky 5 4c shortening file names for DOS \nes 00001/00000/00344d D 1.4 91/09/27 02:38:26 sybalsky 4 3c ISC port changeses 00022/00003/00322d D 1.3 90/09/18 23:45:41 sybalsky 3 2c Retrofit changes from AIX, DEC3100, PS/2es 00033/00003/00292d D 1.2 90/06/12 17:55:39 fuji 2 1c Matsuda: bug fixes 00295/00000/00000d D 1.1 90/05/14 13:01:18 fuji 1 0c date and time created 90/05/14 13:01:18 by fujieuUf e 0tTI 3/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 3I 1/**** Copyright (C) 1990 by Fuji Xerox co.,Ltd.. Al rights reserved.**               Author: Mitsunori Matsuda*               Date  : April 17, 1990*/I 3/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 3#include <stdio.h>I 3#ifndef NOPIXRECTE 3#include <sunwindow/window_hs.h>#include <sunwindow/cms.h>D 3#include <sys/ioctl.h>#include <sys/mman.h>E 3#include <sunwindow/win_ioctl.h>#include <pixrect/pixrect_hs.h>#include <sun/fbio.h>I 3#include <pixrect/pr_planegroups.h>#include <sys/mman.h>D 6#endif NOPIXRECTE 6I 6#endif /* NOPIXRECT */E 6E 3#include <sys/ioctl.h>I 4#include <sys/types.h>E 4#include <sys/file.h>D 3#include <pixrect/pr_planegroups.h>E 3#include <errno.h>#include "lispemul.h"#include "lispmap.h"D 5#include "lisptypes.h"E 5I 5#include "lsptypes.h"E 5#include "address.h"D 5#include "address68k.h"#include "lispglobal.h"#include "emulglobal.h"E 5I 5#include "adr68k.h"#include "lspglob.h"#include "emlglob.h"E 5#include "display.h"D 5#include "devconfig.h"E 5I 5#include "devconf.h"E 5#include "bb.h"#include "bitblt.h"#include "pilotbbt.h" #include "dbprint.h"int MonoOrColor=MONO_SCREEN;DLword *ColorDisplayRegion68k;int Dispcolorsize;int Inited_Color = NIL;extern struct pixrect *ColorDisplayPixrect;extern int DisplayWidth	 , DisplayHeight	 , FrameBufferFd;/*******************************************************************//*	Func name	: cgfour_init_color_display(args)	Arg(s)		: COLOR BITMAP ADDRESS(LISPPTR)	Desc		: Assign to SUBR 0210			  mmap LispPTR to Color Display FB.	By  Takeshi*//*******************************************************************/I 2#ifdef COLORE 2cgfour_init_color_display(color_bitmapbase) /* SUBR 0210 */    LispPTR color_bitmapbase;  /* COLOR BITMAP ADDRESS */    {    struct pixrect *ColorFb;    struct pixrect *color_source;    int mmapstat; if(MonoOrColor == COLOR_SCREEN) {	printf("You can not initialize the color screen from inside color screen. \n");  }    ColorDisplayRegion68k = Addr68k_from_LADDR(color_bitmapbase );        Dispcolorsize = ((DisplayWidth * DisplayHeight + (getpagesize()-1) )			& -getpagesize()); /* 8 bit depth */#ifndef DISPLAYBUFFER    ColorFb = pr_open("/dev/fb");#else     ColorFb = ColorDisplayPixrect;D 6#endif DISPLAYBUFFERE 6I 6#endif /* DISPLAYBUFFER */E 6I 2I 6E 6#ifndef DISPLAYBUFFERE 2    color_source = mem_point(DisplayWidth,DisplayHeight,8,	ColorDisplayRegion68k);     pr_set_plane_group(ColorFb, PIXPG_8BIT_COLOR);    pr_rop(ColorFb,0,0,DisplayWidth,DisplayHeight,PIX_SRC,	color_source,0,0);D 2#ifndef DISPLAYBUFFERE 2    mmapstat = (int)mmap(ColorDisplayRegion68k ,			Dispcolorsize,			PROT_READ | PROT_WRITE,#ifdef OS4			MAP_FIXED |#endif			MAP_SHARED,			FrameBufferFd, 0x40000 );    if(mmapstat == -1){	perror("cgfour_init_color_display: ERROR at mmap system call\n");	error ("cgfour_init_color_display: ERROR at mmap system call\n You may be able to continue by typing 'q'");	}D 6#endif DISPLAYBUFFERE 6I 6#endif /* DISPLAYBUFFER */E 6I 6E 6    printf("COLOR-INIT OK BMBASE=0x%x\nNATIVE:= 0x%x)\n",	color_bitmapbase,ColorDisplayRegion68k);	Inited_Color = T; /* Color display is active. */    return(color_bitmapbase);    } /* end cgfour_init_color_display */I 2D 6#else COLORE 6I 6#else /* COLOR */E 6cgfour_init_color_display(color_bitmapbase) /* SUBR 0210 */    LispPTR color_bitmapbase;  /* COLOR BITMAP ADDRESS */{	printf( "Color is not supported.\n" );}D 6#endif COLORE 6I 6#endif /* COLOR */E 6E 2/*******************************************************************//*	Func name	: cgfour_change_screen_mode(which_screen)	Arg(s)		: MONO_SCREEN OR COLOR_SCREEN	Desc		: Assign to SUBR 0211			  Change screen Mono to Color,vice versa.	By  Takeshi*//*******************************************************************/D 2E 2I 2#ifdef COLORE 2cgfour_change_screen_mode(which_screen)    LispPTR which_screen;    { /* subr 0211 */    struct pixrect *ColorFb;    extern ScreenLocked;    extern DLword *EmCursorX68K,*EmCursorY68K;	int mmapstat;#ifndef DISPLAYBUFFER    ColorFb = pr_open("/dev/fb");#else     ColorFb = ColorDisplayPixrect;D 6#endif DISPLAYBUFFERE 6I 6#endif /* DISPLAYBUFFER */E 6    ScreenLocked=T;    taking_mouse_down();    switch (which_screen & 0xf) {        case MONO_SCREEN : { /* resume mono screen */#ifdef DISPLAYBUFFER	    mmapstat = (int)munmap( ColorDisplayRegion68k, Dispcolorsize );		if( mmapstat == -1){			perror("cg_four_change_screen: ERROR at munmap system call\n");			exit( 0 );		} /* end if(mmapstat) */	    save_color_screen();D 6#endif DISPLAYBUFFERE 6I 6#endif /* DISPLAYBUFFER */E 6	    pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);	    pr_rop(ColorFb,0,0,		   ColorFb->pr_width,		   ColorFb->pr_height, PIX_SET, 0, 0, 0);	    pr_set_plane_group(ColorFb, PIXPG_OVERLAY);#ifdef DISPLAYBUFFER	    flush_display_buffer();D 6#endif DISPLAYBUFFERE 6I 6#endif /* DISPLAYBUFFER */E 6	    MonoOrColor = MONO_SCREEN;	    break;	    }        case COLOR_SCREEN : {#ifndef DISPLAYBUFFER	    pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);	    pr_rop(ColorFb,0,0,		   ColorFb->pr_width,		   ColorFb->pr_height, PIX_CLR, 0, 0, 0);D 6#endif DISPLAYBUFFERE 6I 6#endif /* DISPLAYBUFFER */E 6	    pr_set_plane_group(ColorFb, PIXPG_8BIT_COLOR);#ifdef DISPLAYBUFFER	    restore_color_screen();	    mmapstat = (int)mmap(ColorDisplayRegion68k ,					Dispcolorsize,					PROT_READ | PROT_WRITE,#ifdef OS4					MAP_FIXED |#endif					MAP_SHARED,					FrameBufferFd, 0x40000 );	   if(mmapstat == -1){		perror("cg_four_change_screen: ERROR at mmap system call\n");		exit(0);	   }D 6#endif DISPLAYBUFFERE 6I 6#endif /* DISPLAYBUFFER */E 6	    MonoOrColor = COLOR_SCREEN;	    break;	    }	default : {	    error("cgfour_change_screen_mode:Unknown mode:");	    }	};#ifndef DISPLAYBUFFER    pr_close(ColorFb);D 6#endif DISPLAYBUFFERE 6I 6#endif /* DISPLAYBUFFER */E 6I 6E 6    taking_mouse_up(*EmCursorX68K,*EmCursorY68K);    ScreenLocked=NIL;    return(which_screen);    }I 2D 6#else COLORE 6I 6#else /* COLOR */E 6cgfour_change_screen_mode(which_screen)    LispPTR which_screen;{	printf( "Color is not supported.\n" );}D 6#endif COLORE 6I 6#endif /* COLOR */E 6E 2I 6E 6/*******************************************************************//*	Func name	: cgfour_set_colormap(args)	Arg(s)		: Passed by args			  index: colormap index(0~255)			  red,green,blue:(0~255)	Desc		: Assign to SUBR 0212			  Set Colormap entry	By  Takeshi*//*******************************************************************/unsigned char RED_colormap;unsigned char GRN_colormap;unsigned char BLU_colormap;I 2#ifdef COLORE 2cgfour_set_colormap(args)    LispPTR args[];    {    int index;    struct pixrect *ColorFb;    index=args[0] & 0xff;    RED_colormap = (unsigned char) (args[1] & 0xff);    GRN_colormap = (unsigned char) (args[2] & 0xff);    BLU_colormap = (unsigned char) (args[3] & 0xff);    ColorFb = pr_open("/dev/fb");    if (pr_putcolormap(ColorFb,index,1,			&RED_colormap,			&GRN_colormap,			&BLU_colormap)==-1)	perror("putcolormap:");    pr_close(ColorFb);    return(T);    }I 2D 6#else COLORE 6I 6#else /* COLOR */E 6cgfour_set_colormap(args)    LispPTR args[];{	printf( "Color is not supported.\n" );}D 6#endif COLORE 6I 6#endif /* COLOR */E 6E 2I 6E 6I 2#ifdef COLORE 2#ifdef DISPLAYBUFFERstatic struct pixrect *saved_screen;D 2static int Screen_Saved = NIL;E 2I 2static int Screen_Saved = T;E 2save_color_screen(){	if( !Screen_Saved ) {		saved_screen = mem_point( DisplayWidth					, DisplayHeight					, 8					, ColorDisplayRegion68k );		pr_rop( saved_screen			, 0, 0, DisplayWidth, DisplayHeight			, PIX_SRC, ColorDisplayPixrect, 0, 0 );		Screen_Saved = T;	} /* end if(!Screen_Saved) */	} /* end save_color_screen() */restore_color_screen(){	if( Screen_Saved ) {I 2		saved_screen = mem_point( DisplayWidth					, DisplayHeight					, 8					, ColorDisplayRegion68k );E 2		pr_rop( ColorDisplayPixrect			, 0, 0, DisplayWidth, DisplayHeight			, PIX_SRC, saved_screen, 0, 0 );		Screen_Saved = NIL;	} /* end if(Screen_Saved) */} /* end restore_color_screen() */D 6#endif DISPLAYBUFFERE 6I 6#endif /* DISPLAYBUFFER */E 6I 6E 6static unsigned char red_colormap[256]		   , green_colormap[256]		   , blue_colormap[256];static int Saved_Colormap = NIL;save_colormap(){	struct pixrect *Color_Fb;	if( !Saved_Colormap ) {		Color_Fb = pr_open( "/dev/fb" );		if( (pr_getcolormap( Color_Fb, 0 , 256					, red_colormap					, green_colormap					, blue_colormap )) == -1 ) 			perror("save_color_map:");		else 			Saved_Colormap = T;		pr_close( Color_Fb );	} /* end if( !Saved_Colormap ) */} /* end save_colormap() */restore_colormap(){	struct pixrect *Color_Fb;	if( Saved_Colormap ) {		Color_Fb = pr_open( "/dev/fb" );		if( (pr_putcolormap( Color_Fb, 0 , 256					, red_colormap					, green_colormap					, blue_colormap )) == -1 ) 			perror("restore_color_map:");		pr_close( Color_Fb );		Saved_Colormap = NIL;	} /* end if( Saved_Colormap ) */} /* end restore_colormap() */I 2D 6#endif COLORE 6I 6#endif /* COLOR */E 6E 2E 1