h19642s 00016/00008/00176d D 1.14 92/11/25 21:07:27 sybalsky 14 13c Fixing endif's with extra text => comment. \nes 00000/00000/00184d D 1.13 92/04/21 17:18:04 sybalsky 13 12c shortening file names for DOS \nes 00018/00002/00166d D 1.12 90/09/18 23:45:17 sybalsky 12 11c Retrofit changes from AIX, DEC3100, PS/2es 00004/00000/00164d D 1.11 90/06/22 16:39:53 fuji 11 10c New compile flag NOETHERes 00000/00000/00164d D 1.10 90/04/20 01:46:21 sybalsky 10 9c AIX:  shortening file names, bulk change.es 00007/00002/00157d D 1.9 89/12/13 10:57:03 sybalsky 9 8c Don't die if not setuid root.es 00002/00002/00157d D 1.8 89/10/19 18:00:14 sybalsky 8 7c don't die on unsupported CG/BW types.  Try to keep going.es 00002/00002/00157d D 1.7 88/12/23 14:04:30 shih 7 6c wrong sccs ides 00058/00017/00101d D 1.6 88/10/12 21:06:39 bane 6 5c Has OS4 ifdefs for both OS3 and OS4 Ethernetes 00002/00000/00116d D 1.5 88/06/30 11:10:53 greep 5 4c put "#ifdef DEBUG" around printfes 00003/00002/00113d D 1.4 88/06/27 15:42:13 cutting 4 3c Fixed to look on PATH for lde.es 00000/00002/00115d D 1.3 88/06/15 21:37:19 shih 3 2c another mistake (checked in wrong file)es 00000/00000/00117d D 1.2 88/06/15 21:36:29 shih 2 1c sccs funniness (ha ha)es 00117/00000/00000d D 1.1 88/06/15 20:38:58 shih 1 0c date and time created 88/06/15 20:38:58 by shiheuUtTI 1D 6/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 6I 6D 7/* This is G-file @(#) ldeether.c Version 1.1 (9/20/88). copyright envos & Fuji Xerox  */static char *id = "@(#) ldeether.c	1.1 9/20/88		(envos & Fuji Xeorx)";E 7I 7D 8/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 8I 8D 12 /* @(#) ldeether.c Version 1.7 (12/23/88). copyright envos & Fuji Xerox  */E 8D 9static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 9I 9static char *id = "@(#) ldeether.c	1.7 12/23/88		(envos & Fuji Xerox)";E 12I 12/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 12E 9E 7E 6D 3/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 3/* * *	startlisp.c, Tue Oct 27 17:24:13 1987 *	Copyright (C) 1988 by Xerox Co.  All rights reserved. */I 11#ifdef NOETHERI 12main (argc, argv, argp) int argc; char **argv, **argp;{}E 12#elseE 11#include <stdio.h>#include <ctype.h>#include <sys/types.h>#include <sys/time.h>#include <sys/socket.h>I 6#ifdef OS4#include <sys/file.h>D 14#endif OS4E 14I 14#endif /* OS4 */E 14E 6#include <net/if.h>#include <netdb.h>#include <netinet/in.h>#include <netinet/if_ether.h>#include <net/nit.h>#include <sys/ioctl.h>I 6#ifdef OS4#include <stropts.h>#include <net/nit_if.h>#include <net/nit_pf.h>D 14#endif OS4E 14I 14#endif /* OS4 */E 14E 6#include <nlist.h>I 6#include <fcntl.h>#include <errno.h>E 6int ether_fd = -1;	/* file descriptor for ether socket */unsigned char ether_host[6] = {0,0,0,0,0,0};	/* 48 bit address */char filetorun[30] = "lde";main(argc, argv, envp) int argc; char **argv, **envp;{	char	Earg[30], Ename[30], **newargv;	int i;D 9E 9I 9	int flags;E 9/* Kickstart program for the Lisp Development Environment (LDE).	Run this as setuid root to open the LDE ether socket.	Passes all arguments through to LDE plus -E <ether-info>	to communicate open ether socket.	<ether-info> looks like this:	<descriptor-number>:<b1>:<b2>:<b3>:<b4>:<b5>:<b6>:<name>	where <descriptor-number> is the number of the open	socket (decimal), and <b1>-<b6> are hex of the socket's	48-bit Ethernet address, and <name> is the name of the	Ethernet device as found by SIOCGIFCONF.*/D 6	/* JRB - This code will have to be a bit different for SUN 4.0; the		probable differences are in commented-out code below		(not ifdefed because they're untested...)	*/if (getuid() != geteuid()){E 6I 6if (!geteuid()){#ifndef OS4E 6	if ((ether_fd = socket(AF_NIT, SOCK_RAW, NITPROTO_RAW)) >= 0) {D 6	/* 4.0: socket -> open("/dev/nit", O_BOTH) */E 6I 6D 14#else OS4E 14I 14#else /* OS4 */E 14	if ((ether_fd =  open("/dev/nit", O_RDWR)) >= 0) {D 14#endif OS4E 14I 14#endif /* OS4 */E 14E 6	/* it's open, now query it and find out its name and address */	/* JRB - must document that LDE uses the first net board as found	by SIOCGIFCONF (see if(4)).  Maybe we need an option to specify	which net board (suspect more than one net board on an LDE machine	will be rare, but...).	*/	struct ifconf if_data;	struct ifreq ifbuf[20];I 6#ifdef OS4	/* first and foremost, get the packet filter module attached		(used for ether_suspend and ether_resume) */	if(ioctl(ether_fd, I_PUSH, "pf") < 0) {		perror("IOCTL push of pf lost");		close(ether_fd);		goto I_Give_Up;	}D 14#endif OS4E 14I 14#endif /* OS4 */E 14E 6	if_data.ifc_len = sizeof(ifbuf);	if_data.ifc_req = ifbuf;D 6	/* 4.0 - before the SIOCGIFCONF, do:		bzero(ifbuf, sizeof(ifbuf))	*/E 6I 6#ifndef OS4E 6	if(ioctl(ether_fd, SIOCGIFCONF, &if_data) < 0) {		perror("Couldn't GIFCONF socket; Net is off");I 6D 14#else OS4E 14I 14#else /* OS4 */E 14	bzero(ifbuf, sizeof(ifbuf));	{		/* we have to get the interface name from another socket, since		/dev/nit doesn't know anything until it gets bound, and we		can't bind it without knowing the interface name... */		int s;		if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {			perror("No socket for interface name");			close(s);			close(ether_fd);			ether_fd = -1;			goto I_Give_Up;		}		if (ioctl(s, SIOCGIFCONF, (char *)&if_data) < 0) {			perror("Couldn't get interface name from socket");			close(s);			close(ether_fd);			ether_fd = -1;			goto I_Give_Up;		}		(void) close(s);	}	if(ioctl(ether_fd, NIOCBIND, &if_data.ifc_req[0]) < 0) {		perror("Couldn't NIOCBIND socket: Net is off");D 14#endif OS4E 14I 14#endif /* OS4 */E 14E 6		close(ether_fd);		ether_fd = -1;		goto I_Give_Up;	}D 6	/* 4.0, before the SIOCGIFADDR, do:		ioctl(ether_fd, NIOCBIND, &if_data.ifc_req[0])	*/E 6	/* now for the address */	if(ioctl(ether_fd, SIOCGIFADDR, &if_data.ifc_req[0]) < 0) {		perror("Couldn't GIFADDR socket: Net is off");		close(ether_fd);		ether_fd = -1;		goto I_Give_Up;	}	bcopy(if_data.ifc_req[0].ifr_addr.sa_data, ether_host, 6);	strcpy(Ename, if_data.ifc_req[0].ifr_name);I 9	flags = fcntl(ether_fd, F_GETFL, 0);	flags = fcntl(ether_fd, F_SETFL, flags | FASYNC | FNDELAY);E 9D 6	/* bind the socket to an interface */E 6I 5#ifdef  DEBUGE 5	printf("init_ether: **** Ethernet starts ****\n");I 5#endifE 5	} else {I_Give_Up:D 6		printf("init_ether: can't open NIT socket\n");E 6I 6		perror("init_ether: can't open NIT socket\n");E 6		ether_fd = -1;I 6D 8		exit();E 8I 8	/*	exit();	*/E 8E 6	}	seteuid(getuid());	}D 6/* OK, right here do other stuff like scan args and fork subshell */E 6I 6/* OK, right here do other stuff like scan args */E 6/* finally crank up LDE; first copy the original args */newargv = (char **) malloc((argc + 1 + (ether_fd > 0)*2) * sizeof (char **));newargv[0] = filetorun;	/* or whatever... */for(i=1; i<argc; i++) newargv[i] = argv[i];/* then if the net is active, spit out the ether info */if(ether_fd > 0) {	newargv[i++] = "-E";	sprintf(Earg, "%d:%x:%x:%x:%x:%x:%x:%s", ether_fd,		ether_host[0], ether_host[1], ether_host[2],		ether_host[3], ether_host[4], ether_host[5], Ename);	newargv[i++] = Earg;}newargv[i] = 0;/* then execve the LDE executable */D 4execve(filetorun, newargv, envp);printf("ACK! execve returned!!  Couldn't execute 'lde' for some reason!\n");E 4I 4execvp(filetorun, newargv);perror(filetorun);exit(1);E 4}I 11D 14#endif NOETHERE 14I 14#endif /* NOETHER */E 14E 11E 1