h40850s 00133/00074/00311d D 2.15 93/02/08 14:59:08 sybalsky 18 17c Big VM (and new CDR coding) changes for 3.0 \nes 00004/00004/00381d D 2.14 92/04/21 17:24:17 sybalsky 17 16c shortening file names for DOS \nes 00001/00001/00384d D 2.13 90/07/04 04:03:23 sybalsky 16 15c Interrupt change -- field names change in interrupt vectores 00003/00003/00382d D 2.12 90/06/15 16:57:16 mitani 15 14c GCLOOKUPes 00023/00001/00362d D 2.11 90/05/31 14:52:02 fuji 14 13c Add NEW storage futures.(various process size)es 00001/00001/00362d D 2.10 90/04/20 01:53:13 sybalsky 13 12c X:  shortening file names, bulk change.es 00001/00001/00362d D 2.9 90/03/22 12:35:47 takeshi 12 11c Get correct value from *LeastMDSPage_wordes 00063/00053/00300d D 2.8 89/12/28 15:28:21 sybalsky 11 10c es 00004/00004/00349d D 2.7 89/03/28 01:46:28 sybalsky 10 9c word-pointer fixes for 386es 00045/00045/00308d D 2.6 88/12/23 14:08:12 shih 9 8c wrong sccs id, cleanupes 00003/00003/00350d D 2.5 88/11/08 13:13:04 bane 8 7c Commented out blatantly bougs break; statementes 00004/00002/00349d D 2.4 88/07/20 14:57:04 shimizu 7 6c make printf to DEBUGes 00002/00000/00349d D 2.3 88/06/30 11:02:01 greep 6 5c put "#ifdef DEBUG" around printfses 00011/00004/00338d D 2.2 88/05/26 17:48:40 shimizu 5 4c Using error insted of printf; ADDREF in set_storage_statees 00000/00000/00342d D 2.1 88/05/17 09:26:45 hayata 4 3c Version up to 2.1es 00032/00003/00310d D 1.3 88/05/10 13:50:50 masinter 3 2c Ensure that fptovp is contiguous on the file; allocate space for ites 00002/00002/00311d D 1.2 88/03/13 15:07:05 hayata 2 1c Add SCCS key id (%Z%)es 00313/00000/00000d D 1.1 88/02/24 16:58:31 hayata 1 0c date and time created 88/02/24 16:58:31 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 8/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */D 3static char *id = "%Z% %M%	%I% %G%";E 3I 3static char *id = "%Z% %M%    %I% %G%";E 8I 8D 9/* This is G-file @(#) storage.c Version 2.4 (7/20/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) storage.c    2.4 7/20/88";E 9I 9D 15/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 15I 15/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 15I 11I 18E 18D 14E 14/************************************************************************//*									*/D 18/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 18I 18/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 18/*									*/D 18/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 18I 18/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 18/*									*//************************************************************************/E 11E 9E 8E 3E 2D 18/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 9 *	Auther	:	Takeshi Shimizu	E 9I 9 *	Author	:	Takeshi ShimizuE 9 */E 18/*****************************************************************//*		File Name :	storage.cD 9		Including	:	E 9I 9D 18		Including	:E 18E 9D 18		Created	:	Oct. 7, 1987 Takeshi ShimizuD 9		Changed :	E 9I 9		Changed :E 9E 18*//*****************************************************************/D 13#include "machineconfig.h"E 13I 13D 17#include "hdw_config.h"E 17I 17#include "hdw_conf.h"E 17E 13#include "lispemul.h"#include "address.h"D 17#include "address68k.h"E 17I 17#include "adr68k.h"E 17#include "lispmap.h"#include "stack.h"D 17#include "lispglobal.h"E 17I 17#include "lspglob.h"E 17#include "cell.h"D 17#include "lisptypes.h"E 17I 17#include "lsptypes.h"E 17#include "ifpage.h"I 5#include "gc.h"E 5#define MINARRAYBLOCKSIZE	4#define GUARDVMEMFULL		500#define IFPVALID_KEY		5603I 18#ifdef BIGVM#define GETFPTOVP(b,o) b[o]#define GETPAGEOK(b,o) (b[o]>>16)#else#define GETFPTOVP GETBASEWORD#define GETPAGEOK GETBASEWORD#endif /* BIGVME 18/*****************************************************************//*		Func Name :	checkfor_storagefull(npages)		Created	:	Oct. 7, 1987 Takeshi Shimizu		Changed :	Oct. 12,1987 take*//*****************************************************************/checkfor_storagefull(npages)register  DLword npages;D 18{ register int pagesleft; register INTSTAT *int_state;E 18I 18  {    register int pagesleft;    register INTSTAT *int_state;#ifdef BIGVM    pagesleft = (*Next_MDSpage_word ) -		(*Next_Array_word) - PAGESPER_MDSUNIT ;#else    pagesleft = (*Next_MDSpage_word & 0xffff) -		(*Next_Array_word & 0xffff) - PAGESPER_MDSUNIT ;#endifE 18D 18 pagesleft = (*Next_MDSpage_word & 0xffff) - (*Next_Array_word & 0xffff) - PAGESPER_MDSUNIT ;E 18I 18    if((pagesleft < GUARDSTORAGEFULL) || (npages !=0))      {	if (*STORAGEFULLSTATE_word == NIL) set_storage_state();E 18D 9 E 9I 9E 9D 18 if((pagesleft < GUARDSTORAGEFULL) || (npages !=0)) {	if (*STORAGEFULLSTATE_word == NIL)	     set_storage_state();E 18	switch(*STORAGEFULLSTATE_word & 0xffff)	 {D 18	    case SFS_NOTSWITCHABLE :D 5	    case SFS_FULLYSWITCHED : if(pagesleft <0)					error("MPERROR:Storage completly full");E 5I 5	    case SFS_FULLYSWITCHED : if(pagesleft <0) {					while(T){						error("MP9320:Storage completly full");					}				     }E 5				     else if ((pagesleft<=GUARD1STORAGEFULL)						 && (*STORAGEFULL_word !=NIL))					   {						*STORAGEFULL_word = S_POSITIVE;D 5						printf("STORAGE NEARLY FULL !!!!\n");E 5I 5						error("MP9325:Space getting VERY full.\							Please save and reload a.s.a.p.");E 5					   }					  else if (*STORAGEFULL_word == NIL)						{						  *STORAGEFULL_word=ATOM_T;						  int_state=(INTSTAT *)Addr68k_from_LADDR(*INTERRUPTSTATE_word);						  int_state->storagefull=T;						  *PENDINGINTERRUPT_word =ATOM_T;						}E 18I 18	   case SFS_NOTSWITCHABLE :	   case SFS_FULLYSWITCHED :	     if(pagesleft <0)	       {		 while(T)		   {		     error("MP9320:Storage completly full");		   }		}	    else if ((pagesleft<=GUARD1STORAGEFULL)			 && (*STORAGEFULL_word !=NIL))	       {		*STORAGEFULL_word = S_POSITIVE;		error("MP9325:Space getting VERY full.\		Please save and reload a.s.a.p.");	       }	   else if (*STORAGEFULL_word == NIL)	      {		*STORAGEFULL_word=ATOM_T;		int_state=(INTSTAT *)Addr68k_from_LADDR(*INTERRUPTSTATE_word);		int_state->storagefull=T;		*PENDINGINTERRUPT_word =ATOM_T;	      }E 18I 6#ifdef  DEBUGE 6D 9												  			     printf("\n checkfor_storagefull:DORECLAIM.....\n");E 9I 9D 18															     printf("\n checkfor_storagefull:DORECLAIM.....\n");E 18I 18	    printf("\n checkfor_storagefull:DORECLAIM.....\n");E 18E 9I 6#endifE 6D 18				     return(NIL);E 18I 18	    return(NIL);E 18D 18				     break;E 18I 18	  break;E 18D 18	    case SFS_SWITCHABLE    : if(npages==NIL)				      {					if(pagesleft <= 0)					 {						*LeastMDSPage_word= *Next_Array_word;						*Next_MDSpage_word= *SecondMDSPage_word;						advance_storagestate(SFS_FULLYSWITCHED);						return(advance_array_seg((*SecondArrayPage_word) & 0xffff));					 }				      }				     else if (npages > pagesleft)					   {						/* Have to switch array space over,						  but leave MDS to fill the rest of the low pages   */						*LeastMDSPage_word= *Next_Array_word;						advance_storagestate(SFS_ARRAYSWITCHED);						return(advance_array_seg((*SecondArrayPage_word) & 0xffff));					   }				     break ;	    case SFS_ARRAYSWITCHED : if((*Next_MDSpage_word & 0xffff) <E 18I 18	    case SFS_SWITCHABLE :	      if(npages==NIL)		{		  if(pagesleft <= 0)		    {		      *LeastMDSPage_word= *Next_Array_word;		      *Next_MDSpage_word= *SecondMDSPage_word;		      advance_storagestate(SFS_FULLYSWITCHED);		      return(advance_array_seg((*SecondArrayPage_word)));		    }		}	      else if (npages > pagesleft)		{		  /* Have to switch array space over,		    but leave MDS to fill the rest of the low pages   */		  *LeastMDSPage_word= *Next_Array_word;		  advance_storagestate(SFS_ARRAYSWITCHED);		  return(advance_array_seg((*SecondArrayPage_word)));		}	    break ;#ifdef BIGVM	  case SFS_ARRAYSWITCHED : if((*Next_MDSpage_word) <					 (*LeastMDSPage_word))#else	  case SFS_ARRAYSWITCHED : if((*Next_MDSpage_word & 0xffff) <E 18					 (*LeastMDSPage_word & 0xffff))I 18#endifE 18				      {					*Next_MDSpage_word= *SecondMDSPage_word;					return(advance_storagestate							(SFS_FULLYSWITCHED));				      }				     else if (npages != NIL)					     if((npages + GUARDSTORAGEFULL) >=I 18#ifdef BIGVM						  ((*SecondMDSPage_word)-						    (*Next_Array_word)))#elseE 18						  ((*SecondMDSPage_word & 0xffff)-						    (*Next_Array_word & 0xffff)))I 18#endifE 18							return(NIL);				     return(T);D 8				     break;E 8I 8				  /* break; */E 8	   default :		     error("checkfor_storagefull: Shouldn't <%d>",(*STORAGEFULLSTATE_word) & 0xffff);				     break;	 } } else	return(NIL);}/* checkfor_storagefull end *//*****************************************************************//*		Func Name :	advance_array_seg(nxtpage)		Created	:	Oct. 7, 1987 Takeshi ShimizuD 9		Changed :	E 9I 9		Changed :E 9*//*****************************************************************/advance_array_seg(nxtpage) register DLword nxtpage; /* rare page num */{ DLword ncellsleft; LispPTR mergebackward(); LispPTR makefreearrayblock();D 9  /* Called when 8Mb are exhausted,and we want to switch array space E 9I 9  /* Called when 8Mb are exhausted,and we want to switch array spaceE 9   into the extended area(Secondary space),starting with nextpage.   We MUST clean up old area first.   */I 18#ifdef BIGVM#else	nxtpage &= 0xFFFF;	/* for old VM size, limit is 16 bits of page */#endifE 18D 9 ncellsleft = 	(*Next_Array_word -  POINTER_PAGE(*ArrayFrLst_word) -1)* CELLSPER_PAGE E 9I 9 ncellsleft =	(*Next_Array_word -  POINTER_PAGE(*ArrayFrLst_word) -1)* CELLSPER_PAGEE 9	+ (CELLSPER_PAGE -  (((*ArrayFrLst_word) & 0xff) >> 1) ); if(ncellsleft >= MINARRAYBLOCKSIZE)  {	mergebackward(makefreearrayblock(*ArrayFrLst_word , ncellsleft));I 18#ifdef BIGVM	*ArrayFrLst2_word = (((*LeastMDSPage_word) ) << 8);#elseE 18D 12	*ArrayFrLst2_word = (*LeastMDSPage_word << 8);E 12I 12	*ArrayFrLst2_word = (((*LeastMDSPage_word) & 0xffff) << 8);I 18#endifE 18E 12  }else  {	*ArrayFrLst2_word = *ArrayFrLst_word;  }D 18E 18I 18#ifdef BIGVM *Next_Array_word =  nxtpage ;#elseE 18 *Next_Array_word = S_POSITIVE | nxtpage ;I 18#endifE 18 *ArrayFrLst_word = nxtpage << 8 ; *ArraySpace2_word = *ArrayFrLst_word; return(S_POSITIVE);} /* advance_array_seg end *//*****************************************************************//*		Func Name :	advance_storagestate(flg)		Created	:	Oct. 7, 1987 Takeshi ShimizuD 9		Changed :	E 9I 9		Changed :E 9*//*****************************************************************/advance_storagestate(flg) DLword flg;{ LispPTR dremove();D 7 /****DEBUG ***/  print("STORAGEFULLSTATE is now set to %d \n",flg);E 7I 7D 9#ifdef DEBUG E 9I 9#ifdef DEBUGE 9  printf("STORAGEFULLSTATE is now set to %d \n",flg);#endifE 7 *STORAGEFULLSTATE_word = (S_POSITIVE | flg ); InterfacePage->fullspaceused = 65535 ; *SYSTEMCACHEVARS_word = dremove(STORAGEFULLSTATE_index, *SYSTEMCACHEVARS_word);}/*****************************************************************//*		Func Name :	set_storage_state()		Created	:	Oct. 7, 1987 Takeshi ShimizuD 9		Changed :	E 9I 9		Changed :E 9*//*****************************************************************/set_storage_state(){ LispPTR cons(); if((*MACHINETYPE_word & 0xffff)== KATANA)  {	if(InterfacePage->dl24bitaddressable !=0)		*STORAGEFULLSTATE_word = S_POSITIVE | SFS_SWITCHABLE ;	else		*STORAGEFULLSTATE_word = S_POSITIVE | SFS_NOTSWITCHABLE ;	*SYSTEMCACHEVARS_word = cons(STORAGEFULLSTATE_index, *SYSTEMCACHEVARS_word);D 5	/**DEBUG **/E 5I 5D 15	 GCLOOKUP(0x8000,ADDREF ,*SYSTEMCACHEVARS_word );E 15I 15	 GCLOOKUP(*SYSTEMCACHEVARS_word, ADDREF);E 15D 9#ifdef DEBUG E 9I 9#ifdef DEBUGE 9E 5	printf("SETSTATE: set to %d \n",(*STORAGEFULLSTATE_word)& 0xffff);I 5#endifE 5  } else  {	error("set_storage_state: Sorry! We can work on only KATANA");  }D 9 E 9I 9E 9} /* set_storage_state() end */LispPTR dremove(x,l)LispPTR x,l;{ LispPTR z; if( Listp(l)==NIL) return(NIL); else if (x == car(l))	  {		if(cdr(l)!=NIL)		 {			rplaca(l,car(cdr(l)));			rplacd(l,cdr(cdr(l)));			return(dremove(x,l));		 }	  }	 else	  {			z=l;		lp:	if(Listp(cdr(l)) ==NIL)				return(z);			else if(x==car(cdr(l)))				   rplacd(l , cdr(cdr(l)));				else				   l=cdr(l);			goto lp;	  }}/*****************************************************************//*		Func Name :	newpage(addr)		Created	:	Oct. 12, 1987 Takeshi Shimizu		Changed :	Oct. 13, 1987 take				OCt. 20, 1987 take*//*****************************************************************/LispPTR newpage(base)D 9LispPTR base ; E 9I 9D 11LispPTR base ;E 9{D 9 register DLword vp; E 9I 9 register DLword vp;E 9 register INTSTAT *int_state;E 11I 11  LispPTR base;  {    register DLword vp;    register INTSTAT *int_state;E 11D 11 extern DLword *FPtoVP; extern LispPTR *LASTVMEMFILEPAGE_word; extern LispPTR *VMEM_FULL_STATE_word;I 3 unsigned int nactive;E 3 vp=base >>8;E 11I 11D 18    extern DLword *FPtoVP;E 18    extern LispPTR *LASTVMEMFILEPAGE_word;    extern LispPTR *VMEM_FULL_STATE_word;    unsigned int nactive;   vp=base >>8;E 11#ifdef DEBUGD 11/************************/if(vp == 0) error ("newpage: vp=0");printf("***newpage modify vmemsize %d ",InterfacePage->nactivepages);/*************************/E 11I 11    /************************/    if(vp == 0) error ("newpage: vp=0");    printf("***newpage modify vmemsize %d ",InterfacePage->nactivepages);    /*************************/E 11#endifD 3 *(FPtoVP + (++(InterfacePage->nactivepages))) = vp ;E 3I 3D 11 nactive = ++(InterfacePage->nactivepages);D 9 if ((nactive & 0xff) == 0)  	{ /* need to add virtual page for fptovp first */E 9I 9 if ((nactive & 0xff) == 0)	{ /* need to add virtual page for fptovp first */E 9	  unsigned int vp_of_fp, fp_of_fptovp;E 11I 11    nactive = ++(InterfacePage->nactivepages);D 18    if ((nactive & 0xff) == 0)E 18I 18	/* if nactive is a multiple of the # of FPTOVP entries */	/* on a page, we need to create a new FPTOVP page.     */#ifdef BIGVM    if ((nactive & 127) == 0)	/* in BIGVM, they're cells */#else    if ((nactive & 0xff) == 0)	/* in old way, they're words */#endif /* BIGVM */E 18      { /* need to add virtual page for fptovp first */	unsigned int vp_of_fp, fp_of_fptovp;E 11D 9	  E 9I 9E 9D 11	  /* compute virtual page of new FPtoVP table page */D 9 	  vp_of_fp = (LADDR_from_68k(FPtoVP+nactive) >> 8); 	   	  /* compute file page where this entry has to be to ensure 	    that FPtoVP is contiguous on the file */ 	     	  fp_of_fptovp = InterfacePage->fptovpstart + 	  	 (vp_of_fp - (LADDR_from_68k(FPtoVP) >> 8)); 	  	  	  /* debugging check: make sure FPtoVP is contiguous */ 	   	  if (*(FPtoVP + fp_of_fptovp - 1) != vp_of_fp -1 ) 	  	{printf ("FPtoVP not contiguous\n");} 	  	 	  /* move the file page for the previous VMEM page */ 	  *(FPtoVP + nactive) = *(FPtoVP + fp_of_fptovp); 	   	  /* now, store virtual page of FPtoVP in FPtoVP table */ 	   	  *(FPtoVP + fp_of_fptovp) = (vp_of_fp); 	   	  /* now we can make room for the new page we're adding */ 	  nactive = ++(InterfacePage->nactivepages); 	}E 9I 9	  vp_of_fp = (LADDR_from_68k(FPtoVP+nactive) >> 8);E 11I 11	/* compute virtual page of new FPtoVP table page */I 18	/* i.e., the vp that holds the next FPtoVP entry */E 18	vp_of_fp = (LADDR_from_68k(FPtoVP+nactive) >> 8);E 11D 11	  /* compute file page where this entry has to be to ensure	    that FPtoVP is contiguous on the file */E 11I 11	/* compute file page where this entry has to be to ensure	   that FPtoVP is contiguous on the file */E 11D 11	  fp_of_fptovp = InterfacePage->fptovpstart +E 11I 11	fp_of_fptovp = InterfacePage->fptovpstart +E 11		 (vp_of_fp - (LADDR_from_68k(FPtoVP) >> 8));D 11	  /* debugging check: make sure FPtoVP is contiguous */E 11I 11	/* debugging check: make sure FPtoVP is contiguous */E 11D 10	  if (*(FPtoVP + fp_of_fptovp - 1) != vp_of_fp -1 )E 10I 10D 11	  if (GETWORD(FPtoVP + fp_of_fptovp - 1) != vp_of_fp -1 )E 11I 11D 18	if (GETWORD(FPtoVP + fp_of_fptovp - 1) != vp_of_fp -1 )E 11E 10		{printf ("FPtoVP not contiguous\n");}E 18I 18	if (GETFPTOVP(FPtoVP, fp_of_fptovp - 1) != vp_of_fp -1 )	  {	    printf ("FPtoVP not contiguous\n");	    printf("vp_of_fp = 0x%x, fp = 0x%x\n", vp_of_fp, fp_of_fptovp);	    printf("FPTOVP(fp-1) = 0x%x.\n", GETFPTOVP(FPtoVP,fp_of_fptovp-1));	  }E 18D 11	  /* move the file page for the previous VMEM page */D 10	  *(FPtoVP + nactive) = *(FPtoVP + fp_of_fptovp);E 10I 10	  GETWORD(FPtoVP + nactive) = GETWORD(FPtoVP + fp_of_fptovp);E 11I 11	/* move the file page for the previous VMEM page */D 18	GETWORD(FPtoVP + nactive) = GETWORD(FPtoVP + fp_of_fptovp);E 18I 18	GETFPTOVP(FPtoVP, nactive) = GETFPTOVP(FPtoVP, fp_of_fptovp);E 18E 11E 10D 11	  /* now, store virtual page of FPtoVP in FPtoVP table */E 11I 11	/* now, store virtual page of FPtoVP in FPtoVP table */E 11D 10	  *(FPtoVP + fp_of_fptovp) = (vp_of_fp);E 10I 10D 11	  GETWORD(FPtoVP + fp_of_fptovp) = (vp_of_fp);E 11I 11D 18	GETWORD(FPtoVP + fp_of_fptovp) = (vp_of_fp);E 18I 18	GETFPTOVP(FPtoVP, fp_of_fptovp) = (vp_of_fp);E 18E 11E 10D 11	  /* now we can make room for the new page we're adding */	  nactive = ++(InterfacePage->nactivepages);	}E 9D 10 *(FPtoVP + nactive) = vp ;E 10I 10 GETWORD(FPtoVP + nactive) = vp ;E 11I 11	/* now we can make room for the new page we're adding */	nactive = ++(InterfacePage->nactivepages);      }D 18    GETWORD(FPtoVP + nactive) = vp ;E 18I 18    GETFPTOVP(FPtoVP, nactive) = vp ;E 18E 11E 10E 3#ifdef DEBUGD 11/*************************/printf("to %d  with VP:%d \n",InterfacePage->nactivepages,vp);/************************/E 11I 11    /*************************/    printf("to %d  with VP:%d \n",InterfacePage->nactivepages,vp);    /************************/E 11#endifD 9 if(InterfacePage->nactivepages > E 9I 9D 11 if(InterfacePage->nactivepages >E 11I 11    if(InterfacePage->nactivepages >I 18#ifdef BIGVM	( ((*LASTVMEMFILEPAGE_word)) - GUARDVMEMFULL ) )#elseE 18E 11E 9	( ((*LASTVMEMFILEPAGE_word) & 0xffff) - GUARDVMEMFULL ) )I 18#endifE 18D 11  {E 11I 11      {E 11	/* set vmemfull state */	if(*VMEM_FULL_STATE_word ==NIL)D 11	 {		int_state=(INTSTAT *)Addr68k_from_LADDR(*INTERRUPTSTATE_word);		int_state->vmemfull=T;		*PENDINGINTERRUPT_word =ATOM_T;	 }E 11I 11	  {	    int_state=(INTSTAT *)Addr68k_from_LADDR(*INTERRUPTSTATE_word);	    int_state->vmemfull=T;	   *PENDINGINTERRUPT_word =ATOM_T;	  }I 18#ifdef BIGVM	if(InterfacePage->nactivepages < ((*LASTVMEMFILEPAGE_word) ))#elseE 18E 11	if(InterfacePage->nactivepages < ((*LASTVMEMFILEPAGE_word) & 0xffff))I 18#endifE 18D 11	 {		*VMEM_FULL_STATE_word =S_POSITIVE ; /* set 0 */	 }E 11I 11	  {	    *VMEM_FULL_STATE_word =S_POSITIVE ; /* set 0 */	  }E 11	else if(InterfacePage->key == IFPVALID_KEY)D 11	 {		*VMEM_FULL_STATE_word = ATOM_T;	 }	else		*VMEM_FULL_STATE_word = make_atom("DIRTY",0,5,0);  }E 11I 11	  {	    *VMEM_FULL_STATE_word = ATOM_T;	  }	else *VMEM_FULL_STATE_word = make_atom("DIRTY",0,5,0);      }E 11D 11 return(base);E 11I 11    return(base);E 11D 11} /* newpage */E 11I 11  } /* newpage */I 14D 16/** CHANGES FOR NEW SOTRAGE **/E 16I 16/** CHANGES FOR NEW STORAGE **/E 16/*****************************************************************//*		Func Name :	init_storage()		Description:				Set values which are referenced by 				Lisp Storage handling funcs 		Created	:	Apr-23 1990 Takeshi Shimizu		Changed :	*//*****************************************************************/init_storage(){/*LispPTR *ArraySpace2_word;*/I 18#ifdef BIGVM*SecondMDSPage_word = ( InterfacePage->dllastvmempage		- PAGESPER_MDSUNIT -1);#elseE 18*SecondMDSPage_word = S_POSITIVE |( InterfacePage->dllastvmempage		- PAGESPER_MDSUNIT -1);D 18E 18I 18#endifE 18} /* init_storage *//** CHANGES FOR NEW SOTRAGE  END **/E 14E 11E 1