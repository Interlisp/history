h32106s 00006/00004/00104d D 2.4 90/06/15 16:57:42 mitani 6 5c GCLOOKUPes 00000/00000/00108d D 2.3 90/04/20 01:36:05 sybalsky 5 4c AIX:  shortening file names, bulk change.es 00000/00000/00108d D 2.2 89/03/30 13:16:30 sybalsky 4 3c word pointers.es 00000/00000/00108d D 2.1 88/05/17 09:24:31 hayata 3 2c Version up to 2.1es 00002/00002/00106d D 1.2 88/03/13 14:49:01 hayata 2 1c Add SCCS key id (%Z%)es 00108/00000/00000d D 1.1 88/02/24 16:57:08 hayata 1 0c date and time created 88/02/24 16:57:08 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 6/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 6I 6/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 6E 2/*************************************************************************//*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 *//*************************************************************************//*                                                                       *//*                       File Name : gchoverflow.c                       *//*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : July-8-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions : gc_handleoverflow(arg);                         *//*                       gcmaptable(arg);                                *//*                                                                       *//*************************************************************************//*           Descreption :                                               *//*                                                                       *//*************************************************************************//*                                                               \Tomtom *//*************************************************************************/#include "lispemul.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "gc.h"#define MAXSMALLP		65535#define HTBIGENTRYSIZE		4#define WORDSPERPAGE		256#define MAXTYPENUMBER		INIT_TYPENUM#define GetSegnuminColl(entry1) ((entry1 & 0x01fe) >> 1)#define GetCountinColl(entry1)  ((entry1 & 0x0fc00) >> 10)#define GetStkCnt(entry1)		 ((entry1 & 0x0fe00) >> 9)#define Oddp(num) (((num % 2) != 0)?1:0)#define Evenp(num,prim) (((num % prim) == 0)?1:0)#define Increment_Allocation_Count(n)			\    if (*Reclaim_cnt_word != NIL) 			\		if (*Reclaim_cnt_word > n)		\			(*Reclaim_cnt_word) -= n;	\		else { *Reclaim_cnt_word = NIL; 	\			  doreclaim();  		\			};				\gc_handleoverflow(arg)DLword	arg;   { struct htoverflow  *cell;     struct dtd	        *ptr;     DLword		cellcnt;     LispPTR            addr;	  cell = (struct htoverflow *)HToverflow;			/* This proc. protected from interrupt */	while((addr = cell->ptr) != NIL)D 6	   { htfind(addr, cell->pcase);E 6I 6	   {		REC_GCLOOKUP(addr, cell->pcase);E 6		cell->ptr = 0;		cell->pcase = 0;		++cell; /* (\ADDBASE CELL WORDSPERCELL) */	   };	ptr = (struct dtd *)GetDTD(TYPE_LISTP);		/* same as "extern struct dtd *ListpDTD" */	if ((cellcnt = ptr->dtd_cnt0) > 1024)	   { Increment_Allocation_Count(cellcnt);		ptr->dtd_oldcnt += cellcnt;		ptr->dtd_cnt0 = 0;	   };	return(arg);   }gcmaptable(arg)DLword	arg;   { struct htoverflow	*cell;	struct dtd	*ptr;	DLword		cellcnt;	int		typnum;	LispPTR		addr;				cell = (struct htoverflow *)HToverflow;				/* This proc. protected from interrupt */	while((addr = cell->ptr) != NIL)D 6	   { htfind(addr, cell->pcase);E 6I 6	   {		REC_GCLOOKUP(addr, cell->pcase);E 6		cell->ptr = 0;		cell->pcase = 0;		++cell; /* (\ADDBASE CELL WORDSPERCELL) */	   };	for(typnum = 1; typnum <= *MaxTypeNumber_word; ++typnum)	   /* applied alltype */	   { ptr = (struct dtd *)GetDTD(typnum);		if ((cellcnt = ptr->dtd_cnt0) != 0)		   { ptr->dtd_oldcnt += cellcnt;		     ptr->dtd_cnt0 = 0;		     Increment_Allocation_Count(cellcnt);		   };	   };	return(arg);   }E 1