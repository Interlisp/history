h17332s 00026/00011/00133d D 1.4 92/03/04 18:49:17 sybalsky 4 3c 386es 00075/00010/00069d D 1.3 91/10/15 22:52:29 sybalsky 3 2c ISC changeses 00011/00000/00068d D 1.2 90/06/04 10:37:10 sybalsky 2 1c reformat, copyrightes 00068/00000/00000d D 1.1 90/04/19 23:22:07 sybalsky 1 0c date and time created 90/04/19 23:22:07 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */D 3/* This is G-file @(#) fast_dispatch.h Version 2.6 (10/19/88). copyright Xerox & Fuji Xerox  *//* 	fast_dispatch.h *//* 	Bob Krivacic 3/2/88 */E 3D 3E 3/* 	These are the Macros Used to generate fast dispatch inline code. */I 3/************************************************************************//*									*//*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************/E 3I 2/************************************************************************//*									*/D 3/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 3I 3/*	  F A S T   O P C O D E   D I S P A T C H   M A C R O S		*/E 3/*									*/D 3/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 3I 3/*	These macros generate better opcode-dispatch code than the	*//*	native compiler will.  The difference may be only one or	*//*	two instructions, but in the inner loop, that's a LOT.		*/E 3/*									*/I 3/*	To add a new architecture, you must define 5 macros:		*//*									*//*		nextop0 - for single-byte opcodes			*//*		nextop1 - skip a byte and grab an opcode		*//*		nextop2 - skip 2 bytes and grab an opcode		*//*		nextop3 - skip 3 bytes and grab an opcode		*//*		nextop4 - skip 4 bytes and grab an opcode		*//*									*//*	(These macros are already defined naively, so undef them.)	*//*									*//*	For existing implementations, these often expand out to		*//*	calls to inline functions.					*//*									*//*									*//*									*/E 3/************************************************************************/I 3#ifdef OPDISP	/* Only do any of this if OPDISP is set. */E 3E 2D 3#ifdef OPDISPE 3I 3	/* Sun 3 */E 3#ifdef mc68020#undef nextop0#undef nextop1#undef nextop2#undef nextop3#undef nextop4/* JRB - fast case is now nextop1 */#define nextop0 { fast0_dispatcher(); goto nextopcode; }#define nextop1 { fast1_dispatcher(); goto nextopcode; }#define nextop2 { fast1_dispatcher2(); }#define nextop3 { PCMACL += 2; nextop1; }#define nextop4 { PCMACL += 3; nextop1; }#endifI 3	/* Sun 386i */E 3#ifdef I386#undef nextop0#undef nextop1#undef nextop2#undef nextop3#undef nextop4/* JRB - fast case is now nextop1 */#define nextop0 { fast0_dispatcher(); goto nextopcode; }#define nextop1 { fast1_dispatcher(); goto nextopcode; }#define nextop2 { fast2_dispatcher(); }#define nextop3 { PCMACL += 2; nextop1; }#define nextop4 { PCMACL += 3; nextop1; }#endifI 3	/* ISC 386 using gcc */#ifdef ISC#undef nextop0#undef nextop1#undef nextop2#undef nextop3#undef nextop4#define nextop0 { fast0_dispatcher(); goto nextopcode; }#define nextop1 { fast1_dispatcher(); goto nextopcode; }D 4#define nextop2 { fast2_dispatcher(); }#define nextop3 { PCMACL += 2; nextop1; }#define nextop4 { PCMACL += 3; nextop1; }E 4I 4#define nextop2 { fast2_dispatcher(); goto nextopcode;}#define nextop3 { fast3_dispatcher(); goto nextopcode;}#define nextop4 { fast4_dispatcher(); goto nextopcode;}E 4D 4#define fast0_dispatcher () \    asm("						\n\E 4I 4#define fast0_dispatcher() \    asm volatile("						\n\E 4	leal	-1(%0),%%eax					\n\	xorb	$3,%%al						\n\	movzbl	(%%eax),%%eax					\n\	jmp	*optable(,%%eax,4)" : : "r" (pccache): "ax");D 4#define fast1_dispatcher () \    asm("						\n\E 4I 4#define fast1_dispatcher() \    asm volatile("						\n\E 4	movl	%0,%%eax					\n\	xorb	$3,%%al						\n\	incl	%0						\n\	movzbl	(%%eax),%%eax					\n\D 4	jmp	*optable(,%%eax,4)" : "r" (pccache) : "0" (pccache): "ax");E 4I 4	jmp	*optable(,%%eax,4)" : "=r" (pccache) : "0" (pccache): "ax");E 4D 4#define fast2_dispatcher () \    asm("						\n\E 4I 4#define fast2_dispatcher() \    asm volatile("						\n\E 4	leal	1(%0),%%eax					\n\	addl	$2,%0						\n\	xorb	$3,%%al						\n\	movzbl	(%%eax),%%eax					\n\D 4	jmp	*optable(,%%eax,4)" :"r" (pccache) : "0" (pccache): "ax");E 4I 4	jmp	*optable(,%%eax,4)" :"=r" (pccache) : "0" (pccache): "ax");#define fast3_dispatcher() \    asm volatile("						\n\	leal	2(%0),%%eax					\n\	addl	$3,%0						\n\	xorb	$3,%%al						\n\	movzbl	(%%eax),%%eax					\n\	jmp	*optable(,%%eax,4)" :"=r" (pccache) : "0" (pccache): "ax");#define fast4_dispatcher() \    asm volatile("						\n\	leal	3(%0),%%eax					\n\	addl	$4,%0						\n\	xorb	$3,%%al						\n\	movzbl	(%%eax),%%eax					\n\	jmp	*optable(,%%eax,4)" :"=r" (pccache) : "0" (pccache): "ax");E 4	E 3#endifI 3#endif OPDISPE 3I 3E 3#ifdef SPARCDISP#undef nextop0#undef nextop1#undef nextop2#undef nextop3#undef nextop4#define nextop0 { fast_dispatcher(table, Get_BYTE(PCMAC)); goto nextopcode; }#define nextop_n(n) {							\	PCMACL += n;							\	nextop0; 							\}#define nextop1 { nextop_n(1); }#define nextop2 { nextop_n(2); }#define nextop3 { nextop_n(3); }#define nextop4 { nextop_n(4); }D 3#endifE 3I 3#endif SPARCDISPE 3E 1