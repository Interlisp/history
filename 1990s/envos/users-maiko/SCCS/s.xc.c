h05017s 00033/00016/01437d D 1.33 93/02/08 15:01:30 sybalsky 33 32c Big VM (and new CDR coding) changes for 3.0 \nes 00004/00004/01449d D 1.32 92/07/24 10:47:45 sybalsky 32 31c retrofit of SGI & DEC OSF1 changes \nes 00032/00035/01421d D 1.31 92/06/26 13:51:30 sybalsky 31 30c retrofit of 386 unix changes \nes 00014/00014/01442d D 1.30 92/04/21 17:29:25 sybalsky 30 29c shortening file names for DOS \nes 00299/00004/01157d D 1.29 92/01/16 12:37:54 sybalsky 29 28c 386es 00011/00001/01150d D 1.28 91/10/15 18:28:48 sybalsky 28 27c ISC changeses 00000/00000/01151d D 1.27 91/05/20 09:36:10 sybalsky 27 26c ??es 00006/00000/01145d D 1.26 91/04/16 17:36:20 sybalsky 26 25c Retrofit foreign-OS changes from Savoir.es 00000/00003/01145d D 1.25 91/02/04 12:56:06 sybalsky 25 24c 3-byte-atom fixeses 00030/00001/01118d D 1.24 91/01/24 11:11:32 sybalsky 24 23c 3-byte atom changes, add PCTRACE trace-table option.es 00009/00009/01110d D 1.23 90/09/18 23:50:22 sybalsky 23 22c Retrofit changes from AIX, DEC3100, PS/2es 00006/00006/01113d D 1.22 90/08/30 10:32:13 sybalsky 22 21c fixing interruptcodees 00008/00009/01111d D 1.21 90/07/22 11:36:48 sybalsky 21 20c Change to use FNTRACE, OPTRACE for tracing fn calls, opcode execs, resp.es 00017/00008/01103d D 1.20 90/07/12 16:10:49 sybalsky 20 19c Change to 3-byte atoms under 3BYTEATOMS flages 00027/00003/01084d D 1.19 90/07/04 04:06:32 sybalsky 19 18c Interrupt change:  Count ether interrupts down as we interrupt lisp (but avoid interrupting if it's being handled already!)es 00001/00001/01086d D 1.18 90/04/20 02:09:17 sybalsky 18 17c AIX:  shortening file names, bulk change.es 00022/00007/01065d D 1.17 90/04/19 22:50:11 sybalsky 17 16c AIX include file names shortened.es 00001/00001/01071d D 1.16 90/04/18 11:37:20 sybalsky 16 15c Change tosfuncallmacro to tosfuncall.h for posizes 00000/00002/01072d D 1.15 90/04/17 17:05:48 sybalsky 15 14c 386i -- defeat the optimizer by having never-taken branches to error labels.es 00006/00004/01068d D 1.14 90/04/16 11:00:23 sybalsky 14 13c 386i speed changeses 00020/00000/01052d D 1.13 90/04/02 17:16:32 sybalsky 13 12c 386i arithmetic speedups (add fake branches to labels, so they don't get optimized away!!)es 00013/00000/01039d D 1.12 90/03/22 16:33:49 sybalsky 12 11c Add fast next-opcode fetch for 386ies 00044/00044/00995d D 1.11 90/03/22 10:43:19 sybalsky 11 10c More 386i dispatch speedupses 00001/00001/01038d D 1.10 90/03/19 18:10:07 sybalsky 10 9c changed the opcode trace to show abs PC rather than fn-relative.es 00004/00000/01035d D 1.9 90/03/13 18:56:49 sybalsky 9 8c Added 386i-specific inlinedefs #includees 00002/00002/01033d D 1.8 89/12/28 15:30:04 sybalsky 8 7c es 00003/00001/01032d D 1.7 89/10/19 18:03:02 sybalsky 7 6c MISC7 supportes 00001/00001/01032d D 1.6 89/03/30 13:15:02 sybalsky 6 5c fix byte-swapped refs to use GETWORD or GETBYTE.es 00010/00007/01023d D 1.5 89/03/27 10:16:14 sybalsky 5 4c Changed word-pointer refs to GETWORDes 00002/00002/01028d D 1.4 88/12/01 13:46:53 krivacic 4 3c Add SUN3_OS4_IL & SUN3_OS3_OR_OS4_IL Flags, and move asm labels to inlines.es 00001/00002/01029d D 1.3 88/11/29 13:30:39 shih 3 2c removed bogus sccs stampes 00002/00000/01029d D 1.2 88/11/22 13:16:23 shimizu 2 1c AR10951:slowreturn can notice stackoverflowes 01029/00000/00000d D 1.1 88/11/07 11:58:40 krivacic 1 0c date and time created 88/11/07 11:58:40 by krivaciceuUtTI 1D 3/* This is G-file %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 3I 3D 8/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 3static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 8I 8D 17/* @(#) xc.c Version 1.6 (3/30/89). copyright envos & Fuji Xerox  */static char *id = "@(#) xc.c	1.6 3/30/89		(envos & Fuji Xerox)";E 17I 17D 21/* @(#) xc.c Version 1.6 (3/30/89). copyright Venue & Fuji Xerox  */static char *id = "@(#) xc.c	1.6 3/30/89		(Venue & Fuji Xerox)";E 21I 21/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 21E 17E 8D 3/* This is G-file @(#) xc.c Version 2.21 (8/15/88). copyright Xerox & Fuji Xerox  */E 3I 17/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*/D 23/*	This file is work-product resulting from the Xerox/Venue	*/E 23I 23/*	This file was work-product resulting from the Xerox/Venue	*/E 23/*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/I 20/************************************************************************//*									*//*		  M A I N   D I S P A T C H   L O O P			*//*									*//*	This file contains the main dispatch loop for the emulator.	*//*									*//*									*//*									*//*									*//************************************************************************/E 20E 17#include <sys/types.h>#include <sys/time.h>#include <stdio.h>#include "lispemul.h"D 30#include "emulglobal.h"E 30I 30#include "emlglob.h"E 30#include "address.h"D 30#include "address68k.h"E 30I 30#include "adr68k.h"E 30#include "stack.h"I 5#include "dbprint.h"E 5D 30#include "lispglobal.h"#include "lisptypes.h"E 30I 30#include "lspglob.h"#include "lsptypes.h"E 30#include "lispmap.h"#include "cell.h"D 30#include "initatoms.h"E 30I 30#include "initatms.h"E 30#include "gc.h"#include "arith.h"#include "stream.h"#include "tos1defs.h" D 30#include "tosretmacro.h"D 16#include "tosfuncallmacro.h"E 16I 16#include "tosfuncall.h"E 30I 30#include "tosret.h"#include "tosfns.h"E 30E 16D 17#include "inlinedefsC.h"E 17I 17#include "inlineC.h"E 17D 4#ifdef SUN3_OS3_ILE 4I 4#ifdef SUN3_OS3_OR_OS4_ILE 4D 17#include "inlinedefs68K.h"E 17I 17D 30#include "inline68K.h"E 30I 30#include "inln68k.h"E 30E 17#ifdef UNSAFED 17#include "fastinlinedefs68K.h"E 17I 17D 30#include "fastinline68K.h"E 30I 30#include "fastinln68k.h"E 30E 17#endif#endifI 26D 31#ifdef AIXPS2E 31I 31#ifdef GCC386E 31D 30#include "inlinePS2.h"E 30I 30#include "inlnPS2.h"E 30D 31#endif AIXPS2I 28#ifdef ISCD 30#include "inlinePS2.h"E 30I 30#include "inlnPS2.h"E 30#endif ISCE 31I 31    register InstPtr pccache asm("si");	register LispPTR *cspcache asm("di");	register LispPTR tscache asm("bx");#endifE 31E 28E 26D 21#ifdef sparcE 21I 21	/* Used to just be ifdef sparc, but want to be able to turn */	/* off the inline code even on sparc machines.		    */#ifdef SPARCDISPE 21D 17#include "inlinedefsSPARC.h"E 17I 17D 30#include "inlineSPARC.h"E 30I 30#include "inlnSPARC.h"E 30E 17D 21#endifE 21I 21D 33#endif SPARCDISPE 33I 33#endif /* SPARCDISP */E 33E 21I 33E 33I 9#ifdef I386D 17#include "inlinedefs386i.h"E 17I 17D 30#include "inline386i.h"E 30I 30#include "inln386i.h"E 30E 17#endifE 9D 18#include "fast_dispatch.h"E 18I 18D 30#include "fast_disp.h"E 30I 30#include "fast_dsp.h"E 30E 18#include "profile.h"/* trick now is that pccache points one ahead... */#define PCMAC 		(pccache-1)#define PCMACL		pccache#define CSTKPTR  	((LispPTR *) cspcache)#define	PVAR		((LispPTR *) PVar)#define IVAR		((LispPTR *) IVar)#define BCE_CURRENTFX	((struct  frameex2 *)((DLword *) PVAR - FRAMESIZE))I 19#define CSTKPTRL	(cspcache)D 23#define PVARL		PVAR#define IVARL		IVARE 23I 23#define PVARL		PVar#define IVARL		IVarE 23E 19typedef struct conspage ConsPage;typedef ByteCode *InstPtr;extern DLword *createcell68k();I 29#ifndef ISCE 29#ifdef OPDISPInstPtr optable[512];D 29#endifE 29I 29D 33#endif OPDISP#endif ISCE 33I 33#endif /* OPDISP */E 33E 29I 33#endif /* ISC */E 33I 29I 33E 33E 29I 24#ifdef PCTRACE  /* For keeping a trace table (ring buffer) of 100 last PCs */int pc_table[100],	/* The PC */    op_table[100];	/* The opcode at that PC */LispPTR fn_table[100];	/* The code block the PC is in (Lisp ptr) */int pccounter = 0;	/* ring-buffer counter */D 33#endif PCTRACEE 33I 33#endif /* PCTRACE */E 33int dbgflag = 0;E 24int	extended_frame;		/*indicates if soft stack overflow */int n_mask_array[16] = {	1, 3, 7, 0xf, 			0x1f, 0x3f, 0x7f, 0xff,			0x1ff, 0x3ff, 0x7ff, 0xfff,			0x1fff, 0x3fff, 0x7fff, 0xffff};extern int TIMER_INTERVAL;dispatch(){I 29D 31#ifdef ISC    register InstPtr pccache asm("si");#elseE 31E 29	register InstPtr pccache;I 29D 31#endif ISCE 31E 29I 12#ifdef I386	InstPtr *table;#elseE 12#if defined(OPDISP) || defined(SPARCDISP)D 31  	register InstPtr *table;E 31I 31D 32#ifdef OSCE 32I 32#ifdef ISCE 32  InstPtr *table;#elseregister InstPtr *table;#endifE 31D 29#endifI 12#endifE 29I 29D 32#endif OPDISP#endif I386E 32I 32#endif /* OPDISP */#endif /* I386 */E 32#ifdef ISCD 31	register LispPTR *cspcache asm("di");	register LispPTR tscache asm("dx");E 31#elseE 29E 12	register LispPTR *cspcache;	register LispPTR tscache;I 29D 32#endif ISCE 32I 32#endif /* ISC */E 32E 29#ifdef sparc	register struct state *stateptrcache = MState;#undef MState#define MState stateptrcache#endifI 12D 31#ifdef I386E 31I 31#if (defined(I386) || defined(ISC))E 31	int SaveD6;#elseE 12#ifdef OPDISP	register int SaveD6;#endifI 12#endifE 12#ifdef UNSAFE	register int Save_D5_shift_amount;#endif/* OP_FN_COMMON arguments */    DefCell *fn_defcell;    LispPTR fn_atom_index;    int fn_opcode_size;    int fn_num_args;    int fn_apply;    LispPTR fn_loc_defcell;	RET; 	CLR_IRQ;I 29#ifndef ISCE 29#ifdef OPDISP	table = optable;#endifI 29D 33#endif ISCE 33I 33#endif /* ISC */E 33E 29I 33E 33#ifdef SPARCDISP	table = (InstPtr *) compute_dispatch_table();#endif#ifdef UNSAFE	Save_D5_shift_amount = 15;#endifI 12#ifdef I386	goto setup_table;#elseI 31#ifdef OPDISPE 31I 29#ifdef ISC	asm("	leal optable,%%eax \n\		movl %%eax,%0" : "=g" (table) : "0" (table));	goto nextopcode;#elseE 29E 12D 31#ifdef OPDISPE 31	SaveD6 = 0;	goto setup_table;I 31D 33#endif ISCE 33I 33#endif /* ISC */E 33E 31#else	goto nextopcode;D 31#endifI 12D 29#endifE 29I 29#endif ISCE 31I 31D 33#endif OPDISPE 31#endif I386E 33I 33#endif /* OPDISP */E 33E 29E 12I 33#endif /* I386 */E 33I 33E 33/* INLINE OPCODE FAIL ENTRY POINTS, CALL EXTERNAL ROUTINES HERE */	OPCODEFAIL;/* OPCODE FAIL ENTRY POINTS, CALL UFNS HERE */	UFN_CALLS;op_ufn:	D 31{ register UFN *entry68k;						D 11   entry68k = (UFN *)GetUFNEntry(Get_BYTE(PCMAC));			E 11I 11   entry68k = (UFN *)GetUFNEntry(Get_BYTE_PCMAC0);			E 31I 31{#ifdef ISC   UFN *entry68k;				#else   register UFN *entry68k;						#endif	entry68k = (UFN *)GetUFNEntry(Get_BYTE_PCMAC0);	E 31E 11   fn_num_args = entry68k->arg_num;					   fn_opcode_size = entry68k->byte_num+1;				   fn_atom_index = entry68k->atom_name;					I 33   if (fn_atom_index == 0x14e)	 printf("unk ufn\n.");E 33   fn_defcell = (DefCell *) GetDEFCELL68k(fn_atom_index);		   fn_apply = 2 + entry68k->byte_num; /* code for UFN entry */   goto op_fn_common;							};/* FUNCTION CALL TAIL ROUTINE */	OP_FN_COMMON;/* DISPATCH "LOOP" */nextopcode :D 5E 5I 5D 21#ifdef TRACED 6  printf("Dispatch, op = 0%o.\n",Get_BYTE(PCMAC));E 6I 6D 10  printf("Dispatch, PC = 0%o, op = 0%o.\n", (int)PCMAC-(int)FuncObj, Get_BYTE(PCMAC));E 10I 10D 11  printf("Dispatch, PC = 0x%x, op = 0%o.\n", (int)PCMAC, Get_BYTE(PCMAC));E 11I 11  printf("Dispatch, PC = 0x%x, op = 0%o.\n", (int)PCMAC, Get_BYTE_PCMAC0);E 11E 10E 6#endif TRACEE 5D 11switch (Get_BYTE(PCMAC)) {E 11I 11switch (Get_BYTE_PCMAC0) {E 21I 21D 24  OPTPRINT(("Dispatch, PC = 0x%x, op = 0%o.\n", (int)PCMAC, Get_BYTE_PCMAC0));E 24I 24#ifdef MYOPTRACE  if ((struct fnhead *)Addr68k_from_LADDR(0x2ed600) == FuncObj)      {	quick_stack_check();D 33#endif MYOPTRACEE 33I 33#endif /* MYOPTRACE */E 33  OPTPRINT(("Dispatch, PC = 0x%x, op = 0%o. TOS = 0x%x.\n", (int)PCMAC, Get_BYTE_PCMAC0, TOPOFSTACK));#ifdef MYOPTRACE      }D 33#endif MYOPTRACEE 33I 33#endif /* MYOPTRACE */E 33I 33E 33#ifdef PCTRACE  /* Tracing PC/Function/Opcode in a ring buffer */  pc_table[pccounter] = (int)PCMAC - (int)FuncObj;  fn_table[pccounter] = (LispPTR) LADDR_from_68k(FuncObj);  op_table[pccounter] = Get_BYTE_PCMAC0;  if (99 == pccounter++) pccounter = 0;D 33#endif PCTRACEE 33I 33#endif /* PCTRACE */E 33D 25#ifdef DEBUG  if (dbgflag) check_dtd_chain(6);	/* check array DTD on each opcode! */#endif DEBUGE 25E 24E 21E 11I 33E 33D 21E 21I 21switch (Get_BYTE_PCMAC0) {E 21  case 000 : CASE000: { goto op_ufn; } /* unused */ case 001 : CASE001: OPCAR; case 002 : CASE002: OPCDR; case 003 : CASE003: LISTP; case 004 : CASE004: NTYPEX;D 11 case 005 : CASE005: TYPEP(Get_BYTE(PCMAC+1));E 11I 11 case 005 : CASE005: TYPEP(Get_BYTE_PCMAC1);E 11 case 056 : CASE056: D 11 case 006 : CASE006: DTEST(Get_DLword(PCMAC+1)); case 007 : CASE007: UNWIND(Get_BYTE(PCMAC+1), Get_BYTE(PCMAC+2));E 11I 11D 20 case 006 : CASE006: DTEST(Get_DLword_PCMAC1);E 20I 20 case 006 : CASE006: DTEST(Get_AtomNo_PCMAC1);E 20 case 007 : CASE007: UNWIND(Get_BYTE_PCMAC1, Get_BYTE_PCMAC2);E 11#ifdef NATIVETRAN 	    ret_to_fn0: asm("_ret_to_fn0:"); 			asm("	.globl _ret_to_fn0"); 			RET_FROM_NATIVE;#endif case 010 : CASE010: FN0;#ifdef NATIVETRAN	    ret_to_fn1: asm("_ret_to_fn1:"); 			asm("	.globl _ret_to_fn1"); 			RET_FROM_NATIVE;#endif case 011 : CASE011: FN1;#ifdef NATIVETRAN	    ret_to_fn2: asm("_ret_to_fn2:"); 			asm("	.globl _ret_to_fn2"); 			RET_FROM_NATIVE;#endif case 012 : CASE012: FN2;#ifdef NATIVETRAN	    ret_to_fn3: asm("_ret_to_fn3:"); 			asm("	.globl _ret_to_fn3"); 			RET_FROM_NATIVE;#endif case 013 : CASE013: FN3;#ifdef NATIVETRAN	    ret_to_fn4: asm("_ret_to_fn4:"); 			asm("	.globl _ret_to_fn4"); 			RET_FROM_NATIVE;#endif case 014 : CASE014: FN4;#ifdef NATIVETRAN	    ret_to_fnx: asm("_ret_to_fnx:"); 			asm("	.globl _ret_to_fnx"); 			RET_FROM_NATIVE;#endif case 015 : CASE015: FNX;#ifdef NATIVETRAN	    ret_to_apply: asm("_ret_to_apply:"); 			asm("	.globl _ret_to_apply"); 			RET_FROM_NATIVE;#endif case 016 : CASE016: APPLY; case 017 : CASE017: CHECKAPPLY; case 020 : CASE020: RETURN; case 021 : CASE021: BIND; case 022 : CASE022: UNBIND; case 023 : CASE023: DUNBIND;D 11 case 024 : CASE024: RPLPTR(Get_BYTE(PCMAC+1)); case 025 : CASE025: GCREF(Get_BYTE(PCMAC+1));E 11I 11 case 024 : CASE024: RPLPTR(Get_BYTE_PCMAC1); case 025 : CASE025: GCREF(Get_BYTE_PCMAC1);E 11 case 026 : CASE026: ASSOC;D 11 case 027 : CASE027: GVAR_(Get_DLword(PCMAC+1));E 11I 11D 20 case 027 : CASE027: GVAR_(Get_DLword_PCMAC1);E 20I 20 case 027 : CASE027:		     GVAR_(Get_AtomNo_PCMAC1);E 20E 11 case 030 : CASE030: RPLACA; case 031 : CASE031: RPLACD; case 032 : CASE032: CONS; case 033 : CASE033: CLASSOC; case 034 : CASE034: FMEMB; case 035 : CASE035: CLFMEMB;D 11 case 036 : CASE036: FINDKEY(Get_BYTE(PCMAC+1));E 11I 11 case 036 : CASE036: FINDKEY(Get_BYTE_PCMAC1);E 11 case 037 : CASE037: CREATECELL; case 040 : CASE040: BIN; case 041 : CASE041: { goto op_ufn; } /* BOUT */ case 042 : CASE042: { goto op_ufn; } /* POPDISP - prolog only */D 11 case 043 : CASE043: RESTLIST(Get_BYTE(PCMAC+1)); case 044 : CASE044: MISCN(Get_BYTE(PCMAC+1), Get_BYTE(PCMAC+2));E 11I 11 case 043 : CASE043: RESTLIST(Get_BYTE_PCMAC1); case 044 : CASE044: MISCN(Get_BYTE_PCMAC1, Get_BYTE_PCMAC2);E 11 case 045 : CASE045: { goto op_ufn; }  /* unused */ case 046 : CASE046: RPLCONS; case 047 : CASE047: LISTGET; case 050 : CASE050: { goto op_ufn; }  /* unused */ case 051 : CASE051: { goto op_ufn; }  /* unused */ case 052 : CASE052: { goto op_ufn; }  /* unused */ case 053 : CASE053: { goto op_ufn; }  /* unused */ case 054 : CASE054: EVAL;#ifdef NATIVETRAN	    ret_to_envcall: asm("_ret_to_envcall:"); 			asm("	.globl _ret_to_envcall"); 			RET_FROM_NATIVE;#endif case 055 : CASE055: ENVCALL;/*  case 056 : CASE056: @ 006 */ case 057 : CASE057: STKSCAN; case 060 : CASE060: { goto op_ufn; } /* BUSBLT - DLion only */ case 061 : CASE061: { goto op_ufn; } /* MISC8 - no longer used */D 11 case 062 : CASE062: UBFLOAT3(Get_BYTE(PCMAC+1)); case 063 : CASE063: TYPEMASK(Get_BYTE(PCMAC+1));E 11I 11 case 062 : CASE062: UBFLOAT3(Get_BYTE_PCMAC1); case 063 : CASE063: TYPEMASK(Get_BYTE_PCMAC1);E 11 case 064 : CASE064: { goto op_ufn; } /* rdprologptr */ case 065 : CASE065: { goto op_ufn; } /* rdprologtag */ case 066 : CASE066: { goto op_ufn; } /* writeptr&tag */ case 067 : CASE067: { goto op_ufn; } /* writeptr&0tag */D 7 case 070 : CASE070: { goto op_ufn; }  /* misc7 (pseudocolor) */E 7I 7D 11 case 070 : CASE070: MISC7(Get_BYTE(PCMAC+1));	   /* misc7 (pseudocolor, fbitmapbit) */E 11I 11 case 070 : CASE070: MISC7(Get_BYTE_PCMAC1);	   /* misc7 (pseudocolor, fbitmapbit) */E 11E 7 case 071 : CASE071: { goto op_ufn; } /* dovemisc - dove only */ case 072 : CASE072: EQLOP; case 073 : CASE073: DRAWLINE;D 11 case 074 : CASE074: STOREN(Get_BYTE(PCMAC+1)); case 075 : CASE075: COPYN(Get_BYTE(PCMAC+1));E 11I 11 case 074 : CASE074: STOREN(Get_BYTE_PCMAC1); case 075 : CASE075: COPYN(Get_BYTE_PCMAC1);E 11 case 076 : CASE076: { goto op_ufn; } /* RAID */ case 077 : CASE077: { goto op_ufn; } /* \RETURN */ case 0100 : CASE100:  IVARMACRO (0);   case 0101 : CASE101:  IVARMACRO (1);   case 0102 : CASE102:  IVARMACRO (2);   case 0103 : CASE103:  IVARMACRO (3);   case 0104 : CASE104:  IVARMACRO (4);   case 0105 : CASE105:  IVARMACRO (5);   case 0106 : CASE106:  IVARMACRO (6);   D 11 case 0107 : CASE107:  IVARX (Get_BYTE(PCMAC+1));   E 11I 11 case 0107 : CASE107:  IVARX (Get_BYTE_PCMAC1);   E 11 case 0110 : CASE110:  PVARMACRO (0);   case 0111 : CASE111:  PVARMACRO (1);  case 0112 : CASE112:  PVARMACRO (2);   case 0113 : CASE113:  PVARMACRO (3);   case 0114 : CASE114:  PVARMACRO (4);   case 0115 : CASE115:  PVARMACRO (5);   case 0116 : CASE116:  PVARMACRO (6);    D 11 case 0117 : CASE117: PVARX(Get_BYTE(PCMAC+1));E 11I 11 case 0117 : CASE117: PVARX(Get_BYTE_PCMAC1);E 11 case 0120 : CASE120: FVAR(0); case 0121 : CASE121: FVAR(2); case 0122 : CASE122: FVAR(4); case 0123 : CASE123: FVAR(6); case 0124 : CASE124: FVAR(8); case 0125 : CASE125: FVAR(10); case 0126 : CASE126: FVAR(12);D 11 case 0127 : CASE127: FVARX(Get_BYTE(PCMAC+1));E 11I 11 case 0127 : CASE127: FVARX(Get_BYTE_PCMAC1);E 11		 case 0130 : CASE130: PVARSETMACRO (0);  case 0131 : CASE131: PVARSETMACRO (1);  case 0132 : CASE132: PVARSETMACRO (2); case 0133 : CASE133: PVARSETMACRO (3);  case 0134 : CASE134: PVARSETMACRO (4);  case 0135 : CASE135: PVARSETMACRO (5);  case 0136 : CASE136: PVARSETMACRO (6); D 11 case 0137 : CASE137: PVARX_(Get_BYTE(PCMAC+1));E 11I 11 case 0137 : CASE137: PVARX_(Get_BYTE_PCMAC1);E 11 D 11 case 0140 : CASE140: GVAR(Get_DLword(PCMAC+1));E 11I 11D 20 case 0140 : CASE140: GVAR(Get_DLword_PCMAC1);E 20I 20 case 0140 : CASE140: GVAR(Get_AtomNo_PCMAC1);E 20E 11 case 0141 : CASE141: ARG0;D 11 case 0142 : CASE142: IVARX_(Get_BYTE(PCMAC+1)); case 0143 : CASE143: FVARX_(Get_BYTE(PCMAC+1));E 11I 11 case 0142 : CASE142: IVARX_(Get_BYTE_PCMAC1); case 0143 : CASE143: FVARX_(Get_BYTE_PCMAC1);E 11 case 0144 : CASE144: COPY; case 0145 : CASE145: MYARGCOUNT; case 0146 : CASE146: MYALINK;/******** Aconst	********/D 11 case 0147 : CASE147: { PUSH(Get_DLword(PCMAC+1)); nextop3;}E 11I 11D 20 case 0147 : CASE147: { PUSH(Get_DLword_PCMAC1); nextop3;}E 20I 20 case 0147 : CASE147: { PUSH(Get_AtomNo_PCMAC1); nextop_atom;}E 20E 11 case 0150 : CASE150: { PUSHATOM(NIL_PTR     ); } case 0151 : CASE151: { PUSHATOM(ATOM_T      ); } case 0152 : CASE152: { PUSHATOM(S_POSITIVE  ); } /* '0 */ case 0153 : CASE153: { PUSHATOM(0xE0001     ); } /* '1 *//********* SIC		********/ case 0154 : CASE154: {	D 11 		PUSH(S_POSITIVE | Get_BYTE(PCMAC+1));E 11I 11 		PUSH(S_POSITIVE | Get_BYTE_PCMAC1);E 11 		nextop2;		}/********* SNIC		********/ case 0155 : CASE155: { 	D 11		PUSH(S_NEGATIVE | 0xff00 | Get_BYTE(PCMAC+1));E 11I 11		PUSH(S_NEGATIVE | 0xff00 | Get_BYTE_PCMAC1);E 11 		nextop2;		}/********* SICX		********/ case 0156 : CASE156:{ 	D 11 		PUSH(S_POSITIVE | Get_DLword(PCMAC+1));E 11I 11 		PUSH(S_POSITIVE | Get_DLword_PCMAC1);E 11 		nextop3;		}/********* GCONST	********/ case 0157 : CASE157: {D 20		PUSH(	(Get_BYTE(PCMAC + 1) << 16) | 			(Get_BYTE(PCMAC + 2) << 8) | 			Get_BYTE(PCMAC +  3));E 20I 20		PUSH(Get_Pointer_PCMAC1);E 20D 33		nextop4;E 33I 33		nextop_ptr;E 33		}  case 0160 : CASE160: { goto op_ufn; } /* unused */ case 0161 : CASE161: { goto op_ufn; } /* readflags */ case 0162 : CASE162: { goto op_ufn; } /* readrp */ case 0163 : CASE163: { goto op_ufn; } /* writemap */ case 0164 : CASE164: { goto op_ufn; } /* readprinterport */ case 0165 : CASE165: { goto op_ufn; } /* writeprinterport */ case 0166 : CASE166: PILOTBITBLT; case 0167 : CASE167: RCLK; case 0170 : CASE170: { goto op_ufn; } /* MISC1, dorado only */ case 0171 : CASE171: { goto op_ufn; } /* MISC2, dorado only */ case 0172 : CASE172: RECLAIMCELL; case 0173 : CASE173: GCSCAN1; case 0174 : CASE174: GCSCAN2;D 31 case 0175 : CASE175: { EXT; OP_subrcall(); RET; NATIVE_NEXTOP0; };E 31I 31 case 0175 : CASE175: { EXT; OP_subrcall(Get_BYTE_PCMAC1, Get_BYTE_PCMAC2); RET; NATIVE_NEXTOP0; };E 31 case 0176 : CASE176: { CONTEXTSWITCH; } case 0177 : CASE177: { goto op_ufn; } /* RETCALL *//* JUMP */ case 0200 : CASE200: { JUMPMACRO(2); } case 0201 : CASE201: { JUMPMACRO(3); } case 0202 : CASE202: { JUMPMACRO(4); } case 0203 : CASE203: { JUMPMACRO(5); } case 0204 : CASE204: { JUMPMACRO(6); } case 0205 : CASE205: { JUMPMACRO(7); } case 0206 : CASE206: { JUMPMACRO(8); } case 0207 : CASE207: { JUMPMACRO(9); } case 0210 : CASE210: { JUMPMACRO(10); } case 0211 : CASE211: { JUMPMACRO(11); } case 0212 : CASE212: { JUMPMACRO(12); } case 0213 : CASE213: { JUMPMACRO(13); } case 0214 : CASE214: { JUMPMACRO(14); } case 0215 : CASE215: { JUMPMACRO(15); } case 0216 : CASE216: { JUMPMACRO(16); } case 0217 : CASE217: { JUMPMACRO(17); }/* FJUMP */ case 0220 : CASE220: { FJUMPMACRO(2); } case 0221 : CASE221: { FJUMPMACRO(3); } case 0222 : CASE222: { FJUMPMACRO(4); } case 0223 : CASE223: { FJUMPMACRO(5); } case 0224 : CASE224: { FJUMPMACRO(6); } case 0225 : CASE225: { FJUMPMACRO(7); } case 0226 : CASE226: { FJUMPMACRO(8); } case 0227 : CASE227: { FJUMPMACRO(9); } case 0230 : CASE230: { FJUMPMACRO(10); } case 0231 : CASE231: { FJUMPMACRO(11); } case 0232 : CASE232: { FJUMPMACRO(12); } case 0233 : CASE233: { FJUMPMACRO(13); } case 0234 : CASE234: { FJUMPMACRO(14); } case 0235 : CASE235: { FJUMPMACRO(15); } case 0236 : CASE236: { FJUMPMACRO(16); } case 0237 : CASE237: { FJUMPMACRO(17); }/* TJUMP */ case 0240 : CASE240: { TJUMPMACRO(2); } case 0241 : CASE241: { TJUMPMACRO(3); } case 0242 : CASE242: { TJUMPMACRO(4); } case 0243 : CASE243: { TJUMPMACRO(5); } case 0244 : CASE244: { TJUMPMACRO(6); } case 0245 : CASE245: { TJUMPMACRO(7); } case 0246 : CASE246: { TJUMPMACRO(8); } case 0247 : CASE247: { TJUMPMACRO(9); } case 0250 : CASE250: { TJUMPMACRO(10); } case 0251 : CASE251: { TJUMPMACRO(11); } case 0252 : CASE252: { TJUMPMACRO(12); } case 0253 : CASE253: { TJUMPMACRO(13); } case 0254 : CASE254: { TJUMPMACRO(14); } case 0255 : CASE255: { TJUMPMACRO(15); } case 0256 : CASE256: { TJUMPMACRO(16); } case 0257 : CASE257: { TJUMPMACRO(17); }/******* JUMPX ********/ case 0260 : CASE260: {		CHECK_INTERRUPT;D 5		PCMACL += *(PCMAC+1); nextop0; E 5I 5D 22		PCMACL += GETBYTE(PCMAC+1); nextop0; E 22I 22D 23		PCMACL += GETBYTE((char *)PCMAC+1); nextop0; E 23I 23D 31		PCMACL += GETBYTE((s_char *)PCMAC+1); nextop0; E 31I 31		PCMACL += Get_SBYTE_PCMAC1; nextop0; E 31E 23E 22E 5		}/******* JUMPXX ********/ case 0261 : CASE261: {		CHECK_INTERRUPT;D 5		PCMACL += (*(PCMAC+1)<<8) | Get_BYTE(PCMAC+2); nextop0; E 5I 5D 11		PCMACL += (GETBYTE(PCMAC+1)<<8) | Get_BYTE(PCMAC+2); nextop0; E 11I 11D 22		PCMACL += (GETBYTE(PCMAC+1)<<8) | Get_BYTE_PCMAC2; nextop0; E 22I 22D 23		PCMACL += (GETBYTE((char *)PCMAC+1)<<8) | Get_BYTE_PCMAC2; nextop0; E 23I 23D 31		PCMACL += (GETBYTE((s_char *)PCMAC+1)<<8) | Get_BYTE_PCMAC2; nextop0; E 31I 31		PCMACL += (Get_SBYTE_PCMAC1<<8) | Get_BYTE_PCMAC2; nextop0; E 31E 23E 22E 11E 5		}/******* FJumpx *******/ case 0262 : CASE262: {    if(TOPOFSTACK != 0) {goto PopNextop2;}	CHECK_INTERRUPT;	POP;D 5	PCMACL += *(PCMAC+1);E 5I 5D 22	PCMACL += GETBYTE(PCMAC+1);E 22I 22D 23	PCMACL += GETBYTE((char *)PCMAC+1);E 23I 23D 31	PCMACL += GETBYTE((s_char *)PCMAC+1);E 31I 31	PCMACL += Get_SBYTE_PCMAC1;E 31E 23E 22E 5	nextop0; 	}/******* TJumpx *******/ case 0263 : CASE263: {	if(TOPOFSTACK == 0) {goto PopNextop2;}	CHECK_INTERRUPT;	POP;D 5	PCMACL += *(PCMAC+1);E 5I 5D 22	PCMACL += GETBYTE(PCMAC+1);E 22I 22D 23	PCMACL += GETBYTE((char *)PCMAC+1);E 23I 23D 31	PCMACL += GETBYTE((s_char *)PCMAC+1);E 31I 31	PCMACL += Get_SBYTE_PCMAC1;E 31E 23E 22E 5	nextop0; 	}/******* NFJumpx *******/ case 0264 : CASE264: {	if(TOPOFSTACK != 0) {goto PopNextop2;}	CHECK_INTERRUPT;D 5	PCMACL += *(PCMAC+1);E 5I 5D 22	PCMACL += GETBYTE(PCMAC+1);E 22I 22D 23	PCMACL += GETBYTE((char *)PCMAC+1);E 23I 23D 31	PCMACL += GETBYTE((s_char *)PCMAC+1);E 31I 31	PCMACL += Get_SBYTE_PCMAC1;E 31E 23E 22E 5	nextop0; 	}/******* NTJumpx *******/ case 0265 : CASE265: {	if(TOPOFSTACK == 0) {goto PopNextop2;}	CHECK_INTERRUPT;D 5	PCMACL += *(PCMAC+1);E 5I 5D 22	PCMACL += GETBYTE(PCMAC+1);E 22I 22D 23	PCMACL += GETBYTE((char *)PCMAC+1);E 23I 23D 31	PCMACL += GETBYTE((s_char *)PCMAC+1);E 31I 31	PCMACL += Get_SBYTE_PCMAC1;E 31E 23E 22E 5	nextop0; 	} case 0266 : CASE266:	AREF1; case 0267 : CASE267:	ASET1; case 0270 : CASE270:	PVARSETPOPMACRO(0); case 0271 : CASE271:	PVARSETPOPMACRO(1); case 0272 : CASE272:	PVARSETPOPMACRO(2); case 0273 : CASE273:	PVARSETPOPMACRO(3); case 0274 : CASE274:	PVARSETPOPMACRO(4); case 0275 : CASE275:	PVARSETPOPMACRO(5); case 0276 : CASE276:	PVARSETPOPMACRO(6); case 0277 : CASE277: 	{ POP; nextop1; }D 11 case 0300 : CASE300:  POPN(Get_BYTE(PCMAC+1)); case 0301 : CASE301: 	ATOMCELL_N(Get_BYTE(PCMAC+1));E 11I 11 case 0300 : CASE300:  POPN(Get_BYTE_PCMAC1); case 0301 : CASE301: 	ATOMCELL_N(Get_BYTE_PCMAC1);E 11 case 0302 : CASE302: 	GETBASEBYTE;D 11 case 0303 : CASE303:  INSTANCEP(Get_DLword(PCMAC+1));E 11I 11D 20 case 0303 : CASE303:  INSTANCEP(Get_DLword_PCMAC1);E 20I 20 case 0303 : CASE303:  INSTANCEP(Get_AtomNo_PCMAC1);E 20E 11 case 0304 : CASE304:  BLT; case 0305 : CASE305:  {goto op_ufn; } /* MISC10 */ case 0306 : CASE306:  {goto op_ufn; } /* P-MISC2 ??? */ case 0307 : CASE307:	PUTBASEBYTE;D 11 case 0310 : CASE310:	GETBASE_N(Get_BYTE(PCMAC+1)); case 0311 : CASE311:	GETBASEPTR_N(Get_BYTE(PCMAC+1)); case 0312 : CASE312:	GETBITS_N_M(Get_BYTE(PCMAC+1), Get_BYTE(PCMAC+2));E 11I 11 case 0310 : CASE310:	GETBASE_N(Get_BYTE_PCMAC1); case 0311 : CASE311:	GETBASEPTR_N(Get_BYTE_PCMAC1); case 0312 : CASE312:	GETBITS_N_M(Get_BYTE_PCMAC1, Get_BYTE_PCMAC2);E 11 case 0313 : CASE313:  {goto op_ufn; } /* unused */ case 0314 : CASE314:	CLEQUAL;D 11 case 0315 : CASE315:	PUTBASE_N(Get_BYTE(PCMAC+1)); case 0316 : CASE316:	PUTBASEPTR_N(Get_BYTE(PCMAC+1)); case 0317 : CASE317:	PUTBITS_N_M(Get_BYTE(PCMAC+1), Get_BYTE(PCMAC+2));E 11I 11 case 0315 : CASE315:	PUTBASE_N(Get_BYTE_PCMAC1); case 0316 : CASE316:	PUTBASEPTR_N(Get_BYTE_PCMAC1); case 0317 : CASE317:	PUTBITS_N_M(Get_BYTE_PCMAC1, Get_BYTE_PCMAC2);E 11 case 0320 : CASE320:	N_OP_ADDBASE; case 0321 : CASE321:	N_OP_VAG2; case 0322 : CASE322:	N_OP_HILOC; case 0323 : CASE323:	N_OP_LOLOC; case 0324 : CASE324: 	PLUS2; /* PLUS */ case 0325 : CASE325:  DIFFERENCE;	/* DIFFERENCE */	 case 0326 : CASE326:	TIMES2; /* TIMES2 */ case 0327 : CASE327:  QUOTIENT /* QUOTIENT */ case 0330 : CASE330:  IPLUS2; /* IPLUS2 only while PLUS has no float */ case 0331 : CASE331:  IDIFFERENCE; /* IDIFFERENCE only while no float */ case 0332 : CASE332:	ITIMES2; /* ITIMES2 only while no float */ case 0333 : CASE333:	IQUOTIENT; /* IQUOTIENT */ case 0334 : CASE334:	IREMAINDER;D 11 case 0335 : CASE335:	IPLUS_N(Get_BYTE(PCMAC+1)); case 0336 : CASE336:	IDIFFERENCE_N(Get_BYTE(PCMAC+1));E 11I 11 case 0335 : CASE335:	IPLUS_N(Get_BYTE_PCMAC1); case 0336 : CASE336:	IDIFFERENCE_N(Get_BYTE_PCMAC1);E 11 case 0337 : CASE337:  { goto op_ufn; } /* BASE-< */ case 0340 : CASE340:  LLSH1; case 0341 : CASE341:  LLSH8; case 0342 : CASE342:  LRSH1; case 0343 : CASE343:  LRSH8; case 0344 : CASE344:  LOGOR; case 0345 : CASE345:  LOGAND; case 0346 : CASE346:  LOGXOR; case 0347 : CASE347:  LSH; case 0350 : CASE350:  FPLUS2; case 0351 : CASE351:  FDIFFERENCE; case 0352 : CASE352:  FTIMES2; case 0353 : CASE353:  FQUOTIENT;D 11 case 0354 : CASE354:  UBFLOAT2(Get_BYTE(PCMAC+1)); case 0355 : CASE355:  UBFLOAT1(Get_BYTE(PCMAC+1));E 11I 11 case 0354 : CASE354:  UBFLOAT2(Get_BYTE_PCMAC1); case 0355 : CASE355:  UBFLOAT1(Get_BYTE_PCMAC1);E 11 case 0356 : CASE356:  AREF2; case 0357 : CASE357:  ASET2; case 0360 : CASE360: {		if(TOPOFSTACK == POP_TOS_1)			TOPOFSTACK = ATOM_T;		else	TOPOFSTACK = NIL_PTR;		nextop1;		} case 0361 : CASE361:  IGREATERP; /* IGREATERP if no float */	 case 0362 : CASE362:  FGREATERP; case 0363 : CASE363:	GREATERP; case 0364 : CASE364:  ILEQUAL; case 0365 : CASE365:	MAKENUMBER; case 0366 : CASE366:	BOXIPLUS; case 0367 : CASE367:	BOXIDIFFERENCE; case 0370 : CASE370:  { goto op_ufn; } /* FLOATBLT */ case 0371 : CASE371:  { goto op_ufn; } /* FFTSTEP */D 11 case 0372 : CASE372: 	MISC3(Get_BYTE(PCMAC+1)); case 0373 : CASE373: 	MISC4(Get_BYTE(PCMAC+1));E 11I 11 case 0372 : CASE372: 	MISC3(Get_BYTE_PCMAC1); case 0373 : CASE373: 	MISC4(Get_BYTE_PCMAC1);E 11 case 0374 : CASE374:  { goto op_ufn; } /* upctrace */ case 0375 : CASE375: 	SWAP; case 0376 : CASE376: 	NOP; case 0377 : CASE377: 	CLARITHEQUAL;I 29D 31E 31I 31#ifdef OPDISPE 31#ifdef ISCcase 0400 : goto setup_table; /* to defeat optimizer, so optable exists */D 33#endif ISCI 31#endif OPDISPE 33I 33#endif /* ISC */E 33E 31I 33#endif /* OPDISP */E 33I 31I 33E 33E 31E 29I 13#ifdef I386	/* to defeat the damn optimizer, make it look like */	/* we might branch to the error labels. */ case 0400 : goto plus_err; case 0401 : goto iplus_err; case 0402 : goto iplusn_err; case 0403 : goto idiff_err; case 0404 : goto diff_err; case 0405 : goto idiffn_err;I 14D 15#ifdef NEVERE 15E 14 case 0406 : goto greaterp_err; case 0411 : goto igreaterp_err;I 14D 15#endifE 15E 14 case 0407 : goto llsh8_err; case 0410 : goto lrsh1_err;D 14 case 0412 : goto logand_err; case 0413 : goto logor_err;E 14 case 0414 : goto lrsh8_err;D 14 case 0415 : goto addbase_err; case 0416 : goto logxor_err;E 14 case 0417 : goto llsh1_err;I 14 case 0413 : goto logor_err; case 0412 : goto logand_err; case 0416 : goto logxor_err; case 0415 : goto addbase_err;E 14#endifE 13 	 default: 	error("should not default");	 }	/* switch */#ifdef NATIVETRAN/************************************************************************//*	 	NATIVE CODE INTERFACE 					*//************************************************************************//*		FORIEGN -> DISPATCH 					*//*		Return to current frame ext				*/c_ret_to_dispatch:	asm("	.globl	_c_ret_to_dispatch");	asm("_c_ret_to_dispatch:");	PCMACL = (ByteCode *) FuncObj + BCE_CURRENTFX->pc;	goto ret_to_dispatch;		/* assume optimizer will remove *//*		NATIVE -> DISPATCH 					*//*		Return to current frame ext				*/ret_to_dispatch:	asm("	.globl	_ret_to_dispatch");	asm("_ret_to_dispatch:");	RET_FROM_NATIVE;	nextop0;/*		NATIVE -> DISPATCH 					*//*		Execute opcode in current frame ext			*/ret_to_unimpl:	asm("	.globl	_ret_to_unimpl");	asm("_ret_to_unimpl:");	SaveD6 = 0x100;			/* HACK.  Reg. d6 is set to dispatch to native_check */			/* so need to do switch instead of dispatch! */	RET_FROM_NATIVE;	goto nextopcode;/*		NATIVE -> UFN(PC) 					*/ret_to_ufn:	asm("	.globl	_ret_to_ufn");	asm("_ret_to_ufn:");	RET_FROM_NATIVE;	goto op_ufn;/*		DISPATCH -> NATIVE? 					*//*		Return to current frame ext?				*/	native_check:	SaveD6 = 0;	NATIVE_NEXTOP0;/*		NATIVE -> TIMER						*//*		Return to Execute timer interrupt			*/ret_to_timer:	asm("_ret_to_timer:");	asm("	.globl	_ret_to_timer");	SaveD6 = 0x100;	RET_FROM_NATIVE;	goto check_interrupt;	/* assume optimizer will remove */#elsenative_check: #ifdef OPDISP		SaveD6 = 0x000;#endif		goto nextopcode;#endif/************************************************************************//*		TIMER INTERRUPT CHECK ROUTINE				*//************************************************************************/check_interrupt:D 31#ifdef	NATIVETRANE 31I 31#if	(defined(NATIVETRAN) || defined(SUN3_OS3_OR_OS4_IL) || defined(I386) || defined(ISC))E 31	asm_label_check_interrupt();D 31#elseD 4#ifdef	SUN3_OS3_ILE 4I 4#ifdef SUN3_OS3_OR_OS4_ILE 4	asm_label_check_interrupt();I 17#else#ifdef I386	asm_label_check_interrupt();#endifE 17#endifE 31#endif	if ( (int)CSTKPTR > (int)EndSTKP )		{EXT;		 error("Unrecoverable Stack Overflow");	         RET;		}	/* Check for an IRQ request */{register int need_irq; static int period_cnt=60;D 19extern int	KBDEventFlg;E 19I 19extern int KBDEventFlg;extern int ETHEREventCount;E 19extern LispPTR DOBUFFEREDTRANSITION_index;extern LispPTR INTERRUPTFRAME_index;extern LispPTR *KEYBUFFERING68k;extern LispPTR *PENDINGINTERRUPT68k;extern LispPTR ATOM_STARTED;extern LispPTR *PERIODIC_INTERRUPT68k;extern LispPTR *PERIODIC_INTERRUPT_FREQUENCY68k;extern LispPTR PERIODIC_INTERRUPTFRAME_index;extern LispPTR *Reclaim_cnt_word;extern LispPTR DORECLAIM_index;extern int URaid_req;	/* Check for an Stack Overflow */re_check_stack:	need_irq = 0;	if ( 	((int)(CSTKPTR+1) > Irq_Stk_Check) && 		(Irq_Stk_End > 0) && 		(Irq_Stk_Check > 0) )		{	 	 HARD_PUSH(TOPOFSTACK);		 EXT;		 extended_frame = NIL;		 if (do_stackoverflow(NIL)) { I 2stackoverflow_help:			period_cnt=60; need_irq = T;E 2			error("Stack Overflow, MUST HARDRESET!"); 			RET; TOPOFSTACK = NIL_PTR; 			}		 else { RET; POP; }		 Irq_Stk_Check = (int)EndSTKP-STK_MIN(FuncObj);		 need_irq = (Irq_Stk_End == 0)  || extended_frame;		 *PENDINGINTERRUPT68k |= extended_frame; 		 Irq_Stk_End = (int) EndSTKP;		}	/* Check for an IRQ request */	if ((Irq_Stk_End <= 0) || (Irq_Stk_Check <= 0) || need_irq) {		if (StkOffset_from_68K(CSTKPTR) > InterfacePage->stackbase) {			/* Interrupts not Disabled */#ifndef KBINT			getsignaldata();#endif			EXT; 			update_timer(); 			if(URaid_req ==T){				URaid_req=NIL;				error("Call URaid by User Interrupt");			}			else if((KBDEventFlg>0)&&(*KEYBUFFERING68k==ATOM_T)) {				*KEYBUFFERING68k= ATOM_STARTED;				cause_interruptcall(DOBUFFEREDTRANSITION_index);				KBDEventFlg --;				}			else if(*Reclaim_cnt_word == S_POSITIVE) {  				*Reclaim_cnt_word=NIL;				cause_interruptcall(DORECLAIM_index);				}D 19			else if(*PENDINGINTERRUPT68k!=NIL) { E 19I 19			else if (*PENDINGINTERRUPT68k!=NIL)			  { INTSTAT2 * intstate = ((INTSTAT2 *)Addr68k_from_LADDR(*INTERRUPTSTATE_word));			    unsigned char newints = (intstate->pendingmask) & ~(intstate->handledmask);			 /*   if (newints) */			      {				intstate->handledmask |= intstate->pendingmask;E 19				*PENDINGINTERRUPT68k=NIL;				cause_interruptcall(INTERRUPTFRAME_index);D 19				}E 19I 19			      }			  }			else if (ETHEREventCount>0)			  { INTSTAT * intstate = ((INTSTAT *)Addr68k_from_LADDR(*INTERRUPTSTATE_word));			    if (!(intstate->ETHERInterrupt) &&				!(((INTSTAT2 *)intstate)->handledmask & 0x40))			      {				intstate->ETHERInterrupt=1;				((INTSTAT2 *)intstate)->handledmask |=				    ((INTSTAT2 *)intstate)->pendingmask;				cause_interruptcall(INTERRUPTFRAME_index);				ETHEREventCount--;			      }			    else *PENDINGINTERRUPT68k = ATOM_T;			  }E 19			else if(*PERIODIC_INTERRUPT68k!=NIL) {				if(period_cnt>0)  period_cnt--;				else {					cause_interruptcall(PERIODIC_INTERRUPTFRAME_index);					if(*PERIODIC_INTERRUPT_FREQUENCY68k==NIL)						period_cnt=0;					else						period_cnt=(*PERIODIC_INTERRUPT_FREQUENCY68k & 0xffff) *(1000000/60) /TIMER_INTERVAL;	/* number of 1/60 second periods between interrupts.	  TIMER_INTERVAL is the number of microseconds between	  timer interrupts. The calculation here avoids some	  overflow errors although there is some roundoff	  if the interrupt frequency number is too low,	 it will bottom out and just set period_cnt to 0 */					}				}			RET;			CLR_IRQ;			} /* Interrupts not Disabled */		else {			/* Clear out IRQ (loses pending interrupt request 			   if interrupts are disabled) */			CLR_IRQ;			goto re_check_stack;			}		}}	nextop0;/************************************************************************//* Common Jump Tails (they have to jump anyway, so use common Tail) *//************************************************************************/PopNextop1:	POP; 	nextop1;PopNextop2:	POP; 	nextop2;I 28/************************************************************************//*									*//*	Set up the dispatch table for use when we do assembler		*//*	optimization of the dispatch-jump sequence.			*//*									*//*									*//************************************************************************/E 28#ifdef OPDISP setup_table:I 29#ifndef ISCE 29	SaveD6 = 0;I 12E 12#ifdef UNSAFE	Save_D5_shift_amount = 15;#endif	{int i; for (i = 0; i < 256; i++) { table[i] = (InstPtr) op_ufn; };}	{int i; for (i = 256; i < 512; i++) 		{ table[i] = (InstPtr) native_check; };	}	table[001] = (InstPtr) case001;	table[002] = (InstPtr) case002;	table[003] = (InstPtr) case003;	table[004] = (InstPtr) case004;	table[005] = (InstPtr) case005;	table[006] = (InstPtr) case006;	table[007] = (InstPtr) case007;	table[010] = (InstPtr) case010;	table[011] = (InstPtr) case011;	table[012] = (InstPtr) case012;	table[013] = (InstPtr) case013;	table[014] = (InstPtr) case014;	table[015] = (InstPtr) case015;	table[016] = (InstPtr) case016;	table[017] = (InstPtr) case017;	table[020] = (InstPtr) case020;	table[021] = (InstPtr) case021;	table[022] = (InstPtr) case022;	table[023] = (InstPtr) case023;	table[024] = (InstPtr) case024;	table[025] = (InstPtr) case025;	table[026] = (InstPtr) case026;	table[027] = (InstPtr) case027;	table[030] = (InstPtr) case030;	table[031] = (InstPtr) case031;	table[032] = (InstPtr) case032;	table[033] = (InstPtr) case033;	table[034] = (InstPtr) case034;	table[035] = (InstPtr) case035;	table[036] = (InstPtr) case036;	table[037] = (InstPtr) case037;	table[040] = (InstPtr) case040;	table[041] = (InstPtr) case041;	table[042] = (InstPtr) case042;	table[043] = (InstPtr) case043;	table[044] = (InstPtr) case044;	table[045] = (InstPtr) case045;	table[046] = (InstPtr) case046;	table[047] = (InstPtr) case047;	table[054] = (InstPtr) case054;	table[055] = (InstPtr) case055;	table[056] = (InstPtr) case056;	table[057] = (InstPtr) case057;	table[062] = (InstPtr) case062;	table[063] = (InstPtr) case063;I 7	table[070] = (InstPtr) case070;E 7	table[072] = (InstPtr) case072;	table[073] = (InstPtr) case073;	table[074] = (InstPtr) case074;	table[075] = (InstPtr) case075;	table[0100] = (InstPtr) case100;	table[0101] = (InstPtr) case101;	table[0102] = (InstPtr) case102;	table[0103] = (InstPtr) case103;	table[0104] = (InstPtr) case104;	table[0105] = (InstPtr) case105;	table[0106] = (InstPtr) case106;	table[0107] = (InstPtr) case107;	table[0110] = (InstPtr) case110;	table[0111] = (InstPtr) case111;	table[0112] = (InstPtr) case112;	table[0113] = (InstPtr) case113;	table[0114] = (InstPtr) case114;	table[0115] = (InstPtr) case115;	table[0116] = (InstPtr) case116;	table[0117] = (InstPtr) case117;	table[0120] = (InstPtr) case120;	table[0121] = (InstPtr) case121;	table[0122] = (InstPtr) case122;	table[0123] = (InstPtr) case123;	table[0124] = (InstPtr) case124;	table[0125] = (InstPtr) case125;	table[0126] = (InstPtr) case126;	table[0127] = (InstPtr) case127;	table[0130] = (InstPtr) case130;	table[0131] = (InstPtr) case131;	table[0132] = (InstPtr) case132;	table[0133] = (InstPtr) case133;	table[0134] = (InstPtr) case134;	table[0135] = (InstPtr) case135;	table[0136] = (InstPtr) case136;	table[0137] = (InstPtr) case137;	table[0140] = (InstPtr) case140;	table[0141] = (InstPtr) case141;	table[0142] = (InstPtr) case142;	table[0143] = (InstPtr) case143;	table[0144] = (InstPtr) case144;	table[0145] = (InstPtr) case145;	table[0146] = (InstPtr) case146;	table[0147] = (InstPtr) case147;	table[0150] = (InstPtr) case150;	table[0151] = (InstPtr) case151;	table[0152] = (InstPtr) case152;	table[0153] = (InstPtr) case153;	table[0154] = (InstPtr) case154;	table[0155] = (InstPtr) case155;	table[0156] = (InstPtr) case156;	table[0157] = (InstPtr) case157;	table[0160] = (InstPtr) case160;	table[0161] = (InstPtr) case161;	table[0162] = (InstPtr) case162;	table[0163] = (InstPtr) case163;	table[0164] = (InstPtr) case164;	table[0165] = (InstPtr) case165;	table[0166] = (InstPtr) case166;	table[0167] = (InstPtr) case167;	table[0170] = (InstPtr) case170;	table[0171] = (InstPtr) case171;	table[0172] = (InstPtr) case172;	table[0173] = (InstPtr) case173;	table[0174] = (InstPtr) case174;	table[0175] = (InstPtr) case175;	table[0176] = (InstPtr) case176;	table[0177] = (InstPtr) case177;	table[0200] = (InstPtr) case200;	table[0201] = (InstPtr) case201;	table[0202] = (InstPtr) case202;	table[0203] = (InstPtr) case203;	table[0204] = (InstPtr) case204;	table[0205] = (InstPtr) case205;	table[0206] = (InstPtr) case206;	table[0207] = (InstPtr) case207;	table[0210] = (InstPtr) case210;	table[0211] = (InstPtr) case211;	table[0212] = (InstPtr) case212;	table[0213] = (InstPtr) case213;	table[0214] = (InstPtr) case214;	table[0215] = (InstPtr) case215;	table[0216] = (InstPtr) case216;	table[0217] = (InstPtr) case217;	table[0220] = (InstPtr) case220;	table[0221] = (InstPtr) case221;	table[0222] = (InstPtr) case222;	table[0223] = (InstPtr) case223;	table[0224] = (InstPtr) case224;	table[0225] = (InstPtr) case225;	table[0226] = (InstPtr) case226;	table[0227] = (InstPtr) case227;	table[0230] = (InstPtr) case230;	table[0231] = (InstPtr) case231;	table[0232] = (InstPtr) case232;	table[0233] = (InstPtr) case233;	table[0234] = (InstPtr) case234;	table[0235] = (InstPtr) case235;	table[0236] = (InstPtr) case236;	table[0237] = (InstPtr) case237;	table[0240] = (InstPtr) case240;	table[0241] = (InstPtr) case241;	table[0242] = (InstPtr) case242;	table[0243] = (InstPtr) case243;	table[0244] = (InstPtr) case244;	table[0245] = (InstPtr) case245;	table[0246] = (InstPtr) case246;	table[0247] = (InstPtr) case247;	table[0250] = (InstPtr) case250;	table[0251] = (InstPtr) case251;	table[0252] = (InstPtr) case252;	table[0253] = (InstPtr) case253;	table[0254] = (InstPtr) case254;	table[0255] = (InstPtr) case255;	table[0256] = (InstPtr) case256;	table[0257] = (InstPtr) case257;	table[0260] = (InstPtr) case260;	table[0261] = (InstPtr) case261;	table[0262] = (InstPtr) case262;	table[0263] = (InstPtr) case263;	table[0264] = (InstPtr) case264;	table[0265] = (InstPtr) case265;	table[0266] = (InstPtr) case266;	table[0267] = (InstPtr) case267;	table[0270] = (InstPtr) case270;	table[0271] = (InstPtr) case271;	table[0272] = (InstPtr) case272;	table[0273] = (InstPtr) case273;	table[0274] = (InstPtr) case274;	table[0275] = (InstPtr) case275;	table[0276] = (InstPtr) case276;	table[0277] = (InstPtr) case277;	table[0300] = (InstPtr) case300;	table[0301] = (InstPtr) case301;	table[0302] = (InstPtr) case302;	table[0303] = (InstPtr) case303;	table[0304] = (InstPtr) case304;	table[0305] = (InstPtr) case305;	table[0306] = (InstPtr) case306;	table[0307] = (InstPtr) case307;	table[0310] = (InstPtr) case310;	table[0311] = (InstPtr) case311;	table[0312] = (InstPtr) case312;	table[0313] = (InstPtr) case313;	table[0314] = (InstPtr) case314;	table[0315] = (InstPtr) case315;	table[0316] = (InstPtr) case316;	table[0317] = (InstPtr) case317;	table[0320] = (InstPtr) case320;	table[0321] = (InstPtr) case321;	table[0322] = (InstPtr) case322;	table[0323] = (InstPtr) case323;	table[0324] = (InstPtr) case324;	table[0325] = (InstPtr) case325;	table[0326] = (InstPtr) case326;	table[0327] = (InstPtr) case327;	table[0330] = (InstPtr) case330;	table[0331] = (InstPtr) case331;	table[0332] = (InstPtr) case332;	table[0333] = (InstPtr) case333;	table[0334] = (InstPtr) case334;	table[0335] = (InstPtr) case335;	table[0336] = (InstPtr) case336;	table[0337] = (InstPtr) case337;	table[0340] = (InstPtr) case340;	table[0341] = (InstPtr) case341;	table[0342] = (InstPtr) case342;	table[0343] = (InstPtr) case343;	table[0344] = (InstPtr) case344;	table[0345] = (InstPtr) case345;	table[0346] = (InstPtr) case346;	table[0347] = (InstPtr) case347;	table[0350] = (InstPtr) case350;	table[0351] = (InstPtr) case351;	table[0352] = (InstPtr) case352;	table[0353] = (InstPtr) case353;	table[0354] = (InstPtr) case354;	table[0355] = (InstPtr) case355;	table[0356] = (InstPtr) case356;	table[0357] = (InstPtr) case357;	table[0360] = (InstPtr) case360;	table[0361] = (InstPtr) case361;	table[0362] = (InstPtr) case362;	table[0363] = (InstPtr) case363;	table[0364] = (InstPtr) case364;	table[0365] = (InstPtr) case365;	table[0366] = (InstPtr) case366;	table[0367] = (InstPtr) case367;	table[0370] = (InstPtr) case370;	table[0371] = (InstPtr) case371;	table[0372] = (InstPtr) case372;	table[0373] = (InstPtr) case373;	table[0374] = (InstPtr) case374;	table[0375] = (InstPtr) case375;	table[0376] = (InstPtr) case376;	table[0377] = (InstPtr) case377;     goto nextopcode;I 29#else	/* This is the optable for 386's under gcc */asm volatile("	.data \n\	.align 4");asm volatile("optable:	\n\	.long	_op000 \n\	.long	_op001 \n\	.long	_op002 \n\	.long	_op003 \n\	.long	_op004 \n\	.long	_op005 \n\	.long	_op006 \n\	.long	_op007 \n\	.long	_op010 \n\	.long	_op011 \n\	.long	_op012 \n\	.long	_op013 \n\	.long	_op014 \n\	.long	_op015 \n\	.long	_op016 \n\	.long	_op017 \n\	.long	_op020 \n\	.long	_op021 \n\	.long	_op022 \n\	.long	_op023 \n\	.long	_op024 \n\	.long	_op025 \n\	.long	_op026 \n\	.long	_op027 \n\	.long	_op030 \n\	.long	_op031 \n\	.long	_op032 \n\	.long	_op033 \n\");asm volatile("\n\	.long	_op034 \n\	.long	_op035 \n\	.long	_op036 \n\	.long	_op037 \n\	.long	_op040 \n\	.long	_op041 \n\	.long	_op042 \n\	.long	_op043 \n\	.long	_op044 \n\	.long	_op045 \n\	.long	_op046 \n\	.long	_op047 \n\	.long	_op050 \n\	.long	_op051 \n\	.long	_op052 \n\	.long	_op053 \n\	.long	_op054 \n\	.long	_op055 \n\	.long	_op056 \n\	.long	_op057 \n\	.long	_op060 \n\	.long	_op061 \n\	.long	_op062 \n\	.long	_op063 \n\	.long	_op064 \n\	.long	_op065 \n\	.long	_op066 \n\	.long	_op067 \n\	.long	_op070 \n\	.long	_op071 \n\	.long	_op072 \n\	.long	_op073 \n\	.long	_op074 \n\	.long	_op075 \n\	.long	_op076 \n\	.long	_op077 \n\	.long	_op100 \n\	.long	_op101 \n\	.long	_op102 \n\	.long	_op103 \n\	.long	_op104 \n\	.long	_op105 \n\	.long	_op106 \n\	.long	_op107 \n\	.long	_op110 \n\	.long	_op111 \n\	.long	_op112 \n\	.long	_op113 \n\	.long	_op114 \n\	.long	_op115 \n\	.long	_op116 \n\	.long	_op117 \n\	.long	_op120 \n\	.long	_op121 \n\	.long	_op122 \n\	.long	_op123 \n\	.long	_op124 \n\	.long	_op125 \n\	.long	_op126 \n\	.long	_op127 \n\	.long	_op130 \n\	.long	_op131 \n\	.long	_op132 \n\	.long	_op133 \n\	.long	_op134 \n\	.long	_op135 \n\	.long	_op136 \n\	.long	_op137 \n\	.long	_op140 \n\	.long	_op141 \n\	.long	_op142 \n\	.long	_op143 \n\	.long	_op144 \n\	.long	_op145 \n\	.long	_op146 \n\	.long	_op147 \n\	.long	_op150 \n\	.long	_op151 \n\	.long	_op152 \n\	.long	_op153 \n\	.long	_op154 \n\	.long	_op155 \n\	.long	_op156 \n\	.long	_op157 \n\	.long	_op160 \n\	.long	_op161 \n\	.long	_op162 \n\	.long	_op163 \n\	.long	_op164 \n\	.long	_op165 \n\	.long	_op166 \n\	.long	_op167 \n\	.long	_op170 \n\	.long	_op171 \n\	.long	_op172 \n\	.long	_op173 \n\	.long	_op174 \n\	.long	_op175 \n\	.long	_op176 \n\	.long	_op177 \n\	.long	_op200 \n\	.long	_op201 \n\	.long	_op202 \n\	.long	_op203 \n\	.long	_op204 \n\	.long	_op205 \n\	.long	_op206 \n\	.long	_op207 \n\	.long	_op210 \n\	.long	_op211 \n\	.long	_op212 \n\	.long	_op213 \n\	.long	_op214 \n\	.long	_op215 \n\	.long	_op216 \n\	.long	_op217 \n\	.long	_op220 \n\	.long	_op221 \n\	.long	_op222 \n\	.long	_op223 \n\	.long	_op224 \n\	.long	_op225 \n\	.long	_op226 \n\	.long	_op227 \n\	.long	_op230 \n\	.long	_op231 \n\	.long	_op232 \n\	.long	_op233 \n\	.long	_op234 \n\	.long	_op235 \n\	.long	_op236 \n\	.long	_op237 \n\	.long	_op240 \n\	.long	_op241 \n\	.long	_op242 \n\	.long	_op243 \n\	.long	_op244 \n\	.long	_op245 \n\	.long	_op246 \n\	.long	_op247 \n\	.long	_op250 \n\	.long	_op251 \n\	.long	_op252 \n\	.long	_op253 \n\	.long	_op254 \n\	.long	_op255 \n\	.long	_op256 \n\	.long	_op257 \n\	.long	_op260 \n\	.long	_op261 \n\	.long	_op262 \n\	.long	_op263 \n\	.long	_op264 \n\	.long	_op265 \n\	.long	_op266 \n\	.long	_op267 \n\	.long	_op270 \n\	.long	_op271 \n\	.long	_op272 \n\	.long	_op273 \n\	.long	_op274 \n\	.long	_op275 \n\	.long	_op276 \n\	.long	_op277 \n\	.long	_op300 \n\	.long	_op301 \n\	.long	_op302 \n\	.long	_op303 \n\	.long	_op304 \n\	.long	_op305 \n\	.long	_op306 \n\	.long	_op307 \n\	.long	_op310 \n\	.long	_op311 \n\	.long	_op312 \n\	.long	_op313 \n\	.long	_op314 \n\	.long	_op315 \n\	.long	_op316 \n\	.long	_op317 \n\	.long	_op320 \n\	.long	_op321 \n\	.long	_op322 \n\	.long	_op323 \n\	.long	_op324 \n\	.long	_op325 \n\	.long	_op326 \n\	.long	_op327 \n\	.long	_op330 \n\	.long	_op331 \n\	.long	_op332 \n\	.long	_op333 \n\	.long	_op334 \n\	.long	_op335 \n\	.long	_op336 \n\	.long	_op337 \n\	.long	_op340 \n\	.long	_op341 \n\	.long	_op342 \n\	.long	_op343 \n\	.long	_op344 \n\	.long	_op345 \n\	.long	_op346 \n\	.long	_op347 \n\	.long	_op350 \n\	.long	_op351 \n\	.long	_op352 \n\	.long	_op353 \n\	.long	_op354 \n\	.long	_op355 \n\	.long	_op356 \n\	.long	_op357 \n\	.long	_op360 \n\	.long	_op361 \n\	.long	_op362 \n\	.long	_op363 \n\	.long	_op364 \n\	.long	_op365 \n\	.long	_op366 \n\	.long	_op367 \n\	.long	_op370 \n\	.long	_op371 \n\	.long	_op372 \n\	.long	_op373 \n\	.long	_op374 \n\	.long	_op375 \n\	.long	_op376 \n\	.long	_op377 \n\	 .text");D 33#endif ISCE 33I 33#endif /* ISC */E 33E 29D 28#endifE 28I 28D 33#endif OPDISPE 33I 33#endif /* OPDISP */E 33E 28     }int retfun() {return(0);}do_brk() {}E 1