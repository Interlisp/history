h46652s 00004/00004/00064d D 2.14 92/04/21 17:02:53 sybalsky 16 15c shortening file names for DOS \nes 00000/00000/00068d D 2.13 90/04/20 01:19:30 sybalsky 15 14c AIX:  shortening file names, bulk change.es 00002/00002/00066d D 2.12 90/02/19 09:59:45 sybalsky 14 13c Add a pointer cast to remove warning after reworkes 00000/00000/00068d D 2.11 90/02/19 09:56:58 sybalsky 13 12c es 00039/00021/00029d D 2.10 90/02/19 09:43:16 sybalsky 12 11c Converted One-D Array abs refs to OneDArray struct refs for 386es 00005/00006/00045d D 2.9 88/10/12 14:39:49 krivacic 11 10c new out-of-line interfacees 00015/00060/00036d D 2.8 88/07/06 14:39:43 charnley 10 9c uses new select macro with modified select order.es 00004/00016/00092d D 2.7 88/06/07 15:46:13 charnley 9 8c using macro GetPoses 00001/00001/00107d D 2.6 88/05/25 17:36:50 charnley 8 7c deleted misplaced asteriskes 00000/00000/00108d D 2.5 88/05/25 17:35:28 charnley 7 6c noes 00002/00002/00106d D 2.4 88/05/25 16:58:37 charnley 6 5c changed err typees 00001/00001/00107d D 2.3 88/05/25 16:12:16 charnley 5 4c fixed cc bug.es 00004/00120/00104d D 2.2 88/05/25 15:21:43 charnley 4 3c removed unused code, fixed bug in signed 32 bit casees 00000/00000/00224d D 2.1 88/05/17 09:21:59 hayata 3 2c Version up to 2.1es 00001/00007/00223d D 1.2 88/04/21 09:37:24 charnley 2 1c changed array-type maskes 00230/00000/00000d D 1.1 88/03/30 14:05:15 charnley 1 0c date and time created 88/03/30 14:05:15 by charnleyeuUtTI 1D 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";/*	array3.c */E 12I 12/* This is G-file @(#) array3.c Version 2.9 (10/12/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) array3.c	2.9 10/12/88";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************//************************************************************************//*									*//*			     A R R A Y 3 . C				*//*									*//*	Contains:	N_OP_aref1					*//*									*//************************************************************************/E 12#include <stdio.h>#include "lispemul.h"D 16#include "lispglobal.h"#include "address68k.h"E 16I 16#include "lspglob.h"#include "adr68k.h"E 16#include "lispmap.h"D 16#include "lisptypes.h"#include "emulglobal.h"E 16I 16#include "lsptypes.h"#include "emlglob.h"E 16#include "arith.h"#include "my.h"D 2#include "tos1defs.h" #include "tosretmacro.h"#include "tosfuncallmacro.h"#include "inlinedefsC.h"#include "inlinedefs68K.h" #include "fastinlinedefs68K.h"E 2D 10/************************************************************ OP_aref1   -- op 266   (array index)D 4   Array data structure :Word	Content0	Hi word of base pointer1	Low word of base pointer2	Flag (8 bits), Type (4 bits), Size (bits per element, 4 bits)3	Offset4	Fill pointer5	Total size	typenumber:		type = 7 & (typenumber >> 4)		0  unsigned		1  signed		2  pointer		3  float		4  character		5  xpointer		6  illegal		7  illegal		size = 7 & typenumber		0 1 bit   :		1 2 bits  :		2 4 bits  :		3 8 bits  :		4 16 bits : 		5 24 bits :		6 32 bits :		7 64 bits :	E 4type    size    typenumber  0       0             0      unsigned  : 1 bit  0       3             3      unsigned  : 8 bits  0       4             4      unsigned  : 16 bits  1       4            20      signed    : 16 bits  1       6            22      signed    : 32 bits  2       6            38      pointer   : 32 bits  3       6            54      float     : 32 bits  4       3            67      character : 8 bits  4       4            68      character : 16 bits  5       6            86      Xpointer  : 32 bits***********************************************************/E 10D 4/***	OP_aref1   -- op 266   (array index)   ***/OP_myaref1(){register LispPTR baseL;register short typenumber;register int index;register DLword *array;LispPTR temp;	/*	for CREATECELL  */register DLword	*wordp;DLword	*createcell68k();      /*  verify array  */      temp = *((LispPTR *)(CurrentStackPTR));      if (GetTypeNumber(temp) != TYPE_ONED_ARRAY) gotoufn;      array = Addr68k_from_LADDR(temp);      /*  test and setup index  */      if ((0xFFFF0000 & TopOfStack) != S_POSITIVE) gotoufn;      index = 0xFFFF & TopOfStack;      if (index >= *((DLword *)(array + 5))) gotoufn;      index += *((DLword *)(array + 3));      /*  setup typenumber  */      typenumber = 0xFFFF & *((DLword *)(array + 2));      /*  setup base  */      baseL = *((LispPTR *)(array));      /*  disp on type  */    switch (typenumber) {      case 0: /* unsigned : 1 bit per element */         TopOfStack = ((*(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1;         TopOfStack |= S_POSITIVE;         break;      case 3: /* unsigned : 8 bits per element */         TopOfStack = (*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF;         TopOfStack |= S_POSITIVE;         break;      case 4: /* unsigned : 16 bits per element */         TopOfStack = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;         TopOfStack |= S_POSITIVE;         break;      case 20: /* signed : 16 bits */         TopOfStack = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;         if (TopOfStack & 0x8000) TopOfStack |= S_NEGATIVE;         else TopOfStack |= S_POSITIVE;         break;      case 22: /* signed : 32 bits */         wordp = createcell68k(TYPE_FIXP);         *((int *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);         TopOfStack = LADDR_from_68k(wordp);         break;      case 38: /* pointer : 32 bits */         TopOfStack = *(((int *)Addr68k_from_LADDR(baseL)) + index);         break;      case 54: /* Float : 32 bits */         wordp = createcell68k(TYPE_FLOATP);         *((float *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);         TopOfStack = LADDR_from_68k(wordp);         break;      case 67: /* Character :  8 bits */         TopOfStack = (*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF;         TopOfStack |= S_CHARACTER;         break;      case 68: /* Character :  16 bits */         TopOfStack = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;         TopOfStack |= S_CHARACTER;	   break;      case 86: /* XPointer : 32 bits */         TopOfStack = *(((int *)Addr68k_from_LADDR(baseL)) + index);         break;      default: /* Illegal or Unimplemented */        gotoufn;    }/* end switch typenumber */ CurrentStackPTR -= 2;PC++;} /*  end OP_claref()  */E 4/***	N_OP_aref1   -- op 266   (array index)   ***/D 6N_OP_aref1(arrayarg, index, error_addr)D 4int *error_addr;E 4I 4int error_addr;E 6I 6D 8N_OP_aref1(arrayarg, index, *error_addr)E 8I 8D 9N_OP_aref1(arrayarg, index, error_addr)E 9I 9D 11N_OP_aref1(arrayarg, inx, error_addr)E 9E 8int *error_addr;E 11I 11N_OP_aref1(arrayarg, inx)E 11E 6E 4D 9register int index;LispPTR arrayarg;E 9I 9D 12register LispPTR arrayarg, inx;E 9{E 12I 12  register LispPTR arrayarg, inx;  {E 12D 12register LispPTR baseL;D 9register int typenumber;E 9I 9D 10register int typenumber, index;E 10I 10register int type, index;E 10E 9register DLword *arrayblk;LispPTR temp;register int result;E 12I 12    register LispPTR baseL;    register int type, index;    register OneDArray *arrayblk;    LispPTR temp;    register int result;E 12	/*	for CREATECELL  */D 12register DLword	*wordp;DLword	*createcell68k();E 12I 12    register DLword	*wordp;    DLword	*createcell68k();E 12D 10      /*  verify array  */      if (GetTypeNumber(arrayarg) != TYPE_ONED_ARRAY) ERROR_EXIT(error_addr);      arrayblk = Addr68k_from_LADDR(arrayarg);E 10I 10  /*  verify array  */D 11  if (GetTypeNumber(arrayarg) != TYPE_ONED_ARRAY) ERROR_EXIT(error_addr);E 11I 11D 12  if (GetTypeNumber(arrayarg) != TYPE_ONED_ARRAY) ERROR_EXIT(inx);E 11  arrayblk = Addr68k_from_LADDR(arrayarg);E 12I 12    if (GetTypeNumber(arrayarg) != TYPE_ONED_ARRAY) ERROR_EXIT(inx);D 14    arrayblk = Addr68k_from_LADDR(arrayarg);E 14I 14    arrayblk = (OneDArray *)Addr68k_from_LADDR(arrayarg);E 14E 12E 10D 10      /*  test and setup index  */D 4      if ((0xFFFF0000 & index) != S_POSITIVE) ERROR_EXIT(error_addr);      index = 0xFFFF & index;E 4I 4D 9      if ((0xFF0000 & index) != S_POSITIVE) ERROR_EXIT(error_addr);      index &= 0xFFFF;E 9I 9      N_GetPos(inx, index, error_addr);E 9E 4      if (index >= *((DLword *)(arrayblk + 5))) ERROR_EXIT(error_addr);      index += *((DLword *)(arrayblk + 3));E 10I 10  /*  test and setup index  */D 11  N_GetPos(inx, index, error_addr);  if (index >= *((DLword *)(arrayblk + 5))) ERROR_EXIT(error_addr);E 11I 11D 12  N_GetPos(inx, index, inx);  if (index >= *((DLword *)(arrayblk + 5))) ERROR_EXIT(inx);E 11  index += *((DLword *)(arrayblk + 3));E 12I 12    N_GetPos(inx, index, inx);    if (index >= arrayblk->totalsize) ERROR_EXIT(inx);D 14    index += arrayblk->offset);E 14I 14    index += arrayblk->offset;E 14E 12E 10D 10      /*  setup typenumber  */D 2      typenumber = 0xFFFF & *((DLword *)(arrayblk + 2));E 2I 2      typenumber = 0xFF & *((DLword *)(arrayblk + 2));E 10I 10  /*  setup typenumber  */D 12  type = 0xFF & *((DLword *)(arrayblk + 2));E 12I 12    type = 0xFF & arrayblk->typenumber;E 12E 10E 2D 10      /*  setup base  */      baseL = *((LispPTR *)(arrayblk));E 10I 10  /*  setup base  */D 12  baseL = *((LispPTR *)(arrayblk));E 12I 12    baseL = arrayblk->base;E 12E 10D 10      /*  disp on type  */    switch (typenumber) {      case 0: /* unsigned : 1 bit per element */         return(S_POSITIVE | (((*(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1));D 9         break;E 9      case 3: /* unsigned : 8 bits per element */         return(S_POSITIVE | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF));D 9         break;E 9      case 4: /* unsigned : 16 bits per element */         return(S_POSITIVE | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF));D 9         break;E 9      case 20: /* signed : 16 bits */         result = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;         if (result & 0x8000) return(result | S_NEGATIVE);         else return(result | S_POSITIVE);D 9         break;E 9      case 22: /* signed : 32 bits */         result = *(((int *)Addr68k_from_LADDR(baseL)) + index);D 4         N_ARITH_SWITCH(result);E 4I 4D 5         return(N_ARITH_SWITCH(result));E 5I 5         N_ARITH_SWITCH(result);E 5E 4D 9         break;E 9      case 38: /* pointer : 32 bits */         return(*(((int *)Addr68k_from_LADDR(baseL)) + index));D 9         break;E 9      case 54: /* Float : 32 bits */         wordp = createcell68k(TYPE_FLOATP);         *((int *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);         return(LADDR_from_68k(wordp));D 9         break;E 9      case 67: /* Character :  8 bits */         return(S_CHARACTER | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF));D 9         break;E 9      case 68: /* Character :  16 bits */         return(S_CHARACTER | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF));D 9	   break;E 9      case 86: /* XPointer : 32 bits */         return(*(((int *)Addr68k_from_LADDR(baseL)) + index));D 9         break;E 9      default: /* Illegal or Unimplemented */        ERROR_EXIT(error_addr);    }/* end switch typenumber */E 10I 10  /*  disp on type  */D 11  aref_switch(type, error_addr);E 11I 11D 12  aref_switch(type, inx);E 12I 12    aref_switch(type, inx);E 12E 11E 10} /*  end N_OP_aref1()  */D 10	/*  end module  */E 10E 1