h39354s 00013/00024/00300d D 2.19 92/05/29 10:17:06 sybalsky 27 26c 386 Unix inline arithmetic cleanupes 00004/00000/00320d D 2.18 92/05/27 19:10:49 sybalsky 26 25c start of 386 unix retrofites 00004/00004/00316d D 2.17 92/04/21 17:00:58 sybalsky 25 24c shortening file names for DOS \nes 00000/00000/00320d D 2.16 90/04/20 01:17:13 sybalsky 24 23c  bulk change.es 00002/00002/00318d D 2.15 90/04/16 10:59:46 sybalsky 23 22c es 00008/00008/00312d D 2.14 90/04/02 17:14:29 sybalsky 22 21c 386i speedupses 00001/00000/00319d D 2.13 90/03/19 11:38:15 takeshi 21 20c Floating mode setes 00010/00005/00309d D 2.12 90/02/19 09:19:34 sybalsky 20 19c Remove some opcode #defines that weren't used.es 00022/00000/00292d D 2.11 89/12/29 12:57:18 sybalsky 19 18c Changes from Savoires 00012/00015/00280d D 2.10 88/12/01 13:47:55 krivacic 18 17c Add SUN3_OS4_IL & SUN3_OS3_OR_OS4_IL Flags, and move asm labels to inlines.es 00020/00030/00275d D 2.9 88/11/30 19:54:53 shih 17 16c minor cleanupes 00049/00035/00256d D 2.8 88/10/13 19:27:37 krivacic 16 15c new ifdef varses 00069/00081/00222d D 2.7 88/10/12 14:38:49 krivacic 15 14c new out-of-line interfacees 00070/00012/00233d D 2.6 88/10/10 14:03:41 krivacic 14 13c sun3/4 mergees 00001/00001/00244d D 2.5 88/09/27 16:47:43 shih 13 12c sp correctiones 00000/00494/00245d D 2.4 88/09/27 15:46:58 krivacic 12 11c mergees 00016/00005/00723d D 2.3 88/06/03 17:40:58 krivacic 11 10c have plus2 & difference call floating pt. on type errores 00003/00000/00725d D 2.2 88/05/27 14:48:27 krivacic 10 9c C_ONLY ifdefes 00000/00000/00725d D 2.1 88/05/17 09:21:36 hayata 9 8c Version up to 2.1es 00075/00007/00650d D 1.6 88/05/16 11:41:42 krivacic 8 7c iplus2 idifference N_IGETNUMBERes 00002/00002/00655d D 1.5 88/03/13 14:32:01 hayata 7 6c Add SCCS key id (%Z%)es 00017/00096/00640d D 1.4 88/03/09 18:25:21 krivacic 6 5c Native interface functions completedes 00000/00000/00736d D 1.3 88/03/09 15:45:35 krivacic 5 4c More Native Fn interface rtnses 00271/00002/00465d D 1.2 88/03/09 13:32:39 krivacic 4 1c Added Native Interface Fnses 00002/00002/00465d R 1.2 88/03/09 13:25:57 krivacic 3 1c Added Native Interface Fnses 00002/00002/00465d R 1.2 88/03/07 14:57:26 krivacic 2 1c Added Native Interface Fnses 00467/00000/00000d D 1.1 88/02/24 16:55:36 hayata 1 0c date and time created 88/02/24 16:55:36 by hayataeuUtTI 1D 7/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 7I 7D 15/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 15I 15D 17/* This is G-file @(#) arith2.c Version 2.6 (10/10/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) arith2.c	2.6 10/10/88";E 17I 17D 22/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 22I 22D 23/* @(#) arith2.c Version 2.13 (3/19/90). copyright envos & Fuji Xerox  */static char *id = "@(#) arith2.c	2.13 3/19/90		(envos & Fuji Xerox)";E 23I 23/* @(#) arith2.c Version 2.13 (3/19/90). copyright Venue & Fuji Xerox  */static char *id = "@(#) arith2.c	2.13 3/19/90		(Venue & Fuji Xerox)";E 23E 22I 19/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 19E 17E 15E 7/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 13 *	Auther	:	Hiroshi Hayata	E 13I 13D 17 *	Author	:	Hiroshi Hayata	E 17I 17 *	Author	:	Hiroshi HayataE 17E 13 */#include <stdio.h>#include "lispemul.h"D 25#include "lispglobal.h"#include "emulglobal.h"#include "address68k.h"E 25I 25#include "lspglob.h"#include "emlglob.h"#include "adr68k.h"E 25#include "lispmap.h"D 25#include "lisptypes.h"E 25I 25#include "lsptypes.h"E 25I 21#include "fp.h"E 21#include "arith.h"I 26D 27#ifdef GCC386E 27I 27#ifdef ARITHINLINEE 27#include "arith2.h"#endifE 26D 20#define	SLOWPLUS2	324#define	SLOWIPLUS2	330#define	SLOWDIFFERENCE	325#define	SLOWIDIFFERENCE	331E 20DLword	*createcell68k();I 10D 12#ifdef C_ONLYE 12E 10/************************************************************D 12OP_plus2	entry		PLUS2		OPCODE[0324]	entry		IPLUS2		OPCODE[0330]	1.	<<Entrer>>		*((int *)(CurrentStackPTR))	: argument 1 of PLUS2		TopOfStack			: argument 2 of PLUS2		They are SMALLPL or SMALLNEG, Lisp address.	2.	add argument 1 and argument 2.	3.	<<Exit>>		TopOfStack			: added value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_plus2(){register int	arg1,arg2;register int	result;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_plus2()\n");#endif/*CSP	GetNumber( *((int *)(CurrentStackPTR-1)), arg1 );	*/	GetNumber( *((int *)CurrentStackPTR), arg1 );	GetNumber( TopOfStack, arg2 );	if( (MIN_FIXP <= (arg1 + arg2)) && ((arg1 + arg2) <= MAX_FIXP) ){		/* MIN_FIXP <= (arg1 + arg2) <= MAX_FIXP */		result = arg1 + arg2;	 		if(0 <= result){			if(result <= MAX_SMALL)				TopOfStack = S_POSITIVE | result;			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}else{			if(MIN_SMALL <= result)				TopOfStack = S_NEGATIVE | (0xFFFF & result);			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);	}		}/* end if(0 <= result).... */	}else{		/**** call Lisp Func. ****/		if((0xFF & (*PC)) == SLOWPLUS2){			ufn(SLOWPLUS2);			return;		}else{			ufn(SLOWIPLUS2);			return;		}	}	CurrentStackPTR -= 2;	++PC;}I 4E 4/************************************************************OP_difference	entry		DIFFERENCE		OPCODE[0325]	entry		IDIFFERENCE		OPCODE[0331]	1.	<<Entrer>>		*((int *)(CurrentStackPTR))	: argument 1 of PLUS2		TopOfStack			: argument 2 of PLUS2		They are SMALLPL or SMALLNEG, Lisp address.	2.	subtract argument 2 from argument 1.			(arg1 - arg2)	3.	<<Exit>>		TopOfStack			: subtrated value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_difference(){register int	arg1,arg2;register int	result;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_difference()\n");#endifD 4/*CSP	GetNumber( *((int *)(CurrentStackPTR-1)), arg1);	*/E 4	GetNumber( *((int *)(CurrentStackPTR)), arg1);	GetNumber( TopOfStack, arg2 );	if( (MIN_FIXP <= (arg1 - arg2)) && ((arg1 - arg2) <= MAX_FIXP) ){		/* MIN_FIXP <= (arg1 - arg2) <= MAX_FIXP */		result = arg1 - arg2;	 		if(0 <= result){			if(result <= MAX_SMALL)				TopOfStack = S_POSITIVE | result;			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}else{			if(MIN_SMALL <= result)				TopOfStack = S_NEGATIVE | (0xFFFF & result);			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}/* end if(0 <= result).... */	}else{		/**** call Lisp Func. ****/		if((0xFF & (*PC)) == SLOWDIFFERENCE){			ufn(SLOWDIFFERENCE);			return;		}else{			ufn(SLOWIDIFFERENCE);			return;		}	}	CurrentStackPTR -= 2;	++PC;}D 4E 4/************************************************************OP_logxor	entry		LOGXOR2		OPCODE[0346]	1.	<<Entrer>>		*((int *)(CurrentStackPTR))	: argument 1 of LOGXOR		TopOfStack			: argument 2 of LOGXOR		They are SMALLPL or SMALLNEG, Lisp address.	2.	ex-or argument 1 and argument 2.	3.	<<Exit>>		TopOfStack			: ex-ored value			It is SMALLPL or SMALLNEG, Lisp address.************************************************************/OP_logxor(){register int	arg1,arg2;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_logxor()\n");#endif/*CSP	GetNumber( *((int *)(CurrentStackPTR-1)), arg1);	*/	GetNumber( *((int *)(CurrentStackPTR)), arg1);	GetNumber( TopOfStack, arg2 );	arg1 ^= arg2;	switch(arg1 & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg1;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg1);			break;		default:			/* arg1 is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg1;			TopOfStack = LADDR_from_68k(wordp);			break;	}	CurrentStackPTR -= 2;	++PC;}/************************************************************OP_logand	entry		LOGAND2		OPCODE[0345]	1.	<<Entrer>>		*((int *)(CurrentStackPTR))	: argument 1 of LOGAND		TopOfStack			: argument 2 of LOGAND		They are SMALLPL or SMALLNEG, Lisp address.	2.	and argument 1 and argument 2.	3.	<<Exit>>		TopOfStack			: anded value			It is SMALLPL or SMALLNEG, Lisp address.************************************************************/OP_logand(){register int	arg1,arg2;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_logand()\n");#endif/*CSP	GetNumber( *((int *)(CurrentStackPTR-1)), arg1 );	*/	GetNumber( *((int *)(CurrentStackPTR)), arg1 );	GetNumber( TopOfStack, arg2 );	arg1 &= arg2;	switch(arg1 & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg1;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg1);			break;		default:			/* arg1 is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg1;			TopOfStack = LADDR_from_68k(wordp);			break;	}	CurrentStackPTR -= 2;	++PC;}/************************************************************OP_logor	entry		LOGOR2		OPCODE[0344]	1.	<<Entrer>>		*((int *)(CurrentStackPTR))	: argument 1 of LOGOR		TopOfStack			: argument 2 of LOGOR		They are SMALLPL or SMALLNEG, Lisp address.	2.	or argument 1 and argument 2.	3.	<<Exit>>		TopOfStack			: ored value			It is SMALLPL or SMALLNEG, Lisp address.************************************************************/OP_logor(){register int	arg1,arg2;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_logor()\n");#endif/*CSP	GetNumber( *((int *)(CurrentStackPTR-1)), arg1 );	*/	GetNumber( *((int *)(CurrentStackPTR)), arg1 );	GetNumber( TopOfStack, arg2 );	arg1 |= arg2;	switch(arg1 & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg1;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg1);			break;		default:			/* arg1 is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg1;			TopOfStack = LADDR_from_68k(wordp);			break;	}	CurrentStackPTR -= 2;	++PC;}/************************************************************OP_greaterp	entry		GREATERP		OPCODE[0363]	entry		IGREATERP		OPCODE[0361]	1.	<<Entrer>>		*((int *)(CurrentStackPTR))	: argument 1 of GREATERP		TopOfStack			: argument 2 of GREATERP		They are SMALLPL or SMALLNEG, Lisp address.	2.	compare argument 1 and argument 2.			arg1 > arg2  -- T			arg1 <= arg2 -- NIL	3.	<<Exit>>		TopOfStack			: T or NIL	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_greaterp(){register int	arg1,arg2;#ifdef	TRACE	printPC();	printf("TRACE: OP_greaterp()\n");#endif/*	GetNumber( *((int *)(CurrentStackPTR-1)), arg1 );	*/	GetNumber( *((int *)(CurrentStackPTR)), arg1 );	GetNumber( TopOfStack, arg2 );	if(arg1 > arg2)		TopOfStack = ATOM_T;	else		TopOfStack = NIL_PTR;	CurrentStackPTR -= 2;	++PC;}/************************************************************OP_iplusn	entry		IPLUS.N		OPCODE[0335]	1.	<<Entrer>>		TopOfStack	: argument 1 of IPLUS.N		alpha		: argument 2 of IPLUS.N		TopOfStack is SMALLPL or SMALLNEG, Lisp address.		alpha is immidiate data.	2.	add argument 1 and argument 2.			(arg1 + arg2)	3.	<<Exit>>		TopOfStack			: added value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_iplusn(){register int	arg1,arg2;register int	result;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_iplusn()\n");#endif	GetNumber( TopOfStack, arg1 );	arg2 = 0xFF & (*(PC + 1));	if( (MIN_FIXP <= (arg1 + arg2)) && ((arg1 + arg2) <= MAX_FIXP) ){		/* MIN_FIXP <= (arg1 + arg2) <= MAX_FIXP */		result = arg1 + arg2;	 		if(0 <= result){			if(result <= MAX_SMALL)				TopOfStack = S_POSITIVE | result;			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}else{			if(MIN_SMALL <= result)				TopOfStack = S_NEGATIVE | (0xFFFF & result);			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}/* end if(0 <= result).... */	}else{		/**** call Lisp Func. ****/		ufn(SLOWIPLUS2);		return;	}	/**CurrentStackPTR -= 2; ** BUG **/	PC += 2;}/************************************************************OP_idifferencen	entry		IDIFFERENCE.N		OPCODE[0336]	1.	<<Entrer>>		TopOfStack	: argument 1 of IDIFFERENCE.N		alpha		: argument 2 of IDIFFERENCE.N		TopOfStack is SMALLPL or SMALLNEG, Lisp address.		alpha is immidiate data.	2.	subtract argument 2 from argument 1.			(arg1 - arg2)	3.	<<Exit>>		TopOfStack			: subtracted value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_idifferencen(){register int	arg1,arg2;register int	result;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_idifferencen()\n");#endif	GetNumber( TopOfStack, arg1 );	arg2 = 0xFF & (*(PC + 1));	if( (MIN_FIXP <= (arg1 - arg2)) && ((arg1 - arg2) <= MAX_FIXP) ){		/* MIN_FIXP <= (arg1 - arg2) <= MAX_FIXP */		result = arg1 - arg2;	 		if(0 <= result){			if(result <= MAX_SMALL)				TopOfStack = S_POSITIVE | result;			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}else{			if(MIN_SMALL <= result)				TopOfStack = S_NEGATIVE | (0xFFFF & result);			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}/* end if(0 <= result).... */	}else{		/**** call Lisp Func. ****/		ufn(SLOWIDIFFERENCE);		return;	}	/**CurrentStackPTR -= 2; BUG **/	PC += 2;}I 4I 10#elseE 10/************************************************************E 12N_OP_plus2	entry		PLUS2		OPCODE[0324]	entry		IPLUS2		OPCODE[0330]D 15	return(a = b)E 15I 15	return(tos + b)E 15************************************************************/D 15int N_OP_plus2(b, a, error_addr)	int a, b;	int *error_addr;E 15I 15int N_OP_plus2(tosm1, tos)	int tosm1, tos;E 15{register int	arg1,arg2;register int	result;D 17register DLword	*wordp;E 17D 12#ifdef	TRACE	printPC();	printf("TRACE: N_OP_plus2()\n");#endifE 12D 17E 17D 15	N_GETNUMBER( a, arg1, doufn );	N_GETNUMBER( b, arg2, doufn );E 15I 15	N_GETNUMBER( tos, arg1, doufn );	N_GETNUMBER( tosm1, arg2, doufn );E 15I 14D 16#ifdef NOASM	result = arg1 + arg2;	if ( ((arg1>=0) == (arg2>=0)) && ((result>=0) != (arg1>=0)) )D 15		{ERROR_EXIT(error_addr);}E 15I 15		{ERROR_EXIT(tos);}E 15	N_ARITH_SWITCH(result);E 16I 16D 18#ifdef SUN3_OS3_ILE 18I 18D 22#ifdef SUN3_OS3_OR_OS4_ILE 22I 22D 27#if defined(SUN3_OS3_OR_OS4_IL) || defined(I386)E 22E 18E 16E 27I 27#ifdef ARITHINLINEE 27D 15doufn:	return(N_OP_fplus2(b,a,error_addr));E 15D 16#elseE 16E 14D 6	result = arg1 + arg2;	 	if( (MIN_FIXP <= (result)) && ((result) <= MAX_FIXP) ){		/* MIN_FIXP <= (arg1 + arg2) <= MAX_FIXP */		if(0 <= result){			if(result <= MAX_SMALL)				return(S_POSITIVE | result);			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				return(LADDR_from_68k(wordp));			}		}else{			if(MIN_SMALL <= result)				return(S_NEGATIVE | (0xFFFF & result));			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				return(LADDR_from_68k(wordp));			}		}	}E 6I 6D 17	result = plus32(arg1, arg2);	 E 17I 17	result = plus32(arg1, arg2);E 17D 27	N_ARITH_SWITCH(result);E 27I 27    PLUS_RESULT;E 27D 11asm("plus_err:");	E 6doufn:		ERROR_EXIT(error_addr);E 11I 11D 17doufn2:	asm("plus_err:");	E 17I 17D 18doufn2:	asm("plus_err:");E 18I 18D 27doufn2:	plus_err_label();E 18E 17D 15	ERROR_EXIT(error_addr);I 14doufn:	return(N_OP_fplus2(b, a, doufn2));E 15I 15	ERROR_EXIT(tos);E 15E 14E 11E 27I 16#else	result = arg1 + arg2;	if ( ((arg1>=0) == (arg2>=0)) && ((result>=0) != (arg1>=0)) )		{ERROR_EXIT(tos);}	N_ARITH_SWITCH(result);E 16I 11D 14		/* try floating pt plus */E 14I 14#endifE 14I 15doufn:	return(N_OP_fplus2(tosm1, tos));E 15D 14doufn:		return(N_OP_fplus2(b, a, doufn2));E 14E 11}I 19/************************************************************************//*									*//*			N _ O P _ i p l u s 2				*//*									*//*	Implements the IPLUS2 opcode--add the two arguments, which	*//*	must be SMALLP or FIXP						*//*									*//************************************************************************/E 19I 8D 15int N_OP_iplus2(b, a, error_addr)	int a, b;	int *error_addr;E 15I 15int N_OP_iplus2(tosm1, tos)	int tosm1, tos;E 15{register int	arg1,arg2;register int	result;D 17register DLword	*wordp;E 17D 12#ifdef	TRACE	printPC();	printf("TRACE: N_OP_iplus2()\n");#endifE 12D 17E 17D 15	N_IGETNUMBER( a, arg1, doufn );	N_IGETNUMBER( b, arg2, doufn );E 15I 15	N_IGETNUMBER( tos, arg1, doufn );	N_IGETNUMBER( tosm1, arg2, doufn );E 15I 14D 16#ifdef NOASME 16I 16D 18#ifdef SUN3_OS3_ILE 18I 18D 22#ifdef SUN3_OS3_OR_OS4_ILE 22I 22D 27#if defined(SUN3_OS3_OR_OS4_IL) || defined(I386)E 27I 27#if ARITHINLINEE 27E 22E 18D 17	result = iplus32(arg1, arg2);	 E 17I 17	result = iplus32(arg1, arg2);E 17D 27	N_ARITH_SWITCH(result);I 18dummy:	iplus_err_label();E 27I 27	IPLUS_RESULT;E 27E 18D 18asm("iplus_err:");E 18#elseE 16	result = arg1 + arg2;	if ( ((arg1>=0) == (arg2>=0)) && ((result>=0) != (arg1>=0)) )D 15		{ERROR_EXIT(error_addr);}E 15I 15		{ERROR_EXIT(tos);}E 15	N_ARITH_SWITCH(result);D 16#elseE 16E 14D 16	result = iplus32(arg1, arg2);	 	N_ARITH_SWITCH(result);asm("iplus_err:");	E 16I 14#endifE 14D 15doufn:		ERROR_EXIT(error_addr);E 15I 15doufn:		ERROR_EXIT(tos);E 15}E 8/************************************************************N_OP_difference	entry		DIFFERENCE		OPCODE[0325]	entry		IDIFFERENCE		OPCODE[0331]D 15	return(a - b)E 15I 15	return(a - tos)E 15************************************************************/D 15int N_OP_difference(a, b, error_addr)	int a, b, *error_addr;E 15I 15int N_OP_difference(tosm1, tos)	int tosm1, tos;E 15{register int	arg1,arg2;register int	result;D 6register DLword	*wordp;E 6D 12#ifdef	TRACE	printPC();	printf("TRACE: N_OP_difference()\n");#endifE 12D 17E 17D 15	N_GETNUMBER( a, arg1, doufn );	N_GETNUMBER( b, arg2, doufn );E 15I 15	N_GETNUMBER( tosm1, arg1, doufn );	N_GETNUMBER( tos, arg2, doufn );E 15D 6	result = arg1 - arg2;	 E 6I 6D 14	result = sub32(arg1, arg2);	 E 14I 14D 16#ifdef NOASM	result = arg1 - arg2;	if ( ((arg1>=0) == (arg2<0)) && ((result>=0) != (arg1>=0)) )D 15		{ERROR_EXIT(error_addr);}E 15I 15		{ERROR_EXIT(tos);}E 15E 14	N_ARITH_SWITCH(result);E 16E 6D 6	if( (MIN_FIXP <= result) && (result <= MAX_FIXP) ){		if(0 <= result){			if(result <= MAX_SMALL)				return(S_POSITIVE | result);			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				return(LADDR_from_68k(wordp));			}		}else{			if(MIN_SMALL <= result)				return(S_NEGATIVE | (0xFFFF & result));			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				return(LADDR_from_68k(wordp));			}		}/* end if(0 <= result).... */	}E 6I 6D 11asm("diff_err:");	E 6doufn:		ERROR_EXIT(error_addr);E 11I 11D 14doufn2:	asm("diff_err:");	E 14I 14D 15doufn:	return(N_OP_fdifference(a, b, error_addr));E 14E 15D 14	ERROR_EXIT(error_addr);E 14I 14D 16#elseE 16I 16D 18#ifdef SUN3_OS3_ILE 18I 18D 22#ifdef SUN3_OS3_OR_OS4_ILE 22I 22D 27#if defined(SUN3_OS3_OR_OS4_IL) || defined(I386)E 27I 27#if ARITHINLINEE 27E 22E 18E 16E 14D 14		/* try floating pt difference */E 14I 14D 17	result = sub32(arg1, arg2);	 E 17I 17	result = sub32(arg1, arg2);E 17D 27	N_ARITH_SWITCH(result);E 27I 27	DIFF_RESULT;E 27E 14I 14D 17doufn2:	asm("diff_err:");	E 17I 17D 18doufn2:	asm("diff_err:");E 18I 18D 27doufn2:	diff_err_label();E 18E 17D 15	ERROR_EXIT(error_addr);E 14doufn:	return(N_OP_fdifference(a, b, doufn2));E 15I 15	ERROR_EXIT(tos);I 16E 27#else	result = arg1 - arg2;	if ( ((arg1>=0) == (arg2<0)) && ((result>=0) != (arg1>=0)) )		{ERROR_EXIT(tos);}	N_ARITH_SWITCH(result);E 16D 17#endif	E 15E 11D 14		E 14I 14	E 17I 17#endifE 17D 15#endif		E 15I 15doufn:	return(N_OP_fdifference(tosm1, tos));D 17	E 17I 17E 17E 15E 14}I 8D 15int N_OP_idifference(a, b, error_addr)	int a, b, *error_addr;E 15I 15int N_OP_idifference(tosm1, tos)	int tosm1, tos;E 15{register int	arg1,arg2;register int	result;D 12#ifdef	TRACE	printPC();	printf("TRACE: N_OP_idifference()\n");#endifE 12D 17E 17D 15	N_IGETNUMBER( a, arg1, doufn );	N_IGETNUMBER( b, arg2, doufn );E 15I 15	N_IGETNUMBER( tosm1, arg1, doufn );	N_IGETNUMBER( tos, arg2, doufn );E 15I 14D 16#ifdef NOASM	result = arg1 - arg2;	if ( ((arg1>=0) == (arg2<0)) && ((result>=0) != (arg1>=0)) )D 15		{ERROR_EXIT(error_addr);}E 15I 15		{ERROR_EXIT(tos);}E 15	N_ARITH_SWITCH(result);E 16D 16#elseE 16I 16D 18#ifdef SUN3_OS3_ILE 18I 18D 22#ifdef SUN3_OS3_OR_OS4_ILE 22I 22D 27#if defined(SUN3_OS3_OR_OS4_IL) || defined(I386)E 27I 27#if ARITHINLINEE 27E 22E 18E 16E 14D 17	result = isub32(arg1, arg2);	 E 17I 17	result = isub32(arg1, arg2);E 17D 27	N_ARITH_SWITCH(result);D 15E 15D 16asm("idiff_err:");	E 16I 16D 18asm("idiff_err:");E 18I 18dummy:	idiff_err_label();E 27I 27    IDIFF_RESULT;E 27E 18D 17	E 17I 17E 17#elseE 16I 14I 16	result = arg1 - arg2;	if ( ((arg1>=0) == (arg2<0)) && ((result>=0) != (arg1>=0)) )		{ERROR_EXIT(tos);}	N_ARITH_SWITCH(result);E 16#endifE 14D 15doufn:		ERROR_EXIT(error_addr);E 15I 15doufn:	ERROR_EXIT(tos);E 15D 17		E 17I 17E 17}I 20E 20E 8/************************************************************D 6OP_logxorE 6I 6N_OP_logxorE 6	entry		LOGXOR2		OPCODE[0346]D 15	return(a ^ b)E 15I 15	return(tosm1 ^ tos)E 15************************************************************/D 15N_OP_logxor(a, b, error_addr)	int a, b, *error_addr;E 15I 15N_OP_logxor(tosm1, tos)	int tosm1, tos;E 15{D 14E 14D 12#ifdef	TRACE	printPC();	printf("TRACE: N_OP_logxor()\n");#endifE 12D 8	N_ARITH_BODY_2(a, b, error_addr, ^);E 8I 8D 15	N_IARITH_BODY_2(a, b, error_addr, ^);E 15I 15	N_IARITH_BODY_2(tosm1, tos, ^);E 15E 8}I 20E 20/************************************************************N_OP_logand	entry		LOGAND2		OPCODE[0345]D 15	return(a & b)E 15I 15	return(tosm1 & tos)E 15************************************************************/D 15N_OP_logand(a, b, error_addr)	int a, b, *error_addr;E 15I 15N_OP_logand(tosm1, tos)	int tosm1, tos;E 15{D 14E 14D 12#ifdef	TRACE	printPC();	printf("TRACE: N_OP_logand()\n");#endifE 12D 8	N_ARITH_BODY_2(a, b, error_addr, &);E 8I 8D 15	N_IARITH_BODY_2(a, b, error_addr, &);E 15I 15	N_IARITH_BODY_2(tosm1, tos, &);E 15E 8}I 20E 20/************************************************************N_OP_logor	entry		LOGOR2		OPCODE[0344]D 15	return(a | b)E 15I 15	return(tosm1 | tos)E 15************************************************************/D 15N_OP_logor(a, b, error_addr)	int a, b, *error_addr;E 15I 15N_OP_logor(tosm1, tos)	int tosm1, tos;E 15{D 14E 14D 12#ifdef	TRACE	printPC();	printf("TRACE: N_OP_logor()\n");#endifE 12D 8	N_ARITH_BODY_2(a, b, error_addr, |);E 8I 8D 15	N_IARITH_BODY_2(a, b, error_addr, |);E 15I 15	N_IARITH_BODY_2(tosm1, tos, |);E 15E 8}/************************************************************N_OP_greaterp	entry		GREATERP		OPCODE[0363]	entry		IGREATERP		OPCODE[0361]D 15	return(a > b)E 15I 15	return(tosm1 > tos)E 15************************************************************/D 15N_OP_greaterp(a, b, error_addr)	int a, b, *error_addr;E 15I 15N_OP_greaterp(tosm1, tos)	int tosm1, tos;E 15{D 17register int	arg1,arg2;E 17I 17register int arg1,arg2;E 17D 12#ifdef	TRACE	printPC();	printf("TRACE: N_OP_greaterp()\n");#endifE 12D 17E 17D 15	N_GETNUMBER( a, arg1, do_ufn);	N_GETNUMBER( b, arg2, do_ufn);E 15I 15	N_GETNUMBER( tosm1, arg1, do_ufn);	N_GETNUMBER( tos, arg2, do_ufn);E 15	if(arg1 > arg2)		return(ATOM_T);	else		return(NIL_PTR);D 11do_ufn:	ERROR_EXIT(error_addr);E 11I 11D 14do_ufn2: ERROR_EXIT(error_addr);E 14I 14D 15#ifdef NOASMdo_ufn:	return(N_OP_fgreaterp(a, b, error_addr));E 14I 14#elsedo_ufn2: ERROR_EXIT(error_addr);E 14do_ufn:	 return(N_OP_fgreaterp(a, b, do_ufn2));I 14#endifE 15I 15do_ufn:	 return(N_OP_fgreaterp(tosm1, tos));E 15E 14E 11}I 8D 15N_OP_igreaterp(a, b, error_addr)	int a, b, *error_addr;E 15I 15N_OP_igreaterp(tosm1, tos)	int tosm1, tos;E 15{D 17register int	arg1,arg2;E 17I 17register int arg1,arg2;E 17D 12#ifdef	TRACE	printPC();	printf("TRACE: N_OP_igreaterp()\n");#endifE 12D 17E 17D 15	N_IGETNUMBER( a, arg1, do_ufn);	N_IGETNUMBER( b, arg2, do_ufn);E 15I 15	N_IGETNUMBER( tosm1, arg1, do_ufn);	N_IGETNUMBER( tos, arg2, do_ufn);E 15	if(arg1 > arg2)		return(ATOM_T);	else		return(NIL_PTR);D 15do_ufn:	ERROR_EXIT(error_addr);E 15I 15do_ufn:	ERROR_EXIT(tos);E 15}I 20E 20E 8/************************************************************N_OP_iplusn	entry		IPLUS.N		OPCODE[0335]D 15	return(a + n)E 15I 15	return(tos + n)E 15************************************************************/D 15N_OP_iplusn(a, n, error_addr)	int a, n, *error_addr;E 15I 15N_OP_iplusn(tos, n)	int n, tos;E 15{I 15E 15D 6register int	arg1,arg2;E 6I 6register int	arg1;E 6register int	result;D 6register DLword	*wordp;E 6D 12#ifdef	TRACE	printPC();	printf("TRACE: N_OP_iplusn()\n");#endifE 12D 17E 17D 8	N_GETNUMBER( a, arg1, do_ufn );D 6	result = arg1 + n;	 E 6I 6	result = plus32n(arg1, n);	 E 8I 8D 15	N_IGETNUMBER( a, arg1, do_ufn );E 15I 15	N_IGETNUMBER( tos, arg1, do_ufn );E 15I 14D 16#ifdef NOASM	result = arg1 + n;D 15	if ((result < 0) && (arg1 >= 0)) {ERROR_EXIT(error_addr);}E 15I 15	if ((result < 0) && (arg1 >= 0)) {ERROR_EXIT(tos);}E 15	N_ARITH_SWITCH(result);E 16D 16#elseE 16I 16D 18#ifdef SUN3_OS3_ILE 18I 18D 22#ifdef SUN3_OS3_OR_OS4_ILE 22I 22D 27#if defined(SUN3_OS3_OR_OS4_IL) || defined(I386)E 27I 27#if ARITHINLINEE 27E 22E 18E 16E 14D 17	result = iplus32n(arg1, n);	 E 17I 17	result = iplus32n(arg1, n);E 17E 8D 27	N_ARITH_SWITCH(result);I 18dummy:	iplusn_err_label();E 27I 27    IPLUSN_RESULT;E 27E 18E 6D 6	if( (MIN_FIXP <= result) && (result <= MAX_FIXP) ){		if(0 <= result){			if(result <= MAX_SMALL)				return(S_POSITIVE | result);			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((int *)wordp) = result;				return(LADDR_from_68k(wordp));			}		}else{			if(MIN_SMALL <= result)				return(S_NEGATIVE | (0xFFFF & result));			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((int *)wordp) = result;				return(LADDR_from_68k(wordp));			}		}/* end if(0 <= result).... */	}E 6I 6D 8asm("plus_err2:");	E 8I 8D 17asm("iplusn_err:");	E 17I 17D 18asm("iplusn_err:");E 17I 14E 18I 16#else	result = arg1 + n;	if ((result < 0) && (arg1 >= 0)) {ERROR_EXIT(tos);}	N_ARITH_SWITCH(result);E 16#endifE 14E 8E 6D 15do_ufn:	ERROR_EXIT(error_addr);E 15I 15do_ufn:	ERROR_EXIT(tos);E 15}I 20E 20/************************************************************D 6OP_idifferencenE 6I 6N_OP_idifferencenE 6	entry		IDIFFERENCE.N		OPCODE[0336]D 15	return(a - n)E 15I 15	return(tos - n)E 15************************************************************/D 15N_OP_idifferencen(a, n, error_addr)	int a, n, *error_addr;E 15I 15N_OP_idifferencen(tos, n)	int n, tos;E 15{D 6register int	arg1,arg2;E 6I 6register int	arg1;E 6register int	result;D 6register DLword	*wordp;E 6D 12#ifdef	TRACE	printPC();	printf("TRACE: N_OP_idifferencen()\n");#endifE 12D 17E 17D 8	N_GETNUMBER( a, arg1, do_ufn );E 8I 8D 15	N_IGETNUMBER( a, arg1, do_ufn );E 15I 15	N_IGETNUMBER( tos, arg1, do_ufn );E 15I 14D 16#ifdef NOASM	result = arg1 - n;D 15	if ((result >= 0) && (arg1 < 0)) {ERROR_EXIT(error_addr);}E 15I 15	if ((result >= 0) && (arg1 < 0)) {ERROR_EXIT(tos);}E 15	N_ARITH_SWITCH(result);E 16I 16D 18#ifdef SUN3_OS3_ILE 18I 18D 22#ifdef SUN3_OS3_OR_OS4_ILE 22I 22D 27#if defined(SUN3_OS3_OR_OS4_IL) || defined(I386)E 27I 27#if ARITHINLINEE 27E 22E 18E 16D 16#elseE 16E 14E 8D 6	result = arg1 - n;	 E 6I 6D 17	result = sub32n(arg1, n);	 E 17I 17	result = sub32n(arg1, n);E 17D 27	N_ARITH_SWITCH(result);E 6D 18D 6	if( (MIN_FIXP <= result) && (result <= MAX_FIXP) ){		if(0 <= result){			if(result <= MAX_SMALL)				return(S_POSITIVE | result);			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((int *)wordp) = result;				return(LADDR_from_68k(wordp));			}		}else{			if(MIN_SMALL <= result)				return(S_NEGATIVE | (0xFFFF & result));			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((int *)wordp) = result;				return(LADDR_from_68k(wordp));			}		}/* end if(0 <= result).... */	}E 6I 6D 17asm("diff_err2:");	E 17I 17asm("diff_err2:");E 18I 18dummy:	idiffn_err_label();E 27I 27    IDIFFN_RESULT;E 27E 18E 17I 16#else	result = arg1 - n;	if ((result >= 0) && (arg1 < 0)) {ERROR_EXIT(tos);}	N_ARITH_SWITCH(result);E 16I 14#endifE 14E 6D 15do_ufn:	ERROR_EXIT(error_addr);E 15I 15do_ufn:	ERROR_EXIT(tos);E 15}E 4I 10D 12#endifE 12E 10E 1