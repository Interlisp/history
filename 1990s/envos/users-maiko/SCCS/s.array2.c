h47191s 00004/00004/00061d D 2.12 92/04/21 17:02:30 sybalsky 16 15c shortening file names for DOS \nes 00000/00000/00065d D 2.11 90/04/20 01:18:52 sybalsky 15 14c ange.es 00046/00019/00019d D 2.10 90/02/19 09:35:38 sybalsky 14 13c Add comments, reformat code.es 00006/00007/00032d D 2.9 88/10/12 14:39:39 krivacic 13 12c new out-of-line interfacees 00002/00103/00037d D 2.8 88/07/06 14:39:22 charnley 12 11c uses new select macro with modified select order.es 00015/00021/00125d D 2.7 88/06/07 15:39:43 charnley 11 10c disallow smallp's to char'ses 00003/00001/00143d D 2.6 88/05/25 17:12:35 charnley 10 9c changed err type.es 00002/00002/00142d D 2.5 88/05/25 16:51:16 charnley 9 8c changed sub name.es 00001/00001/00143d D 2.4 88/05/25 15:46:19 charnley 8 7c fixed bug in fl pt.es 00017/00232/00127d D 2.3 88/05/25 15:12:24 charnley 7 6c removed unused code, fixed bug in signed 32 bit casees 00001/00001/00358d D 2.2 88/05/25 11:08:04 krivacic 6 5c remove warning message by putting in (LispPTR)es 00000/00000/00359d D 2.1 88/05/17 09:21:54 hayata 5 4c Version up to 2.1es 00010/00007/00349d D 1.4 88/05/09 21:54:14 shih 4 3c Use GCLOOKUPes 00005/00009/00351d D 1.3 88/04/21 09:36:54 charnley 3 2c changed array-type mask, added refcounts to pointer entrieses 00002/00000/00358d D 1.2 88/04/20 14:19:18 masinter 2 1c Temporary patch to turn off non-refcounting aset of pointeres 00358/00000/00000d D 1.1 88/04/05 15:29:04 charnley 1 0c date and time created 88/04/05 15:29:04 by charnleyeuUtTI 1D 14/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";/*	array2.c */E 14I 14/* This is G-file @(#) array2.c Version 2.9 (10/12/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) array2.c	2.9 10/12/88";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************//************************************************************************//*									*//*			    A R R A Y 2 . C				*//*									*//*	Contains N_OP_misc4, the ASET opcode.				*//*									*//************************************************************************/E 14#include <stdio.h>#include "lispemul.h"D 16#include "lispglobal.h"#include "address68k.h"E 16I 16#include "lspglob.h"#include "adr68k.h"E 16#include "lispmap.h"D 16#include "lisptypes.h"#include "emulglobal.h"E 16I 16#include "lsptypes.h"#include "emlglob.h"E 16I 3#include "gc.h"E 3#include "arith.h"#include "my.h"D 3#include "tos1defs.h" #include "tosretmacro.h"#include "tosfuncallmacro.h"#include "inlinedefsC.h"#include "inlinedefs68K.h" #include "fastinlinedefs68K.h"E 3D 12/************************************************************ OP_claset  -- op 373/7 (newvalue base typenumber index)D 7	typenumber:		type = 7 & (typenumber >> 4)		0  unsigned		1  signed		2  pointer		3  float		4  character		5  xpointer		6  illegal		7  illegalE 7I 7type    size    typenumber  0       0             0      unsigned  : 1 bit  0       3             3      unsigned  : 8 bits  0       4             4      unsigned  : 16 bits  1       4            20      signed    : 16 bits  1       6            22      signed    : 32 bits  2       6            38      pointer   : 32 bits  3       6            54      float     : 32 bits  4       3            67      character : 8 bits  4       4            68      character : 16 bits  5       6            86      Xpointer  : 32 bitsE 7D 7		size = 7 & typenumber		0 1 bit   :		1 2 bits  :		2 4 bits  :		3 8 bits  :		4 16 bits : 		5 24 bits :		6 32 bits :		7 64 bits :	E 7***********************************************************/E 12I 12D 14/***	N_OP_misc4  -- op 373/7 (data, base typenumber, index)   ***/E 12D 7/***	OP_misc4  -- op 373/7 (newvalue base typenumber index)   ***/OP_mymisc4(){register short alpha;alpha = 0xFF & *(PC+1);if ((alpha != 7)  && (alpha != 6)) gotoufn;if (alpha == 7) { register LispPTR base; register short typenumber; register short index; register LispPTR data; register int new; LispPTR temp;   /*  test and setup index  */   if( (0xFF0000 & temp) != S_POSITIVE) gotoufn;   index = 0xFFFF & temp;   /*  test and setup typenumber  */   temp = *((LispPTR *)CurrentStackPTR);   if( (0xFF0000 & temp) != S_POSITIVE) gotoufn;   typenumber = 0xFF & temp;   /*  setup base  */   base = *((LispPTR *)(CurrentStackPTR - 2));   /*  fetch data  */   data = *((LispPTR *)(CurrentStackPTR - 4));    switch (typenumber) {      case 0: /* unsigned : 1 bit per element */        if ((data & 0xFF0000) != S_POSITIVE) gotoufn;         new = data & 0xFFFF;        if (new > 1) gotoufn;        if (new) {          new = (1 << (7 - (index & 7)));          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) |= new;        }        else {          new = 0xFF - (1 << (7 - (index & 7)));          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) &= new;        }        break;      case 3: /* unsigned : 8 bits per element */        if ((data & 0xFF0000) != S_POSITIVE) gotoufn;         new = data & 0xFFFF;        if (new > 0xFF) gotoufn;        *(((char *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 4: /* unsigned : 16 bits per element */        if ((data & 0xFF0000) != S_POSITIVE) gotoufn;         new = data & 0xFFFF;        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 20: /* signed : 16 bits */        if ((((data & 0xFF0000) == S_POSITIVE) && ((data & 0x8000) == 0)) || (((data & 0xFF0000) == S_NEGATIVE) && ((data & 0x8000) != 0)))        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        else gotoufn;        break;      case 22: /* signed : 32 bits */        GetNumber(data, new);        *(((int *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 38: /* pointer : 32 bits */I 2D 3	gotoufn; /* SHOULD REFERENCE COUNT */E 3I 3D 4	gclookup(0x8000|DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));	gclookup(0x8000|ADDREF, data);E 4I 4	GCLOOKUP(0x8000,DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));	GCLOOKUP(0x8000,ADDREF, data);E 4E 3E 2        *(((int *)Addr68k_from_LADDR(base)) + index) = data;        break;      case 54: /* Float : 32 bits */        if (GetTypeNumber(data) != TYPE_FLOATP) gotoufn;        *(((int *)Addr68k_from_LADDR(base)) + index) = *(int *)data;        break;      case 67: /* Character :  8 bits */        if (((data & 0xFF0000) != S_POSITIVE) && ((data & 0xFF0000) != S_CHARACTER)) gotoufn;        new = data & 0xFFFF;        if (new > 0xFF) gotoufn;        *(((char *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 68: /* Character :  16 bits */        if (((data & 0xFF0000) != S_POSITIVE) && ((data & 0xFF0000) != S_CHARACTER)) gotoufn;         new = data & 0xFFFF;        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 86: /* XPointer : 32 bits */        *(((int *)Addr68k_from_LADDR(base)) + index) = data;        break;      default: /* Illegal or Unimplemented */        gotoufn;    }/* end switch typenumber */ TopOfStack = data; }/* end if alpha == 7 */ if (alpha == 6) {/************************************************************	OP_misc4  -- op 373/6373/6	BITMAPBITtos    newValtos-1  Ytos-2  Xtos-3  BitMapformat of BitMap	0: 1:  base address of bitmap	2:     map raster width in words (16 bits)	3:     map height in lines --  (Ymax - 1)	4:     map width in pixels --  (Xmax - 1)	5:     pixel size --  1 or 4 or 8special:  if newVal == NIL, return old value, do not change value***********************************************************//***	OP_misc4  -- op 373/7 (newvalue base typenumber index)   ***/ register DLword *base; register LispPTR data; register int bitindex, pixsize, new, byte, shift; LispPTR temp;  temp = *((LispPTR *)(CurrentStackPTR - 4));  if (GetTypeNumber(temp) != TYPE_BITMAP) gotoufn;D 6  temp = Addr68k_from_LADDR(temp);E 6I 6  temp = (LispPTR) Addr68k_from_LADDR(temp);E 6  base = (DLword *)Addr68k_from_LADDR(*(int *)temp);  {    register LispPTR xval;    register LispPTR yval;    register int rasterwidth;    xval = *((LispPTR *)(CurrentStackPTR - 2));    yval = *((LispPTR *)(CurrentStackPTR));    if ((xval & 0xFF0000) != S_POSITIVE) gotoufn;    if ((yval & 0xFF0000) != S_POSITIVE) gotoufn;    rasterwidth = *((DLword *)(base + 2));    if ((xval = (0xFFFF & xval)) >= (*((DLword *)(base + 4)))) gotoufn;    if ((yval = (0xFFFF & yval)) >= (*((DLword *)(base + 3)))) gotoufn;    bitindex = (yval * rasterwidth * 16) + (xval * pixsize);  }  {    register int byte;    register int pixsize;    pixsize = *((DLword *)(base + 5));    byte = *(((char *)base) + (bitindex >> 3));    switch (pixsize) {      case 1:        shift = (7 - (bitindex & 7));        data = 1 & (byte >> shift);        if (TopOfStack != NIL_PTR) {          if ((TopOfStack & 0xFF0000) != S_POSITIVE) gotoufn;          if ((new = (TopOfStack & 0xFFFF)) >= 1) gotoufn;          byte &= ~(1 << shift);          byte |= (new << shift);          *(((char *)base) + (bitindex >> 3)) = byte;        }        TopOfStack = data | S_POSITIVE;        break;      case 4:        shift = (4 - (bitindex & 4));        data = 0xF & (byte >> shift);        if (TopOfStack != NIL_PTR) {          if ((TopOfStack & 0xFF0000) != S_POSITIVE) gotoufn;          if ((new = (TopOfStack & 0xFFFF)) >= 0xF) gotoufn;          byte &= ~(0xF << shift);          byte |= (new << shift);          *(((char *)base) + (bitindex >> 3)) = byte;          }        TopOfStack = data | S_POSITIVE;        break;      case 8:        if (TopOfStack == NIL_PTR) {          if ((TopOfStack & 0xFF0000) != S_POSITIVE) gotoufn;          if ((new = (TopOfStack & 0xFFFF)) >= 0xFF) gotoufn;          *(((char *)base) + (bitindex >> 3)) = new;        }        TopOfStack = byte | S_POSITIVE;        break;      default: gotoufn;      }/* end switch */    }  }/* end if alpha == 6 */  CurrentStackPTR -= 6;  PC += 2;} /*  end N_OP_misc4()   */E 7D 11N_OP_misc4(data, base, typenumber, index, alpha, error_addr)E 11I 11D 13N_OP_misc4(data, base, typenumber, inx, alpha, error_addr)E 13I 13N_OP_misc4(data, base, typenumber, inx, alpha)E 13E 11int alpha;D 7int *error_addr;E 7I 7D 9int error_addr;E 9I 9D 13int *error_addr;E 13E 9E 7D 11register int index, typenumber;register LispPTR base;register LispPTR data;E 11I 11register LispPTR base, data, typenumber, inx;E 11{register int new;I 11register int index;int type;E 14E 11D 7if ((alpha != 7)  && (alpha != 6)) ERROR_EXIT(error_addr);if (alpha == 7) {E 7I 7D 13if (alpha != 7) ERROR_EXIT(error_addr);E 13I 13D 14if (alpha != 7) ERROR_EXIT(inx);E 14E 13E 7D 12#ifdef	TRACED 7	printf("TRACE: N_OP_misc4(0x%x 0x%x 0x%x 0x%x 0x%x)\n",data, base, typenumber, index, alpha);E 7I 7	printPC();	printf("TRACE: N_OP_misc4()\n");E 7#endifE 12D 14   /*  test and setup index  */D 11   if( (0xFF0000 & index) != S_POSITIVE) ERROR_EXIT(error_addr);   index &= 0xFFFF;E 11I 11D 13   N_GetPos(inx, index, error_addr);E 13I 13   N_GetPos(inx, index, inx);E 14I 14/************************************************************************//*									*//*			N _ O P _ m i s c 4				*//*									*//*	CL:ASET opcode	op 373/7 (data, base typenumber, index)		*//*									*//************************************************************************/E 14E 13E 11D 14   /*  test and setup typenumber  */D 11   if( (0xFF0000 & typenumber) != S_POSITIVE) ERROR_EXIT(error_addr);   typenumber &= 0xFF;E 11I 11D 13   N_GetPos(typenumber, type, error_addr);E 13I 13   N_GetPos(typenumber, type, inx);E 14I 14N_OP_misc4(data, base, typenumber, inx, alpha)  int alpha;  register LispPTR base, data, typenumber, inx;  {      register int new;    register int index;    int type;E 14E 13E 11D 11    switch (typenumber) {E 11I 11D 12   switch (type) {E 11      case 0: /* unsigned : 1 bit per element */D 11        if ((data & 0xFF0000) != S_POSITIVE) ERROR_EXIT(error_addr);         new = data & 0xFFFF;E 11I 11        N_GetPos(data, new, error_addr);E 11        if (new > 1) ERROR_EXIT(error_addr);        if (new) {          new = (1 << (7 - (index & 7)));          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) |= new;        }        else {          new = 0xFF - (1 << (7 - (index & 7)));          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) &= new;        }        return(data);        break;      case 3: /* unsigned : 8 bits per element */D 11        if ((data & 0xFF0000) != S_POSITIVE) ERROR_EXIT(error_addr);         new = data & 0xFFFF;E 11I 11        N_GetPos(data, new, error_addr);E 11        if (new > 0xFF) ERROR_EXIT(error_addr);        *(((char *)Addr68k_from_LADDR(base)) + index) = new;        return(data);        break;      case 4: /* unsigned : 16 bits per element */D 11        if ((data & 0xFF0000) != S_POSITIVE) ERROR_EXIT(error_addr);         new = data & 0xFFFF;E 11I 11        N_GetPos(data, new, error_addr);         if (new > 0xFFFF) ERROR_EXIT(error_addr);E 11        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        return(data);        break;      case 20: /* signed : 16 bits */I 7        new = data & 0xFFFF;E 7D 4        if ((((data & 0xFF0000) == S_POSITIVE) && ((data & 0x8000) == 0)) || (((data & 0xFF0000) == S_NEGATIVE) && ((data & 0x8000) != 0)))E 4I 4D 11        if ((((data & 0xFF0000) == S_POSITIVE) && ((data & 0x8000) == 0)) ||	    (((data & 0xFF0000) == S_NEGATIVE) && ((data & 0x8000) != 0)))E 11I 11        if ((((data & 0xFFFF0000) == S_POSITIVE) && ((data & 0x8000) == 0)) ||	    (((data & 0xFFFF0000) == S_NEGATIVE) && (data & 0x8000)))E 11E 4        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        else ERROR_EXIT(error_addr);        return(data);        break;      case 22: /* signed : 32 bits */D 7        GetNumber(data, new);E 7I 7D 9        N_GetNumber(data, new, error_addr);E 9I 9D 10        N_GETNUMBER(data, new, error_addr);E 10I 10        N_GETNUMBER(data, new, doufn);E 10E 9E 7        *(((int *)Addr68k_from_LADDR(base)) + index) = new;        return(data);        break;      case 38: /* pointer : 32 bits */I 2D 3	ERROR_EXIT(error_addr); /* SHOULD REFERENCE COUNT */E 3I 3D 4	gclookup(0x8000|DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));	gclookup(0x8000|ADDREF, data);E 4I 4	GCLOOKUP(0x8000,DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));	GCLOOKUP(0x8000,ADDREF, data);E 4E 3E 2        *(((int *)Addr68k_from_LADDR(base)) + index) = data;        return(data);        break;      case 54: /* Float : 32 bits */        if (GetTypeNumber(data) != TYPE_FLOATP) ERROR_EXIT(error_addr);D 8        *(((int *)Addr68k_from_LADDR(base)) + index) = *(int *)data;E 8I 8        *(((int *)Addr68k_from_LADDR(base)) + index) = *((int *)Addr68k_from_LADDR(data));E 8        return(data);        break;      case 67: /* Character :  8 bits */D 4        if (((data & 0xFF0000) != S_POSITIVE) && ((data & 0xFF0000) != S_CHARACTER)) ERROR_EXIT(error_addr);E 4I 4D 11        if (((data & 0xFF0000) != S_POSITIVE) &&	    ((data & 0xFF0000) != S_CHARACTER)) ERROR_EXIT(error_addr);E 11I 11        if ((data & 0xFFFF0000) != S_CHARACTER) ERROR_EXIT(error_addr);E 11E 4        new = data & 0xFFFF;        if (new > 0xFF) ERROR_EXIT(error_addr);        *(((char *)Addr68k_from_LADDR(base)) + index) = new;        return(data);        break;      case 68: /* Character :  16 bits */D 4        if (((data & 0xFF0000) != S_POSITIVE) && ((data & 0xFF0000) != S_CHARACTER)) ERROR_EXIT(error_addr); E 4I 4D 11        if (((data & 0xFF0000) != S_POSITIVE) &&	    ((data & 0xFF0000) != S_CHARACTER)) ERROR_EXIT(error_addr); E 11I 11        if ((data & 0xFFFF0000) != S_CHARACTER) ERROR_EXIT(error_addr); E 11E 4        new = data & 0xFFFF;        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        return(data);        break;      case 86: /* XPointer : 32 bits */        *(((int *)Addr68k_from_LADDR(base)) + index) = data;        return(data);        break;      default: /* Illegal or Unimplemented */        ERROR_EXIT(error_addr);    }/* end switch typenumber */E 12I 12D 13   aset_switch(type, error_addr);E 13I 13D 14   aset_switch(type, inx);E 14I 14    if (alpha != 7) ERROR_EXIT(inx);E 14E 13E 12I 10I 14    /*  test and setup index  */    N_GetPos(inx, index, inx);     /*  test and setup typenumber  */    N_GetPos(typenumber, type, inx);    aset_switch(type, inx);E 14D 13doufn:		ERROR_EXIT(error_addr);E 13I 13doufn:		ERROR_EXIT(inx);E 13E 10D 7 }/* end if alpha == 7 */     /* bmb temporarily out */if (alpha == 6) ERROR_EXIT(error_addr);E 7D 14} /*  end N_OP_misc4()  */E 14I 14  } /*  end N_OP_misc4()  */E 14E 1