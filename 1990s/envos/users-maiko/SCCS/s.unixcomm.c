h10312s 00047/00017/01142d D 2.48 93/02/08 15:00:13 sybalsky 60 59c Big VM (and new CDR coding) changes for 3.0 \nes 00104/00021/01055d D 2.47 92/07/24 10:47:13 sybalsky 59 58c retrofit of SGI & DEC OSF1 changes \nes 00121/00039/00955d D 2.46 92/06/26 13:51:03 sybalsky 58 57c retrofit of 386 unix changes \nes 00005/00005/00989d D 2.45 92/04/21 17:27:54 sybalsky 57 56c shortening file names for DOS \nes 00023/00041/00971d D 2.44 91/09/27 03:45:32 sybalsky 56 55c ISC port changeses 00002/00002/01010d D 2.43 91/08/19 16:23:39 sybalsky 55 54c Use fillpointer for Lisp string lengthes 00020/00010/00992d D 2.42 91/05/01 18:17:39 sybalsky 54 53c Retrofit changes from MIPS porting center.es 00004/00000/00998d D 2.41 91/04/09 17:13:50 sybalsky 53 52c Retrofit first round of changes from MIPS porting centeres 00017/00002/00981d D 2.40 91/01/27 12:20:36 sybalsky 52 51c Retrofit HP9000/RS6000 changeses 00002/00000/00981d D 2.39 90/09/21 18:10:08 sybalsky 51 50c es 00038/00011/00943d D 2.38 90/09/18 23:50:02 sybalsky 50 49c Retrofit changes from AIX, DEC3100, PS/2es 00004/00002/00950d D 2.37 90/08/30 10:31:44 sybalsky 49 48c add buffering for unixcomm streams.es 00039/00001/00913d D 2.36 90/08/21 17:17:03 sybalsky 48 47c Retrofit AIX changes from IBMes 00002/00000/00912d D 2.35 90/07/25 01:03:24 sybalsky 47 46c removed include of termios.h (no longer used here, but in unixfork.c)es 00005/00001/00907d D 2.34 90/07/18 20:21:25 sybalsky 46 45c Fix accept code to not return if it gets interrupted, but to try again until the accept works.es 00437/00587/00471d D 2.33 90/07/04 04:05:55 sybalsky 45 44c Bane changes:  Faster I/O, earlier unix forkinges 00010/00001/01048d D 2.32 90/06/14 15:42:40 sybalsky 44 43c Fix read-block (option 9) to check for valid read first.es 00001/00000/01048d D 2.31 90/05/15 18:24:52 sybalsky 43 42c Mke read fail gracefully if tried on non-open process #.es 00000/00000/01048d D 2.30 90/04/20 02:07:20 sybalsky 42 41c AIX:  shortening file names, bulk change.es 00162/00054/00886d D 2.29 90/04/19 22:49:27 sybalsky 41 40c Include BVM's updates, make AIX ocmpatibilty fixes 00012/00007/00928d D 2.28 90/04/02 15:23:12 sybalsky 40 39c Fix handling of non-EOF after other end of shell stream has terminated.es 00011/00000/00924d D 2.27 90/02/12 14:20:55 sybalsky 39 38c fix copyright msges 00017/00005/00907d D 2.26 90/02/12 14:19:32 sybalsky 38 37c Make UNIX-READ check for dead connection -before- read call.  Fixes IDLE/CHAT hangupes 00374/00266/00538d D 2.25 89/12/13 10:59:43 sybalsky 37 36c string-conversion safetyes 00285/00118/00519d D 2.24 89/10/19 18:02:09 sybalsky 36 35c use named connections instead of pipes, for efficiencyes 00003/00003/00634d D 2.23 89/03/18 04:03:25 sybalsky 35 34c OneDArrayes 00023/00022/00614d D 2.22 89/01/09 16:59:52 shih 34 33c wrong sccsides 00003/00003/00633d D 2.21 88/11/08 13:13:57 bane 33 32c Commented out blatantly bogus break; statementses 00002/00002/00634d D 2.20 88/10/07 19:06:21 bane 32 31c now sets LDESHELL=YESes 00005/00001/00631d D 2.19 88/10/03 10:24:37 bane 31 30c Signed char bug, and setenv TERM lde in chat shellses 00002/00002/00630d D 2.18 88/08/16 20:47:53 jmturn 30 29c Fixes bomb-outs during writes to closed streamses 00016/00011/00616d D 2.17 88/07/31 15:28:24 greep 29 28c check for valid pides 00003/00004/00624d D 2.16 88/07/13 16:02:43 jmturn 28 27c Make it work for OS 4.0es 00004/00000/00624d D 2.15 88/06/30 11:04:18 greep 27 26c put "#ifdef DEBUG" around printfses 00002/00000/00622d D 2.14 88/06/29 14:07:04 bane 26 25c Added <setjmp.h> so timeout.h would workes 00037/00017/00585d D 2.13 88/06/17 20:06:06 greep 25 24c fix bug in waiting for process to endes 00015/00008/00587d D 2.12 88/06/16 23:41:54 greep 24 23c more bulletproofing, to fix problem of restarting with shell window openes 00126/00114/00469d D 2.11 88/06/16 21:08:09 greep 23 22c general cleanupes 00041/00020/00542d D 2.10 88/06/15 13:16:23 greep 22 21c unixcomm process kills subprocesses and exits on EOF on pipe from main processes 00026/00008/00536d D 2.9 88/06/09 16:45:15 krivacic 21 20c fix exit statuses 00033/00000/00511d D 2.8 88/06/08 13:13:52 jmturn 20 19c Now can send EOF to streamses 00322/00119/00189d D 2.7 88/06/08 11:40:04 jmturn 19 18c Fixed status return, accidental multiple homicidees 00003/00002/00305d D 2.6 88/06/06 16:04:34 greep 18 17c Read from pty returns EOF on error (except when no chars to read)es 00010/00010/00297d D 2.5 88/06/03 21:07:38 mullins 17 16c Changed N_GETNUMBER calls.es 00002/00000/00305d D 2.4 88/06/03 16:53:49 masinter 16 15c remove turnoff of stdin and stdout for subprocesses 00007/00006/00298d D 2.3 88/05/31 20:14:40 masinter 15 14c change getnumber calls, subrs can't ufnes 00001/00000/00303d D 2.2 88/05/27 15:00:02 krivacic 14 13c jt's desire to close std in & out of spawned process in attempt to fix uraides 00000/00000/00303d D 2.1 88/05/17 09:27:26 hayata 13 12c Version up to 2.1es 00002/00003/00301d D 1.12 88/05/13 15:18:16 hayata 12 11c Add SCCS keyides 00081/00065/00223d D 1.11 88/05/13 12:39:38 jmturn 11 10c Alpha Version 1.0es 00002/00012/00286d D 1.10 88/05/09 20:21:38 jmturn 10 9c Forked Shell mode completees 00064/00026/00234d D 1.9 88/05/09 15:53:09 jmturn 9 8c es 00001/00001/00259d D 1.8 88/05/06 16:06:01 jmturn 8 7c Make Maiko the top processes 00102/00017/00158d D 1.7 88/05/06 11:53:49 jmturn 7 6c Includes PTY codees 00002/00002/00173d D 1.6 88/05/04 15:35:47 jmturn 6 5c es 00000/00000/00175d D 1.5 88/04/21 19:59:39 atty 5 4c es 00000/00154/00175d D 1.4 88/04/06 15:02:06 jmturn 4 3c Try again...es 00175/00000/00000d D 1.3 88/04/06 14:03:38 jmturn 3 2c Now takes arbitrary commandes 00152/00000/00002d D 1.2 88/04/05 11:11:36 jmturn 2 1c Unix Interface Routineses 00002/00000/00000d D 1.1 88/04/04 12:17:39 jmturn 1 0c date and time created 88/04/04 12:17:39 by jmturneuUtTI 3D 6/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 6I 6D 12/* This is G-file @(#) unixcomm.c Version 1.5 (4/21/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) unixcomm.c	1.5 4/21/88";E 6E 12I 12D 28/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 28I 28D 33/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */ static char *id = "%Z% %M%	%I% %G%";E 33I 33D 34/* This is G-file @(#) unixcomm.c Version 2.20 (10/7/88). copyright Xerox & Fuji Xerox  */ static char *id = "@(#) unixcomm.c	2.20 10/7/88";E 34I 34D 37/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 37I 37D 41/* @(#) unixcomm.c Version 2.23 (3/18/89). copyright envos & Fuji Xerox  */static char *id = "@(#) unixcomm.c	2.23 3/18/89		(envos & Fuji Xerox)";E 41I 41D 49/* @(#) unixcomm.c Version 2.23 (3/18/89). copyright Venue & Fuji Xerox  */static char *id = "@(#) unixcomm.c	2.23 3/18/89		(Venue & Fuji Xerox)";E 49I 49/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";I 58E 58E 49E 41E 37E 34E 33E 28E 12/*Unix Interface Communications*/I 39I 56E 56/************************************************************************//*									*/D 56/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 56I 56D 58/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*/E 58I 58D 59/*	(C) Copyright 1989-1992 by Venue. All Rights Reserved.	*/E 59I 59/*	(C) Copyright 1989-1992 by Venue. All Rights Reserved.		*/E 59E 58/*	Manufactured in the United States of America.			*/E 56/*									*/D 56/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 56I 56/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 56/*									*//************************************************************************/I 56E 56E 39#include "lispemul.h"#include "address.h"D 57#include "address68k.h"#include "lisptypes.h"E 57I 57#include "adr68k.h"#include "lsptypes.h"E 57#include "lispmap.h"D 57#include "emulglobal.h"#include "lispglobal.h"E 57I 57#include "emlglob.h"#include "lspglob.h"E 57#include "cell.h"#include "stack.h"#include "arith.h"I 26/* JRB - timeout.h needs setjmp.h */I 38D 45#ifdef HPE 45#include <sys/ioctl.h>D 45#endifE 45E 38#include <setjmp.h>E 26I 25#include "timeout.h"E 25#include <stdio.h>I 47#ifdef OS4E 47D 41#include <sgtty.h>E 41I 41#include <sys/termios.h>I 59#elif APOLLO#include </sys5/usr/include/termios.h>E 59I 49#elseI 51D 52#ifdef AIXE 52E 51#include <sys/termio.h>I 51D 52#endif AIXE 52E 51E 49I 47D 60#endif OS4E 60I 60#endif /* OS4 */E 60I 56#include <sys/types.h>E 56E 47E 41I 7#include <sys/file.h>#include <signal.h>I 9#include <sys/wait.h>I 11D 18#include <sys/errno.h>E 18I 18#include <errno.h>I 36#include "dbprint.h"I 37D 56#include <sys/types.h>E 56#include <sys/socket.h>I 56#ifdef ISC#include <sys/fcntl.h>I 58/* Needed for window size setting ops: */#include <sys/sioctl.h>E 58#elseI 59#include <fcntl.h>E 59E 56#include <sys/un.h>I 56D 60#endif ISCE 60I 60#endif /* ISC */E 60E 56I 52#ifdef HPUX#include <unistd.h>D 60#endif HPUXE 60I 60#endif /* HPUX */E 60E 52E 37I 60E 60I 59#ifdef sun	/* to get S_IFIFO defn for creating fifos */#include <sys/stat.h>#endif /* sun */E 59I 58#ifdef GCC386#include "inlinePS2.h"D 60#endif GCC386E 60I 60#endif /* GCC386 */E 60I 60E 60E 58I 56D 57#include "localfile.h"		/* for LispStringToCString. */E 57I 57#include "locfile.h"		/* for LispStringToCString. */E 57E 56I 52E 52I 41D 45#ifdef AIX#define FNDELAY O_NONDELAY#endifE 45I 45char *malloc();E 45E 41E 36I 19D 45#define NPROCS 100E 45I 45int NPROCS = 100;E 45E 19E 18E 11E 9E 7D 50E 50I 50D 56#ifdef BYTESWAPE 56I 52E 52D 56#define LispStringToCString(Lisp, C) { \  LispPTR *naddress; \  char *base; \  int length, offset, i; \  naddress = (LispPTR *) (Addr68k_from_LADDR(Lisp)); \  base = (char *) (Addr68k_from_LADDR(((OneDArray *)naddress)->base)); \  offset = (int) (((OneDArray *)naddress)->offset); \D 55  length = ((OneDArray *)naddress)->totalsize; \E 55I 55  length = ((OneDArray *)naddress)->fillpointer; \E 55D 54  length = (length <= 150) ? length : 150; \E 54I 54  length = (length <= 2048) ? length : 2048; \E 54  for (i=offset; i<offset+length; i++) C[i] = base[i^3]; \  C[length] = '\0'; \} E 56I 52E 52D 56#elseI 52E 52E 50#define	LispStringToCString(Lisp, C){	\	LispPTR	*naddress;				\	char	*base;					\	int	length;					\	int	offset;					\D 34	naddress = (LispPTR *)(Addr68k_from_LADDR(Lisp));					\E 34I 34D 37	naddress = (LispPTR *)(Addr68k_from_LADDR(Lisp));			\E 34D 35	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));	\	offset = (int)(((ONEDARRAAY *)naddress)->offset);	\D 34	length = ((ONEDARRAAY *)naddress)->totalsize;						\E 34I 34	length = ((ONEDARRAAY *)naddress)->totalsize;		\E 35I 35	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));	\E 37I 37	naddress = (LispPTR *)(Addr68k_from_LADDR(Lisp));		\	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base)); \E 37	offset = (int)(((OneDArray *)naddress)->offset);	\D 55	length = ((OneDArray *)naddress)->totalsize;		\E 55I 55	length = ((OneDArray *)naddress)->fillpointer;		\E 55E 35E 34D 37	strncpy(C, base + offset, length);			\E 37I 37D 54	length = (length <= 150) ? length : 150;		\E 54I 54	length = (length <= 2048) ? length : 2048;		\E 54	strncpy(C, base + offset, length);	\E 37	C[length] = '\0';				\	}I 52E 52I 50#endif BYTESWAPE 50I 52E 56E 52I 7D 9int ForkedIns[100], ForkedOuts[100], ForkedPIDs[100];E 9I 9D 19int ForkedIns[100], ForkedOuts[100], ForkedPIDs[100], ForkedStatus[100];int PIDn;D 11int UpdateProcessStatus();E 11I 11char shcom[150];E 19I 19/* The following globals are used to communicate between Unix   subprocesses and LISP */E 19E 11E 9I 19D 45int ForkedIns[NPROCS],		/* Pipes going from Unix to LISP */    ForkedOuts[NPROCS],		/* Pipes going from LISP to Unix */    ForkedPIDs[NPROCS],		/* Process IDs of forked processes */D 37    ForkedStatus[NPROCS];	/* The value returned by a subprocess */E 37I 37    ForkedStatus[NPROCS],	/* The value returned by a subprocess */E 37				/* (not shell) */I 37    ForkedProcType[NPROCS];	/* -1 = PTY shell, -2 = process stream */E 45E 37I 37D 45long StartTime;			/* Time, for creating pipe filenames */E 45I 45/* One of these structures exists for every possible file descriptor *//* type field encodes kind of stream:                                */E 45E 37I 24D 45#define valid_slot(slot) (slot >= 0 && slot < NPROCS && ForkedPIDs[slot])E 45I 45#define UJUNUSED    0          /* Unused */#define UJSHELL    -1          /* PTY shell */#define UJPROCESS  -2          /* random process */#define UJSOCKET   -3          /* socket open for connections */#define UJSOSTREAM -4          /* connection from a UJSOCKET */E 45I 58   /* These are indexed by WRITE socket# */E 58E 24D 45char shcom[150];		/* Here because I'm suspicious of */				/* large allocations on the stack */E 45I 45struct unixjob {  char *pathname;               /* used by Lisp direct socket access subr */D 58  int sockdesc;                 /* descriptor of socket for this process */E 58I 58  int readsock;                 /* Socket to READ from for this job. */E 58  int PID;			/* process ID associated with this slot */  int status;			/* status returned by subprocess (not shell) */D 50  char type;E 50I 50  int type;E 50};E 45D 45/* fork_Unix is the secondary process spawned right after LISP is   started, to avoid having TWO 8 mbyte images sitting around. It listens   to the pipe LispToUnix waiting for requests, and responds on UnixToLisp.   The data passed through this pipe is in 4 byte packets, of the form:E 45I 45struct unixjob *UJ;             /* allocated at run time */E 45D 23   Byte 0:   Command, one of:E 23I 23D 45   Byte 0:   Command character, one of:E 23                   S: Fork PTY (shell) process. This is used for CHAT windows.D 41		   F: Fork piped shellE 41I 41		   P: New version of S, takes 2 string args.		   F: Fork piped shell, takes 1 string arg.E 41D 37		   W: Write byte to process stdin		   R: Read byte (nohang) from process stdoutE 37		   K: Kill process		   E: Exit (kill all subprocesses)I 20		   C: Close stdin to subprocessI 37		   W: call WAIT3 & get one process's close info.E 37E 20   Byte 1:   Process number (0 to NPROCS - 1)             Not used for S, F, and E commandsI 36D 41	     [For S, pty letter]E 41I 41	     [For S&P, pty letter]E 41I 37	     [For F, process # for pipe naming]E 37E 36   Byte 2:   Value, used as follows:             Only used for W command, contains byte to writeI 36D 41	     [For S, pty number]E 41I 41	     [For S&P, pty number]E 41E 36D 37   Byte 3:   Status, always 1.E 37I 37   Byte 3:   Slot number.E 45I 45long StartTime;			/* Time, for creating pipe filenames */E 45E 37D 34In the case of a F command, additional data follows the 4 byte packet. E 34I 34D 41In the case of a F command, additional data follows the 4 byte packet.E 41I 41D 45In the case of F & P commands, additional data follows the 4 byte packet.E 41E 34This consists of one byte representing the length of the shell commandstring, and the string itself.E 45I 45#define valid_slot(slot) ((slot) >= 0 && (slot) < NPROCS && UJ[slot].type)E 45D 34   fork_Unix will return another 4 byte packet. The bytes are the same as those E 34I 34D 45fork_Unix will return another 4 byte packet. The bytes are the same as thoseE 34of the packet received except:E 45I 45D 54char shcom[150];		/* Here because I'm suspicious of */E 54I 54char shcom[2048];		/* Here because I'm suspicious of */E 54				/* large allocations on the stack */E 45D 45   F:        Byte 2 is job number             Byte 3 is 1 if successful, 0 if not   S:        Byte 2 is job number             Byte 3 is 1 if successful, 0 if not   R:        Byte 2 is value of byte read from stdin, if any             Byte 3 is 1 if successful, 2 if EOF, 0 if nothing waitingD 37   W:        Byte 3 is 1 if successful, 0 if not (pipe full or closed)E 37I 37   W:        Bytes 0 & 1 are the Process ID of the terminated process	     Bytes 2 & 3 are the high & low bytes of the exit status.E 37   K:        Bytes 1 and 2 are the high and low bytes of the exit statusD 34             of the process. E 34I 34             of the process.E 34	     Byte 3 is 1 if an exit status was available.   E:        Always the sameI 20   C:        Always the sameE 20*/I 21D 23union wait ProcessStatus;E 23E 21I 23D 34int find_process_slot(pid) E 34I 34D 36int find_process_slot(pid)E 34/* Find a slot with the specified pid (can be 0 to find a free slot) */     register int pid;{  register int slot;E 36D 34  E 34I 34E 34D 36  for (slot = 0; slot < NPROCS; slot++)    if (ForkedPIDs[slot] == pid)      return slot;  return -1;}E 23I 21E 36E 21E 19D 9E 9E 7fork_Unix(){D 19	int LispToUnix[2], UnixToLisp[2], UnixToProcess[2], ProcessToUnix[2];D 7	int LispPipeIn, LispPipeOut, rdy, PIDn;E 7I 7D 9	int LispPipeIn, LispPipeOut, rdy, PIDn, i, res;E 9I 9D 11	int LispPipeIn, LispPipeOut, rdy, i, res;E 9E 7	char IOBuf[4], *argv[20], *p, c, tmp[1], **ar, shcom[20];E 11I 11	int LispPipeIn, LispPipeOut, rdy, i, res, ProcessStatus[2];	char IOBuf[4], *argv[20], *p, c, tmp[2], **ar;E 19I 19  int LispToUnix[2],		/* Incoming pipe from LISP */      UnixToLisp[2],		/* Outgoing pipe to LISP */      UnixToProcess[2],		/* Temporaries */      ProcessToUnix[2],D 21      LispPipeIn, LispPipeOut, rdy, i, res, ProcessStatus[2], PIDn;E 21I 21D 23      LispPipeIn, LispPipeOut, rdy, i, res, PIDn, PS[2];E 23I 23      LispPipeIn, LispPipeOut, res, pid, slot;E 23E 21E 19E 11D 7	int ForkedIns[100], ForkedOuts[100], ForkedPIDs[100], i;E 7D 19	pipe(LispToUnix);	pipe(UnixToLisp);E 19I 19D 23  char IOBuf[4], *p, c, tmp[2], **ar;E 23I 23  char IOBuf[4], tmp[2];E 23D 21  union wait ProccessStatus;E 21E 19D 19	LispPipeIn = LispToUnix[0];	LispPipeOut = UnixToLisp[1];	UnixPipeIn = UnixToLisp[0];	UnixPipeOut = LispToUnix[1];E 19I 19D 24  pipe(LispToUnix);		/* Pipes between LISP subr and process */  pipe(UnixToLisp);E 24I 24  /* Pipes between LISP subr and process */  if (pipe(LispToUnix) == -1) {    perror("pipe");    exit(-1);  }  if (pipe(UnixToLisp) == -1) {    perror("pipe");    exit(-1);  }E 24D 22  LispPipeIn = LispToUnix[0];  LispPipeOut = UnixToLisp[1];  UnixPipeIn = UnixToLisp[0];  UnixPipeOut = LispToUnix[1];E 22E 19I 36  for (slot = 0; slot < NPROCS; slot++)    ForkedPIDs[slot] = 0;		/* I don't trust it, do you? */E 36D 19	UnixPID = fork();D 8	if (UnixPID == 0) return(1);E 8I 8	if (UnixPID != 0) return(1);E 19I 16D 17/* don't do this: breaks unixcommE 16I 14	close(1); close(0);I 16*/E 17I 17I 37  StartTime = time(0);		/* Save the time, to create filenames with */  StartTime &= 0xFFFFFF;	/* as a positive number! */E 37I 36I 37E 37E 36D 19/*	close(1); close(0); */E 17E 16E 14E 8	PIDn = 0;E 19I 19D 22  UnixPID = fork();		/* Fork off small version of the emulator */  if (UnixPID != 0) return(1);E 22I 22  if ((UnixPID = fork()) == -1) {  /* Fork off small version of the emulator */    perror("fork");    exit(-1);  }E 22E 19I 22  if (UnixPID != 0) {    UnixPipeIn = UnixToLisp[0];    UnixPipeOut = LispToUnix[1];    close(LispToUnix[0]);D 34    close(UnixToLisp[1]);    E 34I 34    close(UnixToLisp[1]);E 34    return(1);  }  LispPipeIn = LispToUnix[0];  LispPipeOut = UnixToLisp[1];  close(LispToUnix[1]);D 34  close(UnixToLisp[0]);    E 22I 9D 11	(void) signal(SIGCHLD, UpdateProcessStatus);E 11I 11D 19	for (i = 0; i < 100; i++) ForkedPIDs[i] = 0;E 19I 19D 23  for (i = 0; i < NPROCS; i++)     ForkedPIDs[i] = 0;		/* I don't trust it, do you? */E 23I 23  for (slot = 0; slot < NPROCS; slot++) E 34I 34  close(UnixToLisp[0]);D 36  for (slot = 0; slot < NPROCS; slot++)E 34    ForkedPIDs[slot] = 0;		/* I don't trust it, do you? */E 36E 23E 19I 37  res = fcntl(LispPipeIn, F_GETFL, 0);  res &= (65535-FNDELAY);  res = fcntl(LispPipeIn, F_SETFL, res);E 37E 11E 9D 19	while (1) {	  read(LispPipeIn, IOBuf, 4);	  switch(IOBuf[0]) {I 7	  case 'S':D 9	    res = ForkUnixShell(PIDn);E 9I 9D 11	    for (PIDn = 0; ForkedPIDs[PIDn] != 0; PIDn++);	    ForkedStatus[PIDn] = 0;	    res = ForkUnixShell();E 9	    if (res != -1)	      IOBuf[1] = PIDn++;	    else	      IOBuf[3] = 0;E 11I 11	    for (PIDn = 0; (ForkedPIDs[PIDn] != 0 && PIDn < 100); PIDn++);	    if (ForkedPIDs[PIDn] == 0) {	      ForkedStatus[PIDn] = 0;	      res = ForkUnixShell();	      if (res != -1)		IOBuf[1] = PIDn++;	      else		IOBuf[3] = 0;	    } else IOBuf[3] = 0;E 11	    break;E 7	  case 'F':D 11	    p = shcom;	    read(LispPipeIn, p, 1);	    while (*p != 0)	      read(LispPipeIn, ++p, 1);	    pipe(UnixToProcess);I 9	    res = fcntl(UnixToProcess[1], F_GETFL);	    res |= FNDELAY;	    res = fcntl(UnixToProcess[1], F_SETFL, res);D 10	    res = fcntl(UnixToProcess[1], F_GETFL);	    if ((res & FNDELAY) == 0)	      printf("No-delay not set\n");E 10E 9	    pipe(ProcessToUnix);I 9	    res = fcntl(ProcessToUnix[0], F_GETFL);	    res |= FNDELAY;	    res = fcntl(ProcessToUnix[0], F_SETFL, res);D 10	    res = fcntl(ProcessToUnix[0], F_GETFL);	    if ((res & FNDELAY) == 0)	      printf("No-delay not set\n");E 10E 9	    for (PIDn = 0; ForkedPIDs[PIDn] != 0; PIDn++);	    ForkedPIDs[PIDn] = fork();	    ForkedIns[PIDn] = ProcessToUnix[0];	    ForkedOuts[PIDn] = UnixToProcess[1];E 11I 11	    for (PIDn = 0; (ForkedPIDs[PIDn] != 0 && PIDn < 100); PIDn++);E 11	    if (ForkedPIDs[PIDn] == 0) {D 11	      dup2(UnixToProcess[0],0);	      dup2(ProcessToUnix[1],1);	      dup2(ProcessToUnix[1],2);	      execl(shcom, shcom, 0);	      exit(1);	    }D 7	    if (ForkedPIDs[PIDn] == -1)E 7I 7	    if (ForkedPIDs[PIDn] == -1) {E 7	      perror("unixcomm");I 7	      IOBuf[3] = 0;	    }E 7	    else	      IOBuf[1] = PIDn++;E 11I 11	      pipe(ProcessToUnix);	      pipe(UnixToProcess);	      pipe(ProcessStatus);	      ForkedStatus[PIDn] = ProcessStatus[0];	      ForkedIns[PIDn] = ProcessToUnix[0];	      ForkedOuts[PIDn] = UnixToProcess[1];	      res = fcntl(UnixToProcess[1], F_GETFL);	      res |= FNDELAY;	      res = fcntl(UnixToProcess[1], F_SETFL, res);	      res = fcntl(ProcessToUnix[0], F_GETFL);	      res |= FNDELAY;	      res = fcntl(ProcessToUnix[0], F_SETFL, res);	      res = fcntl(ProcessStatus[0], F_GETFL);	      res |= FNDELAY;	      res = fcntl(ProcessStatus[0], F_SETFL, res);	      read(LispPipeIn, tmp, 1);	      read(LispPipeIn, shcom, *tmp);E 19I 19  while (1) {D 23    while (((PIDn = wait3(ProcessStatus, WNOHANG, 0)) != 0) && (PIDn != -1)) {      for (i = 0; (i < NPROCS) && (ForkedPIDs[i] != PIDn); i++);D 21      if (ForkedPIDs[i] == PIDn)	ForkedStatus[i] = ProcessStatus->w_status;E 21I 21      if (ForkedPIDs[i] == PIDn) {	read(ForkedStatus[i], tmp, 2);	res = tmp[0] << 8 + tmp[1];	printf("PID %d died, status returned is %d\n", PIDn, 	       res);	ForkedStatus[i] = res;      }E 21    }      E 23I 23D 25    wait_for_comm_processes();E 25I 25D 30    wait_for_comm_processes(0);E 30E 25E 23D 22    read(LispPipeIn, IOBuf, 4);	/* Get packet */E 22I 22D 37    if (read(LispPipeIn, IOBuf, 4) != 4) {	/* Get packet */      kill_comm_processes();      exit(0);E 37I 37    int len;    len = 0;    while (len != 4)    {      if ((len = read(LispPipeIn, IOBuf, 4)) <0)	{	/* Get packet */	  perror("Packet read by slave");	  /*      kill_comm_processes(); */	  exit(0);	}      if (len != 4)	{	  DBPRINT(("Input packet wrong length:  %d.\n", len));	  exit(0);	}E 37    }D 28      E 28I 28D 34    E 34I 34D 37E 34I 30    wait_for_comm_processes(0);E 37I 37    slot = IOBuf[3];E 37E 30D 34    IOBuf[3] = 1;  E 34I 34    IOBuf[3] = 1;E 34E 28E 22    switch(IOBuf[0]) {E 19D 19	      ForkedPIDs[PIDn] = fork();	      if (ForkedPIDs[PIDn] == 0) {		dup2(UnixToProcess[0],0);		dup2(ProcessToUnix[1],1);		dup2(ProcessToUnix[1],2);		res = system(shcom);		tmp[0] = (res & 0xFF00) >> 8;		tmp[1] = res & 0xFF;		write(ProcessStatus[1], tmp, 2);		exit(0);E 19I 19D 41    case 'S':			/* Fork PTY shell */E 41I 41    case 'S': case 'P':			/* Fork PTY shell */E 41D 23      for (PIDn = 0;            (ForkedPIDs[PIDn] != 0 && PIDn < NPROCS);            PIDn++);      if (ForkedPIDs[PIDn] == 0) { /* If we managed to find a free slot */	ForkedStatus[PIDn] = -1;	res = ForkUnixShell(PIDn);	   /* Alloc a PTY and fork  */	if (res != -1)	  IOBuf[1] = PIDn++;	elseE 23I 23D 37      if ((slot = find_process_slot(0)) >= 0) { /* Find a free slot */D 36	res = ForkUnixShell(slot);	   /* Alloc a PTY and fork  */E 36I 36	res = ForkUnixShell(slot, IOBuf[1], IOBuf[2]);   /* Alloc a PTY and fork  */E 36	if (res == -1)E 37I 37      if (slot >= 0)D 41	{ /* Find a free slot */	  res = ForkUnixShell(slot, IOBuf[1], IOBuf[2]);   /* Alloc a PTY and fork  */E 41I 41	{ /* Found a free slot */	  char termtype[32];	  if (IOBuf[0] == 'P')	    {			/* The new style, which takes term type & command to csh */	      if(read(LispPipeIn, tmp, 1) < 0) perror("Slave reading cmd length");	      if(read(LispPipeIn, termtype, *tmp) < 0) perror("Slave reading termtype");	      if(read(LispPipeIn, tmp, 1) < 0) perror("Slave reading cmd length");	      if(read(LispPipeIn, shcom, *tmp) < 0) perror("Slave reading shcom");	    }	    else		/* old style, no args */	      { termtype[0] = 0; shcom[0] = 0; }	  /* Alloc a PTY and fork  */	  res = ForkUnixShell(slot, IOBuf[1], IOBuf[2], termtype, shcom);E 41	  if (res == -1)	    {	      printf("Impossible failure from ForkUnixShell??\n");	      fflush(stdout);	      IOBuf[3] = 0;	    }	  else	    {	      /* ForkUnixShell sets the pid and standard in/out variables */	      ForkedStatus[slot] = -1;	      IOBuf[1] = (ForkedPIDs[slot]>>8)& 0xFF;	      IOBuf[2] = ForkedPIDs[slot] & 0xFF;	    }        }      else 	{	  printf("Can't get process slot for PTY shell.\n");	  fflush(stdout);E 37E 23	  IOBuf[3] = 0;I 23D 37	else {	  /* ForkUnixShell sets the pid and standard in/out variables */	  ForkedStatus[slot] = -1;	  IOBuf[1] = slot;E 37	}E 23D 37      } else IOBuf[3] = 0;      break;E 37I 37       break;E 37    case 'F':			/* Fork pipe command */D 23      for (PIDn = 0; 	   (ForkedPIDs[PIDn] != 0 && PIDn < NPROCS); 	   PIDn++);      if (ForkedPIDs[PIDn] == 0) {E 23I 23D 37      if ((slot = find_process_slot(0)) >= 0) {E 37I 37      if (slot >= 0) 		{E 37	/* Find a free process slot */E 23D 37	pipe(ProcessToUnix);	/* Create pipe between subprocess and here */	pipe(UnixToProcess);I 21D 23	pipe(PS);E 21	ForkedIns[PIDn] = ProcessToUnix[0];	ForkedOuts[PIDn] = UnixToProcess[1];I 21	ForkedStatus[PIDn] = PS[0];E 23I 23	ForkedIns[slot] = ProcessToUnix[0];	ForkedOuts[slot] = UnixToProcess[1];	ForkedStatus[slot] = -1;E 37E 23E 21D 37        /* These calls make sure we never block trying to do IO */	res = fcntl(UnixToProcess[1], F_GETFL);	res |= FNDELAY;	res = fcntl(UnixToProcess[1], F_SETFL, res);	res = fcntl(ProcessToUnix[0], F_GETFL);	res |= FNDELAY;	res = fcntl(ProcessToUnix[0], F_SETFL, res);I 21D 23	res = fcntl(PS[0], F_GETFL);	res |= FNDELAY;	res = fcntl(PS[0], F_SETFL, res);E 23E 21E 37	/* Read in the length of the shell command, and then the command */D 37	read(LispPipeIn, tmp, 1);	read(LispPipeIn, shcom, *tmp);E 37I 37	if(read(LispPipeIn, tmp, 1)<0) perror("Slave reading cmd length");	if(read(LispPipeIn, shcom, *tmp)<0) perror("Slave reading cmd");	DBPRINT(("Cmd len = %d.\n", *tmp));	DBPRINT(("Rev'd cmd string: %s\n", shcom));E 37D 23	ForkedPIDs[PIDn] = fork(); /* Fork */E 23I 23	ForkedPIDs[slot] = fork(); /* Fork */E 23D 23	/* We do a setpgrp so that we can easily kill all the little babies 	if (ForkedPIDs[PIDn] != 0) 	  setpgrp(ForkedPIDs[PIDn], ForkedPIDs[PIDn]); */E 23I 23D 37	if (ForkedPIDs[slot] == 0) {	  int i;I 25	  int status;E 37I 37	if (ForkedPIDs[slot] == 0)	  {	    int i;	    int status, sock;	    struct sockaddr_un addr;	    char PipeName[40];E 37E 25E 23D 23	if (ForkedPIDs[PIDn] == 0) {E 23D 37	  /* Copy the pipes onto stdin, stdout, and stderr */	  dup2(UnixToProcess[0],0);	  dup2(ProcessToUnix[1],1);	  dup2(ProcessToUnix[1],2);E 37I 37	    sock = socket(AF_UNIX, SOCK_STREAM, 0);	    if (sock < 0) {perror("slave socket"); exit(0);}	    sprintf(PipeName, "/tmp/LispPipe%d-%d", StartTime, slot);	    addr.sun_family = AF_UNIX;	    strcpy(addr.sun_path, PipeName);	    status = connect(sock, (struct sockaddr *)&addr,			     strlen(PipeName)+sizeof(addr.sun_family));	    if(status<0)	      {		perror("slave connect");		printf("Name = %s.\n", PipeName); fflush(stdout);		exit(0);	      }	    else	      {		DBPRINT(("Slave connected on %s.\n", PipeName));	      }E 37I 23D 37	  /* Make sure everything else is closed */	  for (i = 3; i < getdtablesize(); i++)	    close(i);E 37I 37	    /* Copy the pipes onto stdin, stdout, and stderr */	    dup2(sock,0);	    dup2(sock,1);	    dup2(sock,2);E 45 D 45	    /* Make sure everything else is closed */	    for (i = 3; i < getdtablesize(); i++)	      close(i);E 45E 37E 23D 37	  /* Run the shell command and get the result */D 23	  res = system(shcom);I 21	  tmp[0] = (res >> 8) & 0xff;	  tmp[1] = res & 0xff;	  write(PS[1], tmp, 2);E 21	  exit(res);E 23I 23D 25	  _exit(system(shcom));E 25I 25	  status = system(shcom);	  _exit((status & ~0xff) ? (status >> 8) : status);E 25E 23	}E 37I 37D 45	    /* Run the shell command and get the result */	    status = system(shcom);	    unlink(PipeName);	    _exit((status & ~0xff) ? (status >> 8) : status);	  }E 37D 37	/* Make sure we don't have an IO conflict */	close(UnixToProcess[0]);	close(ProcessToUnix[1]);E 37	/* Check for error doing the fork */D 23	if (ForkedPIDs[PIDn] == -1) {	  perror("unixcomm");E 23I 23D 37	if (ForkedPIDs[slot] == -1) {	  ForkedPIDs[slot] = 0;	  close(UnixToProcess[1]);	  close(ProcessToUnix[0]);	  perror("unixcomm: fork");E 23	  IOBuf[3] = 0;	}D 23	else	  IOBuf[1] = PIDn++;      } else IOBuf[3] = 0;E 23I 23	else {	  IOBuf[1] = slot;	  /* We do a setpgrp so that we can easily kill all the	     little babies */	  /* setpgrp(ForkedPIDs[slot], ForkedPIDs[slot]); */E 37I 37	if (ForkedPIDs[slot] == -1)	  {	    ForkedPIDs[slot] = 0;	    perror("unixcomm: fork");	    IOBuf[3] = 0;	  }	else	  {	    IOBuf[1] = (ForkedPIDs[slot]>>8)& 0xFF;	    IOBuf[2] = ForkedPIDs[slot] & 0xFF;E 37D 37	}E 37I 37	  }E 37      } else IOBuf[3] = 0; /* Couldn't get a process slot */E 23      break;D 37    case 'W':			/* Write byte */E 37D 23      if (write(ForkedOuts[IOBuf[1]], IOBuf+2, 1) == -1)	IOBuf[3] = 0;      else	IOBuf[3] = 1;E 23I 23D 37      slot = IOBuf[1];      /* 1 means success, 0 means error */D 24      IOBuf[3] = (slot >= 0 && slot < NPROCS &&E 24I 24D 30      IOBuf[3] = (valid_slot(slot) &&E 30I 30      IOBuf[3] = (valid_slot(slot) && (ForkedStatus[slot] == -1) &&E 30E 24	          (write(ForkedOuts[slot], &IOBuf[2], 1) != -1));E 23      break;E 37I 37    case 'W':			/* Wait for a process to die. */      {	int pid;	union wait status;	int slot;E 37D 37    case 'R':			/* Read byte */E 37I 37	status.w_status = 0;	IOBuf[0] = 0; IOBuf[1] = 0;	DBPRINT(("About to wait for processes.\n"));	if (((pid = wait3(&status, WNOHANG, 0)) != 0))	  {	    /* Ignore processes which are suspended but haven't exited	       (this shouldn't happen) */	    if (status.w_stopval == WSTOPPED) break;	    IOBuf[3] = status.w_T.w_Retcode;	    IOBuf[2] = status.w_T.w_Termsig;	    IOBuf[1] = pid & 0xFF;	    IOBuf[0] = (pid>>8) & 0xFF;          }	DBPRINT(("wait3 returned pid = %d.\n", pid));      }E 37D 23      res = read(ForkedIns[IOBuf[1]], IOBuf+2, 1);E 23I 23D 37      slot = IOBuf[1];E 23D 23      /* Return EOF for any error other than no characters to read */      if (res == -1) 	IOBuf[3] = (errno == EWOULDBLOCK) ? 2 : 0;      if (res == 0)	IOBuf[3] = 0;E 23I 23      /* Return EOF (0) for any error other than no characters to read */D 24      IOBuf[3] = (slot >= 0 && slot < NPROCS ?E 24I 24      IOBuf[3] = (valid_slot(slot) ?E 24	          ((res = read(ForkedIns[slot], &IOBuf[2], 1)) == -1 ?		   (errno == EWOULDBLOCK ? 2 : 0) :		   (res != 0)) :		  0);E 37E 23      break;D 37    case 'E':			/* Kill all subprocesses */D 22      for (i = 0; i < NPROCS; i++)	/* If this slot has an active job */	if (ForkedPIDs[i] != 0) {	  /* Kill it and all it's kids */	  kill(ForkedPIDs[i], SIGKILL);	  /* Close the pipes */	  close(ForkedIns[i]);	  close(ForkedOuts[i]);	  ForkedPIDs[i] = 0;	}E 22I 22      kill_comm_processes();E 22      break;E 37I 20    case 'C':			/* Close stdin to subprocess */I 23      slot = IOBuf[1];E 23      /* If this is a valid job */D 23      if (ForkedPIDs[IOBuf[1]] != 0)	/* And it didn't fail to start */	if (ForkedPIDs[IOBuf[1]] != -1)E 23I 23D 24      if (slot >= 0 && slot < NPROCS &&	  (pid = ForkedPIDs[slot]) != 0) {E 24I 24      if (valid_slot(slot)) {E 24E 23	  /* First check to see it hasn't already died */D 23	  if (ForkedStatus[IOBuf[1]] != -1)	    close(ForkedIns[IOBuf[1]]);E 23I 23	  if (ForkedStatus[slot] != -1) {D 37	    close(ForkedIns[slot]);	    ForkedIns[slot] = -1;E 37I 37	    ForkedIns[slot] = 0;E 37	  }      }E 23      break;D 34      E 34I 34E 34E 20    case 'K':			/* Kill subprocess */I 23D 37      slot = IOBuf[1];E 23      /* If this is a valid job */D 23      if (ForkedPIDs[IOBuf[1]] != 0) {	/* And it didn't fail to start */	if (ForkedPIDs[IOBuf[1]] != -1) {	  /* First check to see it hasn't already died */D 21	  if (ForkedStatus[IOBuf[1]] != -1) {E 21I 21	  if (ForkedStatus[IOBuf[1]] == -1) {E 21	    /* Kill the job */	    kill(ForkedPIDs[IOBuf[1]], SIGKILL);	    while (ForkedStatus[IOBuf[1]] == -1)	      while (((PIDn = wait3(ProcessStatus, WNOHANG, 0)) != 0) && 		     (PIDn != -1)) {		for (i = 0; (i < NPROCS) && (ForkedPIDs[i] != PIDn); i++);D 21		if (ForkedPIDs[i] == PIDn)		  ForkedStatus[i] = ProcessStatus->w_status;E 21I 21		if (ForkedPIDs[i] == PIDn) {		  ForkedStatus[i] = 0;		}E 21E 19	      }D 19	      close(UnixToProcess[0]);	      close(ProcessToUnix[1]);	      if (ForkedPIDs[PIDn] == -1) {		perror("unixcomm");		IOBuf[3] = 0;	      }	      else		IOBuf[1] = PIDn++;	    } else IOBuf[3] = 0;E 11	    break;	  case 'W':D 9/*	    if(ioctl(ForkedOuts[IOBuf[1]], TIOCOUTQ, &rdy) != -1) {	      if (rdy < 4095) */		write(ForkedOuts[IOBuf[1]], IOBuf+2, 1);/*	      else		IOBuf[3] = 0;	    }	    else perror("unixcomm"); */E 9I 9	    if (write(ForkedOuts[IOBuf[1]], IOBuf+2, 1) == -1)D 11	      {		if (ForkedPIDs[IOBuf[1]] > 0)E 11		  IOBuf[3] = 0;		elseD 11		  IOBuf[3] = -1;	      }E 11I 11		  IOBuf[3] = 1;E 11E 9	    break;I 7D 9E 9E 7	  case 'R':D 7	    if(ioctl(ForkedIns[IOBuf[1]], FIONREAD, &rdy) != -1) {	      if (rdy > 0)		read(ForkedIns[IOBuf[1]], IOBuf+2, 1);	      else		IOBuf[3] = 0;	    }	    else	      perror("unixcomm");E 7I 7D 11	    IOBuf[3] = read(ForkedIns[IOBuf[1]], IOBuf+2, 1);E 11I 11	    res = read(ForkedIns[IOBuf[1]], IOBuf+2, 1);I 18	    /* Return EOF for any error other than no characters to read */E 18	    if (res == -1) D 18	      IOBuf[3] = 2;E 18I 18	      IOBuf[3] = (errno == EWOULDBLOCK) ? 2 : 0;E 18	    if (res == 0)	      IOBuf[3] = 0;E 11E 7D 9	    break;I 7E 9I 9   	    break;E 9E 7	  case 'K':D 7	    if (kill(ForkedPIDs[IOBuf[1]], 9) != -1)E 7I 7D 9	    if (kill(ForkedPIDs[IOBuf[1]], SIGTERM) == -1) {E 7	      IOBuf[3] = 0;D 7	    elseE 7	      perror("unixcomm");D 7	    close(ForkedIns[IOBuf[1]]);	    close(ForkedOuts[IOBuf[1]]);	    ForkedPIDs[IOBuf[1]] = 0;	    break;E 7I 7	    } else {E 9I 9	    if (ForkedPIDs[IOBuf[1]] != 0) {	      if (ForkedPIDs[IOBuf[1]] != -1)		kill(ForkedPIDs[IOBuf[1]], SIGTERM);I 11	      if (ForkedStatus[IOBuf[1]] > 0) {		res = read(ForkedStatus[IOBuf[1]], tmp, 2);		if (res == 2) {		  IOBuf[1] = tmp[0];		  IOBuf[2] = tmp[1];		}	      }	      else IOBuf[3] = 0;E 11E 9	      close(ForkedIns[IOBuf[1]]);	      close(ForkedOuts[IOBuf[1]]);I 11	      close(ForkedStatus[IOBuf[1]]);E 11	      ForkedPIDs[IOBuf[1]] = 0;D 9	      break;E 9	    }I 9	    break;E 19E 9E 7	  }D 9	  write(LispPipeOut, IOBuf, 4);E 9I 9D 19	write(LispPipeOut, IOBuf, 4);E 19I 19D 21	  IOBuf[2] = ProcessStatus[IOBuf[1]];E 21I 21	  IOBuf[1] = (ForkedStatus[IOBuf[1]] >> 8) & 0xff;	  IOBuf[2] = ForkedStatus[IOBuf[1]]  & 0xff;E 23I 23D 24      if (slot >= 0 && slot < NPROCS &&	  (pid = ForkedPIDs[slot]) != 0) {E 24I 24      if (valid_slot(slot)) {E 24	/* First check to see it hasn't already died */        if (ForkedStatus[slot] == -1) {I 25	  int i;E 25	  /* Kill the job */I 25	  pid = ForkedPIDs[slot];E 25	  /* killpg(pid, SIGKILL); *//* In case it changed its process group */D 34	  kill(pid, SIGKILL); E 34I 34	  kill(pid, SIGKILL);E 34D 25	  while (ForkedStatus[slot] == -1)	    wait_for_comm_processes();E 25I 25	  for (i = 0; i < 10; i++) {	    /* Waiting for the process to exit is possibly risky.	       Sending SIGKILL is always supposed to kill	       a process, but on very rare occurrences this doesn't	       happen because of a Unix kernel bug, usually a user-written	       device driver which hasn't been fully debugged.  So we	       time it out just be safe. */	    if (ForkedStatus[slot] != -1)	      break;	    wait_for_comm_processes(0);	    sleep(1);	  }E 25E 23E 21E 19E 9	}I 19D 23	else IOBuf[3] = 0;E 23I 23	IOBuf[1] = (ForkedStatus[slot] >> 8) & 0xff;	IOBuf[2] = ForkedStatus[slot]  & 0xff;	close(ForkedOuts[slot]);	close(ForkedIns[slot]);	ForkedPIDs[slot] = 0;E 23E 19      }I 19D 23      else IOBuf[3] = 0;      close(ForkedOuts[IOBuf[1]]);      close(ForkedIns[IOBuf[1]]);I 21      close(ForkedStatus[IOBuf[1]]);E 21      ForkedPIDs[IOBuf[1]] = 0;E 23I 23      else /* Not a valid process number */	IOBuf[3] = 0;E 37E 23      break;D 23    }E 23E 19I 23    } /* End of switch */E 23I 19D 34    /* Return the status/data packet */ E 34I 34    /* Return the status/data packet */E 34    write(LispPipeOut, IOBuf, 4);  }}E 19I 22I 36E 45/************************************************************************//*									*//*		f i n d _ p r o c e s s _ s l o t			*//*									*/D 45/*	Find the slot in ForkedPIDs with process id 'pid'.		*//*	If 'pid' is 0, find the first free slot.			*//*	Returns the slot #, or -1 if pid isn't found (or none free)	*/E 45I 45/*	Find the slot in UJ with process id 'pid'.		        *//*	Returns the slot #, or -1 if pid isn't found                    */E 45/*									*//*									*//************************************************************************/int find_process_slot(pid)D 45/* Find a slot with the specified pid (can be 0 to find a free slot) */E 45I 45/* Find a slot with the specified pid */E 45  register int pid;  {    register int slot;    for (slot = 0; slot < NPROCS; slot++)D 37      if (ForkedPIDs[slot] == pid) return slot;E 37I 37D 45      if (ForkedPIDs[slot] == pid)E 45I 45      if (UJ[slot].PID == pid)E 45	{	  DBPRINT(("find_process_slot = %d.\n", slot));	  return slot;	}E 37    return -1;  }D 45/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 45/************************************************************************//*									*//*		w a i t _ f o r _ c o m m _ p r o c e s s e s		*//*									*//*									*//*									*//*									*//************************************************************************/E 36D 23kill_comm_processes()E 23I 23D 25wait_for_comm_processes()E 25I 25D 45wait_for_comm_processes(hang)     int hang;E 45I 45wait_for_comm_processes()E 45E 25E 23{D 23  int i;E 23I 23  int pid;D 37  union wait status;E 37  int slot;I 37  unsigned char d[5];E 37E 23D 23  for (i = 0; i < NPROCS; i++)E 23I 23D 25  while (((pid = wait3(&status, WNOHANG, 0)) != 0) && (pid != -1)) {    if ((slot = find_process_slot(pid)) >= 0) {      if (status.w_T.w_Termsig == 0)	printf("Process %d exited status %d\n", pid, status.w_T.w_Retcode);      else	printf("Process %d terminated with signal %d\n", pid, 	       status.w_T.w_Termsig);      close(ForkedIns[slot]);      ForkedIns[slot] = -1; /* In case user tries to close it */      close(ForkedOuts[slot]);      ForkedOuts[slot] = -1;      ForkedStatus[slot] = status.w_status;E 25I 25D 37  status.w_status = 0;  while (((pid = wait3(&status, hang ? 0 : WNOHANG, 0)) != 0) && (pid != -1)) {I 29    /* Ignore processes which are suspended but haven't exited       (this shouldn't happen) */    if (status.w_stopval == WSTOPPED)      continue;E 29    slot = find_process_slot(pid);D 29    if (status.w_T.w_Termsig == 0) {E 29I 29    /* Ignore processes that we didn't start (shouldn't happen but       occasionally does) */    if (slot >= 0) {      if (status.w_T.w_Termsig == 0) {E 37I 37  d[0] = 'W';  write(UnixPipeOut, d, 4);  read(UnixPipeIn, d, 4);  pid = (d[0]<<8) | d[1];  while ((pid != 0) && (pid != 65535))    {      slot = find_process_slot(pid);      /* Ignore processes that we didn't start (shouldn't happen but         occasionally does) */      if (slot >= 0)	{	  if (d[2] == 0)	    {E 37E 29I 27D 45#ifdef  DEBUGE 27D 29      printf("Process %d exited status %d\n", pid, status.w_T.w_Retcode);E 29I 29D 37	printf("Process %d exited status %d\n", pid, status.w_T.w_Retcode);E 37I 37	      printf("Process %d exited status %d\n", pid, d[3]);E 37E 29I 27#endifE 27D 29      ForkedStatus[slot] = status.w_T.w_Retcode;E 25    }I 25    else {E 29I 29D 37	ForkedStatus[slot] = status.w_T.w_Retcode;      }      else {E 37I 37	      ForkedStatus[slot] = d[3];E 45I 45	      DBPRINT(("Process %d exited status %d\n", pid, d[3]));	      UJ[slot].status = d[3];E 45	    }	  else	    {E 37E 29I 27D 45#ifdef  DEBUGE 27D 29      printf("Process %d terminated with signal %d\n", pid, 	     status.w_T.w_Termsig);E 29I 29D 34	printf("Process %d terminated with signal %d\n", pid, E 34I 34D 37	printf("Process %d terminated with signal %d\n", pid,E 34	       status.w_T.w_Termsig);E 37I 37	      printf("Process %d terminated with signal %d\n", pid, d[2]);E 37E 29I 27#endifE 27D 29      ForkedStatus[slot] = status.w_T.w_Termsig << 8;E 29I 29D 37	ForkedStatus[slot] = status.w_T.w_Termsig << 8;      }E 37I 37	      ForkedStatus[slot] = (d[2] << 8);E 45I 45	      DBPRINT(("Process %d terminated with signal %d\n", pid, d[2]));	      UJ[slot].status = (d[2] << 8);E 45            }	}      /* Look for another stopped process. */      d[0] = 'W';      write(UnixPipeOut, d, 4);      read(UnixPipeIn, d,4);      pid = (d[0]<<8) | d[1];E 37E 29    }D 29/*    if ((slot = find_process_slot(pid)) >= 0)      ForkedStatus[slot] = status.w_status; */E 29E 25D 37  }E 37}E 23I 45/************************************************************************//*									*//*		b u i l d _ s o c k e t _ p a t h n a m e               *//*									*//*	Returns a string which is the pathname associated with a        *//*       socket descriptor.  Has ONE string buffer.                     *//************************************************************************/I 59#ifndef ISCchar *build_socket_pathname(desc)int desc;{  static char PathName[50];E 59E 45I 23I 59  sprintf(PathName, "/tmp/LPU%d-%d", StartTime, desc);  return(PathName);}#elseE 59I 45D 58char *build_socket_pathname(desc)E 58I 58char *build_upward_socket_pathname(desc)E 58int desc;{D 58  static char PathName[40];E 58I 58  static char UpPathName[50];E 58E 45I 36I 45D 58  sprintf(PathName, "/tmp/LispPipe%d-%d", StartTime, desc);  return(PathName);E 58I 58  sprintf(UpPathName, "/tmp/LPU%d-%d", StartTime, desc);  return(UpPathName);E 58}I 58char *build_downward_socket_pathname(desc)int desc;{  static char DownPathName[50];E 58I 58  sprintf(DownPathName, "/tmp/LPD%d-%d", StartTime, desc);  return(DownPathName);}I 59#endif /* ISC */E 59D 59E 59E 58E 45/************************************************************************//*									*/I 37D 45/*		k i l l _ c o m m _ p r o c e s s e s			*/E 45I 45/*		c l o s e _ u n i x _ d e s c r i p t o r s             */E 45E 37/*									*/I 37/*	Kill off forked PTY-shells and forked-command processes		*/I 45/*	Also close sockets						*/E 45E 37/*									*/D 45/*									*/E 45D 37/*									*//*									*/E 37/************************************************************************/E 36D 45kill_comm_processes() /* Kill all the subprocesses we started */E 45I 45close_unix_descriptors() /* Get ready to shut Maiko down */E 45{  int slot;D 45  for (slot = 0; slot < NPROCS; slot++)E 45I 45  for (slot = 0; slot < NPROCS; slot++) {E 45E 23    /* If this slot has an active job */D 23    if (ForkedPIDs[i] != 0) {E 23I 23D 45    if (ForkedPIDs[slot] != 0) {E 45I 45    switch(UJ[slot].type) {E 45E 23D 23      /* Kill it and all it's kids */      kill(ForkedPIDs[i], SIGKILL);E 23I 23D 45      /* Kill it and all its kids */      /* killpg(ForkedPIDs[slot], SIGKILL); */D 37      kill(ForkedPIDs[slot], SIGKILL);E 37I 37      if (kill(ForkedPIDs[slot], SIGKILL)<0) perror("Killing process");E 37I 25      ForkedPIDs[slot] = 0;I 37      if (ForkedProcType[slot] == -1)	{	  DBPRINT(("Kill 5 closing desc %d.\n", ForkedIns[slot]));	  close(ForkedIns[slot]);	  ForkedProcType[slot] = 0;	}      else if (ForkedProcType[slot] == -2)	/* named socket pair */	{	  char PipeName[40];	  DBPRINT(("Kill 5 closing desc %d.\n", ForkedIns[slot]));	  close(ForkedIns[slot]);	  ForkedProcType[slot] = 0;	  sprintf(PipeName, "/tmp/LispPipe%d-%d", StartTime, slot);	  unlink(PipeName);	}E 45I 45    case UJSHELL:      if (kill(UJ[slot].PID, SIGKILL)<0) perror("Killing shell");      UJ[slot].PID = 0;      DBPRINT(("Kill 5 closing shell desc %d.\n", slot));      close(slot);      break;E 45E 37E 25E 23I 45    case UJPROCESS:      if (kill(UJ[slot].PID, SIGKILL)<0) perror("Killing process");      UJ[slot].PID = 0;      DBPRINT(("Kill 5 closing process desc %d.\n", slot));      close(slot);      break;    case UJSOCKET:      close(slot);      if(UJ[slot].pathname != NULL) {	/* socket created directly from Lisp; pathname is in .pathname */	DBPRINT(("Closing socket %d bound to %s\n", slot, UJ[slot].pathname));	unlink(UJ[slot].pathname);	free(UJ[slot].pathname);	UJ[slot].pathname = NULL;      }      break;    case UJSOSTREAM:      close(slot);      break;E 45D 37      /* Close the pipes */D 23      close(ForkedIns[i]);      close(ForkedOuts[i]);      ForkedPIDs[i] = 0;E 23I 23      close(ForkedIns[slot]);      close(ForkedOuts[slot]);E 37E 23    }I 23D 36  wait_for_comm_processes();E 36I 36D 45  wait_for_comm_processes(0);E 45I 45    UJ[slot].type = UJUNUSED;  }/* make sure everyone's really dead before proceeding */  wait_for_comm_processes();E 45E 36E 23}E 22I 19I 45/************************************************************************//*								        *//*			F i n d U n i x P i p e s		        *//*								        *//*   Find the file descriptors of the UnixPipe{In,Out} pipes	        *//*    and a few other important numbers that were set originally        *//*    before the unixcomm process was forked off; it stuck them in the  *//*    environment so we could find them after the original lde process  *//*    got overlaid with the real emulator			        *//*                                                                      *//************************************************************************/E 45D 36/* Valid PTY names are [pqr][0123456789abcdef], if your system is set updifferently, change this! */E 36I 45FindUnixPipes(){  char *envtmp, *getenv();  register int i;  struct unixjob cleareduj;E 45I 36I 45  DBPRINT(("Entering FindUnixPipes\n"));  UnixPipeIn = UnixPipeOut = StartTime = UnixPID = -1;  if(envtmp = getenv("LDEPIPEIN"))    UnixPipeIn = atoi(envtmp);  if(envtmp = getenv("LDEPIPEOUT"))    UnixPipeOut = atoi(envtmp);  if(envtmp = getenv("LDESTARTTIME"))    StartTime = atoi(envtmp);  if(envtmp = getenv("LDEUNIXPID"))    UnixPID = atoi(envtmp);  /* This is a good place to initialize stuff like the UJ table */I 52#ifdef HPUX  NPROCS = sysconf(_SC_OPEN_MAX);#elseE 52  NPROCS = getdtablesize();I 52D 60#endif HPUXE 60I 60#endif /* HPUX */E 60E 52  UJ = (struct unixjob *) malloc(NPROCS * sizeof(struct unixjob));  cleareduj.status = -1;  cleareduj.pathname = NULL;  cleareduj.PID = 0;I 58  cleareduj.readsock = 0;E 58  cleareduj.type = UJUNUSED;  for(i=0; i< NPROCS; i++) UJ[i] = cleareduj;  DBPRINT(("NPROCS is %d; leaving FindUnixPipes\n", NPROCS));  return (UnixPipeIn == -1	  || UnixPipeOut == -1	  || StartTime == -1	  || UnixPID == -1);}E 45/************************************************************************//*									*//*		    F i n d A v a i l a b l e P t y			*//*									*//*	Given strings Master and Slave, fill them with path names	*//*	of the forms:							*//*									*//*		Master:  /dev/ptyxx					*//*		Slave:   /dev/ttyxx					*//*									*//*	Which are the first available pty/tty pair for communicating	*//*	with a forked shell.						*//*									*//*	Assumes that valid PTY names are [pqr][0-f]; if your system	*//*	is different, you'll need to change it.				*//*									*//************************************************************************/E 36E 19I 9D 11UpdateProcessStatus(){  union wait status;  int pid, i;  while ((pid == wait3(&status, WNOHANG, 0)) > 0)    for (i = 0; i < 100; i++) {      if (pid == ForkedPIDs[i]) {	ForkedStatus[i] = status.w_status;	ForkedPIDs[i] = -1;	i = 100;      }    }}E 11E 9I 7#define PTYLETTERS "pqr"#define PTYNUMBERS "0123456789abcdef"E 7I 19/* Find the first PTY pair that is not in use */E 19I 7FindAvailablePty(Master, Slave)char *Master, *Slave;{D 36  int res;E 36I 36  int res, flags;E 36  char *let, *num;I 60#ifdef INDIGO        let = (char *) _getpty(&res, O_RDWR|O_NDELAY, 0600, 0);    strcpy(Slave, let);#elseE 60I 19  /* From p to r */E 19  for (let = PTYLETTERS; *let != 0; let++)I 19    /* and 0 to f */E 19    for (num = PTYNUMBERS; *num != 0; num++) {I 19E 19      sprintf(Master, "/dev/pty%c%c", *let, *num);D 36      sprintf(Slave, "/dev/tty%c%c", *let, *num);I 19E 36I 36      sprintf(Slave, "%c%c", *let, *num);      DBPRINT(("Trying %s. ", Master));E 36      /* Try to open the Master side */E 19D 10      printf("Trying %s / %s\n", Master, Slave);E 10      res = open(Master, O_RDWR);I 60#endifE 60D 36      if (res != -1) return(res);E 36I 36      if (res != -1)	{D 37	  flags = fcntl(res, F_GETFL);E 37I 37	  flags = fcntl(res, F_GETFL, 0);I 58#ifdef ISC	  flags |= O_NONBLOCK;#elseE 58E 37	  flags |= FNDELAY;I 58D 60#endif ISCE 60I 60#endif /* ISC */E 60E 58	  flags = fcntl(res, F_SETFL, flags);	  return(res);	}I 60#ifndef INDIGOE 60E 36    }I 60#endif /* because we commented out the for above also... */E 60  return(-1);}D 34  E 34I 34E 34D 9ForkUnixShell(PIDn, Pipe)int PIDn, Pipe;E 9I 9D 19ForkUnixShell()E 19I 19D 36/* Creates a PTY connection to a csh */E 36D 23ForkUnixShell(PIDn)E 23I 23D 36ForkUnixShell(slot)     int slot;E 23E 19E 9{  char PtyMaster[20], PtySlave[20], buf[1];  int res, PID, MasterFD, SlaveFD;I 9  struct sgttyb tio;E 36E 9I 19D 36  /* Get a PTY pair */E 19  MasterFD = FindAvailablePty(PtyMaster, PtySlave);E 36I 19D 36  /* None available? */E 19  if (MasterFD == -1) return(-1);E 36I 36D 45/************************************************************************//*									*/I 37/*			F o r k U n i x S h e l l			*/E 37/*									*/I 37/*	Fork a PTY connection to a C-shell process.			*/E 37/*									*//*									*/D 37/*									*//*									*/E 37/************************************************************************/E 45E 36D 36  PID = fork();E 36D 36  if (PID == 0) {E 36I 36D 45/* Creates a PTY connection to a csh */E 45E 36I 19D 36    /* Divorce ourselves from /dev/tty */E 19    res = open("/dev/tty", O_RDWR);    if (res >= 0) {      (void) ioctl(res, TIOCNOTTY, (char *)0);      (void) close(res);    }E 36I 36D 41ForkUnixShell(slot, ltr, numb)E 41I 41D 45ForkUnixShell(slot, ltr, numb, termtype, shellarg)E 41  int slot;  char ltr, numb;I 41  char *termtype, *shellarg;E 41  {    char PtySlave[20], buf[1];    int res, PID, MasterFD, SlaveFD;D 41    struct sgttyb tio;E 41I 41    struct termios tio;E 41E 36I 19D 36    /* Open the slave side */E 19    SlaveFD = open(PtySlave, O_RDWR);    if (SlaveFD == -1) {      perror("Slave Open");      exit(0);    }E 36I 36D 41    /* Get a PTY pair */E 36D 34    E 34I 34E 41E 34I 19D 36    /* Set the terminal up to work with CHAT */E 19I 9    ioctl(SlaveFD, TIOCGETP, (char *)&tio);D 10    tio.sg_flags != CRMOD;    tio.sg_flags != ECHO;E 10I 10    tio.sg_flags |= CRMOD;    tio.sg_flags |= ECHO;E 10    ioctl(SlaveFD, TIOCSETP, (char *)&tio);E 9    (void) dup2(SlaveFD, 0);    (void) dup2(SlaveFD, 1);    (void) dup2(SlaveFD, 2);    (void) close(SlaveFD);E 36I 36    PID = fork();E 36D 9    execl("/bin/sh", "sh", "-i", 0);E 9I 9I 36    if (PID == 0)      {D 41E 41I 41	char envstring[64];	char *argvec[4];	E 41	/* Divorce ourselves from /dev/tty */D 38	res = open("/dev/tty", O_RDWR);E 38I 38D 41	res = open("/dev/tty", O_RDWR#ifdef HP				| O_NOCTTY#endif					   );E 41I 41	res = open("/dev/tty", O_RDWR);E 41E 38	if (res >= 0)	  {I 38#ifndef HPE 38	    (void) ioctl(res, TIOCNOTTY, (char *)0);I 38#endifE 38	    (void) close(res);	  }	else	  {	    perror("Slave TTY");	    exit(0);	  }	/* Open the slave side */	sprintf(PtySlave, "/dev/tty%c%c", ltr, numb);	SlaveFD = open(PtySlave, O_RDWR);	if (SlaveFD == -1)	  {	    perror("Slave Open");	    exit(0);	  }D 41	/* Set the terminal up to work with CHAT */E 41I 41/* This is the old way we set up terminal, using an   obsolete ioctl and wrong flags for a display.E 41	ioctl(SlaveFD, TIOCGETP, (char *)&tio);	tio.sg_flags |= CRMOD;	tio.sg_flags |= ECHO;	ioctl(SlaveFD, TIOCSETP, (char *)&tio);I 41*/	/* Set up as basic display terminal: canonical erase, kill processing, echo,	   backspace to erase, echo ctrl chars as ^x, kill line by backspacing */	ioctl(SlaveFD, TCGETS, (char *)&tio);	tio.c_lflag |= ICANON | ECHO | ECHOE | ECHOCTL | ECHOKE;	ioctl(SlaveFD, TCSETS, (char *)&tio);E 41	(void) dup2(SlaveFD, 0);	(void) dup2(SlaveFD, 1);	(void) dup2(SlaveFD, 2);	(void) close(SlaveFD);I 41E 41E 36I 31D 32	/* set the TERM variable so the underlying .cshrc can see it andE 32I 32	/* set the LDESHELL variable so the underlying .cshrc can see it andE 32D 41		configure the shell appropriately */E 41I 41	   configure the shell appropriately, though this may not be so important any more */E 41D 32	putenv("TERM=lde");E 32I 32	putenv("LDESHELL=YES");E 32I 41	if ((termtype[0] != 0) && (strlen(termtype) < 59))	  { 		/* set the TERM environment var */	    sprintf(envstring, "TERM=%s", termtype);	    putenv(envstring);	  }E 41E 31I 19D 36    /* Start up csh */E 19    execl("/bin/csh", "csh", 0);E 36I 36	/* Start up csh */D 41	execl("/bin/csh", "csh", 0);E 41I 41	argvec[0] = "csh";	if (shellarg[0] != 0)	  {			/* setup to run command */	    argvec[1] = "-c";	/* read commands from next arg */	    argvec[2] = shellarg;	    argvec[3] = (char *) 0;	  }	  else argvec[1] = (char *) 0;E 41E 36I 19I 41	execv("/bin/csh", argvec);E 41D 36    /* Should never get here */E 19E 9    perror("execl");    exit(0);  }E 36I 36	/* Should never get here */D 41	perror("execl");E 41I 41	perror("execv");E 41	exit(0);      }E 36I 19D 34  /* Set the process group so all the kids get the bullet too E 34I 34D 36  /* Set the process group so all the kids get the bullet tooE 34  if (setpgrp(PID, PID) != 0)E 36I 36    /* Set the process group so all the kids get the bullet too    if (setpgrp(PID, PID) != 0)E 36D 41    perror("setpgrp"); */E 41I 41      perror("setpgrp"); */E 41D 36  /* Set up the IO not to block */E 19  res = fcntl(MasterFD, F_GETFL);  res |= FNDELAY;  res = fcntl(MasterFD, F_SETFL, res);E 36I 36    ForkedPIDs[slot] = PID;    return(1);  }E 36D 10  res = fcntl(MasterFD, F_GETFL);  if ((res & FNDELAY) == 0)    printf("No-delay not set\n");E 10D 23  ForkedIns[PIDn] = ForkedOuts[PIDn] = MasterFD;  ForkedPIDs[PIDn] = PID;E 23I 23D 36  ForkedIns[slot] = ForkedOuts[slot] = MasterFD;  ForkedPIDs[slot] = PID;E 23  return(1);}E 36D 19      E 19I 19D 36/* LISP subr to talk to fork_Unix. First argument is a number:   0 for Fork Pipe, Arg1 is a string for system(), returns Job # or NIL   1 for Write Byte, Arg1 is Job, Arg2 is Byte, returns 1 (success), NIL (fail)   2 for Read Byte, Arg1 is Job, returns Byte, NIL (no data), T (EOF)   3 for Kill Job, Arg1 is Job, returns Status or T   4 for Fork PTY, returns Job # or NIL   5 for Kill All, returns TI 20   6 for Close (EOF), Arg1 is Job #E 20*/E 36D 34   E 34I 34I 36E 45/************************************************************************//*									*//*		      U n i x _ h a n d l e c o m m			*//*									*//*	LISP subr to talk to the forked "Unix process".			*//*									*/D 41/*	The first argument (Arg[0]) is a number:			*//*		0 Fork Pipe, Arg1 is a string for system(),		*//*		  returns Job # or NIL					*//*		1 Write Byte, Arg1 is Job, Arg2 is Byte,		*//*		  returns 1 (success), NIL (fail)			*//*		2 for Read Byte, Arg1 is Job,				*//*		  returns Byte, NIL (no data), T (EOF)			*//*		3 for Kill Job, Arg1 is Job, returns Status or T	*//*		4 for Fork PTY, returns Job # or NIL			*//*		5 for Kill All, returns T				*//*		6 for Close (EOF), Arg1 is Job #			*/I 37/*		7 for Job status, Arg1 is job #.  Returns T or status	*/E 41I 41/*	The first argument (Arg[0]) is the command number.		*//*	Second argument (Arg[1]) is the Job # (except as indicated).	*/E 41E 37/*									*/I 41/*	Commands are:							*/E 41/*									*/I 41/*		0 Fork Pipe, Arg1 is a string for system();		*//*		     => Job # or NIL					*//*		1 Write Byte, Arg2 is Byte;				*//*		     => 1 (success), NIL (fail)				*//*		2 Read Byte => Byte, NIL (no data), or T (EOF)		*//*		3 Kill Job => Status or T				*//*		4 Fork PTY to Shell (no args) => Job # or NIL		*//*		5 Kill All (no args) => T				*//*		6 Close (EOF)						*//*		7 Job status => T or status				*//*		8 => the largest supported command # (11 now)		*//*		9 Read Buffer, Arg1 = vmempage (512 byte buffer)	*//*		     => byte count (<= 512), NIL (no data), or T (EOF)	*//*	       10 Set Window Size, Arg2 = rows, Arg3 = columns		*//*	       11 Fork PTY to Shell (obsoletes command 4)		*//*		     Arg1 = termtype, Arg2 = csh command string		*//*		     => Job # or NIL					*/I 48/*             12 Create Unix Socket                                    *//*                   Arg1 = pathname to bind socket to (string)         *//*                   => Socket # or NIL                                 *//*             13 Try to accept on unix socket                          *//*                   => Accepted socket #, NIL (fail) or T (try again)  *//*             14 Query job type                                        *//*                   => type number or NIL if not a job                 *//*             15 Write Buffer, Arg1 = Job #, Arg2 = vmempage,          *//*                  Arg3 = # of bytes to write from buffer              *//*                   => # of bytes written or NIL (failed)              */E 48E 41/*									*/D 41/*									*/E 41D 37/*									*/E 37/************************************************************************/E 36E 34E 19E 7Unix_handlecomm(args)D 45LispPTR *args;{D 11	int command,c, PID;E 11I 11D 17	int command,c, PID, i;E 17I 17D 37	int command,c, dest, PID, i;E 37I 37	int command,c, dest, PID, i, slot;E 37E 17E 11	LispPTR retval;D 11	char d[3], shcom[100];E 11I 11D 31	char d[3], b[1];E 31I 31D 37	unsigned char d[3], b[1];E 37I 37	unsigned char d[4], b[1];	unsigned char ch;	unsigned char buf[1];E 45I 45  LispPTR *args;  {I 56D 58#ifndef ISCE 56    int command,c, dest, PID, i, slot;E 58I 58    int command,c, dest, PID, i, slot, sock;E 58    LispPTR retval;    unsigned char d[4], b[1];    unsigned char ch;    unsigned char buf[1];E 45E 37E 31E 11I 37D 45	/* Check on all our processes, to see they're still alive. */	wait_for_comm_processes(0);E 45I 45    /* Get command */    N_GETNUMBER(args[0], command, bad);    DBPRINT(("Unix_handlecomm: trying %d\n", command));E 45E 37I 19D 45	/* Get command */E 19D 15	GetNumber(args[0], command);E 15I 15	N_GETNUMBER(args[0], command, bad);E 45I 45    switch(command)      {E 45E 15D 45	switch(command) {D 19		/* Read byte */	case 0:E 19I 19E 45	case 0:			/* Fork pipe process */E 19D 37	  d[0] = 'F';	  d[3] = 1;E 37I 37	  {D 45	    char PipeName[30];E 45I 45D 58	    char *PipeName;E 58I 58D 59	    char *UpPipeName, *DownPipeName;E 59I 59	    char *UpPipeName, *DownPipeName, *PipeName;E 59E 58E 45	    int res, slot, PipeFD, sockFD;D 58	    struct sockaddr_un sock;E 58I 58D 60/*	    struct sockaddr_un sock; */E 60E 58E 37D 19	  LispStringToCString(args[1],shcom);E 19I 19I 59#ifndef ISCE 59E 19D 37	  write(UnixPipeOut, d, 4);E 37I 37D 45	    d[0] = 'F';	    slot = find_process_slot(0);	    if (slot < 0) return(NIL);	    d[3] = slot;E 37I 19E 45I 45	    /* First create the socket */I 60	    struct sockaddr_un sock; E 60E 45D 37	  /* Convert string to C  */	  LispStringToCString(args[1],shcom);E 37I 37D 58	    sockFD = socket(AF_UNIX, SOCK_STREAM, 0);	    if (sockFD < 0) { perror("socket open"); return(NIL);}E 58I 58D 59	    /* sockFD = socket(AF_UNIX, SOCK_STREAM, 0);	    if (sockFD < 0) { perror("socket open"); return(NIL);} */E 59I 59	    sockFD = socket(AF_UNIX, SOCK_STREAM, 0);	    if (sockFD < 0) { perror("socket open"); return(NIL);}E 59E 58D 45	    sprintf(PipeName, "/tmp/LispPipe%d-%d", StartTime, slot);E 45I 45	    /* then bind it to a canonical pathname */D 58	    PipeName = build_socket_pathname(sockFD);E 58I 58D 59	    /*PipeName = build_socket_pathname(sockFD);E 59I 59	    PipeName = build_socket_pathname(sockFD);E 59E 58E 45	    sock.sun_family = AF_UNIX;	    strcpy(sock.sun_path, PipeName);	    if (bind(sockFD, (struct sockaddr *) &sock,		     strlen(PipeName)+sizeof(sock.sun_family)) < 0)	      {		close(sockFD);		perror("binding sockets");I 59		unlink(PipeName);E 59		return(NIL);	      }I 45E 45	    DBPRINT(("Socket %d bound to name %s.\n", sockFD, PipeName));I 45E 45	    if(listen(sockFD, 1)<0) perror("Listen");I 58D 59*/E 59I 59#elseE 59E 58E 37I 58	    sockFD = open("/tmp/dummyforlisp" , O_CREAT);D 59printf("socket is %d.\n", sockFD); fflush(stdout);E 59	    UpPipeName = build_upward_socket_pathname(sockFD);	    DownPipeName = build_downward_socket_pathname(sockFD);D 59	    printf("Downward FIFO: %s\n", DownPipeName); fflush(stdout);	    printf("Upward FIFO: %s\n", UpPipeName); fflush(stdout);E 59	    DBPRINT(("Downward FIFO: %s\n", DownPipeName));	    DBPRINT(("Upward FIFO: %s\n", UpPipeName));I 59#ifdef sun	    if ((mknod(UpPipeName, 0777|S_IFIFO, 0) < 0) && (errno != EEXIST))	      {		perror("Making Upward FIFO");		printf("(named %s).\n", UpPipeName); fflush(stdout);	      }	    if ((mknod(DownPipeName, 0777|S_IFIFO, 0)<0) && (errno != EEXIST))	      {		perror("Making Downward FIFO");		printf("(named %s).\n", DownPipeName); fflush(stdout);	      }#elseE 59	    if (mkfifo(UpPipeName, 0777) < 0)	      {		perror("Making Upward FIFO");		printf("(named %s).\n", UpPipeName); fflush(stdout);	      }	    if (mkfifo(DownPipeName, 0777) < 0)	      {		perror("Making Downward FIFO");		printf("(named %s).\n", DownPipeName); fflush(stdout);	      }I 59#endif /* SUNs */E 59D 59	    PipeFD = open(DownPipeName, O_RDWR);	    if (PipeFD < 0) perror("Opening Down pipe from lisp");E 59I 59	    PipeFD= open(DownPipeName, O_WRONLY | O_NDELAY);	    if (PipeFD < 0)	      {		perror("Opening Down pipe from lisp");		printf("(Name is %s.)\n",DownPipeName); fflush(stdout);		close(sockFD);		return(NIL);	      }E 59	    dup2(PipeFD,sockFD);D 59	    PipeFD = open(UpPipeName, O_RDWR);	    if (PipeFD < 0) perror("Opening Up pipe from lisp");E 59I 59	    unlink("/tmp/dummyforlisp");E 59I 59	    PipeFD = open(UpPipeName, O_RDONLY | O_NDELAY);	    if (PipeFD < 0)	      {		perror("Opening Up pipe from lisp");		printf("(Name is %s.)\n", UpPipeName); fflush(stdout);		close(sockFD);		return(NIL);	      }#endif /* ISC */E 59E 58I 45	    d[0] = 'F';	    d[3] = sockFD;E 45D 37	  /* Write string length, then string */E 19I 11	  *b = strlen(shcom) +1;	  write(UnixPipeOut, b, 1);E 11	  write(UnixPipeOut, shcom, strlen(shcom)+1);E 37I 37	    write(UnixPipeOut, d, 4);I 41	    WriteLispStringToPipe(args[1]);E 41E 37I 19D 37	  /* Get status */E 19	  read(UnixPipeIn, d, 4);E 37I 37D 41	    /* Convert string to C  */	   LispStringToCString(args[1],shcom);E 37I 19D 37	  /* If it worked, return job # */E 19	  if (d[3] == 1)	    return(GetSmallp(d[1]));	  else	    return(NIL);	  break;E 37I 37	    /* Write string length, then string */	    *b = strlen(shcom) +1;	    write(UnixPipeOut, b, 1);	    write(UnixPipeOut, shcom, strlen(shcom)+1);E 41	    DBPRINT(("Sending cmd string: %s\n", shcom));I 45E 45	    /* Get status */	    read(UnixPipeIn, d, 4);E 37D 19	case 1:E 19I 19D 37	case 1:			/* Write byte */E 19	  d[0] = 'W';E 37I 37	    /* If it worked, return job # */	    if (d[3] == 1)	      {I 59#ifndef ISCE 59I 46	      case0_lp:E 46D 58		TIMEOUT(PipeFD = accept(sockFD, (struct sockaddr *) 0,E 58I 58D 59/*		TIMEOUT(PipeFD = accept(sockFD, (struct sockaddr *) 0,E 59I 59		TIMEOUT(PipeFD = accept(sockFD, (struct sockaddr *) 0,E 59E 58					(int *) 0));		if (PipeFD < 0)		  {I 46		    if (errno == EINTR) goto case0_lp;E 46		    perror("Accept.");		    close(sockFD);		    if (unlink(PipeName)<0) perror("Unlink");		    return(NIL);		  }I 45D 58E 58I 58D 59 */E 59I 59#endif /* oldPIPEway */E 59E 58E 45		res = fcntl(PipeFD, F_GETFL, 0);I 59#ifdef ISCE 59D 58		res |= FNDELAY;E 58I 58		res |= O_NONBLOCK;I 59#else		res |= FNDELAY;#endif /* ISC */E 59E 58		res = fcntl(PipeFD, F_SETFL, res);E 37I 19D 59E 59I 59		if (res < 0)		  {		    perror("setting up fifo to nodelay");		    return(NIL);		  }#ifdef ISCE 59D 37	  /* Get job #, Byte */E 19D 15	  GetNumber(args[1], d[1]);	  GetNumber(args[2], d[2]);E 15I 15D 17	  N_GETNUMBER(args[1], d[1], bad);	  N_GETNUMBER(args[2], d[2], bad);E 17I 17	  N_GETNUMBER(args[1], dest, bad);d[1] = dest;	  N_GETNUMBER(args[2], dest, bad);d[2] = dest;I 36	  if (ForkedPIDs[d[1]] != -1)	    {	      d[3] = 1;	      write(UnixPipeOut, d, 4);E 37I 37D 45		ForkedIns[slot] = ForkedOuts[slot] = PipeFD;		ForkedStatus[slot] = -1;		ForkedPIDs[slot] = (d[1]<<8) | d[2];		ForkedProcType[slot] = -2; /* so we can find them */		if(close(sockFD)<0)		  {perror("listen-socket close");}E 45I 45D 58		UJ[PipeFD].type = UJPROCESS;		UJ[PipeFD].status = -1;		UJ[PipeFD].PID = (d[1]<<8) | d[2];		close(sockFD);		unlink(PipeName);E 58I 58		UJ[sockFD].type = UJPROCESS;		UJ[sockFD].status = -1;		UJ[sockFD].PID = (d[1]<<8) | d[2];		UJ[sockFD].readsock = PipeFD;I 59#else		UJ[PipeFD].type = UJPROCESS;		UJ[PipeFD].status = -1;		UJ[PipeFD].PID = (d[1]<<8) | d[2];		UJ[PipeFD].readsock = 0;		close(sockFD);		unlink(PipeName);#endif /* ISC */E 59E 58E 45E 37E 36I 19E 19E 17E 15D 36	  d[3] = 1;	  write(UnixPipeOut, d, 4);E 36I 36D 37	      /* Get status */	      read(UnixPipeIn, d, 4);E 37I 37D 45		return(GetSmallp(slot));E 45I 45D 58		return(GetSmallp(PipeFD));E 58I 58D 59		/*close(sockFD); */		unlink(UpPipeName);		unlink(DownPipeName);E 59I 59		/* unlink(UpPipeName);		unlink(DownPipeName); */#ifdef ISCE 59		return(GetSmallp(sockFD));I 59#else		return(GetSmallp(PipeFD));#endif /* ISC */E 59E 58E 45	      }	    else	      {		DBPRINT(("Fork request failed."));I 59#ifdef ISCE 59D 58		close(sockFD);D 45		unlink(PipeName)<0;E 45I 45		unlink(PipeName);E 58I 58		close(sockFD); close(PipeFD);		unlink(UpPipeName);		unlink(DownPipeName);I 59#else		close(sockFD);		unlink(PipeName);#endif /* ISC */E 59E 58E 45		return(NIL);	      }	    break;	  }E 37E 36I 19D 36	  /* Get status */E 19	  read(UnixPipeIn, d, 4);I 19	  /* If it worked, return 1 */E 19	  if (d[3] == 1)D 9	    return(ATOM_T);	  elseE 9I 9	    return(GetSmallp(1));D 11	  if (d[3] == -1)E 11I 11D 19	  if (d[3] == 2)E 11E 9	    return(NIL);E 19I 9	  if (d[3] == 0)D 19	    return(ATOM_T);E 19I 19	    return(NIL);E 36I 36D 37	      /* If it worked, return 1 */	      if (d[3] == 1) return(GetSmallp(1));	      if (d[3] == 0) return(NIL);	    }	  elseE 37I 37	case 1:			/* Write byte */	  /* Get job #, Byte */D 41	  N_GETNUMBER(args[1], dest, bad);slot = dest;	  N_GETNUMBER(args[2], dest, bad);ch = dest;E 41I 41	  N_GETNUMBER(args[1], slot, bad);	  N_GETNUMBER(args[2], dest, bad); ch = dest; /* ch is a char */E 41D 45	  if (valid_slot(slot) && (ForkedStatus[slot] == -1))E 37	    {D 37	      DBPRINT(("Writing %c on desc #%d.\n",d[2], ForkedIns[d[1]]));	      dest = write(ForkedIns[d[1]], &d[2], 1);E 37I 37	      dest = write(ForkedIns[slot], &ch, 1);E 37	      if (dest == 0) return(NIL);E 45I 45	  if (valid_slot(slot) && (UJ[slot].status == -1))	    switch(UJ[slot].type) {	    case UJPROCESS:	    case UJSHELL:	    case UJSOSTREAM:	      dest = write(slot, &ch, 1);	      if (dest == 0) {		wait_for_comm_processes();		return(NIL);	      }E 45	        else return(GetSmallp(1));I 45	      break;	    default:  return(NIL);E 45	    }I 37D 45	  else return(NIL);E 45E 37E 36E 19E 9	  break;D 19	case 2:E 19I 19	case 2:			/* Read byte */E 19D 37	  d[0] = 'R';I 19E 37D 40	  /* Get job # */E 19D 15	  GetNumber(args[1], d[1]);E 15I 15D 17	  N_GETNUMBER(args[1], d[1], bad);E 17I 17D 36	  N_GETNUMBER(args[1], dest, bad);d[1] = dest;E 36I 36D 37	  N_GETNUMBER(args[1], dest, bad);E 37I 37	  N_GETNUMBER(args[1], slot, bad);E 40I 40	  /**********************************************************/	  /* 							    */	  /* NB that it is possible for the other end of the stream */D 45	  /* to have terminated, and hence ForkedStatus != -1.	    */E 45I 45	  /* to have terminated, and hence status != -1.	    */E 45	  /* EVEN IF THERE ARE STILL CHARACTERS TO READ.	    */	  /* 							    */	  /**********************************************************/E 40E 37D 38	  E 38I 38D 40	  /* This stream was closed; don't bother reading! */	  if (ForkedStatus[slot] != -1) return(NIL);E 40I 40	  N_GETNUMBER(args[1], slot, bad);	/* Get job # */E 40I 43	  if (!valid_slot(slot)) return(NIL); /* No fd open; punt the read */E 43E 38D 37	  if (ForkedPIDs[dest] != -1)	    {	      DBPRINT(("Reading via pipe for desc %d\n", dest));	      d[1] = dest;	      d[3] = 1;	      write(UnixPipeOut, d, 4);E 36I 19E 19E 17E 15D 36	  d[3] = 1;	  write(UnixPipeOut, d, 4);E 36I 36	      /* Get status */	      read(UnixPipeIn, d, 4);E 36I 19D 36	  /* Get status */E 19	  read(UnixPipeIn, d, 4);E 36I 36	     /* Return byte, NIL, or T (EOF) */	      if (d[3] == 1) return(GetSmallp(d[2]));	      if (d[3] == 2) return(ATOM_T);	      if (d[3] == 0) return(NIL);E 37I 37D 40	  dest = read(ForkedIns[slot], buf, 1);E 40I 40D 45	  TIMEOUT(dest = read(ForkedIns[slot], buf, 1));E 45E 40D 38/*	  DBPRINT((" result:  %d, errno: %d, char: %c\n", dest, errno, buf[0])); */	  if ((dest == 0) && (ForkedStatus[slot] == -1))E 38I 38I 58	  if(UJ[slot].readsock) sock = UJ[slot].readsock; else sock = slot;E 58D 40	  if ((dest == 0) )E 40I 40D 45	  if ((dest == 0) && (ForkedStatus[slot] == -1))E 40E 38	    { /* No available chars, but other guy still running */	      return(ATOM_T);E 37	    }D 37	  else	    {	      char buf[1];	      DBPRINT(("Reading pty %d. ", ForkedIns[dest]));/* 	      DBPRINT(("Reading desc #%d", ForkedIns[dest])); */	      dest = read(ForkedIns[dest], buf, 1);/*	      DBPRINT((" len %d, char %c.\n", dest, buf[0])); */	      if (dest == 0) return(ATOM_T);	        else if (dest != -1) return(GetSmallp(buf[0]));		else if (errno == EWOULDBLOCK) return(ATOM_T);		else return(NIL);E 37I 37	  if (dest > 0)	    { /* Got a character */	      return(GetSmallp(buf[0]));E 37	    }I 37D 38	  if ((errno == EWOULDBLOCK) && (ForkedStatus[slot] == -1))E 38I 38D 40	  if ((errno == EWOULDBLOCK) )E 40I 40	  if ((ForkedStatus[slot] == -1)  &&	      ((errno == EWOULDBLOCK) || (errno == EAGAIN)) )E 40E 38	    { /* No available chars, but other guy still running */	      return(ATOM_T);	    }	  /* At this point, we either got an I/O error, or there */	  /* were no chars available and the other end has terminated. */	  /* Either way, signal EOF. */#ifdef DEBUG	  perror("Reading from shell");			  	  printf("Indicating EOF from PTY desc %d.\n", ForkedIns[slot]);	  fflush(stdout);#endif	  return(NIL);E 45I 45	  switch(UJ[slot].type) {E 45E 37E 36I 19I 45	  case UJPROCESS:	  case UJSHELL:	  case UJSOSTREAM:D 58	    TIMEOUT(dest = read(slot, buf, 1));E 58I 58	    TIMEOUT(dest = read(sock, buf, 1));E 58	    if (dest > 0) return(GetSmallp(buf[0]));		/* Something's amiss; check our process status */	    wait_for_comm_processes();	    if ((dest == 0) && (UJ[slot].status == -1))	      { /* No available chars, but other guy still running */I 59		DBPRINT(("dest = 0, status still -1\n"));E 59		return(ATOM_T);	      }	    if ((UJ[slot].status == -1)  &&		((errno == EWOULDBLOCK) || (errno == EAGAIN)) )	      { /* No available chars, but other guy still running */I 59		DBPRINT((" dest<0, EWOULDBLOCK\n"));E 59		return(ATOM_T);	      }	    /* At this point, we either got an I/O error, or there */	    /* were no chars available and the other end has terminated. */	    /* Either way, signal EOF. */	    DBPRINT(("Indicating EOF from PTY desc %d.\n", slot));	    return(NIL);	    break;	  default:	    return(NIL);	    break;	  }E 45D 36	  /* Return byte, NIL, or T (EOF) */E 19	  if (d[3] == 1)	    return(GetSmallp(d[2]));D 9	  elseE 9I 9D 11	  if (d[3] == -1)E 11I 11	  if (d[3] == 2)E 11	    return(ATOM_T);	  if (d[3] == 0)E 9	    return(NIL);E 36I 11	  break;E 11D 19	case 3:E 19I 19I 41E 41D 45	case 3:			/* Kill process */E 45I 45	case 3:	  /* Kill process */		  /* Maiko uses this as CLOSEF, so "process" is a misnomer */E 45E 19D 37	  d[0] = 'K';E 37I 19D 37	  /* Get job # */E 19D 15	  GetNumber(args[1], d[1]);E 15I 15D 17	  N_GETNUMBER(args[1], d[1], bad);E 17I 17D 36	  N_GETNUMBER(args[1], dest, bad);d[1] = dest;E 36I 36	  N_GETNUMBER(args[1], dest, bad);	  d[1] = dest;E 37I 37	  N_GETNUMBER(args[1], slot, bad);E 37E 36I 19I 58	  DBPRINT(("Killing process in slot %.\n", slot));E 58E 19E 17E 15D 37	  d[3] = 1;	  write(UnixPipeOut, d, 4);E 37I 37	  if (valid_slot(slot))D 45	    {	      /* First check to see it hasn't already died */	      if (ForkedStatus[slot] == -1)		{		  int i;		  /* Kill the job */		  kill(ForkedPIDs[slot], SIGKILL);		  for (i = 0; i < 10; i++)		    {E 45I 45	    switch(UJ[slot].type)	      {		case UJSHELL:		case UJPROCESS:			/* First check to see it hasn't already died */			if (UJ[slot].status == -1)			  {			    int i;			    /* Kill the job */			    kill(UJ[slot].PID, SIGKILL);			    for (i = 0; i < 10; i++)		 	      {E 45		      /* Waiting for the process to exit is possibly risky.		         Sending SIGKILL is always supposed to kill		         a process, but on very rare occurrences this doesn't		         happen because of a Unix kernel bug, usually a user-		         written device driver which hasn't been fully		         debugged.  So we time it out just be safe. */D 45		      if (ForkedStatus[slot] != -1) break;		      wait_for_comm_processes(0);		      sleep(1);		    }		}	    }	  else return(ATOM_T);E 45I 45			      if (UJ[slot].status != -1) break;			       wait_for_comm_processes();			      sleep(1);			    }			}	          break;E 45E 37I 19D 37	  /* Get status */E 19	  read(UnixPipeIn, d, 4);I 19	  /* Read 2 byte return status */E 19I 11	  i = d[1] << 8;	  i += d[2];I 19I 36	  if (ForkedPIDs[dest] == -1)E 37I 37D 45	  if (ForkedProcType[slot] == -1)	/* PTY connection */E 37	    {D 37	      close(ForkedIns[dest]);	      ForkedPIDs[dest] = 0;E 37I 37		DBPRINT(("Kill 3 closing desc %d.\n", ForkedIns[slot]));	      close(ForkedIns[slot]);E 37	    }I 37	  else if (ForkedProcType[slot] == -2)	/* named socket pair */	    {	      char PipeName[40];		DBPRINT(("Kill 3 closing desc %d.\n", ForkedIns[slot]));	      close(ForkedIns[slot]);	      sprintf(PipeName, "/tmp/LispPipe%d-%d", StartTime, slot);	      unlink(PipeName);	    }	  ForkedProcType[slot] = 0;	  ForkedPIDs[slot] = 0;E 45I 45	        }	    else return(ATOM_T);E 45E 37I 45	  switch(UJ[slot].type) {	  case UJSHELL:	    DBPRINT(("Kill 3 closing shell desc %d.\n", slot));	    close(slot);	    break;	  case UJPROCESS:	    DBPRINT(("Kill 3 closing process desc %d.\n", slot));D 58	    close(slot);E 58I 58	    close(slot); if (UJ[slot].readsock) close(UJ[slot].readsock);E 58	    break;	  case UJSOSTREAM:	    DBPRINT(("Kill 3 closing stream socket desc %d.\n", slot));	    close(slot);    	break;	  case UJSOCKET:	    DBPRINT(("Kill 3 closing raw socket desc %d.\n", slot));	    close(slot);		DBPRINT(("Unlinking %s\n", UJ[slot].pathname));		if(UJ[slot].pathname) {			if(unlink(UJ[slot].pathname) < 0)				perror("Kill 3 unlink");			free(UJ[slot].pathname);			UJ[slot].pathname = NULL;		}	    break;	  }	  UJ[slot].type = UJUNUSED;D 58	  UJ[slot].PID = 0;E 58I 58	  UJ[slot].readsock = UJ[slot].PID = 0;E 58	  UJ[slot].pathname = NULL;E 45E 36	  /* If status available, return it, otherwise T */E 19E 11D 37	  if (d[3] == 1)D 11	    return(ATOM_T);E 11I 11	    return(GetSmallp(i));E 11	  elseD 11	    return(NIL);E 11I 11	    return(ATOM_T);E 37I 37D 45	  return(GetSmallp(ForkedStatus[slot]));E 45I 45	  return(GetSmallp(UJ[slot].status));E 45E 37	  break;E 11I 7D 19	case 4:E 19I 19I 45E 45D 41	case 4:			/* Fork PTY process */E 41I 41	case 4:	case 11:		/* Fork PTY process */E 41E 19D 36	  d[0] = 'S';	  d[3] = 1;E 36I 36	  {D 60	    char MasterFD[20], SlavePTY[4];E 60I 60	    char MasterFD[20], SlavePTY[32];E 60	    int Master, res, slot;I 60	    unsigned short len;E 60I 37D 45	    slot = find_process_slot(0);	    if (slot < 0) return(NIL);E 45E 37	    Master = FindAvailablePty(MasterFD, SlavePTY);D 45	    DBPRINT(("Fork Shell; Master PTY = %d. Slave=%c%c.\n", Master, SlavePTY[0], SlavePTY[1]));E 45I 45	    slot = Master;	    DBPRINT(("Fork Shell; Master PTY = %d. Slave=%c%c.\n",		     Master, SlavePTY[0], SlavePTY[1]));E 45D 37	    if (Master < 0) return(NIL);E 37I 37	    if (Master < 0)	      {		printf("Open of lisp side of PTY failed.\n");		fflush(stdout);		return(NIL);	      }E 37E 36I 19E 19D 36	  write(UnixPipeOut, d, 4);E 36I 36D 41	    d[0] = 'S';E 41I 41	    d[0] = (command == 4) ? 'S': 'P';E 41	    d[1] = SlavePTY[0];	    d[2] = SlavePTY[1];D 37	    d[3] = 1;E 37I 37	    d[3] = slot;E 37E 36I 19D 41E 41D 36	  /* Get status */E 19	  read(UnixPipeIn, d, 4);I 19D 28E 28	  /* If successful, return job # */E 19	  if (d[3] == 1)	    return(GetSmallp(d[1]));	  else	    return(NIL);	  break;E 36I 36	    write(UnixPipeOut, d, 4);E 36I 19I 60#ifdef INDIGO	    len = strlen(SlavePTY) + 1;	    write(UnixPipeOut, &len, 2);	    write(UnixPipeOut, SlavePTY, len);#endifE 60I 41	    if (command != 4)D 45	      {			/* New style has arg1 = termtype, arg2 = command */E 45I 45	      {	/* New style has arg1 = termtype, arg2 = command */E 45		WriteLispStringToPipe (args[1]);		WriteLispStringToPipe (args[2]);	      }E 41I 36	    /* Get status */	    read(UnixPipeIn, d, 4);	    /* If successful, return job # */	    DBPRINT(("Pipe/fork result = %d.\n", d[3]));	    if (d[3] == 1)	      {D 37		slot = d[1];E 37		    /* Set up the IO not to block */D 37		res = fcntl(Master, F_GETFL);E 37I 37		res = fcntl(Master, F_GETFL, 0);I 59#ifdef ISCE 59E 37D 58		res |= FNDELAY;E 58I 58		res |= O_NONBLOCK;I 59#else		res |= FNDELAY;#endif /* ISC */E 59E 58		res = fcntl(Master, F_SETFL, res);D 45		ForkedIns[slot] = ForkedOuts[slot] = Master;D 37		ForkedPIDs[slot] = -1; /* so we can find them */E 37I 37		ForkedProcType[slot] = -1; /* so we can find them */		ForkedPIDs[slot] = (d[1]<<8) | d[2];		ForkedStatus[slot] = -1;E 45I 45		UJ[slot].type = UJSHELL; /* so we can find them */		UJ[slot].PID = (d[1]<<8) | d[2];		UJ[slot].status = -1;E 45E 37D 58E 58I 58		DBPRINT(("Forked pty in slot %d.\n", slot));E 58		return(GetSmallp(slot));	      }	     else	      {I 37		printf("Fork failed.\n"); fflush(stdout);E 37		close(Master);		return(NIL);	      }	    break;	  }E 36	case 5:			/* Kill all the subprocesses */D 37	  d[0] = 'E';	  d[3] = 1;E 37D 37	  write(UnixPipeOut, d, 4);	  /* Get status */	  read(UnixPipeIn, d, 4);I 36	  for ( dest = 0; dest < NPROCS; dest++)	    if (ForkedPIDs[dest] == -1)	      {	        close(ForkedIns[dest]);	        ForkedPIDs[dest] = 0;	      }E 37I 37D 45	  kill_comm_processes();E 45I 45	  close_unix_descriptors();E 45E 37E 36I 20	  return(ATOM_T);D 33	  break;E 33I 33D 37       /* break; */E 37E 33D 41	case 6:			/* Kill all the subprocesses */E 41I 41	case 6:			/* Kill this subprocess */E 41	  d[0] = 'C';D 45	  d[3] = 1;E 45	  /* Get job # */D 36	  N_GETNUMBER(args[1], dest, bad);d[1] = dest;E 36I 36	  N_GETNUMBER(args[1], dest, bad);	  d[1] = dest;E 36	  d[3] = 1;	  write(UnixPipeOut, d, 4);	  /* Get status */	  read(UnixPipeIn, d, 4);D 36E 36I 36D 37	  if (ForkedPIDs[dest] == -1)E 37I 37D 45	  if (ForkedProcType[dest] == -1)E 37	    {I 37		DBPRINT(("Kill 5 closing desc %d.\n", ForkedIns[dest]));E 37	      close(ForkedIns[dest]);D 37	      ForkedPIDs[dest] = 0;E 37I 37	      ForkedProcType[dest] = 0;E 37	    }I 37	  else if (ForkedProcType[dest] == -2)	/* named socket pair */	    {	      char PipeName[40];		DBPRINT(("Kill 5 closing desc %d.\n", ForkedIns[dest]));	      close(ForkedIns[dest]);	      ForkedProcType[dest] = 0;	      sprintf(PipeName, "/tmp/LispPipe%d-%d", StartTime, d[1]);	      unlink(PipeName);	    }	  ForkedPIDs[dest] = 0;E 45I 45	  switch(UJ[dest].type) {	  case UJSHELL:	    DBPRINT(("Kill 5 closing shell desc %d.\n", dest));	    close(dest);	    break;	  case UJPROCESS:	    DBPRINT(("Kill 5 closing process desc %d.\n", dest));D 58	    close(dest);E 58I 58	    close(dest); if(UJ[dest].readsock) close(UJ[dest].readsock);	    UJ[dest].readsock=0;E 58	    break;	  case UJSOCKET:	    /* close a socket; be sure and unlink the file handle */	    DBPRINT(("Kill 5 closing raw socket desc %d.\n", dest));		close(dest);	    if(UJ[dest].pathname != NULL) {	      unlink(UJ[dest].pathname);	      free(UJ[dest].pathname);	      UJ[dest].pathname = NULL;	    } /* else return an error somehow... */	    break;	  case UJSOSTREAM:	    DBPRINT(("Kill 5 closing socket stream %d.\n", dest));	    close(dest);	    break;	  }	  UJ[dest].type = UJUNUSED;D 58	  UJ[dest].PID = 0;E 58I 58	  UJ[dest].readsock = UJ[dest].PID = 0;E 58E 45E 37E 36E 20	  return(ATOM_T);D 33	  break;E 33I 33       /* break; */E 33I 37	case 7:			/* Current job status */D 41	  /* Get job # */	  N_GETNUMBER(args[1], dest, bad);slot = dest;E 41I 41	  N_GETNUMBER(args[1], slot, bad);	  /* Get job # */I 45	  wait_for_comm_processes();   /* Make sure we're up to date */E 45E 41D 45	  if (ForkedStatus[slot] == -1) return (ATOM_T);D 41	  else return(GetSmallp(ForkedStatus[slot]));E 41I 41	    else return(GetSmallp(ForkedStatus[slot]));E 45I 45	  if (UJ[slot].status == -1) return (ATOM_T);	  else return(GetSmallp(UJ[slot].status));E 45E 41	  break;I 41	case 8:			/* Return largest supported command */E 41I 41D 45	  return(GetSmallp(11));E 45I 45D 48	  return(GetSmallp(14));E 48I 48	  return(GetSmallp(15));E 48E 45	  I 45E 45	case 9:			/* Read buffer */I 44	  /**********************************************************/	  /* 							    */	  /* NB that it is possible for the other end of the stream */	  /* to have terminated, and hence ForkedStatus != -1.	    */	  /* EVEN IF THERE ARE STILL CHARACTERS TO READ.	    */	  /* 							    */	  /**********************************************************/E 44I 44D 45E 45E 44	  { char *bufp;I 50	    int terno;    /* holds errno thru sys calls after I/O fails */E 50I 45E 45	    N_GETNUMBER(args[1], slot, bad); 		/* Get job # */D 44	    bufp = (char*)(Addr68k_from_LADDR(args[2]));	/* User buffer */E 44I 44	    if (!valid_slot(slot)) return(NIL); /* No fd open; punt the read */I 45I 58	    if (UJ[slot].readsock) sock = UJ[slot].readsock; else sock = slot;E 58E 45	    bufp = (char*)(Addr68k_from_LADDR(args[2]));  /* User buffer */E 44D 45	    dest = read(ForkedIns[slot], bufp, 512);	    if (dest > 0)		/* Got something */	      return(GetSmallp(dest));	    if (((dest == 0) || (errno == EWOULDBLOCK)) &&		(ForkedStatus[slot] == -1)) /* No available chars, but other guy still running */	      return(ATOM_T);	  /* At this point, we either got an I/O error, or there */	  /* were no chars available and the other end has terminated. */	  /* Either way, signal EOF. */#ifdef DEBUG	    perror("Reading from shell");			  	    printf("Indicating EOF from PTY desc %d.\n", ForkedIns[slot]);	    fflush(stdout);#endif	    return(NIL);E 45I 45D 58	    DBPRINT(("Read buffer, type is %d\n", UJ[slot].type));E 58I 58	    DBPRINT(("Read buffer slot %d, type is %d\n", slot, UJ[slot].type));E 58	    switch(UJ[slot].type) {	    case UJSHELL:	    case UJPROCESS:	    case UJSOSTREAM:D 58	      dest = read(slot, bufp, 512);E 58I 58	      dest = read(sock, bufp, 512);E 58I 50#ifdef BYTESWAP	      word_swap_page(bufp, 128);D 60#endif BYTESWAPE 60I 60#endif /* BYTESWAP */E 60E 50D 58	      if (dest > 0) return(GetSmallp(dest));E 58I 58	      if (dest > 0)		{ /* Got characters.  If debugging, print len &c */D 59		  printf("got %d chars\n", dest);E 59I 59		  /* printf("got %d chars\n", dest); */E 59		  return(GetSmallp(dest));		}E 58		  /* Something's amiss; update process status */I 58	      DBPRINT(("Problem: Got status %d from read, errno %d.\n", dest, errno));#ifndef ISCE 58	      wait_for_comm_processes();  /* make sure we're up to date */D 50	      if (((dest == 0) ||E 50I 50	      if (((dest == 0) || (errno == EINTR) || (errno == 0) ||		   (errno == EAGAIN) ||E 50		   (errno == EWOULDBLOCK)) && (UJ[slot].status == -1))		/* No available chars, but other guy still running */		return(ATOM_T);I 58#else	      if (dest == 0) wait_for_comm_processes();  /* make sure we're up to date, because dest==0 means no process is writing there. */	      if (((errno == EINTR) || (errno == 0) ||		   (errno == EAGAIN) ||		   (errno == EWOULDBLOCK)) && (dest == -1) && (UJ[slot].status == -1))		/* No available chars, but other guy still running */		return(ATOM_T);D 60#endif ISCE 60I 60#endif /* ISC */E 60E 58	      /* At this point, we either got an I/O error, or there */	      /* were no chars available and the other end has terminated. */	      /* Either way, signal EOF. */I 50	      DBPRINT(("read failed; dest = %d, errno = %d, status = %d\n",		       dest, terno, UJ[slot].status));E 50	      DBPRINT(("Indicating EOF from PTY desc %d.\n", slot));	      return(NIL);	    default:	      return(NIL);	    }E 45	  }	case 10:			/* Change window */	  { int rows, cols, pgrp, pty;I 52D 54#ifndef HPUXE 54I 54#if (!defined( HPUX) && !defined(RISCOS))E 54E 52	    struct winsize w;I 52D 60#endif HPUXE 60I 60#endif /* HPUX */E 60E 52				/* Get job #, rows, columns */	    N_GETNUMBER(args[1], slot, bad);	    N_GETNUMBER(args[2], rows, bad);	    N_GETNUMBER(args[3], cols, bad);I 52D 54#ifndef HPUXE 54I 54#if (!defined(HPUX) && !defined(RISCOS))E 54E 52D 45	    if (valid_slot(slot) && (ForkedStatus[slot] == -1))E 45I 45	    if (valid_slot(slot)	        && (UJ[slot].type == UJSHELL)	        && (UJ[slot].status == -1))E 45	      {D 45	      w.ws_row = rows;	      w.ws_col = cols;	      w.ws_xpixel = 0;	/* not used */	      w.ws_ypixel = 0;	      pty = ForkedIns[slot];E 45I 45	        w.ws_row = rows;	        w.ws_col = cols;	        w.ws_xpixel = 0;	/* not used */	        w.ws_ypixel = 0;	        pty = slot;E 45				/* Change window size, then				   notify process group of the change */D 45	      if ((ioctl(pty, TIOCSWINSZ, &w) >= 0) &&		  (ioctl(pty, TIOCGPGRP, &pgrp) >= 0) &&		  (killpg(pgrp, SIGWINCH) >= 0))		return (ATOM_T);	      return(GetSmallp(errno));E 45I 45	        if ((ioctl(pty, TIOCSWINSZ, &w) >= 0) &&I 58#ifdef ISC		    (tcgetpgrp(pty) >= 0) &&#elseE 58		    (ioctl(pty, TIOCGPGRP, &pgrp) >= 0) &&I 53D 58#ifdef RISCOSE 58I 58D 60#endif ISCE 60I 60#endif /* ISC */E 60#ifdef SYSVONLYE 58		    (kill(-pgrp, SIGWINCH) >= 0))#elseE 53		    (killpg(pgrp, SIGWINCH) >= 0))I 53D 60#endif RISCOSE 60I 60#endif /* RISCOS */E 60E 53		  return (ATOM_T);	        return(GetSmallp(errno));E 45	      }I 52D 54#endif HPUXE 54I 54D 60#endif HPUX | RISCOSE 60I 60#endif /* HPUX | RISCOS */E 60E 54E 52	    return(NIL);	  }I 45D 58E 58I 58#ifndef ISCE 58	case 12:			/* create Unix socket */	  {	    int res, sockFD;	    struct sockaddr_un sock;	    /* First open the socket */	    sockFD = socket(AF_UNIX, SOCK_STREAM, 0);	    if (sockFD < 0)	      { perror("socket open");		return(NIL);}	    /* Then get a process slot and blit the pathname of the	       socket into it */	    /* need to type-check the string here */D 56	    LispStringToCString(args[1], shcom);E 56I 56	    LispStringToCString(args[1], shcom, 2048);E 56	    UJ[sockFD].pathname = malloc(strlen(shcom) + 1);	    strcpy(UJ[sockFD].pathname, shcom);	    /* Then bind it to the pathname, and get it	listening properly */	    sock.sun_family = AF_UNIX;	    strcpy(sock.sun_path, shcom);	    if (bind(sockFD, (struct sockaddr *) &sock,		     strlen(shcom)+sizeof(sock.sun_family)) < 0)	      {		close(sockFD);		free(UJ[sockFD].pathname);		UJ[sockFD].type = UJUNUSED;		perror("binding Lisp sockets");		return(NIL);	      }	    DBPRINT(("Socket %d bound to name %s.\n", sockFD, shcom));	    if(listen(sockFD, 1)<0) perror("Listen");		    /* Set up the IO not to block */	    res = fcntl(sockFD, F_GETFL, 0);I 59#ifdef ISCE 59D 58	    res |= FNDELAY;E 58I 58	    res |= O_NONBLOCK;I 59#else	    res |= FNDELAY;#endif /* ISC */E 59E 58	    res = fcntl(sockFD, F_SETFL, res);	    /* things seem sane, fill out the rest of the UJ slot and return */	    UJ[sockFD].status = -1;	    UJ[sockFD].PID = -1;	    UJ[sockFD].type = UJSOCKET;	    return(GetSmallp(sockFD));	}	    break;I 58#else	error("Socket creation not supported on ISC");D 60#endif ISCE 60I 60#endif /* ISC */E 60E 58I 60E 60D 58E 58	case 13:  /* try to accept */		{		  /* returns file descriptor if successful,		     -1 if no connection available,		     NIL if failure */		  int sockFD, newFD;		  N_GETNUMBER(args[1], sockFD, bad);		  if(UJ[sockFD].type == UJSOCKET &&		     UJ[sockFD].pathname != NULL) {		    /* sockFD SHOULD be non-blocking;		       but I'll time this out just in case */I 46		case13_lp:E 46		    TIMEOUT(newFD = accept(sockFD, (struct sockaddr *) 0,					 (int *) 0));		    if (newFD < 0)D 46		      if (errno == EWOULDBLOCK)E 46I 46		      if (errno == EINTR) goto case13_lp;		      else if (errno == EWOULDBLOCK)E 46			return (GetSmallp(-1));		      else {			perror("Lisp socket accept");			return (NIL);		      }		    else {		      UJ[newFD].status = -1;		      UJ[newFD].PID = -1;		      UJ[newFD].type = UJSOSTREAM;		      return(GetSmallp(newFD));		    }		  } else return(NIL);		}	  break;	case 14:  /* return type of socket */		{		 int streamFD;		 N_GETNUMBER(args[1], streamFD, bad);		 if(valid_slot(streamFD))			return GetSmallp(UJ[streamFD].type);		 else return NIL;		}		break;I 48		case 15:			/* Write buffer */	  { char *bufp;	    N_GETNUMBER(args[1], slot, bad); 		    /* Get job # */	    bufp = (char*)(Addr68k_from_LADDR(args[2]));    /* User buffer */	    N_GETNUMBER(args[3], i, bad);                   /* # to write */	    DBPRINT(("Write buffer, type is %d\n", UJ[slot].type));	    switch(UJ[slot].type) {	    case UJSHELL:	    case UJPROCESS:	    case UJSOSTREAM:I 50#ifdef BYTESWAP	      word_swap_page(bufp, (i+3)>>2);D 60#endif BYTESWAPE 60I 60#endif /* BYTESWAP */E 60E 50	      dest = write(slot, bufp, i);I 50#ifdef BYTESWAP	      word_swap_page(bufp, (i+3)>>2);D 60#endif BYTESWAPE 60I 60#endif /* BYTESWAP */E 60E 50	      if (dest > 0) return(GetSmallp(dest));		  /* Something's amiss; update process status */	      wait_for_comm_processes();  /* make sure we're up to date */	      if (((dest == 0) ||		   (errno == EWOULDBLOCK)) && (UJ[slot].status == -1))		/* No room to write, but other guy still running */		return(ATOM_T);	      /* At this point, we either got an I/O error, or there */	      /* were no chars available and the other end has terminated. */	      /* Either way, signal EOF. */	      DBPRINT(("Indicating write failure from PTY desc %d.\n", slot));	      return(NIL);	    }	  }E 48E 45E 41E 37E 19E 7D 15E 15I 15D 17	default: 	bad: return(NIL);E 17I 17	default: return(NIL);E 17E 15	}I 19E 19I 17D 37      bad:return(NIL);E 37I 37      bad:	DBPRINT(("Bad input value."));	return(NIL);I 56D 58#endif ISCE 58E 56E 37E 17      }I 17I 56E 56I 54/************************************************************************//*									*//*		W r i t e L i s p S t r i n g T o P i p e		*//*									*//*	Convert a lisp string to a C string (both format and byte-	*/D 56/*	order), write 2 bytes of length and the string	*/E 56I 56/*	order), write 2 bytes of length and the string			*/E 56/*									*//*									*//************************************************************************/E 54E 17I 41WriteLispStringToPipe (lispstr)  LispPTR lispstr;D 56D 50	/* Decode lisp string and write it, preceded by len, to the output pipe */	{ unsigned char b[1];	  LispStringToCString(lispstr, shcom);	  /* Write string length, then string */	  *b = strlen(shcom) + 1;	  write(UnixPipeOut, b, 1);	  write(UnixPipeOut, shcom, *b);	 }E 50I 50  /* Decode lisp string and write it, preceded by len, to the output pipe */E 56D 54  { unsigned char b[1];E 54I 54  { unsigned short len;E 54D 56    LispStringToCString(lispstr, shcom);E 56I 56    LispStringToCString(lispstr, shcom, 2048);E 56    /* Write string length, then string */D 54    *b = strlen(shcom) + 1;    write(UnixPipeOut, b, 1);    write(UnixPipeOut, shcom, *b);E 54I 54    len = strlen(shcom) + 1;    write(UnixPipeOut, &len, 2);    write(UnixPipeOut, shcom, len);E 54  }E 50E 41E 3I 1D 4/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";I 2/*Unix Interface Communications*/#include "lispemul.h"#include "address.h"#include "address68k.h"#include "lisptypes.h"#include "lispmap.h"#include "emulglobal.h"#include "lispglobal.h"#include "cell.h"#include "stack.h"#include "arith.h"#include <stdio.h>#include <sgtty.h>fork_Unix(){	int LispToUnix[2], UnixToLisp[2], UnixToProcess[2], ProcessToUnix[2];	int LispPipeIn, LispPipeOut, rdy, PIDn;	char IOBuf[4];	int ForkedIns[100], ForkedOuts[100], ForkedPIDs[100], i;	pipe(LispToUnix);	pipe(UnixToLisp);	LispPipeIn = LispToUnix[0];	LispPipeOut = UnixToLisp[1];	UnixPipeIn = UnixToLisp[0];	UnixPipeOut = LispToUnix[1];	UnixPID = fork();	if (UnixPID == 0) return(1);	PIDn = 0;	while (1) {	  read(LispPipeIn, IOBuf, 4);	  switch(IOBuf[0]) {	  case 'F':	    pipe(UnixToProcess);	    pipe(ProcessToUnix);	    for (PIDn = 0; ForkedPIDs[PIDn] != 0; PIDn++);	    ForkedPIDs[PIDn] = fork();	    ForkedIns[PIDn] = ProcessToUnix[0];	    ForkedOuts[PIDn] = UnixToProcess[1];	    if (ForkedPIDs[PIDn] == 0) {	      dup2(UnixToProcess[0],0);	      dup2(ProcessToUnix[1],1);	      dup2(ProcessToUnix[1],2);	      execl("/bin/csh", "/bin/csh", 0);	      exit(1);	    }	    if (ForkedPIDs[PIDn] == -1)	      perror("unixcomm");	    else	      IOBuf[1] = PIDn++;	    break;	  case 'W':/*	    if(ioctl(ForkedOuts[IOBuf[1]], TIOCOUTQ, &rdy) != -1) {	      if (rdy < 4095) */		write(ForkedOuts[IOBuf[1]], IOBuf+2, 1);/*	      else		IOBuf[3] = 0;	    }	    else perror("unixcomm"); */	    break;	  case 'R':	    if(ioctl(ForkedIns[IOBuf[1]], FIONREAD, &rdy) != -1) {	      if (rdy > 0)		read(ForkedIns[IOBuf[1]], IOBuf+2, 1);	      else		IOBuf[3] = 0;	    }	    else	      perror("unixcomm");	    break;	  case 'K':	    if (kill(ForkedPIDs[IOBuf[1]], 9) != -1)	      IOBuf[3] = 0;	    else	      perror("unixcomm");	    ForkedPIDs[IOBuf[1]] = 0;	    break;	  }	  write(LispPipeOut, IOBuf, 4);	}      }Unix_handlecomm(args)LispPTR *args;{	int command,c, PID;	LispPTR retval;	char d[3];	GetNumber(args[0], command);	switch(command) {		/* Read byte */	case 0:	  d[0] = 'F';	  d[3] = 1;	  write(UnixPipeOut, d, 4);	  read(UnixPipeIn, d, 4);	  if (d[3] == 1)	    return(GetSmallp(d[1]));	  else	    return(NIL);	  break;	case 1:	  d[0] = 'W';	  GetNumber(args[1], d[1]);	  GetNumber(args[2], d[2]);	  d[3] = 1;	  write(UnixPipeOut, d, 4);	  read(UnixPipeIn, d, 4);	  if (d[3] == 1)	    return(ATOM_T);	  else	    return(NIL);	  break;	case 2:	  d[0] = 'R';	  GetNumber(args[1], d[1]);	  d[3] = 1;	  write(UnixPipeOut, d, 4);	  read(UnixPipeIn, d, 4);	  if (d[3] == 1)	    return(GetSmallp(d[2]));	  else	    return(NIL);	case 3:	  d[0] = 'K';	  GetNumber(args[1], d[1]);	  d[3] = 1;	  write(UnixPipeOut, d, 4);	  read(UnixPipeIn, d, 4);	  if (d[3] == 1)	    return(ATOM_T);	  else	    return(NIL);	}      }E 4E 2E 1