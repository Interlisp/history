h17943s 00000/00000/00199d D 2.20 93/02/08 14:49:44 sybalsky 25 24c Big VM (and new CDR coding) changes for 3.0 \nes 00003/00003/00196d D 2.19 92/04/21 17:08:36 sybalsky 24 23c shortening file names for DOS \nes 00010/00000/00189d D 2.18 91/04/23 15:09:36 sybalsky 23 22c Bob Bane's reopen-the-tty-for-URAID fixes 00002/00000/00187d D 2.17 90/06/22 17:11:28 fuji 22 21c Add way out from C commandes 00000/00000/00187d D 2.16 90/04/20 01:25:26 sybalsky 21 20c AIX:  shortening file names, bulk change.es 00001/00000/00186d D 2.15 90/03/15 22:30:09 sybalsky 20 19c add dbprint.h include, OOPSes 00095/00056/00091d D 2.14 90/03/15 22:03:36 sybalsky 19 18c code reformat, commentses 00002/00002/00145d D 2.13 89/12/28 15:23:44 sybalsky 18 17c cleanupes 00002/00001/00145d D 2.12 89/10/19 17:58:28 sybalsky 17 16c display bufferinges 00000/00000/00146d D 2.11 89/03/17 13:33:21 sybalsky 16 15c Fixed byte-order dependencieses 00011/00011/00135d D 2.10 89/01/09 17:17:56 shih 15 14c spellinges 00001/00001/00145d D 2.9 88/12/12 18:37:49 hayata 14 13c To fix AR10945, obsolete extern declaration is removed. (ScreenBitMap)es 00003/00000/00143d D 2.8 88/10/26 17:06:37 shimizu 13 12c FIX AR10914es 00002/00000/00141d D 2.7 88/07/07 14:45:03 shimizu 12 11c enable to keep error-message from Ces 00008/00002/00133d D 2.6 88/07/07 11:03:30 shimizu 11 10c Can quit from print loop by ESC + RETURNes 00002/00000/00133d D 2.5 88/06/30 10:45:12 greep 10 9c put printf inside #ifdef DEBUGes 00001/00001/00132d D 2.4 88/06/24 15:16:22 shimizu 9 8c Not to smash TOS to NILes 00005/00000/00128d D 2.3 88/06/22 16:34:48 shimizu 8 7c Before enter URaid,set FXindex to maxnumes 00002/00000/00126d D 2.2 88/06/08 19:06:09 shimizu 7 6c Enable to print error message from LISPes 00000/00000/00126d D 2.1 88/05/17 09:22:51 hayata 6 5c Version up to 2.1es 00054/00002/00072d D 1.5 88/05/08 10:33:53 shimizu 5 4c for URaid modifyes 00005/00005/00069d D 1.4 88/05/01 23:47:36 masinter 4 3c make error do backtrace and continue; temp until URaides 00004/00000/00070d D 1.3 88/04/07 14:49:47 shimizu 3 2c Add warn porges 00002/00002/00068d D 1.2 88/03/13 14:34:43 hayata 2 1c Add SCCS key id (%Z%)es 00070/00000/00000d D 1.1 88/02/24 16:56:05 hayata 1 0c date and time created 88/02/24 16:56:05 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 15/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 15I 15D 18/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 15static char *id = "%Z% %M%	%I% %G%";E 18I 18D 19/* @(#) common.c Version 2.11 (3/17/89). copyright envos & Fuji Xerox  */static char *id = "@(#) common.c	2.11 3/17/89";E 19I 19/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 19E 18E 2/*D 19 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.E 19 *D 15 *	Auther	:	Hiroshi Hayata	E 15I 15 *	Author	:	Hiroshi HayataE 15 */#include	<stdio.h>I 11#include  <setjmp.h>I 23#include  <fcntl.h>E 23E 11D 4E 4I 4#include "lispemul.h"I 5#include "lispmap.h"D 24#include "address68k.h"#include "lispglobal.h"E 5#include "emulglobal.h"E 24I 24#include "adr68k.h"#include "lspglob.h"#include "emlglob.h"E 24I 13#include "stack.h"I 20#include "dbprint.h"E 20E 13I 5I 17#ifndef NOPIXRECTE 17#include <pixrect/pixrect_hs.h>D 17E 17I 17#endifE 17E 5E 4stab()D 19{I 10#ifdef  DEBUGE 10	printf("Now in stab\n");I 10#endifE 10}E 19I 19  {    DBPRINT(("Now in stab\n"));  }E 19I 19E 19/***************************************************************error	common sub-routine.	Printout error message.I 5	Enter URAID.E 5D 11	And exit.E 11I 11	And exit.(takeshi)E 11******************************************************************/I 8#define URMAXFXNUM		100E 8I 5extern unsigned int LispReadFds,LispWindowFd,LispKbdFd;D 14extern struct pixrect *ScreenBitMap,*CursorBitMap,*InvisibleCursorBitMap;E 14I 14extern struct pixrect *CursorBitMap,*InvisibleCursorBitMap;E 14extern struct screen LispScreen;extern int DisplayWidth,DisplayHeight;extern DLword *DisplayRegion68k;extern int FrameBufferFd; extern char URaid_inputstring[]; extern char URaid_comm; extern char URaid_arg1[256]; extern char URaid_arg2[10]; extern int URaid_argnum;I 12 extern char *URaid_errmess;E 12I 8 extern  int URaid_currentFX;I 13 extern FX *URaid_FXarray[];E 13I 11 extern jmp_buf BT_jumpbuf;I 22 extern jmp_buf SD_jumpbuf;E 22E 11E 8I 8E 8I 7 LispPTR Uraid_mess=NIL;E 7/* Currentry Don't care Ether re-initial *//* Medley only */I 19/************************************************************************//*									*//*				e r r o r				*//*									*//*	Last-ditch error handling; enters URAID, low-level debug.	*//*									*//************************************************************************/E 19#define URMAXCOMM	512E 5error(cp)D 19char	*cp;{I 5	char *ptr;	if(device_before_raid()<0) {		printf("Can't Enter URAID.\n");		exit(-1);	}	 /* comm read */I 12	URaid_errmess=cp;E 12E 5D 4#ifdef	TRACE2	printf("TRACE:error()\n");#endifE 4	printf("\n*Error* %s\n",cp);D 4	exit(-1);E 4I 4D 5	bt();E 5I 5	fflush(stdin);	printf("Enter the URaid\n");I 7	print(Uraid_mess); putchar('\n');I 8	URaid_currentFX=URMAXFXNUM +1;I 13	bzero(URaid_FXarray,URMAXFXNUM *4);E 19I 19  char	*cp;  {    char *ptr;    if(device_before_raid()<0)      {	printf("Can't Enter URAID.\n");	exit(-1);      }     /* comm read */    URaid_errmess=cp;    printf("\n*Error* %s\n",cp);    fflush(stdin);    printf("Enter the URaid\n");    print(Uraid_mess); putchar('\n');    URaid_currentFX=URMAXFXNUM +1;    bzero(URaid_FXarray,URMAXFXNUM *4);E 19E 13E 8E 7D 11uraidloop: for(;;){ /* URAID LOOP */E 11I 11I 23      {	int stat = fcntl(fileno(stdin), F_GETFL, 0);	if (stat != O_RDONLY && stat != O_RDWR)	  if (freopen("/dev/tty", "r", stdin) == NULL)	    {	      perror("Reopen of stdin failed.");	      exit(0);	    }      }E 23D 15uraidloop: E 15I 15uraidloop:E 15D 19	if(setjmp(BT_jumpbuf) == 1) goto uraidloop;	for(;;){ /* URAID LOOP */E 19I 19    if(setjmp(BT_jumpbuf) == 1) goto uraidloop;I 22    if(setjmp(SD_jumpbuf) == 1) goto uraidloop;E 22    for(;;)      { /* URAID LOOP */E 19D 15		E 15I 15E 15E 11D 19		uraid_commclear();		printf("\n< ");		for( ptr=URaid_inputstring;( *ptr= getchar() ) != '\n' ;			 ptr++) {}D 15 		URaid_argnum = sscanf(URaid_inputstring,"%1s%s%s",&URaid_comm,URaid_arg1,URaid_arg2);E 15I 15		URaid_argnum = sscanf(URaid_inputstring,"%1s%s%s",&URaid_comm,URaid_arg1,URaid_arg2);E 19I 19	uraid_commclear();	printf("\n< ");	for( ptr=URaid_inputstring;( *ptr= getchar() ) != '\n' ; ptr++) {}	URaid_argnum = sscanf(URaid_inputstring,			      "%1s%s%s",&URaid_comm, URaid_arg1, URaid_arg2);E 19E 15D 15		if(uraid_commands()==NIL) break; E 15I 15D 19		if(uraid_commands()==NIL) break;E 15		} /* for end */E 19I 19	if(uraid_commands()==NIL) break;      } /* for end */E 19E 5D 9	TopOfStack = NIL;E 9I 9D 19	/**TopOfStack = NIL;if error is called from subr TOS will be set NIL**/E 9I 5	if(device_after_raid() <0){		 printf("Can't return to Lisp. Return to UNIX?");		{int c;D 15		 	c= getchar();		 	if((c=='Y')||(c=='y')) {E 15I 15			c= getchar();			if((c=='Y')||(c=='y')) {E 15				exit(-1);D 15		  	}E 15I 15			}E 15		}		fflush(stdin);		goto uraidloop;E 19I 19    /**TopOfStack = NIL;if error is called from subr TOS will be set NIL**/    if(device_after_raid() <0)      {	printf("Can't return to Lisp. Return to UNIX?");	{ int c;	  c= getchar();	  if((c=='Y')||(c=='y')) exit(-1);E 19	}E 5D 19	return(0);E 4}D 5E 5I 5/** Warnning message */E 19I 19	fflush(stdin);	goto uraidloop;      }    return(0);  }/************************************************************************//*									*//*				w a r n					*//*									*//*	Print a warning message, but don't stop running.		*//*									*//************************************************************************/E 19E 5I 3warn(s)D 19char *s;{ printf("\nWARN: %s \n",s); }E 19I 19  char *s;  { printf("\nWARN: %s \n",s); }E 19I 19E 19E 3/*****************************************************************stackcheck	common sub-routine.D 15	Not Implented.E 15I 15	Not Implemented.E 15	1.check Stack overflow.		(check CurrentStackPTR)	2.if overflow, return T (not 0).	  Otherwise, return F (0).******************************************************************/stackcheck()D 19{E 19I 19  {E 19#ifdef	TRACE2D 19	printf("TRACE:stackcheck()\n");E 19I 19    printf("TRACE:stackcheck()\n");E 19#endifD 19	return(0);}E 19I 19    return(0);  }E 19I 19E 19/*****************************************************************stackoverflow	common sub-routine.D 15	Not Implented.E 15I 15	Not Implemented.E 15	1.error handling of stack overflow.******************************************************************/stackoverflow()D 19{E 19I 19  {E 19#ifdef	TRACE2D 19	printf("TRACE:stackoverflow()\n");E 19I 19    printf("TRACE:stackoverflow()\n");E 19#endifD 19	printf("stackoverflow \n");}E 19I 19    printf("stackoverflow \n");  }E 19E 1