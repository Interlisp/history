h58082s 00000/00000/00643d D 2.1 88/05/17 09:25:25 hayata 3 2c Version up to 2.1es 00002/00002/00641d D 1.2 88/03/13 14:52:00 hayata 2 1c Add SCCS key id (%Z%)es 00643/00000/00000d D 1.1 88/02/24 16:57:40 hayata 1 0c date and time created 88/02/24 16:57:40 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 2/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther	:	Hiroshi Hayata	 */#include	<stdio.h>#include	"lispemul.h"#include	"emulglobal.h"#include	"lispglobal.h"#define	MaskFF(x)	(0x000000ff & x)#define	FJUMPMACRO(x)	{if(TopOfStack == 0)\				PC += x;\			else\				PC += 1;\			PopCStack;}#define	TJUMPMACRO(x)	{if(TopOfStack != 0)\				PC += x;\			else\				PC += 1;\			PopCStack;}/****************************************************************OP_jumpn	n == 0 : PC += 2		n == 1 : PC += 3		  :	   :		n == 15	: PC += 17	Entry:	JUMP		opcode[0200 - 0217]	1. increment PC by (opcode - 0176).****************************************************************/OP_jump0(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump0()\n");#endif	PC += 2;}OP_jump1(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump1()\n");#endif	PC += 3;}OP_jump2(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump2()\n");#endif	PC += 4;}OP_jump3(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump3()\n");#endif	PC += 5;}OP_jump4(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump4()\n");#endif	PC += 6;}OP_jump5(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump5()\n");#endif	PC += 7;}OP_jump6(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump6()\n");#endif	PC += 8;}OP_jump7(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump7()\n");#endif	PC += 9;}OP_jump8(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump8()\n");#endif	PC += 10;}OP_jump9(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump9()\n");#endif	PC += 11;}OP_jump10(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump10()\n");#endif	PC += 12;}OP_jump11(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump11()\n");#endif	PC += 13;}OP_jump12(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump12()\n");#endif	PC += 14;}OP_jump13(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump13()\n");#endif	PC += 15;}OP_jump14(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump14()\n");#endif	PC += 16;}OP_jump15(){#ifdef TRACE	printPC();	printf("TRACE:OP_jump15()\n");#endif	PC += 17;}/****************************************************************OP_fjumpn		TopOfStack==NIL		TopOfStack==non-NIL	n == 0	PC += 2			PC += 1	n == 1	PC += 3			PC += 1	  :	  :			  :	n == 15	PC += 17		PC += 1		Entry:	FJUMP		opcode[0220 - 0237]	1. if TopOfStack is NIL (Fault), increment PC by (opcode - 0216)	   else increment PC by 1.	2. Pop Current stack.****************************************************************/OP_fjump0(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump0()\n");#endif/*	if(TopOfStack == 0)		PC += 2;	else		PC += 1;	PopCStack;*/	FJUMPMACRO(2)}OP_fjump1(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump1()\n");#endif	FJUMPMACRO(3)}OP_fjump2(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump2()\n");#endif	FJUMPMACRO(4)}OP_fjump3(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump3()\n");#endif	FJUMPMACRO(5)}OP_fjump4(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump4()\n");#endif	FJUMPMACRO(6)}OP_fjump5(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump5()\n");#endif	FJUMPMACRO(7)}OP_fjump6(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump6()\n");#endif	FJUMPMACRO(8)}OP_fjump7(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump7()\n");#endif	FJUMPMACRO(9)}OP_fjump8(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump8()\n");#endif	FJUMPMACRO(10)}OP_fjump9(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump9()\n");#endif	FJUMPMACRO(11)}OP_fjump10(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump10()\n");#endif	FJUMPMACRO(12)}OP_fjump11(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump11()\n");#endif	FJUMPMACRO(13)}OP_fjump12(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump12()\n");#endif	FJUMPMACRO(14)}OP_fjump13(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump13()\n");#endif	FJUMPMACRO(15)}OP_fjump14(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump14()\n");#endif	FJUMPMACRO(16)}OP_fjump15(){#ifdef TRACE	printPC();	printf("TRACE:OP_fjump3()\n");#endif	FJUMPMACRO(17)}/****************************************************************OP_tjumpn		TopOfStack==non-NIL	TopOfStack==NIL	n == 0	PC += 2			PC += 1	n == 1	PC += 3			PC += 1	  :	  :			  :	n == 15	PC += 17		PC += 1	Entry:	TJUMP		opcode[0240 - 0257]	1. if TopOfStack is non-NIL (True) , increment PC by (opcode - 0236)	   else increment PC by 1.	2. Pop Current stack.****************************************************************/OP_tjump0(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump0()\n");#endif	TJUMPMACRO(2)}OP_tjump1(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump1()\n");#endif	TJUMPMACRO(3)}OP_tjump2(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump2()\n");#endif	TJUMPMACRO(4)}OP_tjump3(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump3()\n");#endif	TJUMPMACRO(5)}OP_tjump4(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump4()\n");#endif	TJUMPMACRO(6)}OP_tjump5(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump5()\n");#endif	TJUMPMACRO(7)}OP_tjump6(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump6()\n");#endif	TJUMPMACRO(8)}OP_tjump7(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump7()\n");#endif	TJUMPMACRO(9)}OP_tjump8(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump8()\n");#endif	TJUMPMACRO(10)}OP_tjump9(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump9()\n");#endif	TJUMPMACRO(11)}OP_tjump10(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump10()\n");#endif	TJUMPMACRO(12)}OP_tjump11(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump11()\n");#endif	TJUMPMACRO(13)}OP_tjump12(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump12()\n");#endif	TJUMPMACRO(14)}OP_tjump13(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump13()\n");#endif	TJUMPMACRO(15)}OP_tjump14(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump14()\n");#endif	TJUMPMACRO(16)}OP_tjump15(){#ifdef TRACE	printPC();	printf("TRACE:OP_tjump3()\n");#endif	TJUMPMACRO(17)}/****************************************************************OP_jumpx	Entry:	JUMPX		opcode[0260]	1. if MSB of alpha is off,	   then increment PC by alpha.			(alpha is positive offset)	   else decrement PC by (0400 - alpha).			(alpha is negative offset)****************************************************************/OP_jumpx(){int	alpha;	/* 1st argument of opcode */#ifdef TRACE	printPC();	printf("TRACE:OP_jumpx()\n");#endif	alpha = MaskFF( (int)(*(PC+1)) );	if( alpha & 0200 )		/* negative offset */		PC -= 0400 - alpha;	else		/* positive offset */		PC += alpha;}/****************************************************************OP_jumpxx	Entry:	JUMPXX	opcode[0261]	1. set the concatination of alpha and beta to "arg".	2. if MSB of alpha is off,	   then increment PC by "arg".			("arg" is positive offset)	   else decrement PC by (0x10000 - "arg").			("arg" is negative offset)****************************************************************/OP_jumpxx(){int	alpha;	/* 1st argument of opcode */int	arg;		/* concatinate 1st and 2nd arguments */#ifdef TRACE	printPC();	printf("TRACE:OP_jumpxx()\n");#endif	alpha = MaskFF( (int)(*(PC+1)) );	arg = (alpha << 8) | MaskFF( (int)(*(PC+2)) );		/* (int)(*(PC+2)) is beta */	if( alpha & 0200 )		/* negative offset */		PC -= 0x10000 - arg;	else		/* positive offset */		PC += arg;}/****************************************************************OP_fjumpx	Entry:	FJUMPX	opcode[0262]	1. if TopOfStack is NIL (Fault), increment PC by alpha	   else increment PC by 2.	2. Pop Current stack.****************************************************************/OP_fjumpx(){int	alpha;	/* 1st argument of opcode */#ifdef TRACE	printPC();	printf("TRACE:OP_fjumpx()\n");#endif	alpha = MaskFF( (int)(*(PC+1)) );	if(TopOfStack == 0){		if( alpha & 0200 )			/* negative offset */			PC -= 0400 - alpha;		else			/* positive offset */			PC += alpha;	}else		PC += 2;	PopCStack;}/****************************************************************OP_tjumpx	Entry:	TJUMPX	opcode[0263]	1. if TopOfStack is non-NIL (Fault) , increment PC by alpha	   else increment PC by 2.	2. Pop Current stack.****************************************************************/OP_tjumpx(){int	alpha;	/* 1st argument of opcode */#ifdef TRACE	printPC();	printf("TRACE:OP_tjumpx()\n");#endif	alpha = MaskFF( (int)(*(PC+1)) );	if(TopOfStack != 0){		if( alpha & 0200 )			/* negative offset */			PC -= 0400 - alpha;		else			/* positive offset */			PC += alpha;	}else		PC += 2;	PopCStack;}/****************************************************************OP_nfjumpx	Entry:	NFJUMPX	opcode[0264]	1. if TopOfStack is NIL (Fault), increment PC by alpha	   else increment PC by 2 and Pop Current stack.****************************************************************/OP_nfjumpx(){int	alpha;	/* 1st argument of opcode */#ifdef TRACE	printPC();	printf("TRACE:OP_nfjumpx()\n");#endif	alpha = MaskFF( (int)(*(PC+1)) );	if(TopOfStack == 0){		if( alpha & 0200 )			/* negative offset */			PC -= 0400 - alpha;		else			/* positive offset */			PC += alpha;	}else{		PC += 2;		PopCStack;	}}/****************************************************************OP_ntjumpx	Entry:	NTJUMPX	opcode[0265]	1. if TopOfStack is non-NIL (True), increment PC by alpha	   else increment PC by 2 and Pop Current stack.****************************************************************/OP_ntjumpx(){int	alpha;	/* 1st argument of opcode */#ifdef TRACE	printPC();	printf("TRACE:OP_ntjumpx()\n");#endif	alpha = MaskFF( (int)(*(PC+1)) );	if(TopOfStack != 0){		if( alpha & 0200 )			/* negative offset */			PC -= 0400 - alpha;		else			/* positive offset */			PC += alpha;	}else{		PC += 2;		PopCStack;	}}E 1