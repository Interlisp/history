h53972s 00023/00001/00856d D 2.51 91/10/15 18:15:24 sybalsky 60 59c ISC changeses 00004/00000/00853d D 2.50 91/09/27 02:32:10 sybalsky 59 58c ISC port changeses 00004/00003/00849d D 2.49 91/05/26 17:27:11 sybalsky 58 57c Misc X Cleanup, trying to fix a bug that's in the X-server code.es 00003/00000/00849d D 2.48 91/04/16 15:16:13 sybalsky 57 56c Add required vfork.h include, back out valloc->malloc change (re-change later for other OS's?)es 00003/00003/00846d D 2.47 90/09/18 23:44:12 sybalsky 56 55c Retrofit changes from AIX, DEC3100, PS/2es 00000/00000/00849d D 2.46 90/08/21 17:15:40 sybalsky 55 54c Retrofit AIX changes from IBMes 00002/00002/00847d D 2.45 90/07/04 03:59:42 sybalsky 54 53c Fix X ifdefs so they work.es 00041/00003/00808d D 2.44 90/06/13 18:35:03 sybalsky 53 52c AIX portability changeses 00002/00005/00809d D 2.43 90/05/30 11:08:39 sybalsky 52 51c ??es 00078/00000/00736d D 2.42 90/05/14 15:53:19 fuji 51 50c support for Sun Window Security Feature on OS 4.1es 00050/00144/00686d D 2.41 90/05/14 12:04:02 fuji 50 49c support color funcs on CG6es 00001/00001/00829d D 2.40 90/04/20 01:39:01 sybalsky 49 48c AIX:  shortening file names, bulk change.es 00005/00021/00825d D 2.39 90/03/22 10:43:51 sybalsky 48 47c bit-swapping speedup (inline code now)es 00001/00001/00845d D 2.38 90/03/15 15:12:59 sybalsky 47 46c fix flush_display_region to really decache the whole width of what it's displayinges 00003/00001/00843d D 2.37 90/03/13 18:18:34 takeshi 46 45c Add BYTESWAP option around byte_swapped_displayregiones 00069/00005/00775d D 2.36 90/03/09 14:42:00 takeshi 45 44c slightly optimized the regiones 00003/00002/00777d D 2.35 90/03/05 14:59:54 takeshi 44 43c Add SCCS headeres 00005/00005/00774d D 2.34 90/03/05 14:25:42 takeshi 43 42c Not use clear_CG6es 00014/00043/00765d D 2.33 90/03/02 21:44:46 sybalsky 42 41c 386 changewes 00087/00017/00721d D 2.32 90/03/01 13:56:42 osamu 41 40c Mitsunori Matsuda adds XWindow functionality.es 00021/00011/00717d D 2.31 90/02/12 11:49:15 takeshi 40 39c minor changes for color initializationses 00003/00004/00725d D 2.30 90/02/08 20:42:12 osamu 39 38c Move DISP_MAX_Address out of ifdef DISPLAYBUFFER. c 	Because some functions use this variable when undef DISPLAYBUFFER.es 00029/00008/00700d D 2.29 90/02/08 16:11:55 osamu 38 37c Change  in_display_segment() to macro for efficiency. c 	new macro definition is in display.h. c 	and change DISP_MAX_Address to variable.   es 00007/00004/00701d D 2.28 90/02/08 09:48:54 takeshi 37 36c clear_display changeses 00008/00000/00697d D 2.27 90/02/07 14:57:49 mitani 36 35c DisplayRegion68k_end_addr was added to support non-mmapped frame buffer.es 00000/00000/00697d D 2.26 90/02/06 20:29:34 osamu 35 34c merge JDS code and Fuji Medley1.1.3 codees 00137/00008/00560d D 2.25 90/02/06 11:46:45 sybalsky 34 33c byte-swap/386 changeses 00006/00006/00562d D 2.24 89/12/13 10:55:26 sybalsky 33 32c color ss1es 00263/00097/00305d D 2.23 89/10/19 17:59:24 sybalsky 32 31c display bufferinges 00002/00002/00400d D 2.22 89/03/08 15:51:53 shih 31 30c syntax errors inside the DBPRINT'ses 00057/00030/00345d D 2.21 89/03/03 04:22:04 shih 30 29c attempt to make init betteres 00016/00016/00359d D 2.20 89/03/03 02:10:50 shih 29 28c changed init_display to init_display2, now takes 68k addresses 00002/00002/00373d D 2.19 89/03/02 20:18:31 shih 28 27c typoes 00145/00151/00230d D 2.18 89/03/02 20:13:50 shih 27 26c change SrcPixRect to SrcePixRect, new include (dbprint), style changeses 00008/00001/00373d D 2.17 89/01/17 10:06:11 shimizu 26 25c Add Color cursores 00028/00028/00346d D 2.16 89/01/10 14:10:46 shih 25 24c spellinges 00017/00011/00357d D 2.15 89/01/04 16:58:03 shimizu 24 23c For C-Cursor trackinges 00126/00001/00242d D 2.14 88/12/07 15:26:09 shimizu 23 22c Add funcs for primary cgfour implementationses 00005/00000/00238d D 2.13 88/10/18 13:16:52 charnley 22 21c redefined SrcPixRect for pr_rop in bitbltsub.es 00019/00008/00219d D 2.12 88/10/17 20:02:02 shimizu 21 20c For color config(set IFPAGE)es 00007/00003/00220d D 2.11 88/10/13 11:37:13 krivacic 20 19c add OS4 ifdef for MAP_FIXEDes 00002/00001/00221d D 2.10 88/10/12 21:04:10 bane 19 18c added MAP_FIXED to mmap calles 00006/00007/00216d D 2.9 88/10/12 20:41:27 bane 18 17c Changed mmap result test to work under os3 and os4es 00028/00006/00195d D 2.8 88/10/12 15:53:30 shimizu 17 16c For atuomatic frame buffer config.(only tested on sun3BW)es 00015/00024/00186d D 2.7 88/09/29 14:22:45 charnley 16 15c removed calls to pr_rop.es 00001/00001/00209d D 2.6 88/08/09 16:14:23 shih 15 14c change screen to white upon exites 00016/00000/00194d D 2.5 88/06/30 10:51:19 greep 14 13c put "#ifdef DEBUG" around printfses 00005/00001/00189d D 2.4 88/06/27 01:50:00 bane 13 12c Added FNDELAY on open of LispWindowFdes 00006/00001/00184d D 2.3 88/06/24 23:04:23 bane 12 11c Added INT ifdefs and code for KB interruptses 00005/00002/00180d D 2.2 88/06/20 21:56:29 shimizu 11 10c Add win syscall error checkes 00000/00000/00182d D 2.1 88/05/17 09:25:11 hayata 10 9c Version up to 2.1es 00006/00002/00176d D 1.9 88/05/12 14:34:54 shimizu 9 8c adopt 5/12 codees 00006/00001/00172d D 1.8 88/05/11 20:07:36 shimizu 8 7c For merging bitbltes 00006/00006/00167d D 1.7 88/04/29 05:04:43 masinter 7 6c remove error on > 1 bit per pixeles 00002/00001/00171d D 1.6 88/04/27 09:15:36 bane 6 5c Added int_io_open and int_io_close calls for I/O interrupt stuffes 00003/00003/00169d D 1.5 88/03/23 18:19:39 shimizu 5 4c V1.3 was vanished. So re-FIX init_cursores 00029/00014/00143d D 1.4 88/03/17 18:08:56 krivacic 4 3c Hi Res Display Hacks es 00001/00001/00156d D 1.3 88/03/15 10:49:04 shimizu 3 2c Fix:BitMap remains stuffes 00002/00002/00155d D 1.2 88/03/13 14:51:09 hayata 2 1c Add SCCS key id (%Z%)es 00157/00000/00000d D 1.1 88/02/24 16:57:31 hayata 1 0c date and time created 88/02/24 16:57:31 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 4/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 4I 4D 5/* This is G-file @(#) initdisplay.c Version 1.2 (3/13/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) initdisplay.c	1.2 3/13/88";E 5I 5D 25/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 25I 25D 33/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 25I 9static char *id = "%Z% %M%	%I% %G%";E 33I 33D 40/* @(#) initdisplay.c Version 2.22 (3/8/89). copyright envos & Fuji Xerox  */static char *id = "@(#) initdisplay.c	2.22 3/8/89";E 40I 40D 42/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 42I 42D 44/* @(#) initdisplay.c Version 2.32 (3/1/90). copyright envos & Fuji Xerox  */static char *id = "@(#) initdisplay.c	2.32 3/1/90		(envos & Fuji Xerox)";E 44I 44/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%      %I% %G%         (venue & Fuji Xerox)";I 53/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 53E 44E 42E 40E 33E 9D 7static char *id = "%Z% %M%	%I% %G%";E 7E 5E 4E 2/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.D 7 * *	Auther	:	Osamu Nakamura	E 7I 7 *	file	:	initdisplay.cD 25 *	Author	:	Osamu Nakamura	E 25I 25 *	Author	:	Osamu NakamuraE 25E 7 */I 53E 53D 7/*** ADOPTED NEW VERSION ***/E 7#include <stdio.h>I 53D 54#ifndef XWINDOWE 54I 54#ifndef NOPIXRECTE 54E 53#include <sunwindow/window_hs.h>#include <sunwindow/cms.h>#include <sys/ioctl.h>#include <sys/mman.h>#include <sunwindow/win_ioctl.h>#include <pixrect/pixrect_hs.h>#include <sun/fbio.h>#include <sys/ioctl.h>I 13#include <sys/file.h>I 17#include <pixrect/pr_planegroups.h>I 53D 54#endif XWINDOWE 54I 54#endif NOPIXRECTI 58E 58I 57#ifdef OS4#include <vfork.h>#endif OS4E 57E 54E 53E 17E 13I 17D 41E 41E 17#include "lispemul.h"#include "lispmap.h"I 34#include "lisptypes.h"E 34#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "emulglobal.h"#include "display.h"I 21#include "devconfig.h"E 21I 24#include "bb.h"#include "bitblt.h"#include "pilotbbt.h"I 27#include "dbprint.h"E 27E 24I 59#ifdef ISC#define getpagesize() 512#endif ISCE 59I 38/* from /usr/include/sun/fbio.h some machines don't have following def. */I 50#ifndef FBTYPE_SUNROP_COLORE 50#define FBTYPE_SUNROP_COLOR     13      /* MEMCOLOR with rop h/w */I 50#define FBTYPE_SUNFAST_COLOR 12#endifE 50I 53#ifndef NOPIXRECTE 53E 38I 24D 27E 27E 24struct screen LispScreen;D 16struct pixrect *ScreenBitMap, *CursorBitMap, *InvisibleCursorBitMap;struct pixrect *SrcPixRect, *DestPixRect, *TexturePixRect;I 8D 9struct pixrect *BlackTexturePixRect;E 9I 9struct pixrect *BlackTexturePixRect, *WhiteTexturePixRect;E 16I 16struct pixrect *CursorBitMap, *InvisibleCursorBitMap;I 22D 27struct pixrect *SrcPixRect, *DestPixRect;E 27I 27struct pixrect *SrcePixRect, *DestPixRect;I 32#ifdef DISPLAYBUFFER  int black = 0, white = -1;  struct pixrect *ColorDisplayPixrect,D 33		 *DisplayRegionPixrect;#define COPY_PIXRECT_TO_COLOR (PIX_SRC | PIX_DONTCLIP)E 33I 33			*DisplayRegionPixrect;#define COPY_PIXRECT_TO_COLOR (PIX_SRC  /*| PIX_DONTCLIP */)E 33#ifdef DEBUG  int oldred[2], oldgreen[2], oldblue[2];D 53#endif /* DEBUG */#endifE 53I 53#endif DEBUG#endif DISPLAYBUFFER#endif NOPIXRECTE 53E 32E 27E 22E 16E 9E 8int LispWindowFd;int FrameBufferFd;I 17E 17D 8int DisplayWidth, DisplayHeight;E 8I 8D 9int DisplayWidth, DisplayHeight,DisplayRasterWidth;E 9I 9D 21int DisplayWidth, DisplayHeight, DisplayRasterWidth;E 21I 21D 29int DisplayWidth, DisplayHeight, DisplayRasterWidth,DisplayType;I 24int DisplayByteSize;E 24E 21E 9E 8 short *DisplayRegion68k;	/* 68k addr of #{}22,0 */E 29I 29int    DisplayWidth, DisplayHeight, DisplayRasterWidth, DisplayType;int    DisplayByteSize;D 38short *DisplayRegion68k;	/* 68k addr of #{}22,0 */E 38I 38DLword *DisplayRegion68k;	/* 68k addr of #{}22,0 */E 38I 36#ifdef DISPLAYBUFFERD 38short *DisplayRegion68k_end_addr;E 38I 38D 58/* both vars has same value. That is the end of Lisp DisplayRegion */E 58I 58/* both vars has same value. That is the end of Lisp DisplayRegion */E 58DLword *DisplayRegion68k_end_addr;D 39DLword *DISP_MAX_Address;E 39E 38#endifI 39D 58/* somefunctions use this variable when undef DISPLAYBUFFER */E 58I 58/* some functions use this variable when undef DISPLAYBUFFER */E 58DLword *DISP_MAX_Address;E 39I 53#ifdef SUNDISPLAYE 53E 36E 29struct cursor CurrentCursor, InvisibleCursor;struct winlock DisplayLockArea;I 53#endif SUNDISPLAYE 53extern DLword *EmCursorBitMap68K;extern int errno;I 21extern IFPAGE *InterfacePage;E 21int DebugDSP = T;I 50#ifdef COLORextern DLword *ColorDisplayRegion68k;extern int MonoOrColor;#endif COLORE 50I 41#ifdef XWINDOWDLword *DisplayRegion68k_end_addr;int LispDisplayWidth  , LispDisplayHeight;#endif XWINDOWI 51#ifdef SUNDISPLAY/* For SunOS4.1 Window Security Feature. */int Win_security_p;#include <sys/wait.h>#define SV_ACQUIRE	"/bin/sunview1/sv_acquire"#define SV_RELEASE	"/bin/sunview1/sv_release"#endif SUNDISPLAYE 51E 41I 27/*  ================================================================  */I 29/*  Now takes 68k address, function renamed for safety  */E 29E 27D 4init_display()E 4I 4D 29init_display(lisp_display_addr, display_max)D 27	int lisp_display_addr, display_max;E 27I 27	int  lisp_display_addr, display_max;E 29I 29init_display2(display_addr, display_max)D 32	int   display_addr, display_max;E 29E 27E 4{D 4	int mmapstat;E 4I 4D 24	int mmapstat, size;E 24I 24	int mmapstat;I 30	int fbgattr_result;E 30E 24E 4	char *texture_base, *malloc();	struct fbtype my_screen;I 17	char groups[PIXPG_OVERLAY+1];	struct fbgattr  FBattr;	struct pixrect *ColorFb;E 32I 32  int   display_addr, display_max;  {    int mmapstat;    int fbgattr_result;    char *texture_base, *malloc();I 53#ifdef SUNDISPLAYE 53    struct fbtype my_screen;    char groups[PIXPG_OVERLAY+1];    struct fbgattr  FBattr;    struct pixrect *ColorFb;I 53#endif SUNDISPLAYE 53E 32E 17I 41#ifdef SUNDISPLAYI 51    /* For SunOS4.1 Window Security Feature. */    union wait status;    /* Window Security is available? */    if (!access(SV_ACQUIRE, F_OK))      Win_security_p = 1;    else      Win_security_p = 0;    if (Win_security_p) {	    switch (vfork()) {		  case -1:	/* Error */		    (void)fprintf(stderr, "init_display: Fork failed.\n");		    exit(1);		  case 0:	/* Child */		    (void)execl(SV_ACQUIRE, "sv_acquire", "0", "256", "250", 0);		    /* should not return */		    (void)fprintf(stderr, "init_display: exec for sv_acquire failed\n");		    exit(1);		  default:	/* Parent */		    /* do nothing */		    break;	    }	    (void)wait(&status); /* child dies after changing 6 */	    if (status.w_retcode != 0) {		    (void)fprintf(stderr,				  "init_display: failed to set ownership of win devices\n");		    exit(1);	    }    }    #endif SUNDISPLAY#ifdef SUNDISPLAYE 51E 41D 32	if( (LispWindowFd = win_screennew( &LispScreen )) == -1){D 18		fprintf( stderr, "init_display: can't create LispWindow\n");E 18I 18		perror("init_display: can't create LispWindow\n");E 18		exit( -1 );D 6	}E 6I 6D 12	} else  int_io_open(LispWindowFd);E 12I 12	}I 13	else {E 32I 32    if( (LispWindowFd = win_screennew( &LispScreen )) == -1)      {	perror("init_display: can't create LispWindow\n");	exit( -1 );      }    else      {E 32E 13#ifdef KBINTD 13	else  int_io_open(LispWindowFd);E 13I 13D 32		int_io_open(LispWindowFd);E 32I 32	int_io_open(LispWindowFd);E 32E 13#endifI 13D 32		fcntl(LispWindowFd, F_SETFL, fcntl(LispWindowFd, F_GETFL, 0)| FNDELAY);	}E 32I 32	fcntl(LispWindowFd, F_SETFL, fcntl(LispWindowFd, F_GETFL, 0)| FNDELAY);      }I 41#endif SUNDISPLAYE 41E 32E 13E 12E 6I 29D 32	DisplayRegion68k = (short *) display_addr;E 32I 32D 38    DisplayRegion68k = (short *) display_addr;E 38I 38    DisplayRegion68k = (DLword *) display_addr;E 38E 32E 29D 25	E 25I 25I 41#ifdef SUNDISPLAYE 41E 25D 4	DisplayRegion68k = (short *) Addr68k_from_LADDR( DISPALY_OFFSET );E 4I 4D 29	DisplayRegion68k = (short *) Addr68k_from_LADDR( lisp_display_addr );E 4E 29D 32	if( (FrameBufferFd = open( LispScreen.scr_fbname, 2 )) == -1){D 18		fprintf( stderr, "init_display: can't open FrameBuffer\n");E 18I 18		perror("init_display: can't open FrameBuffer\n");E 18		exit( -1 );	}E 32I 32    if( (FrameBufferFd = open( LispScreen.scr_fbname, 2 )) == -1)      {	perror("init_display: can't open FrameBuffer\n");	exit( -1 );      }E 32D 32	/* initialize Display parameters */        if (ioctl(FrameBufferFd, FBIOGTYPE , &my_screen)== -1) {D 18        fprintf( stderr, "init_display: can't find screen parameters\n");E 18I 18D 30        perror("init_display: can't find screen parameters\n");E 30I 30        	perror("init_display: can't find screen parameters\n");E 30E 18                exit( -1 );        }D 29        DisplayWidth = my_screen.fb_width;E 29I 29        DisplayWidth  = my_screen.fb_width;E 29        DisplayHeight = my_screen.fb_height;I 8        DisplayRasterWidth = DisplayWidth / BITSPER_DLWORD;E 8D 4	if ((DisplayWidth * DisplayHeight) > 65566 * 16){		DisplayHeight = (65566 * 16) / DisplayWidth;E 4I 4	if ((DisplayWidth * DisplayHeight) > display_max){		DisplayHeight = display_max / DisplayWidth;E 4	}E 32I 32    /* initialize Display parameters */    if (ioctl(FrameBufferFd, FBIOGTYPE , &my_screen)== -1)      {	perror("init_display: can't find screen parameters\n");	exit( -1 );      }    DisplayWidth  = my_screen.fb_width;    DisplayHeight = my_screen.fb_height;I 41#endif SUNDISPLAY#ifdef XWINDOW    init_Xdisplay();    DisplayWidth  = LispDisplayWidth;    DisplayHeight = LispDisplayHeight;#endif XWINDOWE 41I 34#ifndef I386E 34    DisplayRasterWidth = DisplayWidth / BITSPER_DLWORD;I 34#else    DisplayRasterWidth = DisplayWidth / BITSPER_DLWORD;#endif I386E 34    if ((DisplayWidth * DisplayHeight) > display_max)      {	DisplayHeight = display_max / DisplayWidth;      }E 32I 14D 27#ifdef  DEBUGE 14I 4	printf("Display = %d x %d\n",DisplayWidth,DisplayHeight);I 14#endifE 27I 27D 39E 39I 39    DISP_MAX_Address = DisplayRegion68k + DisplayRasterWidth * DisplayHeight; E 39D 29	DBPRINT(("Display = %d x %d\n",DisplayWidth,DisplayHeight));E 29I 29D 30	DBPRINT(("FBIOGTYPE size = %d x %d\n", DisplayWidth, DisplayHeight));	DBPRINT(("          type = %d\n", my_screen.fb_type ));E 30I 30D 32	DBPRINT(("FBIOGTYPE w x h = %d x %d\n", DisplayWidth, DisplayHeight));	DBPRINT(("          type  = %d\n", my_screen.fb_type ));	DBPRINT(("          bpp   = %d\n", my_screen.fb_depth ));E 32I 32    DBPRINT(("FBIOGTYPE w x h = %d x %d\n", DisplayWidth, DisplayHeight));I 53D 56#ifndef AIXE 56I 56#ifndef XWINDOWE 56E 53    DBPRINT(("          type  = %d\n", my_screen.fb_type ));    DBPRINT(("          bpp   = %d\n", my_screen.fb_depth ));I 53D 56#endif AIXE 56I 56#endif XWINDOWE 56E 53E 32E 30E 29I 41#ifdef SUNDISPLAYE 41E 27E 14E 4D 17	if (my_screen.fb_depth > 1 ) {I 14#ifdef  DEBUGE 14D 7	fprintf( stderr, "init_display: color display not supported\n");		exit( -1 );E 7I 7	   printf("color screen(!), depth: %d", my_screen.fb_depth );I 14#endifE 17I 17D 30/* probe for DISPLAY type */D 21	if(ioctl(FrameBufferFd,FBIOGATTR,&FBattr) >= 0){ 	/* Maybe it's color display */E 21I 21	if(my_screen.fb_type == FBTYPE_SUN2BW){	   if(ioctl(FrameBufferFd,FBIOGATTR,&FBattr) >= 0){D 25 	   /* Maybe it's color display */E 25I 25	   /* Maybe it's color display */E 25E 21		if(FBattr.real_type== FBTYPE_SUN4COLOR){		  /* it must be color display cgfour */I 21		  DisplayType = SUN4COLOR;E 21		  ColorFb = pr_open("/dev/fb");		  pr_available_plane_groups( ColorFb, sizeof(groups), groups);		  if(groups[PIXPG_OVERLAY] && groups[PIXPG_OVERLAY_ENABLE]){			pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);			pr_rop(ColorFb, 0, 0, ColorFb->pr_width, ColorFb->pr_height,			PIX_SET, 0, 0, 0);			pr_set_plane_group(ColorFb, PIXPG_OVERLAY);D 21      }E 21I 21D 25    		   }E 25I 25		   }E 30I 30/** now attempt to use the FBIOGATTR call for more information **/E 30E 25E 21E 17E 14I 30D 32	fbgattr_result = ioctl(FrameBufferFd, FBIOGATTR, &FBattr);	if( fbgattr_result >= 0 ) { 	    DBPRINT(("FBIOGATTR realtype = %d\n",  FBattr.real_type)); 	    DBPRINT(("   (real) size = %d x %d\n", FBattr.fbtype.fb_width,						   FBattr.fbtype.fb_height));	    DBPRINT(("   (real) type = %d\n",      FBattr.fbtype.fb_type ));	    DBPRINT(("   (real) bpp  = %d\n",      FBattr.fbtype.fb_depth ));	    DBPRINT(("          emuls= %d %d %d %d\n",				 FBattr.emu_types[0], FBattr.emu_types[1],D 31				 FBattr.emu_types[2], FBattr.emu_types[3],));E 31I 31				 FBattr.emu_types[2], FBattr.emu_types[3]));E 31            }	else {	/* fill in defaults */	    FBattr.real_type = my_screen.fb_type;	    };D 31	DBPRINT ("init_display: FBIOGATTR_result = %d\n" fbgattr_result);E 31I 31	DBPRINT (("init_display: FBIOGATTR_result = %d\n", fbgattr_result));E 32I 32    fbgattr_result = ioctl(FrameBufferFd, FBIOGATTR, &FBattr);    if( fbgattr_result >= 0 )      {	DBPRINT(("FBIOGATTR realtype = %d\n",  FBattr.real_type));	DBPRINT(("   (real) size = %d x %d\n", FBattr.fbtype.fb_width,		 FBattr.fbtype.fb_height));	DBPRINT(("   (real) type = %d\n",      FBattr.fbtype.fb_type ));	DBPRINT(("   (real) bpp  = %d\n",      FBattr.fbtype.fb_depth ));	DBPRINT(("          emuls= %d %d %d %d\n",		 FBattr.emu_types[0], FBattr.emu_types[1],		 FBattr.emu_types[2], FBattr.emu_types[3]));      }    else      {	/* fill in defaults */	FBattr.real_type = my_screen.fb_type;      }    DBPRINT (("init_display: FBIOGATTR_result = %d\n", fbgattr_result));E 32E 31D 38E 38I 38/* probe for DISPLAY type *//********************************************************************** *	         FB-TYPE       REAL-TYPE * 	BW2      2             x *	CG2      3             3 *	CG3      8             6 *	CG4      2             8  *	CG6      8             12I 60 *	CG8      6             7E 60 *	CG9(GP1) 4             4    ;gpconfig -f -b *	CG9(GP1) 2            13    ;gpconfig gpone0 -f -b cgtwo0  *	                            ;We assume This config for GXP model ***********************************************************************/E 38/* Medley supports real (or emulated) BW2, so check for that first */I 32#ifndef DISPLAYBUFFERI 36E 36D 60    if ( my_screen.fb_type == FBTYPE_SUN2BW ) /* real or emulated bwtwo */E 60I 60    if ( (my_screen.fb_type == FBTYPE_SUN2BW ) /* real or emulated bwtwo */        ||(my_screen.fb_type == FBTYPE_SUN3COLOR) ) /* Sun 3 color? */E 60      switch ( FBattr.real_type )	{	    case FBTYPE_SUN2BW : DisplayType = SUN2BW;				 break;E 32I 60	    case FBTYPE_MEMCOLOR : /* memory 24-bit (CG8) */		{		DisplayType = SUNMEMCOLOR;		ColorFb = pr_open("/dev/fb");		pr_available_plane_groups( ColorFb, sizeof(groups), groups);		if(groups[PIXPG_OVERLAY] && groups[PIXPG_OVERLAY_ENABLE])		  {		    pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);		    pr_rop(ColorFb, 0, 0, ColorFb->pr_width, ColorFb->pr_height,		           PIX_SET, 0, 0, 0);		    pr_set_plane_group(ColorFb, PIXPG_OVERLAY);		  }		}			break;E 60D 32	if ( my_screen.fb_type == FBTYPE_SUN2BW ) /* real or emulated bwtwo */	  switch ( FBattr.real_type ) {	    case FBTYPE_SUN2BW : {		DisplayType = SUN2BW;		break;E 30D 17	/*	fprintf( stderr, "init_display: color display not supported\n");		exit( -1 ); */E 17I 17		}D 30		else{D 21		  fprintf("initdisplay:Not supported FBTYPE %d\n",E 21I 21D 25		     fprintf("initdisplay:Not supported FBTYPE %d\n",E 25I 25		     fprintf("initdisplay: Unsupported FBTYPE %d\n",E 30I 30	    case FBTYPE_SUN4COLOR : {  /* need to clear overlay plane */E 32I 32D 38	    case FBTYPE_SUN4COLOR :E 38I 38	    case FBTYPE_SUN4COLOR :    /* cg4 */	    case FBTYPE_SUNROP_COLOR : /* cg9(GXP) */E 38	      {  /* need to clear overlay plane */E 32		DisplayType = SUN4COLOR;		ColorFb = pr_open("/dev/fb");		pr_available_plane_groups( ColorFb, sizeof(groups), groups);D 32		if(groups[PIXPG_OVERLAY] && groups[PIXPG_OVERLAY_ENABLE]){E 32I 32		if(groups[PIXPG_OVERLAY] && groups[PIXPG_OVERLAY_ENABLE])		  {E 32		    pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);		    pr_rop(ColorFb, 0, 0, ColorFb->pr_width, ColorFb->pr_height,		           PIX_SET, 0, 0, 0);		    pr_set_plane_group(ColorFb, PIXPG_OVERLAY);D 32		    }E 32I 32		  }E 32		break;D 32		}	    default : {E 32I 32	      }	    default :E 32		printf("initdisplay: Unsupported FBreal_type %d\n",E 30E 25E 21			FBattr.real_type);D 21		  exit(-1);E 21I 21D 30		     DisplayType = (my_screen.fb_type) << 3;		 /* exit(-1);*/E 30I 30		DisplayType = (my_screen.fb_type) << 3;		/* should be able to proceed, since its an emulated bwtwo */E 30E 21D 32		}I 21D 30	   }D 29	   else{	    /* Currently we don't support REAL color buffer (overlay) */E 29I 29	   else{ /* Currently we don't support REAL color buffer (overlay) */E 29	     DisplayType = SUN2BW; /* It will be or-in to IFPAGE->devconfig */D 25  	   }E 25I 25	   }E 25	}/* if ...FBTYPE_SUN2BW end */	else{ /* another type */	   DisplayType = (my_screen.fb_type) << 3;E 21E 17E 7	}E 30I 30	  }	else { /* not currently a SUN2BW, perhaps can emulate it? */	  if ( fbgattr_result >= 0 ) { /* got gattrs, can try sattr */E 32I 32	}    else      { /* not currently a SUN2BW, perhaps can emulate it? */	if ( fbgattr_result >= 0 )	  {  /* got gattrs, can try sattr */#ifdef DEBUGE 32	    error ( "fb bwtwo emulation not implemented, q to proceed\n" );D 32	    }	  else {E 32I 32D 33#endifE 33I 33#endif DEBUGE 33	  }	else 	  {E 32	    error ( "Not cgfour or bwtwo, q to attempt to proceed" );D 32	    }	  printf("initdisplay: Unsupported FBreal_type %d\n", FBattr.real_type);	  DisplayType = (my_screen.fb_type) << 3;	  /* try to muddle on */E 32	  }I 32	printf("initdisplay: Unsupported FBreal_type %d\n", FBattr.real_type);	DisplayType = (my_screen.fb_type) << 3;	  /* try to muddle on */      }#else /* DISPLAYBUFFER is defined, then: */I 36    DisplayRegion68k_end_addr = DisplayRegion68k					+ DisplayRasterWidth * DisplayHeight;E 36D 34    ColorDisplayPixrect = pr_open("/dev/fb");E 34I 34D 38    if ( my_screen.fb_type == FBTYPE_SUN2BW ) /* real or emulated bwtwo */E 38I 38D 39    DISP_MAX_Address = DisplayRegion68k_end_addr;E 39if ( my_screen.fb_type == FBTYPE_SUN2BW ) /* real or emulated bwtwo */E 38      switch ( FBattr.real_type )	{	    case FBTYPE_SUN4COLOR :	      {  /* need to clear overlay plane */		DisplayType = SUN4COLOR;		ColorFb = pr_open("/dev/fb");		pr_available_plane_groups( ColorFb, sizeof(groups), groups);		if(groups[PIXPG_OVERLAY] && groups[PIXPG_OVERLAY_ENABLE])		  {		    pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);		    pr_rop(ColorFb, 0, 0, ColorFb->pr_width, ColorFb->pr_height,		           PIX_CLR, 0, 0, 0);		    pr_set_plane_group(ColorFb, PIXPG_8BIT_COLOR);		  }		ColorDisplayPixrect = ColorFb;		break;	      }	    default : 	ColorDisplayPixrect = pr_open("/dev/fb");			break;	}I 50else if( my_screen.fb_type == FBTYPE_SUN4COLOR ) { /* cg3 or cg6 */	switch ( FBattr.real_type ) {		case FBTYPE_SUN3COLOR: /* cg3 */		/*	DisplayType = SUN3COLOR; */			DisplayType = (FBattr.real_type) << 3;			break;		case FBTYPE_SUNFAST_COLOR: /* cg6 */		/*	DisplayType = SUNFASTCOLOR; */			DisplayType = (FBattr.real_type) << 3; 			break;		default:  /* unknown display */			DisplayType = (FBattr.real_type) << 3;			break;	} /* end switch */	ColorDisplayPixrect = pr_open("/dev/fb");} /* end else if() */E 50     else ColorDisplayPixrect = pr_open("/dev/fb");E 34    DisplayRegionPixrect = mem_point(DisplayWidth, DisplayHeight,				     1, display_addr);I 34#ifdef I386D 45    DisplayRegionPixrect->pr_data->md_flags |= MP_I386;E 45I 45D 52   DisplayRegionPixrect->pr_data->md_flags |= MP_I386;E 45    ColorDisplayPixrect->pr_data->md_flags |= MP_I386;    printf("Disp flags = 0x%x, FB flags = 0x%x.\n",	DisplayRegionPixrect->pr_data->md_flags,	ColorDisplayPixrect->pr_data->md_flags);E 52I 52   ((struct mpr_data *)DisplayRegionPixrect->pr_data)->md_flags |= MP_I386;   ((struct mpr_data *)ColorDisplayPixrect->pr_data)->md_flags |= MP_I386;E 52#endifE 34#ifdef DEBUG    pr_getcolormap(ColorDisplayPixrect, 0, 2, oldred, oldgreen, oldblue);D 33#endifE 33I 33#endif DEBUGE 33    DBPRINT(("Color map for color pixrect:\n  0:  R: %d, G: %d, B: %d\n  1:  R: %d, G: %d, B: %d\n", oldred[0], oldgreen[0], oldblue[0], oldred[1], oldgreen[1], oldblue[1]));    DBPRINT(("Color depth = %d.\n", ColorDisplayPixrect->pr_depth));    pr_putcolormap(ColorDisplayPixrect, 1, 1, &black, &black, &black);    pr_putcolormap(ColorDisplayPixrect, 0, 1, &white, &white, &white);    pr_putcolormap(ColorDisplayPixrect, 255, 1, &black, &black, &black);    pr_putcolormap(ColorDisplayPixrect, 		   (1<<ColorDisplayPixrect->pr_depth)-1, 1,		   &black, &black, &black);#endifE 32E 30I 17D 21E 21E 17D 29	DisplayLockArea.wl_rect.r_width = DisplayWidth;E 29I 29D 32	DisplayLockArea.wl_rect.r_width  = DisplayWidth;E 29	DisplayLockArea.wl_rect.r_height = DisplayHeight;D 23	E 23D 25	init_cursor(); I 4D 24	size = ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) ) E 24I 24	DisplayByteSize= ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) ) E 25I 25	init_cursor();	DisplayByteSize= ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) )E 32I 32    DisplayLockArea.wl_rect.r_width  = DisplayWidth;    DisplayLockArea.wl_rect.r_height = DisplayHeight;I 41#endif SUNDISPLAY#ifdef XWINDOW    DisplayType = SUN2BW;    DisplayRegion68k_end_addr = DisplayRegion68k				+ DisplayRasterWidth * DisplayHeight;    #endif XWINDOWE 41    init_cursor();    DisplayByteSize= ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) )E 32E 25E 24			& -getpagesize());I 14D 27#ifdef  DEBUGE 14	printf("Display Addr: 0x%x\n",DisplayRegion68k);D 24	printf("length: 0x%x\n",size);E 24I 24	printf("length: 0x%x\n",DisplayByteSize);E 24	printf("page size: 0x%x\n",getpagesize());I 14#endifE 27E 14E 4I 27D 29	DBPRINT(("Display Addr: 0x%x\n",DisplayRegion68k));	DBPRINT(("length: 0x%x\n",DisplayByteSize));	DBPRINT(("page size: 0x%x\n",getpagesize()));E 29I 29D 32	DBPRINT(("Display address: 0x%x\n",DisplayRegion68k));	DBPRINT(("        length : 0x%x\n",DisplayByteSize));	DBPRINT(("        pg size: 0x%x\n",getpagesize()));E 32I 32    DBPRINT(("Display address: 0x%x\n",DisplayRegion68k));    DBPRINT(("        length : 0x%x\n",DisplayByteSize));    DBPRINT(("        pg size: 0x%x\n",getpagesize()));E 32E 29I 41#ifdef SUNDISPLAYE 41E 27D 25	mmapstat = E 25I 25D 32	mmapstat =E 25D 18		mmap( DisplayRegion68k,E 18I 18		(int)mmap( DisplayRegion68k,E 32I 32#ifndef DISPLAYBUFFER    mmapstat = (int)mmap( DisplayRegion68k,E 32E 18D 4		      ((DisplayWidth * DisplayHeight / 8 + 2047 ) & -2048),E 4I 4D 20		      size,E 4D 19		      PROT_READ | PROT_WRITE, MAP_SHARED, FrameBufferFd, 0 );E 19I 19		      PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED,			  FrameBufferFd, 0 );E 20I 20D 24		      	size,E 24I 24D 25		      	DisplayByteSize,E 24		      	PROT_READ | PROT_WRITE, #ifdef OS4 			MAP_FIXED | E 25I 25			DisplayByteSize,			PROT_READ | PROT_WRITE,#ifdef OS4			MAP_FIXED |E 25#endif			MAP_SHARED,			FrameBufferFd, 0 );E 20E 19D 25	E 25I 25E 25I 14D 27#ifdef  DEBUGE 14I 4	printf("after mmap: 0x%x\n",mmapstat);I 14#endifE 27I 27D 32	DBPRINT(("after mmap: 0x%x\n",mmapstat));E 32I 32    DBPRINT(("after mmap: 0x%x\n",mmapstat));E 32E 27E 14E 4D 18	if(mmapstat != 0){		fprintf( stderr, "init_display: ERROR at mmap system call\n");		fprintf( stderr, "errno = %d\n\n", errno );E 18I 18D 32	if(mmapstat == -1){		perror("init_display: ERROR at mmap system call\n");E 18		exit( 0 );	}E 32I 32    if(mmapstat == -1)      {	perror("init_display: ERROR at mmap system call\n");	exit( 0 );      }#endif /* ifndef DISPLAYBUFFER */E 32I 27D 32	DBPRINT(("after mem_point\n"));E 32I 32    DBPRINT(("after mem_point\n"));I 41#endif SUNDISPLAYE 41E 32E 27D 16	ScreenBitMap = mem_point( DisplayWidth, DisplayHeight, 1,				  DisplayRegion68k );E 16D 25	E 25I 25E 25I 14D 27#ifdef  DEBUGE 14I 4D 16	printf("after mem_point, ScreenBitMap =  0x%x\n",ScreenBitMap);E 16I 16	printf("after mem_point\n");E 16I 14#endifE 14E 4	/* clear display */E 27D 16	pr_rop( ScreenBitMap, 0, 0, DisplayWidth, DisplayHeight, PIX_CLR,		ScreenBitMap, 0, 0);E 16I 16D 32	clear_display();E 32I 32    clear_display();E 32E 16I 14D 27#ifdef  DEBUGE 14I 4D 16	printf("after PIX_CLR\n");E 16I 16	printf("after clear_display()\n");E 16I 14#endifE 27I 27D 32	DBPRINT(("after clear_display()\n"));E 32I 32    DBPRINT(("after clear_display()\n"));E 32E 27I 22D 32	/* initialize pixrect using in pilotbitblt */D 27	SrcPixRect = mem_point( 0, 0, 1, NULL );E 27I 27	SrcePixRect = mem_point( 0, 0, 1, NULL );E 27	DestPixRect = mem_point( 0, 0, 1, NULL );E 32I 32D 53    /* initialize pixrect using in pilotbitblt */E 53I 53#ifndef NOPIXRECT    /* initialize pixrect used in pilotbitblt */E 53    SrcePixRect = mem_point( 0, 0, 1, NULL );    DestPixRect = mem_point( 0, 0, 1, NULL );I 53#endif NOPIXRECTE 53E 32E 22E 14E 4D 16	/* initialize pixrect using in pilotbitblt */	SrcPixRect = mem_point( 0, 0, 1, NULL );	DestPixRect = mem_point( 0, 0, 1, NULL );	TexturePixRect = mem_create( 16, 32, 1 );I 8	BlackTexturePixRect = mem_create( 16, 16, 1);	pr_rop( BlackTexturePixRect, 0, 0, 16, 16, PIX_SET,		BlackTexturePixRect, 0, 0);I 9	WhiteTexturePixRect = mem_create( 16, 16, 1);	pr_rop( WhiteTexturePixRect, 0, 0, 16, 16, PIX_CLR,		WhiteTexturePixRect, 0, 0);E 16I 14D 27#ifdef  DEBUGE 14E 9E 8D 4	E 4I 4	printf("before set_cursor\n");I 14#endifE 14E 27I 27D 29	DBPRINT(("before set_cursor\n"));E 29I 29D 32	DBPRINT(("exiting init_display\n"));E 32I 32    DBPRINT(("exiting init_display\n"));E 32E 29E 27E 4}I 27D 34/*  ================================================================  */E 34E 27I 53E 53I 34D 41E 41/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/I 53E 53D 41E 41E 34init_cursor()D 27{E 27I 27    {I 53#ifndef NOPIXRECTE 53    CursorBitMap = mem_create( CURSORWIDTH, CURSORHEIGHT, 1 );    mpr_mdlinebytes(CursorBitMap) = CURSORWIDTH >> 3;/* 2(byte) */I 53#endif NOPIXRECTE 53I 41#ifdef SUNDISPLAYE 41    CurrentCursor.cur_xhot = 0;    CurrentCursor.cur_yhot = 0;    CurrentCursor.cur_shape = CursorBitMap;    CurrentCursor.cur_function = PIX_SRC | PIX_DST;I 41#endif SUNDISPLAYE 41E 27D 24E 24D 27	CursorBitMap = mem_create( CURSORWIDTH, CURSORHEIGHT, 1 );	mpr_mdlinebytes(CursorBitMap) = CURSORWIDTH >> 3;/* 2(byte) */	CurrentCursor.cur_xhot = 0;	CurrentCursor.cur_yhot = 0;	CurrentCursor.cur_shape = CursorBitMap;	CurrentCursor.cur_function = PIX_SRC | PIX_DST;E 27I 27    /*  Invisible Cursor */I 53#ifndef NOPIXRECTE 53    InvisibleCursorBitMap = mem_create( 0, 0, 1 );I 53#endif NOPIXRECTE 53I 41#ifdef SUNDISPLAYE 41    InvisibleCursor.cur_xhot = 0;    InvisibleCursor.cur_yhot = 0;    InvisibleCursor.cur_shape = InvisibleCursorBitMap;    InvisibleCursor.cur_function = /*PIX_SRC |*/ PIX_DST;E 27D 25	E 25I 25D 41E 41E 25D 27	/*  Invisible Cursor */D 3	InvisibleCursorBitMap = mem_create( CURSORWIDTH, CURSORHEIGHT, 1 );E 3I 3D 4	InvisibleCursorBitMap = mem_create( 0, 0, 1 );/* Fixed by T.S suggested by O.N*/E 4I 4D 5	InvisibleCursorBitMap = mem_create( CURSORWIDTH, CURSORHEIGHT, 1 );E 5I 5	InvisibleCursorBitMap = mem_create( 0, 0, 1 );E 5E 4E 3	InvisibleCursor.cur_xhot = 0;	InvisibleCursor.cur_yhot = 0;	InvisibleCursor.cur_shape = InvisibleCursorBitMap;	InvisibleCursor.cur_function = /*PIX_SRC |*/ PIX_DST;E 27I 27    win_setcursor( LispWindowFd, &InvisibleCursor);    win_setmouseposition(LispWindowFd, 0, 0);I 41#endif SUNDISPLAYE 41    }E 27D 16	pr_rop( InvisibleCursorBitMap, 0, 0, CURSORWIDTH, CURSORHEIGHT, PIX_CLR,		InvisibleCursorBitMap, 0, 0);E 16D 27	win_setcursor( LispWindowFd, &InvisibleCursor);	win_setmouseposition(LispWindowFd, 0, 0);E 27I 27D 34/*  ================================================================  */E 34E 27D 24}E 24D 41I 34E 41/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/D 41E 41E 34I 24D 27}E 27E 24set_cursor()D 27{E 27I 27    {I 41#ifdef SUNDISPLAYE 41E 27D 24E 24I 24#ifdef OLD_CURSORE 24D 25	(mpr_d(CursorBitMap))->md_image = E 25I 25D 27	(mpr_d(CursorBitMap))->md_image =E 27I 27    (mpr_d(CursorBitMap))->md_image =E 27E 25			(short *)(IOPage->dlcursorbitmap);				/* BitmapBase of CurrentCursor				 * is set to IOPage->dlcursorbitmap				 */D 11	win_setcursor( LispWindowFd, &CurrentCursor );	win_setmouseposition(LispWindowFd, 0, 0);E 11I 11D 27	if(win_setcursor( LispWindowFd, &CurrentCursor )== -1)		perror("SET Cursor");	if(win_setmouseposition(LispWindowFd, 0, 0)==-1)		perror("SET Mouse POS");E 27I 27    if( win_setcursor( LispWindowFd, &CurrentCursor )== -1)	perror("SET Cursor");    if( win_setmouseposition(LispWindowFd, 0, 0)==-1)	perror("SET Mouse POS");E 27I 24#elseD 27      if(win_setcursor(LispWindowFd,&InvisibleCursor) ==-1)             perror("SET Cursor:");E 27I 27    if( win_setcursor(LispWindowFd,&InvisibleCursor) ==-1)	perror("SET Cursor:");E 27#endifI 41#endif SUNDISPLAYE 41E 24I 14D 27#ifdef  DEBUGE 14	printf("After Set cursor\n");I 14#endifE 27I 27I 41#ifdef XWINDOWD 49    Init_DisplayCursor();E 49I 49    Init_XCursor();E 49#endif XWINDOWE 41	DBPRINT(("After Set cursor\n"));E 27E 14E 11}D 27display_before_exit(){E 27I 27D 34/*  ================================================================  */E 34E 27I 34/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/D 41E 41E 34D 27	/* clear display */D 4	pr_rop( ScreenBitMap, 0, 0, DisplayWidth, DisplayHeight, PIX_CLR,E 4I 4E 27I 27display_before_exit()	{I 51#ifdef SUNDISPLAY	union wait status;#endif SUNDISPLAYI 60#ifdef TRUECOLOR	truecolor_before_exit();#endif TRUECOLORE 60E 51E 27D 15	pr_rop( ScreenBitMap, 0, 0, DisplayWidth, DisplayHeight, PIX_SET,E 15I 15D 16	pr_rop( ScreenBitMap, 0, 0, DisplayWidth, DisplayHeight, PIX_CLR,E 15E 4		ScreenBitMap, 0, 0);E 16I 16	clear_display();E 16D 41E 41I 41#ifdef SUNDISPLAYE 41D 4	/* pr_close( ScreenBitMap );        win_remove( LispWindowFd );E 4I 4D 25	 E 25I 25D 27E 25D 16	pr_close( ScreenBitMap );E 16  /*      win_remove( LispWindowFd ); */E 27I 27  /*    win_remove( LispWindowFd ); */E 27E 4        win_screendestroy( LispWindowFd );I 12#ifdef KBINTE 12I 6		int_io_close(LispWindowFd);I 12#endifE 12E 6D 4        close( LispWindowFd ); */E 4I 4D 25        close( LispWindowFd ); E 25I 25        close( LispWindowFd );I 51	if (Win_security_p) {		switch (vfork()) {		      case -1:	/* Error */			(void)fprintf(stderr, "display_before_exit: Fork failed.\n");			exit(1);		      case 0:	/* Child */			(void)execl(SV_RELEASE, "sv_release", 0);			/* should not return */			(void)fprintf(stderr,				      "display_before_exit: exec for sv_release failed\n");			exit(1);		      default:	/* Parent */			/* do nothing */			break;		}		(void)wait(&status);		if (status.w_retcode != 0) {			(void)fprintf(stderr,				      "display_before_raid: failed to set ownership of win devices\n");			exit(1);		}	}E 51I 41#endif SUNDISPLAY#ifdef XWINDOW	lisp_Xexit();#endif XWINDOWE 41I 27	}E 27E 25E 4D 27}E 27I 27D 34/*  ================================================================  */E 34E 27I 34D 41E 41/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/D 50E 50I 50#ifndef COLORE 50E 34I 16clear_display()D 27{register short *word;register int w, h;word = DisplayRegion68k;for (h = DisplayHeight; (h--);)  {  for (w = DisplayRasterWidth; (w--);) {*word++ = 0;}  }I 23}E 27I 27D 32    {E 32I 32  {I 41#ifdef SUNDISPLAYE 41I 37#ifndef DISPLAYBUFFERE 37E 32    register short *word;    register int w, h;D 40    word = DisplayRegion68k;E 40I 40    word =(short*) DisplayRegion68k;E 40    for (h = DisplayHeight; (h--);)D 32	{E 32I 32      {E 32	for (w = DisplayRasterWidth; (w--);) {*word++ = 0;}D 32	}    }E 32I 32      }D 37#ifdef DISPLAYBUFFER    pr_rop(ColorDisplayPixrect, 0, 0, DisplayWidth, DisplayHeight,E 37I 37#elseD 43  /*  pr_rop(ColorDisplayPixrect, 0, 0, DisplayWidth, DisplayHeight,E 37	   COPY_PIXRECT_TO_COLOR,D 37	   DisplayRegionPixrect, 0, 0);#endifE 37I 37	   DisplayRegionPixrect, 0, 0);*/ /* Original images are still kept in SYSOUT(DisplayRegion)  */    clear_CG6;E 43I 43    pr_rop(ColorDisplayPixrect, 0, 0, DisplayWidth, DisplayHeight,	   PIX_CLR,	   ColorDisplayPixrect, 0, 0);  /* Original images are still kept in SYSOUT(DisplayRegion)  */  /*  clear_CG6; */E 43#endif DISPLAYBUFFERI 41#endif SUNDISPLAYE 41E 37  }E 32E 27D 27/*****************************************************//* EXPERIMENTS for COLOR *//* CALLED from SUBR */E 27I 27D 50/*  ================================================================  */E 50I 50#else COLORE 50D 50E 27DLword *ColorDisplayRegion68k;int Dispcolorsize;I 40int MonoOrColor=MONO_SCREEN;E 40I 27I 40E 40E 27D 24char redarr[256];char greenarr[256];char bluearr[256];E 24/*******************************************************************/D 27/*D 25	Func name	: cgfour_init_color_display(args) E 25I 25	Func name	: cgfour_init_color_display(args)E 25	Arg(S)		: COLOR BITMAP ADDRESS(LISPPTR)E 27I 27/*	Func name	: cgfour_init_color_display(args)	Arg(s)		: COLOR BITMAP ADDRESS(LISPPTR)E 27	Desc		: Assign to SUBR 0210			  mmap LispPTR to Color Display FB.	By  TakeshiD 27E 27*//*******************************************************************/cgfour_init_color_display(color_bitmapbase) /* SUBR 0210 */D 27LispPTR color_bitmapbase;  /* COLOR BITMAP ADDRESS */{ struct pixrect *ColorFb;D 25 int mmapstat;  E 25I 25 int mmapstat;E 27I 27    LispPTR color_bitmapbase;  /* COLOR BITMAP ADDRESS */    {    struct pixrect *ColorFb;I 40    struct pixrect *color_source;E 40    int mmapstat;E 27E 25D 27 ColorDisplayRegion68k= Addr68k_from_LADDR(color_bitmapbase );E 27I 27D 40    ColorDisplayRegion68k = Addr68k_from_LADDR(color_bitmapbase );E 40I 40 if(MonoOrColor == COLOR_SCREEN) {	printf("You can not initialize the color screen from inside color screen. \n");  }E 40E 27I 40    ColorDisplayRegion68k = Addr68k_from_LADDR(color_bitmapbase );    E 40D 25 Dispcolorsize = ((DisplayWidth * DisplayHeight + (getpagesize()-1) ) E 25I 25D 27 Dispcolorsize = ((DisplayWidth * DisplayHeight + (getpagesize()-1) )E 27I 27    Dispcolorsize = ((DisplayWidth * DisplayHeight + (getpagesize()-1) )E 27E 25			& -getpagesize()); /* 8 bit depth */D 40E 40I 40    ColorFb = pr_open("/dev/fb");    color_source = mem_point(DisplayWidth,DisplayHeight,8,	ColorDisplayRegion68k);     pr_set_plane_group(ColorFb, PIXPG_8BIT_COLOR);    pr_rop(ColorFb,0,0,DisplayWidth,DisplayHeight,PIX_SRC,	color_source,0,0);E 40D 27 mmapstat = (int)mmap(ColorDisplayRegion68k ,E 27I 27    mmapstat = (int)mmap(ColorDisplayRegion68k ,E 27D 25		      	Dispcolorsize,		      	PROT_READ | PROT_WRITE,E 25I 25			Dispcolorsize,			PROT_READ | PROT_WRITE,E 25#ifdef OS4			MAP_FIXED |#endif			MAP_SHARED,D 27				FrameBufferFd, 0x40000 );	if(mmapstat == -1){	    perror("cgfour_init_color_display: ERROR at mmap system call\n");	    error("cgfour_init_color_display: ERROR at mmap system call\n You may be able to continue by typing 'q'");E 27I 27			FrameBufferFd, 0x40000 );    if(mmapstat == -1){	perror("cgfour_init_color_display: ERROR at mmap system call\n");	error ("cgfour_init_color_display: ERROR at mmap system call\n You may be able to continue by typing 'q'");E 27	}D 24 /*printf("COLOR-INIT OK BMBASE=0x%x\n",color_bitmapbase);*/E 24I 24D 27 printf("COLOR-INIT OK BMBASE=0x%x\n",color_bitmapbase);E 24  return(color_bitmapbase);} /* end cgfour_init_color_display */E 27I 27D 40    printf("COLOR-INIT OK BMBASE=0x%x\n",color_bitmapbase);E 40I 40    printf("COLOR-INIT OK BMBASE=0x%x\nNATIVE:= 0x%x)\n",	color_bitmapbase,ColorDisplayRegion68k);E 40    return(color_bitmapbase);    } /* end cgfour_init_color_display */E 27/*******************************************************************/D 27/*	Func name	: cgfour_change_screen_mode(which_screen)	Arg(S)		: MONO_SCREEN OR COLOR_SCREENE 27I 27/*	Func name	: cgfour_change_screen_mode(which_screen)	Arg(s)		: MONO_SCREEN OR COLOR_SCREENE 27	Desc		: Assign to SUBR 0211			  Change screen Mono to Color,vice versa.	By  TakeshiD 27E 27*//*******************************************************************/D 27#define MONO_SCREEN 0E 27I 27D 40#define MONO_SCREEN  0E 27#define COLOR_SCREEN 1I 27E 27int MonoOrColor=MONO_SCREEN;E 40I 27E 27cgfour_change_screen_mode(which_screen)D 27LispPTR which_screen;{ /* subr 0211 */ struct pixrect *ColorFb;I 26 extern ScreenLocked; extern DLword *EmCursorX68K,*EmCursorY68K;E 27I 27    LispPTR which_screen;    { /* subr 0211 */    struct pixrect *ColorFb;    extern ScreenLocked;    extern DLword *EmCursorX68K,*EmCursorY68K;E 27E 26D 27 ColorFb = pr_open("/dev/fb");D 26E 26I 26 ScreenLocked=T; taking_mouse_down();E 26 if((which_screen& 0xf) ==MONO_SCREEN) { /* resume mono screen */   pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);   pr_rop(ColorFb,0,0,ColorFb->pr_width, ColorFb->pr_height,			PIX_SET, 0, 0, 0);   pr_set_plane_group(ColorFb, PIXPG_OVERLAY);I 26   MonoOrColor = MONO_SCREEN;E 26D 25 } E 25I 25 }E 25 else if((which_screen&0XF)==COLOR_SCREEN){   pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);   pr_rop(ColorFb,0,0,ColorFb->pr_width, ColorFb->pr_height,			PIX_CLR, 0, 0, 0);   pr_set_plane_group(ColorFb, PIXPG_8BIT_COLOR);I 26   MonoOrColor = COLOR_SCREEN ;E 26 } else error("cgfour_change_screen_mode:Unknown mode:");E 27I 27    ColorFb = pr_open("/dev/fb");    ScreenLocked=T;    taking_mouse_down();E 27D 27 pr_close(ColorFb);I 26 taking_mouse_up(*EmCursorX68K,*EmCursorY68K); ScreenLocked=NIL;E 26 return(which_screen);}E 27I 27D 28    switch (which_screen & 0xf)E 28I 28    switch (which_screen & 0xf) {E 28        case MONO_SCREEN : { /* resume mono screen */	    pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);	    pr_rop(ColorFb,0,0,		   ColorFb->pr_width,		   ColorFb->pr_height, PIX_SET, 0, 0, 0);	    pr_set_plane_group(ColorFb, PIXPG_OVERLAY);	    MonoOrColor = MONO_SCREEN;	    break;	    }        case COLOR_SCREEN : {	    pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);	    pr_rop(ColorFb,0,0,		   ColorFb->pr_width,		   ColorFb->pr_height, PIX_CLR, 0, 0, 0);	    pr_set_plane_group(ColorFb, PIXPG_8BIT_COLOR);	    MonoOrColor = COLOR_SCREEN;	    break;	    }	default : {	    error("cgfour_change_screen_mode:Unknown mode:");	    }E 27D 28E 28I 28	};E 28I 27    pr_close(ColorFb);    taking_mouse_up(*EmCursorX68K,*EmCursorY68K);    ScreenLocked=NIL;    return(which_screen);    }E 27/*******************************************************************/D 27/*	Func name	: cgfour_set_colormap(args)	Arg(S)		: Passed by argsE 27I 27/*	Func name	: cgfour_set_colormap(args)	Arg(s)		: Passed by argsE 27			  index: colormap index(0~255)			  red,green,blue:(0~255)	Desc		: Assign to SUBR 0212			  Set Colormap entry	By  TakeshiD 27E 27*//*******************************************************************/unsigned char RED_colormap;D 27unsigned char GREEN_colormap;unsigned char BLUE_colormap;E 27I 27unsigned char GRN_colormap;unsigned char BLU_colormap;E 27cgfour_set_colormap(args)D 27LispPTR args[];{int index;unsigned char red,green,blue;struct pixrect *ColorFb;E 27I 27    LispPTR args[];    {    int index;    struct pixrect *ColorFb;E 27D 27index=args[0]&0xff;red=(unsigned char)(args[1] & 0xff);green=(unsigned char)(args[2] & 0xff);blue=(unsigned char)(args[3] & 0xff);E 27I 27    index=args[0] & 0xff;E 27I 27    RED_colormap = (unsigned char) (args[1] & 0xff);    GRN_colormap = (unsigned char) (args[2] & 0xff);    BLU_colormap = (unsigned char) (args[3] & 0xff);E 27D 27 RED_colormap=red; GREEN_colormap=green; BLUE_colormap=blue;E 27I 27    ColorFb = pr_open("/dev/fb");E 27D 25 E 25I 25E 25D 27 ColorFb = pr_open("/dev/fb"); if(pr_putcolormap(ColorFb,index,1,&RED_colormap,&GREEN_colormap,&BLUE_colormap)==-1)	perror("putcolormap:") ; pr_close(ColorFb);return(T);E 23}E 27I 27    if (pr_putcolormap(ColorFb,index,1,			&RED_colormap,			&GRN_colormap,			&BLU_colormap)==-1)	perror("putcolormap:");    pr_close(ColorFb);    return(T);    }I 32E 50I 50clear_display(){	register short *word;	register int w, h;	if( MonoOrColor == MONO_SCREEN ) {#ifndef DISPLAYBUFFER		word = DisplayRegion68k;		for( h=DisplayHeight; (h--);) {			for( w=DisplayRasterWidth; (w--);) {*word++ = 0;}		} /* end for(h) */#else DISPLAYBUFFER		pr_rop(ColorDisplayPixrect, 0, 0, DisplayWidth, DisplayHeight,	   		PIX_CLR,ColorDisplayPixrect, 0, 0);#endif DISPLAYBUFFER	} else { /* MonoOrColo is COLOR_SCREEN */D 56		word = ColorDisplayRegion68k;E 56I 56		word = (short *)ColorDisplayRegion68k;E 56		for( h=DisplayHeight; (h--);) {			for( w=DisplayRasterWidth*8; (w--);) {*word++ = 0;}		} /* end for(h) */	} /* end if(MonoOrColor) */ }#endif COLORE 50#ifdef DISPLAYBUFFERI 34#ifdef I386#define EVENADDR(ptr) (0xFFFFFFFE & (int)ptr)#else#define EVENADDR(ptr) (ptr)#endifI 41#endif DISPLAYBUFFER#ifdef DISPLAYBUFFERE 41E 34/************************************************************************//*									*//*		    i n _ d i s p l a y _ s e g m e n t			*//*									*//*	Returns T if the base address for this bitblt is in the 	*//*	display segment.						*//*									*//************************************************************************/D 38E 38I 38/*  Change as MACRO by osamu '90/02/08 *  new macro definition is in display.h E 38in_display_segment(baseaddr)  register DLword *baseaddr;  {    if ((DisplayRegion68k <= baseaddr) &&	(baseaddr <=DISP_MAX_Address))   return(T);    return(NIL);  }D 38E 38I 38------------------ */I 41#endif DISPLAYBUFFERE 41E 38/************************************************************************//*									*//*		 f l u s h _ d i s p l a y _ b u f f e r		*//*									*//*	Copy the entire Lisp display bank to the real frame buffer 	*//*	[Needs to be refined for efficiency.]				*//*									*//************************************************************************/flush_display_buffer()  {I 41#ifdef SUNDISPLAY#ifdef DISPLAYBUFFERE 41I 34#ifdef I386D 45    bit_reverse_region( DisplayRegion68k, DisplayWidth,E 45I 45   bit_reverse_region( DisplayRegion68k, DisplayWidth,E 45		        DisplayHeight, DLWORD_PERLINE);#endifE 34    pr_rop(ColorDisplayPixrect, 0, 0, DisplayWidth, DisplayHeight,	   COPY_PIXRECT_TO_COLOR,	   DisplayRegionPixrect, 0, 0);I 34#ifdef I386D 45    bit_reverse_region( DisplayRegion68k, DisplayWidth,E 45I 45   bit_reverse_region( DisplayRegion68k, DisplayWidth,E 45		        DisplayHeight, DLWORD_PERLINE);#endifI 41#endif DISPLAYBUFFER#endif SUNDISPLAY#ifdef XWINDOW    clipping_Xbitblt( 0, 0, DisplayWidth, DisplayHeight ); #endif XWINDOWE 41E 34  }I 41E 41/************************************************************************//*									*//*		 f l u s h _ d i s p l a y _ r e g i o n		*//*									*//*	Copy a region of the Lisp display bank to the real frame 	*//*	buffer.								*//*									*//*	x								*//*	y								*//*	w  the width of the piece to display, in pixels			*//*	h  the height of the piece to display, in pixels		*//*									*//************************************************************************/I 45#define BITEPER_DLBYTE 8#define DLBYTE_PERLINE        (DisplayWidth/8)E 45flush_display_region(x, y, w, h)  int x, y, w, h;I 42#ifdef I386D 45  { flush_display_buffer(); }E 45I 45  { /*flush_display_buffer(); */   register unsigned int *longptr;   int nx,nw;     nx = x & 0xffffffe0 ;D 47     nw =  (w + 31) & 0xffffffe0; /* Still broke right edge */E 47I 47     nw =  (w + 31 + (x & 0x1F)) & 0xffffffe0; /* Still broke right edge */E 47    byte_swapped_displayregion(nx , y , nw , h);    pr_rop(ColorDisplayPixrect, nx, y, nw, h,	   COPY_PIXRECT_TO_COLOR,	   DisplayRegionPixrect, nx, y);    byte_swapped_displayregion(nx , y , nw , h);}E 45#elseE 42  {I 41#ifdef SUNDISPLAY#ifdef DISPLAYBUFFERE 41I 34D 42#ifdef I386 /*   int base = DisplayRegion68k+(y*DLWORD_PERLINE)+(x/16);    int realw = w+ (((int)base&1) ? 16 : 0);    bit_reverse_region( EVENADDR(base), realw,		        h, DLWORD_PERLINE); */    bit_reverse_region( DisplayRegion68k, DisplayWidth,		        DisplayHeight, DLWORD_PERLINE);#endifE 42E 34    pr_rop(ColorDisplayPixrect, x, y, w, h,	   COPY_PIXRECT_TO_COLOR,	   DisplayRegionPixrect, x, y);I 34D 42#ifdef I386/*    bit_reverse_region( EVENADDR(base), realw,		        h, DLWORD_PERLINE); */    bit_reverse_region( DisplayRegion68k, DisplayWidth,		        DisplayHeight, DLWORD_PERLINE);#endifE 42I 41#endif DISPLAYBUFFER#endif SUNDISPLAYE 41E 34D 41  }E 41I 41#ifdef XWINDOW	clipping_Xbitblt( x, y, w, h );#endif XWINDOW}I 42#endif I386I 46#ifdef BYTESWAPE 46I 45byte_swapped_displayregion(x , y , w , h)  int x ,y,w,h;{  extern unsigned char reversedbits[];  register unsigned int *longptr,*lineptr;  register int linecount,wordlimit;E 45E 42E 41I 45      /* Get QUAD byte aligned pointer */  longptr = (unsigned int *)    (((int)((DLword*)DisplayRegion68k + (DLWORD_PERLINE * y))			+ ((x +7)>>3)) & 0xfffffffc);D 48  bit_reverse_region(longptr, w, h, DLWORD_PERLINE);return;E 48D 48/* The following code does not work now */E 48I 48  bit_reverse_region(longptr, w, h, DLWORD_PERLINE);E 48D 48  wordlimit = w +31 >>5 ;   for(linecount=0,lineptr = longptr;	linecount<h;	linecount++,longptr+= DLBYTE_PERLINE/4,lineptr = longptr)  { register  unsigned char *ptr;    register int wcnt;	for(ptr = (unsigned char *)lineptr, wcnt=0;	 wcnt < wordlimit ;wcnt++,ptr+=4)	{ register unsigned int temp;		temp = (unsigned int)reversedbits[(*ptr)];		temp |= (unsigned int)((reversedbits[(*(ptr+1))]<<8) | 			((reversedbits[(*(ptr+2))])<<16) |					 (reversedbits[(*(ptr+3))]<<24));		*(unsigned int*)ptr = temp;			} /* inner for loop */E 48I 48  return;E 48D 48  } /* outer for loop */E 48I 48  }/* byte_swapped_displayregion end */#endif BYTESWAPE 48D 48}/* byte_swapped_displayregion end */D 46E 46I 46#endif BYTESWAPE 48I 48E 48E 46E 45I 41D 42E 42E 41/************************************************************************//*									*//*	    f l u s h _ d i s p l a y _ l i n e r e g i o n		*//*									*//*	Copy a region of the Lisp display bank to the real frame 	*//*	buffer.								*//*									*//*	x								*//*	ybase the offset from top of bitmap, as the address of the	*//*	       first word of the line to start on.			*//*	w  the width of the piece to display, in pixels			*//*	h  the height of the piece to display, in pixels		*//*									*//************************************************************************/flush_display_lineregion(x, ybase, w, h)  int x, ybase, w, h;I 42#ifdef I386D 45  { flush_display_buffer(); }E 45I 45  { /*flush_display_buffer(); */    int y;    y = ((DLword *)ybase-DisplayRegion68k)/DLWORD_PERLINE;	   bit_reverse_region(ybase, DisplayWidth, h,DLWORD_PERLINE);    pr_rop(ColorDisplayPixrect, x, y, DisplayWidth, h,	   COPY_PIXRECT_TO_COLOR,	   DisplayRegionPixrect, x, y);	   bit_reverse_region(ybase, DisplayWidth, h,DLWORD_PERLINE);  }E 45#elseE 42  {    int y;I 41    y = ((DLword *)ybase-DisplayRegion68k)/DLWORD_PERLINE;#ifdef SUNDISPLAY#ifdef DISPLAYBUFFERE 41D 34    y = ((DLword *)ybase-DisplayRegion68k)/DLWORD_PERLINE;E 34I 34D 42#ifdef I386 /*   int realw = w+ (((int)ybase&1) ? 16 : 0);    bit_reverse_region( EVENADDR(ybase), realw,		        h, DLWORD_PERLINE);*/    bit_reverse_region( DisplayRegion68k, DisplayWidth,		        DisplayHeight, DLWORD_PERLINE);#endifE 42D 41   y = ((DLword *)ybase-DisplayRegion68k)/DLWORD_PERLINE;E 41E 34    pr_rop(ColorDisplayPixrect, x,	   y, w, h,	   COPY_PIXRECT_TO_COLOR,	   DisplayRegionPixrect, x, y);I 34D 42#ifdef I386/*    bit_reverse_region( EVENADDR(ybase), realw,		        h, DLWORD_PERLINE);*/    bit_reverse_region( DisplayRegion68k, DisplayWidth,		        DisplayHeight, DLWORD_PERLINE);#endifE 42I 41#endif DISPLAYBUFFER#endif SUNDISPLAYE 41I 41#ifdef XWINDOW    clipping_Xbitblt( x, y, w, h );#endif XWINDOWE 41E 34  }I 42#endif I386E 42D 41E 41/************************************************************************//*									*//*	    f l u s h _ d i s p l a y _ p t r r e g i o n		*//*									*//*	Copy a region of the Lisp display bank to the real frame 	*//*	buffer.								*//*									*//*	bitoffset  bit offset into word pointed to by ybase		*//*	ybase the offset from top of bitmap, as the address of the	*//*	       word containing the upper-leftmost bit changed.		*//*	w  the width of the piece to display, in pixels			*//*	h  the height of the piece to display, in pixels		*//*									*//************************************************************************/#define BITSPERWORD 16flush_display_ptrregion(ybase, bitoffset, w, h)  int bitoffset, ybase, w, h;I 42#ifdef I386  { flush_display_buffer(); }#elseE 42  {D 34    int y, x, baseoffset;    baseoffset = ((DLword *)ybase-DisplayRegion68k);E 34I 34    int y, x, baseoffset, realw;    baseoffset = (((DLword *)ybase)-DisplayRegion68k);E 34    y = baseoffset/DLWORD_PERLINE;    x = bitoffset + (BITSPERWORD*(baseoffset - (DLWORD_PERLINE * y)));I 41#ifdef SUNDISPLAY#ifdef DISPLAYBUFFERE 41I 34D 42#ifdef I386/*    realw = w+ (((int)ybase&1) ? 16 : 0);    bit_reverse_region( EVENADDR(ybase), realw,		        h, DLWORD_PERLINE);*/    bit_reverse_region( DisplayRegion68k, DisplayWidth,		        DisplayHeight, DLWORD_PERLINE);#endifE 42E 34    pr_rop(ColorDisplayPixrect, x,	   y, w, h,	   COPY_PIXRECT_TO_COLOR,	   DisplayRegionPixrect, x, y);I 34D 42#ifdef I386 /*   bit_reverse_region( EVENADDR(ybase), realw,		        h, DLWORD_PERLINE);*/    bit_reverse_region( DisplayRegion68k, DisplayWidth,		        DisplayHeight, DLWORD_PERLINE);#endifE 42I 41#endif DISPLAYBUFFER#endif SUNDISPLAYE 41I 41#ifdef XWINDOW    clipping_Xbitblt( x, y, w, h );#endif XWINDOWE 41E 34  }I 42#endif I386E 42D 41#endif DISPLAYBUFFERE 41E 32E 27E 16E 1