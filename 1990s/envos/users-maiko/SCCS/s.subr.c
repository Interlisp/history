h06444s 00014/00007/00721d D 2.67 92/11/25 21:12:42 sybalsky 94 93c Fixing endif's with extra text => comment. \nes 00006/00005/00722d D 2.66 92/06/26 13:50:23 sybalsky 93 92c retrofit of 386 unix changes \nes 00006/00000/00721d D 2.65 92/04/29 17:40:48 nilsson 92 91c provissions for smashing applyes 00011/00005/00710d D 2.64 92/04/23 10:55:51 sybalsky 91 90c fixing SCCS headers \nes 00004/00004/00711d D 2.63 92/04/21 17:24:32 sybalsky 90 89c shortening file names for DOS \nes 00073/00000/00642d D 2.62 92/03/04 19:28:58 nilsson 89 88c Inserted subrcodes for foreign function callses 00037/00001/00605d D 2.61 91/10/15 18:26:51 sybalsky 88 87c ISC changeses 00026/00001/00580d D 2.60 91/08/26 15:27:34 sybalsky 87 86c CLX -- add subr calls for socketses 00014/00001/00567d D 2.59 91/05/06 15:43:08 sybalsky 86 85c Add re-set interrupts subr.es 00002/00001/00566d D 2.58 91/04/16 17:35:14 sybalsky 85 84c 3-byte-atom changes - find_symbol speedupes 00030/00023/00537d D 2.57 91/03/29 02:45:53 sybalsky 84 83c Add subr 0216:  Color-display line drawing on 8bpp screens.es 00023/00025/00537d D 2.56 90/09/18 23:48:53 sybalsky 83 82c Retrofit changes from AIX, DEC3100, PS/2es 00006/00000/00556d D 2.55 90/07/20 17:34:35 fuji 82 81c Added new function Colorize_Bitmap, Uncolorize_Bitmap.es 00021/00001/00535d D 2.54 90/06/22 16:40:09 fuji 81 80c New compile flag NOETHERes 00004/00000/00532d D 2.53 90/06/15 16:55:50 mitani 80 79c sb_DISABLEGCes 00011/00003/00521d D 2.52 90/06/04 14:52:55 mitani 79 78c new directory enumeration subrcalles 00000/00000/00524d D 2.51 90/04/20 01:53:28 sybalsky 78 77c   shortening file names, bulk change.es 00022/00044/00502d D 2.50 90/04/19 18:24:22 mitani 77 76c Version up to 1.2es 00008/00002/00538d D 2.49 90/02/12 11:45:37 takeshi 76 75c Add C_Slowbltchares 00000/00001/00540d D 2.48 89/12/28 15:28:34 sybalsky 75 74c es 00036/00011/00505d D 2.47 89/12/13 10:58:32 sybalsky 74 73c new TCP subr, more bitblt caseses 00051/00000/00465d D 2.46 89/10/19 18:01:29 sybalsky 73 72c add loops op subrs & char device miscn'ses 00000/00005/00465d D 2.45 89/02/28 03:59:52 sybalsky 72 71c Moved SXHASH from here.es 00002/00002/00468d D 2.44 89/02/27 12:03:12 shih 71 70c lost sccsides 00007/00001/00463d D 2.43 89/02/17 18:41:28 sybalsky 70 69c Added SXHASH entry to the dispatch table.es 00000/00000/00464d D 2.42 89/02/14 13:45:01 snow 69 68c no changeses 00002/00000/00462d D 2.41 89/02/14 13:15:18 snow 68 67c added subr 024 so loadups will workes 00013/00012/00449d D 2.40 89/02/13 16:36:09 sybalsky 67 66c Fix subr names to match lispes 00000/00000/00461d D 2.39 89/02/13 16:35:16 sybalsky 66 65c co subr.ces 00000/00000/00461d D 2.38 89/02/13 16:29:18 sybalsky 65 64c Changed subr number constant names to match lisp's set in \initsubrs.es 00000/00000/00461d D 2.37 89/02/13 14:13:57 sybalsky 64 63c es 00004/00000/00457d D 2.36 88/12/08 15:32:32 shimizu 63 62c Add subr for get address offsetes 00010/00000/00447d D 2.35 88/12/07 15:24:57 shimizu 62 61c Add entry for cgfour colores 00004/00000/00443d D 2.34 88/11/09 16:56:33 bane 61 60c ifdefed dynamic native code subrs with NATIVE_CODEes 00001/00001/00442d D 2.33 88/11/08 13:15:19 bane 60 59c Commented out blatantly bogus break; statementes 00002/00001/00441d D 2.32 88/11/07 18:14:27 krivacic 59 58c removed user-subres 00010/00010/00432d D 2.31 88/10/13 15:09:38 krivacic 58 57c use POP_SUBR_ARGS for sb_BITBLTSUB sb_BLTCHAR sb_NEW_BLTCHARes 00009/00016/00433d D 2.30 88/10/13 11:36:21 krivacic 57 56c set arg[0] = NIL_PTR when there are no argses 00004/00005/00445d D 2.29 88/10/12 14:45:08 krivacic 56 55c new out-of-line interfacees 00005/00002/00445d D 2.28 88/10/10 14:43:09 shimizu 55 54c comments? For primary tune of TEDITes 00004/00015/00443d D 2.27 88/10/10 14:10:02 krivacic 54 53c sun3/4 mergees 00002/00002/00456d D 2.26 88/10/07 16:59:20 krivacic 53 52c change NOASM to NATIVETRANes 00008/00002/00450d D 2.25 88/09/15 15:12:52 krivacic 52 51c add user-subr case & add name to new-bltchares 00011/00004/00441d D 2.24 88/08/09 17:04:25 shih 51 50c more polite error message if illegal alpha bytees 00005/00000/00440d D 2.23 88/07/26 14:31:42 shimizu 50 49c Add subr for monitor_control(0200)es 00020/00030/00420d D 2.22 88/07/19 13:59:31 masinter 49 48c remove unused subrs, allow LOGOUT(0) to suspend, add GETENV and GETPARM subrs, return Videocolor valuees 00165/00081/00285d D 2.21 88/06/29 17:27:18 shimizu 48 47c Addes 00004/00001/00362d D 2.20 88/06/24 17:37:45 shimizu 47 46c In the uraid case,increment PC+=3 and returnes 00001/00001/00362d D 2.19 88/06/21 16:04:14 masinter 46 45c pass number of arguments to DSP_cursor so it knows if it got hotspotes 00001/00000/00362d D 2.18 88/06/20 21:59:27 shimizu 45 44c Subr for URAID calls return NIL on TOSes 00004/00000/00358d D 2.17 88/06/17 01:31:11 greep 44 43c added case for suspend-lispes 00001/00001/00357d D 2.16 88/06/16 21:40:17 shih 43 42c changed INTERLISPVMEM to LDEDESTSYSOUTes 00011/00060/00347d D 2.15 88/06/14 15:10:53 greep 42 41c moved check_unix_password to unix-utils.c; add cases for sb_UNIX_USERNAME and sb_UNIX_FULLNAMEes 00014/00001/00393d D 2.14 88/06/13 19:46:48 greep 41 40c use value of environment var INTERLISPVMEM (if defined) as virtual mem filees 00059/00003/00335d D 2.13 88/06/09 11:31:11 masinter 40 39c add subr for checking bcpl password (in subr.c 'til makefile available)es 00003/00001/00335d D 2.12 88/06/08 19:06:59 shimizu 39 38c URAID enable to print error message from LISPes 00017/00023/00319d D 2.11 88/06/08 18:17:31 hayata 38 37c Change subr number of \UFSSetFileInfo and \DSKSetFileInfo.es 00001/00001/00341d D 2.10 88/06/03 21:05:59 mullins 37 36c Made changes to reflect new subrs.h (see sb_UNIX_HANDLECOMM).es 00002/00002/00340d D 2.9 88/06/03 15:34:28 hayata 36 35c return value from vmem_save is set to TopOfStackes 00017/00013/00325d D 2.8 88/06/02 14:23:07 krivacic 35 34c add cases to get emulator addresseses 00003/00001/00335d D 2.7 88/05/31 20:12:31 masinter 34 33c change getnumber call in subrs, subrs can't ufnes 00000/00032/00336d D 2.6 88/05/24 18:46:57 shimizu 33 32c Del entry 0141,0200,0201 for temp stack stuffes 00003/00000/00365d D 2.5 88/04/19 11:38:10 shimizu 32 31c Add check_sumes 00000/00005/00365d D 2.4 88/05/19 13:47:56 atty 31 30c removed subr 122es 00004/00000/00366d D 2.3 88/05/19 13:18:08 hayata 30 29c Add new subr for SETFILEINFOes 00008/00001/00358d D 2.2 88/05/17 16:07:03 atty 29 28c Added subr for fetching host addresses from Unixes 00000/00000/00359d D 2.1 88/05/17 09:26:50 hayata 28 27c Version up to 2.1es 00007/00000/00352d D 1.27 88/05/11 20:08:05 shimizu 27 26c For merging bitbltes 00002/00001/00350d D 1.26 88/05/11 14:59:26 shimizu 26 25c Comment out,STACK stuffes 00003/00001/00348d D 1.25 88/05/11 12:32:08 krivacic 25 24c do_system_calles 00004/00000/00345d D 1.24 88/05/11 12:02:17 hayata 24 23c Add new subr ether_checkp for new ether code.es 00029/00046/00316d D 1.23 88/05/10 19:44:04 krivacic 23 22c new native code subrses 00030/00030/00332d D 1.22 88/05/10 18:23:43 masinter 22 21c name subrses 00007/00000/00355d D 1.21 88/05/10 12:21:35 hayata 21 20c New subrs mess_read and mess_readp for osmessage.es 00002/00001/00353d D 1.20 88/05/09 20:15:37 shimizu 20 19c Add hardreturn calles 00003/00002/00351d D 1.19 88/05/04 18:12:55 masinter 19 18c new timeres 00002/00001/00351d D 1.18 88/05/02 18:39:31 hayata 18 17c Add SCCS key ides 00004/00002/00348d D 1.17 88/05/02 18:36:29 hayata 17 16c Add new subr UFS_getfreeblock for COPYSYS.es 00004/00001/00346d D 1.16 88/04/28 20:30:49 atty 16 15c Added sb_RPC_CALLes 00004/00007/00343d D 1.15 88/04/28 19:39:46 masinter 15 14c subr call with 0 args popped stack; fixedes 00004/00113/00346d D 1.14 88/04/23 22:34:38 masinter 14 13c Fix paren errores 00119/00023/00231d D 1.13 88/03/22 20:49:30 atty 13 12c Added missing parenes 00033/00017/00317d D 1.12 88/04/23 21:24:08 masinter 12 11c Incorporate Krivacic's changeses 00000/00000/00334d D 1.11 88/04/22 11:42:15 masinter 11 10c Make working directory consistent with sccs fileses 00011/00003/00323d D 1.10 88/04/11 18:44:21 krivacic 10 9c Addr68k_from_LADDRes 00002/00002/00324d D 1.9 88/04/11 18:33:37 krivacic 9 8c Addr68K-from-LADDR subres 00003/00000/00323d D 1.8 88/04/11 09:52:41 krivacic 8 7c Subr to get 68K addr from LADDRes 00006/00002/00317d D 1.7 88/04/08 17:17:56 krivacic 7 6c new native calles 00005/00000/00314d D 1.6 88/04/05 11:11:07 jmturn 6 5c Added Unix Interface Subres 00030/00000/00284d D 1.5 88/04/04 11:45:56 hayata 5 4c Add entiries for DSK devicees 00031/00001/00253d D 1.4 88/03/23 18:03:48 shimizu 4 3c Add moveframe entries(temporary)es 00016/00001/00238d D 1.3 88/03/17 18:10:53 krivacic 3 2c Hi Res Display Hacks es 00002/00002/00237d D 1.2 88/03/13 15:07:21 hayata 2 1c Add SCCS key id (%Z%)es 00239/00000/00000d D 1.1 88/02/24 16:58:34 hayata 1 0c date and time created 88/02/24 16:58:34 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 9D 13/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 13I 13D 14/* This is G-file %Z% %M% xsubr.c Version %I% (%G%). (c) Copyright 1988 Xerox Corporation & Fuji Xerox Company, Ltd.  */E 13E 9I 9D 12/* This is G-file @(#) subr.c Version 1.8 (4/11/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) subr.c	1.8 4/11/88";E 12I 12/* This is G-file %Z% %M% xsubr.c Version %I% (%G%). (c) Copyright 1988 Xerox Corporation & Fuji Xerox Company, Ltd.  */E 14I 14D 16/* This is G-file %Z% %M% subr.c Version %I% (%G%). (c) Copyright 1988 Xerox Corporation & Fuji Xerox Company, Ltd.  */E 16I 16D 18/* This is G-file @(#) subr.c subr.c Version 1.15 (4/28/88). (c) Copyright 1988 Xerox Corporation & Fuji Xerox Company, Ltd.  */E 18I 18D 58/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 58I 58D 71/* This is G-file @(#) subr.c Version 2.30 (10/13/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) subr.c	2.30 10/13/88";E 71I 71D 74/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 74I 74D 76/* @(#) subr.c Version 2.45 (2/28/89). copyright envos & Fuji Xerox  */static char *id = "@(#) subr.c	2.45 2/28/89		(envos & Fuji Xerox)";E 76I 76D 83/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 83I 83/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 83E 76E 74E 71E 58E 18E 16E 14E 12E 9E 2D 84/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 12D 13 *	Auther :  Takeshi ShimizuE 13I 13 *	Author :  Takeshi ShimizuE 13E 12I 12D 14 *	Author :  Takeshi ShimizuE 14E 12 * */E 84I 83D 91E 91D 84E 84/************************************************************************//*									*/D 91/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 91I 91/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 91/*									*/D 91/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 91I 91/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 91/*									*//************************************************************************/E 83/***********************************************************//*		File Name :	subr.c		Including	:	OP_subrcall		Created	:	May 12, 1987 Takeshi Shimizu		Changed :	May 15 87 take		Changed :	Jun 2 87 NMitani				Jun. 5 87 take				Jun. 29 87 NMitani				Oct. 13 87 Hayata				Oct. 16 87 take				Nov. 18 87 Matsuda				Dec. 17 1987 TomtomI 70				2/17/89 Sybalsky (Add SXHASH)E 70*//***********************************************************/ I 79#include <stdio.h>E 79#include "lispemul.h"#include "address.h"D 90#include "address68k.h"#include "lisptypes.h"E 90I 90#include "adr68k.h"#include "lsptypes.h"E 90#include "lispmap.h"D 90#include "emulglobal.h"#include "lispglobal.h"E 90I 90#include "emlglob.h"#include "lspglob.h"E 90#include "cell.h"#include "stack.h"I 3#include "arith.h"E 3D 15 E 15I 15#include "subrs.h"I 54#include "profile.h"I 79#include "dbprint.h"I 86extern LispPTR *PENDINGINTERRUPT68k;E 86E 79E 54E 15/***********************************************************//*	Func Name  :	OP_subrcall	Last Modify :	13-Oct 1987 take*//***********************************************************/I 49D 53#ifndef NOASME 53I 53#ifdef NATIVETRANE 53E 49I 35extern int *c_ret_to_dispatch;extern int *ret_to_dispatch;I 49#endifE 49I 39extern  LispPTR Uraid_mess;E 39E 35D 35E 35LispPTR subr_lisperror(); /* 0377 */char *atom_to_str(atom_index)	LispPTR atom_index;{	PNCell *pnptr;	char *pname_base;	pnptr = (PNCell *) GetPnameCell(atom_index);	pname_base = (char *) Addr68k_from_LADDR(pnptr->pnamebase);	return(pname_base+1);} /*atom_to_str*/I 48D 57#define POP_SUBR_ARGS {if (( arg_num = (argnum = (Get_BYTE(PC+2)))) > 0) \     { while(arg_num >0) \	 PopStackTo(args[--arg_num]); \     }}E 57I 57#define POP_SUBR_ARGS 							\{	args[0] = NIL_PTR;						\D 93	if (( arg_num = (argnum = (Get_BYTE(PC+2)))) > 0)  {		\E 93I 93	if (( arg_num = (argnum/* = (Get_BYTE(PC+2))*/)) > 0)  {		\E 93		 while(arg_num >0) 					\			 PopStackTo(args[--arg_num]); 			\		}							\}E 57E 48D 48E 48D 93OP_subrcall()E 93I 93OP_subrcall(subr_no, argnum)  int subr_no, argnum;E 93{  static LispPTR args[30];D 12D 13  int  arg_num ;E 13I 13D 93  int  arg_num, argnum;E 93I 93  int  arg_num;E 93E 13E 12I 12D 14  int  arg_num, argnum;E 14E 12  int i;D 57#ifdef TRACE  printf("TRACE: OP_subrcall() \n");#endifD 15 /* Get (Arg Number-1) from beta byte */D 12D 13 if (( arg_num = ((*(PC+2)) & 0xff) -1 ) >= 0)E 12I 12 if (( arg_num = (argnum = (Get_BYTE(PC+2)) -1 ) >= 0)E 12 {    /* Save Last Argument */      args[arg_num]= TopOfStack ;	while(arg_num >0)	  PopStackTo(args[--arg_num]) ;D 12/*      for(i=arg_num -1 ; i > 0 ; i--) 		PopStackTo(args[i]);  5-jun*/E 12   }D 12switch((*(PC+1)) & 0xff)E 13I 13D 14 if (( arg_num = (argnum = (Get_BYTE(PC+2)) -1 ) >= 0))E 14I 14 if (( arg_num = (argnum = (Get_BYTE(PC+2))) -1 ) >= 0)E 15I 15  PushCStack; /* save TOS in memory */I 48/***E 48 if (( arg_num = (argnum = (Get_BYTE(PC+2)))) > 0)E 15E 14     {D 15       /* Save Last Argument */       args[arg_num]= TopOfStack ;E 15       while(arg_num >0)	 PopStackTo(args[--arg_num]);            }D 48     E 48I 48 ***/    E 57I 57PushCStack; /* save TOS in memory */E 57I 79D 93DBPRINT(("Subr call to subr 0%o.\n", Get_BYTE(PC+1)));E 93I 93DBPRINT(("Subr call to subr 0%o.\n", subr_no));E 93E 79E 48D 93switch(Get_BYTE(PC+1))E 93I 93switch(subr_no)E 93E 13E 12I 12D 14switch(Get_BYTE(PC+1))E 14E 12  {D 15	case 023  :E 15I 15D 48	case sb_SHOWDISPLAY  :E 48I 48	case sb_SHOWDISPLAY  :POP_SUBR_ARGS;E 48E 15			DSP_showdisplay(args);			break;/* showdisplay */D 22	case 011  :	DSP_dspbout( args );E 22I 22D 48	case sb_DSPBOUT  :	DSP_dspbout( args );E 48I 48	case sb_DSPBOUT  :	POP_SUBR_ARGS;			DSP_dspbout( args );E 48E 22			break; /*dspbout */D 36	/* for Local File System */E 36D 22	case  017 :	error("RAID::::::\n");E 22I 22D 39	case  sb_RAID :	error("RAID::::::\n");E 39I 39D 47	case  sb_RAID :	Uraid_mess= args[0];error("URAID Called:");E 47I 47D 48	case  sb_RAID :	Uraid_mess= args[0];E 48I 48	case  sb_RAID :	POP_SUBR_ARGS;			Uraid_mess= args[0];E 48			PC+= 3; /* for the case of hardreset */			error("URAID Called:");E 47			Uraid_mess=NIL;I 45			TopOfStack =NIL;I 47			return; /* Direct return;avoid to increment PC */E 47E 45E 39E 22D 60			break;E 60I 60		     /* break; */I 84	/*************************/E 84E 60I 36	/* for Local File System */I 84	/*************************/E 84E 36D 22	case  040 :	TopOfStack = UFS_openfile(args);E 22I 22D 48	case  sb_UFS_OPENFILE :	TopOfStack = UFS_openfile(args);E 48I 48D 77	case  sb_UFS_OPENFILE :	POP_SUBR_ARGS;			TopOfStack = UFS_openfile(args);E 77I 77	case  sb_COM_OPENFILE :	POP_SUBR_ARGS;			TopOfStack = COM_openfile(args);E 77E 48E 22			break;D 22	case  041 :	TopOfStack = UFS_closefile(args);E 22I 22D 48	case  sb_UFS_CLOSEFILE :	TopOfStack = UFS_closefile(args);E 48I 48D 77	case  sb_UFS_CLOSEFILE :	POP_SUBR_ARGS;			TopOfStack = UFS_closefile(args);E 77I 77	case  sb_COM_CLOSEFILE :	POP_SUBR_ARGS;			TopOfStack = COM_closefile(args);E 77E 48E 22			break;D 22	case  042 :	TopOfStack = UFS_getfilename(args);E 22I 22D 48	case  sb_UFS_GETFILENAME :	TopOfStack = UFS_getfilename(args);E 48I 48	case  sb_UFS_GETFILENAME :	POP_SUBR_ARGS;			TopOfStack = UFS_getfilename(args);E 48E 22			break;D 22	case  043 :	TopOfStack = UFS_deletefile(args);E 22I 22D 48	case  sb_UFS_DELETEFILE :	TopOfStack = UFS_deletefile(args);E 48I 48	case  sb_UFS_DELETEFILE :	POP_SUBR_ARGS;			TopOfStack = UFS_deletefile(args);E 48E 22			break;D 22	case  044 :	TopOfStack = UFS_renamefile(args);E 22I 22D 48	case  sb_UFS_RENAMEFILE :	TopOfStack = UFS_renamefile(args);E 48I 48	case  sb_UFS_RENAMEFILE :	POP_SUBR_ARGS;			TopOfStack = UFS_renamefile(args);E 48E 22			break;D 22	case  045 :	TopOfStack = UFS_readpage(args);E 22I 22D 48	case  sb_UFS_READPAGES :	TopOfStack = UFS_readpage(args);E 48I 48D 77	case  sb_UFS_READPAGES :	POP_SUBR_ARGS;			TopOfStack = UFS_readpage(args);E 77I 77	case  sb_COM_READPAGES :	POP_SUBR_ARGS;			TopOfStack = COM_readpage(args);E 77E 48E 22			break;D 22	case  046 :	TopOfStack = UFS_writepage(args);E 22I 22D 48	case  sb_UFS_WRITEPAGES :	TopOfStack = UFS_writepage(args);E 48I 48D 77	case  sb_UFS_WRITEPAGES :	POP_SUBR_ARGS;			TopOfStack = UFS_writepage(args);E 77I 77	case  sb_COM_WRITEPAGES :	POP_SUBR_ARGS;			TopOfStack = COM_writepage(args);E 77E 48E 22			break;D 22	case  047 :	TopOfStack = UFS_getsize(args);E 22I 22D 48	case  sb_UFS_GETSIZE :	TopOfStack = UFS_getsize(args);E 48I 48D 77	case  sb_UFS_GETSIZE :	POP_SUBR_ARGS;			TopOfStack = UFS_getsize(args);E 77I 77	case  sb_COM_TRUNCATEFILE :	POP_SUBR_ARGS;			TopOfStack = COM_truncatefile(args);E 77E 48E 22			break;I 79	case  sb_COM_NEXT_FILE :	POP_SUBR_ARGS;			TopOfStack = COM_next_file(args);			break;	case  sb_COM_FINISH_FINFO :	POP_SUBR_ARGS;			TopOfStack = COM_finish_finfo(args);			break;E 79D 22	case  050 :	TopOfStack = UFS_readdir(args);E 22I 22D 48	case  sb_UFS_READDIR :	TopOfStack = UFS_readdir(args);E 48I 48D 77	case  sb_UFS_READDIR :	POP_SUBR_ARGS;			TopOfStack = UFS_readdir(args);E 77I 77	case  sb_COM_GEN_FILES :	POP_SUBR_ARGS;			TopOfStack = COM_gen_files(args);E 77E 48E 22			break;D 22	case  051 :	TopOfStack = UFS_directorynamep(args);E 22I 22D 48	case  sb_UFS_DIRECTORYNAMEP :	TopOfStack = UFS_directorynamep(args);E 48I 48	case  sb_UFS_DIRECTORYNAMEP :	POP_SUBR_ARGS;			TopOfStack = UFS_directorynamep(args);E 48E 22			break;D 22	case  052 :	TopOfStack = UFS_getfileinfo(args);E 22I 22D 48	case  sb_UFS_GETFILEINFO :	TopOfStack = UFS_getfileinfo(args);E 48I 48D 77	case  sb_UFS_GETFILEINFO :	POP_SUBR_ARGS;			TopOfStack = UFS_getfileinfo(args);E 77I 77	case  sb_COM_GETFILEINFO :	POP_SUBR_ARGS;			TopOfStack = COM_getfileinfo(args);E 77E 48E 22D 79			break;D 22	case  053 :	TopOfStack = UFS_dirsize(args);E 22I 22D 48	case  sb_UFS_DIRSIZE :	TopOfStack = UFS_dirsize(args);E 48I 48D 77	case  sb_UFS_DIRSIZE :	POP_SUBR_ARGS;			TopOfStack = UFS_dirsize(args);E 77I 77	case  sb_COM_BUF_SIZE :		POP_SUBR_ARGS;			TopOfStack = COM_bufsize(args);E 79E 77E 48E 22			break;D 17	case  054 :	TopOfStack = UFS_currentdir(args);E 17I 17D 22	case  054 :	TopOfStack = UFS_changedir(args);E 22I 22D 38	case  sb_UFS_CURRENTDIR :	TopOfStack = UFS_changedir(args);E 38I 38D 48	case  sb_UFS_CHANGEDIR :	TopOfStack = UFS_changedir(args);E 48I 48D 77	case  sb_UFS_CHANGEDIR :	POP_SUBR_ARGS;			TopOfStack = UFS_changedir(args);E 77I 77	case  sb_COM_CHANGEDIR :	POP_SUBR_ARGS;			TopOfStack = COM_changedir(args);E 77E 48E 38E 22E 17			break;I 17D 22	case  055:	TopOfStack = UFS_getfreeblock(args);E 22I 22D 38	case  sb_UFS_SETFILEINFO:	TopOfStack = UFS_getfreeblock(args);E 38I 38D 48	case  sb_UFS_GETFREEBLOCK:	TopOfStack = UFS_getfreeblock(args);E 48I 48D 77	case  sb_UFS_GETFREEBLOCK:	POP_SUBR_ARGS;			TopOfStack = UFS_getfreeblock(args);E 77I 77	case  sb_COM_GETFREEBLOCK:	POP_SUBR_ARGS;			TopOfStack = COM_getfreeblock(args);E 77E 48E 38E 22			break;I 38D 48	case  sb_UFS_SETFILEINFO:	TopOfStack = UFS_setfileinfo(args);E 48I 48D 77	case  sb_UFS_SETFILEINFO:	POP_SUBR_ARGS;			TopOfStack = UFS_setfileinfo(args);E 77I 77	case  sb_COM_SETFILEINFO:	POP_SUBR_ARGS;			TopOfStack = COM_setfileinfo(args);E 77E 48			break;I 84	/*************/E 84E 38E 17	/* for Timer */I 84	/*************/E 84D 19	case  060 :	subr_settime(args);E 19I 19D 22	case  060 :	TopOfStack = subr_settime(args);E 22I 22D 48	case  sb_SETUNIXTIME :	TopOfStack = subr_settime(args);E 48I 48	case  sb_SETUNIXTIME :	POP_SUBR_ARGS;			TopOfStack = subr_settime(args);E 48E 22E 19			break;D 19	case  061 :	subr_gettime(args);E 19I 19D 22	case  061 :	TopOfStack = subr_gettime(args);E 22I 22D 48	case  sb_GETUNIXTIME :	TopOfStack = subr_gettime(args);E 48I 48	case  sb_GETUNIXTIME :	POP_SUBR_ARGS;			TopOfStack = subr_gettime(args);E 48E 22E 19			break;I 19D 48	case 062 :	TopOfStack = subr_copytimestats(args);E 48I 48D 67	case 062 :	POP_SUBR_ARGS;E 67I 67	case sb_COPYTIMESTATS :	POP_SUBR_ARGS;E 67			TopOfStack = subr_copytimestats(args);E 48I 24			break;I 84	/*************/E 84E 24E 19	/* for Ether */I 84	/*************/E 84I 81D 83#ifdef NOETHERE 83E 81I 32D 48	case sb_CHECK_SUM : TopOfStack = check_sum(args);E 48I 48	case sb_CHECK_SUM :POP_SUBR_ARGS;I 81D 83			break;	case  sb_ETHER_SUSPEND :	POP_SUBR_ARGS;			break;	case  sb_ETHER_RESUME :	POP_SUBR_ARGS;			break;	case  sb_ETHER_AVAILABLE :	POP_SUBR_ARGS;			break;	case  sb_ETHER_RESET : POP_SUBR_ARGS;			break;	case  sb_ETHER_GET : POP_SUBR_ARGS;			break;	case  sb_ETHER_SEND : POP_SUBR_ARGS;			break;	case  sb_ETHER_SETFILTER : POP_SUBR_ARGS;			break;	case  sb_ETHER_CHECK: POP_SUBR_ARGS;			break;#else	case sb_CHECK_SUM :POP_SUBR_ARGS;E 83E 81			 TopOfStack = check_sum(args);E 48			break;E 32D 22	case  070 :	TopOfStack = ether_suspend(args);E 22I 22D 48	case  sb_ETHER_SUSPEND :	TopOfStack = ether_suspend(args);E 48I 48	case  sb_ETHER_SUSPEND :	POP_SUBR_ARGS;			TopOfStack = ether_suspend(args);E 48E 22			break;D 22	case  071 :	TopOfStack = ether_resume(args);E 22I 22D 48	case  sb_ETHER_RESUME :	TopOfStack = ether_resume(args);E 48I 48	case  sb_ETHER_RESUME :	POP_SUBR_ARGS;			TopOfStack = ether_resume(args);E 48E 22			break;D 48	case  072 :	TopOfStack = ether_ctrlr(args);E 48I 48D 67	case  072 :	POP_SUBR_ARGS;E 67I 67	case  sb_ETHER_AVAILABLE :	POP_SUBR_ARGS;E 67			TopOfStack = ether_ctrlr(args);E 48			break;D 22	case  073 :	TopOfStack = ether_reset(args);E 22I 22D 48	case  sb_ETHER_RESET :	TopOfStack = ether_reset(args);E 48I 48	case  sb_ETHER_RESET : POP_SUBR_ARGS;				TopOfStack = ether_reset(args);E 48E 22			break;D 22	case  074 :	TopOfStack = ether_get(args);E 22I 22D 48	case  sb_ETHER_GET :	TopOfStack = ether_get(args);E 48I 48	case  sb_ETHER_GET : POP_SUBR_ARGS;				TopOfStack = ether_get(args);E 48E 22			break;D 22	case  075 :	TopOfStack = ether_send(args);E 22I 22D 48	case  sb_ETHER_SEND :	TopOfStack = ether_send(args);E 48I 48	case  sb_ETHER_SEND : POP_SUBR_ARGS;				TopOfStack = ether_send(args);E 48E 22			break;D 22	case  076 :	TopOfStack = ether_setfilter(args);E 22I 22D 48	case  sb_ETHER_SETFILTER :	TopOfStack = ether_setfilter(args);E 48I 48	case  sb_ETHER_SETFILTER : POP_SUBR_ARGS;				TopOfStack = ether_setfilter(args);E 48E 22			break;I 24D 48	case  077:	TopOfStack = check_ether();E 48I 48D 67	case  077: POP_SUBR_ARGS;E 67I 67	case  sb_ETHER_CHECK: POP_SUBR_ARGS;E 67				TopOfStack = check_ether();E 48			break;D 81E 81I 81D 83#endif NOETHERE 83E 81E 24I 84	/***************/E 84	/* for Display */I 84	/***************/E 84D 22	case 0100 :	DSP_Cursor(args);E 22I 22D 46	case sb_DSPCURSOR :	DSP_Cursor(args);E 46I 46D 48	case sb_DSPCURSOR :	DSP_Cursor(args, argnum);E 48I 48	case sb_DSPCURSOR : POP_SUBR_ARGS;				DSP_Cursor(args, argnum);E 48E 46E 22			break;D 22	case 0101 :	DSP_SetMousePos(args);E 22I 22D 48	case sb_SETMOUSEXY :	DSP_SetMousePos(args);E 48I 48	case sb_SETMOUSEXY : POP_SUBR_ARGS;				DSP_SetMousePos(args);E 48E 22			break;D 22	case 0102 :	DSP_VideoColor(args);E 22I 22D 48	case sb_DSP_VIDEOCOLOR :	DSP_VideoColor(args);E 48I 48	case sb_DSP_VIDEOCOLOR : POP_SUBR_ARGS;D 49				DSP_VideoColor(args);E 49I 49				TopOfStack = DSP_VideoColor(args);E 49E 48E 22			break;D 14/*** MERGED AT AIS ***/E 14D 22	case 0103 :	TopOfStack = DSP_ScreenWidth(args);E 22I 22D 48	case sb_DSP_SCREENWIDTH :	TopOfStack = DSP_ScreenWidth(args);E 48I 48	case sb_DSP_SCREENWIDTH : POP_SUBR_ARGS;				TopOfStack = DSP_ScreenWidth(args);E 48E 22			break;D 22	case 0104 :	TopOfStack = DSP_ScreenHight(args);E 22I 22D 48	case sb_DSP_SCREENHEIGHT :	TopOfStack = DSP_ScreenHight(args);E 48I 48	case sb_DSP_SCREENHEIGHT : POP_SUBR_ARGS;				TopOfStack = DSP_ScreenHight(args);E 48E 22			break;  I 62D 84	/***** for color experiments */E 84I 84	/*************************/	/* for color experiments */	/*************************/E 84D 67	case 0210 : POP_SUBR_ARGS;E 67I 67	case sb_COLOR_INIT : POP_SUBR_ARGS;E 67			TopOfStack=cgfour_init_color_display(args[0]);			break;D 67	case 0211 : POP_SUBR_ARGS;E 67I 67	case sb_COLOR_SCREENMODE : POP_SUBR_ARGS;E 67			TopOfStack=cgfour_change_screen_mode(args[0]);			break;D 67	case 0212 : POP_SUBR_ARGS;E 67I 67	case sb_COLOR_MAP : POP_SUBR_ARGS;E 67			TopOfStack=cgfour_set_colormap(args);			break;I 63D 67	case 0213 : POP_SUBR_ARGS;E 67I 67	case sb_COLOR_BASE : POP_SUBR_ARGS;E 67			/* retun DLword offsetbetween LISPBASE and Lisp_world */			TopOfStack=S_POSITIVE |(((int)Lisp_world >> 1) & 0xffff);			break;I 76#ifdef COLOR	case sb_C_SlowBltChar : POP_SUBR_ARGS;			/* \\SLOWBLTCHAR for 8BITCOLOR */			C_slowbltchar(args);			break;I 82	case 0215 : POP_SUBR_ARGS; 			Uncolorize_Bitmap(args);			break;	case 0216 : POP_SUBR_ARGS; 			Colorize_Bitmap(args);			break;I 84        case 0217 : POP_SUBR_ARGS;                        Draw_8BppColorLine(args);                        break;E 84E 82D 94#endif COLORE 94I 94#endif /* COLOR */E 94E 76E 63E 62I 27I 94E 94I 84	/***************************/E 84	/***  bitbltsub, bltchar ***/I 84	/***************************/E 84D 48	case 0105 :	bitbltsub(args);E 48I 48D 55	case sb_BITBLTSUB : POP_SUBR_ARGS;			bitbltsub(args);E 55I 55D 58	case sb_BITBLTSUB : CurrentStackPTR -= 26;			bitbltsub(CurrentStackPTR+2);E 58I 58	case sb_BITBLTSUB : POP_SUBR_ARGS;			bitbltsub(args);E 58E 55E 48			break;D 48	case 0106 :	bltchar(args);E 48I 48D 58	case sb_BLTCHAR : CurrentStackPTR -= 12; /* argnum * DLwordsperCell*/			bltchar(CurrentStackPTR+2);E 58I 58	case sb_BLTCHAR : POP_SUBR_ARGS; /* argnum * DLwordsperCell*/D 74			bltchar(args);E 74I 74			bltchar(args);	E 74E 58E 48			break;	 D 48E 48I 48D 52	case 0207 :  CurrentStackPTR -= 6;E 52I 52D 58	case sb_NEW_BLTCHAR :  CurrentStackPTR -= 6;E 52			newbltchar(CurrentStackPTR+2);E 58I 58	case sb_NEW_BLTCHAR :  POP_SUBR_ARGS;			newbltchar(args);E 58I 55			break;D 58	case 0107 /* sb_TEDITBLTCHAR */ : CurrentStackPTR -= 12;			tedit_bltchar(CurrentStackPTR+2);E 58I 58D 67	case 0107 /* sb_TEDITBLTCHAR */ : POP_SUBR_ARGS;E 67I 67D 74	case sb_TEDIT_BLTCHAR /* sb_TEDITBLTCHAR */ : POP_SUBR_ARGS;E 74I 74	case sb_TEDIT_BLTCHAR  : POP_SUBR_ARGS;E 74E 67			tedit_bltchar(args);E 58E 55			break;I 74D 86	case 209:E 86I 86/*	case 209: JDS 4 may 91 - this is code for CHAR-FILLBUFFER?? */E 86	case sb_BITBLT_BITMAP: POP_SUBR_ARGS;  /* BITBLT to a bitmap */		  {		    TopOfStack = bitblt_bitmap(args);		    break;		  }		break;	case  0111/*sb_BITSHADE_BITMAP*/: POP_SUBR_ARGS;  /* BITSHADE to a bitmap */		  {		    TopOfStack = bitshade_bitmap(args);		    break;		  }		break;E 74E 48E 27D 14/*** END ***/	 E 14D 49	/* for RS232C */D 48	case 0110 :	RS232C_cmd();E 48I 48	case 0110 : POP_SUBR_ARGS;				RS232C_cmd();E 48			break;D 48	case 0111 :	RS232C_readinit();E 48I 48	case 0111 : POP_SUBR_ARGS;				RS232C_readinit();E 48			break;D 48	case 0112 :	RS232C_writeinit();E 48I 48	case 0112 : POP_SUBR_ARGS;				RS232C_writeinit();E 48			break;D 48	case 0113 :	RS232C_readcont();E 48I 48	case 0113 : POP_SUBR_ARGS;				RS232C_readcont();E 48			break;D 48	case 0114 :	RS232C_writecont();E 48I 48	case 0114 : POP_SUBR_ARGS;				RS232C_writecont();E 48			break;E 49I 88	/**************/        /* For RS232C */	/**************/#ifdef RS232	case sb_RS232C_CMD:		RS232C_cmd(); 		break;	case sb_RS232C_READ_INIT:	RS232C_readinit(); 	break;	case sb_RS232C_WRITE:		RS232C_write(); 	break;D 94#endif RS232E 94I 94#endif /* RS232 */E 94I 94E 94E 88D 49	/* for TTY */D 48	case 0115 :	TTY_cmd();E 48I 48	case 0115 : POP_SUBR_ARGS;				TTY_cmd();E 48			break;D 48	case 0116 : 	TTY_get();E 48I 48	case 0116 : POP_SUBR_ARGS;			 	TTY_get();E 48			break;E 49D 84I 74E 84I 84	/***********/E 84E 74	/* for K/B */I 84	/***********/E 84D 48	case 0120 :	KB_beep(args);E 48I 48D 67	case 0120 : POP_SUBR_ARGS;E 67I 67	case sb_KEYBOARDBEEP : POP_SUBR_ARGS;E 67				KB_beep(args);E 48			break;D 48	case 0121 :	KB_setmp(args);E 48I 48D 67	case 0121 : POP_SUBR_ARGS;E 67I 67	case sb_KEYBOARDMAP : POP_SUBR_ARGS;E 67				KB_setmp(args);E 48			break;D 22	case 0122 :	KB_enable(args);E 22I 22D 48	case sb_KEYBOARDSTATE :	KB_enable(args);E 48I 48	case sb_KEYBOARDSTATE : POP_SUBR_ARGS;				KB_enable(args);E 48E 22			break;D 48	case 0130 :	TopOfStack = subr_k_trace(args);E 48I 48D 49	case 0130 : POP_SUBR_ARGS;				TopOfStack = subr_k_trace(args);E 48			break ;D 12D 13	case 0131 :	vmem_save("/usr/aig/lispg/lisp/init.sun");E 13I 13D 36	case 0131 :	vmem_save("~/lisp.virtualmem");E 36I 36D 41	case 0131 :	TopOfStack = vmem_save("~/lisp.virtualmem");E 41I 41D 48	case 0131 :E 48I 48	case 0131 : POP_SUBR_ARGS;E 49I 49	case sb_VMEMSAVE:  POP_SUBR_ARGS;E 49D 54			E 48			{			  /* Use value of environment variable if defined */			  char *getenv();			  char *def;			  TopOfStack =			    /* Officially should test against NULL, not 0,			       but NULL is defined in stdio.h which we			       otherwise don't need.  (It really should			       be defined somewhere else since a number			       of non-stdio routines use it.) */D 43			    vmem_save((def = getenv("INTERLISPVMEM")) == 0 ?E 43I 43			    vmem_save((def = getenv("LDEDESTSYSOUT")) == 0 ?E 43			  		"~/lisp.virtualmem" : def);			}E 41E 36E 13E 12I 12D 14	case 0131 :	vmem_save("~/lisp.virtualmem");E 14E 12			/* temp file name */E 54I 54			   TopOfStack = vmem_save0(args);E 54			break;D 48	case 0132 :	lisp_finish();E 48I 48D 49	case 0132 : POP_SUBR_ARGS;				lisp_finish();E 49I 49	case sb_LISPFINISH:	case sb_LISP_FINISH : POP_SUBR_ARGS;D 51		if((argnum>0)&&(args[0]==S_POSITIVE)) E 51I 51		if((argnum>0)&&(args[0]==S_POSITIVE))		/* 8/03/88 This branch impossible to take, subr has no args */E 51			{TopOfStack=suspend_lisp(args);}		else	lisp_finish();E 49E 48			break;D 48	case 0133 :	TopOfStack = newpage(args[0]);E 48I 48D 67	case 0133 : POP_SUBR_ARGS;E 67I 67	case sb_NEWPAGE : POP_SUBR_ARGS;E 67				TopOfStack = newpage(args[0]);E 48			break;D 48	case 0134 :     dogc01();       /* This function is caller of main3. */E 48I 48D 56	case 0134 : POP_SUBR_ARGS;			     dogc01();       /* This function is caller of main3. */E 56I 56	case sb_DORECLAIM : POP_SUBR_ARGS;			doreclaim();       /* top-level GC function */			TopOfStack = NIL_PTR;E 56E 48			break;D 48	case 0135 :     doreclaim();    /* This function is top-level on GC. */E 48I 48D 56	case 0135 : POP_SUBR_ARGS;			     doreclaim();    /* This function is top-level on GC. */E 48			break;E 56D 10D 13	case 0136 :	clr_native_bit(args[0]);E 13I 13D 23	case 0136 :	switch (args[0] & 0xffff) {E 23I 23			/* read & write a abs memory address */D 48	case sb_NATIVE_MEMORY_REFERENCE :	E 48I 48	case sb_NATIVE_MEMORY_REFERENCE : POP_SUBR_ARGS;				E 48			switch (args[0] & 0xffff) {E 23			case 00: 				{register int iarg;D 23				if (argnum != 2) goto badarg2;				N_GETNUMBER(args[1], iarg, badarg1);E 23I 23				if (argnum != 2) goto ret_nil;				N_GETNUMBER(args[1], iarg, ret_nil);E 23				ARITH_SWITCH(*((LispPTR *) iarg), TopOfStack);				break;				}						case 01: 				{register int iarg,iarg2;D 23				if (argnum != 3) goto badarg2;				N_GETNUMBER(args[1], iarg, badarg1);				N_GETNUMBER(args[2], iarg2, badarg1);E 23I 23				if (argnum != 3) goto ret_nil;				N_GETNUMBER(args[1], iarg, ret_nil);				N_GETNUMBER(args[2], iarg2, ret_nil);E 23				*((LispPTR *) iarg) = iarg2;				break;				}I 35I 49D 53#ifndef NOASME 53I 53#ifdef NATIVETRANE 53E 49			case 02: 	/* get an emulator address */				{register int iarg;				if (argnum != 2) goto ret_nil;				switch (args[1] & 0xffff) {				case 00: iarg = (int) &c_ret_to_dispatch;					 break;				case 01: iarg = (int) &ret_to_dispatch;					 break;				}				ARITH_SWITCH(iarg, TopOfStack);				break;				}I 49#endifE 49E 35			}E 13E 10I 10D 12	case 0136 :	switch (args[0] && 0xffff) {			case 00: clr_native_bit(args[1]); break;			case 01: set_native_bit(args[1]& 0xffff); break;E 12I 12D 14	case 0136 :	switch (args[0] & 0xffff) {			case 00: 				{register int iarg;				if (argnum != 2) goto badarg2;				N_GETNUMBER(args[1], iarg, badarg1);				ARITH_SWITCH(*((LispPTR *) iarg), TopOfStack);				break;				}						case 01: 				{register int iarg,iarg2;				if (argnum != 3) goto badarg2;				N_GETNUMBER(args[1], iarg, badarg1);				N_GETNUMBER(args[2], iarg2, badarg1);				*((LispPTR *) iarg) = iarg2;				break;				}E 12			}E 14E 10			break;I 12D 14	badarg1:	 printf("Bad argument to get-native-code\n");			 TopOfStack = NIL_PTR;			 break;	badarg2:	 printf("Bad # args to get-native-code\n");			 TopOfStack = NIL_PTR;			 break;E 14E 12I 10E 10D 12D 13	case 0137 :	{char fn_name[50];E 13I 13D 23	badarg1:	 printf("Bad argument to get-native-code\n");			 TopOfStack = NIL_PTR;			 break;	badarg2:	 printf("Bad # args to get-native-code\n");			 TopOfStack = NIL_PTR;			 break;E 23I 23	ret_nil: 	TopOfStack = NIL_PTR;			break;E 23D 23	case 0137 :	{E 23I 23I 61#ifdef NATIVETRANE 61			/* old load native (should be superceeded) */D 48	case sb_OLD_COMPILE_LOAD_NATIVE :	{E 48I 48	case sb_OLD_COMPILE_LOAD_NATIVE : POP_SUBR_ARGS;				{E 48E 23D 25			char fn_name[50];E 25I 25D 35/*			char fn_name[50];E 25E 13E 12I 12D 14	case 0137 :	{			char fn_name[50];E 14E 12			 int i;			 char *fn = atom_to_str(args[1]);			for (i = 0; i < (args[2] & 0xffff); i++)				fn_name[i] = *fn++;			fn_name[args[2] & 0xffff] = (char) 0;			printf("Compile Native & Load  Name:%s:\n",fn_name );			D 7D 13			Native_Hash[((int) args[0]) & 0xffff] = (CFuncPTR)				dynamic_load("lisp8M", fn_name, 0, 1, 1, 1);E 7I 7			i = dynamic_load("lisp8M", fn_name, 0, 1, 1, 1);D 12			Native_Hash[(int)args[0] & 0xffff] = 				(CFuncPTR)asmcall(i);E 7			set_native_bit(args[0]& 0xffff);E 13I 13			i = dynamic_load("lisp8M", fn_name, 0, 1, 1, 1);			printf("back to subr, tos: 0x%x\n",TopOfStack);I 25*/E 35I 35E 35			TopOfStack = do_system_call(args[0]);E 25E 13E 12I 12D 14			printf("back to subr, tos: 0x%x\n",TopOfStack);E 14E 12			break;			};I 61#endifI 80	case sb_DISABLEGC : POP_SUBR_ARGS;	  		disablegc1(NIL);			TopOfStack = NIL_PTR;			break;E 80E 61I 14E 14D 3E 3I 3D 4D 13	case 0138 :	{int iarg;E 13I 13D 23	case 0140 :	{register int iarg;E 13E 4I 4D 12	case 0140 :	{int iarg;E 12I 12D 14	case 0140 :	{register int iarg;E 14E 12E 4			 N_GETNUMBER(args[1], iarg, badarg);			 printf("Re-Configure Display @ 0x%x for 0x%x\n",				args[0], iarg);		 	 device_before_exit();			 init_display(args[0], iarg);			 printf("Display Re-Configured\n");			 set_cursor();			 init_keyboard();			 args[0] = ATOM_T;			 KB_enable(args);E 23I 23D 48	case sb_GET_NATIVE_ADDR_FROM_LISP_PTR:E 48I 48	case sb_GET_NATIVE_ADDR_FROM_LISP_PTR: POP_SUBR_ARGS;			E 48			{ARITH_SWITCH(Addr68k_from_LADDR(args[0]), TopOfStack);E 23			 break;D 23	badarg:		 printf("Bad argument to Display Re-Configure\n");E 23I 23			}D 48	case sb_GET_LISP_PTR_FROM_NATIVE_ADDR:E 48I 48	case sb_GET_LISP_PTR_FROM_NATIVE_ADDR: POP_SUBR_ARGS;			E 48			{register int iarg;			 N_GETNUMBER(args[0], iarg, ret_nil);			 ARITH_SWITCH(LADDR_from_68k(iarg), TopOfStack);E 23			 break;			};I 23I 61#ifdef NATIVETRANE 61D 35	case sb_LOAD_NATIVE_FILE:E 35I 35D 48	case sb_LOAD_NATIVE_FILE: /* to become OBSOLETE */E 48I 48	case sb_LOAD_NATIVE_FILE: POP_SUBR_ARGS;			 /* to become OBSOLETE */E 48E 35			{TopOfStack = dynamic_load_code(args);		 	 break;			}I 61#endifE 61D 77E 23I 13D 26/**** temp for STACKOVERFLOW staff *****/E 26I 26D 33/**** temp for STACKOVERFLOW staff *****E 26	case 0141 : printf("NOW moveframe is smashed\n");			  smash_moveframe();			  break;	case 0200 : TopOfStack=moveframe				(Addr68k_from_StkOffset(LOLOC(args[0])));			  break;D 20E 20I 20	case 0201 : do_hardreturn(CURRENTFX);			break;I 26********* COMMENT OUT ********/E 33E 26E 20D 40#ifdef	NEWFS/***** 	for DSK device ******/E 40D 38	case  0150 :	TopOfStack = DSK_openfile(args);E 38I 38D 48	case  sb_DSK_OPENFILE :	TopOfStack = DSK_openfile(args);E 48I 48	case  sb_DSK_OPENFILE : POP_SUBR_ARGS;				TopOfStack = DSK_openfile(args);E 48E 38			break;D 38	case  0151 :	TopOfStack = DSK_closefile(args);E 38I 38D 48	case  sb_DSK_CLOSEFILE :	TopOfStack = DSK_closefile(args);E 48I 48	case  sb_DSK_CLOSEFILE : POP_SUBR_ARGS;				TopOfStack = DSK_closefile(args);E 48E 38			break;E 77D 38	case  0152 :	TopOfStack = DSK_getfilename(args);E 38I 38D 48	case  sb_DSK_GETFILENAME :	TopOfStack = DSK_getfilename(args);E 48I 48	case  sb_DSK_GETFILENAME : POP_SUBR_ARGS;				TopOfStack = DSK_getfilename(args);E 48E 38			break;D 38	case  0153 :	TopOfStack = DSK_deletefile(args);E 38I 38D 48	case  sb_DSK_DELETEFILE :	TopOfStack = DSK_deletefile(args);E 48I 48	case  sb_DSK_DELETEFILE : POP_SUBR_ARGS;				TopOfStack = DSK_deletefile(args);E 48E 38			break;D 38	case  0154 :	TopOfStack = DSK_renamefile(args);E 38I 38D 48	case  sb_DSK_RENAMEFILE :	TopOfStack = DSK_renamefile(args);E 48I 48	case  sb_DSK_RENAMEFILE : POP_SUBR_ARGS;				TopOfStack = DSK_renamefile(args);E 48E 38			break;D 38	case  0155 :	TopOfStack = DSK_readpage(args);E 38I 38D 48	case  sb_DSK_READDIR :	TopOfStack = DSK_readdir(args);E 48I 48D 77	case  sb_DSK_READDIR : POP_SUBR_ARGS;				TopOfStack = DSK_readdir(args);E 48E 38			break;E 77D 38	case  0156 :	TopOfStack = DSK_writepage(args);E 38I 38D 48	case  sb_DSK_DIRECTORYNAMEP :	TopOfStack = DSK_directorynamep(args);E 48I 48	case  sb_DSK_DIRECTORYNAMEP : POP_SUBR_ARGS;				TopOfStack = DSK_directorynamep(args);E 48E 38D 77			break;D 38	case  0157 :	TopOfStack = DSK_getsize(args);E 38I 38D 48	case  sb_DSK_GETFILEINFO :	TopOfStack = DSK_getfileinfo(args);E 48I 48	case  sb_DSK_GETFILEINFO : POP_SUBR_ARGS;				TopOfStack = DSK_getfileinfo(args);E 48E 38			break;D 38	case  0160 :	TopOfStack = DSK_readdir(args);E 38I 38D 48	case  sb_DSK_DIRSIZE :	TopOfStack = DSK_dirsize(args);E 48I 48	case  sb_DSK_DIRSIZE : POP_SUBR_ARGS;				TopOfStack = DSK_dirsize(args);E 48E 38			break;D 38	case  0161 :	TopOfStack = DSK_directorynamep(args);E 38I 38D 48	case  sb_DSK_CHANGEDIR :	TopOfStack = DSK_changedir(args);E 48I 48	case  sb_DSK_CHANGEDIR : POP_SUBR_ARGS;				TopOfStack = DSK_changedir(args);E 48E 38			break;D 38	case  0162 :	TopOfStack = DSK_getfileinfo(args);E 38I 38D 48	case  sb_DSK_SETFILEINFO :	TopOfStack = DSK_setfileinfo(args);E 48I 48	case  sb_DSK_SETFILEINFO : POP_SUBR_ARGS;				TopOfStack = DSK_setfileinfo(args);E 77E 48E 38			break;D 38	case  0163 :	TopOfStack = DSK_dirsize(args);			break;D 17	case  0164 :	TopOfStack = DSK_currentdir(args);E 17I 17	case  0164 :	TopOfStack = DSK_changedir(args);E 17			break;I 30	case  0146 :	TopOfStack = UFS_setfileinfo(args);			break;	case  0147 :	TopOfStack = DSK_setfileinfo(args);			break;E 38E 30D 40#endifE 40/* Communications with Unix Subprocess */D 37        case 0165:      TopOfStack = Unix_handlecomm(args);E 37I 37D 48        case sb_UNIX_HANDLECOMM:     TopOfStack = Unix_handlecomm(args);E 48I 48        case sb_UNIX_HANDLECOMM: POP_SUBR_ARGS;			     TopOfStack = Unix_handlecomm(args);E 48E 37		        break;I 88#ifdef OCR        case sb_OCR_COMM: POP_SUBR_ARGS;			     TopOfStack = ocr_comm(args);		        break;D 94#endif OCRE 94I 94#endif /* OCR */E 94/*E 88D 48        case 0166:      {register int temp;E 48I 48        case 0166: POP_SUBR_ARGS;I 67			 error("called SUBR 0166, not defined!!");E 67			      {register int temp;E 48D 34			 GetNumber(TopOfStack, temp);E 34I 34			 N_GETNUMBER(TopOfStack, temp, badarg);E 34			 temp = (int) Addr68k_from_LADDR(temp);			 ARITH_SWITCH(temp, TopOfStack);			 break;I 34		badarg:	TopOfStack = NIL;			break;E 34			}I 21D 88E 88I 88*/E 88/* OS message print routines */ D 38	case 0170:      TopOfStack = mess_readp();E 38I 38D 48	case sb_MESSAGE_READP:      TopOfStack = mess_readp();E 48I 48	case sb_MESSAGE_READP: POP_SUBR_ARGS;			      TopOfStack = mess_readp();E 48E 38			break;D 38	case 0171:      TopOfStack = mess_read(args);E 38I 38D 48	case sb_MESSAGE_READ:      TopOfStack = mess_read(args);E 48I 48	case sb_MESSAGE_READ: POP_SUBR_ARGS;			      TopOfStack = mess_read(args);E 48E 38			break;E 21			E 13I 4D 14/**** temp for STACKOVERFLOW staff *****/	case 0141 : printf("NOW moveframe is smashed\n");			  smash_moveframe();			  break;	case 0200 : TopOfStack=moveframe				(Addr68k_from_StkOffset(LOLOC(args[0])));			  break;I 5#ifdef	NEWFS/***** 	for DSK device ******/	case  0150 :	TopOfStack = DSK_openfile(args);			break;	case  0151 :	TopOfStack = DSK_closefile(args);			break;	case  0152 :	TopOfStack = DSK_getfilename(args);			break;	case  0153 :	TopOfStack = DSK_deletefile(args);			break;	case  0154 :	TopOfStack = DSK_renamefile(args);			break;	case  0155 :	TopOfStack = DSK_readpage(args);			break;	case  0156 :	TopOfStack = DSK_writepage(args);			break;	case  0157 :	TopOfStack = DSK_getsize(args);			break;	case  0160 :	TopOfStack = DSK_readdir(args);			break;	case  0161 :	TopOfStack = DSK_directorynamep(args);			break;	case  0162 :	TopOfStack = DSK_getfileinfo(args);			break;	case  0163 :	TopOfStack = DSK_dirsize(args);			break;	case  0164 :	TopOfStack = DSK_currentdir(args);			break;#endifI 6/* Communications with Unix Subprocess */        case 0165:      TopOfStack = Unix_handlecomm(args);		        break;I 8D 10        case 0166:      TopOfStack = Addr68k_from_LADDR(args[0]);		        break;E 10I 10        case 0166:      {register int temp;			 GetNumber(TopOfStack, temp);			 temp = (int) Addr68k_from_LADDR(temp);			 ARITH_SWITCH(temp, TopOfStack);			 break;			}E 14E 10E 8			I 29/* RPC routines */E 29I 16D 48      case sb_RPC_CALL: TopOfStack = rpc(args);E 48I 48      case sb_RPC_CALL: POP_SUBR_ARGS;			 TopOfStack = rpc(args);E 48			break;I 40D 42      case sb_CHECKBCPLPASSWORD:E 42I 42/* Unix username/password utilities */D 48      case sb_CHECKBCPLPASSWORD: /* Check Unix username/password */E 48I 48      case sb_CHECKBCPLPASSWORD: POP_SUBR_ARGS;			 /* Check Unix username/password */E 48E 42			TopOfStack = check_unix_password(args);			break;I 42D 48      case sb_UNIX_USERNAME:  /* Get Unix username */E 48I 48      case sb_UNIX_USERNAME: POP_SUBR_ARGS;			  /* Get Unix username */E 48			TopOfStack = unix_username(args);			break;D 48      case sb_UNIX_FULLNAME:	/* Get Unix person-name (GECOS field) */E 48I 48      case sb_UNIX_FULLNAME: POP_SUBR_ARGS;				/* Get Unix person-name (GECOS field) */E 48			TopOfStack = unix_fullname(args);			break;I 49      case sb_UNIX_GETENV: POP_SUBR_ARGS;		/* get value of environment variable, or NIL */		TopOfStack = unix_getenv(args); break;      case sb_UNIX_GETPARM: POP_SUBR_ARGS;		/* get built in parameter */		TopOfStack = unix_getparm(args); break;E 49I 44D 48      case sb_SUSPEND_LISP:	/* Suspend Maiko */E 48I 48      case sb_SUSPEND_LISP: POP_SUBR_ARGS;				/* Suspend Maiko */E 48			TopOfStack = suspend_lisp(args);			break;I 50D 67      case 0200 : POP_SUBR_ARGS;E 67I 67      case sb_MONITOR_CONTROL : POP_SUBR_ARGS;E 67		  /* MONITOR CONTROL STOP(0) or RESUME(1) */I 54#ifdef PROFILEE 54			moncontrol(args[0] & 1);I 54D 94#endif PROFILEE 94I 94#endif /* PROFILE */E 94E 54			break;I 84	/*****************/	/* Character I/O */	/*****************/E 84I 73D 74      case 200: POP_SUBR_ARGS;  /* Char-device openfile. */E 74I 74      case sb_CHAR_OPENFILE: POP_SUBR_ARGS;  /* Char-device openfile. */E 74		TopOfStack = CHAR_openfile(args); 		break;D 74      case 201: POP_SUBR_ARGS;  /* Char-device bin. */E 74I 74      case sb_CHAR_BIN: POP_SUBR_ARGS;  /* Char-device bin. */E 74		  {		    TopOfStack = CHAR_bin(args[0], args[1]);		    break;		  }		break;D 74      case 202: POP_SUBR_ARGS;  /* Char-device bout. */E 74I 74      case sb_CHAR_BOUT: POP_SUBR_ARGS;  /* Char-device bout. */E 74		  {		    TopOfStack = CHAR_bout(args[0], args[1], args[2]);		    break;		  }		break;D 74      case 203: POP_SUBR_ARGS;  /* Char-device IOCTL. */E 74I 74      case sb_CHAR_IOCTL: POP_SUBR_ARGS;  /* Char-device IOCTL. */E 74		  {		    TopOfStack = CHAR_ioctl(args);		    break;		  }		break;D 74      case 204: POP_SUBR_ARGS;  /* Char-device CLOSEFILE. */E 74I 74      case sb_CHAR_CLOSEFILE: POP_SUBR_ARGS;  /* Char-device CLOSEFILE. */E 74		  {		    TopOfStack = CHAR_closefile(args);		    break;		  }		break;D 74      case 207: POP_SUBR_ARGS;  /* Char-device \BINS. */E 74I 74      case sb_CHAR_BINS: POP_SUBR_ARGS;  /* Char-device \BINS. */E 74		  {		    TopOfStack = CHAR_bins(args);		    break;		  }		break;D 74      case 208: POP_SUBR_ARGS;  /* Char-device \BOUTS. */E 74I 74      case sb_CHAR_BOUTS: POP_SUBR_ARGS;  /* Char-device \BOUTS. */E 74		  {		    TopOfStack = CHAR_bouts(args);		    break;		  }		break;I 74	case sb_TCP_OP:	POP_SUBR_ARGS;	/* TCP operations */		{		  TopOfStack = subr_TCP_ops(args[0], args[1], args[2],					    args[3], args[4], args[5]);		  break;		}		break;I 88#ifdef TRUECOLOR	case sb_PICTURE_OP: {		POP_SUBR_ARGS;		TopOfStack = Picture_Op( args );		}			break;	case sb_TRUE_COLOR_OP: {		POP_SUBR_ARGS;		TopOfStack = TrueColor_Op( args );		}		break;#ifdef VIDEO	case sb_VIDEO_OP: {		POP_SUBR_ARGS;		TopOfStack = Video_Op( args );		}		break;D 94#endif VIDEO#endif TRUECOLORE 94I 94#endif /* VIDEO */E 94E 88I 94#endif /* TRUECOLOR */E 94E 74D 84D 75E 75E 73I 59/* ******** NOW IN MISCN *********E 59E 50D 52E 52I 52      case sb_USER_SUBR: POP_SUBR_ARGS;			{register LispPTR user_subr, user_args;			 N_GETNUMBER(args[0], user_subr, ret_nil);			 N_GETNUMBER(args[1], user_args, ret_nil);			 TopOfStack = UserSubr(user_subr, user_args, &args[2]);			}			break;I 56D 59E 59I 59********************************** */E 84I 68D 70      case 024: POP_SUBR_ARGS;E 70I 70      case sb_PUPLEVEL1STATE: POP_SUBR_ARGS;  /* Do nothing with PUP on sun */E 70                break;I 84	case sb_WITH_SYMBOL:	POP_SUBR_ARGS;	/* Symbol lookup */		{D 85		  TopOfStack = with_symbol(args[0], args[1], args[2], args[3]);E 85I 85		  TopOfStack = with_symbol(args[0], args[1], args[2], args[3],					   args[4], args[5]);E 85		  break;I 86		}      case 0222:	/* Cause an interrupt to occur.  Used by */			/* Lisp INTERRUPTED to re-set an interrupt */			/* when it's uninterruptable. 		*/		{		  POP_SUBR_ARGS;		  Irq_Stk_Check = Irq_Stk_End=0;		  *PENDINGINTERRUPT68k = ATOM_T;		  TopOfStack = ATOM_T;E 86		}E 84I 70D 72#ifdef SXHASH      case sb_SXHASH:	POP_SUBR_ARGS;			TopOfStack = SX_hash(args);			break;#endifE 72E 70E 68E 59E 56E 52E 44E 42E 40E 16E 6E 5E 4E 3D 29	default :		printf("OP_subrcall: Invalid alpha byte 0%o \n",((*(PC+1)) & 0xff));E 29I 29D 31      case sb_GET_IP_HOST_ADDRESS: TopOfStack = get_ip_host_address(args);			break;E 31D 51      default :		printf("OP_subrcall: Invalid alpha byte 0%o \n",((*(PC+1)) & 0xff));E 29				error("OP_subrcall : Bye !! Good luck");				break;E 51I 51D 87      default :E 87I 87 	/*******************/	/* CLX Support ops */	/*******************/#ifdef CLX	case sb_OPEN_SOCKET: 		POP_SUBR_ARGS;		TopOfStack = Open_Socket( args );		break;	case sb_CLOSE_SOCKET:		TopOfStack = Close_Socket();               break;	case sb_READ_SOCKET:		POP_SUBR_ARGS;		TopOfStack = Read_Socket( args );		break;	case sb_WRITE_SOCKET:		POP_SUBR_ARGS;		TopOfStack = Write_Socket( args );		break;	case 0244: /* KB_TRANSITION */		POP_SUBR_ARGS;		TopOfStack = Kbd_Transition( args );		break;D 94#endif CLXE 94I 94#endif /* CLX */E 94I 91#ifndef NOFORN	/*****************************************/	/*  foreign-function-call support subrs  */	/*****************************************/E 91I 89	case sb_CALL_C_FN:	  {	    POP_SUBR_ARGS;	    TopOfStack = call_c_fn( args ); /* args[0]=fnaddr, args[1]=fn type */	    break;	  }	case sb_DLD_LINK:	  {	    POP_SUBR_ARGS;	    TopOfStack = Mdld_link( args );	    break;	  }	case sb_DLD_UNLINK_BY_FILE:	  {	    POP_SUBR_ARGS;	    TopOfStack = Mdld_unlink_by_file( args );	    break;	  }	case sb_DLD_UNLINK_BY_SYMBOL:	  {	    POP_SUBR_ARGS;	    TopOfStack = Mdld_unlink_by_symbol( args );	    break;	  }	case sb_DLD_GET_SYMBOL:	  {	    POP_SUBR_ARGS;	    TopOfStack = Mdld_get_symbol( args );	    break;	  }	case sb_DLD_GET_FUNC:	  {	    POP_SUBR_ARGS;	    TopOfStack = Mdld_get_func( args );	    break;	  }	case sb_DLD_FUNCTION_EXECUTABLE_P:	  {	    POP_SUBR_ARGS;	    TopOfStack = Mdld_function_executable_p( args );	    break;	  }	case sb_DLD_LIST_UNDEFINED_SYM:	  {	    POP_SUBR_ARGS;	    TopOfStack = Mdld_list_undefined_sym( );	    break;	  }	case sb_MALLOC:	  {	    POP_SUBR_ARGS;	    TopOfStack = c_malloc( args );	    break;	  }	case sb_FREE:	  {	    POP_SUBR_ARGS;	    TopOfStack = c_free( args );	    break;	  }	case sb_PUT_C_BASEBYTE:	  {	    POP_SUBR_ARGS;	    TopOfStack = put_c_basebyte( args );	    break;	  }	case sb_GET_C_BASEBYTE:	  {	    POP_SUBR_ARGS;	    TopOfStack = get_c_basebyte( args );	    break;	  }I 92	case sb_SMASHING_APPLY:	  {	    POP_SUBR_ARGS;	    TopOfStack = smashing_c_fn( args );	    break;	  }E 92I 91#endif /* NOFORN */E 91E 89     default :E 87		{		char errtext[200];		sprintf ( errtext,          	    "OP_subrcall: Invalid alpha byte 0%o", ((*(PC+1)) & 0xff));		printf  ( "%s\n", errtext );		error(errtext);		break;		}E 51 D 14  }/* switvh end */E 14I 14  }/* switch end */E 14D 83PC += 3;}/* OP_subrcall */E 83I 83    PC += 3;	/* Move PC forward to next opcode */  }/* OP_subrcall */E 83D 42I 40#include <pwd.h>/* lisp_string_to_c_string converts lisp string up to maximum length,	returns 0 if succeeds, -1 if error (not a simple string or	too long or has xns characters) */int lisp_string_to_c_string(Lisp, C, length) 	LispPTR Lisp;	char	*C;	int	length;{	ONEDARRAAY	*arrayp;		char	*base, *dp;			short	*sbase;				int	i;		if (GetTypeNumber(Lisp) != TYPE_ONED_ARRAY) {return (-1);}			arrayp = (ONEDARRAAY *)(Addr68k_from_LADDR(Lisp));	if (arrayp->totalsize >= length) {return(-1);} /* too long */		switch(arrayp->typenumber){					case THIN_CHAR_TYPENUMBER:						base = ((char *)(Addr68k_from_LADDR(arrayp->base))) + ((int)(arrayp->offset));		strncpy(C, base, arrayp->totalsize);					C[arrayp->totalsize] = '\0';						return 0;								default:									return -1;			}								}check_unix_password(args)     LispPTR args[];{  struct passwd *pwd;  char *password, *getpass();  char salt[3];  char name[100], pass[100];  if (lisp_string_to_c_string(args[0], name, sizeof name)) {return NIL;}  if (lisp_string_to_c_string(args[1], pass, sizeof pass)) {return NIL;}  if ((pwd = getpwnam(name)) == 0) {    return(NIL);	/* can't find entry for name */  }  salt[0] = pwd->pw_passwd[0];  salt[1] = pwd->pw_passwd[1];  salt[2] = '\0';  if (strcmp(crypt(pass, salt), pwd->pw_passwd) == 0)    return(ATOM_T);  else    return(NIL);}E 40D 23set_native_bit(atom_index)	LispPTR atom_index;{	DefCell *defcell;	struct fnhead *LOCFNCELL;	defcell = (DefCell *) GetDEFCELL68k(atom_index) ;	LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(defcell->defpointer) ;	LOCFNCELL->native = 1;	printf("Set %s to Native\n",atom_to_str(atom_index));};clr_native_bit(atom_index)	LispPTR atom_index;{	DefCell *defcell;	struct fnhead *LOCFNCELL;	defcell = (DefCell *) GetDEFCELL68k(atom_index) ;	LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(defcell->defpointer) ;	LOCFNCELL->native = 0;	printf("Clr %s from Native\n",atom_to_str(atom_index));};E 23I 13D 33smash_moveframe(){int index;DefCell *defptr;struct fnhead *fnptr;char *start; index= make_atom("\\MOVEFRAME",0,10 ,0); defptr=(DefCell*)GetDEFCELL68k(index); fnptr=(struct fnhead *)Addr68k_from_LADDR(defptr->defpointer); start=((char*)fnptr) + fnptr->startpc; start[0]=0100;/*IVAR      FX*/ start[1]=0175;/*SUBRCALL  NIL*/ start[2]=0200; start[3]=1; start[4]=020; /*RETURN */ start[5]=0;}E 33D 14E 13I 4smash_moveframe(){int index;DefCell *defptr;struct fnhead *fnptr;char *start; index= make_atom("\\MOVEFRAME",0,10 ,0); defptr=(DefCell*)GetDEFCELL68k(index); fnptr=(struct fnhead *)Addr68k_from_LADDR(defptr->defpointer); start=((char*)fnptr) + fnptr->startpc; start[0]=0100;/*IVAR      FX*/ start[1]=0175;/*SUBRCALL  NIL*/ start[2]=0200; start[3]=1; start[4]=020; /*RETURN */ start[5]=0;}I 7E 14E 42E 7E 4E 1