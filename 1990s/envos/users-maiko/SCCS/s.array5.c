h47984s 00004/00004/00074d D 2.10 92/04/21 17:03:37 sybalsky 12 11c shortening file names for DOS \nes 00000/00000/00078d D 2.9 90/04/20 01:20:19 sybalsky 11 10c AIX:  shortening file names, bulk change.es 00048/00020/00030d D 2.8 90/02/19 11:07:06 sybalsky 10 9c 386i changes; add commentses 00007/00008/00043d D 2.7 88/10/12 14:40:08 krivacic 9 8c new out-of-line interfacees 00004/00068/00047d D 2.6 88/07/06 14:40:24 charnley 8 7c uses new select macro with modified select order.es 00010/00021/00105d D 2.5 88/06/07 16:48:56 charnley 7 6c fixed problem with index generationes 00001/00001/00125d D 2.4 88/05/25 16:59:44 charnley 6 5c changed err type.es 00002/00002/00124d D 2.3 88/05/25 16:13:58 charnley 5 4c fixed cc bug, and array dim.es 00005/00114/00121d D 2.2 88/05/25 15:52:07 charnley 4 3c removed unused code, fixed bug in signed 32 bit case.es 00000/00000/00235d D 2.1 88/05/17 09:22:08 hayata 3 2c Version up to 2.1es 00001/00007/00234d D 1.2 88/04/21 09:38:53 charnley 2 1c changed array-type maskes 00241/00000/00000d D 1.1 88/03/30 14:05:30 charnley 1 0c date and time created 88/03/30 14:05:30 by charnleyeuUtTI 1D 10/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";/*	array5.c */E 10I 10/* This is G-file @(#) array5.c Version 2.7 (10/12/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) array5.c	2.7 10/12/88";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************//************************************************************************//*									*//*			    A R R A Y 5 . C				*//*									*//*	Contains:	N_OP_aref2  2-d AREF opcode			*//*									*//************************************************************************/E 10#include <stdio.h>#include "lispemul.h"D 12#include "lispglobal.h"#include "address68k.h"E 12I 12#include "lspglob.h"#include "adr68k.h"E 12#include "lispmap.h"D 12#include "lisptypes.h"#include "emulglobal.h"E 12I 12#include "lsptypes.h"#include "emlglob.h"E 12#include "arith.h"#include "my.h"D 2#include "tos1defs.h" #include "tosretmacro.h"#include "tosfuncallmacro.h"#include "inlinedefsC.h"#include "inlinedefs68K.h" #include "fastinlinedefs68K.h"E 2D 8/************************************************************ OP_aref2   -- op 356   (array index)   Array data structure :Word	Content0	Hi word of base pointer1	Low word of base pointer2	Flag (8 bits), Type (4 bits), Size (bits per element, 4 bits)3	Bound 04	Bound 15	Total size  verify tos < Bound1  verify tos-1 < Bound0  index = tos + (tos-1 * bound1)D 4	typenumber:		type = 7 & (typenumber >> 4)		0  unsigned		1  signed		2  pointer		3  float		4  character		5  xpointer		6  illegal		7  illegal		size = 7 & typenumber		0 1 bit   :		1 2 bits  :		2 4 bits  :		3 8 bits  :		4 16 bits : 		5 24 bits :		6 32 bits :		7 64 bits :	E 4type    size    typenumber  0       0             0      unsigned  :  1 bit  0       3             3      unsigned  :  8 bits  0       4             4      unsigned  : 16 bits  1       4            20      signed    : 16 bits  1       6            22      signed    : 32 bits  2       6            38      pointer   : 32 bits  3       6            54      float     : 32 bits  4       3            67      character :  8 bits  4       4            68      character : 16 bits  5       6            86      Xpointer  : 32 bits***********************************************************/D 4/***	OP_aref2   -- op 356   (array index0 index1)   ***/OP_myaref2(){E 4E 8D 4register LispPTR baseL;register int typenumber;register int index;register DLword *array;LispPTR temp;register int i, j;	/*	for CREATECELL  */register DLword	*wordp;DLword	*createcell68k();      /*  verify array  */      temp = *((LispPTR *)(CurrentStackPTR - 2));      if (GetTypeNumber(temp) != TYPE_TWOD_ARRAY) gotoufn;      array = Addr68k_from_LADDR(temp);      /*  test and setup index  */      temp = *((LispPTR *)CurrentStackPTR);      if ((0xFFFF0000 & temp) != S_POSITIVE) gotoufn;      i = 0xFFFF & temp;      if (i >= *((DLword *)(array + 3))) gotoufn;      if ((0xFFFF0000 & TopOfStack) != S_POSITIVE) gotoufn;      index = 0xFFFF & TopOfStack;      if (index >= (j = (*((DLword *)(array + 4))))) gotoufn;      index += (i * j);      /*  setup typenumber  */      typenumber = 0xFF & *((DLword *)(array + 2));      /*  setup base  */      baseL = *((LispPTR *)array);      /*  disp on type  */    switch (typenumber) {      case 0: /* unsigned : 1 bit per element */         TopOfStack = ((*(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1;         TopOfStack |= S_POSITIVE;         break;      case 3: /* unsigned : 8 bits per element */         TopOfStack = (*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF;         TopOfStack |= S_POSITIVE;         break;      case 4: /* unsigned : 16 bits per element */         TopOfStack = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;         TopOfStack |= S_POSITIVE;         break;      case 20: /* signed : 16 bits */         TopOfStack = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;         if (TopOfStack & 0x8000) TopOfStack |= S_NEGATIVE;         else TopOfStack |= S_POSITIVE;         break;      case 22: /* signed : 32 bits */         wordp = createcell68k(TYPE_FIXP);         *((int *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);         TopOfStack = LADDR_from_68k(wordp);         break;      case 38: /* pointer : 32 bits */         TopOfStack = *(((int *)Addr68k_from_LADDR(baseL)) + index);         break;      case 54: /* Float : 32 bits */         wordp = createcell68k(TYPE_FLOATP);         *((float *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);         TopOfStack = LADDR_from_68k(wordp);         break;      case 67: /* Character :  8 bits */          TopOfStack = (*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF;         TopOfStack |= S_CHARACTER;         break;      case 68: /* Character :  16 bits */         TopOfStack = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;         TopOfStack |= S_CHARACTER;	 break;      case 86: /* XPointer : 32 bits */         TopOfStack = *(((int *)Addr68k_from_LADDR(baseL)) + index);         break;      default: /* Illegal or Unimplemented */        gotoufn;    }/* end switch typenumber */ CurrentStackPTR -= 4;PC++;} /*  end OP_aref2()  */E 4D 10/***	N_OP_aref2   -- op 356   (array index0 index1)   ***/E 10I 10/************************************************************************//*									*//*			N _ O P _ a r e f 2				*//*									*//*	2-d AREF op 356   (array index0 index1)				*//*									*//************************************************************************/E 10D 7N_OP_aref2(arrayarg, index0, index1, error_addr)D 4int index0, index1, *error_addr;E 4I 4D 6int index0, index1, error_addr;E 6I 6int index0, index1, *error_addr;E 6E 4LispPTR arrayarg;E 7I 7D 9N_OP_aref2(arrayarg, inx0, inx1, error_addr)int *error_addr;E 9I 9N_OP_aref2(arrayarg, inx0, inx1)E 9D 10LispPTR arrayarg, inx0, inx1;E 7{register LispPTR baseL;D 8register int typenumber;E 8I 8register int type;E 8D 7register int index;E 7I 7register int index, temp;E 7register DLword *arrayblk;D 7LispPTR temp;E 7register int result;int j;E 10I 10  LispPTR arrayarg, inx0, inx1;  {    register LispPTR baseL;    register int type;    register int index, temp;    register LispArray *arrayblk;    register int result;    int j;E 10	/*	for CREATECELL  */D 10register DLword	*wordp;DLword	*createcell68k();E 10I 10    register DLword	*wordp;    DLword	*createcell68k();E 10      /*  verify array  */D 5      if (GetTypeNumber(arrayarg) != TYPE_ONED_ARRAY) ERROR_EXIT(error_addr);E 5I 5D 9      if (GetTypeNumber(arrayarg) != TYPE_TWOD_ARRAY) ERROR_EXIT(error_addr);E 9I 9      if (GetTypeNumber(arrayarg) != TYPE_TWOD_ARRAY) ERROR_EXIT(inx1);E 9E 5D 10      arrayblk = Addr68k_from_LADDR(arrayarg);      baseL = *((LispPTR *)(arrayblk));E 10I 10      arrayblk = (LispArray *)Addr68k_from_LADDR(arrayarg);      baseL = arrayblk->base;E 10     /*  test and setup index  */D 4      if ((0xFFFF0000 & index0) != S_POSITIVE) ERROR_EXIT(error_addr);E 4I 4D 7      if ((0xFF0000 & index0) != S_POSITIVE) ERROR_EXIT(error_addr);E 4      index0 = 0xFFFF & index0;      if (index0 >= *((DLword *)(arrayblk + 3))) ERROR_EXIT(error_addr);D 4      if ((0xFFFF0000 & index1) != S_POSITIVE) ERROR_EXIT(error_addr);      index = 0xFFFF & index1;E 4I 4      if ((0xFF0000 & index1) != S_POSITIVE) ERROR_EXIT(error_addr);      index &= 0xFFFF;E 4      if (index >= (j = (*((DLword *)(arrayblk + 4))))) ERROR_EXIT(error_addr);      index += (index0 * j);E 7I 7D 9      N_GetPos(inx1, temp, error_addr);      if (temp >= (j = (*((DLword *)(arrayblk + 4))))) ERROR_EXIT(error_addr);      N_GetPos(inx0, index, error_addr);      if (index >= *((DLword *)(arrayblk + 3))) ERROR_EXIT(error_addr);E 9I 9      N_GetPos(inx1, temp, inx1);D 10      if (temp >= (j = (*((DLword *)(arrayblk + 4))))) ERROR_EXIT(inx1);E 10I 10      if (temp >= (j = arrayblk->Dim1)) ERROR_EXIT(inx1);E 10      N_GetPos(inx0, index, inx1);D 10      if (index >= *((DLword *)(arrayblk + 3))) ERROR_EXIT(inx1);E 10I 10      if (index >= arrayblk->Dim0) ERROR_EXIT(inx1);E 10E 9      index *= j;      index += temp;E 7      /*  setup typenumber  */D 2      typenumber = 0xFFFF & *((DLword *)(arrayblk + 2));E 2I 2D 8      typenumber = 0xFF & *((DLword *)(arrayblk + 2));E 8I 8D 10      type = 0xFF & *((DLword *)(arrayblk + 2));E 10I 10      type = 0xFF & arrayblk->typenumber;E 10E 8E 2      /*  disp on type  */D 8    switch (typenumber) {      case 0: /* unsigned : 1 bit per element */         return(S_POSITIVE | (((*(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1));D 7         break;E 7      case 3: /* unsigned : 8 bits per element */         return(S_POSITIVE | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF));D 7         break;E 7      case 4: /* unsigned : 16 bits per element */         return(S_POSITIVE | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF));D 7         break;E 7      case 20: /* signed : 16 bits */         result = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;         if (result & 0x8000) return(result | S_NEGATIVE);         else return(result | S_POSITIVE);D 7         break;E 7      case 22: /* signed : 32 bits */         result = *(((int *)Addr68k_from_LADDR(baseL)) + index);D 4         N_ARITH_SWITCH(result);E 4I 4D 5         return(N_ARITH_SWITCH(result));E 5I 5         N_ARITH_SWITCH(result);E 5E 4D 7         break;E 7      case 38: /* pointer : 32 bits */         return(*(((int *)Addr68k_from_LADDR(baseL)) + index));D 7         break;E 7      case 54: /* Float : 32 bits */         wordp = createcell68k(TYPE_FLOATP);         *((int *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);         return(LADDR_from_68k(wordp));D 7         break;E 7      case 67: /* Character :  8 bits */         return(S_CHARACTER | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF));D 7         break;E 7      case 68: /* Character :  16 bits */         return(S_CHARACTER | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF));	   break;      case 86: /* XPointer : 32 bits */         return(*(((int *)Addr68k_from_LADDR(baseL)) + index));D 7         break;E 7      default: /* Illegal or Unimplemented */        ERROR_EXIT(error_addr);    }/* end switch typenumber */E 8I 8D 9      aref_switch(type, error_addr);E 9I 9      aref_switch(type, inx1);E 9E 8} /*  end N_OP_aref2()  */D 8	/*  end module  */E 8E 1