h17314s 00008/00008/00224d D 1.3 93/02/08 14:57:13 sybalsky 3 2c Big VM (and new CDR coding) changes for 3.0 \nes 00009/00006/00223d D 1.2 92/04/22 13:54:52 sybalsky 2 1c fix SCCS headeres 00229/00000/00000d D 1.1 92/04/21 15:29:17 sybalsky 1 0c date and time created 92/04/21 15:29:17 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";D 2/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 2I 2E 2/************************************************************************//*									*/D 2/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 2I 2/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 2/*									*/D 2/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 2I 2/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 2/*									*//************************************************************************/D 2E 2/***********************************************************************//* 		File Name :	mkcell.c		Desc	:	  				Date :		Jun. 4, 1987 				Edited by :	Takeshi Shimizu				Changed :	9 Jun 1987 take						26 Oct. 1987 take(add mask) 		Including :	OP_createcell								*//**********************************************************************/#include "lispemul.h"#include "lispmap.h"#include "emlglob.h"#include "lspglob.h"#include "lsptypes.h"#include "address.h"#include "adr68k.h"#include "cell.h" #include "gc.h"  LispPTR *alloc_mdspage();LispPTR initmdspage();LispPTR N_OP_createcell(tos)	register LispPTR tos;{  register struct dtd *dtd68k;  register DLword *ptr,*lastptr;  register LispPTR newcell ;  register unsigned int type ;D 3  if((tos & 0xff0000) != S_POSITIVE) ERROR_EXIT(tos);E 3I 3  if((tos & SEGMASK) != S_POSITIVE) ERROR_EXIT(tos);E 3  type = tos & 0xffff ;#ifdef DEBUG  if(type==TYPE_LISTP)	error("N_OP_createcell : Can't create Listp cell with CREATECELL");	check_dtd_chain(type);#endif    dtd68k = (struct dtd *)GetDTD(type);  if(dtd68k->dtd_size == 0) ERROR_EXIT(tos);  /* error("OP_createcell : Attempt to create a cell not declared yet"); */retry :D 3  if((tos=newcell=((dtd68k->dtd_free)&0xffffff)) != NIL)E 3I 3  if((tos=newcell=((dtd68k->dtd_free)&POINTERMASK)) != NIL)E 3  {	ptr = (DLword *)Addr68k_from_LADDR(newcell);	/* replace dtd_free with newcell's top DLword (it may keep next chain)*/D 3	dtd68k->dtd_free = (*((LispPTR *)ptr)) & 0xffffff;E 3I 3	dtd68k->dtd_free = (*((LispPTR *)ptr)) & POINTERMASK;E 3	dtd68k->dtd_oldcnt++;	/* clear 0  */	for(lastptr=ptr + dtd68k->dtd_size ;		ptr != lastptr ; ptr++)	  {  GETWORD(ptr) = 0 ; }/*	 IncAllocCnt(1); */	 GCLOOKUP(tos, DELREF);	 return(tos);  }  else  {	dtd68k->dtd_free = initmdspage(alloc_mdspage(dtd68k->dtd_typeentry) , 				dtd68k->dtd_size ,NIL);	goto retry ;  }} /* N_OP_createcell end */DLword *createcell68k(type) unsigned int type;{  register struct dtd *dtd68k;  register DLword *ptr,*lastptr;  register ConsCell *newcell68k;  register LispPTR newcell ;#ifdef DEBUG  if(type==TYPE_LISTP)	error("createcell : Can't create Listp cell with CREATECELL");  if(type==TYPE_STREAM) stab();	check_dtd_chain(type);#endif    dtd68k = (struct dtd *)GetDTD(type);  if(dtd68k->dtd_size == 0)	error("createcell : Attempt to create a cell not declared yet");retry :D 3  if((newcell=(dtd68k->dtd_free & 0xffffff)) != NIL)E 3I 3  if((newcell=(dtd68k->dtd_free & POINTERMASK)) != NIL)E 3  {#ifdef DEBUG	if(type != GetTypeNumber(newcell)) 	  error("createcell : BAD cell in dtdfree");D 3	if(newcell > 0xFFFFFF)E 3I 3	if(newcell > POINTERMASK)E 3		error("createcell : BAD Lisp address");#endif	ptr = Addr68k_from_LADDR(newcell) ;	/* replace dtd_free with newcell's top DLword (it may keep next chain)*/D 3	dtd68k->dtd_free = (*((LispPTR *)ptr)) & 0xFFFFFF ;E 3I 3	dtd68k->dtd_free = (*((LispPTR *)ptr)) & POINTERMASK ;E 3#ifdef DEBUG	if((dtd68k->dtd_free!=0)&&(type != GetTypeNumber(dtd68k->dtd_free)) )	  error("createcell : BAD cell in next dtdfree");	check_dtd_chain(type);#endif	dtd68k->dtd_oldcnt++;	/* clear 0  */	for(lastptr=ptr + dtd68k->dtd_size ;		ptr != lastptr ; ptr++)	  {  GETWORD(ptr) = 0 ; }/*	IncAllocCnt(1); */	GCLOOKUP(newcell, DELREF);#ifdef DEBUG	check_dtd_chain(type);#endif	return(Addr68k_from_LADDR(newcell));	  }  else  {	dtd68k->dtd_free = initmdspage(alloc_mdspage(dtd68k->dtd_typeentry) , 				dtd68k->dtd_size ,NIL);#ifdef DEBUG	check_dtd_chain(type);#endif	goto retry ;  }} /* createcell68k end *//**********************************************************//*  Create a Cell of Specified Type & Set to given Value  *//*  Works with 32 bit typed values only.                  *//*  (Initially used only by native code)                  *//**********************************************************/LispPTR Create_n_Set_Cell(type, value) unsigned int type; LispPTR value;{  register struct dtd *dtd68k;  register DLword *ptr,*lastptr;  register ConsCell *newcell68k;  register LispPTR newcell ;    dtd68k = (struct dtd *)GetDTD(type);  if(dtd68k->dtd_size == 0)	error("createcell : Attempt to create a cell not declared yet");retry :D 3  if((newcell=(dtd68k->dtd_free & 0xffffff)) != NIL)E 3I 3  if((newcell=(dtd68k->dtd_free & POINTERMASK)) != NIL)E 3  {	ptr = Addr68k_from_LADDR(newcell) ;	/* replace dtd_free with newcell's top DLword (it may keep next chain)*/D 3	dtd68k->dtd_free = (*((LispPTR *)ptr)) & 0xFFFFFF ;E 3I 3	dtd68k->dtd_free = (*((LispPTR *)ptr)) & POINTERMASK ;E 3	dtd68k->dtd_oldcnt++;	/* clear 0  */	for(lastptr=ptr + dtd68k->dtd_size ;		ptr != lastptr ; ptr++)	  {  GETWORD(ptr) = 0 ; }/*	IncAllocCnt(1); */	GCLOOKUP(newcell, DELREF);	(* ((LispPTR *) Addr68k_from_LADDR(newcell))) = value;	return(newcell);	  }  else  {	dtd68k->dtd_free = initmdspage(alloc_mdspage(dtd68k->dtd_typeentry) , 				dtd68k->dtd_size ,NIL);	goto retry ;  }} /* createcell68k end */E 1