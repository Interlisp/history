h62800s 00041/00004/02194d D 2.46 91/10/15 18:11:05 sybalsky 50 49c ISC changeses 00054/00053/02144d D 2.45 91/05/20 09:35:57 sybalsky 49 48c Make bitblt functions return T if bits are moved.es 00002/00004/02195d D 2.44 90/09/18 23:30:21 sybalsky 48 47c Retrofit changes from AIX, DEC3100, PS/2es 00016/00008/02183d D 2.43 90/06/15 22:17:38 fuji 47 46c Punt if BPP is not 1es 00004/00001/02187d D 2.42 90/06/13 15:37:34 sybalsky 46 45c AIX compatibility changes.es 00050/00002/02138d D 2.41 90/06/12 19:51:37 fuji 45 44c Add the punt case for bitshade_bitmap,bitblt_bitmapes 00004/00003/02136d D 2.40 90/06/06 13:06:46 sybalsky 44 43c fix to work with new S_CHECKes 00009/00004/02130d D 2.39 90/05/14 13:40:59 sybalsky 43 42c Fix core-smashing bug, where top & right could get set wrong because of min on unsigned values.es 00024/00000/02110d D 2.38 90/05/14 12:03:20 fuji 42 41c Matsuda: support color funcs on CG6es 00000/00000/02110d D 2.37 90/04/20 01:22:39 sybalsky 41 40c AIX:  shortening file names, bulk change.es 00006/00006/02104d D 2.36 90/04/17 17:02:30 sybalsky 40 39c AIX changeses 00009/00011/02101d D 2.35 90/03/06 14:16:42 sybalsky 39 38c 386 fixes.es 00001/00001/02111d D 2.34 90/03/05 13:08:06 sybalsky 38 37c check for 386, pass 1.es 00089/00009/02023d D 2.33 90/03/01 12:56:33 osamu 37 36c Mitsunori Matsuda adds XWindow functionality.es 00014/00009/02018d D 2.32 90/02/12 11:44:36 takeshi 36 35c bitshade_bitmap: testing texture.(countine debug,temp ci)es 00076/00011/01951d D 2.31 90/02/06 11:44:48 sybalsky 35 34c byte-swap fixeses 00011/00000/01951d D 2.30 89/12/29 12:57:43 sybalsky 34 33c Chagnes from Savoires 00001/00013/01950d D 2.29 89/12/28 15:23:07 sybalsky 33 32c speedu[es 00644/00123/01319d D 2.28 89/12/13 10:53:28 sybalsky 32 31c color ss1, speedes 00329/00188/01113d D 2.27 89/10/19 17:58:02 sybalsky 31 30c display bufferinges 00001/00001/01300d D 2.26 89/04/06 19:22:27 sybalsky 30 29c was punting to wrong function after last change....es 00007/00000/01294d D 2.25 89/04/06 16:26:46 sybalsky 29 28c PUNT_TO_BLTCHAR now checks for uninitialized BLTCHAR_index and tries to init it again.es 00128/00003/01166d D 2.24 89/03/30 20:30:14 sybalsky 28 27c Turn off pixrects on 386es 00003/00003/01166d D 2.23 89/03/28 01:46:52 sybalsky 27 26c word-pointer fixes for 386 (VERY IFFY HERE!)es 00005/00014/01164d D 2.22 89/03/27 15:44:09 sybalsky 26 25c Word-ptr ref fixup for MDStypetbl, plus moved bitmap decl to lisptypes.hes 00125/00125/01053d D 2.21 89/03/02 20:13:13 shih 25 24c change SrcPixRect to SrcePixRect, numerous style cleanupses 00098/00110/01080d D 2.20 89/02/09 13:26:09 sybalsky 24 23c Made TEDIT_BLTCHAR know it's not painting direct to the screen.es 00090/00001/01100d D 2.19 89/01/17 10:02:39 shimizu 23 22c Add Color cursores 00010/00011/01091d D 2.18 89/01/11 17:10:43 shimizu 22 21c remove backward check from n_new_cursorines 00029/00007/01073d D 2.17 89/01/10 20:35:40 shimizu 21 20c FIX mouse cursor dropping(in bitbltsub)es 00022/00009/01058d D 2.16 89/01/04 16:55:30 shimizu 20 19c For C-Cursor trackinges 00007/00002/01060d D 2.15 88/11/30 12:50:24 shimizu 19 18c Fix AR10958(Index for \\TEDIT.BLTCHAR)es 00002/00000/01060d D 2.14 88/10/31 16:01:32 shimizu 18 17c AR 10921 fix(PC was wrong)es 00074/00000/00986d D 2.13 88/10/19 14:07:15 shimizu 17 16c Use pr_op in tedit_bltchares 00209/00207/00777d D 2.12 88/10/18 19:50:36 shih 16 15c minor cleanupes 00020/00002/00964d D 2.11 88/10/18 17:25:04 charnley 15 14c fixed cursor check subr for pr_rop cases.es 00180/00001/00786d D 2.10 88/10/18 13:17:35 charnley 14 13c reenabled pr_rop in char subrs.es 00105/00004/00682d D 2.9 88/10/10 14:42:45 shimizu 13 12c For primary tune of TEDITes 00002/00001/00684d D 2.8 88/10/06 11:33:38 shimizu 12 11c AR10887 temp solutiones 00007/00022/00678d D 2.7 88/09/28 10:41:47 charnley 11 10c re-enabled changing character set in C code.es 00186/00289/00514d D 2.6 88/09/23 13:53:49 charnley 10 9c removed calls to Sun pixrect, replaced with bitblt.es 00000/00005/00803d D 2.5 88/08/01 10:08:21 masinter 9 8c moved FRPLPTR to gc.h so it can be used elsewherees 00004/00004/00804d D 2.4 88/07/22 12:34:05 shimizu 8 7c Deu to compiler problem(?) I add the cast for variable comparisones 00044/00026/00764d D 2.3 88/07/06 11:08:03 shimizu 7 6c Make positions and offsets are signed values(still change charset is commented out-> PUNT case)es 00360/00004/00430d D 2.2 88/06/29 17:28:24 shimizu 6 5c add newbltchares 00000/00000/00434d D 2.1 88/05/17 09:22:34 hayata 5 4c Version up to 2.1es 00006/00007/00428d D 1.4 88/05/12 18:16:58 shimizu 4 3c MACRO CURSORINP2 fixedes 00041/00029/00394d D 1.3 88/05/12 15:47:00 shimizu 3 2c Refinement for BLTCHARes 00045/00023/00378d D 1.2 88/05/12 14:34:30 shimizu 2 1c adopt 5/12 codees 00401/00000/00000d D 1.1 88/05/11 20:07:12 shimizu 1 0c date and time created 88/05/11 20:07:12 by shimizueuUtTI 1D 16/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 16I 16D 32/* %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 16D 4static char *id = "%Z% %M%	%I% %G%";E 4/* *	Copyright (C) 1988 by Fuji Xerox Co., Ltd. All rights reserved. *D 16 *	Auther :  Osamu NakamuraE 16I 16 *	Author :  Osamu NakamuraE 16 * */E 32I 32D 36/* @(#) bitbltsub.c Version 2.26 (4/6/89). copyright Xerox & Fuji Xerox  */E 36I 36D 49/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 49I 49/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(Venue & Fuji Xerox)";E 49I 37E 37E 36/************************************************************************//*									*//*			File:	bitbltsub.c				*//*									*/D 49/*	Copyright (C) 1988, 1989 by Fuji Xerox Co., Ltd.,		*//*				    Envos Corporation,			*//*				    John Sybalsky			*//*			All Rights Reserved.				*//*									*/E 49/*	Subroutines to support BITBLT, \BLTCHAR, and \TEDIT.BLTCHAR	*//*	lisp functions, providing performance improvement.		*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/I 34/************************************************************************//*									*/D 49/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 49I 49/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*//*	Manufactured in the United States of America.			*/E 49/*									*/D 49/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 49I 49/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 49/*									*//************************************************************************/I 49E 49E 34E 32#include <stdio.h>#include <sys/ioctl.h>I 50#include <sys/types.h>E 50I 50#ifdef XWINDOW#include <X11/Xlib.h>#include <X11/Xutil.h>extern Display *Xdisplay;/* from pixrect's rect.h: */#ifndef max#define max(a,b) (((a) > (b)) ? (a) : (b))#endif#ifndef min#define min(a,b)	(((a) < (b)) ? (a) : (b))#endif#ifdef ISC  /* for ISC, need to turn off SIGIO while flushing changes to X server */#define SIGoff sighold(SIGPOLL);#define SIGon  sigrelse(SIGPOLL);#include <signal.h>#else#define SIGoff#define SIGon#endif /* ISC */#endif XWINDOW#ifndef XWINDOWE 50I 31#ifndef NOPIXRECTE 31D 10#include <pixrect/pixrect_hs.h>E 10#include <sunwindow/window_hs.h>#include <sunwindow/win_ioctl.h>I 31D 46#endifE 46I 46#endif NOPIXRECTI 50#endif XWINDOWE 50E 46E 31D 31E 31#include "lispemul.h"#include "lispglobal.h"#include "lispmap.h"#include "lisptypes.h"#include "emulglobal.h"#include "address68k.h"#include "address.h"I 32#include "arith.h"E 32I 6#include "stack.h"#include "cell.h"#include "gc.h"I 48E 48I 46#ifdef AIXI 48#include <sys/types.h>E 48#include <macros.h>#endif AIXE 46E 6I 10#include "bb.h"E 10#include "bitblt.h"#include "pilotbbt.h"#include "displaydata.h"I 31#include "display.h"#include "dbprint.h"I 42#ifdef COLORextern int MonoOrColor;#endif COLORE 42E 31/* same definition is in my.h */D 25#define IsNumber(address)     ((*(MDStypetbl +(((address) & 0x0ffff00)>>9))) & 0x1000)E 25I 25D 26#define IsNumber(address)  ((*(MDStypetbl +(((address) & 0x0ffff00)>>9))) & 0x1000)E 26I 26#define IsNumber(address)  ((GETWORD(MDStypetbl +(((address) & 0x0ffff00)>>9))) & 0x1000)E 26E 25D 16		E 16I 16E 16D 31#define Expand4Bit(BITS)	\		((BITS) | ((BITS) << 4) | ((BITS) << 8) | ((BITS) << 12))D 16		E 16I 16E 31E 16#define BITSPERWORD	(16)	/* temp definition	*/I 28D 31	/* Is the bitmap in the display region? */E 31D 31#define IN_DISPLAY_BANK(hiaddr) (((hiaddr)==DISPLAY_HI)|((hiaddr)==(DISPLAY_HI+1)))E 31	/***** Don't use PixRect code on 386i for now *****/I 31	/***** -or on any machine that doesn't support it (HP, e.g.) *****/E 31D 31#ifndef I386E 31I 31	/********************************************************/	/*							*/	/*	prropstyle is DEFINED when we want to use	*/	/*	pixrect versions of the operations in this	*/	/*	file, and UNDEFINED, when we want to use	*/	/*	Don Charnley's bitblt code to do them.		*/	/*							*/	/********************************************************/D 32#ifndef NOPIXRECTE 32I 32D 33#if ( !(defined(NOPIXRECT)) && !(defined(NEWBITLBT))  && !(defined(I386)) )E 33I 33D 35#if ( !(defined(NOPIXRECT)) && !(defined(NEWBITLBT)) )E 35I 35D 39#if ( !(defined(NOPIXRECT)) && !(defined(NEWBITBLT)) )E 39I 39#if ( !(defined(NOPIXRECT)) && !(defined(NEWBITBLT)) && !(defined(I386)) )E 39E 35E 33E 32E 31E 28I 14#define prropstyle 1I 28D 31#endif I386E 31I 31#endif NOPIXRECTE 31E 28E 14I 3D 4#define CURSORINP2( addrhi, x, w, h, y)	\	((((addrhi == DISPALY_HI)&&(addrhi == DISPALY_HI+1))|| \	((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))) ? \	 T : NIL);E 4I 4D 10#define CURSORINP2( addrhi, x, w, h, y)	 (((((addrhi) == DISPALY_HI)||((addrhi) == DISPALY_HI+1))&& \	((x) < MOUSEXR)&&((x) + (w) > MOUSEXL)&&((y) < MOUSEYH)&&((y) + (h) > MOUSEYL)) ? \	 T : NIL) E 10E 4E 3I 3D 10I 4E 10E 4E 3extern int LispWindowFd;I 20extern int ScreenLocked; /* for mouse tracking */E 20/*****************************************************************(PUTPROPS \SETPBTFUNCTION MACRO	(OPENLAMBDA (BBT SourceType Operation)		(PROGN (replace (PILOTBBT PBTOPERATION) of BBT withD 16				(SELECTQ Operation 					(ERASE 1) 					(PAINT 2) 					(INVERT 3) E 16I 16				(SELECTQ Operation					(ERASE 1)					(PAINT 2)					(INVERT 3)E 16					0))D 16		       (replace (PILOTBBT PBTSOURCETYPE) of BBT with 		  	    (COND ((EQ (EQ SourceType (QUOTE INVERT)) 				       (EQ Operation (QUOTE ERASE))) 0) 		  		  (T 1))))))E 16I 16		       (replace (PILOTBBT PBTSOURCETYPE) of BBT with			    (COND ((EQ (EQ SourceType (QUOTE INVERT))				       (EQ Operation (QUOTE ERASE))) 0)				  (T 1))))))E 16*****************************************************************/D 10#define PixOperationLisp( SRCTYPE, OPERATION )	\	( SRCTYPE == INVERT_atom ? \		(OPERATION == REPLACE_atom ? PIX_NOT(PIX_SRC) : \		(OPERATION == PAINT_atom ? PIX_NOT(PIX_SRC) | PIX_DST : \		(OPERATION == ERASE_atom ? PIX_SRC & PIX_DST : \		(OPERATION == INVERT_atom ? PIX_NOT(PIX_SRC) ^ PIX_DST : ERROR)))) : \	/*  SRCTYPE == INPUT, TEXTURE */ \		(OPERATION == REPLACE_atom ? PIX_SRC : \		(OPERATION == PAINT_atom ? PIX_SRC | PIX_DST : \		(OPERATION == ERASE_atom ? PIX_NOT(PIX_SRC) & PIX_DST : \E 10I 10#define PixOperationLisp( SRCTYPE, OPERATION )				\	( SRCTYPE == INVERT_atom ?					\		(OPERATION == REPLACE_atom ? PIX_NOT(PIX_SRC) :		\D 25		(OPERATION == PAINT_atom ? PIX_NOT(PIX_SRC) | PIX_DST :	\		(OPERATION == ERASE_atom ? PIX_SRC & PIX_DST :		\		(OPERATION == INVERT_atom ? PIX_NOT(PIX_SRC) ^ PIX_DST : ERROR)))) :	\E 25I 25		(OPERATION == PAINT_atom   ? PIX_NOT(PIX_SRC) | PIX_DST : \		(OPERATION == ERASE_atom   ? PIX_SRC & PIX_DST :	\		(OPERATION == INVERT_atom  ? PIX_NOT(PIX_SRC) ^ PIX_DST : ERROR)))) :	\E 25	/*  SRCTYPE == INPUT, TEXTURE */				\		(OPERATION == REPLACE_atom ? PIX_SRC :			\D 25		(OPERATION == PAINT_atom ? PIX_SRC | PIX_DST :		\		(OPERATION == ERASE_atom ? PIX_NOT(PIX_SRC) & PIX_DST :	\E 10		(OPERATION == INVERT_atom ? PIX_SRC ^ PIX_DST : ERROR)))))E 25I 25		(OPERATION == PAINT_atom   ? PIX_SRC | PIX_DST :	\		(OPERATION == ERASE_atom   ? PIX_NOT(PIX_SRC) & PIX_DST : \		(OPERATION == INVERT_atom  ? PIX_SRC ^ PIX_DST : ERROR)))))E 25I 10#define bbop( SRCTYPE, OPERATION )					\		(OPERATION == PAINT_atom ? op_fn_or :			\		(OPERATION == ERASE_atom ? op_fn_and :			\		(OPERATION == INVERT_atom ? op_fn_xor : op_repl_src)))E 10I 32	/********************************************************/	/*							*/	/*		    b b s r c _ t y p e			*/	/*							*/	/*	Returns 1 if the source bits must be inverted	*/	/*	as part of the BITBLT.  This is true if the	*/	/*	OPERATION argument to BITBLT is 'ERASE, or	*/	/*	if the SOURCETYPE argument is 'INVERT.		*/	/*							*/	/********************************************************/E 32I 10#define bbsrc_type( SRCTYPE, OPERATION )				\	( SRCTYPE == INVERT_atom ?					\		(OPERATION == ERASE_atom ? 0 : 1 )			\	/*  SRCTYPE == INPUT, TEXTURE */				\		: (OPERATION == ERASE_atom ? 1 : 0))I 35#define init_kbd_startup	\	if (!kbd_for_makeinit){ \		init_keyboard(0); \		kbd_for_makeinit = 1; \	};E 35I 32I 35E 35E 32D 26E 10typedef struct{	LispPTR	bmbase;	DLword	bmrasterwidth;	DLword	bmheight;	DLword	bmwidth;	DLword	bmbitperpixel;}BITMAP;E 26I 14D 25extern struct pixrect *SrcPixRect, *DestPixRect, *TexturePixRect;E 25I 25extern struct pixrect *SrcePixRect, *DestPixRect, *TexturePixRect;E 25extern struct pixrect *BlackTexturePixRect, *WhiteTexturePixRect;E 14D 10extern struct pixrect *SrcPixRect, *DestPixRect, *TexturePixRect;D 2extern struct pixrect *BlackTexturePixRect;E 2I 2extern struct pixrect *BlackTexturePixRect, *WhiteTexturePixRect;E 2E 10D 16extern DLword	TEXTURE_atom; extern DLword	MERGE_atom; extern DLword	INPUT_atom; extern DLword	INVERT_atom; extern DLword	ERASE_atom; extern DLword	PAINT_atom; extern DLword	REPLACE_atom; E 16I 16extern DLword	TEXTURE_atom;extern DLword	MERGE_atom;extern DLword	INPUT_atom;extern DLword	INVERT_atom;extern DLword	ERASE_atom;extern DLword	PAINT_atom;extern DLword	REPLACE_atom;E 16D 10int	sourcetype;	/* this var change to Global to Debug aid. */E 10I 35extern int kbd_for_makeinit;	/*** FOR INIT ***/E 35D 32bitbltsub( args )D 16 register LispPTR	*args;	E 16I 16 register LispPTR	*args;E 16		/*	args[0] :	PILOTBBT		 *	args[1] :	SOURCEBITMAP		 *	args[2] :	SLX (SourceLeftX)		 *	args[3] :	STY (SourceTopY)		 *	args[4] :	DESTINATIONBITMAP		 *	args[5] :	DLX (DestinationLeftX)		 *	args[6] :	DTY (DestinationTopY)D 31		 *	args[7] :	HIGHTE 31I 31		 *	args[7] :	HEIGHTE 31		 *	args[8] :	SourceType		 *	args[9] :	Operation		 *	args[10] :	Texture		 *	args[11] :	WindowXOffset		 *	args[12] :	WindowYOffset		 */{D 10	register PILOTBBT *pbt;	register BITMAP	*srcbm, *destbm;	int	slx, sty, dlx, dty,  height,		/* sourcetype,   this var change to Global to Debug aid. */		operation, 		texture, wxoffset, wyoffset;D 6	int destbpl, sourcebpl, bptgrayoffset, pix_op;E 6I 6	int destbpl, sourcebpl, bptgrayoffset;	register int  pix_op;E 6	int distance, h, w, y;	int pbtdisjointitems = 0, pbtbackward = 0; /* flags */E 10I 10	PILOTBBT *pbt;D 25	BITMAP	*srcbm, *destbm, *texture68k;E 25I 25	BITMAP	*srcebm, *destbm, *texture68k;E 25	DLword	*base;	int	sourcetype, operation;	int	sty, dty, texture, wxoffset, wyoffset;	int h, w;E 10	int displayflg = 0, desthi;D 10	short *srcaddr, *destaddr, *base;	BITMAP *texture68k;E 10I 10	int backwardflg = 0, sx, dx, srcbpl, dstbpl, src_comp, op;	DLword *srcbase, *dstbase;	int gray = 0, num_gray = 0, curr_gray_line = 0;	DLword grayword[4];E 32E 10D 16	E 16I 16E 16D 10	pbt = (PILOTBBT *)Addr68k_from_LADDR( args[0] );	srcbm	 = (BITMAP *)Addr68k_from_LADDR( args[1] );	slx 	 = (args[2] & 0xFFFF);	sty	 = (args[3] & 0xFFFF);	destbm	 = (BITMAP *)Addr68k_from_LADDR( args[4] );	dlx	 = (args[5] & 0xFFFF);	dty	 = (args[6] & 0xFFFF);	height	 = (args[7] & 0xFFFF);E 10I 10D 32	pbt        = (PILOTBBT *)Addr68k_from_LADDR( args[0] );D 25	srcbm	   = (BITMAP *)Addr68k_from_LADDR( args[1] );E 25I 25	srcebm	   = (BITMAP *)Addr68k_from_LADDR( args[1] );E 25D 16	sx 	   = (args[2] & 0xFFFF);E 16I 16	sx	   = (args[2] & 0xFFFF);E 16	sty	   = (args[3] & 0xFFFF);	destbm	   = (BITMAP *)Addr68k_from_LADDR( args[4] );	dx	   = (args[5] & 0xFFFF);	dty	   = (args[6] & 0xFFFF);E 10	sourcetype = ( args[8] == NIL_PTR ? INPUT_atom : args[8] );D 10	operation = ( args[9] == NIL_PTR ? REPLACE_atom : args[9] );	texture = args[10];	wxoffset = ( args[11] == NIL_PTR ? 0 : args[11] & 0xFFFF );	wyoffset = ( args[12] == NIL_PTR ? 0 : args[12] & 0xFFFF );E 10I 10	operation  = ( args[9] == NIL_PTR ? REPLACE_atom : args[9] );E 32E 10I 32/************************************************************************//*									*//*			   b i t b l t s u b				*//*									*//*	Implements the lisp function \BITBLTSUB, which is where		*//*	all BITBLT & BLTSHADE calls bottom out.  This is distinct	*//*	from the PILOTBITBLT opcode, which is implemented in bitblt.c.	*//*									*//*									*//*	args[0] :	PILOTBBT					*//*	args[1] :	SOURCEBITMAP					*//*	args[2] :	SLX (SourceLeftX)		sx		*//*	args[3] :	STY (SourceTopY)		sty		*//*	args[4] :	DESTINATIONBITMAP				*//*	args[5] :	DLX (DestinationLeftX)		dx		*//*	args[6] :	DTY (DestinationTopY)		dty		*//*	args[7] :	HEIGHT						*//*	args[8] :	SourceType					*//*	args[9] :	Operation					*//*	args[10] :	Texture						*//*	args[11] :	WindowXOffset					*//*	args[12] :	WindowYOffset					*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 32D 16	E 16I 16E 16D 32/****start*****/E 32I 32bitbltsub( argv ) LispPTR	*argv;  {    int	sourcetype, operation;    int	sty, dty, texture, wxoffset, wyoffset;    int h, w;    int displayflg = 0, desthi;    int backwardflg = 0, sx, dx, srcbpl, dstbpl, src_comp, op;    register DLword *srcbase, *dstbase;    int gray = 0, num_gray = 0, curr_gray_line = 0;    DLword grayword[4];E 32D 10	mpr_mdlinebytes                            (DestPixRect) = destbm->bmrasterwidth << 1;	destaddr = (short *)			 Addr68k_from_LADDR( ADDBASE( destbm->bmbase, 							    destbm->bmrasterwidth * dty));	(mpr_d(DestPixRect))->md_image = destaddr;	DestPixRect->pr_height = h = pbt->pbtheight;	DestPixRect->pr_width = destbpl = destbm->bmrasterwidth << 4;D 4D 3 	displayflg = cursorin2(GetHiWord(destbm->bmbase),dlx, (w=pbt->pbtwidth), h, dty); E 3I 3 	displayflg = CURSORINP2(GetHiWord(destbm->bmbase),dlx, (w=pbt->pbtwidth), h, dty); E 4I 4	w=pbt->pbtwidth; 	displayflg = CURSORINP2(GetHiWord(destbm->bmbase),dlx, (w), h, dty); E 4E 3/**** for DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG *****//*	displayflg = T;					*//**** for DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG *****/E 10I 10D 16	w = pbt->pbtwidth;		h = pbt->pbtheight;		  if ((h <= 0) || (w <= 0)) return(0);	E 16I 16D 32	w = pbt->pbtwidth;	h = pbt->pbtheight;	  if ((h <= 0) || (w <= 0)) return(0);E 16	src_comp = bbsrc_type(sourcetype, operation);	op = bbop(sourcetype, operation);E 32I 32    { /* Initialization code, in a block so it optimizes independently */      register LispPTR *args = argv;      register PILOTBBT *pbt;      register BITMAP *srcebm, *destbm;      BITMAP *texture68k;      register DLword *base;I 35#ifdef INIT      init_kbd_startup;#endifE 35      pbt        = (PILOTBBT *)Addr68k_from_LADDR( args[0] );      srcebm	   = (BITMAP *)Addr68k_from_LADDR( args[1] );      sx	   = (args[2] & 0xFFFF);      sty	   = (args[3] & 0xFFFF);      destbm	   = (BITMAP *)Addr68k_from_LADDR( args[4] );      dx	   = (args[5] & 0xFFFF);      dty	   = (args[6] & 0xFFFF);      sourcetype = ( args[8] == NIL_PTR ? INPUT_atom : args[8] );      operation  = ( args[9] == NIL_PTR ? REPLACE_atom : args[9] );E 32E 10I 10D 32	dstbpl = destbm->bmrasterwidth << 4;E 32I 32      w = pbt->pbtwidth;      h = pbt->pbtheight;      if ((h <= 0) || (w <= 0)) return(0);      src_comp = bbsrc_type(sourcetype, operation);      op = bbop(sourcetype, operation);E 32E 10D 32	if( sourcetype == TEXTURE_atom ){D 10		slx = ((wxoffset) ? (dlx - wxoffset) : dlx) % BITSPERWORD;		if(IsNumber(texture)){			if( (texture &= 0xffff) == 0){E 10I 10	    texture = args[10];	    wxoffset = ( args[11] == NIL_PTR ? 0 : args[11] & 0xFFFF );	    wyoffset = ( args[12] == NIL_PTR ? 0 : args[12] & 0xFFFF );	    sx = ((wxoffset) ? (dx - wxoffset) : dx) % BITSPERWORD;	    dstbase = (DLword *)E 32I 32      dstbpl = destbm->bmrasterwidth << 4;      if( sourcetype == TEXTURE_atom )	{	  texture = args[10];	  wxoffset = ( args[11] == NIL_PTR ? 0 : args[11] & 0xFFFF );	  wyoffset = ( args[12] == NIL_PTR ? 0 : args[12] & 0xFFFF );	  sx = ((wxoffset) ? (dx - wxoffset) : dx) % BITSPERWORD;	  dstbase = (DLword *)E 32D 16	      Addr68k_from_LADDR( ADDBASE( destbm->bmbase, E 16I 16	      Addr68k_from_LADDR( ADDBASE( destbm->bmbase,E 16	       destbm->bmrasterwidth * dty));D 32	    gray = 1;	    if(IsNumber(texture)){		if( (texture &= 0xffff) == 0){E 10				/* White Shade */D 10				if(operation == REPLACE_atom){					pix_op = PIX_CLR;D 2					goto clear;E 2I 2					goto clear_or_set;E 2				}D 2			/*	SrcPixRect = BlackTexturePixRect;	*/				sourcetype = INVERT_atom;				goto black;E 2I 2				goto white;E 2			}			else if(texture == 0xffff){E 10I 10		    grayword[0] = 0;		    srcbase = &grayword[0];		    num_gray = 1;		    curr_gray_line = 0;		    goto do_it_now;E 32I 32	  gray = 1;	  if (texture == NIL_PTR)	    { /* White Shade */	      grayword[0] = 0;	      srcbase = &grayword[0];	      num_gray = 1;	      curr_gray_line = 0;	      goto do_it_now;	    }	  else if(IsNumber(texture))	    {	      if( (texture &= 0xffff) == 0)		{ /* White Shade */		  grayword[0] = 0;		  srcbase = &grayword[0];		  num_gray = 1;		  curr_gray_line = 0;		  goto do_it_now;E 32		}D 32		else if(texture == 0xffff){E 10				/* Black Shade */D 10				if(operation == REPLACE_atom){					pix_op = PIX_SET;D 2					goto clear;E 2I 2					goto clear_or_set;E 2				}D 2			/*	SrcPixRect = BlackTexturePixRect;	*/				goto black;E 2I 2				goto black_or_white;E 2			}			else{ /* 4x4 */				TexturePixRect->pr_width = 16;					TexturePixRect->pr_height = h = 4;				base = (short *)((mpr_d(TexturePixRect))->md_image);				*base++ = Expand4Bit(((texture >> 12) & 0xf));				*base++ = Expand4Bit(((texture >> 8) & 0xf));				*base++ = Expand4Bit(((texture >> 4) & 0xf));				*base++ = Expand4Bit((texture & 0xf));				bptgrayoffset = (dty + wyoffset) % 4;D 2				goto next;E 2I 2								if(displayflg )					HideCursor;				pix_op = PixOperationLisp(sourcetype,operation);				pr_replrop( DestPixRect, dlx, 0, w, height, pix_op, 					    TexturePixRect, slx, bptgrayoffset);				if(displayflg )					ShowCursor;				return(0);E 2			}D 2		clear:	/* texture is Black Shade or White Shade, and operation is REPLACEE 2I 2		clear_or_set:				/* texture is Black Shade or White Shade, and operation is REPLACEE 2			 * all bits in DestinationBitmap are set or clear.			 */			if(displayflg )				HideCursor;			if(pr_rop( DestPixRect, dlx, 0, 				   pbt->pbtwidth, h, pix_op, 				   DestPixRect, dlx, 0) != 0)				error("pilotbitblt: pr_rop failed\n");			if(displayflg )				ShowCursor;			return(0);D 2		black:	/* texture is Black Shade or White Shade,E 2I 2		black_or_white:				/* texture is Black Shade or White Shade,E 2			 * use BlackTexturePixRect as source			 */			if(displayflg )				HideCursor;			pix_op = PixOperationLisp( sourcetype, operation );			pr_replrop( DestPixRect, dlx, 0, w, h, pix_op,				    BlackTexturePixRect, 0, 0);			if(displayflg )				ShowCursor;			return(0);I 2		white:			/* texture is White Shade,			 * use WhiteTexturePixRect as source			 */			if(displayflg )				HideCursor;			pix_op = PixOperationLisp( sourcetype, operation );			pr_replrop( DestPixRect, dlx, 0, w, h, pix_op,				    WhiteTexturePixRect, 0, 0);			if(displayflg )				ShowCursor;			return(0);E 10I 10		    grayword[0] = 0xFFFF;		    srcbase = &grayword[0];		    num_gray = 1;		    curr_gray_line = 0;		    goto do_it_now;E 32I 32	      else if(texture == 0xffff)		{ /* Black Shade */		  grayword[0] = 0xFFFF;		  srcbase = &grayword[0];		  num_gray = 1;		  curr_gray_line = 0;		  goto do_it_now;E 32E 10E 2		}D 10		else{		/* A bitmap that is 16 bits wide. */			texture68k = (BITMAP *)Addr68k_from_LADDR(texture);			bptgrayoffset = (dty + wyoffset) 				% min( texture68k->bmheight, 16);D 2			(mpr_d(TexturePixRect))->md_image =E 2I 2			(mpr_d(SrcPixRect))->md_image =E 2						(short *)Addr68k_from_LADDR(texture68k->bmbase);D 2			TexturePixRect->pr_width = 16;				TexturePixRect->pr_height = (h = texture68k->bmheight) > 16 ?E 2I 2			SrcPixRect->pr_width = 16;				mpr_mdlinebytes(SrcPixRect) = 2;			SrcPixRect->pr_height = (h = texture68k->bmheight) > 16 ?E 2							16 : h;I 2			if(displayflg )				HideCursor;			pix_op = PixOperationLisp( sourcetype, operation );			pr_replrop( DestPixRect, dlx, 0, w, height, pix_op,				    SrcPixRect, slx, bptgrayoffset);			if(displayflg )				ShowCursor;			return(0);E 10I 10D 32		else{ /* 4x4 */		    srcbase = base = (DLword *)(&grayword[0]);D 26		    *base++ = Expand4Bit(((texture >> 12) & 0xf));D 25		    *base++ = Expand4Bit(((texture >> 8) & 0xf));		    *base++ = Expand4Bit(((texture >> 4) & 0xf));E 25I 25		    *base++ = Expand4Bit(((texture >>  8) & 0xf));		    *base++ = Expand4Bit(((texture >>  4) & 0xf));E 25		    *base++ = Expand4Bit((texture & 0xf));E 26I 26		    GETWORD(base++) = Expand4Bit(((texture >> 12) & 0xf));		    GETWORD(base++) = Expand4Bit(((texture >>  8) & 0xf));		    GETWORD(base++) = Expand4Bit(((texture >>  4) & 0xf));		    GETWORD(base++) = Expand4Bit((texture & 0xf));E 26		    num_gray = 4;		    curr_gray_line = (dty + wyoffset) & 3;		    srcbase += curr_gray_line;		    goto do_it_now;E 32I 32	      else		{ /* 4x4 */		  srcbase = base = (DLword *)(&grayword[0]);		  GETWORD(base++) = Expand4Bit(((texture >> 12) & 0xf));		  GETWORD(base++) = Expand4Bit(((texture >>  8) & 0xf));		  GETWORD(base++) = Expand4Bit(((texture >>  4) & 0xf));		  GETWORD(base++) = Expand4Bit((texture & 0xf));		  num_gray = 4;		  curr_gray_line = (dty + wyoffset) & 3;		  srcbase += curr_gray_line;		  goto do_it_now;E 32E 10D 16E 16E 2		}I 10	    }D 32	    else{		/* A bitmap that is 16 bits wide. */		texture68k = (BITMAP *)Addr68k_from_LADDR(texture);		srcbase = (DLword *)Addr68k_from_LADDR(texture68k->bmbase);		num_gray = min( texture68k->bmheight, 16);		curr_gray_line = (dty + wyoffset) % num_gray;		srcbase += curr_gray_line;		goto do_it_now;E 32I 32	  else	    { /* A bitmap that is 16 bits wide. */	      texture68k = (BITMAP *)Addr68k_from_LADDR(texture);	      srcbase = (DLword *)Addr68k_from_LADDR(texture68k->bmbase);	      num_gray = min( texture68k->bmheight, 16);	      curr_gray_line = (dty + wyoffset) % num_gray;	      srcbase += curr_gray_line;	      goto do_it_now;E 32	    }E 10D 2	next:	/* code that actually bitblt by pirect lib.	*/		if(displayflg )			HideCursor;		pix_op = PixOperationLisp( sourcetype, operation );		pr_replrop( DestPixRect, dlx, 0, w, height, pix_op,				    TexturePixRect             , slx, bptgrayoffset);		if(displayflg )			ShowCursor;		return(0);E 2	}D 10	/*	else if( sourcetype == MERGE_atom )		(RETURN (RAID "Hard bitblt case")) 	*/	else{ /* ; INPUT or INVERT	*/		mpr_mdlinebytes(SrcPixRect) = srcbm->bmrasterwidth << 1;D 6		srcaddr = (unsigned short *)E 6I 6		srcaddr = ( short *)E 6			 Addr68k_from_LADDR( ADDBASE( srcbm->bmbase, 						      srcbm->bmrasterwidth * sty));		mpr_d(SrcPixRect)->md_image = srcaddr;		SrcPixRect->pr_height = h;		SrcPixRect->pr_width = sourcebpl = srcbm->bmrasterwidth << 4;E 10I 10D 32	/* ; INPUT or INVERT	*/D 25		srcbpl = srcbm->bmrasterwidth << 4;E 25I 25		srcbpl = srcebm->bmrasterwidth << 4;E 32I 32      /* ; INPUT or INVERT	*/      srcbpl = srcebm->bmrasterwidth << 4;E 32E 25E 10D 32		/* compute flags */D 10/*		if( (srcbm == destbm) && (sty <= dty + height ) )			pbtdisjointitems = T;		if( (srcbm == destbm) && ((sty != dty ) ||						 ((slx <  dlx) && (dlx < slx + pbt->pbtwidth)))){			pbtbackward = T;			if( sty != dty )				pbtdisjointitems = T;		}*/				if(srcbm != destbm)			/* pbtdisjoint = T	*/;		else if(sty > dty){			if(sty > (dty+height))				/* pbtdisjoint = T	*/;			else				pbtdisjointitems = T;		}		else if(dty > (sty+ height))			/* pbtdisjoint = T	*/;E 10I 10		/* out for nowD 25		if(srcbm == destbm)E 25I 25		if(srcebm == destbm)E 25		if(sty <= dty)		if(dty <= (sty + h))		if((sty != dty) || ((sx < dx) && (dx < (sx + w))))E 32I 32      /* compute flags */      /* out for now      if(srcebm == destbm)      if(sty <= dty)      if(dty <= (sty + h))      if((sty != dty) || ((sx < dx) && (dx < (sx + w))))E 32			backwardflg = T;D 32		out for now */		/* compute flags */D 25		if(srcbm != destbm);E 25I 25		if(srcebm != destbm);E 25		else if(sty > dty);		else if(dty > (sty + h));E 10		else if((sty != dty) ||D 10			((slx < dlx) && (dlx < slx + pbt->pbtwidth))){			pbtbackward = T;			if( sty != dty )				pbtdisjointitems = T;		}E 10I 10			((sx < dx) && (dx < (sx + w))))E 32I 32      out for now */      /* compute flags */      if(srcebm != destbm);      else if(sty > dty);      else if(dty > (sty + h));      else if((sty != dty) ||	      ((sx < dx) && (dx < (sx + w))))E 32			backwardflg = T;E 10D 10		pix_op = PixOperationLisp( sourcetype, operation );E 10I 10D 32	if (backwardflg)E 32I 32      if (backwardflg)E 32	{		srcbase = ( DLword *)D 16			Addr68k_from_LADDR( ADDBASE( srcbm->bmbase, E 16I 16D 25			Addr68k_from_LADDR( ADDBASE( srcbm->bmbase,E 16			   srcbm->bmrasterwidth * (sty + h - 1)));E 25I 25			Addr68k_from_LADDR( ADDBASE( srcebm->bmbase,			   srcebm->bmrasterwidth * (sty + h - 1)));E 25		dstbase = (DLword *)D 16			Addr68k_from_LADDR( ADDBASE( destbm->bmbase, E 16I 16			Addr68k_from_LADDR( ADDBASE( destbm->bmbase,E 16			   destbm->bmrasterwidth * (dty + h - 1)));		srcbpl = 0 - srcbpl;		dstbpl = 0 - dstbpl;	}D 32	elseE 32I 32      elseE 32	{		srcbase = (DLword  *)D 16			Addr68k_from_LADDR( ADDBASE( srcbm->bmbase, E 16I 16D 25			Addr68k_from_LADDR( ADDBASE( srcbm->bmbase,E 16			   srcbm->bmrasterwidth * sty));E 25I 25			Addr68k_from_LADDR( ADDBASE( srcebm->bmbase,			   srcebm->bmrasterwidth * sty));E 25		dstbase = (DLword *)D 16			Addr68k_from_LADDR( ADDBASE( destbm->bmbase, E 16I 16			Addr68k_from_LADDR( ADDBASE( destbm->bmbase,E 16			   destbm->bmrasterwidth * dty));	}E 10D 37E 37I 37#ifdef SUNDISPLAYE 37D 10		if(!displayflg)D 3			 displayflg = cursorin2(GetHiWord(srcbm->bmbase),slx, w, h, sty); E 3I 3			 displayflg = CURSORINP2(GetHiWord(srcbm->bmbase),slx, w, h, sty); E 3 		if(displayflg )			HideCursor;	      		if( pbtdisjointitems && pbtbackward ){			distance = abs(srcaddr - destaddr) / ((destbpl + 15) >> 4);			SrcPixRect->pr_height += distance;			if(pr_rop( SrcPixRect, dlx, distance,				   pbt->pbtwidth, h, pix_op, 				   SrcPixRect, slx, 0) != 0)				error("pilotbitblt: pr_rop failed\n");		}		else{			if(pr_rop( DestPixRect, dlx, 0, 				   pbt->pbtwidth, h, pix_op, 				   SrcPixRect, slx, 0) != 0)				error("pilotbitblt: pr_rop failed\n");		}		if(displayflg )			ShowCursor;E 10I 10D 16 	displayflg = cursorin((0xFFFF & (LADDR_from_68k(srcbase) >> 16)), 	    ((sx >> 4) + (0xFFFF & (LADDR_from_68k(srcbase)))), 	        w, h, backwardflg); E 16I 16D 21	displayflg = cursorin((0xFFFF & (LADDR_from_68k(srcbase) >> 16)),E 21I 21D 22	/*displayflg = cursorin((0xFFFF & (LADDR_from_68k(srcbase) >> 16)),E 22I 22D 32/*	displayflg = cursorin((0xFFFF & (LADDR_from_68k(srcbase) >> 16)),E 22E 21	    ((sx >> 4) + (0xFFFF & (LADDR_from_68k(srcbase)))),D 21	        w, h, backwardflg);E 21I 21D 22	       sx, w, h, backwardflg);*/	displayflg=n_new_cursorin(srcbase,sx,sty,w,h,backwardflg);E 22I 22	        w, h, backwardflg); */E 32D 25	displayflg=n_new_cursorin(srcbase,sx,sty,w,h); E 25I 25	displayflg=n_new_cursorin(srcbase,sx,sty,w,h);I 37#endif SUNDISPLAYE 37I 32    }E 32E 25E 22E 21E 16E 10D 10	}E 10I 10do_it_now:D 21	displayflg |= cursorin((0xFFFF & (LADDR_from_68k(dstbase) >> 16)),E 21I 21D 32	/*displayflg |= cursorin((0xFFFF & (LADDR_from_68k(dstbase) >> 16)),E 21	    ((dx >> 4) + (0xFFFF & (LADDR_from_68k(dstbase)))),D 21	        w, h, backwardflg);E 21I 21D 22	       dx, w, h, backwardflg); **/	displayflg |= n_new_cursorin(dstbase,dx,dty,w,h,backwardflg);E 22I 22D 25	        w, h, backwardflg); */ 	displayflg |= n_new_cursorin(dstbase,dx,dty,w,h); E 25I 25	        w, h, backwardflg); */E 32D 37	displayflg |= n_new_cursorin(dstbase,dx,dty,w,h);E 37E 25E 22E 21I 20	ScreenLocked=T;E 20I 37#ifdef SUNDISPLAY	displayflg |= n_new_cursorin(dstbase,dx,dty,w,h);E 37	if( displayflg ) HideCursor;I 37#endif SUNDISPLAYE 37D 32	new_bitblt_codeE 32I 32#ifdef NEWBITBLT	bitblt(srcbase, dstbase, sx, dx, w, h, srcbpl, dstbpl,		  backwardflg, src_comp, op, gray, num_gray, curr_gray_line);#else	new_bitblt_code;#endifI 37#ifdef SUNDISPLAYE 37E 32I 31#ifdef DISPLAYBUFFERI 42#ifdef COLOR	if( MonoOrColor == MONO_SCREEN )#endif COLORE 42	/* Copy the changed section of display bank to the frame buffer */	if (in_display_segment(dstbase))	  {D 32	DBPRINT(("bltsub: x %d, y %d, w %d, h %d.\n",dx, dty, w,h));	    flush_display_region(dx, dty, w, h);E 32I 32/*	DBPRINT(("bltsub: x %d, y %d, w %d, h %d.\n",dx, dty, w,h)); */	    flush_display_region(dx, dty, w, h); E 32	  }#endifE 31D 37E 37	if( displayflg) ShowCursor;I 37#endif SUNDISPLAY#ifdef XWINDOWI 50	SIGoff;E 50	if (in_display_segment(dstbase))D 50	    flush_display_region(dx, dty, w, h); 	E 50I 50	    flush_display_region(dx, dty, w, h);	XFlush(Xdisplay);	SIGon;E 50#endif XWINDOWE 37D 20E 20I 20	ScreenLocked=NIL;E 20E 10D 32}I 21D 31/* Max address for HI-RES DISPLAY */#define DISP_MAX_Address  (DisplayRegion68k + 1600*1280/8)E 21E 31I 21/* Cursor overlap check for bitbltsub */E 32I 31I 32} /* end of bitbltsub */E 32I 32E 32/************************************************************************//*									*//*			n _ n e w _ c u r s o r i n			*//*									*//*	Is the cursor over the spot we're about to change on the	*//*	screen?								*//*									*//*	This version takes a native address for the bitmap base,	*//*	plus x, y, width, and height for the intended change area.	*//*	Returns T if the cursor overlaps the intended change, NIL	*//*	otherwise.							*//*									*//************************************************************************/E 31I 23#ifndef COLORD 31/* For MONO ONLY */E 31I 25E 25E 23D 22n_new_cursorin(baseaddr,dx,dy,w,h,backwardflg)E 22I 22D 31n_new_cursorin(baseaddr,dx,dy,w,h)E 22register DLword *baseaddr;D 22register int dx,dy,w,h,backwardflg;E 22I 22register int dx,dy,w,h;E 22{extern DLword *DisplayRegion68k; if((DisplayRegion68k <= baseaddr) && (baseaddr <=DISP_MAX_Address)){E 31I 31	/********************************************************/	/*							*/	/*		Monochrome-only version			*/	/*							*/	/********************************************************/E 31D 22    if(backwardflg) dy -= h;E 22D 25    if((dx < MOUSEXR)&&(dx + w > MOUSEXL)&&(dy < MOUSEYH)&&(dy + h > MOUSEYL))E 25I 25D 31    if((dx < MOUSEXR)&&(dx + w > MOUSEXL) &&       (dy < MOUSEYH)&&(dy + h > MOUSEYL)    )E 25	return(T);D 25    else E 25I 25    elseE 25	return(NIL); }D 25 else E 25I 25 elseE 25	return(NIL);E 31I 31n_new_cursorin(baseaddr,dx,dy,w,h)  register DLword *baseaddr;  register int dx,dy,w,h;  {    extern DLword *DisplayRegion68k;I 35#ifdef INIT      init_kbd_startup; /* MUST START KBD FOR INIT BEFORE FIRST BITBLT */#endifE 35    if((DisplayRegion68k <= baseaddr) && (baseaddr <=DISP_MAX_Address))      {	if((dx < MOUSEXR)&&(dx + w > MOUSEXL) &&	   (dy < MOUSEYH)&&(dy + h > MOUSEYL)    ) return(T);	else return(NIL);      }    else return(NIL);E 31D 35}E 35I 35  }E 35I 23#elseI 31	/********************************************************/	/*							*/	/*		   Mono / color version			*/	/*							*/	/********************************************************/E 31E 23I 23D 31#define DLWORD_PERLINE	(DisplayWidth/16)#define HARD_CURSORWIDTH 16#define HARD_CURSORHEIGHT 16#define COLOR_BITSPER_PIXEL 8#define MONO_SCREEN 0#define COLOR_SCREEN 1#define COLOR_MAX_Address (ColorDisplayRegion68k + 1152 * 900)I 25E 31E 25n_new_cursorin(baseaddr,dx,dy,w,h)register DLword *baseaddr;register int dx,dy,w,h;{extern DLword *DisplayRegion68k,*ColorDisplayRegion68k;extern int MonoOrColor;I 35#ifdef INIT      init_kbd_startup; /* MUST START KBD FOR INIT BEFORE FIRST BITBLT */#endifE 35if(MonoOrColor == MONO_SCREEN){ /* in MONO screen */    if((DisplayRegion68k <= baseaddr) && (baseaddr <=DISP_MAX_Address)){D 25        if((dx < MOUSEXR)&&(dx + w > MOUSEXL)&&(dy < MOUSEYH)		&&(dy + h > MOUSEYL))E 25I 25        if((dx < MOUSEXR)&&(dx + w > MOUSEXL) &&	   (dy < MOUSEYH)&&(dy + h > MOUSEYL)    )E 25	 {   return(T);}D 25        else E 25I 25        elseE 25	 {   return(NIL);}     }D 25     else E 25I 25     elseE 25	return(NIL); } /* if for MONO end */else {/* in COLOR screen */    if((ColorDisplayRegion68k <= baseaddr) && (baseaddr <=COLOR_MAX_Address)){	dx = dx >> 3;	/*printf("new_c in COLOR mx=%d my=%d x=%d y=%d\n"	,*EmMouseX68K,*EmMouseY68K,dx,dy);*/        if((dx < MOUSEXR)&&(dx + w > MOUSEXL)&&(dy < MOUSEYH)		&&(dy + h > MOUSEYL))	 { /*  printf("new_c T\n");*/  return(T);}D 25        else E 25I 25        elseE 25	 {   return(NIL);}     }D 25     else E 25I 25     elseE 25	return(NIL); }}#endif COLORI 32I 45#define BITBLTBITMAP_argnum 14#define PUNT_TO_BITBLTBITMAP {\	if(BITBLTBITMAP_index==0xffffffff){				\	   BITBLTBITMAP_index=get_package_atom("\\PUNT.BITBLT.BITMAP",	\						19,"INTERLISP",9, NIL); \	   if(BITBLTBITMAP_index==0xffffffff)				\		{error("BITBLTBITMAP install failed");			\		return;}  }						\	CurrentStackPTR +=(BITBLTBITMAP_argnum-1)*DLWORDSPER_CELL;	\	ccfuncall(BITBLTBITMAP_index,BITBLTBITMAP_argnum,3);return;} LispPTR BITBLTBITMAP_index;E 45/************************************************************************//*									*//*			b i t b l t _ b i t m a p			*//*									*//*	C implementation of the Lisp function \BITBLT.BITMAP,		*//*	which does bitmap-to-bitmap cases of BITBLT, after BITBLT	*//*	does some setup and massaging first.				*//*									*//*	args[xx]: SourceBitmap						*//*	args[xx]: SourceLeft		Must be a SMALLPOSP		*//*	args[xx]: SourceBottom		Must be a SMALLPOSP		*//*	args[xx]: DestBitmap						*//*	args[xx]: DestLeft		Must be a SMALLPOSP		*//*	args[xx]: DestBottom		Must be a SMALLPOSP		*//*	args[xx]: Width			Must be a SMALLPOSP		*//*	args[xx]: height		Must be a SMALLPOSP		*//*	args[xx]: SourceType						*//*	args[xx]: Operation						*//*	args[xx]: Texture						*//*	args[xx]: ClippingRegion					*//*	args[xx]: ClippedSrcLeft	Must be a SMALLPOSP		*//*	args[xx]: ClippedSrcBottom	Must be a SMALLPOSP		*//*									*//*									*//*	SourceType must not be MERGE, which should be handled by	*//*	the lisp code in \BITBLT.BITMAP.				*/I 45D 47/*	This func. can't handle souecetype == MERGE case.		*/E 47I 47/*	This func. can't handle COLOR & souecetype == MERGE case.	*/E 47/* 	It causes punting to \\PUNT.BITBLT.BITMAP.			*//*	Therefore SYSOUT must contain \\PUNT.BITBLT.BITMAP.		*/E 45/*									*//************************************************************************/bitblt_bitmap(args)  LispPTR *args;  {    BITMAP *SourceBitmap, *DestBitmap;    int sleft, sbottom, dleft, dbottom, width, height, clipleft, clipbottom;    LispPTR clipreg, clipvalue;    int stodx, stody, right, top, destbits, sourcebits, left, bottom;    LispPTR sourcetype, operation, texture;    DLword *srcbase, *dstbase;    int dlx, dty, slx, sty, srcbpl, dstbpl, op, src_comp, backwardflg = 0,         displayflg = 0;I 45    extern DLword MERGE_atom;I 47/* Get arguments  and check the possibilities of PUNT */E 47E 45    SourceBitmap = (BITMAP *) Addr68k_from_LADDR(args[0]);D 47    N_GETNUMBER(args[1], sleft, bad_arg);    N_GETNUMBER(args[2], sbottom, bad_arg);E 47    DestBitmap = (BITMAP *) Addr68k_from_LADDR(args[3]);D 47    N_GETNUMBER(args[4], dleft, bad_arg);    N_GETNUMBER(args[5], dbottom, bad_arg);E 47I 47/* It does not handle COLOR ..... maybe later */    if(((destbits = DestBitmap->bmbitperpixel) != 1) ||       ((sourcebits = SourceBitmap->bmbitperpixel) != 1))    { PUNT_TO_BITBLTBITMAP; }E 47    sourcetype = args[8];I 45    /* sourcetype == MERGE_atom case must be handled in	Lisp func \\BITMAP.BITBLT */    if( sourcetype == MERGE_atom)    {  PUNT_TO_BITBLTBITMAP; }I 47    N_GETNUMBER(args[1], sleft, bad_arg);    N_GETNUMBER(args[2], sbottom, bad_arg);    N_GETNUMBER(args[4], dleft, bad_arg);    N_GETNUMBER(args[5], dbottom, bad_arg);E 47E 45    operation = args[9];    texture = args[10];    clipreg = args[11];    N_GETNUMBER(args[12], clipleft, bad_arg);    N_GETNUMBER(args[13], clipbottom, bad_arg);    top = DestBitmap->bmheight;D 47    destbits = DestBitmap->bmbitperpixel;E 47    left = bottom = 0;D 47    sourcebits = SourceBitmap->bmbitperpixel;E 47    right = DestBitmap->bmwidth;    if (clipreg != NIL_PTR)      { /* clip the BITBLT using the clipping region supplied */	register LispPTR clipvalue;	register int temp, cr_left, cr_bot;	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, cr_left, bad_arg);	left = max(left, cr_left);	clipreg = cdr(clipreg);	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, cr_bot, bad_arg);	bottom = max(bottom, cr_bot);	clipreg = cdr(clipreg);	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, temp, bad_arg);	right = min(right, cr_left+temp);	clipreg = cdr(clipreg);	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, temp, bad_arg);	top = min(top, cr_bot+temp);      }    left = max(left, dleft);    bottom = max(bottom, dbottom);    if (args[6] != NIL_PTR)      {	N_GETNUMBER(args[6], width, bad_arg);	right = min(right, dleft+width);      }    if (args[7] != NIL_PTR)      {	N_GETNUMBER(args[7], height, bad_arg);	top = min(top, dbottom+height);      }    stodx = dleft - sleft;    stody = dbottom - sbottom;D 43    left = max(clipleft, max(0, left - stodx));    bottom = max(clipbottom, max(0, bottom - stody));    right = min(SourceBitmap->bmwidth, min(right-stodx, clipleft+width));    top = min(SourceBitmap->bmheight, min(top-stody, clipbottom+height));E 43I 43    {      register int temp;      left = max(clipleft, max(0, left - stodx));      bottom = max(clipbottom, max(0, bottom - stody));      temp = SourceBitmap->bmwidth;      right = min(temp, min(right-stodx, clipleft+width));      temp = SourceBitmap->bmheight;      top = min(temp, min(top-stody, clipbottom+height));    }E 43    if ( (right <= left) || (top <= bottom) ) return(NIL);    /*** PUT SOURCETYPE MERGE special code HERE ***/I 45	/**** See avobe, earler in this code check 		souecetype and punting. *****/E 45    if (sourcebits == destbits)      { /* not 1-bit-per-pixel, so adjust limits by pixel size */	switch (sourcebits)	  {	    case 4:  left = left*4;D 45		     right - right*4;E 45I 45		     right = right*4;E 45		     stodx = stodx*4;		     /* Put color texture merge case here */		     break;	    case 8:  left = left*8;		     right = right*8;		     stodx = stodx*8;		     /* Put color texture merge case here */		     break;	    case 24: left = left*24;		     right = right*24;		     stodx = stodx*24;		     /* Put color texture merge case here */		     break;	  }      }    else      {/*	DBPRINT(("BITBLT between bitmaps of different sizes, unimplemented.")); */	return(NIL);       }    height = top - bottom;    width = right - left;    dty = DestBitmap->bmheight - (top + stody);    dlx = left + stodx;    sty = SourceBitmap->bmheight - top;    slx = left;    /*** Stolen from bitbltsub, to avoid the call overhead: ***/D 49      src_comp = bbsrc_type(sourcetype, operation);      op = bbop(sourcetype, operation);E 49I 49    src_comp = bbsrc_type(sourcetype, operation);    op = bbop(sourcetype, operation);E 49D 49      dstbpl = DestBitmap->bmrasterwidth << 4;E 49I 49    dstbpl = DestBitmap->bmrasterwidth << 4;E 49	      /* Sourcetype guaragneed not to be TEXTURE by BITBLT fn */D 49      srcbpl = SourceBitmap->bmrasterwidth << 4;E 49I 49    srcbpl = SourceBitmap->bmrasterwidth << 4;E 49      /* compute flags */D 49      if(SourceBitmap != DestBitmap);      else if(sty > dty);      else if(dty > (sty + height));      else if((sty != dty) ||	      ((slx < dlx) && (dlx < (slx + width))))			backwardflg = T;E 49I 49    if(SourceBitmap != DestBitmap);    else if(sty > dty);    else if(dty > (sty + height));    else if((sty != dty) || ((slx < dlx) && (dlx < (slx + width))))	    backwardflg = T;E 49D 49      if (backwardflg)	{		srcbase = ( DLword *)			Addr68k_from_LADDR( ADDBASE( SourceBitmap->bmbase,			   SourceBitmap->bmrasterwidth * (sty + height - 1)));		dstbase = (DLword *)			Addr68k_from_LADDR( ADDBASE( DestBitmap->bmbase,			   DestBitmap->bmrasterwidth * (dty + height - 1)));		srcbpl = 0 - srcbpl;		dstbpl = 0 - dstbpl;	}      else	{		srcbase = (DLword  *)			Addr68k_from_LADDR( ADDBASE( SourceBitmap->bmbase,			   SourceBitmap->bmrasterwidth * sty));		dstbase = (DLword *)			Addr68k_from_LADDR( ADDBASE( DestBitmap->bmbase,			   DestBitmap->bmrasterwidth * dty));	}E 49I 49    if (backwardflg)      {	srcbase = ( DLword *)		Addr68k_from_LADDR( ADDBASE( SourceBitmap->bmbase,		   SourceBitmap->bmrasterwidth * (sty + height - 1)));	dstbase = (DLword *)		Addr68k_from_LADDR( ADDBASE( DestBitmap->bmbase,		   DestBitmap->bmrasterwidth * (dty + height - 1)));	srcbpl = 0 - srcbpl;	dstbpl = 0 - dstbpl;      }    else      {	srcbase = (DLword  *)		Addr68k_from_LADDR( ADDBASE( SourceBitmap->bmbase,		   SourceBitmap->bmrasterwidth * sty));	dstbase = (DLword *)		Addr68k_from_LADDR( ADDBASE( DestBitmap->bmbase,		   DestBitmap->bmrasterwidth * dty));      }E 49D 49	displayflg=n_new_cursorin(srcbase,slx,sty,width,height);E 49I 49    displayflg=n_new_cursorin(srcbase,slx,sty,width,height);E 49do_it_now:D 37	displayflg |= n_new_cursorin(dstbase,dlx,dty,width,height);E 37D 49	ScreenLocked=T;E 49I 49    ScreenLocked=T;E 49I 37#ifdef SUNDISPLAYD 49	displayflg |= n_new_cursorin(dstbase,dlx,dty,width,height);E 37	if( displayflg ) HideCursor;E 49I 49    displayflg |= n_new_cursorin(dstbase,dlx,dty,width,height);    if( displayflg ) HideCursor;E 49I 37#endif  SUNDISPLAYE 37#ifdef NEWBITBLTD 49	bitblt(srcbase, dstbase, slx, dlx, width, height, srcbpl, dstbpl,		  backwardflg, src_comp, op, 0, 0, 0);E 49I 49    bitblt(srcbase, dstbase, slx, dlx, width, height, srcbpl, dstbpl,	      backwardflg, src_comp, op, 0, 0, 0);E 49#else#define gray 0I 35#define dx dlx#define sx slx#define w width#define h height#define curr_gray_line dx#define num_gray 0E 35D 33#define w width#define h height#define sx slx#define dx dlx#define curr_gray_line slx#define num_gray dlxE 33D 49	new_bitblt_code;E 49I 49    new_bitblt_code;E 49#undef grayI 35#undef dx#undef sx#undef w#undef h#undef curr_gray_line#undef num_grayE 35D 33#undef w#undef h#undef sx#undef dx#undef curr_gray_line#undef num_grayE 33#endifI 37#ifdef SUNDISPLAYE 37#ifdef DISPLAYBUFFERI 42#ifdef COLORD 49	if( MonoOrColor == MONO_SCREEN )E 49I 49    if( MonoOrColor == MONO_SCREEN )E 49#endif COLORE 42	/* Copy the changed section of display bank to the frame buffer */	if (in_display_segment(dstbase))D 49	  {E 49I 49      {E 49/*	DBPRINT(("bltsub: x %d, y %d, w %d, h %d.\n",dlx, dty, width,height));*/	    flush_display_region(dlx, dty, width, height);D 49	  }E 49I 49      }E 49#endifD 49	if( displayflg) ShowCursor;E 49I 49    if( displayflg) ShowCursor;E 49I 37#endif SUNDISPLAY#ifdef XWINDOWI 50    SIGoff;E 50D 49	if (in_display_segment(dstbase))E 49I 49    if (in_display_segment(dstbase))E 49	    flush_display_region(dlx, dty, width, height);I 50    XFlush(Xdisplay);    SIGon;E 50#endif XWINDOWE 37D 49	ScreenLocked=NIL;E 49I 49    ScreenLocked=NIL;E 49I 49    return(ATOM_T);E 49 bad_arg:  return(NIL);  } /* end of bitblt_bitmap */I 45#define BLTSHADEBITMAP_argnum 8#define PUNT_TO_BLTSHADEBITMAP {\	if(BLTSHADEBITMAP_index==0xffffffff){				\	   BLTSHADEBITMAP_index=get_package_atom("\\PUNT.BLTSHADE.BITMAP"\				,21,"INTERLISP",9, NIL);		\	   if(BLTSHADEBITMAP_index==0xffffffff)				\		{error("BLTSHADEBITMAP install failed");		\		return;}  }						\	CurrentStackPTR +=(BLTSHADEBITMAP_argnum-1)*DLWORDSPER_CELL;	\	ccfuncall(BLTSHADEBITMAP_index,BLTSHADEBITMAP_argnum,3);return;}E 45I 45 LispPTR BLTSHADEBITMAP_index;E 45/************************************************************************//*									*//*		    b i t s h a d e _ b i t m a p			*//*									*//*	C implementation of the Lisp function \BITSHADE.BITMAP,		*//*	which does bitmap-to-bitmap cases of BITSHADE, after BITSHADE	*//*	does some setup and massaging first.				*/I 45/*	This func. can't handle TEXTURE == LISTP or LITATOM case.	*//* 	It causes punting to \\PUNT.BLTSHADE.BITMAP.			*//*	Therefore SYSOUT must contain \\PUNT.BLTSHADE.BITMAP.		*/E 45/*									*//*	args[0]: Texture						*//*	args[1]: DestBitmap						*//*	args[2]: DestLeft		Must be a SMALLPOSP		*//*	args[3]: DestBottom		Must be a SMALLPOSP		*//*	args[4]: Width			Must be a SMALLPOSP		*//*	args[5]: height			Must be a SMALLPOSP		*//*	args[6]: Operation						*//*	args[7]: ClippingRegion						*//*									*//*	The numeric arguments are assumed to be SMALLPOSPs;		*//*	the result with anything else isn't guaranteed correct.		*/I 47/*	 This Func should punt if TEXTURE==LITATOM(NOT NIL) or LISTP	*//*		or DestBitmap's BPP !=1					*/E 47/*									*//*									*//************************************************************************/bitshade_bitmap(args)  LispPTR *args;  {    BITMAP *DestBitmap, *texture68k;    int dleft, dbottom, width, height, clipleft, clipbottom;    LispPTR clipreg;    int right, top, destbits, left, bottom, textureword;    LispPTR sourcetype, operation, texture;    DLword *srcbase, *dstbase, *base;    int dlx, dty, slx, sty, dstbpl, op, src_comp,          displayflg = 0;    int rasterwidth;    int num_gray, curr_gray_line;    DLword grayword[4];    texture = args[0];I 45    {register temp;	temp = GetTypeNumber(texture);	if (((temp== TYPE_LITATOM)&&(texture != NIL_PTR))||	     (temp == TYPE_LISTP))	{ PUNT_TO_BLTSHADEBITMAP;}    }E 45    DestBitmap = (BITMAP *) Addr68k_from_LADDR(args[1]);I 47    if((destbits = DestBitmap->bmbitperpixel) != 1)	{ PUNT_TO_BLTSHADEBITMAP;}E 47    N_GETNUMBER(args[2], dleft, bad_arg);    N_GETNUMBER(args[3], dbottom, bad_arg);    operation = args[6];    clipreg = args[7];    rasterwidth = DestBitmap->bmrasterwidth;    top = DestBitmap->bmheight;D 47    destbits = DestBitmap->bmbitperpixel;E 47    left = bottom = 0;    right = DestBitmap->bmwidth;D 48    DBPRINT(("BLTSHADE:  dleft %d, dbottom %d, width %d, hgt %d,", dleft, dbottom, width, height));    DBPRINT((" texture 0x%x, clipreg 0x%x, top %d, right %d.\n", texture, clipreg, top, right));E 48    if (clipreg != NIL_PTR)      { /* clip the BITBLT using the clipping region supplied */	register LispPTR clipvalue;	register int temp, cr_left, cr_bot;	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, cr_left, bad_arg);	left = max(left, cr_left);	clipreg = cdr(clipreg);	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, cr_bot, bad_arg);	bottom = max(bottom, cr_bot);	clipreg = cdr(clipreg);	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, temp, bad_arg);	right = min(right, cr_left+temp);	clipreg = cdr(clipreg);	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, temp, bad_arg);	top = min(top, cr_bot+temp);      }    left = max(left, dleft);    bottom = max(bottom, dbottom);    if (args[4] != NIL_PTR)      {	N_GETNUMBER(args[4], width, bad_arg);	right = min(right, dleft+width);      }    if (args[5] != NIL_PTR)      {	N_GETNUMBER(args[5], height, bad_arg);	top = min(top, dbottom+height);      }    if ( (right <= left) || (top <= bottom) ) return(NIL);    height = top - bottom;    width = right - left;    dty = DestBitmap->bmheight - top;    if ( (dty < 0) || ((dty+height) > DestBitmap->bmheight)) error("dty bad.");    if ( (bottom < 0) ) error("bottom bad.");    if ((bottom > 2048)) error ("bottom suspicious");        /*** Stolen from bitbltsub, to avoid the call overhead: ***/      src_comp = bbsrc_type(0, operation);      op = bbop(0, operation);      dstbpl = rasterwidth << 4;    if ( (left < 0) || (right > dstbpl) ) error ("left/right bad.");	      slx = left % BITSPERWORD;D 48    DBPRINT(("BLTSHADE later:  height %d, width %d, dty %d, slx %d.\n\n", height, width, dty, slx));E 48      dstbase = (DLword *)	      Addr68k_from_LADDR( ADDBASE( DestBitmap->bmbase,	       (rasterwidth * dty)));D 36	  if (texture == NIL_PTR)	    { /* White Shade */	      grayword[0] = 0;	      srcbase = &grayword[0];	      num_gray = 1;	      curr_gray_line = 0;	      goto do_it_now;	    }E 36I 36	  if (GetTypeNumber(texture) == TYPE_LITATOM){		if(texture == NIL_PTR)	    	{ /* White Shade */	      	grayword[0] = 0;	      	srcbase = &grayword[0];	      	num_gray = 1;	      	curr_gray_line = 0;	      	goto do_it_now;	    	}		/* temp DEBUFG stuff */D 45		else { print(texture); error("Just stop");}E 45I 45		else { print(texture); error("Should not!");}E 45	}E 36      else if(IsNumber(texture))	{	  if( (texture &= 0xffff) == 0)	    { /* White Shade */	      grayword[0] = 0;	      srcbase = &grayword[0];	      num_gray = 1;	      curr_gray_line = 0;	    }	      else if(texture == 0xffff)	    { /* Black Shade */	      grayword[0] = 0xFFFF;	      srcbase = &grayword[0];	      num_gray = 1;	      curr_gray_line = 0;	    }	      else	    { /* 4x4 */	      srcbase = base = (DLword *)(&grayword[0]);	      GETWORD(base++) = Expand4Bit(((texture >> 12) & 0xf));	      GETWORD(base++) = Expand4Bit(((texture >>  8) & 0xf));	      GETWORD(base++) = Expand4Bit(((texture >>  4) & 0xf));	      GETWORD(base++) = Expand4Bit((texture & 0xf));	      num_gray = 4;	      curr_gray_line = (dty) & 3;	      srcbase += curr_gray_line;	    }	}      else	/**** Need to handle texture = listp case, too ***/I 45	/* Listp case alway punt to LISP */E 45	{ /* A bitmap that is 16 bits wide. */	  texture68k = (BITMAP *)Addr68k_from_LADDR(texture);	  srcbase = (DLword *)Addr68k_from_LADDR(texture68k->bmbase);	  num_gray = min( texture68k->bmheight, 16);	  curr_gray_line = (dty) % num_gray;	  srcbase += curr_gray_line;	}do_it_now:D 37	displayflg |= n_new_cursorin(dstbase,left,dty,width,height);E 37	ScreenLocked=T;I 37#ifdef SUNDISPLAY	displayflg |= n_new_cursorin(dstbase,left,dty,width,height);E 37	if( displayflg ) HideCursor;I 37#endif SUNDISPLAYE 37#ifdef NEWBITBLT	bitblt(srcbase, dstbase, slx, left, width, height, 0, dstbpl,		  0, src_comp, op, 1, num_gray, curr_gray_line);#else#define gray 1#define backwardflg 0#define srcbpl 0#define w width#define h height#define dx left#define sx slx	new_bitblt_code;#undef gray#undef backwardflg#undef srcbpl#undef w#undef h#undef dx#undef sx#endifI 37#ifdef SUNDISPLAYE 37#ifdef DISPLAYBUFFERI 42#ifdef COLOR	if( MonoOrColor == MONO_SCREEN )#endif COLORE 42	/* Copy the changed section of display bank to the frame buffer */	if (in_display_segment(dstbase))	  {/*	DBPRINT(("bltsub: x %d, y %d, w %d, h %d.\n",left, dty, width,height));*/	    flush_display_region(left, dty, width, height);	  }#endifD 37E 37	if( displayflg) ShowCursor;I 37#endif  SUNDISPLAY#ifdef XWINDOWD 50	if (in_display_segment(dstbase))	    flush_display_region(left, dty, width, height);E 50I 50    SIGoff;    if (in_display_segment(dstbase))      flush_display_region(left, dty, width, height);    XFlush(Xdisplay);    SIGon;E 50#endif XWINDOWE 37	ScreenLocked=NIL;I 49    return(ATOM_T);E 49 bad_arg:  return(NIL);  } /* end of bitshade_bitmap */E 32E 23E 21/*D 16 *	E 16 *I 16 *E 16 ********	BLTCHAR	BLTCHAR	BLTCHAR	BLTCHAR	********* * *//** \BLTCHAR ****D 16(freplace (PILOTBBT PBTDESTBIT) of LOCAL1 with LEFT) (freplace (PILOTBBT PBTWIDTH) of LOCAL1 with (IDIFFERENCE RIGHT LEFT)) (freplace (PILOTBBT PBTSOURCEBIT) of LOCAL1 with 	(IDIFFERENCE 		(IPLUS (\GETBASE 				(ffetch (\DISPLAYDATA DDOFFSETSCACHE) of DISPLAYDATA) E 16I 16(freplace (PILOTBBT PBTDESTBIT) of LOCAL1 with LEFT)(freplace (PILOTBBT PBTWIDTH) of LOCAL1 with (IDIFFERENCE RIGHT LEFT))(freplace (PILOTBBT PBTSOURCEBIT) of LOCAL1 withD 25	(IDIFFERENCE		(IPLUS (\GETBASE				(ffetch (\DISPLAYDATA DDOFFSETSCACHE) of DISPLAYDATA)E 16				CHAR8CODE)			  LEFT)D 16		CURX)) E 16I 16		CURX))E 25I 25    (IDIFFERENCE	(IPLUS (\GETBASE		    (ffetch (\DISPLAYDATA DDOFFSETSCACHE) of DISPLAYDATA)		    CHAR8CODE)	        LEFT)	CURX))E 25E 16(\PILOTBITBLT LOCAL1 0)*********/D 39#ifdef GETBASE#undef GETBASE#endifE 39D 39#define GETBASE(ptr,off)                (*((DLword *)(ptr) + (off)))E 39I 3D 28typedef  struct {E 28I 28#ifndef BYTESWAPtypedef  struct  {E 28	unsigned nil1		: 8;	unsigned pilotbbt	: 24;	unsigned nil2		: 8;	unsigned displaydata	: 24;	unsigned nil3		: 16;	unsigned char8code	: 16;	unsigned nil4		: 16;	unsigned curx		: 16;	unsigned nil5		: 16;	unsigned left		: 16;	unsigned nil6		: 16;D 28	unsigned right		: 16; } BLTC;E 28I 28	unsigned right		: 16;  } BLTC;#elsetypedef  struct  {	unsigned pilotbbt	: 24;	unsigned nil1		: 8;	unsigned displaydata	: 24;	unsigned nil2		: 8;	unsigned char8code	: 16;	unsigned nil3		: 16;	unsigned curx		: 16;	unsigned nil4		: 16;	unsigned left		: 16;	unsigned nil5		: 16;	unsigned right		: 16;	unsigned nil6		: 16;  } BLTC;E 28D 16	I 14#ifdef notprropstyleE 16E 14I 28#endif BYTESWAPE 28I 16D 31#ifndef prropstyleE 31I 31/************************************************************************//*									*//*				b l t c h a r				*//*									*//*	BITBLT character images onto a display stream.			*//*									*//*									*//************************************************************************/#ifndef prropstyle	/********************************************************/	/*	       Non-PIXRECT version of the code		*/	/********************************************************/	E 31E 16D 14E 14E 3bltchar( args )D 3LispPTR	*args;	/*	args[0] :	PILOTBBTE 3I 3D 16register BLTC	*args;	E 16I 16register BLTC	*args;E 16		/*	args[0] :	PILOTBBTE 3		 *	args[1] :	DISPLAYDATA		 *	args[2] :	CHAR8CODE		 *	args[3] :	CURX		 *	args[4] :	LEFT		 *	args[5] :	RIGHT		 */{D 3	PILOTBBT  *pbt;	DISPLAYDATA	*dspdata;	int	char8code, curx, left, right;	short 	*srcaddr, *destaddr;	int 	x, h, y, displayflg, destbpl, sourcebpl, sourcebit, distance;E 3I 3	register PILOTBBT  *pbt;	register DISPLAYDATA	*dspdata;D 10	int 	x, y,  destbpl, sourcebpl, sourcebit, distance;E 10E 3	int	base;I 3	register int displayflg;E 3D 10	unsigned int pix_op;E 10D 10	E 10I 10	int w, h;	int backwardflg = 0, sx, dx, srcbpl, dstbpl, src_comp, op;	DLword *srcbase, *dstbase;	int gray = 0, num_gray = 0, curr_gray_line = 0;E 10D 3	pbt	  = (PILOTBBT *)Addr68k_from_LADDR( args[0] );	dspdata	  = (DISPLAYDATA *)Addr68k_from_LADDR( args[1] );	char8code = (args[2] & 0xFFFF);	curx	  = (args[3] & 0xFFFF);	left	  = (args[4] & 0xFFFF);	right	  = (args[5] & 0xFFFF);E 3I 3D 25	pbt	  = (PILOTBBT *)Addr68k_from_LADDR( args->pilotbbt );E 25I 25	pbt	  = (PILOTBBT *)   Addr68k_from_LADDR( args->pilotbbt );E 25	dspdata	  = (DISPLAYDATA *)Addr68k_from_LADDR( args->displaydata );E 3D 3	E 3I 3D 10	(mpr_d(SrcPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,E 10I 10	srcbase =(DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,E 10D 16						     pbt->pbtsourcelo)) ;E 16I 16						     pbt->pbtsourcelo));E 16E 3D 3	srcaddr = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,						     pbt->pbtsourcelo));	(mpr_d(SrcPixRect))->md_image = srcaddr;E 3I 3D 10	(mpr_d(DestPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, E 10I 10D 16	dstbase =(DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, E 10						      pbt->pbtdestlo )) ;E 16I 16	dstbase =(DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,						     pbt->pbtdestlo ));E 16E 3D 3	destaddr = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, 						      pbt->pbtdestlo ));	(mpr_d(DestPixRect))->md_image = destaddr;E 3D 10	SrcPixRect->pr_width = sourcebpl = abs( pbt->pbtsourcebpl );	DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );D 3	SrcPixRect->pr_height = DestPixRect->pr_height = h = pbt->pbtheight;E 3I 3	SrcPixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 3		mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;	mpr_mdlinebytes(SrcPixRect) = ( sourcebpl +7) >>3;	 E 10I 10	srcbpl = abs( pbt->pbtsourcebpl );	dstbpl = abs( pbt->pbtdestbpl );	h = pbt->pbtheight;	w = args->right - args->left;D 16	  if ((h <= 0) || (w <= 0)) return(0);	E 16I 16D 25	  if ((h <= 0) || (w <= 0)) return(0);E 25I 25	if ((h <= 0) || (w <= 0)) return(0);E 25E 16E 10D 3	base = GETBASE(Addr68k_from_LADDR(dspdata->ddoffsetscache), char8code);	sourcebit = base + left - curx;E 3I 3D 39	base = GETBASE(Addr68k_from_LADDR(dspdata->ddoffsetscache), args->char8code);E 39I 39	base = GETWORD( Addr68k_from_LADDR			(dspdata->ddoffsetscache + args->char8code));E 39D 10	sourcebit = base + args->left - args->curx ;E 10I 10D 16	sx = base + args->left - args->curx ;E 16I 16	sx = base + args->left - args->curx;E 16	dx = args->left;E 10E 3D 16 E 16I 16I 37#ifdef SUNDISPLAYE 37E 16	/* if displayflg != 0 then source or destination is DisplayBitMap	 * Now we consider about only destination	 */D 10	displayflg = cursorin(pbt->pbtdesthi, pbt->pbtdestlo,D 3 			      left, (right - left), h, y, pbt->pbtbackward); E 3I 3 			      args->left, (args->right - args->left), pbt->pbtheight, y, pbt->pbtbackward); E 10I 10D 16	displayflg = cursorin(pbt->pbtdesthi, (pbt->pbtdestlo + (args->left >> 4)), 			      (args->right - args->left), pbt->pbtheight, pbt->pbtbackward); E 16I 16	displayflg = cursorin(pbt->pbtdesthi,D 25				(pbt->pbtdestlo + (args->left >> 4)),D 21				(args->right - args->left),E 21I 21D 22				dx,(args->right - args->left),E 22I 22				(args->right - args->left),E 22E 21				pbt->pbtheight,				pbt->pbtbackward);E 25I 25			     (pbt->pbtdestlo + (args->left >> 4)),			     (args->right - args->left),			      pbt->pbtheight,			      pbt->pbtbackward);I 37#endif SUNDISPLAYE 37E 25E 16E 10E 3D 10/**** for DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG *****//*	displayflg = T;					*//**** for DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG *****/E 10I 10	op = pbt->pbtoperation;	src_comp = pbt->pbtsourcetype;E 10I 20	ScreenLocked=T;I 37#ifdef SUNDISPLAYE 37E 20D 10	pix_op = PixOperation( pbt->pbtsourcetype, pbt->pbtoperation );E 10	if( displayflg )		HideCursor;I 37#endif SUNDISPLAYE 37I 32#ifdef NEWBITBLT	bitblt(srcbase, dstbase, sx, dx, w, h, srcbpl, dstbpl,		  backwardflg, src_comp, op, gray, num_gray, curr_gray_line);#elseE 32D 20E 20D 3	if(pr_rop( DestPixRect, left, 0, 			   (right - left), h, pix_op, E 3I 3D 10	if(pr_rop( DestPixRect, args->left, 0, 			   (args->right - args->left),pbt->pbtheight , pix_op, E 3			   SrcPixRect, sourcebit, 0) != 0)		error("pilotbitblt: pr_rop failed\n");			E 10I 10	new_char_bitblt_codeI 32#endifI 37#ifdef SUNDISPLAYE 37E 32I 31#ifdef DISPLAYBUFFERI 42#ifdef COLOR    if( MonoOrColor == MONO_SCREEN )#endif COLORE 42    if (in_display_segment(dstbase))      {D 32	DBPRINT(("bltchar nopix:  x %d, y 0x%x, w %d, h %d.\n", dx, dstbase, w, h));E 32I 32D 50/*	DBPRINT(("bltchar nopix:  x %d, y 0x%x, w %d, h %d.\n", dx, dstbase, w, h)); */E 50E 32	flush_display_lineregion(dx,			     dstbase,			     w, h);      }#endifE 31D 20E 20E 10	if( displayflg )		ShowCursor;I 37#endif SUNDISPLAY#ifdef XWINDOWI 50    SIGoff;E 50    if (in_display_segment(dstbase))	flush_display_lineregion(dx, dstbase, w, h);I 50    SIGon;E 50#endif XWINDOWE 37I 20	ScreenLocked=NIL;D 25E 25E 20}I 14D 16#endif#ifdef prropstyleE 16I 16#else/* prropstyle */E 16bltchar( args )D 16register BLTC	*args;	E 16I 16register BLTC	*args;E 16		/*	args[0] :	PILOTBBT		 *	args[1] :	DISPLAYDATA		 *	args[2] :	CHAR8CODE		 *	args[3] :	CURX		 *	args[4] :	LEFT		 *	args[5] :	RIGHT		 */{	register PILOTBBT  *pbt;	register DISPLAYDATA	*dspdata;D 16	int 	x, y,  destbpl, sourcebpl, sourcebit, distance;E 16I 16D 25	int	x, y,  destbpl, sourcebpl, sourcebit, distance;E 25I 25	int	x, y,  destbpl, srcebpl, srcebit, distance;E 25E 16	int	base;	register int displayflg;	unsigned int pix_op;I 31	DLword *dstbase;E 31E 14D 10/* y is already known	*/D 6E 6I 6/*** OBSOLATEE 6int cursorin2( addrhi, x, w, h, y)D 6DLword	addrhi;		/* Lisp addr hi-word	*/E 6I 6DLword	addrhi;	E 6register int	x, w, h, y;{		if((addrhi != DISPALY_HI)&&(addrhi != DISPALY_HI+1))		return( NIL );E 10I 14D 16		pbt	  = (PILOTBBT *)Addr68k_from_LADDR( args->pilotbbt );E 16I 16D 25E 25	pbt	  = (PILOTBBT *)   Addr68k_from_LADDR( args->pilotbbt );E 16	dspdata	  = (DISPLAYDATA *)Addr68k_from_LADDR( args->displaydata );D 25	(mpr_d(SrcPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,D 16						     pbt->pbtsourcelo)) ;E 16I 16						     pbt->pbtsourcelo));E 25I 25	(mpr_d(SrcePixRect))->md_image =	 (short *)Addr68k_from_LADDR(VAG2( pbt->pbtsourcehi, pbt->pbtsourcelo));E 25E 16D 16	(mpr_d(DestPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, 						      pbt->pbtdestlo )) ;E 16I 16D 25	(mpr_d(DestPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,						      pbt->pbtdestlo ));E 25I 25D 31	(mpr_d(DestPixRect))->md_image =E 31I 31	dstbase = (mpr_d(DestPixRect))->md_image =E 31	 (short *)Addr68k_from_LADDR(VAG2( pbt->pbtdesthi,   pbt->pbtdestlo ));E 25E 16D 16	SrcPixRect->pr_width = sourcebpl = abs( pbt->pbtsourcebpl );	DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );E 16I 16D 25	SrcPixRect->pr_width  = sourcebpl = abs( pbt->pbtsourcebpl );	DestPixRect->pr_width = destbpl   = abs( pbt->pbtdestbpl );E 16	SrcPixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 25I 25	SrcePixRect->pr_width  = srcebpl = abs( pbt->pbtsourcebpl );	DestPixRect->pr_width  = destbpl = abs( pbt->pbtdestbpl );	SrcePixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 25D 16	E 16I 16I 28#ifdef I386	/* Need to take care of byte order, because display bank */	/* on the 386 is NOT bit reversed.... */	if (IN_DISPLAY_BANK(pbt->pbtsourcehi))	  mpr_d(SrcePixRect)->md_flags |= MP_I386;	 else mpr_d(SrcePixRect)->md_flags &= (~MP_I386);	if (IN_DISPLAY_BANK(pbt->pbtdesthi))	  mpr_d(DestPixRect)->md_flags |= MP_I386;	 else mpr_d(DestPixRect)->md_flags &= (~MP_I386);#endif I386E 28E 16	mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;D 16	mpr_mdlinebytes(SrcPixRect) = ( sourcebpl +7) >>3;	 E 16I 16D 25	mpr_mdlinebytes(SrcPixRect) = (sourcebpl +7) >> 3;E 25I 25	mpr_mdlinebytes(SrcePixRect) = (srcebpl + 7) >> 3;E 25E 16D 39	base = GETBASE(Addr68k_from_LADDR(dspdata->ddoffsetscache), args->char8code);E 39I 39	base = GETWORD( Addr68k_from_LADDR			(dspdata->ddoffsetscache + args->char8code));E 39D 16	sourcebit = base + args->left - args->curx ; E 16I 16D 25	sourcebit = base + args->left - args->curx;E 25I 25	srcebit = base + args->left - args->curx;E 25I 37#ifdef SUNDISPLAYE 37E 16	/* if displayflg != 0 then source or destination is DisplayBitMap	 * Now we consider about only destination	 */D 15	displayflg = cursorin(pbt->pbtdesthi, pbt->pbtdestlo,E 15I 15	displayflg = old_cursorin(pbt->pbtdesthi, pbt->pbtdestlo,E 15D 16 			      args->left, (args->right - args->left), pbt->pbtheight, y, pbt->pbtbackward); E 16I 16			args->left,			(args->right - args->left),			pbt->pbtheight, y, pbt->pbtbackward);I 37#endif SUNDISPLAYE 37E 16/**** for DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG *****//*	displayflg = T;					*//**** for DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG *****/	pix_op = PixOperation( pbt->pbtsourcetype, pbt->pbtoperation );I 20	ScreenLocked=T;I 37#ifdef SUNDISPLAYE 37E 20	if( displayflg )		HideCursor;I 37#endif SUNDISPLAYE 37D 20E 20D 16	if(pr_rop( DestPixRect, args->left, 0, 			   (args->right - args->left),pbt->pbtheight , pix_op, E 16I 16	if(pr_rop( DestPixRect, args->left, 0,			   (args->right - args->left),pbt->pbtheight, pix_op,E 16D 25			   SrcPixRect, sourcebit, 0) != 0)E 25I 25			   SrcePixRect, srcebit, 0) != 0)E 25		error("pilotbitblt: pr_rop failed\n");I 31I 37#ifdef SUNDISPLAYE 37#ifdef DISPLAYBUFFERI 42#ifdef COLOR	if( MonoOrColor == MONO_SCREEN )#endif COLORE 42	if (in_display_segment(dstbase))	  {D 32	    DBPRINT(("bltchar pix:  x %x, y %d, w %d, h %d.\n", args->left, dstbase, (args->right - args->left),pbt->pbtheight));E 32I 32/*	    DBPRINT(("bltchar pix:  x %x, y %d, w %d, h %d.\n", args->left, dstbase, (args->right - args->left),pbt->pbtheight)); */E 32	    flush_display_lineregion(args->left, dstbase, (args->right - args->left),pbt->pbtheight);	  }#endifE 31D 16			E 16I 16D 20E 20E 16	if( displayflg )		ShowCursor;I 37#endif SUNDISPLAY#ifdef XWINDOW	if (in_display_segment(dstbase))	    flush_display_lineregion(args->left, dstbase, (args->right - args->left),pbt->pbtheight);#endif XWINDOWE 37I 20	ScreenLocked=NIL;E 20}#endifE 14D 10	if((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))		return( T );	else 		return( NIL );I 6}*******OBSOLATE *****/E 10D 31/******************************************************************//*	NEW BLTCHAR*//******************************************************************/E 31I 31/************************************************************************//*									*//*			    n e w b l t c h a r				*//*									*//*	BITBLT character images onto a display stream.  This version	*//*	handles clipping in the C code, and checks for changes of	*//*	character set and hitting the right margin.  In either of	*//*	those cases, it punts to the old LISP code for BLTCHAR.	It	*//*	also punts if the display stream we're writing to isn't for	*//*	the top window on the screen's window stack.			*//*									*//************************************************************************/E 31I 31E 31#define BLTCHAR_argnum 3I 35#ifndef INITE 35D 7#define PUNT_TO_BLTCHAR { \E 7I 7D 31#define PUNT_TO_BLTCHAR {\I 29	if ((BLTCHAR_index==0)) \	  { \D 30	    BLTCHAR_index = get_package_atom("\\BLTCHAR",8,"INTERLISP",9, NIL); \E 30I 30	    BLTCHAR_index = get_package_atom("\\MAIKO.PUNTBLTCHAR",18,"INTERLISP",9, NIL); \E 30	    if (BLTCHAR_index == 0xffffffff) \		{error("TEDIT install failed");				\		return;}  						\	  } \E 29E 7D 16	CurrentStackPTR +=(BLTCHAR_argnum-1)*DLWORDSPER_CELL ; \E 16I 16	CurrentStackPTR +=(BLTCHAR_argnum-1)*DLWORDSPER_CELL; \E 16	ccfuncall(BLTCHAR_index,BLTCHAR_argnum,3);return;}E 31I 31#define PUNT_TO_BLTCHAR 						\  {									\    if ((BLTCHAR_index==0))						\      {									\	BLTCHAR_index = get_package_atom("\\MAIKO.PUNTBLTCHAR",18, 	\					 "INTERLISP",9, NIL);		\	if (BLTCHAR_index == 0xffffffff) 				\	  { 								\D 35	    error("TEDIT install failed");				\E 35I 35	    error("\\MAIKO.PUNTBLTCHAR install failed");		\E 35	    return;							\	  }  								\      } 								\    CurrentStackPTR +=(BLTCHAR_argnum-1)*DLWORDSPER_CELL;	 	\    ccfuncall(BLTCHAR_index,BLTCHAR_argnum,3); 				\    return; 								\  }I 35#else#define PUNT_TO_BLTCHAR 						\  { /* Version that is silent instead of erroring for init */		\    if ((BLTCHAR_index==0))						\      {									\	BLTCHAR_index = get_package_atom("\\MAIKO.PUNTBLTCHAR",18, 	\					 "INTERLISP",9, NIL);		\	if (BLTCHAR_index == 0xffffffff) 				\	  { 								\	 /*   error("\\MAIKO.PUNTBLTCHAR install failed");	*/	\	    return;							\	  }  								\      } 								\    CurrentStackPTR +=(BLTCHAR_argnum-1)*DLWORDSPER_CELL;	 	\    ccfuncall(BLTCHAR_index,BLTCHAR_argnum,3); 				\    return; 								\  }#endif INITE 35E 31I 13#define TEDIT_BLTCHAR_argnum 6#define PUNT_TO_TEDIT_BLTCHAR {\D 16	CurrentStackPTR +=(TEDIT_BLTCHAR_argnum-1)*DLWORDSPER_CELL ; \E 16I 16D 19	CurrentStackPTR +=(TEDIT_BLTCHAR_argnum-1)*DLWORDSPER_CELL; \E 19I 19D 25	if(TEDIT_BLTCHAR_index==0xFFFFFFFF){				\E 25I 25	if(TEDIT_BLTCHAR_index==0xffffffff){				\E 25	   TEDIT_BLTCHAR_index=get_package_atom("\\TEDIT.BLTCHAR",14,"INTERLISP",9, NIL); \	   if(TEDIT_BLTCHAR_index==0xffffffff)				\		{error("TEDIT install failed");				\		return;}  }						\D 25	CurrentStackPTR +=(TEDIT_BLTCHAR_argnum-1)*DLWORDSPER_CELL; 	\E 25I 25	CurrentStackPTR +=(TEDIT_BLTCHAR_argnum-1)*DLWORDSPER_CELL;	\E 25E 19E 16	ccfuncall(TEDIT_BLTCHAR_index,TEDIT_BLTCHAR_argnum,3);return;}E 13D 31typedef struct {	DLword	 nil;	unsigned charset	: 8;	unsigned char8code	: 8;	LispPTR displaystream;D 16 	LispPTR displaydata;E 16I 16	LispPTR displaydata;E 16} BLTARG;E 31I 7D 31E 31D 16#define FGetNum(ptr , place) { \	if(((ptr) & 0xff0000)== S_POSITIVE) {(place) = ((ptr) & 0xffff);}\E 16I 16#define FGetNum(ptr, place) { \	     if(((ptr) & 0xff0000)== S_POSITIVE) {(place) = ((ptr) & 0xffff);}\E 16	else if(((ptr) & 0xff0000)== S_NEGATIVE) {(place) = (int)((ptr)| 0xffff0000);}\	else {PUNT_TO_BLTCHAR;}}D 16#define FGetNum2(ptr , place) { \	if(((ptr) & 0xff0000)== S_POSITIVE) {(place) = ((ptr) & 0xffff);}\E 16I 16#define FGetNum2(ptr, place) { \	     if(((ptr) & 0xff0000)== S_POSITIVE) {(place) = ((ptr) & 0xffff);}\E 16	else if(((ptr) & 0xff0000)== S_NEGATIVE) {(place) = (int)((ptr)| 0xffff0000);}\	else {return(-1);}}E 7D 31LispPTR *TOPWDS68k;LispPTR BLTCHAR_index;I 13D 19LispPTR TEDIT_BLTCHAR_index;E 19I 19LispPTR TEDIT_BLTCHAR_index; /* if NIL ,TEDIT is not yet loaded */E 31I 31LispPTR *TOPWDS68k;		/* Top of window stack's DS */LispPTR BLTCHAR_index;		/* Atom # for \PUNTBLTCHAR punt fn */LispPTR TEDIT_BLTCHAR_index;	/* if NIL ,TEDIT is not yet loaded */E 31E 19E 13I 31	/****************************************/	/*					*/	/*	Arguments to NEWBLTCHAR		*/	/*					*/	/****************************************/D 35E 35I 35#ifndef BYTESWAPE 35typedef struct {	DLword	 nil;			/* Unused word */	unsigned charset	: 8;	/* High 8 bits of character code */	unsigned char8code	: 8;	/* Low 8 bits of character code  */	LispPTR displaystream;		/* The display stream to print on */	LispPTR displaydata;		/* The image data (margins, etc)  */} BLTARG;I 35#elsetypedef struct {	unsigned char8code	: 8;	/* Low 8 bits of character code  */	unsigned charset	: 8;	/* High 8 bits of character code */	DLword	 nil;			/* Unused word */	LispPTR displaystream;		/* The display stream to print on */	LispPTR displaydata;		/* The image data (margins, etc)  */} BLTARG;#endif BYTESWAPE 35D 35E 35E 31I 14D 16#ifdef notprropstyleE 16I 16#ifndef prropstyleE 16E 14D 31newbltchar(args)register BLTARG *args;D 16{ E 16I 16{E 16   register DISPLAYDATA *displaydata68k;E 31D 7   register LispPTR local1;E 7D 10   register int right,left,curx;   register  PILOTBBT *pbt;I 7   register int lmargin,rmargin,xoff;E 10I 10D 31	int right, left, curx;	PILOTBBT *pbt;	int lmargin, rmargin, xoff;	int base;	int h, w;	int displayflg;	int backwardflg = 0, sx, dx, srcbpl, dstbpl, src_comp, op;	DLword *srcbase, *dstbase;	int gray = 0, num_gray = 0, curr_gray_line = 0;E 31I 31/************************************************************************//*									*//*			    n e w b l t c h a r				*//*			   (non-PIXRECT version)			*//*									*//************************************************************************/E 31E 10E 7I 31newbltchar(args)  register BLTARG *args;  {    register DISPLAYDATA *displaydata68k;    int right, left, curx;    PILOTBBT *pbt;    int lmargin, rmargin, xoff;    int base;    int h, w;    int displayflg;    int backwardflg = 0, sx, dx, srcbpl, dstbpl, src_comp, op;    DLword *srcbase, *dstbase;    int gray = 0, num_gray = 0, curr_gray_line = 0;E 31D 31displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);E 31D 31if(displaydata68k->ddcharset != args->charset){E 31I 31    displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);D 39    if(displaydata68k->ddcharset != args->charset)E 39I 39    if((displaydata68k->ddcharset & 0xFFFF) != args->charset)E 39      {E 31I 7D 11	/* Currentry,this has BUG ,so I can't call it */E 7	/*if(changecharset_display(displaydata68k,args->charset) ==-1)*/E 11I 11D 12	if(changecharset_display(displaydata68k, args->charset) ==-1)E 12I 12D 13/* dew to AR10887 ***temp comment out ***//*	if(changecharset_display(displaydata68k, args->charset) ==-1)*/E 13I 13	/*if(changecharset_display(displaydata68k, args->charset) ==-1)*/E 13E 12E 11D 7		PUNT_TO_BLTCHAR;E 7I 7D 31		{PUNT_TO_BLTCHAR;}E 7E 6}E 31I 31D 38	{PUNT_TO_BLTCHAR;}E 38I 38	PUNT_TO_BLTCHAR;E 38      }E 31I 6D 31if(displaydata68k->ddslowprintingcase)	{PUNT_TO_BLTCHAR; /** \SLOWBLTCHAR--return;**/}E 31I 31    if(displaydata68k->ddslowprintingcase)      {	PUNT_TO_BLTCHAR; /** \SLOWBLTCHAR--return;**/      }E 31D 7curx=displaydata68k->ddxposition;E 7I 7D 31FGetNum(displaydata68k->ddxposition,curx);FGetNum(displaydata68k->ddrightmargin,rmargin);FGetNum(displaydata68k->ddleftmargin,lmargin);FGetNum(displaydata68k->ddxoffset,xoff);E 31I 31    FGetNum(displaydata68k->ddxposition,curx);    FGetNum(displaydata68k->ddrightmargin,rmargin);    FGetNum(displaydata68k->ddleftmargin,lmargin);    FGetNum(displaydata68k->ddxoffset,xoff);E 31E 7D 31right = curx + *((DLword*)Addr68k_from_LADDRD 16		(displaydata68k->ddcharimagewidths+ args->char8code)) ;E 16I 16		(displaydata68k->ddcharimagewidths+ args->char8code));E 31I 31D 35    right = curx + *((DLword*)Addr68k_from_LADDRE 35I 35    right = curx + GETWORD((DLword*)Addr68k_from_LADDRE 35		(displaydata68k->ddcharimagewidths + args->char8code));E 31E 16D 7if((right> displaydata68k->ddrightmargin)&&(curx >displaydata68k->ddleftmargin))E 7I 7D 8E 8D 31if((right> rmargin )&&(curx >lmargin))E 7	{PUNT_TO_BLTCHAR;}if(args->displaystream != *TOPWDS68k)	{PUNT_TO_BLTCHAR;}D 7 displaydata68k->ddxposition = curx + *(DLword*)Addr68k_from_LADDRE 7I 7{ register int  newpos; newpos = curx + *(DLword*)Addr68k_from_LADDRE 31I 31    if((right> rmargin )&&(curx >lmargin)) PUNT_TO_BLTCHAR;    if(args->displaystream != *TOPWDS68k) PUNT_TO_BLTCHAR;    {      register int  newpos;D 35      newpos = curx + *(DLword*)Addr68k_from_LADDRE 31E 7	(displaydata68k->ddwidthscache + args->char8code );E 35I 35      newpos = curx + GETWORD((DLword*)Addr68k_from_LADDR	(displaydata68k->ddwidthscache + args->char8code ));E 35I 8E 8D 7if( displaydata68k->ddxoffset_sign == SPOS_HI){	curx += (displaydata68k->ddxoffset)  ;	right +=(displaydata68k->ddxoffset)  ;E 7I 7D 31 if ((0 <= newpos) && (newpos < 65536))E 31I 31      if ((0 <= newpos) && (newpos < 65536))E 31D 16 	(LispPTR)(displaydata68k->ddxposition) =(LispPTR)(S_POSITIVE |newpos);E 16I 16D 40	(LispPTR)(displaydata68k->ddxposition) = (LispPTR)(S_POSITIVE | newpos);E 40I 40	(displaydata68k->ddxposition) = (LispPTR)(S_POSITIVE | newpos);E 40E 16D 31 else if(-65537 < newpos)E 31I 31      else if(-65537 < newpos)E 31D 40	(LispPTR)(displaydata68k->ddxposition) = (LispPTR)(S_NEGATIVE | (0xffff & newpos));E 40I 40	(displaydata68k->ddxposition) = (LispPTR)(S_NEGATIVE | (0xffff & newpos));E 40D 31 else {PUNT_TO_BLTCHAR;}E 7}E 31I 31      else {PUNT_TO_BLTCHAR;}    }E 31D 7else {	curx += (int)((displaydata68k->ddxoffset)|0xFFFF0000 ) ;	right +=(int)((displaydata68k->ddxoffset)|0xFFFF0000 ) ;}	 if(right > (local1= displaydata68k->ddclippingright ))	right=local1;E 7D 7if(curx > (local1= (displaydata68k->ddclippingleft)))E 7I 7D 10	curx += xoff  ;	right +=xoff  ;E 10I 10D 16	curx  += xoff  ;	right += xoff  ;E 16I 16D 31	curx  += xoff;	right += xoff;E 16E 10D 8 if(right > displaydata68k->ddclippingright)E 8I 8D 25 if(right > ((int)displaydata68k->ddclippingright))E 8	right=displaydata68k->ddclippingright;E 25I 25	if(right > (int)(displaydata68k->ddclippingright))E 31I 31    curx  += xoff;    right += xoff;    if(right > (int)(displaydata68k->ddclippingright))E 31		right =  displaydata68k->ddclippingright;E 25D 8if(curx >  displaydata68k->ddclippingleft)E 8I 8D 25if(curx >  (int)(displaydata68k->ddclippingleft))E 8E 7	left = curx;elseD 7	left = local1;E 7I 7	left = displaydata68k->ddclippingleft;E 25I 25D 31	if(curx >  (int)(displaydata68k->ddclippingleft))E 31I 31    if(curx >  (int)(displaydata68k->ddclippingleft))E 31		left = curx;D 31	else    left   = displaydata68k->ddclippingleft;E 31I 31    else    left   = displaydata68k->ddclippingleft;E 31E 25I 8E 8E 7D 10if(left <right) {E 10D 31	pbt= (PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);D 10	if(pbt->pbtheight !=0){	/****** OLD bltchar *****/	register int 	destbpl, sourcebpl, sourcebit;	int	base,y;E 10I 10	h = pbt->pbtheight;	w = right - left;D 16	  if ((h <= 0) || (w <= 0)) return(0);	E 16I 16	if ((h <= 0) || (w <= 0)) return(0);E 31I 31    pbt= (PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);    h = pbt->pbtheight;    w = right - left;    if ((h <= 0) || (w <= 0)) return(0);E 31E 16E 10D 10	(mpr_d(SrcPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,E 10I 10D 31	srcbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,E 31I 31    srcbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,E 31E 10D 16					     pbt->pbtsourcelo)) ;E 16I 16						      pbt->pbtsourcelo));E 16D 10	(mpr_d(DestPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, E 10I 10D 16	dstbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, E 10					      pbt->pbtdestlo )) ;E 16I 16D 31	dstbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,E 31I 31    dstbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,E 31						      pbt->pbtdestlo ));E 16D 10	SrcPixRect->pr_width = sourcebpl = abs( pbt->pbtsourcebpl );	DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );	SrcPixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;		mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;	mpr_mdlinebytes(SrcPixRect) = ( sourcebpl +7) >>3;	 E 10I 10D 16	op = pbt->pbtoperation;E 16I 16D 31	op       = pbt->pbtoperation;E 16	src_comp = pbt->pbtsourcetype;E 31I 31    op       = pbt->pbtoperation;    src_comp = pbt->pbtsourcetype;E 31D 31	srcbpl = abs( pbt->pbtsourcebpl );	dstbpl = abs( pbt->pbtdestbpl );E 10	base = GETBASE(Addr68k_from_LADDR(displaydata68k->ddoffsetscache), args->char8code);D 10	sourcebit = base + left - curx ;E 10I 10D 16	sx = base + left - curx ;E 16I 16	sx = base + left - curx;E 16	dx = left;E 31I 31    srcbpl = abs( pbt->pbtsourcebpl );    dstbpl = abs( pbt->pbtdestbpl );D 39    base = GETBASE(Addr68k_from_LADDR(displaydata68k->ddoffsetscache), args->char8code);E 39I 39    base = GETWORD( Addr68k_from_LADDR			(displaydata68k->ddoffsetscache + args->char8code));E 39    sx = base + left - curx;    dx = left;E 31E 10D 16 E 16I 16I 37    ScreenLocked=T;#ifdef SUNDISPLAYE 37E 16D 10	if( cursorin(pbt->pbtdesthi, pbt->pbtdestlo, 	      left, (right - left), pbt->pbtheight, y, pbt->pbtbackward) ){E 10I 10D 31	displayflg = ( cursorin(pbt->pbtdesthi, (pbt->pbtdestlo + (left >> 4)),E 31I 31    displayflg = ( cursorin(pbt->pbtdesthi, (pbt->pbtdestlo + (left >> 4)),E 31D 16 	      (right - left), pbt->pbtheight, pbt->pbtbackward) );E 16I 16D 21	      (right - left), pbt->pbtheight, pbt->pbtbackward) );E 21I 21D 22	      dx,(right - left), pbt->pbtheight, pbt->pbtbackward) );E 22I 22	      (right - left), pbt->pbtheight, pbt->pbtbackward) );E 22E 21E 16E 10D 37I 20D 31	ScreenLocked=T;E 20D 10		HideCursor;E 10I 10	if (displayflg) HideCursor;E 31I 31    ScreenLocked=T;E 37    if (displayflg) HideCursor;I 37#endif SUNDISPLAYE 37E 31E 10I 32#ifdef NEWBITBLT    bitblt(srcbase, dstbase, sx, dx, w, h, srcbpl, dstbpl,	      backwardflg, src_comp, op, gray, num_gray, curr_gray_line);#elseE 32D 10		if(pr_rop( DestPixRect, left, 0, 			   (right - left),pbt->pbtheight , 			PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ), 			   SrcPixRect, sourcebit, 0) != 0)			error("pilotbitblt: pr_rop failed\n");		ShowCursor;	 } /* display case */ 	else {		if(pr_rop( DestPixRect, left, 0, 			   (right - left),pbt->pbtheight , 			PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ), 			   SrcPixRect, sourcebit, 0) != 0)			error("pilotbitblt: pr_rop failed\n");E 10I 10D 31	new_char_bitblt_codeE 31I 31    new_char_bitblt_codeI 32#endifE 32E 31E 10I 32D 37E 37I 37#ifdef SUNDISPLAYE 37E 32D 10	 } /* else */		/****** OLD bltchar *****/E 10I 10D 31	if (displayflg) ShowCursor;I 20	ScreenLocked=NIL;E 31I 31#ifdef DISPLAYBUFFERI 42#ifdef COLOR    if( MonoOrColor == MONO_SCREEN )#endif COLORE 42    if (in_display_segment(dstbase))      {D 32	DBPRINT(("newbltchar:  x %d, y 0x%x, w %d, h %d.\n", dx, dstbase, w, h));E 32I 32/*	DBPRINT(("newbltchar:  x %d, y 0x%x, w %d, h %d.\n", dx, dstbase, w, h));*/E 32	flush_display_lineregion(dx, dstbase, w, h);      }#endifE 31E 20E 10D 10		}	}E 10D 31} /* newbltchar */E 31I 31    if (displayflg) ShowCursor;I 37#endif SUNDISPLAY#ifdef XWINDOW    if (in_display_segment(dstbase))	flush_display_lineregion(dx, dstbase, w, h);	#endif XWINDOWE 37    ScreenLocked=NIL;E 31I 14D 16#endif#ifdef prropstyleE 16I 16D 31#else/* prropstyle */E 31I 31  } /* end of newbltchar */E 31E 16D 31newbltchar(args)register BLTARG *args;D 16{ E 16I 16{E 16   register DISPLAYDATA *displaydata68k;E 31I 31#else  /* prropstyle */E 31D 31   register int right,left,curx;D 16   register  PILOTBBT *pbt;E 16I 16   register PILOTBBT *pbt;E 16   register int lmargin,rmargin,xoff;E 31I 31/************************************************************************//*									*//*			    n e w b l t c h a r				*//*			     (PIXRECT version)				*//*									*//************************************************************************/E 31I 25D 31   displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);E 31I 31newbltchar(args)  register BLTARG *args;  {    register DISPLAYDATA *displaydata68k;E 31E 25D 25displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);if(displaydata68k->ddcharset != args->charset){E 25I 25D 31   if(displaydata68k->ddcharset != args->charset){E 31I 31    register int right,left,curx;    register PILOTBBT *pbt;    register int lmargin,rmargin,xoff;    int displayflg;	/* T if cursor needs to be taken down */    displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);D 39    if(displaydata68k->ddcharset != args->charset)E 39I 39    if((displaydata68k->ddcharset & 0xFFFF) != args->charset)E 39      {E 31E 25D 16	/* Currentry,this has BUG ,so I can't call it */E 16I 16	/* Currently, this has BUG, so I can't call it */E 16	/*if(changecharset_display(displaydata68k,args->charset) ==-1)*/D 31		{PUNT_TO_BLTCHAR;}D 25}E 25I 25        }E 31I 31	{PUNT_TO_BLTCHAR;}      }E 31E 25D 25E 25D 31if(displaydata68k->ddslowprintingcase)	{PUNT_TO_BLTCHAR; /** \SLOWBLTCHAR--return;**/}E 31I 31    if(displaydata68k->ddslowprintingcase)      {	PUNT_TO_BLTCHAR; /** \SLOWBLTCHAR--return;**/      }E 31D 16FGetNum(displaydata68k->ddxposition,curx);FGetNum(displaydata68k->ddrightmargin,rmargin);FGetNum(displaydata68k->ddleftmargin,lmargin);FGetNum(displaydata68k->ddxoffset,xoff);E 16I 16D 31FGetNum(displaydata68k->ddxposition, curx);FGetNum(displaydata68k->ddrightmargin, rmargin);FGetNum(displaydata68k->ddleftmargin, lmargin);FGetNum(displaydata68k->ddxoffset, xoff);E 31I 31    FGetNum(displaydata68k->ddxposition, curx);    FGetNum(displaydata68k->ddrightmargin, rmargin);    FGetNum(displaydata68k->ddleftmargin, lmargin);    FGetNum(displaydata68k->ddxoffset, xoff);E 31E 16D 31right = curx + *((DLword*)Addr68k_from_LADDRE 31I 31D 35    right = curx + *((DLword*)Addr68k_from_LADDRE 35I 35    right = curx + GETWORD((DLword*)Addr68k_from_LADDRE 35E 31D 16		(displaydata68k->ddcharimagewidths+ args->char8code)) ;E 16I 16		(displaydata68k->ddcharimagewidths+ args->char8code));E 16D 31if((right> rmargin )&&(curx >lmargin))	{PUNT_TO_BLTCHAR;}if(args->displaystream != *TOPWDS68k)	{PUNT_TO_BLTCHAR;}{ register int  newpos; newpos = curx + *(DLword*)Addr68k_from_LADDR	(displaydata68k->ddwidthscache + args->char8code );E 31I 31    if((right> rmargin )&&(curx >lmargin)) PUNT_TO_BLTCHAR;    if(args->displaystream != *TOPWDS68k) PUNT_TO_BLTCHAR;    {      register int  newpos;D 35      newpos = curx + *(DLword*)Addr68k_from_LADDR		(displaydata68k->ddwidthscache + args->char8code );E 35I 35      newpos = curx + GETWORD((DLword*)Addr68k_from_LADDR		(displaydata68k->ddwidthscache + args->char8code ));E 35E 31D 31 if ((0 <= newpos) && (newpos < 65536))E 31I 31      if ((0 <= newpos) && (newpos < 65536))E 31D 16 	(LispPTR)(displaydata68k->ddxposition) =(LispPTR)(S_POSITIVE |newpos);E 16I 16D 40	(LispPTR)(displaydata68k->ddxposition) = (LispPTR)(S_POSITIVE | newpos);E 40I 40	(displaydata68k->ddxposition) = (LispPTR)(S_POSITIVE | newpos);E 40E 16D 31 else if(-65537 < newpos)E 31I 31      else if(-65537 < newpos)E 31D 40	(LispPTR)(displaydata68k->ddxposition) = (LispPTR)(S_NEGATIVE | (0xffff & newpos));E 40I 40	(displaydata68k->ddxposition) = (LispPTR)(S_NEGATIVE | (0xffff & newpos));E 40D 31 else {PUNT_TO_BLTCHAR;}}E 31I 31      else {PUNT_TO_BLTCHAR;}    }E 31D 16	curx += xoff  ;	right +=xoff  ;E 16I 16D 31	curx  += xoff;	right += xoff;E 16D 25 if(right > ((int)displaydata68k->ddclippingright))	right=displaydata68k->ddclippingright;E 25I 25	if(right > (int)(displaydata68k->ddclippingright))E 31I 31    curx  += xoff;    right += xoff;    if(right > (int)(displaydata68k->ddclippingright))E 31		right =  displaydata68k->ddclippingright;E 25D 25if(curx >  (int)(displaydata68k->ddclippingleft))	left = curx;else	left = displaydata68k->ddclippingleft;E 25I 25D 31	if(curx >  (int)(displaydata68k->ddclippingleft))E 31I 31    if(curx >  (int)(displaydata68k->ddclippingleft))E 31		left = curx;D 31	else    left =   displaydata68k->ddclippingleft;E 31I 31    else    left =   displaydata68k->ddclippingleft;E 31E 25D 31if(left <right) {E 31I 31    if(left <right)      {E 31	pbt= (PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);D 31	if(pbt->pbtheight !=0){	/****** OLD bltchar *****/D 16	register int 	destbpl, sourcebpl, sourcebit;E 16I 16D 25	register int	destbpl, sourcebpl, sourcebit;E 25I 25	register int	destbpl, srcebpl, sourcebit;E 25E 16	int	base,y;E 31I 31	if(pbt->pbtheight !=0)	  {	    /****** OLD bltchar *****/	    register int	destbpl, srcebpl, sourcebit;	    DLword * dstbase;	    int	base,y;E 31D 25	(mpr_d(SrcPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,E 25I 25D 31	(mpr_d(SrcePixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,E 31I 31	    (mpr_d(SrcePixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,E 31E 25D 16					     pbt->pbtsourcelo)) ;E 16I 16					     pbt->pbtsourcelo));E 16D 16	(mpr_d(DestPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, 					      pbt->pbtdestlo )) ;E 16I 16D 31	(mpr_d(DestPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,E 31I 31	    dstbase = (mpr_d(DestPixRect))->md_image = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,E 31					      pbt->pbtdestlo ));E 16D 16	SrcPixRect->pr_width = sourcebpl = abs( pbt->pbtsourcebpl );	DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );E 16I 16D 25	SrcPixRect->pr_width  = sourcebpl = abs( pbt->pbtsourcebpl );	DestPixRect->pr_width = destbpl   = abs( pbt->pbtdestbpl );E 16	SrcPixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 25I 25D 31	SrcePixRect->pr_width  = srcebpl = abs( pbt->pbtsourcebpl );	DestPixRect->pr_width  = destbpl = abs( pbt->pbtdestbpl );	SrcePixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 31I 31	    SrcePixRect->pr_width  = srcebpl = abs( pbt->pbtsourcebpl );	    DestPixRect->pr_width  = destbpl = abs( pbt->pbtdestbpl );	    SrcePixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 31E 25D 16	E 16I 16I 28#ifdef I386D 31	/* Need to take care of byte order, because display bank */	/* on the 386 is NOT bit reversed.... */	if (IN_DISPLAY_BANK(pbt->pbtsourcehi))	  mpr_d(SrcePixRect)->md_flags |= MP_I386;	 else mpr_d(SrcePixRect)->md_flags &= (~MP_I386);	if (IN_DISPLAY_BANK(pbt->pbtdesthi))	  mpr_d(DestPixRect)->md_flags |= MP_I386;	 else mpr_d(DestPixRect)->md_flags &= (~MP_I386);E 31I 31	    /* Need to take care of byte order, because display bank */	    /* on the 386 is NOT bit reversed.... */	    if (IN_DISPLAY_BANK(pbt->pbtsourcehi))	      mpr_d(SrcePixRect)->md_flags |= MP_I386;	     else mpr_d(SrcePixRect)->md_flags &= (~MP_I386);	    if (IN_DISPLAY_BANK(pbt->pbtdesthi))	      mpr_d(DestPixRect)->md_flags |= MP_I386;	     else mpr_d(DestPixRect)->md_flags &= (~MP_I386);E 31#endif I386E 28E 16D 31	mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;D 16	mpr_mdlinebytes(SrcPixRect) = ( sourcebpl +7) >>3;	 E 16I 16D 25	mpr_mdlinebytes(SrcPixRect) = (sourcebpl +7) >> 3;E 25I 25	mpr_mdlinebytes(SrcePixRect) = (srcebpl + 7) >> 3;E 31I 31	    mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;	    mpr_mdlinebytes(SrcePixRect) = (srcebpl + 7) >> 3;E 31E 25E 16D 31	base = GETBASE(Addr68k_from_LADDR(displaydata68k->ddoffsetscache), args->char8code);D 16	sourcebit = base + left - curx ; E 16I 16	sourcebit = base + left - curx;E 31I 31	    base = GETBASE(Addr68k_from_LADDR(displaydata68k->ddoffsetscache), args->char8code);	    sourcebit = base + left - curx;E 31I 20D 31	ScreenLocked=T;E 20E 16D 15	if( cursorin(pbt->pbtdesthi, pbt->pbtdestlo,E 15I 15	if( old_cursorin(pbt->pbtdesthi, pbt->pbtdestlo,E 15D 16 	      left, (right - left), pbt->pbtheight, y, pbt->pbtbackward) ){E 16I 16	      left, (right - left), pbt->pbtheight, y, pbt->pbtbackward) ){E 31I 31	   ScreenLocked=T;I 37#ifdef SUNDISPLAYE 37	   if ( displayflg = old_cursorin(pbt->pbtdesthi, pbt->pbtdestlo,	      left, (right - left), pbt->pbtheight, y, pbt->pbtbackward) )	     {E 31E 16D 20E 20		HideCursor;D 20E 20D 16		if(pr_rop( DestPixRect, left, 0, 			   (right - left),pbt->pbtheight , 			PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ), E 16I 16		if(pr_rop( DestPixRect, left, 0,			   (right - left),pbt->pbtheight,			PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ),E 16D 25			   SrcPixRect, sourcebit, 0) != 0)E 25I 25			   SrcePixRect, sourcebit, 0) != 0)E 25			error("pilotbitblt: pr_rop failed\n");I 31		/* Save SHOWCURSOR 'til after paint to screen */#ifndef DISPLAYBUFFERE 31		ShowCursor;D 31	 } /* display case */D 16 	else {		if(pr_rop( DestPixRect, left, 0, 			   (right - left),pbt->pbtheight , 			PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ), E 16I 16	else {E 31I 31#endif	      } /* display case */	    else 	      {E 31		if(pr_rop( DestPixRect, left, 0,			   (right - left),pbt->pbtheight,			PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ),E 16D 25			   SrcPixRect, sourcebit, 0) != 0)E 25I 25			   SrcePixRect, sourcebit, 0) != 0)E 25			error("pilotbitblt: pr_rop failed\n");D 31	 } /* else */E 31I 31	       } /* else */#ifdef DISPLAYBUFFERI 42#ifdef COLOR	if( MonoOrColor == MONO_SCREEN )#endif COLORE 42	if (in_display_segment(dstbase))      {D 32		 DBPRINT(("newbltchar:  x %d, y 0x%x, w %d, h %d.\n", left, dstbase, (right - left), pbt->pbtheight));E 32I 32/*		 DBPRINT(("newbltchar:  x %d, y 0x%x, w %d, h %d.\n", left, dstbase, (right - left), pbt->pbtheight)); */E 32	flush_display_lineregion(left, dstbase, (right - left), pbt->pbtheight);	if (displayflg) ShowCursor; /* because hide is done earlier */      }#endifI 37#endif SUNDISPLAY#ifdef XWINDOW        if(pr_rop( DestPixRect, left, 0,		   (right - left),pbt->pbtheight,		PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ),		   SrcePixRect, sourcebit, 0) != 0)		error("pilotbitblt: pr_rop failed\n");	if (in_display_segment(dstbase))	flush_display_lineregion(left, dstbase, (right - left), pbt->pbtheight);	#endif XWINDOWE 37E 31I 20	ScreenLocked=NIL;E 20		/****** OLD bltchar *****/		}	}} /* newbltchar */#endifE 14/******************************************************************/I 28#ifndef BYTESWAPE 28typedef struct {D 16		LispPTR 	FONTDEVICE;		LispPTR 	SFObsolete1;		LispPTR 	FONTFAMILY;		LispPTR 	FONTSIZE;		LispPTR 	FONTFACE;		LispPTR 	SFObsolete2;		LispPTR 	SFObsolete3;		LispPTR 	SFObsolete4;		DLword 	SFObsolete5;		DLword 	SFObsolete6;		DLword 	SFAscent;		DLword 	SFDescent;		DLword 	SFHeight;		DLword 	ROTATION;E 16I 16		LispPTR		FONTDEVICE;		LispPTR		SFObsolete1;		LispPTR		FONTFAMILY;		LispPTR		FONTSIZE;		LispPTR		FONTFACE;		LispPTR		SFObsolete2;		LispPTR		SFObsolete3;		LispPTR		SFObsolete4;		DLword		SFObsolete5;		DLword		SFObsolete6;		DLword		SFAscent;		DLword		SFDescent;		DLword		SFHeight;		DLword		ROTATION;E 16		short		FBBOX;		short		FBBOY;		short		FBBDX;		short		FBBDY;D 16		unsigned 	SFFACECODE		: 8;E 16I 16		unsigned	SFFACECODE		: 8;E 16		unsigned	SFLKerns		:24;D 16		LispPTR	SFRWidths;		LispPTR 	FONTDEVICESPEC;		LispPTR 	OTHERDEVICEFONTPROPS;		LispPTR 	FONTSCALE;		DLword	FONTAVGCHARWIDTH;		DLword	dum;		LispPTR 	FONTIMAGEWIDTHS;		LispPTR	FONTCHARSETVECTOR;		LispPTR	FONTEXTRAFIELD2;E 16I 16		LispPTR		SFRWidths;		LispPTR		FONTDEVICESPEC;		LispPTR		OTHERDEVICEFONTPROPS;		LispPTR		FONTSCALE;		DLword		FONTAVGCHARWIDTH;		DLword		dum;		LispPTR		FONTIMAGEWIDTHS;		LispPTR		FONTCHARSETVECTOR;		LispPTR		FONTEXTRAFIELD2;E 16} FONTDESC;typedef struct {		LispPTR	WIDTHS;		LispPTR	OFFSETS;D 16		LispPTR 	IMAGEWIDTHS;E 16I 16		LispPTR	IMAGEWIDTHS;E 16		LispPTR	CHARSETBITMAP;		LispPTR	YWIDTHS;		DLword	CHARSETASCENT;		DLword	CHARSETDESCENT;D 40		LispPTR	LEFTKERNE 40I 40		LispPTR	LEFTKERN;E 40 } CHARSETINFO;I 28#elsetypedef struct {		LispPTR		FONTDEVICE;		LispPTR		SFObsolete1;		LispPTR		FONTFAMILY;		LispPTR		FONTSIZE;		LispPTR		FONTFACE;		LispPTR		SFObsolete2;		LispPTR		SFObsolete3;		LispPTR		SFObsolete4;		DLword		SFObsolete6;		DLword		SFObsolete5;		DLword		SFDescent;		DLword		SFAscent;		DLword		ROTATION;		DLword		SFHeight;		short		FBBOY;		short		FBBOX;		short		FBBDY;		short		FBBDX;		unsigned	SFLKerns		:24;		unsigned	SFFACECODE		: 8;		LispPTR		SFRWidths;		LispPTR		FONTDEVICESPEC;		LispPTR		OTHERDEVICEFONTPROPS;		LispPTR		FONTSCALE;		DLword		dum;		DLword		FONTAVGCHARWIDTH;		LispPTR		FONTIMAGEWIDTHS;		LispPTR		FONTCHARSETVECTOR;		LispPTR		FONTEXTRAFIELD2;} FONTDESC;E 28I 28typedef struct {		LispPTR	WIDTHS;		LispPTR	OFFSETS;		LispPTR	IMAGEWIDTHS;		LispPTR	CHARSETBITMAP;		LispPTR	YWIDTHS;		DLword	CHARSETDESCENT;		DLword	CHARSETASCENT;D 40		LispPTR	LEFTKERNE 40I 40		LispPTR	LEFTKERN;E 40 } CHARSETINFO;#endif BYTESWAPE 28D 9#define FRPLPTR(old , new) { \		GCLOOKUP(0x8000,DELREF, (old)); \		GCLOOKUP(0x8000,ADDREF, (new)); \		(old) = (new) ; }E 9#define IMIN(x,y)  (((x) > (y)) ? (y) : (x))D 16#define IMAX(x,y)	(((x) > (y)) ? (x) : (y))E 16I 16#define IMAX(x,y)  (((x) > (y)) ? (x) : (y))E 16I 13/** changecharset_display,sfffixy are not tested *****I don't use TAKE **/E 13changecharset_display(displaydata68k,charset)register DISPLAYDATA *displaydata68k;DLword charset;{ register PILOTBBT *pbt68k; register FONTDESC *fontd68k; LispPTR csinfo; register CHARSETINFO *csinfo68k; BITMAP *bm68k; LispPTR *base68k;D 16 pbt68k=(PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);E 16I 16 pbt68k  =(PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);E 16 fontd68k=(FONTDESC*)Addr68k_from_LADDR(displaydata68k->ddfont);D 16E 16 base68k = (LispPTR*)Addr68k_from_LADDR(fontd68k->FONTCHARSETVECTOR); if((csinfo= *(base68k + charset)) == NIL ){	return(-1); /* punt case */ } csinfo68k =  (CHARSETINFO*)Addr68k_from_LADDR(csinfo);/* REF CNT */D 16 FRPLPTR(displaydata68k->ddwidthscache , csinfo68k->WIDTHS);FRPLPTR(displaydata68k->ddoffsetscache , csinfo68k->OFFSETS);FRPLPTR(displaydata68k->ddcharimagewidths , csinfo68k->IMAGEWIDTHS);E 16I 16FRPLPTR(displaydata68k->ddwidthscache,     csinfo68k->WIDTHS);FRPLPTR(displaydata68k->ddoffsetscache,    csinfo68k->OFFSETS);FRPLPTR(displaydata68k->ddcharimagewidths, csinfo68k->IMAGEWIDTHS);E 16 displaydata68k->ddcharset = charset; bm68k =(BITMAP*)Addr68k_from_LADDR( csinfo68k->CHARSETBITMAP); pbt68k->pbtsourcebpl = (bm68k->bmrasterwidth) << 4;D 11 if((displaydata68k->ddcharsetascent != csinfo68k->CHARSETASCENT) ||	(displaydata68k->ddcharsetdescent != csinfo68k->CHARSETDESCENT))  {D 7		sfffixy(displaydata68k, csinfo68k,pbt68k );E 7I 7		if(sfffixy(displaydata68k, csinfo68k,pbt68k )== -1)			return(-1);E 7  }E 11I 11D 13 return(sfffixy(displaydata68k, csinfo68k,pbt68k ));E 11E 13I 13D 16 if((displaydata68k->ddcharsetascent != csinfo68k->CHARSETASCENT) ||E 16I 16 if((displaydata68k->ddcharsetascent  != csinfo68k->CHARSETASCENT) ||E 16    (displaydata68k->ddcharsetdescent != csinfo68k->CHARSETDESCENT)) { printf("CCD1\n");     return(sfffixy(displaydata68k, csinfo68k,pbt68k )); } else {   register LispPTR addr;   register int num;D 16   FGetNum2(displaydata68k->ddcharheightdelta,num);/* if not number ,return -1 */E 16I 16   FGetNum2(displaydata68k->ddcharheightdelta,num);/* if not number, return -1 */E 16   addr = bm68k->bmbase + (bm68k->bmrasterwidth * num);   printf("CCD2 num=%d\n",num);   pbt68k->pbtsourcehi= addr >> 16;   pbt68k->pbtsourcelo = addr;  /* don't care REFCNT */   return(T); }E 13D 11 else { register LispPTR tmp;		tmp= bm68k->bmbase + 		(bm68k->bmrasterwidth * displaydata68k->ddcharheightdelta);		pbt68k->pbtsourcehi = tmp >> 16;		pbt68k->pbtsourcelo = tmp; } return(T);E 11} /* changecharset_display */sfffixy(displaydata68k,csinfo68k,pbt68k)D 25 DISPLAYDATA *displaydata68k; CHARSETINFO *csinfo68k; PILOTBBT *pbt68k;E 25I 25    DISPLAYDATA *displaydata68k;    CHARSETINFO *csinfo68k;    PILOTBBT *pbt68k;E 25D 25{D 11  int y;E 11I 11 int y;E 11 int chartop,top; BITMAP *bm68k;D 7 register LispPTR base;E 7I 7 register LispPTR base,ypos,yoff; FGetNum2(displaydata68k->ddyoffset, yoff); FGetNum2(displaydata68k->ddyposition, ypos);E 25I 25    {    int y;    int chartop,top;    BITMAP *bm68k;    register LispPTR base,ypos,yoff;E 25E 7D 7 if(displaydata68k->ddyoffset_sign ==SPOS_HI ) 	y = displaydata68k->ddyposition + displaydata68k->ddyoffset; else	y = displaydata68k->ddyposition + (int)(displaydata68k->ddyoffset | 0xFFFF0000);E 7I 7D 25 y = ypos + yoff;E 25I 25    FGetNum2(displaydata68k->ddyoffset, yoff);    FGetNum2(displaydata68k->ddyposition, ypos);E 25D 16 E 16I 16E 16E 7D 25 displaydata68k->ddcharsetascent=csinfo68k->CHARSETASCENT; chartop = y+ displaydata68k->ddcharsetascent;E 25I 25    y = ypos + yoff;E 25D 25 bm68k=(BITMAP*)Addr68k_from_LADDR(displaydata68k->dddestination); base = bm68k->bmbase;D 16 top = IMAX( IMIN(displaydata68k->ddclippingtop , chartop) , 0 );E 16I 16 top = IMAX( IMIN(displaydata68k->ddclippingtop, chartop), 0 );E 16 base= base + (bm68k->bmrasterwidth * (bm68k->bmheight - top)); pbt68k->pbtdesthi= base >> 16;D 16 pbt68k->pbtdestlo= base ;E 16I 16 pbt68k->pbtdestlo= base;E 25I 25    displaydata68k->ddcharsetascent=csinfo68k->CHARSETASCENT;    chartop = y + displaydata68k->ddcharsetascent;E 25E 16D 25 bm68k=(BITMAP*)Addr68k_from_LADDR(csinfo68k->CHARSETBITMAP); base = bm68k->bmbase; displaydata68k->ddcharheightdelta=E 25I 25    bm68k=(BITMAP*)Addr68k_from_LADDR(displaydata68k->dddestination);    base = bm68k->bmbase;    top = IMAX( IMIN(displaydata68k->ddclippingtop, chartop), 0 );    base= base + (bm68k->bmrasterwidth * (bm68k->bmheight - top));    pbt68k->pbtdesthi= base >> 16;    pbt68k->pbtdestlo= base;    bm68k=(BITMAP*)Addr68k_from_LADDR(csinfo68k->CHARSETBITMAP);    base = bm68k->bmbase;    displaydata68k->ddcharheightdelta=E 25D 7	IMIN( IMAX(chartop - top , 0), 65535 );E 7I 7D 11	IMIN( IMAX(chartop - top , 0), 65535 );/* allways positive */E 11I 11D 16	IMIN( IMAX(chartop - top , 0), 65535 );/* always positive */E 16I 16	IMIN( IMAX(chartop - top, 0), 65535 );/* always positive */E 16E 11E 7D 25 base = base + bm68k->bmrasterwidth * displaydata68k->ddcharheightdelta; pbt68k->pbtsourcehi = base >> 16;D 16 pbt68k->pbtsourcelo = base ;E 16I 16 pbt68k->pbtsourcelo = base;E 25I 25    base = base + bm68k->bmrasterwidth * displaydata68k->ddcharheightdelta;    pbt68k->pbtsourcehi = base >> 16;    pbt68k->pbtsourcelo = base;E 25E 16D 11E 11D 25 displaydata68k->ddcharsetdescent= csinfo68k->CHARSETDESCENT;E 25I 25    displaydata68k->ddcharsetdescent= csinfo68k->CHARSETDESCENT;E 25D 11pbt68k->pbtheight = IMAX( top-(IMAX( y- displaydata68k->ddcharsetdescent,displaydata68k->ddclippingbottom)) ,0);E 11I 11D 25 pbt68k->pbtheight = IMAX(0,  top-(IMAX( y- displaydata68k->ddcharsetdescent,displaydata68k->ddclippingbottom))); return(T);E 25I 25    pbt68k->pbtheight = IMAX(0,     top-(IMAX( y- displaydata68k->ddcharsetdescent,displaydata68k->ddclippingbottom)));    return(T);E 25E 11D 25} /* sfffixy */E 25I 25   } /* sfffixy */E 25/******************************************************************/ccfuncall(atom_index,argnum,bytenum)  register unsigned int atom_index;   /* Atomindex for Function you want to invoke */  register int argnum;   /* Number of ARGS on TOS and STK */D 16  register int bytenum;  /* Number of bytes of Caller's E 16I 16  register int bytenum;  /* Number of bytes of Caller'sE 16			OPCODE(including multi-byte) */{D 16  register struct definition_cell *defcell68k ;  /* Definition Cell PTR */  register short pv_num ; /* scratch for pv */E 16I 16  register struct definition_cell *defcell68k;  /* Definition Cell PTR */  register short pv_num; /* scratch for pv */E 16  register struct fnhead *tmp_fn;D 16  int rest ;  /* use for arignments */E 16I 16  int rest;  /* use for arignments */E 16  int closurep=NIL;  register CClosure *closure68k;  /* Get Next Block offset from argnum */  CURRENTFX->nextblock = (LADDR_from_68k(CurrentStackPTR) & 0x0ffff)					- (argnum<<1)+4 /* +3  */;  /* Setup IVar */D 16  IVar = Addr68k_from_LADDR((((LispPTR)(CURRENTFX->nextblock)) | STK_OFFSET)) ;E 16I 16  IVar = Addr68k_from_LADDR((((LispPTR)(CURRENTFX->nextblock)) | STK_OFFSET));E 16  /* Set PC to the Next Instruction and save into FX */D 16  CURRENTFX->pc = ((unsigned int)PC - (unsigned int)FuncObj) + bytenum ; E 16I 16  CURRENTFX->pc = ((unsigned int)PC - (unsigned int)FuncObj) + bytenum;E 16D 16  PushCStack ;  /* save TOS */E 16I 16  PushCStack;  /* save TOS */E 16  /* Get DEFCELL 68k address */D 16  defcell68k =(struct definition_cell *) GetDEFCELL68k(atom_index) ;E 16I 16  defcell68k =(struct definition_cell *) GetDEFCELL68k(atom_index);E 16D 16  tmp_fn = (struct fnhead *)Addr68k_from_LADDR( defcell68k->defpointer ) ;E 16I 16  tmp_fn = (struct fnhead *)Addr68k_from_LADDR( defcell68k->defpointer );E 16if((unsigned int)(CurrentStackPTR + tmp_fn->stkmin +STK_SAFE) >=  (unsigned int)EndSTKP )	{ LispPTR test;		test= *((LispPTR*)CurrentStackPTR);		DOSTACKOVERFLOW(argnum,bytenum-1);D 44		S_CHECK(test==*((LispPTR*)CurrentStackPTR));E 44I 44		S_CHECK(test == *((LispPTR*)CurrentStackPTR),			"stack overflow in ccfuncall");E 44	}D 16  FuncObj = tmp_fn  ; E 16I 16  FuncObj = tmp_fn;E 16 if( FuncObj->na >= 0 )  {	/* This Function is Spread Type */	/* Arguments on Stack Adjustment  */D 16	rest = argnum - FuncObj->na ;		while(rest <0) { 	  PushStack(NIL_PTR) ;E 16I 16	rest = argnum - FuncObj->na;	while(rest <0) {	  PushStack(NIL_PTR);E 16	  rest++;	}D 16	CurrentStackPTR -= (rest<<1) ;E 16I 16	CurrentStackPTR -= (rest<<1);E 16  } /* if end */ /* Set up BF */CurrentStackPTR+=2;D 16 *(CurrentStackPTR) = BF_MARK ; *(CurrentStackPTR+1) = CURRENTFX->nextblock ;E 16I 16D 27 *(CurrentStackPTR) = BF_MARK; *(CurrentStackPTR+1) = CURRENTFX->nextblock;E 27I 27 GETWORD(CurrentStackPTR) = BF_MARK; GETWORD(CurrentStackPTR+1) = CURRENTFX->nextblock;E 27E 16CurrentStackPTR+=2; /* Set up FX */D 27 *(CurrentStackPTR) = FX_MARK;E 27I 27 GETWORD(CurrentStackPTR) = FX_MARK;E 27 /* Now SET new FX */ ((struct frameex1 *)CurrentStackPTR)->alink = LADDR_from_68k(PVar); PVar = (DLword *)CurrentStackPTR + FRAMESIZE;D 16 ((struct frameex1 *)CurrentStackPTR)->lofnheader = 	(defcell68k->defpointer) & 0x0ffff ; ((struct frameex1 *)CurrentStackPTR)->hi2fnheader = 	((defcell68k->defpointer) & 0x0ff0000) >> 16 ;E 16I 16 ((struct frameex1 *)CurrentStackPTR)->lofnheader =	(defcell68k->defpointer) & 0x0ffff; ((struct frameex1 *)CurrentStackPTR)->hi2fnheader =	((defcell68k->defpointer) & 0x0ff0000) >> 16;E 16D 16 CurrentStackPTR = PVar ;E 16I 16 CurrentStackPTR = PVar;E 16 /* Set up PVar area */D 16 pv_num = FuncObj->pv+1 ; /* Changed Apr.27 */E 16I 16 pv_num = FuncObj->pv+1; /* Changed Apr.27 */E 16 while(pv_num > 0) {D 16	*((LispPTR *)CurrentStackPTR) = 0x0ffff0000 ;	CurrentStackPTR += DLWORDSPER_CELL ;	*((LispPTR *)CurrentStackPTR) = 0x0ffff0000 ;	CurrentStackPTR += DLWORDSPER_CELL ;E 16I 16	*((LispPTR *)CurrentStackPTR) = 0x0ffff0000;	CurrentStackPTR += DLWORDSPER_CELL;	*((LispPTR *)CurrentStackPTR) = 0x0ffff0000;	CurrentStackPTR += DLWORDSPER_CELL;E 16	pv_num--;  } /* Set PC points New Function's first OPCODE */D 16 PC = (ByteCode *)FuncObj + FuncObj->startpc ;E 16I 16 PC = (ByteCode *)FuncObj + FuncObj->startpc;I 18 /* It assume that ccfuncall is called  for PUNTing from SUBRCALL */ PC -= 3 ; /* Ajust PC */E 18E 16} /* end ccfuncall */I 13/****************************************************************/D 24/*	tedit_bltchar:		\\TEDIT.BLTCHAR*/E 24I 24/*                                                              *//*                        tedit_bltchar                         *//*								*//*     C-coded version of TEdit's character-painting function   *//*		\\TEDIT.BLTCHAR					*//*								*/E 24/****************************************************************/I 28#ifndef BYTESWAPE 28D 24typedef  struct {	DLword nil;	unsigned  charset	: 8;	unsigned  char8code	: 8;	LispPTR   displaystream;E 24I 24typedefD 44   structE 44I 44   struct tbtaE 44    {	DLword       nil;	unsigned     charset	: 8;	unsigned     char8code	: 8;	LispPTR      displaystream;E 24	unsigned int nil2 : 16;	unsigned int current_x : 16; /* this is allways positive */D 24	LispPTR   displaydata;	LispPTR   ddpilotbitblt;E 24I 24	LispPTR      displaydata;	LispPTR      ddpilotbitblt;E 24	unsigned int nil3 : 16;	unsigned int clipright : 16;/* this is allways positive */D 24 } TBLTARG;E 24I 24     } TBLTARG;E 24D 28E 28I 28#elsetypedefD 44   structE 44I 44   struct tbtaE 44    {	unsigned     char8code	: 8;	unsigned     charset	: 8;	DLword       nil;	LispPTR      displaystream;	unsigned int current_x : 16; /* this is allways positive */	unsigned int nil2 : 16;	LispPTR      displaydata;	LispPTR      ddpilotbitblt;	unsigned int clipright : 16;/* this is allways positive */	unsigned int nil3 : 16;     } TBLTARG;#endif BYTESWAPI 31E 31E 28I 17#ifndef prropstyleI 31	/***************************/	/*   Non-PIXRECT version   */	/***************************/E 31E 17tedit_bltchar(args)D 24register TBLTARG *args;{D 16 	register DISPLAYDATA *displaydata68k;E 16I 16	register DISPLAYDATA *displaydata68k;E 24I 24  register TBLTARG *args;  {#define backwardflg 0#define displayflg 0    register DISPLAYDATA *displaydata68k;    int right;    register PILOTBBT *pbt;    int imagewidth, newx;    /* for new_char_bitblt_code */    int h, w;    int sx, dx, srcbpl, dstbpl, src_comp, op;    DLword *srcbase, *dstbase;    int gray = 0, num_gray = 0, curr_gray_line = 0;E 24E 16D 24	int right;	register PILOTBBT *pbt;	int imagewidth, newx;	int displayflg;	/* for new_char_bitblt_code */	int h, w;	int backwardflg = 0, sx, dx, srcbpl, dstbpl, src_comp, op;	DLword *srcbase, *dstbase;	int gray = 0, num_gray = 0, curr_gray_line = 0;displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);if(displaydata68k->ddcharset != args->charset){E 24I 24    displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);    if(displaydata68k->ddcharset != args->charset)      {E 24	/**if(changecharset_display(displaydata68k, args->charset)== -1)**/D 24	 {		PUNT_TO_TEDIT_BLTCHAR;	 } }/** for debug *************** will be removed ****/ /*if((args->current_x & 0xff0000) != S_POSITIVE) error("bad args in teditblt"); if((args->clipright & 0xff0000) != S_POSITIVE) error("bad args2 in teditblt");***/ imagewidth = *((DLword*)Addr68k_from_LADDRE 24I 24	{	   PUNT_TO_TEDIT_BLTCHAR;	}      }    imagewidth = *((DLword*)Addr68k_from_LADDRE 24		(displaydata68k->ddcharimagewidths+ args->char8code));D 24 newx =  args->current_x + imagewidth; dx = IMAX(0,args->current_x ); right = IMIN(newx, args->clipright);E 24I 24     newx =  args->current_x + imagewidth;     dx = IMAX(0,args->current_x );     right = IMIN(newx, args->clipright);E 24D 24 if(dx < right){E 24I 24     if(dx < right)      {E 24	pbt= (PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);	h = pbt->pbtheight;	srcbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,D 16					     pbt->pbtsourcelo)) ;E 16I 16						      pbt->pbtsourcelo));E 16D 16	dstbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, 					      pbt->pbtdestlo )) ;E 16I 16	dstbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,						      pbt->pbtdestlo ));E 16	srcbpl = abs( pbt->pbtsourcebpl );	dstbpl = abs( pbt->pbtdestbpl );D 16	E 16I 16E 16	op = pbt->pbtoperation;	src_comp = pbt->pbtsourcetype;	/*dx=left;  I'll optimize  later*/D 24	sx = GETBASE(Addr68k_from_LADDR(displaydata68k->ddoffsetscache), args->char8code);E 24I 24	sx = GETBASE(Addr68k_from_LADDR(displaydata68k->ddoffsetscache),		     args->char8code);E 24D 16	w= IMIN(imagewidth , (right-dx));E 16I 16	w= IMIN(imagewidth, (right-dx));I 32#ifdef NEWBITBLT	bitblt(srcbase, dstbase, sx, dx, w, h, srcbpl, dstbpl,		  backwardflg, src_comp, op, gray, num_gray, curr_gray_line);#elseE 32E 16I 20D 24	ScreenLocked=T;E 20D 16 	if(displayflg=cursorin(pbt->pbtdesthi, (pbt->pbtdestlo + (dx >> 4)), 	      (right - dx), pbt->pbtheight, pbt->pbtbackward))E 16I 16	if(displayflg=cursorin(pbt->pbtdesthi, (pbt->pbtdestlo + (dx >> 4)),D 21	      (right - dx), pbt->pbtheight, pbt->pbtbackward))E 21I 21D 22	     dx, (right - dx), pbt->pbtheight, pbt->pbtbackward))E 22I 22	      (right - dx), pbt->pbtheight, pbt->pbtbackward))E 22E 21E 16		HideCursor;E 24I 24	new_char_bitblt_code;I 32#endifE 32E 24D 24		new_char_bitblt_code;	if(displayflg)		ShowCursor;I 20	ScreenLocked=NIL;E 24I 24      }#undef displayflg#undef backwardflgE 24E 20D 16	E 16I 16E 16D 24 }} /* end tedit_bltchar */E 24I 24  } /* end tedit_bltchar */E 24I 17#elseE 17I 15I 17/* pr_op style */I 31	/**********************/	/*   PIXRECT version  */	/**********************/E 31tedit_bltchar(args)D 24register TBLTARG *args;{	register DISPLAYDATA *displaydata68k;E 24I 24  register TBLTARG *args;  {    register DISPLAYDATA *displaydata68k;    register int left,right;    register PILOTBBT *pbt;    register int imagewidth, newx;    register displayflg;E 24D 24	register int left,right;	register PILOTBBT *pbt;	register int imagewidth, newx;I 20	register displayflg;E 20displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);if(displaydata68k->ddcharset != args->charset){E 24I 24    displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);    if(displaydata68k->ddcharset != args->charset)      {E 24	/**if(changecharset_display(displaydata68k, args->charset)== -1)**/	 {D 24		PUNT_TO_TEDIT_BLTCHAR;E 24I 24	   PUNT_TO_TEDIT_BLTCHAR;E 24	 }D 24 } imagewidth = *((DLword*)Addr68k_from_LADDR		(displaydata68k->ddcharimagewidths+ args->char8code)); newx =  args->current_x + imagewidth; left = IMAX(0,args->current_x ); right = IMIN(newx, args->clipright);I 20 ScreenLocked=T;E 24I 24      }    imagewidth = *((DLword*)Addr68k_from_LADDR		   (displaydata68k->ddcharimagewidths+ args->char8code));     newx =  args->current_x + imagewidth;     left = IMAX(0,args->current_x );     right = IMIN(newx, args->clipright);     ScreenLocked=T;E 24E 20D 24 if(left < right){    pbt= (PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);	if( pbt->pbtheight){	(mpr_d(SrcPixRect))->md_image = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,						      pbt->pbtsourcelo));E 24I 24     if(left < right)      {        pbt= (PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);D 25    	if( pbt->pbtheight)E 25I 25	if( pbt->pbtheight)E 25	  {D 25	    (mpr_d(SrcPixRect))->md_image =E 25I 25	    (mpr_d(SrcePixRect))->md_image =E 25		 (short *)Addr68k_from_LADDR(VAG2(pbt->pbtsourcehi,						  pbt->pbtsourcelo));E 24D 24	(mpr_d(DestPixRect))->md_image = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,						      pbt->pbtdestlo ));	{ register int sourcebpl,destbpl;	SrcPixRect->pr_width = sourcebpl = abs( pbt->pbtsourcebpl );	DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );	SrcPixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 24I 24	    (mpr_d(DestPixRect))->md_image =		(short *)Addr68k_from_LADDR(VAG2(pbt->pbtdesthi,						 pbt->pbtdestlo ));	      {D 25		register int sourcebpl,destbpl;		SrcPixRect->pr_width = sourcebpl = abs( pbt->pbtsourcebpl );E 25I 25		register int srcebpl,destbpl;		SrcePixRect->pr_width = srcebpl = abs( pbt->pbtsourcebpl );E 25		DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );D 25		SrcPixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 25I 25		SrcePixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;I 28#ifdef I386	/* Need to take care of byte order, because display bank */	/* on the 386 is NOT bit reversed.... */	if (IN_DISPLAY_BANK(pbt->pbtsourcehi))	  mpr_d(SrcePixRect)->md_flags |= MP_I386;	 else mpr_d(SrcePixRect)->md_flags &= (~MP_I386);	if (IN_DISPLAY_BANK(pbt->pbtdesthi))	  mpr_d(DestPixRect)->md_flags |= MP_I386;	 else mpr_d(DestPixRect)->md_flags &= (~MP_I386);#endif I386E 28E 25E 24D 24	mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;	mpr_mdlinebytes(SrcPixRect) = ( sourcebpl +7) >>3;	}E 24I 24		mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;D 25		mpr_mdlinebytes(SrcPixRect) = ( sourcebpl +7) >>3;E 25I 25		mpr_mdlinebytes(SrcePixRect) = (srcebpl + 7) >> 3;E 25	      }E 24D 24	pbt->pbtwidth= IMIN(imagewidth, (right-left));	pbt->pbtsourcebit=GETBASE(Addr68k_from_LADDR		(displaydata68k->ddoffsetscache), args->char8code);E 24I 24	    pbt->pbtwidth= IMIN(imagewidth, (right-left));	    pbt->pbtsourcebit=GETBASE(Addr68k_from_LADDR			(displaydata68k->ddoffsetscache), args->char8code);E 24D 20	if(old_cursorin(pbt->pbtdesthi, pbt->pbtdestlo,left,E 20I 20I 24D 25	    if(pr_rop( DestPixRect, left, 0, 		   pbt->pbtwidth,pbt->pbtheight , 		PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ), 		   SrcPixRect, pbt->pbtsourcebit, 0) != 0)E 25I 25	    if(pr_rop( DestPixRect, left, 0,		   pbt->pbtwidth,pbt->pbtheight,		PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ),		   SrcePixRect, pbt->pbtsourcebit, 0) != 0)E 25		error("pilotbitblt: pr_rop failed\n");E 24D 24	if(displayflg=old_cursorin(pbt->pbtdesthi, pbt->pbtdestlo,left,E 20	      pbt->pbtwidth, pbt->pbtheight, pbt->pbtbackward))		HideCursor;E 24D 24		if(pr_rop( DestPixRect, left, 0, 			   pbt->pbtwidth,pbt->pbtheight , 			PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ), 			   SrcPixRect, pbt->pbtsourcebit, 0) != 0)			error("pilotbitblt: pr_rop failed\n");;D 20	E 20I 20		if(displayflg)E 20		ShowCursor;	}	else {		if(pr_rop( DestPixRect, left, 0, 			   pbt->pbtwidth,pbt->pbtheight , 			PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ), 			   SrcPixRect, pbt->pbtsourcebit, 0) != 0)			error("pilotbitblt: pr_rop failed\n");;	}E 24I 24           } /* if pbt->pbtheight */	} /* if left<right */E 24D 24     }E 24I 24    ScreenLocked=NIL;E 24I 20D 24 ScreenLocked=NIL;E 20} /* end tedit_bltchar */E 24I 24  } /* end tedit_bltchar */E 24I 23#endifE 23I 23#ifndef COLORE 23E 17int old_cursorin  ( addrhi, addrlo, x, w, h, y, backward)     DLword	addrhi;		/* Lisp addr hi-word	*/     DLword	addrlo;		/* Lisp addr lo-word	*/     register int	x, w, h, y;     {I 35#ifdef INIT      init_kbd_startup;#endifE 35	if (addrhi == DISPLAY_HI)  y = addrlo / DisplayRasterWidth;	else if (addrhi == DISPLAY_HI+1)	   y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth;	else return( NIL );	if(backward) y -= h;D 16		E 16I 16E 16D 25	if((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))E 25I 25	if((x < MOUSEXR)&&(x + w > MOUSEXL)&&	   (y < MOUSEYH)&&(y + h > MOUSEYL)   )E 25	   return( T );D 16	else E 16I 16	elseE 16	   return( NIL );     }I 17I 23#else/* For MONO and COLOR */old_cursorin  ( addrhi, addrlo, x, w, h, y, backward)     DLword	addrhi;		/* Lisp addr hi-word	*/     DLword	addrlo;		/* Lisp addr lo-word	*/     register int	x, w, h, y;     {	register DLword *base68k;	extern int MonoOrColor;	extern int DisplayWidth;I 35#ifdef INIT      init_kbd_startup;#endifE 35E 23D 23#endifE 23I 23	if(MonoOrColor == MONO_SCREEN) {	  if (addrhi == DISPLAY_HI)  y = addrlo / DisplayRasterWidth;	  else if (addrhi == DISPLAY_HI+1)	     y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth;	  else return( NIL );	  if(backward) y -= h;D 25	  if((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))E 25I 25	  if((x < MOUSEXR)&&(x + w > MOUSEXL)&&	     (y < MOUSEYH)&&(y + h > MOUSEYL)   )E 25	     return( T );	  else	     return( NIL );	} /* MONO case end */	else {	  base68k=(DLword*)Addr68k_from_LADDR(addrhi << 16 | addrlo);	  if ((ColorDisplayRegion68k<=base68k) &&		 (base68k <= COLOR_MAX_Address)){	     y =(base68k - ColorDisplayRegion68k) /DisplayWidth ;	  }	  else return( NIL );	  if(backward) y -= h;	 /*  printf("old_c:x=%d,y=%d,w=%d,h=%d\n",x,y,w,h);*/	  if((x < MOUSEXR)&&((x + (w >>3)) > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))	     { /* printf("old_c T\n");*/ return( T );}	  else	      return( NIL );	} /* COLOR case end */     }#endif COLORE 23E 17E 15E 13E 6E 1