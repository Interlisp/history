h15364s 00001/00001/00415d D 2.25 91/09/27 03:45:45 sybalsky 27 26c ISC port changeses 00004/00001/00412d D 2.24 91/09/27 02:48:50 sybalsky 26 25c ISC port changeses 00002/00000/00411d D 2.23 91/01/24 22:31:21 sybalsky 25 24c Retrofit HPUX changes for HP9000.es 00015/00002/00396d D 2.22 90/09/18 23:46:27 sybalsky 24 23c Retrofit changes from AIX, DEC3100, PS/2es 00000/00000/00398d D 2.21 90/08/21 17:16:29 sybalsky 23 22c Retrofit AIX changes from IBMes 00003/00001/00395d D 2.20 90/06/26 15:35:41 sybalsky 22 21c AIX compatibilityes 00000/00000/00396d D 2.19 90/04/20 01:51:26 sybalsky 21 20c AIX:  shortening file names, bulk change.es 00010/00002/00386d D 2.18 90/03/22 12:37:45 takeshi 20 19c mess-read can print correct string even in i386es 00003/00003/00385d D 2.17 90/02/13 19:46:50 takeshi 19 18c Swap the order of tty/pty closees 00002/00002/00386d D 2.16 89/12/28 15:27:42 sybalsky 18 17c es 00311/00187/00077d D 2.15 89/12/13 10:57:47 sybalsky 17 16c interrupt-driven logginges 00001/00001/00263d D 2.14 89/03/18 04:03:04 sybalsky 16 15c OneDArrayes 00010/00008/00254d D 2.13 89/01/09 15:56:37 shih 15 14c minor spelling correctionses 00003/00000/00259d D 2.12 89/01/05 13:51:29 hayata 14 13c TICOCONS sequence n mess_reset() is masked to avoid SunOS panic.es 00021/00011/00238d D 2.11 88/08/02 12:24:20 hayata 13 12c Try to keep one opend log file, when read, write and so on, reopen the opend file.es 00023/00074/00226d D 2.10 88/06/27 20:27:21 hayata 12 11c Remove error call which mess display image.es 00064/00006/00236d D 2.9 88/07/26 15:58:06 hayata 11 10c flush_pyt is made. It is called from OSMESSAGE_PRINTes 00006/00000/00236d D 2.8 88/06/29 10:52:16 hayata 10 9c To fix TIMEOUT, SETJMP are usedes 00039/00008/00197d D 2.7 88/06/19 13:45:04 hayata 9 8c Add error trap, when OSMESSAGE does not work.es 00003/00002/00202d D 2.6 88/06/13 17:36:48 hayata 8 7c Add SCCS key ides 00015/00007/00189d D 2.5 88/06/13 17:35:21 hayata 7 6c Add TIMEOUTes 00006/00000/00190d D 2.4 88/06/07 18:47:35 greep 6 5c make /dev/console be the system console when running Raid locallyes 00002/00002/00188d D 2.3 88/06/01 09:29:04 hayata 5 4c Change logfile directory to /tmp to fix AR10251es 00001/00001/00189d D 2.2 88/05/26 10:05:13 hayata 4 3c Change logfile from ~/lisp.log to /tmp/xxx-lisp.loges 00000/00000/00190d D 2.1 88/05/17 09:26:12 hayata 3 2c Version up to 2.1es 00092/00077/00098d D 1.2 88/05/08 15:37:39 hayata 2 1c Use pty and tty to get /dev/console.es 00175/00000/00000d D 1.1 88/05/06 12:10:19 hayata 1 0c date and time created 88/05/06 12:10:19 by hayataeuUtTI 1D 5/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 5I 5D 8/* This is G-file @(#) osmessage.c Version 2.2 (5/26/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) osmessage.c	2.2 5/26/88";E 8I 8D 15/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 15I 15D 18/* %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 15static char *id = "%Z% %M%	%I% %G%";E 18I 18D 19/* @(#) osmessage.c Version 2.14 (3/18/89). copyright Xerox & Fuji Xerox  */static char *id = "@(#) osmessage.c	2.14 3/18/89";E 19I 19/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%      %I% %G%         (venue & Fuji Xerox)";E 19E 18I 17/************************************************************************//*									*//*			O S M E S S A G E . C				*//*									*//*	Functions for handling the redirection of console and stan-	*//*	dard-error output so it appears in the prompt window.		*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*	(C) Copyright 1988, 1989 Xerox Corporation and John Sybalsky	*//*	    All Rights Reserved.					*//*									*//************************************************************************/E 17I 10E 10E 8E 5#include	<pwd.h>D 24#include	<errno.h>E 24D 26#include	<sys/file.h>E 26#include	<sys/types.h>I 26#ifdef ISCD 27#inlcude	<sys/bsdtypes.h>E 27I 27#include	<sys/bsdtypes.h>E 27#endif ISC#include	<sys/file.h>E 26#include	<sys/stat.h>I 24#ifndef AIXE 24#include	<sys/ioctl.h>I 24#endif AIXE 24I 2#include	<sys/time.h>I 24#ifndef AIXE 24I 9#include	<sys/vfs.h>I 24#endif AIXI 25#ifndef HPUXE 25E 24E 9E 2#include	<strings.h>I 25#endif HPUXE 25I 10D 15#include 	<setjmp.h>E 15I 15#include	<setjmp.h>E 15E 10#include	<stdio.h>I 9#include	<errno.h>E 9#include	"lispemul.h"#include	"lispmap.h"#include	"address68k.h"#include	"lisptypes.h"#include	"arith.h"#include	"stream.h"#include	"lispglobal.h"I 7#include	"timeout.h"I 20#include	"localfile.h"E 20I 11#include	"osmessage.h"I 17#include "dbprint.h"#ifdef OS4#include <stropts.h>#endifE 17E 11E 7D 2#define	MESSAGE_BUFFER_SIZE	512E 2I 2#define	MESSAGE_BUFFER_SIZE	1024int	cons_tty;int	cons_pty;E 2D 2char	save_stdout[100];char	save_stderr[100];char	logfile[100];E 2I 2D 13char	logfile[100];	E 13I 13char	logfile[100];D 15int	log_id;	E 15I 15int	log_id;E 15E 13E 2int	previous_size;I 17int	logChanged;	/* T if log file has changed since last READ */			/* Set by flush_pty, to avoid the stat call  */u_int LogFileFd;extern u_int LispReadFds;E 17D 2char	buf[MESSAGE_BUFFER_SIZE];E 2I 17/************************************************************************//*									*//*			    m e s s _ i n i t				*//*									*//*	Initialize console-message handling.  Console & Log msgs	*//*	are redirected to a pty; when messages appear, we get the	*//*	interrupt, and signal a Lisp interrupt to print each msg	*//*	in the prompt window.  For historical reasons, the msgs 	*//*	are saved on the file tmp/<username>-log.			*//*									*//************************************************************************/E 17D 2char	*ttyname();E 2mess_init()D 17{D 2int	i;E 2int	id;D 2int	tty;struct sgttyb	buf;E 2struct passwd *pwd;D 2struct stat	sbuf;	char	*cbuf;/*	tty = open("/dev/console", O_RDWR);	if(tty >= 0){		if( ioctl(tty, TIOCNOTTY, 0) == -1){ 			return(-1);			}		close(tty);	}else{		return(-1);E 2I 2int	ttyfd;int	ptyfd, ptynum;char	*ptyname, *ttyname;int	temp;	ptyname = "/dev/ptypx";	ttyname = "/dev/ttypx";E 17I 17  {I 24#ifndef XWINDOWE 24    int	id;    struct passwd *pwd;    int	ttyfd;    int	ptyfd, ptynum;    char	*ptyname, *ttyname;    int	temp, flags;    int on = 1;E 17I 17    ptyname = "/dev/ptypx";    ttyname = "/dev/ttypx";E 17/* Get pty and tty */D 17	ptynum = 0;E 17I 17    ptynum = 0;E 17needpty:D 17	while( ptynum<16 ){		ptyname[9] = "0123456789abcdef"[ptynum];		if( (ptyfd=open(ptyname, 2)) >= 0 )			goto gotpty;		ptynum++;E 2	}D 2*/E 2I 2	return(NIL);E 17I 17    while( ptynum<16 )      {	ptyname[9] = "0123456789abcdef"[ptynum];	if( (ptyfd=open(ptyname, 2)) >= 0 ) goto gotpty;	ptynum++;      }    return(NIL);E 17gotpty:D 17	ttyname[9] = ptyname[9];	if( (ttyfd=open(ttyname, 2)) < 0){		ptynum++;		close(ptyfd);		goto needpty;	}E 17I 17    ttyname[9] = ptyname[9];    if( (ttyfd=open(ttyname, 2)) < 0)      {	ptynum++;	close(ptyfd);	goto needpty;      }E 17D 17/* Set tty parameter same as stderr */	/* line discipline */	ioctl(    2, TIOCGETD, &temp);	ioctl(ttyfd, TIOCSETD, &temp);	/* tty parameters */	ioctl(    2, TIOCGETP, &temp);	ioctl(ttyfd, TIOCSETP, &temp);	/* local modes */	ioctl(    2, TIOCLGET, &temp);	ioctl(ttyfd, TIOCLSET, &temp);	/* terminal characters */	ioctl(    2, TIOCGETC, &temp);	ioctl(ttyfd, TIOCSETC, &temp);	/* local special characters */	ioctl(    2, TIOCGLTC, &temp);	ioctl(ttyfd, TIOCSLTC, &temp);E 17I 17	/* Set tty parameters same as stderr */E 17I 17    ioctl(    2, TIOCGETD, &temp);	/* Line discipline */    ioctl(ttyfd, TIOCSETD, &temp);    ioctl(    2, TIOCGETP, &temp);	/* TTY parameters */    ioctl(ttyfd, TIOCSETP, &temp);    ioctl(    2, TIOCLGET, &temp);    ioctl(ttyfd, TIOCLSET, &temp);    ioctl(    2, TIOCGETC, &temp);	/* Terminal characters */    ioctl(ttyfd, TIOCSETC, &temp);    ioctl(    2, TIOCGLTC, &temp);	/* Local special characters */    ioctl(ttyfd, TIOCSLTC, &temp);E 17/* Get console IO */D 17	ioctl(ptyfd, FIOCLEX);	if( (ioctl(ttyfd, TIOCCONS, 0)) == -1){D 11		printf("TIOCCONS erros\n");E 11I 11D 15		OSMESSAGE_PRINT( printf("TIOCCONS erros\n") );E 15I 15		OSMESSAGE_PRINT( printf("TIOCCONS error\n") );E 15E 11		exit(-1);	}	cons_pty = ptyfd;	cons_tty = ttyfd;E 17I 17    ioctl(ptyfd, FIOCLEX, 0);I 22#ifndef AIXE 22    if( (ioctl(ttyfd, TIOCCONS, 0)) == -1)      {	OSMESSAGE_PRINT( printf("TIOCCONS error\n") );	exit(-1);      }I 22#endif AIXE 22    cons_pty = ptyfd;    cons_tty = ttyfd;E 17D 9/* Initialize ~/lisp.log file */E 9I 9/* Initialize log file */E 9E 2D 17	pwd = getpwuid(getuid());D 2	sprintf(logfile,"%s/errlog", pwd->pw_dir);	if( unlink(logfile) == -1){	/* delete old errlog file */E 2I 2D 4	sprintf(logfile,"%s/lisp.log", pwd->pw_dir);E 4I 4	sprintf(logfile,"/tmp/%s-lisp.log", pwd->pw_name);E 4	if( unlink(logfile) == -1){	/* delete old log file */E 2		if(errno != ENOENT)D 2			return(-1);	E 2I 2D 15			return(NIL);	E 15I 15			return(NIL);E 15E 2	}D 2	if((cbuf=ttyname(1)) == 0){		return(-1);	}	strcpy(save_stdout, cbuf);	if((cbuf=ttyname(2)) == 0){		return(-1);	}	strcpy(save_stderr, cbuf);	id = open(logfile, (O_RDWR | O_CREAT), 0666);	if( dup2(id,1) == -1){	/* stdout is changed */		return(-1);	}	if( dup2(id,2) == -1){ /* stderr is changed */		return(-1);	}E 2I 2D 13	if( (id = open(logfile, (O_RDWR | O_CREAT), 0666)) < 0 )E 13I 13	if( (log_id = open(logfile, (O_RDWR | O_CREAT), 0666)) < 0 )E 13		return(NIL);I 13/*E 13E 2	close(id);I 13*/E 13	previous_size = 0;}E 17I 17    pwd = getpwuid(getuid());    sprintf(logfile,"/tmp/%s-lisp.log", pwd->pw_name);    if( unlink(logfile) == -1)      {	/* delete old log file */	if(errno != ENOENT) return(NIL);      }E 17I 17    if( (log_id = open(logfile, (O_RDWR | O_CREAT), 0666)) < 0 )      return(NIL);#ifdef LOGINT    LogFileFd = 1 << cons_pty;    flags = fcntl(cons_pty, F_GETFL, 0);    flags = fcntl(cons_pty, F_SETFL, (flags | FASYNC | FNDELAY));    if(fcntl(cons_pty, F_SETOWN, getpid()) == -1 )      {#ifdef DEBUG	perror("fcntl F_SETOWN of log PTY");#endif      };    LispReadFds |= LogFileFd;    flush_pty();#endif    previous_size = 0;    DBPRINT(("Console logging started.\n"));I 24#endif XWINDOWE 24  }/************************************************************************//*									*//*			    m e s s _ r e s e t				*//*									*//*	Undo the redirection of console and standard-error outputs	*//*	presumably preparatory to shutting down lisp.  Closes the	*//*	TTY/PTY pair used for logging the messages			*//*									*//************************************************************************/E 17mess_reset()D 17{I 6	int console_fd;I 13	close(log_id);E 13E 6D 2int	id;	if(fflush(stdout) == -1){		printf("fflush err\n");		return(-1);	}	if(fflush(stderr) == -1){		printf("fflush err\n");		return(-1);	}	id = open(save_stdout, O_WRONLY);	if( dup2(id,1) == -1){			return(-1);	}	id = open(save_stderr, O_WRONLY);	if( dup2(id,2) == -1){			return(-1);	}	return(1);E 2I 2	close(cons_pty);	close(cons_tty);I 6	/* Try to make /dev/console be the real console again */E 17I 17  {I 24#ifndef XWINDOWE 24    int console_fd;    close(log_id);D 19    close(cons_pty);E 19    close(cons_tty);I 19    close(cons_pty);E 19    /* Try to make /dev/console be the real console again */E 17I 14D 15/*** This sequnce sometimes cause SunOs panic on SunOS4.0(and 4.0.1).E 15I 15/*** This sequence sometimes cause SunOs panic on SunOS4.0(and 4.0.1).E 15D 17	TIOCCONS probelm ???E 14	if ((console_fd = open("/dev/console", 0)) >= 0) {E 17I 17    TIOCCONS probelm ???    if ((console_fd = open("/dev/console", 0)) >= 0) {E 17	  ioctl(console_fd, TIOCCONS, 0);	  close(console_fd);	}I 14***/I 24#endif XWINDOWE 24E 14E 6E 2D 17}E 17I 17  }E 17I 17/************************************************************************//*									*//*			m e s s _ r e a d p				*//*									*//*	Returns T if there are log/console messages waiting		*//*	to be printed.  More accurately, if the logChanged flag		*//*	has been set by flush_pty().					*//*									*//************************************************************************/E 17I 2static struct timeval	selecttimeout = {0, 0};E 2mess_readp()D 17{int	id;struct stat sbuf;D 2	if(fflush(stdout) == -1){		printf("fflush err\n");E 2I 2char	buf[MESSAGE_BUFFER_SIZE];	/* Buffer between pty and log file */int	size;D 9FILE	*fp;E 9static int  rfds;I 7int	rval;I 9struct statfs	fsbuf;E 17I 17  {I 24#ifndef XWINDOWE 24    int	id;    struct stat sbuf;    int	size;    int	rval;    struct statfs	fsbuf;E 17E 9E 7I 10D 12	SETJMP(NIL);E 12E 10D 17/* polling pty nd flush os message to log file */D 12	rfds = (1 << cons_pty);	if(select(32, &rfds, NULL, NULL, &selecttimeout) < 0 ){D 11		printf("mess_readp: select error\n");E 11I 11		OSMESSAGE_PRINT( printf("mess_readp: select error\n") );E 11E 2		return(NIL);	}D 2	if(fflush(stderr) == -1){		printf("fflush err\n");		return(NIL);E 2I 2	if( (cons_pty >= 0) && (rfds & (1 << cons_pty)) ){		size = read(cons_pty, buf, MESSAGE_BUFFER_SIZE-1);I 9		if(size == -1){			error("osmessage error: read from pty failed");			return(NIL);		}/*E 9		buf[size] = '\0';D 9		if( (fp = fopen(logfile, "a")) == NULL){			printf("open error: log file can not open\n");E 9I 9*/		TIMEOUT( id=open(logfile, O_WRONLY | O_APPEND, 0666) );		if( id == -1){			error("osmessage error: log file can not open (/tmp)");E 9			return(NIL);		}else{D 9			fputs(buf, fp);			fclose(fp);			return(ATOM_T);E 9I 9			/* Check free space to avoid print System Error Mesage  to /dev/console */			TIMEOUT( rval=statfs("/tmp", &fsbuf) );			if( rval != 0){				return(NIL);			}			if(fsbuf.f_bavail <= (long)0){				/* No Free Space */				error("osmessage error: No free space on file system (/tmp).");				return(NIL);			}E 12I 12	flush_pty();E 17I 17    /* polling pty nd flush os message to log file */    flush_pty();E 17E 12D 12			TIMEOUT( rval=write(id, buf, size) );			if( rval == -1){				if(errno == 28){ /* No free space, but its too late to avoid print system Error Message. */					error("osmessage error: No free space on file system (/tmp).");					return(NIL);				}else{				error("osmessage error: can not write to log file (/tmp)");					return(NIL);				}			}else{				close(id);				return(ATOM_T);			}E 9		}E 2	}I 2E 12D 17/* polling log file */I 12	SETJMP(NIL);E 12E 2D 7	if(stat(logfile, &sbuf) != 0){E 7I 7	TIMEOUT( rval=stat(logfile, &sbuf) );	if(rval != 0){E 7D 9		printf("stat err\n");E 9I 9		error("osmessage error: can not find a log file under /tmp");E 9		return(NIL);	}	if( previous_size < (int)(sbuf.st_size) ){		return(ATOM_T);	}E 17I 17/* * * * * * * * * * * * COMMENTED OUT * * * * * * * * *    SETJMP(NIL);    TIMEOUT( rval=stat(logfile, &sbuf) );    if(rval != 0)      {	error("osmessage error: can not find a log file under /tmp");E 17	return(NIL);I 17      }    if( previous_size < (int)(sbuf.st_size) ) return(ATOM_T);* * * * * * * * * * * * * */    if (logChanged) return(ATOM_T);    return(NIL);I 24#endif XWINDOWE 24E 17}I 17/************************************************************************//*									*//*			   m e s s _ r e a d				*//*									*//*	Read up to 1024 chars of log and console message(s)		*//*	that are waiting to be printed, into a buffer supplied		*//*	by the caller.  If all pending message text gets read in	*//*	this call, reset the logChanged flag; Otherwise, leave		*//*	it set, so Lisp knows there is more to read.			*//*									*//************************************************************************/E 17mess_read(args)D 17LispPTR	*args;/* args[0]		buffer	*/{int	id;struct stat sbuf;D 2int	size, save_size, pos;E 2I 2int	size, save_size;E 2char	*base;LispPTR	*naddress;int	i;I 10	SETJMP(NIL);E 17I 17  LispPTR	*args;  /* args[0]		buffer	*/  {I 24#ifndef XWINDOWE 24    int	id;    struct stat sbuf;    int	size, save_size;    char	*base;    LispPTR	*naddress;    int	i;I 20D 22	static temp_buf[MESSAGE_BUFFER_SIZE];E 22I 22    static char temp_buf[MESSAGE_BUFFER_SIZE];E 22E 20    SETJMP(NIL);E 17I 20	/* Get buff address from LISP */E 20E 10D 17	naddress = (LispPTR *)(Addr68k_from_LADDR(args[0]));D 16	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));E 16I 16	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));E 17I 17    naddress = (LispPTR *)(Addr68k_from_LADDR(args[0]));    base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));E 17E 16D 7	if((id=open(logfile, O_RDONLY)) == -1){E 7I 7D 13	TIMEOUT(id=open(logfile, O_RDONLY));	if(id == -1){E 13I 13D 17	close(log_id);	TIMEOUT(log_id=open(logfile, O_RDONLY));	if(log_id == -1){E 13E 7		return(NIL);	}D 2/* No need to flush	if(fflush(stdout) == -1){		printf("fflush err\n");		return(NIL);	}	if(fflush(stderr) == -1){		printf("fflush err\n");		return(NIL);	}*/E 2D 7	if(fstat(id, &sbuf) != 0){E 7I 7D 13	TIMEOUT(i=fstat(id, &sbuf));E 13I 13	TIMEOUT(i=fstat(log_id, &sbuf));E 13	if(i != 0){E 7D 11		printf("stat err\n");E 11I 11		OSMESSAGE_PRINT( printf("stat err\n") );E 11		return(NIL);	}	save_size = (int)(sbuf.st_size);	size = save_size - previous_size;	if(size > MESSAGE_BUFFER_SIZE)		size = MESSAGE_BUFFER_SIZE;D 2	if((pos=lseek(id, previous_size, L_SET)) == -1){E 2I 2D 7	if(lseek(id, previous_size, L_SET) == -1){E 7I 7D 13	TIMEOUT(i=lseek(id, previous_size, L_SET));E 13I 13	TIMEOUT(i=lseek(log_id, previous_size, L_SET));E 13	if(i == -1){E 7E 2D 11		printf("seek err\n");E 11I 11		OSMESSAGE_PRINT( printf("seek err\n") );E 11		return(NIL);	}D 7	if((size = read(id, base, size)) == -1){E 7I 7D 13	TIMEOUT(size=read(id, base, size));E 13I 13	TIMEOUT(size=read(log_id, base, size));E 13	if(size == -1){E 7D 11		printf("read err\n");E 11I 11		OSMESSAGE_PRINT( printf("read err\n") );E 11		return(NIL);	}D 7	if(lseek(id, save_size, L_SET) == -1){E 7I 7D 13	TIMEOUT(i=lseek(id, save_size, L_SET));E 13I 13	TIMEOUT(i=lseek(log_id, save_size, L_SET));E 13	if(i == -1){E 7D 11		printf("seek err\n");E 11I 11		OSMESSAGE_PRINT( printf("seek err\n") );E 11		return(NIL);	}E 17I 17    close(log_id);    TIMEOUT(log_id=open(logfile, O_RDONLY));    if(log_id == -1)return(NIL);    TIMEOUT(i=fstat(log_id, &sbuf));    if(i != 0)      {	OSMESSAGE_PRINT( printf("stat err\n") );	return(NIL);      }    save_size = (int)(sbuf.st_size);    size = save_size - previous_size;    if(size > MESSAGE_BUFFER_SIZE) size = MESSAGE_BUFFER_SIZE;    else logChanged = 0; /* only reset msg-pending flg if we cleaned it out! */    TIMEOUT(i=lseek(log_id, previous_size, L_SET));    if(i == -1)      {	OSMESSAGE_PRINT( printf("seek err\n") );	return(NIL);      }D 20    TIMEOUT(size=read(log_id, base, size));E 20I 20	/* Now, read "console output" */    TIMEOUT(size=read(log_id, temp_buf, size));E 20    if(size == -1)      {	OSMESSAGE_PRINT( printf("read err\n") );	return(NIL);      }    TIMEOUT(i=lseek(log_id, save_size, L_SET));    if(i == -1)      {	OSMESSAGE_PRINT( printf("seek err\n") );	return(NIL);      }E 17I 13/*E 13I 2D 7	close(id);E 7I 7D 17	TIMEOUT( close(id) );E 17I 17    TIMEOUT( close(id) );E 17I 13*/E 13E 7E 2D 17	previous_size += size;E 17I 17    previous_size += size;E 17I 2E 2D 17	for(i=0;i<size;++i){		if(base[i] == '\n')D 2			base[i] = '\015';E 2I 2			base[i] = '\000';E 2	}E 17I 17    for(i=0;i<size;++i)      {D 20	if(base[i] == '\n') base[i] = '\000';E 20I 20	if(temp_buf[i] == '\n') temp_buf[i] = '\000';E 20      }I 20	/* COPY actual Lisp Buffer(for BYTESWAP magic) */	StrNCpyFromCToLisp(base,temp_buf, size);E 20E 17D 2	close(id);E 2I 2E 2D 17	return(GetSmallp(size));}E 17I 17    return(GetSmallp(size));I 24#endif XWINDOWE 24  }E 17I 11D 17flush_pty(){int	id;struct stat sbuf;char	buf[MESSAGE_BUFFER_SIZE];	/* Buffer between pty and log file */int	size;static int  rfds;int	rval;struct statfs	fsbuf;E 17D 17	SETJMP(NIL);E 17I 17/************************************************************************//*									*//*			f l u s h _ p t y				*//*									*//*	Called whenever the console/standard-error PTY signals (IO)	*//*	that there's a message waiting to be printed.  Copies the	*//*	msg to the log file, sets the "msg waiting" semaphore, and	*//*	signals the log-message-waiting Lisp interrupt.			*//*									*//************************************************************************/E 17I 17flush_pty()  {I 24#ifndef XWINDOWE 24    int	id;    struct stat sbuf;    char buf[MESSAGE_BUFFER_SIZE];	/* Buffer between pty and log file */    int	size;    static int  rfds;    int	rval;    struct statfs	fsbuf;    SETJMP(NIL);    DBPRINT(("flush_pty() called.\n"));E 17/* polling pty nd flush os message to log file */D 17	rfds = (1 << cons_pty);	if(select(32, &rfds, NULL, NULL, &selecttimeout) < 0 ){E 17I 17#ifndef LOGINT    rfds = (1 << cons_pty);    if(select(32, &rfds, NULL, NULL, &selecttimeout) < 0 ) return(NIL);    if( (cons_pty >= 0) && (rfds & (1 << cons_pty)) )#else LOGINT    if ((cons_pty >= 0) &&	((size = read(cons_pty, buf, MESSAGE_BUFFER_SIZE-1)) > 0))#endif      { /* There are messages to log in the file. */	DBPRINT(("Log msgs being printed...\n"));	close(log_id);	TIMEOUT( log_id=open(logfile, O_WRONLY | O_APPEND, 0666) );	if( log_id == -1)return(NIL);#ifndef LOGINT	size = read(cons_pty, buf, MESSAGE_BUFFER_SIZE-1);#endif	if(size == -1) return(NIL);	/* Check free space to avoid print System Error Mesage	   to /dev/console */	TIMEOUT( rval=statfs("/tmp", &fsbuf) );	if( rval != 0) return(NIL);	if(fsbuf.f_bavail <= (long)0)	  {	    /* No Free Space */	    error("osmessage error: No free space on file system (/tmp).");	    return(NIL);	  }	logChanged = 1;		/* Note the change, for READP */	TIMEOUT( rval=write(log_id, buf, size) );	if( rval == -1)	  {D 24	    if(errno == 28)E 24I 24	    if(errno == ENOSPC)   /* == 28 on Sun, ibm */E 24	      {		/* No free space, but it's too late to avoid		   print system Error Message. */		error("osmessage error: No free space on file system (/tmp).");E 17		return(NIL);D 17	}	if( (cons_pty >= 0) && (rfds & (1 << cons_pty)) ){I 12D 13		TIMEOUT( id=open(logfile, O_WRONLY | O_APPEND, 0666) );		if( id == -1)E 13I 13		close(log_id);		TIMEOUT( log_id=open(logfile, O_WRONLY | O_APPEND, 0666) );		if( log_id == -1)E 13			return(NIL);E 12		size = read(cons_pty, buf, MESSAGE_BUFFER_SIZE-1);		if(size == -1){D 12			error("osmessage error: read from pty failed");E 12			return(NIL);		}D 12		TIMEOUT( id=open(logfile, O_WRONLY | O_APPEND, 0666) );		if( id == -1){			error("osmessage error: log file can not open (/tmp)");E 12I 12D 15		/* Check free space to avoid print System Error Mesage  to /dev/console */E 15I 15		/* Check free space to avoid print System Error Mesage		   to /dev/console */E 15		TIMEOUT( rval=statfs("/tmp", &fsbuf) );		if( rval != 0){E 12			return(NIL);D 12		}else{			/* Check free space to avoid print System Error Mesage  to /dev/console */			TIMEOUT( rval=statfs("/tmp", &fsbuf) );			if( rval != 0){				return(NIL);			}			if(fsbuf.f_bavail <= (long)0){				/* No Free Space */E 12I 12		}		if(fsbuf.f_bavail <= (long)0){			/* No Free Space */			error("osmessage error: No free space on file system (/tmp).");			return(NIL);		}D 13		TIMEOUT( rval=write(id, buf, size) );E 13I 13		TIMEOUT( rval=write(log_id, buf, size) );E 13		if( rval == -1){			if(errno == 28){D 15				/* No free space, but its too late to avoid print system Error Message. */E 15I 15				/* No free space, but its too late to avoid				   print system Error Message. */E 15E 12				error("osmessage error: No free space on file system (/tmp).");				return(NIL);D 12			}			TIMEOUT( rval=write(id, buf, size) );			if( rval == -1){				if(errno == 28){ /* No free space, but its too late to avoid print system Error Message. */					error("osmessage error: No free space on file system (/tmp).");					return(NIL);				}else{				error("osmessage error: can not write to log file (/tmp)");					return(NIL);				}E 12			}else{D 12				close(id);				return(ATOM_T);E 12I 12				error("osmessage error: can not write to log file (/tmp)");				return(NIL);E 12			}I 12		}else{E 17I 17	      }	    else	      {		error("osmessage error: cannot write to log file (/tmp)");		return(NIL);	      }	  }	else	  {E 17I 13/**E 13D 17			close(id);E 17I 17	    close(id);E 17I 13**/E 13D 17			return(ATOM_T);E 12		}	}}E 17I 17	    return(ATOM_T);	  }      }I 24#endif XWINDOWE 24  }E 17E 11E 1