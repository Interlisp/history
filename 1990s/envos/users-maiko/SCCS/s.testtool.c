h32365s 00060/00064/01280d D 1.17 93/02/08 14:59:31 sybalsky 17 16c Big VM (and new CDR coding) changes for 3.0 \nes 00001/00001/01343d D 1.16 92/07/24 10:46:56 sybalsky 16 15c retrofit of SGI & DEC OSF1 changes \nes 00009/00008/01335d D 1.15 92/06/26 13:50:37 sybalsky 15 14c retrofit of 386 unix changes \nes 00005/00005/01338d D 1.14 92/04/21 17:25:23 sybalsky 14 13c shortening file names for DOS \nes 00002/00002/01341d D 1.13 91/08/19 16:23:20 sybalsky 13 12c Use fillpointer for lisp string lengthes 00003/00000/01340d D 1.12 91/04/16 17:35:46 sybalsky 12 11c es 00087/00005/01253d D 1.11 91/02/04 12:55:07 sybalsky 11 10c Support more opcodes (JUMP target printing ,eg) in dump_fnbodyes 00036/00008/01222d D 1.10 91/01/25 18:06:09 sybalsky 10 9c 3-byte atom changeses 00167/00013/01063d D 1.9 91/01/24 11:10:49 sybalsky 9 8c Add dump_fnbody (takes lisp ptr to code block); make them 3-byte-atom safe.es 00001/00001/01075d D 1.8 90/09/18 23:49:26 sybalsky 8 7c Retrofit changes from AIX, DEC3100, PS/2es 00000/00000/01076d D 1.7 90/07/12 16:11:03 sybalsky 7 6c Change to 3-byte atoms under 3BYTEATOMS flages 00002/00002/01074d D 1.6 90/07/04 04:04:13 sybalsky 6 5c DTD change -- 24 bit type namees 00009/00003/01067d D 1.5 90/06/22 17:11:12 fuji 5 4c Add way out from C commandes 00029/00021/01041d D 1.4 90/05/30 11:23:02 sybalsky 4 3c ANSI cx fixeses 00000/00000/01062d D 1.3 90/04/20 01:58:06 sybalsky 3 2c AIX:  shortening file names, bulk change.es 00000/00002/01062d D 1.2 90/04/19 21:58:35 sybalsky 2 1c Fix check-in mistake in headeres 01064/00000/00000d D 1.1 90/04/19 21:03:52 sybalsky 1 0c date and time created 90/04/19 21:03:52 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";D 2/* @(#) Ktesttool.c Version 1.8 (3/23/89). copyright envos & Fuji Xerox  */static char *id = "@(#) Ktesttool.c      1.8 3/23/89";E 2I 15E 15/************************************************************************//*									*/D 15/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 15I 15/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 15/*									*/D 15/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 15I 15/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 15/*									*//************************************************************************/D 15/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. */E 15/***************************************************************//*D 15	file name :	 Ktesttools.cE 15I 15	file name :	 testtool.cE 15	For Debugging Aids	Including :		dump_check_atoms()		print_atomname(index)		dump_dtd()		check_type_68k(type,ptr)		type_num(LISPPTR)		dump_conspage(base , linking )		trace_listpDTD()		a68k( lispptr)		laddr(addr68k)		dump_fnobj(index)I 11		dump_fnbody(lisp-codeaddr)E 11		doko()		dumpl(laddr)		ptintPC()		all_stack_dump(start,end)		date :   14 May 1987   takeshi			 15 May 1987 take			 1  June 1987 take			 21  June 1987 NMitani			  9  Sep. 1987 take*/#include <stdio.h>I 5#include  <setjmp.h>I 12#ifdef AIX#include <sys/types.h>D 17#endif AIXE 17I 17#endif /* AIX */E 17E 12E 5#include "lispemul.h"#include "lispmap.h"D 14#include "address68k.h"#include "lisptypes.h"#include "lispglobal.h"#include "emulglobal.h"E 14I 14#include "adr68k.h"#include "lsptypes.h"#include "lspglob.h"#include "emlglob.h"E 14#include "cell.h"#include "stack.h"#include "ifpage.h"#include "debug.h"#include "dbprint.h"I 9D 14#include "tosfuncall.h"E 14I 14#include "tosfns.h"E 14E 9#define URMAXFXNUM		100#define URSCAN_ALINK		0#define URSCAN_CLINK		1extern int URaid_scanlink;extern int URaid_currentFX;extern FX *URaid_FXarray[];extern int URaid_ArrMAXIndex;/************************************************************************//*									*//*			P R I N T _ A T O M N A M E			*//*									*//*	Given the Atom # for an atom, print the atom's name.		*//*									*//************************************************************************/print_atomname(index)D 17 DLword index; /* atomindex */E 17I 17 LispPTR index; /* atomindex */E 17{ char *pname; DLword length; PNCell *pnptr; pnptr =(PNCell *)GetPnameCell( index); print_package_name(pnptr->pkg_index); pname=(char *) Addr68k_from_LADDR(pnptr->pnamebase); length = (DLword) GETBYTE(pname++); while(length >0){			 putchar(GETBYTE(pname++));			 length--;		}} /* end print_atomname *//************************************************************************//*									*//*		F I N D _ P A C K A G E _ F R O M _ N A M E		*//*									*//************************************************************************/#define PACKAGES_LIMIT 255/** GET PACKAGE INDEX from PACKAGE FULL NAME */find_package_from_name(packname,len)  char *packname;  int len;  {    int index;    PACKAGE *package;    NEWSTRINGP *namestring;    DLword len2;    char *pname;    for(index =1; index <= PACKAGES_LIMIT; index++)      {	package = (PACKAGE *)Addr68k_from_LADDR(			  aref1(*Package_from_Index_word, index));	namestring = (NEWSTRINGP*)Addr68k_from_LADDR(package->NAME);	pname = (char*)Addr68k_from_LADDR(namestring->base);	if(namestring->offset != 0)	  {	    pname += namestring->offset;	  }D 13	len2 = (DLword)(namestring->totalsize);E 13I 13	len2 = (DLword)(namestring->fillpointer);E 13	if(len == len2)	  {	    if(compare_chars(pname, packname, len)==T)	      {		return(index);	      }	  } } /* for end */ return(-1);}/************************************************************************//*									*//*		    P R I N T _ P A C K A G E _ N A M E			*//*									*//************************************************************************/print_package_name(index)  int index;  {    PACKAGE *package;    NEWSTRINGP *namestring;    DLword len;    char *pname;    if(index == 0)      {	printf("#:");	return;      }    package = (PACKAGE *)Addr68k_from_LADDR(			  aref1(*Package_from_Index_word, index));    namestring = (NEWSTRINGP*)Addr68k_from_LADDR(package->NAME);    pname = (char*)Addr68k_from_LADDR(namestring->base);    if(namestring->offset != 0)      {	pname += namestring->offset;	printf("OFFSET:\n");      }D 13    len = (DLword)(namestring->totalsize);E 13I 13    len = (DLword)(namestring->fillpointer);E 13    if(compare_chars(pname , "INTERLISP", len) == T)      {	printf("IL:");	return;      }    else if(compare_chars(pname , "LISP", len) == T)     {	printf("CL:");	return;      }    else if(compare_chars(pname , "XEROX-COMMON-LISP", len) == T)      {	printf("XCL:");	return;      }    else if(compare_chars(pname , "SYSTEM", len) == T)      {	printf("SI:");	return;      }    else if(compare_chars(pname , "KEYWORD", len) == T)     {	printf(":");	return;      }    else if(compare_chars(pname , "COMPILER", len) == T)      {	printf("XCLC:");	return;      }    else      {	while(len >0)	  {	     putchar(GETBYTE(pname++));	     len--;	  }	putchar(':');	return;      }  }  /*print_package_name *//************************************************************************//*									*//*				d u m p _ d t d				*//*									*//*									*//*									*//************************************************************************/dump_dtd()  {    extern DLword *DTDspace;    struct dtd *dtdp;    DLword cnt;    dtdp = (struct dtd *)DTDspace;    dtdp++;    for (cnt = 0; cnt < INIT_TYPENUM; cnt ++)       {	printf("DTD[ %d ] for ",cnt+1);D 6	print_atomname(dtdp->dtd_name);E 6I 6D 17	print_atomname(dtdp->dtd_namelo + (dtdp->dtd_namehi<<16));E 17I 17	print_atomname(dtdp->dtd_name);E 17E 6	putchar('\n');D 6	printf("    dtd_name = %d\n",dtdp->dtd_name);E 6I 6D 17	printf("    dtd_name = %d\n",dtdp->dtd_namelo + (dtdp->dtd_namehi<<16));E 17I 17	printf("    dtd_name = %d\n",dtdp->dtd_name);E 17E 6	printf("    dtd_size = %d\n",dtdp->dtd_size);	printf("    dtd_free = %d\n",dtdp->dtd_free);	printf("    dtd_obsolate = %d\n",dtdp->dtd_obsolate);	printf("    dtd_finalizable = %d\n",dtdp->dtd_finalizable);	printf("    dtd_lockedp = %d\n",dtdp->dtd_lockedp);	printf("    dtd_hunkp = %d\n",dtdp->dtd_hunkp);	printf("    dtd_gctype = %d\n",dtdp->dtd_gctype);	printf("    dtd_descrs = %d\n",dtdp->dtd_descrs);	printf("    dtd_typespecs = %d\n",dtdp->dtd_typespecs);	printf("    dtd_ptrs = %d\n",dtdp->dtd_ptrs);	printf("    dtd_oldcnt = %d\n",dtdp->dtd_oldcnt);	printf("    dtd_cnt0 = %d\n",dtdp->dtd_cnt0);	printf("    dtd_nextpage = %d\n",dtdp->dtd_nextpage);	printf("    dtd_typeentry = 0x%x\n",dtdp->dtd_typeentry);	printf("    dtd_supertype = %d\n",dtdp->dtd_supertype);	dtdp++;      }  } /* end dump dtd *//************************************************************************//*									*//*			c h e c k _ t y p e _ 6 8 k			*//*									*//*	Check that the lisp pointer ptr is of type type, then		*//*	print a message showing the type number.			*//*									*//************************************************************************/check_type_68k(type,ptr) LispPTR *ptr;{ if (type != (GetTypeNumber(LADDR_from_68k(ptr)) ) )  {  printf("Mismatching occur !!! LispAddr 0x%x  type %d\n",LADDR_from_68k(ptr)	  ,type);  exit(-1);  }  printf("LispPTR 0x%x is the datatype %d\n", LADDR_from_68k(ptr)      ,GetTypeNumber(LADDR_from_68k(ptr)) );}/************************************************************************//*									*//*				t y p e _ n u m				*//*									*//*	Given a lisp pointer, return its type number.			*//*									*//************************************************************************/type_num(lispptr) LispPTR lispptr;{  int type;  type = GetTypeNumber(lispptr);  printf("LispPTR 0x%x is datatype %dth\n",lispptr,type);  return(type);}/************************************************************************//*									*//*			d u m p _ c o n s p a g e			*//*									*//*	Print information about a CONS page, and the cells in it.	*//*									*//************************************************************************/dump_conspage(base , linking )   struct conspage *base; /* target conspage address */   int linking;  /* look for chaiing conspage ? T/NIL */  {   ConsCell *cell;   int  i;lp:    printf("conspage at 0x%x(lisp) has %d free cells , next available cell offset is %d ,and next page is 0x%x(lisp)\n",	   LADDR_from_68k(base), (0xff & base->count), 	   (0xff & base->next_cell), base->next_page );    for( i = 0 , cell = (ConsCell *)base+1; i <127; i++,cell++)      {	printf(" LADDR : %d = Cell[ %d ]## cdr_code= %d ,car = %d\n",	       LADDR_from_68k(cell),i+1,cell->cdr_code,cell->car_field);      }    if ((linking==T) && (base->next_page != NIL_PTR))      {	base =(struct conspage *) Addr68k_from_LPAGE(base->next_page);	goto lp;      }  } /* end dump_conspage *//*********************************//* trace the link in ListpDTD->dtd_nextpage */trace_listpDTD(){extern struct dtd *ListpDTD; printf("Dump conspages from ListpDTD chain\n"); dump_conspage(Addr68k_from_LPAGE(ListpDTD->dtd_nextpage) , T);}/************************************************************************//*									*//*				a 6 8 k					*//*									*//*	Given a lisp pointer, print the corresponding native address.	*//*									*//************************************************************************/a68k(lispptr)  LispPTR lispptr;  {    DLword *val;    val = Addr68k_from_LADDR(lispptr);    printf("68k: 0x%x (%d)\n", val, val);  }/************************************************************************//*									*//*			   l a d d r					*//*									*//*	Given a native address, print the corresponding lisp ptr.	*//*									*//************************************************************************/laddr(addr68k)  DLword *addr68k;  {    int val;    val = LADDR_from_68k(addr68k);    printf("LADDR : 0x%x (%d)\n", val, val);  }D 9E 9D 10/*************************************************************//* dump_fnobj(index) */E 10I 10/************************************************************************//*									*//*			d u m p _ f n o b j				*//*									*//*	Given an atom number, dump that atom's definition.		*//*									*//************************************************************************/E 10#define DUMPSIZE 40dump_fnobj(index)  LispPTR index; /* atom index */  {    struct fnhead *fnobj;    DefCell *defcell68k;    LispPTR cell;    DLbyte *scratch;    int i;    defcell68k = (DefCell *)GetDEFCELL68k(index);D 17    fnobj = (struct fnhead *)Addr68k_from_LADDR(defcell68k->defpointer);E 17D 17    /* check if it's the same index ??*/    if (index != (fnobj->framename))      {	printf("DEFCELL says it is ");	print_atomname(index);	printf("\n But Func OBJ says ");	print_atomname(fnobj->framename);	putchar('\n');	return;      }E 17I 17	dump_fnbody(*defcell68k);E 17D 17    printf("***DUMP Func Obj << ");    printf("start at 0x%x lisp address(0x%x 68k)\n",		LADDR_from_68k(fnobj),fnobj);E 17I 17  } /*dump_fnobj end */E 17D 11    print_atomname(index);E 11I 11D 17    print(index);E 11    putchar('\n');E 17D 17    printf("stkmin    : %d\n",fnobj->stkmin);    printf("na        : %d\n",fnobj->na);    printf("pv        : %d\n",fnobj->pv);    printf("startpc   : %d\n",fnobj->startpc);    printf("argtype   : %d\n",fnobj->argtype);    printf("framename : %d\n",fnobj->framename);    printf("ntsize    : %d\n",fnobj->ntsize);    printf("nlocals   : %d\n",fnobj->nlocals);    printf("fvaroffset: %d\n",fnobj->fvaroffset);E 17D 17   scratch= (DLbyte *)fnobj;   for (i= 20; i<(fnobj->startpc); i+=2)      {	printf(" 0x%x(0x%x 68k): 0%o\n",		LADDR_from_68k(scratch), scratch,		(int)(0xffff & (GETWORD((DLword *)(scratch+i)))) );      }E 17D 17    scratch= (DLbyte *)fnobj + (fnobj->startpc);    for (i= 0; i< DUMPSIZE; i++, scratch++)      {D 16	printf(" 0x%x(0x%x 68k): 0%o\n", LADDR_from_68k(scratch), E 16I 16	printf(" 0x%x(0x%x 68k): 0%o\n", LADDR_from_68k(scratch), E 16		scratch, (int)(0xff & GETBYTE(scratch)) );      }E 17D 17} /*dump_fnobj end */I 9D 10/*************************************************************//* dump_fnbody(fnblockaddr) */E 10E 9I 9I 10E 17/************************************************************************//*									*//*			d u m p _ f n b o d y				*//*									*//*	Given the (Lisp) address of a function header, dump the		*//*	function's definition.						*//*									*//************************************************************************/E 10dump_fnbody(fnblockaddr)  LispPTR fnblockaddr; /* atom index */  {    struct fnhead *fnobj;    DefCell *defcell68k;    LispPTR cell;    DLbyte *scratch;    int i;    fnobj = (struct fnhead *)Addr68k_from_LADDR(fnblockaddr);    printf("***DUMP Func Obj << ");    printf("start at 0x%x lisp address(0x%x 68k)\n",		LADDR_from_68k(fnobj),fnobj);D 11    print_atomname(fnobj->framename);E 11I 11    print(fnobj->framename);E 11    putchar('\n');    printf("stkmin    : %d\n",fnobj->stkmin);    printf("na        : %d\n",fnobj->na);    printf("pv        : %d\n",fnobj->pv);    printf("startpc   : %d\n",fnobj->startpc);    printf("argtype   : %d\n",fnobj->argtype);    printf("framename : %d\n",fnobj->framename);    printf("ntsize    : %d\n",fnobj->ntsize);    printf("nlocals   : %d\n",fnobj->nlocals);    printf("fvaroffset: %d\n",fnobj->fvaroffset);   scratch= (DLbyte *)fnobj;   for (i= 20; i<(fnobj->startpc); i+=2)      {D 17	printf(" 0x%x(0x%x 68k): 0%o\n",E 17I 17	int word;	word = (int)(0xffff & (GETWORD((DLword *)(scratch+i)))) ;	printf(" 0x%x(0x%x 68k): 0%6o  0x%4x\n",E 17D 11		LADDR_from_68k(scratch), scratch,E 11I 11		LADDR_from_68k(scratch+i), scratch+i,E 11D 17		(int)(0xffff & (GETWORD((DLword *)(scratch+i)))) );E 17I 17		word, word);E 17      }    scratch= (DLbyte *)fnobj + (fnobj->startpc);D 17    for (i= 0; i< 1000; i++)E 17I 17    for (i= 0; i< 2000; i++)E 17      {D 17	int len = print_opcode(fnobj->startpc+i, scratch);E 17I 17	int len = print_opcode(fnobj->startpc+i, scratch, fnobj);E 17	if (len < 1) return;	scratch += len;	i += (len -1);      }D 10} /*dump_fnobj end */E 10I 10} /*dump_fnbody end */E 10I 10E 10/************************************************************************//*									*//*			p r i n t _ o p c o d e				*//*									*/I 10/*	Print a single opcode's worth of a function body.		*/E 10/*									*/D 10/*									*/E 10/************************************************************************/I 10  /* Opcode names, by opcode */E 10char * opcode_table[256] =   { "-X-", "CAR", "CDR", "LISTP", "NTYPX", "TYPEP", "DTEST", "UNWIND",    "FN0", "FN1", "FN2", "FN3", "FN4", "FNX", "APPLYFN", "CHECKAPPLY*",    "RETURN", "BIND", "UNBIND", "DUNBIND", "RPLPTR.N", "GCREF", "ASSOC", "GVAR_",   "RPLACA", "RPLACD", "CONS", "CMLASSOC", "FMEMB", "CMLMEMBER", "FINDKEY", "CREATECELL",    "BIN", "BOUT", "PROLOG", "RESTLIST", "MISCN", "<>", "RPLCONS", "LISTGET",    "ELT", "NTHCHC", "SETA", "RPLCHARCODE", "EVAL", "ENVCALL", "TYPECHECK.N", "STKSCAN",     "BUSBLT", "MISC8", "UBFLOAT3", "TYPEMASK.N", "PROLOG", "PROLOG", "PROLOG", "PROLOG",    "PSEUDOCOLOR", "<>", "EQL", "DRAWLINE", "STORE.N", "COPY.N", "RAID", "\\RETURN",     "IVAR0", "IVAR1", "IVAR2", "IVAR3", "IVAR4", "IVAR5", "IVAR6", "IVARX",    "PVAR0", "PVAR1", "PVAR2", "PVAR3", "PVAR4", "PVAR5", "PVAR6", "PVARX",    "FVAR0", "FVAR1", "FVAR2", "FVAR3", "FVAR4", "FVAR5", "FVAR6", "FVARX",    "PVAR_0", "PVAR_1", "PVAR_2", "PVAR_3", "PVAR_4", "PVAR_5", "PVAR_6", "PVAR_X",    "GVAR", "ARG0", "IVARX_", "FVARX_", "COPY", "MYARGCOUNT", "MYALINK", "ACONST",    "'NIL", "'T", "'0", "'1", "SIC", "SNIC", "SICX", "GCONST",    "ATOMNUMBER", "READFLAGS", "READRP", "WRITEMAP", "RPPORT", "WPRTPORT", "PILOTBBT", "RCLK",    "MISC1", "MISC2", "RECCELL", "GCSCAN1", "GCSCAN2", "SUBRCALL", "CONTEXT", "<>",    "JUMP", "JUMP", "JUMP", "JUMP", "JUMP", "JUMP", "JUMP", "JUMP",    "JUMP", "JUMP", "JUMP", "JUMP", "JUMP", "JUMP", "JUMP", "JUMP",    "FJUMP", "FJUMP", "FJUMP", "FJUMP", "FJUMP", "FJUMP", "FJUMP", "FJUMP",    "FJUMP", "FJUMP", "FJUMP", "FJUMP", "FJUMP", "FJUMP", "FJUMP", "FJUMP",    "TJUMP", "TJUMP", "TJUMP", "TJUMP", "TJUMP", "TJUMP", "TJUMP", "TJUMP",    "TJUMP", "TJUMP", "TJUMP", "TJUMP", "TJUMP", "TJUMP", "TJUMP", "TJUMP",    "JUMPX", "JUMPXX", "FJUMPX", "TJUMPX", "NFJUMPX", "NTJUMPX", "AREF1", "ASET1",    "PVAR_0^", "PVAR_1^", "PVAR_2^", "PVAR_3^", "PVAR_4^", "PVAR_5^", "PVAR_6^", "POP",    "POP.N", "ATOMCELL.N", "GETBASEBYTE", "INSTANCEP", "BLT", "MISC10", "<>", "PUTBASEBYTE",    "GETBASE.N", "GETBASEPTR.N", "GETBITS.N.FD", "<>", "CMLEQUAL", "PUTBASE.N", "PUTBASEPTR.N", "PUTBITS.N.FD",    "ADDBASE", "VAG2", "HILOC", "LOLOC", "PLUS2", "DIFFERENCE", "TIMES2", "QUOTIENT",    "IPLUS2", "IDIFFERENCE", "ITIMES2", "IQUOTIENT", "IREMAINDER", "IPLUS.N", "IDIFFERENCE.N", "<>",    "LLSH1", "LLSH8", "LRSH1", "LRSH8", "LOGOR2", "LOGAND2", "LOGXOR2", "LSH",    "FPLUS2", "FIDFFERENCE", "FTIMES2", "FQUOTIENT", "UBFLOAT2", "UBFLOAT1", "AREF2", "ASET2",    "EQ", "IGREATERP", "FGREATERP", "GREATERP", "EQUAL", "MAKENUMBER", "BOXIPLUS", "BOSIDIFFERENCE",    "FLOATBLT", "FFTSTEP", "MISC3", "MISC4", "UPCTRACE", "SWAP", "NOP", "CL="      };D 11print_opcode(pc, addr)E 11I 11print_opcode(pc, addr, fnobj)E 11  int pc;  DLbyte * addr;I 11  struct fnhead *fnobj;E 11  {    /* Print the opcode at addr, including args, and return length */    /* if this opcode is the last, return -1			   */    int op = (int) (0xFF & GETBYTE(addr));    int i;    extern unsigned int oplength[256];    int len =oplength[op]+1;    printf(" 0%o (0x%x)	", pc, pc);    for (i=0; i<len; i++) printf("%o ", 0xFF&GETBYTE(addr+i));    printf("	%s", opcode_table[op]);    switch (op)      {	case 0:	putchar('\n');	/* End of function */		return(-1);		break;I 11	case 015:	printf("(%d)", (unsigned char)GETBYTE(addr+1));			addr += 1;	/* FNX uses an extra byte */					/* Fall thru to the name print */E 11	case 006:	/* DTEST */	case 010:	/* FN0-4 */	case 011:	case 012:	case 013:	case 014:	case 027:	/* GVAR_ */D 11	case 057:	/* ACONST */E 11	case 0140:	/* GVAR */I 11	case 0303:	/* INSTANCEP */	case 056:	/* TYPENAMEP */E 11	case 0147:	putchar(' ');D 17#ifdef BIGATOMSE 17I 17#ifdef BIGVM			print_atomname(((unsigned char)GETBYTE(addr+1)<<24)					+ ((unsigned char)GETBYTE(addr+2)<<16)					+ ((unsigned char)GETBYTE(addr+3)<< 8)					+ (unsigned char)GETBYTE(addr+4));#elif BIGATOMSE 17			print_atomname(((unsigned char)GETBYTE(addr+1)<<16)					+ ((unsigned char)GETBYTE(addr+2)<<8)					+ (unsigned char)GETBYTE(addr+3));#else			print_atomname(((unsigned char)GETBYTE(addr+1)<<8)					+(unsigned char)GETBYTE(addr+2));D 17#endif BIGATOMSE 17I 17#endif /* BIGATOMS */E 17I 11			putchar('\n');			break;	case 0200:	/* Jump opcodes */	case 0201:	case 0202:	case 0203:	case 0204:	case 0205:	case 0206:	case 0207:	case 0210:	case 0211:	case 0212:	case 0213:	case 0214:	case 0215:	case 0216:	case 0217:	printf(" 0%o (0x%x)\n", pc+2+op-0200, pc+2+op-0200);			break;	case 0220:	/* FJUMP opcodes */	case 0221:	case 0222:	case 0223:	case 0224:	case 0225:	case 0226:	case 0227:	case 0230:	case 0231:	case 0232:	case 0233:	case 0234:	case 0235:	case 0236:	case 0237:	printf(" 0%o (0x%x)\n", pc+2+op-0220, pc+2+op-0220);			break;	case 0240:	/* TJUMP opcodes */	case 0241:	case 0242:	case 0243:	case 0244:	case 0245:	case 0246:	case 0247:	case 0250:	case 0251:	case 0252:	case 0253:	case 0254:	case 0255:	case 0256:	case 0257:	printf(" 0%o (0x%x)\n", pc+2+op-0240, pc+2+op-0240);			break;	case 0260:	/* JUMPX */	case 0262:	/* FJUMPX */	case 0263:	/* TJUMPX */	case 0264:	/* NFJUMPX */	case 0265:	/* NTJUMPX */			printf(" 0%o (0x%x)\n", pc+(s_char)GETBYTE(addr+1),						pc+(s_char)GETBYTE(addr+1));			break;	case 0261:	/* JUMPXX */			printf(" 0%o (0x%x)\n",				pc+((s_char)GETBYTE(addr+1)<<8)				     + (unsigned char)GETBYTE(addr+2),				pc+((s_char)GETBYTE(addr+1)<<8)				     + (unsigned char)GETBYTE(addr+2));			break;	case 0120:	/* FVAR opcodes */	case 0121:	case 0122:	case 0123:	case 0124:	case 0125:	case 0126:	putchar(' ');			print_atomname(get_fn_fvar_name(fnobj, op-0120));E 11			putchar('\n');			break;	default:	putchar('\n');	      }I 17    fflush(stdout);	/* Make sure each line is really printed as we go. */E 17    return(len);  }E 9D 10/*********************************************************************/E 10I 10/************************************************************************//*									*//*					d o k o				*//*									*//*	For URAID:  Display the current function name & PC.		*//*									*//************************************************************************/E 10 struct doko   {    LispPTR func;    int     pc;  };D 10E 10struct doko doko()  {    struct doko tmp;     printf(" At ");     print_atomname(FuncObj->framename);     putchar('\n');     printf("   PC cnt = 0%o\n" ,tmp.pc=((int)(PC)- (int)FuncObj) );     tmp.func= FuncObj->framename;     return(tmp);  }/**** dump specified area (in 32 bit width) ***/dumpl(laddr)  LispPTR laddr;  {    int i;    LispPTR *ptr;    ptr = (LispPTR *)Addr68k_from_LADDR(laddr);   for(i=0; i< 40; i++,ptr++)      printf("LADDR 0x%x : %d\n", LADDR_from_68k(ptr), *ptr);  }/**** dump specified area (in 16 bit width) ***/dumps(laddr)  LispPTR laddr;  {    int i;    DLword *ptr;    ptr = (DLword *)Addr68k_from_LADDR(laddr);   for(i=0; i< 40; i++,ptr++)      printf("LADDR 0x%x : %d\n", LADDR_from_68k(ptr), (GETWORD(ptr)& 0xffff));  }/***********************/printPC()  {    unsigned short pc;    pc =(int)PC - (int)FuncObj;    printf("PC: O%o ",pc);  }/***************************/countchar(string)  char *string;  {    int cnt=0;    while(*string != '\0') { string++; cnt++;}    return(cnt);  }/***************************************************************//*	Func Name :	dump_stackframe	Desc :		For Debugging Aids	Changed		8 JUN 1987 TAKE*//***************************************************************/dump_stackframe( fx_addr68k )  struct frameex1 *fx_addr68k;  {    Bframe *bf;    if((fx_addr68k->alink & 1)==0)      {   /* FAST */	bf = (Bframe *)(((DLword *)fx_addr68k)  - 2 );      }    else      {   /* SLOW */	bf =(Bframe *) Addr68k_from_LADDR((fx_addr68k->blink+ STK_OFFSET));      }    dump_bf(bf);    dump_fx(fx_addr68k);  }dump_bf(bf)  Bframe *bf;  {    DLword *ptr;    printf("\n*** Basic Frame");    if (BFRAMEPTR(bf)->flags != 4)      {	printf("\nInvalid basic frame"); 	return(0);      };    if (BFRAMEPTR(bf)->residual) {goto printflags;}    ptr = Addr68k_from_LADDR( STK_OFFSET + bf->ivar);    if ( (((DLword*)bf - ptr) > 512) || (( (int)ptr & 1) != 0) )      {	printf("\nInvalid basic frame");	return(0);      }    while(ptr < (DLword *)bf)      {	printf("\n %x : %x %x", LADDR_from_68k(ptr),		GETWORD(ptr), GETWORD(ptr+1));	print(*ptr);	ptr+=2;      }printflags:    printf("\n %x : %x %x ",LADDR_from_68k(bf),*bf, *(bf+1));    putchar('[');    if (BFRAMEPTR(bf)->residual)	printf("Residual, ");    if (BFRAMEPTR(bf)->padding)	printf("Padded, ");    printf("usecnt=%d ] ",BFRAMEPTR(bf)->usecnt);    printf("ivar : 0x%x",BFRAMEPTR(bf)->ivar);}dump_fx( fx_addr68k)  struct frameex1 *fx_addr68k;  {    DLword *next68k;    DLword *ptr;    LispPTR atomindex;    ptr = (DLword *)fx_addr68k;    if(fx_addr68k->flags != 6)      {	printf("\nInvalid frame,NOT FX"); 	return(0);      };    atomindex = get_framename(fx_addr68k);    printf("\n*** Frame Extension for ");    print(atomindex);    printf("\n %x : %x %x ",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));    putchar('[');    if(fx_addr68k->fast) printf("F,");    if(fx_addr68k->incall) printf("incall, ");    if(fx_addr68k->validnametable) printf("V, ");    printf("usecnt = %d]; alink",fx_addr68k->usecount);    if(fx_addr68k->alink & 1)    printf("[SLOWP]");    ptr+=2;    printf("\n %x : %x %x fnheadlo, fnheadhi\n", 		LADDR_from_68k(ptr), GETWORD(ptr), GETWORD(ptr+1));    ptr+=2;    printf("\n %x : %x %x next,     pc\n",		LADDR_from_68k(ptr), GETWORD(ptr), GETWORD(ptr+1));    ptr+=2;    printf("\n %x : %x %x LoNmTbl,  HiNmTbl\n",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));    ptr+=2;    printf("\n %x : %x %x #blink,   #clink\n",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));    /* should pay attention to the name table like RAID does */    next68k = (DLword *)Addr68k_from_LADDR((fx_addr68k->nextblock+STK_OFFSET));    if (fx_addr68k == CURRENTFX) {next68k = CurrentStackPTR + 2;}    if ((next68k < ptr) || (((int)next68k & 1) != 0) )    {printf ("\nNext block invalid"); return(0);}    while(next68k > ptr)      {	ptr+=2;	printf("\n %x : %x %x",		LADDR_from_68k(ptr), GETWORD(ptr), GETWORD(ptr+1));      }    return (0);  } /* end dump_fx */dump_CSTK(before)  int before;  {    DLword *ptr;    ptr= CurrentStackPTR - before;    while(ptr != CurrentStackPTR)      {	printf("\n%x : %x ",LADDR_from_68k(ptr),GETWORD(ptr));	ptr++;      }    printf("\nCurrentSTKP : %x  ",LADDR_from_68k(CurrentStackPTR));    printf("\ncontents :  %x ",*((LispPTR *)(CurrentStackPTR-1)));  }/* dump_CSTK end *//******************************************//* BTV */btv()  {    struct frameex1 *fx_addr68k;    LispPTR atomindex;    struct frameex1 *get_nextFX();    fx_addr68k = CURRENTFX;loop:    dump_stackframe(fx_addr68k);    if( fx_addr68k->alink == 0 )     {printf ("\n BTV end"); return(0);};    fx_addr68k= get_nextFX(fx_addr68k);    goto loop;  } /*end btv*/get_framename(fx_addr68k)  struct frameex1 *fx_addr68k;  {    struct fnhead *fnheader;    LispPTR scratch;    /* Get FNHEAD */I 17#ifdef BIGVME 17    if(fx_addr68k->validnametable==0)      {I 17	scratch  = (unsigned int)(fx_addr68k->fnheader);      }  else      {	scratch  = (unsigned int)(fx_addr68k->nametable);      }#else    if(fx_addr68k->validnametable==0)      {E 17	scratch  = (unsigned int)(fx_addr68k->hi2fnheader << 16);	scratch |= (unsigned int)(fx_addr68k->lofnheader);      }  else      {	scratch  = (unsigned int)(fx_addr68k->hi2nametable << 16);	scratch |= (unsigned int)(fx_addr68k->lonametable);      }I 17#endif /* BIGVM */E 17    fnheader = (struct fnhead *)Addr68k_from_LADDR( scratch );    return(fnheader->framename);  }/* get_framename end */FX *get_nextFX(fx)  FX *fx;  {    DLword *pv;    if(URaid_scanlink==URSCAN_ALINK)	return((FX *)Addr68k_from_StkOffset(GETALINK(fx)));    else	return((FX *)Addr68k_from_StkOffset(GETCLINK(fx)));  } /* get_nextFX end */MAKEATOM(string)  char *string;  {    int length;    length = countchar(string);    return(make_atom(string,0,length,0));  }/************************************************************************//*									*//*			M a k e A t o m 6 8 k				*//*									*//*	Given a LITATOM that exists before the package system was	*//*	turned on, return a pointer to that atom's value cell.		*//*									*//************************************************************************/DLword *MakeAtom68k(string)    char   *string;    {    int index;    index = make_atom(string, 0, countchar(string), 0);I 17#ifdef BIGVM	index = (PNP_HI << 16) + (index * 10) + NEWATOM_VALUE_OFFSET;#elseE 17    index = VALS_OFFSET + (index << 1);I 17#endif /* BIGVM */	E 17    return ( Addr68k_from_LADDR( index ) );    }D 17/****************/E 17I 17/************************************************************************//*									*//*		G E T T O P V A L					*//*									*//*	Print the top-level value of a given atom; for use in dbx.			*//*									*//************************************************************************/E 17GETTOPVAL(string)D 17 char *string;{  int index;  LispPTR *cell68k;E 17I 17  char *string;  {    int index;    LispPTR *cell68k;E 17D 17 index=MAKEATOM(string); cell68k= (LispPTR *)GetVALCELL68k(index);  print(*cell68k);E 17I 17    index=MAKEATOM(string);	if (index != -1)	/* Only print if there's such an atom */      {	cell68k= (LispPTR *)GetVALCELL68k(index);	print(*cell68k);      }    else printf("'%s': no such symbol.\n", string);E 17}/************************************************************************//*									*//*				S _ T O P V A L				*//*									*//*	Given a string that's an atom name minus the initial \,		*//*	print the atom's top-level value.  This is here because		*//*	DBX won't put \'s in strings you type.				*//*									*//************************************************************************/S_TOPVAL(string)  char *string;  {    int index;    LispPTR *cell68k;    int length;    char dummy[256];    dummy[0]='\\';    for(length=1; *string != '\0'; length++,string++)      { 	dummy[length] = *string;      }    index=make_atom(dummy,0,length,0);    cell68k= (LispPTR *)GetVALCELL68k(index);    print(*cell68k);  }/***************/S_MAKEATOM(string) char *string;{  int index=0; int length; char dummy[256]; dummy[0]='\\'; for(length=1; *string != '\0'; length++,string++)  { dummy[length] = *string;} index=make_atom(dummy,0,length,0);  printf("#Atomindex : %d\n",index); return(index);}/****************************************************************************//*     all_stack_dump(start,end)*/D 5#define SDMAXLINE 40#define SD_morep	if(++sdlines>SDMAXLINE){\			 printf("\nPress Return:"); getchar();fflush(stdin);sdlines=0;}E 5I 5jmp_buf SD_jumpbuf;#define SDMAXLINE 30#define SD_morep	if(++sdlines>SDMAXLINE){ int temp;\			 printf("\nPress Return:(to quit Esc and Ret):");\			 temp = getchar();fflush(stdin);\			  sdlines=0;if(temp==27)longjmp(SD_jumpbuf,1) ;}E 5#ifndef BYTESWAPtypedef struct stack_header  {    unsigned	flags1 : 3;    unsigned	flags2  : 5;    unsigned	usecount : 8;  } STKH;#define STKHPTR(ptr) (ptr)#elsetypedef struct stack_header  {    unsigned	usecount : 8;    unsigned	flags2  : 5;    unsigned	flags1 : 3;  } STKH;#define STKHPTR(ptr) ((STKH *) (2^(int)(ptr)))D 17#endif BYTESWAPE 17I 17#endif /* BYTESWAP */E 17all_stack_dump(start,end,silent) DLword start,end ,silent; /* Stack offset in DLword */{  STKH *stkptr;  DLword *start68k,*end68k,*orig68k;  DLword size,dummy;  int sdlines=0; extern IFPAGE *InterfacePage; if(start==0) start68k= Stackspace + InterfacePage->stackbase; else start68k = Addr68k_from_LADDR(STK_OFFSET | start); if(end==0) end68k= Stackspace+ InterfacePage->endofstack; else end68k = Addr68k_from_LADDR(STK_OFFSET | end); stkptr= (STKH *)start68k;I 4E 4  while(((DLword*)stkptr) < end68k )  {	dummy = LADDR_from_68k(stkptr);	switch (STKHPTR(stkptr)->flags1 ) {	case STK_GUARD :	case STK_FSB :			if( (STKHPTR(stkptr)->flags2 !=0) || (STKHPTR(stkptr)->usecount!=0) )				{goto badblock;};			size = GETWORD(((DLword *)stkptr) +1);D 4			if(size <=0 || size > ((DLword*)end68k-(DLword*)stkptr))			 {goto badblock;};E 4			if(STKHPTR(stkptr)->flags1 == STK_GUARD)D 4			printf("\n<<  0x%x GUARD size : 0x%x >>",LADDR_from_68k(stkptr),size );			else printf("\n<<  0x%x FSB size : 0x%x >>",LADDR_from_68k(stkptr),size);E 4I 4			  printf("\n0x%x GUARD, size : 0x%x",				  LADDR_from_68k(stkptr),size );			else printf("\n0x%x FSB,   size : 0x%x",				    LADDR_from_68k(stkptr),size);			if(size <=0 ||			   size > ((DLword*)end68k-(DLword*)stkptr))			  {goto badblock;};E 4			SD_morep;			size = GETWORD(((DLword *)stkptr) +1);	checksize:			if(size <=0 || size > ((DLword*)end68k-(DLword*)stkptr))			 {goto badblock;};D 4			((DLword *)stkptr) += size;E 4I 4			stkptr = (STKH *) (((DLword *) stkptr) + size);E 4			break;	case STK_FX :			/*if((((FX *)stkptr)->pc < 24) ||				(((FX *)stkptr)->alink==0)  ||				 (STKHPTR(stkptr)->usecount > 31))			 {goto badblock;};*/			if (silent)D 4			{SD_morep;			 printf("\n<<  0x%x: FX for ",LADDR_from_68k(stkptr));			 print(get_framename(stkptr));			 printf(" [");			 if(((FX *)stkptr)->fast)	printf("fast,");			 if(((FX *)stkptr)->native)	printf("native,");			 if(((FX *)stkptr)->incall)	printf("incall,");			 if(((FX *)stkptr)->validnametable)	printf("V,");			 if(((FX *)stkptr)->nopush)	printf("nopush,");			 printf("]"); }E 4I 4			  { SD_morep;			    printf("\n0x%x: FX for ",LADDR_from_68k(stkptr));			     print(get_framename(stkptr));			     printf(" [");			     if(((FX *)stkptr)->fast)	printf("fast,");			     if(((FX *)stkptr)->native)	printf("native,");			     if(((FX *)stkptr)->incall)	printf("incall,");			     if(((FX *)stkptr)->validnametable)	printf("V,");			     if(((FX *)stkptr)->nopush)	printf("nopush,");			     printf("]");			  }E 4			else {dump_fx(stkptr);}			if((FX *)stkptr == CURRENTFX) {				printf(" <-***current***");				size= EndSTKP - (DLword*)stkptr;			}			else {D 4			size = (Addr68k_from_LADDR(STK_OFFSET| ((FX *)stkptr)->nextblock) - (DLword*)stkptr);E 4I 4			size = Addr68k_from_LADDR(STK_OFFSET| ((FX *)stkptr)->nextblock) - (DLword*)stkptr;E 4			};			goto checksize;	default :		       orig68k =(DLword*) stkptr;                        while(STKHPTR(stkptr)->flags1 != STK_BF) {                                if(STKHPTR(stkptr)->flags1!=STK_NOTFLG){goto badblock;};D 4                                ((DLword *)stkptr) += DLWORDSPER_CELL;E 4I 4                                stkptr = (STKH *) (((DLword *)stkptr) + DLWORDSPER_CELL);E 4                         };			if((BFRAMEPTR(stkptr))->residual)                          { if((DLword*) stkptr != orig68k)                             {				printf("\n$$$Bad BF(res):0x%x",LADDR_from_68k(stkptr));				goto incptr;			     }			  }			 else			  {				 if(BFRAMEPTR(stkptr)->ivar						!= StkOffset_from_68K(orig68k))				 {					printf("\n$$$BF doesn't point TopIVAR:0x%x\n",LADDR_from_68k(stkptr));					goto incptr;				 }			  }			if(silent)			  { SD_morep;D 4			    printf("\n<<  0x%x: BF ",LADDR_from_68k(stkptr));E 4I 4			    printf("\n0x%x BF,   ",LADDR_from_68k(stkptr));E 4			    putchar('[');			if (BFRAMEPTR(stkptr)->residual) printf("Res,");			if (BFRAMEPTR(stkptr)->padding) printf("Pad,");			printf("ivar : 0x%x]", BFRAMEPTR(stkptr)->ivar);			} else  dump_bf(stkptr);D 4			((DLword *)stkptr) += 2;E 4I 4			stkptr = (STKH*) (((DLword *)stkptr) + 2);E 4			break;	badblock:       SD_morep;D 4			printf("\n!!!<< 0x%x: Invalid, %x %x>>!!!",LADDR_from_68k(stkptr), GETWORD(stkptr), GETWORD(stkptr+1));	incptr:		((DLword *)stkptr)+=2;E 4I 4			printf("\n0x%x: Invalid, %x %x",LADDR_from_68k(stkptr), GETWORD(stkptr), GETWORD(stkptr+1));	incptr:		stkptr = (STKH *) (((DLword *)stkptr) + 2);E 4			break;	} /* case end */  } /* while end */printf("\n<< That's All , last stack :0x%x >>\n",InterfacePage->endofstack);}/************************************************************/dtd_chain(type) DLword type;  {    struct dtd *dtdp;    LispPTR next;    LispPTR *next68k;    dtdp=(struct dtd *)GetDTD(type);    next=dtdp->dtd_free;    next68k=(LispPTR *) Addr68k_from_LADDR(next);    while((*next68k) != 0)      {	if(type != GetTypeNumber(next)) {	printf("BAD cell in next dtdfree\n");	  return; }	print(next);	putchar('\n');	next= *next68k;	next68k=(LispPTR *) Addr68k_from_LADDR(next);      }    printf("That's All !\n");  }/*  dtd_chain end **/D 8#ifdef CHECKE 8I 8#ifdef DEBUGE 8check_dtd_chain(type)D 9	DLword          type;{	register LispPTR next;	LispPTR         before;E 9I 9  DLword          type;  {    register LispPTR next;    LispPTR         before;E 9D 9	next = ((struct dtd *)GetDTD(type))->dtd_free;E 9I 9    next = ((struct dtd *)GetDTD(type))->dtd_free;E 9D 9	while (next != NIL) {		if (type != GetTypeNumber(next)) {			error("BAD cell in next dtdfree ");			return;		}		next = *((LispPTR *)Addr68k_from_LADDR(next));	}}E 9I 9    while (next != NIL)      {	if (next & 1)	  {	    error("Free pointer is ODD!");	    return;	  }	if (type != GetTypeNumber(next))	  {	    error("BAD cell in next dtdfree ");	    return;	  }	next = *((LispPTR *)Addr68k_from_LADDR(next));      }  }E 9#endif/************************************************************************//*									*//*			T R A C E _ F N C A L L				*//*			T R A C E _ A P P L Y				*//*									*//*	Functions for tracing function call and apply.  Trace_FNCall	*//*	takes 2 arguments:  The # of args the fn is bing called with	*//*	and the atom index of the function's name.			*//*									*//*	Trace_APPLY takes one argument:  The atom number of the		*//*	atom being applied.						*//*									*//************************************************************************/Trace_FNCall(numargs, atomindex)  int numargs;  int atomindex;  {    printf("Calling a %d-arg FN:  ", numargs);    print_atomname(atomindex);    printf(".\n");  }Trace_APPLY(atomindex)  int atomindex;  {    printf("APPLYing an atom:  ");    print_atomname(atomindex);    printf(".\n");  }E 1