h06193s 00030/00015/00803d D 2.43 92/11/25 21:06:36 sybalsky 53 52c Fixing endif's with extra text => comment. \nes 00000/00000/00818d D 2.42 92/07/24 10:46:13 sybalsky 52 51c retrofit of SGI & DEC OSF1 changes \nes 00073/00024/00745d D 2.41 92/06/26 13:49:31 sybalsky 51 50c retrofit of 386 unix changes \nes 00002/00001/00767d D 2.40 92/04/27 18:46:49 nilsson 50 49c Fix of Xdisplay deps.es 00003/00003/00765d D 2.39 92/04/21 17:16:54 sybalsky 49 48c shortening file names for DOS \nes 00008/00005/00760d D 2.38 92/03/20 17:21:13 sybalsky 48 47c Add ability to see key-#s of keystrokes, conditioned on SHOWKEYSTROKES flag.es 00131/00139/00634d D 2.37 92/03/10 14:29:00 sybalsky 47 46c cleanup, reformattinges 00001/00000/00772d D 2.36 92/03/04 18:55:42 sybalsky 46 45c 386es 00011/00003/00761d D 2.35 92/01/16 12:35:06 sybalsky 45 44c 386 changeses 00025/00004/00739d D 2.34 91/10/15 18:15:56 sybalsky 44 43c ISC changeses 00006/00002/00737d D 2.33 90/07/04 04:00:47 sybalsky 43 42c New interrupt code; count ether interrupts so as not to lose them.es 00024/00002/00715d D 2.32 90/06/26 14:49:34 sybalsky 42 41c Fix X-window code to eliminate parts that aren't used when X is in use.es 00008/00002/00709d D 2.31 90/06/22 16:39:33 fuji 41 40c New compile flag NOETHERes 00002/00002/00709d D 2.30 90/06/18 20:05:05 fuji 40 39c Makes Cntrl-Shift-Return as emergency interruptes 00003/00001/00708d D 2.29 90/05/25 11:53:33 osamu 39 38c in function taking_mouse_up() c 	copy_cursor(newx,newy) doesn't work when INIT.es 00004/00002/00705d D 2.28 90/05/14 12:05:06 fuji 38 37c Matsuda: support color funcs on CG6es 00001/00001/00706d D 2.27 90/05/02 17:00:54 fuji 37 36c Fix missed comma in Line#563.c old: flush_display_region(dx, LastCursorY, w h); c new: flush_display_region(dx, LastCursorY, w, h);es 00000/00000/00707d D 2.26 90/04/20 01:40:40 sybalsky 36 35c tening file names, bulk change.es 00003/00005/00704d D 2.25 90/03/02 14:45:07 takeshi 35 34c Remove ifdef around RCLKes 00016/00000/00693d D 2.24 90/03/01 13:57:35 osamu 34 33c Mitsunori Matsuda adds XWindow functionality.es 00002/00003/00691d D 2.23 90/02/12 11:50:00 takeshi 33 32c Add SCCS headeres 00017/00000/00677d D 2.22 89/12/29 13:01:17 sybalsky 32 31c Changes from Savoir -- Interrupt driver, add IO interruptes 00078/00011/00599d D 2.21 89/12/13 10:56:12 sybalsky 31 30c color ss1, interrupt-driven ether & loges 00181/00149/00429d D 2.20 89/10/19 17:59:46 sybalsky 30 29c display bufferinges 00055/00035/00523d D 2.19 89/04/03 13:03:48 shih 29 28c removed GETWORD from Emxxxx, already aligned.  PYUTes 00015/00003/00543d D 2.18 89/03/30 20:32:00 sybalsky 28 27c Byte swappinges 00021/00027/00525d D 2.17 89/03/27 16:59:51 sybalsky 27 26c Refs to word pointers, some fixed.  Still emulator word ptrs to look at.es 00015/00000/00537d D 2.16 89/02/14 13:40:53 snow 26 25c added code to keyevent to check for making an inites 00123/00009/00414d D 2.15 89/01/17 10:04:51 shimizu 25 24c Add Color cursores 00159/00007/00264d D 2.14 89/01/04 16:59:40 shimizu 24 23c For C-Cursor trackinges 00011/00000/00260d D 2.13 88/12/06 12:15:05 shimizu 23 22c Add Cnt-Shift-Return as extra emergency interrupt for TYPE4KBD(OS4 only)es 00000/00000/00260d D 2.12 88/11/09 16:57:31 bane 22 21c I forget...es 00001/00001/00259d D 2.11 88/10/17 20:01:15 shimizu 21 20c For type-4 kbd changeses 00003/00067/00257d D 2.10 88/10/10 19:48:36 shimizu 20 19c move some MACROs to keyboard.hes 00007/00002/00317d D 2.9 88/09/14 11:52:54 shimizu 19 18c To notice keytransition when exit from URAIDes 00011/00004/00308d D 2.8 88/07/21 09:56:26 shimizu 18 17c Add Shift-Cnt-NEXT for emergency Interruptes 00006/00002/00306d D 2.7 88/07/06 18:18:29 shimizu 17 16c for KEYDOWNP1 put a bit data to EmUtilin68K in kb_transes 00002/00007/00306d D 2.6 88/06/27 01:50:41 bane 16 15c changed getsignaldata to take advantage of FNDELAY on LispWindowFdes 00018/00010/00295d D 2.5 88/06/24 23:04:53 bane 15 14c Added KB interrupt code and KBINT ifdefses 00006/00110/00299d D 2.4 88/06/21 16:03:25 masinter 14 13c Fix cursor so it doesn't jump; remove obsolete codees 00271/00006/00138d D 2.3 88/06/20 21:58:03 shimizu 13 12c For C KeyHandleres 00017/00127/00127d D 2.2 88/05/31 20:00:31 masinter 12 11c eliminate io interrupts: made things wrse. Fix getsignaldata to discard multiple mouse moveses 00000/00000/00254d D 2.1 88/05/17 09:25:34 hayata 11 10c Version up to 2.1es 00004/00004/00250d D 1.10 88/05/11 12:01:37 hayata 10 9c Comment out ether polling in getsignaldat for new ether code.es 00006/00004/00248d D 1.9 88/05/10 19:42:12 krivacic 9 8c new Irq_Stk_Check, Irq_Stk_Endes 00025/00014/00227d D 1.8 88/04/27 13:55:44 bane 8 7c Minor cleanup on I/O interrupts, plus commented experimental codees 00030/00012/00211d D 1.7 88/04/27 09:16:17 bane 7 6c added I/O interrupt code to getsignaldataes 00002/00002/00221d D 1.6 88/03/13 14:53:08 hayata 6 5c Add SCCS key id (%Z%)es 00020/00072/00203d D 1.5 88/03/10 11:09:44 shimizu 5 4c Use MACROS PUTBASEBIT68K and Remove obsolte lines and functionses 00004/00003/00271d D 1.4 88/03/09 19:25:48 shimizu 4 3c change if condition for select calles 00042/00051/00232d D 1.3 88/03/09 17:10:14 takeshi 3 2c Remove redundant vars.Using MACROS(MouseMove,ADDBASE68K)es 00006/00005/00277d D 1.2 88/03/01 15:29:05 takeshi 2 1c Fix mouse response issue. Remove redundant reg-var(DeviceID). Mouse can get his position even on High-Reso Display.(takeshi)es 00282/00000/00000d D 1.1 88/02/24 16:57:46 hayata 1 0c date and time created 88/02/24 16:57:46 by hayataeuUtTI 1D 6/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 6I 6D 28/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 28I 28D 29/* This is G-file @(#) keyevent.c Version 2.17 (3/27/89). copyright Xerox & Fuji Xerox  */static char *id = "@(#) keyevent.c	2.17 3/27/89";E 29I 29D 31/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 31I 31D 33/* @(#) keyevent.c Version 2.19 (4/3/89). copyright envos & Fuji Xerox  */static char *id = "@(#) keyevent.c	2.19 4/3/89		(envos & Fuji Xerox)";I 32E 33I 33D 42/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 42I 42/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 42D 35static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 35I 35static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 35E 33I 47E 47/************************************************************************//*									*/D 47/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 47I 47/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 47/*									*/D 47/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 47I 47/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 47/*									*//************************************************************************/E 32E 31E 29E 28E 6D 12/*** ADOPTED NEW VERSION ***/E 12/*D 29 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.E 29I 29D 31 *	Copyright (C) 1989 by Fuji Xerox Co., Ltd. All rights reserved.E 31I 31D 47 *	Copyright (C) 1989 by Fuji Xerox Co., Ltd., Venue, and Xerox. *		  All rights reserved.E 31E 29 *D 12 *	Auther	:	Osamu Nakamura	E 12I 12 *	Author	:	Osamu Nakamura	E 12 *//*E 47D 29 *	This file contains the noutines that intenface Lisp to the *	Sun keyboand and mouse.E 29I 29 *	This file contains the routines that interface Lisp to the *	Sun keyboard and mouse.E 29 * */#include	<stdio.h>#include	<signal.h>I 44#include	<sys/types.h>E 44#include	<sys/file.h>#include	<sys/ioctl.h>I 13#include	<sys/time.h>I 42#ifndef XWINDOWE 42E 13#include	<sunwindow/window_hs.h>#include	<sunwindow/win_ioctl.h>D 29#include <suntool/window.h>#include <ctype.h>E 29I 29#include	<suntool/window.h>#include	<ctype.h>E 29#include	<sundev/kbio.h>I 43#elseD 44#include	<sys/types.h>E 44#define TRUE 1#define FALSE 0E 43I 42D 53#endif XWINDOWE 53I 53#endif /* XWINDOW */E 53E 42I 53E 53I 44#ifdef ISC#include <sys/bsdtypes.h>#include <signal.h>#define SIGIO SIGPOLLD 53#endif ISCE 53I 53#endif /* ISC */E 53I 53E 53E 44#include "lispemul.h"D 49#include "lispglobal.h"#include "address68k.h"E 49I 49#include "lspglob.h"#include "adr68k.h"E 49#include "address.h"#include "stack.h"I 20#include "keyboard.h"I 24#include "display.h"I 27D 49#include "lisptypes.h"E 49I 49#include "lsptypes.h"E 49E 27E 24E 20I 20E 20#include "iopage.h"#include "ifpage.h"D 2#include "display.h"E 2I 24#include "bb.h"#include "bitblt.h"#include "pilotbbt.h"E 24I 31#include "dbprint.h"I 51#ifdef ISC	/*****************************************************/	/*  ISC Unix uses POLL, rather than SELECT, because  */	/*  SELECT causes intermittent wild jumps.  This is  */	/*  the pollfd structure to drive it.		     */	/*****************************************************/#include <poll.h>struct pollfd  pollfds[33] = { {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0},			       {0, POLLIN|POLLOUT, 0} };D 53#endif ISCE 53I 53#endif /* ISC */E 53I 53E 53E 51E 31I 2D 20E 2#define	MOUSE_LEFT	13#define	MOUSE_MIDDLE	15#define	MOUSE_RIGHT	14#define	CAPSKEY		16E 20/* for contextsw */#define AS_OPCODE	1#define AS_CPROG	0I 4D 27#define MouseMove(x,y) {(*((DLword *)EmMouseX68K)) = x;\			(*((DLword *)EmMouseY68K)) = y;}E 27I 27D 29#define MouseMove(x,y) {(GETWORD((DLword *)EmMouseX68K)) = x;\			(GETWORD((DLword *)EmMouseY68K)) = y;}E 29I 29/*  EmMouseX68K are already swapped, no need for GETWORD */#define MouseMove(x,y) {*((DLword *)EmMouseX68K) = x;	\			*((DLword *)EmMouseY68K) = y;}E 29E 27I 29#ifndef BYTESWAPE 29I 5#define PUTBASEBIT68K(base68k, offset, bitvalue ) { \	if( bitvalue) \D 27		*((DLword*)(base68k) + (((u_short)(offset))>>4 )) \E 27I 27D 29		GETWORD((DLword*)(base68k) + (((u_short)(offset))>>4 )) \E 27				|= 1 << (15 - ((u_short)(offset))%BITSPER_DLWORD); \	else	 \D 27		*((DLword*)(base68k) + (((u_short)(offset))>>4 ))  \E 27I 27		GETWORD((DLword*)(base68k) + (((u_short)(offset))>>4 ))  \E 27				&= ~( 1 << (15 - ((u_short)(offset)) %BITSPER_DLWORD)); \E 29I 29		*((DLword*)(base68k) + (((u_short)(offset))>>4 )) \		|=    1 << (15 - ((u_short)(offset))%BITSPER_DLWORD); \	    else	 \		*((DLword*)(base68k) + (((u_short)(offset))>>4 ))  \		&= ~( 1 << (15 - ((u_short)(offset)) %BITSPER_DLWORD)); \E 29	}I 29#elseE 29I 29/* convert to real 68 k address, then do arithmetic, and convert   back to i386 address pointer */E 29I 29#define PUTBASEBIT68K(base68k, offset, bitvalue ) { \    int real68kbase;		\    real68kbase = 2 ^ ((int)(base68k));		\	if( bitvalue) \		GETWORD((DLword*)(real68kbase) + (((u_short)(offset))>>4 )) \		|=    1 << (15 - ((u_short)(offset))%BITSPER_DLWORD); \	    else	 \		GETWORD((DLword*)(real68kbase) + (((u_short)(offset))>>4 ))  \		&= ~( 1 << (15 - ((u_short)(offset)) %BITSPER_DLWORD)); \	}#endifE 29E 5E 4D 17extern DLword  *EmMouseX68K, *EmMouseY68K, *EmKbdAd068K, *EmRealUtilin68K;E 17I 17extern DLword  *EmMouseX68K, *EmMouseY68K, *EmKbdAd068K, *EmRealUtilin68K,*EmUtilin68K;E 17D 13E 13I 13extern DLword  *EmKbdAd168K,*EmKbdAd268K,*EmKbdAd368K,*EmKbdAd468K,*EmKbdAd568K;E 13D 21extern u_char SUNLispKeyMap[];E 21I 21extern u_char *SUNLispKeyMap;E 21extern u_int   LispReadFds, LispWindowFd;D 41extern int	ether_fd;E 41D 44extern int     TTY_Fd, RS232C_Fd;E 44I 44D 51extern int     RS232CReadFds, RS232C_remain_data, Xfd;E 51I 51extern int     RS232CReadFds, RS232C_remain_data, Xfd, XLocked;int XNeedSignal = 0;	/* T if an X interrupt happened while XLOCK asserted */E 51E 44I 41#ifdef NOETHERextern u_int	LogFileFd;#elseextern int	ether_fd;E 41I 31extern u_int	LogFileFd, EtherReadFds;I 41D 53#endif NOETHERE 53I 53#endif /* NOETHER */E 53E 41E 31I 24extern DLword *DisplayRegion68k;E 24I 31u_int LispIOFds = 0;E 31static	struct timeval	SelectTimeout = {	0, 0	};I 34#ifdef XWINDOWstatic int Xcount=1;extern int Event_Req;I 50extern int *Xdisplay;		/* DANGER!! /jarl nilsson 27-apr-92 */E 50D 53#endif XWINDOWE 53I 53#endif /* XWINDOW */E 53E 34I 13I 34I 53E 53E 34extern MISCSTATS *MiscStats; LispPTR *LASTUSERACTION68k; LispPTR *CLastUserActionCell68k; LispPTR *CURSORDESTHEIGHT68k; LispPTR *CURSORDESTWIDTH68k; LispPTR *CURSORHOTSPOTX68k; LispPTR *CURSORHOTSPOTY68k; LispPTR *SOFTCURSORUPP68k;I 24 LispPTR *SOFTCURSORWIDTH68k; LispPTR *SOFTCURSORHEIGHT68k; LispPTR *CURRENTCURSOR68k;E 24extern DLword *EmCursorX68K;extern DLword *EmCursorY68K;D 20#define HARDCURSORHEIGHT 16E 20I 28D 51#ifndef BYTESWAPE 28D 47typedef struct {		unsigned nil : 8;		unsigned type: 8;		unsigned num : 16;} SNum;E 47I 47typedef struct  {    unsigned nil : 8;    unsigned type: 8;    unsigned num : 16;  } SNum;E 47I 28#elseD 47typedef struct {		unsigned num : 16;		unsigned type: 8;		unsigned nil : 8;} SNum;E 47I 47typedef struct  {    unsigned num : 16;    unsigned type: 8;    unsigned nil : 8;  } SNum;E 51E 47E 28I 28D 51#endif BYTESWAPE 28#define  IDiff(x68k,y68k)	(((SNum*)(x68k))->num - ((SNum*)(y68k))->num)E 51I 51E 51I 29/*  EmXXXX68K are already swapped, no need for GETWORD */E 29I 24#ifdef OLD_CURSORE 24#define TrackCursor(cx,cy)	{*CLastUserActionCell68k = MiscStats->secondstmp;\D 14	if(cx >= IDiff(CURSORDESTWIDTH68k , CURSORHOTSPOTX68k))  \	{cx = IDiff(CURSORDESTWIDTH68k , CURSORHOTSPOTX68k) -1;\		goto tr1;\	}\	else if(cy >= (((SNum*)CURSORDESTHEIGHT68k)->num - HARDCURSORHEIGHT))\	  {tr1:\		 if( cy >= IDiff(CURSORDESTHEIGHT68k, CURSORHOTSPOTY68k)) {\			cy = IDiff(CURSORDESTHEIGHT68k , CURSORHOTSPOTY68k) -1;\		 }\	  }\E 14D 27	*EmCursorX68K= cx;\	*EmCursorY68K= cy;}E 27I 27D 29	GETWORD(EmCursorX68K)= cx;\	GETWORD(EmCursorY68K)= cy;}E 29I 29	*EmCursorX68K = cx;	\	*EmCursorY68K = cy;}E 29E 27I 24#else#define TrackCursor(cx,cy)	{*CLastUserActionCell68k = MiscStats->secondstmp;\	taking_mouse_down();\	taking_mouse_up(cx,cy); \D 27	*EmCursorX68K= cx;\	*EmCursorY68K= cy;}E 27I 27D 29	GETWORD(EmCursorX68K)= cx;\	GETWORD(EmCursorY68K)= cy;}E 29I 29	*EmCursorX68K= cx;\	*EmCursorY68K= cy;}E 29E 27D 53#endif OLD_CURSORE 53I 53#endif /* OLD_CURSOR */E 53E 24I 24I 53E 53E 24E 13I 7D 8/* utility function that returns true if input is waiting on a file */left_to_read(fd) int fd;E 8I 8D 12extern int FileIOFlag;D 9extern int LoopCounter;E 9I 9extern int Irq_Stk_Check, Irq_Stk_End;E 9E 12/* function that checks to see if more input is waiting on a file;	if some is, it bumps FileIOFlag so it'll get seen next time around */D 9/* commented out is some code that would also clobber LoopCounter to forceE 9I 9/* commented out is some code that would also clobber 	Irq_Stk_Check & Irq_Stk_End to forceE 9	a new interrupt as rapidly as possible; it causes odd behavior...	needs some study and thought */D 12check_for_more(fd) int fd;E 8{D 8	int result;	ioctl(fd, FIONREAD, &result);	return result;E 8I 8	/* if FileIOFlag is still positive after being bumped, we don't have to		check; we'll be back soon... */	if(!--FileIOFlag) {		int result;E 12D 12		ioctl(fd, FIONREAD, &result);		if(result) {			FileIOFlag = 1;			/* This causes odd behavior; removing for now... */D 9			/* LoopCounter = 0; */E 9I 9			/* Irq_Stk_End = Irq_Stk_Check = 0; */E 9		}D 9	} /* else LoopCounter = 0;	 this too, no doubt... */E 9I 9	} /* else Irq_Stk_End = Irq_Stk_Check = 0;						 this too, no doubt... */E 9E 8}E 12I 12/* this is currently called EVERY time the timer expires. It checks for   keyboard input */E 12E 7I 7D 12E 7/*  for debug */extern int DebugKBD;extern FILE *KBlog;extern	int errno;I 7D 8extern int FileIOFlag;E 8E 7getsignaldata()E 12I 12D 13void getsignaldata()E 13I 13D 20/***********NEWLY ADDED************/typedef struct {		DLword read;		DLword write; } RING;#define RING_READ(head68k)	(((RING*)(head68k))->read)#define RING_WRITE(head68k)	(((RING*)(head68k))->write)	#define MAXKEYEVENT	4598#define MINKEYEVENT	2#define KEYEVENTSIZE	 12		/* for feature use */typedef struct {	DLword 	mousex;	DLword	mousey;	DLword	utilin;	DLword	kbdad0;	DLword	kbdad1;	DLword	kbdad2;	DLword	kbdad3;	DLword	kbdad4;	DLword	kbdad5;} IOState;typedef struct {	DLword W0;	DLword W1;	DLword W2;	DLword W3;	DLword WU;	DLword W4;	DLword W5;	int		time;	unsigned	mousestate	: 3;	unsigned	shift1		: 1;	unsigned	shift2		: 1;	unsigned	lock		: 1;	unsigned	ctrl		: 1;	unsigned	meta		: 1;	unsigned	font		: 1;	unsigned	usermode1	: 1;	unsigned	usermode2	: 1;	unsigned	usermode3	: 1;	unsigned	nil		: 4;	DLword	mousex;	DLword	mousey;} KBEVENT;#define DLMOUSEUP 	0#define DLMOUSEWAITING 	1#define DLMOUSENORMAL 	2#define MOUSE_ALLBITS	7E 20I 20LispPTR *MOUSECHORDTICKS68k;E 20D 20 LispPTR *MOUSECHORDTICKS68k;#define KB_ALLUP		0xffff#define RCLK(place) {  struct timeval time;\					gettimeofday(&time,NULL);\					(place)=(time.tv_sec * 1000000)+time.tv_usec;}E 20/**NEW GLOBAL***-> will be moved***/LispPTR *KEYBOARDEVENTQUEUE68k;LispPTR *KEYBUFFERING68k;D 24int	MouseMoveFlg=0;E 24int	KBDEventFlg=NIL;DLword *CTopKeyevent;LispPTR DOBUFFEREDTRANSITION_index;LispPTR INTERRUPTFRAME_index;LispPTR *TIMER_INTERRUPT_PENDING68k;LispPTR *PENDINGINTERRUPT68k;LispPTR ATOM_STARTED;LispPTR *PERIODIC_INTERRUPT68k;LispPTR *PERIODIC_INTERRUPT_FREQUENCY68k;LispPTR PERIODIC_INTERRUPTFRAME_index;LispPTR DORECLAIM_index;I 32LispPTR *IOINTERRUPTFLAGS_word;E 32I 18int URaid_req=NIL;I 24int ScreenLocked=NIL;E 24E 18I 24DLword MonoCursor_savebitmap[CURSORHEIGHT]; /* for mono cursor save-image */#define COLOR_DEPTH 8#define COLORPIXELS_IN_LONGWORD 4D 25LispPTR ColorCursor_savebitmap[CURSORWIDTH/COLORPIXELS_IN_LONGWORD * CURSORHEIGHT];E 25I 25#define COLORPIXELS_IN_DLWORD 2DLword ColorCursor_savebitmap[CURSORWIDTH/COLORPIXELS_IN_DLWORD * CURSORHEIGHT];I 30/************************************************************************//*									*//*			G E T S I G N A L D A T A			*//*									*//*	Handler for the SIGIO interrupt, which happens			*//*		1. When a key transition happens			*/D 31/*		2. On mouse moves??					*/E 31I 31/*		2. On mouse moves					*//*		3. When TCP input becomes available.			*//*		4. When a NIT ethernet packet becomes available.	*//*		5. When a console/log/stderr msg needs to be printed.	*/E 31/*									*/I 31/*									*//*									*//*									*//*									*//*									*//*									*//*									*//*	Statics:  LispReadFds	A 32-bit vector with a 1 for each	*//*				FD that can get SIGIO interrupts.	*//*									*//*		  LispWindowFd	The keyboard/window FD, for keyboard	*//*				and mouse events.			*//*									*//*		  LispIOFds	A bit vector of TCP FDs, or other	*//*				FDs Lisp is doing async I/O on.		*//*				Activity on any of these will signal	*//*				the Lisp IOInterrupt interrupt.		*//*									*//*		  ether_fd	The raw ethernet FD, for 10MB I/O	*//*									*//*		  EtherReadFds	A bit vector with the raw enet's	*//*				bit turned on.  To speed up processing.	*//*									*//*		  LogFileFd	A bit vector with the log-file's	*//*				bit on, for capturing console msgs.	*//*									*//*									*//*									*/E 31/************************************************************************/E 30E 25E 24D 20/**** NEWLY ADDED END *****/E 20D 15 getsignaldata(sig, code, scp)E 15I 15getsignaldata(sig, code, scp)E 15D 30int sig, code;struct sigcontext *scp;E 13E 12{D 12        struct itimerval TimeLeft;E 12        struct inputevent event;D 12        static int ether_result;E 12D 3        int result, rfds, wfds, nfds, port;E 3I 3        static int  rfds;E 30I 30  int sig, code;  struct sigcontext *scp;  {I 42#ifndef XWINDOWE 42    struct inputevent event;I 42D 53#endif XWINDOWE 53I 53#endif /* XWINDOW */E 53E 42D 31    static int  rfds;E 31I 31D 51    static int  rfds, wfds, efds;E 51I 51    static int  rfds, wfds, efds, res;E 51E 31E 30I 24I 51#ifdef ISC	int fdcount = 0;	int bit;#endifE 51I 34#ifdef XWINDOWI 45D 47#ifdef ISC    sighold(SIGPOLL);#endif ISCE 47E 45D 44    if( Event_Req ) {	getXsignaldata();E 44I 44D 51#ifdef neverE 51I 51#if (defined(APOLLO) || defined(sun))E 51D 45if( Event_Req ) {printf("."); fflush(stdout);	getXsignaldata();E 45I 45    if( Event_Req )      {D 48	printf("."); fflush(stdout);	getXsignaldata();E 48I 48D 51	getXsignaldata();E 51I 51	if (!XLocked) getXsignaldata(Xdisplay);	else XNeedSignal = 1;E 51E 48E 45E 44	Event_Req = FALSE;D 45    }E 45I 45      }E 45I 44D 51#endif neverE 51I 51#endif E 51E 44D 53#endif XWINDOWE 53I 53#endif /* XWINDOW */E 53I 53E 53E 34E 24I 15D 16		long eventsleft;E 16I 16D 31#ifndef KBINTE 31I 31/* #ifndef KBINT */E 31E 16E 15D 12	register int *rfdsptr;E 3E 12D 30        rfds = LispReadFds;I 15/* label and ifs not needed if only keyboard on SIGIO */E 30I 30    rfds = LispReadFds;I 31    efds = LispReadFds;E 31   /* label and ifs not needed if only keyboard on SIGIO */E 30D 16#ifndef KBINTE 16E 15D 3        /* wfds = LispWriteFds;		*/        if( (nfds = select(32, &rfds, NULL, NULL, &SelectTimeout)) > 0 ){                if( rfds & (1 << LispWindowFd) ){E 3I 3D 4        if( select(32, &rfds, NULL, NULL, &SelectTimeout) > 0 ){E 4I 4D 7        if( select(32, &rfds, NULL, NULL, &SelectTimeout) >= 0 ){E 4                if( rfds & (1 << LispWindowFd) )			{E 3                        if( input_readevent(LispWindowFd, &event) != -1 ){                                        kb_event( &event );D 3                        }else{				fprintf( stderr,"input_readevent: errno = %d\m", errno );				exit( -1 );			}                }E 3I 3                        }				  else				   {					fprintf( stderr,"input_readevent: errno = %d\m", errno );E 7I 7D 12	if(FileIOFlag) {E 12I 12D 13getmore:E 13I 13getmore: I 51#ifdef ISC	for (res=0, bit=1; res<32; res++, bit <<= 1)	  if (LispReadFds&bit)	{	  pollfds[fdcount++].fd = res;	}    if ((res = poll(pollfds, fdcount, 0)) > 0)#elseE 51D 15	int_block();E 15E 13E 12D 30        if(select(32, &rfds, NULL, NULL, &SelectTimeout) >= 0 ){                if( rfds & (1 << LispWindowFd) ) {E 30I 30D 31    if(select(32, &rfds, NULL, NULL, &SelectTimeout) >= 0 )E 31I 31    if(select(32, &rfds, NULL, &efds, &SelectTimeout) >= 0 )E 31D 51      {E 51I 51#endif	  {E 51I 31	DBPRINT(("SIGIO: fd mask(r/e) = 0x%x/0x%x.\n", rfds, efds));I 34#ifdef SUNDISPLAYE 34E 31	if( rfds & (1 << LispWindowFd) )	  {E 30I 15D 31#endifE 31I 31/* #endif */E 31D 16					do {E 15D 8					FileIOFlag--;E 8D 12                    if( input_readevent(LispWindowFd, &event) != -1 ){                        kb_event( &event );D 8						if(left_to_read(LispWindowFd)) FileIOFlag++;E 8I 8						check_for_more(LispWindowFd);E 8                    } else {					  fprintf( stderr,"input_readevent: errno = %d\m", errno );E 7					exit( -1 );				   }    			}E 3D 10                /*  code for ether event by kiuchi*/E 10I 10                /*  code for ether event by kiuchiE 10		if( (ether_fd >= 0) && (rfds & (1 << ether_fd)) ){I 7D 8			FileIOFlag--;E 8E 7			ether_result = CheckEther();I 7D 8			if(left_to_read(ether_fd)) FileIOFlag++;E 8I 8			check_for_more(ether_fd);E 8E 7D 10		}E 10I 10		}*/E 10                D 10		/* code for serial port event */E 10I 10		/* code for serial port event E 10D 7		if ( rfds & (1 << RS232C_Fd) )E 7I 7		if ( rfds & (1 << RS232C_Fd) ) {D 8			FileIOFlag--;E 8E 7			RS232C_readcont();D 7		if ( rfds & (1 << TTY_Fd) )E 7I 7D 8			if(left_to_read(RS232C_Fd)) FileIOFlag++;E 8I 8			check_for_more(RS232C_Fd);E 8		}		if ( rfds & (1 << TTY_Fd) ) {D 8			FileIOFlag--;E 8E 7			TTY_get();I 7D 8			if(left_to_read(TTY_Fd)) FileIOFlag++;E 8I 8			check_for_more(TTY_Fd);E 8D 10		}E 10I 10		}*/E 10E 7D 2		  contextsw( KbdFXP, AS_CPROG , 0);	/* contextsw to KEYHANDLER always */E 2I 2		 /* contextsw( KbdFXP, AS_CPROG , 0);Moved to outside of IF statement */E 2	}D 3	else if( nfds < 0){		printf( "select error: nfsd = %d  errno = %d\n", nfds, errno);E 3I 3	else {D 7		printf( "select error:\n ");E 7I 7		printf( "select error:\n "); E 7E 3	}I 7}E 7I 2	contextsw( KbdFXP, AS_CPROG , 0);	/* contextsw to KEYHANDLER always */E 2E 12I 12                    if( input_readevent(LispWindowFd, &event) >= 0 ){E 16I 16D 30                    while( input_readevent(LispWindowFd, &event) >= 0 ){E 16D 13                        if(!kb_event( &event )) {goto getmore;};                    } }	};E 13I 13                        /*if(!kb_event( &event )) {goto getmore;};*/D 15			if((KBDEventFlg+=kb_event( &event ))>0) {				Irq_Stk_End=Irq_Stk_Check=0;			  	/* immidiately request for IRQ check */E 13I 13			}                    } }	}	int_unblock();E 15I 15						if((KBDEventFlg+=kb_event( &event ))>0) {			  				/* immidiately request for IRQ check */							Irq_Stk_End=Irq_Stk_Check=0;						}					}E 30I 30	    while( input_readevent(LispWindowFd, &event) >= 0 )	      {	        /*if(!kb_event( &event )) {goto getmore;};*/	        if((KBDEventFlg+=kb_event( &event ))>0)	          {		    /* immidiately request for IRQ check */		    Irq_Stk_End=Irq_Stk_Check=0;		  }	      }E 30D 16					}					while (ioctl(LispWindowFd, FIONREAD, &eventsleft),						  eventsleft > 0);E 16D 31#ifndef KBINTD 30				}		}E 30I 30	    }	}E 31I 31/* #ifndef KBINT */	  }I 34D 53#endif SUNDISPLAYE 53I 53#endif /* SUNDISPLAY */E 53I 44#ifdef XWINDOW    if (rfds & (1 << Xfd))      {D 50	getXsignaldata();E 50I 50D 51	getXsignaldata(Xdisplay);E 51I 51	if (!XLocked) getXsignaldata(Xdisplay);	else XNeedSignal = 1;E 51E 50      }D 53#endif XWINDOWE 53I 53#endif /* XWINDOW */E 53E 44D 41E 41I 41#ifdef NOETHER#elseE 41E 34	if (rfds & EtherReadFds)	  { /* Raw ethernet (NIT) I/O happened, so handle it. */	    DBPRINT(("Handling enet interrupt.\n\n"));	    check_ether();	  }I 41D 53#endif NOETHERE 53I 53#endif /* NOETHER */E 53I 44I 53E 53#ifdef RS232	if (((rfds & RS232CReadFds) == RS232CReadFds) ||	    (RS232C_remain_data && rs232c_lisp_is_ready())) rs232c_read();D 53#endif RS232E 53I 53#endif /* RS232 */E 53I 53E 53E 44E 41#ifdef LOGINT	if (rfds & LogFileFd)	  { /* There's info in the log file.  Tell Lisp to print it. */	    flush_pty();	/* move the msg(s) to the log file */D 43	    *PENDINGINTERRUPT68k = ATOM_T;E 43	    	   ((INTSTAT*)Addr68k_from_LADDR(*INTERRUPTSTATE_word))		->LogFileIO = 1;I 43	    *PENDINGINTERRUPT68k = ATOM_T;E 43	    Irq_Stk_End=Irq_Stk_Check=0;	  }E 31E 30#endifI 31	if (rfds & LispIOFds)	  { /* There's activity on a Lisp-opened FD.  Tell Lisp. */I 32	    u_int *flags;	    flags = (u_int *)Addr68k_from_LADDR(*IOINTERRUPTFLAGS_word);	    *flags = rfds & LispIOFds;E 32D 43	    *PENDINGINTERRUPT68k = ATOM_T;E 43	    	   ((INTSTAT*)Addr68k_from_LADDR(*INTERRUPTSTATE_word))		->IOInterrupt = 1;I 43	    *PENDINGINTERRUPT68k = ATOM_T;E 43	    Irq_Stk_End=Irq_Stk_Check=0;	  }      }/* #endif */I 45D 47#ifdef ISC    signal(SIGIO, getsignaldata);    sigrelse(SIGIO);#endif ISCE 47E 45E 31E 15E 13E 12D 2E 2D 30} /* end getsignaldata */E 30I 30  } /* end getsignaldata */E 30I 30E 30D 12kb_event( event )E 12I 12D 42/* kb_event returns 1 if a keytransition happened, 0 if not. */E 42I 42/************************************************************************//*									*//*			    k b _ e v e n t				*//*									*//*	Given an event from the kbd code, return 1 if a key transition	*//*	occurred, 0 if one didn't occur.				*//*									*//************************************************************************/E 42I 13I 42#ifndef XWINDOWE 42I 26extern int for_makeinit;E 26E 13int kb_event( event )E 12D 3struct inputevent *event;E 3I 3register struct inputevent *event;E 3D 47{D 2	register u_int eventcode, keycode, upflg, DeviceID;E 2I 2D 3	register u_int eventcode, keycode, upflg;E 2	register u_int x, y;E 3I 3D 5	register u_int /* eventcode, keycode, */ upflg;	/*register u_int x, y;*/E 5I 5	register u_int  upflg;E 5E 3	int kn;I 13	DLword w,r;	KBEVENT *kbevent;E 47I 47  {    register u_int  upflg;    int kn;    DLword w,r;    KBEVENT *kbevent;E 47I 26#ifdef INIT/* generate some code to check if we are running as an INIT.  Don't   needlessly generate this code, and don't return if we aren't   running with the -INIT flag turned on.  --was 2/7/89 */D 47	if (for_makeinit)	   {		return(0);	   };E 47I 47    if (for_makeinit)       {	return(0);       };E 47#endifE 26D 24static DLword MouseState = DLMOUSEUP;D 14static DLword OLDEmMouseX;static DLword OLDEmMouseY;static DLword OLDEmRealUtilin=KB_ALLUP;static DLword OLDKbdAd0=KB_ALLUP;static DLword OLDKbdAd1=KB_ALLUP;static DLword OLDKbdAd2=KB_ALLUP;static DLword OLDKbdAd3=KB_ALLUP;static DLword OLDKbdAd4=KB_ALLUP;static DLword OLDKbdAd5=KB_ALLUP;/* It is for Dlion's 2 button mouse,So, I don't care this FAKE */static DLword OLDFakeU=KB_ALLUP;E 14E 24E 13D 12E 12D 3	if( DebugKBD ){		printf("code = %d\t", event->ie_code );		printf("code(hi) = %d\t", ((event->ie_code) >> 8) & 0xff );		printf("code(lo) = %d\t", (event->ie_code) & 0xff );		printf("flags = %x\t", event->ie_flags );		printf("shiftmask = %x\t", event->ie_shiftmask );		printf("(x,y) = (%d, %d)\n", event->ie_locx, event->ie_locy );		printf("key#= %d\n",SUNLispKeyMap[(event->ie_code) & 0xFF]);E 3D 5D 3	}	eventcode = event->ie_code;D 2	/* DeviceID = (EventCode >> 8) & 0xFF; */E 2	keycode = eventcode & 0xFF;E 3I 3	/*eventcode = event->ie_code;*/	/*keycode = eventcode & 0xFF;*/E 5E 3D 47	upflg = event_is_up( event );I 46	/* printf("Key # %d, upflg %d.\n", (unsigned short)event->ie_code, upflg); */E 46D 12E 12D 3	switch( eventcode ){E 3I 3	switch( ((unsigned short)event->ie_code) ){E 3		case LOC_MOVE:E 47I 47    upflg = event_is_up( event );D 48	    /* printf("Key # %d, upflg %d.\n", (unsigned short)event->ie_code, upflg);*/     switch( ((unsigned short)event->ie_code) )E 48I 48#ifdef SHOWKEYSTROKES    printf("Key # %d, upflg %d.\n", (unsigned short)event->ie_code, upflg); #endif	switch( ((unsigned short)event->ie_code) )E 48      {	case LOC_MOVE:E 47D 3			x = event->ie_locx;			y = event->ie_locy;			/* -------------------------------------------- *			 *	Clip the mouse position so that it nemains			 *	within the Lisp display area.			 * -------------------------------------------- */I 2			/*** COMMENT OUT ***E 2			if( x < 0 ) x = 0;			if( y < 0 ) y = 0;			if( x > DISPLAYWIDTH ) x = DISPLAYWIDTH;			if( y > DISPLAYHEIGHT ) y = DISPLAYHEIGHT;I 2			***COMMENT OUT March-1 88 **/E 2			mouse_move( x, y );E 3I 3D 24			MouseMove( event->ie_locx, event->ie_locy );I 13			TrackCursor(event->ie_locx,event->ie_locy );			MouseMoveFlg=T;E 24I 24#ifndef OLD_CURSORD 47			if(!ScreenLocked)E 47I 47		if(!ScreenLocked)E 47#endifD 47			{ ScreenLocked=T;			  MouseMove( event->ie_locx, event->ie_locy );			  TrackCursor(event->ie_locx,event->ie_locy );			  ScreenLocked=NIL;			}E 24E 13E 3D 12			break;E 12I 12			return(0);E 47I 47		  { ScreenLocked=T;		    MouseMove( event->ie_locx, event->ie_locy );		    TrackCursor(event->ie_locx,event->ie_locy );		    ScreenLocked=NIL;		  }		return(0);E 47E 12D 47		case MS_LEFT:D 5			mouse_button( MOUSE_LEFT, upflg );E 5I 5			/*mouse_button( MOUSE_LEFT, upflg );*/D 29			PUTBASEBIT68K( EmRealUtilin68K,MOUSE_LEFT , upflg );E 29I 29			PUTBASEBIT68K( EmRealUtilin68K, MOUSE_LEFT, upflg );E 29E 5			break;E 47I 47	case MS_LEFT:  /*mouse_button( MOUSE_LEFT, upflg );*/		PUTBASEBIT68K( EmRealUtilin68K, MOUSE_LEFT, upflg );		break;E 47			D 47		case MS_MIDDLE:D 5			mouse_button( MOUSE_MIDDLE, upflg );E 5I 5			/*mouse_button( MOUSE_MIDDLE, upflg );*/D 29			PUTBASEBIT68K( EmRealUtilin68K,MOUSE_MIDDLE , upflg );E 29I 29			PUTBASEBIT68K( EmRealUtilin68K, MOUSE_MIDDLE, upflg );E 29E 5			break;E 47I 47	case MS_MIDDLE:  /*mouse_button( MOUSE_MIDDLE, upflg );*/		PUTBASEBIT68K( EmRealUtilin68K, MOUSE_MIDDLE, upflg );		break;E 47			D 47		case MS_RIGHT:D 5			mouse_button( MOUSE_RIGHT, upflg );E 5I 5			/*mouse_button( MOUSE_RIGHT, upflg );*/D 29			PUTBASEBIT68K( EmRealUtilin68K,MOUSE_RIGHT , upflg );E 29I 29			PUTBASEBIT68K( EmRealUtilin68K, MOUSE_RIGHT, upflg );E 29E 5			break;E 47I 47	case MS_RIGHT:  /*mouse_button( MOUSE_RIGHT, upflg );*/		PUTBASEBIT68K( EmRealUtilin68K, MOUSE_RIGHT, upflg );		break;E 47D 47		default:	/* keystroke */D 3			if((kn=SUNLispKeyMap[keycode]) > -1)E 3I 3			if((kn=SUNLispKeyMap[((unsigned short)event->ie_code)]) > -1)E 47I 47	default:  /* keystroke */		if((kn=SUNLispKeyMap[((unsigned short)event->ie_code)]) > -1)E 47E 3				kb_trans( kn, upflg );D 47			else				printf("kb_event: unknown key number=%d\n",D 3					keycode );E 3I 3					event->ie_code );E 47I 47		else			printf("kb_event: unknown key number=%d\n",				event->ie_code );E 47E 3			D 47			break;D 12	}		  /* contextsw( KbdFXP, AS_CPROG , 0); */	 } /* end kb_event */E 12I 12	};I 13D 14/***** Allways DO ****	if(*EmRealUtilin68K != OLDEmRealUtilin) {		OLDEmRealUtilin= *EmRealUtilin68K;		MouseState= do_mousechording(*EmRealUtilin68K,MouseState);		goto do_ring;	}	else if( MouseState== DLMOUSEWAITING) { 		MouseState= DLMOUSENORMAL;		MouseState= do_mousechording(*EmRealUtilin68K,MouseState);		goto do_ring;	}	if((*EmKbdAd068K != OLDKbdAd0)||		(*EmKbdAd168K != OLDKbdAd1)||		(*EmKbdAd268K != OLDKbdAd2)||		(*EmKbdAd368K != OLDKbdAd3)||		(*EmKbdAd468K != OLDKbdAd4)||		(*EmKbdAd568K != OLDKbdAd5))*************/E 14 	{	 do_ring:D 18		if(((*EmKbdAd268K) & 2114) == 0)		 {/*Ctrl-shift-DEL*/			error("Call URaid by User Interrupt");E 18I 18D 27		if(((*EmKbdAd268K) & 2113) == 0)E 27I 27D 29		if((GETWORD(EmKbdAd268K) & 2113) == 0)E 29I 29		/* Emxxx do not use GETWORD */		if(((*EmKbdAd268K) & 2113) == 0)E 29E 27		 {/*Ctrl-shift-NEXT*/			error("******  EMERGENCY Interrupt ******");E 18D 27			*EmKbdAd268K=KB_ALLUP; /*reset*/E 27I 27D 29			GETWORD(EmKbdAd268K)=KB_ALLUP; /*reset*/E 29I 29			(*EmKbdAd268K)=KB_ALLUP; /*reset*/E 29E 27D 19			return(0);E 19I 19			((RING*)CTopKeyevent)->read=0;  /* reset queue */			((RING*)CTopKeyevent)->write=MINKEYEVENT; 			/*return(0);*/E 19D 18		 }E 18I 18		 } D 28		else if(((*EmKbdAd268K) & 2114) == 0)E 28I 28D 29		else if((GETWORD(EmKbdAd268K) & 2114) == 0)E 29I 29		else if(((*EmKbdAd268K) & 2114) == 0)E 29E 28		     { /* Ctrl-Shift-DEL */D 27			*EmKbdAd268K=KB_ALLUP; /*reset*/E 27I 27D 29			GETWORD(EmKbdAd268K)=KB_ALLUP; /*reset*/E 29I 29			(*EmKbdAd268K)=KB_ALLUP; /*reset*/E 29E 27			URaid_req=T;D 19			return(0);E 19I 19			((RING*)CTopKeyevent)->read=0;  /* reset queue */			((RING*)CTopKeyevent)->write=MINKEYEVENT; E 47I 47		break;      };      {    do_ring:	/* Emxxx do not use GETWORD */	if(((*EmKbdAd268K) & 2113) == 0)	  {/*Ctrl-shift-NEXT*/	    error("******  EMERGENCY Interrupt ******");	    (*EmKbdAd268K)=KB_ALLUP; /*reset*/	    ((RING*)CTopKeyevent)->read=0;  /* reset queue */	    ((RING*)CTopKeyevent)->write=MINKEYEVENT; 	    /*return(0);*/	  } 	else if(((*EmKbdAd268K) & 2114) == 0)	  { /* Ctrl-Shift-DEL */	    (*EmKbdAd268K)=KB_ALLUP; /*reset*/	    URaid_req=T;	    ((RING*)CTopKeyevent)->read=0;  /* reset queue */	    ((RING*)CTopKeyevent)->write=MINKEYEVENT; E 47D 47			/*return(0);*/E 19		     }E 47I 47	    /*return(0);*/	  }E 47E 18I 23#ifdef OS4_TYPE4BUGD 27		else if(((*EmKbdAd268K) & 2120) == 0)E 27I 27D 29		else if((GETWORD(EmKbdAd268K) & 2120) == 0)E 29I 29D 47		else if(((*EmKbdAd268K) & 2120) == 0)E 29E 27		     { /* Ctrl-Shift-Return */I 40			error("******  EMERGENCY Interrupt ******");E 40D 27			*EmKbdAd268K=KB_ALLUP; /*reset*/E 27I 27D 29			GETWORD(EmKbdAd268K)=KB_ALLUP; /*reset*/E 29I 29			(*EmKbdAd268K)=KB_ALLUP; /*reset*/E 29E 27D 40			URaid_req=T;E 40			((RING*)CTopKeyevent)->read=0;  /* reset queue */			((RING*)CTopKeyevent)->write=MINKEYEVENT; D 40E 40I 40			/*return(0);*/E 40		     }E 47I 47	else if(((*EmKbdAd268K) & 2120) == 0)	  { /* Ctrl-Shift-Return */	    error("******  EMERGENCY Interrupt ******");	    (*EmKbdAd268K)=KB_ALLUP; /*reset*/	    ((RING*)CTopKeyevent)->read=0;  /* reset queue */	    ((RING*)CTopKeyevent)->write=MINKEYEVENT; 	    /*return(0);*/	  }E 47#endifE 23D 47		r=RING_READ(CTopKeyevent);		w=RING_WRITE(CTopKeyevent);E 47I 47	r=RING_READ(CTopKeyevent);	w=RING_WRITE(CTopKeyevent);E 47D 29		if(r==w) /* event queqe FULL */E 29I 29D 47		if(r==w) /* event queue FULL */E 29			goto KBnext;		kbevent=(KBEVENT*)(CTopKeyevent+ w);E 47I 47	if(r==w) goto KBnext; /* event queue FULL */E 47I 28D 35#ifndef BYTESWAPE 35I 35E 35E 28D 47		RCLK(kbevent->time);E 47I 47	kbevent=(KBEVENT*)(CTopKeyevent+ w);E 47I 28D 35#else		RCLK(kbevent->time_hi, kbevent->time_lo);#endif BYTESWAPE 35I 35E 35E 28D 14		kbevent->W0=OLDKbdAd0= *EmKbdAd068K;		kbevent->W1=OLDKbdAd1= *EmKbdAd168K;		kbevent->W2=OLDKbdAd2= *EmKbdAd268K;		kbevent->W3=OLDKbdAd3= *EmKbdAd368K;		kbevent->W4=OLDKbdAd4= *EmKbdAd468K;		kbevent->W5=OLDKbdAd5= *EmKbdAd568K;E 14I 14D 27		kbevent->W0= *EmKbdAd068K;		kbevent->W1= *EmKbdAd168K;		kbevent->W2= *EmKbdAd268K;		kbevent->W3= *EmKbdAd368K;		kbevent->W4= *EmKbdAd468K;		kbevent->W5= *EmKbdAd568K;E 14		kbevent->WU= *EmRealUtilin68K;E 27I 27D 29		kbevent->W0= GETWORD(EmKbdAd068K);		kbevent->W1= GETWORD(EmKbdAd168K);		kbevent->W2= GETWORD(EmKbdAd268K);		kbevent->W3= GETWORD(EmKbdAd368K);		kbevent->W4= GETWORD(EmKbdAd468K);		kbevent->W5= GETWORD(EmKbdAd568K);		kbevent->WU= GETWORD(EmRealUtilin68K);E 29I 29D 47		kbevent->W0= (*EmKbdAd068K);	/* Emxxxx do not use GETWORD */		kbevent->W1= (*EmKbdAd168K);		kbevent->W2= (*EmKbdAd268K);		kbevent->W3= (*EmKbdAd368K);		kbevent->W4= (*EmKbdAd468K);		kbevent->W5= (*EmKbdAd568K);		kbevent->WU= (*EmRealUtilin68K);E 47I 47D 48	RCLK(kbevent->time);E 48I 48/*	RCLK(kbevent->time); */E 48E 47E 29E 27D 47		if(r==0) /* Queue was empty */			((RING*)CTopKeyevent)->read=w;		if(w >= MAXKEYEVENT)			((RING*)CTopKeyevent)->write = MINKEYEVENT;		else			((RING*)CTopKeyevent)->write = w + KEYEVENTSIZE;E 47I 47	kbevent->W0= (*EmKbdAd068K);	/* Emxxxx do not use GETWORD */	kbevent->W1= (*EmKbdAd168K);	kbevent->W2= (*EmKbdAd268K);	kbevent->W3= (*EmKbdAd368K);	kbevent->W4= (*EmKbdAd468K);	kbevent->W5= (*EmKbdAd568K);	kbevent->WU= (*EmRealUtilin68K);E 47D 47 	 KBnext:		if(*KEYBUFFERING68k ==NIL)			*KEYBUFFERING68k=ATOM_T;E 47I 47	if(r==0) /* Queue was empty */ ((RING*)CTopKeyevent)->read=w;	if(w >= MAXKEYEVENT) ((RING*)CTopKeyevent)->write = MINKEYEVENT;	else ((RING*)CTopKeyevent)->write = w + KEYEVENTSIZE;E 47D 47 	} /* if *EmRealUtilin68K end */D 24E 24E 13 return(1); } E 47I 47    KBnext:D 51	if(*KEYBUFFERING68k ==NIL) *KEYBUFFERING68k=ATOM_T;E 51I 51	if(*KEYBUFFERING68k == NIL) *KEYBUFFERING68k=ATOM_T;E 51      } /* if *EmRealUtilin68K end */    return(1);  } E 47I 42D 53#endif XWINDOWE 53I 53#endif /* XWINDOW */E 53E 42E 12I 42I 53E 53/************************************************************************//*									*//*			   k b _ t r a n s				*//*									*//*	Return the transition code??					*//*									*//************************************************************************/E 42D 3E 3I 3D 5/****E 3mouse_move( x, y )u_short x, y;{	if( DebugKBD && KBlog )		fprintf( KBlog, "mouse_move:	x = %3d y=%3d\n", x, y );E 5D 5	putbase68k( EmMouseX68K, 0, x);	putbase68k( EmMouseY68K, 0, y);D 3}E 3I 3}****/D 4#define MouseMove(x,y)	{ (*((DLword *)EmMouseX68K)) = x; \					  (*((DLword *)EmMouseY68K)) = y; }E 4E 3mouse_button( no, upflg )u_short no, upflg;{D 3	if( DebugKBD && KBlog )E 3I 3	/**if( DebugKBD && KBlog )E 3		fprintf( KBlog, "mouse_button:	no = %3d upflg=%3d\n",D 3				no, upflg );E 3I 3				no, upflg );**/E 3	putbasebit68k( EmRealUtilin68K, no, upflg );}E 5kb_trans( keycode, upflg )D 47u_short	keycode;u_short upflg;{I 17 extern IFPAGE *InterfacePage;E 17D 5D 3	if( DebugKBD && KBlog )E 3I 3/***	if( DebugKBD && KBlog )E 3		fprintf( KBlog, "kb_trans:	keycode = %3d upflg=%3d\n",D 3				keycode, upflg );E 3I 3				keycode, upflg ); ***/E 3E 5	if( keycode < 64 )	/* DLKBDAD0 ~ 3	*/D 5		putbasebit68k( EmKbdAd068K, keycode, upflg );E 5I 5		{PUTBASEBIT68K( EmKbdAd068K, keycode, upflg );}E 5	else if( keycode >= 80 )/* DLKBDAD4, 5	*/D 5		putbasebit68k( EmKbdAd068K, keycode - 16, upflg );E 5I 5		{PUTBASEBIT68K( EmKbdAd068K, keycode - 16, upflg );}E 5	else if( keycode >= 64 && keycode < 80 )/* DLUTILIN	*/D 5		putbasebit68k( EmRealUtilin68K, keycode - 64, upflg );E 5I 5D 12		{PUTBASEBIT68K( EmRealUtilin68K, keycode - 64, upflg );}E 5E 12I 12D 17		{PUTBASEBIT68K( EmRealUtilin68K, keycode - 64, upflg );};E 17I 17		{		  PUTBASEBIT68K( EmRealUtilin68K, (keycode & 15), upflg );		  PUTBASEBIT68K( EmUtilin68K, (keycode & 15), upflg );		}E 47I 47  u_short keycode;  u_short upflg;  {    extern IFPAGE *InterfacePage;    if( keycode < 64 )	/* DLKBDAD0 ~ 3	*/      { PUTBASEBIT68K( EmKbdAd068K, keycode, upflg );}    else if( keycode >= 80 )/* DLKBDAD4, 5	*/      { PUTBASEBIT68K( EmKbdAd068K, keycode - 16, upflg );}    else if( keycode >= 64 && keycode < 80 )/* DLUTILIN	*/      {	PUTBASEBIT68K( EmRealUtilin68K, (keycode & 15), upflg );	PUTBASEBIT68K( EmUtilin68K, (keycode & 15), upflg );      }E 47E 17E 12}I 13D 14do_mousechording(realutilin,state) DLword realutilin; DLword state;{	DLword lrstate=NIL;	if((*MOUSECHORDTICKS68k==NIL) 	||	((lrstate=((realutilin & MOUSE_ALLBITS) ^ MOUSE_ALLBITS)) == 0))		state= DLMOUSEUP;	else {		/*switch(state)*/		printf("mousechording not-impl\n");	}/* else end */	*EmRealUtilin68K= realutilin;	return(state);} /* do_mousechording */trackcursor(cx,cy)DLword cx,cy;{ int debug=NIL;	*CLastUserActionCell68k = MiscStats->secondstmp;	/*printf("ORG:x=%d , y=%d \n",cx,cy);*/	if(cx >= IDiff(CURSORDESTWIDTH68k , CURSORHOTSPOTX68k))	{ /*CHECK right boundary don't care about "32767"*/		cx = IDiff(CURSORDESTWIDTH68k , CURSORHOTSPOTX68k) -1;		debug=T;		if(cx <0) error("Cursor POSX NEG?");		goto tr1;	}	else if(cy >= (((SNum*)CURSORDESTHEIGHT68k)->num - HARDCURSORHEIGHT))	  {		tr1:		 if( cy >= IDiff(CURSORDESTHEIGHT68k, CURSORHOTSPOTY68k))		 {			cy = IDiff(CURSORDESTHEIGHT68k , CURSORHOTSPOTY68k) -1;			debug=T;			if(cy<0) error("Cursor POSY NEG?");		 }	  }	if(debug == T)printf("CHANGED x=%d , y=%d \n",cx,cy);	if(*SOFTCURSORUPP68k != NIL)		softcorsorposition(cx,cy);	*EmCursorX68K= cx;	*EmCursorY68K= cy;}/*trackcursor*/softcorsorposition(x,y)DLword x,y;{ if((*EmCursorX68K != x) || (*EmCursorY68K != y)){	if(*SOFTCURSORUPP68k != NIL)		printf("Sorry:softcorsor wasn't implemented\n"); }} /*softcorcorposition */E 14E 13D 5D 3putbase68k( base68k, offset, value )E 3I 3/** putbase68k( base68k, offset, value )E 3DLword	*base68k;u_short	offset;u_short value;{	*(base68k + offset) = value;D 3}E 3I 3}**/E 3I 3#define PUTBASE68K(base68k,offset,val)  (*(((DLword *)(base68k)) + (offset)))=(val)E 3I 3E 3#define BITSPERWORD 16putbasebit68k( base68k, offset, bitvalue )DLword	*base68k;u_short	offset;u_short bitvalue;{	base68k =  base68k + (offset / BITSPERWORD );	if( bitvalue )	/* bitvalue != 0 */		*base68k = *base68k | 1 << (15 - offset % BITSPERWORD);	else		/* bitvalue == 0 */		*base68k = *base68k & ~( 1 << (15 - offset % BITSPERWORD));}I 3#define PUTBASEBIT68K(base68k, offset, bitvalue ) { \	((DLword *)(base68k)) += (((u_short)(offset))>>4 ); \	if( bitvalue )	/* bitvalue != 0 */ \		*base68k = *base68k | 1 << (15 - (((u_short)(offset)) & 0xffff)); \	else		/* bitvalue == 0 */ \		*base68k = *base68k & ~( 1 << (15 - (((u_short)(offset)) & 0xffff))); \	}E 3E 5I 24/**********************************************************//* 	MOUSE tracking*//**********************************************************/D 47typedef struct {	LispPTR CUIMAGE;	LispPTR CUMASK;	LispPTR CUHOTSPOTX;	LispPTR CUHOTSPOTY;	LispPTR CUDATA;} CURSOR ;E 47I 47typedef struct  {    LispPTR CUIMAGE;    LispPTR CUMASK;    LispPTR CUHOTSPOTX;    LispPTR CUHOTSPOTY;    LispPTR CUDATA;  } CURSOR ;E 47D 27typedef struct{	LispPTR	bmbase;	DLword	bmrasterwidth;	DLword	bmheight;	DLword	bmwidth;	DLword	bmbitperpixel;}BITMAP;E 27#define DLWORD_PERLINE	(DisplayWidth/16)#define HARD_CURSORWIDTH 16#define HARD_CURSORHEIGHT 16I 25#define COLOR_BITSPER_PIXEL 8/* For MonoOrColor */#define MONO_SCREEN 0#define COLOR_SCREEN 1E 25#define CursorClippingX(posx,width) {				\	if( DisplayWidth < (posx + HARD_CURSORWIDTH)) {		\ 	 LastCursorClippingX=width=DisplayWidth-posx;}		\	else { LastCursorClippingX=width=HARD_CURSORWIDTH;}}#define CursorClippingY(posy,height){				\	if(DisplayHeight < (posy + HARD_CURSORHEIGHT)) {	\	 LastCursorClippingY = height = DisplayHeight - posy;}	\	else { LastCursorClippingY = height = HARD_CURSORHEIGHT;}} extern int DisplayWidth, DisplayHeight;extern int DisplayInitialized ;I 25extern int MonoOrColor; /* MONO_SCREEN or COLOR_SCREEN */E 25int LastCursorClippingX=HARD_CURSORWIDTH;int LastCursorClippingY = HARD_CURSORHEIGHT;int LastCursorX=0;int LastCursorY=0;I 31E 31D 25E 25I 25#ifndef COLOR/* FOR MONO ONLY */E 25taking_mouse_down()D 30{ register DLword	*srcbase, *dstbase; static int sx, dx, w, h, srcbpl, dstbpl, backwardflg=0; static int src_comp=0, op=0, gray=0, num_gray=0, curr_gray_line=0;E 30I 30  {    register DLword	*srcbase, *dstbase;    static int sx, dx, w, h, srcbpl, dstbpl, backwardflg=0;    static int src_comp=0, op=0, gray=0, num_gray=0, curr_gray_line=0;E 30D 30 if(!DisplayInitialized) return; /* restore saved image */ srcbase=MonoCursor_savebitmap;D 25/*********dstbase=DisplayRegion68k +( (*EmCursorY68K) * DLWORD_PERLINE); **************** old y */E 25 dstbase=DisplayRegion68k +( (LastCursorY) * DLWORD_PERLINE); /* old y */ sx=0;D 25/***************************dx = *EmCursorX68K;***************** old x */E 25 dx = LastCursorX; /* old x */ w = LastCursorClippingX; /* Old clipping */D 25 /***h=HARD_CURSORHEIGHT;***/E 25 h= LastCursorClippingY; srcbpl =HARD_CURSORWIDTH; dstbpl =DisplayWidth; op=0; new_bitblt_code;I 25}E 30I 30    if(!DisplayInitialized) return;    /* restore saved image */    srcbase=MonoCursor_savebitmap;    dstbase=DisplayRegion68k +( (LastCursorY) * DLWORD_PERLINE); /* old y */    sx=0;    dx = LastCursorX; /* old x */    w = LastCursorClippingX; /* Old clipping */    h= LastCursorClippingY;    srcbpl =HARD_CURSORWIDTH;    dstbpl =DisplayWidth;    op=0;    new_bitblt_code;#ifdef DISPLAYBUFFER    flush_display_region(dx, (LastCursorY), w, h);#endif  }E 30#elseD 47/* For COLOR & MONO */E 47I 47			/* For COLOR & MONO */E 47extern DLword *ColorDisplayRegion68k;D 30/* It assumes that MONO screen size and COLOR screen size are identical */E 30I 30  /* It assumes that MONO screen size and COLOR screen size are identical */E 30taking_mouse_down()D 30{ register DLword	*srcbase, *dstbase; static int sx, dx, w, h, srcbpl, dstbpl, backwardflg=0; static int src_comp=0, op=0, gray=0, num_gray=0, curr_gray_line=0;E 30I 30  {    register DLword	*srcbase, *dstbase;    static int sx, dx, w, h, srcbpl, dstbpl, backwardflg=0;    static int src_comp=0, op=0, gray=0, num_gray=0, curr_gray_line=0;E 30E 25I 25D 30 if(!DisplayInitialized) return; /* restore saved image */   sx=0;E 30I 30    if(!DisplayInitialized) return;    /* restore saved image */    sx=0;E 30D 30if(MonoOrColor == MONO_SCREEN) {   dx = LastCursorX; /* old x */   srcbase=MonoCursor_savebitmap;   dstbase=DisplayRegion68k +( (LastCursorY) * DLWORD_PERLINE); /* old y */   w = LastCursorClippingX; /* Old clipping */   h= LastCursorClippingY;   srcbpl =HARD_CURSORWIDTH;   dstbpl =DisplayWidth;E 30I 30    if(MonoOrColor == MONO_SCREEN)      {	dx = LastCursorX; /* old x */	srcbase=MonoCursor_savebitmap;	dstbase=DisplayRegion68k +( (LastCursorY) * DLWORD_PERLINE); /* old y */	w = LastCursorClippingX; /* Old clipping */	h= LastCursorClippingY;	srcbpl =HARD_CURSORWIDTH;	dstbpl =DisplayWidth;      }    else      {	dx = LastCursorX * COLOR_BITSPER_PIXEL; /* old x */	srcbase=ColorCursor_savebitmap;D 47	dstbase= ColorDisplayRegion68k +( (LastCursorY) * DLWORD_PERLINE * COLOR_BITSPER_PIXEL ); /* old y */E 47I 47	dstbase= ColorDisplayRegion68k +	   ((LastCursorY) * DLWORD_PERLINE * COLOR_BITSPER_PIXEL); /* old y */E 47	w = LastCursorClippingX * COLOR_BITSPER_PIXEL; /* Old clipping */	h= LastCursorClippingY;	srcbpl =HARD_CURSORWIDTH * COLOR_BITSPER_PIXEL;	dstbpl =DisplayWidth * COLOR_BITSPER_PIXEL ;      }    op=0;    new_bitblt_code;#ifdef DISPLAYBUFFERD 37    flush_display_region(dx, LastCursorY, w h);E 37I 37D 38    flush_display_region(dx, LastCursorY, w, h);E 38I 38    if( MonoOrColor == MONO_SCREEN )    	flush_display_region(dx, LastCursorY, w, h);E 38E 37#endifE 30E 25}I 25D 30else {   dx = LastCursorX * COLOR_BITSPER_PIXEL; /* old x */   srcbase=ColorCursor_savebitmap;   dstbase= ColorDisplayRegion68k +( (LastCursorY) * DLWORD_PERLINE * COLOR_BITSPER_PIXEL ); /* old y */   w = LastCursorClippingX * COLOR_BITSPER_PIXEL; /* Old clipping */   h= LastCursorClippingY;   srcbpl =HARD_CURSORWIDTH * COLOR_BITSPER_PIXEL;   dstbpl =DisplayWidth * COLOR_BITSPER_PIXEL ;} op=0; new_bitblt_code;E 25I 25}E 30D 53#endif COLORE 53I 53#endif /* COLOR */E 53I 53E 53E 25/* I'll make it MACRO */taking_mouse_up(newx,newy)D 30int newx,newy;{ if(!DisplayInitialized) return;/* save hidden bitmap */cursor_hidden_bitmap(newx,newy);/* Copy Cursor Image */copy_cursor(newx,newy); LastCursorX=newx;LastCursorY=newy;}E 30I 30  int newx,newy;  {    if(!DisplayInitialized) return;    /* save hidden bitmap */    cursor_hidden_bitmap(newx,newy);    /* Copy Cursor Image */D 39    copy_cursor(newx,newy); E 39I 39#ifndef INIT    copy_cursor(newx,newy);#endif E 39    LastCursorX=newx;    LastCursorY=newy;  }E 30/* LastCursorClippingX must be set brfore calling  To avoid duplicate caluculation */I 25#ifndef COLOR/* FOR MONO ONLY */E 25copy_cursor(newx,newy)D 30int newx,newy;{register DLword	*srcbase, *dstbase;register int offsetx,offsety;static int	sx, dx, w, h, srcbpl, dstbpl, backwardflg=0;static int	src_comp=0, op=0, gray=0, num_gray=0, curr_gray_line=0;extern DLword *EmCursorBitMap68K;/* copy cursor image */srcbase = EmCursorBitMap68K;dstbase= DisplayRegion68k +(newy * DLWORD_PERLINE) ;sx=0;dx=newx;w=LastCursorClippingX;h=LastCursorClippingY;;srcbpl=HARD_CURSORWIDTH;dstbpl=DisplayWidth;op=2; /* OR-in */new_bitblt_code;E 30I 30  int newx,newy;  {    register DLword	*srcbase, *dstbase;    register int offsetx,offsety;    static int	sx, dx, w, h, srcbpl, dstbpl, backwardflg=0;    static int	src_comp=0, op=0, gray=0, num_gray=0, curr_gray_line=0;    extern DLword *EmCursorBitMap68K;    /* copy cursor image */    srcbase = EmCursorBitMap68K;    dstbase= DisplayRegion68k +(newy * DLWORD_PERLINE) ;    sx=0;    dx=newx;    w=LastCursorClippingX;    h=LastCursorClippingY;;    srcbpl=HARD_CURSORWIDTH;    dstbpl=DisplayWidth;    op=2; /* OR-in */    new_bitblt_code;#ifdef DISPLAYBUFFER    flush_display_region(dx, newy, w, h);#endif  }E 30D 30}E 30/* store bitmap image inside rect. which specified by x,y */cursor_hidden_bitmap(x,y)D 30int x,y;{	register DLword	*srcbase, *dstbase;	static int	sx, dx, w, h, srcbpl, dstbpl, backwardflg=0;	static int	src_comp=0, op=0, gray=0, num_gray=0, curr_gray_line=0;/* save image */srcbase=DisplayRegion68k +( y* DLWORD_PERLINE) ;dstbase=MonoCursor_savebitmap;sx=x;dx=0;CursorClippingX(x,w); /* w and LastCursorClippingX rest */CursorClippingY(y,h); /* h and LastCursorClippingY reset */srcbpl =DisplayWidth;dstbpl=HARD_CURSORWIDTH;op= 0; /* replace */new_bitblt_code;}E 30I 30  int x,y;  {    register DLword	*srcbase, *dstbase;    static int	sx, dx, w, h, srcbpl, dstbpl, backwardflg=0;    static int	src_comp=0, op=0, gray=0, num_gray=0, curr_gray_line=0;    /* save image */    srcbase=DisplayRegion68k +( y* DLWORD_PERLINE) ;    dstbase=MonoCursor_savebitmap;    sx=x;    dx=0;    CursorClippingX(x,w); /* w and LastCursorClippingX rest */    CursorClippingY(y,h); /* h and LastCursorClippingY reset */    srcbpl =DisplayWidth;    dstbpl=HARD_CURSORWIDTH;    op= 0; /* replace */    new_bitblt_code;  }E 30I 25#else/* For COLOR & MONO */#define IMIN(x,y)  (((x) > (y)) ? (y) : (x))copy_cursor(newx,newy)D 30int newx,newy;{register DLword	*srcbase, *dstbase;register int offsetx,offsety;static int	sx, dx, w, h, srcbpl, dstbpl, backwardflg=0;static int	src_comp=0, op=0, gray=0, num_gray=0, curr_gray_line=0;CURSOR *cursor68k;BITMAP *bitmap68k;extern DLword *EmCursorBitMap68K;/* copy cursor image */if(MonoOrColor == MONO_SCREEN) {   srcbase = EmCursorBitMap68K;   dstbase= DisplayRegion68k +(newy * DLWORD_PERLINE) ;   sx=0;   dx=newx;   w=LastCursorClippingX;   h=LastCursorClippingY;;   srcbpl=HARD_CURSORWIDTH;   dstbpl=DisplayWidth;}else {   cursor68k = (CURSOR*)Addr68k_from_LADDR(*CURRENTCURSOR68k);   bitmap68k=(BITMAP*)Addr68k_from_LADDR(cursor68k->CUIMAGE);   srcbase =(DLword*) Addr68k_from_LADDR(bitmap68k->bmbase);   dstbase=  ColorDisplayRegion68k +(newy * DLWORD_PERLINE * COLOR_BITSPER_PIXEL) ;   sx=0;   dx=newx * COLOR_BITSPER_PIXEL;   w=IMIN(LastCursorClippingX,LOLOC(bitmap68k->bmwidth)) * COLOR_BITSPER_PIXEL;   h=IMIN(LastCursorClippingY,LOLOC(bitmap68k->bmheight));  /* srcbpl=HARD_CURSORWIDTH * COLOR_BITSPER_PIXEL;*/   srcbpl = bitmap68k->bmwidth * COLOR_BITSPER_PIXEL;   dstbpl=DisplayWidth * COLOR_BITSPER_PIXEL;}op=2; /* OR-in */new_bitblt_code;}E 30I 30  int newx,newy;  {    register DLword	*srcbase, *dstbase;    register int offsetx,offsety;    static int	sx, dx, w, h, srcbpl, dstbpl, backwardflg=0;    static int	src_comp=0, op=0, gray=0, num_gray=0, curr_gray_line=0;    CURSOR *cursor68k;    BITMAP *bitmap68k;    extern DLword *EmCursorBitMap68K;    /* copy cursor image */    if(MonoOrColor == MONO_SCREEN)      {	srcbase = EmCursorBitMap68K;	dstbase= DisplayRegion68k +(newy * DLWORD_PERLINE) ;	sx=0;	dx=newx;	w=LastCursorClippingX;	h=LastCursorClippingY;;	srcbpl=HARD_CURSORWIDTH;	dstbpl=DisplayWidth;      }   else      {	cursor68k = (CURSOR*)Addr68k_from_LADDR(*CURRENTCURSOR68k);	bitmap68k=(BITMAP*)Addr68k_from_LADDR(cursor68k->CUIMAGE);	srcbase =(DLword*) Addr68k_from_LADDR(bitmap68k->bmbase);	dstbase=  ColorDisplayRegion68k +(newy * DLWORD_PERLINE * COLOR_BITSPER_PIXEL) ;	sx=0;	dx=newx * COLOR_BITSPER_PIXEL;	w=IMIN(LastCursorClippingX,LOLOC(bitmap68k->bmwidth)) * COLOR_BITSPER_PIXEL;	h=IMIN(LastCursorClippingY,LOLOC(bitmap68k->bmheight));	/* srcbpl=HARD_CURSORWIDTH * COLOR_BITSPER_PIXEL;*/	srcbpl = bitmap68k->bmwidth * COLOR_BITSPER_PIXEL;	dstbpl=DisplayWidth * COLOR_BITSPER_PIXEL;      }    op=2; /* OR-in */    new_bitblt_code;#ifdef DISPLAYBUFFERD 38    flush_display_region(dx, newy, w, h);E 38I 38    if( MonoOrColor == MONO_SCREEN )    	flush_display_region(dx, newy, w, h);E 38#endif  }E 30/* store bitmap image inside rect. which specified by x,y */cursor_hidden_bitmap(x,y)int x,y;{register DLword	*srcbase, *dstbase;static int	sx, dx, w, h, srcbpl, dstbpl, backwardflg=0;static int	src_comp=0, op=0, gray=0, num_gray=0, curr_gray_line=0;/* save image */if(MonoOrColor == MONO_SCREEN) {   srcbase=DisplayRegion68k +( y* DLWORD_PERLINE) ;   dstbase=MonoCursor_savebitmap;   sx=x;   dx=0;   CursorClippingX(x,w); /* w and LastCursorClippingX rest */   CursorClippingY(y,h); /* h and LastCursorClippingY reset */   srcbpl =DisplayWidth;   dstbpl=HARD_CURSORWIDTH;}else {   srcbase=ColorDisplayRegion68k +(y * DLWORD_PERLINE * COLOR_BITSPER_PIXEL);   dstbase= ColorCursor_savebitmap;   sx=x * COLOR_BITSPER_PIXEL ;   dx=0;   CursorClippingX(x,w); /* w and LastCursorClippingX rest */   CursorClippingY(y,h); /* h and LastCursorClippingY reset */   w = w * COLOR_BITSPER_PIXEL;   srcbpl =DisplayWidth * COLOR_BITSPER_PIXEL ;   dstbpl=HARD_CURSORWIDTH * COLOR_BITSPER_PIXEL;}op= 0; /* replace */new_bitblt_code;}D 53#endif COLORE 53I 53#endif /* COLOR */E 53E 25E 24D 12/*  * debugging functions */watch_event( fd, count )int fd;int count;{	int c;	int rfds, wfds, nfds;	rfds = 0;	wfds = 0;	rfds |= 1 << fd;	while( count-- ){			nfds = select(32, &rfds, &wfds, NULL, NULL);			if( nfds > 0)				get_event( fd, 1 );	}		}get_event( fd, count )int fd;int count;{	struct inputevent event;	while( count-- ){		input_readevent( fd, &event );		pr_event( &event );	}}pr_event( event )struct inputevent *event;{	printf( "code = %d\t", event->ie_code );	printf( "code(hi) = %d\t", ((event->ie_code) >> 8) & 0xff );	printf( "code(lo) = %d\t", (event->ie_code) & 0xff );	printf( "flags = %x\t", event->ie_flags );	printf( "shiftmask = %x\t", event->ie_shiftmask );	printf( "(x,y) = (%d, %d)\n", event->ie_locx, event->ie_locy );}E 12E 1