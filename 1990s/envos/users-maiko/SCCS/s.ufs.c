h37386s 00010/00005/01193d D 2.53 92/11/25 21:14:59 sybalsky 71 70c Fixing endif's with extra text => comment. \nes 00002/00000/01196d D 2.52 92/07/24 10:47:04 sybalsky 70 69c retrofit of SGI & DEC OSF1 changes \nes 00011/00003/01185d D 2.51 92/04/23 10:56:19 sybalsky 69 68c fixing SCCS headers \nes 00004/00004/01184d D 2.50 92/04/21 17:27:36 sybalsky 68 67c shortening file names for DOS \nes 00002/00002/01186d D 2.49 91/09/27 03:06:52 sybalsky 67 66c ISC port changeses 00004/00000/01184d D 2.48 91/04/09 17:13:19 sybalsky 66 65c Retrofit first round of changes from MIPS porting centeres 00002/00002/01182d D 2.47 91/02/04 12:55:43 sybalsky 65 64c Fix errors in teh Savoir retrofit (placement of ifdefs &c)es 00002/00000/01182d D 2.46 91/01/27 12:08:44 sybalsky 64 63c Retrofit HP9000/RS6000 changeses 00026/00005/01156d D 2.45 90/10/09 10:38:59 fuji 63 62c Add the file name length check for FDEV methodses 00029/00000/01132d D 2.44 90/09/18 23:49:50 sybalsky 62 61c Retrofit changes from AIX, DEC3100, PS/2es 00000/00002/01132d D 2.43 90/06/20 12:38:16 mitani 61 60c remove redundant ERRSETJMPes 00174/00052/00960d D 2.42 90/06/04 14:53:22 mitani 60 59c new directory enumerationes 00010/00006/01002d D 2.41 90/04/25 18:26:24 mitani 59 58c unixpathname handles trail quote mark correctlyes 00000/00000/01008d D 2.40 90/04/20 02:00:29 sybalsky 58 57c AIX:  shortening file names, bulk change.es 00899/00796/00109d D 2.39 90/04/19 18:24:40 mitani 57 56c Version up to 1.2es 00008/00000/00897d D 2.38 90/03/09 14:42:36 takeshi 56 55c byte-swap for read/write bufferes 00014/00002/00883d D 2.37 90/03/08 10:01:43 takeshi 55 54c care about byte-order in stringses 00014/00003/00871d D 2.36 89/12/28 15:29:27 sybalsky 54 53c es 00015/00015/00859d D 2.35 89/12/13 10:59:18 sybalsky 53 52c string-conversion safety addedes 00004/00002/00870d D 2.34 89/04/04 17:20:42 sybalsky 52 51c changed getfileinfo to return 0 if author is unknownes 00004/00004/00868d D 2.33 89/03/18 04:02:37 sybalsky 51 50c OneDArrayes 00002/00002/00870d D 2.32 88/12/07 09:47:27 hayata 50 49c add SCCS key ides 00012/00002/00860d D 2.31 88/12/07 09:46:21 hayata 49 48c To fix AR10974(Lafite prints noisy message), fsync system call is added to UFS_getsize. fsync synclonize file data.es 00038/00011/00824d D 2.30 88/12/06 10:09:58 hayata 48 47c To fix connection timeout problem, UFS_readpages, UFS_writepages, and UFS_directorynamep are passed Lisp ERRNO cell from new lisp code.es 00005/00002/00830d D 2.29 88/12/01 15:55:14 hayata 47 46c Check errp consistency between Lisp & C (code & comment)es 00073/00085/00759d D 2.28 88/12/01 12:03:03 hayata 46 45c To fix error message problem (connection time out & too many files open), global var *Lisp_errno is used to keep errno.es 00002/00004/00842d D 2.27 88/11/15 17:27:55 hayata 45 44c To fix "connection timeout" problem, set of errono after makepathname is removed.es 00008/00003/00838d D 2.26 88/11/11 16:20:32 hayata 44 43c In UFS_openfile, stat is used to UNIX device file. In some case, stat cause "file not fonud", I change UFS_openfile to avoid this.es 00097/00035/00744d D 2.25 88/11/10 10:40:19 hayata 43 42c Fix serial port problem, {UNIX}/dev/ttya can handle serial portes 00005/00001/00774d D 2.24 88/10/27 13:21:43 hayata 42 41c when opening file is /dev/xxx, ignore close 'NOT OWNER' errores 00007/00007/00768d D 2.23 88/10/18 15:01:40 krivacic 41 40c remove warning message by replacing PAGESIZE with PAGE_SIZEes 00004/00002/00771d D 2.22 88/10/08 15:08:41 hayata 40 39c UFS_getfreeblock is changed. pathname is examined by confirmpath().es 00088/00024/00685d D 2.21 88/10/06 17:02:30 hayata 39 37c change for cross device rename filees 00025/00005/00704d R 2.21 88/09/26 15:31:49 hayata 38 37c makefile() is changed to handle "~user-name/foo" es 00006/00006/00703d D 2.20 88/09/07 18:34:24 hayata 37 36c To fix truncate bug, change UFS_getsize.es 00161/00002/00548d D 2.19 88/07/29 17:38:10 hayata 36 35c To fix wrong error message, errno is informed to Lisp. This change is all inside #ifdef FSERROR. Beause they need new lisp code. I'll add -DFSERROR to makefile after new sysout is made.es 00005/00005/00545d D 2.18 88/07/26 18:58:46 hayata 35 34c move SETJMP to avoid duplicate use of jump bufferes 00069/00072/00481d D 2.17 88/07/21 14:51:12 hayata 34 33c add register declarationses 00002/00004/00551d D 2.16 88/07/20 14:44:04 hayata 33 32c openfile set Creationdate to cdate buffer, to set validation filed inLisp.es 00000/00005/00555d D 2.15 88/07/13 18:14:10 hayata 32 31c commented out some printf in order to fix a problem of full buffer of pty.es 00017/00002/00543d D 2.14 88/06/29 10:50:30 hayata 31 30c To fix TIMEOUT, SETJMP are used.es 00003/00002/00542d D 2.13 88/06/19 13:23:31 hayata 30 29c Add SCCS key ides 00004/00000/00540d D 2.12 88/06/19 13:22:32 hayata 29 28c UFS_getfileinfo can handle PROTECTION attribute.es 00004/00003/00536d D 2.11 88/06/16 10:30:33 hayata 28 27c sys_err about access is commented out.es 00061/00033/00478d D 2.10 88/06/13 17:34:12 hayata 27 26c Add TIMEOUTes 00001/00000/00510d D 2.9 88/06/11 17:24:59 hayata 26 25c Add comment when utimes is failed.es 00004/00002/00506d D 2.8 88/06/09 19:47:49 hayata 25 24c In \UFSopenfile, cdate is set to 0. Because it is set in Lisp(open method).es 00010/00010/00498d D 2.7 88/06/04 13:11:12 hayata 24 23c Change UFS_getfreeblock to fix sysout buges 00016/00002/00492d D 2.6 88/06/03 17:28:09 hayata 23 22c UFS_getfreeblock is changed to allow a file name with new directorey.es 00044/00045/00450d D 2.5 88/05/23 17:41:12 hayata 22 21c Add some check of library rouitnees 00003/00001/00492d D 2.4 88/05/18 16:19:02 hayata 21 20c Add err_mess in UFS_setfielinfo.es 00000/00000/00493d D 2.3 88/05/17 17:59:49 krivacic 20 19c make sure ufs.c is read onlyes 00002/00005/00491d D 2.2 88/05/17 17:30:21 hayata 19 18c Keep creation datees 00000/00000/00496d D 2.1 88/05/17 10:08:23 hayata 18 17c Version up to 2.1es 00013/00002/00483d D 1.15 88/05/13 17:06:38 hayata 17 16c Close set Ctime at not INPUT, GetFileInfo returns correct authores 00003/00000/00482d D 1.14 88/05/11 18:31:32 hayata 16 15c Change UFSopenfile. On output open, unlink file at first.es 00061/00021/00421d D 1.13 88/05/10 17:44:10 hayata 15 14c Add system call error message.es 00005/00004/00437d D 1.12 88/05/07 18:19:12 hayata 14 13c Change matchp and add non-recog to UFS_getfilenamees 00021/00001/00420d D 1.11 88/05/02 18:35:55 hayata 13 12c Add UFS_getfreeblock for COPYSYS.es 00003/00003/00418d D 1.10 88/04/29 17:28:24 hayata 12 11c change includees 00003/00003/00418d D 1.9 88/04/29 17:24:12 hayata 11 10c change UFS_openfile's flags initilization and call UFS_readAllDires 00005/00005/00416d D 1.8 88/04/28 20:42:50 masinter 10 9c go back to old versiones 00003/00003/00418d D 1.7 88/04/28 18:52:24 hayata 9 8c change include localfile.h and UFS_readalldir.es 00005/00000/00416d D 1.6 88/04/26 18:19:03 hayata 8 7c Add UFS_currentdir for tentative codees 00010/00003/00406d D 1.5 88/04/26 17:29:40 hayata 7 4c Add UFS_changedir for CHDIRes 00000/00001/00409d R 1.6 88/03/24 15:23:07 hayata 6 5c For Testes 00410/00000/00000d R 1.5 88/03/24 15:03:40 hayata 5 4c For Testes 00003/00000/00406d D 1.4 88/04/20 14:58:18 hayata 4 3c Change UFS_dirsize and UFS_readdir to accept non version file.es 00002/00000/00404d D 1.3 88/04/06 14:25:04 hayata 3 2c Add SCCS key ides 00001/00068/00403d D 1.2 88/04/06 14:22:48 hayata 2 1c Move macro to filesystem.hes 00471/00000/00000d D 1.1 88/04/04 11:58:20 hayata 1 0c date and time created 88/04/04 11:58:20 by hayataeuUtTI 3D 10/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 10I 10D 12/* This is G-file @(#) ufs.c Version 1.6 (4/26/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) ufs.c	1.6 4/26/88";E 12I 12D 28/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 28I 28D 30/* This is G-file @(#) ufs.c Version 2.10 (6/13/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) ufs.c	2.10 6/13/88";E 30I 30D 39/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 39I 39D 40/* This is G-file %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xeorx)";E 40I 40D 43/* This is G-file @(#) ufs.c Version 2.21 (10/6/88). copyright envos & Fuji Xerox  */D 42static char *id = "@(#) ufs.c	2.21 10/6/88		(envos & Fuji Xeorx)";E 42I 42static char *id = "@(#) ufs.c	2.21 10/6/88		(envos & Fuji Xerox)";E 43I 43D 49/* This is G-file %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 49I 49D 50/* This is G-file @(#) ufs.c Version 2.30 (12/6/88). copyright envos & Fuji Xerox  */static char *id = "@(#) ufs.c	2.30 12/6/88		(envos & Fuji Xerox)";E 50I 50D 54/* This is G-file %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 54I 54D 55/* This is G-file @(#) ufs.c Version 2.34 (4/4/89). copyright envos & Fuji Xerox  */static char *id = "@(#) ufs.c	2.34 4/4/89		(envos & Fuji Xerox)";E 55I 55D 63/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 63I 63/* @(#) ufs.c Version 2.44 (9/18/90). copyright venue & Fuji Xerox  */static char *id = "@(#) ufs.c	2.44 9/18/90		(venue & Fuji Xerox)";E 63E 55E 54E 50E 49E 43E 42E 40E 39I 54I 69E 69/************************************************************************//*									*/D 69/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 69I 69/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 69/*									*/D 69/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 69I 69/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 69/*									*//************************************************************************/E 54E 30E 28E 12E 10E 3I 1D 2/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 2D 57#include	<pwd.h>#include	<sys/file.h>E 57#include	<sys/types.h>I 64D 65#ifndef HPUXE 65E 64D 57#include	<sys/stat.h>E 57#include	<sys/param.h>I 64D 65#endif HPUXE 65I 65#ifndef HPUXE 65E 64I 57#include	<strings.h>I 65D 71#endif HPUXE 71I 71#endif /* HPUX */E 71E 65#include	<sys/file.h>I 69#ifndef INDIGO	/* Indigo has this duplicated in dirent.h, sigh. */E 69#include	<sys/dir.h>I 69#endif /* INDIGO */E 69#include	<sys/stat.h>E 57#include	<sys/time.h>I 62#ifndef AIXI 70#ifndef APOLLOE 70E 62I 13#include	<sys/vfs.h>I 70#endif /* APOLLO */E 70I 62D 71#endif AIXE 71I 71#endif /* AIX */E 71I 66D 67#ifdef RISCOSE 67I 67#ifdef SYSVONLYE 67#include	<dirent.h>#include	<unistd.h>D 67#endif RISCOSE 67I 67D 71#endif SYSVONLYE 71I 71#endif /* SYSVONLY */E 71E 67E 66E 62I 57#include	<pwd.h>E 57I 31#include	<setjmp.h>I 57#include	<fcntl.h>#include	<stdio.h>E 57E 31E 13I 4D 15#include	<strings.h>E 15I 15#include	<errno.h>E 15E 4#include	"lispemul.h"#include	"lispmap.h"D 68#include	"address68k.h"#include	"lisptypes.h"I 57#include	"lispglobal.h"E 68I 68#include	"adr68k.h"#include	"lsptypes.h"#include	"lspglob.h"E 68E 57#include	"arith.h"#include	"stream.h"I 27#include	"timeout.h"E 27D 2#include	"filesystem.h"E 2I 2D 12#include	"/users/hayata/fs/c/filesystem.h"E 12I 12D 68#include	"localfile.h"E 68I 68#include	"locfile.h"E 68I 57#include	"dbprint.h"E 57E 12E 2I 15D 57char	*rindex();I 24char	*index();E 24E 15D 2#define	PAGESIZE	512	/* 1 page == 512 byte */E 2E 57I 46int	*Lisp_errno;D 54int	Dummy_errno;		/* If errno cell is not provided by Lisp, dummy_errno is used. */E 54I 54int	Dummy_errno;	/* If errno cell is not provided by Lisp, dummy_errno is used. */E 54I 62E 62E 46I 43D 57#define	SPECIALFILEMARK	-1E 57I 57/*		 * Name:	UFS_getfilename * * Argument:	LispPTR	*args	args[0] *				 Full file name in Lisp format. *				args[1] *				 Rcoginition mode.  See IRM. *				args[2] *				 Name area where the recognized full file name *				 will be stored. *				args[3] *				 The place where the error number should be *				 stored. * * Value:	If succeed, returns the Lisp smallp which represents the length *		of the recognized full file name, otherwise Lisp NIL. * * Side Effect:	If succeed, name area (args[2]) will be replaced with the  *		recognized full file name. * * Description: * * The implementation of GETFILENAME FDEV method for UNIX device.  Performs the * recognition on the specified name.  Does not check if OPENFILE actually * can open the file with the specified mode or not. */E 57E 43D 2#define	RECOG_OLD		S_POSITIVE | 0#define	RECOG_OLDEST		S_POSITIVE | 1#define	RECOG_NEW		S_POSITIVE | 2#define	RECOG_NEW_OLD		S_POSITIVE | 3#define	ACCESS_INPUT		S_POSITIVE | 0#define	ACCESS_OUTPUT		S_POSITIVE | 1#define	ACCESS_BOTH		S_POSITIVE | 2#define	ACCESS_APPEND		S_POSITIVE | 3#define	SIZE			S_POSITIVE | 1	/* For getfileinfo */#define	WDATE			S_POSITIVE | 2#define	RDATE			S_POSITIVE | 3#define	AUTHOR		S_POSITIVE | 5extern	DLword	*Lisp_world;	/* To access LispSysout area */#define	LispStringToCString(Lisp, C){	\	LispPTR	*naddress;				\	char	*base;					\	int	length;					\	int	offset;					\	naddress = (LispPTR *)(Addr68k_from_LADDR(Lisp));					\	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));	\	offset = (int)(((ONEDARRAAY *)naddress)->offset);	\	length = ((ONEDARRAAY *)naddress)->totalsize;						\	strncpy(C, base + offset, length);			\	C[length] = '\0';				\	}#define	LispNumToCInt(Lisp)		\		( ((Lisp & 0xFF0000) == S_POSITIVE) ? 	\		(Lisp & 0xFFFF) : (*((int *)(Addr68k_from_LADDR(Lisp)))) );#define	ToLispTime(x)	((int)x + 29969152)			/* For getfileinfo */			/* 29969152 == (timer.c)LISP_UNIX_TIME_DIFF */			/* ((int)x + 29969152 - 61200) (for Japan) */			/* - 61200 == - 17hours (for Japan) */#define	ToUnixTime(x)	((int)x - 29969152)			/* For setfileinfo */			/* 29969152 == (timer.c)LISP_UNIX_TIME_DIFF */E 2D 57UFS_openfile(args)D 34LispPTR	*args;E 34I 34register LispPTR	*args;E 34/* args[0]		fullname *//* args[1]		rec *//* args[2]		acc *//* args[3]		cdate *//* args[4]		size */I 36/* args[5]		errno */E 57I 57UFS_getfilename(args)	register LispPTR	*args;E 57E 36{D 34int	id;	/* return value  of open system call. */int	flags;	/* open system call's argument */char	pathname[MAXPATHLEN];E 34I 34D 57register int	flags;	/* open system call's argument, and id of file */register int	*bufp;register int	rval;E 34struct stat	statbuf;D 34int	*bufp;I 27int	rval;E 34I 34char	pathname[MAXPATHLEN];I 36#ifdef	FSERRORD 46int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[5]));		ERRSETJMP(NIL, errp);E 46I 46	Lisp_errno = (int *)(Addr68k_from_LADDR(args[5]));		ERRSETJMP(NIL);E 46#elseE 36E 34I 31	SETJMP(NIL);I 36#endifE 36E 31E 27D 2/***E 2D 53	LispStringToCString(args[0], pathname);E 53I 53	LispStringToCString(args[0], pathname, MAXPATHLEN);E 53I 43	TIMEOUT( rval=stat(pathname, &statbuf) );	if( rval == -1){D 44		err_mess("stat", errno);E 44I 44		if(errno == 2){			/* Skip file not found error */			statbuf.st_mode = S_IFREG;		}else{			err_mess("stat", errno);E 44#ifdef FSERRORD 44		*errp = errno;E 44I 44D 46			*errp = errno;E 46I 46			*Lisp_errno = errno;E 46E 44#endifD 44		return(NIL);E 44I 44			return(NIL);		}E 44	}E 43D 2***/	{LispPTR	*naddress;		char	*base;		int	length;		int	offset;	naddress = (LispPTR *)(Addr68k_from_LADDR(args[0]));		base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));	offset = (int)(((ONEDARRAAY *)naddress)->offset);	length = ((ONEDARRAAY *)naddress)->totalsize;		strncpy(pathname, base + offset, length);		pathname[length] = '\0';		}E 2	flags = 0;	switch(args[1]){	case RECOG_OLD:	case RECOG_OLDEST:			break;	case RECOG_NEW_OLD:	case RECOG_NEW:			flags = O_CREAT;			break;	default:			return(NIL);	}D 43	switch(args[2]){	case	ACCESS_INPUT:D 9			flags |= O_RDONLY;E 9I 9D 10			flags |= O_RDWR;E 10I 10D 11			flags |= O_RDONLY;E 11I 11D 13			flags |= O_RDWR;E 13I 13			flags |= O_RDONLY;E 13E 11E 10E 9			break;	case	ACCESS_OUTPUT:I 16			unlink(pathname);			flags |= (O_RDWR | O_CREAT);			break;E 16	case	ACCESS_APPEND:D 9			flags |= (O_WRONLY | O_CREAT);E 9I 9D 10			flags |= (O_RDWR | O_CREAT);E 10I 10D 11			flags |= (O_WRONLY | O_CREAT);E 11I 11			flags |= (O_RDWR | O_CREAT);E 11E 10E 9			break;	case	ACCESS_BOTH:			flags |= (O_RDWR | O_CREAT);			break;D 2/*** Changed 4/1 by Hiroshi	case	ACCESS_APPEND:			flags |= O_APPEND;			break;***/E 2	default:E 43I 43	if((statbuf.st_mode & S_IFREG) == 0){		/* Not regular file, open special file */		switch(args[2]){		case	ACCESS_INPUT:				flags = O_RDONLY;				break;		case	ACCESS_OUTPUT:				flags = O_WRONLY;				break;		case	ACCESS_APPEND:				flags = O_WRONLY;				break;		case	ACCESS_BOTH:				flags = O_RDWR;				break;		default:E 43			return(NIL);I 43		}	}else{		switch(args[2]){		case	ACCESS_INPUT:				flags |= O_RDONLY;				break;		case	ACCESS_OUTPUT:D 45				unlink(pathname);E 45I 45				TIMEOUT( unlink(pathname) );E 45				flags |= (O_RDWR | O_CREAT);				break;		case	ACCESS_APPEND:				flags |= (O_RDWR | O_CREAT);				break;		case	ACCESS_BOTH:				flags |= (O_RDWR | O_CREAT);				break;		default:			return(NIL);		}E 43	}D 27	id = open(pathname, flags, 0666);E 27I 27D 34	TIMEOUT( id=open(pathname, flags, 0666) );E 27D 15	if(id == -1)			return(NIL);	if(fstat(id, &statbuf) == -1)			return(NIL);E 15I 15	if(id == -1){E 34I 34	TIMEOUT( flags=open(pathname, flags, 0666) );	if(flags == -1){E 34		err_mess("open", errno);I 36#ifdef FSERRORD 46		*errp = errno;E 46I 46		*Lisp_errno = errno;E 46#endifE 36		return(NIL);	}I 43	/* refetch new file info */E 43D 27	if(fstat(id, &statbuf) == -1){E 27I 27D 34	TIMEOUT( rval=fstat(id, &statbuf) );E 34I 34	TIMEOUT( rval=fstat(flags, &statbuf) );E 34	if( rval == -1){E 27		err_mess("fstat", errno);I 36#ifdef FSERRORD 46		*errp = errno;E 46I 46		*Lisp_errno = errno;E 46#endifE 36		return(NIL);	}E 15D 25	bufp = (int *)(Addr68k_from_LADDR(args[3]));D 17	*bufp = statbuf.st_mtime;E 17I 17D 19	if(args[2] == ACCESS_INPUT)		*bufp = 0;	else		*bufp = statbuf.st_mtime;E 19I 19	*bufp = ToLispTime(statbuf.st_mtime);E 25I 25D 33	/* Set of creation date is obsolte */	/* But, to keep cosistency with Lisp code, the code is remained */		bufp = (int *)(Addr68k_from_LADDR(args[3]));		*bufp = 0;E 33I 33	bufp = (int *)(Addr68k_from_LADDR(args[3]));	*bufp = ToLispTime(statbuf.st_mtime);E 33E 25E 19E 17	bufp = (int *)(Addr68k_from_LADDR(args[4]));D 43	*bufp = statbuf.st_size;E 43I 43	if((statbuf.st_mode & S_IFREG) == 0){		/* Special file */		*bufp = SPECIALFILEMARK;	}else{		/* Regular file */		*bufp = statbuf.st_size;	}E 43D 34	return(GetSmallp(id));E 34I 34	return(GetSmallp(flags));E 34}E 57I 57	register char	*base;	register int	len, rval;	char		lfname[MAXPATHLEN], file[MAXPATHLEN];E 57D 57UFS_closefile(args)D 34LispPTR	*args;E 34I 34register LispPTR	*args;E 34/* args[0]		pathname	*//* args[1]		id	*//* args[2]		cdate	*/I 36/* args[3]		errno */E 36{D 34int	id;	/* FileID */int	date;	/* Creatoin Date */char	pathname[MAXPATHLEN];char	*base;int	length;E 34I 34register int	id;	/* FileID */register int	date;	/* Creatoin Date */register char	*base;register int	rval;E 34D 39struct timeval time[2];E 39I 39static struct timeval time[2];E 39struct stat	statbuf;I 27D 34int	rval;E 34I 34char	pathname[MAXPATHLEN];I 36#ifdef	FSERRORD 46int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));		ERRSETJMP(NIL, errp);E 46I 46	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	E 57	ERRSETJMP(NIL);E 46D 57#elseE 36E 34I 31	SETJMP(NIL);I 36#endifE 36E 31E 27D 53	LispStringToCString(args[0], pathname);E 53I 53	LispStringToCString(args[0], pathname, MAXPATHLEN);E 53	id = LispNumToCInt(args[1]);	date = LispNumToCInt(args[2]);I 43	TIMEOUT( rval=fstat(id, &statbuf) );		if(rval != 0){		err_mess("fstat", errno);#ifdef FSERRORD 46		*errp = errno;E 46I 46		*Lisp_errno = errno;E 46#endif		return(NIL);	}E 43I 17	if(date == 0){ /* just close */D 27		if( close(id) == -1){E 27I 27		TIMEOUT( rval=close(id) );		if( rval == -1){I 42			if(errno==1){	/* Not owner error */D 43				if(matchp(pathname, "/dev/*")==1)E 43I 43				if((statbuf.st_mode & S_IFREG) == 0){				/* Not regular file, open special file */E 43					return(ATOM_T);I 43				}E 43			}E 42E 27			err_mess("close", errno);I 36#ifdef FSERRORD 46			*errp = errno;E 46I 46			*Lisp_errno = errno;E 46#endifE 36			return(NIL);		}		return(ATOM_T);	}D 27	/* set Creation date and close */		E 17D 15	if(fstat(id, &statbuf) != 0)E 15I 15	if(fstat(id, &statbuf) != 0){E 27I 27	/* set Creation date and close */	D 43	TIMEOUT( rval=fstat(id, &statbuf) );		if(rval != 0){E 27		err_mess("fstat", errno);I 36#ifdef FSERROR		*errp = errno;#endifE 36E 15		return(NIL);I 15	}E 43E 15	time[0].tv_sec = statbuf.st_atime;D 19	time[1].tv_sec = date;E 19I 19	time[1].tv_sec = ToUnixTime(date);E 19D 15	if( close(id) == -1)E 15I 15D 27	if( close(id) == -1){E 27I 27	TIMEOUT( rval=close(id) );	if( rval == -1){E 27		err_mess("close", errno);I 36#ifdef FSERRORD 46		*errp = errno;E 46I 46		*Lisp_errno = errno;E 46#endifE 36E 15		return(NIL);D 15	if(utimes(pathname, time) != 0)E 15I 15	}D 27	if(utimes(pathname, time) != 0){E 27I 27	TIMEOUT( rval=utimes(pathname, time) );	if(rval != 0){E 27		err_mess("utimes", errno);I 36#ifdef FSERRORD 46		*errp = errno;E 46I 46		*Lisp_errno = errno;E 46#endifE 36I 26D 32		printf("	FileName is %s\n", pathname);E 32E 26E 15		return(NIL);I 15	}E 15	return(ATOM_T);}E 57I 57	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	I 63	LispStringLength(args[0], len, rval);	len += 1;		/* Add 1 for tuminating NULL char. */	if (len > MAXPATHLEN) FileNameTooLong(NIL);E 63	LispStringToCString(args[0], lfname, MAXPATHLEN);	/*	 * Convert a Lisp file name to UNIX one.  This is a UNIX device method.	 * Thus we don't need to convert a version field.  Third argument for	 * unixpathname specifies it.	 */	if (unixpathname(lfname, file, 0, 0) == 0) return(NIL);E 57I 57	switch (args[1]) {E 57I 45E 45D 57UFS_getfilename(args)D 34LispPTR	*args;E 34I 34register LispPTR	*args;E 34/* args[0]		pathname	*//* args[1]		rec	*//* args[2]		buffer	*/I 36/* args[3]		errno	*/E 36{D 34int	length;E 34I 34register char	*base;register LispPTR	*naddress;register int	rval;E 34char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];I 36#ifdef	FSERRORD 46int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));	E 46I 46	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	E 46#endifE 36D 34char	*base;LispPTR	*naddress;I 27int	rval;E 34I 31D 35	SETJMP(NIL);E 35E 31E 27D 53	LispStringToCString(args[0], pathname);E 53I 53	LispStringToCString(args[0], pathname, MAXPATHLEN);E 53I 36D 46#ifdef	FSERROR	if( makepathname(pathname, fullpathname, errp) == 0){E 46I 46	if( makepathname(pathname, fullpathname) == 0){E 46D 45		*errp = errno;E 45		return(NIL);	}D 46#elseE 36	if( makepathname(pathname, fullpathname) == 0)		return(NIL);I 36#endifE 46E 36	switch(args[1]){	case RECOG_OLD:	case RECOG_OLDEST:I 46#ifdef	FSERROR		ERRSETJMP(NIL);#elseE 46I 35		SETJMP(NIL);I 46#endifE 46E 35D 15		if(access(fullpathname, F_OK) == -1)E 15I 15D 27		if(access(fullpathname, F_OK) == -1){E 27I 27D 28E 28		TIMEOUT( rval=access(fullpathname, F_OK) );		if(rval == -1){I 28			/** There is no need to report access error. E 28E 27			err_mess("access", errno);I 28			**/I 46#ifdef FSERROR			if(errno == 60)				*Lisp_errno = errno;#endifE 57I 57	      case RECOG_OLD:	      case RECOG_OLDEST:		/*		 * "Old" and "Oldest" means the "existing" file.  All we have to do		 * is to make sure it is an existing file or not.		 */		TIMEOUT(rval = access(file, F_OK));		if (rval == -1) {			*Lisp_errno = errno;E 57E 46E 28E 15			return(NIL);I 15		}E 15		break;D 57	case RECOG_NEW_OLD:	case RECOG_NEW:I 14	case RECOG_NON:E 57I 57	      case RECOG_NEW:	      case RECOG_OLD_NEW:	      case RECOG_NON:		/*		 * "New" file means the "not existing" file.  UNIX device always		 * recognizes a not existing file as if, the subsequent OPENFILE will		 * find the truth.		 * "Non" reognition is used to recognize a sysout file.		 */E 57E 14		break;D 57	default:		return(NIL);E 57	}D 57	/*** CStringToLispString ***/	naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));D 51	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));E 51I 51	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));E 51D 34	length = strlen(fullpathname);	strncpy(base, fullpathname, length);	return(GetSmallp(length));E 34I 34	rval = strlen(fullpathname);E 57I 57	/*	 * Now, we convert a file name back to Lisp format.  The version field have not	 * to be converted.  The fourth argument for lisppathname specifies it.	 */	if (lisppathname(file, lfname, 0, 0) == 0) return(NIL);	STRING_BASE(args[2], base);	len = strlen(lfname);E 57I 55#ifndef BYTESWAPE 55D 57	strncpy(base, fullpathname, rval);E 57I 57	strncpy(base, lfname, len + 1);E 57I 55#elseD 57	StrNCpyFromCToLisp(base, fullpathname, rval);E 57I 57	StrNCpyFromCToLisp(base, lfname, len + 1);E 57D 71#endif BYTESWAPE 71I 71#endif /* BYTESWAP */E 71E 55D 57	return(GetSmallp(rval));E 34}E 57I 71E 71D 36makepathname(src, dst)E 36I 36D 46#ifdef FSERRORmakepathname(src, dst, errp)E 36D 34char	*src;char	*dst;E 34I 34register char	*src;register char	*dst;E 34D 36{				E 36I 36int	*errp;	#elseE 46D 57makepathname(src, dst)register char	*src;register char	*dst;				D 46#endifE 46{I 39register int len;E 39E 36D 22char	*sp, *dp, *base;int	i, length, wdlength;						E 22I 22D 34char	*base, *cp;E 22struct passwd *pwd;E 34I 34register char	*base, *cp;register struct passwd *pwd;I 39char	name[MAXPATHLEN];E 39E 34I 31D 35	SETJMP(0);E 35E 31	base = src;D 22	length = strlen(src);E 22	switch ( *base ) {	case '.':D 22			getwd(dst);			wdlength = strlen(dst);							switch ( *(base+1) ){								case '.':	if(*(base+2) == '/'){										for(dp=dst+wdlength;*dp != '/';--wdlength, --dp);						for(i=0, sp=base+2;i<length;++i)										*dp++ = *sp++;								*dp = '\0';										}else{											return(0);								}											break;								case '/':					for(i=0, sp=base+1, dp=dst+wdlength;i<length;++i)							*dp++ = *sp++;								*dp = '\0';									break;									default:												return(0);							}			break;							E 22I 22		if(getwd(dst) == 0){	/* set working directory */I 46#ifdef FSERROR			*Lisp_errno = errno;#endifE 46D 32			printf("error:getwd %s\n", getwd);E 32			return(0);		}		switch ( *(base+1) ){							case '.':			if(*(base+2) == '/'){	/* Now, base == "../xxxx" */				cp = rindex(dst, '/');				if(cp == 0){D 32					printf("error:rindex\n");E 32					return(0);				}				*cp = '\0';				strcat(dst, base+2);				return(1);								}else{									return(0);						}								case '/':			/* Now, base == "./xxx" */			strcat(dst, base+1);						return(1);								default:										return(0);						}E 22	case '~':I 36#ifdef FSERRORD 46		ERRSETJMP(0, errp);E 46I 46		ERRSETJMP(0);E 46#elseE 36I 35		SETJMP(0);I 36#endifE 36E 35D 22			pwd = getpwuid( getuid());							for(dp=dst, sp=(pwd->pw_dir); (*sp) != '\0' ;)					*dp++ = *sp++;				for(i=0, sp=base+1;i<length;++i)						*dp++ = *sp++;								break;	default:	for(i=0, sp=base, dp=dst;i<length;++i)				*dp++ = *sp++;			*dp = '\0';									break;							E 22I 22D 31		pwd = getpwuid( getuid());E 31I 31D 39		TIMEOUT( pwd = getpwuid( getuid()) );E 31		if(pwd == NULL){				D 32			printf("error:getpwuid\n");E 32			return(0);E 39I 39		if( *(base+1) == '/'){			/* path is "~/foo" */			TIMEOUT( pwd = getpwuid( getuid()) );			if(pwd == NULL){				I 46#ifdef FSERROR				*Lisp_errno = errno;#endifE 46				return(0);			}			sprintf(dst, "%s%s", pwd->pw_dir, base+1);			return(1);		}else{			/* path is "~foo/" */			if((cp=index(base+1, '/')) == 0){				return(0);			}else{				len = (int)cp - (int)base -1;				strncpy(name, base+1, len);				name[len] = '\0';				TIMEOUT( pwd = getpwnam(name) );				if(pwd == NULL){				I 46#ifdef FSERROR					*Lisp_errno = errno;#endifE 46					return(0);				}				sprintf(dst, "%s%s", pwd->pw_dir, cp);				return(1);				}E 39		}D 39		sprintf(dst, "%s%s", pwd->pw_dir, base+1);		return(1);E 39	default:		strcpy(dst, src);							return(1);							E 22	}E 57I 57	return(GetSmallp(len));E 57D 22	return(1);E 22}I 62E 62I 57/*		 * Name:	UFS_deletefile * * Argument:	LispPTR	*args	args[0] *				 Full file name in Lisp format. *				args[1] *				 The place where the error number should be *				 stored. * * Value:	If succeed, returns the Lisp symbol T, otherwise Lisp NIL. * * Side Effect:	If succeed, the specified file is unlinked. * * Description: * * The implementation of DELETEFILE FDEV method for UNIX device.  Try to delete * a specified file. */E 57UFS_deletefile(args)D 57LispPTR	*args;/*	args[0]:	Indirect pointer to buffer	*/I 36/*	args[1]:	errno	*/E 57I 57	register LispPTR	*args;E 57E 36{I 34D 57register int	rval;E 34char	pathname[MAXPATHLEN];I 36#ifdef	FSERRORD 46int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[1]));		ERRSETJMP(NIL, errp);E 46I 46	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));	E 57I 57	char			file[MAXPATHLEN], fbuf[MAXPATHLEN];D 63	register int		rval;E 63I 63	register int		len, rval;E 63	E 57	ERRSETJMP(NIL);E 46D 57#elseE 36I 27D 34int	rval;E 34I 31	SETJMP(NIL);I 36#endifE 36E 31E 27D 53	LispStringToCString(args[0], pathname);E 53I 53	LispStringToCString(args[0], pathname, MAXPATHLEN);E 53D 15	if(unlink(pathname) == -1)E 15I 15D 27	if(unlink(pathname) == -1){E 27I 27	TIMEOUT( rval=unlink(pathname) );	if(rval == -1){E 27		err_mess("unlink", errno);I 36#ifdef FSERRORE 57I 57	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));	I 63	LispStringLength(args[0], len, rval);	len += 1;	if (len > MAXPATHLEN) FileNameTooLong(NIL);E 63	LispStringToCString(args[0], fbuf, MAXPATHLEN);	unixpathname(fbuf, file, 0, 0);	/*	 * On UNIX device, all we have to do is just to unlink the file.	 */	TIMEOUT(rval = unlink(file));	if (rval == -1) {E 57D 46		*errp = errno;E 46I 46		*Lisp_errno = errno;E 46D 57#endifE 57E 36E 15		return(NIL);I 15	}I 57E 57E 15	return(ATOM_T);}I 62E 62I 57/*		 * Name:	UFS_renamefile * * Argument:	LispPTR	*args	args[0] *				 Full file name in Lisp format.  The file which *				 is being renamed. *				args[1] *				 Full file name in Lisp format.  The file to which *				 args[0] is being renamed. *				args[2] *				 The place where the error number should be *				 stored. * * Value:	If succeed, returns the Lisp symbol T, otherwise Lisp NIL. * * Side Effect:	If succeed, the specified file is unlinked. * * Description: * * The implementation of RENAMEFILE FDEV method for UNIX device.  Try to rename * a specified file. */E 57UFS_renamefile(args)D 34LispPTR	*args;E 34I 34D 57register LispPTR	*args;E 34/*	args[0]:	Indirect pointer to buffer (old file name)	*//*	args[1]:	Indirect pointer to buffer (new file name)	*/I 47/*	args[2]:	pointer to errno	*/E 57I 57	register LispPTR	*args;E 57E 47{I 34D 57register int	rval;E 34char	old_pathname[MAXPATHLEN], new_pathname[MAXPATHLEN];I 36#ifdef	FSERRORD 46int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[2]));		ERRSETJMP(NIL, errp);E 46I 46	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));	E 57I 57	char			fbuf[MAXPATHLEN], src[MAXPATHLEN], dst[MAXPATHLEN];D 63	int			rval;E 63I 63	int			rval, len;E 63	E 57	ERRSETJMP(NIL);E 46D 57#elseE 36I 27D 34int	rval;E 34I 31	SETJMP(NIL);I 36#endifE 36E 31E 27D 53	LispStringToCString(args[0], old_pathname);	LispStringToCString(args[1], new_pathname);E 53I 53	LispStringToCString(args[0], old_pathname, MAXPATHLEN);	LispStringToCString(args[1], new_pathname, MAXPATHLEN);E 53D 15	if(rename(old_pathname, new_pathname) == -1)E 15I 15D 27	if(rename(old_pathname, new_pathname) == -1){E 27I 27	TIMEOUT( rval=rename(old_pathname, new_pathname) );	if( rval== -1){E 27D 39		err_mess("rename", errno);E 39I 39		if(errno != 18){			/* Not, cross device rename error */			err_mess("rename", errno);		}E 39I 36#ifdef FSERRORE 57I 57	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));	I 63	LispStringLength(args[0], len, rval);	len += 1;	if (len > MAXPATHLEN) FileNameTooLong(NIL);	LispStringLength(args[1], len, rval);	len += 1;	if (len > MAXPATHLEN) FileNameTooLong(NIL);E 63	LispStringToCString(args[0], fbuf, MAXPATHLEN);	unixpathname(fbuf, src, 0, 0);	LispStringToCString(args[1], fbuf, MAXPATHLEN);	unixpathname(fbuf, dst, 0, 0);	TIMEOUT(rval = rename(src, dst));	if (rval == -1) {E 57D 46		*errp = errno;E 46I 46		*Lisp_errno = errno;E 46D 57#endifE 57E 36E 15		return(NIL);I 15	}I 57E 57E 15	return(ATOM_T);}I 62E 62I 36D 57/*** Common routine between DSK and UNIX. ****/E 57I 57/* * Name:	UFS_directorynamep * * Argument:	LispPTR	*args	args[0]D 63 *				 Directory name in Lispformat.  Both of the initialE 63I 63 *				 Directory name in Lisp format.  Both of the initialE 63 *				 and trail directory delimiter are stripped by Lisp *				 code.  Only one exception is a "root directory". *				 "Root directory is represented as ">". *				args[1] *				 The place where the "true" name of the directory *				 in Lisp format will be stored. *				args[2] *				 The place where the error number should be stored. *				 Not use in the current Lisp code implementation. * * Value:	If succeed, returns the Lisp smallp which represents the length *		of the "true" name of the directory, otherwise Lisp NIL. * * Side Effect:	If the directory is recognized as a valid directory representation, *		args[1] is replaced with the "true" directory name. * * Description: * * The implementation of the DIRECTORYNAMEP FDEV method for UNIX device. * Performs the recoginition as well. Accepts the directory representation which * obeys the Xerox Lisp file naming convention. The "true" name which is stored * on the area specified with the second argument also follows the Xerox Lisp * file naming convention, and it includes the initial and trail directory * delimiter. Thus the Lisp code does not have to worry about the conversion of * the directory name representation. */E 57E 36D 57UFS_readpage(args)D 34LispPTR	*args;E 34I 34register LispPTR	*args;E 34/*	args[0]:	Indirect pointer to FileID	*//*	args[1]:	Indirect pointer to PageOffset	*//*	args[2]:	pointer to buffer		*/I 48/*	args[3]:	pointer to errno		*/E 57I 57UFS_directorynamep(args) 	register LispPTR	*args;E 57E 48{D 34int	id;int	pageoffset;char	*bufp;D 27int	count;E 27I 27int	rval;E 27char	*bp;E 34I 34D 57register int	id;register int	pageoffset;register char	*bufp;register int	rval;register char	*bp;I 43int	count;struct	stat	sbuf;	/* Strucure for FileInfo. */I 46#ifdef	FSERRORD 48	Lisp_errno = &Dummy_errno;#endifE 48I 48	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));E 57I 57	char		dirname[MAXPATHLEN];	char		fullname[MAXPATHLEN];	register int	len, rval;	register char	*base;	struct stat	sbuf;E 57	ERRSETJMP(NIL);D 57#elseE 48E 46E 43E 34I 31	SETJMP(NIL);I 46D 48		/* There is no err in args, so we can not use ERRSETJMP */E 48I 48#endifE 48E 46E 31	id = LispNumToCInt(args[0]);	pageoffset = LispNumToCInt(args[1]);	bufp = (char*)(Addr68k_from_LADDR(args[2]));D 41	/* The filepointer is set to (pageoffset*PAGESIZE) bytes. */D 15	if(lseek(id, (pageoffset*PAGESIZE), L_SET) == -1)E 15I 15D 27	if(lseek(id, (pageoffset*PAGESIZE), L_SET) == -1){E 27I 27	TIMEOUT( rval=lseek(id, (pageoffset*PAGESIZE), L_SET) );E 41I 41D 43	/* The filepointer is set to (pageoffset*PAGE_SIZE) bytes. */	TIMEOUT( rval=lseek(id, (pageoffset*PAGE_SIZE), L_SET) );E 41	if(rval == -1){E 27		err_mess("lseek", errno);E 43I 43	TIMEOUT( rval=fstat(id, &sbuf) );	if(rval != 0){		err_mess("fstat", errno);I 48#ifdef FSERRORE 57I 57	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));	I 63	LispStringLength(args[0], len, rval);	len += 1;	/* -2 for the initial and trail directory delimitor. */	if (len > MAXPATHLEN - 2) FileNameTooLong(NIL);E 63	LispStringToCString(args[0], dirname, MAXPATHLEN);	/* Convert Xerox Lisp file naming convention to Unix one. */	if (unixpathname(dirname, fullname, 0, 0) == 0) return(NIL);	TIMEOUT(rval = stat(fullname, &sbuf));	if (rval == -1) {E 57		*Lisp_errno = errno;D 57#endifE 57E 48E 43E 15		return(NIL);I 15	}I 43D 57	if((sbuf.st_mode & S_IFREG) != 0){		/* Not regular file: skip, no need lseek */		/* Regular file: need lseek */		/* The filepointer is set to (pageoffset*PAGE_SIZE) bytes. */		TIMEOUT( rval=lseek(id, (pageoffset*PAGE_SIZE), L_SET) );		if(rval == -1){I 48#ifdef FSERROR			*Lisp_errno = errno;#endifE 48			err_mess("lseek", errno);			return(NIL);		}	}E 43E 15	/* Read BUFFSIZE bytes file contents from filepointer. */D 27	count = read(id, bufp, PAGESIZE);D 15	if( count == -1)E 15I 15	if( count == -1){E 27I 27D 41	TIMEOUT( rval=read(id, bufp, PAGESIZE) );E 41I 41D 43	TIMEOUT( rval=read(id, bufp, PAGE_SIZE) );E 41	if(rval == -1){E 43I 43	TIMEOUT( count=read(id, bufp, PAGE_SIZE) );	if(count == -1){I 48#ifdef FSERROR		*Lisp_errno = errno;#endifE 48E 43E 27		err_mess("read", errno);E 15		return(NIL);I 15	}E 15	/* Fill the unread part of buffer with 0. */D 27	for(bp = &bufp[count]; count < PAGESIZE; ++count, ++bp){E 27I 27D 41	for(bp = &bufp[rval]; rval < PAGESIZE; ++rval, ++bp){E 41I 41D 43	for(bp = &bufp[rval]; rval < PAGE_SIZE; ++rval, ++bp){E 43I 43	for(bp = &bufp[count], rval=count; rval < PAGE_SIZE; ++rval, ++bp){E 43E 41E 27		*bp = 0;	}I 56#ifdef BYTESWAP{   word_swap_page(bufp, PAGE_SIZE/4);E 57I 57	if ((sbuf.st_mode & S_IFMT) != S_IFDIR) return(NIL); 	/* Convert Unix file naming convention to Xerox Lisp one. */	if (lisppathname(fullname, dirname, 1, 0) == 0) return(NIL); 	len = strlen(dirname);	STRING_BASE(args[1], base); #ifndef	BYTESWAP	strncpy(base, dirname, len + 1);#else	StrNCpyFromCToLisp(base, dirname, len + 1);D 71#endif	BYTESWAPE 71I 71#endif /* BYTESWAP */E 71 	return(GetSmallp(len));E 57}D 57#endif BYTESWAPE 56D 43	return(ATOM_T);E 43I 43	return(GetSmallp(count));E 43}E 57I 62E 62I 36D 57/*** Common routine between DSK and UNIX. ****/E 57I 57/*		 * Name:	unixpathname * * Argument:	char	*src	Xerox Lisp syntax pathname. *				The HOST name field is not included. *				The initial directory delimiter is not included and *				if the pathname is passed as a directory, the *				tail delimiter may be included. *		char	*dst	The buffer to which the converted pathname is stored. *		int	versionp *				If 1, version field in src is converted to UNIX *				version form.  {DSK} device invokes unixpathname *				with versionp. *		int	genp	If 1, it indicates unixpathname is called from *				directory enmumerateion routine.  In this case, *				trail period which is used to specify an empty *				extension field is treated specially. * * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	None. * * Description: * * Converts the Xerox Lisp syntax pathname to Unix syntax pathname. * Src pathname might start with the one of the meta characters. And it * might include Xerox Lisp pathname quote notation.  The characters * must be quoted in the Xerox Lisp file naming convention are valid in the UNIX * file naming convention.  So only skipping the quote character would be * sufficient. * If the trail directory delimiter, '>', is included in src, dst will also include * UNIX trail directory delimiter '/'. * */E 57E 36D 57UFS_writepage(args)D 34LispPTR	*args;E 34I 34register LispPTR	*args;E 34/*	args[0]	:	Indirect pointer to FileID *//*	args[1] :	Indirect pointer to PageOffset	*//*	args[2] :	pointer to buffer	*/	/*	args[3] :	Indirect pointer to size		*/I 48/*	args[4] :	pointer to errno		*/E 57I 57unixpathname(src, dst, versionp, genp)	register char	*src;	register char	*dst;	register int	versionp;	register int	genp;E 57E 48{D 34int	id;int	pageoffset;char	*bufp;D 27int	count, size;E 27I 27int	rval, size;E 34I 34D 57register int	id;register int	pageoffset;register char	*bufp;register int	rval, size;I 46#ifdef	FSERRORD 48	Lisp_errno = &Dummy_errno;#endifE 48I 48	Lisp_errno = (int *)(Addr68k_from_LADDR(args[4]));	ERRSETJMP(NIL);#elseE 48E 46E 34I 31	SETJMP(NIL);I 46D 48		/* There is no err in args, so we can not use ERRSETJMP */E 48I 48#endifE 48E 46E 31E 27	id = LispNumToCInt(args[0]);	pageoffset = LispNumToCInt(args[1]);	bufp = (char*)(Addr68k_from_LADDR(args[2]));	size = LispNumToCInt(args[3]);D 41	/* The filepointer is set to (pageoffset*PAGESIZE) bytes. */D 15	if(lseek(id, (pageoffset*PAGESIZE), L_SET) == -1)E 15I 15D 27	if(lseek(id, (pageoffset*PAGESIZE), L_SET) == -1){E 27I 27	TIMEOUT( rval=lseek(id, (pageoffset*PAGESIZE), L_SET) );E 41I 41	/* The filepointer is set to (pageoffset*PAGE_SIZE) bytes. */	TIMEOUT( rval=lseek(id, (pageoffset*PAGE_SIZE), L_SET) );E 41	if(rval == -1){E 27D 48		err_mess("lseek", errno);E 48I 48#ifdef FSERROR		*Lisp_errno = errno;#endif		if(errno != 28){			/* When error is file system full, skip err_mess() */			err_mess("write", errno);E 57I 57	register char	*cp, *dp, *np;	register int	newdirflg;	char		name[64];	char		lfname[MAXPATHLEN], fbuf1[MAXPATHLEN], fbuf2[MAXPATHLEN];	char		ver1[VERSIONLEN], ver2[VERSIONLEN];	struct passwd	*pwd;D 61	ERRSETJMP(0);	E 61	/*	 * The UNIX root directory is represented as "<" in Xerox Lisp generic	 * file system code.	 */	if (strcmp(src, "<") == 0) {		strcpy(dst, "/");		return(1);	}	/* Copy src to protect it from destructive modification. */	strcpy(lfname, src);		/*	 * If versionp is specified, we have to deal with the version field first,	 * because the quotation mark which quotes the semicolon might be lost	 * in the course of the following conversion.	 */	if (versionp) LispVersionToUnixVersion(lfname);	cp = lfname;	dp = dst;	/*	 * We have to deal with the case in which the pathname is started with	 * the meta character ('.', '~').	 */	switch (*cp) {			      case '.':		switch (*(cp + 1)) {		      case '.':			if (*(cp + 2) == '>' || *(cp +2) == '\0') {				/*				 * "..>" or ".." means the parent directory of the				 * user's current working directory.				 */				if (getwd(dst) == 0) return(0);				dp = rindex(dst, '/');								dp++;				if (*(cp + 2) == '\0')				  cp += 2;				else				  cp += 3;			} else {				/* Insert the initial directory delimiter. */				*dp++ = '/';			}			break;		      case '>':			/* ".>" means the user's current working directory. */			if (getwd(dst) == 0) return(0);			while (*dp != '\0') dp++;			*dp++ = '/';			cp += 2;			break;					      case '\0':			/* "." also means the user's current working directory. */			if (getwd(dst) == 0) return(0);			while (*dp != '\0') dp++;			*dp++ = '/';			cp++;			break;		      default:			/* Insert the initial directory delimiter. */			*dp++ = '/';			break;E 57		}E 48E 15D 57		return(NIL);E 57I 57		break;	      case '~':		if (*(cp + 1) == '>' || *(cp +  1) == '\0') {			/* "~>" or "~" means the user's home directory. */			TIMEOUT(pwd = getpwuid(getuid()));			if (pwd == NULL) return(0);			strcpy(dst, pwd->pw_dir);			while (*dp != '\0') dp++;			if (*(dp -1) != '/') {				/*				 * Usually system administrators specify the users'				 * home directories in the /etc/passwd without				 * the trail directory delimiter.				 */				*dp++ = '/';			}			if (*(cp + 1) == '\0')			  cp++;			else			  cp += 2;		} else {			/*			 * In this case, we assume some user's home directory			 * is specifed in the form "~username".			 */			for (++cp, np = name; *cp != '\0' && *cp != '>';) *np++ = *cp++ ;			*np = '\0';			TIMEOUT(pwd = getpwnam(name));			if (pwd == NULL) return(0);			strcpy(dst, pwd->pw_dir);			while (*dp != '\0') dp++;			if (*(dp -1) != '/') {				/*				 * Usually system administrators specify the users'				 * home directories in the /etc/passwd without				 * the trail directory delimiter.				 */				*dp++ = '/';			}			if (*cp == '>') cp++;		}		break;	      default:		*dp++ = '/';	/* Insert the initial directory delimiter. */		break;E 57I 15	}E 15D 41	/* Read PAGESIZE bytes file contents from filepointer. */E 41I 41D 57	/* Read PAGE_SIZE bytes file contents from filepointer. */I 56#ifdef BYTESWAP  word_swap_page(bufp, (size+3)>>2);#endif BYTESWAPE 56E 41D 27	count = write(id, bufp, size);D 15	if( count == -1)E 15I 15	if( count == -1){E 27I 27	TIMEOUT( rval=write(id, bufp, size) );	if( rval == -1){E 27D 48		err_mess("write", errno);E 48I 48#ifdef FSERROR		*Lisp_errno = errno;#endif		if(errno != 28){			/* When error is file system full, skip err_mess() */			err_mess("write", errno);E 57I 57	/*	 * At this point, cp is placed at the point from which the source pathname	 * will be scaned, and dp is placed at the point on dst from which the	 * pathname will be copied.	 */	newdirflg = 1;	while (*cp != '\0') {		if (newdirflg) {			/*			 * The new directory component starts.  We have to care about			 * the meta characters again.  This time, the tilde character			 * has no special meaning.			 */			switch (*cp) {			      case '.':				switch (*(cp + 1)) {				      case '.':					/* "..>" or ".." */					if (*(cp + 2) == '>' || *(cp + 2) == '\0') {						/*						 * We have to check if we have already						 * backed to the root directory or not.						 */						if ((dp - 1) != dst) {							/*							 * We are not at the root							 * directory.  Back to the							 * parent directory.							 */							for (dp -= 2; *dp != '/'; dp--) {}							dp++;						}						if (*(cp + 2) == '\0')						  cp += 2;						else						  cp += 3;					} else {						/*						 * (IL:DIRECTORY "{DSK}.") is translated						 * as (IL:DIRECTORY "{DSK}~>.;*").						 * The Lisp directory is translated as						 * like "/users/akina/..~*~" by						 * unixpathname.   Although such						 * file name representaion makes no sense,						 * to avoid infinite loop, skip the						 * first period here, as well as down						 * a newdirflg.						 */						cp++;						newdirflg = 0;					}					break;				      case '>':					/* ".>" */					cp += 2;					break;									      case '\0':					/* "." */					cp++;					break;				      default:					*dp++ = *cp++;					newdirflg = 0;					break;				}				break;			      case '\'':				/*				 * The first character of the new directory component				 * is a quotation mark which is the quote character				 * in the Xerox Lisp file naming convention.  Copy the				 * next character and skip the quoted character.				 */				*dp++ = *(cp + 1);				cp += 2;				newdirflg = 0;				break;			      default:				*dp++ = *cp++;				newdirflg = 0;				break;			}		} else {			switch (*cp) {							      case '>':				/*				 * Xerox Lisp directory delimiter '>' is translated into				 * UNIX one, '/'.				 */				*dp = '/';				dp++;				cp++;				newdirflg = 1; /* Turn on the new directory flag. */				break;							      case '\'':				/*				 * The special characters in the Xerox Lisp file naming				 * convention are quoted with the quote character.				 * They are all valid in the UNIX file naming convention.				 * So only we have to do is to skip the quotation mark				 * and copy the next character.				 */				*dp++ = *(cp + 1);				cp += 2;				break;			      default:				*dp++ = *cp++;				break;			}E 57		}E 48E 15D 57		return(NIL);E 57I 15	}E 15D 57	return(ATOM_T);E 57I 57	*dp = '\0';	if (!newdirflg && !genp) {		/*		 * If the last chracter in dst is a period, it have to be handled		 * specially, because it might be used to specify that src has no		 * extension field.  This case can be distinguish by examining the		 * character just before the period.		 * If the specified pathname is one like "~>..", the last meta character		 * matches this case.  Thus we check newdirflg first so as not to be		 * confused by this case.		 *		 * Only case in which genp is 1 is unixpathname is used to convert		 * a pattern which is used to enumerate directory.  In this csae,		 * for the convinience of the pattern matching routines, we don't		 * care about the last period character.		 */		strcpy(fbuf1, lfname);		strcpy(fbuf2, dst);		separate_version(fbuf1, ver1, 1);		separate_version(fbuf2, ver2, 1);		for (cp = fbuf1; *cp; cp++) {}		for (dp = fbuf2; *dp; dp++) {}D 59		if (*(cp - 1) == '.' && *(cp - 2) != '\'') {			/*			 * The last period is not been quoted.  It is used to specify			 * the no extension case.  We have to omit this period.			 */			*(dp - 1) = '\0';E 59I 59		if (*(cp - 1) == '.') {			if (*(cp - 2) != '\'' ||			    ((cp - 3) > fbuf1 && *(cp - 3) == '\'')) {				/*				 * The last period is not been quoted.  It is used				 * to specify the no extension case.  We have to				 * omit this period.				 */				*(dp - 1) = '\0';			}E 59		}		ConcNameAndVersion(fbuf2, ver2, dst);	}	return(1);E 57}I 62E 62D 57UFS_getsize(args)D 34LispPTR	*args;E 34I 34register LispPTR	*args;I 37/* This function set real file size. The name should be UFS_setsize */E 37E 34/*	args[0]:	Indirect pointer file ID to be closed */D 37/*	args[1]:	Pointer to FIXP buffer.	*/E 37I 37/*	args[1]:	Indirect pointer file size	*/I 47/*	args[2]:	pointer to errno	*/E 57I 57/*		 * Name:	lisppathname * * Argument:	char	*fullname	UNIX full pathname. *		char	*lispname	The pathnaem following the Xerox *					Lisp naming convention. *				        The first argument fullname is assumed *					the "true" name of lispname. *					The lispname is used to determine which *					charcter should be quoted in the result *					Xerox Lisp pathname representation. *		int	dirp		If 1, fullname is a directory.  If 0, *					fullname is a file. *		int	versionp	If 1, version field is also converted *					to the Xerox Lisp version.  {DSK} device *					invokes lisppathname with versionp but *					{UNIX} device without versionp.  If *					versionp is 1, dirp must be 0. * * Value:	If succeed, returns 1, otherwise 0. *		of the "true" name of the directory, otherwise Lisp NIL. * * Side Effect:	If succeed, lispname is replaced with "true" name which follows *		the Xerox Lisp file naming convention. * * Description: * * Converts the UNIX file name to Xerox Lisp file name.  The fields which might * be included in the result filename are directory, name, extension, and version. * The result file name can use the quotation mark to quote the chracters which * are dealt with specially in the Xerox Lisp file naming convention.  These * characters include "<", ">", ";", ".", and "'" itself.  Notice that "." must be * quoted if it is used as a part of the extension field.  Also notice that "<" * is quoted only if it is used as a first character of the initial directory. * */lisppathname(fullname, lispname, dirp, versionp)	register char	*fullname;	register char	*lispname;	register int	dirp;	register int	versionp;E 57E 47E 37{D 34int	id;	/* FileID */int	*bufp;	/* pointer to FIXP buffer */E 34I 34D 57register int	rval;register int	id;	/* FileID */D 37register int	*bufp;	/* pointer to FIXP buffer */E 37I 37register int	size;	/* file size */E 37E 34struct	stat	sbuf;	/* Strucure for FileInfo. */I 36#ifdef	FSERRORD 46int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[2]));		ERRSETJMP(NIL, errp);E 46I 46	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));		ERRSETJMP(NIL);E 46#elseE 36I 27D 34int	rval;E 34I 31	SETJMP(NIL);I 36#endifE 36E 31E 27	id = LispNumToCInt(args[0]);D 15	if(fstat(id, &sbuf) != 0)E 15I 15D 27	if(fstat(id, &sbuf) != 0){E 27I 27D 37	TIMEOUT( rval=fstat(id, &sbuf) );E 37I 37	size = LispNumToCInt(args[1]);I 43	TIMEOUT( rval=fstat(id, &sbuf) );	if(rval != 0){		err_mess("fstat", errno);#ifdef FSERRORD 46		*errp = errno;E 46I 46		*Lisp_errno = errno;E 46#endif		return(NIL);E 57I 57	register char	*cp, *dp, *lnamep, *cnamep;	char		namebuf[MAXPATHLEN], fbuf[MAXPATHLEN], ver[VERSIONLEN];	register int	i, mask, extensionp;		if (strcmp(fullname, "/") == 0) {		strcpy(lispname, "<");		return(1);E 57	}D 57	if((sbuf.st_mode & S_IFREG) == 0){		/* Not regular file, no need truncate */		return(ATOM_T);E 57I 57	if (!dirp) {		/*		 * The characters which are dealt with specialy (i.e. are quoted)		 * in the Xerox Lisp file naming convention are all valid in UNIX		 * file name convetion.  So the conversion rule is almost		 * straightforward except the "extension" field.  Only glancing		 * the UNIX file name, we cannot determine which period character		 * should be quoted in the result Xerox Lisp file name when more		 * than one period are included in the UNIX file name.  In such		 * case, we have to refer to the Xerox Lisp file name representation		 * which is specified the user.  Thus, at first, extract the		 * name field from the original Lisp file name.		 */		cp = lispname;		lnamep = cp - 1;		while (*cp != '\0') {			switch (*cp) {							      case '>':				lnamep = cp + 1;				cp++;				break;			      case '\'':				if (*(cp + 1) != '\0')				  cp += 2;				else				  cp++;				break;			      default:				cp++;				break;			}		}		/* Name field in the UNIX file name representation. */		cnamep = rindex(fullname, '/') + 1;	} else {		cnamep = fullname + strlen(fullname);E 57	}E 43D 57	TIMEOUT( rval=ftruncate(id, size) );E 37	if(rval != 0){E 27D 37		err_mess("fstat", errno);E 37I 37		err_mess("ftruncate", errno);I 49#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);E 57I 57	/*	 * Convertion rule of file name from UNIX to Xerox Lisp.	 *	UNIX		Lisp	 *	/		<    only if it is used as a root directory	 *			     delimiter.	 *	/		>    if used as a directory delimiter for other	 *			     directories than root directory.	 *	>		'>	 *	;		';	 *	'		''	 *	.		'.   only if it is used as a part of the extension	 *			     field.	 *	others		as if	 */	cp = fullname + 1;	dp = namebuf;	*dp++ = '<';	if (*cp == '<') {		/*		 * If the first character of the initial directory is '<',		 * it should be quoted in the result Lisp file name.		 */		*dp++ = '\'';		*dp++ = *cp++;E 57	}D 57	/* sync the file state */	/* This routine is called from Lisp FORCEOUTPUT, it expects sync */	TIMEOUT( rval=fsync(id) );	if(rval != 0){		err_mess("fsync", errno);E 49E 37I 36#ifdef FSERRORD 46		*errp = errno;E 46I 46		*Lisp_errno = errno;E 46#endifE 36E 15		return(NIL);E 57I 57		while (cp < cnamep) {		switch (*cp) {					      case '>':		      case ';':		      case '\'':			*dp++ = '\'';			*dp++ = *cp++;			break;		      case '/':			*dp++ = '>';			cp++;			break;		      default:			*dp++ = *cp++;			break;		}E 57I 15	}E 15D 37	bufp = (int *)(Addr68k_from_LADDR(args[1]));	*bufp = sbuf.st_size;E 37D 57	return(ATOM_T);}E 57D 57UFS_directorynamep(args)D 34LispPTR	*args;E 34I 34register LispPTR	*args;E 34/*	args[0]:	IndirectPonter to Directory Name */I 46D 47/* 	args[1]		buf for errno */E 47I 47D 48/* 	args[1]		buf for errno *//** [hh:12/01] It is not passed from LISP **/E 48I 48/* 	args[1]		buf for errno */	/** [hh:12/01] It is not passed from LISP **/	/** [hh:12/06] It is passed from new LISP **/E 48E 47E 46{I 34register int	rval;struct	stat	sbuf;	/* Strucure for FileInfo. */E 34char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];I 36#ifdef	FSERRORD 46int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[1]));	E 46I 46D 47	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));	E 47I 47D 48/**	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));	**/	Lisp_errno = &Dummy_errno;E 48I 48	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));/**	Lisp_errno = &Dummy_errno; **/E 48E 47E 46#endifE 36D 34struct	stat	sbuf;	/* Strucure for FileInfo. */I 27int	rval;E 34I 31D 35	SETJMP(NIL);E 35E 31E 27D 53	LispStringToCString(args[0], pathname);E 53I 53	LispStringToCString(args[0], pathname, MAXPATHLEN);E 53I 36D 46#ifdef	FSERROR	if( makepathname(pathname, fullpathname, errp) == 0){D 45		*errp = errno;E 45		return(NIL);	}#elseE 46E 36	if( makepathname(pathname, fullpathname) == 0)		return(NIL);I 36D 46#endifE 46#ifdef	FSERRORD 46	ERRSETJMP(NIL, errp);E 46I 46	ERRSETJMP(NIL);E 46#elseE 36I 35	SETJMP(NIL);I 36#endifE 36E 35D 15	if(stat(fullpathname, &sbuf) != 0)E 15I 15D 27	if(stat(fullpathname, &sbuf) != 0){E 27I 27	TIMEOUT( rval=stat(fullpathname, &sbuf) );	if(rval != 0){E 27		err_mess("stat", errno);I 36#ifdef FSERRORD 46		*errp = errno;E 46I 46		*Lisp_errno = errno;E 46#endifE 36E 15		return(NIL);E 57I 57	if (dirp) {		if (*(dp - 1) != '>' ||  *(dp - 2) == '\'') *dp++ = '>';		*dp = '\0';		strcpy(lispname, namebuf);		return(1);E 57I 15	}E 15D 57	if((sbuf.st_mode & S_IFMT) == S_IFDIR)		return(ATOM_T);	return(NIL);}E 57D 57UFS_getfileinfo(args)D 34LispPTR	*args;E 34I 34register LispPTR	*args;E 34/*	args[0]:	IndirectPonter to File Name *//*	args[1]:	IndirectPonter to Attribute *//*	args[2]:	IndirectPonter to BUffer */I 36/* args[3]		buf for errno */E 36{D 34char	pathname[MAXPATHLEN];int	*buffixp;E 34I 34D 39register int	*buffixp;E 39I 39register unsigned int	*buffixp;E 39register char	*base;register struct passwd *pwd;register int	rval;E 34LispPTR	*naddress;D 34char	*base;E 34struct stat sbuf;D 34struct passwd *pwd;D 27int	length;E 27I 27int	rval;E 34I 34char	pathname[MAXPATHLEN];I 39LispPTR	lisp_addr;E 57I 57	/*	 * Be careful dealing with the extenstion field.  If we encounter with the	 * period mark which was quoted in the original Lisp file name, we have	 * to quote it in the result file name.	 * First we count the period mark included in the Lisp file name, and	 * remember the position of the quoted period.  Then when we met the	 * period while we are converting the UNIX file name into Lisp one,	 * examine it if it is a quoted one or not, then if so, we quote it.	 */E 57E 39I 36D 57#ifdef	FSERRORD 46int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));		ERRSETJMP(NIL, errp);E 46I 46	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));		ERRSETJMP(NIL);E 46#elseE 36E 34I 31	SETJMP(NIL);I 36#endifE 36E 31E 27D 53	LispStringToCString(args[0], pathname);E 53I 53	LispStringToCString(args[0], pathname, MAXPATHLEN);E 53D 15	if(stat(pathname, &sbuf) != 0)E 15I 15D 27	if(stat(pathname, &sbuf) != 0){E 27I 27	TIMEOUT( rval=stat(pathname, &sbuf) );	if(rval != 0){E 27		err_mess("stat", errno);I 36#ifdef FSERRORD 46		*errp = errno;E 46I 46		*Lisp_errno = errno;E 46#endifE 36E 15		return(NIL);E 57I 57	mask = 0;	i = 1;	lnamep++;	while (*lnamep) {		if (*lnamep == '.') {			if (lnamep != lispname && *(lnamep - 1) == '\'') mask |= i;			i <<= 1;		}		lnamep++;E 57I 15	}E 15D 57	switch(args[1]){	case SIZE:D 39		buffixp = (int *)(Addr68k_from_LADDR(args[2]));E 39I 39		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));E 39		*buffixp = sbuf.st_size;		return(ATOM_T);	case WDATE:D 39		buffixp = (int *)(Addr68k_from_LADDR(args[2]));E 39I 39		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));E 39		*buffixp = ToLispTime(sbuf.st_mtime);		return(ATOM_T);	case RDATE:D 39		buffixp = (int *)(Addr68k_from_LADDR(args[2]));E 39I 39		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));E 39		*buffixp= ToLispTime(sbuf.st_atime);		return(ATOM_T);	case AUTHOR:D 17		pwd = getpwuid(getuid());E 17I 17D 31		pwd = getpwuid(sbuf.st_uid);E 31I 31		TIMEOUT( pwd = getpwuid(sbuf.st_uid) );E 31I 22		if(pwd == NULL){D 32			printf("error:getpwuid\n");E 32D 52			return(NIL);E 52I 52		/** changed to return 0 for author name length -was **/			return(GetSmallp(0));E 57I 57				i = 1;	while (*cp) {		switch (*cp) {					      case '>':		      case ';':		      case '\'':			*dp++ = '\'';			*dp++ = *cp++;			break;		      case '.':			if ((i & mask) == i) {				/* This period should be quoted. */				*dp++ = '\'';				*dp++ = *cp++;			} else {				*dp++ = *cp++;			}			i <<= 1;			break;		      default:			*dp++ = *cp++;			break;E 57E 52		}E 22E 17D 57		/*** CStringToLispString ***/		naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));D 51		base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));E 51I 51		base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));E 51D 27		length = strlen(pwd->pw_name);		strncpy( base, pwd->pw_name, length );				return(GetSmallp(length));E 27I 27		rval = strlen(pwd->pw_name);I 55#ifndef BYTESWAPE 55		strncpy( base, pwd->pw_name, rval );		I 55#else		StrNCpyFromCToLisp( base, pwd->pw_name, rval );#endif BYTESWAPE 55		return(GetSmallp(rval));I 29	case PROTECTION:D 39		buffixp = (int *)(Addr68k_from_LADDR(args[2]));E 39I 39		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));E 39		*buffixp= sbuf.st_mode;		return(ATOM_T);I 39	case ALL:		/* length */		lisp_addr = cdr(car(args[2]));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp= sbuf.st_size;		/* wdate */		lisp_addr = cdr(car(cdr(args[2])));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp = ToLispTime(sbuf.st_mtime);		/* rdate */		lisp_addr = cdr(car(cdr(cdr(args[2]))));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp= ToLispTime(sbuf.st_atime);		/* protection */		lisp_addr = cdr(car(cdr(cdr(cdr(args[2])))));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp= sbuf.st_mode;		/* author */		TIMEOUT( pwd = getpwuid(sbuf.st_uid) );		if(pwd == NULL){D 52			return(NIL);E 52I 52		/** changed to return 0 for author name length -was **/			return(GetSmallp(0));E 52		}		lisp_addr = cdr(car(cdr(cdr(cdr(cdr(args[2]))))));		naddress = (LispPTR *)(Addr68k_from_LADDR(lisp_addr));D 51		base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));E 51I 51		base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));E 51		rval = strlen(pwd->pw_name);I 55#ifndef BYTESWAPE 55		strncpy( base, pwd->pw_name, rval );		I 55#else		StrNCpyFromCToLisp( base, pwd->pw_name, rval );#endif BYTESWAPE 55		return(GetSmallp(rval));E 39E 29E 27	default:		return(NIL);E 57	}D 57}E 57D 57UFS_setfileinfo(args)D 34LispPTR	*args;E 34I 34register LispPTR	*args;E 34/*	args[0]:	IndirectPonter to File Name *//*	args[1]:	IndirectPonter to Attribute *//*	args[2]:	IndirectPonter to Value */I 46/* 	args[3]		buf for errno */E 46{D 34char	pathname[MAXPATHLEN];D 27int	date;E 27I 27int	rval;E 34I 34D 39register int	rval;E 39I 39register unsigned int	rval;E 39E 34E 27struct stat	sbuf;D 39struct timeval time[2];E 39I 39static struct timeval time[2];E 39I 34char	pathname[MAXPATHLEN];I 36#ifdef	FSERRORD 46int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));		ERRSETJMP(NIL, errp);E 46I 46	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));		ERRSETJMP(NIL);E 46#elseE 36E 34I 31	SETJMP(NIL);I 36#endifE 36E 31D 53	LispStringToCString(args[0], pathname);E 53I 53	LispStringToCString(args[0], pathname, MAXPATHLEN);E 53D 15	if(stat(pathname, &sbuf) != 0)E 15I 15D 27	if(stat(pathname, &sbuf) != 0){E 27I 27D 39	TIMEOUT( rval=stat(pathname, &sbuf) );	if(rval != 0){E 27		err_mess("stat", errno);I 36#ifdef FSERROR		*errp = errno;#endifE 36E 15		return(NIL);I 15	}E 39E 15	switch(args[1]){	case WDATE:I 39		TIMEOUT( rval=stat(pathname, &sbuf) );		if(rval != 0){			err_mess("stat", errno);#ifdef FSERRORD 46			*errp = errno;E 46I 46			*Lisp_errno = errno;E 46#endif			return(NIL);E 57I 57	*dp = '\0';	/*	 * exntensionp indicates whether exentsion field is included in a file name	 * or not.  If extenstion field is not included, we have to add a period	 * to specify empty extension field.	 */	strcpy(fbuf, namebuf);	dp = cp = fbuf;	while (*cp) {		switch (*cp) {		      case '>':			dp = cp;			cp++;			break;		      case '\'':			if (*(cp + 1) != '\0')			  cp += 2;			else			  cp++;			break;		      default:			cp++;			break;E 57		}E 39D 27		date = LispNumToCInt(args[2]);E 27I 27D 57		rval = LispNumToCInt(args[2]);E 27		time[0].tv_sec = sbuf.st_atime;D 27		time[1].tv_sec = ToUnixTime(date);D 21		if(utimes(pathname, time) != 0)E 21I 21		if(utimes(pathname, time) != 0){E 27I 27		time[1].tv_sec = ToUnixTime(rval);		TIMEOUT( rval=utimes(pathname, time) );		if(rval != 0){E 27			err_mess("utimes", errno);I 39#ifdef FSERRORD 46			*errp = errno;E 46I 46			*Lisp_errno = errno;E 46#endif			return(NIL);		}		return(ATOM_T);	case PROTECTION:		rval = LispNumToCInt(args[2]);		TIMEOUT( rval=chmod(pathname, rval) );		if(rval != 0){			err_mess("chmod", errno);E 39I 36#ifdef FSERRORD 46			*errp = errno;E 46I 46			*Lisp_errno = errno;E 46#endifE 36E 21			return(NIL);I 21		}E 21		return(ATOM_T);	default:		return(NIL);E 57	}D 57}E 57I 57	cp = dp + 1;	if (versionp) separate_version(fbuf, ver, 1);	extensionp = 0;	while (*cp && !extensionp) {		switch (*cp) {E 57D 57UFS_dirsize(args)D 34LispPTR	*args;E 34I 34register LispPTR	*args;E 34/*	args[0]:	IndirectPonter to Directory Name *//*	args[1]:	IndirectPonter to Filter Name */I 46/* 	args[2]		buf for errno */E 46{I 34register int	size;E 34char	dirname[MAXPATHLEN];char	fulldirname[MAXPATHLEN];char	filter[MAXPATHLEN];I 36#ifdef	FSERRORD 46int	errp;E 46I 46	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));	E 46#endifE 36D 34int	size;E 34D 53	LispStringToCString(args[0], dirname);E 53I 53	LispStringToCString(args[0], dirname, MAXPATHLEN);E 53I 36D 46#ifdef	FSERROR	if( makepathname(dirname, fulldirname, &errp) == 0)#elseE 46E 36	if( makepathname(dirname, fulldirname) == 0)I 36D 46#endifE 46E 36		return(NIL);D 53	LispStringToCString(args[1], filter);E 53I 53	LispStringToCString(args[1], filter, MAXPATHLEN);E 53I 4D 14	LispVersionToNoVersion(filter);E 4	size = alldirSize( fulldirname, "", 0, filter);E 14I 14D 22	/*LispVersionToNoVersion(filter);*/	size = alldirSize( fulldirname, "", 0, filter);E 22I 22	size = alldirSize( fulldirname, "", 0, filter);E 22E 14	if(size == -1)		return(NIL);	else		return(GetSmallp(size));}E 57I 57		      case '.':			extensionp = 1;			break;E 57D 57UFS_readdir(args)D 34LispPTR	*args;E 34I 34register LispPTR	*args;E 34/*	args[0]:	IndirectPonter to Directory Name *//*	args[1]:	IndirectPonter to Filter Name *//*	args[2]:	IndirectPonter to BUffer */I 46/* 	args[3]		buf for errno */E 46{I 34register LispPTR	*naddress;register char	*base;register int	size;E 34char	dirname[MAXPATHLEN];char	fulldirname[MAXPATHLEN];char	filter[MAXPATHLEN];I 36#ifdef	FSERRORD 46int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));	E 46I 46	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	E 46#endifE 36D 34LispPTR	*naddress;char	*base;int	size;E 34D 53	LispStringToCString(args[0], dirname);E 53I 53	LispStringToCString(args[0], dirname, MAXPATHLEN);E 53I 36D 46#ifdef	FSERROR	if( makepathname(dirname, fulldirname, errp) == 0){D 45		*errp = errno;E 45		return(NIL);	}#elseE 46E 36	if( makepathname(dirname, fulldirname) == 0)		return(NIL);I 36D 46#endifE 46E 36D 53	LispStringToCString(args[1], filter);E 53I 53	LispStringToCString(args[1], filter, MAXPATHLEN);E 53I 4D 14	LispVersionToNoVersion(filter);E 4	naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));E 14I 14D 22/*	LispVersionToNoVersion(filter);*/	naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));E 22I 22	naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));E 22E 14D 51	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));E 51I 51	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));E 51D 9	size = readAllDir(fulldirname, "", 0, filter, base);E 9I 9D 10	size = UFS_readAllDir(fulldirname, "", 0, filter, base);E 10I 10D 11	size = readAllDir(fulldirname, "", 0, filter, base);E 11I 11	size = UFS_readAllDir(fulldirname, "", 0, filter, base);E 11E 10E 9	if(size == -1)		return(NIL);	else		return(GetSmallp(size));}E 57I 57		      case '\'':			if (*(cp + 1) != '\0')			  cp += 2;			else			  cp++;			break;E 57I 8D 22UFS_currentdir(args)LispPTR	*args;{}E 22E 8D 7UFS_currentdir(args)E 7I 7D 57UFS_changedir(args)E 7D 34LispPTR	*args;E 34I 34register LispPTR	*args;E 34I 7/*	args[0]:	IndirectPonter to Directory Name */E 7{I 34register int	rval;E 34I 7char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];I 36#ifdef	FSERRORD 46int	errp;E 46I 46	Lisp_errno = &Dummy_errno;E 46#endifE 36I 27D 34int	rval;E 34I 31D 35	SETJMP(NIL);E 35E 31E 27D 53	LispStringToCString(args[0], pathname);E 53I 53	LispStringToCString(args[0], pathname, MAXPATHLEN);E 53I 36D 46#ifdef	FSERROR	if( makepathname(pathname, fullpathname, &errp) == 0)#elseE 46E 36	if( makepathname(pathname, fullpathname) == 0)I 36D 46#endifE 46E 36		return(NIL);I 35	SETJMP(NIL);I 46		/* There is no err in args, so we can not use ERRSETJMP */E 46E 35D 15	if(chdir(fullpathname) != 0)E 15I 15D 27	if(chdir(fullpathname) != 0){E 27I 27	TIMEOUT( rval=chdir(fullpathname) );	if(rval != 0){E 27		err_mess("chdir", errno);	E 15		return(NIL);E 57I 57		      default:			cp++;			break;		}E 57I 15	}E 15I 13D 57	return(ATOM_T);E 57I 57	if (!extensionp) {		*cp++ = '.';		*cp = '\0';	}	if (versionp && *ver != '\0') {		ConcNameAndVersion(fbuf, ver, namebuf);	} else {		strcpy(namebuf, fbuf);	}	/*	 * Now, it's time to convert the version field.	 */D 60	if (!dirp && versionp) UnixVersionToLispVersion(namebuf);E 60I 60	if (!dirp && versionp) UnixVersionToLispVersion(namebuf, 0);E 60		strcpy(lispname, namebuf);	return(1);E 57}I 62E 62D 57UFS_getfreeblock(args)D 34LispPTR	*args;E 34I 34register LispPTR	*args;E 34/*	args[0]:	IndirectPonter to file Name *//*	args[1]:	IndirectPonter to buffer */E 57I 57/*		D 60 * Name:	quote_filenameE 60I 60 * Name:	quote_fnameE 60 * * Argument:	char	*file		The root file name in UNIX format.  "Root" *					file name contains the name, extenstion and *					version fields.  A valid version field is in a *					form as ".~##~".D 60 *		int	versionp	If 1, version field is also converted *					to the Xerox Lisp version.  {DSK} device *					invokes lisppathname with versionp but *					{UNIX} device without versionp.  If *					versionp is 1, dirp must be 0. *		int	dirp		If 1, the file is directory.E 60 * * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	If succeed, file is replaced with the file name in Xerox Lisp format *		in which special characters are quoted. * * Description: * * Converts a UNIX root file name to Xerox Lisp one.  This routine only quotes special * characters in Xerox file naming convention, does not care about the "true" name * which might be specified directly by the user as like lisppathname.   Thus, this * routine can be invoked when you don't know how to escape the period character.  This * is the case when you convert a file name in the course of the directory enumeration. *I 60 * This routine is used when file is a "FILE" name and being converted to {DSK} name. *E 60 * The special characters which is quoted include "<", ">", ";", and "'" itself.  Notice * again that "." is not quoted, because we don't know it is a extension separator in * Lisp sense or not. */D 60quote_filename(file, versionp, dirp)E 60I 60quote_fname(file)E 60	register char	*file;D 60	register int	versionp;E 60E 57{I 34D 57register int	*buffixp;register char	*cp;register int	rval;struct statfs	buf;E 34char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];I 36#ifdef	FSERRORD 46int	errp;E 46I 46	Lisp_errno = &Dummy_errno;E 46#endifE 36D 34struct statfs	buf;int	*buffixp;I 15char	*cp;I 27int	rval;E 34I 31D 35	SETJMP(NIL);E 35E 31E 27I 23	buffixp = (int *)(Addr68k_from_LADDR(args[1]));E 23E 15D 53	LispStringToCString(args[0], pathname);E 53I 53	LispStringToCString(args[0], pathname, MAXPATHLEN);E 53D 23	if( makepathname(pathname, fullpathname) == 0)E 23I 23D 24	if( makepathname(pathname, fullpathname) == 0){E 24I 24	/*** SkipHostName ***/	if(*pathname == '{'){		if((cp=index(pathname, '}')) == 0)			cp = pathname;		else			++cp;	}else		cp = pathname;I 36D 46#ifdef	FSERROR	if( makepathname(cp, fullpathname, &errp) == 0){#elseE 46E 36	if( makepathname(cp, fullpathname) == 0){I 36D 46#endifE 46E 36E 24		*buffixp = 0;	E 23		return(NIL);E 57I 57	register char	*cp, *dp;	register int	extensionp;	char		fbuf[MAXNAMLEN + 1], namebuf[MAXNAMLEN + 1], ver[VERSIONLEN];		cp = file;	dp = fbuf;	while (*cp) {		switch (*cp) {		      case '>':		      case ';':		      case '\'':			*dp++ = '\'';			*dp++ = *cp++;			break;		      default:			*dp++ = *cp++;			break;		}E 57I 23	}D 24/***E 23D 15	if( statfs(fullpathname, &buf) != 0)E 15I 15D 22	cp = rindex(fullpathname, '/');E 22I 22	if( (cp=rindex(fullpathname, '/')) == 0)		return(NIL);E 22	*cp = '\0';	if( statfs(fullpathname, &buf) != 0){		err_mess("statfs", errno);	E 15		return(NIL);I 15	}E 15D 23	buffixp = (int *)(Addr68k_from_LADDR(args[1]));E 23I 23***/E 24D 57	while(T){		if((cp=rindex(fullpathname, '/')) == 0){			*buffixp = 0;				return(NIL);E 57I 57	*dp = '\0';D 60	if (!dirp) {		/*		 * exntensionp indicates whether exentsion field is included in a file		 * name or not.  If extenstion field is not included, we have to add a		 * period to specify empty extension field.		 */		if (versionp) separate_version(fbuf, ver, 1);		cp = fbuf;		extensionp = 0;		while (*cp && !extensionp) {			switch (*cp) {E 60I 60	/*	 * exntensionp indicates whether exentsion field is included in a file	 * name or not.  If extenstion field is not included, we have to add a	 * period to specify empty extension field.	 */	separate_version(fbuf, ver, 1);	cp = fbuf;	extensionp = 0;	while (*cp && !extensionp) {		switch (*cp) {E 60D 60			      case '.':				if (*(cp + 1)) extensionp = 1;				cp++;				break;E 60I 60		      case '.':			if (*(cp + 1)) extensionp = 1;			cp++;			break;E 60D 60			      case '\'':				if (*(cp + 1) != '\0')				  cp += 2;				else				  cp++;				break;E 60I 60		      case '\'':			if (*(cp + 1) != '\0')			  cp += 2;			else			  cp++;			break;E 60D 60			      default:				cp++;				break;			}E 60I 60		      default:			cp++;			break;E 60E 57		}D 57		*cp = '\0';I 40		if(confirmpath(fullpathname) == 0)			return(NIL);E 40I 35		SETJMP(NIL);I 46		/* There is no err in args, so we can not use ERRSETJMP */E 46E 35D 27		if( statfs(fullpathname, &buf) == 0){E 27I 27		TIMEOUT( rval=statfs(fullpathname, &buf) );		if( rval == 0){E 27			break;E 57I 57D 60		if (!extensionp) {			if (*(cp - 1) == '.') {				*(cp - 1) = '\'';				*cp++ = '.';			}E 60I 60	}	if (!extensionp) {		if (*(cp - 1) == '.') {			*(cp - 1) = '\'';E 60			*cp++ = '.';D 60			*cp = '\0';E 60E 57		}D 57	}	E 23	*buffixp = buf.f_bavail;E 13	return(ATOM_T);E 57I 57D 60		if (versionp && *ver != '\0') {			ConcNameAndVersion(fbuf, ver, namebuf);		} else {			strcpy(namebuf, fbuf);		}E 60I 60		*cp++ = '.';		*cp = '\0';	}	if (*ver != '\0') {		ConcNameAndVersion(fbuf, ver, namebuf);E 60	} else {D 60		if (*(dp - 1) == '.') {			/* Trail period should be quoted. */			*(dp - 1) = '\'';			*dp++ = '.';		}E 60		strcpy(namebuf, fbuf);	}D 60	if (versionp) UnixVersionToLispVersion(namebuf);E 60I 60	UnixVersionToLispVersion(namebuf, 1);E 60	strcpy(file, namebuf);I 60}I 62E 62/*		 * Name:	quote_fname_ufs * * Argument:	char	*file		The root file name in UNIX format.  "Root" *					file name contains the name, extenstion and *					version fields.  A valid version field is in a *					form as ".~##~". * * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	If succeed, file is replaced with the file name in Xerox Lisp format *		in which special characters are quoted. * * Description: * * Similar to quote_fname, but this routine is only used when file is a "FILE" name * and being converted to {UNIX} name. */quote_fname_ufs(file)	register char	*file;{	register char	*cp, *dp;	register int	extensionp;	char		fbuf[MAXNAMLEN + 1];		cp = file;	dp = fbuf;	while (*cp) {		switch (*cp) {		      case '>':		      case ';':		      case '\'':			*dp++ = '\'';			*dp++ = *cp++;			break;		      default:			*dp++ = *cp++;			break;		}	}	*dp = '\0';	/*	 * exntensionp indicates whether exentsion field is included in a file	 * name or not.  If extenstion field is not included, we have to add a	 * period to specify empty extension field.	 */	cp = fbuf;	extensionp = 0;	while (*cp && !extensionp) {		switch (*cp) {		      case '.':			if (*(cp + 1)) extensionp = 1;			cp++;			break;		      case '\'':			if (*(cp + 1) != '\0')			  cp += 2;			else			  cp++;			break;		      default:			cp++;			break;		}	}	if (!extensionp) {		if (*(cp - 1) == '.') {			*(cp - 1) = '\'';			*cp++ = '.';		}		*cp++ = '.';		*cp = '\0';	}	strcpy(file, fbuf);}I 62E 62/*		 * Name:	quote_dname * * Argument:	char	*dir		The directory name in UNIX format.  Does not *					include its parent name. * * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	If succeed, dir is replaced with the directory name in Xerox Lisp * 		format in which special characters are quoted. * * Description: * * Similar to quote_fname, but this routine is only used when dir is a "DIRECTORY" * name.  Both {DSK} and {UNIX} uses this routine. */quote_dname(dir)	register char	*dir;{	register char	*cp, *dp;	char		fbuf[MAXNAMLEN + 1];		cp = dir;	dp = fbuf;	while (*cp) {		switch (*cp) {		      case '>':		      case ';':		      case '\'':			*dp++ = '\'';			*dp++ = *cp++;			break;		      default:			*dp++ = *cp++;			break;		}	}	*dp = '\0';	if (*(dp - 1) == '.') {		/* Trail period should be quoted. */		*(dp - 1) = '\'';		*dp++ = '.';	}	strcpy(dir, fbuf);E 60E 57E 7}D 7E 7E 1