h05980s 00007/00007/00163d D 1.3 93/02/08 14:56:24 sybalsky 3 2c Big VM (and new CDR coding) changes for 3.0 \nes 00016/00007/00154d D 1.2 92/04/22 14:02:02 sybalsky 2 1c fix SCCS headeres 00161/00000/00000d D 1.1 92/04/21 15:29:05 sybalsky 1 0c date and time created 92/04/21 15:29:05 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";D 2/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Author	:	Hiroshi Hayata */E 2I 2/************************************************************************//*									*//*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************/E 2#include <stdio.h>#include "lispemul.h"#include "lspglob.h"#include "adr68k.h"#include "lispmap.h"#include "lsptypes.h"#include "emlglob.h"int mask_array[16] = {	1, 3, 7, 0xf,			0x1f, 0x3f, 0x7f, 0xff,			0x1ff, 0x3ff, 0x7ff, 0xfff,			0x1fff, 0x3fff, 0x7fff, 0xffff};/************************************************************ N_OP_putbitsnfd	entry		PUTBITS.N.FD		OPCODE[0317]	1.	<<Enter>>		TopOfStack: NewValue		*((int *)(CurrentStackPTR)):	 base address.		alpha:	word offset.		beta:		High nibble -- number of the first bit of the field				Low nibble  -- (number of the size of the fiel) - 1	2.	Data is @[TopOfStack + alpha]	3.	Shift and mask the data.	4.	Set the data at [TopOfStack + alpha].	5.	<<Exit>>		return:	??***********************************************************/LispPTR N_OP_putbitsnfd(base, data, word_offset, beta)register LispPTR base, data;	 int word_offset;register int beta;{register DLword	*pword;register int shift_size, field_size, fmask;#ifdef CHECKD 3	if (base > 0xFFFFFF) {error("getbits: base out of range");}E 3I 3	if (base > POINTERMASK) {error("getbits: base out of range");}E 3	if (beta > 0xFF) {error("bad beta argument to PUTBITS");}#endifD 3	if( (0xFFFF0000 & data ) != S_POSITIVE ) { ERROR_EXIT(data); };E 3I 3	if( (SEGMASK & data ) != S_POSITIVE ) { ERROR_EXIT(data); };E 3	pword = Addr68k_from_LADDR( base + word_offset );	field_size = 0xF & beta;	shift_size = 15 - (beta >> 4) - field_size;	fmask = mask_array[field_size] << shift_size;	GETWORD(pword) = ( (data << shift_size) & fmask)  |  (GETWORD(pword) & (~fmask));	return(base);}/************************************************************ N_OP_getbitsnfd	entry		GETBITS.N.FD		OPCODE[0312]	1.	<<Enter>>		TopOfStack: base address.		alpha:	word offset.		beta:	High nibble -- number of the first bit of the field			Low nibble  -- (number of the size of the fiel) - 1	2.	Data is @[TopOfStack + alpha]	3.	Shift and mask the data.	4.	<<Exit>>		return:		hi - S_POSITIVE				lo - mask & shifted data***********************************************************/LispPTR N_OP_getbitsnfd(base_addr, word_offset, beta)	int base_addr;	register int word_offset;	int beta;{register DLword	*pword;register short first;register short size;	pword = Addr68k_from_LADDR( base_addr + word_offset );	size = 0xF & beta;	first = beta >> 4;#ifdef CHECKD 3	if (base_addr > 0xFFFFFF) {error("getbits: base out of range");}E 3I 3	if (base_addr > POINTERMASK) {error("getbits: base out of range");}E 3	if (first+size > 15) {error("getbits beta too big");}#endif	return(S_POSITIVE |		( ( GETWORD(pword) >> (16 - (first + size + 1)) )			& mask_array[size] ) ) ;}/************************************************************ N_OP_putbasen	entry		PUTBASE.N		OPCODE[0315]	1.	<<Enter>>		TopOfStack:	Low Word - replace data		*(CurrentStackPTR): base address.		alpha: offset.	2.	if high word of TopOFStack is not SMALLPL,		then call ufn2incS,		else replace (base address + offset) with data.	3.	increment PC by 2.	4.	<<Exit>>		return:	base address.		(Called only by Native code)***********************************************************/LispPTR N_OP_putbasen(base, tos, n)	register LispPTR base, tos;	int n;{D 3	base = 0xFFFFFF & base;	if( (0xFFFF0000 & tos ) != S_POSITIVE ) {ERROR_EXIT(tos);}E 3I 3	base = POINTERMASK & base;	if( (SEGMASK & tos ) != S_POSITIVE ) {ERROR_EXIT(tos);}E 3	else{		GETWORD((DLword *) Addr68k_from_LADDR( base + n )) = GetLoWord(tos);		return(base);	}}/************************************************************ N_OP_putbaseptrn	entry		PUTBASEPTR.N		OPCODE[0316]	1.	<<Enter>>		TopOfStack:	replace data (2 words)		*(CurrentStackPTR): base address.		alpha: offset.	2.	replace (base address + offset) with data.	3.	save base address to TopOfStack	3.	increment PC by 2.	4.	<<Exit>>		return:	base address.		(Called only by Native code)***********************************************************/LispPTR N_OP_putbaseptrn(base, tos, n)	register LispPTR base, tos;	int n;{D 3	base = 0xFFFFFF & base;	*((LispPTR *) Addr68k_from_LADDR( base + n )) = tos & 0xffffff;E 3I 3	base = POINTERMASK & base;	*((LispPTR *) Addr68k_from_LADDR( base + n )) = tos & POINTERMASK;E 3	return(base);}E 1