h48566s 00000/00000/00127d D 2.9 90/04/20 01:49:49 sybalsky 14 13c AIX:  shortening file names, bulk change.es 00000/00004/00127d D 2.8 90/03/05 18:57:50 takeshi 13 12c delete  unused vares 00002/00002/00129d D 2.7 89/03/27 22:36:37 sybalsky 12 11c Changed word-ptr refs to use GETWORDes 00020/00023/00111d D 2.6 88/10/14 19:17:21 shih 11 10c putbasebyte ufn returns wrong result.  cleanupes 00009/00197/00125d D 2.5 88/10/12 14:44:39 krivacic 10 9c new out-of-line interfacees 00009/00018/00313d D 2.4 88/08/01 15:19:56 shih 9 8c removed fixp displacement from putbasebyte cuz should error.es 00001/00002/00330d D 2.3 88/06/23 18:41:15 shih 8 7c Putbasebyte didn't return the byte (so didnt get pushed on stack)es 00004/00000/00328d D 2.2 88/05/27 14:58:20 krivacic 7 6c C_ONLY ifdefes 00000/00000/00328d D 2.1 88/05/17 09:26:02 hayata 6 5c Version up to 2.1es 00001/00001/00327d D 1.5 88/04/27 13:39:47 krivacic 5 4c fix N_OP_putbasebyte argument errores 00002/00002/00326d D 1.4 88/04/06 19:17:50 krivacic 4 3c fix addbase errores 00141/00000/00187d D 1.3 88/03/31 10:07:57 krivacic 3 2c N interfaces es 00002/00002/00185d D 1.2 88/03/13 14:54:41 hayata 2 1c Add SCCS key id (%Z%)es 00187/00000/00000d D 1.1 88/02/24 16:58:03 hayata 1 0c date and time created 88/02/24 16:58:03 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 2/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 11 *	Auther	:	Hiroshi Hayata	E 11I 11 *	Author	:	Hiroshi HayataE 11 */#include <stdio.h>#include "lispemul.h"#include "lispglobal.h"#include "address68k.h"#include "lispmap.h"#include "lisptypes.h"#include "emulglobal.h"I 11/*** NOTE: these routines likely not called (see inlinedefsC.h) ***/E 11I 7D 10#ifdef C_ONLYE 10E 7/************************************************************D 10 OP_addbase	entry		ADDBASE		OPCODE[0320]	1. 	<<Enter>>		TopOfStack: offset		*(CurrentStackPTR): base address	2.	if High word of TopOfStack is SMALLPL or SMALLNEG,		then add base address and offset and set the result to TopOfStack.		else call ufn2incs.	3.	increment PC.	4.	<<Exit>>		TopOfStack: new address***********************************************************/OP_addbase(){register int	base;	/* base address */#ifdef	TRACE	printPC();	printf("TRACE: OP_addbase()\n");#endif/*CSP	base = 0xFFFFFF & *((int *)(--CurrentStackPTR));	*/	base = 0xFFFFFF & *((int *)(CurrentStackPTR));	switch( (0xFFFF0000 & TopOfStack) ){	case S_POSITIVE:		TopOfStack = base + (TopOfStack & 0x0000FFFF);		break;	case S_NEGATIVE:		TopOfStack = base + (TopOfStack | 0xFFFF0000);		break;	default:		switch( (GetTypeNumber(TopOfStack)) ){		case TYPE_FIXP:			/* overflow or underflow isn't check */ D 4			TopOfStack = base + *(short*)Addr68k_from_LADDR(TopOfStack);E 4I 4			TopOfStack = base + *(int *)Addr68k_from_LADDR(TopOfStack);E 4			break;		case TYPE_FLOATP:			/* Fixp.From.Floatp not implemented */			/* TopOfStack				 = base + ((int) *Addr68k_from_LADDR(TopOfStack)); */			error("FLOATP not implemented!");			break;		default:			error("NON-NUMERIC ARG!");			break;		}/* end switch */		break;	}/* end switch *//*CSP	--CurrentStackPTR;	*/	CurrentStackPTR-=2;	++PC;}/************************************************************ OP_getbasebyte	entry		GETBASEBYTE		OPCODE[0302]	1.	<<Enter>>		*(--CuurentStackPTR): base address.		TopOfStack: 	Low word - byte offset.	2.	if high word of TopOfStack is not SMALLPL,		then	call ufn2incS.		else	fetch 8 bits word at (base address + byte offset).	3.	increment PC by 1.	4.	<<Exit>>		TopOfStack: 	Least Low Byte - fetched data***********************************************************/OP_getbasebyte(){register LispPTR	base_addr;	/* base address, Lisp address */register int		byteoffset;	/* byte offset for fetched data. */register char *ptr;#ifdef	TRACE	printPC();	printf("TRACE: OP_getbasebyte()\n");#endif/*CSP	base_addr = *((LispPTR *)(--CurrentStackPTR));	*/	base_addr = *((LispPTR *)(CurrentStackPTR));	switch( (0xFFFF0000 & TopOfStack) ){	case S_POSITIVE:		byteoffset =  TopOfStack & 0x0000FFFF;		break;	case S_NEGATIVE:		byteoffset = TopOfStack | 0xFFFF0000;		break;	default:		switch( (GetTypeNumber(TopOfStack)) ){		case TYPE_FIXP:			byteoffset = *((int *)Addr68k_from_LADDR(TopOfStack));			break;		case TYPE_FLOATP:			/* Fixp.From.Floatp not implemented */			/* byteoffset = *Addr68k_from_LADDR((int)TopOfStack); */			error("FLOATP offset is not implemented!");			break;		default:			error("NON-NUMERIC ARG!");			break;			}/* end switch */		break;	}/* end switch */	TopOfStack = (0xFF & (*((char*)Addr68k_from_LADDR((0xFFFFFF & base_addr)) + byteoffset))) | S_POSITIVE;/*CSP	--CurrentStackPTR;	*/	CurrentStackPTR -= 2;	++PC;}/************************************************************ OP_putbasebyte	entry		PUTBASEBYTE		OPCODE[0307]	1.	<<Enter>>D 9		*((int *)(CuurentStackPTR-1)): base address.		*((int *)(CuurentStackPTR-3)): byte offset.E 9		TopOfStack: 	Least Low Byte - replace data.D 9	2.		3.	increment PC by 1.	4.	<<Exit>>E 9I 9		*((int *)(CurrentStackPTR-1)): byte offset.		*((int *)(CurrentStackPTR-2)): base address.	2.	increment PC by 1.	3.	<<Exit>>E 9		TopOfStack: 	Least Low Byte - replace data ?***********************************************************/OP_putbasebyte(){register LispPTR	base_addr;	/* base address, Lisp address */register int	byteoffset;	/* byte offset from base_addr */register char *ptr;#ifdef	TRACE	printPC();	printf("TRACE: OP_putbasebyte()\n");#endif/*CSP	byteoffset = *((int *)(CurrentStackPTR - 1));	base_addr = *((LispPTR *)((CurrentStackPTR - 3)));	*/	byteoffset = *((LispPTR *)(CurrentStackPTR));	base_addr = *((LispPTR *)((CurrentStackPTR - 2)));		if( ((0xFFFF0000 & TopOfStack ) != S_POSITIVE) || ((unsigned short)TopOfStack >= 256) )		error("ILLEGAL ARG!");	switch( (0xFFFF0000 & byteoffset) ){	case S_POSITIVE:		byteoffset &=  0x0000FFFF;		break;	case S_NEGATIVE:		byteoffset |=  0xFFFF0000;		break;	default:		switch( (GetTypeNumber(byteoffset)) ){		case TYPE_FIXP:			byteoffset = *((int *)Addr68k_from_LADDR(byteoffset));			break;		case TYPE_FLOATP:			/* Fixp.From.Floatp not implemented */			/* byteoffset = *Addr68k_from_LADDR((int)byteoffset); */			error("FLOATP offset is not implemented!");			break;		default:			error("NON-NUMERIC ARG!");			break;			}/* end switch */		break;	}/* end switch */	*(((char*)Addr68k_from_LADDR(0xFFFFFF & base_addr)) + byteoffset) = 0xFF & TopOfStack;  	CurrentStackPTR -= 4;	++PC;D 8E 8}I 3I 7#elseE 7/************************************************************E 10 N_OP_addbase	entry		ADDBASE		OPCODE[0320]D 11	1. 	<<Enter>>E 11I 11	1.	<<Enter>>E 11		TopOfStack: offset		*(CurrentStackPTR): base address	2.	if High word of TopOfStack is SMALLPL or SMALLNEG,D 11		then add base address and offset and set the result to TopOfStack.E 11I 11		then add base address and offset and set result to TopOfStack.E 11		else call ufn2incs.	4.	<<Exit>>		return: new address***********************************************************/D 10LispPTR N_OP_addbase(base, offset, error_addr)E 10I 10LispPTR N_OP_addbase(base, offset)E 10	register int base, offset;D 10	int *error_addr;E 10{D 10#ifdef	TRACE	printf("TRACE: N_OP_addbase()\n");#endifE 10	base = 0xFFFFFF & base;	switch( (0xFFFF0000 & offset) ){	case S_POSITIVE:		return(base + (offset & 0x0000FFFF));	case S_NEGATIVE:		return(base + (offset | 0xFFFF0000));	default:		switch( (GetTypeNumber(offset)) ){		case TYPE_FIXP:D 11			/* overflow or underflow isn't check */ E 11I 11			/* overflow or underflow isn't check */E 11D 4			return(base + *(short*)Addr68k_from_LADDR(offset));E 4I 4			return(base + *(int *)Addr68k_from_LADDR(offset));E 4D 11		case TYPE_FLOATP:E 11I 11		default:	/* floatp also */E 11D 10			ERROR_EXIT(error_addr);E 10I 10			ERROR_EXIT(offset);E 10D 11		default:D 10			ERROR_EXIT(error_addr);E 10I 10			ERROR_EXIT(offset);E 11E 10		}/* end switch */	}/* end switch */}/************************************************************ N_OP_getbasebyte	entry		GETBASEBYTE		OPCODE[0302]	1.	<<Enter>>D 9		*(--CuurentStackPTR): base address.E 9I 9		*(--CurrentStackPTR): base address.E 9D 11		TopOfStack: 	Low word - byte offset.E 11I 11		TopOfStack:	Low word - byte offset.E 11	2.	if high word of TopOfStack is not SMALLPL,		then	call ufn2incS.		else	fetch 8 bits word at (base address + byte offset).	4.	<<Exit>>D 11		return: 	Least Low Byte - fetched dataE 11I 11		return:		Least Low Byte - fetched dataE 11***********************************************************/D 10N_OP_getbasebyte(base_addr, byteoffset, error_addr)E 10I 10N_OP_getbasebyte(base_addr, byteoffset)E 10	register LispPTR base_addr;	register int byteoffset;D 10	int *error_addr;E 10D 11E 11{D 13register char *ptr;E 13D 10#ifdef	TRACE	printf("TRACE: N_OP_getbasebyte()\n");#endifE 10	switch( (0xFFFF0000 & byteoffset) ){	case S_POSITIVE:		byteoffset =  byteoffset & 0x0000FFFF;		break;	case S_NEGATIVE:		byteoffset = byteoffset | 0xFFFF0000;		break;	default:		switch( (GetTypeNumber(byteoffset)) ){		case TYPE_FIXP:			byteoffset = *((int *)Addr68k_from_LADDR(byteoffset));			break;D 11		case TYPE_FLOATP:E 11I 11		default:	/* floatp also fall thru */E 11D 10			ERROR_EXIT(error_addr);E 10I 10			ERROR_EXIT(byteoffset);E 10D 11		default:D 10			ERROR_EXIT(error_addr);E 10I 10			ERROR_EXIT(byteoffset);E 11E 10			}/* end switch */		break;	}/* end switch */D 12	return((0xFF & (*((char*)Addr68k_from_LADDR((0xFFFFFF & base_addr)) + byteoffset))) | S_POSITIVE);E 12I 12	return((0xFF & (GETBYTE((char*)Addr68k_from_LADDR((0xFFFFFF & base_addr)) + byteoffset))) | S_POSITIVE);E 12}/************************************************************ N_OP_putbasebyte	entry		PUTBASEBYTE		OPCODE[0307]	1.	<<Enter>>D 9		*((int *)(CuurentStackPTR-1)): base address.		*((int *)(CuurentStackPTR-3)): byte offset.E 9D 11		TopOfStack: 	Least Low Byte - replace data.E 11I 11		TopOfStack:	Least Low Byte - replace data.E 11I 9		*((int *)(CurrentStackPTR-1)): byte offset.		*((int *)(CurrentStackPTR-2)): base address.E 9	4.	<<Exit>>D 11		return: 	Least Low Byte - replace data ?E 11I 11		return:		Least Low Byte - replace data ?E 11***********************************************************/D 5N_OP_putbasebyte(byteoffset, base_addr, data, error_addr)E 5I 5D 10N_OP_putbasebyte(base_addr, byteoffset, data, error_addr)E 10I 10D 11N_OP_putbasebyte(base_addr, byteoffset, data)E 10E 5	register int byteoffset;E 11I 11N_OP_putbasebyte(base_addr, byteoffset, tos)E 11	register LispPTR base_addr;D 11	register int data;E 11I 11	register int byteoffset;	register int tos;E 11D 10	int *error_addr;E 10{D 13register char *ptr;E 13D 10#ifdef	TRACE	printf("TRACE: N_OP_putbasebyte()\n");#endifE 10D 11	if(((0xFFFF0000 & data ) != S_POSITIVE) || ((unsigned short)data >= 256))D 10		ERROR_EXIT(error_addr);E 10I 10		ERROR_EXIT(byteoffset);E 11I 11	if(((0xFFFF0000 & tos ) != S_POSITIVE) || ((unsigned short)tos >= 256))		ERROR_EXIT(tos);E 11E 10	switch( (0xFFFF0000 & byteoffset) ){	case S_POSITIVE:		byteoffset &=  0x0000FFFF;		break;	case S_NEGATIVE:		byteoffset |=  0xFFFF0000;		break;	default:D 9		switch( (GetTypeNumber(byteoffset)) ){		case TYPE_FIXP:			byteoffset = *((int *)Addr68k_from_LADDR(byteoffset));			break;		case TYPE_FLOATP:			ERROR_EXIT(error_addr);		default:			ERROR_EXIT(error_addr);			}/* end switch */		break;E 9I 9	/* ucode and ufn don't handle displacement not smallp */D 10		ERROR_EXIT(error_addr);E 10I 10D 11		ERROR_EXIT(byteoffset);E 11I 11		ERROR_EXIT(tos);E 11E 10E 9	}/* end switch */D 11	*(((char*)Addr68k_from_LADDR(0xFFFFFF & base_addr)) + byteoffset) = 0xFF & data;  D 8E 8I 8	return ( data );E 11I 11D 12	*(((char*)Addr68k_from_LADDR(0xFFFFFF & base_addr)) + byteoffset) = 0xFF & tos;E 12I 12	GETBYTE(((char*)Addr68k_from_LADDR(0xFFFFFF & base_addr)) + byteoffset) = 0xFF & tos;E 12	return ( tos );E 11E 8}I 7D 10#endifE 10E 7E 3E 1