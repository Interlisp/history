h03283s 00004/00004/00060d D 2.12 92/04/21 17:02:07 sybalsky 15 14c shortening file names for DOS \nes 00000/00000/00064d D 2.11 90/04/20 01:18:28 sybalsky 14 13c change.es 00001/00000/00063d D 2.10 90/02/19 11:05:52 sybalsky 13 12c 386i check; add commentses 00020/00012/00043d D 2.9 90/02/19 09:31:56 sybalsky 12 11c commants, code reformatting.es 00002/00002/00053d D 2.8 88/12/23 13:57:11 shih 11 10c wrong sccs ides 00006/00006/00049d D 2.7 88/10/12 14:39:27 krivacic 10 9c new out-of-line interfacees 00003/00048/00052d D 2.6 88/07/06 14:38:59 charnley 9 8c uses new select macro with modified select order.es 00008/00008/00092d D 2.5 88/06/07 15:38:46 charnley 8 7c using new macro GetPoses 00001/00001/00099d D 2.4 88/05/25 16:56:44 charnley 7 6c changed err type.es 00001/00002/00099d D 2.3 88/05/25 16:19:03 charnley 6 5c fixed signed 32 bit problem.es 00007/00119/00094d D 2.2 88/05/25 14:47:50 charnley 5 4c removed unused code, fixed bug in signed 32 bit casees 00000/00000/00213d D 2.1 88/05/17 09:21:50 hayata 4 3c Version up to 2.1es 00000/00001/00213d D 1.3 88/04/21 09:34:08 charnley 3 2c changed array-type mask, was ufning when shouldn'tes 00000/00006/00214d D 1.2 88/04/06 23:38:55 masinter 2 1c  Remove spurious #include lineses 00220/00000/00000d D 1.1 88/03/30 14:04:57 charnley 1 0c date and time created 88/03/30 14:04:57 by charnleyeuUtTI 1D 5/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 5I 5D 11/* This is G-file @(#) array.c Version 1.3 (4/21/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) array.c	1.3 4/21/88";E 11I 11D 12/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 11E 5/*	array.c */E 12I 12/* @(#) array.c Version 2.8 (12/23/88). copyright envos & Fuji Xerox  */static char *id = "@(#) array.c	2.8 12/23/88		(envos & Fuji Xerox)";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 12#include <stdio.h>#include "lispemul.h"D 15#include "lispglobal.h"#include "address68k.h"E 15I 15#include "lspglob.h"#include "adr68k.h"E 15#include "lispmap.h"D 15#include "lisptypes.h"#include "emulglobal.h"E 15I 15#include "lsptypes.h"#include "emlglob.h"E 15#include "arith.h"#include "my.h"D 2#include "tos1defs.h" #include "tosretmacro.h"#include "tosfuncallmacro.h"#include "inlinedefsC.h"#include "inlinedefs68K.h" #include "fastinlinedefs68K.h"E 2D 3E 3/************************************************************ OP_claref  -- op 372/9 (base typenumber index)D 5	typenumber:		type = 7 & (typenumber >> 4)		0  unsigned		1  signed		2  pointer		3  float		4  character		5  xpointer		6  illegal		7  illegal		size = 7 & typenumber		0 1 bit   :		1 2 bits  :		2 4 bits  :		3 8 bits  :		4 16 bits : 		5 24 bits :		6 32 bits :		7 64 bits :	E 5type    size    typenumber  0       0             0      unsigned  : 1 bit  0       3             3      unsigned  : 8 bits  0       4             4      unsigned  : 16 bits  1       4            20      signed    : 16 bits  1       6            22      signed    : 32 bits  2       6            38      pointer   : 32 bits  3       6            54      float     : 32 bits  4       3            67      character : 8 bits  4       4            68      character : 16 bits  5       6            86      Xpointer  : 32 bits***********************************************************/D 5/***	OP_mymisc3  -- op 372/9 (base typenumber index)   ***/OP_mymisc3(){register short alpha;register LispPTR baseL;register short typenumber;register short index;LispPTR temp;	/*	for CREATECELL  */register DLword	*wordp;DLword	*createcell68k();#ifdef	TRACE	printPC();	printf("TRACE: OP_misc3()\n");#endif   alpha = 0xFF & *(PC+1);   if (alpha != 9) gotoufn;    /*  test and setup index  */    if( (0xFF0000 & TopOfStack) != S_POSITIVE) gotoufn;    index = 0xFFFF & TopOfStack;    /*  test and setup typenumber  */    temp = *((LispPTR *)(CurrentStackPTR));    if( (0xFF0000 & temp) != S_POSITIVE) gotoufn;    typenumber = 0xFF & temp;    /*  setup base  */    baseL = *((LispPTR *)(CurrentStackPTR - 2));    /*  disp on type  */    switch (typenumber) {      case 0: /* unsigned : 1 bit per element */         TopOfStack = ((*(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1;         TopOfStack |= S_POSITIVE;         break;      case 3: /* unsigned : 8 bits per element */         TopOfStack = (*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF;         TopOfStack |= S_POSITIVE;         break;      case 4: /* unsigned : 16 bits per element */         TopOfStack = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;         TopOfStack |= S_POSITIVE;         break;      case 20: /* signed : 16 bits */         TopOfStack = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;         if (TopOfStack & 0x8000) TopOfStack |= S_NEGATIVE;         else TopOfStack |= S_POSITIVE;         break;      case 22: /* signed : 32 bits */         wordp = createcell68k(TYPE_FIXP);         *((int *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);         TopOfStack = LADDR_from_68k(wordp);         break;      case 38: /* pointer : 32 bits */         TopOfStack = *(((int *)Addr68k_from_LADDR(baseL)) + index);         break;      case 54: /* Float : 32 bits */         wordp = createcell68k(TYPE_FLOATP);         *((float *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);         TopOfStack = LADDR_from_68k(wordp);         break;      case 67: /* Character :  8 bits */         TopOfStack = (*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF;         TopOfStack |= S_CHARACTER;         break;      case 68: /* Character :  16 bits */         TopOfStack = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;         TopOfStack |= S_CHARACTER;	   break;      case 86: /* XPointer : 32 bits */         TopOfStack = *(((int *)Addr68k_from_LADDR(baseL)) + index);         break;      default: /* Illegal or Unimplemented */        gotoufn;    }/* end switch typenumber */    CurrentStackPTR -= 4;    PC += 2;} /*  end OP_claref()  */E 5/***	N_OP_misc3  -- op 372/9 (base typenumber index)   ***/D 8N_OP_misc3(baseL, typenumber, index, alpha, error_addr)D 5int baseL, typenumber, index, alpha, *error_addr;E 5I 5D 7int baseL, typenumber, index, alpha, error_addr;E 7I 7int baseL, typenumber, index, alpha, *error_addr;E 8I 8D 10N_OP_misc3(baseL, typenumber, inx, alpha, error_addr)int alpha, *error_addr;E 10I 10N_OP_misc3(baseL, typenumber, inx, alpha)D 12int alpha;E 10LispPTR baseL, typenumber, inx;E 8E 7E 5{register int result;I 5D 9register int data;E 9I 8register int index, type;E 12I 12  int alpha;  LispPTR baseL, typenumber, inx;  {    register int result;    register int index, type;I 13    register DLword *wordp;E 13E 12E 8E 5	/*	for CREATECELL  */D 12register DLword	*wordp;DLword	*createcell68k();E 12I 12    DLword	*createcell68k();E 12D 9#ifdef	TRACE	printPC();	printf("TRACE: N_OP_misc3()\n");#endif   if (alpha != 9) ERROR_EXIT(error_addr);E 9I 9D 10    if (alpha != 9) ERROR_EXIT(error_addr);E 10I 10    if (alpha != 9) ERROR_EXIT(inx);E 10E 9    /*  test and setup index  */D 8    if( (0xFF0000 & index) != S_POSITIVE) ERROR_EXIT(error_addr);    index = 0xFFFF & index;E 8I 8D 10    N_GetPos(inx, index, error_addr);E 10I 10    N_GetPos(inx, index, inx);E 10E 8    /*  test and setup typenumber  */D 8    if( (0xFF0000 & typenumber) != S_POSITIVE) ERROR_EXIT(error_addr);    typenumber = 0xFF & typenumber;E 8I 8D 10    N_GetPos(typenumber, type, error_addr);E 10I 10    N_GetPos(typenumber, type, inx);E 10E 8    /*  disp on type  */D 8    switch (typenumber) {E 8I 8D 9    switch (type) {E 8      case 0: /* unsigned : 1 bit per element */         return(S_POSITIVE | (((*(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1));         break;      case 3: /* unsigned : 8 bits per element */         return(S_POSITIVE | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF));         break;      case 4: /* unsigned : 16 bits per element */         return(S_POSITIVE | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF));         break;      case 20: /* signed : 16 bits */         result = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;         if (result & 0x8000) return(result | S_NEGATIVE);         else return(result | S_POSITIVE);         break;      case 22: /* signed : 32 bits */D 5         result = *(((int *)Addr68k_from_LADDR(baseL)) + index);         N_ARITH_SWITCH(result);E 5I 5         data = *(((int *)Addr68k_from_LADDR(baseL)) + index);D 6         N_ARITH_SWITCH(data, result);         return(result);E 6I 6         N_ARITH_SWITCH(data);E 6E 5         break;      case 38: /* pointer : 32 bits */         return(*(((int *)Addr68k_from_LADDR(baseL)) + index));         break;      case 54: /* Float : 32 bits */         wordp = createcell68k(TYPE_FLOATP);         *((int *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);         return(LADDR_from_68k(wordp));         break;      case 67: /* Character :  8 bits */         return(S_CHARACTER | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF));         break;      case 68: /* Character :  16 bits */         return(S_CHARACTER | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF));	   break;      case 86: /* XPointer : 32 bits */         return(*(((int *)Addr68k_from_LADDR(baseL)) + index));         break;      default: /* Illegal or Unimplemented */D 8        ERROR_EXIT(error_addr);E 8I 8         ERROR_EXIT(error_addr);E 8    }/* end switch typenumber */} /*  end N_OP_misc3()  */E 9I 9D 10    aref_switch(type, error_addr);E 10I 10    aref_switch(type, inx);E 10E 9D 9	/*  end module  */E 9I 9D 12} /*  end N_OP_misc3()  */E 12I 12  } /*  end N_OP_misc3()  */E 12E 9E 1