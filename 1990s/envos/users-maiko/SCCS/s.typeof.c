h54643s 00009/00001/00094d D 2.14 93/02/08 14:59:42 sybalsky 17 16c Big VM (and new CDR coding) changes for 3.0 \nes 00002/00002/00093d D 2.13 92/04/21 17:26:25 sybalsky 16 15c shortening file names for DOS \nes 00044/00024/00051d D 2.12 90/07/04 04:05:19 sybalsky 15 14c DTD change -- 24 bit type name in INSTANCEP opcode (& DTEST, tho' that's opencoded)es 00015/00001/00060d D 2.11 90/06/04 18:09:14 sybalsky 14 13c reformat, copyrightes 00000/00000/00061d D 2.10 90/04/20 01:59:13 sybalsky 13 12c AIX:  shortening file names, bulk change.es 00002/00002/00059d D 2.9 89/01/09 17:18:15 shih 12 11c spellinges 00002/00003/00059d D 2.8 88/10/12 14:45:17 krivacic 11 10c new out-of-line interfacees 00000/00000/00062d D 2.7 88/10/10 14:10:24 krivacic 10 9c sun3/4 mergees 00001/00000/00061d D 2.6 88/09/27 19:46:28 shih 9 8c added lispglobal.hes 00000/00016/00061d D 2.5 88/09/27 16:39:45 shih 8 7c removed unneeded extern declarations, removed TRACEs (for now)es 00000/00035/00077d D 2.4 88/09/27 15:39:14 shih 7 6c removed C_ONLY dead codees 00001/00001/00111d D 2.3 88/05/27 14:59:13 krivacic 6 5c N_OP_instancepes 00005/00121/00107d D 2.2 88/05/25 17:49:42 krivacic 5 4c removed un-referenced obsolete fnses 00000/00000/00228d D 2.1 88/05/17 09:27:16 hayata 4 3c Version up to 2.1es 00050/00000/00178d D 1.3 88/03/31 12:47:20 krivacic 3 2c new interfacees 00002/00002/00176d D 1.2 88/03/13 15:08:38 hayata 2 1c Add SCCS key id (%Z%)es 00178/00000/00000d D 1.1 88/02/24 16:58:49 hayata 1 0c date and time created 88/02/24 16:58:49 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 12I 12D 14/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 14I 14/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 14E 12static char *id = "%Z% %M%	%I% %G%";E 2/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	File   : typeof.cD 12 *	Auther :  Takeshi ShimizuE 12I 12 *	Author :  Takeshi ShimizuE 12	** ADOPTED NEW VERSION * */I 14/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 14/****************************************************************//* LISTP(3Q),NTYPEX(4Q),TYPEP(5Q),DTEST(6Q) ,INSTANCEP(303Q)    *//****************************************************************//*				changed : Jan. 13 1987 take				changed : Feb. 05 1987 take				changed : Jul. 24 1987 take*/#include "lispemul.h"D 16#include "lisptypes.h"E 16I 16#include "lsptypes.h"E 16#include "cell.h"#include "lispmap.h"I 9D 16#include "lispglobal.h"E 16I 16#include "lspglob.h"E 16E 9I 15/************************************************************************//*									*//*			N _ O P _ d t e s t				*//*									*//*	Check for type conformity, else error.				*//*									*//************************************************************************/E 15D 8extern DLword *Atomspace;D 5E 5extern int TopOfStack;extern DLword *CurrentStackPTR ;extern ByteCode *PC ;extern DLword  *MDStypetbl;extern DLword  *Spospspace;D 5 /* extern DLword Spos_seg ; Feb 05 */ /* has spospspace's seg. LISP address */E 5extern DLword *DTDspace ;E 8D 5/* Changed : Lisp ptr changes from byte ptr to word ptr *//* argument address should be word offset ptr *//*  following defs were moved to lisptypes.h #define GetTypeEntry(address)       *(MDStypetbl + ((address & 0x0ffff00)>>9))#define GetTypeNumber(address)     ((*(MDStypetbl +((address & 0x0ffff00)>>9))) & 0xff)*/E 5D 7D 5OP_listp(){#ifdef TRACE	printPC();	printf("TRACE: OP_listp()\n");#endifE 5I 5#ifdef C_ONLYE 5D 5  if( (unsigned int)GetTypeNumber(TopOfStack) != TYPE_LISTP)     TopOfStack = (LispPTR)NIL_PTR;        PC++ ;}OP_ntypex(){#ifdef TRACE	printPC();	printf("TRACE: OP_ntypex()\n");#endif  TopOfStack = (LispPTR)(S_POSITIVE | (unsigned int)(GetTypeNumber(TopOfStack)));  PC++;  /* Changed Feb 5 */}OP_typep(){#ifdef TRACE	printPC();	printf("TRACE: OP_typep()\n");#endif  /* This OPcode takes 1 argument that contains type number */  if((DLword)GetTypeNumber(TopOfStack) != *(++PC))     TopOfStack =NIL_PTR ;  PC++;}OP_typemask(){#ifdef TRACE	printPC();	printf("TRACE: OP_typemask()\n");#endif  /* This OPcode takes 1 argument that contains type number */    if(( ((DLword)GetTypeEntry(TopOfStack))  & ((DLword)(Get_BYTE(PC+1)) << 8)) == 0)    TopOfStack = NIL_PTR;  PC+=2 ;  }E 5OP_dtest(){ /* This OPcode takes 2 arguments that is atom index. */D 5/** register unsigned int type ;**/E 5 register unsigned int scratch; register struct dtd *dtd68k ;#ifdef TRACE	printPC();	printf("TRACE: OP_dtest()\n");#endif   scratch = (Get_BYTE(PC+1) << 8 )| (Get_BYTE(PC+2)); D 5/**** for( type = (DLword)GetTypeNumber(TopOfStack);	scratch != (dtd68k=(struct dtd *)GetDTD(type))->dtd_name ;	type = dtd68k->dtd_supertype )	{		if(type == 0) {			ufn(06);			return ; }	}  *****/E 5 for(dtd68k=(struct dtd *) GetDTD(GetTypeNumber(TopOfStack));	scratch != dtd68k->dtd_name ;	dtd68k=(struct dtd *) GetDTD(dtd68k->dtd_supertype))	{		if( dtd68k->dtd_supertype == 0) {			ufn(06);			return ; }	} PC += 3;} /* OP_DTEST END */I 5#elseE 5E 7D 5OP_instancep(){ /* This OPcode takes 2 arguments that is atom index. */ register unsigned int type ; register unsigned int scratch; register struct dtd *dtd68k ;#ifdef TRACE	printPC();	printf("TRACE: OP_instancep()\n");#endif scratch =( Get_BYTE(PC+1) << 8 ) | (Get_BYTE(PC+2));/***for( type = (DLword)GetTypeNumber(TopOfStack);	scratch != (dtd68k=(struct dtd *)GetDTD(type))->dtd_name ;	type = dtd68k->dtd_supertype )	{		if(type == 0) {			TopOfStack = NIL;			PC += 3;			return ; }	} **/for(  dtd68k=(struct dtd *)GetDTD(GetTypeNumber(TopOfStack));	scratch != dtd68k->dtd_name ;	dtd68k=(struct dtd *)GetDTD(dtd68k->dtd_supertype) )	{		if( dtd68k->dtd_supertype== 0) {			TopOfStack = NIL;			PC += 3;			return ; }	} TopOfStack = ATOM_T ; PC += 3; } /* OP_instancep END */I 3/* ********************************************************************** */E 5D 11LispPTR N_OP_dtest(tos, atom_index, error_addr)E 11I 11LispPTR N_OP_dtest(tos, atom_index)E 11D 15	register LispPTR tos;	register int atom_index;D 11	int *error_addr;E 11{ register struct dtd *dtd68k ;E 15I 15  register LispPTR tos;  register int atom_index;  {    register struct dtd *dtd68k ;E 15D 8#ifdef TRACE	printf("TRACE: N_OP_dtest()\n");#endifD 7  E 7 E 8D 15 for(dtd68k=(struct dtd *) GetDTD(GetTypeNumber(tos));	atom_index != dtd68k->dtd_name ;E 15I 15    for(dtd68k=(struct dtd *) GetDTD(GetTypeNumber(tos));I 17#ifdef BIGVM	atom_index != dtd68k->dtd_name;#elseE 17	atom_index != dtd68k->dtd_namelo+(dtd68k->dtd_namehi<<16) ;I 17#endif /* BIGVM */E 17E 15	dtd68k=(struct dtd *) GetDTD(dtd68k->dtd_supertype))D 15	{D 11		if( dtd68k->dtd_supertype == 0) ERROR_EXIT(error_addr);E 11I 11		if( dtd68k->dtd_supertype == 0) ERROR_EXIT(tos);E 11	} return(tos);} /* OP_DTEST END */E 15I 15      {	if( dtd68k->dtd_supertype == 0) ERROR_EXIT(tos);      }    return(tos);  } /* OP_DTEST END */E 15I 5D 7#endifE 7E 5I 15/************************************************************************//*									*//*			N _ O P _ i n s t a n c e p			*//*									*//*	Returns T if tos has type named by atom_index, else NIL.	*//*									*//************************************************************************/E 15LispPTR N_OP_instancep(tos, atom_index)D 15	register LispPTR tos;	register int atom_index;{ register unsigned int type ; register struct dtd *dtd68k ;E 15I 15  register LispPTR tos;  register int atom_index;  {    register unsigned int type ;    register struct dtd *dtd68k ;E 15D 8#ifdef TRACE	printf("TRACE: N_OP_instancep()\n");#endifE 8D 7E 7D 15for(  dtd68k=(struct dtd *)GetDTD(GetTypeNumber(tos));	atom_index != dtd68k->dtd_name ;	dtd68k=(struct dtd *)GetDTD(dtd68k->dtd_supertype) )	{		if( dtd68k->dtd_supertype== 0) { return(NIL_PTR); }	} return(ATOM_T);E 15I 15    for(  dtd68k=(struct dtd *)GetDTD(GetTypeNumber(tos));D 17	  atom_index != dtd68k->dtd_namelo +(dtd68k->dtd_namehi<<16) ;E 17I 17#ifdef BIGVM	atom_index != dtd68k->dtd_name;#else	atom_index != dtd68k->dtd_namelo+(dtd68k->dtd_namehi<<16) ;#endif /* BIGVM */E 17	  dtd68k=(struct dtd *)GetDTD(dtd68k->dtd_supertype) )      {	if( dtd68k->dtd_supertype== 0) { return(NIL_PTR); }      }    return(ATOM_T);E 15D 6} /* OP_instancep END */E 6I 6D 15} /* N_OP_instancep END */E 15I 15  } /* N_OP_instancep END */E 15E 6I 5D 7E 7E 5E 3E 1