h38723s 00000/00000/00837d D 1.12 92/04/21 16:22:25 sybalsky 12 11c shortening file names for DOSes 00000/00001/00837d D 1.11 91/08/28 15:34:55 sybalsky 11 10c Remove a debugging printf from the backwards-blting code.es 00164/00033/00674d D 1.10 91/05/20 09:36:38 sybalsky 10 9c Fix C version of the 16-bit bitblt bug; add more comments.es 00012/00001/00695d D 1.9 90/06/04 10:32:30 sybalsky 9 8c reformat, copyrightes 00010/00022/00686d D 1.8 90/04/17 17:06:26 sybalsky 8 7c AIX port, change pointer arithmetic to word-based from (int)ptr += bytes.es 00023/00023/00685d D 1.7 89/12/13 11:02:23 sybalsky 7 6c color ss1, bitblt speedupes 00026/00019/00682d D 1.6 88/10/17 22:11:57 shih 6 5c slight performance improvement in loop initializationes 00208/00085/00493d D 1.5 88/09/23 13:51:52 charnley 5 4c cleaned up argument passinges 00001/00001/00577d D 1.4 88/09/15 10:06:48 charnley 4 3c changed src shift mask for backward alligned case.es 00004/00004/00574d D 1.3 88/09/07 15:35:03 charnley 3 2c some end masking and post-fetching problems resolved.es 00001/00001/00577d D 1.2 88/09/07 10:59:47 charnley 2 1c fixes bug assoc with backward bitblt, 2 src word in first dest word conditionales 00578/00000/00000d D 1.1 88/08/18 16:54:33 charnley 1 0c date and time created 88/08/18 16:54:33 by charnleyeuUf e 0tTI 1D 9/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 9I 9/* This is G-file %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 9/*	bb.h		written by don charnley						*/I 9I 10E 10/************************************************************************//*									*/D 10/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 10I 10/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*//*	Manufactured in the United States of America.			*/E 10/*									*/D 10/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 10I 10/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 10/*									*//************************************************************************/E 9I 10E 10/*		COMMENTS:	This code tries to make very few assumptions about the	underlying hardware, and some are required.  The following	assumptions are made:		memory addresses are "byte addresses"		data is effectively 32 bits		the memory is most efficient at 32-bit wordsD 10			(always 32-bit alligned)E 10I 10			(always 32-bit aligned)E 10D 5	Left and right shift amounts are always less than 32 bits,	and right shifted data is always masked to compensate for	possible arithemetic shifts.  Either logical or arithmetic	shifts will execute correctly.E 5I 5	Left and right shift amounts are always less than 32 bits.	(there is one exception, B_postloop_mask, which may have its	shift count = 32, in which case it is not used)	Right shifted data is masked if necessary to compensate forD 6	possible arithemetic shifts.  Arithmetic shifts are assumed as E 6I 6	possible arithemetic shifts.  Arithmetic shifts are assumed asE 6	the default.E 5	The backwards bit of the control block is followed blindly,	except that gray is always executed forwards.  Gray bricks	are always 16 bits wide, and 1 to 16 bits high.  These	assumptions are identical to those made in the D-machine	microcode.*//*	INDEX	CONSTANTS	op_repl_src	op_fn_and	op_fn_or	op_fn_xor	CONDITIONSD 10	alligned_loop	F_single_dst_wordE 10I 10	aligned_loop		-- it's all 32-bit-word aligned.	F_single_dst_word	-- All the dest bits lie in 1 wordE 10	F_postloop_dst_word	F_two_preloop_src	F_src_preloop_normal	F_src_word_in_postloop	B_two_preloop_src	B_src_preloop_normalD 10	B_single_dst_wordE 10I 10	B_single_dst_word	-- All the dest bits lie in 1 wordE 10	B_postloop_dst_word	B_src_word_in_postloop	VARIABLES	F_num_loopD 5	F_sdw_maskE 5	F_preloop_mask	F_postloop_mask	B_num_loopD 5	B_sdw_maskE 5	B_preloop_mask	B_postloop_mask	OTHER	TRANSFER LOOP THINGS	ForInner	DestGetsF	DestGetsB	GetSrcF	GetSrcB	INIT	some_init	do_gray_init	F_do_init	B_do_init	F_dst_init	gray_src_init	F_src_init	B_dst_init	B_src_init	SETUPS	do_src_gray_setup	F_do_src_setup	B_do_src_setup	TRANSFERS	do_gray_transfer	F_do_transfer	B_do_transfer	do_partial_transfer	POSTLOOP	F_do_postloop_src_prep	B_do_postloop_src_prep	ADVANCES	do_gray_advance	F_do_advance	B_do_advance	do_src_gray_advance	F_do_dst_advance	F_do_src_advance	B_do_src_advance	B_do_dst_advance	NAMED VARIABLES	variables*//*   CONSTANTS   */#define	 op_repl_src	0#define	 op_fn_and	1#define	 op_fn_or	2#define	 op_fn_xor	3/*   CONDITIONS   */D 10#define  alligned_loop  src32lbit == dst32lbitE 10I 10#define  aligned_loop  src32lbit == dst32lbitE 10D 6#define  F_single_dst_word  (dst32lbit + w) <= 32 #define  F_postloop_dst_word  dst32rbit != 31 E 6I 6#define  F_single_dst_word  (dst32lbit + w) <= 32#define  F_postloop_dst_word  dst32rbit != 31E 6#define  F_two_preloop_src  (src32lbit > dst32lbit) && ((src32lbit + w) > 32)#define  F_src_preloop_normal  src32lbit <= dst32lbitD 3#define  F_src_word_in_postloop  src32rbit < dst32rbitE 3I 3#define  F_src_word_in_postloop  src32rbit <= dst32rbitE 3#define  B_single_dst_word  (dst32lbit + w) <= 32D 2#define  B_two_preloop_src  (src32rbit < dst32rbit) && ((src32lbit + w) > 32)E 2I 2#define  B_two_preloop_src  (src32rbit < dst32rbit) && ((src32lbit + w) > (dst32lbit + 1))E 2#define  B_src_preloop_normal  src32rbit >= dst32rbit#define  B_postloop_dst_word  dst32lbit != 0D 3#define  B_src_word_in_postloop  src32lbit > dst32lbitE 3I 3#define  B_src_word_in_postloop  src32lbit >= dst32lbitE 3/*   VARIABLES   */#define  F_num_loop  ((dst32lbit + w) >> 5) - 1D 5#define  F_sdw_mask  (F_preloop_mask) & (F_postloop_mask)E 5I 5#define  B_num_loop  ((w - dst32rbit - 1) > 0) ? ((w - dst32rbit - 1) >> 5) : 0E 5D 6#define  F_preloop_mask  ((dst32lbit) ? (~(0xFFFFFFFF << (32 - dst32lbit))) : 0xFFFFFFFF) #define  F_postloop_mask  0xFFFFFFFF << (31 - dst32rbit) E 6I 6#define  F_preloop_mask  ((dst32lbit) ? (~(0xFFFFFFFF << (32 - dst32lbit))) : 0xFFFFFFFF)#define  F_postloop_mask  0xFFFFFFFF << (31 - dst32rbit)E 6D 5#define  B_num_loop  ((w - dst32rbit - 1) > 0) ? ((w - dst32rbit - 1) >> 5) : 0#define  B_sdw_mask  (B_preloop_mask) & (B_postloop_mask)E 5#define  B_preloop_mask  0xFFFFFFFF << (31 - dst32rbit)D 10#define  B_postloop_mask  (~(0xFFFFFFFF << (32 - dst32lbit)))E 10I 10#define  B_postloop_mask  ((dst32lbit) ? (~(0xFFFFFFFF << (32 - dst32lbit))) : 0xFFFFFFFF)E 10/*   OTHER   */I 10/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 10D 6/*   TRANSFER LOOP THINGS   */#define ForInner   for (cnt = dstnumL; cnt > 0; cnt--)E 6I 6/*   TRANSFER LOOP THINGS (assume cnt's value is not used!)  */#define ForInner   for (cnt = dstnumL; --cnt >= 0; )E 6#define DestGetsF(FN)   *(dst32addr++) FN shS;#define DestGetsB(FN)   *(dst32addr--) FN shS;I 10E 10#define GetSrcF   newS = *(src32addr++);			\D 7  shS        = savedS | ((newS >> srcRshift) & srcRmask);	\E 7I 7  shS        = savedS | ((newS >> srcRshift)/* & srcRmask*/);	\E 7  savedS     = newS << srcLshift;I 10E 10D 6#define GetSrcCF   newS =  *(src32addr++);			\E 6I 6#define GetSrcCF  newS = *(src32addr++);			\E 6D 7  shS        = ~(savedS | ((newS >> srcRshift) & srcRmask));	\E 7I 7  shS        = ~(savedS | ((newS >> srcRshift) /* & srcRmask */));	\E 7  savedS     = newS << srcLshift;I 10E 10D 6#define GetSrcB   newS =  *(src32addr--);			\E 6I 6#define GetSrcB  newS = *(src32addr--);				\E 6  shS    = savedS | (newS << srcLshift);			\D 7  savedS = (newS >> srcRshift) & srcRmask;E 7I 7  savedS = (newS >> srcRshift) /* & srcRmask*/;E 7I 10E 10D 6#define GetSrcCB   newS = *(src32addr--);			\E 6I 6#define GetSrcCB newS = *(src32addr--);				\E 6  shS    = ~(savedS | (newS << srcLshift));			\D 7  savedS = (newS >> srcRshift) & srcRmask;E 7I 7  savedS = (newS >> srcRshift)/* & srcRmask*/;E 7D 10/*   INIT   */E 10I 10/************************************************************************//*									*//*			I N I T I A L I Z A T I O N S			*//*									*//*									*//*									*//************************************************************************/E 10#define  some_init						\ num_lines_remaining = h;					\D 5 if ((h <= 0) || (w <= 0)) return;				\ op = pbt->pbtoperation;					\E 5 fwd = !backwardflg;						\D 5 src_comp = pbt->pbtsourcetype;					\ gray = pbt->pbtusegray;					\E 5I 5 bb_fast = !(31 & (srcbpl | dstbpl));				\E 5 if (gray) {do_gray_init}					\ else if (fwd) {F_do_init}					\ else {B_do_init}I 10E 10#define  do_gray_init						\ F_dst_init							\ gray_src_initI 10E 10#define  F_do_init						\ F_dst_init							\ F_src_initI 10E 10#define  B_do_init						\ B_dst_init							\ B_src_initI 10E 10#define  F_dst_init						\ if (dx < 0)							\ {								\D 7   x32byta  = (int)dstbase - ((7 - dx) >> 3);			\E 7I 7   x32byta  = (int)dstbase - ((7 - dx) >> 3);		\E 7 }								\ else								\ {								\D 7   x32byta  = (int)dstbase + (dx >> 3);				\E 7I 7   x32byta  = (int)dstbase + (dx >> 3);		\E 7 }								\ x32nbyt  = x32byta & 3;					\ x32ia  = x32byta - x32nbyt;					\D 7 dst32addr = (int *)x32ia;					\E 7I 7 dst32addr = (unsigned int *)x32ia;					\E 7 dst32lbit = (x32nbyt << 3) + (dx & 7);				\ dst32rbit = 31 & (dst32lbit + w - 1);				\D 5 OrigDstAddr = dst32addr;E 5I 5 OrigDstAddr = dst32addr;					\ preloop_mask = F_preloop_mask;					\ postloop_mask = F_postloop_mask;				\ sdw_mask = preloop_mask & postloop_mask;			\ dstnumL = F_num_loop;E 5I 10E 10#define  gray_src_init						\D 5 num_gray = ((TEXTUREBBT *)pbt)->pbtgrayheightlessone + 1;	\ curr_gray_line = ((TEXTUREBBT *)pbt)->pbtgrayoffset;		\E 5I 5 bb_fast = !(dstbpl & 31);					\E 5 src32lbit = 15 & sx;I 10E 10#define  F_src_init						\ if (sx < 0)							\ {								\D 7   x32byta  = (int)srcbase - ((7 - sx) >> 3);			\E 7I 7   x32byta  = (int)srcbase - ((7 - sx) >> 3);		\E 7 }								\ else								\ {								\D 7   x32byta  = (int)srcbase + (sx >> 3);				\E 7I 7   x32byta  = (int)srcbase + (sx >> 3);		\E 7 }								\ x32nbyt  = x32byta & 3;					\ x32ia  = x32byta - x32nbyt;					\D 7 src32addr = (int *)x32ia;					\E 7I 7 src32addr = (unsigned int *)x32ia;				\E 7 src32lbit = (x32nbyt << 3) + (sx & 7);				\ src32rbit = 31 & (src32lbit + w - 1);				\I 5 srcRshift = 31 & (dst32lbit - src32lbit);			\ srcLshift = 31 & (src32lbit - dst32lbit);			\ srcRmask  = ((srcLshift) ? ~(0xFFFFFFFF << srcLshift) : 0xFFFFFFFF);	\E 5 OrigSrcAddr = src32addr;I 10E 10#define  B_dst_init						\ abc = dx + w - 1;						\ if (abc < 0)							\ {								\   x32byta  = (int)dstbase - ((7 - abc) >> 3);			\ }								\ else								\ {								\   x32byta  = (int)dstbase + (abc >> 3);			\ }								\ x32nbyt  = x32byta & 3;					\ x32ia  = x32byta - x32nbyt;					\D 7 dst32addr = (int *)x32ia;					\E 7I 7 dst32addr = (unsigned int *)x32ia;				\E 7 dst32rbit = (x32nbyt << 3) + (abc & 7);			\ dst32lbit = 31 & (dst32rbit - w + 1);				\D 5 OrigDstAddr = dst32addr;E 5I 5 OrigDstAddr = dst32addr;					\ preloop_mask = B_preloop_mask;					\ postloop_mask = B_postloop_mask;				\ sdw_mask = preloop_mask & postloop_mask;			\ dstnumL = B_num_loop;E 5I 10E 10#define  B_src_init						\ abc = sx + w - 1;						\ if (abc < 0)							\ {								\   x32byta  = (int)srcbase - ((7 - abc) >> 3);			\ }								\ else								\ {								\   x32byta  = (int)srcbase + (abc >> 3);			\ }								\ x32nbyt  = x32byta & 3;					\ x32ia  = x32byta - x32nbyt;					\D 7 src32addr = (int *)x32ia;					\E 7I 7 src32addr = (unsigned int *)x32ia;					\E 7 src32rbit = (x32nbyt << 3) + (abc & 7);			\ src32lbit = 31 & (src32rbit - w + 1);				\I 5 srcRshift = 31 & (dst32lbit - src32lbit);			\ srcLshift = 31 & (src32lbit - dst32lbit);			\ srcRmask  = ((srcLshift) ? ~(0xFFFFFFFF << srcLshift) : 0);	\E 5 OrigSrcAddr = src32addr;I 10/************************************************************************//*									*//*	  S O U R C E   &   D E S T I N A T I O N   S E T - U P S	*//*									*//*									*//*									*//************************************************************************/E 10/*   SETUPS   */I 10E 10#define  do_src_gray_setup					\D 5 dstnumL = F_num_loop;						\E 5I 5 srcLshift = 15 & (src32lbit - dst32lbit);			\E 5 shS = *srcbase;						\D 7 shS |= (shS << 16);						\D 5 srcLshift = 15 & (src32lbit - dst32lbit);			\E 5 shS <<= srcLshift;						\ shS |= (0xFFFF & (shS >> 16));					\E 7I 7 shS |= (shS << 16);	/* replicate the word */		\ shS <<= srcLshift;			/* rotate left */	\ shS |= (0xFFFF & (shS >> 16));		/*    "     "  */	\E 7 if (src_comp) shS = ~shS;I 10E 10#define  F_do_src_setup						\D 5 dstnumL = F_num_loop;						\ srcRshift = 31 & (dst32lbit - src32lbit);			\ srcLshift = 31 & (src32lbit - dst32lbit);			\ srcRmask  = ((srcLshift) ? ~(0xFFFFFFFF << srcLshift) : 0xFFFFFFFF);	\E 5 if (F_two_preloop_src)						\ {								\   newS = *(src32addr++);					\   savedS = newS << srcLshift;					\   newS = *(src32addr++);					\   shS = savedS | ((newS >> srcRshift) & srcRmask);		\D 3   savedS = newS << srcLshift;					\E 3I 3D 5   savedS = (newS << srcLshift) & ~srcRmask;					\E 5I 5   savedS = (newS << srcLshift) & ~srcRmask;			\E 5E 3 }								\ else if (F_src_preloop_normal)					\ {								\   newS = *(src32addr++);					\   shS = ((newS >> srcRshift) & srcRmask);			\D 3   savedS = newS << srcLshift;					\E 3I 3D 5   savedS = (newS << srcLshift) & ~srcRmask;					\E 5I 5   savedS = (newS << srcLshift) & ~srcRmask;			\E 5E 3 }								\ else								\ {								\   newS = *(src32addr++);					\   shS = newS << srcLshift;					\ }								\ if (src_comp) shS = ~shS;I 10E 10#define  B_do_src_setup						\D 5 dstnumL = B_num_loop;						\ srcRshift = 31 & (dst32lbit - src32lbit);			\ srcLshift = 31 & (src32lbit - dst32lbit);			\D 4 srcRmask  = ((srcLshift) ? ~(0xFFFFFFFF << srcLshift) : 0xFFFFFFFF);	\E 4I 4 srcRmask  = ((srcLshift) ? ~(0xFFFFFFFF << srcLshift) : 0);	\E 5E 4 if (B_two_preloop_src)						\ {								\   newS = *(src32addr--);					\   savedS = (newS >> srcRshift) & srcRmask;			\   newS = *(src32addr--);					\   shS = savedS | (newS << srcLshift);				\   savedS = (newS >> srcRshift) & srcRmask;			\ }								\ else if (B_src_preloop_normal)					\ {								\   newS = *(src32addr--);					\   shS = newS << srcLshift;					\   savedS = (newS >> srcRshift) & srcRmask;			\ }								\ else								\ {								\   newS = *(src32addr--);					\   shS = (newS >> srcRshift) & srcRmask;			\ }								\ if (src_comp) shS = ~shS;D 10/*   TRANSFERS   */I 6/* -------------------------------- */E 10I 10/************************************************************************//*									*//*			T R A N S F E R   L O O P S			*//*									*//*									*//*									*//************************************************************************/E 10E 6#define  do_gray_transfer					\ if (F_single_dst_word)						\ {								\D 5   mask = F_sdw_mask;						\E 5I 5   mask = sdw_mask;						\E 5   goto do_fpt;							\ }								\D 5 mask = F_preloop_mask;						\E 5I 5 mask = preloop_mask;						\E 5 do_partial_transfer						\ dst32addr++;							\ switch (op)							\ { register int cnt;						\   case op_repl_src: ForInner { DestGetsF(=)  } break;		\D 6   case op_fn_and: ForInner   { DestGetsF(&=) } break;		\   case op_fn_or: ForInner    { DestGetsF(|=) } break;		\   case op_fn_xor: ForInner   { DestGetsF(^=) } break;		\E 6I 6   case op_fn_and:   ForInner { DestGetsF(&=) } break;		\   case op_fn_or:    ForInner { DestGetsF(|=) } break;		\   case op_fn_xor:   ForInner { DestGetsF(^=) } break;		\E 6 }								\ if (F_postloop_dst_word)					\ {								\D 5   mask = F_postloop_mask;					\E 5I 5   mask = postloop_mask;					\E 5   goto do_fpt;							\ }								\ goto next_line;I 6D 10/* -------------------------------- */E 10I 10E 10E 6#define  F_do_transfer						\ if (F_single_dst_word)						\ {								\D 5   mask = F_sdw_mask;						\E 5I 5   mask = sdw_mask;						\E 5   goto do_fpt;							\ }								\D 5 mask = F_preloop_mask;						\E 5I 5 mask = preloop_mask;						\E 5 do_partial_transfer						\ dst32addr++;							\D 10 if (alligned_loop)						\E 10I 10 if (aligned_loop)						\E 10 {								\   if (src_comp) switch (op)					\   { register int cnt;							\     case op_repl_src: ForInner {*dst32addr++  = ~*src32addr++;} break;	\     case op_fn_and:   ForInner {*dst32addr++ &= ~*src32addr++;} break;	\     case op_fn_or:    ForInner {*dst32addr++ |= ~*src32addr++;} break;	\     case op_fn_xor:   ForInner {*dst32addr++ ^= ~*src32addr++;} break;	\   }									\   else switch (op)							\   { register int cnt;							\     case op_repl_src: ForInner {*dst32addr++  = *src32addr++;} break;	\     case op_fn_and:   ForInner {*dst32addr++ &= *src32addr++;} break;	\     case op_fn_or:    ForInner {*dst32addr++ |= *src32addr++;} break;	\     case op_fn_xor:   ForInner {*dst32addr++ ^= *src32addr++;} break;	\   }									\ }									\ else									\ {									\   if (src_comp) switch (op)						\   { register int cnt;							\     case op_repl_src: ForInner {GetSrcCF DestGetsF(=)  } break;	\     case op_fn_and:   ForInner {GetSrcCF DestGetsF(&=) } break;	\     case op_fn_or:    ForInner {GetSrcCF DestGetsF(|=) } break;	\     case op_fn_xor:   ForInner {GetSrcCF DestGetsF(^=) } break;	\   }									\   else switch (op)							\   { register int cnt;							\     case op_repl_src: ForInner {GetSrcF  DestGetsF(=)  } break;	\     case op_fn_and:   ForInner {GetSrcF  DestGetsF(&=) } break;	\     case op_fn_or:    ForInner {GetSrcF  DestGetsF(|=) } break;	\     case op_fn_xor:   ForInner {GetSrcF  DestGetsF(^=) } break;	\   }									\ }								\ if (F_postloop_dst_word)					\ {								\   F_do_postloop_src_prep					\D 5   mask = F_postloop_mask;					\E 5I 5   mask = postloop_mask;					\E 5   goto do_fpt;							\ }								\ goto next_line;I 6D 10/* -------------------------------- */E 10I 10E 10E 6#define  B_do_transfer						\ if (B_single_dst_word)						\ {								\D 5   mask = B_sdw_mask;						\E 5I 5   mask = sdw_mask;						\I 10D 11   printf("lbit = %d, rbit = %d, mask = 0x%x\n", dst32lbit, dst32rbit, mask); \E 11E 10E 5   goto do_fpt;							\ }								\D 5 mask = B_preloop_mask;						\E 5I 5 mask = preloop_mask;						\E 5 do_partial_transfer						\ dst32addr--;							\D 10 if (alligned_loop)						\E 10I 10 if (aligned_loop)						\E 10 {								\   if (src_comp) switch (op)					\   { register int cnt;							\     case op_repl_src: ForInner {*dst32addr--  = ~*src32addr--;} break;	\     case op_fn_and:   ForInner {*dst32addr-- &= ~*src32addr--;} break;	\     case op_fn_or:    ForInner {*dst32addr-- |= ~*src32addr--;} break;	\     case op_fn_xor:   ForInner {*dst32addr-- ^= ~*src32addr--;} break;	\   }									\   else switch (op)							\   { register int cnt;							\     case op_repl_src: ForInner {*dst32addr--  = *src32addr--;} break;	\     case op_fn_and:   ForInner {*dst32addr-- &= *src32addr--;} break;	\     case op_fn_or:    ForInner {*dst32addr-- |= *src32addr--;} break;	\     case op_fn_xor:   ForInner {*dst32addr-- ^= *src32addr--;} break;	\   }									\ }									\ else									\ {									\   if (src_comp) switch (op)						\   { register int cnt;							\     case op_repl_src: ForInner {GetSrcCB DestGetsB(=)  } break;	\     case op_fn_and:   ForInner {GetSrcCB DestGetsB(&=) } break;	\     case op_fn_or:    ForInner {GetSrcCB DestGetsB(|=) } break;	\     case op_fn_xor:   ForInner {GetSrcCB DestGetsB(^=) } break;	\   }									\   else switch (op)							\   { register int cnt;							\     case op_repl_src: ForInner {GetSrcB  DestGetsB(=)  } break;	\     case op_fn_and:   ForInner {GetSrcB  DestGetsB(&=) } break;	\     case op_fn_or:    ForInner {GetSrcB  DestGetsB(|=) } break;	\     case op_fn_xor:   ForInner {GetSrcB  DestGetsB(^=) } break;	\   }									\ }								\ if (B_postloop_dst_word)					\ {								\   B_do_postloop_src_prep					\D 5   mask = B_postloop_mask;					\E 5I 5   mask = postloop_mask;					\E 5   goto do_fpt;							\ }								\ goto next_line;I 6D 10/* -------------------------------- */E 10I 10E 10E 6#define  do_partial_transfer					\ dstdata = *dst32addr;						\ dstold = dstdata & ~mask;					\ switch (op)							\ {								\D 6   case op_repl_src: dstdata = shS; break;			\   case op_fn_and: dstdata &= shS; break;			\   case op_fn_or: dstdata |= shS; break;			\   case op_fn_xor: dstdata ^= shS; break;			\E 6I 6   case op_repl_src: dstdata  = shS; break;			\   case op_fn_and:   dstdata &= shS; break;			\   case op_fn_or:    dstdata |= shS; break;			\   case op_fn_xor:   dstdata ^= shS; break;			\E 6 }								\ dstdata &= mask;						\ dstdata |= dstold;						\ *dst32addr = dstdata;D 10/*   POSTLOOP   */I 6/* -------------------------------- */E 10I 10/************************************************************************//*									*//*			P O S T - L O O P  C O D E			*//*									*//*									*//*									*//************************************************************************/E 10E 6#define F_do_postloop_src_prep					\ if (F_src_word_in_postloop)					\ {								\   newS = *src32addr;						\   shS = savedS | ((newS >> srcRshift) & srcRmask);		\ }								\ else								\ {								\   shS = savedS;						\ }								\ if (src_comp) shS = ~shS;I 6D 10/* -------------------------------- */E 10I 10E 10E 6#define B_do_postloop_src_prep					\ if (B_src_word_in_postloop)					\ {								\   newS = *src32addr;						\   shS = savedS | (newS << srcLshift);				\ }								\ else								\ {								\   shS = savedS;						\ }								\ if (src_comp) shS = ~shS;I 6D 10/* -------------------------------- */E 6/*   ADVANCES   */E 10I 10/************************************************************************//*									*//*	    L O O P - C O U N T E R   A D V A N C E   C O D E		*//*									*//*									*//*									*//************************************************************************/E 10#define  do_gray_advance					\ F_do_dst_advance						\ do_src_gray_advance#define  F_do_advance						\ F_do_dst_advance						\ F_do_src_advance#define  B_do_advance						\ B_do_dst_advance						\ B_do_src_advance#define F_do_dst_advance					\D 5 dst32addr = OrigDstAddr;					\ dst32lbit += dstbpl;						\ temp = dst32lbit >> 5;						\ temp <<= 2;							\ (int)dst32addr += temp;					\ dst32lbit &= 31;						\ dst32rbit = 31 & (dst32lbit + w - 1);				\ OrigDstAddr = dst32addr;E 5I 5 if (bb_fast)							\ {								\D 8   (int)OrigDstAddr += dstbpl >> 3;				\E 8I 8   OrigDstAddr += dstbpl >> 5;				\E 8   dst32addr = OrigDstAddr;					\ }								\ else								\ {								\   dst32addr = OrigDstAddr;					\   dst32lbit += dstbpl;						\D 8   temp = dst32lbit >> 5;					\   temp <<= 2;							\   (int)dst32addr += temp;					\E 8I 8   dst32addr += dst32lbit >> 5;					\E 8   dst32lbit &= 31;						\   dst32rbit = 31 & (dst32lbit + w - 1);			\   OrigDstAddr = dst32addr;					\   preloop_mask = F_preloop_mask;				\   postloop_mask = F_postloop_mask;				\   sdw_mask = preloop_mask & postloop_mask;			\   dstnumL = F_num_loop;					\ }D 6 E 6I 6E 6E 5#define do_src_gray_advance					\ if (++curr_gray_line >= num_gray)				\ {								\   curr_gray_line = 0;						\   srcbase = srcbase - (num_gray - 1);				\ }								\ else ++srcbase;#define F_do_src_advance					\D 5 src32addr = OrigSrcAddr;					\ src32lbit += srcbpl;						\ temp = src32lbit >> 5;						\ temp <<= 2;							\ (int)src32addr += temp;					\ src32lbit &= 31;						\ src32rbit = 31 & (src32lbit + w - 1);				\ OrigSrcAddr = src32addr;#define B_do_src_advance					\ src32addr = OrigSrcAddr;					\ src32rbit += srcbpl;						\ if (src32rbit < 0)						\E 5I 5 if (bb_fast)							\E 5 {								\D 5   temp = (31 - src32rbit) >> 5;				\   temp <<= 2;							\   (int)src32addr -= temp;					\E 5I 5D 8   (int)OrigSrcAddr += srcbpl >> 3;				\E 8I 8   OrigSrcAddr += srcbpl >> 5;				\E 8   src32addr = OrigSrcAddr;					\E 5 }								\ else								\ {								\D 5   temp = src32rbit >> 5;					\E 5I 5   src32addr = OrigSrcAddr;					\   src32lbit += srcbpl;						\D 8   temp = src32lbit >> 5;					\E 5   temp <<= 2;							\   (int)src32addr += temp;					\E 8I 8   src32addr += src32lbit >> 5;					\E 8I 5   src32lbit &= 31;						\   src32rbit = 31 & (src32lbit + w - 1);			\   OrigSrcAddr = src32addr;					\   srcRshift = 31 & (dst32lbit - src32lbit);			\   srcLshift = 31 & (src32lbit - dst32lbit);			\   srcRmask  = ((srcLshift) ? ~(0xFFFFFFFF << srcLshift) : 0xFFFFFFFF);	\ }#define B_do_src_advance					\ if (bb_fast)							\ {								\D 8   (int)OrigSrcAddr += srcbpl >> 3;				\E 8I 8   OrigSrcAddr += srcbpl >> 5;				\E 8   src32addr = OrigSrcAddr;					\E 5 }								\D 5 src32rbit &= 31;						\ src32lbit = 31 & (src32rbit - w + 1);				\ OrigSrcAddr = src32addr;E 5I 5 else								\ {								\   src32addr = OrigSrcAddr;					\   src32rbit += srcbpl;						\   if (src32rbit < 0)						\   {								\D 8     temp = (31 - src32rbit) >> 5;				\     temp <<= 2;						\     (int)src32addr -= temp;					\E 8I 8     src32addr -= (31 - src32rbit) >> 5;					\E 8   }								\   else								\   {								\D 8     temp = src32rbit >> 5;					\     temp <<= 2;						\     (int)src32addr += temp;					\E 8I 8     src32addr += src32rbit >> 5;					\E 8   }								\   src32rbit &= 31;						\   src32lbit = 31 & (src32rbit - w + 1);			\   srcRshift = 31 & (dst32lbit - src32lbit);			\   srcLshift = 31 & (src32lbit - dst32lbit);			\   srcRmask  = ((srcLshift) ? ~(0xFFFFFFFF << srcLshift) : 0);	\   OrigSrcAddr = src32addr;					\ }E 5#define B_do_dst_advance					\D 5 dst32addr = OrigDstAddr;					\ dst32rbit += dstbpl;						\ if (dst32rbit < 0)						\E 5I 5 if (bb_fast)							\E 5 {								\D 5   temp = (31 - dst32rbit) >> 5;				\   temp <<= 2;							\   (int)dst32addr -= temp;					\E 5I 5D 8   (int)OrigDstAddr += dstbpl >> 3;				\E 8I 8D 10   OrigDstAddr += dstbpl >> 5;				\E 10I 10   OrigDstAddr += dstbpl >> 5;					\E 10E 8   dst32addr = OrigDstAddr;					\E 5 }								\ else								\ {								\D 5   temp = dst32lbit >> 5;					\   temp <<= 2;							\   (int)dst32addr += temp;					\ }								\ dst32rbit &= 31;						\ dst32lbit = 31 & (dst32rbit - w + 1);				\ OrigDstAddr = dst32addr;					\E 5I 5   dst32addr = OrigDstAddr;					\   dst32rbit += dstbpl;						\   if (dst32rbit < 0)						\   {								\D 8     temp = (31 - dst32rbit) >> 5;				\     temp <<= 2;						\     (int)dst32addr -= temp;					\E 8I 8D 10     dst32addr -= (31 - dst32rbit) >> 5;					\E 10I 10     dst32addr -= (31 - dst32rbit) >> 5;			\E 10E 8   }								\   else								\   {								\D 8     temp = dst32lbit >> 5;					\     temp <<= 2;						\     (int)dst32addr += temp;					\E 8I 8D 10     dst32addr += dst32lbit >> 5;					\E 10I 10     dst32addr += dst32lbit >> 5;				\E 10E 8   }								\   dst32rbit &= 31;						\   dst32lbit = 31 & (dst32rbit - w + 1);			\   OrigDstAddr = dst32addr;					\   preloop_mask = B_preloop_mask;				\   postloop_mask = B_postloop_mask;				\   sdw_mask = preloop_mask & postloop_mask;			\   dstnumL = B_num_loop;					\ }E 5D 10/*   NAMED VARIABLES   */I 5/*	the following variables need to be set up:D 6	register DLword 	*srcbase, *dstbase;E 6I 6	register DLword	*srcbase, *dstbase;E 6	int	sx, dx, w, h, srcbpl, dstbpl, backwardflg;	int	src_comp, op, gray, num_gray, curr_gray_line;*/E 10I 10/************************************************************************//*									*//*		V A R I A B L E   D E C L A R A T I O N S		*//*									*//*	This sets up the strictly-internal variables for bitblt.	*//*									*//*	However, YOU must set up the control variables that are used	*//*	as "arguments" to the bitblt code:				*//*									*//*	register DLword	*srcbase, *dstbase;				*//*	int	sx, dx, w, h, srcbpl, dstbpl, backwardflg;		*//*	int	src_comp, op, gray, num_gray, curr_gray_line;		*//*									*//************************************************************************/E 10E 5#define variables						\D 5int num_lines_remaining, temp, num_gray;			\int dstnumL, src32lbit;				\E 5I 5int num_lines_remaining, temp;					\D 7int dstnumL, src32lbit;						\E 5int srcRmask, srcLshift, dstold, dstdata, mask;			\int x32byta, x32nbyt, x32ia, dst32lbit;				\E 7I 7int dstnumL, src32lbit, srcLshift, dst32lbit;			\D 10unsigned int srcRmask, dstold, dstdata, mask;	\int x32byta, x32nbyt, x32ia;		\E 10I 10unsigned int srcRmask, dstold, dstdata, mask;			\int x32byta, x32nbyt, x32ia;					\E 10E 7D 5int curr_gray_line;						\int abc, dst32rbit, src32rbit;					\E 5I 5int abc, dst32rbit, src32rbit, fwd;				\E 5D 7int *OrigSrcAddr, *OrigDstAddr;					\E 7I 7unsigned int *OrigSrcAddr, *OrigDstAddr;			\E 7D 5int op, fwd, src_comp, gray;					\E 5I 5int bb_fast;							\D 7int preloop_mask, postloop_mask, sdw_mask;			\E 5register int *dst32addr, *src32addr;				\register int shS, savedS, newS, srcRshift;E 7I 7unsigned int preloop_mask, postloop_mask, sdw_mask;		\register unsigned int *dst32addr, *src32addr;			\register unsigned int shS, savedS, newS;			\register int srcRshift;E 7I 5I 10/************************************************************************//*									*//*			n e w _ b i t b l t _ c o d e			*//*									*//*	Generic bitblt-code macro; generates bitblt code for the	*//*	general cases.  Requires a number of symbols be defined		*//*	by the calling code, in lieu of arguments:			*//*									*//*	srcbase								*//*	dstbase								*//*	srcbpl								*//*	dstbpl								*//*	backwardflg							*//*	sx, dx								*//*	w, h								*//*									*//************************************************************************/E 10#define  new_bitblt_code			\{						\variables					\some_init					\while (num_lines_remaining-- > 0)		\{ /* begin line loop */				\  if (gray)					\  {						\    do_src_gray_setup				\    do_gray_transfer				\  }						\  if (fwd)					\  {						\    F_do_src_setup				\    F_do_transfer				\  }						\  {						\    B_do_src_setup				\    B_do_transfer				\  }						\do_fpt:						\  {						\    do_partial_transfer				\    goto next_line;				\  }						\next_line:					\  if (gray)					\  {						\    do_gray_advance				\    continue;					\  }						\  if (fwd)					\  {						\    F_do_advance				\    continue;					\  }						\  {						\    B_do_advance				\    continue;					\  }						\} /* end line loop */				\}I 10/************************************************************************//*									*//*		n e w _ g r a y _ b i t b l t _ c o d e			*//*									*//*	Handles texture case of bitblt, for BLTSHADE functions.		*//*									*//************************************************************************/E 10#define  new_gray_bitblt_code			\{						\variables					\some_init					\while (num_lines_remaining-- > 0)		\{ /* begin line loop */				\  do_src_gray_setup				\  do_gray_transfer				\do_fpt:						\  do_partial_transfer				\next_line:					\  do_gray_advance				\} /* end line loop */				\}I 10/************************************************************************//*									*//*		 n e w _ c h a r _ b i t b l t _ c o d e		*//*									*//*	Optimized slightly for bltchar.					*//*									*//************************************************************************/E 10#define  new_char_bitblt_code			\{						\variables					\some_init					\while (num_lines_remaining-- > 0)		\{ /* begin line loop */				\  F_do_src_setup				\  F_do_transfer					\do_fpt:						\  do_partial_transfer				\next_line:					\  F_do_advance					\} /* end line loop */				\}E 5D 7E 7E 1