h36431s 00015/00008/00264d D 2.13 93/02/08 14:41:22 sybalsky 16 15c Big VM (and new CDR coding) changes for 3.0 \nes 00001/00000/00271d D 2.12 92/06/26 13:47:43 sybalsky 15 14c retrofit of 386 unix changes \nes 00005/00005/00266d D 2.11 92/04/21 16:56:11 sybalsky 14 13c shortening file names for DOS \nes 00001/00001/00270d D 2.10 91/08/19 16:22:55 sybalsky 13 12c Better test for end of name tableses 00040/00008/00231d D 2.9 91/07/11 12:10:35 sybalsky 12 11c Refit Savoir changes for DEC3100 - make print use only 24-bit pointers.es 00001/00001/00238d D 2.8 90/07/22 11:36:09 sybalsky 11 10c Change dtd_name reference to combo of dtd_namelo & _hi.es 00003/00003/00236d D 2.7 90/07/04 03:53:25 sybalsky 10 9c DTD type-name changees 00000/00000/00239d D 2.6 90/04/20 01:07:47 sybalsky 9 8c AIX:  shortening file names, bulk change.es 00011/00002/00228d D 2.5 90/03/15 20:56:48 takeshi 8 7c Add floating printinges 00057/00049/00173d D 2.4 90/02/21 17:31:42 sybalsky 7 6c Commenting, reformatting code, checking for 386 changes needed (nonytes 00011/00000/00211d D 2.3 89/12/29 12:56:45 sybalsky 6 5c Changes from Savoires 00060/00048/00151d D 2.2 89/03/28 01:48:14 sybalsky 5 4c Fixed prindatum to handle strings right, get type info right.es 00000/00000/00199d D 2.1 88/05/17 09:21:18 hayata 4 3c Version up to 2.1es 00020/00002/00179d D 1.3 88/05/08 10:32:58 shimizu 3 2c for URaid modifyes 00002/00002/00179d D 1.2 88/03/13 14:30:36 hayata 2 1c Add SCCS key id (%Z%)es 00181/00000/00000d D 1.1 88/02/24 16:55:24 hayata 1 0c date and time created 88/02/24 16:55:24 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 7/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 2/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. */E 7I 7D 10/* This is G-file @(#) Kprint.c Version 2.3 (12/29/89). copyright Xerox & Fuji Xerox  */static char *id = "@(#) Kprint.c	2.3 12/29/89";E 10I 10/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 10E 7I 12E 12I 7/************************************************************************//*									*/D 12/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 12I 12D 16/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*/E 16I 16/*	(C) Copyright 1989-1992 Venue. All Rights Reserved.	*/E 16/*	Manufactured in the United States of America.			*/E 12/*									*/D 12/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 12I 12/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 12/*									*//************************************************************************/E 7I 7E 7D 12/* "print.c" edited by Hirofumi Komatsubara   */E 12D 12/***********/E 12/* 30 April 1987 *//* print litatom,list,smallp *//***********//* 9 Jun 1987 *//* print string *//* changed prindatum and added print_string */ /***********//* 2 July 1987 *//* print fixp *//* changed printdatum *//************/D 3/* Aug 14 87 take enable to print newstring(Lyric) */E 3I 3/* Aug 14 87 Take enable to print newstring(Lyric) */E 3/* 26 August 1987 *//* changing for debug tool */I 3/* 6 May 1988 Modify for URAID by Take */E 3#include	<stdio.h>#include	"print.h"#include	"address.h"#include	"lispemul.h"D 14#include	"lisptypes.h"#include	"lispglobal.h"#include	"initatoms.h"E 14I 14#include	"lsptypes.h"#include	"lspglob.h"#include	"initatms.h"E 14#include	"cell.h"D 14#include	"emulglobal.h"E 14I 14#include	"emlglob.h"E 14#include	"lispmap.h"D 14#include	"address68k.h"E 14I 14#include	"adr68k.h"E 14I 12E 12I 3int PrintMaxLevel= 2;int Printdepth=0;I 16int PrintMaxLen = 50;int PrintLen[20] ;E 16E 3I 5D 16E 16/************************************************************************//*									*//*			P R I N D A T U M				*//*									*//************************************************************************/E 5D 3E 3prindatum(x)D 5LispPTR	x;{	NEWSTRINGP *newstring ;	struct dtd *dtd_base;	int	typen;	DLword	typename;E 5I 5  LispPTR x; {    NEWSTRINGP *newstring ;    struct dtd *dtd_base;    int	typen;    DLword	typename;E 5I 3D 5	if(Printdepth > PrintMaxLevel)	{		if(GetTypeNumber(x)==TYPE_LISTP)		{			printf("(-)");		}		else			printf("*");		return;	}E 5I 5D 16    if(Printdepth > PrintMaxLevel)E 16I 16    if(Printdepth >= PrintMaxLevel)E 16      {D 16	if(GetTypeNumber(x)==TYPE_LISTP)E 16I 16	if (Printdepth = PrintMaxLevel){ if(GetTypeNumber(x)==TYPE_LISTP)E 16	  {	    printf("(-)");	  }D 16	  else printf("*");E 16I 16	  else printf("*");}E 16	return;      }E 5	E 3D 5	switch (GetTypeNumber(x)) {	case TYPE_LITATOM:E 5I 5  switch (typen = GetTypeNumber(x))   {      case TYPE_LITATOM:I 15      case TYPE_NEWATOM:E 15E 5			print_atomname(x);			break;D 5	case	TYPE_LISTP:I 3			Printdepth++;E 3			printf("%c" , LEFT_PAREN);		/* print "(" */			lp:	prindatum(car(x));				if (Listp (cdr(x)) == 0) {	/* print doted pair */					if ((x = cdr(x)) != NIL) {							printf(" . ");							prindatum(x);							}						}				else					{					printf("%c" , SPACE);					x = cdr(x);					goto lp;					}				printf("%c" , RIGHT_PAREN);	/* print ")" */I 3				Printdepth--;E 3			break;E 5I 5      case TYPE_LISTP:		Printdepth++;I 16		PrintLen[Printdepth] = 0;E 16		printf("%c" , LEFT_PAREN);		/* print "(" */D 16		lp: prindatum(car(x));E 16I 16		lp: if (PrintLen[Printdepth] ++ > PrintMaxLen) {printf("%c", RIGHT_PAREN); Printdepth--;  break;}			prindatum(car(x));E 16		    if (Listp (cdr(x)) == 0) 		      {	/* print dotted pair */			if ((x = cdr(x)) != NIL)			  {			    printf(" . ");			    prindatum(x);			  }		      }		     else		      {			printf("%c" , SPACE);			x = cdr(x);			goto lp;		      }		    printf("%c" , RIGHT_PAREN);	/* print ")" */		    Printdepth--;		    break;E 5		case	TYPE_SMALLP:D 16			if ((x & 0xff0000) == S_POSITIVE)E 16I 16			if ((x & SEGMASK) == S_POSITIVE)E 16				printf("%d" , LOLOC(x));	/* print positive smallp */				else										printf("%d" , (LOLOC(x) | 0xffff0000));	/* print negative smallp */			break;	case	TYPE_FIXP:			print_fixp(x);		/* print fixp  */			break;D 8E 8I 8	case TYPE_FLOATP:			print_floatp(x);			break;E 8	case TYPE_STRINGP:			print_string(x);		/* print string */			break;	case TYPE_ONED_ARRAY :	case TYPE_GENERAL_ARRAY :			newstring=(NEWSTRINGP *)Addr68k_from_LADDR(x);			if(newstring->stringp){			  print_NEWstring(x);			  break; }	default: D 5		typen = GetTypeNumber(x);E 5		dtd_base = (struct dtd *)GetDTD(typen);		printf("{");I 16#ifdef BIGVM 		if((typename = dtd_base->dtd_name) != 0)#elseE 16D 11		if((typename = dtd_base->dtd_name) != 0)E 11I 11		if((typename = dtd_base->dtd_namelo+(dtd_base->dtd_namehi<<16)) != 0)I 16#endifE 16E 11D 7			print_atomname(typename);		else			printf("unknown");E 7I 7		  print_atomname(typename);		else printf("unknown");E 7		printf("}0x");D 7		printf("%x" , x);		/* print lispaddoress by hex */E 7I 7		printf("%x" , x);	/* print lisp address in hex */E 7	}}I 5/************************************************************************//*									*//*				P R I N T				*//*									*/I 7/*	Equivalent to the Lisp function PRINT,  prints the object.	*//*									*/E 7/************************************************************************/E 5LispPTR	print(x)D 5LispPTR		x;{I 3	Printdepth=0;E 3	prindatum(x);	/* printf("\n"); */		/* print CR */	return (x);}E 5I 5  LispPTR x;  {    Printdepth=0;D 12    prindatum(x);E 12I 12D 16    prindatum(x&0xFFFFFF);E 16I 16    prindatum(x&POINTERMASK);E 16E 12    /* printf("\n"); */		/* print CR */    return (x);  }E 5I 12/************************************************************************//*									*//*			   p r i n t _ s t r i n g			*//*									*//*	Print a Lisp string.						*//*									*//************************************************************************/E 12print_string(x)D 7LispPTR	x;{struct stringp	*string_point;DLword	st_length;DLbyte	*string_base;E 7I 7  LispPTR	x;  {    struct stringp	*string_point;    DLword	st_length;    DLbyte	*string_base;E 7D 7int		i;E 7I 7    int		i;E 7D 7		string_point = (struct stringp *)Addr68k_from_LADDR(x);		st_length = string_point->length;		string_base = (DLbyte *)Addr68k_from_LADDR(string_point->base);E 7I 7    string_point = (struct stringp *)Addr68k_from_LADDR(x);    st_length = string_point->length;    string_base = (DLbyte *)Addr68k_from_LADDR(string_point->base);E 7D 7		printf("%c" , DOUBLEQUOTE);	/* print %" */E 7I 7    printf("%c" , DOUBLEQUOTE);	/* print %" */E 7		D 7		for (i = 1 ; i <= st_length ; i++){D 5			printf("%c" , *string_base);E 5I 5			printf("%c" , GETBYTE(string_base));E 5			string_base++;			}E 7I 7    for (i = 1 ; i <= st_length ; i++)      {	printf("%c" , GETBYTE(string_base));	string_base++;      }E 7D 7		printf("%c" , DOUBLEQUOTE);	/* print %" */}E 7I 7    printf("%c" , DOUBLEQUOTE);	/* print %" */  }E 7I 6/************************************************************************//*									*//*		      p r i n t _ N E W s t r i n g			*//*									*//*	Print a Lyric-style string (the Commonlisp-array kind), as	*//*	opposed to the older special-case STRINGP kind from Koto.	*//*									*//************************************************************************/E 6print_NEWstring(x)D 7LispPTR	x;{NEWSTRINGP *string_point;DLword	st_length;DLbyte	*string_base;E 7I 7  LispPTR	x;  {    NEWSTRINGP *string_point;    DLword	st_length;    DLbyte	*string_base;E 7D 7int		i;/* STRING type in LYRIC by takeshi */E 7I 7    int		i;E 7D 7		string_point = (NEWSTRINGP *)Addr68k_from_LADDR(x);		st_length = string_point->totalsize;		string_base = (DLbyte *)Addr68k_from_LADDR(string_point->base);		string_base += string_point->offset ;E 7I 7    string_point = (NEWSTRINGP *)Addr68k_from_LADDR(x);D 13    st_length = string_point->totalsize;E 13I 13    st_length = string_point->fillpointer;E 13    string_base = (DLbyte *)Addr68k_from_LADDR(string_point->base);    string_base += string_point->offset ;E 7D 7		printf("%c" , DOUBLEQUOTE);	/* print %" */E 7I 7    printf("%c" , DOUBLEQUOTE);	/* print %" */E 7		D 7		for (i = 0 ; i <= st_length ; i++){D 5			printf("%c" , *string_base);E 5I 5			printf("%c" , GETBYTE(string_base));E 5			string_base++;			}E 7I 7    for (i = 0 ; i <= st_length ; i++)      {	printf("%c" , GETBYTE(string_base));	string_base++;      }E 7D 7		printf("%c" , DOUBLEQUOTE);	/* print %" */}E 7I 7    printf("%c" , DOUBLEQUOTE);	/* print %" */  }E 7I 12/************************************************************************//*									*//*			p r i n t _ f i x p				*//*									*//*	Print a lisp integer (but not a bignum!)			*//*									*//************************************************************************/E 12print_fixp(x)D 7LispPTR	x;{int	*addr_fixp;E 7I 7  LispPTR	x;  {    int	*addr_fixp;E 7D 7	addr_fixp = (int *)Addr68k_from_LADDR(x);	printf("%d" , *addr_fixp);}E 7I 7    addr_fixp = (int *)Addr68k_from_LADDR(x);    printf("%d" , *addr_fixp);  }E 7D 12	E 12I 12/************************************************************************//*									*//*			p r i n t _ f l o a t p				*//*									*//*	Print a lisp floating-point value.				*//*									*//************************************************************************/E 12D 8	E 8I 8print_floatp(x)  LispPTR	x;  {D 10    float	*addr_floatp;E 10I 10    float *addr_floatp;E 10    addr_floatp = (float *)Addr68k_from_LADDR(x);    printf("%f" , *addr_floatp); }E 8	E 1