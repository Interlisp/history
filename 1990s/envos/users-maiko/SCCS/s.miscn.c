h49597s 00006/00003/00203d D 1.16 92/11/25 21:09:38 sybalsky 16 15c Fixing endif's with extra text => comment. \nes 00002/00005/00204d D 1.15 92/06/26 13:50:02 sybalsky 15 14c retrofit of 386 unix changes \nes 00004/00004/00205d D 1.14 92/04/21 17:20:41 sybalsky 14 13c shortening file names for DOS \nes 00001/00001/00208d D 1.13 92/03/04 18:55:50 sybalsky 13 12c 386es 00003/00000/00206d D 1.12 92/01/29 14:56:44 sybalsky 12 11c Added foreign-function-call interface.es 00050/00000/00156d D 1.11 91/10/15 18:19:20 sybalsky 11 10c ISC changeses 00000/00000/00156d D 1.10 90/04/20 01:50:39 sybalsky 10 9c AIX:  shortening file names, bulk change.es 00032/00000/00124d D 1.9 89/12/29 13:01:40 sybalsky 9 8c Savoir changes -- LOOPS opcodeses 00011/00004/00113d D 1.8 89/12/28 15:27:16 sybalsky 8 7c es 00011/00000/00106d D 1.7 89/08/12 11:30:28 shih 7 6c added extra uraid casees 00008/00012/00098d D 1.6 89/06/19 12:21:51 shih 6 5c minor cleanupes 00012/00003/00098d D 1.5 89/04/28 16:55:17 sybalsky 5 4c cialles 00007/00002/00094d D 1.4 89/03/02 11:50:17 sybalsky 4 3c ci sxhash.ces 00004/00000/00092d D 1.3 89/02/28 03:59:34 sybalsky 3 2c Moved SXHASH to here.es 00034/00022/00058d D 1.2 88/11/08 17:28:57 krivacic 2 1c change to use EXT/RET interfacees 00080/00000/00000d D 1.1 88/11/07 18:13:59 krivacic 1 0c date and time created 88/11/07 18:13:59 by krivaciceuUf e 0tTI 1D 6/* This is G-file %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 6I 6/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 6static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";D 8/*D 6 *	Copyright (C) 1988 by Envos Inc. All rights reserved.E 6I 6 *	Copyright (C) 1988, 1989 by Envos Inc. All rights reserved.E 6 * */E 8I 8/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 8/***********************************************************//*		File Name:	miscn.c		Including:	OP_miscn*//***********************************************************/D 6 E 6I 6E 6#include "lispemul.h"#include "address.h"D 14#include "address68k.h"#include "lisptypes.h"E 14I 14#include "adr68k.h"#include "lsptypes.h"E 14#include "lispmap.h"D 14#include "emulglobal.h"#include "lispglobal.h"E 14I 14#include "emlglob.h"#include "lspglob.h"E 14#include "arith.h"#include "subrs.h"#include "profile.h"/***********************************************************//*D 2	Func Name  :	N_OP_miscnE 2I 2	Func Name  :	OP_miscnE 2D 2	Interface:	given TOPOFSTACK & Current Stack PTR	Returns:	if must UFN	-1			else		New TopOfStack 	Caller:		Must decrement Stackpointer by alpha byte - 1			and increment the PCE 2I 2	Interface:	Global Machine State	Returns:	(must UFN)D 5			0 = continue			1 = must UFNE 5I 5			0 = continue, C code succeeded.			1 = must UFN, C code failed.E 5E 2*//***********************************************************/D 2LispPTR N_OP_miscn(tos, stkptr, misc_index, arg_count)LispPTR tos;LispPTR *stkptr;int misc_index, arg_count;E 2I 2D 15int OP_miscn()E 2{E 15I 15int OP_miscn(misc_index, arg_count)E 15I 2D 6LispPTR *stkptr;E 6  int misc_index, arg_count;I 15{E 15E 2  register LispPTR *stk;D 2  register int  arg_num;E 2I 2  register int result;E 2D 5  static LispPTR args[30];E 5I 5  static LispPTR args[255];E 5D 15I 2	misc_index = Get_BYTE(PC+1);D 6	arg_count = Get_BYTE(PC+2);E 6I 6	arg_count  = Get_BYTE(PC+2);E 15E 6E 2/* Put the Args into a Vector */	args[0] = NIL_PTR;D 2	stk = stkptr;	arg_num = arg_count;E 2I 2	stk = ((LispPTR *) CurrentStackPTR) + 1;	{register int arg_num = arg_count;E 2	if (arg_num > 0)  {D 2		*stk++ = tos;		while(arg_num > 0)			 args[--arg_num] = *--stk;E 2I 2		*stk++ = (LispPTR) TopOfStack;		while(arg_num > 0) args[--arg_num] = *--stk;E 2		}I 2	}E 2I 2D 6		E 6E 2/* Select the Misc Number */switch(misc_index)  {D 6      case miscn_USER_SUBR: E 6I 6      case miscn_USER_SUBR:E 6	{register LispPTR user_subr, user_args;D 2	 register int result;E 2	 N_GETNUMBER(args[0], user_subr, do_ufn);	 if ((result = UserSubr(user_subr, arg_count-1, &args[1])) < 0)D 2		ERROR_EXIT(tos);	 return((LispPTR) result);E 2I 2		goto do_ufn;E 2	}	break;I 3D 4#ifdef SXHASHE 4      case miscn_SXHASH:  result = SX_hash(args);			  break;I 5E 5D 4#endifE 4I 4      case miscn_STRING_EQUAL_HASHBITS:			  result = STRING_EQUAL_HASHBITS(args);			  break;I 5E 5      case miscn_STRINGHASHBITS:			  result = STRING_HASHBITS(args);			  break;I 5      case miscn_VALUES:I 7			if ( arg_count > 255 ) {				error ( "miscn: arg_count too big! continue punts" );				goto do_ufn;				break;				}E 7			  result = values(arg_count, args);			  break;      case miscn_VALUES_LIST:I 7			/*** debugging: should be impossible, but ADB found this once -FS *****/			if ( arg_count > 255 ) {				error ( "miscn: arg_count too big! continue punts" );				goto do_ufn;				break;				}E 7			  result = values_list(arg_count, args);			  break;E 5E 4E 3I 9      case miscn_LCFetchMethod:			  result = LCFetchMethod(args[0],args[1]);			  if (result < 0) goto lc_ufn;			  break;      case miscn_LCFetchMethodOrHelp:			  result = LCFetchMethodOrHelp(args[0],args[1]);			  if (result < 0) goto lc_ufn;			  break;      case miscn_LCFindVarIndex:			  result = LCFindVarIndex(args[0],args[1]);			  if (result < 0) goto lc_ufn;			  break;      case miscn_LCGetIVValue:			  result = LCGetIVValue(args[0],args[1]);			  if (result < 0) goto lc_ufn;			  break;      case miscn_LCPutIVValue:			  result = LCPutIVValue(args[0],args[1],args[2]);			  if (result < 0) goto lc_ufn;			  break;I 11#ifdef RS232      case miscn_RAW_RS232C_OPEN:			if((result = raw_rs232c_open(args[0]))==NIL)				goto do_ufn;E 11I 11			break;      case miscn_RAW_RS232C_CLOSE:			if((result = raw_rs232c_close(args[0]))==NIL)				goto do_ufn;			break;      case miscn_RAW_RS232C_SETPARAM:			if((result = raw_rs232c_setparams(args[0],args[1]))						== NIL) goto do_ufn;			break;      case miscn_RAW_RS232C_GETPARAM:			/******/ break;      case miscn_RAW_RS232C_READ:			if((result = raw_rs232c_read(args[0],args[1],args[2]))				== NIL) goto do_ufn;			break;      case miscn_RAW_RS232C_WRITE:			if((result = raw_rs232c_write(args[0],args[1],args[2]))				== NIL) goto do_ufn;			break;      case miscn_RAW_RS232C_SETINT:			if((result = raw_rs232c_setint(args[0],args[1]))				==NIL) goto do_ufn;			break;      case miscn_CHATTER:                        result = chatter(args);                        break;D 16#endif RS232E 16I 16#endif /* RS232 */E 16#ifdef JLISP      case miscn_EJLISP:#ifndef NOWNN                        result = ejlisp(args);#endif                        break;D 16#endif JLISPE 16I 16#endif /* JLISP */E 16#ifdef CDROM      case miscn_CDAUDIO:                        result = cdaudio(args);                        break;      case miscn_CDROM:                        result = cdrom(args);                        break;D 16#endif CDROME 16I 16#endif /* CDROM */E 16I 12D 13      case /* miscn_CALL_C*/ 014: result = call_c_fn(args);E 13I 13      case /* miscn_CALL_C*/ 014:/* result = call_c_fn(args); */E 13			 break;E 12E 11E 9D 6      default : E 6I 6      default :E 6D 2	ERROR_EXIT(tos);E 2I 2	goto do_ufn;E 2	break;D 6 E 6I 6E 6  }/* switch end */I 2D 6E 6/* Setup Global Machine State for a Normal Return */	PC += 3;	CurrentStackPTR = (DLword *) (stk - 1);D 6	TopOfStack = (LispPTR)  result;E 6I 6	TopOfStack = (LispPTR) result;E 6	return(0);/* A UFN request, so return 1 & don't change the Machine State */E 2do_ufn:D 2	ERROR_EXIT(tos);E 2I 2	return(1);I 9lc_ufn:	if (result == -2) {	  return(0);		/* have built new stack frame */	}else{	  goto do_ufn;	}E 9E 2D 2}/* N_OP_miscn */E 2I 2}/* OP_miscn */E 2E 1