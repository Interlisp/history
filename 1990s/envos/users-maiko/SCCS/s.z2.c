h58067s 00021/00016/00163d D 2.16 93/02/08 15:01:41 sybalsky 18 17c Big VM (and new CDR coding) changes for 3.0 \nes 00004/00004/00175d D 2.15 92/04/21 17:29:39 sybalsky 17 16c shortening file names for DOS \nes 00012/00001/00167d D 2.14 90/06/04 18:10:57 sybalsky 16 15c reformat, copyrightes 00000/00000/00168d D 2.13 90/04/20 02:09:36 sybalsky 15 14c AIX:  shortening file names, bulk change.es 00003/00003/00165d D 2.12 90/02/06 11:51:30 sybalsky 14 13c Comments, timer-interrupt fixes to FMEMB, CL:ASSOCes 00015/00018/00153d D 2.11 89/01/09 17:24:53 shih 13 12c spellinges 00002/00002/00169d D 2.10 89/01/09 16:02:05 shih 12 11c spellinges 00010/00021/00161d D 2.9 88/10/12 14:46:29 krivacic 11 10c new out-of-line interfacees 00000/00002/00182d D 2.8 88/10/10 14:11:34 krivacic 10 9c sun3/4 mergees 00004/00004/00180d D 2.7 88/07/29 17:36:44 shimizu 9 8c Add SAVE_ERROR_EXIT and S_N_CHECKANDCADes 00010/00004/00174d D 2.6 88/07/27 17:34:34 shimizu 8 7c Enable to continue the execution for timer interrupt;clfmemb&classoces 00004/00005/00174d D 2.5 88/07/08 11:00:16 bane 7 6c Fixed N_OP in bad context bug in CLFMEMBes 00023/00021/00156d D 2.4 88/06/29 15:12:45 bane 6 5c improved cl:fmemb and cl:assoces 00003/00004/00174d D 2.3 88/06/11 11:56:12 charnley 5 4c fixed restlist opcode.es 00005/00005/00173d D 2.2 88/06/08 09:47:05 charnley 4 3c added interrupt test to inner loops of cl fmemb and cl assoces 00000/00000/00178d D 2.1 88/05/17 09:28:04 hayata 3 2c Version up to 2.1es 00004/00004/00174d D 1.2 88/05/09 21:15:10 shih 2 1c Use GCLOOKUPes 00178/00000/00000d D 1.1 88/05/06 16:19:42 charnley 1 0c date and time created 88/05/06 16:19:42 by charnleyeuUtTI 1D 4/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 4I 4D 8/* This is G-file @(#) z2.c Version 1.2 (5/9/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) z2.c	1.2 5/9/88";E 8I 8D 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 12I 12D 13/* This is G-file @(#) z2.c Version 2.9 (10/12/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) z2.c	2.9 10/12/88";E 13I 13D 14/* %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 14I 14D 16/* @(#) z2.c Version 2.11 (1/9/89). copyright Xerox & Fuji Xerox  */E 16I 16D 18/* @(#) z2.c Version 2.11 (1/9/89). copyright Venue & Fuji Xerox  */E 16static char *id = "@(#) z2.c	2.11 1/9/89";E 18I 18/* %Z% %M% Version %I% (%G%). copyright venue   */static char *id = "%Z% %M%	%I% %G%	(venue)";E 18E 14E 13E 12E 8E 4/*D 13 *	Copyright (C) 1988 by XEROX, All rights reserved. * *	Auther :  don charnley *E 13I 13 *	Author :  don charnleyE 13 *//***********************************************************************//*D 13 		File Name :	z2.cE 13I 13		File Name :	z2.cE 13		Including :	N_OP_clfmemb   -- op 035				N_OP_classoc   -- op 033				N_OP_restlist  -- op 043D 13				E 13I 13E 13*//**********************************************************************/I 16I 18E 18/************************************************************************//*									*/D 18/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 18I 18/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 18/*									*/D 18/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 18I 18/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 18/*									*//************************************************************************/E 16D 18E 18#include <stdio.h>#include "lispemul.h"D 17#include "emulglobal.h"#include "lispglobal.h"E 17I 17#include "emlglob.h"#include "lspglob.h"E 17#include "lispmap.h"D 17#include "lisptypes.h"E 17I 17#include "lsptypes.h"E 17#include "address.h"D 17#include "address68k.h"E 17I 17#include "adr68k.h"E 17D 13#include "cell.h"    E 13I 13#include "cell.h"E 13#include "stack.h"D 13#include "gc.h"    #include "my.h"    E 13I 13#include "gc.h"#include "my.h"E 13I 4D 10extern int Irq_Stk_End;E 4E 10struct cadr_cell cadr();/*   N_OP_classoc()  OP 33Q  */D 11N_OP_classoc(key, list, error_addr)int *error_addr;E 11I 11N_OP_classoc(key, list)E 11LispPTR	key, list;{register struct cadr_cell cadr1;D 6register struct cadr_cell cadr2;E 6D 18register LispPTR	cdr;	/* address of (cdr A-list); Lisp address */E 18I 18register LispPTR	cdrcell;	/* address of (cdr A-list); Lisp address */E 18D 6register LispPTR	caar;	/* address of (caar A-list); Lisp address */E 6D 11#ifdef	TRACE	printf("TRACE: N_OP_classoc()\n");#endifE 11D 18  switch (key & 0xFF0000) {E 18I 18  switch (key & SEGMASK) {E 18    case S_POSITIVE:   break;    case S_NEGATIVE:   break;    case S_CHARACTER:  break;    case ATOMS_OFFSET: break;D 9    default: ERROR_EXIT(error_addr);E 9I 9D 11    default: SAVE_ERROR_EXIT(list,error_addr);E 11I 11    default: ERROR_EXIT(list);E 11E 9  }I 6  /* JRB - Don Charnley claims the code below should be identical to the	code in IL:ASSOC, so I copied my new and exciting version over */E 6	if (list == NIL_PTR) { return(NIL_PTR); }D 13	E 13I 13E 13	if (GetTypeNumber( list ) != TYPE_LISTP) { return(NIL_PTR); }D 13	I 6	E 13I 13E 13E 6D 9	N_CHECKANDCADR(list, cadr1, error_addr);E 9I 9D 11	S_N_CHECKANDCADR(list, cadr1, error_addr,list);E 11I 11	S_N_CHECKANDCADR(list, cadr1, list);E 11E 9D 6	/* cadr1 = cadr(list); */E 6	do{D 18		cdr = cadr1.cdr_cell;	/* the rest of A-list */E 18I 18		cdrcell = cadr1.cdr_cell;	/* the rest of A-list */E 18D 6		N_CHECKANDCADR(cadr1.car_cell, cadr2, error_addr);		/* cadr2 = cadr(cadr1.car_cell); */		if(key == cadr2.car_cell){E 6I 6D 7		if(GetTypeNumber(cadr1.car_cell) == TYPE_LISTP		&& key == N_OP_car(cadr1.car_cell, error_addr)){E 7I 7		if(Listp(cadr1.car_cell) && key == car(cadr1.car_cell)){E 7E 6		/* cons data found */			return(cadr1.car_cell);		}		/* search the rest of A-list */I 6D 7		if(GetTypeNumber(cdr) == TYPE_LISTP)E 7I 7D 18		if(Listp(cdr))E 7			cadr1 = cadr(cdr);		else cdr = NIL;E 18I 18		if(Listp(cdrcell))			cadr1 = cadr(cdrcell);		else cdrcell = NIL;E 18		/* check for interrupts and punt to handle one safely */E 6I 4D 8		if (!Irq_Stk_End) ERROR_EXIT(error_addr);E 8I 8		if (!Irq_Stk_End) {D 18			TopOfStack = cdr; /* for continuation */D 11			TIMER_EXIT(error_addr);E 11I 11D 14			TIMER_EXIT(list);E 14I 14			TIMER_EXIT(cdr);E 18I 18			TopOfStack = cdrcell; /* for continuation */			TIMER_EXIT(cdrcell);E 18E 14E 11		}E 8E 4D 6		N_CHECKANDCADR(cadr1.cdr_cell, cadr1, error_addr);		/* cadr1 = cadr(cadr1.cdr_cell); */E 6D 18	}while(cdr != NIL_PTR);E 18I 18	}while(cdrcell != NIL_PTR);E 18	return(NIL_PTR);} /* end N_OP_classoc() *//*   (CL:FMEMB item list)  OP 35Q  */D 11N_OP_clfmemb(item, list, error_addr)E 11I 11N_OP_clfmemb(item, list)E 11register LispPTR item, list;{  /* OP 35Q */D 6register struct cadr_cell cadrobj;struct cadr_cell cadr();E 6D 11#ifdef	TRACE	printf("TRACE: N_OP_clfmemb()\n");#endifE 11D 18  switch (item & 0xFF0000) {E 18I 18  switch (item & SEGMASK) {E 18    case S_POSITIVE:   break;    case S_NEGATIVE:   break;    case S_CHARACTER:  break;    case ATOMS_OFFSET: break;D 9    default: ERROR_EXIT(error_addr);E 9I 9D 11    default: SAVE_ERROR_EXIT(list,error_addr);E 11I 11    default: ERROR_EXIT(list);E 11E 9  }D 6  if(list != NIL_PTR)    {N_CHECKANDCADR(list, cadrobj, error_addr);      while (cadrobj.car_cell != item)	  {		if (cadrobj.cdr_cell == NIL_PTR) return(NIL_PTR);		list = cadrobj.cdr_cell;I 4		if (!Irq_Stk_End) ERROR_EXIT(error_addr);E 4		N_CHECKANDCADR(cadrobj.cdr_cell, cadrobj, error_addr);	  }   }  return(list);E 6I 6  /* JRB - Don Charnley claims the code below should be identical to IL:FMEMB,	so I copied it */	while(Listp(list)) {D 7		if(item == N_OP_car(list, error_addr))E 7I 7		if(item == car(list))E 7			return list;D 7		list = N_OP_cdr(list, error_addr);E 7I 7		list = cdr(list);E 7		/* if we get an interrupt, punt so we can handle it safely */D 8		if(!Irq_Stk_End) ERROR_EXIT(error_addr);E 8I 8		if(!Irq_Stk_End) {			TopOfStack = list; /* for continuation */D 11			TIMER_EXIT(error_addr);E 11I 11			TIMER_EXIT(list);E 11		}E 8	}D 9	if(list) ERROR_EXIT(error_addr);E 9I 9D 11	if(list) SAVE_ERROR_EXIT( list,error_addr);E 11I 11	if(list) ERROR_EXIT( list);E 11E 9	return list;E 6} /* end N_OP_clfmemb() *//************************************************************	 43      RESTLISTD 13  	alpha = skip  --  number of args to skipE 13I 13	alpha = skip  --  number of args to skipE 13	tos = last  --  last arg#	tos-1 = tail	IF tail = NIL THEND 13		page _ NEXTCONSPAGE  E 13I 13		page _ NEXTCONSPAGEE 13		GOTO make	ELSE		AddRef tail		page _ CONSPAGE[tail]		GOTO make	make:		get [cnt,,next] from page	make1:		tail _ CONSCELL (CAR = IVar(last), CDR = tail)		AddRef IVar(last)		IF skip = last THEN GOTO fin		last _ last - 1		GOTO make1	noroomonconspage:	fin:		store updated [cnt,,next]		update ListpDTD:COUNTER		DelRef tail		IF noroomonconspage THEN UFN		ELSEIF ListpDTD:COUNTER overflow then GCPUNT		ELSEIF overflow entries then GCHANDLEOVERFLOW		ELSE NEXTOPCODED 13 	alpha = skip  --  number of args to skipE 13I 13	alpha = skip  --  number of args to skipE 13	tos = last  --  last arg#	tos-1 = tail	AddRef tailD 2make1:	tail ¬ cons(IVar(last), tail)E 2I 2make1:	tail , cons(IVar(last), tail)E 2	AddRef IVar(last)	IF skip = last THEN GOTO fin	last _ last - 1	GOTO make1fin:	DelRef tail***********************************************************/D 11N_OP_restlist(tail, last, skip, error_addr)E 11I 11N_OP_restlist(tail, last, skip)E 11register LispPTR tail;D 11register int last, skip, error_addr;E 11I 11register int last, skip;E 11{D 11#ifdef	TRACE	printf("TRACE: N_OP_restlist()\n");#endifE 11D 5	printf("CHECK: N_OP_restlist()\n");E 5  last &= 0xFFFF;D 2  gclookup(0x8000|ADDREF, tail);E 2I 2D 4  GCLOOKUP(0x8000,ADDREF, tail);E 4E 2D 5  while (skip < last) {    tail = cons(GetLongWord(IVar + (last-- << 1)), tail);E 5I 5  while (skip <= last) {    tail = cons(GetLongWord(IVar + (--last << 1)), tail);E 5D 2    gclookup(0x8000|ADDREF, tail);E 2I 2D 4    GCLOOKUP(0x8000,ADDREF, tail);E 4E 2  }D 2  gclookup(0x8000|DELREF, tail);E 2I 2D 4  GCLOOKUP(0x8000,DELREF, tail);E 4E 2D 5  return(last | S_POSITIVE);E 5I 5  return(tail);E 5}/* end N_OP_restlist() */     /* end module */E 1