h42692s 00208/00185/00613d D 1.9 91/07/11 12:10:52 sybalsky 9 8c Dec3100 changes for beg atomses 00000/00005/00798d D 1.8 91/05/01 18:12:57 sybalsky 8 7c Retrofit changes from MIPS porting center.es 00038/00024/00765d D 1.7 91/02/04 12:51:11 sybalsky 7 6c Fix errors in teh Savoir retrofit (placement of ifdefs &c)es 00020/00007/00769d D 1.6 91/01/25 17:54:35 sybalsky 6 5c Fix up 3-byte handling in stack dumping fnses 00002/00000/00774d D 1.5 90/12/10 23:41:19 sybalsky 5 4c Cut out BIG NAMETABLE change while I debug 3-byte atoms elsewhere -- JDSes 00185/00018/00589d D 1.4 90/07/25 20:31:32 osamu 4 3c Change for expanding name-table. This changes work when #ifdef BIGATOMSes 00000/00000/00607d D 1.3 90/04/20 01:26:31 sybalsky 3 2c shortening file names, bulk change.es 00000/00002/00607d D 1.2 90/04/19 21:58:26 sybalsky 2 1c Fix check-in mistake in headeres 00609/00000/00000d D 1.1 90/04/19 21:03:47 sybalsky 1 0c date and time created 90/04/19 21:03:47 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";D 2/* @(#) Kdebugtools.c Version 2.6 (3/30/89). copyright envos & Fuji Xerox  */static char *id = "@(#) Kdebugtools.c	2.6 3/30/89";E 2/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************//***************************************************************//*	file name :	 Kdebugtools.c	For Debugging Aids	Including :		get_ivar_name(fx_addr68k , offset)		date :   25 Aug 1987	NMitani		changed: 09 Sep 1987 NMitani*//***************************************************************/#include <stdio.h>#include  <setjmp.h>#include "lispemul.h"#include "lispmap.h"#include "address68k.h"#include "lisptypes.h"#include "lispglobal.h"#include "emulglobal.h"#include "cell.h"#include "stack.h"I 5D 6#undef BIGATOMS		/* * * * * * * * untiol 3-byte atoms are in * * */E 6E 5#define	LOCAL_PVAR	0xFFFFI 4#ifdef BIGATOMS#define	VTY_IVAR	0x00000000#define	VTY_PVAR	0x80000000#define VTY_FVAR	0xC0000000#define NT_OFFSET_MASK  0xFFFFFF#define GetNTEntry(X)   GetLongWord(X)#define NAMETABLE       LispPTR#elseE 4#define	VTY_IVAR	0x0000#define	VTY_PVAR	0x8000#define VTY_FVAR	0xC000I 4#define NT_OFFSET_MASK  0xFF#define GetNTEntry(X)   GETWORD(X)#define NAMETABLE       DLword#endifE 4#define URMAXFXNUM		2000#define URSCAN_ALINK		0#define URSCAN_CLINK		1extern int URaid_scanlink;extern int URaid_currentFX;extern FX *URaid_FXarray[];extern int URaid_ArrMAXIndex;int BT_lines;int BT_temp;jmp_buf BT_jumpbuf;#define BTMAXLINE 30#define BT_morep if(++BT_lines>BTMAXLINE){\			 printf("Press Return(to quit Esc and Ret):");\			 BT_temp=getchar();\			 fflush(stdin);\			 BT_lines=0; \			 if(BT_temp==27)longjmp(BT_jumpbuf,1) ; \		}/***************************************************************//*	Func Name :	get_ivar_name	Desc :		returns atom index of ivar on the given			FX.			If ivar is localvars then set *localivar			1 otherwize 0.	Changed		25 Aug 1987	NMitani*//***************************************************************/LispPTR get_ivar_name(fx_addr68k , offset , localivar)  struct frameex1 *fx_addr68k ;  DLword offset ;  int *localivar ;  {D 4    DLword		*first_table;    DLword		*second_table;E 4I 4    NAMETABLE		*first_table;    NAMETABLE		*second_table;E 4    struct fnhead	*fnobj;    int		i;    fnobj = (struct fnhead *)Addr68k_from_LADDR(		((int)(fx_addr68k)->hi2fnheader << 16) | (fx_addr68k)->lofnheader);    if (fnobj->ntsize > 0)      {	/* name table exists */D 4	first_table = (DLword *)(fnobj + 1);	second_table = first_table + fnobj->ntsize;	for(i = 0; (i < fnobj->ntsize) && (GETWORD(second_table) != offset) ;E 4I 4	first_table = (NAMETABLE *)(fnobj + 1);	second_table =(NAMETABLE *)((DLword *)first_table + fnobj->ntsize);	for(i = 0; (i < fnobj->ntsize) && (GetNTEntry(second_table) != offset) ;E 4	first_table++ , second_table++ , i++) ;D 4	if ((i < fnobj->ntsize) && (GETWORD(first_table) != 0))E 4I 4	if ((i < fnobj->ntsize) && (GetNTEntry(first_table) != 0))E 4	  {	    /* target ivar was in name table */	    *localivar = 0 ;D 4	    return((LispPTR)(GETWORD(first_table)));E 4I 4	    return((LispPTR)(GetNTEntry(first_table)));E 4	  }	else	  {	    /* Target ivar is in locar vars table */D 4	    first_table = (DLword *)(fnobj + 1) + (fnobj->ntsize << 1);E 4I 4	    first_table = (NAMETABLE *)(fnobj + 1) + (fnobj->ntsize << 1);#ifdef BIGATOMS	    second_table = first_table + (((DLword *)fnobj						    + (fnobj->startpc >> 1) 						    - (DLword *)first_table) >> 2);#elseE 4	    second_table = first_table + (((DLword *)fnobj +				(fnobj->startpc >> 1) - first_table) >> 1);I 4#endifE 4	  }      }    else      {	/* name table doesn't exist, so all ivars are in locar vars table */D 4	first_table = (DLword *)(fnobj + 1) +  4;E 4I 4#ifdef BIGATOMSD 6	first_table = (NAMETABLE *)((fnobj + 1) +  (4>>1));E 6I 6	first_table = (NAMETABLE *)(fnobj + 1) +  (4>>1);E 6	second_table = first_table + (((DLword *)fnobj					      + (fnobj->startpc >> 1)					      - (DLword *)first_table) >> 1);#else	first_table = (NAMETABLE *)(fnobj + 1) +  4;E 4	second_table = first_table +	(((DLword *)fnobj + (fnobj->startpc >> 1) - first_table) >> 1);I 4#endifE 4      }I 6#ifdef BIGATOMS    while (*(second_table) != (VTY_IVAR |offset))#elseE 6    while (GETWORD(second_table) != (VTY_IVAR |offset))I 6#endif BIGATOMSE 6      {	first_table++ ;	second_table++ ;      }    *localivar = 1 ;I 6#ifdef BIGATOMS    return((LispPTR)( *(first_table)));#elseE 6    return((LispPTR)(GETWORD(first_table)));I 6#endif BIGATOMSE 6 }/* end get_ivar_name *//***************************************************************//*	Func Name :	get_pvar_name	Desc :		returns atom index of pvar on the given			FX or LOCAL_PVAR if that pvar is localvars.	Changed		26 Aug 1987	NMitani*//***************************************************************/LispPTR get_pvar_name(fx_addr68k , offset)  struct frameex1 *fx_addr68k ;  DLword offset ;  {D 4    DLword		*first_table;    DLword		*second_table;E 4I 4    NAMETABLE		*first_table;    NAMETABLE		*second_table;E 4    struct fnhead	*fnobj;    int		i;    fnobj = (struct fnhead *)Addr68k_from_LADDR(	     ((int)(fx_addr68k)->hi2fnheader << 16) | (fx_addr68k)->lofnheader);D 4    first_table = (DLword *)(fnobj + 1);    second_table = first_table + fnobj->ntsize;E 4I 4    first_table = (NAMETABLE *)(fnobj + 1);    second_table =(NAMETABLE *)((DLword *)first_table + fnobj->ntsize);E 4    if (first_table == second_table) return(LOCAL_PVAR);  /* no name table */    for(i = 0;I 4#ifdef BIGATOMSD 6        i < (fnobj->ntsize >> 1) && GETWORD(second_table) != (VTY_PVAR | offset);E 6I 6        i < (fnobj->ntsize >> 1) && *(second_table) != (VTY_PVAR | offset);E 6#elseE 4        i < fnobj->ntsize && GETWORD(second_table) != (VTY_PVAR | offset);I 4#endifE 4	first_table++ , second_table++ , i++) /* Do nothing */;I 4#ifdef BIGATOMSD 6    if (i < (fnobj->ntsize >> 1)) return((LispPTR)GETWORD(first_table));E 6I 6    if (i < (fnobj->ntsize >> 1)) return((LispPTR) *(first_table));E 6#elseE 4    if (i < fnobj->ntsize) return((LispPTR)GETWORD(first_table));I 4#endifE 4    else return(LOCAL_PVAR);	/* Pvar was local */  }/* end get_pvar_name */D 7/***************************************************************//*	Func Name :	get_fvar_nameE 7I 7/************************************************************************//*									*//*			g e t _ f n _ f v a r _ n a m e			*//*									*//*	Given (LISP) codeblock addr and an offset return fvar's name	*//*									*//************************************************************************/E 7D 7	Desc :		returns atom index of fvar on the given			FX.	Changed		26 Aug 1987	NMitani*//***************************************************************/LispPTR get_fvar_name(fx_addr68k , offset)  struct frameex1 *fx_addr68k ;E 7I 7LispPTR get_fn_fvar_name(fnhdr , offset)  LispPTR fnhdr;E 7  DLword offset ;  {D 4    DLword		*first_table;    DLword		*second_table;E 4I 4    NAMETABLE		*first_table;    NAMETABLE		*second_table;E 4    struct fnhead	*fnobj;D 7    fnobj = (struct fnhead *)Addr68k_from_LADDR(	    ((int)(fx_addr68k)->hi2fnheader << 16) | (fx_addr68k)->lofnheader);E 7I 7    fnobj = (struct fnhead *)Addr68k_from_LADDR(fnhdr);E 7D 4    first_table = (DLword *)fnobj + fnobj->fvaroffset;    second_table = first_table + fnobj->ntsize;E 4I 4    first_table = (NAMETABLE *)((DLword *)fnobj + fnobj->fvaroffset);    second_table =(NAMETABLE *)((DLword *)first_table + fnobj->ntsize);E 4D 6E 6I 6#ifdef BIGATOMS    while (*(second_table) != (VTY_FVAR | offset))#elseE 6    while (GETWORD(second_table) != (VTY_FVAR | offset))I 6#endif BIGATOMSE 6      {	first_table++ ;	second_table++;      }D 6E 6I 6#ifdef BIGATOMS    return((LispPTR) *(first_table));#elseE 6    return((LispPTR)GETWORD(first_table));I 6#endif BIGATOMSE 6  }/* end get_fvar_name */I 7E 7/************************************************************************//*									*/I 7/*			g e t _ f v a r _ n a m e			*//*									*//*	Given an FX and fvar offset, return the atom# for the fvar.	*//*									*//************************************************************************/LispPTR get_fvar_name(fx_addr68k , offset)  struct frameex1 *fx_addr68k ;  DLword offset ;  {    get_fn_fvar_name(	    ((int)(fx_addr68k)->hi2fnheader << 16) | (fx_addr68k)->lofnheader, offset);  }/* end get_fvar_name *//************************************************************************//*									*/E 7/*				s f					*//*									*//*	Dump the contents of a single frame, given the address of 	*//*	the frame as a NATIVE address.					*//*									*//*									*//*									*//************************************************************************/sf(fx_addr68k)  struct frameex1 *fx_addr68k ;D 9{  Bframe *bf;  DLword *next68k ;  DLword *ptr ;  DLword *ptrhi ;  DLword *ptrlo ;  LispPTR atomindex ;  int i;  DLword npvar;  DLword max_npvar;  LispPTR pvarindex ;  DLword nfvar;  struct fnhead	*fnobj;  int localivar;  LispPTR ivarindex ;E 9I 9  {    Bframe *bf;    DLword *next68k ;    DLword *ptr ;    DLword *ptrhi ;    DLword *ptrlo ;    LispPTR atomindex ;    int i;    DLword npvar;    DLword max_npvar;    LispPTR pvarindex ;    DLword nfvar;    struct fnhead	*fnobj;    int localivar;    LispPTR ivarindex ;E 9D 9  BT_lines=0; if((int)fx_addr68k == 0) return(-1); if((fx_addr68k)->flags != STK_FX){E 9I 9    BT_lines=0;    if((int)fx_addr68k == 0) return(-1);    if((fx_addr68k)->flags != STK_FX)      {E 9	printf("Invalid FX 0x%x, flags = 0x%x.\n",		LADDR_from_68k(fx_addr68k),		(fx_addr68k)->flags);	return(-1);D 9 }E 9I 9      }E 9D 9 if(((fx_addr68k)->alink & 1)==0)  {   /* FAST */E 9I 9    if(((fx_addr68k)->alink & 1)==0)      {   /* FAST */E 9	bf = (Bframe *)(((DLword *)fx_addr68k)  - 2 );D 9  }  else  {   /* SLOW */E 9I 9      }    else      {   /* SLOW */E 9	bf =(Bframe *) Addr68k_from_LADDR(((fx_addr68k)->blink+ STK_OFFSET)) ;D 9  }E 9I 9      }E 9D 9/* Print IVARs */  printf("IVAR -------\n");BT_morep;E 9I 9    /* Print IVARs */    printf("IVAR -------\n");BT_morep;E 9D 9  ptr = Addr68k_from_LADDR( STK_OFFSET + bf->ivar); i=0; while(ptr!=(DLword *)bf){  ptrhi = ptr;  ptrlo = ptr + 1 ;  printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr), GETWORD(ptr) , GETWORD(ptrlo));  ivarindex = get_ivar_name(fx_addr68k , i++ , &localivar);  if (localivar == 1)	printf("*local* ");  print_atomname(ivarindex);  printf("  ");  print(*(LispPTR *)ptr);  putchar('\n');BT_morep;  ptr += 2 ;} putchar('\n');BT_morep; printf("## STACK BF at 0x%x ##\n",(LispPTR)LADDR_from_68k(bf));BT_morep;/* print BF  */ if(bf->flags != 4)	{printf("Invalid frame, NOT a BX\n");return(-1);} putchar('[');  if (bf->residual)	printf("Res, ");  if (bf->padding)	printf("Pad, ");  printf("cnt=%d ]\n",bf->usecnt);BT_morep;  printf("ivar : 0x%x\n",bf->ivar);BT_morep;E 9I 9    ptr = Addr68k_from_LADDR( STK_OFFSET + bf->ivar);    i=0;    while(ptr!=(DLword *)bf)      {	ptrhi = ptr;	ptrlo = ptr + 1 ;	printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),	       GETWORD(ptr) , GETWORD(ptrlo));	ivarindex = get_ivar_name(fx_addr68k , i++ , &localivar);	if (localivar == 1) printf("*local* ");	print_atomname(ivarindex);	printf("  ");	print(*(LispPTR *)ptr);	putchar('\n');BT_morep;	ptr += 2 ;      }    putchar('\n');BT_morep;    printf("## STACK BF at 0x%x ##\n",(LispPTR)LADDR_from_68k(bf));BT_morep;E 9D 9    printf(">> Bf's ivar says 0x%x vs. IVar says 0x%x\n",bf->ivar+STK_OFFSET,LADDR_from_68k(IVar));BT_morep;E 9I 9    /* print BF  */    if(bf->flags != 4) {printf("Invalid frame, NOT a BX\n");return(-1);}    putchar('[');    if (bf->residual)	printf("Res, ");    if (bf->padding)	printf("Pad, ");    printf("cnt=%d ]\n",bf->usecnt);BT_morep;    printf("ivar : 0x%x\n",bf->ivar);BT_morep;E 9I 9    printf(">> Bf's ivar says 0x%x vs. IVar says 0x%x\n",	   bf->ivar+STK_OFFSET,LADDR_from_68k(IVar));BT_morep;E 9D 9  atomindex = get_framename(fx_addr68k);  printf("Fname is ");D 7  print_atomname(atomindex);E 7I 7  print(atomindex);E 7  printf("\n");BT_morep;E 9D 9/***** printout FX ****/  printf("## STACK FX at 0x%x ##\n",LADDR_from_68k(fx_addr68k));BT_morep;E 9I 9    atomindex = get_framename(fx_addr68k);    printf("Fname is ");    print(atomindex);    printf("\n");BT_morep;E 9D 9  if((fx_addr68k)->flags != 6)   { printf("Invalid frame, NOT FX\n");return(-1);}E 9I 9    /***** printout FX ****/    printf("## STACK FX at 0x%x ##\n",LADDR_from_68k(fx_addr68k));BT_morep;E 9D 9 putchar('[');  if((fx_addr68k)->fast)		printf("F, ");  if((fx_addr68k)->incall)	printf("incall, ");  if(fx_addr68k->validnametable)	printf("V, ");  printf("cnt = %d ]\n",fx_addr68k->usecount);BT_morep;E 9I 9    if((fx_addr68k)->flags != 6)      { printf("Invalid frame, NOT FX\n");return(-1);}E 9D 9  printf(" #alink           0x%x ",fx_addr68k->alink);  if(fx_addr68k->alink & 1)  printf("[SLOWP]\n");  else printf("\n");E 9I 9    putchar('[');    if((fx_addr68k)->fast)		printf("F, ");    if((fx_addr68k)->incall)	printf("incall, ");    if(fx_addr68k->validnametable)	printf("V, ");    printf("cnt = %d ]\n",fx_addr68k->usecount);BT_morep;E 9D 9 BT_morep;E 9I 9    printf(" #alink           0x%x ",fx_addr68k->alink);E 9D 9  printf(" fnheadlo         0x%x \n",fx_addr68k->lofnheader);BT_morep;  printf(" hi1,hi2 fnhead   0x%x , 0x%x \n",fx_addr68k->hi1fnheader,fx_addr68k->hi2fnheader);BT_morep;  printf(" nextblock        0x%x \n",fx_addr68k->nextblock);BT_morep;  printf(" pc               0x%x \n",fx_addr68k->pc);BT_morep;  printf(" lonametbl        0x%x \n",fx_addr68k->lonametable);BT_morep;  printf(" hi1,hi2 nametbl  0x%x , 0x%x  \n",fx_addr68k->hi1nametable,fx_addr68k->hi2nametable);BT_morep;  printf(" #blink           0x%x \n",fx_addr68k->blink);BT_morep;  printf(" #clink           0x%x \n",fx_addr68k->clink);BT_morep;E 9I 9    if(fx_addr68k->alink & 1) printf("[SLOWP]\n");    else printf("\n");E 9D 9/* added by NMitani 26 Aug 87 */E 9I 9   BT_morep;E 9D 9 fnobj = (struct fnhead *)Addr68k_from_LADDR(E 9I 9    printf(" fnheadlo         0x%x \n",fx_addr68k->lofnheader);BT_morep;    printf(" hi1,hi2 fnhead   0x%x , 0x%x \n",	   fx_addr68k->hi1fnheader,fx_addr68k->hi2fnheader);BT_morep;    printf(" nextblock        0x%x \n",fx_addr68k->nextblock);BT_morep;    printf(" pc               0x%x \n",fx_addr68k->pc);BT_morep;    printf(" lonametbl        0x%x \n",fx_addr68k->lonametable);BT_morep;    printf(" hi1,hi2 nametbl  0x%x , 0x%x  \n",	   fx_addr68k->hi1nametable,fx_addr68k->hi2nametable);BT_morep;    printf(" #blink           0x%x \n",fx_addr68k->blink);BT_morep;    printf(" #clink           0x%x \n",fx_addr68k->clink);BT_morep;    /* added by NMitani 26 Aug 87 */    fnobj = (struct fnhead *)Addr68k_from_LADDR(E 9		((int)fx_addr68k->hi2fnheader << 16) | fx_addr68k->lofnheader);D 9 max_npvar = npvar = fnobj->nlocals;	/* npvar is number of Pvars */ if (fnobj->fvaroffset)D 4  nfvar = GETWORD((DLword *)fnobj + fnobj->fvaroffset + fnobj->ntsize) & 0xFF;E 4I 4  nfvar = GETWORD((NAMETABLE *)E 9I 9    max_npvar = npvar = fnobj->nlocals;	/* npvar is number of Pvars */    if (fnobj->fvaroffset)#ifdef BIGATOMS      nfvar = *((NAMETABLE *)#else      nfvar = GETWORD((NAMETABLE *)#endif BIGATOMSE 9		  ((DLword *)fnobj + fnobj->fvaroffset + fnobj->ntsize)) & NT_OFFSET_MASK;E 4D 9 else  nfvar = 0; if (fx_addr68k == CURRENTFX) {E 9I 9    else nfvar = 0;    if (fx_addr68k == CURRENTFX)      {E 9	ptr=PVar;	i = 0;D 9	while(npvar-- > 0){		ptrhi = ptr;		ptrlo = ptr + 1 ;		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,E 9I 9	while(npvar-- > 0)	  {	    ptrhi = ptr;	    ptrlo = ptr + 1 ;	    printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,E 9			GETWORD(ptrlo));D 9		if ((pvarindex = get_pvar_name(fx_addr68k , i++)) == LOCAL_PVAR)E 9I 9	    if ((pvarindex = get_pvar_name(fx_addr68k , i++)) == LOCAL_PVAR)E 9			printf("*local* [pvar%d] " , (i - 1));D 9		elseE 9I 9	    elseE 9			print_atomname(pvarindex);D 9		if (GETWORD(ptr) == 0xFFFF){			printf("  [variable not bound]\n");BT_morep;		}		else{			printf("  ");			print(*(LispPTR *)ptr);			putchar('\n');		BT_morep;		}		ptr += 2 ;	}E 9I 9	    if (GETWORD(ptr) == 0xFFFF)	      {		printf("  [variable not bound]\n");BT_morep;	      }	    else	      {		printf("  ");		print(*(LispPTR *)ptr);		putchar('\n');		BT_morep;	      }	    ptr += 2 ;	  }E 9	i = max_npvar;D 9	while(nfvar && nfvar-- >= max_npvar){		ptrhi = ptr;		ptrlo = ptr + 1 ;		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,E 9I 9	while(nfvar && nfvar-- >= max_npvar)	  {	    ptrhi = ptr;	    ptrlo = ptr + 1 ;	    printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,E 9			GETWORD(ptrlo));D 9		if (0xFFFF == GETWORD(ptrhi)){E 9I 9	    if (0xFFFF == GETWORD(ptrhi))	      {E 9			printf("[not looked up]  ");			print_atomname(get_fvar_name(fx_addr68k , i));			putchar('\n');BT_morep;D 9		}		else if ((0xFFFF & GETWORD(ptrlo)) == 1){			printf("[fvar  ");			print_atomname(get_fvar_name(fx_addr68k , i));			printf("  on stack]  ");			print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & GETWORD(ptrlo)) << 16) | GETWORD(ptrhi))));			putchar('\n');BT_morep;		}		else{			printf("[fvar  ");			print_atomname(get_fvar_name(fx_addr68k , i));			printf("  top value ]   ");			print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & GETWORD(ptrlo)) << 16) | GETWORD(ptrhi))));			putchar('\n');BT_morep;		}		ptr += 2 ;		i++;	}E 9I 9	      }	    else if ((0xFFFF & GETWORD(ptrlo)) == 1)	      {		printf("[fvar  ");		print_atomname(get_fvar_name(fx_addr68k , i));		printf("  on stack]  ");		print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & GETWORD(ptrlo)) << 16) | GETWORD(ptrhi))));		putchar('\n');BT_morep;	      }	    else	      {		printf("[fvar  ");		print_atomname(get_fvar_name(fx_addr68k , i));		printf("  top value ]   ");		print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & GETWORD(ptrlo)) << 16) | GETWORD(ptrhi))));		putchar('\n');BT_morep;	      }	    ptr += 2 ;	    i++;	  }E 9	if (fx_addr68k->alink == 11)  /* for contextsw */		next68k = (DLword *)Addr68k_from_LADDR((fx_addr68k->nextblock+STK_OFFSET)) ;D 9	else		next68k = CurrentStackPTR;E 9I 9	else next68k = CurrentStackPTR;E 9	while(ptr < next68k)D 9	{		ptrhi = ptr;		ptrlo = ptr + 1 ;		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,E 9I 9	  {	    ptrhi = ptr;	    ptrlo = ptr + 1 ;	    printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,E 9			GETWORD(ptrlo));D 9		print(*(LispPTR *)ptr);		ptr += 2 ;		putchar('\n');BT_morep;	}  printf("this frame is last !!\n");BT_morep;  return(-1); }E 9I 9	    print(*(LispPTR *)ptr);	    ptr += 2 ;	    putchar('\n');BT_morep;	  }	printf("this frame is last !!\n");BT_morep;	return(-1);      }E 9D 9 next68k = (DLword *)Addr68k_from_LADDR((fx_addr68k->nextblock+STK_OFFSET)) ; ptr =(DLword *)(fx_addr68k+1) ;E 9I 9    next68k = (DLword *)Addr68k_from_LADDR((fx_addr68k->nextblock+STK_OFFSET)) ;    ptr =(DLword *)(fx_addr68k+1) ;E 9D 9 i = 0; while(npvar-- > 0){		ptrhi = ptr;		ptrlo = ptr + 1 ;		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,E 9I 9    i = 0;    while(npvar-- > 0)      {	ptrhi = ptr;	ptrlo = ptr + 1 ;	printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,E 9			GETWORD(ptrlo));D 9		if ((pvarindex = get_pvar_name(fx_addr68k , i++)) == LOCAL_PVAR)E 9I 9	if ((pvarindex = get_pvar_name(fx_addr68k , i++)) == LOCAL_PVAR)E 9			printf("*local* [pvar%d] " , (i - 1));D 9		elseE 9I 9	elseE 9			print_atomname(pvarindex);D 9		if (GETWORD(ptr) == 0xFFFF){E 9I 9	if (GETWORD(ptr) == 0xFFFF){E 9			printf("  [variable not bound]\n");BT_morep;		}D 9		else{E 9I 9	else{E 9			printf("  ");			print(*(LispPTR *)ptr);			putchar('\n');		BT_morep;		}D 9		ptr += 2 ;	} i = max_npvar;	while(nfvar && nfvar-- >= max_npvar){		ptrhi = ptr;		ptrlo = ptr + 1 ;		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,E 9I 9	ptr += 2 ;      }    i = max_npvar;    while(nfvar && nfvar-- >= max_npvar)      {	ptrhi = ptr;	ptrlo = ptr + 1 ;	printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,E 9			GETWORD(ptrlo));D 9		if (0xFFFF == GETWORD(ptrhi)){			printf("[not looked up]  ");			print_atomname(get_fvar_name(fx_addr68k , i));			putchar('\n');BT_morep;		}		else if ((0xFFFF & GETWORD(ptrlo)) == 1){			printf("[fvar  ");			print_atomname(get_fvar_name(fx_addr68k , i));			printf("  on stack]  ");			print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & GETWORD(ptrlo)) << 16) | GETWORD(ptrhi))));			putchar('\n');BT_morep;		}		else{			printf("[fvar  ");			print_atomname(get_fvar_name(fx_addr68k , i));			printf("  top value ]   ");			print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & GETWORD(ptrlo)) << 16) | GETWORD(ptrhi))));			putchar('\n');BT_morep;		}		ptr += 2 ;		i++;	} while(next68k > ptr)  {E 9I 9	if (0xFFFF == GETWORD(ptrhi))	  {	    printf("[not looked up]  ");	    print_atomname(get_fvar_name(fx_addr68k , i));	   putchar('\n');BT_morep;	  }	else if ((0xFFFF & GETWORD(ptrlo)) == 1)	  {	    printf("[fvar  ");	    print_atomname(get_fvar_name(fx_addr68k , i));	    printf("  on stack]  ");	    print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & GETWORD(ptrlo)) << 16) | GETWORD(ptrhi))));	    putchar('\n');BT_morep;	  }	else	  {	    printf("[fvar  ");	    print_atomname(get_fvar_name(fx_addr68k , i));	    printf("  top value ]   ");	    print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & GETWORD(ptrlo)) << 16) | GETWORD(ptrhi))));	    putchar('\n');BT_morep;	  }	ptr += 2 ;	i++;      }    while(next68k > ptr)      {E 9	printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptr++) ,		GETWORD(ptr++));	putchar('\n');BT_morep;D 9  }return (0);E 9I 9      }    return (0);E 9D 9}E 9I 9  }E 9/************************************************************************//*									*//*				b t					*//*									*//*	Print the names of the frames on the stack.  Equivalent to	*//*	the Lisp DEBUGGER's BT! command.				*//*									*//*		Changed		26 Aug 1987	NMitani			*//*		Changed   May 4, 1988	Take(for URaid)			*//*									*//************************************************************************/bt()  {    bt1(CURRENTFX);  }bt1(startFX)  FX *startFX;  {    FX	*fx ;    struct fnhead	*fnobj;    FX *get_nextFX();    int fnum=0;    BT_lines=0;    fx = startFX ;    URaid_FXarray[fnum]=fx;    printf("%3d : ",fnum++);    fnobj = (struct fnhead *)Addr68k_from_LADDR(    	((int)fx->hi2fnheader << 16) | fx->lofnheader);    printf("   0x%x : " , LADDR_from_68k(fx));D 7    print_atomname(fnobj->framename);E 7I 7    print(fnobj->framename);E 7    putchar('\n');BT_morep;    while((fnobj->framename != ATOM_T) && (fx->alink != 11))      {	if(fnum >URMAXFXNUM-1)	  {	   /* Internal buf overflow,more than 100 stacks */	   printf("***There are more than 100 stack frames.\n");	   printf("If you want to continue, Uraid will smash its internal table for FX pointer. Do you accept?(Y or N)\n");	   {	     int c;	     c= getchar();fflush(stdin);	     if((c=='Y')||(c=='y'))	       {		 fnum=0;		 bzero(URaid_FXarray,URMAXFXNUM *4);	       }	     else goto bt1_exit;	    }	  }	fx= get_nextFX(fx);	fnobj = (struct fnhead *)Addr68k_from_LADDR(	((int)fx->hi2fnheader << 16) | fx->lofnheader);	URaid_FXarray[fnum]=fx;	printf("%3d : ",fnum++);	printf("   0x%x : " , LADDR_from_68k(fx));D 7	print_atomname(fnobj->framename);E 7I 7	print(fnobj->framename);E 7	putchar('\n');BT_morep;      }   if (fnobj->framename != ATOM_T)      {	printf(">>root frame for contextsw<<\n");	putchar('\n');BT_morep;      }bt1_exit: URaid_ArrMAXIndex=fnum-1;	URaid_currentFX=0;  }/* end bt *//***************************************************************//*	Func Name :	btvv	Desc :		dumps the all stack frame name.	Changed		4 Sep 1987	NMitani*//***************************************************************//************************************************************************//*									*//*				b t v v					*//*									*//*	Print all stack frames, with variables.  Equivalent to the	*//*	Lisp DEBUGGER's BTV! command.					*//*									*//*									*//*									*//************************************************************************/btvv(){	struct frameex1 *fx_addr68k;	LispPTR atomindex ;	FX *get_nextFX();	fx_addr68k = CURRENTFX ;	atomindex = get_framename(fx_addr68k);	while((atomindex != ATOM_T) && (fx_addr68k->alink != 11))	{		sf(fx_addr68k);		fx_addr68k= get_nextFX(fx_addr68k);		atomindex = get_framename(fx_addr68k);	}	sf(fx_addr68k);	printf("\n BTV! end ********\n");} /*end btvv*//************************************************************************//*									*//*				s f f					*//*									*//*	Given the address of a lisp stack frame-extension (FX)		*//*	as a LISP (not native!) address, print the stack frame.		*//*									*//*									*//*							NMitani		*//************************************************************************/sff(laddr)  LispPTR laddr;  {    sf((FX *)Addr68k_from_LADDR(laddr));  }I 4#ifdef BIGATOMS  /*****************************************************************//* Nametable debugging aid                                       *//*                                                               *//* nt(index): print function header and name table               *//*            in defcell of Atom index 'index'                   *//*****************************************************************/#define DUMPSIZE 40#define FNOVERHEADWORDS (8)nt(index)  LispPTR index; /* atom index */  {    struct fnhead *fnobj;    DefCell *defcell68k;    LispPTR cell;    DLbyte *scratch;    int i;    LispPTR *localnt1;    int localntsize;    DLword fnobj_lisp;    defcell68k = (DefCell *)GetDEFCELL68k(index);    fnobj = (struct fnhead *)Addr68k_from_LADDR(defcell68k->defpointer);    /* check if it's the same index ??*/    if (index != (fnobj->framename))      {	printf("DEFCELL says it is ");	print_atomname(index);	printf("\n But Func OBJ says ");	print_atomname(fnobj->framename);	putchar('\n');	return;      }    printf("***DUMP Func Header << ");    printf("start at 0x%x lisp address(0x%x 68k)\n",		LADDR_from_68k(fnobj),fnobj);D 7    print_atomname(index);E 7I 7    print(index);E 7    putchar('\n');    ntheader(fnobj);}ntheader(fnobj)struct fnhead *fnobj;D 7{  LispPTR *localnt1;  int localntsize;  LispPTR *fnobj_lisp;E 7I 7  {    LispPTR *localnt1;    int localntsize;    LispPTR *fnobj_lisp;E 7D 7  fnobj_lisp = LADDR_from_68k((DLword *)fnobj); E 7I 7    fnobj_lisp = (LispPTR *)LADDR_from_68k((DLword *)fnobj); E 7    printf("0x%06x: 0x%08x  stkmin\n",fnobj_lisp,fnobj->stkmin);    printf("0x%06x: 0x%08x  na\n",fnobj_lisp+1, fnobj->na);    printf("0x%06x: 0x%08x  pv\n",fnobj_lisp+2, fnobj->pv);    printf("0x%06x: 0x%08x  startpc\n",fnobj_lisp+3,fnobj->startpc);    printf("0x%06x: 0x%08x  argtype\n",fnobj_lisp+4,fnobj->argtype);    printf("0x%06x: 0x%08x  framename ",fnobj_lisp+5,fnobj->framename);    print(fnobj->framename);    putchar('\n');    printf("0x%06x: 0x%08x  ntsize\n",fnobj_lisp+6,fnobj->ntsize);    printf("0x%06x: 0x%08x  nlocals",fnobj_lisp+7,fnobj->nlocals);    printf("  0x%08x  fvaroffset\n",fnobj->fvaroffset);    nt1((LispPTR *)((DLword *)fnobj + FNOVERHEADWORDS), fnobj->ntsize, "Name Table" );    localnt1= (LispPTR *)((DLword *)fnobj + FNOVERHEADWORDS + (fnobj->ntsize ? (2 * fnobj->ntsize) : 4));    localntsize = ((DLword *)fnobj + (fnobj->startpc >> 1) - (DLword *)localnt1) >> 1;     nt1(localnt1,localntsize,"Local args");  }nts(fxp)struct frameex1 *fxp;{  struct fnhead *nt;  if(fxp->validnametable)    nt = (struct fnhead *)		   (Addr68k_from_LADDR(((fxp->hi2nametable)<<16 |					 fxp->lonametable )));  else      nt = (struct fnhead *)		    (Addr68k_from_LADDR(((fxp->hi2fnheader)<<16 |					  fxp->lofnheader )));  ntheader(nt);}#define VARTYPE_FVAR (3)#define VARTYPE_PVAR (2)#define VARTYPE_IVAR (0)D 8static  char *fvarstr[4] = "FVAR",       *pvarstr[4] = "PVAR",       *ivarstr[4] = "IVAR",       *others[4]  = "????";E 8#define VAROFFSET(X) (X & 0xFFFFFF)nt1(start,size,str)LispPTR *start;int size;char *str;{  LispPTR *endp, *entry2p;  printf("\n---- %s ----\n", str);  size = size >> 1; /* originally size is # of word. now size is # of int */  endp = start + size;  while( start < endp ){    entry2p = start+size;    printf("0x%06x: 0x%08x",	   LADDR_from_68k((DLword *)start), *start);    printf("  0x%06x: 0x%08x",	   LADDR_from_68k((DLword *)entry2p), *entry2p);    if(*start != 0){      if((*entry2p >> 30)== VARTYPE_FVAR)         printf(" FVAR");      else if((*entry2p >> 30)== VARTYPE_PVAR)         printf(" PVAR");      else if((*entry2p >> 30)== VARTYPE_IVAR)         printf(" IVAR");      else        printf(" ????");      printf("%2d  ",  VAROFFSET(*entry2p));      print_atomname(*start);     }    putchar('\n');    start++;  }}#endifE 4E 1