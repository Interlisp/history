h57800s 00087/00043/01340d D 1.55 93/02/08 15:00:48 sybalsky 55 54c Big VM (and new CDR coding) changes for 3.0 \nes 00003/00004/01380d D 1.54 92/07/24 10:47:29 sybalsky 54 53c retrofit of SGI & DEC OSF1 changes \nes 00004/00001/01380d D 1.53 92/06/26 13:51:12 sybalsky 53 52c retrofit of 386 unix changes \nes 00005/00001/01376d D 1.52 92/04/23 10:56:43 sybalsky 52 51c fixing SCCS headers \nes 00005/00005/01372d D 1.51 92/04/21 17:28:40 sybalsky 51 50c shortening file names for DOS \nes 00022/00001/01355d D 1.50 91/10/15 18:28:29 sybalsky 50 49c ISC changeses 00008/00003/01348d D 1.49 91/09/27 03:30:38 sybalsky 49 48c ISC port changeses 00010/00000/01341d D 1.48 91/04/23 15:10:06 sybalsky 48 47c Add some comments.es 00011/00007/01330d D 1.47 91/04/09 17:16:16 sybalsky 47 46c Retrofit first round of changes from MIPS porting centeres 00075/00069/01262d D 1.46 91/03/07 19:40:56 sybalsky 46 45c 3-byte atom changeses 00009/00003/01322d D 1.45 90/06/22 16:40:28 fuji 45 44c New compile flag NOETHERes 00109/00002/01216d D 1.44 90/05/14 15:54:27 fuji 44 43c Window Security Feature. 's' uses execl instead of system.es 00203/00001/01015d D 1.43 90/05/14 12:06:06 fuji 43 42c support color funcs on CG6. es 00000/00000/01016d D 1.42 90/04/20 02:08:00 sybalsky 42 41c AIX:  shortening file names, bulk change.es 00002/00000/01014d D 1.41 90/04/17 17:03:36 sybalsky 41 40c AIX changes, ifdef out some include files for sunwindows.es 00004/00004/01010d D 1.40 90/03/22 12:37:02 takeshi 40 39c To restore correct display image on i386es 00025/00004/00989d D 1.39 90/03/01 13:55:54 osamu 39 38c Mitsunori Matsuda adds XWindow functionality.es 00004/00002/00989d D 1.38 90/02/08 11:51:46 osamu 38 37c change ether_fd to EtherReadFds in device_after_raid() c 	After change: LispReadFds |= (1 << EtherReadFds);es 00024/00009/00967d D 1.37 90/02/08 09:47:44 takeshi 37 36c Add DISPLAYBUFFER option for CG3/CG6es 00017/00006/00959d D 1.36 89/12/28 15:29:41 sybalsky 36 35c es 00150/00106/00815d D 1.35 89/12/13 11:00:18 sybalsky 35 34c show more frames (> 100!), clean up cmd summary grammares 00021/00021/00900d D 1.34 89/01/10 13:59:04 shih 34 33c spellinges 00002/00001/00919d D 1.33 88/12/28 14:21:39 shimizu 33 32c Fix win_setcursor error in device_before_raides 00047/00047/00873d D 1.32 88/11/30 16:50:14 shih 32 31c grammar correction in symbol lookup, minor cleanupes 00015/00000/00905d D 1.31 88/11/15 15:07:47 shimizu 31 30c Fix the AR10933(suspend-lisp can't recover the screen image on CGFOUR)es 00005/00005/00900d D 1.30 88/11/08 13:14:20 bane 30 29c Commented out blatantly bogus break; statementses 00001/00001/00904d D 1.29 88/10/27 18:02:58 shimizu 29 28c change I/F for init_keyboardes 00001/00001/00904d D 1.28 88/10/18 15:01:52 krivacic 28 27c remove warning messagees 00012/00023/00893d D 1.27 88/10/14 21:31:36 shih 27 26c mistake in copy_region fixedes 00336/00333/00580d D 1.26 88/10/13 18:57:12 shih 26 25c minor cleanup (needs lispmap.h)es 00007/00003/00906d D 1.25 88/10/13 11:37:01 krivacic 25 24c add OS4 ifdef for MAP_FIXEDes 00002/00001/00907d D 1.24 88/10/12 21:03:46 bane 24 23c added MAP_FIXED to mmap calles 00001/00001/00907d D 1.23 88/10/12 20:40:02 bane 23 22c Changed mmap result test to work under os3 and os4es 00044/00022/00864d D 1.22 88/09/29 14:23:42 charnley 22 21c removed calls to pr_rop.es 00012/00012/00874d D 1.21 88/09/19 17:54:17 shih 21 20c typo cleanupses 00100/00026/00786d D 1.20 88/09/16 11:47:45 shimizu 20 19c changes about error check etc. based on AR10844es 00011/00003/00801d D 1.19 88/08/18 18:17:07 shimizu 19 18c Add 'g' 'p' options for 'l' commandes 00002/00002/00802d D 1.18 88/08/02 15:06:57 shimizu 18 17c Change the summary for 'v' commandes 00003/00002/00801d D 1.17 88/08/02 12:15:20 shimizu 17 16c device_after_uraid returns -1 if it fails in opening windowFDes 00000/00001/00803d D 1.16 88/07/18 16:05:07 greep 16 15c removed extraneous call to free() with no argumentses 00019/00001/00785d D 1.15 88/07/07 14:46:46 shimizu 15 14c ! command prints error message from C; Fix the BUG in v commandes 00004/00004/00782d D 1.14 88/07/02 02:25:51 shih 14 13c two spelling errors on uraid help menues 00004/00001/00782d D 1.13 88/06/27 01:51:24 bane 13 12c Added FNDELAY on open of LispWindowFdes 00011/00002/00772d D 1.12 88/06/24 23:07:07 bane 12 11c Added KB interrupt code and KBINT ifdefses 00006/00002/00768d D 1.11 88/06/24 17:36:49 shimizu 11 10c FIX for AR10511,10514es 00003/00001/00767d D 1.10 88/06/24 15:20:21 shimizu 10 9c FIX comm do hardreturnes 00003/00004/00765d D 1.9 88/06/20 21:53:43 shimizu 9 8c q comm exit with NO-operationses 00002/00004/00767d D 1.8 88/06/10 11:45:23 shimizu 8 7c Be able to treat IL: packagees 00036/00017/00735d D 1.7 88/06/09 19:55:10 shimizu 7 6c AR10334 fixes 00001/00001/00751d D 1.6 88/06/08 19:05:18 shimizu 6 5c Enable to print error message from LISPes 00003/00003/00749d D 1.5 88/06/02 11:11:35 shimizu 5 4c Correct spelling miss in "confirm"es 00012/00006/00740d D 1.4 88/05/31 16:43:52 shimizu 4 3c Change ret val of parse_atomstring and protect calling get_package_atom with INTERLISP in defaultes 00003/00002/00743d D 1.3 88/05/27 14:14:30 shimizu 3 2c "l u" calls bt()es 00005/00004/00740d D 1.2 88/05/27 14:09:40 shimizu 2 1c Add "u" type to "l" commes 00744/00000/00000d D 1.1 88/04/19 11:54:17 shimizu 1 0c date and time created 88/04/19 11:54:17 by shimizueuUtTI 1D 30/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 30I 30D 32/* This is G-file @(#) uraid.c Version 1.29 (10/27/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) uraid.c	1.29 10/27/88";E 32I 32D 35/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 35I 35D 39/* @(#) uraid.c Version 1.34 (1/10/89). copyright envos & Fuji Xerox  */static char *id = "@(#) uraid.c	1.34 1/10/89		(envos & Fuji Xerox)";E 39I 39D 46/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 46I 46/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(Venue & Fuji Xerox)";E 46E 39E 35E 32E 30I 46/************************************************************************//*									*/D 52/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*/E 52I 52/*	(C) Copyright 1989-1992 Venue. All Rights Reserved.		*/E 52/*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************/I 48/************************************************************************//************************************************************************//*									*//*			    U R A I D . C				*//*									*//*	URAID is the low-level debugger for Medley.			*//*									*//************************************************************************//************************************************************************/E 48E 46#include <stdio.h>#include "lispemul.h"#include "lispmap.h"D 51#include "address68k.h"#include "lisptypes.h"#include "lispglobal.h"#include "emulglobal.h"E 51I 51#include "adr68k.h"#include "lsptypes.h"#include "lspglob.h"#include "emlglob.h"E 51#include "cell.h"#include "stack.h"#include "ifpage.h"#include "debug.h"I 31D 51#include "devconfig.h"E 51I 51#include "devconf.h"E 51I 43#include "display.h"E 43I 37#include "bitblt.h"E 37E 31D 49#include <sys/file.h>E 49I 49#ifdef ISC#include <sys/bsdtypes.h>#define vfork forkD 55#endif ISCE 55I 55#endif /* ISC */E 55I 52I 55E 55#ifdef INDIGO#define vfork fork#endif /* INDIGO */E 52E 49#include <sys/types.h>I 49#include <sys/file.h>E 49#include <sys/param.h>#include <sys/ioctl.h>I 44#include <sys/wait.h>E 44#include <fcntl.h>I 41D 54#ifndef AIXE 54I 54#ifdef SUNDISPLAYE 54E 41#include <sundev/kbd.h>#include <sundev/kbio.h>#include <errno.h>#include <sunwindow/window_hs.h>#include <sunwindow/win_ioctl.h>#include <pixrect/pixrect_hs.h>#include <sunwindow/win_cursor.h>#include <sunwindow/cms.h>#include <sys/mman.h>I 44D 54#ifdef SUNDISPLAYE 54extern int Win_security_p;D 54#endif SUNDISPLAYE 44I 41#endif AIXE 54I 54#endif /* SUNDISPLAY */E 54E 41I 43#ifdef COLORextern int MonoOrColor;extern int Dispcolorsize;extern DLword *ColorDisplayRegion68k;D 55#endif COLORE 55I 55#endif /* COLOR */E 55E 43I 36D 46/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 46I 55E 55E 36/***********************************************************************//*	File name : uraid.c	Written by : Takeshi Shimizu(Take)	Date:   6-May-1988	This File Supports the following commands:D 35**URAID commands summary**E 35I 35**URAID command summary**E 35<<Displaying a Stack>>c                       Checks all user stack contentsD 14f number                Displays Frame extention for the number(decimal)E 14I 14D 32f number                Displays Frame extension for the number(decimal)E 32I 32f number                Displays frame extension for the number(decimal)E 32E 14k type                  Changes the type of stack link following.(a|c)D 2l [type]                Back Trace for Specified type stack.(k|m|r)E 2I 2D 19l [type]                Back Trace for Specified type stack.(k|m|r|u)E 19I 19D 32l [type]                Back Trace for Specified type stack.(k|m|r|g|p|u)E 32I 32l [type]                Back trace for specified type stack.(k|m|r|g|p|u)E 32E 19E 2<CR>                    Display next frame.<<Displaying the Memory contents>>a litatom               Displays the top-level value of the litatomD 32d litatom               Displays the Definition Cell for the litatomE 32I 32d litatom               Displays the definition cell for the litatomE 32M                       Displays TOS,CSP,PVAR,IVAR,PCm func1 func2           MOVED func1 to func2t Xaddress              Displays the type of this objectD 14p litatom               Displays the Propaty list of the litatomE 14I 14D 32p litatom               Displays the Property list of the litatomE 32I 32p litatom               Displays the property list of the litatomE 32E 14w                       Displays the current function-name and PCx Xaddress [xnum]       Hex-Dump xnum word(16-bits) starting at XaddressD 20@ litatom val           Sets TOPVAL of litatom to valE 20I 20@ litatom val           Sets TOPVAL of litatom to Decimal-valE 20< Xaddress val          Sets the word(16-bits) at the address to val<<Return or Exit>>e                       Exit to UNIXh                       Context switch to HARDRESETD 9q                       Returns from URAID with NILE 9I 9q                       Returns from URAID with NO-changeE 9<<Misc>>s                       Invoke ShellD 18v filename              Save the current virtual memory on the filenameE 18I 18v filename              Save the virtual memory on the filename(Not Bootable)E 18( [num]                 Sets Print levelI 20!			Prints the error message passed from the emulatorE 20?                       Display this summary*//************************************************************************/I 35D 37#ifdef DISPLAYBUFFERE 37  extern int black, white;  extern struct pixrect *ColorDisplayPixrect,			*DisplayRegionPixrect;D 37#endif DISPLAYBUFFERE 37E 35I 22extern int DisplayRasterWidth;E 22extern unsigned int LispReadFds,LispWindowFd,LispKbdFd;D 22extern struct pixrect *ScreenBitMap,*CursorBitMap,*InvisibleCursorBitMap;E 22I 22extern struct pixrect *CursorBitMap,*InvisibleCursorBitMap;I 33extern struct cursor CurrentCursor, InvisibleCursor;E 33E 22extern struct screen LispScreen;extern int DisplayWidth,DisplayHeight;extern DLword *DisplayRegion68k;extern int FrameBufferFd,ether_fd,RS232C_Fd;I 38extern u_int	EtherReadFds;I 53extern int Xfd;E 53E 38I 53E 53LispPTR RadiAtomIndex;LispPTR RaidPackageIndex;D 22struct pixrect *HideBitMap;E 22char *HideDisp68k;I 43#ifdef COLORchar *HideColorDisp68k;extern int Inited_Color;D 55#endif COLORE 55I 55#endif /* COLOR */E 55I 55E 55E 43D 35char *URaid_summary = {"**URAID commands summary**\n\<<Displaying a Stack>>\n\E 35I 35char *URaid_summary = {"---URAID command summary---\n\<<Displaying the Stack>>\n\E 35c\t\t\tChecks all user stack contents\n\D 14f number\t\tDisplays Frame extention for the number(decimal)\n\E 14I 14D 36f number\t\tDisplays Frame extension for the number(decimal)\n\E 14k type\t\t\tChanges the type of stack link following.(a|c)\n\D 2l [type]\t\tBack Trace for Specified type stack.(k|m|r)\n\E 2I 2D 19l [type]\t\tBack Trace for Specified type stack.(k|m|r|u|<null>)\n\E 19I 19D 32l [type]\t\tBack Trace for Specified type stack.(k|m|r|g|p|u|<null>)\n\E 32I 32l [type]\t\tBack Trace for specified type stack.(k|m|r|g|p|u|<null>)\n\E 32E 19E 2<CR>\t\t\tDisplay next frame.\n<<Displaying the Memory contents>>\n\E 36I 36D 46f number\t\tDisplays Frame extension for the number (decimal)\n\E 46I 46D 50f number\t\tDisplays stakc frame for that frame number (decimal)\n\E 50I 50f number\t\tDisplays stack frame for that frame number (decimal)\n\E 50E 46k type\t\t\tChanges the type of stack link following. (a|c)\n\l [type]\t\tBack Trace for specified type stack. (k|m|r|g|p|u|<null>)\n\<CR>\t\t\tDisplay next frame.\n<<Displaying memory contents>>\n\E 36a litatom\t\tDisplays the top-level value of the litatom\n\I 46B Xaddress\t\tPrint the contents of the arrayblock at that address.\n\E 46D 32d litatom\t\tDisplays the Definition Cell for the litatom\n\E 32I 32d litatom\t\tDisplays the definition cell for the litatom\n\E 32D 35M\t\t\tDisplays TOS,CSP,PVAR,IVAR,PC\nm func1 func2\t\tMOVED func1 to func2\n\E 35I 35D 46M\t\t\tDisplays TOS,CSP,PVAR,IVAR,PC\nm func1 func2\t\tMOVD func1 to func2\n\E 46I 46M\t\t\tDisplays TOS,CSP,PVAR,IVAR,PC\n\m func1 func2\t\tMOVD func1 to func2\n\O Xaddress\t\tDisplays the object with that address\n\E 46E 35t Xaddress\t\tDisplays the type of this object\n\D 14p litatom\t\tDisplays the Propaty list of the litatom\n\E 14I 14D 32p litatom\t\tDisplays the Property list of the litatom\n\E 32I 32p litatom\t\tDisplays the property list of the litatom\n\E 32E 14w\t\t\tDisplays the current function-name and PC\n\D 36x Xaddress [xnum]\tHex-Dump xnum word(16-bits) starting at Xaddress\n\E 36I 36x Xaddress [xnum]\tHex-Dump xnum (16-bit) words starting at Xaddress\n\E 36D 20@ litatom val\t\tSets TOPVAL of litatom to val\n\< Xaddress val\t\tSets the word(16-bits) at the address to val\n\E 20I 20@ litatom val\t\tSets TOPVAL of litatom to Decimal-val\n\D 36< Xaddress val\t\tSets the word(16-bits) at the address to Xval\n\E 36I 36< Xaddress Xval\t\tSets the (16-bit) word at the address to Xval\n\E 36E 20<<Return or Exit>>\n\e\t\t\tExit to UNIX\n\D 35h\t\t\tContext switch to HARDRESET\n\D 9q\t\t\tReturns from URAID with NIL\n\E 9I 9q\t\t\tReturns from URAID with NO-change\n\E 35I 35h\t\t\tDo a HARDRESET\n\D 46q\t\t\tReturns from URAID with NOchange\n\E 46I 46q\t\t\tReturns from URAID with NO change\n\E 46E 35E 9<<Misc>>\ns\t\t\tInvoke Shell\n\D 18v filename\t\tSave the current virtual memory on the filename\n\E 18I 18v filename\t\tSave the virtual memory on the filename(Not Bootable)\n\E 18( [num]\t\t\tSets Print level\n\I 20!\t\t\tPrints the error message passed from the emulator\n\E 20?\t\t\tDisplay this summary"};D 20E 20I 20D 26/****OBSOLATEE 26I 26D 46/****OBSOLETEE 26E 20#define HEXNUMP(str,err)	if(((*str < '0') || (*str > '9')) \				&&((*str < 'A') || (*str > 'F'))){ \D 34			 	printf("Illegal argument, %s\n",err); \D 7			  	return; }E 7I 7			  	return(T); }E 34I 34				printf("Illegal argument, %s\n",err); \				return(T); }E 34I 20*****/E 46E 20E 7D 32			E 32I 32E 32D 7#define ADD_RANGEP(address)		if((address < 0) || (0xFFFFFF <= address)) \E 7I 7D 26#define ADD_RANGEP(address)		if((address < 0) || (0xFFFFFF < address)) \E 26I 26D 55#define ADD_RANGEP(address)	if((address < 0) || (0xFFFFFF < address)) \E 55I 55#define ADD_RANGEP(address)	if((address < 0) || (POINTERMASK < address)) \E 55E 26E 7				 { \D 21					printf("Address exceeded.\n"); \E 21I 21					printf("Address out of range.\n"); \E 21D 7					return; \E 7I 7					return(T); \E 7				 }extern int get_package_atom();#define URMAXCOMM		512D 35#define URMAXFXNUM		100E 35I 35#define URMAXFXNUM		2000E 35#define URSCAN_ALINK		0#define URSCAN_CLINK		1/*** URaid G vals ***/ int URaid_scanlink= URSCAN_ALINK; int URaid_currentFX=URMAXFXNUM +1; FX *URaid_FXarray[URMAXFXNUM]; int URaid_ArrMAXIndex; char URaid_inputstring[URMAXCOMM]; char URaid_comm; char URaid_arg1[URMAXCOMM/2]; char URaid_arg2[URMAXCOMM/2]; int URaid_argnum;I 15 char *URaid_errmess;E 15D 32	E 32I 32E 32 extern int PrintMaxLevel; /* for print level */I 46E 46/***********************************************************************//*	func name : parse_atomstring(string)	Written by : Takeshi Shimizu	Date:   6-May-1988	Pass the atomstring(e.g. "XCL:EVAL")	 Then Returns atomindex .D 26	If fail to find,return -1E 26I 26	If fail to find, return -1E 26	If there is no package prefix,it will be treated as IL:*//***********************************************************************/I 26LispPTR make_atom();D 46E 26D 7 parse_atomstring(string)E 7I 7LispPTR parse_atomstring(string)E 7 char *string; {  char *start,*packageptr,*nameptr;  int flag=0;  int packagelen=0;  int namelen=0;  int cnt;D 4  int aindex;E 4I 4  LispPTR aindex;D 26  LispPTR make_atom();E 26E 4 for(cnt=0,start=string; *string != '\0' ; string++,cnt++)E 46I 46  LispPTR parse_atomstring(string)  char *string;E 46  {I 46    char *start,*packageptr,*nameptr;    int flag=0;    int packagelen=0;    int namelen=0;    int cnt;    LispPTR aindex;    for(cnt=0,start=string; *string != '\0' ; string++,cnt++)      {E 46	if(*string ==':')D 46	{		packagelen= cnt;		packageptr=start;		nameptr=string+1;		cnt=0;		*string=0;	}  } if(packagelen==0) { /* treat as IL: */E 46I 46	  {	    packagelen= cnt;	    packageptr=start;	    nameptr=string+1;	    cnt=0;	    *string=0;	  }      }   if(packagelen==0)      { /* treat as IL: */E 46	nameptr=start;	namelen = cnt;D 46 } elseD 4	namelen = cnt-1;E 4I 4	namelen = cnt -1;E 46I 46      }    else namelen = cnt -1;E 46E 4D 20if((packagelen == 0) || (compare_chars(packageptr, "IL",packagelen ) == T)) E 20I 20D 32if((packagelen == 0) || (strncmp(packageptr, "IL",packagelen ) == 0)) E 32I 32D 46if((packagelen == 0) || (strncmp(packageptr, "IL",packagelen ) == 0))E 32E 20 {/* default IL: */E 46I 46    if((packagelen == 0) || (strncmp(packageptr, "IL",packagelen ) == 0))      {/* default IL: */E 46	aindex=make_atom(nameptr,0,namelen,T);D 4	if(aindex > 0xffff){ return(-1);}E 4I 4	if(aindex == 0xffffffff)D 8	 {  /*printf("try IL:\n");		aindex = get_package_atom(nameptr,namelen,"INTERLISP",9,0);*/		printf("Sorry,I can't try to find for the SYMBOL in INTERLISP package. \n Because It may cause floating exception error(I don't know why).\n");D 7		return(-1);E 7I 7		return(0xffffffff);E 8I 8D 32	 {  printf("try IL:\n");E 32I 32	 {  printf("trying IL:\n");E 32		aindex = get_package_atom(nameptr,namelen,"INTERLISP",9,0);E 8E 7	 }E 4D 46 }else	aindex = get_package_atom(nameptr,namelen,packageptr,packagelen,0);D 4printf("INDEX : %d \n",aindex);return(aindex);E 4I 4D 7if(aindex== 0xffffffff) return(-1);E 7I 7if(aindex== 0xffffffff) return(0xffffffff);E 7D 34printf("INDEX : %d \n",aindex& 0xffff);E 34I 34printf("INDEX : %d\n",aindex& 0xffff);E 34return(aindex & 0xffff);E 4}E 46I 46      }    else aindex = get_package_atom(nameptr,namelen,packageptr,packagelen,0);    if(aindex== 0xffffffff) return(0xffffffff);    printf("INDEX : %d\n",aindex& 0xffff);    return(aindex & 0xffff);  }E 46/***********************************************************************//*	func name : uraid_commclear()	Written by : Takeshi Shimizu	Date:   6-May-1988		Clear Command bufferD 32	E 32I 32E 32*//***********************************************************************/uraid_commclear()D 20{ register int i;E 20I 20D 32{ D 26/****OBSOLATE E 26I 26/****OBSOLETE E 32I 32{D 46/****OBSOLETEE 32E 26register int i;E 20  for(i=0;i <URMAXCOMM ; i++)	URaid_inputstring[i]=0;  for(i=0;i < URMAXCOMM/2 ; i++){	URaid_arg1[URMAXCOMM/2]=0;D 34 	URaid_arg2[URMAXCOMM/2]=0;E 34I 34	URaid_arg2[URMAXCOMM/2]=0;E 34  }I 20******/E 46  bzero(URaid_inputstring,URMAXCOMM);  bzero(URaid_arg1,URMAXCOMM/2);  bzero(URaid_arg2,URMAXCOMM/2);E 20  URaid_comm=0;  URaid_argnum=0;}I 46E 46I 26D 27copy_region ( src, dst, w, h )E 27I 27copy_region ( src, dst, width, h )E 27register short *src, *dst;D 27register int w, h;E 27I 27int width;register int h;E 27    {I 27    register int w;E 27    for (; (h--);) {D 27	for (; (w--);) {E 27I 27	for ( w = width; (w--);) {E 27D 40	    *dst++ = *src++;E 40I 40	    GETWORD(dst++ )= GETWORD(src++);E 40	    }	}    }E 26/***********************************************************************//*	func name : uraid_commands()	Written by : Takeshi Shimizu	Date:   6-May-1988		Execute URaid commands		To continue, return T		To exit, return NIL*//***********************************************************************/uraid_commands(){ int num,address,val,tmp;D 7 DLword index;E 7I 7 LispPTR index;E 7 DefCell *defcell68k;I 47D 49#ifdef RISCOSE 49I 49#ifdef SYSVONLYE 49int status;#elseE 47I 44 union wait status;I 47D 49#endif RISCOSE 49I 49D 55#endif SYSVONLYE 55I 55#endif /* SYSVONLY */E 55E 49E 47E 44I 55E 55  if(URaid_argnum == -1){	/* disp next FX */D 7	if(URaid_currentFX+1 >= URaid_ArrMAXIndex)E 7I 7	if(URaid_currentFX > URaid_ArrMAXIndex)E 7	{D 21	  printf("There is no more Stack.\n");E 21I 21	  printf("There is no more stack.\n");E 21	  return(T);	}	else	{D 32	  sf(URaid_FXarray[URaid_currentFX++]); E 32I 32	  sf(URaid_FXarray[URaid_currentFX++]);E 32	  return(T);	}  }  switch(URaid_comm)  {I 20E 20	/*** Displaying STACK stuff */	case 'c' :	stack_check(0);			break;	case 'C' :	all_stack_dump(0,0,T);			break;D 20	case 'f' :	if((URaid_arg1[0] < '0') || (URaid_arg1[0] > '9')){E 20I 20	case 'f' :	/**if((URaid_arg1[0] < '0') || (URaid_arg1[0] > '9')){E 20D 34			   printf("Illegal argument,Not number\n");E 34I 34			   printf("Illegal argument, not a number\n");E 34			    return(T);I 20			}**/			if(URaid_argnum==1) /* f comm only */			{D 35			  printf("DUMP-STACK: f decmal-FXnumber\n");E 35I 35			  printf("DUMP-STACK: f decimal-FXnumber\n");E 35			  return(T);E 20			}D 20			sscanf(URaid_arg1,"%d",&num);E 20I 20			if( sscanf(URaid_arg1,"%d",&num) <= 0)			{ /* com read fails */D 21			  printf("Illegal argument,Not number\n");E 21I 21			  printf("Illegal argument, not decimal number\n");E 21			  return(T);			}E 20			if((num > URaid_ArrMAXIndex) || (num < 0))			{D 21			  printf("Such Frame doesn't exist.\n");E 21I 21D 26			  printf("Such frame doesn't exist.\n");E 26I 26			  printf("Frame number doesn't exist.\n");E 26E 21			  return(T);			}			sf(URaid_FXarray[num]);			URaid_currentFX = num+1;			break;D 2	case 'k' :	if(URaid_arg1[0] == 'A')E 2I 2	case 'k' :	if((URaid_arg1[0] == 'A')||(URaid_arg1[0] == 'a'))E 2			URaid_scanlink =URSCAN_ALINK;D 2			else if(URaid_arg1[0] == 'C')E 2I 2			else if((URaid_arg1[0] == 'C')||(URaid_arg1[0] == 'c'))E 2				URaid_scanlink = URSCAN_CLINK;D 32			else E 32I 32			elseE 32				printf("Link type should be A or C\n");			break;	case 'l' :	if(URaid_argnum ==1)			{				bt(); /* default case CURRENTFX */				return(T);			}			switch(URaid_arg1[0])			{			 case 'k' :	printf("IFP->KBDFXP :\n");					bt1(Addr68k_from_StkOffset(InterfacePage->kbdfxp));					break;			 case 'm' :	printf("IFP->MISCFXP :\n");					bt1(Addr68k_from_StkOffset(InterfacePage->miscfxp));					break;			 case 'r' :	printf("IFP->RESETFXP :\n");					bt1(Addr68k_from_StkOffset(InterfacePage->resetfxp));					break;I 19			 case 'g' :	printf("IFP->GCFXP :\n");					bt1(Addr68k_from_StkOffset(InterfacePage->gcfxp));					break;			 case 'p' :	printf("IFP->FAULTFXP :\n");					bt1(Addr68k_from_StkOffset(InterfacePage->faultfxp));					break;E 19I 2D 3			 case 'u' :E 2			 default :	printf("2nd argument should be K,M,R or null.\n");E 3I 3D 32			 case 'u' :	bt(); E 32I 32			 case 'u' :	bt();E 32					break;D 19			 default :	printf("2nd argument should be k,m,r,u or null.\n");E 19I 19			 default :	printf("2nd argument should be k,m,r,g,p,u or null.\n");E 19E 3					break;			} /* switch end */		break;	/* Displaying the memory contents stuff */	case 'a' :	 /* GETTOPVAL */D 26				if(URaid_argnum != 2)I 20				{					printf("GETTOPVAL: a litatom\n");E 20					return(T);I 20				}E 20D 7				if((index = parse_atomstring(URaid_arg1))<0){E 7I 7				if((index = parse_atomstring(URaid_arg1))==						0xffffffff ){E 7					printf("No such atom\n");					return(T);				}				print(*((LispPTR*)GetVALCELL68k(index)));				break;E 26I 26			if(URaid_argnum != 2)			{				printf("GETTOPVAL: a litatom\n");				return(T);			}			if((index = parse_atomstring(URaid_arg1))==					0xffffffff ){D 46				printf("No such atom\n");E 46I 46				printf("No such atom.\n");E 46				return(T);			}			print(*((LispPTR*)GetVALCELL68k(index)));			break;E 26	case 'd' : /* DEFCELL */D 26				if(URaid_argnum != 2){					printf("GETD: d litatom\n");					return(T);				}D 7				if((index = parse_atomstring(URaid_arg1))<0){E 7I 7				if((index = parse_atomstring(URaid_arg1))==						0xffffffff){E 7					printf("No such atom\n");					return(T);				}				defcell68k= (DefCell*)GetDEFCELL68k(index);				if(defcell68k->ccodep) {				  printf("{CCODEP}0x%x \n",defcell68k->defpointer);				  return(T);				}				else{				  print(defcell68k->defpointer);				  return(T);				}				break;E 26I 26			if(URaid_argnum != 2){				printf("GETD: d litatom\n");				return(T);			}			if((index = parse_atomstring(URaid_arg1))==					0xffffffff){D 46				printf("No such atom\n");E 46I 46				printf("No such atom.\n");E 46				return(T);			}			defcell68k= (DefCell*)GetDEFCELL68k(index);			if(defcell68k->ccodep) {D 34			  printf("{CCODEP}0x%x \n",defcell68k->defpointer);E 34I 34			  printf("{CCODEP}0x%x\n",defcell68k->defpointer);E 34			  return(T);			}			else{			  print(defcell68k->defpointer);			  return(T);			}			break;E 26	case 'M' :	 /* Machine States */D 26				printf("TOS   : 0x%x \n",TopOfStack);				printf("CSTKP : 0x%x \n",LADDR_from_68k(CurrentStackPTR));				printf("PVAR  : 0x%x \n",LADDR_from_68k(PVar));				printf("IVAR  : 0x%x \n",LADDR_from_68k(IVar));				printPC(); putchar('\n');				break;E 26I 26D 34			printf("TOS   : 0x%x \n",TopOfStack);			printf("CSTKP : 0x%x \n",LADDR_from_68k(CurrentStackPTR));			printf("PVAR  : 0x%x \n",LADDR_from_68k(PVar));			printf("IVAR  : 0x%x \n",LADDR_from_68k(IVar));E 34I 34			printf("TOS   : 0x%x\n",TopOfStack);			printf("CSTKP : 0x%x\n",LADDR_from_68k(CurrentStackPTR));			printf("PVAR  : 0x%x\n",LADDR_from_68k(PVar));			printf("IVAR  : 0x%x\n",LADDR_from_68k(IVar));E 34			printPC(); putchar('\n');			break;E 26D 35	case 'm' :	/* MOVED */E 35I 35	case 'm' :	/* MOVD */E 35D 26				if(URaid_argnum != 3){					printf("MOVED: m <from funcname> <to funcname>\n");					return(T);				}				{ DefCell *fromfunc,*tofunc;D 7				  int fromindex,toindex;					if((fromindex = parse_atomstring(URaid_arg1))<0){E 7I 7				  LispPTR fromindex,toindex;					if((fromindex = parse_atomstring(URaid_arg1))==0xffffffff){E 26I 26D 46			if(URaid_argnum != 3){D 35				printf("MOVED: m <from funcname> <to funcname>\n");E 35I 35				printf("MOVD: m <from funcname> <to funcname>\n");E 35				return(T);			}E 46I 46			if(URaid_argnum != 3)			  {			    printf("MOVD: m <from funcname> <to funcname>\n");			    return(T);			  }E 46			{ DefCell *fromfunc,*tofunc;			  LispPTR fromindex,toindex;				if((fromindex = parse_atomstring(URaid_arg1))==0xffffffff){E 26E 7D 21					printf("No such function(from)\n");E 21I 21					printf("No such function (from)\n");E 21					return(T);D 26					}D 7					if((toindex = parse_atomstring(URaid_arg2))<0){E 7I 7					if((toindex = parse_atomstring(URaid_arg2))==0xffffffff){E 26I 26				}				if((toindex = parse_atomstring(URaid_arg2))==0xffffffff){E 26E 7D 21					printf("No such function(to)\n");E 21I 21					printf("No such function (to)\n");E 21					return(T);D 26					}E 26I 26				}E 26D 26					fromfunc= (DefCell*)GetDEFCELL68k(fromindex);					tofunc= (DefCell*)GetDEFCELL68k(toindex);					tofunc->defpointer = fromfunc->defpointer;					print(toindex);					printf(" is smashed with ");					print(fromindex);putchar('\n');E 26I 26				fromfunc= (DefCell*)GetDEFCELL68k(fromindex);				tofunc= (DefCell*)GetDEFCELL68k(toindex);				tofunc->defpointer = fromfunc->defpointer;				print(toindex);				printf(" is smashed with ");				print(fromindex);putchar('\n');E 26D 26				}E 26I 26			}E 26D 32				E 32I 32E 32D 26				break;	case 'O' :		{ /* print instance from Laddr. Not documented */					int objaddr;D 20					sscanf(URaid_arg1,"%x",&objaddr);E 20I 20					if(URaid_argnum ==1)					{						printf("PRINT-INSTANCE: O HEX-LispAddress\n");						return(T);					}					if(sscanf(URaid_arg1,"%x",&objaddr)						<=0) {						printf("Arg not HEX number\n");						return(T);					}E 20					print(objaddr);				}				break;	case 't' :   /* Object TYPE */				if(URaid_argnum != 2){D 20					printf("PRINTTYPENAME: t xaddress\n");E 20I 20					printf("PRINTTYPENAME: t Xaddress\n");E 26I 26			break;	case 'O' :	{ /* print instance from Laddr. Not documented */				int objaddr;				if(URaid_argnum ==1)				{					printf("PRINT-INSTANCE: O HEX-LispAddress\n");E 26E 20					return(T);				}D 26D 20				HEXNUMP(URaid_arg1,"Not Address");				sscanf(URaid_arg1,"%x",&address);E 20I 20				/**HEXNUMP(URaid_arg1,"Not Address");**/				if(sscanf(URaid_arg1,"%x",&address)<=0)				{E 26I 26				if(sscanf(URaid_arg1,"%x",&objaddr)					<=0) {E 26					printf("Arg not HEX number\n");					return(T);				}E 20D 26				ADD_RANGEP(address);E 26I 26				print(objaddr);			}			break;	case 't' :   /* Object TYPE */			if(URaid_argnum != 2){				printf("PRINTTYPENAME: t Xaddress\n");				return(T);			}E 26D 26				switch(address >> 16) {				 case ATOMS_HI : printf("{ATOM}");						 printf("0x%x\n",address);						 break;				 case STK_HI : printf("{STK}");						 printf("0x%x\n",address);						 break;					 case PLIS_HI : printf("{PLIST}");						 printf("0x%x\n",address);						 break;					 case FPTOVP_HI : printf("{FPTOVP}");						 printf("0x%x\n",address);						 break;					 case PNP_HI : printf("{PNP}");						 printf("0x%x\n",address);						 break;					 case DEFS_HI : printf("{DEF}");						 printf("0x%x\n",address);						 break;					 case VALS_HI : printf("{VAL}");						 printf("0x%x\n",address);						 break;				 case DISPALY_HI :				 case DISPALY_HI+1 :printf("{DISPLAY}");						 printf("0x%x\n",address);						 break;				 default:					num= GetTypeNumber(address);					putchar('{');					print_atomname((DLword)GetDTD(num));					putchar('}');					break;				} /* switch end */E 26I 26			/**HEXNUMP(URaid_arg1,"Not Address");**/			if(sscanf(URaid_arg1,"%x",&address)<=0)			{				printf("Arg not HEX number\n");				return(T);			}			ADD_RANGEP(address);E 26I 26			switch(address >> 16) {			 case ATOMS_HI : printf("{ATOM}");					 printf("0x%x\n",address);					 break;			 case STK_HI : printf("{STK}");					 printf("0x%x\n",address);D 32					 break;	E 32I 32					 break;E 32			 case PLIS_HI : printf("{PLIST}");					 printf("0x%x\n",address);D 32					 break;	E 32I 32					 break;E 32			 case FPTOVP_HI : printf("{FPTOVP}");					 printf("0x%x\n",address);D 32					 break;	E 32I 32					 break;E 32			 case PNP_HI : printf("{PNP}");					 printf("0x%x\n",address);D 32					 break;	E 32I 32					 break;E 32			 case DEFS_HI : printf("{DEF}");					 printf("0x%x\n",address);D 32					 break;	E 32I 32					 break;E 32			 case VALS_HI : printf("{VAL}");					 printf("0x%x\n",address);					 break;			 case DISPLAY_HI :			 case DISPLAY_HI+1 :printf("{DISPLAY}");					 printf("0x%x\n",address);					 break;			 default:				num= GetTypeNumber(address);				putchar('{');D 53				print_atomname((DLword)GetDTD(num));E 53I 53				print_atomname((DLword *)GetDTD(num));E 53				putchar('}');E 26				break;I 26			} /* switch end */			break;E 26#define GetPROPCELL68k(index)	((LispPTR *)Plistspace + (index) )D 26	case 'p' :	 /* propaty lisp */				if(URaid_argnum != 2){					printf("GETPROPLIST : p litatom\n");					return(T);				}D 7				if((index = parse_atomstring(URaid_arg1)) <0){E 7I 7				if((index = parse_atomstring(URaid_arg1)) ==						0xffffffff){E 7					printf("No such atom\n");					return(T);				}				print(*(GetPROPCELL68k(index)) & 0xffffff );				break;E 26I 26	case 'p' :	 /* property list */			if(URaid_argnum != 2){				printf("GETPROPLIST : p litatom\n");				return(T);			}			if((index = parse_atomstring(URaid_arg1)) ==					0xffffffff){				printf("No such atom\n");				return(T);			}D 55			print(*(GetPROPCELL68k(index)) & 0xffffff );E 55I 55			print(*(GetPROPCELL68k(index)) & POINTERMASK );E 55			break;E 26	case 'w' :  /* Disp CurrentFunc name & PC */D 26				doko();				break;E 26I 26			doko();			break;E 26#define XDUMPW 8D 20	case 'x' :	  /* HEX dump */E 20I 20	case 'x' :	  /* HEX dump "x Xaddress Xnum" */D 26				/* Obsolate E 20				HEXNUMP(URaid_arg1,"Not Address");				HEXNUMP(URaid_arg2,"Not number");D 20				sscanf(URaid_arg1,"%x",&address);				if(sscanf(URaid_arg2,"%x",&num)==-1)				 num = 8;E 20I 20				***/				if(URaid_argnum==1)				{ /* for help */				  printf("HEX-DUMP: x Xaddress [Xnum]\n");				  return(T);				}				if(sscanf(URaid_arg1,"%x",&address)<=0)				{ /* arg1 not HEX */				  printf("Arg(Xaddress) not Xaddress\n");				  return(T);				}				switch(sscanf(URaid_arg2,"%x",&num))				{				  case -1 :  /* Use defaultval for word-num */				 	    num = XDUMPW;					    break;				  case 0  : /* Illegal number */					    printf("Arg(Xnum) not Xnum\n");					    return(T);					    break;				  default : break;				}				if(num < 0)				{D 21				  printf("Dump words num should be Positive\n");E 21I 21				  printf("Dump words num should be positive\n");E 21				  return(T);				}				/* Address range check */E 20				ADD_RANGEP(address);I 20				ADD_RANGEP(address+num);E 26I 26D 32			/* Obsolete E 32I 32			/* ObsoleteE 32			HEXNUMP(URaid_arg1,"Not Address");			HEXNUMP(URaid_arg2,"Not number");			***/			if(URaid_argnum==1)			{ /* for help */			  printf("HEX-DUMP: x Xaddress [Xnum]\n");			  return(T);			}			if(sscanf(URaid_arg1,"%x",&address)<=0)			{ /* arg1 not HEX */			  printf("Arg(Xaddress) not Xaddress\n");			  return(T);			}			switch(sscanf(URaid_arg2,"%x",&num))			{			  case -1 :  /* Use defaultval for word-num */D 34			 	    num = XDUMPW;E 34I 34				    num = XDUMPW;E 34				    break;			  case 0  : /* Illegal number */				    printf("Arg(Xnum) not Xnum\n");				    return(T);D 30				    break;E 30I 30				 /* break; */E 30			  default : break;			}			if(num < 0)			{			  printf("Dump words num should be positive\n");			  return(T);			}			/* Address range check */			ADD_RANGEP(address);			ADD_RANGEP(address+num);E 26E 20D 26				{ int i;				  DLword *ptr,*endptr;					ptr=(DLword*)Addr68k_from_LADDR(address);					endptr=ptr+num;E 26I 26			{ int i;			  DLword *ptr,*endptr;				ptr=(DLword*)Addr68k_from_LADDR(address);				endptr=ptr+num;E 26D 26					while(ptr < endptr)					{D 20						printf("%x : ",LADDR_from_68k(ptr));E 20I 20						printf("0x%x : ",LADDR_from_68k(ptr));E 26I 26				while(ptr < endptr)				{					printf("0x%x : ",LADDR_from_68k(ptr));E 26E 20D 26						for(i=0;							((ptr <endptr)&& (i<XDUMPW)) ;ptr++,i++) 						{							printf("%4x ",*ptr);						}						putchar('\n');E 26I 26					for(i=0;D 32					((ptr <endptr)&& (i<XDUMPW));ptr++,i++) E 32I 32					((ptr <endptr)&& (i<XDUMPW));ptr++,i++)E 32					{						printf("%4x ",*ptr);E 26					}I 26					putchar('\n');E 26				}D 26				break;E 26I 26			}			break;E 26	case '@' :		/* SETTOPVAL */D 26				if(URaid_argnum != 3){D 20					printf("SETTOPVAL: @ litatom val\n");E 20I 20					printf("SETTOPVAL: @ litatom Decimal-val\n");E 26I 26			if(URaid_argnum != 3){				printf("SETTOPVAL: @ litatom Decimal-val\n");				return(T);			}			if((index = parse_atomstring(URaid_arg1))					== 0xffffffff){				printf("No such atom\n");				return(T);			}			if (strncmp(URaid_arg2, "NIL",3 ) == 0)				{val=NIL;}			else if (*URaid_arg2== 'T')  val=ATOM_T;D 32			else { E 32I 32			else {E 32				if(sscanf(URaid_arg2,"%d",&val) == -1){D 34					printf(" Bad value \n");E 34I 34					printf(" Bad value\n");E 34E 26E 20					return(T);				}D 7				if((index = parse_atomstring(URaid_arg1))<0){E 7I 7D 26				if((index = parse_atomstring(URaid_arg1))						== 0xffffffff){E 7					printf("No such atom\n");					return(T);				}D 20				if (compare_chars(URaid_arg2, "NIL", 3) == T)					val=NIL;E 20I 20				if (strncmp(URaid_arg2, "NIL",3 ) == 0)					{val=NIL;}E 20				else if (*URaid_arg2== 'T')  val=ATOM_T;				else { 					if(sscanf(URaid_arg2,"%d",&val) == -1){						printf(" Bad value \n");E 26I 26				else {					if((val < -65536)||(65535 < val)){D 32						printf("Bad Val range\n"); E 32I 32						printf("Bad Val range\n");E 32E 26						return(T);					}D 26					else {						if((val < -65536)||(65535 < val)){							printf("Bad Val range\n"); 							return(T);						}						if(val >=0)							val |= S_POSITIVE;D 7						elseE 7I 7						else {  val = val & 0xffff;E 7							val |= S_NEGATIVE;I 7						}E 26I 26					if(val >=0)						val |= S_POSITIVE;					else {  val = val & 0xffff;						val |= S_NEGATIVE;E 26E 7					}D 26E 26				}D 26				printf("Old value is ");				print(*((LispPTR*)GetVALCELL68k(index)));				putchar('\n');				*((LispPTR*)GetVALCELL68k(index)) =(LispPTR) val;				print(val);				break;E 26I 26			}			printf("Old value is ");			print(*((LispPTR*)GetVALCELL68k(index)));			putchar('\n');			*((LispPTR*)GetVALCELL68k(index)) =(LispPTR) val;			print(val);			break;E 26D 32	E 32I 32E 32D 7	case '<' :		/* Assignment */E 7I 7D 26	case '<' :		if(URaid_argnum != 3){					printf("Mem modify: < Xaddre Xval\n");					return(T);				}				/* Assignment */I 20				/* OBSOLATEE 20E 7				HEXNUMP(URaid_arg1,"Not Address");				HEXNUMP(URaid_arg2,"Not Proper Value");I 20				***/E 26I 26	case '<' :	if(URaid_argnum != 3){				printf("Mem modify: < Xaddre Xval\n");				return(T);			}			/* Assignment */			/* OBSOLETE			HEXNUMP(URaid_arg1,"Not Address");			HEXNUMP(URaid_arg2,"Not Proper Value");			***/E 26E 20D 20				sscanf(URaid_arg1,"%x",&address);				sscanf(URaid_arg2,"%x",&val);E 20I 20D 26				if(sscanf(URaid_arg1,"%x",&address) <=0)				{				  printf("Arg(Xaddress) not Xaddress\n");				  return(T);				}				if(sscanf(URaid_arg2,"%x",&val) <=0)				{				  printf("Arg(Xval) not Xaddress\n");				  return(T);				}E 26I 26			if(sscanf(URaid_arg1,"%x",&address) <=0)			{			  printf("Arg(Xaddress) not Xaddress\n");			  return(T);			}			if(sscanf(URaid_arg2,"%x",&val) <=0)			{			  printf("Arg(Xval) not Xaddress\n");			  return(T);			}E 26E 20D 26				ADD_RANGEP(address);I 7				if(val <0 || val > 0xffff){D 20					printf("VAL invalid.\n");E 20I 20D 21					printf("Xval invalid(16bits range ecceeded).\n");E 21I 21					printf("Xval invalid (16 bit range exceeded).\n");E 21E 20					return(T);				}E 26I 26			ADD_RANGEP(address);			if(val <0 || val > 0xffff){				printf("Xval invalid (16 bit range exceeded).\n");				return(T);			}E 26E 7D 26				{ DLword *ptr;					ptr =(DLword*)Addr68k_from_LADDR(address);					*ptr=val;					printf("0x%x : 0x%x\n",address,*ptr);				}				break;E 26I 26			{ DLword *ptr;				ptr =(DLword*)Addr68k_from_LADDR(address);				*ptr=val;				printf("0x%x : 0x%x\n",address,*ptr);			}			break;E 26/****MISC ****/D 10	case 'q' :		/* return with NIL */E 10I 10	case 'q' :		/* return with do Nothing */E 10D 5				printf("Return to Lisp?[comfirm](Y or N)<");E 5I 5D 26				printf("Return to Lisp?[confirm](Y or N)<");E 5				{int c;				  c= getchar();				  if((c=='Y')||(c=='y')) {D 9					TopOfStack = NIL;E 9I 9					/*TopOfStack = NIL;*/E 9					return(NIL);				   }				}				fflush(stdin);				URaid_currentFX=URMAXFXNUM +1;				return(T);				break;E 26I 26			printf("Return to Lisp?[confirm](Y or N)<");			{int c;			  c= getchar();			  if((c=='Y')||(c=='y')) {				/*TopOfStack = NIL;*/				return(NIL);			   }			}			fflush(stdin);			URaid_currentFX=URMAXFXNUM +1;			return(T);D 30			break;E 30I 30		     /* break; */E 30E 26	case 'h' :		/* HARDRESET */D 5				printf("HARDRESET?[comfirm](Y or N)<");E 5I 5D 26				printf("HARDRESET?[confirm](Y or N)<");E 5				{ int c;				  c= getchar();				  if((c=='Y')||(c=='y'))I 7				  {D 11					PC+= 3;/* for currentfx->pc ajust*/E 11I 11					/*PC+= 3; for currentfx->pc ajust:MOve to subr */E 11E 7					contextsw(ResetFXP,2,0);I 7D 11					PC -= 3; /* in subr.c it increments by 3 */E 11I 11					/*PC -= 3;  in subr.c it increments by 3 */E 11I 10					fflush(stdin);					return(NIL); /* return to dispatch */E 10				  }E 7				}E 26I 26			printf("HARDRESET?[confirm](Y or N)<");			{ int c;			  c= getchar();			  if((c=='Y')||(c=='y'))			  {				/*PC+= 3; for currentfx->pc ajust:MOve to subr */				contextsw(ResetFXP,2,0);				/*PC -= 3;  in subr.c it increments by 3 */E 26				fflush(stdin);D 9				return(NIL);E 9D 26				break;E 26I 26				return(NIL); /* return to dispatch */			  }			}			fflush(stdin);			break;E 26	case 'e' :		/* exit to UNIX */D 5				printf("Exit to UNIX?[comfirm](Y or N)<");E 5I 5D 26				printf("Exit to UNIX?[confirm](Y or N)<");E 5				{ int c;				  c= getchar();				  if((c=='Y')||(c=='y'))					exit(0);				}				fflush(stdin);				URaid_currentFX=URMAXFXNUM +1;				break;E 26I 26			printf("Exit to UNIX?[confirm](Y or N)<");			{ int c;			  c= getchar();			  if((c=='Y')||(c=='y'))				exit(0);			}			fflush(stdin);			URaid_currentFX=URMAXFXNUM +1;			break;E 26	case 's' :		/* SHELL */D 26				system("/bin/sh -i");E 26I 26D 44			system("/bin/sh -i");E 44I 44			switch (vfork()) {			case -1:			  (void)fprintf(stderr, "uraic_comm: Fork failed.\n");			  exit(1);			case 0:			  (void)execl("/bin/sh", "sh", "-i", 0);			  exit(1);			default:			  break;			}	  		(void)wait(&status);			/* system("/bin/sh -i"); */E 44			return(T);D 30			break;E 30I 30		     /* break; */E 30	case 'v' :	if(URaid_argnum != 2){				printf("VMEMSAVE: v filename (it's NOT bootable)\n");E 26				return(T);D 26				break;D 15	case 'v' :		vmem_save(URaid_arg1);E 15I 15D 20	case 'v' :		pr_rop(ScreenBitMap,0,0,DisplayWidth,E 20I 20	case 'v' :		if(URaid_argnum != 2){D 21					printf("VMEMSAVE: v filename(it's NOT bootable)\n");E 21I 21					printf("VMEMSAVE: v filename (it's NOT bootable)\n");E 21					return(T);				}D 22				pr_rop(ScreenBitMap,0,0,DisplayWidth,E 20					DisplayHeight,PIX_CLR,ScreenBitMap,0,0);				pr_rop( ScreenBitMap, 0, 0, DisplayWidth, 					DisplayHeight,PIX_SRC | PIX_DST,						HideBitMap, 0, 0);E 22I 22			{			register short *src, *dst;			register int w, h;			dst = (short *)DisplayRegion68k;			src = (short *)HideDisp68k;			for (h = DisplayHeight; (h--);)			  {			  for (w = DisplayRasterWidth; (w--);) 			    {			    *dst++ = *src++;			    }			  }E 26			}E 22D 26				if(vmem_save(URaid_arg1) != NIL){D 22				  pr_rop(ScreenBitMap,0,0,DisplayWidth,					DisplayHeight,PIX_CLR,ScreenBitMap,0,0);E 22I 22				  clear_display();E 22				  printf("VMEMSAVE fails\n");				}				else {D 22				  pr_rop(ScreenBitMap,0,0,DisplayWidth,					DisplayHeight,PIX_CLR,ScreenBitMap,0,0);E 22I 22				  clear_display();E 22D 21				  printf("VMEMSAVE finished,But it's not bootable\n");E 21I 21				  printf("VMEMSAVE finished, but it's not bootable\n");E 21				}E 15				break;	case '(' :		if(URaid_argnum==1) num = 2;								else if((URaid_arg1[0] < '0') || (URaid_arg1[0] > '9')){D 21					printf("Illegal argument,Not number\n");E 21I 21					printf("Illegal argument, not number\n");E 21			 		return(T);				}				else 					sscanf(URaid_arg1,"%d",&num);		E 26D 37E 37I 37#ifndef DISPLAYBUFFERE 37D 26				PrintMaxLevel = num;				printf("PrintLevel is set to %d.",num);				break;	case '?' :		printf("%s\n",URaid_summary);				break;I 15	case '!' :		printf("Error message is: %s \n",URaid_errmess);				break;E 26I 26D 27			copy_region ( (short *)HideDisp68k,				      (short *)DisplayRegion68k,E 27I 27			copy_region ( HideDisp68k,				      DisplayRegion68k,E 27				      DisplayRasterWidth,				      DisplayHeight );E 26D 37E 37I 37D 55#endif DISPLAYBUFFERE 55I 55#endif /* DISPLAYBUFFER */E 55E 37I 26			if(vmem_save(URaid_arg1) != NIL){I 37#ifndef DISPLAYBUFFERE 37			  clear_display();I 37D 55#endif DISPLAYBUFFERE 55I 55#endif /* DISPLAYBUFFER */E 55E 37			  printf("VMEMSAVE fails\n");			}			else {			  clear_display();			  printf("VMEMSAVE finished, but it's not bootable\n");			}			break;	case '(' :	if(URaid_argnum==1) num = 2;			else if((URaid_arg1[0] < '0') || (URaid_arg1[0] > '9')){				printf("Illegal argument, not number\n");D 34		 		return(T);E 34I 34				return(T);E 34			}D 32			else 				sscanf(URaid_arg1,"%d",&num);		E 32I 32			else				sscanf(URaid_arg1,"%d",&num);E 32			PrintMaxLevel = num;			printf("PrintLevel is set to %d.",num);			break;	case '?' :	printf("%s\n",URaid_summary);			break;D 34	case '!' :	printf("Error message is: %s \n",URaid_errmess);E 34I 34	case '!' :	printf("Error message is: %s\n",URaid_errmess);E 34			break;E 26E 15D 21	default :  printf("Not supported command.\n");E 21I 21	default :  printf("Unsupported command.\n");E 21			break;  } /* switch end */return(T);}I 46E 46I 35/************************************************************************//*									*//*			device_before_raid()				*//*									*//*	Written by : Takeshi Shimizu					*//*	Date:	 6-May-1988						*//*									*//*									*//*	Do whatever cleanup is necessary before leaving Lisp 		*//*	for URAID or for SUSPEND-LISP:  Cache the display buffer,	*//*	close the frame buffer, and any buffering pixrects.		*//*									*/E 35D 46/***********************************************************************/E 46I 46/************************************************************************/E 46I 37#ifdef DISPLAYBUFFERextern struct pixrect *ColorDisplayPixrect,*DisplayRegionPixrect;#endifE 37D 35/*	func name :  device_before_raid()	Written by : Takeshi ShimizuD 34	Date:  	 6-May-1988E 34I 34	Date:	 6-May-1988E 35E 34I 44#ifdef SUNDISPLAY#define SV_ACQUIRE	"/bin/sunview1/sv_acquire"#define SV_RELEASE	"/bin/sunview1/sv_release"D 55#endif SUNDISPLAYE 55I 55#endif /* SUNDISPLAY */E 55I 55E 55E 44D 26	This shoul be calld before invoking URaid.E 26I 26D 35	This should be called before invoking URaid.E 26*//***********************************************************************/E 35device_before_raid()D 35{	int keytrans;	int size;	int munmapstat;	struct pixrect *fb;	extern char *alloc_hideDISP();E 35I 35  {    int keytrans;    int size;    int munmapstat;    struct pixrect *fb;    extern char *alloc_hideDISP();E 35D 44E 44I 44#ifdef SUNDISPLAY    union wait status;D 55#endif SUNDISPLAYE 55I 55#endif /* SUNDISPLAY */E 55E 44D 35	char *valloc();E 35I 35D 47    char *valloc();E 47I 47    char *malloc();E 47E 35D 16	free();E 16D 32	E 32I 32E 32D 35	int_timer_off();E 35I 35    int_timer_off();E 35I 39#ifdef XWINDOWI 53	LispReadFds |= (1 << Xfd);E 53	Xevent_before_raid();D 55#endif XWINDOWE 55I 55#ifdef SYSVSIGNALS	sigrelse(SIGIO);	/* So X events still get recognized, for e.g. window expose*/#endif /* SYSVSIGNALS */#endif /* XWINDOW */E 55I 55E 55#ifdef SUNDISPLAYE 39D 33	win_setcursor(LispWindowFd, &InvisibleCursorBitMap);E 33I 33D 35	win_setcursor(LispWindowFd, &InvisibleCursor);E 35I 35    win_setcursor(LispWindowFd, &InvisibleCursor);E 35E 33I 12#ifdef KBINTE 12D 35	int_io_close(LispWindowFd);E 35I 35    int_io_close(LispWindowFd);E 35I 12#endifI 39D 55#endif SUNDISPLAYE 55I 55#endif /* SUNDISPLAY */E 55D 45E 45I 45#ifdef NOETHER#elseE 45E 39#ifdef ETHERINTE 12D 35	int_io_close(ether_fd);E 35I 35D 38    int_io_close(ether_fd);E 38I 38    if(ether_fd > 0) /* check ether is used or not */      int_io_close(ether_fd);E 38E 35D 12/*	int_io_close(RS232C_Fd);*/E 12I 12#endifI 45D 55#endif NOETHERE 55I 55#endif /* NOETHER */E 55E 45#ifdef RS232INTD 35	int_io_close(RS232C_Fd);E 35I 35    int_io_close(RS232C_Fd);E 35#endifI 39#ifdef SUNDISPLAYE 39E 12D 35	mess_reset();E 35I 35    mess_reset();I 50#ifdef FX_AR_124    /* For AR 124. Type4 driver bug?? by m.matsuda */    { long i; for( i=0; i<900000; i++ ); }D 55#endif FX_AR_124E 55I 55#endif /* FX_AR_124 */E 55E 50E 35I 50I 55E 55E 50D 6	if( (LispKbdFd = open( LispScreen.scr_kbdname )) == -1){E 6I 6D 35	if( (LispKbdFd = open( LispScreen.scr_kbdname , O_RDWR)) == -1){E 6		fprintf( stderr, "can't open %s\n", LispScreen.scr_kbdname);		return( -1 );	}E 35I 35    if( (LispKbdFd = open( LispScreen.scr_kbdname , O_RDWR)) == -1)      {	fprintf( stderr, "can't open %s\n", LispScreen.scr_kbdname);	return( -1 );      }E 35D 35	keytrans = TR_EVENT;	/* keyboard encodes key */	if(ioctl( LispKbdFd, KIOCTRANS, &keytrans)== -1){D 34		fprintf( stderr, "Error at ioctl errnoo =%d\n", errno);E 34I 34		fprintf( stderr, "Error at ioctl errno =%d\n", errno);E 34		return( -1 );	}	close( LispKbdFd );D 32        close( LispWindowFd ); E 32I 32        close( LispWindowFd );E 35I 35    keytrans = TR_EVENT;	/* keyboard encodes key */    if(ioctl( LispKbdFd, KIOCTRANS, &keytrans)== -1)      {	fprintf( stderr, "Error at ioctl errno =%d\n", errno);	return( -1 );      }    close( LispKbdFd );    close( LispWindowFd );I 50#ifdef TRUECOLOR    truecolor_before_raid();D 55#endif TRUECOLORE 55I 55#endif /* TRUECOLOR */E 55I 55E 55E 50E 35E 32D 39I 37#ifndef DISPLAYBUFFERE 39I 39D 40#ifdef DISPLAYBUFFERE 40I 40#ifndef DISPLAYBUFFERE 40E 39E 37D 32	size = ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) ) E 32I 32D 35	size = ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) )E 35I 35    size = ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) )E 35E 32			& -getpagesize());D 35	if((HideDisp68k= valloc(size)) == 0){		  printf("can't valloc hide space\n");		  return(-1);	}E 35I 35D 47    if((HideDisp68k= valloc(size)) == 0)E 47I 47    if((HideDisp68k= malloc(size)) == 0)E 47      {D 47	printf("can't valloc hide space\n");E 47I 47	printf("can't malloc hide space\n");E 47	return(-1);      }E 35D 22	HideBitMap= mem_point(DisplayWidth,DisplayHeight,1,HideDisp68k);	pr_rop( HideBitMap, 0,0,DisplayWidth,DisplayHeight,PIX_SRC,		ScreenBitMap,0,0);	pr_rop(ScreenBitMap,0,0,DisplayWidth,DisplayHeight,		PIX_CLR,ScreenBitMap,0,0);E 22I 22D 26	{E 26I 26D 27	copy_region ( (short *)DisplayRegion68k,		      (short *)HideDisp68k,E 27I 27D 35	copy_region ( DisplayRegion68k,		      HideDisp68k,E 27		      DisplayRasterWidth,		      DisplayHeight );	clear_display();E 35I 35    copy_region ( DisplayRegion68k,		  HideDisp68k,		  DisplayRasterWidth,		  DisplayHeight );I 37D 55#endif DISPLAYBUFFERE 55I 55#endif /* DISPLAYBUFFER */E 55I 55E 55I 43#ifdef COLOR	save_colormap();#ifndef DISPLAYBUFFER	if( Inited_Color ) {#else 	if( MonoOrColor == COLOR_SCREEN ) { D 55#endif DISPLAYBUFFERE 55I 55#endif /* DISPLAYBUFFER */E 55		/* save color image */		size = ((DisplayWidth * DisplayHeight + (getpagesize()-1) )				& -getpagesize()); /* 8 bit depth */D 47		if((HideColorDisp68k= valloc(size)) == 0){			printf("can't valloc hide space\n");E 47I 47		if((HideColorDisp68k= malloc(size)) == 0){			printf("can't malloc hide space\n");E 47			return(-1);		}		copy_region( ColorDisplayRegion68k,		      		HideColorDisp68k,		      		DisplayRasterWidth * 8,		      		DisplayHeight );	} /* end if(MonoOrColor) */	D 55#endif COLORE 55I 55#endif /* COLOR */E 55I 55E 55E 43E 37    clear_display();E 35I 37#ifdef DISPLAYBUFFER	pr_close(ColorDisplayPixrect);I 43	close(FrameBufferFd);E 43#endifI 44    if (Win_security_p) {	    switch (vfork()) {		  case -1:	/* Error */		    (void)fprintf(stderr, "display_before_exit: Fork failed.\n");		    exit(1);		  case 0:	/* Child */		    (void)execl(SV_RELEASE, "sv_release", 0);		    /* should not return */		    (void)fprintf(stderr,				  "display_before_exit: exec for sv_release failed\n");		    exit(1);		  default:	/* Parent */		    /* do nothing */		    break;	    }	    (void)wait(&status); /* child dies after changing 16 */	    if (status.w_retcode != 0) {		    (void)fprintf(stderr,				  "device_before_raid: failed to set ownership of win devices\n");		    exit(1);	    }    }E 44I 39D 55#endif SUNDISPLAYE 55I 55#endif /* SUNDISPLAY */E 55E 39I 55E 55E 37D 27/****	{E 26	register short *src, *dst;	register int w, h;	src = (short *)DisplayRegion68k;	dst = (short *)HideDisp68k;	for (h = DisplayHeight; (h--);)	  {	  for (w = DisplayRasterWidth; (w--);) 	    {	    *dst++ = *src;	    *src++ = 0;	    }	  }D 26	}E 26I 26	}   ****/E 27E 26E 22D 35	return(0);}E 35I 35    return(0);  }E 35/**char *alloc_hideDISP(size)int size;{ char *retaddr; switch(*STORAGEFULLSTATE_word & 0xffff)  {	case SFS_NOTSWITCHABLE :D 47		if((retaddr =valloc(size)) ==0){E 47I 47		if((retaddr =malloc(size)) ==0){E 47D 34			fprintf(stderr,"can't alloc hide disp\n");E 34I 34			fprintf(stderr,"can't alloc hide space\n");E 34		 }		break;	case 0 :	case SFS_SWITCHABLE :D 32		retaddr = E 32I 32		retaddr =E 32D 55		 (char*)Addr68k_from_LADDR((*ArraySpace2_word) & 0xffffff);E 55I 55		 (char*)Addr68k_from_LADDR((*ArraySpace2_word) & POINTERMASK);E 55		printf("Hidespace inside Lisp(2)\n");		break;	case SFS_ARRAYSWITCHED :		retaddr=(char*)Addr68k_from_LADDR(*Next_Array_word & 0xffff);;		printf("Hidespace inside Lisp(3)\n");		break;	case SFS_FULLYSWITCHED :D 32		if((int)Addr68k_from_LADDR(*Next_MDSpage_word & 0xffff) E 32I 32		if((int)Addr68k_from_LADDR(*Next_MDSpage_word & 0xffff)E 32			- (int)Addr68k_from_LADDR(*Next_Array_word & 0xffff)		 >size) {			retaddr= (char*)Addr68k_from_LADDR(*Next_Array_word & 0xffff);			printf("Hidespace inside Lisp(4)\n");		 }D 47		else if((retaddr=valloc(size)) ==0){E 47I 47		else if((retaddr=malloc(size)) ==0){E 47			fprintf(stderr,"can't alloc hide disp\n");			 }			printf("Hidespace new\n");		break;	default : printf("Illegal data in STORAGEFULLSTATE\n");		  retaddr=0;		 break;D 32  } E 32I 32  }E 32 return(retaddr);}****/I 35E 35/***********************************************************************//*	func name : device_after_raid()	Written by : Takeshi Shimizu	Date:   6-May-1988D 34 	This should be called when returning LISP.E 34I 34	This should be called when returning LISP.E 34D 32	E 32I 32E 32*//***********************************************************************/I 11#define KB_ALLUP		0xffffE 11device_after_raid()D 35{I 11extern DLword  *EmMouseX68K, *EmMouseY68K, *EmKbdAd068K, *EmRealUtilin68K;extern DLword  *EmKbdAd168K,*EmKbdAd268K,*EmKbdAd368K,*EmKbdAd468K,*EmKbdAd568K;E 11	LispReadFds = 0;D 17	re_init_display(DISPALY_OFFSET,65536 * 16 *2);E 17I 17D 26	if(re_init_display(DISPALY_OFFSET,65536 * 16 *2)== -1)E 26I 26	if(re_init_display(DISPLAY_OFFSET,65536 * 16 *2)== -1)E 35I 35  {    extern DLword  *EmMouseX68K, *EmMouseY68K,		   *EmKbdAd068K, *EmRealUtilin68K;    extern DLword  *EmKbdAd168K,*EmKbdAd268K,*EmKbdAd368K,		   *EmKbdAd468K,*EmKbdAd568K;    LispReadFds = 0;    if(re_init_display(DISPLAY_OFFSET,65536 * 16 *2)== -1)E 35E 26		return(-1);E 17D 35	set_cursor();D 29	init_keyboard();E 29I 29	init_keyboard(1);E 29	init_ether();D 32	int_init(); E 32I 32	int_init();E 32	LispReadFds |= (1 << LispWindowFd) ;	int_timer_on();I 11 *EmKbdAd068K= *EmRealUtilin68K= *EmKbdAd168K= *EmKbdAd268K= *EmKbdAd368K= *EmKbdAd468K= *EmKbdAd568K=KB_ALLUP ;E 11D 17E 17I 17 return(0);E 17} /* device_after_raid */E 35I 35    set_cursor();    init_keyboard(1);I 50#ifdef TRUECOLOR	truecolor_after_raid();D 55#endif TRUECOLORE 55I 55#endif /* TRUECOLOR */E 55I 55E 55E 50I 45#ifdef NOETHER#elseE 45    init_ether();I 45D 55#endif NOETHERE 55I 55#endif /* NOETHER */E 55E 45    int_init();I 39#ifdef SUNDISPLAYE 39    LispReadFds |= (1 << LispWindowFd) ;I 39D 55#endif SUNDISPLAYE 55I 55#endif /* SUNDISPLAY */E 55D 45E 45I 45#ifdef NOETHER#elseE 45E 39D 38    LispReadFds |= (1 << ether_fd) ;E 38I 38    LispReadFds |= (1 << EtherReadFds) ;I 39D 45E 45I 45D 55#endif NOETHERE 55I 55#endif /* NOETHER */E 55E 45#ifdef XWINDOW	Xevent_after_raid();D 55#endif XWINDOWE 55I 55	LispReadFds |= (1 << Xfd);#endif /* XWINDOW */E 55I 55E 55E 39E 38    int_timer_on();    *EmKbdAd068K= *EmRealUtilin68K= *EmKbdAd168K=                  *EmKbdAd268K= *EmKbdAd368K=                  *EmKbdAd468K= *EmKbdAd568K=KB_ALLUP ;    return(0);  } /* device_after_raid */E 35I 35E 35/***********************************************************************//*	func name :re_init_display(lisp_display_addr, display_max)			int lisp_display_addr, display_max;	Written by : Takeshi Shimizu	Date:   6-May-1988D 34 	This should be called when returning LISP.E 34I 34	This should be called when returning LISP.E 34	Only called by device_after_raidD 32	E 32I 32E 32*//***********************************************************************/D 43E 43I 43#ifndef COLORE 43re_init_display(lisp_display_addr, display_max)D 35	int lisp_display_addr, display_max;{	int mmapstat, size;I 31	struct pixrect *ColorFb;E 35I 35  int lisp_display_addr, display_max;  {    int mmapstat, size;    struct pixrect *ColorFb;E 35D 32	E 32I 32D 37E 37I 37    extern struct pixrect *ColorDisplayPixrect,*DisplayRegionPixrect;E 37E 32D 35	extern int DisplayType;E 35I 35    extern int DisplayType;E 35E 31I 39#ifdef SUNDISPLAYI 44    union wait status;    if (Win_security_p) {	    switch (vfork()) {		  case -1:	/* Error */		    (void)fprintf(stderr, "re_init_display: Fork failed.\n");		    exit(1);		  case 0:	/* Child */		    (void)execl(SV_ACQUIRE, "sv_acquire", "0", "256", "250", 0);		    /* should not return */		    (void)fprintf(stderr, "re_init_display: exec for sv_acquire failed\n");		    exit(1);		  default:	/* Parent */		    /* do nothing */		    break;	    }	    (void)wait(&status); /* child dies after changing 6 */	    if (status.w_retcode != 0) {		    (void)fprintf(stderr,				  "re_init_display: failed to set ownership of win devices\n");		    exit(1);	    }    }E 44E 39D 35	mess_init();	if( (LispWindowFd = win_screennew( &LispScreen )) == -1){		fprintf( stderr, "init_display: can't create LispWindow\n");		return( -1 );D 12	} else  int_io_open(LispWindowFd);E 12I 12	}I 13	else {E 35I 35    mess_init();    if( (LispWindowFd = win_screennew( &LispScreen )) == -1)      {	fprintf( stderr, "init_display: can't create LispWindow\n");	return( -1 );      }    else       {E 35E 13#ifdef KBINTD 13	else  int_io_open(LispWindowFd);E 13I 13D 35		int_io_open(LispWindowFd);		fcntl(LispWindowFd, F_SETFL, fcntl(LispWindowFd, F_GETFL, 0)| FNDELAY);E 35I 35	int_io_open(LispWindowFd);	fcntl(LispWindowFd, F_SETFL, fcntl(LispWindowFd, F_GETFL, 0)| FNDELAY);I 50#ifdef FX_AR_124	/* For AR 124. Type4 driver bug?? by m.matsuda */	{ long i; for( i=0 ; i<900000 ; i++ ) ; }D 55#endif FX_AR_124E 55I 55#endif /* FX_AR_124 */E 55I 55E 55E 50E 35E 13#endifI 31D 35	}E 35I 35      }E 35I 35#ifndef DISPLAYBUFFERE 35/* for CGFOUR dev */D 35	if(DisplayType == SUN4COLOR){	  ColorFb = pr_open("/dev/fb");	  pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);	  pr_rop(ColorFb, 0, 0, ColorFb->pr_width, ColorFb->pr_height,E 35I 35    if(DisplayType == SUN4COLOR)      {	ColorFb = pr_open("/dev/fb");	pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);	pr_rop(ColorFb, 0, 0, ColorFb->pr_width, ColorFb->pr_height,E 35		PIX_SET, 0, 0, 0);D 35	  pr_set_plane_group(ColorFb, PIXPG_OVERLAY);E 35I 35	pr_set_plane_group(ColorFb, PIXPG_OVERLAY);      }#else	/* DISPLAYBUFFER is T */D 37    ColorDisplayPixrect = pr_open("/dev/fb");E 37I 37/*  ColorDisplayPixrect = pr_open("/dev/fb");E 37    pr_putcolormap(ColorDisplayPixrect, 1, 1, &black, &black, &black);    pr_putcolormap(ColorDisplayPixrect, 0, 1, &white, &white, &white);    pr_putcolormap(ColorDisplayPixrect, 255, 1, &black, &black, &black);    pr_putcolormap(ColorDisplayPixrect, 		   (1<<ColorDisplayPixrect->pr_depth)-1, 1,		   &black, &black, &black);E 35D 37E 37I 37***/E 37E 31I 13D 35	}E 35I 35D 55#endif DISPLAYBUFFERE 55I 55#endif /* DISPLAYBUFFER */E 55E 35E 13E 12I 55E 55I 35    init_cursor();E 35D 32	init_cursor(); 	size = ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) ) E 32I 32D 35	init_cursor();	size = ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) )E 35I 35#ifndef DISPLAYBUFFER    size = ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) )E 35E 32			& -getpagesize());D 28	mmapstat = E 28I 28D 35	mmapstat = (int)E 35I 35    mmapstat = (int)E 35E 28		mmap( DisplayRegion68k,D 25		      size,D 24		      PROT_READ | PROT_WRITE, MAP_SHARED, FrameBufferFd, 0 );E 24I 24		      PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED,			  FrameBufferFd, 0 );E 25I 25D 34		      	size,		      	PROT_READ | PROT_WRITE,E 34I 34			size,			PROT_READ | PROT_WRITE,E 34D 32#ifdef OS4 			MAP_FIXED | E 32I 32#ifdef OS4			MAP_FIXED |E 32D 35#endifE 35I 35D 55#endif OS4E 55I 55#endif /* OS4 */E 55E 35			MAP_SHARED,			FrameBufferFd, 0 );E 25E 24D 32	E 32I 32E 32D 23	if(mmapstat != 0){E 23I 23D 35	if(mmapstat == -1){E 23		fprintf( stderr, "re_init_display: ERROR at mmap system call\n");		fprintf( stderr, "errno = %d\n\n", errno );		return( 0 );	}E 35I 35    if(mmapstat == -1)      {	fprintf( stderr, "re_init_display: ERROR at mmap system call\n");	fprintf( stderr, "errno = %d\n\n", errno );	return( 0 );      }D 37#endif DISPLAYBUFFERE 37E 35D 22	pr_rop(ScreenBitMap,0,0,DisplayWidth,DisplayHeight,PIX_CLR,		ScreenBitMap,0,0);	pr_rop( ScreenBitMap, 0, 0, DisplayWidth, DisplayHeight,PIX_SRC | PIX_DST,		HideBitMap, 0, 0);E 22I 22D 26	{	register short *src, *dst;	register int w, h;	dst = (short *)DisplayRegion68k;	src = (short *)HideDisp68k;	for (h = DisplayHeight; (h--);)	  {	  for (w = DisplayRasterWidth; (w--);) 	    {	    *dst++ = *src++;	    }	  }	}E 26I 26D 27	copy_region ( (short *)HideDisp68k,		      (short *)DisplayRegion68k,E 27I 27D 35	copy_region ( HideDisp68k,		      DisplayRegion68k,E 27		      DisplayRasterWidth,		      DisplayHeight );E 35I 35    copy_region ( HideDisp68k,		  DisplayRegion68k,		  DisplayRasterWidth,		  DisplayHeight );E 35E 26E 22D 22	pr_close(HideBitMap);E 22D 35	free(HideDisp68k);	return(0);}E 35I 35    free(HideDisp68k);I 37D 55#endif DISPLAYBUFFERE 55I 55#endif /* DISPLAYBUFFER */E 55E 37I 55E 55#ifdef DISPLAYBUFFERD 37    flush_display_buffer();E 37I 37     ColorDisplayPixrect = pr_open("/dev/fb");D 40    /* flush_display_buffer();*/     refresh_CG6;E 40I 40     flush_display_buffer();/*     refresh_CG6; */E 40E 37D 55#endif DISPLAYBUFFERI 39#endif SUNDISPLAYE 55I 55#endif /* DISPLAYBUFFER */E 55I 55#endif /* SUNDISPLAY */E 55E 39    return(0);  }E 35I 43D 55#else COLORE 55I 55#else /* COLOR */E 55re_init_display(lisp_display_addr, display_max)  int lisp_display_addr, display_max;  {    int mmapstat, size;    struct pixrect *ColorFb;/*    extern struct pixrect *color_source;*/    struct pixrect *color_source;    extern int DisplayType;#ifdef SUNDISPLAYI 44    union wait status;    if (Win_security_p) {	    switch (vfork()) {		  case -1:	/* Error */		    (void)fprintf(stderr, "re_init_display: Fork failed.\n");		    exit(1);		  case 0:	/* Child */		    (void)execl(SV_ACQUIRE, "sv_acquire", "0", "256", "250", 0);		    /* should not return */		    (void)fprintf(stderr, "re_init_display: exec for sv_acquire failed\n");		    exit(1);		  default:	/* Parent */		    /* do nothing */		    break;	    }	    (void)wait(&status); /* child dies after changing 6 */	    if (status.w_retcode != 0) {		    (void)fprintf(stderr,				  "re_init_display: failed to set ownership of win devices\n");		    exit(1);	    }    }E 44    mess_init();    if( (LispWindowFd = win_screennew( &LispScreen )) == -1)      {	fprintf( stderr, "init_display: can't create LispWindow\n");	return( -1 );      }    else       {#ifdef KBINT	int_io_open(LispWindowFd);	fcntl(LispWindowFd, F_SETFL, fcntl(LispWindowFd, F_GETFL, 0)| FNDELAY);#endif      }#ifdef DISPLAYBUFFER	if( (FrameBufferFd = open( LispScreen.scr_fbname, 2 )) == -1){		perror("init_display: can't open FrameBuffer\n");		exit( -1 );	}D 55#endif DISPLAYBUFFERE 55I 55#endif /* DISPLAYBUFFER */E 55I 55E 55	restore_colormap();	if( MonoOrColor == MONO_SCREEN ) {#ifndef DISPLAYBUFFER		/* for CGFOUR dev */		if(DisplayType == SUN4COLOR) {			ColorFb = pr_open("/dev/fb");			pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);			pr_rop(ColorFb, 0, 0, ColorFb->pr_width, ColorFb->pr_height,					PIX_SET, 0, 0, 0);			pr_set_plane_group(ColorFb, PIXPG_OVERLAY);		}#else	/* DISPLAYBUFFER is T */		/*  ColorDisplayPixrect = pr_open("/dev/fb");		    pr_putcolormap(ColorDisplayPixrect, 1, 1, &black, &black, &black);		    pr_putcolormap(ColorDisplayPixrect, 0, 1, &white, &white, &white);		    pr_putcolormap(ColorDisplayPixrect, 255, 1, &black, &black, &black);		    pr_putcolormap(ColorDisplayPixrect, 				   (1<<ColorDisplayPixrect->pr_depth)-1, 1,				   &black, &black, &black);***/D 55#endif DISPLAYBUFFERE 55I 55#endif /* DISPLAYBUFFER */E 55I 55E 55		init_cursor();#ifndef DISPLAYBUFFER		size = ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) )				& -getpagesize());    		mmapstat = (int)				mmap( DisplayRegion68k,					size,					PROT_READ | PROT_WRITE,#ifdef OS4					MAP_FIXED |D 55#endif OS4E 55I 55#endif /* OS4 */E 55					MAP_SHARED,					FrameBufferFd, 0 );		if( Inited_Color )			mmapstat = (int)					mmap( ColorDisplayRegion68k,						Dispcolorsize,						PROT_READ | PROT_WRITE,#ifdef OS4						MAP_FIXED |D 55#endif OS4E 55I 55#endif /* OS4 */E 55						MAP_SHARED,						FrameBufferFd, 0x40000 );    		if(mmapstat == -1)   		   {			fprintf( stderr, "re_init_display: ERROR at mmap system call\n");			fprintf( stderr, "errno = %d\n\n", errno );			return( 0 );  		   }			/* restore mono image */		    copy_region ( HideDisp68k,				  DisplayRegion68k,				  DisplayRasterWidth,				  DisplayHeight );		    free(HideDisp68k);			if( Inited_Color ) { /* restore color image */				copy_region( HideColorDisp68k					   , ColorDisplayRegion68k					   , DisplayRasterWidth * 8					   , DisplayHeight );				free(HideColorDisp68k);			} /* end if( Inited_Color ) */D 55#endif DISPLAYBUFFERE 55I 55#endif /* DISPLAYBUFFER */E 55I 55E 55#ifdef DISPLAYBUFFER		     ColorDisplayPixrect = pr_open("/dev/fb");		     flush_display_buffer();		/*     refresh_CG6; */D 55#endif DISPLAYBUFFERE 55I 55#endif /* DISPLAYBUFFER */E 55I 55E 55	} else { /* MonoOrColor is COLOR_SCREEN */		ColorFb = pr_open("/dev/fb");#ifdef DISPLAYBUFFER		ColorDisplayPixrect = ColorFb;D 55#endif DISPLAYBUFFERE 55I 55#endif /* DISPLAYBUFFER */E 55		color_source = mem_point(DisplayWidth,DisplayHeight,8,ColorDisplayRegion68k);		pr_rop(ColorFb,0,0,DisplayWidth,DisplayHeight,PIX_SRC,color_source,0,0);#ifndef DISPLAYBUFFER		pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);		pr_rop(ColorFb,0,0,ColorFb->pr_width, ColorFb->pr_height,					PIX_CLR, 0, 0, 0);D 55#endif DISPLAYBUFFERE 55I 55#endif /* DISPLAYBUFFER */E 55		pr_set_plane_group(ColorFb, PIXPG_8BIT_COLOR);		init_cursor();		mmapstat = (int)mmap(ColorDisplayRegion68k ,					Dispcolorsize,					PROT_READ | PROT_WRITE,#ifdef OS4					MAP_FIXED |#endif					MAP_SHARED,					FrameBufferFd, 0x40000 );		if(mmapstat == -1){		    perror("cgfour_init_color_display: ERROR at mmap system call\n");		    error("cgfour_init_color_display: ERROR at mmap system call\n You may be able to continue by typing 'q'");/*		    printf("MMAP FAIL:BMBASE=0x%x\nNATIVE:= 0x%x\nLISPBASEN:= 0x%x\n",			color_bitmapbase,ColorDisplayRegion68k,Lisp_world);*/			return(NIL);		} /* end if(mmapstat) */#ifndef DISPLAYBUFFER		/* restore mono image */		copy_region ( HideDisp68k,			      DisplayRegion68k,			      DisplayRasterWidth,			      DisplayHeight );		free(HideDisp68k);D 55#endif DISPLAYBUFFERE 55I 55#endif /* DISPLAYBUFFER */E 55I 55E 55		/* restore coloe image */		copy_region ( HideColorDisp68k,			      ColorDisplayRegion68k,			      DisplayRasterWidth * 8,			      DisplayHeight );		free(HideColorDisp68k);	} /* end if(MonoOrColor) */D 55#endif SUNDISPLAYE 55I 55#endif /* SUNDISPLAY */E 55I 55E 55    return(0);  }D 55#endif COLORE 55I 55#endif /* COLOR */E 55E 43E 1