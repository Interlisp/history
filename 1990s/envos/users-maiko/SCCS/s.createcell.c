h57918s 00008/00009/00219d D 2.9 90/06/15 16:52:33 mitani 14 13c GCLOOKUPes 00000/00000/00228d D 2.8 90/04/20 01:26:09 sybalsky 13 12c   shortening file names, bulk change.es 00016/00017/00212d D 2.7 90/02/21 18:46:46 sybalsky 12 11c add 386i WORDPTR/GETWORD refs.  Reformat codees 00000/00000/00229d D 2.6 89/03/27 10:36:23 sybalsky 11 10c word order fixes:  None needed.es 00003/00094/00226d D 2.5 88/10/12 14:41:34 krivacic 10 9c new out-of-line interfacees 00053/00000/00267d D 2.4 88/08/11 09:46:26 krivacic 9 8c add native routine Create_n_Set_Celles 00004/00004/00263d D 2.3 88/06/03 12:37:02 masinter 8 7c Make createcell increment allocation counteres 00068/00064/00199d D 2.2 88/05/27 14:55:48 krivacic 7 6c C_ONLY ifdefes 00000/00000/00263d D 2.1 88/05/17 09:23:04 hayata 6 5c Version up to 2.1es 00003/00003/00260d D 1.5 88/05/09 21:20:44 shih 5 4c Use GCLOOKUPes 00001/00017/00262d D 1.4 88/04/25 12:13:14 krivacic 4 3c es 00081/00000/00198d D 1.3 88/04/13 17:50:45 krivacic 3 2c added N_OP_createcelles 00002/00002/00196d D 1.2 88/03/13 14:35:32 hayata 2 1c Add SCCS key id (%Z%)es 00198/00000/00000d D 1.1 88/02/24 16:56:14 hayata 1 0c date and time created 88/02/24 16:56:14 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 2/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 8 *	Auther :  Takeshi ShimizuE 8I 8 *	Author :  Takeshi ShimizuE 8 * */E 12I 12D 14/* This is G-file @(#) createcell.c Version 2.6 (3/27/89). copyright Xerox & Fuji Xerox  */static char *id = "@(#) createcell.c	2.6 3/27/89";E 14I 14/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 14D 14E 14/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 12/***********************************************************************//* 		File Name :	createcell.c		Desc	:	  				Date :		Jun. 4, 1987 				Edited by :	Takeshi Shimizu				Changed :	9 Jun 1987 take						26 Oct. 1987 take(add mask) 		Including :	OP_createcell								*//**********************************************************************/#include "lispemul.h"#include "lispmap.h"#include "emulglobal.h"#include "lispglobal.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "cell.h" #include "gc.h"  LispPTR *alloc_mdspage();LispPTR initmdspage();I 7D 10#ifdef C_ONLYE 7OP_createcell(){  register struct dtd *dtd68k;  register DLword *ptr,*lastptr;  register LispPTR newcell ;  register unsigned int type ;#ifdef TRACE	printf("TRACE : OP_createcell");#endif  if((TopOfStack & 0xff0000) != S_POSITIVE)	error("OP_createcell : Type is not specified as SMALLP");  type = TopOfStack & 0xffff ;#ifdef DEBUG  if(type==TYPE_LISTP)	error("OP_createcell : Can't create Listp cell with CREATECELL");	check_dtd_chain(type);#endif    dtd68k = (struct dtd *)GetDTD(type);  if(dtd68k->dtd_size == 0)	error("OP_createcell : Attempt to create a cell not declared yet");retry :  if((TopOfStack=newcell=((dtd68k->dtd_free)&0xffffff)) != NIL)  {#ifdef DEBUG	if(type != GetTypeNumber(newcell)) 	  error("OP_createcell : BAD cell in dtdfree");#endif	ptr = (DLword *)Addr68k_from_LADDR(newcell);	/* replace dtd_free with newcell's top DLword (it may keep next chain)*/	dtd68k->dtd_free = (*((LispPTR *)ptr)) & 0xffffff;#ifdef DEBUG	if((dtd68k->dtd_free !=0) && (type != GetTypeNumber(dtd68k->dtd_free))) 	  error("OP_createcell : BAD cell in next dtdfree");		check_dtd_chain(type);#endif	dtd68k->dtd_oldcnt++;	/* clear 0  */	for(lastptr=ptr + dtd68k->dtd_size ;		ptr != lastptr ; ptr++)	  {  *ptr = 0 ; }D 8	 /* createref(); but not impl. RECLAIMCOUNTDOWN */E 8I 8	 IncAllocCnt(1);E 8D 5	 gclookup(0x8000|DELREF , TopOfStack);E 5I 5	 GCLOOKUP(0x8000,DELREF , TopOfStack);E 5	PC++;	  }  else  {	dtd68k->dtd_free = initmdspage(alloc_mdspage(dtd68k->dtd_typeentry) , 				dtd68k->dtd_size ,NIL);	goto retry ;  }#ifdef DEBUG/*********FOR DEBUG AID **********************************//**********************************************************/	check_dtd_chain(type);#endif} /* OP_createcell end */I 7#elseE 7I 7LispPTR N_OP_createcell(tos, error_addr)E 10I 10LispPTR N_OP_createcell(tos)E 10	register LispPTR tos;D 10	int *error_addr;E 10{  register struct dtd *dtd68k;  register DLword *ptr,*lastptr;  register LispPTR newcell ;  register unsigned int type ;D 10#ifdef TRACE	printf("TRACE : N_OP_createcell");#endif  if((tos & 0xff0000) != S_POSITIVE) ERROR_EXIT(error_addr);E 10I 10  if((tos & 0xff0000) != S_POSITIVE) ERROR_EXIT(tos);E 10  type = tos & 0xffff ;#ifdef DEBUG  if(type==TYPE_LISTP)	error("N_OP_createcell : Can't create Listp cell with CREATECELL");	check_dtd_chain(type);#endif    dtd68k = (struct dtd *)GetDTD(type);D 10  if(dtd68k->dtd_size == 0) ERROR_EXIT(error_addr);E 10I 10  if(dtd68k->dtd_size == 0) ERROR_EXIT(tos);E 10  /* error("OP_createcell : Attempt to create a cell not declared yet"); */retry :  if((tos=newcell=((dtd68k->dtd_free)&0xffffff)) != NIL)  {	ptr = (DLword *)Addr68k_from_LADDR(newcell);	/* replace dtd_free with newcell's top DLword (it may keep next chain)*/	dtd68k->dtd_free = (*((LispPTR *)ptr)) & 0xffffff;	dtd68k->dtd_oldcnt++;	/* clear 0  */	for(lastptr=ptr + dtd68k->dtd_size ;		ptr != lastptr ; ptr++)D 12	  {  *ptr = 0 ; }E 12I 12	  {  GETWORD(ptr) = 0 ; }E 12D 8	 /* createref(); but not impl. RECLAIMCOUNTDOWN */E 8I 8D 14	 IncAllocCnt(1);E 8	 GCLOOKUP(0x8000,DELREF , tos);E 14I 14/*	 IncAllocCnt(1); */	 GCLOOKUP(tos, DELREF);E 14	 return(tos);  }  else  {	dtd68k->dtd_free = initmdspage(alloc_mdspage(dtd68k->dtd_typeentry) , 				dtd68k->dtd_size ,NIL);	goto retry ;  }} /* N_OP_createcell end */D 10#endifE 10E 7DLword *createcell68k(type) unsigned int type;{  register struct dtd *dtd68k;  register DLword *ptr,*lastptr;  register ConsCell *newcell68k;  register LispPTR newcell ;#ifdef DEBUG  if(type==TYPE_LISTP)	error("createcell : Can't create Listp cell with CREATECELL");  if(type==TYPE_STREAM) stab();	check_dtd_chain(type);#endif    dtd68k = (struct dtd *)GetDTD(type);  if(dtd68k->dtd_size == 0)	error("createcell : Attempt to create a cell not declared yet");retry :  if((newcell=(dtd68k->dtd_free & 0xffffff)) != NIL)  {#ifdef DEBUG	if(type != GetTypeNumber(newcell)) 	  error("createcell : BAD cell in dtdfree");	if(newcell > 0xFFFFFF)		error("createcell : BAD Lisp address");#endif	ptr = Addr68k_from_LADDR(newcell) ;	/* replace dtd_free with newcell's top DLword (it may keep next chain)*/	dtd68k->dtd_free = (*((LispPTR *)ptr)) & 0xFFFFFF ;#ifdef DEBUG	if((dtd68k->dtd_free!=0)&&(type != GetTypeNumber(dtd68k->dtd_free)) )	  error("createcell : BAD cell in next dtdfree");	check_dtd_chain(type);#endif	dtd68k->dtd_oldcnt++;	/* clear 0  */	for(lastptr=ptr + dtd68k->dtd_size ;		ptr != lastptr ; ptr++)D 12	  {  *ptr = 0 ; }E 12I 12	  {  GETWORD(ptr) = 0 ; }E 12D 8	 /* createref(); */E 8I 8D 14	IncAllocCnt(1);E 8D 5	gclookup(0x8000|DELREF , newcell);E 5I 5	GCLOOKUP(0x8000,DELREF , newcell);E 14I 14/*	IncAllocCnt(1); */	GCLOOKUP(newcell, DELREF);E 14E 5#ifdef DEBUGD 12/*********FOR DEBUG AID **********************************//**********************************************************/E 12	check_dtd_chain(type);#endif	return(Addr68k_from_LADDR(newcell));	  }  else  {	dtd68k->dtd_free = initmdspage(alloc_mdspage(dtd68k->dtd_typeentry) , 				dtd68k->dtd_size ,NIL);#ifdef DEBUGD 12/*********FOR DEBUG AID **********************************//**********************************************************/E 12	check_dtd_chain(type);#endif	goto retry ;  }} /* createcell68k end */I 3D 7/* ******************************************************************* */LispPTR N_OP_createcell(tos, error_addr)	register LispPTR tos;	int *error_addr;{  register struct dtd *dtd68k;  register DLword *ptr,*lastptr;  register LispPTR newcell ;  register unsigned int type ;#ifdef TRACE	printf("TRACE : N_OP_createcell");#endif  if((tos & 0xff0000) != S_POSITIVE) ERROR_EXIT(error_addr);  type = tos & 0xffff ;#ifdef DEBUG  if(type==TYPE_LISTP)	error("N_OP_createcell : Can't create Listp cell with CREATECELL");	check_dtd_chain(type);#endif    dtd68k = (struct dtd *)GetDTD(type);  if(dtd68k->dtd_size == 0) ERROR_EXIT(error_addr);  /* error("OP_createcell : Attempt to create a cell not declared yet"); */retry :  if((tos=newcell=((dtd68k->dtd_free)&0xffffff)) != NIL)  {D 4#ifdef DEBUG	if(type != GetTypeNumber(newcell)) 	  error("N_OP_createcell : BAD cell in dtdfree");#endifE 4	ptr = (DLword *)Addr68k_from_LADDR(newcell);	/* replace dtd_free with newcell's top DLword (it may keep next chain)*/	dtd68k->dtd_free = (*((LispPTR *)ptr)) & 0xffffff;D 4#ifdef DEBUG	if((dtd68k->dtd_free !=0) && (type != GetTypeNumber(dtd68k->dtd_free))) 	  error("N_OP_createcell : BAD cell in next dtdfree");		check_dtd_chain(type);#endifE 4	dtd68k->dtd_oldcnt++;	/* clear 0  */	for(lastptr=ptr + dtd68k->dtd_size ;		ptr != lastptr ; ptr++)	  {  *ptr = 0 ; }	 /* createref(); but not impl. RECLAIMCOUNTDOWN */D 5	 gclookup(0x8000|DELREF , tos);E 5I 5	 GCLOOKUP(0x8000,DELREF , tos);E 5I 4	 return(tos);E 4  }  else  {	dtd68k->dtd_free = initmdspage(alloc_mdspage(dtd68k->dtd_typeentry) , 				dtd68k->dtd_size ,NIL);	goto retry ;  }D 4#ifdef DEBUG/*********FOR DEBUG AID **********************************//**********************************************************/	check_dtd_chain(type);#endifE 4} /* N_OP_createcell end */E 7I 9/**********************************************************//*  Create a Cell of Specified Type & Set to given Value  *//*  Works with 32 bit typed values only.                  *//*  (Initially used only by native code)                  *//**********************************************************/LispPTR Create_n_Set_Cell(type, value) unsigned int type; LispPTR value;{  register struct dtd *dtd68k;  register DLword *ptr,*lastptr;  register ConsCell *newcell68k;  register LispPTR newcell ;    dtd68k = (struct dtd *)GetDTD(type);  if(dtd68k->dtd_size == 0)	error("createcell : Attempt to create a cell not declared yet");retry :  if((newcell=(dtd68k->dtd_free & 0xffffff)) != NIL)  {	ptr = Addr68k_from_LADDR(newcell) ;	/* replace dtd_free with newcell's top DLword (it may keep next chain)*/	dtd68k->dtd_free = (*((LispPTR *)ptr)) & 0xFFFFFF ;	dtd68k->dtd_oldcnt++;	/* clear 0  */	for(lastptr=ptr + dtd68k->dtd_size ;		ptr != lastptr ; ptr++)D 12	  {  *ptr = 0 ; }E 12I 12	  {  GETWORD(ptr) = 0 ; }E 12D 14	IncAllocCnt(1);	GCLOOKUP(0x8000,DELREF , newcell);E 14I 14/*	IncAllocCnt(1); */	GCLOOKUP(newcell, DELREF);E 14	(* ((LispPTR *) Addr68k_from_LADDR(newcell))) = value;	return(newcell);	  }  else  {	dtd68k->dtd_free = initmdspage(alloc_mdspage(dtd68k->dtd_typeentry) , 				dtd68k->dtd_size ,NIL);	goto retry ;  }} /* createcell68k end */E 9E 3E 1