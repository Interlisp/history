h09804s 00000/00000/00910d D 2.5 92/04/21 17:23:29 sybalsky 8 7c shortening file names for DOS \nes 00717/00308/00193d D 2.4 91/10/15 18:22:27 sybalsky 7 6c ISC changeses 00000/00000/00501d D 2.3 90/04/20 01:52:28 sybalsky 6 5c AIX:  shortening file names, bulk change.es 00004/00000/00497d D 2.2 88/06/24 23:05:18 bane 5 4c Added RS232INT ifdefses 00000/00000/00497d D 2.1 88/05/17 09:26:31 hayata 4 3c Version up to 2.1es 00002/00000/00495d D 1.3 88/04/27 09:17:00 bane 3 2c added int_io_open and int_io_close calls for I/O interrupt stuffes 00002/00002/00493d D 1.2 88/03/13 14:56:03 hayata 2 1c Add SCCS key id (%Z%)es 00495/00000/00000d D 1.1 88/02/24 16:58:19 hayata 1 0c date and time created 88/02/24 16:58:19 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";I 7/* FILE: rs232c.c REL.1 SCCSID:1.3  *//* SCCS file: /medley/project1/emul/SCCS/s.rs232c.c  */E 7E 2/*** ADOPTED NEW VERSION ***//*D 7* RS232C driver of Xerox Lisp on SUN.** Copyright (C) 1987 by Fuji Xerox Co.,Ltd.. All rights reserved.***/E 7I 7 * RS232C driver of Xerox Lisp on SUN. * * Copyright (C) 1987, 1988, 1989, 1990, 1991 by Fuji Xerox Co.,Ltd.. All rights reserved. * * */E 7I 7/* Last Edited: 01/19/91 21:48:23 */	E 7#include "rs232c.h"D 7DLRS232C_HDW_CONF 	 	*HardWareConfig;DLRS232C_IOP_GET_FLAG 	 	*RS232CGetFlag;DLRS232C_IOP_PUT_FLAG 	 	*RS232CPutFlag;DLRS232C_IOP_MISC_CMD    	*RS232CMiscCommand;DLRS232C_PARAMETER_OUTCOME 	*RS232CParameterOutcome;E 7I 7/* * Lisp Interface */static DLRS232C_HDW_CONF 	 	*HardWareConfig;static DLRS232C_IOP_GET_FLAG 	 	*RS232CGetFlag;static DLRS232C_IOP_PUT_FLAG 	 	*RS232CPutFlag;static DLRS232C_IOP_MISC_CMD    	*RS232CMiscCommand;static DLRS232C_PARAMETER_OUTCOME 	*RS232CParameterOutcome;static DLRS232C_DEVICE_STATUS		*RS232CDeviceStatus;static DLRS232C_PARAMETER_CSB		*RS232CParameterCSB;static DLword				*RS232CGetCSB	      			,	*RS232CPutCSB;E 7D 7DLword	*RS232CGetCSB      ,	*RS232CPutCSB      ,	*RS232CParameterCSB;E 7I 7/* * File descriptor */extern int 		LispReadFds;static int		RS232C_Fd;int			RS232CReadFds;E 7D 7extern int LispReadFds;E 7I 7int			RS232C_remain_data;static char 		*RS232C_Dev;static struct termios	RS232C_Mode;E 7D 7int	RS232C_Fd;E 7I 7/* * Following two signal handler vector is used to deal with SIGHUP signal * which is sent if CLOCAL flag is not set and a modem disconnect * is detected. */E 7D 7char 	*RS232C_Dev;E 7I 7static struct sigvec	rs_hup_sv;static struct sigvec	prev_hup_sv;E 7D 7char 	*RS232C_WrBufAddr   , 	*RS232C_RdBufAddr;E 7I 7voidrs232c_hup_handler(){	printf("Modem disconnect is detected.\n");	fflush(stdout);	return;}E 7D 7short 	RS232C_WrMaxCount    , 	RS232C_WrCount    , 	RS232C_WrStat    , 	RS232C_RdMaxCount    , 	RS232C_RdCount    , 	RS232C_RdStat;E 7I 7rs_install_hup_handler(){	rs_hup_sv.sv_handler = rs232c_hup_handler;	rs_hup_sv.sv_mask = rs_hup_sv.sv_flags = 0;	sigvec(SIGHUP, &rs_hup_sv, &prev_hup_sv);}E 7D 7struct sgttyb RS232C_Mode;E 7I 7rs_restore_hup_handler(){	sigvec(SIGHUP, &prev_hup_sv, (struct sigvec *)NULL);}E 7D 7DLRS232C_IOCB *RS232C_WrIOCB            , *RS232C_RdIOCB;E 7I 7/* * Fatal Error, enter URAID */rs_error(msg)	char	*msg;{	error(msg);}E 7I 7/* * Continuable Error */rs_cerror(msg)	char	*msg;{	printf(msg);}E 7I 7/* * Invoked at boot time */E 7rs232c_init(){D 7#ifdef TRACE	printf( "TRACE: rs232c_init()\n" );#endifE 7	RS232C_Dev = "/dev/ttyb"; /*Modify for target system */D 7	RS232C_Fd  = (-1);E 7I 7	RS232C_Fd  = -1;E 7	/* Pointer to IOPAGE */D 7	RS232CMiscCommand      = (DLRS232C_IOP_MISC_CMD*)      Addr68k_from_LADDR(IOPAGE_OFFSET+24);	RS232CPutFlag          = (DLRS232C_IOP_PUT_FLAG*)      Addr68k_from_LADDR(IOPAGE_OFFSET+25);	RS232CGetFlag          = (DLRS232C_IOP_GET_FLAG*)      Addr68k_from_LADDR(IOPAGE_OFFSET+26);	RS232CPutCSB           = (DLword*)                     Addr68k_from_LADDR(IOPAGE_OFFSET+49);	RS232CGetCSB           = (DLword*)                     Addr68k_from_LADDR(IOPAGE_OFFSET+51);	RS232CParameterOutcome = (DLRS232C_PARAMETER_OUTCOME*) Addr68k_from_LADDR(IOPAGE_OFFSET+54);	HardWareConfig         = (DLRS232C_HDW_CONF*)          Addr68k_from_LADDR(IOPAGE_OFFSET+100);	RS232CParameterCSB     = (DLword*)                     Addr68k_from_LADDR(IOPAGE_OFFSET+112);E 7I 7	HardWareConfig = (DLRS232C_HDW_CONF *)&IOPage->dliophardwareconfig;	RS232CGetFlag = (DLRS232C_IOP_GET_FLAG *)&IOPage->dlrs232cgetflag;	RS232CPutFlag = (DLRS232C_IOP_PUT_FLAG *)&IOPage->dlrs232cputflag;	RS232CMiscCommand = (DLRS232C_IOP_MISC_CMD *)&IOPage->dlrs232cmisccommand;	RS232CParameterOutcome = (DLRS232C_PARAMETER_OUTCOME *)	  &IOPage->dlrs232cparameteroutcome;	RS232CDeviceStatus = (DLRS232C_DEVICE_STATUS *)&IOPage->dlrs232cdevicestatus;	RS232CParameterCSB = (DLRS232C_PARAMETER_CSB *)&IOPage->dlrs232cparametercsblo_11;	RS232CGetCSB = (DLword *)&IOPage->dlrs232cgetcsblo;	RS232CPutCSB = (DLword *)&IOPage->dlrs232cputcsblo;E 7D 7	HardWareConfig->rs232c_absent = 0; /* Oprion Board Exist */E 7I 7	HardWareConfig->rs232c_absent = 0;	RS232CMiscCommand->busy = 0;E 7D 7	RS232C_WrStat = INACTIVE;	RS232C_RdStat = INACTIVE;E 7I 7}				/* rs232c_init end */E 7D 7	RS232C_WrIOCB = NULL;	RS232C_RdIOCB = NULL;E 7I 7#define MIN_CHARS	256#define MIN_TIME	1E 7D 7	RS232C_WrBufAddr = NULL;	RS232C_RdBufAddr = NULL;} /* rs232c_init end */rs232c_open()E 7I 7/* * Default set up for the RS232C file descriptor * The value of the other parameters not listed below can be changed by user. */rs232_fd_init(fd)	register int	fd;E 7{D 7	int stat;E 7I 7	struct termios	tio;E 7D 7#ifdef TRACE	printf("TRACE: rs232c_open()\n");#endifE 7I 7	if (ioctl(fd, TCGETS, &tio) < 0) {		rs_error("RS232C: rs232c_fd_init: cannot get status");		return 0;	} else {		/* Input Mode */		tio.c_iflag &= ~IGNBRK;		tio.c_iflag &= ~IGNPAR;		tio.c_iflag &= ~IUCLC;E 7D 7	if ( RS232C_Fd < 0) {		if (( RS232C_Fd = open( RS232C_Dev,O_RDWR )) >= 0) {E 7I 7		/* Output Mode */		tio.c_oflag |= OPOST;		tio.c_oflag &= ~OLCUC;		tio.c_oflag &= ~OFILL;		tio.c_oflag &= ~OFDEL;		tio.c_oflag &= ~NLDLY;		tio.c_oflag &= ~CRDLY;		tio.c_oflag &= ~BSDLY;		tio.c_oflag &= ~VTDLY;		tio.c_oflag &= ~FFDLY;E 7D 7			stat = ioctl( RS232C_Fd, TIOCGETP, &RS232C_Mode );			RS232C_Mode.sg_flags = RAW;			stat = ioctl( RS232C_Fd, TIOCSETP, &RS232C_Mode );E 7I 7		/* Control Mode */		tio.c_cflag |= CREAD;		tio.c_cflag |= HUPCL;		tio.c_cflag &= ~CIBAUD;	/* Input Baudrate == Output Baudrate*/E 7D 7			RS232C_WrStat = INACTIVE;			RS232C_RdStat = INACTIVE;E 7I 7		/* Local Modes */		tio.c_lflag &= ~ISIG;		tio.c_lflag &= ~ICANON;		tio.c_lflag &= ~XCASE;		tio.c_lflag &= ~ECHO;		tio.c_lflag &= ~ECHOE;		tio.c_lflag &= ~ECHOK;		tio.c_lflag &= ~ECHONL;		tio.c_lflag &= ~NOFLSH;		tio.c_lflag &= ~TOSTOP;		tio.c_lflag &= ~ECHOCTL;		tio.c_lflag &= ~ECHOPRT;		tio.c_lflag &= ~ECHOKE;		tio.c_lflag &= ~FLUSHO;		tio.c_lflag &= ~PENDIN;E 7D 7			LispReadFds |= ( 1 << RS232C_Fd );I 5#ifdef RS232INTE 5I 3			int_io_open(RS232C_Fd);I 5#endifE 7I 7		/* Minimum and Timeout */		tio.c_cc[VMIN] = MIN_CHARS;		tio.c_cc[VTIME] = MIN_TIME;E 7E 5E 3D 7		} else {			RS232C_Fd = (-1);			error( "RS232C: rs232c_open" );		}E 7I 7		RS232C_Mode = tio;E 7I 7		if (ioctl(fd, TCSETS, &tio) < 0)		  rs_error("RS232C: rs232c_fd_init: cannot set status");		else		  return 1;E 7	}D 7} /* rs232c_open end */	E 7I 7}E 7D 7rs232c_close()E 7I 7rs232c_open()E 7{D 7#ifdef TRACE	printf( "TRACE: rs232c_close()\n" );#endifE 7I 7	if (RS232C_Fd < 0) {E 7I 7		if ((RS232C_Fd = open(RS232C_Dev, O_RDWR)) < 0)		  rs_error("RS232C: rs232c_open: cannot open");		else {			rs232_fd_init();						/* Receive SIGIO on the descriptor */			if (ioctl(RS232C_Fd, I_SETSIG, S_INPUT) < 0)			  rs_error("RS232C: rs232c_open: cannot set signal");			else {				rs_install_hup_handler();E 7D 7	if ( RS232C_Fd >= 0 ) {E 7I 7				LispReadFds |= (RS232CReadFds = 1 << RS232C_Fd);				RS232C_remain_data = 0;			}		}	}}E 7D 7		rs232c_abortinput();		rs232c_readcomp();E 7I 7rs232c_close(){	if (RS232C_Fd >= 0) {E 7I 7		rs232c_abortinput();E 7		rs232c_abortoutput();D 7		rs232c_writecomp();E 7D 7		LispReadFds &= ~( 1 << RS232C_Fd );E 7I 7		rs_restore_hup_handler();E 7I 5D 7#ifdef RS232INTE 5I 3		int_io_close(RS232C_Fd);I 5#endifE 5E 3		close( RS232C_Fd );		RS232C_Fd = (-1);E 7I 7		LispReadFds &= ~RS232CReadFds;/*		if (close(RS232C_Fd) < 0)		  rs_error("RS232C: rs232c_close: cannot close");*/		close(RS232C_Fd);		RS232C_Fd = -1;E 7	}D 7} /* rs232c_close end */E 7I 7}E 7RS232C_readinit(){D 7#ifdef TRACE	printf( "TRACE: rs232c_readinit()\n" );#endif	if ( RS232CGetFlag->busy && ( RS232C_Fd >= 0 ) 				 && ( RS232C_RdStat == INACTIVE ) ) {		RS232C_RdIOCB     = (DLRS232C_IOCB*) Addr68k_from_LADDR(((*(RS232CGetCSB+1) & 0xff)<<16) + *RS232CGetCSB );		RS232C_RdBufAddr  = (char*)          Addr68k_from_LADDR(((RS232C_RdIOCB->block_pointer_hi & 0xff)<<16) + RS232C_RdIOCB->block_pointer_lo );		RS232C_RdMaxCount = RS232C_RdIOCB->byte_count;		RS232C_RdCount    = 0;		if ( !RS232C_RdIOCB->put ) {			RS232C_RdStat = ACTIVE;		} else {			RS232C_RdStat = TERMINATED;		}E 7I 7	if (RS232C_remain_data) {		/*		 * There are other data which we have not read yet.		 * Signaling SIGIO invokes rs232c_read.		 */		kill(getpid(), SIGIO);E 7	}D 7} /* RS232C_readinit end */E 7I 7}E 7D 7RS232C_writeinit()E 7I 7rs232c_lisp_is_ready()E 7{D 7#ifdef TRACE	printf( "TRACE: rs232c_writeinit()\n" );#endifE 7I 7	return(RS232CGetFlag->busy);}E 7D 7	if ( RS232CPutFlag->busy && ( RS232C_Fd >= 0 ) 				 && ( RS232C_WrStat == INACTIVE ) ) {		RS232C_WrIOCB     = (DLRS232C_IOCB*) Addr68k_from_LADDR(((*(RS232CPutCSB+1) & 0xff)<<16) + *RS232CPutCSB  );		RS232C_WrBufAddr  = (char*)          Addr68k_from_LADDR(((RS232C_WrIOCB->block_pointer_hi & 0xff)<<16) + RS232C_WrIOCB->block_pointer_lo );		RS232C_WrMaxCount = RS232C_WrIOCB->byte_count;		RS232C_WrCount    = 0;E 7I 7static struct timeval	sel_tv = {0, 0};E 7D 7		if ( RS232C_WrIOCB->put ) {			RS232C_WrStat = ACTIVE;		} else {			RS232C_WrStat = TERMINATED;		}	}} /* RS232C_writeinit end */RS232C_readcont()E 7I 7rs232c_read()E 7{D 7	short    size		,count;	char    *bufaddr;E 7I 7	register DLRS232C_IOCB	*iocb;	register int		count;	fd_set			readfds;E 7D 7#ifdef TRACE	printf( "TRACE: rs232c_readcont()\n" );#endifE 7I 7	if (RS232C_Fd >= 0) {		if (RS232CGetFlag->busy) {E 7D 7	if  ( RS232C_RdStat == ACTIVE ) {E 7I 7			iocb = (DLRS232C_IOCB*)Addr68k_from_LADDR			  (((*(RS232CGetCSB+1) & 0xff)<<16) + *RS232CGetCSB );E 7D 7		bufaddr = RS232C_RdBufAddr + RS232C_RdCount;		size    = RS232C_RdMaxCount - RS232C_RdCount;E 7I 7			if ((count =			     read(RS232C_Fd,				  (char*)Addr68k_from_LADDR				  (((iocb->block_pointer_hi & 0xff)<<16)				   + iocb->block_pointer_lo),				  iocb->byte_count				  )) < 0) {				((DLRS232C_IOCB_TRANSFER_STATUS *)				 (&iocb->transfer_status))->success = 0;				RS232CGetFlag->busy = 0;				return;			}					((DLRS232C_IOCB_TRANSFER_STATUS *)			 (&(iocb->transfer_status)))->success = 1;			iocb->returned_byte_count = count;			RS232CGetFlag->busy = 0;E 7D 7		if ((count = read( RS232C_Fd, bufaddr, size)) > 0) {			RS232C_RdCount += count;			RS232C_RdStat = TERMINATED;E 7I 7			/*			 * We want to check if the some other data			 * remaining or not.			 */			FD_ZERO(&readfds);			FD_SET(RS232C_Fd, &readfds);			if (select(RS232C_Fd + 1, &readfds, NULL, NULL, &sel_tv) > 0) {				if (FD_ISSET(RS232C_Fd, &readfds))				  RS232C_remain_data = 1;				else				  RS232C_remain_data = 0;			} else {				RS232C_remain_data = 0;			}		} else {			/*			 * SIGIO handler getsignaldata and the successive			 * rs232c_read has been called before Lisp prepares			 * the next buffer.  Turn on RS232C_remain_data to			 * specify to read the remaining data after.			 */			RS232C_remain_data = 1;E 7		}D 7		rs232c_readcomp();E 7	}I 7}E 7D 7} /* RS232C_readcont end */E 7I 7#define MAX_WRITE_TRY	5E 7D 7RS232C_writecont()E 7I 7RS232C_write()E 7{D 7	short    size	        ,count;	char    *bufaddr;E 7I 7	register int		size, count, trynum;	register char		*buf;	register DLRS232C_IOCB	*iocb;E 7D 7#ifdef TRACE	printf( "TRACE: rs232c_writecont()\n" );#endifE 7I 7	iocb = (DLRS232C_IOCB*)	  Addr68k_from_LADDR(((*(RS232CPutCSB+1) & 0xff)<<16) + *RS232CPutCSB );E 7D 7	if  ( RS232C_WrStat == ACTIVE ) {E 7I 7	if (RS232CPutFlag->busy && RS232C_Fd >= 0) {E 7D 7		bufaddr = RS232C_WrBufAddr + RS232C_WrCount;		size    = RS232C_WrMaxCount - RS232C_WrCount;		if (size > 64)  size = 64;E 7I 7		if (iocb->put) {			for (size = iocb->byte_count,			     buf = (char*)			     Addr68k_from_LADDR(((iocb->block_pointer_hi & 0xff)<<16)						+ iocb->block_pointer_lo);			     size > 0;			     size -= count, buf += count) {E 7D 7		if (( count = write( RS232C_Fd, bufaddr, size )) > 0) {			RS232C_WrCount += count;E 7I 7				trynum = 0;				while (trynum < MAX_WRITE_TRY) {					count = write(RS232C_Fd, buf, size);					if (count >= 0) break;					trynum ++;				}E 7D 7			if ( RS232C_WrCount == RS232C_WrMaxCount ) {				RS232C_WrStat = TERMINATED;E 7I 7				if (count < 0) {					((DLRS232C_IOCB_TRANSFER_STATUS *)					 (&(iocb->transfer_status)))->success = 0;					RS232CPutFlag->busy =0;					return;				}E 7			}I 7			((DLRS232C_IOCB_TRANSFER_STATUS *)(&(iocb->transfer_status)))			  ->success = 1;			RS232CPutFlag->busy =0;		} else {			((DLRS232C_IOCB_TRANSFER_STATUS *)(&(iocb->transfer_status)))			  ->success = 1;			RS232CPutFlag->busy =0;E 7		}D 7		rs232c_writecomp();E 7I 7	} else {		((DLRS232C_IOCB_TRANSFER_STATUS *)(&(iocb->transfer_status)))		  ->success = 1;		RS232CPutFlag->busy =0;E 7	}I 7}E 7D 7} /* RS232C_writecont end */E 7RS232C_cmd(){D 7	short command;E 7I 7	if (RS232CMiscCommand->busy) {E 7D 7#ifdef TRACE	printf("TRACE: rs232c_cmd()\n");#endif	if ( RS232CMiscCommand->busy ) {		RS232CParameterOutcome->success = 0; /* success flag off */		if      ( RS232CMiscCommand->command == ON )                   rs232c_open();		else if ( RS232CMiscCommand->command == OFF )                  rs232c_close();		else if ( RS232CMiscCommand->command == BREAK_ON )             rs232c_breakon();		else if ( RS232CMiscCommand->command == BREAK_OFF )            rs232c_breakoff();		else if ( RS232CMiscCommand->command == ABORT_INPUT )          rs232c_abortinput();		else if ( RS232CMiscCommand->command == ABORT_OUTPUT )         rs232c_abortoutput();		else if ( RS232CMiscCommand->command == GET_STATUS )           rs232c_getstatus();		else if ( RS232CMiscCommand->command == MAJOR_SET_PARAMETERS ) rs232c_majorparam();		else if ( RS232CMiscCommand->command == MINOR_SET_PARAMETERS ) rs232c_minorparam();		else			error( "RS232C : rs232c_cmd" );E 7I 7		switch (RS232CMiscCommand->command) {		      case ON:			rs232c_open();		break;		      case OFF:			rs232c_close(); 	break;		      case BREAK_ON:			rs232c_breakon(); 	break;		      case BREAK_OFF:			rs232c_breakoff(); 	break;		      case ABORT_INPUT:			rs232c_abortinput(); 	break;		      case ABORT_OUTPUT:			rs232c_abortoutput(); 	break;		      case GET_STATUS:			rs232c_getstatus(); 	break;		      case MAJOR_SET_PARAMETERS:			rs232c_majorparam(); 	break;		      case MINOR_SET_PARAMETERS:			rs232c_minorparam(); 	break;		      default:			rs_error( "RS232C : RS232C_cmd" );		}		RS232CMiscCommand->busy = 0;	} else {		rs_cerror("RS232C : RS232C_cmd: device busy.");E 7	}D 7	/* success flag */	RS232CParameterOutcome->success = 1;		RS232CMiscCommand->busy = 0;E 7D 7} /* RS232C_cmd end */E 7I 7}E 7rs232c_breakon(){D 7	int stat;E 7D 7#ifdef TRACE	printf( "TRACE: rs232c_breakon()\n" );#endifE 7	if (RS232C_Fd >= 0) {D 7		stat = ioctl( RS232C_Fd, TIOCSBRK, 0 );E 7I 7		if (ioctl(RS232C_Fd, TIOCSBRK, 0) < 0)		  rs_cerror("RS232C: rs232c_breakon");E 7	}D 7} /* rs232c_breakon end */E 7I 7}E 7rs232c_breakoff(){D 7	int stat;#ifdef TRACE	printf( "TRACE: rs232c_breakoff()\n" );#endif	if ( RS232C_Fd >= 0 ) {		stat = ioctl( RS232C_Fd, TIOCCBRK, 0 );E 7I 7	if (RS232C_Fd >= 0) {		if(ioctl(RS232C_Fd, TIOCCBRK, 0) < 0)		  rs_cerror("RS232C: rs232c_breakoff");E 7	}D 7} /* rs232c breakoff end */E 7I 7}E 7rs232c_abortinput(){I 7	if (RS232C_Fd >= 0) {		if (ioctl(RS232C_Fd, TCFLSH, 0) < 0)		  rs_cerror("RS232C: rs232c_abortinput");		else		  RS232C_remain_data = 0;	}}E 7D 7#ifdef TRACE	printf( "TRACE: rs232c_abortinput()\n" );#endif	if ( RS232C_RdStat == ACTIVE ) {		RS232C_RdStat = TERMINATED;		}} /* rs232c_abortinput end */E 7rs232c_abortoutput(){D 7#ifdef TRACE	printf( "TRACE: rs232c_abortoutput()\n" );#endifE 7I 7	if (RS232C_Fd >= 0) {		if (ioctl(RS232C_Fd, TCFLSH, 1) < 0)		  rs_cerror("RS232C: rs232c_abortoutput");	}}E 7D 7	if ( RS232C_WrStat == ACTIVE ) {		RS232C_WrStat = TERMINATED;E 7I 7rs232c_getstatus(){	int	status;	if (RS232C_Fd >= 0) {		if (ioctl(RS232C_Fd, TIOCMGET, &status) < 0)		  rs_error("rs232c_getstatus : cannot get status");		else {			RS232CDeviceStatus->power_indication			  = ((status & TIOCM_LE) ==  TIOCM_LE);			((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)			  ->data_terminal_ready			    = ((status & TIOCM_DTR) ==  TIOCM_DTR);			((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)			  ->request_to_send			    = ((status & TIOCM_RTS) ==  TIOCM_RTS);			RS232CDeviceStatus->clear_to_send			  = ((status & TIOCM_CTS) ==  TIOCM_CTS);			RS232CDeviceStatus->carrier_detect			  =  ((status & TIOCM_CAR) ==  TIOCM_CAR);			RS232CDeviceStatus->ring_indicator			  = ((status & TIOCM_RNG) ==  TIOCM_RNG);			RS232CDeviceStatus->data_set_ready			  = ((status & TIOCM_DSR) == TIOCM_DSR);E 7		}D 7} /* rs232c_abortoutput end */E 7I 7	}}E 7I 7rs_baud(baud)	u_int	baud;{	switch (baud) {	      case 0: return B50;	      case 1: return B75;	      case 2: return B110;	      case 3: return B134;	      case 4: return B150;	      case 5: return B200;	      case 6: return B300;	      case 7: return B600;	      case 8: return B1200;	      case 9: return B1800;	      case 10: return B2400;	      case 11: return B4800;	      case 12: return B9600;	      case 13: return B19200;	      case 14: return B38400;	      default: rs_error("rs_baud: illegal baud rate.");	}}E 7D 7rs232c_getstatus()E 7I 7rs_csize(csize)	u_int	csize;E 7{D 7#ifdef TRACE	printf( "TRACE: rs232c_getstatus()\n" );#endifE 7I 7	switch (csize) {	      case 0: return CS5;	      case 1: return CS6;	      case 2: return CS7;	      case 3: return CS8;	      default: rs_error("rs_csize: illegal character size");	}}E 7D 7} /* rs232c_getstatus end */E 7I 7rs_sbit(sbit)	u_int	sbit;{	switch (sbit) {	      case 0: return 0;	      case 1: return CSTOPB;	      default: rs_error("rs_bit: illegal stop bit");	}}E 7D 7E 7rs232c_majorparam(){D 7	DLRS232C_PARAMETER_CSB *param;	char baudrate;	int stat;E 7D 7#ifdef TRACE	printf( "TRACE: rs232c_majorparam()\n" );#endifE 7I 7	register int	baud, csize, sbit;E 7D 7	if ( RS232C_Fd >= 0 ) {		param = (DLRS232C_PARAMETER_CSB*) RS232CParameterCSB;				/* Baudrate */		if (( baudrate = rs232c_baudtosymbol( (int) param->line_speed )) != -1 ) {			RS232C_Mode.sg_ispeed = baudrate;			RS232C_Mode.sg_ospeed = baudrate;		} else {			error( "RS232C : rs232c_majorparam" );E 7I 7	if (RS232C_Fd >= 0) {		baud = rs_baud((u_int)((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)->line_speed);		RS232C_Mode.c_cflag &= ~CBAUD;		RS232C_Mode.c_cflag |= baud;		csize = rs_csize((u_int)((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)->char_length);		RS232C_Mode.c_cflag &= ~CSIZE;		RS232C_Mode.c_cflag |= csize;		if (csize == CS8)		  RS232C_Mode.c_iflag &= ~ISTRIP;		else		  RS232C_Mode.c_iflag |= ISTRIP;		switch ((u_int)((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)->parity) {		      case ODD:			RS232C_Mode.c_iflag |= INPCK;			RS232C_Mode.c_cflag |= PARENB;			RS232C_Mode.c_cflag |= PARODD;			break;		      case EVEN:			RS232C_Mode.c_iflag |= INPCK;			RS232C_Mode.c_cflag |= PARENB;			RS232C_Mode.c_cflag &= ~PARODD;			break;		      default:			RS232C_Mode.c_iflag &= ~INPCK;			RS232C_Mode.c_cflag  &= ~PARENB;E 7		}D 7		/* Xon/Xoff Control */		if ( param->flowcontrol_on ) {			RS232C_Mode.sg_flags |= TANDEM;E 7I 7		sbit = rs_sbit((u_int)((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)->stop_bits);		RS232C_Mode.c_cflag &= ~CSTOPB;		RS232C_Mode.c_cflag |= sbit;		if (((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)->flowcontrol_on) {			RS232C_Mode.c_iflag |= IXON;			RS232C_Mode.c_iflag |= IXOFF;			RS232C_Mode.c_cc[VSTART] = (char)((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)			  ->flowcontrol_xon_char;			RS232C_Mode.c_cc[VSTOP] = (char)((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)			  ->flowcontrol_xoff_char;E 7		} else {D 7			RS232C_Mode.sg_flags &=~TANDEM;E 7I 7			RS232C_Mode.c_iflag &= ~IXON;			RS232C_Mode.c_iflag &= ~IXOFF;E 7		}D 7		stat = ioctl(RS232C_Fd,TIOCSETP,&RS232C_Mode);			}} /* rs232c_majorparm end */ rs232c_baudtosymbol( aBaud )        short aBaud;{E 7I 7		switch ((u_int)			((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)->in_eol) {		      case CR:			RS232C_Mode.c_iflag &= ~INLCR;			RS232C_Mode.c_iflag &= ~IGNCR;			RS232C_Mode.c_iflag &= ~ICRNL;			break;E 7D 7#ifdef TRACE        printf( "TRACE: rs232c_baudtosymbol(%#x)\n", aBaud );#endifE 7I 7		      case LF:			RS232C_Mode.c_iflag |= INLCR;			RS232C_Mode.c_iflag &= ~IGNCR;			RS232C_Mode.c_iflag &= ~ICRNL;			break;					      case CRLF:		      default:			RS232C_Mode.c_iflag |= INLCR;			RS232C_Mode.c_iflag |= IGNCR;		}E 7D 7        if( aBaud ==  0 ) return( B50 );        if( aBaud ==  1 ) return( B75 );        if( aBaud ==  2 ) return( B110 );        if( aBaud ==  3 ) return( B134 );        if( aBaud ==  4 ) return( B150 );        if( aBaud ==  5 ) return( B300 );        if( aBaud ==  6 ) return( B600 );        if( aBaud ==  7 ) return( B1200 );        if( aBaud ==  8 ) return( B2400 );        if( aBaud == 10 ) return( B4800 );        if( aBaud == 12 ) return( B9600 );        if( aBaud == 13 ) return( EXTA );        return( -1 );} /* rs232c_baudtosymbol end */E 7I 7		switch ((u_int)			((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)->out_eol) {		      case LF:			RS232C_Mode.c_oflag &= ~ONLCR;			RS232C_Mode.c_oflag &= ~OCRNL;			RS232C_Mode.c_oflag &= ~ONOCR;			RS232C_Mode.c_oflag &= ~ONLRET;			break;E 7I 7		      case CRLF:			RS232C_Mode.c_oflag |= ONLCR;			RS232C_Mode.c_oflag &= ~OCRNL;			RS232C_Mode.c_oflag &= ~ONOCR;			RS232C_Mode.c_oflag &= ~ONLRET;			break;		      case CR:		      default:			RS232C_Mode.c_oflag &= ~ONLCR;			RS232C_Mode.c_oflag &= ~OCRNL;			RS232C_Mode.c_oflag &= ~ONOCR;			RS232C_Mode.c_oflag |= ONLRET;		}		if (((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)->input_max_bell)		  RS232C_Mode.c_iflag |= IMAXBEL;		else		  RS232C_Mode.c_iflag &= ~IMAXBEL;		if (((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)->tab_expand)		  RS232C_Mode.c_oflag |= XTABS;		else		  RS232C_Mode.c_oflag &= ~XTABS;		if (((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)->modem_status_line)		  RS232C_Mode.c_cflag &= ~CLOCAL;		else		  RS232C_Mode.c_cflag |= CLOCAL;		if (((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)->rts_cts_control)		  RS232C_Mode.c_cflag |= CRTSCTS;		else		  RS232C_Mode.c_cflag &= ~CRTSCTS;		if (ioctl(RS232C_Fd, TCSETS, &RS232C_Mode) < 0)		  rs_error("rs232c_majorparam: cannot set params");		else		  RS232CParameterOutcome->success = 1;	}} E 7rs232c_minorparam(){D 7        DLRS232C_PARAMETER_CSB *param;	int stat;        #ifdef TRACE        printf( "TRACE: rs232c_minoreparam()\n" );#endifE 7D 7	if ( RS232C_Fd >= 0 ) {		param = (DLRS232C_PARAMETER_CSB*) RS232CParameterCSB;E 7I 7	int	status;E 7D 7		/* DTR */		if ( param->data_terminal_ready ) {			stat = ioctl( RS232C_Fd, TIOCSDTR, 0 );		} else {			stat = ioctl( RS232C_Fd, TIOCCDTR, 0 );E 7I 7	if (RS232C_Fd >= 0) {		if (ioctl(RS232C_Fd, TIOCMGET, &status) < 0)		  rs_error("rs_minorparam: cannot get status");		else {			if (((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)			    ->data_terminal_ready)			  status |= TIOCM_DTR;			else			  status &= ~TIOCM_DTR;			if (((DLRS232C_PARAMETER_CSB *)RS232CParameterCSB)			    ->request_to_send)			  status |= TIOCM_RTS;			else			  status &= ~TIOCM_RTS;			if (ioctl(RS232C_Fd, TIOCMSET, &status) < 0)			  rs_error("rs_minorparam: cannot set status");			else			  RS232CParameterOutcome->success = 1;E 7		}	}D 7} /* rs232c_minorparam end */E 7I 7}E 7D 7rs232c_readcomp()E 7I 7/* * Following functions named as check_XXX are used for debug. */check_params(fd)	int	fd;E 7{D 7	DLRS232C_IOCB_TRANSFER_STATUS *temp;E 7I 7	struct termios tos;E 7D 7#ifdef TRACE        printf( "TRACE: rs232c_readcomp()\n" );#endifE 7I 7	if (ioctl(fd, TCGETS, &tos) < 0) {		perror("IOCTL");		exit(1);	}E 7D 7	if ( RS232C_RdStat == TERMINATED ) {E 7I 7	check_brate(tos.c_cflag);	check_csize(tos.c_cflag);	check_sbit(tos.c_cflag);	check_parity(tos.c_cflag);	check_oflag(tos.c_oflag);E 7D 7		temp = (DLRS232C_IOCB_TRANSFER_STATUS*) (&(RS232C_RdIOCB->transfer_status));		temp->success = 1;E 7I 7	check_cannon(&tos);}E 7D 7		RS232C_RdIOCB->returned_byte_count = RS232C_RdCount;		RS232C_RdIOCB->completed           = 1;		RS232C_RdStat                      = INACTIVE;		RS232CGetFlag->busy                = 0;E 7I 7check_brate(cf)	u_long	cf;{	int	b;	printf("Baud rate : ");	switch (cf & CBAUD) {	      case B0: b = 0; break;	      case B50: b = 50; break;	      case B75: b = 75; break;	      case B110: b = 110; break;	      case B134: b = 134; break;	      case B200: b = 200; break;	      case B300: b = 300; break;	      case B600: b = 600; break;	      case B1200: b = 1200; break;	      case B1800: b = 1800; break;	      case B2400: b = 2400; break;	      case B4800: b = 4800; break;	      case B9600: b = 9600; break;	      case B19200: b = 19200; break;	      case B38400: b = 384000; break;	      default: printf("Illeagal.\n");E 7	}D 7} /* rs232c_readcomp end */E 7I 7	printf("%d bps.\n", b);}E 7D 7rs232c_writecomp()E 7I 7check_csize(cf)	u_long	cf;E 7{D 7	DLRS232C_IOCB_TRANSFER_STATUS *temp;E 7I 7	int	s;	printf("Char size : ");	switch(cf & CSIZE) {	      case CS5: s = 5; break;	      case CS6: s = 6; break;	      case CS7: s = 7; break;	      case CS8: s = 8; break;	      default: printf("Illeagal.\n");	}	printf("%d chars.\n", s);}E 7D 7#ifdef TRACEE 7I 7check_sbit(cf)	u_long cf;{	int	s;	printf("Stop bit : ");	if (cf & CSTOPB)	  printf("2 bits.\n");	else	  printf("1 bit.\n");}E 7D 7	printf( "TRACE: rs232c_writecomp()\n" );#endifE 7I 7check_parity(cf)	u_long	cf;{	if (cf & PARENB) {		printf("Parity Enabled : ");		if (cf &PARODD)		  printf("Odd.\n");		else		  printf("Even.\n");	} else {		printf("Parity Disabled.\n");	}}E 7D 7	if ( RS232C_WrStat == TERMINATED ) {E 7I 7check_cannon(tos)	struct termios *tos;{	u_long	lf;E 7D 7		temp = (DLRS232C_IOCB_TRANSFER_STATUS*) (&(RS232C_WrIOCB->transfer_status));		temp->success = 1;E 7I 7	lf = tos->c_lflag;E 7D 7		RS232C_WrIOCB->returned_byte_count = RS232C_WrCount;		RS232C_WrIOCB->completed           = 1;		RS232C_WrStat                      = INACTIVE;		RS232CPutFlag->busy                = 0;E 7I 7	if (lf & ICANON) {		printf("Cannonical.\n");	} else {		printf("Non-Cannonical.\n");		printf("MIN : %d  ,  TIME : %d\n",		       (tos->c_cc)[VMIN], (tos->c_cc)[VTIME]);E 7	}D 7} /* rs232c_writecomp end */E 7I 7}E 7I 7check_oflag(of)	u_long	of;{	if ((OPOST & of) == OPOST) {		printf("OPOST : O\n");	} else {		printf("OPOST : X\n");	}	if ((ONLCR & of) == ONLCR) {		printf("ONLCR : O\n");	} else {		printf("ONLCR : X\n");	}	if ((OCRNL & of) == OCRNL) {		printf("OCRNL : O\n");	} else {		printf("OCRNL : X\n");	}	if ((ONOCR & of) == ONOCR) {		printf("ONOCR : O\n");	} else {		printf("ONOCR : X\n");	}	if ((ONLRET & of) == ONLRET) {		printf("ONLRET : O\n");	} else {		printf("ONLRET : X\n");	}	if ((OFILL & of) == OFILL) {		printf("OFILL : O\n");	} else {		printf("OFILL : X\n");	}	if ((OFDEL & of) == OFDEL) {		printf("OFDEL : O\n");	} else {		printf("OFDEL : X\n");	}	switch (NLDLY & of) {	      case NL0:		printf("NL0 \n"); break;	      case NL1:		printf("NL1\n"); break;	}	switch (CRDLY & of) {	      case CR0:		printf("NL0 \n"); break;	      case CR1:		printf("CR1\n"); break;	      case CR2:		printf("CR2\n"); break;	      case CR3:		printf("CR3\n"); break;	}	switch (TABDLY & of) {	      case TAB0:		printf("NL0 \n"); break;	      case TAB1:		printf("TAB1\n"); break;	      case TAB2:		printf("TAB2\n"); break;	      case XTABS:		printf("XTABS\n"); break;	}	switch (BSDLY & of) {	      case BS0:		printf("NL0 \n"); break;	      case BS1:		printf("BS1\n"); break;	}	switch (VTDLY & of) {	      case VT0:		printf("NL0 \n"); break;	      case VT1:		printf("VT1\n"); break;	}	switch (FFDLY & of) {	      case FF0:		printf("NL0 \n"); break;	      case FF1:		printf("FF1\n"); break;	}}	/* * In dbx, "call rsc()". */rsc(){	if (RS232C_Fd >= 0)		check_params(RS232C_Fd);}/* Old debug function: not updated.E 7rs232c_debug( name, sw )        char *name;	int  sw;{        struct sgttyb mode;	if ( sw == 1 ) {        printf("DEBUG: %s\n",name);        printf("DEBUG: \t\tRS232C_Dev = %s\n", RS232C_Dev);        printf("DEBUG: \t\tRS232C_Fd  = %d\n", RS232C_Fd);        if ( RS232C_Fd >= 0 ) {                ioctl( RS232C_Fd, TIOCGETP, &mode );        printf("DEBUG: \t\tRS232C_Mode.sg_ispeed = %#x\n", mode.sg_ispeed );        printf("DEBUG: \t\tRS232C_Mode.sg_ospeed = %#x\n", mode.sg_ospeed );        printf("DEBUG: \t\tRS232C_Mode.sg_erase  = %#x\n", mode.sg_erase  );        printf("DEBUG: \t\tRS232C_Mode.sg_kill   = %#x\n", mode.sg_kill   );        printf("DEBUG: \t\tRS232C_Mode.sg_flags  = %#x\n", mode.sg_flags  );D 7        } /* if(RS232C_Fd) end */E 7I 7        } /+ if(RS232C_Fd) end +/E 7D 7	} /* if(sw) end */E 7I 7	} /+ if(sw) end +/E 7	if ( sw == 2 ) {        printf("DEBUG: %s\n",name);	printf("DEBUG:\n");	printf("DEBUG: \t\tSymbol             Address    Contents\n");        printf("DEBUG: \t\tIOPAGE             %#x\n",Addr68k_from_LADDR(IOPAGE_OFFSET));         printf("DEBUG: \t\tHardWareConfig     %#x    %#x\n", HardWareConfig, *(DLword*) HardWareConfig);         printf("DEBUG: \t\tRS232CGetFlag      %#x    %#x\n", RS232CGetFlag, *(DLword*) RS232CGetFlag);         printf("DEBUG: \t\tRS232CPutFlag      %#x    %#x\n", RS232CPutFlag, *(DLword*) RS232CPutFlag);         printf("DEBUG: \t\tRS232CMiscCommand  %#x    %#x\n", RS232CMiscCommand, *(DLword*) RS232CMiscCommand);         printf("DEBUG: \t\tRS232CGetCSB       %#x    %#x\n", RS232CGetCSB, (LispPTR) (((*(RS232CGetCSB+1) & 0xff)<<16) + *RS232CGetCSB ));         printf("DEBUG: \t\tRS232CPutCSB       %#x    %#x\n", RS232CPutCSB, (LispPTR) (((*(RS232CPutCSB+1) & 0xff)<<16) + *RS232CPutCSB ));        printf("DEBUG: \t\tRS232CParameterCSB %#x    %#x\n", RS232CParameterCSB, *(DLword*) RS232CParameterCSB);        printf("DEBUG: \t\t                              %#x\n", *(DLword*) (RS232CParameterCSB+1));        printf("DEBUG: \t\t                              %#x\n", *(DLword*) (RS232CParameterCSB+2));        printf("DEBUG: \t\t                              %#x\n", *(DLword*) (RS232CParameterCSB+3));        printf("DEBUG: \t\t                              %#x\n", *(DLword*) (RS232CParameterCSB+4));        printf("DEBUG: \t\t                              %#x\n", *(DLword*) (RS232CParameterCSB+5));        printf("DEBUG: \t\t                              %#x\n", *(DLword*) (RS232CParameterCSB+6));        printf("DEBUG: \t\t                              %#x\n", *(DLword*) (RS232CParameterCSB+7));        if( RS232C_WrIOCB != NULL )         printf("DEBUG: \t\tRS232C_WrIOCB      %#x    %#x\n", RS232C_WrIOCB, *((LispPTR*)RS232C_WrIOCB));        if( RS232C_RdIOCB != NULL )         printf("DEBUG: \t\tRS232C_RdIOCB      %#x    %#x\n", RS232C_RdIOCB, *((LispPTR*)RS232C_RdIOCB)); D 7	/*E 7I 7	/+E 7        if( RS232C_WrBufAddr != NULL )         printf("DEBUG: \t\tRS232C_WrBufAddr   %s\n" , RS232C_WrBufAddr);        if( RS232C_WrBufAddr != NULL )         printf("DEBUG: \t\tRS232C_RdBufAddr   %s\n" , RS232C_RdBufAddr);D 7	*/E 7I 7	+/E 7D 7	} /* if(sw) end */E 7I 7	} /+ if(sw) end +/E 7D 7 } /* rs232c_debug end */ E 7I 7 } /+ rs232c_debug end +/E 7I 7*/E 7E 1