h54618s 00000/00000/00861d D 2.64 90/04/19 21:49:12 sybalsky 87 86c AIX/Posix:  Name shortenedes 00025/00004/00836d D 2.63 90/03/22 10:45:15 sybalsky 86 85c es 00001/00001/00839d D 2.62 90/03/13 18:57:54 sybalsky 85 84c make SWAP_WORDS work rightes 00001/00005/00839d D 2.61 90/03/12 14:41:00 sybalsky 84 83c fix for 386 (got it wrong last time, sigh!)es 00004/00001/00840d D 2.60 90/03/12 12:27:05 sybalsky 83 82c fix SWAP_WORDS definition to only evaluate its argument once.es 00011/00000/00830d D 2.59 89/10/19 18:04:16 sybalsky 82 81c MISC7 supportes 00000/00000/00830d D 2.58 89/08/12 11:31:13 shih 81 80c nonees 00000/00000/00830d D 2.57 89/04/28 16:55:58 sybalsky 80 79c es 00013/00010/00817d D 2.56 89/03/30 13:02:13 sybalsky 79 78c Changed word-ptr refs to use GETWORD, byte-ptr refs to use GETBYTE, WBITS refs to use WBITSPTR.es 00019/00019/00808d D 2.55 89/03/23 12:56:13 sybalsky 78 77c Changed some word-ptr refs to use GETWORD, byte-ptr refs to use GETBYTE, for 386es 00001/00001/00826d D 2.54 89/02/24 13:40:28 sybalsky 77 76c Removed a bogus push of alpha/beta from MISCN ufn pathes 00002/00002/00825d D 2.53 88/12/01 13:50:03 krivacic 76 75c Add SUN3_OS4_IL & SUN3_OS3_OR_OS4_IL Flags, and move asm labels to inlines.es 00001/00001/00826d D 2.52 88/11/29 16:33:40 shih 75 74c minor cleanupes 00001/00001/00826d D 2.51 88/11/29 13:31:54 shih 74 73c removed bogus sccs stampes 00005/00006/00822d D 2.50 88/11/08 17:29:34 krivacic 73 72c change MISCN to use EXT/RET interfacees 00001/00001/00827d D 2.49 88/11/08 13:16:57 bane 72 71c Added (unsigned) cast to AREF1 macro for Apollo C compileres 00011/00000/00817d D 2.48 88/11/07 18:15:08 krivacic 71 70c add MISCNes 00010/00011/00807d D 2.47 88/10/13 19:29:15 krivacic 70 69c ifdef cleanuupes 00268/00049/00550d D 2.46 88/10/12 14:48:00 krivacic 69 68c new out-of-line interfacees 00000/00007/00599d D 2.45 88/10/10 14:12:55 krivacic 68 67c sun3/4 mergees 00012/00012/00594d D 2.44 88/10/05 18:14:59 krivacic 67 66c sun3 & sun4 mergees 00036/00195/00570d D 2.43 88/10/05 17:02:05 krivacic 66 65c sun 3 / 4 mergees 00013/00013/00752d D 2.42 88/09/16 14:39:12 bane 65 64c Adjusted PC changeses 00006/00006/00759d D 2.41 88/08/15 14:25:19 krivacic 64 63c change of OPFN args for assembly lang fn calles 00007/00009/00758d D 2.40 88/08/01 16:11:06 shih 63 62c putbasebyte should punt if displacement is not smallpes 00064/00002/00703d D 2.39 88/07/25 16:56:23 hayata 62 61c Inline code of GETBASEBYTE, PUTBASEBYTE and PUTNITS_N_M are defined.es 00034/00000/00671d D 2.38 88/07/25 15:19:56 krivacic 61 60c put old FVAR stuf on OLD_FVAR flages 00009/00008/00662d D 2.37 88/07/13 02:45:05 shih 60 59c restored version stamp, minor (5%?) performance cleanupes 00051/00006/00619d D 2.36 88/07/12 19:58:10 shih 59 58c slightly faster FVAR, FVARXes 00003/00004/00622d D 2.35 88/07/07 17:09:58 bane 58 57c Fixed off-by-1 bug (AR 10589) in POPNes 00036/00001/00590d D 2.34 88/07/07 12:47:15 hayata 57 56c UNBIND and DUNBIND are inlined.es 00000/00000/00591d D 2.33 88/07/07 12:25:57 shih 56 55c noees 00013/00013/00578d D 2.32 88/07/06 14:12:03 charnley 55 54c reordered aset type select arms.es 00019/00001/00572d D 2.31 88/07/05 11:40:57 charnley 54 53c added DTEST inline.es 00001/00000/00572d D 2.30 88/07/01 19:58:11 shih 53 52c left out nextop1 from BIN inlinees 00022/00002/00550d D 2.29 88/07/01 19:20:31 shih 52 51c added bin opcode inlinees 00033/00001/00519d D 2.28 88/07/01 19:10:03 hayata 51 50c BIND and GETBITS_N_M are inlined.es 00000/00001/00520d D 2.27 88/07/01 10:51:00 charnley 50 49c removed extraneous FVARX macro.es 00002/00003/00519d D 2.26 88/07/01 10:47:49 charnley 49 48c added FVARX macro.es 00022/00000/00500d D 2.25 88/06/30 17:52:41 charnley 48 47c added fvarx inline def.es 00007/00009/00493d D 2.24 88/06/29 09:12:45 charnley 47 46c aref fixed and reinstated.es 00006/00002/00496d D 2.23 88/06/28 23:50:39 shih 46 45c disabled inline AREF opcode (makefile INes 00083/00062/00415d D 2.22 88/06/28 19:12:01 charnley 45 44c part of fvar inline.es 00000/00001/00477d D 2.21 88/06/28 17:01:05 charnley 44 43c AREF1 really in now.es 00012/00005/00466d D 2.20 88/06/27 21:18:36 bane 43 42c Duplicated nextop1 in OPCAR and OPCDR inline codees 00069/00000/00402d D 2.19 88/06/27 17:04:15 charnley 42 41c put aref1 inline.es 00012/00001/00390d D 2.18 88/06/27 12:44:29 charnley 41 40c putting cl:= <377> smallp cases inline.es 00002/00002/00389d D 2.17 88/06/21 15:22:19 bane 40 39c fixed bad cast in CDR inline macroes 00002/00002/00389d D 2.16 88/06/20 20:42:02 bane 39 38c CAR and CDR really in line this time...es 00054/00000/00337d D 2.15 88/06/20 14:05:00 bane 38 37c Put CAR and CDR inlinees 00003/00006/00334d D 2.14 88/06/17 12:11:22 krivacic 37 36c put back CHECK_INTERRUPT on jump caseses 00001/00005/00339d D 2.13 88/06/15 21:17:12 krivacic 36 35c make rplcons use an error exites 00007/00008/00337d D 2.12 88/06/15 09:56:14 bane 35 34c removed CHECK_INTERRUPTS from forward brancheses 00008/00001/00337d D 2.11 88/06/09 22:55:13 masinter 34 33c make RECLAIMCELL conditional on ifdef RECLAIMINC (currently turned off)es 00001/00001/00337d D 2.10 88/06/09 13:53:06 krivacic 33 32c masinter: turn off gcreclaimcell again, doesn't work in freeze sysoutes 00001/00001/00337d D 2.9 88/06/09 11:06:13 masinter 32 31c turn on GCRECLAIMCELL now that reclaimcodeblock is fixed againes 00001/00001/00337d D 2.8 88/06/03 15:02:57 masinter 31 30c turn off gcreclaimcell until it is debuggedes 00004/00005/00334d D 2.7 88/06/03 10:59:58 masinter 30 29c put back in masking to catch erroneous GETBASE, etc. opcode callses 00001/00001/00338d D 2.6 88/06/03 09:23:59 greep 29 28c Removed extra right-paren in defn of VAG2es 00001/00002/00338d D 2.5 88/06/02 13:44:33 masinter 28 27c Turn back on C reclaimcell now that extra refcnt bug is foundes 00012/00022/00328d D 2.4 88/05/31 20:27:00 masinter 27 26c speed up getbase, fix putbaseptr bug, fix (unused) VAG2, calls to inimplemented opses 00011/00005/00339d D 2.3 88/05/27 15:01:32 krivacic 26 25c extra C only versions addedes 00000/00001/00344d D 2.2 88/05/24 18:18:49 krivacic 25 24c remove EVAL macro (now inline in dispatch)es 00000/00000/00345d D 2.1 88/05/17 09:18:05 hayata 24 23c Version up to 2.1es 00018/00015/00327d D 1.23 88/05/10 19:38:53 krivacic 23 22c OP_ENVCALL, CHECK_INTERRUPT on fn callses 00001/00000/00341d D 1.22 88/05/05 14:10:20 krivacic 22 21c ENVCALLes 00006/00000/00335d D 1.21 88/05/04 15:10:28 krivacic 21 20c fix POP.N buges 00002/00002/00333d D 1.20 88/04/27 13:30:17 krivacic 20 19c CONTEXTSWITCH NATIVE_NEXTOP0es 00011/00010/00324d D 1.19 88/04/26 21:49:25 krivacic 19 18c moved CHECK_INTERRUPT test on fn calls & CONTEXTSWITCHes 00002/00000/00332d D 1.18 88/04/25 11:40:01 krivacic 18 17c LSH macroes 00001/00001/00331d D 1.17 88/04/24 16:00:02 bane 17 16c fixed CHECK_INTERRUPTes 00220/00296/00112d D 1.16 88/04/22 19:21:03 krivacic 16 15c inlinedefs re-arrangement & ni removales 00003/00001/00405d D 1.15 88/03/15 17:16:35 bane 15 14c Changed CHECK_INTERRUPTS to use timer interrupt.es 00001/00001/00405d D 1.14 88/03/25 09:32:06 charnley 14 13c same againes 00001/00001/00405d D 1.13 88/03/24 15:09:54 charnley 13 12c fixed typo in prev fixes 00006/00000/00400d D 1.12 88/03/23 14:23:35 charnley 12 11c added ufn_2d to UFN_CALLSes 00000/00000/00400d D 1.11 88/03/23 10:13:34 krivacic 11 10c last changes this file should be removedes 00006/00000/00394d D 1.10 88/03/21 17:11:20 charnley 10 9c added ufn_9 for drawline C codees 00031/00004/00363d D 1.9 88/03/21 13:57:32 krivacic 9 8c car-cdr native opses 00007/00002/00360d D 1.8 88/03/18 17:56:25 krivacic 8 7c Added N_OP_atomcell & N_OP_bines 00006/00004/00356d D 1.7 88/03/15 18:23:29 krivacic 7 6c Closure Call, Apply, & CheckApply to dispatch loopes 00065/00005/00295d D 1.6 88/03/14 17:39:49 krivacic 6 5c add QUOTIENT TIMES2 IREMAINDERes 00043/00005/00257d D 1.5 88/03/14 11:48:37 krivacic 5 4c Dummy macros for Don's opcodeses 00001/00001/00261d D 1.4 88/03/13 13:21:43 hayata 4 3c Add SCCS key id (%Z%)es 00053/00084/00209d D 1.3 88/03/11 18:03:39 krivacic 3 2c Add es 00029/00014/00264d D 1.2 88/03/09 15:43:42 krivacic 2 1c added SWAP_WORDS macroes 00278/00000/00000d D 1.1 88/03/03 11:22:06 krivacic 1 0c date and time created 88/03/03 11:22:06 by krivaciceuUtTI 1D 4/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 4I 4D 46/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 46I 46D 60/* This is G-file @(#) inlinedefsC.h Version 2.22 (6/28/88). copyright Xerox & Fuji Xerox  */E 46E 4D 28/* 	inlinedefsC.h */E 28/* 	Bob Krivacic 2/23/88 */E 60I 60D 65/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 65I 65D 74/* This is G-file @(#) inlinedefsC.h Version 2.41 (8/15/88). copyright Xerox & Fuji Xerox  */E 74I 74/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 74E 65E 60D 60E 60D 16/* 	These are the Macros Used to generate inline c code 	to implement the opcodes.  Used by both dispatch 	loop and native code.E 16I 16/* 		These are the Macros Used to generate inline c code.	These are the goto ni definitions of the opcodes.E 16*/I 86/************************************************************************//*									*//*	    Macros for fetching bytes & words PC-relative		*//*									*//*	These are this way so that they can be redefined for the 386i,	*//*	where it makes a difference in speed if you know in advance.	*//*									*//************************************************************************/E 86I 66D 69#define SV E 66#undef ADDBASE#undef LOLOC#undef HILOC#undef VAG2E 69I 86#define Get_BYTE_PCMAC0 Get_BYTE(PCMAC)#define Get_BYTE_PCMAC1 Get_BYTE(PCMAC+1)#define Get_BYTE_PCMAC2 Get_BYTE(PCMAC+2)#define Get_BYTE_PCMAC3 Get_BYTE(PCMAC+3)#define Get_DLword_PCMAC0 Get_DLword(PCMAC)#define Get_DLword_PCMAC1 Get_DLword(PCMAC+1)#define Get_DLword_PCMAC2 Get_DLword(PCMAC+2)#define Get_DLword_PCMAC3 Get_DLword(PCMAC+3)E 86I 3D 69I 27E 69E 27E 3I 2D 16#define SWAP_WORDS(x) \D 3	(((int x) << 16) & 0xFFFF0000) | (((int x) >> 16) & 0xFFFF)E 3I 3	(((int) x << 16) & 0xFFFF0000) | (((int) x >> 16) & 0xFFFF)E 16I 16D 23/* this NEEDS to be FIXED !!!! */E 16E 3I 16D 17#define CHECK_INTERRUPT {if(--LoopCounter<=0) goto check_interrupt;} E 17I 17#define CHECK_INTERRUPT {if(!LoopCounter) goto check_interrupt;} E 17E 16I 3E 23I 23#define CHECK_INTERRUPT {if((int)CSTKPTR > Irq_Stk_Check) goto check_interrupt;} E 23E 3E 2D 15#define CHECK_INTERRUPT {if(--LoopCounter<0) goto check_interrupt;} E 15I 15D 16/* JRB - no longer a Counter per se, but retaining the name to avoid munging	other stuff prematurely */#define CHECK_INTERRUPT {if(!LoopCounter) goto check_interrupt;} E 16I 16D 84#define SWAP_WORDS(x) \D 60	((((unsigned int) x << 16) & 0xFFFF0000) | (((unsigned int) x >> 16) & 0xFFFF))E 60I 60D 83	(((unsigned int) x << 16) | (((unsigned int) x >> 16) & 0xFFFF))E 83I 83  { \    register unsigned int temp = (unsigned int)x; \    ((temp << 16) | ((temp >> 16) & 0xFFFF)) \  }E 84I 84D 85#define SWAP_WORDS(x) ((x << 16) | ((x >> 16) & 0xFFFF))E 85I 85#define SWAP_WORDS(x) (((unsigned int)x << 16) | (((unsigned int)x >> 16) & 0xFFFF))E 85E 84E 83E 60E 16E 15D 3#define registers  							\	register int arg1,arg2, arg3, result; register DLword *wordp; 	\	register LispPTR *cellp;E 3D 3E 3D 16#ifdef OPDISPE 16I 16#define NATIVECHECK							\	{if (BCE_CURRENTFX->native) {goto gonative ;} nextop0; }E 16D 16extern void jumpLabel();void LispPTR difference();E 16D 27D 16#define nextop0 {jumpLabel();}#define nextop1 {PCMAC += 1; jumpLabel();}#define nextop2 {PCMAC += 2; jumpLabel();}#define nextop3 {PCMAC += 3; jumpLabel();}#define nextop4 {PCMAC += 4; jumpLabel();}E 16I 16#define nextop0 {int i; i = Get_BYTE(PCMAC); goto nextopcode; }E 27I 27#define nextop0 {goto nextopcode; }E 27D 65#define nextop1 {PCMAC += 1; nextop0; }#define nextop2 {PCMAC += 2; nextop0; }#define nextop3 {PCMAC += 3; nextop0; }#define nextop4 {PCMAC += 4; nextop0; }E 65I 65#define nextop1 {PCMACL += 1; nextop0; }#define nextop2 {PCMACL += 2; nextop0; }#define nextop3 {PCMACL += 3; nextop0; }#define nextop4 {PCMACL += 4; nextop0; }E 65E 16I 38#define OPCAR \ if (Listp(TOPOFSTACK))\ {\ register ConsCell *DATUM68K = (ConsCell *)(Addr68k_from_LADDR(TOPOFSTACK));\	if (DATUM68K->cdr_code == CDR_INDIRECT)\	{\		TOPOFSTACK = ((LispPTR)((ConsCell *)Addr68k_from_LADDR(DATUM68K->car_field))->car_field);\I 43		nextop1; \E 43	}\	else \	{ \		TOPOFSTACK = ((LispPTR)DATUM68K->car_field);\I 43		nextop1; \E 43  } \D 43  nextop1; \E 43  }\ else	if (TOPOFSTACK == NIL_PTR)\		{ nextop1; } \	else if ( TOPOFSTACK == ATOM_T)\		{ nextop1; } \	else \	  {\		goto op_ufn; \	  } /* end of OPCAR */#define OPCDR  \ if (Listp(TOPOFSTACK))\ {\register ConsCell *DATUM68K = (ConsCell *)(Addr68k_from_LADDR(TOPOFSTACK));\D 66register DLword CDRCODEX = DATUM68K->cdr_code;\E 66I 66register int CDRCODEX = DATUM68K->cdr_code;\E 66D 43	if (CDRCODEX == CDR_NIL)\E 43I 43	if (CDRCODEX == CDR_NIL) {\E 43		/* cdr-nil */\		TOPOFSTACK = (NIL_PTR);\D 43	else if (CDRCODEX> CDR_ONPAGE)\E 43I 43		nextop1; \		} \	else if (CDRCODEX> CDR_ONPAGE) {\E 43		/* cdr-samepage */\		TOPOFSTACK = (POINTER_PAGEBASE(TOPOFSTACK) + \		((CDRCODEX & 127) << 1));\D 43	else if (CDRCODEX == CDR_INDIRECT)	/* CDRCODEX < CDR_ONPAGE */\E 43I 43		nextop1; \		} \	else if (CDRCODEX == CDR_INDIRECT) {	/* CDRCODEX < CDR_ONPAGE */\E 43		/* cdr-indirect */\		TOPOFSTACK = (cdr ((LispPTR)(DATUM68K->car_field)));\I 43		nextop1; \		} \E 43	else\	{\		/* cdr-differentpage */\D 40		TOPOFSTACK = (LispPTR)((ConsCell *)(Addr68k_from_LADDR \E 40I 40		TOPOFSTACK = ((ConsCell *)(Addr68k_from_LADDR \E 40		(POINTER_PAGEBASE(TOPOFSTACK) + (CDRCODEX << 1)))\D 40											->car_field);\E 40I 40											)->car_field;\I 43		nextop1; \E 43E 40	}\D 43	nextop1; \E 43  }\ else	if (TOPOFSTACK == NIL_PTR)\		{ nextop1; } \	else\	 {\		goto op_ufn; \	 } /* end of OPCDR */E 38D 16#else#define nextop0 {goto nextopcode; }#define nextop1 {PCMAC += 1; goto nextopcode; }#define nextop2 {PCMAC += 2; goto nextopcode; }#define nextop3 {PCMAC += 3; goto nextopcode; }#define nextop4 {PCMAC += 4; goto nextopcode; }#endifE 16D 27#define UFN(x)  { EXT; ufn((x)); NRET; }E 27D 3D 2#define CGETNUMBER(sour, dest, label)					\E 2I 2#define N_GETNUMBER(sour, dest, label)					\E 2{		dest = sour;	 					\		switch(0xFFFF0000 & dest){				\		case S_POSITIVE:					\			dest = 0xFFFF & dest;				\			break;						\		case S_NEGATIVE:					\			dest = 0xFFFF0000 | dest;			\			break;						\		default:						\			if (GetTypeNumber( dest ) != TYPE_FIXP)		\				{ goto label; }				\			dest = *((int *)Addr68k_from_LADDR(dest));	\		}							\}E 3D 16#define SETTOS_NEWFIXP(val)						\			{register DLword *wordp; 			\			wordp = createcell68k(TYPE_FIXP);		\			*((unsigned int *)wordp) = val;			\			TOPOFSTACK = LADDR_from_68k(wordp);		\			}E 16D 66#define	IVARMACRO(x)	{PUSH(GetLongWord((LispPTR *)IVAR + x )); nextop1;}#define	PVARMACRO(x)	{PUSH(GetLongWord((LispPTR *)PVAR + x )); nextop1;}D 26#define	FVARMACRO(x)	{EXT; OP_fvarn(); NRET; }E 26I 26D 45#define	FVAR(x)	{EXT; OP_fvarn(); NRET; }E 45E 26#define	PVARSETMACRO(x)	{*((LispPTR *)PVAR + x) = TOPOFSTACK; nextop1;}#define	PVARSETPOPMACRO(x) {*((LispPTR *)PVAR + x) = TOPOFSTACK; POP; nextop1;}E 66I 66#define	IVARMACRO(x)	{PUSH(IVAR[x]); nextop1;}#define	PVARMACRO(x)	{PUSH(PVAR[x]); nextop1;}#define	PVARSETMACRO(x)	{PVAR[x] = TOPOFSTACK; nextop1;}#define	PVARSETPOPMACRO(x) {PVAR[x] = TOPOFSTACK; POP; nextop1;}E 66#define	PUSHATOM(x)	{PUSH(x); nextop1;}I 35D 37/* JRB - removed CHECK_INTERRUPT from these JUMP macros; they are only used to	branch forward... */E 37E 35D 3#define	FJUMPMACRO(x)	{if(TOPOFSTACK != 0) {goto PopNextop1 ; }	\E 3I 3D 6#define	FJUMPMACRO(x)	{/*CHECK_INTERRUPT;	*/			\E 6I 6D 35#define	JUMPMACRO(x)	{CHECK_INTERRUPT;				\			PCMAC += x; nextop0;				\			}E 35I 35D 37#define	JUMPMACRO(x)	{PCMAC += x; nextop0;}E 37I 37D 65#define	JUMPMACRO(x)	{CHECK_INTERRUPT; PCMAC += x; nextop0;}E 65I 65#define	JUMPMACRO(x)	{CHECK_INTERRUPT; PCMACL += x; nextop0;}E 65E 37E 35D 35#define	FJUMPMACRO(x)	{CHECK_INTERRUPT;				\E 6			if(TOPOFSTACK != 0) {goto PopNextop1 ; }	\E 35I 35#define	FJUMPMACRO(x)	{if(TOPOFSTACK != 0) {goto PopNextop1 ; }	\E 35E 3D 37			{POP; PCMAC += x; nextop0;}			\E 37I 37D 65			{CHECK_INTERRUPT; POP; PCMAC += x; nextop0;}	\E 65I 65			{CHECK_INTERRUPT; POP; PCMACL += x; nextop0;}	\E 65E 37			}D 3#define	TJUMPMACRO(x)	{if(TOPOFSTACK == 0) {goto PopNextop1 ; }	\E 3I 3D 6#define	TJUMPMACRO(x)	{/*CHECK_INTERRUPT;*/				\E 6I 6D 35#define	TJUMPMACRO(x)	{CHECK_INTERRUPT;				\E 6			if(TOPOFSTACK == 0) {goto PopNextop1 ; }	\E 35I 35#define	TJUMPMACRO(x)	{if(TOPOFSTACK == 0) {goto PopNextop1 ; }	\E 35E 3D 37			{POP; PCMAC += x; nextop0;}			\E 37I 37D 65			{CHECK_INTERRUPT; POP; PCMAC += x; nextop0;}	\E 65I 65			{CHECK_INTERRUPT; POP; PCMACL += x; nextop0;}	\E 65E 37			}D 16D 6E 6I 6D 8#define ATOMCELL_N(n)	{ EXT; OP_atomcellN(); NRET }E 8I 8D 9#define ATOMCELL_N(n)	{ TOPOFSTACK = N_OP_atomcellN(TOPOFSTACK, n, ufn_1d); }E 9I 9#define ATOMCELL_N(n)							\	{TOPOFSTACK = N_OP_atomcellN(TOPOFSTACK, n, ufn_1d);		\	 nextop2;							\	}/*#define ATOMCELL_N(n)	{ EXT; OP_atomcellN(); NRET; }*/E 9E 8E 6D 3#define BLT	{ EXT; OP_blt(); NRET; }E 3I 3#define BLT		{ EXT; OP_blt(); NRET; }E 3#define PUTBASEBYTE	{ EXT; OP_putbasebyte(); NRET; }#define PUTBASEPTR_N(n)	{ EXT; OP_putbaseptrn(); NRET; }#define PUTBASE_N(n)	{ EXT; OP_putbasen(); NRET; }E 16D 79#define GETBASE_N(n)	{ 						\E 79I 79#define GETBASE_N(N)	{ 						\E 79		TOPOFSTACK = 						\D 78			(S_POSITIVE | *((DLword *)			\E 78I 78			(S_POSITIVE | GETWORD((DLword *)			\E 78D 27			Addr68k_from_LADDR((0xFFFFFF & TOPOFSTACK) + n)));\E 27I 27D 30			Addr68k_from_LADDR(TOPOFSTACK + n)));		\E 30I 30D 79			Addr68k_from_LADDR((0xFFFFFF & TOPOFSTACK) + n)));\E 79I 79			Addr68k_from_LADDR((0xFFFFFF & TOPOFSTACK) + N)));\E 79E 30E 27		nextop2;						\		}D 79#define GETBASEPTR_N(n) {						\E 79I 79#define GETBASEPTR_N(N) {						\E 79		TOPOFSTACK = 						\			(0xFFFFFF & *((LispPTR *)			\D 27			Addr68k_from_LADDR((0xFFFFFF & TOPOFSTACK) + n)));\E 27I 27D 30			Addr68k_from_LADDR(TOPOFSTACK + n)));		\E 30I 30D 79			Addr68k_from_LADDR((0xFFFFFF & TOPOFSTACK) + n)));\E 79I 79			Addr68k_from_LADDR((0xFFFFFF & TOPOFSTACK) + N)));\E 79E 30E 27		nextop2;						\		}D 62E 62I 62D 63/****E 62I 16#define PUTBASEBYTE	{ EXT; OP_putbasebyte(); NRET; }I 26#define GETBASEBYTE	{ EXT; OP_getbasebyte(); NRET; }I 62*****/E 63#define PUTBASEBYTE							\	{ register int byteoffset;					\D 63	  register char	*p_data;						\	 if(((0xFFFF0000 & TOPOFSTACK ) != S_POSITIVE) || ((unsigned short)TOPOFSTACK >= 256))	\E 63I 63	  register char	*p_data;					\	 if(((0xFFFF0000 & TOPOFSTACK) != S_POSITIVE) ||		\	    ((unsigned short)TOPOFSTACK >= 256))			\E 63		goto op_ufn;						\D 63	 byteoffset = GET_TOS_1;						\E 63I 63	 byteoffset = GET_TOS_1;					\E 63	 switch( (0xFFFF0000 & byteoffset) ){				\	 case S_POSITIVE:						\	 	byteoffset &=  0x0000FFFF;				\	 	break;							\	 case S_NEGATIVE:						\		byteoffset |=  0xFFFF0000;				\		break;							\	 default:							\D 63		if( GetTypeNumber(byteoffset) == TYPE_FIXP )		\E 63I 63		goto op_ufn;						\	/***	if( GetTypeNumber(byteoffset) == TYPE_FIXP )		\E 63			byteoffset = *((int *)Addr68k_from_LADDR(byteoffset));	\		else							\D 63			goto op_ufn;					\E 63I 63			goto op_ufn; ***/				\E 63	 }								\	 --CSTKPTR;							\	 p_data = (char*)Addr68k_from_LADDR(0xFFFFFF & (POP_TOS_1)) + byteoffset;	\D 78	 *p_data = 0xFF & TOPOFSTACK;					\E 78I 78D 79	 GETBYTE(p_data) = 0xFF & TOPOFSTACK;					\E 79I 79	 GETBYTE(p_data) = 0xFF & TOPOFSTACK;				\E 79E 78	 nextop1;							\	}E 62E 26E 16I 62#define GETBASEBYTE							\	{switch( (0xFFFF0000 & TOPOFSTACK) ){				\	 case S_POSITIVE:						\		TOPOFSTACK &=  0x0000FFFF;				\		break;							\	 case S_NEGATIVE:						\		TOPOFSTACK |=  0xFFFF0000;				\		break;							\	 default:							\		if( GetTypeNumber(TOPOFSTACK) == TYPE_FIXP )		\D 78			TOPOFSTACK = *((int *)Addr68k_from_LADDR(TOPOFSTACK));	\E 78I 78		 TOPOFSTACK = *((int *)Addr68k_from_LADDR(TOPOFSTACK));	\E 78		else							\			goto op_ufn;					\	 }								\D 78	 TOPOFSTACK = (0xFF & (*((char*)Addr68k_from_LADDR((0xFFFFFF & (POP_TOS_1))) + TOPOFSTACK))) | S_POSITIVE;	\E 78I 78	 TOPOFSTACK = (0xFF & (GETBYTE((char*)Addr68k_from_LADDR((0xFFFFFF & (POP_TOS_1))) + TOPOFSTACK))) | S_POSITIVE;	\E 78	 nextop1;							\	}E 62D 3#define NATIVECHECK	{if (FuncObj->native) {goto gonative ;} nextop0; }E 3I 3D 16#define NATIVECHECK							\	{if (BCE_CURRENTFX->native) {goto gonative ;} nextop0; }E 3D 3#define DIFFERENCE						\	{register int arg1, arg2; 				\D 2	CGETNUMBER(TOPOFSTACK, arg2, OP_fix_0);			\	CGETNUMBER(POP_TOS_1, arg1, OP_fix_1);			\E 2I 2	N_GETNUMBER(TOPOFSTACK, arg2, OP_fix_0);		\	N_GETNUMBER(POP_TOS_1, arg1, OP_fix_1);			\E 2	arg1 = arg1 - arg2;	 				\	if(0 <= arg1)						\	  {     if(arg1 <= MAX_SMALL)				\			{ TOPOFSTACK = (S_POSITIVE | arg1); }	\		else	{ SETTOS_NEWFIXP(arg1);}		\	  }else{						\		if(MIN_SMALL <= arg1)				\			{ TOPOFSTACK = (S_NEGATIVE | (0xFFFF & arg1)); }\		else	{ SETTOS_NEWFIXP(arg1);}		\		};						\	nextop1;						\E 3I 3#define DIFFERENCE							\	{TOPOFSTACK = N_OP_difference(POP_TOS_1, TOPOFSTACK, ufn_2);	\	nextop1;							\E 16I 16#define PUTBASEPTR_N(n)							\	{ register int base;						\D 27	  if (GetHiWord(TOPOFSTACK) != (S_POSITIVE >> 16))		\		goto op_ufn;						\	  base = 0xffffff & POP_TOS_1;					\	  *((LispPTR *)Addr68k_from_LADDR(base + n)) = 0xffffff & TOPOFSTACK;\E 27I 27D 30	  base = POP_TOS_1;						\E 30I 30	  base = 0xffffff & POP_TOS_1;					\E 30	  *((LispPTR *)Addr68k_from_LADDR(base + n)) = TOPOFSTACK;      \E 27	  TOPOFSTACK = base;						\	  nextop2;							\E 16E 3	}D 16D 3#define PLUS							\	{register int arg1, arg2; 				\D 2	CGETNUMBER(TOPOFSTACK, arg2, OP_fix_0);			\	CGETNUMBER(POP_TOS_1, arg1, OP_fix_1);			\E 2I 2	N_GETNUMBER(TOPOFSTACK, arg2, OP_fix_0);		\	N_GETNUMBER(POP_TOS_1, arg1, OP_fix_1);			\E 2	arg1 = arg1 + arg2;	 				\	if(0 <= arg1)						\	  {     if(arg1 <= MAX_SMALL)				\			{ TOPOFSTACK = (S_POSITIVE | arg1); }	\		else	{ SETTOS_NEWFIXP(arg1);}		\	  }else{						\		if(MIN_SMALL <= arg1)				\			{ TOPOFSTACK = (S_NEGATIVE | (0xFFFF & arg1)); }\		else	{ SETTOS_NEWFIXP(arg1);}		\		};						\	nextop1;						\E 3I 3#define PLUS								\	{TOPOFSTACK = N_OP_plus2(POP_TOS_1, TOPOFSTACK, ufn_2);		\	nextop1;							\E 16I 16#define PUTBASE_N(n)							\	{ register int base;						\	  if (GetHiWord(TOPOFSTACK) != (S_POSITIVE >> 16))		\		goto op_ufn;						\D 27	  base = 0xffffff & POP_TOS_1;					\E 27I 27D 30	  base = POP_TOS_1;						\E 30I 30	  base = 0xffffff & POP_TOS_1;					\E 30E 27D 78	  *((DLword *)Addr68k_from_LADDR(base + n)) = GetLoWord(TOPOFSTACK);\E 78I 78	  GETWORD((DLword *)Addr68k_from_LADDR(base + n)) = GetLoWord(TOPOFSTACK);\E 78	  TOPOFSTACK = base;						\	  nextop2;							\E 16E 3	}I 16D 66#define PVARX(x)	{ PUSH(GetLongWord((DLword * )PVAR + x)); nextop2; }#define PVARX_(x)	{ *((LispPTR *)((DLword * )PVAR+x))=TOPOFSTACK; nextop2;}#define IVARX(x)	{ PUSH(GetLongWord((DLword * )IVAR + x)); nextop2; }#define IVARX_(x)	{ *((LispPTR *)((DLword * )IVAR+x))=TOPOFSTACK; nextop2;}E 66I 66#define PVARX(x)	{ PUSH(GetLongWord((DLword *)PVAR + x)); nextop2; }#define PVARX_(x)	{ *((LispPTR *)((DLword *)PVAR+x))=TOPOFSTACK; nextop2;}#define IVARX(x)	{ PUSH(GetLongWord((DLword *)IVAR + x)); nextop2; }#define IVARX_(x)	{ *((LispPTR *)((DLword *)IVAR+x))=TOPOFSTACK; nextop2;}E 66#define GVAR(x)		{ PUSH(GetLongWord(Valspace + (x<<1))); nextop3; }E 16D 3#define	GREATERP						\	{register int arg1, arg2; 				\D 2		CGETNUMBER(TOPOFSTACK, arg2, OP_fix_0);		\		CGETNUMBER(POP_TOS_1, arg1, OP_fix_1);		\E 2I 2		N_GETNUMBER(TOPOFSTACK, arg2, OP_fix_0);	\		N_GETNUMBER(POP_TOS_1, arg1, OP_fix_1);		\E 2		if (arg1 > arg2)				\			{ TOPOFSTACK = ATOM_T; }		\		else	{ TOPOFSTACK = NIL_PTR;	 };		\		nextop1;					\E 3I 3D 16#define	GREATERP							\	{TOPOFSTACK = N_OP_greaterp(POP_TOS_1, TOPOFSTACK, ufn_2);	\	nextop1;							\E 3	}E 16I 16#define COPY		{ HARD_PUSH(TOPOFSTACK); nextop1; }E 16I 6D 16#define IPLUS_N(n)							\	{TOPOFSTACK = N_OP_iplusn(TOPOFSTACK, n, ufn_1);		\	nextop1;							\	}E 6I 6#define IDIFFERENCE_N(n)						\	{TOPOFSTACK = N_OP_difference(TOPOFSTACK, n, ufn_1);		\	nextop1;							\	}#define QUOTIENT							\	{TOPOFSTACK = N_OP_quot(POP_TOS_1, TOPOFSTACK, ufn_2); 		\	nextop1;							\	}#define TIMES2								\	{TOPOFSTACK = N_OP_times2(POP_TOS_1, TOPOFSTACK, ufn_2); 	\	nextop1;							\	}#define IREMAINDER							\	{TOPOFSTACK = N_OP_remainder(POP_TOS_1, TOPOFSTACK, ufn_2); 	\	nextop1;							\	}/**//*#define QUOTIENT 	{ EXT; OP_quot(); NRET; } #define TIMES2		{ EXT; OP_times2(); NRET; } #define IREMAINDER 	{ EXT; OP_remainder(); NRET; }*/E 6D 3E 3#define LOGOR	{ EXT; OP_logor(); NRET; } #define LOGAND	{ EXT; OP_logand(); NRET; }I 3#define LOGXOR	{ EXT; OP_logxor(); NRET; }E 3D 5#define LRSH1	{ EXT; OP_lrsh1(); NRET; }#define LRSH8	{ EXT; OP_lrsh8(); NRET; }#define LLSH1	{ EXT; OP_llsh1(); NRET; }#define LLSH8	{ EXT; OP_llsh8(); NRET; }E 5I 5#define LRSH1								\	{TOPOFSTACK = N_OP_lrsh1(TOPOFSTACK, ufn_1);			\	nextop1;							\	}#define LRSH8								\	{TOPOFSTACK = N_OP_lrsh8(TOPOFSTACK, ufn_1);			\	nextop1;							\	}#define LLSH1								\	{TOPOFSTACK = N_OP_llsh1(TOPOFSTACK, ufn_1);			\	nextop1;							\	}#define LLSH8								\	{TOPOFSTACK = N_OP_llsh8(TOPOFSTACK, ufn_1);			\	nextop1;							\	}E 5#define ADDBASE { EXT; OP_addbase(); NRET; }#define LOLOC	{ EXT; OP_loloc(); NRET; }#define HILOC	{ EXT; OP_hiloc(); NRET; }#define VAG2	{ EXT; OP_vag2(); NRET; }D 9E 9I 9/*E 9#define OPCAR	{ EXT; OP_car(); NRET; }#define OPCDR	{ EXT; OP_cdr(); NRET; }I 9*/#define OPCAR	{ TOPOFSTACK = N_OP_car(TOPOFSTACK, ufn_1); nextop1; }#define OPCDR	{ TOPOFSTACK = N_OP_cdr(TOPOFSTACK, ufn_1); nextop1; }E 9#define LISTP	{ EXT; OP_listp(); NRET; }#define NTYPEX	{ EXT; OP_ntypex(); NRET; }#define TYPEP	{ EXT; OP_typep(); NRET; }#define DTEST	{ EXT; OP_dtest(); NRET; }I 3E 16I 16#define SWAP		{ register LispPTR temp;			\D 23		 	 temp = GET_TOS_1;				\E 23I 23D 37		 	 CHECK_INTERRUPT;				\E 37			 temp = GET_TOS_1;				\E 23			 GET_TOS_1 = TOPOFSTACK;			\		 	 TOPOFSTACK = temp;				\			 nextop1;					\			}I 27D 29#define	VAG2		{ TOPOFSTACK = (GET_TOS_1 << 16)) | (0xFFFF & TOPOFSTACK); CSTKPTR--; nextop0; }E 29I 29D 66#define	VAG2		{ TOPOFSTACK = (GET_TOS_1 << 16) | (0xFFFF & TOPOFSTACK); CSTKPTR--; nextop0; }E 29E 27#define UNWIND(n)	{ EXT; OP_unwind(); NRET;}E 66I 66D 69#define	VAG2		{ TOPOFSTACK = (GET_TOS_1 << 16) | (0xFFFF & TOPOFSTACK); CSTKPTR--; nextop1; }E 69I 69#define	N_OP_VAG2		{ TOPOFSTACK = (GET_TOS_1 << 16) | (0xFFFF & TOPOFSTACK); CSTKPTR--; nextop1; }E 69E 66E 16E 3D 2#define FN0		{registers; CHECK_INTERRUPT; OPFN(0); nextop0; }#define FN1		{registers; CHECK_INTERRUPT; OPFN(1); nextop0; }#define FN2		{registers; CHECK_INTERRUPT; OPFN(2); nextop0; }#define FN3		{registers; CHECK_INTERRUPT; OPFN(3); NATIVECHECK; }#define FN4		{registers; CHECK_INTERRUPT; OPFN(4); nextop0; }E 2I 2D 19#define FN0		{CHECK_INTERRUPT; OPFN(0); nextop0; }#define FN1		{CHECK_INTERRUPT; OPFN(1); nextop0; }#define FN2		{CHECK_INTERRUPT; OPFN(2); nextop0; }D 3#define FN3		{CHECK_INTERRUPT; OPFN(3); NATIVECHECK; }E 3I 3#define FN3		{CHECK_INTERRUPT; OPFN(3); nextop0; }E 3#define FN4		{CHECK_INTERRUPT; OPFN(4); nextop0; }E 2D 7#define FNX		{CHECK_INTERRUPT; EXT; OP_fnx(); RET; nextop0; }#define APPLY		{CHECK_INTERRUPT; EXT; OP_apply(); RET; nextop0;  }D 3#define CHECKAPPLY	{ EXT; OP_checkapply(); RET; NATIVECHECK;}#define RETURN		{ OPRETURN; NATIVECHECK; }E 3I 3#define CHECKAPPLY	{CHECK_INTERRUPT; EXT; OP_checkapply(); RET; nextop0; }E 7I 7#define FNX		{CHECK_INTERRUPT; OPFNX;   nextop0; }I 16#define RETURN		{OPRETURN; nextop0; }E 16#define APPLY		{CHECK_INTERRUPT; OPAPPLY; }#define CHECKAPPLY	{OPCHECKAPPLY; nextop1; }E 19I 19D 23#define FN0		{ OPFN(0); CHECK_INTERRUPT; nextop0; }#define FN1		{ OPFN(1); CHECK_INTERRUPT; nextop0; }#define FN2		{ OPFN(2); CHECK_INTERRUPT; nextop0; }#define FN3		{ OPFN(3); CHECK_INTERRUPT; nextop0; }#define FN4		{ OPFN(4); CHECK_INTERRUPT; nextop0; }#define FNX		{ OPFNX;   CHECK_INTERRUPT; nextop0; }I 22#define ENVCALL		{ OP_ENVCALL; CHECK_INTERRUPT; nextop0; }E 23I 23D 64#define FN0		{ OPFN(0); nextop0; }#define FN1		{ OPFN(1); nextop0; }#define FN2		{ OPFN(2); nextop0; }#define FN3		{ OPFN(3); nextop0; }#define FN4		{ OPFN(4); nextop0; }#define FNX		{ OPFNX;   nextop0; }E 64I 64D 65#define FN0		{ OPFN(0, fn0_args, fn0_xna); }#define FN1		{ OPFN(1, fn1_args, fn1_xna); }#define FN2		{ OPFN(2, fn2_args, fn2_xna); }#define FN3		{ OPFN(3, fn3_args, fn3_xna); }#define FN4		{ OPFN(4, fn4_args, fn4_xna); }E 65I 65#define FN0		{ OPFN(0, fn0_args, fn0_xna, fn0_native); }#define FN1		{ OPFN(1, fn1_args, fn1_xna, fn1_native); }#define FN2		{ OPFN(2, fn2_args, fn2_xna, fn2_native); }#define FN3		{ OPFN(3, fn3_args, fn3_xna, fn3_native); }#define FN4		{ OPFN(4, fn4_args, fn4_xna, fn4_native); }E 65#define FNX		{ OPFNX; nextop0; }E 64#define ENVCALL		{ OP_ENVCALL; nextop0; }E 23E 22#define RETURN		{ OPRETURN; nextop0; }#define APPLY		{ OPAPPLY;}#define CHECKAPPLY	{ OPCHECKAPPLY; nextop1; }E 19E 7D 16#define RETURN		{OPRETURN; nextop0; }E 3I 3D 6E 6E 3/*I 7#define CHECKAPPLY	{CHECK_INTERRUPT; EXT; OP_checkapply(); RET; nextop0; }#define APPLY		{CHECK_INTERRUPT; EXT; OP_apply(); RET; nextop0;  }E 7D 3#define FN0		{ goto ni; }#define FN1		{ goto ni; }#define FN2		{ goto ni; }#define FN3		{ goto ni; }#define FN4		{ goto ni; }#define FNX		{ goto ni; }#define APPLY		{ goto ni; }#define CHECKAPPLY	{ goto ni; }#define RETURN		{ goto ni; }E 3I 3#define FN0		{ CHECK_INTERRUPT; goto ni; }#define FN1		{ CHECK_INTERRUPT; goto ni; }#define FN2		{ CHECK_INTERRUPT; goto ni; }#define FN3		{ CHECK_INTERRUPT; goto ni; }#define FN4		{ CHECK_INTERRUPT; goto ni; }#define FNX		{ CHECK_INTERRUPT; goto ni; }#define APPLY		{ CHECK_INTERRUPT; goto ni; }#define CHECKAPPLY	{ CHECK_INTERRUPT; goto ni; }#define RETURN		{ CHECK_INTERRUPT; goto ni; }E 3*/I 6E 6D 3E 3#define BIND		{ EXT; OP_bind(); NRET; }#define UNBIND		{ EXT; OP_unbind(); NRET; }#define DUNBIND		{ EXT; OP_dunbind(); NRET; }#define RPLPTR		{ EXT; OP_rplptr(); NRET; }#define GCREF		{ EXT; OP_gcref(); NRET; }#define ASSOC		{ EXT; OP_assoc(); NRET; }I 9#define RPLACA								\	{TOPOFSTACK = N_OP_rplaca(POP_TOS_1, TOPOFSTACK, ufn_2);	\	 nextop1;							\	}#define RPLACD								\	{TOPOFSTACK = N_OP_rplacd(POP_TOS_1, TOPOFSTACK, ufn_2);	\	 nextop1; 							\	}/*E 16I 16D 66#define ADDBASE 	{ EXT; OP_addbase(); NRET; }D 27#define VAG2		{ EXT; OP_vag2(); NRET; }E 27D 39#define OPCAR		{ EXT; OP_car(); NRET; }#define OPCDR		{ EXT; OP_cdr(); NRET; }E 39I 39/* #define OPCAR		{ EXT; OP_car(); NRET; } *//* #define OPCDR		{ EXT; OP_cdr(); NRET; } */E 39E 16E 9#define RPLACA		{ EXT; OP_rplaca(); NRET; }#define RPLACD		{ EXT; OP_rplacd(); NRET; }I 36#define RPLCONS		{ EXT; OP_rplcons(); NRET; }E 36I 9D 16*/E 16I 16D 26#define DTEST		{ EXT; OP_dtest(); NRET; }E 26I 26D 54#define DTEST(n)	{ EXT; OP_dtest(); NRET; }E 54E 26#define ATOMCELL_N(n)	{ EXT; OP_atomcellN(); NRET; }#define BLT		{ EXT; OP_blt(); NRET; }#define DIFFERENCE	{ EXT; OP_difference(); NRET; }#define PLUS2		{ EXT; OP_plus2(); NRET; }#define QUOTIENT 	{ EXT; OP_quot(); NRET; } #define TIMES2		{ EXT; OP_times2(); NRET; } #define IDIFFERENCE	{ EXT; OP_difference(); NRET; }#define IPLUS2		{ EXT; OP_plus2(); NRET; }#define IQUOTIENT 	{ EXT; OP_quot(); NRET; } #define ITIMES2		{ EXT; OP_times2(); NRET; } #define	GREATERP	{ EXT; OP_greaterp(); NRET; }#define	IGREATERP	{ EXT; OP_greaterp(); NRET; }#define IPLUS_N(n)	{ EXT; OP_iplusn(); NRET; }I 18D 26#define IDIFFERENCE_N(n) { EXT; OP_idifferencefn(); NRET; }E 26I 26#define IDIFFERENCE_N(n) { EXT; OP_idifferencen(); NRET; }E 26E 18#define IREMAINDER 	{ EXT; OP_remainder(); NRET; }#define LOGOR		{ EXT; OP_logor(); NRET; } #define LOGAND		{ EXT; OP_logand(); NRET; }#define LOGXOR		{ EXT; OP_logxor(); NRET; }#define LRSH1		{ EXT; OP_lrsh1(); NRET; }#define LRSH8		{ EXT; OP_lrsh8(); NRET; }#define LLSH1		{ EXT; OP_llsh1(); NRET; }#define LLSH8		{ EXT; OP_llsh8(); NRET; }I 18#define LSH		{ EXT; OP_lsh(); NRET; }E 18#define ADDBASE 	{ EXT; OP_addbase(); NRET; }D 26#define VAG2		{ EXT; OP_vag2(); NRET; }E 26#define GCREF		{ EXT; OP_gcref(); NRET; }#define ASSOC		{ EXT; OP_assoc(); NRET; }E 16E 9D 26#define CONS		{ EXT; OP_cons(); NRET; }E 26D 30#define DBX		{ EXT; OP_dbx(); NRET; }E 30#define FMEMB		{ EXT; OP_fmemb(); NRET; }D 16#define FINDKEY		{ EXT; OP_findkey(); NRET; }E 16#define CREATECELL	{ EXT; OP_createcell(); NRET; }E 66D 8#define BIN		{ EXT; OP_bin(); NRET; }E 8I 8D 9#define BIN		{ TOPOFSTACK = N_OP_bin(TOPOFSTACK, ufn_1); }E 9I 9D 16#define BIN		{ TOPOFSTACK = N_OP_bin(TOPOFSTACK, ufn_1); nextop1; }E 9E 8#define RPLCONS		{ EXT; OP_rplcons(); NRET; }E 16I 16D 52#define BIN		{ EXT; OP_bin(); NRET; }E 52I 52#define BIN								\{									\register Stream *stream68k; /* stream instance on TOS */		\register  char *buff68k;     /* pointer to BUFF */			\									\  if ( GetTypeNumber(TOPOFSTACK) == TYPE_STREAM ) {			\	stream68k=(Stream *) Addr68k_from_LADDR(TOPOFSTACK);		\	if( ( !stream68k->BINABLE ) ||					\	    (  stream68k->COFFSET >=					\	       stream68k->CBUFSIZE   ) ) goto op_ufn;			\									\	/* get BUFFER instance */					\	buff68k =(char *)Addr68k_from_LADDR(stream68k->CBUFPTR);	\									\	/* get BYTE data and set it to TOS */				\	TOPOFSTACK = (S_POSITIVE |					\		      (Get_BYTE(buff68k + (stream68k->COFFSET)++)) );	\I 53	nextop1;							\E 53	}								\  else	goto op_ufn;							\}E 52E 16D 66#define LISTGET		{ EXT; OP_listget(); NRET; }D 16E 16I 16D 62#define PUTBITS_N_M(a,b) { EXT; OP_putbitsnfd(); NRET; }E 62E 16D 25#define EVAL		{ EXT; OP_eval(); NRET; }E 25#define STKSCAN		{ EXT; OP_stkscan(); NRET; }D 27#define RECLAIMCELL	{ EXT; OP_reclaimcell(); NRET; }E 27I 27D 28#define RECLAIMCELL	{ goto op_ufn; }E 28I 28D 31#define RECLAIMCELL	{ TOPOFSTACK = gcreclaimcell(TOPOFSTACK); nextop1; }E 31I 31D 32#define RECLAIMCELL	{ goto op_ufn; /* TOPOFSTACK = gcreclaimcell(TOPOFSTACK); nextop1; */ }E 32I 32D 33#define RECLAIMCELL	{ TOPOFSTACK = gcreclaimcell(TOPOFSTACK); nextop1;}E 33I 33D 34#define RECLAIMCELL	{ goto op_ufn; /* TOPOFSTACK = gcreclaimcell(TOPOFSTACK); nextop1; */}E 34I 34E 66#ifdef RECLAIMINC#define RECLAIMCELL	{ TOPOFSTACK = gcreclaimcell(TOPOFSTACK); nextop1; }#else#define RECLAIMCELL	{ goto op_ufn; }#endifD 52E 52E 34E 33E 32E 31E 28E 27I 6D 66#define GCSCAN1		{ EXT; OP_gcscan1(); NRET; }#define GCSCAN2		{ EXT; OP_gcscan2(); NRET; }I 26#define ARG0		{ EXT; OP_arg0(); NRET; }E 66I 66#define GCSCAN1		{ TOPOFSTACK=gcscan1(TOPOFSTACK & 0xffff);	\			 if (TOPOFSTACK) {TOPOFSTACK |= S_POSITIVE; };nextop1;}E 66E 26D 19#define CONTEXTSWITCH	{ EXT; OP_contextsw(); NRET; }E 19I 19D 20#define CONTEXTSWITCH	{ EXT; OP_contextsw(); RET; CHECK_INTERRUPT; nextop0; }E 20I 20D 23#define CONTEXTSWITCH	{ EXT; OP_contextsw(); RET; CHECK_INTERRUPT; NATIVE_NEXTOP0; }E 23I 23I 66#define GCSCAN2		{ TOPOFSTACK=gcscan2(TOPOFSTACK & 0xffff);	\			  if (TOPOFSTACK) {TOPOFSTACK |=S_POSITIVE; };nextop1;}E 66#define CONTEXTSWITCH	{ EXT; OP_contextsw(); RET; 			\			  /*CHECK_INTERRUPT;*/ CLR_IRQ;			\			  NATIVE_NEXTOP0; }I 26D 66#define PILOTBITBLT	{ EXT; OP_pilotbitblt(); NRET; }E 66E 26E 23E 20E 19E 6D 16E 16D 5#define UBFLOAT3	{ EXT; OP_ubfloat3(); NRET; }E 5I 5D 27#define UBFLOAT3(n)	{ EXT; OP_ubfloat3(); NRET; }E 27I 27D 69#define UBFLOAT3(n)	{ goto op_ufn; }E 69E 27E 5D 16#define TYPEMASK	{ EXT; OP_typemask(); NRET; }E 16D 66#define EQLOP		{ EXT; OP_eqlop(); NRET; }#define DRAWLINE	{ EXT; OP_drawline(); NRET; }D 16#define STOREN		{ EXT; OP_storen(); NRET; }#define COPYN		{ EXT; OP_copyn(); NRET; }#define PVARX(x)	{ PUSH(GetLongWord((DLword * )PVAR + x)); nextop2; }#define PVARX_(x)	{ *((LispPTR *)((DLword * )PVAR+x))=TOPOFSTACK; nextop2;}#define IVARX(x)	{ PUSH(GetLongWord((DLword * )IVAR + x)); nextop2; }#define IVARX_(x)	{ *((LispPTR *)((DLword * )IVAR+x))=TOPOFSTACK; nextop2;}#define GVAR(x)		{ PUSH(GetLongWord(Valspace + (x<<1))); nextop3; }#define GVAR_(x)	{ EXT; OP_gvar_(); NRET; }E 16D 49#define FVARX(x)	{ EXT; OP_fvarn(); NRET; }E 49D 50#define FVARX_(x)	{ EXT; OP_fvar_(); NRET; }E 50I 23D 35#define	NOP		{ CHECK_INTERRUPT; nextop1; }E 35I 35/* JRB - removed CHECK_INTERRUPT from NOP macro */E 66#define	NOP		{ nextop1; }E 35#define RESLIST(n)	{ goto op_ufn; }E 23I 3D 16#define MAKENUMBER 							\		{TOPOFSTACK = N_OP_makenumber(POP_TOS_1,TOPOFSTACK,ufn_2);\E 16I 16D 23E 23D 66/* ***** THESE USE THE NEWER NATIVE INTERFACE ROUTINES ***** */E 66#define FINDKEY(x)							\		{							\		 TOPOFSTACK = N_OP_findkey(TOPOFSTACK, x);		\		 nextop2;						\		}#define RPLPTR(n)							\		{							\		 TOPOFSTACK = N_OP_rplptr(POP_TOS_1, TOPOFSTACK, n);	\		 nextop2;						\		}D 69E 69#define GVAR_(atom_index)						\		{							\D 66		 TOPOFSTACK = N_OP_gvar_(TOPOFSTACK, atom_index);	\E 66I 66		 N_OP_gvar_(TOPOFSTACK, atom_index);			\E 66		 nextop3;						\		}D 51E 51I 51D 66/**E 51#define BIND	{							\		 CSTKPTR = (LispPTR *) N_OP_bind(CSTKPTR, TOPOFSTACK, 	\				Get_BYTE(PCMAC+1), Get_BYTE(PCMAC+2));	\		 TOPOFSTACK = *CSTKPTR;					\		 nextop3;						\		}I 51**/E 66I 66E 66#define BIND	{register int n1;					\		register int n2;					\		register LispPTR *ppvar;				\		register int i;						\D 86		n1 = Get_BYTE(PCMAC+1) >> 4;				\		n2 = Get_BYTE(PCMAC+1) & 0xf;				\		ppvar = (LispPTR *)PVAR + 1 + Get_BYTE(PCMAC+2);	\E 86I 86		n1 = Get_BYTE_PCMAC1 >> 4;				\		n2 = Get_BYTE_PCMAC1 & 0xf;				\		ppvar = (LispPTR *)PVAR + 1 + Get_BYTE_PCMAC2;	\E 86D 67		for(i=0; i<n1; i++){ *--ppvar = NIL_PTR; }		\E 67I 67		for(i=n1; --i >= 0;){ *--ppvar = NIL_PTR; }		\E 67		if(n2 == 0){						\			*CSTKPTR++ = TOPOFSTACK;			\		}else{							\			*--ppvar = TOPOFSTACK;				\			for(i=1; i<n2; i++) { *--ppvar = *(--CSTKPTR); }	\		}							\		i = ~(n1 + n2);						\D 86		TOPOFSTACK = (i<<16) | (Get_BYTE(PCMAC+2)<<1);		\E 86I 86		TOPOFSTACK = (i<<16) | (Get_BYTE_PCMAC2<<1);		\E 86		nextop3;						\		}E 51I 51D 57E 57I 57D 66/**E 57E 51#define UNBIND	{							\		 CSTKPTR = (LispPTR *) N_OP_unbind(CSTKPTR);		\E 16		 nextop1;						\		}I 57**/E 66D 67#define UNBIND	{register DLword num;					\E 67I 67#define UNBIND	{register int num;					\E 67		register LispPTR *ppvar;				\D 66		register int	i;				\		register LispPTR value;				\		for(; !( *--CSTKPTR & 0x80000000 ););		\		value = *CSTKPTR;			\		num = (DLword) ~(value>>16);			\E 66I 66		register int	i;					\		register LispPTR value;					\		for(; ( ((int)*--CSTKPTR) >= 0 ););			\		value = *CSTKPTR;					\D 67		num = (DLword) ~(value>>16);				\E 67I 67		num = (~value)>>16;					\E 67E 66		ppvar = (LispPTR *)((DLword *)PVAR + 2 + GetLoWord(value));\D 67		for(i=0;i<num;++i){*--ppvar = 0xffffffff;}		\E 67I 67		for(i=num; --i >= 0;){*--ppvar = 0xffffffff;}		\E 67		nextop1;						\		}E 57D 16#define BOXIPLUS							\		{TOPOFSTACK = N_OP_boxiplus(POP_TOS_1,TOPOFSTACK,ufn_2);\		nextop1;						\E 16I 16I 57D 66/**E 57#define DUNBIND	{							\		 CSTKPTR = (LispPTR *) N_OP_dunbind(CSTKPTR, TOPOFSTACK);\		 POP;							\		 nextop1;						\E 16		}I 57**/E 66D 67#define DUNBIND	{register DLword num;					\E 67I 67#define DUNBIND	{register int num;					\E 67		register LispPTR *ppvar;				\D 66		register int	i;				\		register LispPTR value;				\		if(TOPOFSTACK & 0x80000000){ 				\E 66I 66		register int	i;					\		register LispPTR value;					\		if((int)TOPOFSTACK < 0){ 				\E 66D 67		  num =(DLword) ~(TOPOFSTACK>>16);			\E 67I 67		  num =(~TOPOFSTACK)>>16;				\E 67		  if(num != 0){						\		    ppvar = (LispPTR *)((DLword *)PVAR + 2 + GetLoWord(TOPOFSTACK)); \D 66		    for(i=0;i<num;++i) { *--ppvar = 0xffffffff; }		\E 66I 66D 67		    for(i=0;i<num;++i) { *--ppvar = 0xffffffff; }	\E 67I 67D 79		    for(i=num; --i >= 0;) { *--ppvar = 0xffffffff; }	\E 79I 79		    for(i=num; --i >= 0;) {  \					    *--ppvar = 0xffffffff; }	\E 79E 67E 66		  }							\		}else{							\D 66		  for(; !( *--CSTKPTR & 0x80000000 ););	\		  value = *CSTKPTR;			\		  num = (DLword) ~(value>>16);			\E 66I 66		for(; ( ((int)*--CSTKPTR) >= 0 ););			\		  value = *CSTKPTR;					\D 67		  num = (DLword) ~(value>>16);				\E 67I 67		  num = (~value)>>16;					\E 67E 66		  ppvar = (LispPTR *)((DLword *)PVAR + 2 + GetLoWord(value));\D 67		  for(i=0;i<num;++i) { *--ppvar = 0xffffffff; }	\E 67I 67D 79		  for(i=num; --i >= 0;) { *--ppvar = 0xffffffff; }	\E 79I 79		  for(i=num; --i >= 0;) {  \					  *--ppvar = 0xffffffff; }	\E 79E 67		}							\		POP;							\		nextop1;						\		}E 57D 16#define BOXIDIFFERENCE							\		{TOPOFSTACK = N_OP_boxidiff(POP_TOS_1,TOPOFSTACK,ufn_2);\E 16I 16D 69#define HILOC								\E 69I 69#define N_OP_HILOC							\E 69		{							\		 TOPOFSTACK = GetHiWord(TOPOFSTACK) | S_POSITIVE;	\		 nextop1;						\		}D 69#define LOLOC								\E 69I 69#define N_OP_LOLOC							\E 69		{							\		 TOPOFSTACK = GetLoWord(TOPOFSTACK) | S_POSITIVE;	\		 nextop1;						\		}I 51D 69/**E 51#define GETBITS_N_M(a, b)						\		{							\		 TOPOFSTACK = N_OP_getbitsnfd(TOPOFSTACK, a, b);	\		 nextop3;						\		}I 62#define PUTBITS_N_M(a,b) { EXT; OP_putbitsnfd(); NRET; }E 62I 51**/E 69I 62E 62#define GETBITS_N_M(a, b)						\		{register int temp;					\		temp = 0xF & b;						\		TOPOFSTACK = S_POSITIVE | 				\D 78		 (( (*(Addr68k_from_LADDR(0xFFFFFF & (TOPOFSTACK+a))))	\E 78I 78		 (( (GETWORD(Addr68k_from_LADDR(0xFFFFFF & (TOPOFSTACK+a))))	\E 78			>> (16 - ( (0xF & (b >> 4)) + temp + 1)) )	\			& n_mask_array[temp] );				\		 nextop3;						\		}I 62#define PUTBITS_N_M(a, b)						\	{ int	base;							\	  register DLword	*pword;					\	  register int shift_size, field_size, fmask;			\	 if( (0xFFFF0000 & TOPOFSTACK) != S_POSITIVE ){ goto op_ufn; };	\	 base = 0xFFFFFF & POP_TOS_1;					\	 pword = (DLword*)Addr68k_from_LADDR( base + a );		\	 field_size = 0xF & b;						\	 shift_size = 15 - (0xF & (b >> 4)) - field_size;		\	 fmask = n_mask_array[field_size] << shift_size;		\D 78	 *pword = ( (TOPOFSTACK << shift_size) & fmask) | (*pword & (~fmask));	\E 78I 78D 79	 GETWORD(pword) = ( (TOPOFSTACK << shift_size) & fmask) | (*pword & (~fmask));	\E 79I 79	 GETWORD(pword) = ( (TOPOFSTACK << shift_size) & fmask) |	\			    (GETWORD(pword) & (~fmask));		\E 79E 78	 TOPOFSTACK = base;						\	 nextop3;							\	}E 62E 51I 26D 69E 69#define CONS								\	{ TOPOFSTACK = N_OP_cons(POP_TOS_1, TOPOFSTACK);		\D 36	  nextop1;							\	}E 26#define RPLCONS								\	{ TOPOFSTACK = N_OP_rplcons(POP_TOS_1, TOPOFSTACK);		\E 36	  nextop1;							\	}#define MYALINK								\	{								\	 PUSH(((( CURRENTFX->alink) & 0xfffe)-FRAMESIZE) | S_POSITIVE);	\	 nextop1;							\	}#define MYARGCOUNT							\	{ register int arg_num;						\	  if (( CURRENTFX->alink & 1) == 0)				\	    arg_num = (int)((LispPTR *)(CURRENTFX) - 1);				\ 	  else								\	    arg_num = (int)(Stackspace + CURRENTFX->blink);		\	 PUSH( (DLword)((arg_num - (int)IVar) >> 2) | S_POSITIVE);	\	 nextop1;							\	}#define RCLK								\	{								\	 TOPOFSTACK = N_OP_rclk(TOPOFSTACK);				\	 nextop1;							\	}#define LISTP	{							\D 67		 if((unsigned int)GetTypeNumber(TOPOFSTACK) != TYPE_LISTP)\E 67I 67		 if((DLword)GetTypeNumber(TOPOFSTACK) != TYPE_LISTP)\E 67    			TOPOFSTACK = NIL_PTR;				\		 nextop1;						\		}#define NTYPEX								\		{							\D 67		 TOPOFSTACK = S_POSITIVE | (unsigned int)(GetTypeNumber(TOPOFSTACK));\E 67I 67		 TOPOFSTACK = S_POSITIVE | (DLword)(GetTypeNumber(TOPOFSTACK));\E 67E 16		nextop1;						\		}E 3D 16#define COPY		{HARD_PUSH(TOPOFSTACK); nextop1; }E 16I 16#define TYPEP(n) 							\		{							\		  if((DLword)GetTypeNumber(TOPOFSTACK) != n)		\    			TOPOFSTACK = NIL_PTR;				\		 nextop2;						\		}E 16D 16#define SWAP		{ register LispPTR temp;			\		 	temp = GET_TOS_1;				\			GET_TOS_1 = TOPOFSTACK;				\		 	TOPOFSTACK = temp;				\			nextop1;					\			}E 16I 16#define TYPEMASK(n) 							\		{							\  		 if( ( ((DLword)GetTypeEntry(TOPOFSTACK))  & 		\		     ( (DLword)n << 8)) == 0)				\    			TOPOFSTACK = NIL_PTR;				\		 nextop2;						\		}E 16I 5I 16#define INSTANCEP(atom_index)						\		{							\		 TOPOFSTACK = N_OP_instancep(TOPOFSTACK,atom_index);	\		 nextop3;						\		}E 16D 16#define AREF1		{ goto ni; }#define AREF2		{ goto ni; }#define ASET1		{ goto ni; }#define ASET2		{ goto ni; }#define MISC3(n)	{ goto ni; }#define MISC4(n)	{ goto ni; }#define CLEQUAL		{ goto ni; }#define ILEQUAL		{ goto ni; }#define CLARITHEQUAL	{ goto ni; }#define UBFLOAT1(n)	{ goto ni; }#define UBFLOAT2(n)	{ goto ni; }#define RESTLIST	{ goto ni; }#define CLFMEMB		{ goto ni; }#define CLASSOC		{ goto ni; }#define FPLUS2		{ goto ni; }#define FDIFFERENCE	{ goto ni; }#define FTIMES2		{ goto ni; }#define FQUOTIENT	{ goto ni; }#define FGREATERP	{ goto ni; }E 16I 16#define STOREN(n)							\		{ *(CSTKPTR  - ((n+2) >> 1)) = TOPOFSTACK;		\		 nextop2;						\		}E 16E 5I 16#define COPYN(n)							\		{ PUSH(*(CSTKPTR  - ((n+2) >> 1)));			\		 nextop2;						\		}E 16I 21D 58#define POPN(n)								\		{CSTKPTR  -= n;						\		 TOPOFSTACK = *CSTKPTR;					\		 nextop2;						\E 58I 58D 66#define POPN(n)									\		{TOPOFSTACK = *(CSTKPTR -= ((n)+1));	\		 nextop2;								\E 66I 66#define POPN(n)								\		{TOPOFSTACK = *(CSTKPTR -= ((n)+1));			\		 nextop2;						\E 66E 58		}I 41#define CLARITHEQUAL	{						\register int arg2;							\D 66  arg2 = POP_TOS_1;							\E 66I 66  SV; arg2 = POP_TOS_1;							\E 66  if ((TOPOFSTACK & 0xff0000) == S_POSITIVE)				\  {									\  if (arg2 == TOPOFSTACK) {TOPOFSTACK = ATOM_T; nextop1;}		\  if ((arg2 & 0xff0000) == S_POSITIVE) {TOPOFSTACK = NIL; nextop1;}	\  }									\D 69  TOPOFSTACK = N_OP_eqq(arg2, TOPOFSTACK, ufn_2);			\  nextop1;								\E 69I 69  N_OP_POPPED_CALL_2(N_OP_eqq, arg2);					\E 69}E 41E 21D 16#define DEFAULT								\D 3ni: 	{  	setniaddr();						\   		EXT;							\E 3I 3ni: 	{	asm("ni:");						\		EXT;							\E 3		(*(OPtbl_base + Get_BYTE(PCMAC)))();			\ 		RET; nextop0; 						\	}E 16I 42#define S_CHARACTER 0x70000D 45#define AREF1	{	\LispPTR arrayarg;	\register LispPTR baseL;	\register int index;	\register DLword *arrayblk;	\DLword	*createcell68k();	\  arrayarg = POP_TOS_1;	\E 45I 45D 46#define AREF1	{							\E 46I 46D 47#undef AREF1#define AREF1	{TOPOFSTACK = N_OP_aref1(POP_TOS_1, TOPOFSTACK, ufn_2);	\	nextop1;}#define AREF1UNSURE	{						\E 47I 47#define AREF1	{							\E 47E 46LispPTR arrayarg;							\register LispPTR baseL;							\register int index;							\D 78register DLword *arrayblk;						\E 78I 78register OneDArray *arrayblk;						\E 78DLword	*createcell68k();						\D 67  arrayarg = POP_TOS_1;							\E 67I 67    SV; arrayarg = POP_TOS_1;						\E 67E 45D 47    if (GetTypeNumber(arrayarg) != TYPE_ONED_ARRAY) ERROR_EXIT(ufn_2);	\E 47I 47    if (GetTypeNumber(arrayarg) != TYPE_ONED_ARRAY) goto aref_ufn;	\E 47D 45    arrayblk = Addr68k_from_LADDR(arrayarg);	\E 45I 45D 78    arrayblk = Addr68k_from_LADDR(arrayarg);				\E 78I 78    arrayblk = (OneDArray *)Addr68k_from_LADDR(arrayarg);		\E 78E 45D 47    if ((TOPOFSTACK & 0xFFFF0000) != S_POSITIVE) ERROR_EXIT(ufn_2);	\E 47I 47    if ((TOPOFSTACK & 0xFFFF0000) != S_POSITIVE) goto aref_ufn;		\E 47D 45    index = TOPOFSTACK & 0xFFFF;	\E 45I 45    index = TOPOFSTACK & 0xFFFF;					\E 45D 47    if (index >= *((DLword *)(arrayblk + 5))) ERROR_EXIT(ufn_2);	\E 47I 47D 78    if (index >= *((DLword *)(arrayblk + 5))) goto aref_ufn;		\E 47D 45    index += *((DLword *)(arrayblk + 3));	\    baseL = *((LispPTR *)(arrayblk));	\    switch (0xFF & *((DLword *)(arrayblk + 2))) {	\      case 0: /* unsigned : 1 bit per element */	\         TOPOFSTACK = S_POSITIVE | (((*(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1);	\         break;	\      case 3: /* unsigned : 8 bits per element */	\         TOPOFSTACK = S_POSITIVE | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF);	\         break;	\      case 4: /* unsigned : 16 bits per element */	\         TOPOFSTACK = S_POSITIVE | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF);	\         break;	\      case 20: /* signed : 16 bits */	\         TOPOFSTACK = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;	\         if (TOPOFSTACK & 0x8000) TOPOFSTACK |= S_NEGATIVE;	\         else TOPOFSTACK |= S_POSITIVE;	\         break;	\      case 22: /* signed : 32 bits */	\E 45I 45    index += *((DLword *)(arrayblk + 3));				\    baseL = *((LispPTR *)(arrayblk));					\    switch (0xFF & *((DLword *)(arrayblk + 2))) {			\E 78I 78    if (index >= arrayblk->totalsize) goto aref_ufn;		\    index += arrayblk->offset;				\    baseL = arrayblk->base;					\    switch (arrayblk->typenumber) {			\E 78D 55      case 0: /* unsigned : 1 bit per element */			\         TOPOFSTACK = S_POSITIVE | (((*(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1);				\E 55I 55      case 38: /* pointer : 32 bits */					\         TOPOFSTACK = *(((int *)Addr68k_from_LADDR(baseL)) + index);	\E 55         nextop1;							\D 55      case 3: /* unsigned : 8 bits per element */			\         TOPOFSTACK = S_POSITIVE | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF);								\         nextop1;							\      case 4: /* unsigned : 16 bits per element */			\         TOPOFSTACK = S_POSITIVE | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF);							\         nextop1;							\E 55      case 20: /* signed : 16 bits */					\D 78         TOPOFSTACK = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;									\E 78I 78         TOPOFSTACK = (GETWORD(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;									\E 78         if (TOPOFSTACK & 0x8000) TOPOFSTACK |= S_NEGATIVE;		\         else TOPOFSTACK |= S_POSITIVE;					\         nextop1;							\I 55      case 67: /* Character :  8 bits */				\D 78         TOPOFSTACK = S_CHARACTER | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF);								\E 78I 78         TOPOFSTACK = S_CHARACTER | ((GETBYTE(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF);								\E 78         nextop1;							\E 55      case 22: /* signed : 32 bits */					\E 45         TOPOFSTACK = *(((int *)Addr68k_from_LADDR(baseL)) + index);	\D 45         switch(TOPOFSTACK & 0xFFFF0000){	\           case 0:	\             TOPOFSTACK |= S_POSITIVE;	\             break;	\           case 0xFFFF0000:	\             TOPOFSTACK &= S_NEGATIVE;	\             break;	\           default:{register DLword *wordp;	\             wordp = createcell68k(TYPE_FIXP);	\             *((int *)wordp) = TOPOFSTACK;	\             (LispPTR)TOPOFSTACK = LADDR_from_68k(wordp);	\             }	\         }	\         break;	\      case 38: /* pointer : 32 bits */	\E 45I 45         switch(TOPOFSTACK & 0xFFFF0000){				\           case 0:							\             TOPOFSTACK |= S_POSITIVE;					\             break;							\D 72           case 0xFFFF0000:						\E 72I 72D 75           case (unsigned)0xFFFF0000:						\E 75I 75           case (unsigned)0xFFFF0000:					\E 75E 72             TOPOFSTACK &= S_NEGATIVE;					\             break;							\           default:{register DLword *wordp;				\             wordp = createcell68k(TYPE_FIXP);				\             *((int *)wordp) = TOPOFSTACK;				\             (LispPTR)TOPOFSTACK = LADDR_from_68k(wordp);		\             }								\         }								\         nextop1;							\D 55      case 38: /* pointer : 32 bits */					\E 45         TOPOFSTACK = *(((int *)Addr68k_from_LADDR(baseL)) + index);	\E 55I 55      case 0: /* unsigned : 1 bit per element */			\D 78         TOPOFSTACK = S_POSITIVE | (((*(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1);				\E 78I 78         TOPOFSTACK = S_POSITIVE | (((GETBYTE(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1);				\E 78E 55D 45         break;	\      case 54: /* Float : 32 bits */{register DLword *wordp;	\         wordp = createcell68k(TYPE_FLOATP);	\         *((int *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);	\         (LispPTR)TOPOFSTACK = LADDR_from_68k(wordp);	\         }	\         break;	\      case 67: /* Character :  8 bits */	\         TOPOFSTACK = S_CHARACTER | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF);	\         break;	\      case 68: /* Character :  16 bits */	\         TOPOFSTACK = S_CHARACTER | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF);	\         break;	\      case 86: /* XPointer : 32 bits */	\E 45I 45         nextop1;							\I 55      case 3: /* unsigned : 8 bits per element */			\D 78         TOPOFSTACK = S_POSITIVE | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF);								\E 78I 78         TOPOFSTACK = S_POSITIVE | ((GETBYTE(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF);								\E 78         nextop1;							\      case 4: /* unsigned : 16 bits per element */			\D 78         TOPOFSTACK = S_POSITIVE | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF);							\E 78I 78         TOPOFSTACK = S_POSITIVE | ((GETWORD(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF);							\E 78         nextop1;							\E 55      case 54: /* Float : 32 bits */{register DLword *wordp;		\         wordp = createcell68k(TYPE_FLOATP);				\         *((int *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);\         (LispPTR)TOPOFSTACK = LADDR_from_68k(wordp);			\         }								\D 55         nextop1;							\      case 67: /* Character :  8 bits */				\         TOPOFSTACK = S_CHARACTER | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF);								\E 55         nextop1;							\      case 68: /* Character :  16 bits */				\D 78         TOPOFSTACK = S_CHARACTER | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF);							\E 78I 78         TOPOFSTACK = S_CHARACTER | ((GETWORD(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF);							\E 78         nextop1;							\      case 86: /* XPointer : 32 bits */					\E 45         TOPOFSTACK = *(((int *)Addr68k_from_LADDR(baseL)) + index);	\D 45         break;	\      default: /* Illegal or Unimplemented */	\        ERROR_EXIT(ufn_2);	\    }/* end switch typenumber */	\nextop1;	\E 45I 45         nextop1;							\      default: /* Illegal or Unimplemented */				\D 47        ERROR_EXIT(ufn_2);						\E 47I 47        goto aref_ufn;							\E 47    }/* end switch typenumber */					\I 47aref_ufn:								\D 69TOPOFSTACK = N_OP_aref1(arrayarg, TOPOFSTACK, ufn_2); nextop1;		\E 69I 69	N_OP_POPPED_CALL_2(N_OP_aref1, arrayarg); 			\E 69E 47}I 54#define DTEST(n)							\{									\	register int atom_index;					\	register struct dtd *dtd68k ;					\	atom_index = n;							\ for(dtd68k=(struct dtd *) GetDTD(GetTypeNumber(TOPOFSTACK));		\	atom_index != dtd68k->dtd_name ;				\	    dtd68k=(struct dtd *) GetDTD(dtd68k->dtd_supertype))	\	{								\		if( dtd68k->dtd_supertype == 0)				\		{							\D 60		 TOPOFSTACK = N_OP_dtest(TOPOFSTACK,atom_index,ufn_1d);	\		 nextop3;						\E 60I 60		 goto op_ufn;						\E 60		}							\	}								\nextop3;								\}I 59D 66/** #define FVAR(n)	{fvar_chain = PVar + n; goto fvar_code;}  **/E 66E 59E 54D 69E 69I 61D 66#ifndef OLD_FVARE 66E 61D 59#define FVAR(n)	{fvar_chain = PVar + n; goto fvar_code;}E 59I 59#define FVAR(n)	{							\I 61register LispPTR *chain;						\chain = (LispPTR *) (PVar + n);						\D 79if(((WBITS *)chain)->LSB){						\E 79I 79if(WBITSPTR(chain)->LSB){						\E 79	PUSH(GetLongWord(Addr68k_from_LADDR(				\		0xFFFFFF & SWAP_WORDS(native_newframe(n >> 1)))));	\	nextop1;							\    }/* if(((WBITS */							\PUSH(GetLongWord(Addr68k_from_LADDR(0xFFFFFF & SWAP_WORDS(*chain))));	\nextop1;								\}D 66#elseE 66D 69E 69D 66#define FVAR(n)	{							\E 61register DLword	*chain;							\chain = PVar + n;							\if(((WBITS *)chain)->LSB){						\	register struct fnhead	*apfnhead1;				\	register int	paoffset;					\	apfnhead1 = FuncObj;						\	paoffset  = ((int)chain - (int)PVar)>>2;			\	nnewframe(CURRENTFX,						\		  chain,						\		  (*(((DLword *)apfnhead1) +				\		     (  apfnhead1->fvaroffset				\		      - apfnhead1->nlocals				\		      + paoffset))));					\    }/* if(((WBITS */							\PUSH(									\  GetLongWord( 								\	Addr68k_from_LADDR(0xFFFFFF & (((*(chain+1))<<16) | *chain))));	\nextop1;								\}E 66E 59D 68I 61D 66#endifE 61I 59E 66E 59D 60#define FVAR_CODE_HERE							\E 60I 60#define FVAR_CODE_HERE /* no longer used, but macro referenced */D 66#define FVAR_CODE_HERE_OBSOLETE						\E 60fvar_code:								\{									\register DLword	*chain;							\chain = fvar_chain;							\if(((WBITS *)chain)->LSB){						\	register struct fnhead	*apfnhead1;				\D 59	register DLword *pfh;						\E 59	register int	paoffset;					\	apfnhead1 = FuncObj;						\D 59	pfh = (DLword *)apfnhead1;					\	paoffset = ((int)chain - (int)PVar)>>2;				\	nnewframe(CURRENTFX, chain, (*(pfh + (apfnhead1->fvaroffset + paoffset - apfnhead1->nlocals))));						\E 59I 59	paoffset  = ((int)chain - (int)PVar)>>2;			\	nnewframe(CURRENTFX,						\		  chain,						\		  (*(((DLword *)apfnhead1) +				\		     (  apfnhead1->fvaroffset				\		      - apfnhead1->nlocals				\		      + paoffset))));					\E 59    }/* if(((WBITS */							\PUSH(									\  GetLongWord( 								\	Addr68k_from_LADDR(0xFFFFFF & (((*(chain+1))<<16) | *chain))));	\nextop1;								\E 45}E 66E 42E 68I 48D 49#define FVARX(n)	{fvarx_chain = PVar + n; goto fvarx_code;}E 49I 49D 59#define FVARX(n)	{fvar_chain = PVar + n; goto fvarx_code;}E 59I 59D 66/** #define FVARX(n)	{fvar_chain = PVar + n; goto fvarx_code;}  **/I 61#ifndef OLD_FVARE 66E 61#define FVARX(n)	{						\I 61register LispPTR *chain;						\chain = (LispPTR *) (PVar + n);						\D 79if(((WBITS *)chain)->LSB){						\E 79I 79if(WBITSPTR(chain)->LSB){						\E 79	PUSH(GetLongWord(Addr68k_from_LADDR(				\		0xFFFFFF & SWAP_WORDS(native_newframe(n >> 1)))));	\	nextop2;							\    }/* if(((WBITS */							\PUSH(GetLongWord(Addr68k_from_LADDR(0xFFFFFF & SWAP_WORDS(*chain))));	\nextop2;								\}D 68D 66#else#define FVARX(n)	{						\E 61register DLword	*chain;							\chain = PVar + n;							\if(((WBITS *)chain)->LSB){						\	register struct fnhead	*apfnhead1;				\	register int	paoffset;					\	apfnhead1 = FuncObj;						\	paoffset  = ((int)chain - (int)PVar)>>2;			\	nnewframe(CURRENTFX,						\		  chain,						\		  (*(((DLword *)apfnhead1) +				\		     (  apfnhead1->fvaroffset				\		      - apfnhead1->nlocals				\		      + paoffset))));					\    }/* if(((WBITS */							\PUSH(									\  GetLongWord( 								\	Addr68k_from_LADDR(0xFFFFFF & (((*(chain+1))<<16) | *chain))));	\nextop2;								\}E 59E 49I 61#endifE 66E 61D 60#define FVARX_CODE_HERE							\E 60I 60#define FVARX_CODE_HERE /* no longer used but macro referenced */E 68D 66#define FVARX_CODE_HERE_OBSOLETE					\E 60fvarx_code:								\{									\register DLword	*chain;							\D 49chain = fvarx_chain;							\E 49I 49chain = fvar_chain;							\E 49if(((WBITS *)chain)->LSB){						\	register struct fnhead	*apfnhead1;				\	register DLword *pfh;						\	register int	paoffset;					\	apfnhead1 = FuncObj;						\	pfh = (DLword *)apfnhead1;					\	paoffset = ((int)chain - (int)PVar)>>2;				\	nnewframe(CURRENTFX, chain, (*(pfh + (apfnhead1->fvaroffset + paoffset - apfnhead1->nlocals))));						\    }/* if(((WBITS */							\PUSH(									\  GetLongWord( 								\	Addr68k_from_LADDR(0xFFFFFF & (((*(chain+1))<<16) | *chain))));	\nextop2;								\}E 66E 48D 16#define OPCODEFAIL							\									\OP_fix_2:								\D 3	setfixtosaddr2();						\E 3I 3	asm("fixtos2:");						\E 3	FIXTOS1;							\OP_fix_1:								\D 3	setfixtosaddr();						\E 3I 3	asm("fixtos1:");						\E 3	FIXTOS1;							\OP_fix_0:								\	EXT;								\  	(*(OPtbl_base + Get_BYTE(PCMAC)))();				\   	RET;								\  	nextop0;E 16I 41D 66E 66E 41I 16D 69/* these opcodes UFN, but NEED to be DEFINED */E 69I 69/* ********************************************************************	*//* THE FOLLOWING WAS IN n_op_inlinedefsC.h *//* ********************************************************************	*/E 69E 16I 3I 16D 69#define CLFMEMB		{ goto op_ufn; }#define CLASSOC		{ goto op_ufn; }#define CLEQUAL		{ goto op_ufn; }#define ILEQUAL		{ goto op_ufn; }D 41#define CLARITHEQUAL	{ goto op_ufn; }E 41#define UBFLOAT1(n)	{ goto op_ufn; }#define UBFLOAT2(n)	{ goto op_ufn; }D 23#define RESTLIST	{ goto op_ufn; }E 23I 23#define RESTLIST(n)	{ goto op_ufn; }E 23#define FPLUS2		{ goto op_ufn; }#define FDIFFERENCE	{ goto op_ufn; }#define FTIMES2		{ goto op_ufn; }#define FQUOTIENT	{ goto op_ufn; }#define FGREATERP	{ goto op_ufn; }#define CLEQUAL		{ goto op_ufn; }#define MAKENUMBER 	{ goto op_ufn; }#define BOXIPLUS	{ goto op_ufn; }	D 66#define BOXIDIFFERENCE	{ goto op_ufn; }						/* these opcodes are defined only in the Native Interface with assembly help */E 66I 66#define BOXIDIFFERENCE	{ goto op_ufn; }E 66D 44#define AREF1		{ goto op_ufn; }E 44#define AREF2		{ goto op_ufn; }#define ASET1		{ goto op_ufn; }#define ASET2		{ goto op_ufn; }#define MISC3(n)	{ goto op_ufn; }#define MISC4(n)	{ goto op_ufn; }E 69I 69#define GCREF(n)							\	{TOPOFSTACK = htfind(TOPOFSTACK, n);				\	nextop2;}E 69E 16E 3D 2E 2I 2D 27#define	UFN_CALLS							\									\I 10D 16ufn_9:	fixspn(10);							\	CSTKPTR += 8;							\	EXT;								\E 16I 16op_ufn:	EXT;								\E 16	ufn(Get_BYTE(PCMAC));						\	RET;								\I 19	CHECK_INTERRUPT;						\E 19D 16	nextop0;							\E 10I 6ufn_4d:	fixspn(6);							\	CSTKPTR += 3;							\	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\ufn_3d:	fixspn(5);							\	CSTKPTR += 2;							\	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\I 12ufn_2d:	fixspn(4);							\	CSTKPTR += 1;							\	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\D 13	nextop0;	E 13I 13D 14	nextop0;						\	E 14I 14	nextop0;							\E 14E 13E 12I 8ufn_1d:	fixsp3();							\	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\D 9	nextop0;E 9I 9	nextop0;							\E 9E 8ufn_3:	fixspn(4);							\	CSTKPTR += 2;							\	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\E 6ufn_2:	fixsp3();							\	CSTKPTR += 1;							\D 6/*	printf("ufn try: 0x%x ? 0x%x, SP:0x%x\n",GET_TOS_1, TOPOFSTACK,(int) CSTKPTR);	*/\E 6	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\ufn_1:	fixsp2();							\D 7	EXT;								\E 7I 7ufn_0:	EXT;								\E 7	ufn(Get_BYTE(PCMAC));						\	RET;								\E 16D 20	nextop0;E 20I 20	NATIVE_NEXTOP0;E 20I 3D 16E 3E 2E 16E 27I 27D 69#define UFN_CALLSE 69I 69#define ATOMCELL_N(n)							\	{if ((unsigned int)TOPOFSTACK >> 16) {goto op_ufn;}		\	TOPOFSTACK = (n << 16) + (TOPOFSTACK << 1) ;			\	nextop2;							\	}#define DIFFERENCE	{N_OP_CALL_2(N_OP_difference);}#define LOGOR		{N_OP_CALL_2(N_OP_logor);}D 70#define LOGAND 		{N_OP_CALL_2N_OP_logand();}#define LOGXOR 		{N_OP_CALL_2N_OP_logand(N_OP_logxor);}E 70I 70#define LOGAND 		{N_OP_CALL_2(N_OP_logand);}#define LOGXOR 		{N_OP_CALL_2(N_OP_logxor);}E 70#define PLUS2		{N_OP_CALL_2(N_OP_plus2);}#define QUOTIENT	{N_OP_CALL_2(N_OP_quot);}#define TIMES2		{N_OP_CALL_2(N_OP_times2);}D 70#define	GREATERP	{N_OP_CALL_2(N_OP_greaterp();}E 70I 70#define	GREATERP	{N_OP_CALL_2(N_OP_greaterp);}E 70#define IDIFFERENCE	{N_OP_CALL_2(N_OP_idifference);}#define IPLUS2		{N_OP_CALL_2(N_OP_iplus2);}#define IQUOTIENT	{N_OP_CALL_2(N_OP_iquot);}#define ITIMES2		{N_OP_CALL_2(N_OP_itimes2);}D 70#define	IGREATERP	{N_OP_CALL_2(N_OP_igreaterp();}E 70I 70#define	IGREATERP	{N_OP_CALL_2(N_OP_igreaterp);}E 70#define IREMAINDER	{N_OP_CALL_2(N_OP_iremainder);}#define IPLUS_N(n)	{N_OP_CALL_1d(N_OP_iplusn, n)}#define IDIFFERENCE_N(n)	{N_OP_CALL_1d(N_OP_idifferencen, n);}#define BOXIPLUS	{N_OP_CALL_2(N_OP_boxiplus);}#define BOXIDIFFERENCE	{N_OP_CALL_2(N_OP_boxidiff);}#define FPLUS2		{N_OP_CALL_2(N_OP_fplus2);}#define FDIFFERENCE	{N_OP_CALL_2(N_OP_fdifference);}#define FTIMES2		{N_OP_CALL_2(N_OP_ftimes2);}#define FQUOTIENT	{N_OP_CALL_2(N_OP_fquotient);}#define FGREATERP	{N_OP_CALL_2(N_OP_fgreaterp);}#define UBFLOAT1(n)	{N_OP_UNBOXED_CALL_1d(N_OP_ubfloat1, n);}#define UBFLOAT2(n)	{N_OP_UNBOXED_CALL_2d(N_OP_ubfloat2, n);}#define UBFLOAT3(n)	{N_OP_UNBOXED_CALL_3d(N_OP_ubfloat3, n);}#define LRSH1		{N_OP_CALL_1(N_OP_lrsh1);}#define LRSH8		{N_OP_CALL_1(N_OP_lrsh8);}#define LLSH1		{N_OP_CALL_1(N_OP_llsh1);}#define LLSH8		{N_OP_CALL_1(N_OP_llsh8);}#define LSH		{N_OP_CALL_2(N_OP_lsh);}#define RPLACA		{N_OP_CALL_2(N_OP_rplaca);}#define RPLACD		{N_OP_CALL_2(N_OP_rplacd);}#define RPLCONS		{N_OP_CALL_2(N_OP_rplcons);}#define MAKENUMBER 	{N_OP_CALL_2(N_OP_makenumber);}#define EQLOP		{N_OP_CALL_2(N_OP_eqlop);}#define CLEQUAL		{N_OP_CALL_2(N_OP_clequal);}#define ILEQUAL		{N_OP_CALL_2(N_OP_equal);}#define CLFMEMB		{N_OP_CALL_exception_2(N_OP_clfmemb);}#define CLASSOC		{N_OP_CALL_exception_2(N_OP_classoc);}#define FMEMB		{N_OP_CALL_exception_2(N_OP_fmemb);}#define ASSOC		{N_OP_CALL_exception_2(N_OP_assoc);}#define ARG0		{N_OP_CALL_1(N_OP_arg0);}#define LISTGET		{N_OP_CALL_exception_2C(N_OP_listget);}#define DRAWLINE	{N_OP_CALL_9(N_OP_drawline);}#define N_OP_ADDBASE	{N_OP_CALL_2(N_OP_addbase);}#define UNWIND(n, m)							\		{	 						\		 if ((int)(CSTKPTR = (LispPTR *)			\		      N_OP_unwind(CSTKPTR, TOPOFSTACK, n, m)) < 0) 	\			goto unwind_err;				\		 POP;							\		 nextop3;						\		}#define STKSCAN								\		{TOPOFSTACK = N_OP_stkscan(TOPOFSTACK);			\		 nextop1;						\		}#define FVARX_(n)							\		{TOPOFSTACK = N_OP_fvar_(TOPOFSTACK, n);		\		 nextop2;						\		}#define BLT		{N_OP_CALL_3(N_OP_blt);}#define PILOTBITBLT							\		{TOPOFSTACK = N_OP_pilotbitblt(POP_TOS_1, TOPOFSTACK);	\		 nextop1;						\		}#define CREATECELL	{N_OP_CALL_1(N_OP_createcell);}#define RESTLIST(n)	{TOPOFSTACK = N_OP_restlist(POP_TOS_1, TOPOFSTACK, n);\			nextop2;}#define ASET1		{N_OP_CALL_3(N_OP_aset1);}#define ASET2		{N_OP_CALL_4(N_OP_aset2);}#define MISC3(n)	{N_OP_CALL_3d(N_OP_misc3, n);}#define MISC4(n)	{N_OP_CALL_4d(N_OP_misc4, n);}I 82#define MISC7(n)	{N_OP_CALL_7d(N_OP_misc7, n);}E 82#define AREF2		{N_OP_CALL_3(N_OP_aref2);}I 71#define MISCN(index, args)						\D 73{	if ((int)(TOPOFSTACK = 						\			N_OP_miscn(TOPOFSTACK, CSTKPTR, index, args)) 	\		< 0) {							\		TOPOFSTACK = (LispPTR) TopOfStack;			\E 73I 73{	EXT;								\	if (OP_miscn())  {						\		RET;							\E 73D 77		PUSH(S_POSITIVE | (index << 8) | args);			\E 77I 77	/*	PUSH(S_POSITIVE | (index << 8) | args);		*/	\E 77		goto op_ufn;						\		}							\D 73	CSTKPTR -= (args-1);						\	nextop3;							\E 73I 73	RET;								\	nextop0;							\E 73}E 71/* ******************************************************************** *//*	Call Interface where -1 indicates an error return		*//* ******************************************************************** *//* SV need do no work */#define SV/* UFN_CALLS are inserted in xc.c. Note that only ufn_2 calls have decremented the stack at the time the UFN is called *//* ufn_x	there are x args from the Lisp stack   ufn_xd	there are x args from the Lisp stack & 		some from the code stream.*/#define	UFN_CALLS							\									\unwind_err:	 							\	CSTKPTR = (LispPTR *) CurrentStackPTR;				\	Error_Exit = 0;							\	goto op_ufn;							\ufn_2d:	CSTKPTR += 1;							\	goto fix_tos_ufn;						\ufn_2d2:CSTKPTR += 1;							\	goto fix_tos_ufn;						\ufn_2:	CSTKPTR += 1;							\	goto fix_tos_ufn;						\exception_2 : 								\	Error_Exit = 0;							\	CSTKPTR += 1;							\	TOPOFSTACK = TopOfStack;					\	if(!Irq_Stk_End){						\		 goto check_interrupt;					\	}								\	else goto op_ufn;						\exception_2C : 								\	Error_Exit = 0;							\	TOPOFSTACK = TopOfStack;					\	*CSTKPTR = Scratch_CSTK;					\	CSTKPTR += 1;							\	if(!Irq_Stk_End){						\		 goto check_interrupt;					\	}								\	else {								\		goto op_ufn;						\	}								\fix_tos_ufn:								\	TOPOFSTACK = TopOfStack;					\	Error_Exit = 0;							\	goto op_ufn;#define N_OP_CALL_1(op_name)						\if ((int)((int)TOPOFSTACK = op_name(TOPOFSTACK)) < 0) goto fix_tos_ufn;	\nextop1;#define N_OP_CALL_1d(op_name, n)					\if ((int)((int)TOPOFSTACK = op_name(TOPOFSTACK, n)) < 0) goto fix_tos_ufn;\nextop2;#define N_OP_UNBOXED_CALL_1d(op_name, n)				\TOPOFSTACK = op_name(TOPOFSTACK, n);					\if (Error_Exit) goto fix_tos_ufn;					\nextop2;#define N_OP_CALL_2(op_name)						\if ((int)((int)TOPOFSTACK = op_name(POP_TOS_1, TOPOFSTACK)) < 0)	\	goto ufn_2;							\nextop1;#define N_OP_POPPED_CALL_2(op_name, popped_arg)				\if ((int)((int)TOPOFSTACK = op_name(popped_arg, TOPOFSTACK)) < 0)	\	goto ufn_2;							\nextop1;#define N_OP_CALL_2d(op_name, n)					\if ((int)((int)TOPOFSTACK = op_name(POP_TOS_1, TOPOFSTACK, n)) < 0)	\	goto ufn_2d;							\nextop2;#define N_OP_UNBOXED_CALL_2d(op_name, n)				\TOPOFSTACK = op_name(POP_TOS_1, TOPOFSTACK, n);				\if (Error_Exit) goto ufn_2d;						\nextop2;#define N_OP_CALL_2d2(op_name, a, b)					\if ((int)((int)TOPOFSTACK = op_name(POP_TOS_1, TOPOFSTACK, a, b)) < 0)	\	goto ufn_2d2;							\nextop3;#define N_OP_CALL_exception_2(op_name)					\if ((int)((int)TOPOFSTACK = op_name(POP_TOS_1, TOPOFSTACK)) < 0)	\	goto exception_2;						\nextop1;#define N_OP_CALL_exception_2C(op_name)					\if ((int)((int)TOPOFSTACK = op_name(POP_TOS_1, TOPOFSTACK)) < 0)	\	goto exception_2C;						\nextop1;#define N_OP_CALL_3(op_name)						\if ((int)((int)TOPOFSTACK = op_name(					\		 *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK)) < 0)		\	goto fix_tos_ufn;						\CSTKPTR -= 2;								\nextop1;#define N_OP_CALL_3d(op_name, n)					\if ((int)((int)TOPOFSTACK = op_name(					\		 *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n)) < 0)	\	goto fix_tos_ufn;						\CSTKPTR -= 2;								\nextop2;#define N_OP_UNBOXED_CALL_3d(op_name, n)				\TOPOFSTACK = op_name(*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n);	\if (Error_Exit) goto fix_tos_ufn;					\CSTKPTR -= 2;								\nextop2;#define N_OP_CALL_4(op_name)						\if ((int)((int)TOPOFSTACK = op_name(					\	*(CSTKPTR-3), *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK)) < 0)	\	goto fix_tos_ufn;						\CSTKPTR -= 3;								\nextop1;#define N_OP_CALL_4d(op_name, n)					\if ((int)((int)TOPOFSTACK = op_name(					\	*(CSTKPTR-3), *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n)) < 0)	\	goto fix_tos_ufn;						\CSTKPTR -= 3;								\nextop2;I 82#define N_OP_CALL_7d(op_name, n)					\if ((int)((int)TOPOFSTACK = op_name(					\	*(CSTKPTR-6), *(CSTKPTR-5), *(CSTKPTR-4),			\	*(CSTKPTR-3), *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n)) < 0)	\	goto fix_tos_ufn;						\CSTKPTR -= 6;								\nextop2;E 82#define N_OP_CALL_9(op_name)						\if ((int)((int)TOPOFSTACK = op_name(					\		 *(CSTKPTR-8), *(CSTKPTR-7), *(CSTKPTR-6),		\		 *(CSTKPTR-5), *(CSTKPTR-4), *(CSTKPTR-3), *(CSTKPTR-2),\		 *(CSTKPTR-1), TOPOFSTACK, fix_tos_ufn)) < 0)		\	goto fix_tos_ufn;						\CSTKPTR -= 8;								\nextop1;D 70#ifdef NOASME 70I 70D 76#ifdef SUN3_OS3_ILE 76I 76#ifdef SUN3_OS3_OR_OS4_ILE 76E 70D 70/* no opcode fail point necessary */#define OPCODEFAIL#elseE 70/* need jump point for inline asm code, e.g., for IPLUS */#define OPCODEFAIL							\									\fixtos1:								\D 76asm("fixtos1:");							\E 76I 76	fixtos1_label();						\E 76	FIXTOS1;							\	goto op_ufn;I 70#else/* no opcode fail point necessary */#define OPCODEFAILE 70#endifE 69E 27E 1