h36839s 00000/00000/00163d D 2.6 90/04/19 21:49:55 sybalsky 7 6c AIX/Posix:  Name shortenedes 00003/00000/00160d D 2.5 90/03/13 18:58:14 sybalsky 6 5c make SWAP-WWORDS not evaluate its argument twice.es 00003/00001/00157d D 2.4 88/10/13 15:09:06 krivacic 5 4c fix IVAR & PVAR macros (missing PCMACL += 1)es 00000/00003/00158d D 2.3 88/10/12 17:08:39 krivacic 4 3c fix sccs stampes 00137/00116/00024d D 2.2 88/10/04 15:50:56 krivacic 3 2c take sun 4 updateses 00000/00000/00140d D 2.1 88/05/17 09:18:10 hayata 2 1c Version up to 2.1es 00140/00000/00000d D 1.1 88/03/23 10:11:07 krivacic 1 0c date and time created 88/03/23 10:11:07 by krivaciceuUtTI 1/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */D 4/* This is G-file @(#) inlinedefs68K.h Version 1.4 (3/13/88). copyright Xerox & Fuji Xerox  */E 4/* 	inlinedefsSPARC.h */D 3/* 	Bob Krivacic 2/23/88 */E 3I 3/* 	Bob Krivacic, Steve Purcell  */E 3D 3/* 	These are the Macros Used to generate inline 68K assembly code E 3I 3/* 	These are the Macros Used to generate inline SPARC assembly code E 3	to implement the opcodes.  Used by both dispatch 	loop and native code.*/D 3/* ******** noop for now ********#undef DIFFERENCE#undef PLUS#undef GREATERP#undef LOGOR#undef LOGAND#undef LOGXOR#undef LRSH8#undef LRSH1#undef LLSH8#undef LLSH1#undef ADDBASE#undef LOLOC#undef HILOC#undef VAG2#undef LISTP#undef NTYPEX#undef TYPEP#undef SWAP_WORDSE 3I 3/* this is *very* carefully written to generate optimal sun4 assembly code. Be very careful modifying it if you must do so. scp*/E 3I 3/*	Get_BYTE(PCMAC+1);			\xc.c:		#define PCMAC pccachexc.c:		register InstPtr pccache;xc.c:		typedef ByteCode *InstPtr;  CHANGED TOxc.c:		typedef BYTECODE *InstPtr;lispemul.h:	typedef char ByteCode;lispemul.h:	#define Get_BYTE(byteptr)	(((BYTECODE *)(byteptr))->code)lispemul.h:	typedef struct {unsigned code : 8;} BYTECODE; */E 3D 3#define SWAP_WORDS(x) swapx(x) #define DIFFERENCE {						\	TOPOFSTACK = op_difference(POP_TOS_1, TOPOFSTACK);	\	nextop1;						\diff_err:							\	asm("diff_err:");					\	TOPOFSTACK = N_OP_difference(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\	}E 3I 3/* shuffle loads to go faster */#undef IVARMACRO#define	IVARMACRO(x) {						\	register LispPTR *var = (LispPTR *)IVar;		\								\	HARD_PUSH(TOPOFSTACK); 					\	{register unsigned char opcode;				\	opcode = *(unsigned char *)(PCMAC+1);			\	TOPOFSTACK = *(var + x); 				\I 5 	PCMACL += 1;						\E 5D 4	PCMAC += 1;						\E 4	fast_dispatcher(table, opcode);}			\	goto nextopcode; }E 3D 3#define PLUS {							\	TOPOFSTACK = op_plus(POP_TOS_1, TOPOFSTACK);		\	nextop1;						\plus_err:							\	asm("plus_err:");					\	TOPOFSTACK = N_OP_plus2(GET_POPPED, TOPOFSTACK, ufn_2);	\	nextop1;						\	}E 3I 3#undef PVARMACRO#define	PVARMACRO(x) {						\	register LispPTR *var = (LispPTR *)PVar;		\								\	HARD_PUSH(TOPOFSTACK); 					\	{register unsigned char opcode;				\	opcode = *(unsigned char *)(PCMAC+1);			\	TOPOFSTACK = *(var + x); 				\I 5 	PCMACL += 1;						\E 5D 4	PCMAC += 1;						\E 4	fast_dispatcher(table, opcode);}			\	goto nextopcode; }E 3D 3#define	GREATERP {						\	TOPOFSTACK = op_greaterp(POP_TOS_1, TOPOFSTACK);	\	nextop1;						\greaterp_err:							\	asm("greaterp_err:");					\	TOPOFSTACK = N_OP_greaterp(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\	}E 3D 3#define LOGOR { 						\	TOPOFSTACK = op_logor(POP_TOS_1, TOPOFSTACK);		\	nextop1;						\logor_err:							\	asm("logor_err:");					\	TOPOFSTACK = N_OP_logor(GET_POPPED, TOPOFSTACK, ufn_2);	\	nextop1;						\	} #define LOGAND {						\	TOPOFSTACK = op_logand(POP_TOS_1, TOPOFSTACK);		\	nextop1;						\logand_err:							\	asm("logand_err:");					\	TOPOFSTACK = N_OP_logand(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\	}E 3I 3#define NSMALLP(x) (((x) >> 17) ^ 7)#define NSMALLP_RANGE(x) (((x << 15) >>15) ^ x)E 3D 3#define LOGXOR {						\	TOPOFSTACK = op_logxor(POP_TOS_1, TOPOFSTACK);		\	nextop1;						\logxor_err:							\	asm("logxor_err:");					\	TOPOFSTACK = N_OP_logxor(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\	}E 3I 3#define UNBOX_SMALLP(sour)  ( ((int)sour << 15) >> 15 )E 3I 3#define HARD_CASE(fn) {SV; TOPOFSTACK = fn(POP_TOS_1, TOPOFSTACK, ufn_2); nextop1;}E 3D 3#define LRSH8 {							\	TOPOFSTACK = op_lrsh8(TOPOFSTACK);			\	nextop1;						\lrsh8_err:							\	asm("lrsh8_err:");					\	TOPOFSTACK = N_OP_lrsh8(TOPOFSTACK, ufn_1);		\	nextop1;						\	}	#define LRSH1 {							\	TOPOFSTACK = op_lrsh1(TOPOFSTACK);			\	nextop1;						\lrsh1_err:							\	asm("lrsh1_err:");					\	TOPOFSTACK = N_OP_lrsh1(TOPOFSTACK, ufn_1);		\	nextop1;						\	}E 3I 3#define UNBOX_ELSE(sour, dest, otherwise){			\	if (NSMALLP(sour))					\	    if (GetTypeNumber(sour) != TYPE_FIXP) otherwise;	\	    else dest = FIXP_VALUE(sour);			\	else dest = UNBOX_SMALLP(sour);}E 3D 3#define LLSH8 {							\	TOPOFSTACK = op_llsh8(TOPOFSTACK);			\	nextop1;						\llsh8_err:							\	asm("llsh8_err:");					\	TOPOFSTACK = N_OP_llsh8(TOPOFSTACK, ufn_1);		\	nextop1;						\	}E 3I 3#define UNBOX_ELSE_UFN(sour, dest) UNBOX_ELSE(sour, dest, goto op_ufn);E 3D 3#define LLSH1 {							\	TOPOFSTACK = op_llsh1(TOPOFSTACK);			\	nextop1;						\llsh1_err:							\	asm("llsh1_err:");					\	TOPOFSTACK = N_OP_llsh1(TOPOFSTACK, ufn_1);		\	nextop1;						\	}E 3I 3#define BOX_INTO(result, dest){					\	if (NSMALLP_RANGE(result))/* dest = box_fixp(result);*/	\		{register LispPTR *wordp; 			\		wordp = (LispPTR *) createcell68k(TYPE_FIXP);	\		*((int *)wordp) = result;			\		dest = (LADDR_from_68k(wordp));	}		\	else dest = (( (unsigned)result <<15) >>15) | S_POSITIVE;}E 3D 3#define ADDBASE {						\	TOPOFSTACK = addbase(POP_TOS_1, TOPOFSTACK);		\	nextop1;						\	}E 3I 3#define ARITH_OP(op, exceptions, handler) 			\	{register int arg1, arg2, result;			\	arg1 = GET_TOS_1;		 /* w/o side effect */	\	if(!NSMALLP(TOPOFSTACK) && !NSMALLP(arg1)) {		\		arg2 = UNBOX_SMALLP(TOPOFSTACK);		\		arg1 = UNBOX_SMALLP(arg1);			\		result = arg1 op arg2;				\		BOX_INTO(result, TOPOFSTACK);			\		POP_TOS_1;					\		nextop1;}					\D 5	HARD_CASE(handler); }E 5I 5	N_OP_CALL_2(handler); }E 5E 3D 3#define LOLOC	{ TOPOFSTACK = loloc(TOPOFSTACK); nextop1; }#define HILOC	{ TOPOFSTACK = hiloc(TOPOFSTACK); nextop1; }#define VAG2	{ TOPOFSTACK = vag2(POP_TOS_1, TOPOFSTACK); nextop1; }E 3I 3#define BINARY_OP(exp, exceptions) {				\	register int arg1, arg2, result;			\	arg1 = GET_TOS_1;		 /* w/o side effect */	\	UNBOX_ELSE_UFN(TOPOFSTACK, arg2);			\	UNBOX_ELSE_UFN(arg1, arg1);				\	result = exp;						\	if (exceptions) goto op_ufn;				\	BOX_INTO(result, TOPOFSTACK);				\	POP_TOS_1; nextop1;}E 3D 3#define LISTP	{ TOPOFSTACK = listp(TOPOFSTACK); nextop1;}#define NTYPEX	{ TOPOFSTACK = ntypex(TOPOFSTACK); nextop1; }#define TYPEP	{ TOPOFSTACK = typep(TOPOFSTACK, Get_BYTE(PCMAC+1)); nextop2; }E 3I 3#undef GREATERP #undef IGREATERPE 3I 3#define GREATERP {						\	register int arg1, arg2, result;			\	arg1 = GET_TOS_1;		 /* w/o side effect */	\	UNBOX_ELSE_UFN(TOPOFSTACK, arg2);			\	UNBOX_ELSE_UFN(arg1, arg1);				\	TOPOFSTACK = (arg1>arg2? ATOM_T : NIL_PTR);		\	POP_TOS_1; nextop1;}E 3D 3*/E 3I 3#define IGREATERP {						\	register int arg1, arg2, result;			\	arg1 = GET_TOS_1;		 /* w/o side effect */	\	UNBOX_ELSE_UFN(TOPOFSTACK, arg2);			\	UNBOX_ELSE_UFN(arg1, arg1);				\	TOPOFSTACK = (arg1>arg2? ATOM_T : NIL_PTR);		\	POP_TOS_1; nextop1;}#define OVERFLOW(a,b,r) (   (int)((r^a) & (a^~b))    < 0)#define SOVERFLOW(a,b,r) (   (int)((r^a) & (a^b))    < 0)/* overflow is ((arg1>0) == (arg2>0)) && ((result>0) != (arg1>0)) */ #undef IPLUS2#undef PLUS2#define	IPLUS2		ARITH_OP(+, OVERFLOW(arg1,arg2,result), N_OP_iplus2)#define	PLUS2		ARITH_OP(+, OVERFLOW(arg1,arg2,result), N_OP_plus2)#undef IDIFFERENCE #undef DIFFERENCE #define	IDIFFERENCE	ARITH_OP(-, SOVERFLOW(arg1,arg2,result), N_OP_idifference)#define	DIFFERENCE	ARITH_OP(-, SOVERFLOW(arg1,arg2,result), N_OP_difference)#undef LOGOR#undef LOGAND#undef LOGXOR#define LOGOR		BINARY_OP(arg1 | arg2, 0)#define LOGAND		BINARY_OP(arg1 & arg2, 0)#define LOGXOR		BINARY_OP(arg1 ^ arg2, 0)#define UNARY_OP(exp, exceptions) {				\	register int arg, result; 						\	UNBOX_ELSE_UFN(TOPOFSTACK, arg);			\	result = exp;						\	if (exceptions) goto op_ufn;				\	BOX_INTO(result, TOPOFSTACK);				\	nextop1;}#undef LRSH8#undef LRSH1#define LRSH8	UNARY_OP((unsigned)arg >> 8, 0)#define LRSH1	UNARY_OP((unsigned)arg >> 1, 0)#undef LLSH8#undef LLSH1 #define LLSH8	UNARY_OP(arg << 8, ((arg >> 24)!=0))#define LLSH1	UNARY_OP(arg << 1, (arg < 0))#undef ADDBASE#define ADDBASE {						\	register int arg1, arg2;				\	UNBOX_ELSE_UFN(TOPOFSTACK, arg2);			\	TOPOFSTACK = POP_TOS_1 + arg2;				\	nextop1;}I 6#undef SWAP_WORDS#define SWAP_WORDS(x) swapx(x)E 6E 3E 1