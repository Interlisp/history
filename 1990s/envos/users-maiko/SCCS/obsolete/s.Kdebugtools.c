h09961s 00000/00000/00607d D 2.10 90/04/19 22:45:35 sybalsky 15 14c AIX:  OBSOLETED.  replaced with debugtools.ces 00001/00001/00606d D 2.9 90/02/06 11:44:04 sybalsky 14 13c Stack-display cleanup, byte-swap fixeses 00075/00073/00532d D 2.8 89/12/29 12:56:19 sybalsky 13 12c Changes from Savoires 00064/00028/00541d D 2.7 89/12/28 15:22:24 sybalsky 12 11c cleanup codees 00000/00000/00569d D 2.6 89/03/30 13:03:42 sybalsky 11 10c Changed string print code & c to use byte-swapped macroses 00116/00090/00453d D 2.5 89/03/23 12:53:34 sybalsky 10 9c Byte-order shifting, for 386es 00045/00053/00498d D 2.4 89/01/10 13:34:19 shih 9 8c spellinges 00022/00003/00529d D 2.3 88/10/26 17:07:05 shimizu 8 7c FIX AR10914es 00011/00003/00521d D 2.2 88/07/07 11:04:06 shimizu 7 6c Can quit from print loop by ESC + RETURNes 00000/00000/00524d D 2.1 88/05/17 09:21:13 hayata 6 5c Version up to 2.1es 00054/00042/00470d D 1.5 88/05/08 10:32:33 shimizu 5 4c for URaid modifyes 00025/00051/00487d D 1.4 88/05/05 10:52:11 shimizu 4 3c First modify for URAIDes 00002/00002/00536d D 1.3 88/03/13 14:30:17 hayata 3 2c Add SCCS key id (%Z%)es 00003/00003/00535d D 1.2 88/03/03 11:32:31 krivacic 2 1c Removed global CurrentFX to use CURRENTFX = PVAR - FRAMESIZEes 00538/00000/00000d D 1.1 88/02/24 16:55:22 hayata 1 0c date and time created 88/02/24 16:55:22 by hayataeuUtTI 1D 3/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 3I 3D 9/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 9I 9D 13/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 9static char *id = "%Z% %M%	%I% %G%";E 13I 13/* @(#) Kdebugtools.c Version 2.6 (3/30/89). copyright envos & Fuji Xerox  */static char *id = "@(#) Kdebugtools.c	2.6 3/30/89";E 13E 3D 12/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. */E 12I 12/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 12/***************************************************************//*	file name :	 Kdebugtools.c	For Debugging Aids	Including :		get_ivar_name(fx_addr68k , offset)		date :   25 Aug 1987	NMitani		changed: 09 Sep 1987 NMitani*//***************************************************************/D 5E 5I 5#include <stdio.h>I 7#include  <setjmp.h>E 7E 5#include "lispemul.h"#include "lispmap.h"#include "address68k.h"#include "lisptypes.h"#include "lispglobal.h"#include "emulglobal.h"#include "cell.h"#include "stack.h"#define	LOCAL_PVAR	0xFFFF#define	VTY_IVAR	0x0000#define	VTY_PVAR	0x8000D 9#define VTY_FVAR	0xC000	E 9I 9#define VTY_FVAR	0xC000E 9D 4E 4I 4D 14#define URMAXFXNUM		100E 14I 14#define URMAXFXNUM		2000E 14#define URSCAN_ALINK		0#define URSCAN_CLINK		1D 5int URaid_scanlink= URSCAN_ALINK;int URaid_currentFX;FX *URaid_FXarray[URMAXFXNUM];int URaid_ArrMAXIndex;E 5I 5extern int URaid_scanlink;extern int URaid_currentFX;extern FX *URaid_FXarray[];extern int URaid_ArrMAXIndex;int BT_lines;D 7#define BTMAXLINE 40#define BT_morep	if(++BT_lines>BTMAXLINE){\			 printf("Press Return:"); getchar();fflush(stdin);BT_lines=0;}E 7I 7int BT_temp;jmp_buf BT_jumpbuf;#define BTMAXLINE 30#define BT_morep if(++BT_lines>BTMAXLINE){\			 printf("Press Return(to quit Esc and Ret):");\			 BT_temp=getchar();\			 fflush(stdin);\			 BT_lines=0; \			 if(BT_temp==27)longjmp(BT_jumpbuf,1) ; \		}E 7I 12E 12E 5E 4/***************************************************************//*	Func Name :	get_ivar_name	Desc :		returns atom index of ivar on the given			FX.			If ivar is localvars then set *localivar			1 otherwize 0.D 9	Changed 	25 Aug 1987	NMitaniE 9I 9	Changed		25 Aug 1987	NMitaniE 9*//***************************************************************/I 12E 12LispPTR get_ivar_name(fx_addr68k , offset , localivar)  struct frameex1 *fx_addr68k ;  DLword offset ;  int *localivar ;D 13{	DLword		*first_table;	DLword		*second_table;	struct fnhead	*fnobj;	int		i;E 13I 13  {    DLword		*first_table;    DLword		*second_table;    struct fnhead	*fnobj;    int		i;E 13D 9	E 9I 9E 9D 13	fnobj = (struct fnhead *)Addr68k_from_LADDR(E 13I 13    fnobj = (struct fnhead *)Addr68k_from_LADDR(E 13D 10		((int)fx_addr68k->hi2fnheader << 16) | fx_addr68k->lofnheader);E 10I 10		((int)(fx_addr68k)->hi2fnheader << 16) | (fx_addr68k)->lofnheader);E 10D 13	if (fnobj->ntsize > 0){		/* name table exist */		first_table = (DLword *)(fnobj + 1);		second_table = first_table + fnobj->ntsize;D 10		for(i = 0; (i < fnobj->ntsize) && (*second_table != offset) ;E 10I 10		for(i = 0; (i < fnobj->ntsize) && (GETWORD(second_table) != offset) ;E 10		first_table++ , second_table++ , i++) ;D 10		if ((i < fnobj->ntsize) && (*first_table != 0)){E 10I 10		if ((i < fnobj->ntsize) && (GETWORD(first_table) != 0)){E 10			/* target ivar was in name table */			*localivar = 0 ;D 10			return((LispPTR)(*first_table));E 10I 10			return((LispPTR)(GETWORD(first_table)));E 10		}		else{			/* target ivar is in locar vars table */D 9			first_table = (DLword *)(fnobj + 1) + E 9I 9			first_table = (DLword *)(fnobj + 1) +E 9					(fnobj->ntsize << 1);D 9			second_table = first_table + (((DLword *)fnobj + E 9I 9			second_table = first_table + (((DLword *)fnobj +E 13I 13    if (fnobj->ntsize > 0)      {	/* name table exists */	first_table = (DLword *)(fnobj + 1);	second_table = first_table + fnobj->ntsize;	for(i = 0; (i < fnobj->ntsize) && (GETWORD(second_table) != offset) ;	first_table++ , second_table++ , i++) ;	if ((i < fnobj->ntsize) && (GETWORD(first_table) != 0))	  {	    /* target ivar was in name table */	    *localivar = 0 ;	    return((LispPTR)(GETWORD(first_table)));	  }	else	  {	    /* Target ivar is in locar vars table */	    first_table = (DLword *)(fnobj + 1) + (fnobj->ntsize << 1);	    second_table = first_table + (((DLword *)fnobj +E 13E 9				(fnobj->startpc >> 1) - first_table) >> 1);D 13		}	}	else{		/* name table not exsit, so all ivars are in locar vars table */		first_table = (DLword *)(fnobj + 1) +  4;D 9		second_table = first_table + E 9I 9		second_table = first_table +E 9		(((DLword *)fnobj + (fnobj->startpc >> 1) - first_table) >> 1);	}D 10	while (*second_table != (VTY_IVAR |offset)){E 10I 10	while (GETWORD(second_table) != (VTY_IVAR |offset)){E 10		first_table++ ;		second_table++ ;	}	*localivar = 1 ;D 10	return((LispPTR)(*first_table));E 10I 10	return((LispPTR)(GETWORD(first_table)));E 13I 13	  }      }    else      {	/* name table doesn't exist, so all ivars are in locar vars table */	first_table = (DLword *)(fnobj + 1) +  4;	second_table = first_table +	(((DLword *)fnobj + (fnobj->startpc >> 1) - first_table) >> 1);      }    while (GETWORD(second_table) != (VTY_IVAR |offset))      {	first_table++ ;	second_table++ ;      }    *localivar = 1 ;    return((LispPTR)(GETWORD(first_table)));E 13E 10D 9	E 9I 9E 9D 13}/* end get_ivar_name */E 13I 13 }/* end get_ivar_name */E 13I 10E 10/***************************************************************//*	Func Name :	get_pvar_name	Desc :		returns atom index of pvar on the given			FX or LOCAL_PVAR if that pvar is localvars.D 9	Changed 	26 Aug 1987	NMitaniE 9I 9	Changed		26 Aug 1987	NMitaniE 9*//***************************************************************/I 12E 12LispPTR get_pvar_name(fx_addr68k , offset)  struct frameex1 *fx_addr68k ;  DLword offset ;D 13{	DLword		*first_table;	DLword		*second_table;	struct fnhead	*fnobj;	int		i;E 13I 13  {    DLword		*first_table;    DLword		*second_table;    struct fnhead	*fnobj;    int		i;E 13D 9	E 9I 9E 9D 13	fnobj = (struct fnhead *)Addr68k_from_LADDR(D 10		((int)fx_addr68k->hi2fnheader << 16) | fx_addr68k->lofnheader);E 10I 10		((int)(fx_addr68k)->hi2fnheader << 16) | (fx_addr68k)->lofnheader);E 13I 13    fnobj = (struct fnhead *)Addr68k_from_LADDR(	     ((int)(fx_addr68k)->hi2fnheader << 16) | (fx_addr68k)->lofnheader);E 13E 10D 13	first_table = (DLword *)(fnobj + 1);	second_table = first_table + fnobj->ntsize;D 10	if (first_table == second_table)	/* name table not exitst */E 10I 10	if (first_table == second_table)	/* name table not exist */E 10		return(LOCAL_PVAR);E 13I 13    first_table = (DLword *)(fnobj + 1);    second_table = first_table + fnobj->ntsize;    if (first_table == second_table) return(LOCAL_PVAR);  /* no name table */E 13D 9	for(i = 0; i < fnobj->ntsize && *second_table != (VTY_PVAR | offset); 		first_table++ , second_table++ , i++) E 9I 9D 10	for(i = 0; i < fnobj->ntsize && *second_table != (VTY_PVAR | offset);E 10I 10D 13	for(i = 0; i < fnobj->ntsize && GETWORD(second_table) != (VTY_PVAR | offset);E 10		first_table++ , second_table++ , i++)E 9		;E 13I 13    for(i = 0;        i < fnobj->ntsize && GETWORD(second_table) != (VTY_PVAR | offset);	first_table++ , second_table++ , i++) /* Do nothing */;E 13D 13	if (i < fnobj->ntsize)D 10		return((LispPTR)(*first_table));E 10I 10		return((LispPTR)GETWORD(first_table));E 10	else		return(LOCAL_PVAR);	/* Pvar was local */}/* end get_pvar_name */E 13I 13    if (i < fnobj->ntsize) return((LispPTR)GETWORD(first_table));    else return(LOCAL_PVAR);	/* Pvar was local */  }/* end get_pvar_name */E 13I 10E 10/***************************************************************//*	Func Name :	get_fvar_name	Desc :		returns atom index of fvar on the given			FX.D 9	Changed 	26 Aug 1987	NMitaniE 9I 9	Changed		26 Aug 1987	NMitaniE 9*//***************************************************************/I 12E 12LispPTR get_fvar_name(fx_addr68k , offset)  struct frameex1 *fx_addr68k ;  DLword offset ;D 13{	DLword		*first_table;	DLword		*second_table;	struct fnhead	*fnobj;E 13I 13  {    DLword		*first_table;    DLword		*second_table;    struct fnhead	*fnobj;E 13D 9	E 9I 9E 9D 13	fnobj = (struct fnhead *)Addr68k_from_LADDR(D 10		((int)fx_addr68k->hi2fnheader << 16) | fx_addr68k->lofnheader);E 10I 10		((int)(fx_addr68k)->hi2fnheader << 16) | (fx_addr68k)->lofnheader);E 13I 13    fnobj = (struct fnhead *)Addr68k_from_LADDR(	    ((int)(fx_addr68k)->hi2fnheader << 16) | (fx_addr68k)->lofnheader);E 13E 10D 13	first_table = (DLword *)fnobj + fnobj->fvaroffset;	second_table = first_table + fnobj->ntsize;E 13I 13    first_table = (DLword *)fnobj + fnobj->fvaroffset;    second_table = first_table + fnobj->ntsize;E 13D 9	while (*second_table != (VTY_FVAR | offset)){ E 9I 9D 10	while (*second_table != (VTY_FVAR | offset)){E 10I 10D 13	while (GETWORD(second_table) != (VTY_FVAR | offset)){E 10E 9		first_table++ ;D 9		second_table++; E 9I 9		second_table++;E 9	}E 13I 13    while (GETWORD(second_table) != (VTY_FVAR | offset))      {	first_table++ ;	second_table++;      }E 13D 10	return((LispPTR)(*first_table));E 10I 10D 13	return((LispPTR)GETWORD(first_table));E 13I 13    return((LispPTR)GETWORD(first_table));E 13E 10D 13}/* end get_fvar_name */E 13I 13  }/* end get_fvar_name */E 13D 12/***************************************************************//*	Func Name :	sfE 12D 12	Desc :		dumps the stack frame.E 12D 9	Changed 	26 Aug 1987	NMitaniE 9I 9D 12	Changed		26 Aug 1987	NMitaniE 12E 9D 12*//***************************************************************/E 12I 12/************************************************************************//*									*//*				s f					*//*									*//*	Dump the contents of a single frame, given the address of 	*//*	the frame as a NATIVE address.					*//*									*//*									*//*									*//************************************************************************/E 12sf(fx_addr68k)  struct frameex1 *fx_addr68k ;{  Bframe *bf;  DLword *next68k ;  DLword *ptr ;  DLword *ptrhi ;  DLword *ptrlo ;  LispPTR atomindex ;  int i;  DLword npvar;  DLword max_npvar;  LispPTR pvarindex ;  DLword nfvar;  struct fnhead	*fnobj;  int localivar;  LispPTR ivarindex ;I 5  BT_lines=0;I 8 if((int)fx_addr68k == 0) return(-1);D 10 if(fx_addr68k->flags != STK_FX){	printf("Invalid FX 0x%x\n",LADDR_from_68k(fx_addr68k));E 10I 10 if((fx_addr68k)->flags != STK_FX){	printf("Invalid FX 0x%x, flags = 0x%x.\n",		LADDR_from_68k(fx_addr68k),		(fx_addr68k)->flags);E 10	return(-1); }E 8E 5D 10 if((fx_addr68k->alink & 1)==0)E 10I 10 if(((fx_addr68k)->alink & 1)==0)E 10  {   /* FAST */D 9 	bf = (Bframe *)(((DLword *)fx_addr68k)  - 2 );  E 9I 9	bf = (Bframe *)(((DLword *)fx_addr68k)  - 2 );E 9  }  else  {   /* SLOW */D 10	bf =(Bframe *) Addr68k_from_LADDR((fx_addr68k->blink+ STK_OFFSET)) ;E 10I 10	bf =(Bframe *) Addr68k_from_LADDR(((fx_addr68k)->blink+ STK_OFFSET)) ;E 10  }/* Print IVARs */D 5  printf("IVAR -------\n");E 5I 5  printf("IVAR -------\n");BT_morep;E 5  ptr = Addr68k_from_LADDR( STK_OFFSET + bf->ivar); i=0; while(ptr!=(DLword *)bf){  ptrhi = ptr;  ptrlo = ptr + 1 ;D 10  printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr), *ptr , *ptrlo);E 10I 10  printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr), GETWORD(ptr) , GETWORD(ptrlo));E 10  ivarindex = get_ivar_name(fx_addr68k , i++ , &localivar);  if (localivar == 1)	printf("*local* ");  print_atomname(ivarindex);  printf("  ");  print(*(LispPTR *)ptr);D 5  putchar('\n');E 5I 5  putchar('\n');BT_morep;E 5  ptr += 2 ;}D 5 putchar('\n'); printf("## STACK BF at 0x%x ## \n",(LispPTR)LADDR_from_68k(bf));E 5I 5 putchar('\n');BT_morep;D 9 printf("## STACK BF at 0x%x ## \n",(LispPTR)LADDR_from_68k(bf));BT_morep;E 9I 9 printf("## STACK BF at 0x%x ##\n",(LispPTR)LADDR_from_68k(bf));BT_morep;E 9E 5/* print BF  */ if(bf->flags != 4)D 5	printf("Invalid frame,NOT BX \n");E 5I 5D 8	printf("Invalid frame,NOT BX \n");BT_morep;E 8I 8D 9	{printf("Invalid frame,NOT BX \n");return(-1);}E 9I 9D 13	{printf("Invalid frame, NOT BX\n");return(-1);}E 13I 13	{printf("Invalid frame, NOT a BX\n");return(-1);}E 13E 9E 8E 5 putchar('[');  if (bf->residual)	printf("Res, ");  if (bf->padding)	printf("Pad, ");D 5  printf("cnt=%d ]\n",bf->usecnt);  printf("ivar : 0x%x \n",bf->ivar);E 5I 5  printf("cnt=%d ]\n",bf->usecnt);BT_morep;D 9  printf("ivar : 0x%x \n",bf->ivar);BT_morep;E 9I 9  printf("ivar : 0x%x\n",bf->ivar);BT_morep;E 9E 5D 5    printf(">> Bf's ivar says 0x%x vs. IVar says 0x%x \n",bf->ivar+STK_OFFSET,LADDR_from_68k(IVar));E 5I 5D 9    printf(">> Bf's ivar says 0x%x vs. IVar says 0x%x \n",bf->ivar+STK_OFFSET,LADDR_from_68k(IVar));BT_morep;E 9I 9    printf(">> Bf's ivar says 0x%x vs. IVar says 0x%x\n",bf->ivar+STK_OFFSET,LADDR_from_68k(IVar));BT_morep;E 9E 5  atomindex = get_framename(fx_addr68k);  printf("Fname is ");  print_atomname(atomindex);D 5  printf("\n");E 5I 5  printf("\n");BT_morep;E 5/***** printout FX ****/D 5  printf("## STACK FX at 0x%x ## \n",LADDR_from_68k(fx_addr68k));E 5I 5D 9  printf("## STACK FX at 0x%x ## \n",LADDR_from_68k(fx_addr68k));BT_morep;E 9I 9  printf("## STACK FX at 0x%x ##\n",LADDR_from_68k(fx_addr68k));BT_morep;E 9E 5D 10  if(fx_addr68k->flags != 6)E 10I 10  if((fx_addr68k)->flags != 6)E 10D 5    printf("Invalid frame,NOT FX \n");E 5I 5D 8    printf("Invalid frame,NOT FX \n");BT_morep;E 8I 8D 9   { printf("Invalid frame,NOT FX \n");return(-1);}E 9I 9   { printf("Invalid frame, NOT FX\n");return(-1);}E 9E 8E 5 putchar('[');D 9  if(fx_addr68k->fast)		printf("F,");E 9I 9D 10  if(fx_addr68k->fast)		printf("F, ");E 9  if(fx_addr68k->incall)	printf("incall, ");E 10I 10  if((fx_addr68k)->fast)		printf("F, ");  if((fx_addr68k)->incall)	printf("incall, ");E 10  if(fx_addr68k->validnametable)	printf("V, ");D 5  printf("cnt = %d ]\n",fx_addr68k->usecount);E 5I 5  printf("cnt = %d ]\n",fx_addr68k->usecount);BT_morep;E 5  printf(" #alink           0x%x ",fx_addr68k->alink);  if(fx_addr68k->alink & 1)D 9  printf("[SLOWP] \n");E 9I 9  printf("[SLOWP]\n");E 9  else printf("\n");D 5  printf(" fnheadlo         0x%x \n",fx_addr68k->lofnheader);  printf(" hi1,hi2 fnhead   0x%x , 0x%x \n",fx_addr68k->hi1fnheader,fx_addr68k->hi2fnheader);  printf(" nextblock        0x%x \n",fx_addr68k->nextblock);  printf(" pc               0x%x \n",fx_addr68k->pc);  printf(" lonametbl        0x%x \n",fx_addr68k->lonametable);  printf(" hi1,hi2 nametbl  0x%x , 0x%x  \n",fx_addr68k->hi1nametable,fx_addr68k->hi2nametable);  printf(" #blink           0x%x \n",fx_addr68k->blink);  printf(" #clink           0x%x \n",fx_addr68k->clink);E 5I 5 BT_morep;E 5I 5  printf(" fnheadlo         0x%x \n",fx_addr68k->lofnheader);BT_morep;  printf(" hi1,hi2 fnhead   0x%x , 0x%x \n",fx_addr68k->hi1fnheader,fx_addr68k->hi2fnheader);BT_morep;  printf(" nextblock        0x%x \n",fx_addr68k->nextblock);BT_morep;  printf(" pc               0x%x \n",fx_addr68k->pc);BT_morep;  printf(" lonametbl        0x%x \n",fx_addr68k->lonametable);BT_morep;  printf(" hi1,hi2 nametbl  0x%x , 0x%x  \n",fx_addr68k->hi1nametable,fx_addr68k->hi2nametable);BT_morep;  printf(" #blink           0x%x \n",fx_addr68k->blink);BT_morep;  printf(" #clink           0x%x \n",fx_addr68k->clink);BT_morep;E 5/* added by NMitani 26 Aug 87 */ fnobj = (struct fnhead *)Addr68k_from_LADDR(		((int)fx_addr68k->hi2fnheader << 16) | fx_addr68k->lofnheader); max_npvar = npvar = fnobj->nlocals;	/* npvar is number of Pvars */ if (fnobj->fvaroffset)D 10  nfvar = *((DLword *)fnobj + fnobj->fvaroffset + fnobj->ntsize) & 0xFF;E 10I 10  nfvar = GETWORD((DLword *)fnobj + fnobj->fvaroffset + fnobj->ntsize) & 0xFF;E 10 else  nfvar = 0;D 2 if (fx_addr68k ==CurrentFX) {E 2I 2 if (fx_addr68k == CURRENTFX) {E 2D 9 	ptr=PVar;E 9I 9	ptr=PVar;E 9	i = 0;	while(npvar-- > 0){		ptrhi = ptr;		ptrlo = ptr + 1 ;D 9		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),*ptrhi , E 9I 9D 10		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),*ptrhi ,E 9			*ptrlo);E 10I 10		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,			GETWORD(ptrlo));E 10		if ((pvarindex = get_pvar_name(fx_addr68k , i++)) == LOCAL_PVAR)			printf("*local* [pvar%d] " , (i - 1));		else			print_atomname(pvarindex);D 10		if (*ptr == 0xFFFF){E 10I 10		if (GETWORD(ptr) == 0xFFFF){E 10D 5			printf("  [variable not bound]\n");E 5I 5			printf("  [variable not bound]\n");BT_morep;E 5		}		else{			printf("  ");			print(*(LispPTR *)ptr);D 5			putchar('\n');			E 5I 5D 9			putchar('\n');		BT_morep;	E 9I 9			putchar('\n');		BT_morep;E 9E 5		}		ptr += 2 ;	}	i = max_npvar;	while(nfvar && nfvar-- >= max_npvar){		ptrhi = ptr;		ptrlo = ptr + 1 ;D 9		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),*ptrhi , E 9I 9D 10		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),*ptrhi ,E 9			*ptrlo);		if (0xFFFF == *ptrhi){E 10I 10		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,			GETWORD(ptrlo));		if (0xFFFF == GETWORD(ptrhi)){E 10			printf("[not looked up]  ");			print_atomname(get_fvar_name(fx_addr68k , i));D 5			putchar('\n');E 5I 5			putchar('\n');BT_morep;E 5		}D 10		else if ((0xFFFF & *ptrlo) == 1){E 10I 10		else if ((0xFFFF & GETWORD(ptrlo)) == 1){E 10			printf("[fvar  ");			print_atomname(get_fvar_name(fx_addr68k , i));			printf("  on stack]  ");D 10			print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & *ptrlo) << 16) | *ptrhi)));E 10I 10			print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & GETWORD(ptrlo)) << 16) | GETWORD(ptrhi))));E 10D 5			putchar('\n');E 5I 5			putchar('\n');BT_morep;E 5		}		else{			printf("[fvar  ");			print_atomname(get_fvar_name(fx_addr68k , i));			printf("  top value ]   ");D 10			print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & *ptrlo) << 16) | *ptrhi)));E 10I 10			print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & GETWORD(ptrlo)) << 16) | GETWORD(ptrhi))));E 10D 5			putchar('\n');E 5I 5			putchar('\n');BT_morep;E 5		}		ptr += 2 ;		i++;	}	if (fx_addr68k->alink == 11)  /* for contextsw */		next68k = (DLword *)Addr68k_from_LADDR((fx_addr68k->nextblock+STK_OFFSET)) ;	else		next68k = CurrentStackPTR;	while(ptr < next68k)	{		ptrhi = ptr;		ptrlo = ptr + 1 ;D 9		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),*ptrhi , 			*ptrlo);		E 9I 9D 10		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),*ptrhi ,			*ptrlo);E 10I 10		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,			GETWORD(ptrlo));E 10E 9		print(*(LispPTR *)ptr);		ptr += 2 ;D 5		putchar('\n');E 5I 5		putchar('\n');BT_morep;E 5	}D 5  printf("this frame is last !! \n");E 5I 5D 9  printf("this frame is last !! \n");BT_morep;E 9I 9  printf("this frame is last !!\n");BT_morep;E 9E 5  return(-1); } next68k = (DLword *)Addr68k_from_LADDR((fx_addr68k->nextblock+STK_OFFSET)) ; ptr =(DLword *)(fx_addr68k+1) ; i = 0; while(npvar-- > 0){		ptrhi = ptr;		ptrlo = ptr + 1 ;D 9		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),*ptrhi , E 9I 9D 10		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),*ptrhi ,E 9			*ptrlo);E 10I 10		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,			GETWORD(ptrlo));E 10		if ((pvarindex = get_pvar_name(fx_addr68k , i++)) == LOCAL_PVAR)			printf("*local* [pvar%d] " , (i - 1));		else			print_atomname(pvarindex);D 10		if (*ptr == 0xFFFF){E 10I 10		if (GETWORD(ptr) == 0xFFFF){E 10D 5			printf("  [variable not bound]\n");E 5I 5			printf("  [variable not bound]\n");BT_morep;E 5		}		else{			printf("  ");			print(*(LispPTR *)ptr);D 5			putchar('\n');			E 5I 5D 9			putchar('\n');		BT_morep;	E 9I 9			putchar('\n');		BT_morep;E 9E 5		}		ptr += 2 ;	} i = max_npvar;	while(nfvar && nfvar-- >= max_npvar){		ptrhi = ptr;		ptrlo = ptr + 1 ;D 9		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),*ptrhi , E 9I 9D 10		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),*ptrhi ,E 9			*ptrlo);		if (0xFFFF == *ptrhi){E 10I 10		printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptrhi) ,			GETWORD(ptrlo));		if (0xFFFF == GETWORD(ptrhi)){E 10			printf("[not looked up]  ");			print_atomname(get_fvar_name(fx_addr68k , i));D 5			putchar('\n');E 5I 5			putchar('\n');BT_morep;E 5		}D 10		else if ((0xFFFF & *ptrlo) == 1){E 10I 10		else if ((0xFFFF & GETWORD(ptrlo)) == 1){E 10			printf("[fvar  ");			print_atomname(get_fvar_name(fx_addr68k , i));			printf("  on stack]  ");D 10			print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & *ptrlo) << 16) | *ptrhi)));E 10I 10			print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & GETWORD(ptrlo)) << 16) | GETWORD(ptrhi))));E 10D 5			putchar('\n');E 5I 5			putchar('\n');BT_morep;E 5		}		else{			printf("[fvar  ");			print_atomname(get_fvar_name(fx_addr68k , i));			printf("  top value ]   ");D 10			print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & *ptrlo) << 16) | *ptrhi)));E 10I 10			print(*(LispPTR *)(Addr68k_from_LADDR(((int)(0x0F & GETWORD(ptrlo)) << 16) | GETWORD(ptrhi))));E 10D 5			putchar('\n');E 5I 5			putchar('\n');BT_morep;E 5		}		ptr += 2 ;		i++;	} while(next68k > ptr)  {D 9	printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),*ptr++ , E 9I 9D 10	printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),*ptr++ ,E 9		*ptr++);E 10I 10	printf(" %6x : 0x%4x  0x%4x  ",LADDR_from_68k(ptr),GETWORD(ptr++) ,		GETWORD(ptr++));E 10D 5	putchar('\n');E 5I 5	putchar('\n');BT_morep;E 5  }return (0);D 9} E 9I 9}E 9D 12/***************************************************************//*	Func Name :	btE 12D 12	Desc :		dumps the stack frame name.E 12D 9	Changed 	26 Aug 1987	NMitaniE 9I 9D 12	Changed		26 Aug 1987	NMitaniE 9I 4	Changed   May 4, 1988	Take(for URaid)E 12E 4D 12*//***************************************************************/E 12I 12/************************************************************************//*									*//*				b t					*//*									*//*	Print the names of the frames on the stack.  Equivalent to	*//*	the Lisp DEBUGGER's BT! command.				*//*									*//*		Changed		26 Aug 1987	NMitani			*//*		Changed   May 4, 1988	Take(for URaid)			*//*									*//************************************************************************/E 12bt()D 10{I 4  bt1(CURRENTFX);}E 10I 10  {    bt1(CURRENTFX);  }E 10bt1(startFX)D 10FX *startFX;{E 4	FX	*fx ;	struct fnhead	*fnobj;I 4	FX *get_nextFX();	int fnum=0;E 4D 5E 5I 5	BT_lines=0;E 5D 2	fx = CurrentFX ;E 2I 2D 4	fx = CURRENTFX ;E 4I 4	fx = startFX ;E 10I 10  FX *startFX;  {    FX	*fx ;    struct fnhead	*fnobj;    FX *get_nextFX();    int fnum=0;    BT_lines=0;    fx = startFX ;    URaid_FXarray[fnum]=fx;    printf("%3d : ",fnum++);    fnobj = (struct fnhead *)Addr68k_from_LADDR(    	((int)fx->hi2fnheader << 16) | fx->lofnheader);    printf("   0x%x : " , LADDR_from_68k(fx));    print_atomname(fnobj->framename);    putchar('\n');BT_morep;    while((fnobj->framename != ATOM_T) && (fx->alink != 11))      {	if(fnum >URMAXFXNUM-1)	  {	   /* Internal buf overflow,more than 100 stacks */	   printf("***There are more than 100 stack frames.\n");	   printf("If you want to continue, Uraid will smash its internal table for FX pointer. Do you accept?(Y or N)\n");	   {	     int c;	     c= getchar();fflush(stdin);	     if((c=='Y')||(c=='y'))	       {		 fnum=0;		 bzero(URaid_FXarray,URMAXFXNUM *4);	       }	     else goto bt1_exit;	    }	  }	fx= get_nextFX(fx);	fnobj = (struct fnhead *)Addr68k_from_LADDR(	((int)fx->hi2fnheader << 16) | fx->lofnheader);E 10	URaid_FXarray[fnum]=fx;	printf("%3d : ",fnum++);E 4E 2D 10	fnobj = (struct fnhead *)Addr68k_from_LADDR(		((int)fx->hi2fnheader << 16) | fx->lofnheader);E 10I 5	printf("   0x%x : " , LADDR_from_68k(fx));E 5	print_atomname(fnobj->framename);D 5	printf("   0x%x\n" , LADDR_from_68k(fx));E 5I 5D 10	 putchar('\n');BT_morep;E 5	while((fnobj->framename != ATOM_T) && (fx->alink != 11)){I 8		if(fnum >URMAXFXNUM-1){		 /* Internal buf overflow,more than 100 stacks */		 printf("***There are more than 100 stack frames.\n");D 9		 printf("If you want to continue,Uraid will smash its internal table for FX pointer. Do you accept?(Y or N)\n");E 9I 9		 printf("If you want to continue, Uraid will smash its internal table for FX pointer. Do you accept?(Y or N)\n");E 9		 {int c;			  c= getchar();fflush(stdin);			  if((c=='Y')||(c=='y')) {				fnum=0;				bzero(URaid_FXarray,URMAXFXNUM *4);			   }			  else goto bt1_exit;E 10I 10	putchar('\n');BT_morep;      }   if (fnobj->framename != ATOM_T)      {	printf(">>root frame for contextsw<<\n");	putchar('\n');BT_morep;      }E 10D 9			E 9I 9E 9D 10		}}E 8D 4		if(fx->alink & 1)			fx = (FX *)Addr68k_from_LADDR((fx->clink - 10) | 							STK_OFFSET);		else 			fx = (FX *)Addr68k_from_LADDR(((fx->alink & 0xFFFE)- 10)					| STK_OFFSET);E 4I 4		fx= get_nextFX(fx);E 4		fnobj = (struct fnhead *)Addr68k_from_LADDR(		((int)fx->hi2fnheader << 16) | fx->lofnheader);I 4		URaid_FXarray[fnum]=fx;		printf("%3d : ",fnum++);I 5		printf("   0x%x : " , LADDR_from_68k(fx));E 5E 4		print_atomname(fnobj->framename);D 5		printf("   0x%x\n" , LADDR_from_68k(fx));E 5I 5		putchar('\n');BT_morep;E 5	}D 5	if (fnobj->framename != ATOM_T)E 5I 5	if (fnobj->framename != ATOM_T){E 5		printf(">>root frame for contextsw<<\n");I 5		putchar('\n');BT_morep;}E 5I 4E 10D 8	URaid_ArrMAXIndex=fnum-1;E 8I 8bt1_exit: URaid_ArrMAXIndex=fnum-1;E 8	URaid_currentFX=0;E 4D 10}/* end bt */E 10I 10  }/* end bt */E 10/***************************************************************//*	Func Name :	btvv	Desc :		dumps the all stack frame name.D 9	Changed 	4 Sep 1987	NMitaniE 9I 9	Changed		4 Sep 1987	NMitaniE 9*//***************************************************************/I 12/************************************************************************//*									*//*				b t v v					*//*									*//*	Print all stack frames, with variables.  Equivalent to the	*//*	Lisp DEBUGGER's BTV! command.					*//*									*//*									*//*									*//************************************************************************/E 12btvv()D 9{  E 9I 9{E 9	struct frameex1 *fx_addr68k;	LispPTR atomindex ;D 4	struct frameex1 *get_nextFX();E 4I 4	FX *get_nextFX();E 4D 2	fx_addr68k = CurrentFX ;E 2I 2	fx_addr68k = CURRENTFX ;E 2	atomindex = get_framename(fx_addr68k);	while((atomindex != ATOM_T) && (fx_addr68k->alink != 11))	{		sf(fx_addr68k);		fx_addr68k= get_nextFX(fx_addr68k);		atomindex = get_framename(fx_addr68k);	}	sf(fx_addr68k);	printf("\n BTV! end ********\n");D 9		E 9I 9E 9} /*end btvv*/I 10E 10D 12/***************************************************************//*D 4	Func Name :	get_previous_FX	Desc :		returns 68k address of FX.	Changed 	27 Aug 1987	NMitani*//***************************************************************/struct frameex1 *get_previous_FX(fx_addr68k , useclink) struct frameex1 *fx_addr68k ; int useclink ;{	DLword	*pv ;	}/***************************************************************//*E 4	Func Name :	sffE 12I 12/************************************************************************//*									*//*				s f f					*//*									*//*	Given the address of a lisp stack frame-extension (FX)		*//*	as a LISP (not native!) address, print the stack frame.		*//*									*//*									*//*							NMitani		*//************************************************************************/E 12D 12	Desc :		dumps FX.D 9	Changed 	10 Sep 1987	NMitaniE 9I 9	Changed		10 Sep 1987	NMitaniE 9*//***************************************************************/E 12sff(laddr)D 10	LispPTR laddr;{	sf((FX *)Addr68k_from_LADDR(laddr));}/* end bt */E 10I 10  LispPTR laddr;  {    sf((FX *)Addr68k_from_LADDR(laddr));D 12  }/* end bt */E 12I 12  }E 12E 10D 4/***************************************************************//*	Func Name :	mtype_patch	Desc :		temporary patch file for MACHINETYPE	Changed 	11 Sep 1987	NMitani*//***************************************************************/mtype_patch(){	struct definition_cell *defcell68k;	int index , atom_index;	char	*base;	index = MAKEATOM("MACHINETYPE");	atom_index = MAKEATOM("KATANA");	defcell68k = (struct definition_cell *)GetDEFCELL68k(index) ;	base = (char *)Addr68k_from_LADDR(defcell68k->defpointer) ;	*(base + 073) = 0154 ;	/* sic */	*(base + 074) = 0 ;	/* dummy */	*(base + 076) = 0xFF & (atom_index >> 8);	*(base + 077) = 0xFF & atom_index ;	}E 4D 9					E 9E 1