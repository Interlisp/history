h51285s 00007/00000/00581d D 2.24 90/04/18 11:18:16 sybalsky 48 47c THIS IS NOW OBSOLETE; it now has an illegal preprocessor line in it to cause errors.es 00007/00007/00574d D 2.23 90/03/27 14:30:44 sybalsky 47 46c 386i optimization was too good, back offes 00002/00002/00579d D 2.22 90/03/22 16:35:56 sybalsky 46 45c add comments to OPFN; still some work to be done speeding it up.es 00015/00015/00566d D 2.21 90/03/22 10:45:46 sybalsky 45 44c Change Get_BYTE, Get_DLword to non-arg macros, for inline code.es 00002/00001/00579d D 2.20 89/03/30 13:00:35 sybalsky 44 43c Fixed word-pointer refs to use GETWORD, byte refs to use GETBYTE.es 00000/00000/00580d D 2.19 89/03/24 13:25:29 sybalsky 43 42c no changeses 00015/00005/00565d D 2.18 89/02/28 04:01:37 sybalsky 42 41c Changed ENVCALL so if env arg=NIL, doesn't get smashed into PVAR0es 00093/00095/00477d D 2.17 89/01/05 21:01:10 shih 41 40c restored sccs id, whitespace cleanupes 00001/00001/00571d D 2.16 88/12/01 13:49:15 krivacic 40 39c Add SUN3_OS4_IL & SUN3_OS3_OR_OS4_IL Flags, and move asm labels to inlines.es 00000/00001/00572d D 2.15 88/11/15 14:27:04 bane 39 38c removed native-code dependent label from non-NATIVECODE ifdefes 00058/00006/00515d D 2.14 88/10/13 19:30:01 krivacic 38 37c ifdef cleanuupes 00003/00001/00518d D 2.13 88/10/12 17:09:11 krivacic 37 36c add ifdef for asm labeles 00005/00000/00514d D 2.12 88/10/05 17:03:11 krivacic 36 35c sun 3 / 4 mergees 00030/00016/00484d D 2.11 88/09/16 14:39:28 bane 35 34c Adjusted PC changeses 00066/00009/00434d D 2.10 88/08/15 14:26:16 krivacic 34 33c asm fn call code & speedup of C versiones 00000/00027/00443d D 2.9 88/07/20 12:14:11 krivacic 33 32c SCCS fix of double lineses 00000/00001/00470d D 2.8 88/07/19 17:34:14 krivacic 32 31c extra LispPTR closure_env = (LispPTR) 0xffffffff;es 00030/00036/00413d D 2.7 88/07/19 16:43:38 krivacic 31 30c fix call to native codees 00028/00033/00416d D 2.6 88/07/12 15:03:22 shih 30 29c itty bit faster loops, no incr of nv (1 folded into tests)es 00003/00002/00446d D 2.5 88/06/15 15:21:57 krivacic 29 28c fix APPLY of Native Closure bug & unnecessary test in EVALes 00034/00009/00414d D 2.4 88/05/31 20:34:57 masinter 28 27c allow UFN to tail into OP_FN_COMMON, make fn_apply a case rather than a flages 00001/00001/00422d D 2.3 88/05/27 15:04:36 krivacic 27 26c change newframe reference to nnewframees 00061/00089/00362d D 2.2 88/05/24 18:19:42 krivacic 26 25c add EVAL macro, remove obsolete stack check macros, remove TRADSTACKOVERes 00000/00000/00451d D 2.1 88/05/17 09:19:33 hayata 25 24c Version up to 2.1es 00001/00001/00450d D 1.24 88/05/13 10:04:45 hayata 24 23c Add SCCS keyides 00003/00003/00448d D 1.23 88/05/12 12:45:01 shimizu 23 22c Commented out the redeclaration for fnerres 00080/00025/00371d D 1.22 88/05/10 19:41:10 krivacic 22 21c FN_STACK_CHECK1 & FN_STACK_CHECK2 -> FN_STACK_CHECKes 00007/00006/00389d D 1.21 88/05/06 13:44:20 krivacic 21 20c ENVCALL in and workinges 00076/00013/00319d D 1.20 88/05/04 20:40:48 krivacic 20 19c OP_ENVCALLes 00001/00001/00331d D 1.19 88/04/27 13:31:06 krivacic 19 18c NATIVE_NEXTOP0 in OP_apply()es 00002/00001/00330d D 1.18 88/04/26 21:50:23 krivacic 18 17c added CHECK_INTERRUPT on OP_apply calles 00003/00000/00328d D 1.17 88/04/26 16:43:06 krivacic 17 16c fix do_stackoverflow ?? for last time ?es 00022/00004/00306d D 1.16 88/04/22 19:21:38 krivacic 16 15c inlinedefs re-arrangement & ni removales 00031/00017/00279d D 1.15 88/04/21 18:10:36 krivacic 15 14c move where dostackover is calledes 00010/00009/00286d D 1.14 88/04/14 14:40:56 krivacic 14 13c APPLY fixes 00002/00003/00293d D 1.13 88/04/13 17:37:44 krivacic 13 12c Call ufn instead of error in applyes 00008/00001/00288d D 1.12 88/04/11 18:31:48 krivacic 12 11c TRADSTACKOVER def checkes 00016/00009/00273d D 1.11 88/04/08 17:21:58 krivacic 11 10c pc interfacees 00001/00001/00281d D 1.10 88/04/04 10:49:08 krivacic 10 9c es 00003/00003/00279d D 1.9 88/03/29 14:39:36 krivacic 9 8c fix stk overflow checkes 00031/00161/00251d D 1.8 88/03/28 11:56:46 krivacic 8 7c checkapply fix attemptes 00203/00118/00209d D 1.7 88/03/15 18:23:51 krivacic 7 6c Closure Call, Apply, & CheckApply to dispatch loopes 00001/00000/00326d D 1.6 88/03/13 14:18:59 hayata 6 5c Change SCCS key ides 00000/00000/00326d D 1.5 88/03/13 13:28:25 hayata 5 4c Add SCCS key id (%Z%)es 00038/00022/00288d D 1.4 88/03/08 18:38:47 krivacic 4 3c Register, re-ordiering, swap, Optimizationses 00009/00002/00301d D 1.3 88/03/04 11:02:27 krivacic 3 2c Fixed Native Interface FuncObjes 00051/00042/00252d D 1.2 88/03/03 11:43:28 krivacic 2 1c Removed global CurrentFX to use CURRENTFX = PVAR - FRAMESIZEes 00294/00000/00000d D 1.1 88/02/23 18:37:25 hayata 1 0c date and time created 88/02/23 18:37:25 by hayataeuUtTI 6D 10/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 10I 10D 16/* This is G-file @(#) tosfuncallmacro.h Version 1.9 (3/29/88). copyright Xerox & Fuji Xerox  */E 16I 16D 23/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 23I 23D 24/* This is G-file @(#) tosfuncallmacro.h Version 1.22 (5/10/88). copyright Xerox & Fuji Xerox  */E 24I 24D 35/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 35I 35D 41/* This is G-file @(#) tosfuncallmacro.h Version 2.10 (8/15/88). copyright Xerox & Fuji Xerox  */E 41I 41D 46/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 46I 46/* @(#) tosfuncallmacro.h Version 2.21 (3/22/90). copyright envos & Fuji Xerox  */I 48#illegal/*****************************************************************//*****************************************************************//*    OBSOLETE:  REPLACED BY TOSFUNCALL.H 4/17/90                *//*****************************************************************//*****************************************************************/E 48E 46E 41E 35E 24E 23E 16E 10E 6I 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 2/***D 16	funcallmacro.hE 16I 16	tosfuncallmacro.hE 16	By Takeshi	3-Dec-87D 7***/E 7D 8#define FNDEFCELL68K ((DefCell *)wordp)#define TMP_FNCELL68K ((struct fnhead *)cellp)#define APPLYSTKOVER_ATOM arg1#define APPLY_ARGNUM	arg2D 2#define CLOSUREFUNCP arg3E 2I 2#define CLOSUREFUNCP 	arg3E 2D 4#define RESTARGS	arg1E 4#define FNPV_NUM	resultE 8I 7***/E 7D 4#define NEXTBLOCK	arg2#define LOCFNCELL	((struct fnhead *) wordp)E 4I 16E 16I 15D 26#ifdef TRADSTACKOVERE 26D 41E 15I 2D 11#define  CFnStkOvr(argnum,bytenum) { \				CPushStack(S_POSITIVE | argnum); \				EXT;\				contextsw(SubovFXP,bytenum,1); \				RET; nextop0; }E 11I 11D 26/****************************************************************/D 15/******			 LOCAL MACROS			 ********/E 15I 15D 22/******		 Old Stack Overflow checks		 ********/E 22I 22/******		 OBSOLETE  Stack Overflow checks	 ********/E 22E 15/****************************************************************/E 26E 11E 41I 12D 15#ifdef TRADSTACKOVERE 15E 12I 11D 26I 12D 15#define  FNSTACKOVER(argnum,bytenum) 	 goto ni;			E 15I 15#define  FN_STACK_CHECK1 						\  if ((unsigned int)((DLword *)CSTKPTR+LOCFNCELL->stkmin+STK_SAFE) >=	\		(unsigned int)StkLimO )  				\D 16	{ goto ni; }							E 16I 16	{ EXT; fnerr(); NRET; }E 16E 15I 16fnerr(){   switch(Get_BYTE(PC)) {	case 010 : OP_fn(); break;	case 011 : OP_fn(); break;	case 012 : OP_fn(); break;	case 013 : OP_fn(); break;	case 014 : OP_fn(); break;	case 015 : OP_fnx(); break;	case 016 : OP_apply(); break;	default : error ("stack overflow not in fn call?");	}}E 16I 15#define  FN_STACK_CHECK2 	 {}E 15#elseE 26E 12D 15#define  FNSTACKOVER(argnum,bytenum) 					\	{ 		/* need to -1 from bytenum */			\E 15I 15/****************************************************************/D 22/******		 New Stack Overflow checks		 ********/E 22I 22D 26/******		 xxx Stack Overflow checks		 ********/E 22/****************************************************************/D 16#define  FN_STACK_CHECK1 	 {}E 16I 16#define  FN_STACK_CHECK1	 {}E 16#define  FN_STACK_CHECK2 						\I 17D 22  if ((unsigned int)((DLword *)(CSTKPTR-1)+LOCFNCELL->stkmin+STK_SAFE) >=	\		(unsigned int)StkLimO )  				\E 17	{ 								\E 15D 12	 goto ni; EXT;								\E 12I 12	 EXT;								\E 12	 if(do_stackoverflow()) 					\D 15		{ RET;  goto ni; }					\E 15I 15		{ RET;  goto nextopcode; }				\E 15	 RET;								\I 17	 NEXTBLOCK = StkOffset_from_68K(IVAR);				\E 22I 22  Irq_Stk_Check = STK_END_COMPUTE(Irq_Stk_End, LOCFNCELL);		\  Irq_Stk_Check = STK_END_COMPUTE(StkLimO, LOCFNCELL);		\  if ((int)CSTKPTR > Irq_Stk_Check)					\	{register int check_lim = STK_END_COMPUTE(StkLimO, LOCFNCELL);	\	 if ((int)CSTKPTR > check_lim) {				\		 EXT;							\		 if(do_stackoverflow(T)) 				\			{ RET;  goto nextopcode; }			\		 RET;							\		 NEXTBLOCK = StkOffset_from_68K(IVAR);			\		}							\ 	 if (Irq_Stk_End)  						\		Irq_Stk_Check = STK_END_COMPUTE(StkLimO, LOCFNCELL);	\	 else Irq_Stk_Check = 0;					\  Irq_Stk_Check = STK_END_COMPUTE(StkLimO, LOCFNCELL);		\E 22E 17	}I 12#endifE 12I 22E 22I 15/****************************************************************/E 26I 22/******		 CURRENT Stack Overflow checks		 ********//****************************************************************/D 26#ifdef TRADSTACKOVERD 23E 23I 23/**E 23fnerr(){   switch(Get_BYTE(PC)) {	case 010 : OP_fn(); break;	case 011 : OP_fn(); break;	case 012 : OP_fn(); break;	case 013 : OP_fn(); break;	case 014 : OP_fn(); break;	case 015 : OP_fnx(); break;	case 016 : OP_apply(); break;	default : error ("stack overflow not in fn call?");	}D 23}E 23I 23}**/E 23#define  FN_STACK_CHECK 						\  if ((unsigned int)((DLword *)CSTKPTR+LOCFNCELL->stkmin+STK_SAFE) >=	\		(unsigned int)StkLimO )  				\	{ EXT; fnerr(); NRET; }#elseE 26D 28#define  FN_STACK_CHECK {						\  Irq_Stk_Check = STK_END_COMPUTE(Irq_Stk_End, LOCFNCELL);		\  if ((int)CSTKPTR > Irq_Stk_Check) goto check_interrupt;		\  }E 28I 28#define  FN_STACK_CHECK			\  if ((int)CSTKPTR > (Irq_Stk_Check=(Irq_Stk_End-STK_MIN(LOCFNCELL))))	\     goto check_interrupt;E 28D 26#endifE 26D 26E 26/****************************************************************/E 22/******			 LOCAL MACROS			 ********//****************************************************************/I 36D 38#ifdef NOASM#define FN_CALL_NATIVE_CHECK(fncell, args, extra_code)#define	FN_CALL_NATIVE_CHECK2(fncell, args, extra_code)I 37#define ASM_LABEL_OF_FN_COMMON E 37#elseE 38I 38#ifdef NATIVETRANE 38E 36E 15E 11I 8D 20#define	FN_CALL_NATIVE_CHECK(fncell, args)				\E 20I 20D 22#define	FN_CALL_NATIVE_CHECK(fncell, args, closurep)			\E 22I 22#define	FN_CALL_NATIVE_CHECK(fncell, args, extra_code)			\E 22E 20{									\D 41  if (fncell->native) 							\	{ 								\E 41I 41  if (fncell->native)							\	{								\E 41I 20D 22	 closurep;							\E 22I 22	 extra_code;							\E 22E 20D 31	 call_pc = (int) PCMAC;						\	 PC = (ByteCode *) args; 					\E 31	 FuncObj = fncell;						\D 31	 goto call_native;						\E 31I 31	 HARD_PUSH(TOPOFSTACK);						\	 CALL_NATIVE(fncell, args);					\E 31	}								\}E 8I 35#define	FN_CALL_NATIVE_CHECK2(fncell, args, extra_code)			\{									\D 41  if (fncell->native) 							\	{ 								\E 41I 41  if (fncell->native)							\	{								\E 41	 extra_code;							\	 (int) PC = args;						\	 FuncObj = fncell;						\	 HARD_PUSH(TOPOFSTACK);						\	 CALL_NATIVE2(fncell, args);					\	}								\}I 38E 38I 37#define ASM_LABEL_OF_FN_COMMON asm_label_op_fn_common()I 38#else#define FN_CALL_NATIVE_CHECK(fncell, args, extra_code)#define	FN_CALL_NATIVE_CHECK2(fncell, args, extra_code)D 41#define ASM_LABEL_OF_FN_COMMON E 41I 41#define ASM_LABEL_OF_FN_COMMONE 41E 38E 37I 36#endifE 36E 35I 22#define APPLY_POP_PUSH_TEST {						\D 28	 if (fn_apply) {POP; POP; }					\E 28I 28	 switch (fn_apply) {						\		case 0:	break; /* do nothing */				\		case 1: POP; POP;  break; /* from apply */		\D 41		case 2: break; /* ufn 0 args */  			\		case 3: PUSH(S_POSITIVE | Get_BYTE(PCMAC+1)); break; 	\		case 4: PUSH(S_POSITIVE | Get_DLword(PCMAC+1)); break; 	\E 41I 41		case 2: break; /* ufn 0 args */				\D 45		case 3: PUSH(S_POSITIVE | Get_BYTE(PCMAC+1)); break;	\		case 4: PUSH(S_POSITIVE | Get_DLword(PCMAC+1)); break;	\E 45I 45		case 3: PUSH(S_POSITIVE | Get_BYTE_PCMAC1); break;	\		case 4: PUSH(S_POSITIVE | Get_DLword_PCMAC1); break;	\E 45E 41		default: error("Storage error: invalid UFN entry");	\		}							\E 28D 41 	 if (needpush) PUSH(fn_atom_index);				\E 41I 41	 if (needpush) PUSH(fn_atom_index);				\E 41	}E 22I 8I 22#define N_APPLY_POP_PUSH_TEST {						\	APPLY_POP_PUSH_TEST;						\	native_closure_env=closure_env;					\	}#define N_ENVCALL_POP_TEST {						\	CSTKPTR -=2;							\	native_closure_env=closure_env;					\	}E 22/****************************************************************//******			 OPAPPLY			 ********//****************************************************************/E 8I 7#define OPAPPLY	{							\D 13  if ( GET_TOS_1_HI  != SPOS_HI ) 					\	error("OP_apply:Illegal data on Stack");			\E 13I 13D 14  if ( GET_TOS_1_HI  != SPOS_HI ) goto op_ufn;				\E 13  fn_num_args = GET_TOS_1_LO;						\  fn_opcode_size = 1;							\  fn_apply = T;								\  fn_atom_index = TOPOFSTACK;						\  if ( (0xffff0000 & TOPOFSTACK) == 0)					\D 8	fn_defcell = (DefCell *) GetDEFCELL68k(TOPOFSTACK);		\  else	{fn_defcell = (DefCell *) &fn_loc_defcell;			\	 fn_loc_defcell = TOPOFSTACK;					\	 goto ni;							\E 8I 8	{fn_defcell = (DefCell *) GetDEFCELL68k(TOPOFSTACK);		\   	 goto op_fn_common;						\E 14I 14  if ( GET_TOS_1_HI  == SPOS_HI ) {					\D 41  	fn_num_args = GET_TOS_1_LO;					\  	fn_opcode_size = 1;						\D 28  	fn_apply = T;							\E 28I 28  	fn_apply = 1;							\E 28  	fn_atom_index = TOPOFSTACK;					\  	if ( (0xffff0000 & TOPOFSTACK) == 0)				\E 41I 41	fn_num_args = GET_TOS_1_LO;					\	fn_opcode_size = 1;						\	fn_apply = 1;							\	fn_atom_index = TOPOFSTACK;					\	if ( (0xffff0000 & TOPOFSTACK) == 0)				\E 41D 26		{fn_defcell = (DefCell *) GetDEFCELL68k(TOPOFSTACK);	\   		 goto op_fn_common;					\		}							\E 26I 26	     {	fn_defcell = (DefCell *) GetDEFCELL68k(TOPOFSTACK);	\		goto op_fn_common;					\	     }								\	else								\	if (GetTypeNumber(TOPOFSTACK)==TYPE_COMPILED_CLOSURE)		\D 29	     {	fn_defcell = (DefCell *) Addr68k_from_LADDR(TOPOFSTACK);\E 29I 29	     {	TopOfStack=TOPOFSTACK;					\		fn_defcell = (DefCell *) &TopOfStack;			\E 29		goto op_fn_common;					\	     }								\	else {	fn_defcell = (DefCell *) GetDEFCELL68k(NIL_PTR);	\		goto op_fn_common;					\	     }								\E 26E 14E 8	}								\D 8  goto op_fn_common;							\E 8I 8D 13  else	goto ni;							\E 13I 13D 14  else	goto op_ufn;							\E 14I 14D 18  EXT; OP_apply(); NRET;						\E 18I 18D 19  EXT; OP_apply(); RET; CHECK_INTERRUPT; nextop0;			\E 19I 19D 26  EXT; OP_apply(); RET; CHECK_INTERRUPT; NATIVE_NEXTOP0;		\E 26I 26  goto op_ufn;								\E 26E 19E 18E 14E 13E 8} /* OPAPPLY */E 7E 2D 7#define OPAPPLY	{\E 7I 7D 8#define XOPAPPLY	{\E 7  /** register DefCell *defcell68k -> wordp Definition Cell PTR */\  /*register int FNPV_NUM->result*/\  /** register LispPTR APPLYSTKOVER_ATOM;-> arg1 */\ /** register struct fnhead *TMP_FNCELL68K; -> cellp */\ /**  register DLword APPLY_ARGNUM ;->arg2 Num of args */\ /** int RESTARGS ;->arg1 use for arignments */\  register CClosure *closure68k; /* closure object*/\\  CLOSUREFUNCP=NIL; /* if closure,T else NIL */\  if(*(CSTKPTR) != SPOS_HI)\	error("OP_apply:Illegal data on Stack");\  else\	APPLY_ARGNUM = *(CSTKPTR+1) ;\  /* Get Next Block offset form OPCODE byte */\  CURRENTFX->nextblock = (LADDR_from_68k(CSTKPTR) & 0x0ffff)\					- (APPLY_ARGNUM<<1) /* -1 */;\  /* Setup IVAR */\  IVAR = Addr68k_from_LADDR((((LispPTR)(CURRENTFX->nextblock)) | STK_OFFSET)) ;\  /* Set PC to the Next Instruction and save into FX */\  CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 1 ;  \  if( (TOPOFSTACK  & 0xffff0000) == 0)\   { /* applyCode */\	APPLYSTKOVER_ATOM=TOPOFSTACK;\	FNDEFCELL68K =(DefCell *) GetDEFCELL68k(TOPOFSTACK) ;\	if( FNDEFCELL68K->ccodep == 0 )\	 {\	   /* This LispFunc is NOT compiled object . We must use Interpreter*/\		FNDEFCELL68K = (DefCell *)GetDEFCELL68k(ATOM_INTERPRETER);\		CSmashStack(TOPOFSTACK);  /* Move AtomIndex to CSTK */\		APPLYSTKOVER_ATOM=ATOM_INTERPRETER;\	 }\	else\	 { /* Added 26-Apr-87 */\		CSTKPTR -= 2 ;  /* to smash Arg Num on CSTK */\	 }\   }\  else\   { /* notCCode :  This Object may be Lambda Expr or C-Closure */\	/* add this clause on Aug 18 87 by take */\	if(GetTypeNumber(TOPOFSTACK)==TYPE_COMPILED_CLOSURE)\	{ /* setup closure */\		CLOSUREFUNCP=T;\		/* get closure object */\		/* And closure obj , They are equal pointer */\\		closure68k=(CClosure *)Addr68k_from_LADDR(TOPOFSTACK);\		FNDEFCELL68K =(DefCell *)closure68k;\		APPLYSTKOVER_ATOM=TOPOFSTACK;\	/* Added 09-Nov-87 by Hayata */\		CSTKPTR -= 2 ;  /* to smash Arg Num on CSTK */\	} /* if end */\	else /* Lambda Expr */\	{ \		/* prepare to call INTERPRETER */\		FNDEFCELL68K = (DefCell *)GetDEFCELL68k(ATOM_INTERPRETER);\		CSmashStack(TOPOFSTACK);  /* Move Object Pointer to CSTK */\		APPLYSTKOVER_ATOM=ATOM_INTERPRETER;\	} /* else end */\   }\  TMP_FNCELL68K = (struct fnhead *)Addr68k_from_LADDR( FNDEFCELL68K->defpointer ) ;\/* stack overflow check */\if((unsigned int)(CSTKPTR + TMP_FNCELL68K->stkmin + STK_SAFE) >=  (unsigned int)StkLimO )\	{\		TOPOFSTACK = APPLYSTKOVER_ATOM;\		CFnStkOvr(APPLY_ARGNUM,0);\		NEXTOPCODE;\	}\  FuncObj = TMP_FNCELL68K ;/* Nov 25 87 take */\ if( FuncObj->na >= 0 )\  {\	/* This Function is Spread Type */\	/* Arguments on Stack Adjustment  */\	/* Here,arg1 uses as RESTARGS(before APPLYSTKOVER_ATOM) */\	RESTARGS = APPLY_ARGNUM - FuncObj->na ;\	while(RESTARGS <0) { \	  CPushStack(NIL_PTR) ;\	  RESTARGS++;\	}\	CSTKPTR -= (RESTARGS<<1) ;\  } /* if end */\ /* Set up BF */\ CSTKPTR += 2;\ /*** *(++CSTKPTR) = BF_MARK ;**/\/**  *(++CSTKPTR) = CURRENTFX->nextblock ;***/\ *((LispPTR *)CSTKPTR) = BF_MARK32 | (CURRENTFX->nextblock) ;\ /* Set up FX */\ CSTKPTR += 2;\ *(CSTKPTR) = FX_MARK;\ CURRENTFX = (struct frameex1 *)CSTKPTR ;\D 2 CURRENTFX->alink = LADDR_from_68k(PVAR);\E 2I 2 CURRENTFX->alink = LADDR_from_68k(PVar);\E 2 CURRENTFX->lofnheader = (FNDEFCELL68K->defpointer) & 0x0ffff ;\ CURRENTFX->hi2fnheader = ((FNDEFCELL68K->defpointer) & 0x0ff0000) >> 16 ;\D 2 /*  Set PVAR pointer */\ PVAR = CSTKPTR = (DLword *)CURRENTFX + FRAMESIZE ;\ /* Set up PVAR area */\E 2I 2 /*  Set PVar pointer */\ PVar = CSTKPTR = (DLword *)CURRENTFX + FRAMESIZE ;\ /* Set up PVar area */\E 2 FNPV_NUM = FuncObj->pv +1 ; /* Apr. 27 */\/* The following lines added on Aug 18 1987 by take */\/* IF CLOSUREFUNCP then Put the closure environmentto top of PVAR slot */\if(CLOSUREFUNCP)\{\	*((LispPTR *)CSTKPTR) = closure68k->env_ptr ;\	CSTKPTR += DLWORDSPER_CELL ;\	*((LispPTR *)CSTKPTR) = 0xFFFF0000 ; \	CSTKPTR += DLWORDSPER_CELL ; \	FNPV_NUM--;\} /* clouserp end */\ while(FNPV_NUM > 0) {\	*((LispPTR *)CSTKPTR) = 0x0ffff0000 ;\	CSTKPTR += DLWORDSPER_CELL ;\	*((LispPTR *)CSTKPTR) = 0x0ffff0000 ;\	CSTKPTR += DLWORDSPER_CELL ; \	FNPV_NUM--;\  }\ /** CSTKPTR ++ ;***/\ /* Set PC points New Function's first OPCODE */\ PCMAC = (ByteCode *)FuncObj + FuncObj->startpc ;\} /* end OPAPPLY */E 8I 7D 34E 34D 8E 8E 7/****************************************************************//******			 OPFN(x)			 ********//****************************************************************/D 2#define OPFN(x)	{ /* x is a number of the arguments on stack */\  DefCell *defcell;\  save_atom_index = Get_DLword(PCMAC+1); \  defcell = (DefCell *) GetDEFCELL68k(Get_DLword(PCMAC+1)) ;\  if( defcell->ccodep == 0 ) { goto ni; }\E 2I 2D 34#define OPFN(x)	{ /* x is a number of the arguments on stack */		\E 34I 34D 35#if (defined(sun) && defined(mc68020) && ~(defined(NOASM)) && ~(defined(NOASMFNCALL)))E 35I 35D 38#if (defined(sun) && defined(mc68020) && !(defined(NOASM)) && !(defined(NOASMFNCALL))) E 38I 38D 40#if (defined(SUN3_OS3_IL) &&  !(defined(NOASMFNCALL)) )E 40I 40#if (defined(SUN3_OS3_OR_OS4_IL) &&  !(defined(NOASMFNCALL)) )E 40E 38E 35I 38#ifdef NATIVETRANE 38D 35#define OPFN(x, num_args_fn, fn_xna_args)			\E 35I 35#define OPFN(x, num_args_fn, fn_xna_args, fn_native)			\E 35{    /* asm inlines for fn call (much care put into keeping optimizer	\	from moving things around). */					\	fn_section1();							\	fn_section2();							\	num_args_fn();							\I 38	fn_native_test();						\E 38	fn_section3();							\	fn_xna_args();							\	fn_section4();							\D 35	fast_dispatcher();		/* nextop0 don't work here */	\E 35I 35	fast1_dispatcher();		/* nextop0 don't work here */	\	fn_native();							\E 35	fn_section5();							\			/* asm code jumps here when not ccodep */	\D 45	{ fn_atom_index = Get_DLword(PCMAC+1);				\E 45I 45	{ fn_atom_index = Get_DLword_PCMAC1;				\E 45	  fn_defcell = (DefCell *) GetDEFCELL68k(fn_atom_index);	\	  fn_num_args = x;						\	  fn_opcode_size = 3;						\	  fn_apply = 0;							\D 41	  goto op_fn_common; 						\E 41I 41	  goto op_fn_common;						\E 41	}								\}D 41#define OPFNX	 							\E 41I 41#define OPFNX								\E 41{    /* asm inlines for fn call (much care put into keeping optimizer	\D 41	from moving things around. 	*/				\E 41I 41	from moving things around.	*/				\E 41	fnx_section1();							\	fn_section2();							\	fnx_args();							\I 38	fn_native_test();						\E 38	fn_section3();							\	fnx_xna();							\	fn_section4();							\D 35	fast_dispatcher();		/* nextop0 don't work here */	\E 35I 35	fast1_dispatcher();		/* nextop0 don't work here */	\	fnx_native();							\E 35	fn_section5();							\D 45	fn_atom_index = Get_DLword(PCMAC+2);				\E 45I 45D 47	fn_atom_index = Get_DLword_PCMAC2;				\E 47I 47	fn_atom_index = Get_DLword(PCMAC+2);				\E 47E 45	fn_defcell = (DefCell *) GetDEFCELL68k(fn_atom_index);		\D 45	fn_num_args = Get_BYTE(PCMAC+1);				\E 45I 45	fn_num_args = Get_BYTE_PCMAC1;				\E 45	fn_opcode_size = 4;						\	fn_apply = 0;							\D 41	goto op_fn_common; 						\E 41I 41	goto op_fn_common;						\E 41		/* *** these carefully arranged to satisfy optimizer */ \D 35label1:	fast_dispatcher();						\E 35I 35label1:	fast1_dispatcher();						\E 35label2:	to_native_label();						\									\}I 38#elseE 38I 38#define OPFN(x, num_args_fn, fn_xna_args, fn_native)			\{    /* asm inlines for fn call (much care put into keeping optimizer	\	from moving things around). */					\	fn_section1();							\	fn_section2();							\	num_args_fn();							\	fn_section3();							\	fn_xna_args();							\	fn_section4();							\	fast1_dispatcher();		/* nextop0 don't work here */	\	fn_section5();							\			/* asm code jumps here when not ccodep */	\D 45	{ fn_atom_index = Get_DLword(PCMAC+1);				\E 45I 45	{ fn_atom_index = Get_DLword_PCMAC1;				\E 45	  fn_defcell = (DefCell *) GetDEFCELL68k(fn_atom_index);	\	  fn_num_args = x;						\	  fn_opcode_size = 3;						\	  fn_apply = 0;							\D 41	  goto op_fn_common; 						\E 41I 41	  goto op_fn_common;						\E 41	}								\}D 41#define OPFNX	 							\E 41I 41#define OPFNX								\E 41{    /* asm inlines for fn call (much care put into keeping optimizer	\D 41	from moving things around. 	*/				\E 41I 41	from moving things around.	*/				\E 41	fnx_section1();							\	fn_section2();							\	fnx_args();							\	fn_section3();							\	fnx_xna();							\	fn_section4();							\	fast1_dispatcher();		/* nextop0 don't work here */	\	fn_section5();							\D 45	fn_atom_index = Get_DLword(PCMAC+2);				\E 45I 45D 47	fn_atom_index = Get_DLword_PCMAC2;				\E 47I 47	fn_atom_index = Get_DLword(PCMAC+2);				\E 47E 45	fn_defcell = (DefCell *) GetDEFCELL68k(fn_atom_index);		\D 45	fn_num_args = Get_BYTE(PCMAC+1);				\E 45I 45	fn_num_args = Get_BYTE_PCMAC1;				\E 45	fn_opcode_size = 4;						\	fn_apply = 0;							\D 41	goto op_fn_common; 						\E 41I 41	goto op_fn_common;						\E 41		/* *** these carefully arranged to satisfy optimizer */ \label1:	fast1_dispatcher();						\D 39label2:	to_native_label();						\E 39									\}#endifE 38#elseD 35#define OPFN(x, num_args_fn, fn_xna_args, native_label)			\E 35I 35#define OPFN(x, num_args_fn, fn_xna_args, fn_native)			\E 35{	 /* x is a number of the arguments on stack */			\E 34D 4  DefCell *defcell;							\E 4I 4  register struct fnhead *LOCFNCELL;					\D 34  register DefCell *defcell;	/* this reg is not allocated */		\E 34I 34  register int defcell_word;						\E 34  register int NEXTBLOCK;						\E 4D 34  defcell = (DefCell *) GetDEFCELL68k(Get_DLword(PCMAC+1)) ;		\D 7  if( defcell->ccodep == 0 ) { goto ni; }				\E 7I 7  if( defcell->ccodep == 0 )						\	{ fn_defcell = defcell;						\E 34I 34D 41  if((defcell_word = *((int *) GetDEFCELL68k(Get_DLword(PCMAC+1)))) >= 0 )\E 41I 41D 45  if((defcell_word = *((int *) GetDEFCELL68k(Get_DLword(PCMAC+1)))) >= 0)\E 45I 45D 47  if((defcell_word = *((int *) GetDEFCELL68k(Get_DLword_PCMAC1))) >= 0)\E 47I 47  if((defcell_word = *((int *) GetDEFCELL68k(Get_DLword(PCMAC+1)))) >= 0)\E 47E 45E 41D 44	{ fn_defcell = (DefCell *) GetDEFCELL68k(Get_DLword(PCMAC+1));	\E 44I 44D 46	{								\E 46I 46	{ /* it's not a CCODEP (what a test^!! */			\E 46D 45	  fn_defcell = (DefCell *) GetDEFCELL68k(Get_DLword(PCMAC+1));	\E 45I 45D 47	  fn_defcell = (DefCell *) GetDEFCELL68k(Get_DLword_PCMAC1);	\E 47I 47	  fn_defcell = (DefCell *) GetDEFCELL68k(Get_DLword(PCMAC+1));	\E 47E 45E 44E 34	  fn_num_args = x;						\	  fn_opcode_size = 3;						\D 45	  fn_atom_index = Get_DLword(PCMAC+1);				\E 45I 45D 47	  fn_atom_index = Get_DLword_PCMAC1;				\E 47I 47	  fn_atom_index = Get_DLword(PCMAC+1);				\E 47E 45D 28	  fn_apply = NIL;						\E 28I 28D 34	  fn_apply = 0;						\E 34I 34	  fn_apply = 0;							\E 34E 28D 41	  goto op_fn_common; 						\E 41I 41	  goto op_fn_common;						\E 41	}								\E 7E 2D 34  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(defcell->defpointer) ;\E 34I 34D 41  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR((defcell_word &= 0xffffff)) ;\E 41I 41  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR((defcell_word &= 0xffffff));\E 41E 34I 3D 9  if ((unsigned int)(CSTKPTR + LOCFNCELL->stkmin +STK_SAFE) >=  	\E 9I 9D 15  if ((unsigned int)((DLword *)CSTKPTR+LOCFNCELL->stkmin+STK_SAFE) >=	\E 9		(unsigned int)StkLimO )  				\D 11	{goto ni; }							\E 11I 11	{FNSTACKOVER(x, 3); }						\E 15I 15D 22  FN_STACK_CHECK1;							\E 22E 15E 11E 3I 2D 8  if (LOCFNCELL->native) 						\D 3	{FuncObj = LOCFNCELL; PC = (ByteCode *) -x; PCMAC += 3; goto callnative; }	\E 2  if((unsigned int)(CSTKPTR + LOCFNCELL->stkmin +STK_SAFE) >=  (unsigned int)StkLimO )  {goto ni; }\E 3I 3	{ 								\	 PC = (ByteCode *) -x; 						\	 PCMAC = (ByteCode *)						\		 ((unsigned int)PCMAC + 3 - (unsigned int)FuncObj); 	\	 FuncObj = LOCFNCELL;						\D 4	 goto callnative; }						\E 3D 2  CURRENTFX->nextblock = NEXTBLOCK = LADDR_from_68k(CSTKPTR-(x<<1)+2) & 0x0ffff ;\  IVAR = Addr68k_from_LADDR((((LispPTR)NEXTBLOCK)) | STK_OFFSET) ;\  CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 3 ; \  CPushCStack ;  /* save TOS */\  if( LOCFNCELL->na >= 0 )\  {\	RESTARGS = x - LOCFNCELL->na ;\	while(RESTARGS <0) { \	 CPushStack(NIL_PTR) ;\	  RESTARGS++;\	}\	CSTKPTR -= (RESTARGS<<1) ;\  } /* if end */\ /* Set up BF */\ CPushStack(BF_MARK32 | NEXTBLOCK);\ CURRENTFX = (struct frameex1 *)(CSTKPTR) ;\E 2I 2  CURRENTFX->nextblock = NEXTBLOCK = LADDR_from_68k(CSTKPTR-x+1) & 0x0ffff ;\  IVAR = (LispPTR *)Addr68k_from_LADDR(((LispPTR)NEXTBLOCK) | STK_OFFSET) ;\  CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 3 ; 	\E 4I 4	 goto callnative; };						\E 8I 8  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 3;\D 20  FN_CALL_NATIVE_CHECK(LOCFNCELL,-x);					\E 20I 20  FN_CALL_NATIVE_CHECK(LOCFNCELL,-x,{});				\I 22  FN_STACK_CHECK;							\E 22E 20E 8  {register int newivar;						\	(LispPTR *) newivar = IVAR = CSTKPTR-x+1;			\D 41  	BCE_CURRENTFX->nextblock = 					\	NEXTBLOCK = 							\E 41I 41	BCE_CURRENTFX->nextblock =					\	NEXTBLOCK =							\E 41		StkOffset_from_68K(newivar);				\  }									\D 8  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 3;\E 8E 4  HARD_PUSH(TOPOFSTACK);  /* save TOS */				\I 15D 22  FN_STACK_CHECK2;							\E 22E 15  if( LOCFNCELL->na >= 0 )						\D 4  {									\E 4I 4  {register int RESTARGS;						\E 4D 41	RESTARGS = x - LOCFNCELL->na ;					\	while(RESTARGS <0) { 						\D 4	 HARD_PUSH(NIL_PTR) ;						\E 4I 4	  HARD_PUSH(NIL_PTR) ;						\E 41I 41	RESTARGS = x - LOCFNCELL->na;					\	while(RESTARGS <0) {						\	  HARD_PUSH(NIL_PTR);						\E 41E 4	  RESTARGS++;							\	}								\D 41	CSTKPTR -= (RESTARGS) ;						\E 41I 41	CSTKPTR -= (RESTARGS);						\E 41  } /* if end */							\ /* Set up BF */							\ HARD_PUSH(BF_MARK32 | NEXTBLOCK);					\D 4/* CURRENTFX = (struct frameex1 *)(CSTKPTR) ;	*/			\E 2 *((LispPTR *)CSTKPTR) = (FX_MARK << 16) | (LADDR_from_68k(PVAR) & 0x0ffff);\D 2 ((struct frameex1 *)CSTKPTR)->lofnheader = defcell->defpointer;\E 2I 2 ((struct frameex1 *)CSTKPTR)->lofnheader = defcell->defpointer;	\E 2 ((struct frameex1 *)CSTKPTR)->hi2fnheader = *((ByteCode *)(defcell) + 1);\D 2  PVAR = CSTKPTR += FRAMESIZE ;\  result = LOCFNCELL->pv+1 ;\  while(result > 0) {\	*((LispPTR *)CSTKPTR++) = 0x0ffffffff ;\	*((LispPTR *)(CSTKPTR++)) = 0x0ffffffff ;\	result--;\  }\ CSTKPTR += 2 ; \ PCMAC = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc ;\ FuncObj = LOCFNCELL  ; \E 2I 2  ((DLword *) CSTKPTR) += FRAMESIZE;		\  PVAR = (LispPTR *) CSTKPTR;		\  result = LOCFNCELL->pv+1 ;						\  while(result > 0) {							\	*((LispPTR *)CSTKPTR++) = 0x0ffffffff ;				\	*((LispPTR *)(CSTKPTR++)) = 0x0ffffffff ;			\	result--;							\  }									\E 4I 4 *((LispPTR *)CSTKPTR) = (FX_MARK << 16) | (StkOffset_from_68K(PVAR));	\D 7/* ((struct frameex1 *)CSTKPTR)->lofnheader = defcell->defpointer;	\ ((struct frameex1 *)CSTKPTR)->hi2fnheader = *((ByteCode *)(defcell) + 1);*/\E 7D 34 ((struct frameex2 *)CSTKPTR)->fnheader = SWAP_WORDS(defcell->defpointer);\E 34I 34 ((struct frameex2 *)CSTKPTR)->fnheader = SWAP_WORDS(defcell_word);\E 34  ((DLword *) CSTKPTR) += FRAMESIZE;					\  PVAR = (LispPTR *) CSTKPTR;						\  {register int result;							\D 30D 31	result = LOCFNCELL->pv+1 ;					\ 	if (result > 0)							\E 31I 31	result = LOCFNCELL->pv;						\D 41 	if (result >= 0)						\E 41I 41	if (result >= 0)						\E 41E 31E 30I 30D 33	result = LOCFNCELL->pv;						\ 	if (result >= 0)						\E 33E 30	  {register LispPTR unboundval;					\D 30D 31	   unboundval = (LispPTR) 0x0ffffffff;				\E 31I 31	   unboundval = (LispPTR) 0xffffffff;				\E 31E 30I 30D 33	   unboundval = (LispPTR) 0xffffffff;				\E 33E 30	   HARD_PUSH(unboundval);					\	   HARD_PUSH(unboundval);					\D 30D 31	   if (result > 1)						\E 31I 31	   if (result > 0)						\E 31E 30I 30D 33	   if (result > 0)						\E 33E 30	    {HARD_PUSH(unboundval);					\	     HARD_PUSH(unboundval);					\D 30D 31	     result-=2;							\	     while(result > 0) {					\E 31I 31	     result-=1;							\	     for (; --result >= 0;) {					\E 31E 30I 30D 33	     result-=1;							\	     for (; --result >= 0;) {					\E 33E 30	       HARD_PUSH(unboundval);					\	       HARD_PUSH(unboundval);					\D 30D 31	       result--;						\ 	     }								\E 31I 31	     }								\E 31E 30I 30D 33	     }								\E 33E 30D 41 	   }								\ 	 }								\E 41I 41	   }								\	 }								\E 41 }									\E 4D 41 CSTKPTR += 1 ; 							\E 41I 41 CSTKPTR += 1;								\E 41D 35 PCMAC = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc ;			\E 35I 35 PCMACL = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1;		\E 35D 41 FuncObj = LOCFNCELL  ; 						\E 41I 41 FuncObj = LOCFNCELL;							\E 41I 34 nextop0;								\E 34E 2} /* end OPFN */I 34E 34/*************** OPFNX *************/D 7#define OPFNX	{ \  register struct definition_cell *defcell68k ;  /* Definition Cell PTR */\ /*  register short pv_num -> result;*/ /* scratch for pv */\  /***register struct fnhead *TMP_FNCELL68K;**/ \ /* int RESTARGS ; is arg1  use for arignments */ \  register CClosure *closure68k; \  /* int CLOSUREFUNCP is arg3 */ \ CLOSUREFUNCP =NIL;\ /* Get aromindex (result)*/ \/* result = (Get_BYTE(PCMAC+2) <<8) | Get_BYTE(PCMAC +3) ;  */\ result = Get_DLword(PCMAC+2);\  /* Get Next Block offset from argnum */ \  CURRENTFX->nextblock = (LADDR_from_68k(CSTKPTR) & 0x0ffff) \					- ((Get_BYTE(PCMAC +1))<<1) +4 /*+3*/ ; \  /* Setup IVAR */ \  IVAR = Addr68k_from_LADDR((((LispPTR)(CURRENTFX->nextblock)) | STK_OFFSET)) ;\  /* Set PC to the Next Instruction and save into FX */\  /* we assume FNX's bytenum is 4 */ \  CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 4 ; \  CPushCStack ;  /* save TOS */\  /* Get DEFCELL 68k address */ \  defcell68k =(struct definition_cell *) GetDEFCELL68k(result) ; \  if( defcell68k->ccodep == 0 ) \  { \   /* This clause added on 18-Aug-87 take */\	if(GetTypeNumber(defcell68k->defpointer)==TYPE_COMPILED_CLOSURE)\	 { /* setup closure */\		CLOSUREFUNCP=T;\		/* get closure object */\		closure68k=(CClosure *)Addr68k_from_LADDR(defcell68k->defpointer);\		/* Defcell is equal to Closure->defptr */\		defcell68k=(DefCell *)closure68k ;\	 } /* if end */\	else {\  	/* This LispFunc is NOT compiled object . We must use Interpreter*/\	defcell68k = (struct definition_cell *)GetDEFCELL68k(ATOM_INTERPRETER);\	CPushStack(result); /* provide the argument for INTERPRETER */\	result=ATOM_INTERPRETER;\	 } /*else end */\  }\    /* Nov 25 87 take */\  TMP_FNCELL68K = (struct fnhead *)Addr68k_from_LADDR( defcell68k->defpointer ) ;\if((unsigned int)(CSTKPTR + TMP_FNCELL68K->stkmin +STK_SAFE) >=  (unsigned int)StkLimO )\	{\		if(CLOSUREFUNCP)\		TOPOFSTACK = LADDR_from_68k(closure68k);\		else\		TOPOFSTACK= result;\		CFnStkOvr(Get_BYTE(PCMAC +1),3);\		NEXTOPCODE;\	}\  FuncObj = TMP_FNCELL68K  ; /* Nov 25 87 take */\ if( FuncObj->na >= 0 )\  {\	/* This Function is Spread Type */\	/* Arguments on Stack Adjustment  */\	RESTARGS = Get_BYTE(PCMAC +1)- FuncObj->na ;\	while(RESTARGS <0) { \	 CPushStack(NIL_PTR) ;\	  RESTARGS++;\	}\	CSTKPTR -= (RESTARGS<<1) ;\  } /* if end */\ /* Set up BF */\ CSTKPTR +=2 ; \ *((LispPTR *)CSTKPTR) = BF_MARK32 | (CURRENTFX->nextblock) ; \ /* *(++CSTKPTR) = BF_MARK ; */\/* *(++CSTKPTR) = CURRENTFX->nextblock ; */\ /* Set up FX */\ CSTKPTR +=2 ; \ *(CSTKPTR) = FX_MARK;\ /* Now SET new FX */\ CURRENTFX = (struct frameex1 *)CSTKPTR ;\D 2 CURRENTFX->alink = LADDR_from_68k(PVAR);\E 2I 2 CURRENTFX->alink = LADDR_from_68k(PVar);\E 2 CURRENTFX->lofnheader = (defcell68k->defpointer) & 0x0ffff ;\ CURRENTFX->hi2fnheader = ((defcell68k->defpointer) & 0x0ff0000) >> 16 ;\D 2 /*  Set PVAR pointer */\ PVAR = CSTKPTR = (DLword *)CURRENTFX + FRAMESIZE ;\ /* Set up PVAR area   NOW result uses as pv_num*/\E 2I 2 /*  Set PVar pointer */\ PVar = CSTKPTR = (DLword *)CURRENTFX + FRAMESIZE ;\ /* Set up PVar area   NOW result uses as pv_num*/\E 2 result = FuncObj->pv+1 ; /* Changed Apr.27 */\/* The following lines added on Aug 18 1987 by take */\/* IF CLOSUREFUNCP then Put the closure environmentto top of PVAR slot */\if(CLOSUREFUNCP)\{\	*((LispPTR *)CSTKPTR) = closure68k->env_ptr ;\	CSTKPTR += DLWORDSPER_CELL ;\	*((LispPTR *)CSTKPTR) = 0xFFFF0000 ; \	CSTKPTR += DLWORDSPER_CELL ;\	result--;\} /* clouserp end */\ while(result > 0) {\	*((LispPTR *)CSTKPTR) = 0x0ffff0000 ;\	CSTKPTR += DLWORDSPER_CELL ;\	*((LispPTR *)CSTKPTR) = 0x0ffff0000 ;\	CSTKPTR += DLWORDSPER_CELL ;\	result--;\  }\/** CSTKPTR ++ ;**/\ /* Set PC points New Function's first OPCODE */\ PCMAC = (ByteCode *)FuncObj + FuncObj->startpc ;\E 7I 7D 41#define OPFNX	{ 							\E 41I 41#define OPFNX	{							\E 41  register struct fnhead *LOCFNCELL;					\  register DefCell *defcell;	/* this reg is not allocated */		\  register int NEXTBLOCK;						\D 45  int num_args = Get_BYTE(PCMAC+1);					\D 41  defcell = (DefCell *) GetDEFCELL68k(Get_DLword(PCMAC+2)) ;		\E 41I 41  defcell = (DefCell *) GetDEFCELL68k(Get_DLword(PCMAC+2));		\E 45I 45  int num_args = Get_BYTE_PCMAC1;					\D 47  defcell = (DefCell *) GetDEFCELL68k(Get_DLword_PCMAC2);		\E 47I 47  defcell = (DefCell *) GetDEFCELL68k(Get_DLword(PCMAC+2));		\E 47E 45E 41  if( defcell->ccodep == 0 )						\	{ fn_defcell = defcell;						\	  fn_num_args = num_args;					\	  fn_opcode_size = 4;						\D 45	  fn_atom_index = Get_DLword(PCMAC+2);				\E 45I 45D 47	  fn_atom_index = Get_DLword_PCMAC2;				\E 47I 47	  fn_atom_index = Get_DLword(PCMAC+2);				\E 47E 45D 28	  fn_apply = NIL;						\E 28I 28D 41	  fn_apply = 0;						\E 28	  goto op_fn_common; 						\E 41I 41	  fn_apply = 0;							\	  goto op_fn_common;						\E 41	}								\D 41  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(defcell->defpointer) ;\E 41I 41  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(defcell->defpointer);	\E 41D 9  if ((unsigned int)(CSTKPTR + LOCFNCELL->stkmin +STK_SAFE) >=  	\E 9I 9D 15  if ((unsigned int)((DLword *)CSTKPTR+LOCFNCELL->stkmin+STK_SAFE) >=	\E 9		(unsigned int)StkLimO )  				\D 11	{goto ni; }							\E 11I 11	{FNSTACKOVER(num_args, 4); }					\E 15I 15D 22  FN_STACK_CHECK1;							\E 22E 15E 11D 8  if (LOCFNCELL->native) 						\	{ 								\	 PC = (ByteCode *) - num_args; 					\	 PCMAC = (ByteCode *)						\		 ((unsigned int)PCMAC + 4 - (unsigned int)FuncObj); 	\	 FuncObj = LOCFNCELL;						\	 goto callnative; };						\E 8I 8  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 4;\D 20  FN_CALL_NATIVE_CHECK(LOCFNCELL, - num_args); 			\E 20I 20D 35  FN_CALL_NATIVE_CHECK(LOCFNCELL, - num_args, {}); 			\E 35I 35D 41  FN_CALL_NATIVE_CHECK2(LOCFNCELL, - num_args, {}); 			\E 41I 41  FN_CALL_NATIVE_CHECK2(LOCFNCELL, - num_args, {});			\E 41E 35I 22  FN_STACK_CHECK;							\E 22E 20E 8  {register int newivar;						\	(LispPTR *) newivar = IVAR = CSTKPTR-num_args+1;		\D 41  	BCE_CURRENTFX->nextblock = 					\	NEXTBLOCK = 							\E 41I 41	BCE_CURRENTFX->nextblock =					\	NEXTBLOCK =							\E 41		StkOffset_from_68K(newivar);				\  }									\D 8  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 4;\E 8  HARD_PUSH(TOPOFSTACK);  /* save TOS */				\I 15D 22  FN_STACK_CHECK2;							\E 22E 15  if( LOCFNCELL->na >= 0 )						\  {register int RESTARGS;						\D 41	RESTARGS = num_args - LOCFNCELL->na ;			\	while(RESTARGS <0) { 						\	  HARD_PUSH(NIL_PTR) ;						\E 41I 41	RESTARGS = num_args - LOCFNCELL->na;				\	while(RESTARGS <0) {						\	  HARD_PUSH(NIL_PTR);						\E 41	  RESTARGS++;							\	}								\D 41	CSTKPTR -= (RESTARGS) ;						\E 41I 41	CSTKPTR -= (RESTARGS);						\E 41  } /* if end */							\ /* Set up BF */							\ HARD_PUSH(BF_MARK32 | NEXTBLOCK);					\ *((LispPTR *)CSTKPTR) = (FX_MARK << 16) | (StkOffset_from_68K(PVAR));	\ ((struct frameex2 *)CSTKPTR)->fnheader = SWAP_WORDS(defcell->defpointer);\  ((DLword *) CSTKPTR) += FRAMESIZE;					\  PVAR = (LispPTR *) CSTKPTR;						\  {register int result;							\D 30D 31	result = LOCFNCELL->pv+1 ;					\ 	if (result > 0)							\E 31I 31	result = LOCFNCELL->pv;						\D 41 	if (result >= 0)						\E 41I 41	if (result >= 0)						\E 41E 31E 30I 30D 33	result = LOCFNCELL->pv;						\ 	if (result >= 0)						\E 33E 30	  {register LispPTR unboundval;					\D 30D 31	   unboundval = (LispPTR) 0x0ffffffff;				\E 31I 31	   unboundval = (LispPTR) 0xffffffff;				\E 31E 30I 30D 33	   unboundval = (LispPTR) 0xffffffff;				\E 33E 30	   HARD_PUSH(unboundval);					\	   HARD_PUSH(unboundval);					\D 30D 31	   if (result > 1)						\E 31I 31	   if (result > 0)						\E 31E 30I 30D 33	   if (result > 0)						\E 33E 30	    {HARD_PUSH(unboundval);					\	     HARD_PUSH(unboundval);					\D 30D 31	     result-=2;							\	     while(result > 0) {					\E 31I 31	     result-=1;							\	     for (; --result >= 0;) {					\E 31E 30I 30D 33	     result-=1;							\	     for (; --result >= 0;) {					\E 33E 30	       HARD_PUSH(unboundval);					\	       HARD_PUSH(unboundval);					\D 30D 31	       result--;						\ 	     }								\E 31I 31	     }								\E 31E 30I 30D 33	     }								\E 33E 30D 41 	   }								\ 	 }								\E 41I 41	   }								\	 }								\E 41 }									\D 41 CSTKPTR += 1 ; 							\D 35 PCMAC = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc ;			\E 35I 35 PCMACL = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1 ;		\E 35 FuncObj = LOCFNCELL  ; 						\E 41I 41 CSTKPTR += 1;								\ PCMACL = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1;		\ FuncObj = LOCFNCELL;							\E 41E 7} /* end OPFN */D 7#define OPCHECKAPPLY {\	wordp =(DLword *) GetDEFCELL68k(TOPOFSTACK) ; \	if( ( ((struct definition_cell *)wordp)->ccodep ) && ( ( ((struct definition_cell *)wordp)->argtype == 0 ) ||  \	                    ( ((struct definition_cell *)wordp)->argtype == 2 )    )) \		{\		PCMAC++;\		NEXTOPCODE;\		}\	else {\		UFN(017); \		NEXTOPCODE;\		}\	}E 7I 34#endifE 34I 8/****************************************************************//******			 OPCHECKAPPLY			 ********//****************************************************************/E 8I 7D 8E 8#define OPCHECKAPPLY {							\  register DefCell *defcell;						\D 8  defcell =(DefCell *) GetDEFCELL68k(TOPOFSTACK) ; 			\  if (! ( ( defcell->ccodep ) && ( ( defcell->argtype == 0 ) ||  	\	                           ( defcell->argtype == 2 ) ) )  )	\	goto ufn_0;							\E 8I 8D 41  defcell = (DefCell *) GetDEFCELL68k(TOPOFSTACK & 0xffff) ; 		\E 41I 41  defcell = (DefCell *) GetDEFCELL68k(TOPOFSTACK & 0xffff);		\E 41  if  (!(  defcell->ccodep  && ((TOPOFSTACK & 0xffff0000) == 0)	&&	\D 41	( ( defcell->argtype == 0 ) || ( defcell->argtype == 2 ) ) ) ) 	\  	goto op_ufn;							\E 41I 41	( ( defcell->argtype == 0 ) || ( defcell->argtype == 2 ) ) ) )	\	goto op_ufn;							\E 41E 8}D 22E 22/****************************************************************/I 28/*		UFN_COMMON at op_ufn				 //****************************************************************/#define GetUFNEntry(num)	(((UFN *)UFNTable) + (num))#define	UFN_COMMON							\op_ufn:		 use code in XC.c					\{ register UFN *entry68k;						\D 45   entry68k = (UFN *)GetUFNEntry(Get_BYTE(PCMAC));			\E 45I 45   entry68k = (UFN *)GetUFNEntry(Get_BYTE_PCMAC0);			\E 45   fn_num_args = entry68k->arg_num;					\   fn_opcode_size = entry68k->byte_num+1;				\   fn_atom_index = entry68k->atom_name;					\   fn_defcell = (DefCell *) GetDEFCELL68k(fn_atom_index);		\   fn_apply = 0;							\   goto op_fn_common;							\  };/****************************************************************/E 28/******			 OP_FN_COMMON			 ********//* vars:							*//*	fn_atom_index						*//*	fn_num_args						*//*	fn_opcode_size						*//*	fn_defcell						*//*	fn_apply						*/I 20/*								*//* All Closure Calls go through here				*/E 20/****************************************************************/#define needpush NEXTBLOCK#define OP_FN_COMMON							\op_fn_common:								\I 34D 37	asm_label_op_fn_common();					\E 37I 37D 41	ASM_LABEL_OF_FN_COMMON;					\E 41I 41	ASM_LABEL_OF_FN_COMMON;						\E 41E 37E 34{ register struct fnhead *LOCFNCELL;					\  register DefCell *defcell;	/* this reg is not allocated */		\  CClosure *closure;							\D 20  int closurep = NIL;							\E 20I 20D 30D 31  LispPTR closure_env = (LispPTR) 0x0ffffffff;				\E 31I 31  LispPTR closure_env = (LispPTR) 0xffffffff;				\E 31E 30I 30D 32  LispPTR closure_env = (LispPTR) 0xffffffff;				\E 32E 30E 20 {register int NEXTBLOCK = NIL;						\  defcell = fn_defcell;							\D 41  if( (defcell->ccodep == 0)  ) 					\E 41I 41  if( (defcell->ccodep == 0)  )						\E 41    if(GetTypeNumber(defcell->defpointer)==TYPE_COMPILED_CLOSURE)	\	 { /* setup closure */						\		closure=(CClosure *)Addr68k_from_LADDR(defcell->defpointer);\		defcell=(DefCell *)closure;				\		/* not  a closure if closure's env is NIL */		\D 20		if(closure->env_ptr ) closurep=T;			\E 20I 20D 41		if(closure->env_ptr ) 					\			{closure_env =  (LispPTR) (closure->env_ptr); 	\E 41I 41		if(closure->env_ptr )					\			{closure_env =  (LispPTR) (closure->env_ptr);	\E 41			}						\E 20	 } /* if end */							\	else {								\D 41  	/* NOT compiled object . We must use Interpreter*/		\E 41I 41	/* NOT compiled object . We must use Interpreter*/		\E 41	defcell = (DefCell *)GetDEFCELL68k(ATOM_INTERPRETER);		\D 28	needpush = T;							\E 28I 28	needpush = 1;							\E 28	 } /*else end */						\D 41  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(defcell->defpointer) ;\E 41I 41  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(defcell->defpointer);	\E 41D 9  if ((unsigned int)(CSTKPTR + LOCFNCELL->stkmin +STK_SAFE) >=  	\E 9I 9D 15  if ((unsigned int)((DLword *)CSTKPTR+LOCFNCELL->stkmin+STK_SAFE) >=	\E 9		(unsigned int)StkLimO )  				\D 11	{printf("error StkLimO\n");\	goto ni; 							\E 11I 11	{								\	FNSTACKOVER(fn_num_args, fn_opcode_size); 			\E 11	}								\E 15I 15D 22  FN_STACK_CHECK1;							\E 15  if (fn_apply) {POP; POP; }						\  if (needpush) PUSH(fn_atom_index);					\E 22D 8  if (LOCFNCELL->native) 						\	{ 								\	 PC = (ByteCode *) -fn_num_args; 				\	 PCMAC = (ByteCode *)						\		 ((unsigned int)PCMAC + 				\			fn_opcode_size - (unsigned int)FuncObj); 	\	 FuncObj = LOCFNCELL;						\	 goto callnative; 						\	};								\E 8I 8  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + fn_opcode_size;\D 20  FN_CALL_NATIVE_CHECK(LOCFNCELL, -fn_num_args);			\E 20I 20D 22  FN_CALL_NATIVE_CHECK(LOCFNCELL, -fn_num_args, native_closure_env=closure_env)\E 22I 22D 35  FN_CALL_NATIVE_CHECK(LOCFNCELL, -fn_num_args, N_APPLY_POP_PUSH_TEST)	\E 35I 35  FN_CALL_NATIVE_CHECK2(LOCFNCELL, -fn_num_args, N_APPLY_POP_PUSH_TEST)	\E 35  FN_STACK_CHECK;							\  APPLY_POP_PUSH_TEST;							\E 22E 20E 8 {register int newivar;							\	(LispPTR *) newivar = IVAR = CSTKPTR+(1-fn_num_args-needpush);	\D 41  	BCE_CURRENTFX->nextblock = 					\	NEXTBLOCK = 							\E 41I 41	BCE_CURRENTFX->nextblock =					\	NEXTBLOCK =							\E 41		StkOffset_from_68K(newivar);				\  }									\D 8  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + fn_opcode_size;\E 8  HARD_PUSH(TOPOFSTACK);  /* save TOS */				\I 15D 22  FN_STACK_CHECK2;							\E 22E 15  if( LOCFNCELL->na >= 0 )						\  {register int RESTARGS;						\D 41	RESTARGS = fn_num_args - LOCFNCELL->na ;			\	while(RESTARGS <0) { 						\	  HARD_PUSH(NIL_PTR) ;						\E 41I 41	RESTARGS = fn_num_args - LOCFNCELL->na;				\	while(RESTARGS <0) {						\	  HARD_PUSH(NIL_PTR);						\E 41	  RESTARGS++;							\	}								\D 41	CSTKPTR -= (RESTARGS) ;						\E 41I 41	CSTKPTR -= (RESTARGS);						\E 41  } /* if end */							\ /* Set up BF */							\ HARD_PUSH(BF_MARK32 | NEXTBLOCK);					\ } /* NEXTBLOCK BLOCK */						\ *((LispPTR *)CSTKPTR) = (FX_MARK << 16) | (StkOffset_from_68K(PVAR));	\ ((struct frameex2 *)CSTKPTR)->fnheader = SWAP_WORDS(defcell->defpointer);\  ((DLword *) CSTKPTR) += FRAMESIZE;					\  PVAR = (LispPTR *) CSTKPTR;						\  {register int result;							\   register LispPTR unboundval;						\D 30D 31   unboundval = (LispPTR) 0x0ffffffff;					\D 20   result = LOCFNCELL->pv+1 ;						\   if (closurep)							\	{								\	  HARD_PUSH(closure->env_ptr);					\	  HARD_PUSH(unboundval);					\	  result--;							\	} /* clouserp end */						\E 20I 20   result = LOCFNCELL->pv ;						\E 31I 31   unboundval = (LispPTR) 0xffffffff;					\   result = LOCFNCELL->pv;						\E 31E 30I 30D 33   unboundval = (LispPTR) 0xffffffff;					\   result = LOCFNCELL->pv;						\E 33E 30   HARD_PUSH(closure_env);						\   HARD_PUSH(unboundval);						\E 20D 30D 31   while (result > 0)							\	{								\	   HARD_PUSH(unboundval);					\	   HARD_PUSH(unboundval);					\	   result--;							\	 }	 /*while*/						\E 31I 31   for (; --result >= 0;) {						\       HARD_PUSH(unboundval);						\       HARD_PUSH(unboundval);						\       }								\E 31E 30I 30D 33   for (; --result >= 0;) {						\       HARD_PUSH(unboundval);						\       HARD_PUSH(unboundval);						\       }								\E 33E 30 }	/* result, unboundval block */					\D 41 CSTKPTR += 1 ; 							\E 41I 41 CSTKPTR += 1;								\E 41D 35 PCMAC = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc ;			\E 35I 35 PCMACL = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1;		\E 35D 41 FuncObj = LOCFNCELL  ; 						\E 41I 41 FuncObj = LOCFNCELL;							\E 41I 18 CHECK_INTERRUPT;							\E 18 nextop0;								\} /* end OP_FN_COMMON */I 20D 42/****************************************************************//******			 OP_ENVCALL			 ********//* Environment call on a code object				*//****************************************************************/E 42I 42/************************************************************************//*									*//*			O P _ E N V C A L L				*//*									*//*	Environment call on a code object.  Takes an arg count on	*//*	the stack, along with a pointer to an environment.  If non-	*//*	NIL, the environment is stuffed into the PVAR0 slot of the	*//*	frame. [This NIL check is in the UFN, and seems to be meant	*//*	to allow closures to be called without an environment, without	*//*	the compiler having to emit special code.]			*//*									*//************************************************************************/E 42D 41#define OP_ENVCALL	{ 						\E 41I 41#define OP_ENVCALL	{						\E 41  register struct fnhead *LOCFNCELL;					\  register int NEXTBLOCK;						\  register LispPTR closure_env = TOPOFSTACK;				\D 21  register int num_args = GET_TOS_1;					\  register DefCell *defcell = (DefCell *) GET_TOS_2 ;			\  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(defcell->defpointer) ;\E 21I 21  register int num_args;						\D 41  register LispPTR Fn_DefCell=  GET_TOS_1 ;				\  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(Fn_DefCell) ;		\E 41I 41  register LispPTR Fn_DefCell=  GET_TOS_1;				\  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(Fn_DefCell);		\E 41  N_GETNUMBER(GET_TOS_2, num_args, op_ufn);				\E 21D 22  FN_STACK_CHECK1;							\E 22D 21  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 4;\E 21I 21  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 1;\I 22D 35  FN_CALL_NATIVE_CHECK(LOCFNCELL, -num_args, N_ENVCALL_POP_TEST);	\E 35I 35  FN_CALL_NATIVE_CHECK2(LOCFNCELL, -num_args, N_ENVCALL_POP_TEST);	\E 35  FN_STACK_CHECK;							\E 22E 21  CSTKPTR -= 2;								\D 22  FN_CALL_NATIVE_CHECK(LOCFNCELL, -num_args, native_closure_env=closure_env);\E 22  {register int newivar;						\	(LispPTR *) newivar = IVAR = CSTKPTR-num_args;			\D 41  	BCE_CURRENTFX->nextblock = 					\	NEXTBLOCK = 							\E 41I 41	BCE_CURRENTFX->nextblock =					\	NEXTBLOCK =							\E 41		StkOffset_from_68K(newivar);				\  }									\D 22  FN_STACK_CHECK2;							\E 22  if( LOCFNCELL->na >= 0 )						\  {register int RESTARGS;						\D 41	RESTARGS = num_args - LOCFNCELL->na ;				\	while(RESTARGS <0) { 						\	  HARD_PUSH(NIL_PTR) ;						\E 41I 41	RESTARGS = num_args - LOCFNCELL->na;				\	while(RESTARGS <0) {						\	  HARD_PUSH(NIL_PTR);						\E 41	  RESTARGS++;							\	}								\D 41	CSTKPTR -= (RESTARGS) ;						\E 41I 41	CSTKPTR -= (RESTARGS);						\E 41  } /* if end */							\ /* Set up BF */							\ HARD_PUSH(BF_MARK32 | NEXTBLOCK);					\ *((LispPTR *)CSTKPTR) = (FX_MARK << 16) | (StkOffset_from_68K(PVAR));	\D 21 ((struct frameex2 *)CSTKPTR)->fnheader = SWAP_WORDS(defcell->defpointer);\E 21I 21 ((struct frameex2 *)CSTKPTR)->fnheader = SWAP_WORDS(Fn_DefCell);	\E 21  ((DLword *) CSTKPTR) += FRAMESIZE;					\  PVAR = (LispPTR *) CSTKPTR;						\  {register int result;							\D 30D 31	result = LOCFNCELL->pv+1 ;					\ 	if (result > 0)							\E 31I 31	result = LOCFNCELL->pv;						\D 41 	if (result >= 0)						\E 41I 41	if (result >= 0)						\E 41E 31E 30I 30D 33	result = LOCFNCELL->pv;						\ 	if (result >= 0)						\E 33E 30	  {register LispPTR unboundval;					\D 30D 31	   unboundval = (LispPTR) 0x0ffffffff;				\E 31I 31	   unboundval = (LispPTR) 0xffffffff;				\E 31E 30I 30D 33	   unboundval = (LispPTR) 0xffffffff;				\E 33E 30D 42	   HARD_PUSH(closure_env);					\E 42I 42	   if (closure_env == NIL_PTR) HARD_PUSH(unboundval);		\	     else HARD_PUSH(closure_env);				\E 42	   HARD_PUSH(unboundval);					\D 30D 31	   if (result > 1)						\E 31I 31	   if (result > 0)						\E 31E 30I 30D 33	   if (result > 0)						\E 33E 30	    {HARD_PUSH(unboundval);					\	     HARD_PUSH(unboundval);					\D 30D 31	     result-=2;							\	     while(result > 0) {					\E 31I 31	     result-=1;							\	     for (; --result >= 0;) {					\E 31E 30I 30D 33	     result-=1;							\	     for (; --result >= 0;) {					\E 33E 30	       HARD_PUSH(unboundval);					\	       HARD_PUSH(unboundval);					\D 30D 31	       result--;						\ 	     }								\E 31I 31D 33	     }								\E 33E 31E 30I 30	     }								\E 30D 41 	   }								\ 	 }								\E 41I 41	   }								\	 }								\E 41 }									\D 41 CSTKPTR += 1 ; 							\E 41I 41 CSTKPTR += 1;								\E 41D 35 PCMAC = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc ;			\E 35I 35 PCMACL = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1;		\E 35D 41 FuncObj = LOCFNCELL  ; 						\E 41I 41 FuncObj = LOCFNCELL;							\E 41D 21} /* end OPFN */E 21I 21} /* end OP_ENVCALL */I 26/****************************************************************//******			 EVAL				 ********//****************************************************************/#define EVAL								\{									\ LispPTR scratch;							\D 41 register LispPTR work ;						\E 41I 41 register LispPTR work;							\E 41 register LispPTR lookuped; /* keep looked up value */			\									\  switch(TOPOFSTACK & 0x0ff0000) {					\   case S_POSITIVE :							\D 41   case S_NEGATIVE :	nextop1; 					\E 41I 41   case S_NEGATIVE :	nextop1;					\E 41									\   case ATOMS_OFFSET : if((TOPOFSTACK==NIL_PTR)||(TOPOFSTACK==ATOM_T))	\D 35				nextop1;				\E 35I 35			goto Hack_Label;				\E 35D 27			newframe(CURRENTFX,&scratch,TOPOFSTACK & 0xffff);\E 27I 27D 29			if (nnewframe(CURRENTFX,&scratch,TOPOFSTACK & 0xffff) == -1) goto op_ufn;\E 29I 29			nnewframe(CURRENTFX,&scratch,TOPOFSTACK & 0xffff);\E 29E 27D 41			work =	((scratch & 0xffff0000)>> 16) | 	\				((scratch & 0x00ff) <<16) ;		\E 41I 41			work =	((scratch & 0xffff0000)>> 16) |		\				((scratch & 0x00ff) <<16);		\E 41			lookuped =					\			  *((LispPTR *)(Addr68k_from_LADDR(work)));	\			if(lookuped==NOBIND_PTR) goto op_ufn;		\			TOPOFSTACK = lookuped;				\D 35			nextop1;					\E 35I 35Hack_Label:		nextop1;					\E 35									\   default :		switch(GetTypeNumber(TOPOFSTACK)){		\			  case TYPE_FIXP :				\D 41			  case TYPE_FLOATP : 				\E 41I 41			  case TYPE_FLOATP :				\E 41			  case TYPE_STRINGP :				\			  case TYPE_ONED_ARRAY :			\D 41		  	  case TYPE_GENERAL_ARRAY :	nextop1;	\E 41I 41			  case TYPE_GENERAL_ARRAY :	nextop1;	\E 41									\D 41			  case TYPE_LISTP : 				\E 41I 41			  case TYPE_LISTP :				\E 41				fn_atom_index = ATOM_EVALFORM;		\				fn_num_args = 1;			\				fn_opcode_size = 1;			\				fn_defcell = (DefCell *)		\					GetDEFCELL68k(ATOM_EVALFORM);	\				fn_apply = 0;				\				goto op_fn_common;			\									\			  default :	 goto op_ufn;			\				}					\									\  } /* end switch */							\									\}/* EVAL end */E 26E 21E 20E 7E 1