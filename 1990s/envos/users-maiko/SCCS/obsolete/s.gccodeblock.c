h25332s 00014/00003/00190d D 1.6 90/02/06 11:45:41 sybalsky 6 5c GC of VMEMPAGEPs now workses 00000/00000/00193d D 1.5 89/03/30 13:16:14 sybalsky 5 4c Found word pointers & made to use GETWORD.es 00023/00017/00170d D 1.4 89/03/01 11:04:51 sybalsky 4 3c ci gcreclaimcell.ces 00001/00001/00186d D 1.3 88/12/23 14:50:04 shih 3 2c accidently removed R in Reprobefnes 00000/00002/00187d D 1.2 88/12/23 13:27:41 shih 2 1c removed duplicate sccs stampses 00189/00000/00000d D 1.1 88/12/23 13:25:25 shih 1 0c date and time created 88/12/23 13:25:25 by shiheuUtTI 1D 2/* This is G-file %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 2D 6/* %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 6I 6/* @(#) gccodeblock.c Version 1.5 (3/30/89). copyright Xerox & Fuji Xerox  */static char *id = "@(#) gccodeblock.c	1.5 3/30/89";E 6/************************************************************************//************************************************************************//* Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	*//************************************************************************//* File Name : gccodeblock.c						*//*									*//************************************************************************//*									*//* Creation Date : Sep-25-1987						*//* Written by Tomoru Teruuchi						*//* Edit by Larry Masinter						*//************************************************************************//*									*//* Functions :								*//* reclaimcodeblock();							*//*									*//*									*//*									*//************************************************************************//* \Tomtom								*//************************************************************************/#include "lispemul.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "lispmap.h"#include "stack.h"#include "cell.h"#include "ifpage.h"#include "gc.h"#include "array.h"#define min(a,b)		((a > b)?b:a)#define ENDOFX			0#define GCONST			111D 3#define eprobefn(bits, index)  (((bits^((bits) >> 8)) & min(63, index)) | 1)E 3I 3#define Reprobefn(bits, index)  (((bits^((bits) >> 8)) & min(63, index)) | 1)E 3#define Fn16bits(a, b)          ((a + b) & 0x0ffff)#define Hashingbits(item)       (HILOC(item)^( \	     ((LOLOC(item) & 0x1fff) << 3)^(LOLOC(item) >> 9)))#define Getikvalue(base, index) \        (*( LispPTR *)Addr68k_from_LADDR(base + (index << 1)))D 6E 6I 6#ifndef BYTESWAPE 6typedefstruct implicit_key_hash_table {  LispPTR        base;  unsigned       last_index : 16;  unsigned       num_slots  : 16;  unsigned       num_keys   : 16;  unsigned       null_slots : 16;  LispPTR        key_accessor;} Ikhashtbl;I 6#elsetypedefstruct implicit_key_hash_table {  LispPTR        base;  unsigned       num_slots  : 16;  unsigned       last_index : 16;  unsigned       null_slots : 16;  unsigned       num_keys   : 16;  LispPTR        key_accessor;} Ikhashtbl;#endifE 6unsigned int oplength[256] = {0,0,0,0,0,1,2,2,2,2,2,2,2,3,0,0,0,2,0,0,1,1,0,2,0,0,0,0,0,0,1,0,0,0,0,1,2,9,0,0,9,9,9,9,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,2,0,1,1,0,0,0,2,0,0,0,0,1,1,2,3,9,0,0,0,0,0,0,0,1,1,0,0,0,2,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,2,0,1,1,0,1,1,2,9,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0};typedef ByteCode *InstPtr;map_code_pointers(codeblock, casep)	LispPTR		codeblock;	short		casep;{	InstPtr         codeptr;	register unsigned int opnum;	register unsigned int len;	struct fnhead  *fnbase;	fnbase = (struct fnhead *) Addr68k_from_LADDR(codeblock);	codeptr = ((InstPtr) fnbase) + fnbase->startpc;D 4	while (T) {		switch (opnum=Get_BYTE(codeptr)) {		case ENDOFX:	/* -X- */			return (NIL);		case GCONST:	/* GCONST */			{LispPTR reclaimed = (Get_BYTE(codeptr + 1) << 16) |				 (Get_BYTE(codeptr + 2) << 8) |				 Get_BYTE(codeptr + 3);			if (reclaimed != codeblock)				{htfind(reclaimed, casep);}			};		};		if ((len = oplength[opnum]) > 3) {			error("unrecognized bytecode in compiled code; continue to use UFN length");			oplength[opnum] = len =(((UFN *)UFNTable) + (opnum))->byte_num;			}		codeptr += len + 1;E 4I 4	while (T)	 {	   switch (opnum=Get_BYTE(codeptr))	    {	      case ENDOFX:	/* -X- */		      return (NIL);	      case GCONST:	/* GCONST */		      {LispPTR reclaimed = (Get_BYTE(codeptr + 1) << 16) |			       (Get_BYTE(codeptr + 2) << 8) |			       Get_BYTE(codeptr + 3);		      if (reclaimed != codeblock)			      {htfind(reclaimed, casep);}		      };	    };	  if ((len = oplength[opnum]) > 3)	   {	     char errtext[200];	     sprintf(errtext,		      "Unrecognized bytecode (0%o) in code block x%x,x%x; continue to use UFN length", opnum, (codeblock>>16)&0xFF, codeblock&0xFFFF);	     error(errtext);	     oplength[opnum] = len =(((UFN *)UFNTable) + (opnum))->byte_num;	   }	  codeptr += len + 1;E 4	};}/* JRB - These values are xpointers; their high bytes are not set and	shouldn't be looked at */#define getikkey(value) ((*(LispPTR *)Addr68k_from_LADDR(value)) & 0xffffff)LispPTR remimplicitkeyhash(item, ik_hash_table)LispPTR  item, ik_hash_table;{Ikhashtbl *ik_htable; LispPTR   reprobe, bits, limits, index,           base, value, key_accessor;    ik_htable = (Ikhashtbl *)Addr68k_from_LADDR(ik_hash_table);    bits   =  Hashingbits(item);    limits = ik_htable->last_index;    index  = (bits & limits);    base   = ik_htable->base;    value  = Getikvalue(base, index);    if (value != *Deleted_Implicit_Hash_Slot_word)      { if (value != NIL)	  {if (item ==	       getikkey(value))	     {goto found;};	 }	else	  return(NIL);      };    reprobe = Reprobefn(bits, limits); lp:    index = Fn16bits(index, reprobe) & limits;    value = Getikvalue(base, index);    if (value != *Deleted_Implicit_Hash_Slot_word)      { if (value != NIL)	  {if (item ==	       getikkey(value))	     {goto found;};	 }	else	  return(NIL);      };    goto lp; found:    htfind(*Deleted_Implicit_Hash_Slot_word, ADDREF);    htfind(Getikvalue(base, index), DELREF);    Getikvalue(base, index) = *Deleted_Implicit_Hash_Slot_word;      (ik_htable->num_keys)--;    return (T);}LispPTR reclaimcodeblock(codebase)LispPTR			codebase;{struct fnhead		*fnbase;   if ((*Closure_Cache_Enabled_word != NIL) &&       (remimplicitkeyhash(codebase, *Closure_Cache_word) != NIL))     { return(T);     };   fnbase = (struct fnhead *)Addr68k_from_LADDR(codebase);   htfind((0x0ffffff & fnbase->framename), DELREF);   if (fnbase->startpc != 0)	map_code_pointers(codebase,DELREF);   return(NIL);}E 1