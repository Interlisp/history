h29501s 00000/00000/00191d D 2.3 90/04/19 21:47:44 sybalsky 13 12c AIX/Posix:  Name shortened to fastinline66Kes 00026/00050/00165d D 2.2 88/10/12 14:48:50 krivacic 12 11c new out-of-line interfacees 00000/00000/00215d D 2.1 88/05/17 09:17:41 hayata 11 10c Version up to 2.1es 00026/00018/00189d D 1.10 88/05/16 11:40:28 krivacic 10 9c IPLUS2 IGREATERP IDIFFERENCEes 00001/00001/00206d D 1.9 88/05/13 10:00:41 hayata 9 8c Add SCCS keyides 00000/00000/00207d D 1.8 88/05/04 15:10:11 krivacic 8 7c fix shift bugses 00059/00014/00148d D 1.7 88/04/27 13:33:23 krivacic 7 6c more fast inlines: LOLOC HILOC VAG2...es 00038/00006/00124d D 1.6 88/04/25 21:19:28 krivacic 6 5c fast plus, idifferencenes 00013/00000/00117d D 1.5 88/04/22 19:20:28 krivacic 5 4c inlinedefs re-arrangement & ni removales 00007/00001/00110d D 1.4 88/03/23 10:27:19 krivacic 4 3c added labels for statement not reached warninges 00038/00019/00073d D 1.3 88/03/14 17:39:26 krivacic 3 2c fix / add fast shiftses 00000/00001/00092d D 1.2 88/03/13 13:33:44 hayata 2 1c Change SCCS Key ides 00093/00000/00000d D 1.1 88/03/11 17:58:57 krivacic 1 0c date and time created 88/03/11 17:58:57 by krivaciceuUtTI 1D 4/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 4I 4D 9/* This is G-file @(#) fastinlinedefs68K.h Version 1.3 (3/14/88). copyright Xerox & Fuji Xerox  */E 9I 9/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 9E 4D 2/* This is G-file inlinedefs68K.h Version 1.2 (3/9/88). copyright Xerox & Fuji Xerox  */E 2D 10/* 	inlinedefs68K.h */E 10I 10/* 	fastinlinedefs68K.h */E 10/* 	Bob Krivacic 2/23/88 *//* 	These are the Macros Used to generate inline 68K assembly code.	The call inline code which really CHEATS!	BEWARE the inline code makes many register assumptions! 	Such as:		D7 = TOPOFSTACK		D5 = 15		A3 = CSTKPTR*/#undef DIFFERENCE#define DIFFERENCE {						\	fast_op_difference(POP_TOS_1);				\	nextop1;						\I 4diff_err:							\E 4	asm("diff_err:");					\	asm("addqb #7,d7");					\	asm("rorl d5,d7");					\D 12	TOPOFSTACK = N_OP_difference(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\E 12I 12	N_OP_POPPED_CALL_2(N_OP_difference, GET_POPPED);	\E 12	}I 6#undef IDIFFERENCE#define IDIFFERENCE {						\D 10	fast_op_difference(POP_TOS_1);				\E 10I 10	fast_op_idifference(POP_TOS_1);				\E 10	nextop1;						\I 10idiff_err:							\	asm("idiff_err:");					\	asm("addqb #7,d7");					\	asm("rorl d5,d7");					\D 12	TOPOFSTACK = N_OP_idifference(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\E 12I 12	N_OP_POPPED_CALL_2(N_OP_idifference, GET_POPPED);	\E 12E 10	}#undef IDIFFERENCE_N#define IDIFFERENCE_N(n) {					\D 12	fast_op_idifferencen(n);					\E 12I 12	fast_op_idifferencen(n);				\E 12	nextop2;						\idiffn_err:							\	asm("idiffn_err:");					\	asm("addqb #7,d7");					\	asm("rorl d5,d7");					\D 12	TOPOFSTACK = N_OP_idifferencen(TOPOFSTACK, n, ufn_1d);	\	nextop2;						\E 12I 12	N_OP_CALL_1d(N_OP_idifferencen, n);			\E 12	}D 10#undef PLUS#define PLUS {							\E 10I 10#undef PLUS2#define PLUS2 {							\E 10	fast_op_plus(POP_TOS_1);				\	nextop1;						\plus_err:							\	asm("plus_err:");					\	asm("addqb #7,d7");					\	asm("rorl d5,d7");					\D 10	TOPOFSTACK = N_OP_plus(GET_POPPED, TOPOFSTACK, ufn_2);\E 10I 10D 12	TOPOFSTACK = N_OP_plus2(GET_POPPED, TOPOFSTACK, ufn_2);\E 10	nextop1;						\E 12I 12	N_OP_POPPED_CALL_2(N_OP_plus2, GET_POPPED);		\E 12	}D 10#undef IPLUS#define IPLUS {							\	fast_op_plus(POP_TOS_1);				\E 10I 10#undef IPLUS2D 12#define IPLUS2 {							\E 12I 12#define IPLUS2 {						\E 12	fast_op_iplus(POP_TOS_1);				\E 10	nextop1;						\I 10iplus_err:							\	asm("iplus_err:");					\	asm("addqb #7,d7");					\	asm("rorl d5,d7");					\D 12	TOPOFSTACK = N_OP_iplus2(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\E 12I 12	N_OP_POPPED_CALL_2(N_OP_iplus2, GET_POPPED);		\E 12E 10	}I 7#undef IPLUS_N#define IPLUS_N(n) {						\D 10	fast_op_idifferencen(n);				\E 10I 10	fast_op_iplusn(n);					\E 10	nextop2;						\iplusn_err:							\	asm("iplusn_err:");					\	asm("addqb #7,d7");					\	asm("rorl d5,d7");					\D 12	TOPOFSTACK = N_OP_iplusn(TOPOFSTACK, n, ufn_1d);	\	nextop2;						\E 12I 12	N_OP_CALL_1d(N_OP_iplusn, n);				\E 12	}E 7E 6#undef GREATERP#define	GREATERP {						\	fast_op_greaterp(POP_TOS_1);				\	nextop1;						\I 4greaterp_err:							\E 4	asm("greaterp_err:");					\D 12	TOPOFSTACK = N_OP_greaterp(GET_POPPED, TOPOFSTACK, ufn_2);\D 6	nextop1;						\	}I 5#undef IDIFFERENCE#define IDIFFERENCE {						\	fast_op_difference(POP_TOS_1);				\E 6	nextop1;						\E 12I 12	N_OP_POPPED_CALL_2(N_OP_greaterp, GET_POPPED);		\E 12	}#undef IGREATERP#define	IGREATERP {						\D 10	fast_op_greaterp(POP_TOS_1);				\E 10I 10	fast_op_igreaterp(POP_TOS_1);				\E 10	nextop1;						\I 10igreaterp_err:							\	asm("igreaterp_err:");					\D 12	TOPOFSTACK = N_OP_igreaterp(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\E 12I 12	N_OP_POPPED_CALL_2(N_OP_igreaterp, GET_POPPED);		\E 12E 10	}E 5I 3#undef LRSH8#define LRSH8 {							\	fast_op_lrsh8();					\	nextop1;						\I 4lrsh8_err:							\E 4	asm("lrsh8_err:");					\D 12	TOPOFSTACK = N_OP_lrsh8(TOPOFSTACK, ufn_1);		\	nextop1;						\E 12I 12	N_OP_CALL_1(N_OP_lrsh8);				\E 12	}E 3I 3#undef LRSH1#define LRSH1 {							\	fast_op_lrsh1();					\	nextop1;						\I 4lrsh1_err:							\E 4	asm("lrsh1_err:");					\D 12	TOPOFSTACK = N_OP_lrsh1(TOPOFSTACK, ufn_1);		\	nextop1;						\E 12I 12	N_OP_CALL_1(N_OP_lrsh1);				\E 12	}#undef LLSH8#define LLSH8 {							\	fast_op_llsh8();					\	nextop1;						\I 4llsh8_err:							\E 4	asm("llsh8_err:");					\D 12	TOPOFSTACK = N_OP_llsh8(TOPOFSTACK, ufn_1);		\	nextop1;						\E 12I 12	N_OP_CALL_1(N_OP_llsh8);				\E 12	}#undef LLSH1#define LLSH1 {							\	fast_op_llsh1();					\	nextop1;						\I 4llsh1_err:							\E 4	asm("llsh1_err:");					\D 12	TOPOFSTACK = N_OP_llsh1(TOPOFSTACK, ufn_1);		\	nextop1;						\E 12I 12	N_OP_CALL_1(N_OP_llsh1);				\E 12	}D 7E 3/*E 7I 7#undef LOGORE 7#define LOGOR { 						\D 7	TOPOFSTACK = op_logor(POP_TOS_1, TOPOFSTACK);		\E 7I 7	fast_op_logor(POP_TOS_1);				\E 7	nextop1;						\I 7logor_err:							\E 7	asm("logor_err:");					\I 7	asm("rorl d5,d7");					\E 7D 12	TOPOFSTACK = N_OP_logor(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\E 12I 12	N_OP_POPPED_CALL_2(N_OP_logor, GET_POPPED);		\E 12	} I 7#undef LOGANDE 7#define LOGAND {						\D 7	TOPOFSTACK = op_logand(POP_TOS_1, TOPOFSTACK);		\E 7I 7	fast_op_logand(POP_TOS_1);				\E 7	nextop1;						\I 7logand_err:							\E 7	asm("logand_err:");					\I 7	asm("rorl d5,d7");					\E 7D 12	TOPOFSTACK = N_OP_logand(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\E 12I 12	N_OP_POPPED_CALL_2(N_OP_logand, GET_POPPED);		\E 12	}D 7D 3#define LRSH8 {							\	TOPOFSTACK = lrsh8(TOPOFSTACK);				\	nextop1;						\	}#define LRSH1 {							\	TOPOFSTACK = lrsh1(TOPOFSTACK);				\	nextop1;						\	}#define LLSH8 {							\	TOPOFSTACK = llsh8(TOPOFSTACK);				\	nextop1;						\	}#define LLSH1 {							\	TOPOFSTACK = llsh1(TOPOFSTACK);				\	nextop1;						\	}E 3E 7I 7#undef LOGXOR#define LOGXOR { 						\	fast_op_logxor(POP_TOS_1);				\	nextop1;						\logxor_err:							\	asm("logxor_err:");					\	asm("rorl d5,d7");					\D 12	TOPOFSTACK = N_OP_logxor(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\E 12I 12	N_OP_POPPED_CALL_2(N_OP_logxor, GET_POPPED);		\E 12	} D 12#undef ADDBASEE 7#define ADDBASE {						\E 12I 12#undef N_OP_ADDBASE#define N_OP_ADDBASE {						\E 12D 7	TOPOFSTACK = addbase(POP_TOS_1, TOPOFSTACK);		\E 7I 7	fast_op_addbase(POP_TOS_1);				\E 7	nextop1;						\I 7addbase_err:							\	asm("addbase_err:");					\	asm("addqb #7,d7");					\	asm("rorl d5,d7");					\D 12	TOPOFSTACK = N_OP_addbase(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\E 12I 12	N_OP_POPPED_CALL_2(N_OP_addbase, GET_POPPED);		\E 12E 7	}D 7#define LOLOC	{ TOPOFSTACK = loloc(TOPOFSTACK); nextop1; }#define HILOC	{ TOPOFSTACK = hiloc(TOPOFSTACK); nextop1; }#define VAG2	{ TOPOFSTACK = vag2(POP_TOS_1, TOPOFSTACK); nextop1; }E 7I 7D 12#undef LOLOC#define LOLOC	{ fast_op_loloc(); nextop1; }#undef HILOC#define HILOC	{ fast_op_hiloc(); nextop1; }#undef VAG2#define VAG2	{ fast_op_vag2(POP_TOS_1); nextop1; }E 12I 12#undef N_OP_LOLOC#define N_OP_LOLOC	{ fast_op_loloc(); nextop1; }#undef N_OP_HILOC#define N_OP_HILOC	{ fast_op_hiloc(); nextop1; }#undef N_OP_VAG2#define N_OP_VAG2	{ fast_op_vag2(POP_TOS_1); nextop1; }E 12E 7D 7#define LISTP	{ TOPOFSTACK = listp(TOPOFSTACK); nextop1;}#define NTYPEX	{ TOPOFSTACK = ntypex(TOPOFSTACK); nextop1; }#define TYPEP	{ TOPOFSTACK = typep(TOPOFSTACK, *(PCMAC+1)); nextop2; }E 7I 7D 12/*#undef LISTP#define LISTP	{ fast_op_listp(); nextop1;}#undef NTYPEX#define NTYPEX	{ fast_op_ntypex(); nextop1; }#undef TYPEP#define TYPEP(x) { fast_op_typep(); nextop2; }D 10*//*E 7#define FN3	{ registers; CHECK_INTERRUPT; fn3(); NATIVECHECK; }#define RETURN	{ opreturn(); NATIVECHECK; }E 10*/E 12E 1