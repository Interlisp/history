h17357s 00002/00002/00476d D 2.29 88/10/05 18:15:15 krivacic 51 50c sun3 & sun4 mergees 00121/00074/00357d D 2.28 88/10/05 17:02:45 krivacic 50 49c sun 3 / 4 mergees 00003/00004/00428d D 2.27 88/10/04 13:50:49 krivacic 49 48c fix fmemb / lispget problemses 00001/00001/00431d D 2.26 88/09/15 12:38:18 krivacic 48 47c fix unwindbug error  (ar pending)es 00001/00001/00431d D 2.25 88/08/16 18:27:21 krivacic 47 46c fix # args on sixspn call of unwindes 00019/00007/00413d D 2.24 88/07/27 17:38:47 shimizu 46 45c Add exception2C: for N_OP_listget;FMEMB,LISTGET,CLFMEMB,CLASSOC punt address are changedes 00007/00003/00413d D 2.23 88/07/27 14:52:07 shimizu 45 44c N_OP_assoc punt to exception_2;and be able to continue the execution.es 00002/00000/00414d D 2.22 88/07/25 16:53:44 hayata 44 43c Define of GETBASEBYTE, PUTBASEBYTE and PUTNITS_N_M are commented out. They are defined in inlinedefsC.hes 00000/00006/00414d D 2.21 88/07/05 11:41:22 charnley 43 42c added DTEST inline.es 00000/00004/00420d D 2.20 88/07/01 19:21:13 shih 42 41c added bin opcode inline, so removed BIN from herees 00000/00006/00424d D 2.19 88/07/01 10:46:17 charnley 41 40c fixed version problemes 00000/00000/00430d D 2.18 88/07/01 10:39:25 charnley 40 39c deleteed old FVARX macro, for putting FVARX inline.es 00000/00006/00430d D 2.17 88/06/28 19:12:25 charnley 39 38c part of fvar inline.es 00000/00004/00436d D 2.16 88/06/27 17:04:38 charnley 38 37c put aref1 inline.es 00000/00004/00440d D 2.15 88/06/27 12:44:41 charnley 37 36c putting cl:= <377> smallp cases inline.es 00005/00005/00439d D 2.14 88/06/20 20:43:21 bane 36 35c Commented out OPCAR and OPCDR to allow inline defs to workes 00004/00000/00440d D 2.13 88/06/20 13:16:50 charnley 35 34c reenabled array ops once again.es 00007/00000/00433d D 2.12 88/06/15 21:17:35 krivacic 34 33c make rplcons use an error exites 00003/00003/00430d D 2.11 88/06/15 15:22:15 charnley 33 32c changed fvar calls to be without err addrs, they can't ufn.es 00005/00000/00428d D 2.10 88/06/15 11:19:03 charnley 32 31c enabled aref2 opcode.es 00003/00005/00425d D 2.9 88/06/15 10:06:07 charnley 31 30c reenabled UNWIND,  and fixed.es 00004/00000/00426d D 2.8 88/06/11 11:54:10 charnley 30 29c enabled restlist opcode.es 00002/00006/00424d D 2.7 88/06/10 10:58:55 charnley 29 28c re-enabled the array ops.  all are in now.es 00004/00014/00426d D 2.6 88/06/09 22:57:19 masinter 28 27c remove use of suspicious (but currently working) POP in blt & bitblt; remove unused VAG2 def; make DONSOPS an ifdefes 00015/00000/00425d D 2.5 88/06/02 17:03:44 charnley 27 26c added unboxed opcodeses 00017/00055/00408d D 2.4 88/05/31 20:31:00 masinter 26 25c make UFN go to common tail for stack overflow, native code checkes 00003/00001/00460d D 2.3 88/05/31 14:23:27 krivacic 25 24c ARG0 & PILOTBITBLTes 00010/00008/00451d D 2.2 88/05/27 15:02:08 krivacic 24 23c C version of VAG2 & CONSes 00000/00000/00459d D 2.1 88/05/17 09:18:49 hayata 23 22c Version up to 2.1es 00018/00016/00441d D 1.22 88/05/16 11:40:59 krivacic 22 21c calls to N_OP_iremainder N_OP_igreaterp N_OP_itimes2 ...es 00020/00000/00437d D 1.21 88/05/10 11:30:52 charnley 21 20c added FPLUS opcode family (5 ops)es 00020/00000/00417d D 1.20 88/05/06 16:40:39 charnley 20 19c turned on 3 eq ops + clfmemb and classoces 00001/00001/00416d D 1.19 88/05/02 14:55:45 masinter 19 18c fix bug in Listgetes 00004/00000/00413d D 1.18 88/05/02 10:27:47 masinter 18 17c temporarily comment out dons ops until reference count problem fixedes 00002/00002/00411d D 1.17 88/04/29 17:57:57 shimizu 17 16c Def for UNWIND is commented out(temp)es 00000/00005/00413d D 1.16 88/04/26 10:40:12 masinter 16 15c Turn back on new UNWIND interfacees 00004/00004/00414d D 1.15 88/04/25 19:32:22 krivacic 15 14c fix difference.n & plus.nes 00004/00001/00414d D 1.14 88/04/25 11:40:13 krivacic 14 13c LSH macroes 00091/00151/00324d D 1.13 88/04/22 19:21:26 krivacic 13 12c inlinedefs re-arrangement & ni removales 00005/00003/00470d D 1.12 88/04/14 15:48:35 krivacic 12 11c blt & pilotbitblt & createcell back ines 00019/00002/00454d D 1.11 88/04/14 14:41:26 krivacic 11 10c pilogbitblt & blt callses 00028/00000/00428d D 1.10 88/03/31 19:34:29 krivacic 10 9c FVar ops & stkscanes 00094/00006/00334d D 1.9 88/03/31 15:10:31 krivacic 9 8c storen, copyn, arg0, assoces 00025/00000/00315d D 1.8 88/03/31 11:07:59 krivacic 8 7c rplconses 00052/00000/00263d D 1.7 88/03/31 10:06:14 krivacic 7 6c N interfaces for get&put byteses 00012/00002/00251d D 1.6 88/03/29 18:47:58 krivacic 6 5c cons, eqlop, findkey, gvar_, rplptr, listget, fmemb, hiloc, loloces 00053/00004/00200d D 1.5 88/03/29 17:29:18 krivacic 5 4c temp cies 00003/00004/00201d D 1.4 88/03/28 19:19:38 krivacic 4 3c bind ops N_OP interfacees 00021/00001/00184d D 1.3 88/03/28 15:20:29 krivacic 3 2c temp cies 00006/00001/00179d D 1.2 88/03/28 11:39:27 krivacic 2 1c op_ufn labeles 00180/00000/00000d D 1.1 88/03/23 10:10:42 krivacic 1 0c date and time created 88/03/23 10:10:42 by krivaciceuUtTI 1/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */D 3/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 3/* 	n_op_inlinedefsC.h *//* 	Bob Krivacic 2/23/88 */D 13/* 	These are the Macros Used to generate inline c code.E 13I 13/* 	E 13	These use the N_OP interface of the opcodes.I 13D 50	They REQUIRE the fixsp() inline ASSEMBLY routines to operate!E 50I 50	They used to require the fixsp() inline ASSEMBLY routines to operate!E 50E 13*/#undef ATOMCELL_N#undef DIFFERENCED 13#undef PLUS	#undef GREATERP#undef IPLUS_NE 13I 13#undef PLUS2	E 13#undef QUOTIENT  #undef TIMES2	 I 13#undef GREATERPD 22#undef IDIFFERENCE#undef IPLUS2	#undef IQUOTIENT  #undef ITIMES2	 #undef IGREATERPE 22#undef IPLUS_NE 13D 22#undef IREMAINDER E 22#undef IDIFFERENCE_N#undef MAKENUMBER#undef BOXIPLUS#undef BOXIDIFFERENCE#undef LRSH1#undef LRSH8#undef LLSH1#undef LLSH8							D 5#undef OPCAR#undef OPCDR#undef RPLACA#undef RPLACDE 5D 42#undef BINE 42#undef UFN_CALLSI 50#define GCREF(n)							\	{TOPOFSTACK = htfind(TOPOFSTACK, n);				\	nextop2;}E 50#define ATOMCELL_N(n)							\D 50	{TOPOFSTACK = N_OP_atomcellN(TOPOFSTACK, n, ufn_1d);		\	 nextop2;							\E 50I 50	{if (TOPOFSTACK & 0xffff0000) {goto op_ufn;}			\	TOPOFSTACK = (n << 16) + (TOPOFSTACK << 1) ;			\	nextop2;							\E 50	}#define DIFFERENCE							\D 50	{TOPOFSTACK = N_OP_difference(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50I 50	{SV; TOPOFSTACK = N_OP_difference(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50	nextop1;							\	}I 50#define LOGOR {SV; TOPOFSTACK = N_OP_logor(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;							\	}E 50I 50#define LOGAND {SV; TOPOFSTACK = N_OP_logand(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;							\	}#define LOGXOR {SV; TOPOFSTACK = N_OP_logxor(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;							\	}E 50D 13#define PLUS								\E 13I 13#define PLUS2								\E 13D 50	{TOPOFSTACK = N_OP_plus2(POP_TOS_1, TOPOFSTACK, ufn_2);		\E 50I 50	{SV; TOPOFSTACK = N_OP_plus2(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50	nextop1;							\	}I 13#define QUOTIENT							\D 50	{TOPOFSTACK = N_OP_quot(POP_TOS_1, TOPOFSTACK, ufn_2); 		\E 50I 50	{SV; TOPOFSTACK = N_OP_quot(POP_TOS_1, TOPOFSTACK, ufn_2); 	\E 50	nextop1;							\	}#define TIMES2								\D 50	{TOPOFSTACK = N_OP_times2(POP_TOS_1, TOPOFSTACK, ufn_2); 	\E 50I 50	{SV; TOPOFSTACK = N_OP_times2(POP_TOS_1, TOPOFSTACK, ufn_2); 	\E 50	nextop1;							\	}E 13#define	GREATERP							\D 50	{TOPOFSTACK = N_OP_greaterp(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50I 50	{SV; TOPOFSTACK = N_OP_greaterp(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50	nextop1;							\	}I 22D 24/*E 24I 24E 24#undef IDIFFERENCE#undef IPLUS2	#undef IQUOTIENT  #undef ITIMES2	 #undef IGREATERP#undef IREMAINDER E 22I 22E 22D 13#define IPLUS_N(n)							\	{TOPOFSTACK = N_OP_iplusn(TOPOFSTACK, n, ufn_1);		\E 13I 13#define IDIFFERENCE							\D 22	{TOPOFSTACK = N_OP_difference(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 22I 22D 50	{TOPOFSTACK = N_OP_idifference(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50I 50	{SV; TOPOFSTACK = N_OP_idifference(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50E 22E 13	nextop1;							\	}D 13#define IDIFFERENCE_N(n)						\	{TOPOFSTACK = N_OP_difference(TOPOFSTACK, n, ufn_1);		\E 13I 13#define IPLUS2								\D 22	{TOPOFSTACK = N_OP_plus2(POP_TOS_1, TOPOFSTACK, ufn_2);		\E 22I 22D 50	{TOPOFSTACK = N_OP_iplus2(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50I 50	{SV; TOPOFSTACK = N_OP_iplus2(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50E 22E 13	nextop1;							\	}D 13#define QUOTIENT							\E 13I 13#define IQUOTIENT							\E 13D 22	{TOPOFSTACK = N_OP_quot(POP_TOS_1, TOPOFSTACK, ufn_2); 		\E 22I 22D 50	{TOPOFSTACK = N_OP_iquot(POP_TOS_1, TOPOFSTACK, ufn_2); 	\E 50I 50	{SV; TOPOFSTACK = N_OP_iquot(POP_TOS_1, TOPOFSTACK, ufn_2); 	\E 50E 22	nextop1;							\	}D 13#define TIMES2								\E 13I 13#define ITIMES2								\E 13D 22	{TOPOFSTACK = N_OP_times2(POP_TOS_1, TOPOFSTACK, ufn_2); 	\E 22I 22D 50	{TOPOFSTACK = N_OP_itimes2(POP_TOS_1, TOPOFSTACK, ufn_2); 	\E 50I 50	{SV; TOPOFSTACK = N_OP_itimes2(POP_TOS_1, TOPOFSTACK, ufn_2); 	\E 50E 22	nextop1;							\	}I 13#define	IGREATERP							\D 22	{TOPOFSTACK = N_OP_greaterp(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 22I 22D 50	{TOPOFSTACK = N_OP_igreaterp(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50I 50	{SV; TOPOFSTACK = N_OP_igreaterp(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50E 22	nextop1;							\	}I 22#define IREMAINDER							\D 50	{TOPOFSTACK = N_OP_iremainder(POP_TOS_1, TOPOFSTACK, ufn_2); 	\E 50I 50	{SV; TOPOFSTACK = N_OP_iremainder(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50	nextop1;							\	}E 22I 22D 24*/E 24E 22I 24E 24#define IPLUS_N(n)							\D 15	{TOPOFSTACK = N_OP_iplusn(TOPOFSTACK, n, ufn_1);		\	nextop1;							\E 15I 15D 50	{TOPOFSTACK = N_OP_iplusn(TOPOFSTACK, n, ufn_1d);		\E 50I 50	{SV; TOPOFSTACK = N_OP_iplusn(TOPOFSTACK, n, ufn_1d);		\E 50	nextop2;							\E 15	}#define IDIFFERENCE_N(n)						\D 14	{TOPOFSTACK = N_OP_difference(TOPOFSTACK, n, ufn_1);		\E 14I 14D 15	{TOPOFSTACK = N_OP_idifferencen(TOPOFSTACK, n, ufn_1);		\E 14	nextop1;							\E 15I 15D 50	{TOPOFSTACK = N_OP_idifferencen(TOPOFSTACK, n, ufn_1d);		\E 50I 50	{SV; TOPOFSTACK = N_OP_idifferencen(TOPOFSTACK, n, ufn_1d);	\E 50	nextop2;							\E 15D 22	}E 13#define IREMAINDER							\	{TOPOFSTACK = N_OP_remainder(POP_TOS_1, TOPOFSTACK, ufn_2); 	\	nextop1;							\E 22	}#define LRSH1								\D 50	{TOPOFSTACK = N_OP_lrsh1(TOPOFSTACK, ufn_1);			\E 50I 50	{SV; TOPOFSTACK = N_OP_lrsh1(TOPOFSTACK, ufn_1);		\E 50	nextop1;							\	}#define LRSH8								\D 50	{TOPOFSTACK = N_OP_lrsh8(TOPOFSTACK, ufn_1);			\E 50I 50	{SV; TOPOFSTACK = N_OP_lrsh8(TOPOFSTACK, ufn_1);		\E 50	nextop1;							\	}#define LLSH1								\D 50	{TOPOFSTACK = N_OP_llsh1(TOPOFSTACK, ufn_1);			\E 50I 50	{SV; TOPOFSTACK = N_OP_llsh1(TOPOFSTACK, ufn_1);		\E 50	nextop1;							\	}#define LLSH8								\D 50	{TOPOFSTACK = N_OP_llsh8(TOPOFSTACK, ufn_1);			\E 50I 50	{SV; TOPOFSTACK = N_OP_llsh8(TOPOFSTACK, ufn_1);		\E 50	nextop1;							\	}I 14#undef LSHD 50#define LSH	{ TOPOFSTACK = N_OP_lsh(POP_TOS_1,TOPOFSTACK,ufn_2); nextop1; }E 50I 50#define LSH	{SV;  TOPOFSTACK = N_OP_lsh(POP_TOS_1,TOPOFSTACK,ufn_2); nextop1; }E 50E 14I 36/* removing OPCAR and OPCDR; they are now inline code in inlinedefsC.h *//* #undef OPCAR *//* #define OPCAR	{ TOPOFSTACK = N_OP_car(TOPOFSTACK, ufn_1); nextop1; } */E 36I 5D 36#undef OPCARE 5#define OPCAR	{ TOPOFSTACK = N_OP_car(TOPOFSTACK, ufn_1); nextop1; }I 5#undef OPCDRE 5#define OPCDR	{ TOPOFSTACK = N_OP_cdr(TOPOFSTACK, ufn_1); nextop1; }E 36I 36/* #undef OPCDR *//* #define OPCDR	{ TOPOFSTACK = N_OP_cdr(TOPOFSTACK, ufn_1); nextop1; } */E 36I 5#undef RPLACAE 5#define RPLACA								\D 50	{TOPOFSTACK = N_OP_rplaca(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50I 50	{SV; TOPOFSTACK = N_OP_rplaca(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50	 nextop1;							\	}I 5#undef RPLACDE 5#define RPLACD								\D 50	{TOPOFSTACK = N_OP_rplacd(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50I 50	{SV; TOPOFSTACK = N_OP_rplacd(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50	 nextop1; 							\	}I 34#undef RPLCONS#define RPLCONS								\D 50	{ TOPOFSTACK = N_OP_rplcons(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50I 50	{ SV; TOPOFSTACK = N_OP_rplcons(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50	  nextop1;							\	}D 42E 34I 5D 24#undef CONS#define CONS								\	{ TOPOFSTACK = N_OP_cons(POP_TOS_1, TOPOFSTACK);		\	  nextop1;							\	}E 24E 5#define BIN		{ TOPOFSTACK = N_OP_bin(TOPOFSTACK, ufn_1); nextop1; }E 42#define MAKENUMBER 							\D 50		{TOPOFSTACK = N_OP_makenumber(POP_TOS_1,TOPOFSTACK,ufn_2);\E 50I 50		{SV; TOPOFSTACK = N_OP_makenumber(POP_TOS_1,TOPOFSTACK,ufn_2);\E 50		 nextop1;						\		}#define BOXIPLUS							\D 50		{TOPOFSTACK = N_OP_boxiplus(POP_TOS_1,TOPOFSTACK,ufn_2);\E 50I 50		{SV; TOPOFSTACK = N_OP_boxiplus(POP_TOS_1,TOPOFSTACK,ufn_2);\E 50		nextop1;						\		}#define BOXIDIFFERENCE							\D 50		{TOPOFSTACK = N_OP_boxidiff(POP_TOS_1,TOPOFSTACK,ufn_2);\E 50I 50		{SV; TOPOFSTACK = N_OP_boxidiff(POP_TOS_1,TOPOFSTACK,ufn_2);\E 50		nextop1;						\		}I 3D 4/*E 4I 4E 4D 13#undef BIND#define BIND	{							\		 CSTKPTR = (LispPTR *) N_OP_bind(CSTKPTR, TOPOFSTACK, 	\				Get_BYTE(PCMAC+1), Get_BYTE(PCMAC+2));	\D 4		 POP;							\E 4I 4		 TOPOFSTACK = *CSTKPTR;					\E 4		 nextop3;						\		}E 3I 3#undef UNBIND#define UNBIND	{							\		 CSTKPTR = (LispPTR *) N_OP_unbind(CSTKPTR);		\D 4		 POP;							\E 4		 nextop1;						\		}I 4E 4#undef DUNBIND#define DUNBIND	{							\		 CSTKPTR = (LispPTR *) N_OP_dunbind(CSTKPTR, TOPOFSTACK);\		 POP;							\		 nextop1;						\		}E 13I 5#undef EQLOP#define EQLOP	{							\D 50		 TOPOFSTACK = N_OP_eqlop(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50I 50		 SV; TOPOFSTACK = N_OP_eqlop(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 50		 nextop1;						\		}D 13#undef FINDKEY#define FINDKEY(x)							\		{							\		 TOPOFSTACK = N_OP_findkey(TOPOFSTACK, x);		\		 nextop2;						\		}D 6E 6#undef GVAR_#define GVAR_(atom_index)						\		{							\		 TOPOFSTACK = N_OP_gvar_(TOPOFSTACK, atom_index);	\		 nextop3;						\		}#undef RPLPTR#define RPLPTR(n)							\		{							\		 TOPOFSTACK = N_OP_rplptr(POP_TOS_1, TOPOFSTACK, n);	\		 nextop2;						\		}E 13#undef FMEMB#define FMEMB								\		{							\D 46		 TOPOFSTACK = N_OP_fmemb(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 46I 46D 50		 TOPOFSTACK = N_OP_fmemb(POP_TOS_1, TOPOFSTACK, exception_2);	\E 50I 50		 SV; TOPOFSTACK = N_OP_fmemb(POP_TOS_1, TOPOFSTACK, exception_2);	\E 50E 46		 nextop1;						\		}#undef LISTGET#define LISTGET								\		{							\D 19		 TOPOFSTACK = N_OP_fmemb(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 19I 19D 46		 TOPOFSTACK = N_OP_listget(POP_TOS_1, TOPOFSTACK, ufn_2);\E 46I 46D 50		 TOPOFSTACK = N_OP_listget(POP_TOS_1, TOPOFSTACK, exception_2C);\E 50I 50		 SV; TOPOFSTACK = N_OP_listget(POP_TOS_1, TOPOFSTACK, exception_2C);\E 50E 46E 19		 nextop1;						\		}E 5D 4*/E 4E 3D 6E 6I 6D 13#undef HILOC#define HILOC								\		{							\		 TOPOFSTACK = GetHiWord(TOPOFSTACK) | S_POSITIVE;	\		 nextop1;						\		}#undef LOLOC#define LOLOC								\		{							\		 TOPOFSTACK = GetLoWord(TOPOFSTACK) | S_POSITIVE;	\		 nextop1;						\		}E 6E 13I 7#undef DRAWLINE	#define DRAWLINE							\		{							\D 13		 TOPOFSTACK = N_OP_draw(				\E 13I 13D 50		 TOPOFSTACK = N_OP_drawline(				\E 13			POP_TOS_1, POP_TOS_1, POP_TOS_1, POP_TOS_1,	\			POP_TOS_1, POP_TOS_1, POP_TOS_1, POP_TOS_1,	\			TOPOFSTACK, ufn_9);				\		 nextop1;						\E 50I 50		 SV; TOPOFSTACK = N_OP_drawline(			\		 *(CSTKPTR-8), *(CSTKPTR-7), *(CSTKPTR-6),		\		 *(CSTKPTR-5), *(CSTKPTR-4), *(CSTKPTR-3), *(CSTKPTR-2),\		 *(CSTKPTR-1), TOPOFSTACK, ufn_9);			\		 CSTKPTR -= 8; nextop1;					\E 50		}#undef ADDBASE#define ADDBASE								\D 50		{ 							\E 50I 50		{ SV; 							\E 50		 TOPOFSTACK = N_OP_addbase(POP_TOS_1, TOPOFSTACK, ufn_2);\		 nextop1;						\		}I 44/*** [HH: 22-Jul-88] Inline code of these opcodes are made in inlinedefsC.hE 44#undef GETBASEBYTE#define GETBASEBYTE							\D 50		{							\E 50I 50		{SV; 							\E 50		 TOPOFSTACK = N_OP_getbasebyte(POP_TOS_1, TOPOFSTACK, ufn_2);\		 nextop1;						\		}#undef PUTBASEBYTE#define PUTBASEBYTE							\D 50		{							\E 50I 50		{	SV; 						\E 50		 TOPOFSTACK = N_OP_putbasebyte(				\D 51			POP_TOS_1, POP_TOS_1, TOPOFSTACK, ufn_3);	\		 nextop1;						\E 51I 51			*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, ufn_3);	\		 CSTKPTR-=2; nextop1;					\E 51		}D 13#undef GETBITS_N_M#define GETBITS_N_M(a, b)						\		{							\		 TOPOFSTACK = N_OP_getbitsnfd(TOPOFSTACK, a, b);	\		 nextop3;						\		}E 13#undef PUTBITS_N_M#define PUTBITS_N_M(a, b)						\D 50		{							\E 50I 50		{	SV; 						\E 50		 TOPOFSTACK = N_OP_putbitsnfd(POP_TOS_1, TOPOFSTACK, a, b, ufn_2d2);\		 nextop3;						\		}I 44****/E 44I 8D 13#undef RPLCONS#define RPLCONS								\	{ TOPOFSTACK = N_OP_rplcons(POP_TOS_1, TOPOFSTACK);		\	  nextop1;							\	}D 9/*E 9#define MYALINK								\	{								\D 9	 PUSH(((( CURRENTFX-> alink) & 0xfffe)-FRAMESIZE) | S_POSITIVE);\E 9I 9	 PUSH(((( CURRENTFX->alink) & 0xfffe)-FRAMESIZE) | S_POSITIVE);	\E 9	 nextop1;							\	}I 9E 9#define MYARGCOUNT							\	{ register int arg_num;						\	  if (( CURRENTFX->alink & 1) == 0)				\D 9	    arg_num = (int)(CURRENTFX - 1);				\E 9I 9	    arg_num = (int)((LispPTR *)(CURRENTFX) - 1);				\E 9 	  else								\	    arg_num = (int)(Stackspace + CURRENTFX->blink);		\	 PUSH( (DLword)((arg_num - (int)IVar) >> 2) | S_POSITIVE);	\	 nextop1;							\	}D 9*/#define MYALINK		{goto ni; }#define MYARGCOUNT	{goto ni; }E 9I 9#define RCLK								\	{								\	 TOPOFSTACK = N_OP_rclk(TOPOFSTACK);				\	 nextop1;							\	}#undef LISTP#undef NTYPEX#undef TYPEPE 13D 43#undef DTESTD 13#define LISTP	{							\		 if((unsigned int)GetTypeNumber(TOPOFSTACK) != TYPE_LISTP)\    			TOPOFSTACK = NIL_PTR;				\		 nextop1;						\		}E 13D 16E 16D 13#define NTYPEX								\		{							\		 TOPOFSTACK = S_POSITIVE | (unsigned int)(GetTypeNumber(TOPOFSTACK));\		nextop1;						\		}#define TYPEP(n) 							\		{							\		  if((DLword)GetTypeNumber(TOPOFSTACK) != n)		\    			TOPOFSTACK = NIL_PTR;				\		 nextop2;						\		}E 13#define DTEST(atom_index)						\		{							\		 TOPOFSTACK = N_OP_dtest(TOPOFSTACK,atom_index,ufn_1d);	\		 nextop3;						\		}E 43D 17E 17I 17D 25/* Temp commented out *********E 25I 25D 31/*E 31E 25E 17D 13#undef TYPEMASK#define TYPEMASK(n) 							\		{							\  		 if( ( ((DLword)GetTypeEntry(TOPOFSTACK))  & 		\		     ( (DLword)n << 8)) == 0)				\    			TOPOFSTACK = NIL_PTR;				\		 nextop2;						\		}E 13I 13D 16/* TEMP Turn off unwind until tested more E 13E 16D 13#undef INSTANCEP#define INSTANCEP(atom_index)						\		{							\		 TOPOFSTACK = N_OP_instancep(TOPOFSTACK,atom_index);	\		 nextop3;						\		}E 13D 11E 11#undef UNWINDI 11D 13/*E 13I 13D 16E 16E 13E 11D 31#define UNWIND(n)							\E 31I 31#define UNWIND(n, m)							\E 31D 50		{							\E 50I 50		{	SV; 						\E 50		 CSTKPTR = (LispPTR *)					\D 31			N_OP_unwind(CSTKPTR, TOPOFSTACK, n, unwind_err);\E 31I 31			N_OP_unwind(CSTKPTR, TOPOFSTACK, n, m, unwind_err);\E 31D 11		 TOPOFSTACK = *(CSTKPTR - 1);				\E 11I 11D 48		 TOPOFSTACK = *CSTKPTR;				\E 48I 48		 POP;				\E 48E 11D 31		 nextop2;						\E 31I 31		 nextop3;						\E 31		}I 11D 16*/E 16D 13#define UNWIND(n)	{goto ni;}E 13E 11D 17E 17I 17D 31*/E 31I 25#undef ARG0E 25E 17I 11D 13E 11#undef STOREN#define STOREN(n)							\		{ *(CSTKPTR  - ((n+2) >> 1)) = TOPOFSTACK;		\		 nextop2;						\		}#undef COPYN#define COPYN(n)							\		{ PUSH(*(CSTKPTR  - ((n+2) >> 1)));			\		 nextop2;						\		}E 13#define ARG0								\D 50		{ TOPOFSTACK = N_OP_arg0(TOPOFSTACK, ufn_1);		\E 50I 50		{ SV; TOPOFSTACK = N_OP_arg0(TOPOFSTACK, ufn_1);	\E 50		 nextop1;						\		}#undef ASSOC#define ASSOC								\D 45		{TOPOFSTACK = N_OP_assoc(POP_TOS_1, TOPOFSTACK, ufn_2);	\E 45I 45D 50		{TOPOFSTACK = N_OP_assoc(POP_TOS_1, TOPOFSTACK, exception_2);	\E 50I 50		{SV; TOPOFSTACK = N_OP_assoc(POP_TOS_1, TOPOFSTACK, exception_2);\E 50E 45		 nextop1;						\		}D 13E 13I 13D 39/* check these out -- is there really an error case ??? */E 13I 10#undef FVAR#define FVAR(n)								\D 33		{PUSH(N_OP_fvarn(n << 1, ufn_d));			\E 33I 33		{PUSH(N_OP_fvarn(n << 1));			\E 33		 nextop1;						\		}E 39D 41#undef FVARX#define FVARX(n)							\D 33		{PUSH(N_OP_fvarn(n, ufn_d));				\E 33I 33		{PUSH(N_OP_fvarn(n));				\E 33		 nextop2;						\		}E 10E 41I 10#undef STKSCAN#define STKSCAN								\D 50		{TOPOFSTACK = N_OP_stkscan(TOPOFSTACK, ufn_1);		\E 50I 50		{SV; TOPOFSTACK = N_OP_stkscan(TOPOFSTACK, ufn_1);	\E 50		 nextop1;						\		}E 10I 10#undef FVARX_#define FVARX_(n)							\D 33		{TOPOFSTACK = N_OP_fvar_(TOPOFSTACK, n, ufn_1d);	\E 33I 33D 50		{TOPOFSTACK = N_OP_fvar_(TOPOFSTACK, n);	\E 50I 50		{TOPOFSTACK = N_OP_fvar_(TOPOFSTACK, n);		\E 50E 33		 nextop2;						\		}E 10I 13D 50/* probably doesn't need a UFN case */E 50E 13I 10I 11#undef BLT#define BLT								\D 28		{TOPOFSTACK = N_OP_blt(POP, POP, TOPOFSTACK, ufn_3);	\E 28I 28D 50		{TOPOFSTACK = N_OP_blt(POP_TOS_1, POP_TOS_1, TOPOFSTACK, ufn_3);\E 28		 nextop1;						\E 50I 50		{SV; TOPOFSTACK = N_OP_blt(*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, ufn_3);\		 CSTKPTR-=2; nextop1;					\E 50		}I 13/* probably doesn't need a UFN case */I 25#undef PILOTBITBLTE 25E 13#define PILOTBITBLT							\D 28		{TOPOFSTACK = N_OP_pilotbitblt(POP, TOPOFSTACK, ufn_2);	\E 28I 28D 50		{TOPOFSTACK = N_OP_pilotbitblt(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50I 50		{SV; TOPOFSTACK = N_OP_pilotbitblt(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50E 28		 nextop1;						\		}I 24D 28#undef VAG2#define VAG2								\		{TOPOFSTACK = N_OP_vag2(POP, TOPOFSTACK, ufn_2);	\		 nextop1;						\		}E 24I 13/* probably doesn't need a UFN case */E 28E 13D 12/*#define PILOTBITBLT	{goto ni;}*/E 12I 12#undef CREATECELL#define CREATECELL							\D 50		{TOPOFSTACK = N_OP_createcell(TOPOFSTACK, ufn_1);	\E 50I 50		{SV; TOPOFSTACK = N_OP_createcell(TOPOFSTACK, ufn_1);	\E 50		 nextop1;						\		}E 12E 11I 21#undef FPLUS2D 50#define FPLUS2	{TOPOFSTACK = N_OP_fplus2(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50I 50#define FPLUS2	{SV; TOPOFSTACK = N_OP_fplus2(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50	nextop1;}#undef FDIFFERENCED 50#define FDIFFERENCE	{TOPOFSTACK = N_OP_fdifference(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50I 50#define FDIFFERENCE	{SV; TOPOFSTACK = N_OP_fdifference(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50	nextop1;}#undef FTIMES2D 50#define FTIMES2	{TOPOFSTACK = N_OP_ftimes2(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50I 50#define FTIMES2	{SV; TOPOFSTACK = N_OP_ftimes2(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50	nextop1;}#undef FQUOTIENTD 50#define FQUOTIENT	{TOPOFSTACK = N_OP_fquotient(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50I 50#define FQUOTIENT	{SV; TOPOFSTACK = N_OP_fquotient(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50	nextop1;}#undef FGREATERPD 50#define FGREATERP	{TOPOFSTACK = N_OP_fgreaterp(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50I 50#define FGREATERP	{SV; TOPOFSTACK = N_OP_fgreaterp(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50	nextop1;}I 27#undef UBFLOAT1(n)D 50#define UBFLOAT1(n)	{TOPOFSTACK = N_OP_ubfloat1(TOPOFSTACK, n, ufn_1d);\E 50I 50#define UBFLOAT1(n)	{SV; TOPOFSTACK = N_OP_ubfloat1(TOPOFSTACK, n, ufn_1d);\E 50	nextop2;}#undef UBFLOAT2(n)D 50#define UBFLOAT2(n)	{TOPOFSTACK = N_OP_ubfloat2(POP_TOS_1, TOPOFSTACK, n, ufn_2d);\E 50I 50#define UBFLOAT2(n)	{SV; TOPOFSTACK = N_OP_ubfloat2(POP_TOS_1, TOPOFSTACK, n, ufn_2d);\E 50	nextop2;}#undef UBFLOAT3(n)D 50#define UBFLOAT3(n)	{TOPOFSTACK = N_OP_ubfloat3(POP_TOS_1, POP_TOS_1, TOPOFSTACK, n, ufn_3d);\E 50I 50#define UBFLOAT3(n)	{SV; TOPOFSTACK = N_OP_ubfloat3(*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n, ufn_3d); CSTKPTR-=2; \E 50	nextop2;}E 27E 21I 20#undef CLFMEMBD 46#define CLFMEMB	{TOPOFSTACK = N_OP_clfmemb(POP_TOS_1, TOPOFSTACK, ufn_2);\E 46I 46D 50#define CLFMEMB	{TOPOFSTACK = N_OP_clfmemb(POP_TOS_1, TOPOFSTACK, exception_2);\E 50I 50#define CLFMEMB	{SV; TOPOFSTACK = N_OP_clfmemb(POP_TOS_1, TOPOFSTACK, exception_2);\E 50E 46	nextop1;}#undef CLASSOCD 46#define CLASSOC	{TOPOFSTACK = N_OP_classoc(POP_TOS_1, TOPOFSTACK, ufn_2);\E 46I 46D 50#define CLASSOC	{TOPOFSTACK = N_OP_classoc(POP_TOS_1, TOPOFSTACK, exception_2);\E 50I 50#define CLASSOC	{SV; TOPOFSTACK = N_OP_classoc(POP_TOS_1, TOPOFSTACK, exception_2);\E 50E 46	nextop1;}I 50/* NOTE: RESTLIST never punts */E 50I 30#undef RESTLIST(n)#define RESTLIST(n)	{TOPOFSTACK = N_OP_restlist(POP_TOS_1, TOPOFSTACK, n, ufn_2d);\	nextop2;}E 30#undef CLEQUALD 50#define CLEQUAL	{TOPOFSTACK = N_OP_clequal(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50I 50#define CLEQUAL	{SV; TOPOFSTACK = N_OP_clequal(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50	nextop1;}#undef ILEQUALD 50#define ILEQUAL	{TOPOFSTACK = N_OP_equal(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50I 50#define ILEQUAL	{SV; TOPOFSTACK = N_OP_equal(POP_TOS_1, TOPOFSTACK, ufn_2);\E 50	nextop1;}D 37#undef CLARITHEQUAL#define CLARITHEQUAL	{TOPOFSTACK = N_OP_eqq(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}E 37E 20I 18D 28/* temporarily comment these out until reference count problem is fixed E 28I 28D 29#ifdef DONSOPSE 29E 28E 18I 13D 38#undef AREF1#define AREF1	{TOPOFSTACK = N_OP_aref1(POP_TOS_1, TOPOFSTACK, ufn_2);	\	nextop1;}E 13E 38I 13#undef ASET1#define ASET1								\D 50	{TOPOFSTACK = N_OP_aset1(POP_TOS_1, POP_TOS_1, TOPOFSTACK, ufn_3);\D 29	nextop1;							\}E 29I 29	nextop1;}E 50I 50	{SV; TOPOFSTACK = N_OP_aset1(*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, ufn_3);\	CSTKPTR-=2; nextop1;}E 50E 29#undef MISC4(n)#define MISC4(n)							\D 50	{TOPOFSTACK = N_OP_misc4(POP_TOS_1, POP_TOS_1, POP_TOS_1, TOPOFSTACK, n, ufn_4d); nextop2;}E 50I 50	{SV; TOPOFSTACK = N_OP_misc4(*(CSTKPTR-3), *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n, ufn_4d); CSTKPTR-=3; nextop2;}E 50I 35#undef MISC3(n)#define MISC3(n)							\D 50	{TOPOFSTACK = N_OP_misc3(POP_TOS_1, POP_TOS_1, TOPOFSTACK, n, ufn_3d); nextop2;}E 50I 50	{SV; TOPOFSTACK = N_OP_misc3(*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n, ufn_1d); CSTKPTR-=2; nextop2;}E 50E 35I 32#undef AREF2D 50#define AREF2	{TOPOFSTACK = N_OP_aref2(POP_TOS_1,			\                 POP_TOS_1, TOPOFSTACK, ufn_3);				\E 50I 50#define AREF2	{SV; TOPOFSTACK = N_OP_aref2(*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, ufn_1); CSTKPTR-=2;				\E 50		 nextop1;}E 32#undef ASET2D 50#define ASET2	{TOPOFSTACK = N_OP_aset2(POP_TOS_1,			\                 POP_TOS_1, POP_TOS_1, TOPOFSTACK, ufn_4);		\E 50I 50#define ASET2	{SV; TOPOFSTACK = N_OP_aset2(*(CSTKPTR-3), *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, ufn_1); CSTKPTR-=3; \E 50D 29		 nextop1;						\}E 29I 29		 nextop1;}E 29I 18D 28 **** END TEMPORARY COMMENT OUT */E 28I 28D 29#endifE 29E 28E 18/* Error Recovery & UFN calls */I 50#ifdef NOASME 50I 50/* SV needs to save state */#define SV EXT/* no extra code for UFN_CALLS, define labels as constants */#define UFN_CALLS#define ufn_3d 0#define ufn_2 0#define ufn_1 0#define ufn_4 0#define ufn_4d 0#define ufn_3 0#define ufn_1d 0#define ufn_9 0#define ufn_2d2 0#define unwind_err 0#define ufn_2d 0#define exception_2 0#define exception_2C 0/* no opcode fail point necessary */#define OPCODEFAIL#else/* SV need do no work */#define SV/* UFN_CALLS are inserted in xc.c. Note that only ufn_2 calls have decremented the stack at the time the UFN is called *//* ufn_x	there are x args from the Lisp stack   ufn_xd	there are x args from the Lisp stack & 		some from the code stream.*/E 50E 13E 10E 9E 8E 7#define	UFN_CALLS							\									\I 9unwind_err:	 							\D 26	fixspn(4);						\	 goto op_ufn;						\E 26I 26D 47	fixspn(4);							\E 47I 47	fixspn(5);							\E 47	goto op_ufn;							\E 26E 9ufn_9:	fixspn(10);							\D 50	CSTKPTR += 8;							\E 50D 26	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\E 26I 26	goto op_ufn;							\E 26ufn_4d:	fixspn(6);							\D 50	CSTKPTR += 3;							\E 50D 26	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\E 26I 26	goto op_ufn;							\E 26ufn_3d:	fixspn(5);							\D 50	CSTKPTR += 2;							\E 50I 27	goto op_ufn;							\ufn_2d:	fixspn(4);							\	CSTKPTR += 1;							\E 27I 7D 26	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\E 26I 26	goto op_ufn;							\E 26ufn_2d2:fixspn(5);							\	CSTKPTR += 1;							\E 7D 26	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\E 26I 26	goto op_ufn;							\E 26ufn_1d:	fixsp3();							\I 10D 26	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\E 26I 26	goto op_ufn;							\E 26ufn_d:	fixsp2();							\E 10D 26	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\E 26I 26	goto op_ufn;							\E 26I 13ufn_4:	fixspn(5);							\D 50	CSTKPTR += 3;							\E 50D 26	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\E 26I 26	goto op_ufn;							\E 26E 13ufn_3:	fixspn(4);							\D 50	CSTKPTR += 2;							\E 50D 26	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\ufn_2:	fixsp3();							\E 26I 26	goto op_ufn;							\ufn_2:	fixsp3(); 							\E 26	CSTKPTR += 1;							\D 26	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\ufn_1:	fixsp2();							\D 2ufn_0:	EXT;								\E 2I 2	EXT;								\	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;							\ufn_0:	fixsp1();							\op_ufn:	EXT;								\E 2	ufn(Get_BYTE(PCMAC));						\	RET;								\	nextop0;E 26I 26	goto op_ufn;							\ufn_1:	fixsp2(); 							\	goto op_ufn;							\ufn_0:	fixsp1(); 							\D 45	goto op_ufn;E 26E 45I 45	goto op_ufn;							\exception_2 : fixsp3();							\	CSTKPTR += 1;							\I 49	TOPOFSTACK = TopOfStack;					\E 49D 46	TOPOFSTACK = TopOfStack;					\	if(!Irq_Stk_End) goto check_interrupt;				\	else goto op_ufn;E 46I 46	if(!Irq_Stk_End){						\D 49		 TOPOFSTACK = TopOfStack;				\E 49		 goto check_interrupt;					\	}								\	else goto op_ufn;						\exception_2C : fixsp3();						\I 49	*CSTKPTR = Scratch_CSTK;					\	CSTKPTR += 1;							\E 49	if(!Irq_Stk_End){						\D 49		 *CSTKPTR = Scratch_CSTK;				\		 CSTKPTR += 1;						\E 49		 goto check_interrupt;					\	}								\	else {								\D 49		CSTKPTR += 1;						\E 49		goto op_ufn;						\	}E 46E 45I 50/* need jump point for inline asm code, e.g., for IPLUS */E 50I 50E 50D 26I 13E 26#define OPCODEFAIL							\									\fixtos1:								\asm("fixtos1:");							\	FIXTOS1;							\D 26	EXT;								\  	ufn(Get_BYTE(PCMAC));						\   	NRET;E 26I 26	goto op_ufn;E 26E 13I 50#endif NOASME 50E 1