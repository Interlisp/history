h42475s 00009/00010/00201d D 1.5 88/12/23 14:20:27 shih 5 4c wrong sccs id, spelling errorses 00059/00083/00152d D 1.4 88/06/21 15:23:28 bane 4 3c RPLACA/D in this file broken; CAR and CDR copied to inlinedefsC.hes 00001/00001/00234d D 1.3 88/04/21 18:22:17 masinter 3 2c no changees 00001/00001/00234d D 1.2 88/03/13 13:16:53 hayata 2 1c Add SCCS key id (%Z%)es 00235/00000/00000d D 1.1 88/02/23 18:36:03 hayata 1 0c date and time created 88/02/23 18:36:03 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 2I 2D 3/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 3I 3D 5/* This is G-file @(#) car-cdrmacro.h Version 1.2 (3/13/88). copyright Xerox & Fuji Xerox  */E 3E 2E 5I 5/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 5/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 5 *	Auther :  Takeshi Shimizu,Naoyuki MitaniE 5I 5 *	Author :  Takeshi Shimizu, Naoyuki MitaniE 5 * *//***********************************************************************//*D 5 		File Name :	car-cdrmacro.hE 5I 5		File Name :	car-cdrmacro.hE 5		Desc	:	car-cdr managementD 5  				ORGINAL	Date :		Apr 24, 1987E 5I 5				ORIGINAL	Date :		Apr 24, 1987E 5				Changed : 4 Dec. 87 TakeshiD 5 		Including :	E 5I 5		Including :E 5				OPCAR				OPCDR				OPRPLACA				OPRPLACD*//**********************************************************************/D 4#define DATUM68K	((ConsCell *)wordp)#define TEMP68K		((ConsCell *)cellp)#define OPCAR	{ \/*** register ConsCell *DATUM68K;***/\/*** register ConsCell *temp; ***/\ DATUM68K = (ConsCell *)(Addr68k_from_LADDR(TOPOFSTACK));\E 4I 4/* #define DATUM68K	((ConsCell *)wordp) *//* #define TEMP68K		((ConsCell *)cellp) */#define OPCAR \E 4 if (Listp(TOPOFSTACK))\ {\I 4 register ConsCell *DATUM68K = (ConsCell *)(Addr68k_from_LADDR(TOPOFSTACK));\E 4	if (DATUM68K->cdr_code == CDR_INDIRECT)\	{\D 4		TEMP68K = (ConsCell *)Addr68k_from_LADDR(DATUM68K->car_field);\		TOPOFSTACK = ((LispPTR)TEMP68K->car_field);\E 4I 4		TOPOFSTACK = ((LispPTR)((ConsCell *)Addr68k_from_LADDR(DATUM68K->car_field))->car_field);\E 4	}\	else \I 4	{ \E 4		TOPOFSTACK = ((LispPTR)DATUM68K->car_field);\I 4  } \  nextop1; \E 4  }\ else	if (TOPOFSTACK == NIL_PTR)\D 4		goto car_ret;\E 4I 4		{ nextop1; } \E 4	else if ( TOPOFSTACK == ATOM_T)\D 4		goto car_ret;\	else\E 4I 4		{ nextop1; } \	else \E 4	  {\D 4		UFN(1); /* call CAR.UFN */\		NEXTOPCODE;\	  }\car_ret:\ PCMAC++;\} /* end of OPCAR */E 4I 4		goto op_ufn; \	  } /* end of OPCAR */E 4/**********************************************************************/D 4#define CDRCODEX	((LispPTR)arg1)E 4#define OPCDR  { \D 4/*** register ConsCell *DATUM68K;**/\/*** register DLword cdr_code;***/\/*** register ConsCell *TEMP68K;***/\ DATUM68K = (ConsCell *)(Addr68k_from_LADDR(TOPOFSTACK));\ CDRCODEX = DATUM68K->cdr_code;\E 4 if (Listp(TOPOFSTACK))\ {\I 4register ConsCell *DATUM68K = (ConsCell *)(Addr68k_from_LADDR(TOPOFSTACK));\register DLword CDRCODEX = DATUM68K->cdr_code;\E 4	if (CDRCODEX == CDR_NIL)\		/* cdr-nil */\		TOPOFSTACK = (NIL_PTR);\	else if (CDRCODEX> CDR_ONPAGE)\		/* cdr-samepage */\		TOPOFSTACK = (POINTER_PAGEBASE(TOPOFSTACK) + \		((CDRCODEX & 127) << 1));\	else if (CDRCODEX == CDR_INDIRECT)	/* CDRCODEX < CDR_ONPAGE */\		/* cdr-indirect */\		TOPOFSTACK = (cdr ((LispPTR)(DATUM68K->car_field)));\	else\	{\		/* cdr-differentpage */\D 4		TEMP68K = (ConsCell *)(Addr68k_from_LADDR\		(POINTER_PAGEBASE(TOPOFSTACK) + (CDRCODEX << 1)));\		TOPOFSTACK = ((LispPTR)TEMP68K->car_field);\E 4I 4		TOPOFSTACK = (LispPTR)((ConsCell *)(Addr68k_from_LADDR \		(POINTER_PAGEBASE(TOPOFSTACK) + (CDRCODEX << 1)))\											->car_field);\E 4	}\I 4	nextop1; \E 4  }\ else	if (TOPOFSTACK == NIL_PTR)\D 4		TOPOFSTACK = NIL_PTR;\E 4I 4		{ nextop1; } \E 4	else\	 {\D 4		UFN(2); /* call UFN.CDR */\		NEXTOPCODE;\E 4I 4		goto op_ufn; \E 4	 }\D 4 PCMAC++;\E 4} /* end of OPCDR *//**********************************************************************/D 4#define DATAX	((LispPTR)arg2)#define X68K	((ConsCell *)cellp)#define OPRPLACA	{ \/*** register LispPTR x; ***/\/*** register  ConsCell *x_68k;***/\register ConsCell *temp68k;\ DATAX = *((LispPTR *)(CSTKPTR));\ CSTKPTR -= 2;\E 4I 4#ifdef NOWAY#define RPLACA	{ \register LispPTR DATAX = *((LispPTR *)(CurrentStackPTR));\ CurrentStackPTR -= 2;\E 4 if (Listp(DATAX) == NIL)\ {\	if (DATAX == NIL_PTR)\	{\		if (TOPOFSTACK != NIL_PTR)\D 4			error("Attempt to RPLACA NIL");\		else\			TOPOFSTACK = NIL_PTR;	\			PCMAC++;\E 4I 4			goto op_ufn; \			/* error("Attempt to RPLACA NIL"); */ \E 4	}\	else\D 4		error("ARG not List");\E 4I 4		goto op_ufn; \		/* error("ARG not List"); */\E 4 }\ else \ {\D 4	X68K = (ConsCell *)Addr68k_from_LADDR(DATAX);\	gclookup(0x8000|DELREF , car(DATAX));	/* set up referense count */\	gclookup(0x8000|ADDREF , TOPOFSTACK);\E 4I 4	register ConsCell *X68K = (ConsCell *)Addr68k_from_LADDR(DATAX);\D 5	GCLOOKUP(0x8000, DELREF , car(DATAX));	/* set up referense count */\E 5I 5	GCLOOKUP(0x8000, DELREF , car(DATAX));	/* set up reference count */\E 5	GCLOOKUP(0x8000, ADDREF , TOPOFSTACK);\E 4	if (X68K->cdr_code == CDR_INDIRECT)\	{\D 4		temp68k = (ConsCell *)Addr68k_from_LADDR\					((LispPTR)X68K->car_field);\		temp68k->car_field = TOPOFSTACK;\E 4I 4		((ConsCell *)Addr68k_from_LADDR((LispPTR)X68K->car_field))\			->car_field = TOPOFSTACK;\E 4	}\	else\		X68K->car_field = TOPOFSTACK ;\D 4 	PCMAC++;\E 4	TOPOFSTACK = DATAX;\ }\I 4 nextop1; \E 4} /* end of OPRPLACA *//**********************************************************************/D 4#define CDR_CELL	arg3#define RP_PAGE		rp_page#define CDR_CELL68K	((ConsCell *)wordp)#define OPRPLACD  { \E 4I 4#define RPLACD  { \E 4 extern struct conspage *next_conspage();\D 4/** register LispPTR x;DATAX is arg2 */\/** register ConsCell *x_68k;is cellp */\ /** register ConsCell *CDR_CELL68K; is wordp */\ /** LispPTR  CDR_CELL is arg3 */\  LispPTR RP_PAGE;\/**  DLword CDRCODEX; is reg arg1 **/\register ConsCell *temp68k;\ register struct conspage *cons68k;\ DATAX = *((LispPTR *)(CSTKPTR));\ CSTKPTR -= 2;\E 4I 4 register LispPTR DATAX = *((LispPTR *)(CurrentStackPTR));\ CurrentStackPTR -= 2;\E 4 if (Listp(DATAX) == NIL)\ {\	if (DATAX == NIL_PTR)\	{\		if (TOPOFSTACK != NIL_PTR)\D 4			error("Attempt to RPLACD NIL");\E 4I 4			goto op_ufn; \			/* error("Attempt to RPLACD NIL"); */\E 4		else\			TOPOFSTACK = NIL_PTR;	\	}\	else\D 4		error("ARG not List");\E 4I 4		goto op_ufn; \		/* error("ARG not List"); */\E 4 }\ else \ {\D 4	X68K = (ConsCell *)Addr68k_from_LADDR(DATAX);\	gclookup(0x8000|DELREF , cdr(DATAX));	/* set up referense count */\	gclookup(0x8000|ADDREF , TOPOFSTACK);\	CDRCODEX = X68K->cdr_code;\E 4I 4	register ConsCell *X68K = (ConsCell *)Addr68k_from_LADDR(DATAX);\	register CDRCODEX = X68K->cdr_code;\	register LispPTR RP_PAGE = X68K->car_field;\D 5	GCLOOKUP(0x8000, DELREF , cdr(DATAX));	/* set up referense count */\E 5I 5	GCLOOKUP(0x8000, DELREF , cdr(DATAX));	/* set up reference count */\E 5	GCLOOKUP(0x8000, ADDREF , TOPOFSTACK);\E 4	if (CDRCODEX == CDR_INDIRECT)\	{\		/* cdr-indirect */\D 4		RP_PAGE = X68K->car_field;\		temp68k = (ConsCell *)Addr68k_from_LADDR(RP_PAGE);\		CDR_CELL = POINTER_PAGEBASE(RP_PAGE) + \				(temp68k->cdr_code << 1);\		CDR_CELL68K = (ConsCell *)Addr68k_from_LADDR(CDR_CELL);\		*(LispPTR *)CDR_CELL68K = TOPOFSTACK & 0xffffff;\E 4I 4		register LispPTR CDR_CELL = POINTER_PAGEBASE(RP_PAGE) + \				(((ConsCell *)Addr68k_from_LADDR(RP_PAGE))->cdr_code << 1);\		*(LispPTR *)((ConsCell *)Addr68k_from_LADDR(CDR_CELL)) = \				TOPOFSTACK & 0xffffff;\E 4			/* CDRCODEX is set to 0 */\	}\	else if (CDRCODEX <= CDR_MAXINDIRECT)\	{\		/* cdr-differentpage */\D 4		CDR_CELL = POINTER_PAGEBASE(DATAX) + (CDRCODEX << 1);\		CDR_CELL68K = (ConsCell *)Addr68k_from_LADDR(CDR_CELL);\		*(LispPTR *)CDR_CELL68K = TOPOFSTACK & 0xffffff;\E 4I 4		register LispPTR CDR_CELL = POINTER_PAGEBASE(DATAX) + (CDRCODEX << 1);\		*(LispPTR *)((ConsCell *)Addr68k_from_LADDR(CDR_CELL)) = \				TOPOFSTACK & 0xffffff;\E 4			/* CDRCODEX is set to 0 */\	}\	else if (TOPOFSTACK == NIL_PTR)\		/* cdr-samepage & TOPOFSTACK is nil */\		X68K->cdr_code = CDR_NIL;\	else if ((RP_PAGE = POINTER_PAGEBASE(DATAX )) == \					POINTER_PAGEBASE(TOPOFSTACK))\		/* cdr-samepage & x and TOPOFSTACK are on same page */\		X68K->cdr_code = CDR_ONPAGE + ((TOPOFSTACK & 0xff) >> 1);\	else\	{\		/* cdr-samepage & x and TOPOFSTACK are on different page */\D 4		cons68k = (struct conspage *)Addr68k_from_LADDR(RP_PAGE);\E 4I 4		register struct conspage *cons68k = (struct conspage *)Addr68k_from_LADDR(RP_PAGE);\		register ConsCell *CDR_CELL68K; \E 4		if (cons68k->count > 0)\		{\			/* at least one free-cell on x's conspage */\			CDR_CELL68K = GetNewCell_68k(cons68k);\			cons68k->count--;\			cons68k->next_cell = CDR_CELL68K->cdr_code;\			*(LispPTR *)CDR_CELL68K = TOPOFSTACK & 0xffffff;\				/* cdr_code is set to 0 */\			X68K->cdr_code = (LADDR_from_68k(CDR_CELL68K) - \			RP_PAGE) >> 1;\		}\		else\		{\			/* no more free-cell on x's conspage */\I 4			register ConsCell *temp68k; \E 4			cons68k = next_conspage();\			CDR_CELL68K = GetNewCell_68k(cons68k);\			cons68k->next_cell = CDR_CELL68K->cdr_code;\			temp68k = GetNewCell_68k(cons68k);\			cons68k->next_cell = temp68k->cdr_code ;\			/* cons68k->next_cell = CDR_CELL68K->cdr_code;*/\			cons68k->count -= 2;\			*(LispPTR *)CDR_CELL68K = TOPOFSTACK & 0xffffff;\				/* cdr_code is set to 0 */\			temp68k->car_field = X68K->car_field;\			(LispPTR)X68K->car_field = LADDR_from_68k(temp68k);\			temp68k->cdr_code = (LADDR_from_68k(CDR_CELL68K) \			& 0xff) >> 1;\			X68K->cdr_code = CDR_INDIRECT;\		}\	}\ }\D 4 PCMAC++;\E 4 TOPOFSTACK = DATAX;\I 4 nextop1; \E 4}/* end of OPRPLACD */I 4#endifE 4E 1