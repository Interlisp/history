h45706s 00000/00000/00151d D 2.4 90/04/19 21:48:58 sybalsky 13 12c AIX/Posix:  Name shortened toes 00003/00002/00148d D 2.3 89/04/07 20:19:26 shih 12 11c bad sccsides 00021/00035/00129d D 2.2 88/10/12 14:47:49 krivacic 11 10c new out-of-line interfacees 00000/00000/00164d D 2.1 88/05/17 09:18:00 hayata 10 9c Version up to 2.1es 00001/00001/00163d D 1.9 88/05/13 10:01:32 hayata 9 8c Add SCCS keyides 00020/00002/00144d D 1.8 88/04/22 19:20:53 krivacic 8 7c inlinedefs re-arrangement & ni removales 00001/00001/00145d D 1.7 88/03/31 15:10:20 krivacic 7 6c storen, copyn, arg0, assoces 00011/00001/00135d D 1.6 88/03/23 10:12:52 krivacic 6 5c fixed for SPARC mergees 00018/00006/00118d D 1.5 88/03/14 12:16:05 krivacic 5 4c Don's opcodeses 00001/00001/00123d D 1.4 88/03/13 13:21:17 hayata 4 3c Add SCCS key id (%Z%)es 00011/00002/00113d D 1.3 88/03/11 18:03:08 krivacic 3 2c Native Fn Interfaceses 00023/00005/00092d D 1.2 88/03/09 15:42:39 krivacic 2 1c swapx inlinees 00097/00000/00000d D 1.1 88/03/03 11:22:13 krivacic 1 0c date and time created 88/03/03 11:22:13 by krivaciceuUtTI 1D 4/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 4I 4D 5/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 5I 5D 9/* This is G-file @(#) inlinedefs68K.h Version 1.4 (3/13/88). copyright Xerox & Fuji Xerox  */E 9I 9D 11/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 11I 11D 12/* This is G-file @(#) inlinedefs68K.h Version 1.9 (5/13/88). copyright Xerox & Fuji Xerox  */E 12I 12/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 12E 11E 9E 5E 4/* 	inlinedefs68K.h *//* 	Bob Krivacic 2/23/88 */D 12/* 	These are the Macros Used to generate inline 68K assembly code E 12I 12/* 	These are the Macros used to generate inline 68K assembly code E 12	to implement the opcodes.  Used by both dispatch 	loop and native code.*/#undef DIFFERENCED 8#undef PLUSE 8I 8#undef PLUS2E 8#undef GREATERPI 8#undef IDIFFERENCE#undef IPLUS2#undef IGREATERPE 8#undef LOGOR#undef LOGANDI 3#undef LOGXORE 3#undef LRSH8#undef LRSH1#undef LLSH8#undef LLSH1D 11#undef ADDBASE#undef LOLOC#undef HILOC#undef VAG2E 11I 11#undef N_OP_ADDBASE#undef N_OP_LOLOC#undef N_OP_HILOC#undef N_OP_VAG2E 11#undef LISTP#undef NTYPEX#undef TYPEPI 2#undef SWAP_WORDSE 2/*#undef FN3#undef RETURN*/ I 2#define SWAP_WORDS(x) swapx(x) E 2#define DIFFERENCE {						\D 2	TOPOFSTACK = difference(POP_TOS_1, TOPOFSTACK);		\E 2I 2	TOPOFSTACK = op_difference(POP_TOS_1, TOPOFSTACK);	\E 2	nextop1;						\I 6diff_err:							\E 6I 2	asm("diff_err:");					\D 11	TOPOFSTACK = N_OP_difference(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\E 11I 11	N_OP_POPPED_CALL_2(N_OP_difference, GET_POPPED);	\E 11E 2	}D 8#define PLUS {							\E 8I 8#define PLUS2 {							\E 8D 2	TOPOFSTACK = plus(POP_TOS_1, TOPOFSTACK);		\E 2I 2	TOPOFSTACK = op_plus(POP_TOS_1, TOPOFSTACK);		\E 2	nextop1;						\I 6plus_err:							\E 6I 2	asm("plus_err:");					\D 11	TOPOFSTACK = N_OP_plus2(GET_POPPED, TOPOFSTACK, ufn_2);	\	nextop1;						\E 11I 11	N_OP_POPPED_CALL_2(N_OP_plus2, GET_POPPED);		\E 11E 2	}#define	GREATERP {						\D 2	TOPOFSTACK = greaterp(POP_TOS_1, TOPOFSTACK);		\E 2I 2D 3	TOPOFSTACK = op_greaterp(POP_TOS_1, TOPOFSTACK);		\E 3I 3	TOPOFSTACK = op_greaterp(POP_TOS_1, TOPOFSTACK);	\E 3E 2	nextop1;						\I 6greaterp_err:							\E 6I 2	asm("greaterp_err:");					\D 11	TOPOFSTACK = N_OP_greaterp(GET_POPPED, TOPOFSTACK, ufn_2);\	nextop1;						\E 11I 11	N_OP_POPPED_CALL_2(N_OP_greaterp, GET_POPPED);		\E 11E 2	}I 8#define IDIFFERENCE {						\	TOPOFSTACK = op_difference(POP_TOS_1, TOPOFSTACK);	\	}#define IPLUS2 {							\	TOPOFSTACK = op_plus(POP_TOS_1, TOPOFSTACK);		\	nextop1;						\	}#define	IGREATERP {						\	TOPOFSTACK = op_greaterp(POP_TOS_1, TOPOFSTACK);	\	nextop1;						\	}E 8#define LOGOR { 						\D 2	TOPOFSTACK = logor(POP_TOS_1, TOPOFSTACK);		\E 2I 2	TOPOFSTACK = op_logor(POP_TOS_1, TOPOFSTACK);		\E 2	nextop1;						\I 6logor_err:							\E 6I 2	asm("logor_err:");					\D 3	TOPOFSTACK = N_OP_logor(GET_POPPED, TOPOFSTACK, ufn_2);\E 3I 3D 11	TOPOFSTACK = N_OP_logor(GET_POPPED, TOPOFSTACK, ufn_2);	\E 3	nextop1;						\E 11I 11	N_OP_POPPED_CALL_2(N_OP_logor, GET_POPPED);		\E 11E 2	} #define LOGAND {						\D 2	TOPOFSTACK = logand(POP_TOS_1, TOPOFSTACK);		\E 2I 2	TOPOFSTACK = op_logand(POP_TOS_1, TOPOFSTACK);		\	nextop1;						\I 6logand_err:							\E 6	asm("logand_err:");					\D 11	TOPOFSTACK = N_OP_logand(GET_POPPED, TOPOFSTACK, ufn_2);\I 3	nextop1;						\E 11I 11	N_OP_POPPED_CALL_2(N_OP_logand, GET_POPPED);		\E 11	}#define LOGXOR {						\	TOPOFSTACK = op_logxor(POP_TOS_1, TOPOFSTACK);		\	nextop1;						\I 6logxor_err:							\E 6	asm("logxor_err:");					\D 11	TOPOFSTACK = N_OP_logxor(GET_POPPED, TOPOFSTACK, ufn_2);\E 3E 2	nextop1;						\E 11I 11	N_OP_POPPED_CALL_2(N_OP_logxor, GET_POPPED);		\E 11	}#define LRSH8 {							\D 5	TOPOFSTACK = lrsh8(TOPOFSTACK);				\E 5I 5	TOPOFSTACK = op_lrsh8(TOPOFSTACK);			\E 5	nextop1;						\I 6lrsh8_err:							\E 6I 5	asm("lrsh8_err:");					\D 11	TOPOFSTACK = N_OP_lrsh8(TOPOFSTACK, ufn_1);		\	nextop1;						\E 11I 11	N_OP_CALL_1(N_OP_lrsh8);				\E 11E 5	}D 5E 5I 5	E 5#define LRSH1 {							\D 5	TOPOFSTACK = lrsh1(TOPOFSTACK);				\E 5I 5	TOPOFSTACK = op_lrsh1(TOPOFSTACK);			\E 5	nextop1;						\I 6lrsh1_err:							\E 6I 5	asm("lrsh1_err:");					\D 11	TOPOFSTACK = N_OP_lrsh1(TOPOFSTACK, ufn_1);		\	nextop1;						\E 11I 11	N_OP_CALL_1(N_OP_lrsh1);				\E 11E 5	}#define LLSH8 {							\D 5	TOPOFSTACK = llsh8(TOPOFSTACK);				\E 5I 5	TOPOFSTACK = op_llsh8(TOPOFSTACK);			\E 5	nextop1;						\I 6llsh8_err:							\E 6I 5	asm("llsh8_err:");					\D 11	TOPOFSTACK = N_OP_llsh8(TOPOFSTACK, ufn_1);		\	nextop1;						\E 11I 11	N_OP_CALL_1(N_OP_llsh8);				\E 11E 5	}#define LLSH1 {							\D 5	TOPOFSTACK = llsh1(TOPOFSTACK);				\E 5I 5	TOPOFSTACK = op_llsh1(TOPOFSTACK);			\	nextop1;						\I 6llsh1_err:							\E 6	asm("llsh1_err:");					\D 11	TOPOFSTACK = N_OP_llsh1(TOPOFSTACK, ufn_1);		\E 5	nextop1;						\E 11I 11	N_OP_CALL_1(N_OP_llsh1);				\E 11	}D 11#define ADDBASE {						\E 11I 11#define N_OP_ADDBASE {						\E 11	TOPOFSTACK = addbase(POP_TOS_1, TOPOFSTACK);		\	nextop1;						\	}D 11#define LOLOC	{ TOPOFSTACK = loloc(TOPOFSTACK); nextop1; }#define HILOC	{ TOPOFSTACK = hiloc(TOPOFSTACK); nextop1; }#define VAG2	{ TOPOFSTACK = vag2(POP_TOS_1, TOPOFSTACK); nextop1; }E 11I 11#define N_OP_LOLOC	{ TOPOFSTACK = loloc(TOPOFSTACK); nextop1; }#define N_OP_HILOC	{ TOPOFSTACK = hiloc(TOPOFSTACK); nextop1; }#define N_OP_VAG2	{ TOPOFSTACK = vag2(POP_TOS_1, TOPOFSTACK); nextop1; }E 11D 11#define LISTP	{ TOPOFSTACK = listp(TOPOFSTACK); nextop1;}#define NTYPEX	{ TOPOFSTACK = ntypex(TOPOFSTACK); nextop1; }E 11I 11#define LISTP		{ TOPOFSTACK = listp(TOPOFSTACK); nextop1;}#define NTYPEX		{ TOPOFSTACK = ntypex(TOPOFSTACK); nextop1; }E 11D 6#define TYPEP	{ TOPOFSTACK = typep(TOPOFSTACK, *(PCMAC+1)); nextop2; }E 6I 6D 7#define TYPEP	{ TOPOFSTACK = typep(TOPOFSTACK, Get_BYTE(PCMAC+1)); nextop2; }E 7I 7#define TYPEP(n)	{ TOPOFSTACK = typep(TOPOFSTACK, Get_BYTE(PCMAC+1)); nextop2; }E 7E 6D 11/*#define FN3	{ registers; CHECK_INTERRUPT; fn3(); NATIVECHECK; }#define RETURN	{ opreturn(); NATIVECHECK; }*/E 11E 1