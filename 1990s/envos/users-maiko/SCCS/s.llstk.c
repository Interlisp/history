h43421s 00008/00002/00943d D 1.27 93/02/08 14:55:57 sybalsky 27 26c Big VM (and new CDR coding) changes for 3.0 \nes 00004/00002/00941d D 1.26 92/11/25 21:08:47 sybalsky 26 25c Fixing endif's with extra text => comment. \nes 00005/00005/00938d D 1.25 92/04/21 17:19:10 sybalsky 25 24c shortening file names for DOS \nes 00002/00002/00941d D 1.24 91/02/04 12:53:36 sybalsky 24 23c Fix errors in teh Savoir retrofit (placement of ifdefs &c)es 00196/00034/00747d D 1.23 91/01/24 11:09:33 sybalsky 23 22c 3-byte-atom changes -- stack format changes for nametablees 00021/00012/00760d D 1.22 90/08/21 17:16:05 sybalsky 22 21c Retrofit AIX changes from IBMes 00000/00000/00772d D 1.21 90/07/04 04:01:54 sybalsky 21 20c Interrupt code -- field naming.es 00002/00002/00770d D 1.20 90/06/13 15:13:33 sybalsky 20 19c Fix more cases of += breaking registerses 00275/00238/00497d D 1.19 90/06/06 13:48:28 sybalsky 19 18c remove += of register variables, fix to make it work with new S_CHECKes 00015/00006/00720d D 1.18 90/04/27 13:05:56 sybalsky 18 17c Work around  compiler bug wrt register vars:  var += const compiles wrong.es 00001/00001/00725d D 1.17 90/04/20 01:47:11 sybalsky 17 16c AIX:  shortening file names, bulk change.es 00007/00008/00719d D 1.16 90/04/19 22:48:37 sybalsky 16 15c AIX:  pointer arithmetic leftside cast fixeses 00016/00002/00711d D 1.15 90/03/02 21:46:54 sybalsky 15 14c 386 changeses 00007/00002/00706d D 1.14 90/03/01 13:57:59 osamu 14 13c Mitsunori Matsuda adds XWindow functionality.es 00002/00002/00706d D 1.13 89/12/13 10:57:24 sybalsky 13 12c color ss1es 00010/00010/00698d D 1.12 89/03/29 13:12:21 sybalsky 12 11c Fixed word pointer refs in single-word structure pointers.es 00013/00013/00695d D 1.11 89/03/27 22:35:58 sybalsky 11 10c Changed word-ptr refs (CurrentStakdPTR) to use GETWORD.es 00090/00090/00618d D 1.10 88/11/30 19:39:12 shih 10 9c restored sccs stamp, minor cleanupes 00055/00013/00653d D 1.9 88/11/16 15:16:21 shimizu 9 8c Add the process for AT-EOS stackoverflowes 00003/00003/00663d D 1.8 88/11/08 13:12:09 bane 8 7c Commented out blatantly bogus break; statementes 00001/00001/00665d D 1.7 88/10/10 14:07:22 krivacic 7 6c sun3/4 mergees 00003/00002/00663d D 1.6 88/10/04 13:58:27 krivacic 6 5c es 00005/00003/00660d D 1.5 88/09/29 14:23:06 charnley 5 4c removed calls to pr_rop.es 00005/00001/00658d D 1.4 88/06/23 10:50:11 shimizu 4 3c Makes flip_cursor as ifdefes 00004/00004/00655d D 1.3 88/06/02 11:13:50 shimizu 3 2c avoid to call error in stack_check . and correct spell miss in stack_checkes 00001/00002/00658d D 1.2 88/05/31 20:02:29 masinter 2 1c moved extern decls to include file. Fix warning msg.es 00660/00000/00000d D 1.1 88/04/18 20:10:51 shimizu 1 0c date and time created 88/04/18 20:10:51 by shimizueuUtTI 1D 8/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 8I 8D 10/* This is G-file @(#) llstk.c Version 1.7 (10/10/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) llstk.c	1.7 10/10/88";E 10I 10D 12/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(envos & Fuji Xerox)";E 12I 12D 14/* @(#) llstk.c Version 1.11 (3/27/89). copyright envos & Fuji Xerox  */static char *id = "@(#) llstk.c	1.11 3/27/89	(envos & Fuji Xerox)";E 14I 14D 15/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 15I 15/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 15E 14E 12E 10E 8I 15/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 15/******************************************************************//*        File Name :     llstk.c        Desc.     :     Low Level stack operations        Including :        Edited by :     Takeshi Shimizu(March 14, 1988)*//******************************************************************/D 16#include <sunwindow/window_hs.h>E 16#include "lispemul.h"#include "lispmap.h"D 25#include "address68k.h"E 25I 25#include "adr68k.h"E 25#include "address.h"D 25#include "lisptypes.h"#include "initatoms.h"#include "lispglobal.h"#include "emulglobal.h"E 25I 25#include "lsptypes.h"#include "initatms.h"#include "lspglob.h"#include "emlglob.h"E 25#include "cell.h"#include "stack.h"#include "return.h"D 10        E 10I 10E 10I 6extern int extended_frame;E 6/******************************************************************//*        Func Name :     do_stackoverflow(incallp)		retval: If There is no space for stack then return 1					else return 0D 10        	incallp:E 10I 10		incallp:E 10			If Calling during function call,incallp=T			else NIL        Edited by :     Take(March 28, 1988)*//******************************************************************/do_stackoverflow(incallp)D 19 int incallp;{  register DLword *next68k;D 10  DLword newfx; E 10I 10  DLword newfx;E 10  DLword savenext;  DLword *oldPVar;  int movedistance;D 2  extern int Irq_Stk_Check, Irq_Stk_End;E 2  LispPTR moveframe();E 19I 19  int incallp;  {    register DLword *next68k;    DLword newfx;    DLword savenext;    DLword *oldPVar;    int movedistance;    LispPTR moveframe();E 19#ifdef STACKCHECKD 19  LispPTR stackcontents;  LispPTR TopIVAR;E 19I 19    LispPTR stackcontents;    LispPTR TopIVAR;E 19D 19  stackcontents= *((LispPTR*)CurrentStackPTR);  TopIVAR= *((LispPTR*)IVar);E 19I 19    stackcontents= *((LispPTR*)CurrentStackPTR);    TopIVAR= *((LispPTR*)IVar);E 19#endifD 19 /* Don't care PC,FuncObj, */D 10 /*if incall flag ON ,Don't care IVar E 10I 10 /*if incall flag ON ,Don't care IVarE 19I 19   /* Don't care PC,FuncObj, */   /*if incall flag ON ,Don't care IVarE 19E 10	,became resudual and it is pointed by copied FX's BLINK*/D 19  oldPVar=PVar;E 19I 19    oldPVar=PVar;E 19D 19 if(*NeedHardreturnCleanup_word)  {E 19I 19    if(*NeedHardreturnCleanup_word)      {E 19D 2	warn("HardreturnCleanup in DOSTACKOVERFLOW");E 2I 2	warn("HardreturnCleanup in do_stackoverflow");E 2D 19  }if(incallp){E 19I 19      }    if(incallp)      {E 19D 10 	savenext=CURRENTFX->nextblock; /* save old nextblock */E 10I 10	savenext=CURRENTFX->nextblock; /* save old nextblock */E 10D 19 }BEFORE_CONTEXTSW;/* Don't Use MIDPUNT and Don't care IFPAGE */E 19I 19      }E 19D 13/* Call MOVEFRAME directory */E 13I 13D 19/* Call MOVEFRAME directly */E 13 if((newfx=(DLword)moveframe(CURRENTFX)) == 0xFFFF) {E 19I 19    BEFORE_CONTEXTSW;	/* Don't Use MIDPUNT and Don't care IFPAGE */    /* Call MOVEFRAME directly */    if((newfx=(DLword)moveframe(CURRENTFX)) == 0xFFFF)      {E 19	 /* To make immidiately call HARDRESET */	Irq_Stk_Check = 0;D 10	Irq_Stk_End=0; 		E 10I 10	Irq_Stk_End=0;E 10	return(1); /* Whole space exausted */D 19 }E 19I 19      }E 19D 19/* Return from MOVEFRAME directory */E 19D 10 E 10I 10E 10D 19 PVar=(DLword*)Addr68k_from_StkOffset(newfx+FRAMESIZE); movedistance= ((int)PVar-(int)oldPVar) >>1; AFTER_CONTEXTSW;if(incallp){E 19I 19    /* Return from MOVEFRAME directory */    PVar=(DLword*)Addr68k_from_StkOffset(newfx+FRAMESIZE);    movedistance= ((int)PVar-(int)oldPVar) >>1;    AFTER_CONTEXTSW;    if(incallp)      {E 19	/* set next(it pointed to old IVar) with offset */D 10	CURRENTFX->nextblock= savenext + movedistance;  E 10I 10	CURRENTFX->nextblock= savenext + movedistance;I 19E 19E 10	/* including Last Arg(kept in TOS */	S_CHECK(FuncObj == (struct fnhead *)			Addr68k_from_LADDR(D 10				(CURRENTFX->hi2fnheader << 16) | E 10I 10				(CURRENTFX->hi2fnheader << 16) |E 10D 19				CURRENTFX->lofnheader) );E 19I 19				CURRENTFX->lofnheader),		 "in call, but stack frame doesn't match FN being executed." );E 19	CHECK_FX(CURRENTFX);	 /* We should re-Set up IVAR,CURRENTFX->nextblock */	 IVar += movedistance;D 19} /* incallp */E 19I 19      } /* incallp */E 19D 19  return(0); /* Normal return *//* If  incallp ,we CAN continue executing FN or APPLY by just returning *//* new PVar will set in funcall */}/* end do_stackoverflow */E 19I 19    return(0); /* Normal return */    /* If  incallp ,we CAN continue executing FN or APPLY by just returning */    /* new PVar will set in funcall */  }/* end do_stackoverflow */E 19I 19E 19/******************************************************************//*        Func Name :     moveframe(oldfx68k)D 10        E 10I 10E 10        Edited by :     Take(March 14, 1988)*//******************************************************************/LispPTR moveframe(oldfx68k)D 19 register FX *oldfx68k;{ register int size; register DLword *next68k; register DLword *new68k; DLword *freestackblock(); DLword *extendstack(); int nametbl_on_stk =NIL;I 9 int at_eos = NIL;E 19I 19  register FX *oldfx68k;  {    register int size;    register DLword *next68k;    register DLword *new68k;    DLword *freestackblock();    DLword *extendstack();    int nametbl_on_stk =NIL;    int at_eos = NIL;E 19E 9D 10 E 10I 10E 10D 19 PreMoveFrameCheck(oldfx68k);E 19I 19    PreMoveFrameCheck(oldfx68k);E 19D 4E 4I 4#ifdef FLIPCURSORE 4D 19 flip_cursorbar(10);E 19I 19    flip_cursorbar(10);E 19I 4#endifE 4D 19 size = FX_size(oldfx68k) + DLWORDSPER_CELL; S_CHECK(size > 0); next68k=Addr68k_from_StkOffset(oldfx68k->nextblock);E 19I 19    size = FX_size(oldfx68k) + DLWORDSPER_CELL;    S_CHECK(size > 0, "size of stack block < 0");    next68k=Addr68k_from_StkOffset(oldfx68k->nextblock);E 19I 9tryfsb:E 9D 19 if(FSBP(next68k))  {E 19I 19    if(FSBP(next68k))      {E 19        /* merge free blocks */D 9        for(new68k = next68k + FSB_size(next68k);			FSBP(new68k); new68k+= FSB_size(new68k))E 9I 9        new68k = next68k + FSB_size(next68k);D 19	if(FSBP(new68k)){	    for(;FSBP(new68k); new68k+= FSB_size(new68k))E 19I 19	if(FSBP(new68k))	  {	    for(;FSBP(new68k); new68k = new68k + FSB_size(new68k))E 19E 9                FSB_size(next68k) += FSB_size(new68k);D 9        if(StkOffset_from_68K(new68k) == InterfacePage->endofstack)E 9I 9	    new68k=(DLword *)oldfx68k;	    goto out;D 19	}        else if(StkOffset_from_68K(new68k) == InterfacePage->endofstack)E 9        {D 9                if(extendstack() != NIL)E 9I 9	  if((StkOffset_from_68K(new68k) > LOLOC(*GuardStackAddr_word)) &&E 19I 19	  }	else if(StkOffset_from_68K(new68k) == InterfacePage->endofstack)          {	    if((StkOffset_from_68K(new68k) > LOLOC(*GuardStackAddr_word)) &&E 19		((*STACKOVERFLOW_word)== NIL) )D 19	    at_eos = T; /* search FSB in earler STACK area by freestackblock */          else if(extendstack() != NIL)E 9                 {                        new68k=(DLword *)oldfx68k;                        goto out;                 }D 9			else			 {				/* These lines are different from Original Code */				return(0xFFFF); /* No space */			 }        }E 9I 9		else		 {			/* These lines are different from Original Code */			return(0xFFFF); /* No space */		 }        }/* else if end */E 19I 19	      at_eos = T; /* search FSB in earler STACK area by freestackblock */            else if(extendstack() != NIL)	      {		new68k=(DLword *)oldfx68k;		goto out;	      }	    else	      {		/* These lines are different from Original Code */		return(0xFFFF); /* No space */	      }          }/* else if end */E 19E 9D 10        E 10I 10E 10D 19  }E 19I 19      }E 19D 19CHECK_FX(oldfx68k);E 19I 19    CHECK_FX(oldfx68k);E 19D 19S_CHECK(oldfx68k->usecount == 0);D 13 /* we don't check\INTERRUPTABLE */E 13I 13 /* we don't check \INTERRUPTABLE */E 19I 19    S_CHECK(oldfx68k->usecount == 0, "use count > 0");    /* we don't check \INTERRUPTABLE */E 19E 13D 27E 27I 27#ifdef BIGVM    if(oldfx68k->validnametable && ((oldfx68k->nametable>>16)==STK_HI))#elseE 27D 19if(oldfx68k->validnametable && (oldfx68k->hi2nametable==STK_HI)) {   /* frame contains a name table, so we care that the alignmentE 19I 19    if(oldfx68k->validnametable && (oldfx68k->hi2nametable==STK_HI))I 27#endif /* BIGVM */E 27      {	/* frame contains a name table, so we care that the alignmentE 19	 of the new block be same as old */#ifdef STACKCHECK        { DLword n;D 19                n=oldfx68k->lonametable;                if((n <= StkOffset_from_68K(oldfx68k))E 19I 19	  n=oldfx68k->lonametable;	  if((n <= StkOffset_from_68K(oldfx68k))E 19                  && (n >= oldfx68k->nextblock))D 19                        {WARN("moveframe:check!!",						sff(LADDR_from_68k(oldfx68k)));}E 19I 19	    {  WARN("moveframe:check!!", sff(LADDR_from_68k(oldfx68k)));}E 19        }#endifD 19   nametbl_on_stk = T;   /* Find a free stack block */   new68k=freestackblock(size,oldfx68k,        (LADDR_from_68k(oldfx68k)-DLWORDSPER_CELL)% DLWORDSPER_QUAD); }else  new68k=freestackblock(size,oldfx68k,-1);/* Not needed to align */E 19I 19	nametbl_on_stk = T;	/* Find a free stack block */	new68k=freestackblock(size,oldfx68k,               (LADDR_from_68k(oldfx68k)-DLWORDSPER_CELL)% DLWORDSPER_QUAD);      }    else	new68k=freestackblock(size,oldfx68k,-1);/* Not needed to align */E 19D 19 if(new68k==0)	return(0xFFFF);  /* exhausted */E 19I 19    if(new68k==0) return(0xFFFF);  /* exhausted */E 19I 9D 19if( at_eos && ((unsigned int)new68k > (unsigned int)oldfx68k)) {  /* extendstack already done in freestackblock */   ((STKBLK*)new68k)->flagword = STK_FSB_WORD;    goto tryfsb;}E 19I 19    if( at_eos && ((unsigned int)new68k > (unsigned int)oldfx68k))      {	/* extendstack already done in freestackblock */	((STKBLK*)new68k)->flagword = STK_FSB_WORD;	goto tryfsb;      }E 19E 9D 19/* blt(dest,source,size) *//* copy frame and dummy bf pointer too */blt(new68k,(((DLword*)oldfx68k) - DLWORDSPER_CELL),size);E 19I 19    /* copy frame and dummy bf pointer too */    blt(new68k,(((DLword*)oldfx68k) - DLWORDSPER_CELL),size);E 19D 19((Bframe*)new68k)->residual =T;D 16((DLword*)new68k)+= DLWORDSPER_CELL; /* now NEW points to the FX */E 16I 16new68k += DLWORDSPER_CELL; /* now NEW points to the FX */E 16((FX*)new68k)->nextblock=(StkOffset_from_68K(new68k) + size)-DLWORDSPER_CELL;/* (CHECK (fetch (BF CHECKED) of (fetch (FX BLINK) of OLDFRAME)))*/CHECK_BF(Addr68k_from_StkOffset(GETBLINK(oldfx68k)));/* Set true BFptr,not residual */SETBLINK(new68k,GETBLINK(oldfx68k));E 19I 19    ((Bframe*)new68k)->residual =T;    new68k = new68k + DLWORDSPER_CELL; /* now NEW points to the FX */    ((FX*)new68k)->nextblock = (StkOffset_from_68K(new68k) + size)				-DLWORDSPER_CELL;    /* (CHECK (fetch (BF CHECKED) of (fetch (FX BLINK) of OLDFRAME)))*/    CHECK_BF(Addr68k_from_StkOffset(GETBLINK(oldfx68k)));E 19D 19if(nametbl_on_stk) { S_CHECK(( (((int)new68k - (int)oldfx68k)>>1) % DLWORDSPER_QUAD) == 0);E 19I 19    /* Set true BFptr,not residual */    SETBLINK(new68k,GETBLINK(oldfx68k));E 19D 19  ((FX*)new68k)->lonametable += (((int)new68k - (int)oldfx68k)>>1); }if( ((Bframe*)DUMMYBF(oldfx68k))->residual ) {E 19I 19    if(nametbl_on_stk)      {	S_CHECK(( (((int)new68k - (int)oldfx68k)>>1) % DLWORDSPER_QUAD) == 0,		 "Misalignment of stack blocks, with nametable on stack");D 27E 27I 27#ifdef BIGVM	((FX*)new68k)->nametable += (((int)new68k - (int)oldfx68k)>>1);#elseE 27	((FX*)new68k)->lonametable += (((int)new68k - (int)oldfx68k)>>1);I 27#endifE 27      }    if( ((Bframe*)DUMMYBF(oldfx68k))->residual )      {E 19        MAKEFREEBLOCK(((DLword*)oldfx68k)-DLWORDSPER_CELL , size);D 19 }else {E 19I 19      }    else      {E 19        MAKEFREEBLOCK(oldfx68k,size - DLWORDSPER_CELL);D 19 }E 19I 19      }E 19out:I 4#ifdef FLIPCURSORE 4D 19 flip_cursorbar(10);E 19I 19    flip_cursorbar(10);E 19I 4#endifE 4D 19 return(S_POSITIVE|StkOffset_from_68K(new68k));} /* moveframe end */E 19I 19    return(S_POSITIVE|StkOffset_from_68K(new68k));  } /* moveframe end */E 19/******************************************************************//*        Func Name :     extendstack()D 7        Desc.     :     if LastStackAddr is exceeded,then allocate E 7I 7D 10        Desc.     :     if LastStackAddr_word is exceeded,then allocate E 10I 10        Desc.     :     if LastStackAddr_word is exceeded,then allocateE 10E 7                        one new lisppage for STACK area.D 10                E 10I 10E 10        Edited by :     Take(March 14, 1988)D 10                        E 10I 10E 10*//******************************************************************/DLword *extendstack()D 19{ register LispPTR easp; register LispPTR scanptr;E 19I 19  {    register LispPTR easp;    register LispPTR scanptr;E 19D 19 easp = InterfacePage->endofstack;E 19I 19    easp = InterfacePage->endofstack;E 19D 19 if (easp < LOLOC(*LastStackAddr_word))  {        if((easp > LOLOC(*GuardStackAddr_word)) &&E 19I 19    if (easp < LOLOC(*LastStackAddr_word))      {	if((easp > LOLOC(*GuardStackAddr_word)) &&E 19                ((*STACKOVERFLOW_word)== NIL) )D 6         {                ((INTSTAT*)INTERRUPTSTATE_word)->stackoverflow = ATOM_T;E 6I 6D 19         {	extended_frame = 1;                ((INTSTAT*)Addr68k_from_LADDR(*INTERRUPTSTATE_word))->stackoverflow = 1;E 6                *STACKOVERFLOW_word = *PENDINGINTERRUPT_word=ATOM_T;         }E 19I 19	  { extended_frame = 1;            ((INTSTAT*)Addr68k_from_LADDR(*INTERRUPTSTATE_word))->stackoverflow = 1;             *STACKOVERFLOW_word = *PENDINGINTERRUPT_word=ATOM_T;          }E 19        newpage(STK_OFFSET|(scanptr=easp+2));        /* I don't concern about DOLOCKPAGES */        MAKEFREEBLOCK(Addr68k_from_StkOffset(scanptr),DLWORDSPER_PAGE-2);D 19	   InterfacePage->endofstack = scanptr=easp+DLWORDSPER_PAGE;E 19I 19	InterfacePage->endofstack = scanptr=easp+DLWORDSPER_PAGE;E 19        SETUPGUARDBLOCK(		Addr68k_from_StkOffset(InterfacePage->endofstack), 2);        MAKEFREEBLOCK(Addr68k_from_StkOffset(easp) , 2);        return((DLword*)Addr68k_from_StkOffset(scanptr));D 19  } else   return(NIL);} /* end extendstack */E 19I 19      }    else return(NIL);  } /* end extendstack */E 19/******************************************************************//*        Func Name :     freestackblock(n,sart,align)        Desc.     :     Search the FSB has specified size n or more                        Return useful area's ptr.				   If there is no space for STACK,return 0        Edited by :     take(15-Jul-87)                        take(11-Apr-88)*//******************************************************************/DLword *freestackblock( n , start68k , align )D 10 DLword n ;     /* size you want(in DLword) */E 10I 10D 19 DLword n;     /* size you want(in DLword) */E 10 StackWord *start68k; /* searching will start68k at here */D 10 int align ; /* if Negative,it needn't align */E 10I 10 int align; /* if Negative,it needn't align */E 10{ register int wantedsize;D 10 register StackWord *scanptr68k ; register StackWord *orig68k ;E 10I 10 register StackWord *scanptr68k; register StackWord *orig68k;E 10 register STKBLK *freeptr68k; register StackWord *easp68k; register DLword freesize;E 19I 19  DLword n;     /* size you want(in DLword) */  StackWord *start68k; /* searching will start68k at here */  int align; /* if Negative,it needn't align */  {    register int wantedsize;    register StackWord *scanptr68k;    register StackWord *orig68k;    register STKBLK *freeptr68k;    register StackWord *easp68k;    register DLword freesize;E 19D 19 DLword *extendstack();E 19I 19    DLword *extendstack();E 19D 19 /* compute actually size you needed */D 10 wantedsize = n + STACKAREA_SIZE + MINEXTRASTACKWORDS ;E 10I 10 wantedsize = n + STACKAREA_SIZE + MINEXTRASTACKWORDS;E 19I 19    /* compute actually size you needed */    wantedsize = n + STACKAREA_SIZE + MINEXTRASTACKWORDS;E 19E 10D 10 easp68k =(StackWord*) (Addr68k_from_StkOffset(InterfacePage->endofstack)) ;E 10I 10D 19 easp68k =(StackWord*) (Addr68k_from_StkOffset(InterfacePage->endofstack));E 19I 19    easp68k =(StackWord*) (Addr68k_from_StkOffset(InterfacePage->endofstack));E 19E 10D 19/*** DEBUG ***/S_CHECK(n>2);S_CHECK(start68k != 0);S_CHECK(start68k >= (StackWord*)Addr68k_from_StkOffset(InterfacePage->stackbase));E 19I 19    /*** DEBUG ***/    S_CHECK(n>2, "asking for block < 2 words long");    S_CHECK(start68k != 0, "start68k = 0");    S_CHECK(start68k >=	    (StackWord*)Addr68k_from_StkOffset(InterfacePage->stackbase),	    "start68k before stack base");E 19D 10STARTOVER :   if(start68k) E 10I 10STARTOVER :D 19  if(start68k)E 10	scanptr68k =start68k;D 10  else E 10I 10  elseE 10	scanptr68k = (StackWord *)Addr68k_from_StkOffset(InterfacePage->stackbase);E 19I 19    if(start68k) scanptr68k = start68k;    else scanptr68k =	    (StackWord *)Addr68k_from_StkOffset(InterfacePage->stackbase);E 19D 12SCAN :  switch((unsigned)(scanptr68k->flags)){E 12I 12D 19SCAN :  switch((unsigned)(STKWORD(scanptr68k)->flags)){E 12D 10        case STK_FSB :  goto FREESCAN ;E 10I 10        case STK_FSB :  goto FREESCAN;E 10                                break;        case STK_GUARD: if(scanptr68k < easp68k)E 19I 19SCAN :  switch((unsigned)(STKWORD(scanptr68k)->flags))	  {            case STK_FSB :  goto FREESCAN;                            break;            case STK_GUARD: if(scanptr68k < easp68k)E 19                            goto FREESCAN;D 19                        if (start68k) {E 19I 19                            if (start68k)			      {E 19                                scanptr68k =(StackWord *)Addr68k_from_StkOffsetD 19                                (InterfacePage->stackbase);D 10                                goto SCAN ; }                        else goto NEWPAGE ;E 10I 10                                goto SCAN; }                        else goto NEWPAGE;E 10                        break;        case STK_FX :   scanptr68k =(StackWord *)Addr68k_from_StkOffset(					((FX*)scanptr68k)->nextblock);D 10                        break ;E 10I 10                        break;E 10        default :       orig68k = scanptr68k;E 19I 19                                		(InterfacePage->stackbase);                                goto SCAN;			      }                            else goto NEWPAGE;                            break;            case STK_FX :   scanptr68k =(StackWord *)Addr68k_from_StkOffset(					    ((FX*)scanptr68k)->nextblock);                            break;            default :       orig68k = scanptr68k;E 19D 12                        while(scanptr68k->flags != STK_BF) {                                S_CHECK(scanptr68k->flags==STK_NOTFLG);E 12I 12D 19                        while(STKWORD(scanptr68k)->flags != STK_BF) {                                S_CHECK(STKWORD(scanptr68k)->flags==STK_NOTFLG);E 12D 10                                ((DLword *)scanptr68k) += DLWORDSPER_CELL ; E 10I 10D 16                                ((DLword *)scanptr68k) += DLWORDSPER_CELL;E 16I 16D 18                                scanptr68k += DLWORDSPER_CELL;E 18I 18			    scanptr68k = (StackWord *)					  ((DLword *)scanptr68k					        + DLWORDSPER_CELL);E 18E 16E 10                         };E 19I 19                            while(STKWORD(scanptr68k)->flags != STK_BF)			      {D 20                                S_CHECK(STKWORD(scanptr68k)->flags==STK_NOTFLG,					"NOTFLG not on");E 20I 20                                S_WARN(STKWORD(scanptr68k)->flags==STK_NOTFLG,					"NOTFLG not on", scanptr68k);E 20			        scanptr68k = (StackWord *)					       (((DLword *)scanptr68k)					            + DLWORDSPER_CELL);                             };E 19D 10#ifdef STACKCHECK                        E 10I 10#ifdef STACKCHECKE 10D 19				   if(((Bframe*)scanptr68k)->residual)D 10                          { if(scanptr68k != orig68k) E 10I 10                          { if(scanptr68k != orig68k)E 10                             {						 WARN("freestackblock:scanptr68k !=org",						printf(":0x%x\n",LADDR_from_68k(scanptr68k)));					   }					}				   else					{D 10					   if(((Bframe*)scanptr68k)->ivar E 10I 10					   if(((Bframe*)scanptr68k)->ivarE 10						!= StkOffset_from_68K(orig68k))						{							WARN("BF doesn't point TopIVAR",printf(":0x%x\n",LADDR_from_68k(scanptr68k)));						}					}E 19I 19			   if(((Bframe*)scanptr68k)->residual)                             { if(scanptr68k != orig68k)                                {				  WARN("freestackblock:scanptr68k !=org",					printf(":0x%x\n",						LADDR_from_68k(scanptr68k)));				}			     }			  else			    {			      if(((Bframe*)scanptr68k)->ivar					!= StkOffset_from_68K(orig68k))				{				  WARN("BF doesn't point TopIVAR",					printf(":0x%x\n",						LADDR_from_68k(scanptr68k)));				}			    }E 19#endifD 10                        ((DLword*)scanptr68k) += DLWORDSPER_CELL ;E 10I 10D 16                        ((DLword*)scanptr68k) += DLWORDSPER_CELL;E 16I 16D 18                        scanptr68k += DLWORDSPER_CELL;E 18I 18D 19			/* Used to be a +=, but SunOS4/Sparc compiles it wrong */                        scanptr68k = (StackWord *)					((DLword *)scanptr68k + DLWORDSPER_CELL);E 18E 16E 10                        break;E 19I 19		/* Used to be a +=, but SunOS4/Sparc compiles it wrong */                            scanptr68k = (StackWord *)					    ((DLword *)scanptr68k						+ DLWORDSPER_CELL);                            break;E 19      } /* end switch(scanptr68k */D 19NEXT: if(scanptr68k != start68k){D 10         S_CHECK(scanptr68k <=easp68k) ;         goto SCAN ;E 10I 10         S_CHECK(scanptr68k <=easp68k);         goto SCAN;E 10        }NEWPAGE :       easp68k =(StackWord*)extendstack();D 10			if(easp68k)                	goto STARTOVER;                else  E 10I 10		if(easp68k)				goto STARTOVER;                elseE 10			 {				warn("freestackblock:StackFull MP9319");				return(0);			 }E 19I 19NEXT: if(scanptr68k != start68k)      {	S_CHECK(scanptr68k <=easp68k, "scan ptr past end of stack");	goto SCAN;      }NEWPAGE : easp68k =(StackWord*)extendstack();	  if(easp68k) goto STARTOVER;	  else	   {	    warn("freestackblock:StackFull MP9319");	    return(0);	   }E 19FREESCAN :      freeptr68k=(STKBLK *)scanptr68k;D 10                freesize=FSB_size(freeptr68k) ;E 10I 10                freesize=FSB_size(freeptr68k);E 10D 19FREE:           scanptr68k = (StackWord *)((DLword *)freeptr68k + freesize);E 19I 19FREE:           scanptr68k = (StackWord *)(((DLword *)freeptr68k) + freesize);E 19D 12                switch((unsigned)(scanptr68k->flags)){E 12I 12D 19                switch((unsigned)(STKWORD(scanptr68k)->flags)){E 12D 10                        case STK_FSB : freesize += FSB_size(scanptr68k) ;                                        goto FREE ;D 8                                        break ;E 8I 8                                    /*  break ; */E 10I 10                        case STK_FSB : freesize += FSB_size(scanptr68k);                                        goto FREE;                                    /*  break; */E 10E 8                        case STK_GUARD : if(scanptr68k<easp68k){                                                freesize += FSB_size(scanptr68k);D 10                                                goto FREE ;E 10I 10                                                goto FREE;E 10                                         }                                        break;                        default :       break;E 19I 19                switch((unsigned)(STKWORD(scanptr68k)->flags))		  {		    case STK_FSB:  freesize = freesize + FSB_size(scanptr68k);                                   goto FREE;                                    		    case STK_GUARD: if(scanptr68k<easp68k)				      {					freesize = freesize + FSB_size(scanptr68k);					goto FREE;                                       }                                     break;E 19D 10                E 10I 10E 10D 19                } /* end switch(scanp.. */E 19I 19		    default :       break;E 19D 19 if(freesize >= wantedsize){   if((align<0) || (align==(StkOffset_from_68K(freeptr68k) % DLWORDSPER_QUAD)))        wantedsize= MINEXTRASTACKWORDS;D 10   else E 10I 10   elseE 10        wantedsize= MINEXTRASTACKWORDS+DLWORDSPER_CELL;E 19I 19 		  } /* end switch(scanp.. */E 19D 19   scanptr68k =(StackWord*) (((DLword *)freeptr68k) + wantedsize);E 19I 19    if(freesize >= wantedsize)      {	if((align<0) ||	    (align==(StkOffset_from_68K(freeptr68k) % DLWORDSPER_QUAD)))          wantedsize= MINEXTRASTACKWORDS;	else wantedsize= MINEXTRASTACKWORDS+DLWORDSPER_CELL;E 19D 19   SETUPGUARDBLOCK(scanptr68k, n);   MAKEFREEBLOCK(freeptr68k,wantedsize);   MAKEFREEBLOCK(((DLword*)scanptr68k) + n, freesize - wantedsize -n);   return((DLword*)scanptr68k);  }D 10 else E 10I 10 elseE 10   MAKEFREEBLOCK( freeptr68k, freesize);E 19I 19	scanptr68k =(StackWord*) (((DLword *)freeptr68k) + wantedsize);E 19D 10goto NEXT ;E 10I 10D 19goto NEXT;E 10} /* freestackblock end */E 19I 19	SETUPGUARDBLOCK(scanptr68k, n);	MAKEFREEBLOCK(freeptr68k,wantedsize);	MAKEFREEBLOCK(((DLword*)scanptr68k) + n, freesize - wantedsize -n);	return((DLword*)scanptr68k);      }    else MAKEFREEBLOCK( freeptr68k, freesize);E 19I 19    goto NEXT;  } /* freestackblock end */E 19/******************************************************************//*        Func Name :     decusecount68k(frame)        Desc.     :     Search the FSB has specified size n or more                        Return useful are ptr.        Edited by :     take(March 14, 1988)*//******************************************************************/#define BF_size(ptr68k) ((StkOffset_from_68K(ptr68k)) - ((Bframe*)(ptr68k))->ivar + 2)decusecount68k(frame68k)D 10  register FX *frame68k ;E 10I 10  register FX *frame68k;E 10{ DLword *alink68k; register Bframe *blink68k; DLword *clink68k; register DLword *ivar68k; register int size;if(FX_INVALIDP(frame68k)) return;CHECK_FX(frame68k);/* I don't check if \INTERRUPTABLE is NIL */ while(StkOffset_from_68K(frame68k)) {        if(frame68k->usecount != 0)        {                frame68k->usecount--;                return;         }        else        {                alink68k = Addr68k_from_StkOffset(GETALINK(frame68k));                blink68k =(Bframe*) Addr68k_from_StkOffset(GETBLINK(frame68k));                clink68k = Addr68k_from_StkOffset(GETCLINK(frame68k));                size = FX_size(frame68k);                if(((Bframe*)DUMMYBF(frame68k))->residual)                { /* this frame has dummy BF */                        MAKEFREEBLOCK(((DLword*)frame68k) -DLWORDSPER_CELL,size+DLWORDSPER_CELL);                }                else                {                        MAKEFREEBLOCK(frame68k,size);                }                if(blink68k->usecnt !=0)                {                        blink68k->usecnt--;                }                else                {                    /***    ivar68k=Addr68k_from_StkOffset(blink68k->ivar);D 11                        *ivar68k=STK_FSB_WORD;D 10                        *(ivar68k+1)=ivar68k -(DLword *)blink68k +2 ; **/E 10I 10                        *(ivar68k+1)=ivar68k -(DLword *)blink68k +2; **/E 11I 11                        GETWORD(ivar68k)=STK_FSB_WORD;                        GETWORD(ivar68k+1)=ivar68k -(DLword *)blink68k +2; **/E 11E 10				MAKEFREEBLOCK(Addr68k_from_StkOffset(blink68k->ivar),							BF_size(blink68k));                }                if(alink68k!= clink68k)                        decusecount68k(alink68k);D 10                frame68k = (FX*)clink68k ;E 10I 10                frame68k = (FX*)clink68k;E 10        } /* else end */ }/*while end */} /* decusecount68k end */#ifdef ORG_FILPCORSORBARextern DLword *EmCursorBitMap68K;extern int LispWindowFd;extern struct cursor CurrentCursor; flip_cursorbar(n)int n;{D 11 *(EmCursorBitMap68K +n) = ~(*(EmCursorBitMap68K +n));E 11I 11 GETWORD(EmCursorBitMap68K +n) = ~(GETWORD(EmCursorBitMap68K +n));I 14#ifdef SUNDISPLAYE 14E 11 win_setcursor(LispWindowFd,&CurrentCursor);I 14D 26#endif SUNDISPLAYE 26I 26#endif /* SUNDISPLAY */E 26#ifdef XWINDOWD 17 Set_DisplayCursor( 0, 0 );E 17I 17 Set_XCursor( 0, 0 );E 17D 26#endif XWINDOWE 26I 26#endif /* XWINDOW */E 26E 14}#elseD 5extern struct pixrect *ScreenBitMap;E 5I 5extern short *DisplayRegion68k;extern int DisplayRasterWidth;E 5 flip_cursorbar(n)int n;{D 5   pr_rop(ScreenBitMap,0,0,16,2*n,	PIX_NOT(PIX_SRC),ScreenBitMap,0,0);/* 16->width 2*n ->height */E 5I 5register short *word;word = DisplayRegion68k + (n * DisplayRasterWidth);D 11*(word) ^= 0xFFFF;E 11I 11GETWORD(word) ^= 0xFFFF;E 11E 5}#endif/**************************************************************//*                blt(dest,source,size)*//**************************************************************/blt(dest68k,source68k,nw) register DLword *source68k;D 10 register DLword *dest68k ;E 10I 10 register DLword *dest68k;E 10  int nw;{/******* OLD def , Due to C compiler's bug, we can't use pre-decriment for register valD 10  source68k += nw ;  dest68k += nw ;E 10I 10  source68k += nw;  dest68k += nw;E 10  while(nw)D 10  {     *(--dest68k)= *(--source68k) ;E 10I 10  {D 11    *(--dest68k)= *(--source68k);E 11I 11    GETWORD(--dest68k)= GETWORD(--source68k);E 11E 10    nw--;   }**** OLD def ****/D 10  source68k += nw-1 ;  dest68k += nw-1 ;E 10I 10D 19  source68k += nw-1;  dest68k += nw-1;E 19I 19  source68k = source68k + nw-1;  dest68k = dest68k + nw-1;E 19E 10  while(nw--)D 10  {     *(dest68k--)= *(source68k--) ;E 10I 10  {D 11    *(dest68k--)= *(source68k--);E 11I 11D 19    GETWORD(dest68k--)= GETWORD(source68k--);E 19I 19    GETWORD(dest68k--) = GETWORD(source68k--);E 19E 11E 10  }}I 19E 19/**************************************************************//*		stack_check(start68k)D 10		for DEBUG E 10I 10		for DEBUGE 10*//**************************************************************/stack_check(start68k)D 23 StackWord *start68k;{D 10   StackWord *scanptr68k ;E 10I 10   StackWord *scanptr68k;E 10   StackWord *endstack68k;   DLword *top_ivar;   DLword save_nextblock;   DLword savestack1,savestack2;   DLword setflg=NIL;I 9   DLword freesize;E 23I 23  StackWord *start68k;  {    StackWord *scanptr68k;    StackWord *endstack68k;    DLword *top_ivar;    DLword save_nextblock;    DLword savestack1,savestack2;    DLword setflg=NIL;    DLword freesize;E 23E 9I 9#ifdef FSBCHECKD 23   struct big_fsbs {   DLword offset; DLword size;} bigFSB[100];   int bigFSBindex=0;E 23I 23    struct big_fsbs {   DLword offset; DLword size;} bigFSB[100];    int bigFSBindex=0;E 23D 23   bzero((char*)bigFSB, 100 * 2 * 2);E 23I 23    bzero((char*)bigFSB, 100 * 2 * 2);E 23#endifE 9D 23  if((CURRENTFX->nextblock != StkOffset_from_68K(CurrentStackPTR))E 23I 23    if((CURRENTFX->nextblock != StkOffset_from_68K(CurrentStackPTR))E 23	||(!FSBP(CurrentStackPTR)))D 23  {E 23I 23      {E 23	if((DLword*)CURRENTFX >= CurrentStackPTR)D 23	{		WARN("CURRENTFX >= CurrentStackPTR??\n",		printf("CURRENTFX=0x%x,CurrentStackPTR=0x%x\n",			LADDR_from_68k(CURRENTFX),LADDR_from_68k(CurrentStackPTR)));	}E 23I 23	  {	    WARN("CURRENTFX >= CurrentStackPTR??\n",	    printf("CURRENTFX=0x%x,CurrentStackPTR=0x%x\n",		    LADDR_from_68k(CURRENTFX),LADDR_from_68k(CurrentStackPTR)));	  }E 23	setflg=T;D 3	printf("set CURRENTFX->nextblock in debugger \n");E 3I 3	printf("set CURRENTFX->nextblock in debugger. But it will be reset after this check \n");E 3	save_nextblock=CURRENTFX->nextblock;D 11	savestack1= *(CurrentStackPTR+2);	savestack2= *(CurrentStackPTR+3);E 11I 11	savestack1= GETWORD(CurrentStackPTR+2);	savestack2= GETWORD(CurrentStackPTR+3);E 11	CURRENTFX->nextblock=StkOffset_from_68K(CurrentStackPTR+2);D 11	*(CurrentStackPTR+2)=STK_FSB_WORD;	*(CurrentStackPTR+3)= (((int)EndSTKP-(int)(CurrentStackPTR+2))>>1);E 11I 11	GETWORD(CurrentStackPTR+2)=STK_FSB_WORD;	GETWORD(CurrentStackPTR+3)= (((int)EndSTKP-(int)(CurrentStackPTR+2))>>1);E 11D 23 }E 23I 23      }E 23D 10  if(start68k) E 10I 10D 23  if(start68k)E 10	scanptr68k =start68k;D 10  else E 10I 10  elseE 10scanptr68k= (StackWord *)Addr68k_from_StkOffset(InterfacePage->stackbase);endstack68k=(StackWord *)Addr68k_from_StkOffset(InterfacePage->endofstack);E 23I 23    if(start68k) scanptr68k =start68k;    else scanptr68k =	  (StackWord *)Addr68k_from_StkOffset(InterfacePage->stackbase);    endstack68k=(StackWord *)Addr68k_from_StkOffset(InterfacePage->endofstack);E 23D 12if(endstack68k->flags !=STK_GUARD) printf("?? endstack is not GUARD BLK\n");E 12I 12D 23if(STKWORD(endstack68k)->flags !=STK_GUARD) printf("?? endstack is not GUARD BLK\n");E 12while(scanptr68k <endstack68k){D 12  switch((unsigned)(scanptr68k->flags)){E 12I 12  switch((unsigned)(STKWORD(scanptr68k)->flags)){E 12D 9        case STK_FSB :	((DLword*)scanptr68k) +=FSB_size(scanptr68k) ;E 9I 9        case STK_FSB :	freesize= FSB_size(scanptr68k);E 23I 23    if(STKWORD(endstack68k)->flags !=STK_GUARD)      printf("?? endstack is not GUARD BLK\n");    while(scanptr68k <endstack68k)      {	switch((unsigned)(STKWORD(scanptr68k)->flags))	  {	    case STK_FSB :	freesize= FSB_size(scanptr68k);				if (freesize == 0)				  {D 24				    WARN("FSB freesize = 0!",);E 24I 24				    warn("FSB freesize = 0!");E 24				  }E 23#ifdef FSBCHECK			if(freesize > STACKAREA_SIZE+MINEXTRASTACKWORDS){			    if(bigFSBindex < 100){				bigFSB[bigFSBindex].offset = StkOffset_from_68K(scanptr68k);				bigFSB[bigFSBindex].size = freesize;				bigFSBindex++;			    }			}#endifD 10			((DLword*)scanptr68k) +=freesize ;E 10I 10D 16			((DLword*)scanptr68k) +=freesize;E 16I 16D 18			scanptr68k += freesize;E 18I 18                        scanptr68k = (StackWord *)					((DLword *)scanptr68k + freesize);E 18E 16E 10E 9					putchar('F');					break;D 10	   case STK_GUARD:	((DLword*)scanptr68k) +=FSB_size(scanptr68k) ;E 10I 10D 16	   case STK_GUARD:	((DLword*)scanptr68k) +=FSB_size(scanptr68k);E 16I 16D 18	   case STK_GUARD:	scanptr68k += FSB_size(scanptr68k);E 18I 18D 23	   case STK_GUARD:	scanptr68k = (StackWord *)					((DLword *)scanptr68k + FSB_size(scanptr68k));E 18E 16E 10					putchar('G');					break;E 23I 23	     case STK_GUARD:	freesize = FSB_size(scanptr68k);				if (freesize == 0)				  {D 24				    WARN("Guard block freesize = 0!",);E 24I 24				    warn("Guard block freesize = 0!");E 24				  }				scanptr68k = (StackWord *)					((DLword *)scanptr68k + freesize);				putchar('G');				break;E 23        case STK_FX :	CHECK_FX(scanptr68k);					scanptr68k =(StackWord *)Addr68k_from_StkOffset(					((FX*)scanptr68k)->nextblock);					putchar('X');					break;	   default:		top_ivar=(DLword*)scanptr68k;D 12					while(scanptr68k->flags != STK_BF) {						if (scanptr68k->flags!=STK_NOTFLG)E 12I 12					while(STKWORD(scanptr68k)->flags != STK_BF) {						if (STKWORD(scanptr68k)->flags!=STK_NOTFLG)E 12						{D 11                                WARN("StackCheck:!=STK_NOTFLG",printf("content:0x%x\n",*scanptr68k));E 11I 11                                WARN("StackCheck:!=STK_NOTFLG",printf("content:0x%x\n",GETWORD(scanptr68k)));E 11						}D 10                                ((DLword *)scanptr68k) += DLWORDSPER_CELL ; E 10I 10D 16                                ((DLword *)scanptr68k) += DLWORDSPER_CELL;E 16I 16D 18                                scanptr68k += DLWORDSPER_CELL;E 18I 18				scanptr68k = (StackWord *)					((DLword *)scanptr68k + DLWORDSPER_CELL);E 18E 16E 10                           }/* while end */;					CHECK_BF(scanptr68k);					if(((Bframe*)scanptr68k)->residual)					 {						if((DLword*)scanptr68k != top_ivar)D 3							error("Residual has real IVAR");E 3I 3							printf("Residual has real IVAR:0x%x\n",LADDR_from_68k(scanptr68k));E 3					  }					else					 {D 10					   if(((Bframe*)scanptr68k)->ivar E 10I 10					   if(((Bframe*)scanptr68k)->ivarE 10						!= StkOffset_from_68K(top_ivar))D 3						error("BF doesn't point TopIVAR");E 3I 3						printf("BF doesn't point TopIVAR:0x%x\n",LADDR_from_68k(scanptr68k));E 3					  }D 10					((DLword *)scanptr68k) += DLWORDSPER_CELL ;E 10I 10D 16					((DLword *)scanptr68k) += DLWORDSPER_CELL;E 16I 16D 18					scanptr68k += DLWORDSPER_CELL;E 18I 18					scanptr68k = (StackWord *)							((DLword *)scanptr68k					      		  + DLWORDSPER_CELL);E 18E 16E 10					putchar('B');					break;  }/*switch end */D 10  if(scanptr68k != start68k) E 10I 10  if(scanptr68k != start68k)E 10  {	if(scanptr68k >endstack68k)	{		WARN("scanptr exceeded end stack",printf("scanptr68k=0x%x endstack68k=0x%x",scanptr68k,endstack68k));	}  }}/* while end */I 9#ifdef FSBCHECKif(bigFSBindex!=0){   int i;   printf("\nBIG FSB(s):\n");   for(i=0;i<bigFSBindex;i++){	printf("Offset: 0x%x , Size: 0x%x\n",bigFSB[i].offset,bigFSB[i].size);   }}#endifE 9D 3printf("\nStack Cehck done\n");E 3I 3printf("\nStack Check done\n");E 3 if(setflg) {	CURRENTFX->nextblock=save_nextblock;D 11	*(CurrentStackPTR+2)=savestack1;	*(CurrentStackPTR+3)=savestack2;E 11I 11	GETWORD(CurrentStackPTR+2)=savestack1;	GETWORD(CurrentStackPTR+3)=savestack2;E 11 }}/*stack_check end */I 23/**************************************************************//*		quick_stack_check()		for DEBUGING using FNSTKCHECK*//**************************************************************/quick_stack_check()  {    StackWord *start68k;    StackWord *scanptr68k;    StackWord *endstack68k;    DLword *top_ivar;    DLword save_nextblock;    DLword savestack1,savestack2;    DLword setflg=NIL;    DLword freesize;#ifdef FSBCHECK    struct big_fsbs {   DLword offset; DLword size;} bigFSB[100];    int bigFSBindex=0;    bzero((char*)bigFSB, 100 * 2 * 2);#endif    if((CURRENTFX->nextblock != StkOffset_from_68K(CurrentStackPTR))	||(!FSBP(CurrentStackPTR)))      {	if((DLword*)CURRENTFX >= CurrentStackPTR)	  {		return(0);	    WARN("CURRENTFX >= CurrentStackPTR??\n",	    printf("CURRENTFX=0x%x,CurrentStackPTR=0x%x\n",		    LADDR_from_68k(CURRENTFX),LADDR_from_68k(CurrentStackPTR)));	  }	setflg=T;	save_nextblock=CURRENTFX->nextblock;	savestack1= GETWORD(CurrentStackPTR+2);	savestack2= GETWORD(CurrentStackPTR+3);	CURRENTFX->nextblock=StkOffset_from_68K(CurrentStackPTR+2);	GETWORD(CurrentStackPTR+2)=STK_FSB_WORD;	GETWORD(CurrentStackPTR+3)= (((int)EndSTKP-(int)(CurrentStackPTR+2))>>1);      }    scanptr68k = start68k =	  (StackWord *)Addr68k_from_StkOffset(InterfacePage->stackbase);    endstack68k=(StackWord *)Addr68k_from_StkOffset(InterfacePage->endofstack);    if(STKWORD(endstack68k)->flags !=STK_GUARD)      printf("?? endstack is not GUARD BLK\n");    while(scanptr68k <endstack68k)      {	switch((unsigned)(STKWORD(scanptr68k)->flags))	  {	    case STK_FSB :	freesize= FSB_size(scanptr68k);				if (freesize == 0)				  {				    warn("FSB freesize = 0!");				    return(1);				  }#ifdef FSBCHECK			if(freesize > STACKAREA_SIZE+MINEXTRASTACKWORDS){			    if(bigFSBindex < 100){				bigFSB[bigFSBindex].offset = StkOffset_from_68K(scanptr68k);				bigFSB[bigFSBindex].size = freesize;				bigFSBindex++;			    }			}#endif                        scanptr68k = (StackWord *)					((DLword *)scanptr68k + freesize);					break;	     case STK_GUARD:	freesize = FSB_size(scanptr68k);				if (freesize == 0)				  {				    warn("Guard block freesize = 0!");				    return(1);				  }				scanptr68k = (StackWord *)					((DLword *)scanptr68k + freesize);				break;        case STK_FX :	CHECK_FX(scanptr68k);					scanptr68k =(StackWord *)Addr68k_from_StkOffset(					((FX*)scanptr68k)->nextblock);					break;	   default:		top_ivar=(DLword*)scanptr68k;					while(STKWORD(scanptr68k)->flags != STK_BF) {						if (STKWORD(scanptr68k)->flags!=STK_NOTFLG)						{                                warn("StackCheck:!=STK_NOTFLG");				printf("content:0x%x\n",GETWORD(scanptr68k));				return(1);						}				scanptr68k = (StackWord *)					((DLword *)scanptr68k + DLWORDSPER_CELL);                           }/* while end */;					CHECK_BF(scanptr68k);					if(((Bframe*)scanptr68k)->residual)					 {						if((DLword*)scanptr68k != top_ivar)							printf("Residual has real IVAR:0x%x\n",LADDR_from_68k(scanptr68k));					  }					else					 {					   if(((Bframe*)scanptr68k)->ivar						!= StkOffset_from_68K(top_ivar))						printf("BF doesn't point TopIVAR:0x%x\n",LADDR_from_68k(scanptr68k));					  }					scanptr68k = (StackWord *)							((DLword *)scanptr68k					      		  + DLWORDSPER_CELL);					break;  }/*switch end */  if(scanptr68k != start68k)  {	if(scanptr68k >endstack68k)	{		WARN("scanptr exceeded end stack",printf("scanptr68k=0x%x endstack68k=0x%x",scanptr68k,endstack68k));	}  }}/* while end */#ifdef FSBCHECKif(bigFSBindex!=0){   int i;   printf("\nBIG FSB(s):\n");   for(i=0;i<bigFSBindex;i++){	printf("Offset: 0x%x , Size: 0x%x\n",bigFSB[i].offset,bigFSB[i].size);   }}#endif if(setflg) {	CURRENTFX->nextblock=save_nextblock;	GETWORD(CurrentStackPTR+2)=savestack1;	GETWORD(CurrentStackPTR+3)=savestack2; } return(0);}/* quick_stack_check end */E 23check_FX(fx68k)FX *fx68k;{D 10	Bframe *dummybf,*mtmp; 	int mblink; 	if(((FX*)(fx68k))->flags != STK_FX) 		error("CheckFX:NOT FX"); 	dummybf=(Bframe*)DUMMYBF(fx68k); 	if(StkOffset_from_68K(dummybf) == GETBLINK(fx68k)) 			{goto checkfx_OK;} 	mblink=GETBLINK(fx68k); E 10I 10	Bframe *dummybf,*mtmp;	int mblink;	if(((FX*)(fx68k))->flags != STK_FX)		error("CheckFX:NOT FX");	dummybf=(Bframe*)DUMMYBF(fx68k);	if(StkOffset_from_68K(dummybf) == GETBLINK(fx68k))			{goto checkfx_OK;}	mblink=GETBLINK(fx68k);E 10	mtmp=(Bframe*)Addr68k_from_StkOffset(mblink);D 10	if( ( dummybf->residual != NIL ) && E 10I 10	if( ( dummybf->residual != NIL ) &&E 10		( dummybf->ivar == mtmp->ivar ) )			goto checkfx_OK;D 10	else E 10I 10	elseE 10		error("CheckFX:bad residual case");	checkfx_OK: return;} /* END check_FX */I 15E 15check_BF(bf68k) Bframe *bf68k;{ Bframe *iptr68k;D 10	if(bf68k->flags != STK_BF) 		error("checkBF:not BF1"); E 10I 10	if(bf68k->flags != STK_BF)		error("checkBF:not BF1");E 10	if(bf68k->residual == T)		return;	else	{	for(iptr68k=(Bframe*)Addr68k_from_StkOffset(bf68k->ivar);D 10		iptr68k <=(Bframe*)(((DLword*)bf68k)-2); 		iptr68k++ ) /* inc 2DLword */ 		{ 		  if(iptr68k->flags!=STK_NOTFLG)  			error("CheckBF:Not BF2"); 		} E 10I 10		iptr68k <=(Bframe*)(((DLword*)bf68k)-2);		iptr68k++ ) /* inc 2DLword */		{		  if(iptr68k->flags!=STK_NOTFLG)			error("CheckBF:Not BF2");		}E 10	}} /* end check_BF */I 22/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 22check_stack_rooms(fx68k)D 22FX *fx68k;{  int size;  DLword *freeptr68k,*endstk68k;E 22I 22  FX *fx68k;  {    int size;    DLword *freeptr68k,*endstk68k;E 22D 22  CHECK_FX(fx68k);  freeptr68k=Addr68k_from_StkOffset(fx68k->nextblock); if(!FSBP(freeptr68k))  error("check_stack_rooms:nextblock doesn't point FSB"); /*endstk68k=freeptr68k + FSB_size(freeptr68k); size=((int)endstk68k - (int)CurrentStackPTR) >> 1;*/ return(FSB_size(freeptr68k));E 22I 22    CHECK_FX(fx68k);    freeptr68k=Addr68k_from_StkOffset(fx68k->nextblock);    if(!FSBP(freeptr68k))    error("check_stack_rooms:  nextblock doesn't point to an FSB");    /*endstk68k=freeptr68k + FSB_size(freeptr68k);    size=((int)endstk68k - (int)CurrentStackPTR) >> 1;*/    return(FSB_size(freeptr68k));E 22D 10  E 10I 10E 10D 22} /* end check_stack_rooms */E 22I 22  } /* end check_stack_rooms */E 22E 1