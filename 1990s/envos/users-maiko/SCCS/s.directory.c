h57171s 00002/00000/01775d D 2.39 92/01/16 12:32:27 sybalsky 48 47c 386 deltases 00007/00000/01768d D 2.38 91/09/27 02:15:07 sybalsky 47 46c ISC port changeses 00003/00000/01765d D 2.37 91/04/09 17:06:51 sybalsky 46 45c Retrofit first round of changes from MIPS porting centeres 00002/00000/01763d D 2.36 91/01/25 17:54:46 sybalsky 45 44c Retrofit HP9000/RS6000 changeses 00014/00003/01749d D 2.35 90/10/09 10:45:06 fuji 44 43c Add the file name check for FDEV methodses 00000/00000/01752d D 2.34 90/10/09 10:36:48 fuji 43 42c Add the file name length check for FDEV methodses 00000/00008/01752d D 2.33 90/06/20 12:37:13 mitani 42 41c remove redundant ERRSETJMPes 01357/00932/00403d D 2.32 90/06/04 14:51:23 mitani 41 40c finfo structure is introducedes 00000/00000/01335d D 2.31 90/04/20 01:26:53 sybalsky 40 39c ortening file names, bulk change.es 01189/00929/00146d D 2.30 90/04/19 18:22:30 mitani 39 38c Version up to 1.2es 00001/00004/01074d D 2.29 90/03/23 11:31:27 takeshi 38 37c remove redundant BYTESWAP in UFS_readalldires 00036/00018/01042d D 2.28 90/03/08 10:01:07 takeshi 37 36c care about byte-order in stringses 00323/00157/00737d D 2.27 90/03/01 13:58:21 sybalsky 36 35c Checked for 386i stuff, added comments.es 00010/00010/00884d D 2.26 89/01/16 22:15:30 hayata 35 34c cant take & of reg. var.es 00123/00039/00771d D 2.25 89/01/13 19:36:29 hayata 34 33c corrected sorting, separated for dsk,ufses 00002/00002/00808d D 2.24 89/01/13 14:44:10 hayata 33 31c spellinges 00053/00060/00757d R 2.24 89/01/13 14:27:40 hayata 32 31c correct miss spell.es 00002/00002/00808d D 2.23 89/01/13 14:36:25 hayata 31 30c Add SCCS key id.es 00054/00061/00756d D 2.22 89/01/13 14:34:36 hayata 30 29c Fix AR110247(wildchar does not work well) and lexical sort of version number.es 00028/00028/00789d D 2.21 89/01/09 17:18:05 shih 29 28c spellinges 00079/00020/00738d D 2.20 88/12/01 14:44:46 hayata 28 27c Use ERRSETJMP insted of SETJMPes 00001/00000/00757d D 2.19 88/10/07 14:04:26 hayata 27 26c UFS_readAllDir() is changed to fix a buf of C sort.es 00080/00004/00677d D 2.18 88/10/06 17:01:25 hayata 26 25c sort is implemented in Ces 00028/00004/00653d D 2.17 88/07/28 09:46:39 hayata 25 24c dir *.*; enumerate highest version files.es 00001/00000/00656d D 2.16 88/07/26 18:57:13 hayata 24 23c move SETJMP to avoid duplicate use of jump bufferes 00001/00011/00655d D 2.15 88/07/21 18:52:18 hayata 23 22c Some macros are moved to localfile.hes 00078/00151/00588d D 2.14 88/07/21 14:19:19 hayata 22 21c add register declarationses 00006/00001/00733d D 2.13 88/07/01 14:32:45 hayata 21 20c Change SetFilesToBuffer and LinkP, to fix the problem that versionless linked file does not enumarated.es 00007/00000/00727d D 2.12 88/06/29 10:49:21 hayata 20 19c To fix TIMEOUT, SETJMP are used.es 00010/00001/00717d D 2.11 88/06/27 14:18:34 hayata 19 18c In {DSK} enumeration, skip symbolic link file which does not have linked to file.es 00336/00029/00382d D 2.10 88/06/27 10:34:02 hayata 18 17c In {DSK} enumeration, versionless file is added version number.es 00001/00000/00410d D 2.9 88/06/17 11:19:49 hayata 17 16c AddNotNoExtention macro is put on some places.es 00031/00011/00379d D 2.8 88/06/13 17:34:59 hayata 16 15c Add TIMEOUTes 00003/00002/00387d D 2.7 88/06/11 17:29:18 hayata 15 14c To add SCCS key ides 00043/00034/00346d D 2.6 88/06/11 17:25:55 hayata 14 13c Change version convention from ~#~ to .~#~es 00006/00000/00374d D 2.5 88/05/25 11:59:03 hayata 13 12c Enumeration of symbolic linked file without linked-to file cause error. To fix this bug, ignore stat error.es 00018/00012/00356d D 2.4 88/05/23 17:44:04 hayata 12 11c Add some check of result of library functionses 00002/00002/00366d D 2.3 88/05/23 17:42:02 hayata 11 10c Add some check of library functionses 00078/00069/00290d D 2.2 88/05/19 16:36:34 hayata 10 9c Enumeration of DSK is case insensitivees 00000/00000/00359d D 2.1 88/05/17 09:23:09 hayata 9 8c Version up to 2.1es 00004/00004/00355d D 1.8 88/05/10 17:43:42 hayata 8 7c Add system call error message.es 00067/00050/00292d D 1.7 88/05/07 18:20:11 hayata 7 6c Change matchpes 00000/00004/00342d D 1.6 88/05/02 15:28:44 hayata 6 5c remove comment out of if(matchp...) in alldirsize.es 00061/00000/00285d D 1.5 88/04/29 18:01:07 hayata 5 4c Add old entryes 00082/00031/00203d D 1.4 88/04/29 17:21:36 hayata 4 3c change readalldir to UFS_readalldir and DSK_readalldires 00017/00000/00217d D 1.3 88/04/20 14:55:18 hayata 3 2c change matchp to accept ~#~ notation.es 00002/00002/00215d D 1.2 88/03/13 14:35:48 hayata 2 1c Add SCCS key id (%Z%)es 00217/00000/00000d D 1.1 88/02/24 16:56:18 hayata 1 0c date and time created 88/02/24 16:56:18 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 11/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 11I 11D 12/* This is G-file @(#) directory.c Version 2.2 (5/19/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) directory.c	2.2 5/19/88";E 12I 12D 14/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 14I 14D 15/* This is G-file @(#) directory.c Version 2.5 (5/25/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) directory.c	2.5 5/25/88";E 15I 15D 29/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 29I 29D 30/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 29static char *id = "%Z% %M%	%I% %G%";E 30I 30D 31/* This is G-file @(#) directory.c Version 2.20 (12/1/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) directory.c	2.20 12/1/88";E 31I 31D 36/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */D 35static char *id = "%Z% %M%      %I% %G%         (envos & Fuji Xerox)";E 31E 30E 35I 35static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 35E 15E 14E 12E 11E 2/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 29 *	Auther	:	Hiroshi Hayata	E 29I 29D 30 *	Author	:	Hiroshi HayataE 30I 30D 33 *	Auther	:	Hiroshi Hayata	E 33I 33D 34 *	Author	:	Hiroshi Hayata	E 34I 34 *	Author	:	Hiroshi HayataE 34E 33E 30E 29 */E 36I 36D 37/* @(#) directory.c Version 2.26 (1/16/89). copyright envos & Fuji Xerox  */static char *id = "@(#) directory.c	2.26 1/16/89		(envos & Fuji Xerox)";E 37I 37D 44/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 44I 44/* @(#) directory.c Version 2.33 (6/20/90). copyright venue & Fuji Xerox  */static char *id = "@(#) directory.c	2.33 6/20/90		(venue & Fuji Xerox)";E 44E 37/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 36D 39#include <sys/types.h>#include <sys/stat.h>#include <sys/param.h>#include <sys/file.h>#include <sys/ioctl.h>#include <sys/dir.h>I 3#include <strings.h>E 3#include <stdio.h>#include <errno.h>I 20#include <setjmp.h>E 20I 4D 36#include	"lispemul.h"I 10#include	"lispmap.h"I 16#include	"timeout.h"E 16E 10#include	"localfile.h"E 36I 36#include "lispemul.h"#include "lispmap.h"I 37#include "lisptypes.h"E 37#include "timeout.h"#include "localfile.h"E 39I 39#include	<sys/types.h>#include	<sys/param.h>#include	<sys/dir.h>#include	<sys/stat.h>#include	<setjmp.h>#include	<pwd.h>I 47E 47I 45#ifndef HPUXE 45#include	<strings.h>I 45#endif HPUXI 46#ifdef RISCOS#include	<dirent.h>I 48#define direct direntE 48#endif RISCOSI 47#ifdef ISC#include	<dirent.h>#include	<unistd.h>#include	<sys/bsdtypes.h>I 48#define direct direntE 48#endif ISCE 47E 46E 45#include	<stdio.h>#include	<errno.h>#include	"lispemul.h"#include	"lispmap.h"#include	"address68k.h"#include	"lisptypes.h"#include	"arith.h"#include	"lispglobal.h"#include	"timeout.h"#include	"localfile.h"E 39E 36E 4D 39#define	TRUE	1#define	FALSE	0#define	FAILED	-1#define SEPRCHAR	'\\'#define DIRCHAR	'/'#undef	ALLDIRSEARCHI 18#define	MAXNAMELEN 128E 39I 28extern	int*	Lisp_errno;extern	int	Dummy_errno;I 39#define DIRCHAR	'>'E 39I 41/************************************************************************	SUBROUTINES	For pattern matching check************************************************************************/E 41E 28D 39typedef struct	dir_spec{	struct	file_spec	*files;	struct	dir_spec	*dirs;	time_t	mtime;	u_short	namlen;			/* 3 */	char	name[MAXNAMELEN];	/* bar, only root has pathname /foo/fee */}DirSpec;E 39I 39/*		D 41 * Name:	CASE_INS_COMPE 41I 41 * Name:	SetupMatchE 41 *D 41 * Argument:	char	c1	A character to be compared. *		char	c2	A character to be compared. *		int	res	The place where the result of the comparison will beE 41I 41 * Argument:	char	*tname	Target name including name ,extension and version. *		char	*pname	Pattern including name and extenstion. *		char	*text	The place where separated target extension will beE 41 *				stored.I 41 *		char	*pext	The place where separated pattern extension will be *				stored. *		char	*tver	The place where separated target version will be *				stored.E 41 * * Value:	N/A *D 41 * Side Effect:	None.E 41I 41 * Side Effect:	The string tname and pname points are destructivly modified.E 41 * * Description: *D 41 * Compares c1 and c2 lexically but with case insensitive mode.  Returns a value * through res.  The value is greater than, equal to, or less than 0, according * as c1 is lexically but with case insensitive mode greater than, equal to, * or less than c2.E 41I 41 * Split target and pattern to each component for the convinience of match_pattern * routine.E 41 */E 39D 39typedef struct	file_spec{	struct	file_spec	*pnext;	int		ver_no;		/* 3 */	ino_t		ino;	short		nlink;	char	name[MAXNAMELEN];	/* bar */	char	version[VERSIONLEN];	/* 3, 3% */}FileSpec;E 39I 39D 41#define CASE_INS_COMP(c1, c2, res){				\								\	register int	a, b;					\								\	a = (int)c1;						\	b = (int)c2;						\								\	if ('A' <= a && a <= 'Z') a += UPLOWDIFF;		\	if ('A' <= b && b <= 'Z') b += UPLOWDIFF;		\								\	if (a == b)						\	  res = 0;						\	else if (a < b)						\	  res = -1;						\	else							\	  res = 1;						\E 41I 41#define SetupMatch(tname, pname, text, pext, tver) {				\	  register char	*pp;							\										\	  separate_version(tname, tver, 0);					\										\	  if ((pp = rindex(tname, '.')) == NULL) {				\		  *text = '\0';							\	  } else {								\		  *pp = '\0';							\		  strcpy(text, pp + 1);						\	  }									\										\	  if ((pp = rindex(pname, '.')) == NULL) {				\		  *pext = '\0';							\	  } else {								\		  *pp = '\0';							\		  strcpy(pext, pp + 1);						\	  }									\  }#define MatchP(target, name, ver, matchtag, unmatchtag) {			   \										   \	char	tname[MAXNAMLEN], text[MAXNAMLEN], tver[VERSIONLEN];		   \	char	pname[MAXNAMLEN], pext[MAXNAMLEN];   				   \										   \	strcpy(tname, target);						   	   \	DOWNCASE(tname);						   	   \	strcpy(pname, name);						   	   \	DOWNCASE(pname);						   	   \										   \	SetupMatch(tname, pname, text, pext, tver);				   \										   \	if (match_pattern(tname, pname) &&			   		   \	    match_pattern(text, pext) &&	   				   \	    match_pattern(tver, ver))	   					   \	  goto matchtag;							   \	else									   \	  goto unmatchtag;							   \E 41}E 39I 41#define MatchP_Case(target, name, ver, matchtag, unmatchtag) {			   \										   \	char	tname[MAXNAMLEN], text[MAXNAMLEN], tver[VERSIONLEN];		   \	char	pname[MAXNAMLEN], pext[MAXNAMLEN];   				   \										   \	strcpy(tname, target);						   	   \	strcpy(pname, name);						   	   \										   \	SetupMatch(tname, pname, text, pext, tver);				   \										   \	if (match_pattern(tname, pname) &&			   		   \	    match_pattern(text, pext) &&   					   \	    match_pattern(tver, ver))	   					   \	  goto matchtag;							   \	else									   \	  goto unmatchtag;							   \}E 41D 39DirSpec	RootDirSpec;E 39I 39/*		D 41 * Name:	dsk_filecmpE 41I 41 * Name:	match_patternE 41 *D 41 * Argument:	char	*f1	A file name to be comapred in Lisp format. *		char	*f2	A file name to be compared in Lisp format.E 41I 41 * Argument:	char	*tp	String which is matched against pattern. *		char	*pp	String represents a pattern.E 41 *D 41 * Value:	Returns -1, 0, or 1, according as s1 is lexically but with case *		insensitive mode greater than, equal to, or less than c2.E 41I 41 * Value:	If target is regarded to match with pattern, returns 1, otherwise 0.E 41 * * Side Effect:	None. * * Description: *D 41 * Compares two file names lexically but with case insensitive mode.  Two file names * should be processed by UnixVersionToLispVersion to make sure that they have a * valid version fields.  The version fields comparison is done in numerical manner. * Note that the result is in the reversed order.E 41I 41 * Matches string against pattern.  Wild character is '*', it matches to arbitrary * number of characters.E 41 */E 39I 23E 23D 39char	*SetDirsToBuffer();char	*SetFilesToBuffer();E 39I 39D 41dsk_filecmp(f1, f2)	register char	*f1;	register char	*f2;E 41I 41match_pattern(tp, pp)	register char	*tp;	register char	*pp;E 41{D 41	register int	v1, v2, res;E 41I 41	register char	*tsp, *psp;	register int	inastr;E 41	D 41	for (;; f1++, f2++) {		CASE_INS_COMP(*f1, *f2, res);		if (res != 0) return(-res); /* Returns in the reversed order */E 41I 41	for (tsp = tp, psp = pp, inastr = 0;;tp++, pp++) {		switch (*pp) {E 41E 39I 26D 39/** For sort_file() **/E 39I 39D 41		switch (*f1) {E 39I 34E 41D 39/** lowercase a is  97, so a << 1 is 194.    lowercase z is 122, so z << 1 is 244.    uppercase A is  65, so A << 1 is 130.    uppercase Z is  90, so Z << 1 is 180  ***/E 39I 39		      case '\0':D 41			/* Both of the file names have been scanned. */			return(0);			break;E 41I 41			return ((*tp == '\0') ? 1 : 0);E 41E 39D 39/** note that x < y implies z = -1.			*/E 39I 39D 41		      case ';':			if (*(f1 - 1) != '\'') {E 41I 41		      case '*':			while (*pp == '*') pp++; /* Skip successive '*'s. */			if (*pp == '\0') return(1);			psp = pp;			while (*tp != *pp && *tp != '\0') tp++;			if (*tp == '\0') return(0);			tsp = tp;			inastr = 1;			continue;		      default:			if (*tp == *pp) continue;			if (inastr) {E 41				/*D 41				 * Not quoted semi colon means the start of the				 * version field.  We have to compare versions in				 * numeric manner.E 41I 41				 * Try to find a character which match to				 * a character psp points from a charcter				 * next to tsp.  If found retry from there.E 41				 */D 41				v1 = atoi(f1 + 1);				v2 = atoi(f2 + 1);				if (v1 == v2)				  return(0);				else if (v1 < v2)				  return(-1);				else				  return(1);E 41I 41				for (tp = tsp + 1;				     *tp != '\0' && *tp != *psp;				     tp++) {}				if (*tp == '\0') return(0);				pp = psp;				tsp = tp;				continue;E 41			} else {D 41				/*				 * Quoted semi colon is just a character, does not				 * have special meaning.				 */				break;E 41I 41				return(0);E 41			}D 41			break;E 39E 34D 39#define	CASE_CHARCMP(x, y, z)				\	{						\I 34	register int  xx, yy;				\		xx = (x)<<1;				\		yy = (y)<<1;				\		if ( (194 <= xx)  && ( xx <= 244 ) )	\D 35			xx = xx - 64;			\E 35I 35			xx -= 64;			\E 35/* add 1 if lcase > ucase (but that's wrong) */		\		if ( (194 <= yy)  && ( yy <= 244 ) )	\D 35			yy = yy - 64;			\E 35I 35			yy -= 64;			\E 35							\		if( xx < yy )				\			z = -1;				\		else					\			if( xx == yy )			\				z = 0;			\			else				\				z = 1;			\E 39I 39		      default:			break;E 41		}E 39	}I 39}E 39I 39D 41/*		 * Name:	unix_filecmpE 41I 41/************************************************************************//******** E N D   O F   P A T T E R N - M A T C H I N G   C O D E *******//************************************************************************//************************************************************************//************ B E G I N  O F   F I L E - I N F O   C O D E **************//************************************************************************//* * FINFO and FPROP are used to store the information of the enumerated files * and directories.  They are arranged in a form of linked list.  Each list is * corresponding to the each directory enumeratreion.  All of the informations * Lisp needs are stored in the list.  This list is in the emulator's address space * and can be specified by "ID" which is the interface between the emulator and Lisp * code.  In this implementation, ID is represeted as an integer and is actually * an index of the array of the lists.E 41 *D 41 * Argument:	char	*f1	A file name to be comapred in UNIX format. *		char	*f2	A file name to be compared in UNIX format.E 41I 41 * To avoid the overhead of the FINFO and FPROP structure dynamic allocation and * deallocation, some number of their instances are pre-allocated when the emulator * starts and managed in a free list.  If all of the pre-allocated instances are in * use, new instances are allocated.  The new instances are linked to the free list * when it is freed.E 41 *D 41 * Value:	Returns -1, 0, or 1, according as s1 is lexically greater than, *		equal to, or less than c2. * * Side Effect:	None. * * Description: * * Compares two file names lexically mode. * Note that the result is in the reversed order.E 41I 41 * As described above, the linked list result of the enumeration is stored in a * array for the subsequent request from Lisp.  Lisp code requests the emulator to * release the list when it enumerated all of the entries in the list or the * enumerating operation is aborted.E 41 */E 39I 39D 41unix_filecmp(f1, f2)	register char	*f1;	register char	*f2;E 41I 41typedef struct fprop {	unsigned	length;		/* Byte length of this file. */	unsigned	wdate;		/* Written (Creation) date in Lisp sense. */	unsigned	rdate;		/* Read date in Lisp sense. */	unsigned	protect;	/* Protect mode of this file. */	char		author[256];	/* Author in Lisp sense. */	u_short		au_len;		/* Byte length of author. */} FPROP;typedef struct finfo {	char		lname[MAXNAMLEN];	/* Name in Lisp Format. */	u_short		lname_len; 		/* Byte length of lname. */	char		no_ver_name[MAXNAMLEN];						/*					 	 * Name in UNIX Format.  Does not						 * include Version field.						 * All lower case.					 	 */	ino_t		ino;			/* I-node number of this file. */	unsigned	version;		/* Version in Lisp sense. */	u_short		dirp;			/* If 1, this file is a directory. */	FPROP		*prop;			/* File properties Lisp needs. */	struct finfo	*next;			/*					         * Link to a next entry.  Last entry is					 	 * indicated by NULL pointer.						 */} FINFO;typedef struct dfinfo {	FINFO		*head;		/* Head of the linked FINFO structures. */	FINFO		*next;		/* FINFO structure generated next time. */} DFINFO;FINFO		*FreeFinfoList;#define		INITFINFONUM	1024DFINFO		*FinfoArray;#define		INITFINFOARRAY	32unsigned	MAXFINFO;#define		FINFOARRAYRSIZE	16#define AllocFinfo(fp) {							\	if (FreeFinfoList != (FINFO *)NULL) {					\		fp = FreeFinfoList;						\		FreeFinfoList = fp->next;					\	} else if ((fp = (FINFO *)calloc(1, sizeof(FINFO))) == NULL) {		\		fp = (FINFO *)NULL;						\	} else if ((fp->prop = (FPROP *)calloc(1, sizeof(FPROP))) == NULL) {	\		free(fp);							\		fp = (FINFO *)NULL;						\	}									\}#define FreeFinfo(fp) {								\	register FINFO	*lastp;							\	for (lastp = fp; lastp->next != (FINFO *)NULL; lastp = lastp->next) {}	\	lastp->next = FreeFinfoList;						\	FreeFinfoList = fp;							\}/* * For debug aid. */#ifdef FSDEBUGprint_finfo(fp)	FINFO	*fp;E 41{D 41	return(-strcmp(f1, f2));E 41I 41	FINFO	*sp;	sp = fp;	if (fp != (FINFO *)NULL) {		do {			printf("%s -> ", fp->lname);			printf("%d\n", fp->version);			fp = fp->next;		} while (fp != (FINFO *)NULL && fp != sp);		if (fp = sp) printf("Circular detected!\n");	}E 41}I 41#endif FSDEBUGE 41E 39D 35#define	OLDCASE_CHARCMP(x, y, z)				\E 35I 35D 39#define	OLDCASE_CHARCMP(x, y, z)			\E 35	{						\E 34	register char	*cp1,*cp2;			\		cp1 = index(alpha_order, x);		\		cp2 = index(alpha_order, y);		\		if( (int)cp1 < (int)cp2 )		\			z = -1;				\		else					\			if( (int)cp1 == (int)cp2 )	\				z = 0;			\			else				\				z = 1;			\	}E 39I 39/*		D 41 * Name:	file_sortE 41I 41 * Name:	init_finfoE 41 *D 41 * Argument:	char	*bufp	A pointer to a buffer where file names are stored. *		int	fnum	A number of files stored in the buffer. *		int	(*sortfn)() *				A pointer to a function to be used to sort the files.E 41I 41 * Argument:	None.E 41 *D 41 * Value:	If succeed, returns 1, otherwise, 0.E 41I 41 * Value:	If suceed, returns 1, otherwise 0.E 41 *D 41 * Side Effect:	None.E 41I 41 * Side Effect:	FreeFinfoList will point to the alloced area.  MAXFINFO will hold *		the total number of allocated instances of FINFO structure.E 41 * * Description: *D 41 * Sorts the files to be appropriate for Lisp.   dsk_filecmp and unix_filecmp are * used for {DSK} and {UNIX} device respectively as a sort function.  bufp is actually * pointing a buffer which is allocated by Lisp code.  Thus, copying the sorted file * names from the malloced working buffer to bufp, we have to care about the * byte order of the platform architecture.E 41I 41 * Allocates the storage for the instances of FINFO and FPROP structure and arrange * them to build a linked list. * This routine is invoked at very first stage of emulator start up.E 41 */E 39E 26D 23#define	STAT(x,y){						\		TIMEOUT(rval=stat(x, y));	\		if(rval != 0){					\			err_mess("stat", errno);		\			return(-1);				\		}						\		}E 18extern int errno;E 23I 26D 29/*** static	char	alpha_order[100] = E 29I 29D 30/***static	char	alpha_order[100] =E 30I 30D 34/*** static	char	alpha_order[100] = E 34I 34D 39/***static	char	alpha_order[100] =E 34E 30E 29	" !\"#$%&'()*+,-./0123456789:;<=>?@aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ[\\]^_`{|}~";***/D 29static	char	alpha_order[100] = E 29I 29D 30static	char	alpha_order[100] =E 30I 30/*** This is masked. [13-Jan-99 HH]D 34static	char	alpha_order[100] = E 34I 34static	char	alpha_order[100] =E 34E 30E 29	"~}|{`_^]\\[ZzYyXxWwVvUuTtSsRrQqPpOoNnMmLlKkJjIiHhGgFfEeDdCcBbAa@?>=<;:9876543210/.-,+*)('&%$#\"! ";I 30***/D 34static	char	alpha_order[100] = E 34I 34static	char	alpha_order[100] =E 34	"}|{`_^]\\[ZzYyXxWwVvUuTtSsRrQqPpOoNnMmLlKkJjIiHhGgFfEeDdCcBbAa@?>=<;:9876543210~/.-,+*)('&%$#\"! ";E 39I 39D 41file_sort(bufp, fnum, sortfn)	register char	*bufp;	register int	fnum;	register int	(*sortfn)();E 41I 41init_finfo()E 41{D 41	register char	*sp, *dp, *colp, *sort_bufp;	register int	i;	int		dsk_filecmp(), unix_filecmp();E 41I 41	register FINFO	*cp;	register int	n;E 41E 39E 30I 39D 41	if ((sort_bufp = (char *)calloc((unsigned)((MAXNAMLEN + 1) * fnum),					 sizeof(char))) == NULL)	  return(0);E 39I 34D 36/* Purely lexical sort, we think is correct (we hope) */E 36E 34I 39	/*	 * Each file names in bufp is delimitted with NULL character.	 */	for (sp = bufp, colp = sort_bufp, i = fnum; i > 0; i--,	     colp += (MAXNAMLEN + 1)) {		dp = colp;		while (*sp) *dp++ = *sp++;		*dp = '\0';		sp++;E 41I 41	if ((FreeFinfoList =	     (FINFO *)calloc(sizeof(FINFO) + sizeof(FPROP), INITFINFONUM))	    == (FINFO *)NULL) {		*Lisp_errno = errno;		return(0);E 41	}I 41	for (cp = FreeFinfoList, n = INITFINFONUM; n > 1; n--) {		cp->prop = (FPROP *)(cp + 1);		cp->next = (FINFO *)((char *)cp + sizeof(FINFO) + sizeof(FPROP));		cp = cp->next;	}	cp->prop = (FPROP *)(cp + 1);	cp->next = (FINFO *)NULL;E 41E 39I 36I 39D 41	qsort(sort_bufp, fnum, (MAXNAMLEN + 1), sortfn);E 39D 39/************************************************************************//*									*//*			u f s _ s t r c m p				*//*									*//*	String-compare function for {UNIX} file names.  ONLY WORKS ON C	*//*	STRINGS, NOT ON LISP STRINGS ON 386's.				*//*									*//*									*//************************************************************************/E 39I 39	/*	 * Write back the sorted file names to the buffer where Lisp can access.	 * Byte order problem is handled within GETBYTE macro.	 */	for (colp = sort_bufp, dp = bufp, i = fnum; i > 0; i--,	     colp += (MAXNAMLEN + 1)) {		sp = colp;		while (*sp) GETBYTE(dp++) = *sp++;		GETBYTE(dp++) = '\0';E 41I 41	if ((FinfoArray = (DFINFO *)calloc(sizeof(DFINFO), INITFINFOARRAY))	    == (DFINFO *)NULL) {		*Lisp_errno = errno;		return(0);E 41	}I 41	MAXFINFO = INITFINFOARRAY;E 41E 39E 36D 34int	case_strcmp();E 34I 34D 39ufs_strcmp(s1,s2)D 36register char	*s1, *s2;{	return (-strcmp(s1, s2));}E 36I 36  register char	*s1, *s2;  {    return (-strcmp(s1, s2));  }E 39I 39D 41	free(sort_bufp);E 41	return(1);}E 39E 36E 34D 34case_strcmp(s1,s2)E 34I 34D 36/* Almost case insensitive (upper case is < lower), also   legal version numbers are < illegal version numbers, also   illegal version numbers are almost lexical (as above) */E 36D 39I 36E 39D 41/************************************************************************/D 39/*									*//*				d s k _ s t r c m p			*//*									*//*	String-compare function for {DSK} file names.  Almost		*//*	case-insensitive, except that upper-case is < lower-case,	*//*	so sort order is AbBbCc...  Also, legal version numbers sort	*//*	before  illegal version numbers, & illegal version sort in	*//*	the same case-insensitive way AbBb... as above			*//*									*/E 39I 39/************ E N D   O F   F I L E - S O R T I N G   C O D E ***********/E 39/************************************************************************/E 36D 39dsk_strcmp(s1,s2)E 34D 36register char	*s1, *s2;{I 34register int	j, v1, v2, res1, res2;I 35int  num;		/* can't take address of register var */E 35char ch;E 36I 36  register char	*s1, *s2;  {    register int	j, v1, v2, res1, res2;    int  num;		/* can't take address of register var */    char ch;E 39E 36E 41D 36	for (; ;++s1, ++s2){		CASE_CHARCMP(*s1, *s2, j);		if( j != 0)			return(-j);	/* lisp wants reversed sense */E 36I 36D 39    for (; ;++s1, ++s2)      {	CASE_CHARCMP(*s1, *s2, j);	if( j != 0) return(-j);	/* lisp wants reversed sense */E 39I 39/*		D 41 * Name:	FILESPEC(struct file_spec)E 41I 41 * Name:	get_finfo_idE 41 *D 41 * Description:E 41I 41 * Argument:	None.E 41 *D 41 * The structure to be used to cache the file information which is enumerated. * FILESPEC structures are hold in files field of DIRSPEC structre. */E 39E 36D 36		if (*s1 == '\0') /* both null */ return (0);D 35	        if ( *s1 == ';') /* both semi */ {E 35I 35	        if (*s1 == ';')  /* both semi */ {E 35			s1++; s2++;		/* legal version is exactly res==1 a number, no more.		   resx now boolean					*/D 35			res1 = sscanf ( s1, "%d%c", &v1, &ch );			res1 = (res1 == 1);E 35I 35			res1 = (1 == (sscanf ( s1, "%d%c", &num, &ch )));			v1   = num;E 36I 36D 39	if (*s1 == '\0') return (0);  /* both null */	if (*s1 == ';')  /* both semi */	  {	    s1++; s2++;	    /* legal version is exactly res==1 a number, no more.	       resx now boolean					*/	    res1 = (1 == (sscanf ( s1, "%d%c", &num, &ch )));	    v1   = num;E 39I 39typedef struct file_spec {	struct file_spec	*next;	/* Link to a next entry. */	int			ver;	/*					 * A version number of this file.  A versionless					 * file has 0 as this value.					 */	char			version[VERSIONLEN]; /* String representation of ver */	char			*name;	/* The pointer to the name of the file. */	u_short			namlen;	/* The length of the file name */	char			*sname;	/*					 * The pointer to the name of the file without					 * a version field.  If ver is 0, this field					 * is not used.					 */	ino_t			ino;	/* The i-node number of this file. */} FILESPEC;E 39E 36E 35D 35			res2 = sscanf ( s2, "%d%c", &v2, &ch );			res2 = (res2 == 1);E 35I 35D 36			res2 = (1 == (sscanf ( s2, "%d%c", &num, &ch )));			v2   = num;E 36I 36D 39	    res2 = (1 == (sscanf ( s2, "%d%c", &num, &ch )));	    v2   = num;E 39I 39/*		 * Name:	DIRSPEC(struct dir_spec)E 41I 41 * Value:	If suceed, returns the id of linked list of FINFO structures, *		otherwise -1.E 41 *I 41 * Side Effect:	If needed, FinfoArray will be extened according to the value of *		FINFOARRAYRSIZE. *E 41 * Description: *D 41 * The structure to be used to cache the directory information which is enumerated. * In the current implementaion, the member dirs and files are only used in the top * entry of the linked structure, because the current implementaion does not support * the nested enumeration, that is only the specified directory is enumerated and the * contents of the sub directories are not enumerated. * The member mtime is used to verify the cache is still valid or not.E 41I 41 * Get an ID which can be used to name a linked list of FINFO structure.  ID is * represeted as an integer, and it is actualy an index of an array FinfoArray. * * If all entries of FinfoArray is occupied by linked lists of FINFO structures, * extended storage is allocated and old contents of the array are copied to the * new area.  The size of the extended part is decided by the value of * FINFOARRAYRSIZE.E 41 */E 39E 36E 35D 36			if ( res1 && res2 ) { /* both versions, use < */				if ( v1 < v2 ) return(-1);				if ( v1 > v2 ) return( 1);				return(0);				}				/* vers. name shorter (but reverse sense) */			else if ( res1 && !res2 ) {				return( 1);				}			else if ( res2 && !res1 ) {				return(-1);				}			/* otherwise continue lexical scan */			/* need to backup 1, because forloop ++ */			s1--; s2--;			}	} /* for */}E 36I 36D 39	    if ( res1 && res2 )	      { /* both versions, use < */		if ( v1 < v2 ) return(-1);		if ( v1 > v2 ) return( 1);		return(0);	      }	    /* vers. name shorter (but reverse sense) */	    else if ( res1 && !res2 ) return( 1);	    else if ( res2 && !res1 ) return(-1);	    /* otherwise continue lexical scan */	    /* need to backup 1, because forloop ++ */	    s1--; s2--;	  }      } /* for */  }E 39I 39D 41typedef struct dir_spec {	struct dir_spec		*next;	/*					 * Link pointer to the next entry.  					 * The directories linked on this structure					 * are all on same level, that is the direct					 * subdirectories of the parent directory.					 */	struct dir_spec		*dirs; 	/*					 * The information of the sub directories of					 * this directory.					 */	FILESPEC		*files;	/*					 * The information of the files on this					 * directory.					 */	time_t			mtime; 	/* The last time the i-node was changed */	u_short			namlen;	/*					 * The length of the directory name.  Does					 * not include the NULL terminating character.					 */	char			*name;	/* The pointer to the name of the directory. */} DIRSPEC;E 41I 41get_finfo_id(){	register int	i;	DFINFO		*dfap;E 41E 39E 36I 39D 41DIRSPEC	Cached_Dir;E 41I 41	for (i = 0; i < MAXFINFO; i++) if (FinfoArray[i].head == (FINFO *)0)	  return (i);E 41E 39D 36intoldcase_strcmp(s1,s2)register char	*s1, *s2;{E 34register int	j;	for(; *s1!='\0' || *s2!='\0';++s1, ++s2){		CASE_CHARCMP(*s1, *s2, j);		if( j != 0)			return(j);	}	return(0);}E 36I 41	if ((dfap = (DFINFO *)calloc(sizeof(DFINFO), MAXFINFO + FINFOARRAYRSIZE))	    == (DFINFO *)NULL) {		*Lisp_errno = errno;		return(-1);	}	for (i = 0; i < MAXFINFO; i++) {		dfap[i].head = FinfoArray[i].head;		dfap[i].next = FinfoArray[i].next;	}	free(FinfoArray);	MAXFINFO += FINFOARRAYRSIZE;	FinfoArray = dfap;	return(i);}E 41I 39/*		D 41 * Name:	Push_DirE 41I 41 * Name:	enum_dsk_propE 41 *D 41 * Argument:	DIRSPEC	*dirspecp *				A pointer to a DIRSPEC structure.   *		struct direct	*dirp *				A pointer to a direct structure which should be pushd *				into next field of dirspecp. *		int	res	The place where a result of the operation will be *				stored.  If succeed, res holds 1, otherwise 0.E 41I 41 * Argument:	char	*dir	Absolute path of directory in UNIX format. *		char	*name	Pattern specify the files to be enumerated. *		char	*ver    String representation of version should be *				enumerated. *		FINFO	**finfo_buf *				The place where linked list of FINFO structures *				reslt of the enumeration will be stored.E 41 *D 41 * Value:	N/AE 41I 41 * Value:	If suceed, returns the number of enumerated files, otherwise -1.E 41 *D 41 * Side Effect:	(dirspecp->next)->name and (dirspecp->next) will hold malloced *		storages.E 41I 41 * Side Effect:	None.E 41 * * Description: *D 41 * Convert a dirent structure dirp to dirspecp structure and pushes it into next * field of the passed dirspecp.  A caller have to make shure that direct represents * directory file.E 41I 41 * Enumerates files and directories matching to the pattern on the specified * directory.  The pattern matching is done in case insensitive manner. * File properties Lisp will need later are also stored in the result linked list * of FINFO structures. E 41 */E 39I 36I 39D 41#define Push_Dir(dirspecp, dirp, res){						\										\	register DIRSPEC	*newdp, *nextp;				\	u_short			nlen;						\	  									\	/*									\	 * Skip the current directory, the parent of the current directory and	\	 * the removed files.							\	 */									\	if (strcmp(dirp->d_name, ".") != 0 && strcmp(dirp->d_name, "..") !=0 &&	\	    dirp->d_ino != 0) {							\		/* Obtain a next entry. */					\		if ((newdp = (DIRSPEC *)calloc(1, sizeof(DIRSPEC))) ==	\		    (DIRSPEC *)NULL) {						\			res = 0;						\		} else {							\			nlen = strlen(dirp->d_name);				\			if ((newdp->name = (char *)malloc(nlen + 1)) == NULL) {	\				res = 0;					\			} else {						\				strcpy(newdp->name, dirp->d_name, nlen);	\				(newdp->name)[nlen] = '\0';			\				newdp->namlen = nlen;				\				/*						\				 * Push an new entry in the linked structre	\				 * of dirspec.					\				 */						\				nextp = (dirspecp)->next;			\				(dirspecp)->next = newdp;		\				newdp->next = nextp;				\				newdp->files = (FILESPEC *)NULL;		\				/* Currently not support nested enumeration. */ \				newdp->dirs = (DIRSPEC *)NULL;			\			      	res = 1;					\			}							\		}								\	} else									\	  res = 1;								\E 41I 41enum_dsk_prop(dir, name, ver, finfo_buf)	char	*dir;	char	*name;	char	*ver;	FINFO	**finfo_buf;{	register struct direct	*dp;	register FINFO		*prevp;	register FINFO		*nextp;	int			n, len, rval;	DIR			*dirp;	register struct passwd	*pwd;		struct stat		sbuf;	char			namebuf[MAXPATHLEN];	char			fver[VERSIONLEN];	D 42	ERRSETJMP(-1);E 42        TIMEOUT(dirp = opendir(dir));	if (dirp == NULL) {		*Lisp_errno = errno;		return(-1);	}	for (S_TOUT(dp = readdir(dirp)), nextp = prevp = (FINFO *)NULL, n = 0;	     dp != (struct direct *)NULL;	     S_TOUT(dp = readdir(dirp)), prevp = nextp) {		if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0 ||		    dp->d_ino == 0) continue;		MatchP(dp->d_name, name, ver, match, unmatch);	      unmatch:		continue;	      match:		AllocFinfo(nextp);		if (nextp == (FINFO *)NULL) {			FreeFinfo(prevp);			closedir(dirp);			*Lisp_errno = errno;			return(-1);		}		nextp->next = prevp;		sprintf(namebuf, "%s/%s", dir, dp->d_name);		TIMEOUT(rval = stat(namebuf, &sbuf));		if (rval == -1 && errno != ENOENT) {			/*			 * ENOENT error might be caused by missing symbolic			 * link. We should ignore such error here.			 */			FreeFinfo(nextp);			closedir(dirp);			*Lisp_errno = errno;			return(-1);		}					strcpy(namebuf, dp->d_name);		if (sbuf.st_mode & S_IFDIR) {			nextp->dirp = 1;			quote_dname(namebuf);			strcpy(nextp->lname, namebuf);			len = strlen(namebuf);			*(nextp->lname + len) = DIRCHAR;			*(nextp->lname + len + 1) = '\0';			nextp->lname_len = len + 1;		} else {			/* All other types than directory. */			nextp->dirp = 0;			quote_fname(namebuf);			len = strlen(namebuf);			strcpy(nextp->lname, namebuf);			*(nextp->lname + len) = '\0';			nextp->lname_len = len;		}		strcpy(namebuf, dp->d_name);		len = strlen(namebuf);		separate_version(namebuf, fver, 1);		DOWNCASE(namebuf);		strcpy(nextp->no_ver_name, namebuf);		if (*fver == '\0')		  nextp->version = 0;		else		  nextp->version = atoi(fver);		nextp->ino = sbuf.st_ino;		nextp->prop->length = (unsigned)sbuf.st_size;		nextp->prop->wdate = (unsigned)ToLispTime(sbuf.st_mtime);		nextp->prop->rdate = (unsigned)ToLispTime(sbuf.st_atime);		nextp->prop->protect = (unsigned)sbuf.st_mode;		TIMEOUT(pwd = getpwuid(sbuf.st_uid));		if (pwd == (struct passwd *)NULL) {			nextp->prop->au_len = 0;		} else {			len = strlen(pwd->pw_name);			strcpy(nextp->prop->author, pwd->pw_name);			*(nextp->prop->author + len) = '\0';			nextp->prop->au_len = len;		}		n++;	}	closedir(dirp);	if (n > 0) *finfo_buf = prevp;	return(n);E 41}E 39E 36D 34file_sort(startp, f_count)E 34I 34D 39file_sort(startp, f_count, devsortfn)E 34D 36char	*startp;int	f_count;I 34int	(*devsortfn)();E 34{char	*sort_buffer;register char	*bp, *sourcep, *destp;register int	i;E 36I 36D 37  char	*startp;E 37I 37  char	*startp; /* points the buffer in LISP, but not yet byte-swapped */E 37  int	f_count;  int	(*devsortfn)();  {    char	*sort_buffer;    register char	*bp, *sourcep, *destp;    register int	i;E 39I 39/*		D 41 * Name:	Push_FileE 41I 41 * Name:	enum_dskE 41 *D 41 * Argument:	DIRSPEC	*dirspecp *				A pointer to a DIRSPEC structure.   *		struct direct	*dirp *				A pointer to a direct structure which should be pushd *				into next field of dirspecp. *		int	res	The place where a result of the operation will be *				stored.  If succeed, res holds 1, otherwise 0.E 41I 41 * Argument:	char	*dir	Absolute path of directory in UNIX format. *		char	*name	Pattern specify the files to be enumerated. *		char	*ver    String representation of version should be *				enumerated. *		FINFO	**finfo_buf *				The place where linked list of FINFO structures *				reslt of the enumeration will be stored.E 41 *D 41 * Value:	N/AE 41I 41 * Value:	If suceed, returns the number of enumerated files, otherwise -1.E 41 *D 41 * Side Effect:	(dirspecp->next)->name and (dirspecp->next) will hold malloced *		storages.E 41I 41 * Side Effect:	None.E 41 * * Description: *D 41 * Convert a dirent structure dirp to FILESPEC structure and pushes it into next * field of the passed dirspecp.  A caller have to make sure that direct represents * a other kind of file than a directory.E 41I 41 * Similar to enum_dsk_prop, but file properties are not stored.E 41 */E 39E 36I 34E 34D 36	sort_buffer = (char *)malloc(MAXPATHLEN * f_count);	for(bp=sort_buffer,sourcep=startp,i=0;i<f_count;bp+=MAXPATHLEN,++i){		for(destp=bp;*sourcep!=	SEPRCHAR;)			*destp++ = *sourcep++;		++sourcep;D 34		*destp++ = SEPRCHAR;E 34I 34/***		*destp++ = SEPRCHAR; don't add, messes up sort 	***/E 34		*destp++ = '\0';D 29	}	E 29I 29D 30	}E 30I 30D 34	}	E 30E 29	qsort(sort_buffer, f_count, MAXPATHLEN, case_strcmp);E 34I 34	}	qsort(sort_buffer, f_count, MAXPATHLEN, devsortfn);E 34	for(bp=sort_buffer,sourcep=startp,i=0;i<f_count;bp+=MAXPATHLEN,++i){		for(destp=bp;*destp!='\0';)			*sourcep++ = *destp++;D 29	}	E 29I 29D 30	}E 30I 30D 34	}	E 34I 34		*sourcep++ = SEPRCHAR;	}E 34E 30E 29	free(sort_buffer);}E 36I 36D 39    sort_buffer = (char *)malloc(MAXPATHLEN * f_count);    for (bp=sort_buffer,sourcep=startp,i=0;i<f_count;bp+=MAXPATHLEN,++i)      {	for(destp=bp;*sourcep!=	SEPRCHAR;) *destp++ = *sourcep++;	++sourcep;	*destp++ = '\0';      }    qsort(sort_buffer, f_count, MAXPATHLEN, devsortfn);E 39I 39D 41#define Push_File(dirspecp, dirp, res){						\										\	register FILESPEC	*newfp, *nextp;					\	u_short			nlen;						\	char			sname[MAXNAMLEN + 1], ver[VERSIONLEN];		\										\	/* Skip the removed files. */						\	if (dirp->d_ino != 0) {							\		/* Obtain a next entry. */					\		if ((newfp = (FILESPEC *)calloc(1, sizeof(FILESPEC))) ==	\		    (FILESPEC *)NULL) {						\			res = 0;						\		} else {							\			nlen = strlen(dirp->d_name);				\			if ((newfp->name = (char *)malloc(nlen + 1)) == NULL) {	\				res = 0;					\			} else {						\				strcpy(newfp->name, dirp->d_name, nlen);	\				newfp->namlen = nlen;				\				(newfp->name)[nlen] = '\0';			\				strcpy(sname, dirp->d_name);			\				separate_version(sname, ver, 1);		\				if (ver != '\0') {				\					strcpy(newfp->version, ver);		\					newfp->ver = atoi(ver);			\					if ((newfp->sname =			\					     (char *)malloc(strlen(sname) + 1))	\					    == NULL) {				\						res = 0;			\					} else {				\						strcpy(newfp->sname, sname);	\						res = 1;			\					}					\				} else {					\					newfp->ver = 0;				\					res = 1;				\				}						\				if (res != 0) {					\					/*					\					 * Push an new entry in the linked	\					 * structure of direspec.		\					 */					\					nextp = (dirspecp)->files;		\					(dirspecp)->files = newfp;		\					newfp->next = nextp;			\				}						\			}							\		}								\	} else									\	  res = 1;								\E 41I 41enum_dsk(dir, name, ver, finfo_buf)	char	*dir;	char	*name;	char	*ver;	FINFO	**finfo_buf;{	register struct direct	*dp;	register FINFO		*prevp;	register FINFO		*nextp;	int			n, len, rval;	DIR			*dirp;	struct stat		sbuf;	char			namebuf[MAXPATHLEN];	char			fver[VERSIONLEN];	D 42	ERRSETJMP(-1);E 42        TIMEOUT(dirp = opendir(dir));	if (dirp == NULL) {		*Lisp_errno = errno;		return(-1);	}	for (S_TOUT(dp = readdir(dirp)), nextp = prevp = (FINFO *)NULL, n = 0;	     dp != (struct direct *)NULL;	     S_TOUT(dp = readdir(dirp)), prevp = nextp) {		if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0 ||		    dp->d_ino == 0) continue;		MatchP(dp->d_name, name, ver, match, unmatch);	      unmatch:		continue;	      match:		AllocFinfo(nextp);		if (nextp == (FINFO *)NULL) {			FreeFinfo(prevp);			closedir(dirp);			*Lisp_errno = errno;			return(-1);		}		nextp->next = prevp;		sprintf(namebuf, "%s/%s", dir, dp->d_name);		TIMEOUT(rval = stat(namebuf, &sbuf));		if (rval == -1 && errno != ENOENT) {			/*			 * ENOENT error might be caused by missing symbolic			 * link. We should ignore such error here.			 */			FreeFinfo(nextp);			closedir(dirp);			*Lisp_errno = errno;			return(-1);		}					strcpy(namebuf, dp->d_name);		if (sbuf.st_mode & S_IFDIR) {			nextp->dirp = 1;			quote_dname(namebuf);			strcpy(nextp->lname, namebuf);			len = strlen(namebuf);			*(nextp->lname + len) = DIRCHAR;			*(nextp->lname + len + 1) = '\0';			nextp->lname_len = len + 1;		} else {			/* All other types than directory. */			nextp->dirp = 0;			quote_fname(namebuf);			len = strlen(namebuf);			strcpy(nextp->lname, namebuf);			*(nextp->lname + len) = '\0';			nextp->lname_len = len;		}		strcpy(namebuf, dp->d_name);		len = strlen(namebuf);		separate_version(namebuf, fver, 1);		DOWNCASE(namebuf);		strcpy(nextp->no_ver_name, namebuf);		if (*fver == '\0')		  nextp->version = 0;		else		  nextp->version = atoi(fver);		nextp->ino = sbuf.st_ino;		n++;	}	closedir(dirp);	if (n > 0) *finfo_buf = prevp;	return(n);E 41}E 39I 37D 39/* It seems, now copy file names from work buffer to buffer in LISP   For i386, byte-swap operation should be done here */E 37    for(bp=sort_buffer,sourcep=startp,i=0;i<f_count;bp+=MAXPATHLEN,++i)      {D 37	for(destp=bp;*destp!='\0';) *sourcep++ = *destp++;	*sourcep++ = SEPRCHAR;E 37I 37	for(destp=bp;*destp!='\0';) GETBYTE(sourcep++ )= *destp++;	GETBYTE(sourcep++) = SEPRCHAR;E 37      }    free(sort_buffer);  }E 39I 39/*		D 41 * Name:	free_dirspecE 41I 41 * Name:	enum_ufs_propE 41 *D 41 * Argument:	DIRSPEC	*dirspecp *				A pointer to a DIRSPEC structure to be freed. *		int	selfp	If 1, frees itself, otherwise frees only its files *				member and decsendant DIRSPEC structurs.E 41I 41 * Argument:	char	*dir	Absolute path of directory in UNIX format. *		char	*name	Pattern specify the files to be enumerated. *		char	*ver    String representation of version should be *				enumerated. *		FINFO	**finfo_buf *				The place where linked list of FINFO structures *				reslt of the enumeration will be stored.E 41 *D 41 * Value:	Void.E 41I 41 * Value:	If suceed, returns the number of enumerated files, otherwise -1.E 41 *D 41 * Side Effect:	The specified storages will be freed.E 41I 41 * Side Effect:	None.E 41 * * Description: *D 41 * Frees the storages allocated fo DIRSPEC structure.  If selfp is 1, the top level * DIRSPEC structure will also be freed.E 41I 41 * Enumerates files and directories matching to the pattern on the specified * directory.  The pattern matching is done in case sensitive manner. * File properties Lisp will need later are also stored in the result linked list * of FINFO structures. E 41 */E 39E 36D 36/*** End sort_file() stuff ***/E 36I 36D 39/************************************************************************//************ E N D   O F   F I L E - S O R T I N G   C O D E ***********//************************************************************************/E 39I 39D 41free_dirspec(dirspecp, selfp)	register DIRSPEC	*dirspecp;	register int		selfp;E 41I 41enum_ufs_prop(dir, name, ver, finfo_buf)	char	*dir;	char	*name;	char	*ver;	FINFO	**finfo_buf;E 41{D 41	register FILESPEC	*cfp, *nfp;E 41I 41	register struct direct	*dp;	register FINFO		*prevp;	register FINFO		*nextp;	int			n, len, rval;	DIR			*dirp;	register struct passwd	*pwd;		struct stat		sbuf;	char			namebuf[MAXPATHLEN];	D 42	ERRSETJMP(-1);E 41E 39E 36E 42I 39D 41	/*	 * At first, free the linked structures of FILESPEC in files field of	 * this DIRSPEC structure.	 */	for (cfp = dirspecp->files; cfp != (FILESPEC *)NULL; cfp = nfp) {		nfp = cfp->next;		free(cfp->name);		if (cfp->ver != 0) free(cfp->sname);		free((char *)cfp);E 41I 41        TIMEOUT(dirp = opendir(dir));	if (dirp == NULL) {		*Lisp_errno = errno;		return(-1);E 41	}D 41	dirspecp->files = (FILESPEC *)NULL;	E 41E 39I 36D 39/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 39I 39D 41	/*	 * Next, free the linked structure of DIRSPEC in next field of this	 * DIRSPEC structure by calling free_dirspec recarsively with selfp	 * flag on.  This linked structure represents the directories on	 * the same level of this dirspec.	 */	if (dirspecp->next != (DIRSPEC *)NULL) {		free_dirspec(dirspecp->next, 1);		dirspecp->next = (DIRSPEC *)NULL;	}E 41I 41	for (S_TOUT(dp = readdir(dirp)), nextp = prevp = (FINFO *)NULL, n = 0;	     dp != (struct direct *)NULL;	     S_TOUT(dp = readdir(dirp)), prevp = nextp) {		if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0 ||		    dp->d_ino == 0) continue;		MatchP_Case(dp->d_name, name, ver, match, unmatch);	      unmatch:		continue;	      match:		AllocFinfo(nextp);		if (nextp == (FINFO *)NULL) {			FreeFinfo(prevp);			closedir(dirp);			*Lisp_errno = errno;			return(-1);		}		nextp->next = prevp;		sprintf(namebuf, "%s/%s", dir, dp->d_name);		TIMEOUT(rval = stat(namebuf, &sbuf));		if (rval == -1 && errno != ENOENT) {			/*			 * ENOENT error might be caused by missing symbolic			 * link. We should ignore such error here.			 */			FreeFinfo(nextp);			closedir(dirp);			*Lisp_errno = errno;			return(-1);		}					strcpy(namebuf, dp->d_name);		if (sbuf.st_mode & S_IFDIR) {			nextp->dirp = 1;			quote_dname(namebuf);			strcpy(nextp->lname, namebuf);			len = strlen(namebuf);			*(nextp->lname + len) = DIRCHAR;			*(nextp->lname + len + 1) = '\0';			nextp->lname_len = len + 1;		} else {			/* All other types than directory. */			nextp->dirp = 0;			quote_fname_ufs(namebuf);			len = strlen(namebuf);			strcpy(nextp->lname, namebuf);			*(nextp->lname + len) = '\0';			nextp->lname_len = len;		}E 41E 39I 39D 41	/*	 * Next, free the linked structure of DIRSPEC in dirs field of this	 * DIRSPEC structure by calling free_dirspec recarsively with selfp	 * flag on.  This linked structure represents the subdirectories	 * of this dirspec.	 */	if (dirspecp->dirs != (DIRSPEC *)NULL) {		free_dirspec(dirspecp->dirs, 1);		dirspecp->dirs = (DIRSPEC *)NULL;E 41I 41		strcpy(namebuf, dp->d_name);		len = strlen(namebuf);		nextp->ino = sbuf.st_ino;		nextp->prop->length = (unsigned)sbuf.st_size;		nextp->prop->wdate = (unsigned)ToLispTime(sbuf.st_mtime);		nextp->prop->rdate = (unsigned)ToLispTime(sbuf.st_atime);		nextp->prop->protect = (unsigned)sbuf.st_mode;		TIMEOUT(pwd = getpwuid(sbuf.st_uid));		if (pwd == (struct passwd *)NULL) {			nextp->prop->au_len = 0;		} else {			len = strlen(pwd->pw_name);			strcpy(nextp->prop->author, pwd->pw_name);			*(nextp->prop->author + len) = '\0';			nextp->prop->au_len = len;		}		n++;E 41	}E 39D 41E 36E 26I 3D 14#define	StrongLispVersionToUnixVersion(pathname){	\		char	*cp;				\		if( (cp=index(pathname, ';')) != 0 ){	\			if(*(cp+1) != '0'){		\				*cp++ = '~';		\				for(;*cp!='\0';cp++);	\				*cp++ = '~';		\			}				\			*cp = '\0';			\		}else{					\			strcat(pathname, "~0~");	\		}					\		}E 14E 3D 39alldirSize(dirName, dir, dirlen, filter)D 22char *dirName;	/* Pointer to directoryname. ex. "/usr/aig/hayata" */E 22I 22D 36register char *dirName;	/* Pointer to directoryname. ex. "/usr/aig/hayata" */E 22char *dir;D 22int dirlen;	/* Size of directory name after dirName, initially 0 */char *filter;	/* Potinter to filter striing. ex. "*.*;*" or "a*.l*" */E 22I 22register int dirlen;	/* Size of directory name after dirName, initially 0 */D 29register char *filter;	/* Potinter to filter striing. ex. "*.*;*" or "a*.l*" */E 29I 29D 30register char *filter;	/* Pointer to filter string. ex. "*.*;*" or "a*.l*" */E 30I 30D 34register char *filter;	/* Potinter to filter striing. ex. "*.*;*" or "a*.l*" */E 34I 34register char *filter;	/* Pointer to filter string. ex. "*.*;*" or "a*.l*" */E 34E 30E 29E 22{D 22DIR *dp;struct direct *directp;E 22I 22register DIR *dp;register struct direct *directp;register int	totalsize;register int	rval;E 22struct stat stat_buf;D 22char	newdir[MAXPATHLEN];E 22char	full_name[MAXPATHLEN];E 36I 36  register char *dirName; /* Pointer to directoryname. ex. "/usr/aig/hayata" */  char *dir;  register int dirlen;	/* Size of directory name after dirName, initially 0 */  register char *filter; /* Pointer to filter string. ex. "*.*;*" or "a*.l*" */  {    register DIR *dp;    register struct direct *directp;    register int	totalsize;    register int	rval;    struct stat stat_buf;    char	full_name[MAXPATHLEN];E 36D 22int	totalsize;I 16int	rval;E 16E 22I 22#ifdef	ALLDIRSEARCHD 36char	newdir[MAXPATHLEN];E 36I 36    char	newdir[MAXPATHLEN];E 36#endifI 28#ifdef	FSERRORD 36	ERRSETJMP(-1);E 36I 36    ERRSETJMP(-1);E 36#elseE 28E 22I 20D 36	SETJMP(-1);E 36I 36    SETJMP(-1);E 36I 28#endifE 28E 20I 10D 36	if(index(filter, '/') == 0){D 16		if(stat(dirName, &stat_buf) != 0){E 16I 16		TIMEOUT( rval=stat(dirName, &stat_buf) );		if(rval != 0){E 16			err_mess("stat", errno);E 36I 36    if(index(filter, '/') == 0)      {	TIMEOUT( rval=stat(dirName, &stat_buf) );	if(rval != 0)	  {	    err_mess("stat", errno);E 36I 28#ifdef	FSERRORD 36			*Lisp_errno = errno;E 36I 36	    *Lisp_errno = errno;E 36#endifE 28D 36			return(-1);		}		return(stat_buf.st_size);D 29	}	E 29I 29D 30	}E 30I 30D 34	}	E 34I 34	}E 34E 30E 29E 10D 4#ifdef	TRACE	printf("TRACE:alldirSize(%s, %d, %s)\n", dirName, dirlen, filter);#endifE 4	totalsize = 0;D 16	if ((dp = opendir(dirName)) == (DIR *)NULL)E 16I 16	TIMEOUT( dp=opendir(dirName) );D 28	if (dp == (DIR *)NULL)E 28I 28	if (dp == (DIR *)NULL){E 36I 36	    return(-1);	  }	return(stat_buf.st_size);      }    totalsize = 0;    TIMEOUT( dp=opendir(dirName) );    if (dp == (DIR *)NULL)      {E 36#ifdef	FSERRORD 36		*Lisp_errno = errno;E 36I 36	*Lisp_errno = errno;E 36#endifE 28E 16D 36		return(-1);I 28	}E 28I 16	for(S_TOUT(directp=readdir(dp)); directp!=(struct direct *)NULL; S_TOUT(directp=readdir(dp)) ) {D 22/**E 16	while ((directp = readdir(dp)) != (struct direct *)NULL) {D 16		/* Skip "." and ".." */E 16I 16**/		/* Skip "." and ".." */E 22I 22		/* Skip "." and ".." */E 22E 16		if((*(directp->d_name))=='.'){			if(directp->d_namlen == 1)E 36I 36	return(-1);      }E 39I 39	/*	 * The name of itself also have to be freed.	 */	free(dirspecp->name);	dirspecp->name = NULL;		/*	 * Finally, if selfp is on, free itself.	 */	if (selfp) free((char *)dirspecp);E 41I 41	closedir(dirp);	if (n > 0) *finfo_buf = prevp;	return(n);E 41}E 39D 39    for(S_TOUT(directp=readdir(dp)); directp!=(struct direct *)NULL; S_TOUT(directp=readdir(dp)) )       {	/* Skip "." and ".." */	if((*(directp->d_name))=='.')	  {	    if(directp->d_namlen == 1) continue;	    else if((directp->d_namlen == 2) && (*((directp->d_name)+1) == '.'))E 36				continue;D 36			else if((directp->d_namlen == 2) && (*((directp->d_name)+1) == '.'))				continue;		}D 4		strcpy(full_name, dirName);		strcat(full_name, "/");		strcat(full_name, directp->d_name);E 4I 4		sprintf(full_name, "%s/%s", dirName, directp->d_name);E 4D 12		if(stat(full_name, &stat_buf) != 0)E 12I 12D 16		if(stat(full_name, &stat_buf) != 0){E 16I 16		TIMEOUT( rval=stat(full_name, &stat_buf) );		if(rval != 0){E 36I 36	  }	sprintf(full_name, "%s/%s", dirName, directp->d_name);	TIMEOUT( rval=stat(full_name, &stat_buf) );	if(rval != 0)	  {E 36E 16I 13D 28/** When symbolic linked file have not a linked-to file, stat cause error. So this err_mess and return should be skipped.E 13E 12D 8			printf("Error: stat [error %d]\n", errno);E 8I 8			err_mess("stat", errno);I 12			closedir(dp);			return(-1);I 13**/E 28I 28/** When symbolic linked file have not a linked-to file, stat cause error. So this err_mess and return should be skipped. **/D 36			if(errno != 2){				err_mess("stat", errno);E 36I 36	    if(errno != 2)	      {		err_mess("stat", errno);E 36#ifdef	FSERRORD 36				*Lisp_errno = errno;E 36I 36		*Lisp_errno = errno;E 36#endifD 36				TIMEOUT( closedir(dp) );				return(-1);			}E 28E 13		}E 12E 8		else			if((*(directp->d_name) != '.') && (stat_buf.st_mode & S_IFDIR)){E 36I 36		TIMEOUT( closedir(dp) );		return(-1);	      }	  }	else if((*(directp->d_name) != '.') && (stat_buf.st_mode & S_IFDIR))	  {E 36#ifdef	ALLDIRSEARCHD 36				strcpy(newdir, dir);				strcat(newdir, directp->d_name);				strcat(newdir, "/");				totalsize += alldirSize(full_name, newdir, strlen(newdir), filter);E 36I 36	    strcpy(newdir, dir);	    strcat(newdir, directp->d_name);	    strcat(newdir, "/");	    totalsize += alldirSize(full_name, newdir, strlen(newdir), filter);E 36#elseD 4				strcpy(full_name, dir);				strcat(full_name, directp->d_name);E 4I 4D 36				sprintf(full_name, "%s%s", dir, directp->d_name);D 6/* No need -- Hiroshi Apr-28E 6E 4D 10				if(matchp(full_name, filter)==TRUE)	E 10I 10D 29				if(DSK_matchp(full_name, filter)==TRUE)	E 29I 29D 30				if(DSK_matchp(full_name, filter)==TRUE)E 30I 30D 34				if(DSK_matchp(full_name, filter)==TRUE)	E 34I 34				if(DSK_matchp(full_name, filter)==TRUE)E 34E 30E 29E 10I 4D 6*/E 6E 4D 12					totalsize += (dirlen + directp->d_namlen + 2);	/* 2 means DIRCHAR and SEPRCHAR */				E 12I 12					totalsize += (dirlen + directp->d_namlen + 2);D 29					/* 2 means DIRCHAR and SEPRCHAR */		E 29I 29D 30					/* 2 means DIRCHAR and SEPRCHAR */E 30I 30D 34					/* 2 means DIRCHAR and SEPRCHAR */		E 34I 34					/* 2 means DIRCHAR and SEPRCHAR */E 36I 36	    sprintf(full_name, "%s%s", dir, directp->d_name);	    if(DSK_matchp(full_name, filter)==TRUE)	    totalsize += (dirlen + directp->d_namlen + 2);	    /* 2 means DIRCHAR and SEPRCHAR */E 36E 34E 30E 29E 12#endifD 36			}else{D 4				strcpy(full_name, dir);				strcat(full_name, directp->d_name);				if(matchp(full_name, filter)==TRUE){						totalsize += (dirlen + directp->d_namlen + 1); /* 1 means SEPRCHAR */				}E 4I 4				sprintf(full_name, "%s%s", dir, directp->d_name);D 6/* No need -- Hiroshi Apr-28E 6D 10				if(matchp(full_name, filter)==TRUE)	E 10I 10D 29				if(DSK_matchp(full_name, filter)==TRUE)	E 29I 29D 30				if(DSK_matchp(full_name, filter)==TRUE)E 30I 30D 34				if(DSK_matchp(full_name, filter)==TRUE)	E 34I 34				if(DSK_matchp(full_name, filter)==TRUE)E 34E 30E 29E 10D 6*/E 6D 12					totalsize += (dirlen + directp->d_namlen + 10); /* 10 means SEPRCHAR and version */E 12I 12					totalsize += (dirlen + directp->d_namlen + 10);					 /* 10 means SEPRCHAR and version */E 12E 4			}	}D 16	closedir(dp);E 16I 16	TIMEOUT( closedir(dp) );E 16D 12	if( errno == EINVAL ) errno = 0;	/*ignore spurious error for empty dir*/E 12	return(totalsize);}E 36I 36	  }	else	  {	    sprintf(full_name, "%s%s", dir, directp->d_name);	    if(DSK_matchp(full_name, filter)==TRUE)	      totalsize += (dirlen + directp->d_namlen + 10);	   /* 10 means SEPRCHAR and version */	  }      }    TIMEOUT( closedir(dp) );    return(totalsize);  }E 39I 39/*		D 41 * Name:	recache_dirspecE 41I 41 * Name:	enum_ufsE 41 *D 41 * Argument:	DIRSPEC	*dirspecp *				A pointer to a DIRSPEC structure.   *		char	*dir	A full directory name which information is re cached.E 41I 41 * Argument:	char	*dir	Absolute path of directory in UNIX format. *		char	*name	Pattern specify the files to be enumerated. *		char	*ver    String representation of version should be *				enumerated. *		FINFO	**finfo_buf *				The place where linked list of FINFO structures *				reslt of the enumeration will be stored.E 41 *D 41 * Value:	If succeed, returns 1, otherwise 0.E 41I 41 * Value:	If suceed, returns the number of enumerated files, otherwise -1.E 41 *D 41 * Side Effect:	Storages for new dirspec and its components will be malloced. E 41I 41 * Side Effect:	None.E 41 * * Description: *D 41 * Recache the information of dir on dirspecp structure.  At first, the storages * for the components of dirspecp is freed, then new storages will be alloced. * Thease storages can be freeed with free_dirspec routine.  This routine does not * maintain mtime field of dirspecp.  A caller have to maintain it.E 41I 41 * Similar to enum_ufs_prop, but file properties are not stored.E 41 */E 39E 36I 39D 41recache_dirspec(dirspecp, dir)	register DIRSPEC	*dirspecp;	char			*dir;E 41I 41enum_ufs(dir, name, ver, finfo_buf)	char	*dir;	char	*name;	char	*ver;	FINFO	**finfo_buf;E 41{	register struct direct	*dp;D 41	register DIR		*dirp;E 41I 41	register FINFO		*prevp;	register FINFO		*nextp;	int			n, len, rval;	DIR			*dirp;E 41	struct stat		sbuf;D 41	char			file[MAXPATHLEN];	register int		len, rval;E 39I 36I 39	ERRSETJMP(0);E 41I 41	char			namebuf[MAXPATHLEN];E 41	D 41	/*	 * We don't want to free the top level cache structure, Cached_Dir.  Thus	 * the second argument for free_dirspec, selfp, is 0.	 */	free_dirspec(dirspecp, 0);E 41I 41D 42	ERRSETJMP(-1);E 41E 39E 42D 39/************************************************************************//*									*//*									*/I 37/*	This function is only called from DSK_readdir(dsk.c)		*/E 37/*									*//*									*/D 37/*									*/E 37/************************************************************************/E 39I 39D 41	TIMEOUT(rval = stat(dir, &sbuf));	if (rval == -1){		*Lisp_errno = errno;		return(0);	}E 39E 36I 18D 22#ifdef VERSIONLESSE 22E 18D 4readAllDir(dirName, dir, dirlen, filter, buffer)E 4I 4D 39DSK_readAllDir(dirName, dir, dirlen, filter, buffer)E 4D 22char *dirName;E 22I 22register char *dirName;E 22char *dir;int dirlen;char *filter;D 22char *buffer;E 22I 22D 37register char *buffer;E 37I 37register char *buffer;/* buffer is in LISP */E 37E 22{D 22DIR *dp;struct direct *directp;struct stat stat_buf;char	full_name[MAXPATHLEN];char	newdir[MAXPATHLEN];I 18char	path[MAXPATHLEN];char	name[MAXPATHLEN];char	version[VERSIONLEN];E 22I 22register int	rval;register DIR *dp;register struct direct *directp;E 22E 18char	*startp;I 4D 18int	length;E 18I 18D 22int	i;E 18I 16int	rval;E 16E 4I 20	SETJMP(-1);E 20D 4#ifdef	TRACE	printf("TRACE:readAllDir(%s, %s, %d, %s, %x)\n", dirName, dir, dirlen, filter, buffer);E 4I 4	startp = buffer;D 16	if ((dp = opendir(dirName)) == (DIR *)NULL)E 16I 16	TIMEOUT( dp=opendir(dirName) );	if (dp == (DIR *)NULL)E 16		return(-1);I 16	for(S_TOUT(directp=readdir(dp)); directp!=(struct direct *)NULL; S_TOUT(directp=readdir(dp)) ){D 18/**E 16	while ((directp = readdir(dp)) != (struct direct *)NULL) {I 16**/E 18E 16		/* Skip "." and ".." */		if((*(directp->d_name))=='.'){			if(directp->d_namlen == 1)				continue;			else if((directp->d_namlen == 2) && (*((directp->d_name)+1) == '.'))				continue;		}		sprintf(full_name, "%s/%s", dirName, directp->d_name);D 12		if(stat(full_name, &stat_buf) != 0)E 12I 12D 16		if(stat(full_name, &stat_buf) != 0){E 16I 16		TIMEOUT(rval=stat(full_name, &stat_buf));		if(rval != 0){E 16I 13/** When symbolic linked file have not a linked-to file, stat cause error. So this err_mess and return should be skipped.E 13E 12D 8			printf("Error: stat [error %d]\n", errno);E 8I 8			err_mess("stat", errno);I 12			closedir(dp);			return(-1);I 13**/E 13		}E 12E 8		else			if((*(directp->d_name) != '.') && (stat_buf.st_mode & S_IFDIR)){D 18#ifdef	ALLDIRSEARCH				strcpy(newdir, dir);				strcat(newdir, directp->d_name);				strcat(newdir, "/");D 10				buffer += readAllDir(full_name, newdir, strlen(newdir), filter, buffer);E 10I 10				buffer += DSK_readAllDir(full_name, newdir, strlen(newdir), filter, buffer);E 10#elseE 18				sprintf(full_name, "%s%s", dir, directp->d_name);D 10				if(matchp(full_name, filter)==TRUE){	E 10I 10				if(DSK_matchp(full_name, filter)==TRUE){	E 10					strncpy(buffer, full_name, dirlen+directp->d_namlen);					buffer += (dirlen + directp->d_namlen);					*(buffer++) = DIRCHAR;					*(buffer++) = SEPRCHAR;				}E 4D 18#endifE 18I 4			}else{				sprintf(full_name, "%s%s", dir, directp->d_name);D 10				if(matchp(full_name, filter)==TRUE){	E 10I 10				if(DSK_matchp(full_name, filter)==TRUE){	E 10					UnixVersionToLispVersion(full_name);I 17D 18					AddDodNoExtention(full_name);E 17					length = strlen(full_name);					strncpy(buffer, full_name, length);					buffer += length;E 18I 18					if(parse(full_name, path, name, version) == 0)						continue;					if(*version == '\0')						i = MAXVERSION;					else						i = atoi(version);										if(getoldfile(path, name+1, i, version) == 0)						continue;					AddDodNoExtention(path);					i = strlen(path);					strncpy(buffer, path, i);					buffer += i;E 18					*(buffer++) = SEPRCHAR;				}			}	}D 16	closedir(dp);E 16I 16	TIMEOUT( closedir(dp) );E 16D 12	if( errno == EINVAL ) errno = 0;	/*ignore spurious error for empty dir*/E 12D 10	return(buffer - startp);E 10I 10	return( (int)buffer - (int)startp );E 10}I 18#elseDSK_readAllDir(dirName, dir, dirlen, filter, buffer)char *dirName;char *dir;int dirlen;char *filter;char *buffer;{E 22struct stat stat_buf;D 22int	rval;DIR *dp;struct direct *directp;char	*startp;E 22char	pathname[MAXPATHLEN];I 26static	int	f_count;E 39I 39	/*	 * The top dirspec of the cache holds the full directory name in its	 * name field.  Note that discendants holds only its name, not fullname.	 */	len = strlen(dir);	if ((dirspecp->name = (char *)malloc(len + 1)) == NULL) return(0);	strcpy(dirspecp->name, dir);	dirspecp->namlen = len;E 39E 26E 41I 28D 39#ifdef	FSERROR	ERRSETJMP(-1);#elseE 28I 20	SETJMP(-1);I 28#endifE 28E 20	STAT(dirName, &stat_buf);	if(ValidDirSpecP(dirName, stat_buf.st_mtime)==0){		/* Free RootDirSpec and re-set RootDirSpec */		FreeArea(&RootDirSpec);		strcpy(RootDirSpec.name, dirName);		RootDirSpec.namlen = strlen(dirName);D 29		RootDirSpec.mtime = stat_buf.st_mtime;			RootDirSpec.files = 0;			RootDirSpec.dirs = 0;	E 29I 29D 30		RootDirSpec.mtime = stat_buf.st_mtime;		RootDirSpec.files = 0;		RootDirSpec.dirs = 0;E 30I 30D 34		RootDirSpec.mtime = stat_buf.st_mtime;			RootDirSpec.files = 0;			RootDirSpec.dirs = 0;	E 34I 34		RootDirSpec.mtime = stat_buf.st_mtime;		RootDirSpec.files = 0;		RootDirSpec.dirs = 0;E 34E 30E 29		TIMEOUT( dp=opendir(dirName) );D 28		if (dp == (DIR *)NULL)E 28I 28		if (dp == (DIR *)NULL){#ifdef	FSERRORE 39I 39        TIMEOUT(dirp = opendir(dir));	if (dirp == NULL) {D 41		free(dirspecp->name);E 41		*Lisp_errno = errno;D 41		return(0);E 41I 41		return(-1);E 41	}D 41	for (S_TOUT(dp = readdir(dirp)); dp != (struct direct *)NULL;	     S_TOUT(dp = readdir(dirp))) {		sprintf(file, "%s/%s", dir, dp->d_name);		TIMEOUT(rval = stat(file, &sbuf));E 41I 41	for (S_TOUT(dp = readdir(dirp)), nextp = prevp = (FINFO *)NULL, n = 0;	     dp != (struct direct *)NULL;	     S_TOUT(dp = readdir(dirp)), prevp = nextp) {		if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0 ||		    dp->d_ino == 0) continue;		MatchP_Case(dp->d_name, name, ver, match, unmatch);	      unmatch:		continue;	      match:		AllocFinfo(nextp);		if (nextp == (FINFO *)NULL) {			FreeFinfo(prevp);			closedir(dirp);			*Lisp_errno = errno;			return(-1);		}		nextp->next = prevp;		sprintf(namebuf, "%s/%s", dir, dp->d_name);		TIMEOUT(rval = stat(namebuf, &sbuf));E 41		if (rval == -1 && errno != ENOENT) {			/*D 41			 * ENOENT error might be caused by missing symbolic link.			 * We should ignore such error here.E 41I 41			 * ENOENT error might be caused by missing symbolic			 * link. We should ignore such error here.E 41			 */D 41			free(dirspecp->name);E 39			*Lisp_errno = errno;E 41I 41			FreeFinfo(nextp);E 41D 39#endifE 28			return(-1);E 39I 39			closedir(dirp);D 41			return(0);E 41I 41			*Lisp_errno = errno;			return(-1);E 41E 39I 28		}E 28D 39		for(S_TOUT(directp=readdir(dp)); directp!=(struct direct *)NULL; S_TOUT(directp=readdir(dp)) ){			sprintf(pathname, "%s/%s", dirName, directp->d_name);D 19			STAT(pathname, &stat_buf);E 19I 19			TIMEOUT(rval=stat(pathname, &stat_buf));			if(rval != 0){			/* When symbolic linked file have not a linked-to file, stat cause error. So if errno = 2, skip the file */				if(errno==2){					continue;				}else{					err_mess("stat", errno);I 28#ifdef	FSERROR					*Lisp_errno = errno;#endif					TIMEOUT( closedir(dp) );E 28					return(-1);				}E 39I 39D 41E 41I 41					strcpy(namebuf, dp->d_name);E 41		if (sbuf.st_mode & S_IFDIR) {D 41			Push_Dir(dirspecp, dp, rval);			if (!rval) {				free(dirspecp->name);				closedir(dirp);				return(0);E 39			}E 41I 41			nextp->dirp = 1;			quote_dname(namebuf);			strcpy(nextp->lname, namebuf);			len = strlen(namebuf);			*(nextp->lname + len) = DIRCHAR;			*(nextp->lname + len + 1) = '\0';			nextp->lname_len = len + 1;E 41E 19D 39			if(stat_buf.st_mode & S_IFDIR){D 28				if(SetToDirs(&RootDirSpec, directp) == -1)E 28I 28				if(SetToDirs(&RootDirSpec, directp) == -1){					TIMEOUT( closedir(dp) );E 28					return(-1);I 28				}E 28			}else{D 28				if(SetToFiles(&RootDirSpec, directp) == -1)E 28I 28				if(SetToFiles(&RootDirSpec, directp) == -1){					TIMEOUT( closedir(dp) );E 28					return(-1);I 28				}E 39I 39		} else {			/* All other types than directory. */D 41			Push_File(dirspecp, dp, rval);			if (!rval) {				free(dirspecp->name);				closedir(dirp);				return(0);E 39E 28			}I 39			dirspecp->files->ino = sbuf.st_ino;E 41I 41			nextp->dirp = 0;			quote_fname_ufs(namebuf);			len = strlen(namebuf);			strcpy(nextp->lname, namebuf);			*(nextp->lname + len) = '\0';			nextp->lname_len = len;E 41E 39		}I 41		strcpy(namebuf, dp->d_name);		len = strlen(namebuf);		nextp->ino = sbuf.st_ino;		n++;E 41I 28D 39#ifdef	FSERROR		ERRSETJMP(-1);#elseE 28I 24		SETJMP(-1);I 28#endifE 28E 24		TIMEOUT( closedir(dp) );E 39	}D 39	/* Now, RootDirSpec is valid */	startp = buffer;D 26	buffer = SetDirsToBuffer(&RootDirSpec, buffer, filter);	buffer = SetFilesToBuffer(&RootDirSpec, buffer, filter);E 26I 26	f_count = 0;	buffer = SetDirsToBuffer(&RootDirSpec, buffer, filter, &f_count);	buffer = SetFilesToBuffer(&RootDirSpec, buffer, filter, &f_count);E 26	*buffer = '\0';I 37	/* byte-swap OP will be done in file_sort on i386 */E 37I 26D 34	file_sort(startp, f_count);E 34I 34	file_sort(startp, f_count,dsk_strcmp);E 34E 26	return( (int)buffer - (int)startp );E 39I 39D 41	TIMEOUT(closedir(dirp));	return(1);E 41I 41	closedir(dirp);	if (n > 0) *finfo_buf = prevp;	return(n);E 41E 39}I 39D 41/************************************************************************	SUBROUTINES	For pattern matching check************************************************************************/E 39I 36E 41I 39/*		D 41 * Name:	match_name_pE 41I 41 * Name:	trim_finfoE 41 *D 41 * Argument:	char	*name	The name and extenstion part of the file name in *				UNIX format. *		char	*pattern *				The pattern to which name is compared.  The wild card *				character is '*'. *		int	recp	If 1, indicates that match_name_p is called *				recursively.E 41I 41 * Argument:	FINFO	**fp	Linked list of the numerated FINFO structures.E 41 *D 41 * Value:	If name is regarded to match with pattern, returns 1, otherwise 0.E 41I 41 * Value:	Returns the total number of files still remaining in **fp.E 41 * * Side Effect:	None. * * Description: *D 41 * Matches name against pattern.   *E 41I 41 * Giving the linked list of FINFO, take care of versionless files.  If the * versionless file is not linked any higher versioned file, it is given a highest * version.  If versionless file is linked to one of versioned file, it is got * rid of. * This routine is only used by DSK codes.E 41 */E 39D 39/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 36D 22#endifE 22E 18UFS_readAllDir(dirName, dir, dirlen, filter, buffer)D 22char *dirName;E 22I 22register char *dirName;E 22char *dir;int dirlen;char *filter;D 22char *buffer;E 22I 22register char *buffer;E 39I 39D 41match_name_p(name, pattern, recp)	register char	*name;	register char	*pattern;	register int	recp;E 41I 41trim_finfo(fp)	FINFO	**fp;E 41E 39E 22{D 22DIR *dp;struct direct *directp;E 22I 22D 39register DIR *dp;register struct direct *directp;char	*startp;register int	length;register int	rval;E 22struct stat stat_buf;char	full_name[MAXPATHLEN];I 26int	f_count = 0;E 26I 22#ifdef	ALLDIRSEARCHE 22char	newdir[MAXPATHLEN];D 22char	*startp;int	length;I 16int	rval;E 22I 22#endifE 39I 39D 41	register char	*np, *pp;	np = name;	pp = pattern;		for (;;) {		switch (*pp) {E 41I 41	register FINFO	*tp, *sp, *mp, *cp, *pp;	register int	num, pnum;	int		linkp;	char		ver[VERSIONLEN];E 41E 39E 22E 16I 28D 39#ifdef	FSERROR	ERRSETJMP(-1);#elseE 28I 20	SETJMP(-1);I 28#endifE 28E 20E 4	startp = buffer;D 16	if ((dp = opendir(dirName)) == (DIR *)NULL)E 16I 16	TIMEOUT( dp=opendir(dirName) );D 28	if (dp == (DIR *)NULL)E 28I 28	if (dp == (DIR *)NULL){#ifdef	FSERROR		*Lisp_errno = errno;#endifE 28E 16		return(-1);I 28	}E 28I 16	for(S_TOUT(directp=readdir(dp)); directp!=(struct direct *)NULL; S_TOUT(directp=readdir(dp))){D 18/**E 16	while ((directp = readdir(dp)) != (struct direct *)NULL) {I 16**/E 18E 16		/* Skip "." and ".." */		if((*(directp->d_name))=='.'){			if(directp->d_namlen == 1)				continue;			else if((directp->d_namlen == 2) && (*((directp->d_name)+1) == '.'))				continue;		}D 4		strcpy(full_name, dirName);		strcat(full_name, "/");		strcat(full_name, directp->d_name);E 4I 4		sprintf(full_name, "%s/%s", dirName, directp->d_name);E 4D 12		if(stat(full_name, &stat_buf) != 0)E 12I 12D 16		if(stat(full_name, &stat_buf) != 0){E 16I 16		TIMEOUT( rval=stat(full_name, &stat_buf) );		if(rval != 0){E 16I 13D 28/** When symbolic linked file have not a linked-to file, stat cause error. So this err_mess and return should be skipped.E 13E 12D 8			printf("Error: stat [error %d]\n", errno);E 8I 8			err_mess("stat", errno);I 12			closedir(dp);			return(-1);I 13**/E 28I 28/** When symbolic linked file have not a linked-to file, stat cause error. So this err_mess and return should be skipped. **/			if(errno != 2){				err_mess("stat", errno);				closedir(dp);				return(-1);E 39I 39D 41		      case '\0':			return ((*np == '\0') ? 1 : 0);			break;E 41I 41	sp = mp = cp = *fp;	pp = (FINFO *)NULL;	num = pnum = 0;E 41D 41		      case '*':			while (*pp == '*') pp++; /* Skip the successive '*'s. */			if (*pp == '\0') return(1);					      LOOP:E 41I 41	do {		if (cp->dirp) {			pp = cp;			sp = cp = cp->next;			pnum++;			num++;			continue;		}E 41D 41			while (*np != *pp && *np != '\0') np++;			if (*np == '\0') {E 41I 41		if (cp->next != (FINFO *)NULL &&		    strcmp(cp->next->no_ver_name, cp->no_ver_name) == 0) {			mp = cp = cp->next;			num++;			while (cp->next != (FINFO *)NULL &&			       strcmp(cp->next->no_ver_name, cp->no_ver_name) == 0) {				cp = cp->next;				num++;			}		} else {			mp = cp;		}		if (sp->version == 0) {			if (cp != sp) {E 41				/*D 41				 * name has been completely scaned.				 * If remaining part of the pattern is only colon or				 * colon and following wild characters, we regard				 * it as being match.E 41I 41				 * Both versionless and versioned files exists.E 41				 */D 41				if (*pp == '.' && *(pp + 1) == '\0')				  return((!recp) ? 1 : 0);				if (*pp != '.' || *(pp + 1) != '*') return(0);				for (pp++; *pp == '*'; pp++) {}				return ((*pp == '\0') ? 1 : 0);			} else if (match_name_p(np, pp, 1)) {				/*				 * The rest part has been matched.				 */				return(1);E 41I 41				linkp = 0;				tp = sp;				do {					tp = tp->next;					if (tp->ino == sp->ino) {						linkp = 1;						break;					}				} while (cp != tp);				if (!linkp) {					/*					 * Versionless is not linked to any versioned					 * file.					 */					sprintf(ver, ";%d", mp->version + 1);					strcat(sp->lname, ver);					sp->lname_len = strlen(sp->lname);					pnum = ++num;					pp = cp;					sp = cp = cp->next;				} else {					/*					 * Versionless is linked to one of versionless					 * files. We can remove it.					 */					sp->next = (FINFO *)NULL;					FreeFinfo(sp);					pnum = num;					if (pp != (FINFO *)NULL)					  pp->next = mp;					else					  *fp = mp;					pp = cp;					sp = cp = cp->next;				}E 41			} else {				/*D 41				 * We can proceed to find the next character which				 * match the current chracter pp points.E 41I 41				 * Only versionless file exists. It is regarded as				 * version 1.E 41				 */D 41				np++;				recp = 1;				goto LOOP;E 41I 41				strcat(cp->lname, ";1");				cp->lname_len += 2;				pp = cp;				sp = cp = cp->next;				num = ++pnum;E 41E 39			}E 28E 13D 39		}E 12E 8		else			if((*(directp->d_name) != '.') && (stat_buf.st_mode & S_IFDIR)){#ifdef	ALLDIRSEARCH				strcpy(newdir, dir);				strcat(newdir, directp->d_name);				strcat(newdir, "/");D 10				buffer += readAllDir(full_name, newdir, strlen(newdir), filter, buffer);E 10I 10				buffer += UFS_readAllDir(full_name, newdir, strlen(newdir), filter, buffer);E 10#elseD 4				strcpy(full_name, dir);				strcat(full_name, directp->d_name);E 4I 4				sprintf(full_name, "%s%s", dir, directp->d_name);E 4D 29				if(matchp(full_name, filter)==TRUE){	E 29I 29D 30				if(matchp(full_name, filter)==TRUE){E 30I 30D 34				if(matchp(full_name, filter)==TRUE){	E 34I 34				if(matchp(full_name, filter)==TRUE){I 37D 38#ifndef BYTESWAPE 38I 38				/* No need to BYTESWAP here */E 38E 37E 34E 30E 29D 4					strncpy(buffer, dir, dirlen);					buffer += dirlen;					strncpy(buffer, directp->d_name, directp->d_namlen);					buffer += directp->d_namlen;E 4I 4					strncpy(buffer, full_name, dirlen+directp->d_namlen);I 37D 38#else					StrNCpyFromCToLisp(buffer, full_name, dirlen+directp->d_namlen);#endif BYTESWAPE 38E 37					buffer += (dirlen + directp->d_namlen);E 4D 37					*(buffer++) = DIRCHAR;					*(buffer++) = SEPRCHAR;E 37I 37					GETBYTE(buffer++) = DIRCHAR;					GETBYTE(buffer++) = SEPRCHAR;E 37I 27					++f_count;E 27				}#endif			}else{D 4				strcpy(full_name, dir);				strcat(full_name, directp->d_name);E 4I 4				sprintf(full_name, "%s%s", dir, directp->d_name);E 4D 29				if(matchp(full_name, filter)==TRUE){	E 29I 29D 30				if(matchp(full_name, filter)==TRUE){E 30I 30D 34				if(matchp(full_name, filter)==TRUE){	E 34I 34				if(matchp(full_name, filter)==TRUE){E 34E 30E 29D 4					strncpy(buffer, dir, dirlen);					buffer += dirlen;					strncpy(buffer, directp->d_name, directp->d_namlen);					buffer += directp->d_namlen;E 4I 4					length = dirlen + directp->d_namlen;I 37#ifndef BYTESWAPE 37					strncpy(buffer, full_name, length);I 37#else					StrNCpyFromCToLisp(buffer, full_name, length);#endif BYTESWAPE 37					buffer += length;E 4D 37					*(buffer++) = SEPRCHAR;E 37I 37					GETBYTE(buffer++) = SEPRCHAR;E 37I 26					++f_count;E 26				}E 39I 39D 41			break;		      default:			if (*np != '\0') {				if (*pp != *np) return(0);				pp++;				np++;E 41I 41		} else {			if (cp != sp) {				/*				 * All files are versioned.				 */				pnum = ++num;E 41			} else {				/*D 41				 * name has been completely scaned.				 * If remaining part of the pattern is only colon or				 * colon and following wild characters, we regard				 * it as being match.E 41I 41				 * A versioned file only exists.E 41				 */D 41				if (*pp == '.' && *(pp + 1) == '\0') return(1);				if (*pp != '.' || *(pp + 1) != '*') return(0);				for (pp++; *pp == '*'; pp++) {}				return ((*pp == '\0') ? 1 : 0);E 41I 41				num = ++pnum;E 41E 39			}I 39D 41			break;E 41I 41			pp = cp;			sp = cp = cp->next;E 41		}E 39D 41	}E 41I 41	} while (sp != (FINFO *)NULL) ;	return(num);E 41D 16	closedir(dp);E 16I 16D 39	TIMEOUT( closedir(dp) );I 26D 34	file_sort(startp, f_count);E 34I 34	file_sort(startp, f_count, ufs_strcmp);E 34E 26E 16D 12	if( errno == EINVAL ) errno = 0;	/*ignore spurious error for empty dir*/E 12D 10	return(buffer - startp);E 10I 10	return( (int)buffer - (int)startp );E 39E 10}I 22D 39/************************************************************************	SUBROUTINES	For pattern matching check************************************************************************/I 36/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 39I 39/*		D 41 * Name:	match_version_pE 41I 41 * Name:	trim_finfo_highestE 41 *D 41 * Argument:	char	*ver	The version field of a file name.  Does not include *				any version field delimiter like '~' or ';'. *		char	*pattern *				The pattern to which version is compared.  The wild card *				character is '*'.E 41I 41 * Argument:	FINFO	**fp	Linked list of the numerated FINFO structures.E 41 *D 41 * Value:	If ver is regarded to match with pattern, returns 1, otherwise 0.E 41I 41 * Value:	Returns the total number of files still remaining in **fp.E 41 * * Side Effect:	None. * * Description: *D 41 * Matches version against pattern.   *E 41I 41 * Similar to true_finfo, but the files but the highest versioned file are got rid * of.E 41 */E 39E 36E 22I 5D 10readAllDir(dirName, dir, dirlen, filter, buffer)char *dirName;char *dir;int dirlen;char *filter;char *buffer;/* for Old entry */{DIR *dp;struct direct *directp;struct stat stat_buf;char	full_name[MAXPATHLEN];char	newdir[MAXPATHLEN];char	*startp;int	length;	startp = buffer;	if ((dp = opendir(dirName)) == (DIR *)NULL)		return(-1);	while ((directp = readdir(dp)) != (struct direct *)NULL) {		/* Skip "." and ".." */		if((*(directp->d_name))=='.'){			if(directp->d_namlen == 1)				continue;			else if((directp->d_namlen == 2) && (*((directp->d_name)+1) == '.'))				continue;		}		sprintf(full_name, "%s/%s", dirName, directp->d_name);		if(stat(full_name, &stat_buf) != 0)D 8			printf("Error: stat [error %d]\n", errno);E 8I 8			err_mess("stat", errno);E 8		else			if((*(directp->d_name) != '.') && (stat_buf.st_mode & S_IFDIR)){#ifdef	ALLDIRSEARCH				strcpy(newdir, dir);				strcat(newdir, directp->d_name);				strcat(newdir, "/");				buffer += readAllDir(full_name, newdir, strlen(newdir), filter, buffer);#else				sprintf(full_name, "%s%s", dir, directp->d_name);				if(matchp(full_name, filter)==TRUE){						strncpy(buffer, full_name, dirlen+directp->d_namlen);					buffer += (dirlen + directp->d_namlen);					*(buffer++) = DIRCHAR;					*(buffer++) = SEPRCHAR;				}#endif			}else{				sprintf(full_name, "%s%s", dir, directp->d_name);				if(matchp(full_name, filter)==TRUE){						length = dirlen + directp->d_namlen;					strncpy(buffer, full_name, length);					buffer += length;					*(buffer++) = SEPRCHAR;				}			}	}	closedir(dp);	if( errno == EINVAL ) errno = 0;	/*ignore spurious error for empty dir*/	return(buffer - startp);}E 10E 5D 39matchp(name, filter)char	*name;char	*filter;E 39I 39D 41match_version_p(ver, pattern)	register char	*ver;	register char	*pattern;E 41I 41trim_finfo_highest(fp, highestp)	FINFO	**fp;	int	highestp;E 41E 39{D 7char	*np,*fp;#ifdef	TRACE	printf("TRACE:matchp(%s, %s)\n", name, filter);#endif	/* matchp filename ? */I 3	StrongLispVersionToUnixVersion(name);E 3	for(np=name, fp=filter; *fp!='.';){E 7I 7D 39char	name_name[100];char	name_extension[100];char	name_version[100];char	filter_name[100];char	filter_extension[100];char	filter_version[100];E 39I 39D 41	register char	*vp, *pp;	vp = ver;	pp = pattern;		for (;;) {		switch (*pp) {E 41I 41	register FINFO	*tp, *sp, *mp, *cp, *pp;	register int	num, pnum;	int		linkp;	char		ver[VERSIONLEN];E 41E 39D 39	match_parse(name, name_name, name_extension, name_version);	match_parse(filter, filter_name, filter_extension, filter_version);	if( match_part_p(name_name, filter_name) == 0)		return(0);	if( match_part_p(name_extension, filter_extension) == 0)		return(0);	if( match_part_p(name_version, filter_version) == 0)		return(0);	return(1);}I 36/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 39I 39D 41		      case '\0':			return ((*vp == '\0') ? 1 : 0);			break;E 41I 41	sp = mp = cp = *fp;	pp = (FINFO *)NULL;	num = pnum = 0;E 41E 39E 36I 39D 41		      case '*':			while (*pp == '*') pp++; /* Skip the successive '*'s. */			if (*pp == '\0') return(1);					      LOOP:E 41I 41	do {		if (cp->dirp) {			pp = cp;			sp = cp = cp->next;			pnum++;			num++;			continue;		}E 41E 39I 36E 36I 10D 39DSK_matchp(name, filter)char	*name;char	*filter;{/** Case insesitive matchp **/char	name_name[100];char	name_extension[100];char	name_version[100];char	filter_name[100];char	filter_extension[100];char	filter_version[100];E 39I 39D 41			while (*vp != *pp && *vp != '\0') vp++;			if (*vp == '\0') {				return(0);			} else if (match_version_p(vp, pp)) {E 41I 41		if (cp->next != (FINFO *)NULL &&		    strcmp(cp->next->no_ver_name, cp->no_ver_name) == 0) {			mp = cp = cp->next;			num++;			while (cp->next != (FINFO *)NULL &&			       strcmp(cp->next->no_ver_name, cp->no_ver_name) == 0) {				cp = cp->next;				num++;			}		} else {			mp = cp;		}		if (sp->version == 0) {			if (cp != sp) {E 41				/*D 41				 * The rest part has been matched.E 41I 41				 * Both versionless and versioned files exists.E 41				 */D 41				return(1);E 41I 41				linkp = 0;				tp = sp;				do {					tp = tp->next;					if (tp->ino == sp->ino) {						linkp = 1;						break;					}				} while (cp != tp);				if (!linkp) {					/*					 * Versionless is not linked to any versioned					 * file.					 */					sprintf(ver, ";%d", mp->version + 1);					strcat(sp->lname, ver);					sp->lname_len = strlen(sp->lname);					/*					 * Lower versioned files, mp to cp					 * inclusive, should be removed.					 */					sp->next = cp->next;					cp->next = (FINFO *)NULL;					FreeFinfo(mp);					num = ++pnum;					pp = sp;					sp = cp = pp->next;				} else {					/*					 * Versionless is linked to one of versionless					 * files. We can remove it.					 */					if (mp != cp) {						sp->next = mp->next;						mp->next = cp->next;						cp->next = (FINFO *)NULL;					} else {						sp->next = (FINFO *)NULL;					}					FreeFinfo(sp);					num = ++pnum;					if (pp != (FINFO *)NULL)					  pp->next = mp;					else					  *fp = mp;					pp = mp;					sp = cp = mp->next;				}E 41			} else {				/*D 41				 * We can proceed to find the next character which				 * match the current chracter pp points.E 41I 41				 * Only versionless file exists. It is regared as				 * version 1.E 41				 */D 41				vp++;				goto LOOP;E 41I 41				strcat(cp->lname, ";1");				cp->lname_len += 2;				pp = cp;				sp = cp = cp->next;				num = ++pnum;E 41			}D 41			break;E 39E 10I 10D 39	match_parse(name, name_name, name_extension, name_version);	match_parse(filter, filter_name, filter_extension, filter_version);	if( DSK_match_part_p(name_name, filter_name) == 0)		return(0);	if( DSK_match_part_p(name_extension, filter_extension) == 0)		return(0);	if( DSK_match_part_p(name_version, filter_version) == 0)		return(0);	return(1);E 39I 39		      default:			if (*pp != *vp) return(0);			pp++;			vp++;			break;E 41I 41		} else {			if (cp != sp) {				/*				 * All files are versioned.				 * Lower versioned files can be removed.				 */				tp = sp->next;				sp->next = cp->next;				cp->next = (FINFO *)NULL;				FreeFinfo(tp);				num = ++pnum;			} else {				/*				 * A versioned file only exists.				 */				num = ++pnum;			}			pp = sp;			sp = cp = sp->next;E 41		}D 41	}E 41I 41	} while (sp != (FINFO *)NULL) ;	return(num);E 41E 39}I 36D 39/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 39I 39/*		D 41 * Name:	match_pE 41I 41 * Name:	trim_finfo_versionE 41 *D 41 * Argument:	char	*target	The target file name to be examined.  Following the *				UNIX file naming convention. *		char	*pattern *				The pattern to which the target  is compared. *				The wild card character is '*'.  Following the UNIX *				file naming convention. *		int	casep	If 1, the match is done with a case sensitive manner. *				If 0, the match is done with a case insensitive *				manner, this flag should be 0 if match_p is invoked *				from {DSK} device codes.E 41I 41 * Argument:	FINFO	**fp	Linked list of the numerated FINFO structures. *		int	rver	Requested version number.E 41 *D 41 * Value:	If target is regarded to match with pattern, returns 1, otherwise 0.E 41I 41 * Value:	Returns the total number of files still remaining in **fp.E 41 * * Side Effect:	None. * * Description: *D 41 * Matches a file name against pattern. *E 41I 41 * Similar to true_finfo, but the files but the versioned file with specified version * are got rid of.E 41 */E 39E 36D 14E 14E 10D 39match_parse(path, name, extension, version)D 22char	*path;		/* format is foo.fee;1 or foo.fee~1~ */char	*name;E 22I 22register char	*path;		/* format is foo.fee;1 or foo.fee~1~ */register char	*name;E 22char	*extension;char	*version;E 39I 39D 41match_p(target, pattern, casep)	register char	*target;	register char	*pattern;	register int	casep;E 41I 41trim_finfo_version(fp, rver)	FINFO	**fp;	int	rver;E 41E 39{D 14char	*dp,*sp;	for(sp=path, dp=name; (*sp!='.' & *sp!='~' & *sp!=';' & *sp!='\0');)		*dp++ = *sp++;	*dp = '\0';	if(*sp == '.'){		sp++;		for(dp=extension; (*sp!='~' & *sp!=';' & *sp!='\0');)			*dp++ = *sp++;		*dp = '\0';E 14I 14D 22char	*cp,*cp1;int	length;E 22I 22D 39register char	*cp,*cp1;register int	length;E 22	if( (cp=rindex(path, ';')) != 0){	/* version -- ;# */		strcpy(version, cp+1);		length = (int)cp - (int)path;		strncpy(name, path, length);	/* name & ext is saved to name buf */D 29		name[length] = '\0';		}else if( (cp=rindex(path, '~'))!=0 && (cp1=index(path, '~'))!=0 && cp1!=cp){	 E 29I 29D 30		name[length] = '\0';	}else if( (cp=rindex(path, '~'))!=0 && (cp1=index(path, '~'))!=0 && cp1!=cp){E 30I 30D 34		name[length] = '\0';		}else if( (cp=rindex(path, '~'))!=0 && (cp1=index(path, '~'))!=0 && cp1!=cp){	 E 34I 34		name[length] = '\0';	}else if( (cp=rindex(path, '~'))!=0 && (cp1=index(path, '~'))!=0 && cp1!=cp){E 34E 30E 29			if(*(cp1-1) == '.'){				/* version -- .~#~ */				++cp1;				length = (int)cp - (int)cp1;				strncpy(version, cp1, length);				version[length] = '\0';				length = (int)cp1 - (int)path - 2;				strncpy(name, path, length);	/* name & ext is saved to name buf */D 29				name[length] = '\0';	E 29I 29D 30				name[length] = '\0';E 30I 30D 34				name[length] = '\0';	E 34I 34				name[length] = '\0';E 34E 30E 29			}else{D 18#ifdef	OLD_VERSION_CONVENTION			/* version -- ~#~ */				++cp1;				length = (int)cp - (int)cp1;				strncpy(version, cp1, length);				version[length] = '\0';				length = (int)cp1 - (int)path - 1;				strncpy(name, path, length);	/* name & ext is saved to name buf */				name[length] = '\0';#elseE 18			/* No version */			version[0] = '\0';			strcpy(name, path);D 18#endifE 18			}E 14	}else{D 14		*extension = '\0';E 14I 14		/* No version */		version[0] = '\0';		strcpy(name, path);E 39I 39D 41	char	tbuf[MAXPATHLEN], pbuf[MAXPATHLEN];	char	tdir[MAXPATHLEN], pdir[MAXPATHLEN];	char	tname[MAXNAMLEN], pname[MAXNAMLEN];	char	tver[VERSIONLEN], pver[VERSIONLEN];E 41I 41	register FINFO	*tp, *sp, *mp, *cp, *pp, *vp;	register int	num, pnum;	int		linkp;	char		ver[VERSIONLEN];E 41D 41	if (!casep) {		strcpy(tbuf, target);		strcpy(pbuf, pattern);		DOWNCASE(tbuf);		DOWNCASE(pbuf);		target = tbuf;		pattern = pbuf;E 39E 14	}E 41I 41	sp = mp = cp = *fp;	pp = (FINFO *)NULL;	num = pnum = 0;E 41D 14	if(*sp == ';' | *sp == '~'){		sp++;		for(dp=version; (*sp!='~' & *sp!='\0');)			*dp++ = *sp++;		*dp = '\0';E 14I 14D 39	if( (cp=rindex(name, '.')) != 0){		strcpy(extension, cp+1);		*cp = '\0';E 14	}else{D 14		*version = '\0';E 14I 14		/* No extension */		extension[0] = '\0';E 14	}}E 39I 36D 39/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 39I 39D 41	/*	 * Ther fifth argument for unpack_filename specifies whether a version	 * field is checked as a "numeric" or not.  For a pattern, we do not like	 * to check it, because wild card characters "*" should be used in a	 * version field.	 */	if (unpack_filename(target, tdir, tname, tver, 1) == 0) return(0);	if (unpack_filename(pattern, pdir, pname, pver, 0) == 0) return(0);E 41I 41	do {		if (cp->dirp) {			/*			 * Directory has no version, thus they should be remvoed.			 */			sp = cp = cp->next;			continue;		}				if (cp->next != (FINFO *)NULL &&		    strcmp(cp->next->no_ver_name, cp->no_ver_name) == 0) {			mp = cp = cp->next;			num++;			while (cp->next != (FINFO *)NULL &&			       strcmp(cp->next->no_ver_name, cp->no_ver_name) == 0) {				cp = cp->next;				num++;			}		} else {			mp = cp;		}E 41E 39E 36D 39match_part_p(name, filter)D 22char	*name;char	*filter;E 22I 22register char	*name;register char	*filter;E 22{D 22char	*np, *fp;	E 22I 22D 29register char	*np, *fp;	E 29I 29D 30register char	*np, *fp;E 30I 30D 34register char	*np, *fp;	E 34I 34register char	*np, *fp;E 34E 30E 29E 22I 10	for(np=name, fp=filter; *fp!='\0';){D 30		if(*fp=='*')			if(*(++fp)=='\0'){E 30I 30		if(*fp=='*'){			/* skip *s, like "***s" */			for(;*(fp+1)=='*'; ++fp);			if(*(++fp)=='\0'){/* filetr is "..*\0", the rest is OK */E 30				return(1);			}else{I 30			LP:				/* fp points next of *. */E 30				for(;*fp!=*np;++np)D 30					if(*np=='\0')E 30I 30					if(*np=='\0'){						/* np is finished */E 30						return(0);D 30				for(;*np==*(np+1);++np);				++fp; ++np; /* Both points next of matched char */E 30I 30					}				/* find candidate. */				if(match_part_p(np+1, fp+1) == 1){					/* The rest is match */					return(1);				}else{					/* try to find next cand */					++np;					goto LP;D 34				}	E 30			}E 34I 34				} /* else */			} /* else */E 34D 30		else{E 30I 30		}else{E 30			if(*np!=*fp)				return(0);			if(*(++fp)=='\0')				if(*(++np)=='\0'){					return(1);				}else					return(0);			++np;D 34		}	}E 34I 34		} /* else */	} /* for */E 34	if(*np=='\0')		return(1);	return(0);E 39I 39D 41	/*	 * Current specification does not allow to use wild card characters in	 * a directory part.  Thus we can compare directory parts with strcmp.	 */		return ((strcmp(tdir, pdir) == 0	&&		 match_name_p(tname, pname, 0)	&&		 match_version_p(tver, pver)) ? 1 :0);E 39}E 41I 41		for (tp = sp, vp = (FINFO *)NULL; tp != cp->next; tp = tp->next) {			if (tp->version == rver) {				vp = tp;				break;			}		}E 41I 41		if (vp != (FINFO *)NULL) {			/*			 * Specified version file exists.  Other files should be			 * removed.			 */			if (vp == sp) {				if (cp != sp) {					vp->next = cp->next;					cp->next = (FINFO *)NULL;					FreeFinfo(mp);				}			} else {				for (tp = sp; tp->next != vp; tp = tp->next) {}				if (vp != cp) {					tp->next = vp->next;					vp->next = cp->next;					cp->next = (FINFO *)NULL;				} else {					tp->next = (FINFO *)NULL;				}				if (pp != (FINFO *)NULL)				  pp->next = vp;				else				  *fp = vp;				FreeFinfo(sp);			}			pp = vp;			sp = cp = vp->next;			num = ++pnum;			continue;E 41I 30I 36D 39/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 36E 30DSK_match_part_p(n, f)D 22char	*n;char	*f;E 22I 22register char	*n;register char	*f;E 39I 39D 41case_ins_strcmp(s1, s2)	register char	*s1;	register char	*s2;E 39E 22{D 39/** Case insensitive match_part_p **/I 22D 30register char	*np, *fp;E 30E 22char	name[100];char	filter[100];D 22char	*np, *fp;E 22	strcpy(name, n);	strcpy(filter, f);	DOWNCASE(name);	DOWNCASE(filter);E 10D 30	for(np=name, fp=filter; *fp!='\0';){E 7		if(*fp=='*')D 7			if(*(++fp)=='.'){				for(;*np!='.';++np)					if(*np == '\0'){						++fp;						goto extension; 					}				++fp; ++np; /* Both points next of '.' */				goto extension;E 7I 7			if(*(++fp)=='\0'){				return(1);E 7			}else{				for(;*fp!=*np;++np)D 7					if(*np=='\0' || *np=='.')					/* "*Axx" is not matched with "xxx.x" */						return(FALSE);E 7I 7					if(*np=='\0')						return(0);				for(;*np==*(np+1);++np);E 7				++fp; ++np; /* Both points next of matched char */			}		else{			if(*np!=*fp)D 7				return(FALSE);			if(*(++fp)=='.')				if(*(++np)=='.'){					++fp; ++np; /* Both points next of '.' */					goto extension;E 7I 7				return(0);			if(*(++fp)=='\0')				if(*(++np)=='\0'){					return(1);E 7				}elseD 7					return(FALSE);E 7I 7					return(0);E 7			++np;		}D 7	}/* end for */	++fp;extension:	for(;*fp!='\0';){		if(*fp=='*'){			if(*np=='\0' || *(++fp)=='\0')				return(TRUE); 			else{				for(;*fp!=*np;++np)					if(*np=='\0')					/* "*Axx" is not matched with "xxx.x" */						return(FALSE);				++fp; ++np; /* Both points next of matched char */			}		}else{			if(*np!=*fp)				return(FALSE);			if(*(++fp)=='\0')				if(*(++np)=='\0')					return(TRUE);				else					return(FALSE);			++np;		}	} /* end for */	return(TRUE);	/* Never arrive ? */E 7I 7	}	if(*np=='\0')		return(1);	return(0);E 30I 30	return(match_part_p(name, filter));E 39I 39	char	sb1[MAXPATHLEN], sb2[MAXPATHLEN];	strcpy(sb1, s1);	strcpy(sb2, s2);	DOWNCASE(sb1);	DOWNCASE(sb2);	return(strcmp(s1, s2));E 41I 41		}		/*		 * Although there is no file with specified version, versionless		 * file might be interpreted the specified version.		 */		if (sp->version == 0) {			if (cp != sp) {				/*				 * Both versionless and versioned files exists.				 */				linkp = 0;				tp = sp;				do {					tp = tp->next;					if (tp->ino == sp->ino) {						linkp = 1;						break;					}				} while (cp != tp);				if (!linkp) {					/*					 * Versionless is not linked to any versioned					 * file.					 */					if (mp->version + 1 == rver) {						sprintf(ver, ";%d", rver);						strcat(sp->lname, ver);						sp->lname_len = strlen(sp->lname);						/*						 * Lower versioned files, mp to cp						 * inclusive, should be removed.						 */						sp->next = cp->next;						cp->next = (FINFO *)NULL;						FreeFinfo(mp);						num = ++pnum;						pp = sp;						sp = cp = pp->next;					} else {						/*						 * sp to cp inclusive, all files,						 * should be removed.						 */						tp = cp->next;						if (pp != (FINFO *)NULL)						  pp->next = tp;						else						  *fp = tp;						cp->next = (FINFO *)NULL;						FreeFinfo(sp);						sp = cp = tp;					}				} else {					/*					 * Versionless is linked to one of versionless					 * files.  We can remove all files, because					 * no versioned file match with rver.					 */					tp = cp->next;					if (pp != (FINFO *)NULL)					  pp->next = tp;					else					  *fp = tp;					cp->next = (FINFO *)NULL;					FreeFinfo(sp);					sp = cp = tp;				}			} else {				/*				 * Only versionless file exists. It is regared as				 * version 1.  Unless rver is 1, we can remove it.				 */				if (rver != 1) {					cp = sp->next;					if (pp != (FINFO *)NULL)					  pp->next = cp;					else					  *fp = cp;					sp->next = (FINFO *)NULL;					FreeFinfo(sp);					sp = cp;				} else {					strcat(cp->lname, ";1");					cp->lname_len += 2;					pp = cp;					sp = cp = cp->next;					num = ++pnum;				}			}		}	} while (sp != (FINFO *)NULL) ;	return(num);E 41E 39E 30E 7}I 18I 41/************************************************************************//************ E N D   O F   F I L E - I N F O   C O D E *****************//************************************************************************//************************************************************************//********* B E G I N  O F   F I L E - S O R T I N G   C O D E ***********//************************************************************************/E 41I 39/*		D 41 * Name:	CheckVlessLinkWithDirSpecE 41I 41 * Name:	prepare_sort_bufE 41 *D 41 * Argument:	DIRSPEC	*dirspecp *				A pointer to a DIRSPEC structure. *		FILESPEC *vlessp *				A pointer to a FILESPEC structure which represents *				a versionless file. *		int	linkp	A place where a value which indicates whether a *				versionless file has a link to a higher versioned file *				or not will be stored. *		int	highest	A place where a highest version number will be stored.E 41I 41 * Argument:	FINFO	*fp	Linked list of FINFO structures being sorted. *		int	n       Total number of structures in the above list.E 41 *D 41 * Value:	N/AE 41I 41 * Value:	If succeed, returns the pointer to the buffer, otherwise NULL *		pointer.E 41 *D 41 * Side Effect:	linkp and highest will hold the link flag and highest version *		respectively.E 41I 41 * Side Effect:	(sizeof(FINFO *) * n) bytes storage are allocated as a sort buffer.E 41 * * Description: *D 41 * Walk through dirspecp and examines whether a versionless file corresponding to * vlessp has a link to one of higher versioned file or not.  If a versionless file * has a link, linkp will hold 1, otherwise, 0.  If linkp is 0, highest always holds * the highest version in dirspecp.  If only a versionless file exists, highest * will hold 0.E 41I 41 * Prepare an area to be used as a sort buffer by qsort routine, and arrange the * contents of the buffer to be convinience to qsort routine. * Caller have to free the area after sorting done.E 41 */E 39D 22/* For versionless */E 22I 22D 39/**********************************************************************************	SUBROUTINESD 33	For versionless, currently theses routines are used only for DSK.E 33I 33	For versionless, currently these routines are used only for DSK.E 33**********************************************************************************/E 39I 39D 41#define CheckVlessLinkWithDirSpec(dirspecp, vlessp, linkp, highest){			\											\	register FILESPEC	*cp;							\											\	linkp = 0;									\	highest = 0;									\	for (cp = (dirspecp)->files; cp != (FILESPEC *)NULL; cp = cp->next) {		\		if (cp->ver != 0 && case_ins_strcmp(cp->sname, (vlessp)->name) == 0) {	\			highest = (highest > cp->ver) ? highest : cp->ver;		\			if (cp->ino == vlessp->ino) {					\				linkp = 1;						\				break;							\			}								\		}									\	}										\E 41I 41FINFO **prepare_sort_buf(fp, n)	register FINFO	*fp;	register int	n;{	register FINFO	**bp;	register FINFO	**bufp;		if ((bufp = (FINFO **)malloc(sizeof(FINFO *) * n)) == NULL) {		*Lisp_errno = errno;		return((FINFO **)NULL);	}	for (bp = bufp; fp != (FINFO *)NULL; fp = fp->next, bp++) *bp = fp;	return(bufp);E 41}E 39E 22I 39/*		D 41 * Name:	enum_dirsE 41I 41 * Name:	dsk_filecmpE 41 *D 41 * Argument:	DIRSPEC	*dirspecp *				A pointer to a DIRSPEC structure to be freed. *		char	*pattern *				A pattern to which the directories in dirspecp *				will be compared.  Specified in UNIX format. *		char	**buf	The place where the names of the enumerated directories *				will be stored. *		int	*countp	The place where total number of directories put on *				buf will be stored. *		int	dskp	If, this routine is called from {DSK} code, dskp is 1, *				otherwise 0.E 41I 41 * Argument:	FINFO	*fp1	A FINFO structure, a file name in it is being compared. *		FINFO	*fp2	A FINFO structure, a file name in it is being compared.E 41 *D 41 * Value:	Void.E 41I 41 * Value:	Returns -1, 0, or 1, according as s1 is lexically but with case *		insensitive mode greater than, equal to, or less than c2.E 41 *D 41 * Side Effect:	If succeed, buf will points to the place from where next enumerated *		objects to be stored.   countp will hold the number of enumerated *		directories.  buf will hold the enumerated directories.  Each directory *		name is separated with NULL character.E 41I 41 * Side Effect:	None.E 41 * * Description: *D 41 * Selects directories which match with pattern from dirspecp and stores them into * buf.  If dskp is on, the match will be done in case insensitive manner.E 41I 41 * Compares two file names lexically but with case insensitive mode.  Two file names * should be processed by UnixVersionToLispVersion to make sure that they have a * valid version fields.  The version fields comparison is done in numerical manner. * Note that the result is in the reversed order.E 41 */E 39D 29	E 29I 29D 30E 30I 30D 34	E 34I 34I 36D 39/************************************************************************//*									*//*									*/I 37/*		Do not care about BYTE-SWAP, 				*//*		because 'buffer' will be used in file_sort		*/E 37/*									*//*									*/D 37/*									*/E 37/************************************************************************/E 36E 34E 30E 29char *D 26SetDirsToBuffer(dirs, buffer, filter)E 26I 26SetDirsToBuffer(dirs, buffer, filter, f_count_p)E 26D 22DirSpec	*dirs;char	*buffer;char	*filter;E 22I 22register DirSpec	*dirs;D 37register char	*buffer;E 37I 37register char	*buffer; /* buffer is in LISP */E 37register char	*filter;I 26int	*f_count_p;E 39I 39D 41enum_dirs(dirspecp, pattern, buf, countp, dskp)	register DIRSPEC	*dirspecp;	register char		*pattern;	register char		**buf;	register int		*countp;	register int		dskp;E 41I 41dsk_filecmp(fp1, fp2)	FINFO	**fp1;	FINFO	**fp2;E 41E 39E 26E 22{D 22DirSpec	*dp;E 22I 22D 39register DirSpec	*dp;I 26register int	f_count = 0;E 26E 22	for(dp=dirs; dp->dirs!=0;){		dp=dp->dirs;		if( DSK_matchp(dp->name, filter) ){			strncpy(buffer, dp->name, dp->namlen);E 39I 39D 41	register DIRSPEC	*dsp;	register int		n;	char			fullname[MAXPATHLEN], fullptn[MAXPATHLEN];	char			dir[MAXNAMLEN + 1];E 41I 41	register int	res, v1, v2;E 41E 39I 37E 37D 39			buffer += dp->namlen;I 37E 37			*(buffer++) = DIRCHAR;			*(buffer++) = SEPRCHAR;I 26			++f_count;E 39I 39D 41	sprintf(fullptn, "%s/%s", dirspecp->name, pattern);	n = 0;	for (dsp = dirspecp->next; dsp != NULL; dsp = dsp->next) {		sprintf(fullname, "%s/%s", dirspecp->name, dsp->name);		if (match_p(fullname, fullptn, !dskp)) {			strcpy(dir, dsp->name);			quote_filename(dir, 0, 1);			strcpy(*buf, dir);			*buf += strlen(dir);			*(*buf)++ = DIRCHAR;			*(*buf)++ = '\0';			n++;E 39E 26		}	}I 26D 39	*f_count_p += f_count;E 26	return(buffer);E 39I 39	*countp = n;E 41I 41	if ((res = strcmp((*fp1)->no_ver_name, (*fp2)->no_ver_name)) != 0)	  return(res);	if ((*fp1)->version == (*fp2)->version) return(0);	if ((v1 = (*fp1)->version) == 0) return(-1);	if ((v2 = (*fp2)->version) == 0) return(1);	return((v1 < v2) ? 1 : -1);E 41E 39}I 36D 39/************************************************************************//*									*//*									*/I 37/*		Do not care about BYTE-SWAP, 				*//*		because 'buffer' will be used in file_sort		*/E 37/*									*//*									*//*									*//************************************************************************/E 39I 39/*		D 41 * Name:	enum_filesE 41I 41 * Name:	unix_filecmpE 41 *D 41 * Argument:	DIRSPEC	*dirspecp *				A pointer to a DIRSPEC structure to be freed. *		char	*pattern *				A pattern to which the files in dirspecp *				will be compared.  Specified in UNIX format. *		char	**buf	The place where the names of the enumerated files *				will be stored. *		int	*countp	The place where total number of files put on *				buf will be stored. *		int	dskp	If, this routine is called from {DSK} code, dskp is 1, *				otherwise 0. *		int	highestp *				If highestp is 1, the files with highest version in *				the files matches to pattern are enumerated.  This *				flag has no mean if dskp is 0. *				E 41I 41 * Argument:	FINFO	*f1	A FINFO structure, a file name in it is being compared. *		FINFO	*f2	A FINFO structure, a file name in it is being compared.E 41 *D 41 * Value:	Void.E 41I 41 * Value:	Returns -1, 0, or 1, according as s1 is lexically greater than, *		equal to, or less than c2.E 41 *D 41 * Side Effect:	If succeed, buf will points to the place from where next enumerated *		objects to be stored.   countp will hold the number of enumerated *		files.  buf will hold the enumerated files.  Each file name is *		separated with NULL character.E 41I 41 * Side Effect:	None.E 41 * * Description: *D 41 * Selects files which match with pattern from dirspecp and stores them into * buf.  If dskp is on, the match will be done in case insensitive manner. * If dskp is on, versionlesss file is dealt with specially, if there is a file * to which that versionless file is linked in dirspecp, the versionless file will * not be copied into buf.  Version field is converted into Lisp format when dskp * is on.E 41I 41 * Compares two file names lexically mode. * Note that the result is in the reversed order.E 41 */E 39E 36D 39char *D 26SetFilesToBuffer(dir, buffer, filter)E 26I 26SetFilesToBuffer(dir, buffer, filter, f_count_p)E 26D 22DirSpec	*dir;char	*buffer;char	*filter;E 22I 22register DirSpec	*dir;D 37register char	*buffer;register char	*filter;E 37I 37register char	*buffer; /* buffer in LISP */register char	*filter; /* filter has right byte-order */E 37I 26int	*f_count_p;E 39I 39D 41enum_files(dirspecp, pattern, buf, countp, dskp, highestp)	register DIRSPEC	*dirspecp;	register char		*pattern;	register char		**buf;	register int		*countp;	register int		dskp;	register int		highestp;E 41I 41unix_filecmp(f1, f2)	register FINFO	**f1;	register FINFO	**f2;E 41E 39E 26E 22{D 22FileSpec	*fp;int	high_ver;E 22I 22D 39register FileSpec	*fp;register int	high_ver;D 37register int	i;E 37I 37register int	len,i;E 37I 26register int	f_count = 0;E 26E 22char	name[MAXPATHLEN];char	version[VERSIONLEN];D 22int	i;E 22	if(dir->files==0)		return(buffer);	for(fp=dir->files; fp!=0;fp=fp->pnext){		strcpy(version, fp->version);		/* change version number */		if(fp->ver_no == 0 && STREQ(fp->version, "0") ){			/* fp is versionless file */			if(fp->nlink == 1){			/* versionless is highest+1 */				if((i=GetHighest(dir, fp->name)) == -1)					continue;				sprintf(version, "%d", i+1);			}else{			/* if versionless link some one in directory, skip */D 21				if(LinkP(dir, fp->ino))E 21I 21				if(LinkP(dir, fp->ino)){E 21					continue;I 21				}else{			/* versionless has no link with file in the directory */					strcpy(version, "1");E 39I 39D 41	register FILESPEC	*fp;        register int		n, linkp, highest;	char			file[MAXPATHLEN], ver[VERSIONLEN];	char			fullname[MAXPATHLEN], fullptn[MAXPATHLEN];	sprintf(fullptn, "%s/%s", dirspecp->name, pattern);	n = 0;	for (fp = dirspecp->files; fp != NULL; fp = fp->next) {		sprintf(fullname, "%s/%s", dirspecp->name, fp->name);		if (match_p(fullname, fullptn, !dskp)) {			if (dskp) {				/*				 * {DSK} device, we have to care about the way				 * to deal with a versionless file.				 */				if (fp->ver == 0) {					CheckVlessLinkWithDirSpec(dirspecp, fp,								  linkp, highest);					if (!linkp) {						/*						 * A versionless file has no link to						 * any higher versioned file.  Thus,						 * one higher than the highest						 * version is a version for this						 * versionless file.						 */						sprintf(ver, "%d", highest + 1);						ConcNameAndVersion(fp->name, ver								   ,file);						/*						 * We have to quote special characters						 * in a file name.						 */						quote_filename(file, dskp, 0);						strcpy(*buf, file);						*buf += strlen(file) + 1;						n++;					} else {						/*						 * A versionless file is linked to						 * one of higher versioned file.						 * We don't need to enumerate it if						 * highestp is off.  If highestp						 * is on, that is, the file is						 * enumerated with an empty version						 * pattern, we have to enumerate						 * highest version file.						 */						if (highestp) {							sprintf(ver, "%d", highest);							ConcNameAndVersion(fp->name,									   ver,									   file);							quote_filename(file, dskp, 0);							strcpy(*buf, file);							*buf += strlen(file) + 1;							n++;						}					}				} else {					/* A file with version. */					strcpy(file, fp->name);					quote_filename(file, dskp, 0);					strcpy(*buf, file);					*buf += strlen(file) + 1;					n++;E 39				}I 39			} else {				/*				 * {UNIX} device.  Only we have to do is to				 * copy the file name as if to a buffer.				 */				strcpy(file, fp->name);				quote_filename(file, dskp, 0);				strcpy(*buf, file);				*buf += strlen(file) + 1;				n++;E 39E 21			}D 29		}			E 29I 29D 30		}E 30I 30D 34		}			E 34I 34		}E 34E 30E 29D 25		if( DSK_matchp2(fp->name, version, filter) ){E 25I 25D 39		if( DSK_matchp2(fp, version, filter,dir) ){E 25			sprintf(name, "%s;%s", fp->name, version);			AddDodNoExtention(name);D 37			i = strlen(name);			strncpy(buffer, name, i);			buffer += i;E 37I 37			len = strlen(name);			strncpy(buffer, name, len);			buffer += len;E 37			*(buffer++) = SEPRCHAR;I 26			++f_count;E 26		}E 39	}I 26D 39	*f_count_p += f_count;E 26	return(buffer);E 39I 39	*countp = n;E 41I 41	return(strcmp((*f1)->lname, (*f2)->lname));E 41E 39}I 36D 39/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 39I 39/*		D 41 * Name:	enum_allE 41I 41 * Name:	file_sortE 41 *D 41 * Argument:	char	*dir	A full directory name on which files and directories *				are being enumerated. *		char	*pattern *				A pattern to which files and directories on dir will *				be compared.  Specified in UNIX format. *		char	*buf	The place where the names of the enumerated files and *				directories will be stored. *		int	dskp	If, this routine is called from {DSK} code, dskp is 1, *				otherwise 0. *		int	highestp *				If, only highest version file should be enumerated, *				highestp is 1, otherwise 0.E 41I 41 * Argument:	FINFO	**fpp	A pointer to a pointer adressing the linked FINFO *				being sorted. *		int	n	A number of FINFO structure linked. *		int	(*sortfn)() *				A pointer to a function to be used to sort the FINFOs.E 41 *D 41 * Value:	If succeed, returns the total number of files and directories *		enumerated, otherwise -1.E 41I 41 * Value:	If succeed, returns 1, otherwise, 0.E 41 *D 41 * Side Effect:	buf will hold the enumerated directories.  Each file and directory *		name is separated with NULL character.E 41I 41 * Side Effect:	None.E 41 * * Description: *D 41 * Selects files and directories which match with pattern from dirspecp and stores * them buf.  If dskp is on, the match will be done in case insensitive manner.E 41I 41 * Sorts the files to be appropriate for Lisp.   dsk_filecmp and unix_filecmp are * used for {DSK} and {UNIX} device respectively as a sort function.E 41 */E 39E 36D 39SetToDirs(dir, directp)D 22DirSpec	*dir;		/* RootDirSpec */struct direct *directp;E 22I 22register DirSpec	*dir;		/* RootDirSpec */register struct direct *directp;E 39I 39D 41enum_all(dir, pattern, buf, dskp, highestp)	register char	*dir;	register char	*pattern;	char		*buf;	register int	dskp;	register int	highestp;E 41I 41file_sort(fpp, n, sortfn)	register FINFO	**fpp;	register int	n;	register int	(*sortfn)();E 41E 39E 22{D 22char	name[MAXPATHLEN];DirSpec	*newdp;DirSpec	*dp;int	rval;E 22I 22D 39register DirSpec	*newdp;register DirSpec	*dp;register int	rval;E 22struct stat stat_buf;I 22char	name[MAXPATHLEN];I 28#ifdef	FSERRORE 39I 39D 41	register int	rval, n;	int		count;	struct stat	sbuf;E 41I 41	register FINFO	**fp;	register FINFO	**sort_bufp;E 41E 39D 41	ERRSETJMP(-1);D 39#elseE 28E 22I 20	SETJMP(-1);I 28#endifE 28E 20	/* skip . and .. */	if(STREQ(directp->d_name, ".")){D 28		return;E 28I 28		return(1);E 39I 39		TIMEOUT(rval = stat(dir, &sbuf));	if (rval == -1) {		*Lisp_errno = errno;		return(-1);E 39E 28	}E 41I 41	if ((sort_bufp = prepare_sort_buf(*fpp, n)) == (FINFO **)NULL) return(0);E 41D 39	if(STREQ(directp->d_name, "..")){D 28		return;E 28I 28		return(1);E 39I 39D 41	if (Cached_Dir.mtime != sbuf.st_mtime || strcmp(Cached_Dir.name, dir) != 0) {		/*		 * Cached information is invalid.  Recache it.		 */		if (!recache_dirspec(&Cached_Dir, dir)) return(-1);		Cached_Dir.mtime = sbuf.st_mtime;E 39E 28	}E 41I 41	qsort(sort_bufp, n, sizeof(FINFO *), sortfn);E 41D 39	/* scan last one */	for(dp=dir;dp->dirs!=0;dp=dp->dirs);	/* get new one */D 28	newdp = ((DirSpec *)malloc(sizeof(DirSpec)));E 28I 28	if( ( newdp = ((DirSpec *)malloc(sizeof(DirSpec))) ) == NULL)		return(-1);E 28	/* set to new one */	strcpy(newdp->name, directp->d_name);	newdp->namlen = strlen(directp->d_name);	sprintf(name, "%s/%s", dir->name, directp->d_name);	STAT(name, &stat_buf);	newdp->mtime = stat_buf.st_mtime;	newdp->files = 0;	newdp->dirs = 0;	/* link with last */	dp->dirs = newdp;I 28	return(1);E 39I 39D 41	n = 0;	count = 0;	enum_dirs(&Cached_Dir, pattern, &buf, &count, dskp);	n += count;	enum_files(&Cached_Dir, pattern, &buf, &count, dskp, highestp);	n += count;E 41I 41	/*	 * Relink FINFO structures in a buffer.	 */	for (fp = sort_bufp; n > 1; fp++, n--) (*fp)->next = *(fp + 1);	(*fp)->next = (FINFO *)NULL;E 41D 41	return(n);E 41I 41	*fpp = *sort_bufp;	free((char *)sort_bufp);	return(1);E 41E 39E 28}I 41/************************************************************************//************ E N D   O F   F I L E - S O R T I N G   C O D E ***********//************************************************************************/#ifndef BYTESWAPtypedef struct ufsgfs {	unsigned	finfoid;	unsigned	fileid;	unsigned	totalnum;	LispPTR		directory;	unsigned	propp		: 1;	unsigned	padding		: 7;	unsigned	dev		:24;	LispPTR		thisfile;	int		errno;	LispPTR		name;	unsigned	length;	unsigned	wdate;	unsigned	rdate;	unsigned	protection;	LispPTR		author;	unsigned	aulen;} UFSGFS;#endif BYTESWAP#ifdef BYTESWAPtypedef struct ufsgfs {	unsigned	finfoid;	unsigned	fileid;	unsigned	totalnum;	LispPTR		directory;	unsigned	dev		:24;	unsigned	padding		: 7;	unsigned	propp		: 1;	LispPTR		thisfile;	int		errno;	LispPTR		name;	unsigned	length;	unsigned	wdate;	unsigned	rdate;	unsigned	protection;	LispPTR		author;	unsigned	aulen;} UFSGFS;#endif BYTESWAPE 41I 36D 39/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 39I 39/*		 * Name:	COM_gen_files * * Argument:	LispPTR	*args	args[0] *				 The pattern of file name to be enumerated in Lisp *				 format.  Includes the host field. *				args[1]D 41 *				 The place where the name of the enumerated files *				 will be stored.E 41I 41 *				 Flag indicating whether Lisp needs property or not.E 41 *				args[2]I 41 *				 The place where the file info ID should be placed. *				args[3]E 41 *				 The place where the error number should be stored. * * Value:	If succeed, returns the Lisp positive integer which represents the *		total number of enumerated files, otherwise Lisp -1. * * Side Effect:	None. * * Description: * * The implementation of GENERATEFILES FDEV method for DSK and UNIX device. * Enumerates files matching pattern. */E 39E 36D 39SetToFiles(dir, directp)D 22DirSpec	*dir;		/* RootDirSpec */struct direct *directp;E 22I 22register DirSpec	*dir;		/* RootDirSpec */register struct direct *directp;E 39I 39COM_gen_files(args)	register LispPTR	*args;E 39E 22{I 22D 39register FileSpec	*fp;register FileSpec	*newp;register int	rval;struct stat stat_buf;E 22char	name[MAXPATHLEN];char	version[VERSIONLEN];I 28#ifdef	FSERROR	ERRSETJMP(-1);#elseE 28D 22FileSpec	*fp;FileSpec	*newp;int	rval;struct stat stat_buf;E 22I 20	SETJMP(-1);I 28#endifE 28E 20	/* get new one */D 28	newp = ((FileSpec *)malloc(sizeof(FileSpec)));E 28I 28	if( (newp = ((FileSpec *)malloc(sizeof(FileSpec)))) == NULL)		return(-1);E 28	/* set to new one */	strcpy(name, directp->d_name);	parseversion(name, version);	strcpy(newp->name, name);	strcpy(newp->version, version);	sprintf(name, "%s/%s", dir->name, directp->d_name);	STAT(name, &stat_buf);	newp->ino = stat_buf.st_ino;	newp->nlink = stat_buf.st_nlink;	newp->ver_no = atoi(version);	newp->pnext = 0;E 39I 39D 41	char		fbuf[MAXPATHLEN], pattern[MAXPATHLEN], dir[MAXPATHLEN];E 41I 41D 44	char		fbuf[MAXPATHLEN], dir[MAXPATHLEN], pattern[MAXPATHLEN];E 44I 44	char		fbuf[MAXPATHLEN + 5], dir[MAXPATHLEN], pattern[MAXPATHLEN];E 44E 41	char		host[MAXNAMLEN], name[MAXNAMLEN], ver[VERSIONLEN];D 41	register int	dskp, count, highestp;	register	char *buf;	int		(*sortfn)(), dsk_filecmp(), unix_filecmp();E 41I 41	int		dskp, count, highestp, propp, id, version;	register char	*cp;	FINFO		*fp;	int		dsk_filecmp(), unix_filecmp();E 41E 39D 39	/* scan  and link last one */	if(dir->files==0){		dir->files = newp;	}else{		for(fp=dir->files; fp->pnext!=0;fp=fp->pnext);		fp->pnext = newp;E 39I 39	ERRSETJMP(GetSmallp(-1));	D 41	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));E 41I 41	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));E 41	I 44	LispStringLength(args[0], count, dskp);	/*	 * Because of the version number convention, Lisp pathname might	 * be shorter than UNIX one.  For THIN string, the difference	 * is 2 bytes, for FAT string, 4 bytes.  Add 1 byte for NULL	 * terminating character.	 */	count = dskp ? count + 4 + 1 : count + 2 + 1;	/* Add 5 for the host name field in Lisp format. */	if (count > MAXPATHLEN + 5) FileNameTooLong((GetSmallp(-1)));E 44	LispStringToCString(args[0], fbuf, MAXPATHLEN);	separate_host(fbuf, host);	UPCASE(host);	if (strcmp(host, "DSK") == 0)	  dskp = 1;	else if (strcmp(host, "UNIX") == 0)	  dskp = 0;	else	  return(NIL);I 41	if (args[1] == NIL)	  propp = 0;	else	  propp = 1;E 41	/*	 * The way to deal with the version field in file enumeration is a little	 * bit tricky because of the bad specification of original {UNIX} device.	 *	 * According to the Medley 1.1 release note, in the representation	 * "{UNIX}<dir>name.ext;3", ';' and '3' are regarded as a part of the	 * file name, not its version.  On the other hand, in 1.1 implementation,	 * in the pattern "{UNIX}<dir>*.*;*", the ';' and the last '*' are regarded	 * as a version field, not part of the file name.  Actually the pattern	 * "{UNIX}<tmp>*.*;*" enumerates all of the files on /tmp directory	 * even if they never include ';' character in its name, as well as '.'.	 *	 * Thus I beleive, the specification should be clean upped as like,	 * "UNIX device always ignores the version field in it file name representation	 * even if a user specifies it expricitly".	 * But to keep a compatibility to an already released version, we have	 * to do some trick here.	 */	if (!unixpathname(fbuf, pattern, 1, 1)) {D 41		/* yes, always dskp is on */E 41I 41		/* Yes, always dskp is on */E 41		return(GetSmallp(-1));E 39	}D 28	return;E 28I 28D 39	return(1);E 28}E 39I 36D 39/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 39I 39	if (!unpack_filename(pattern, dir, name, ver, 0)) return(GetSmallp(-1));E 39E 36D 39FreeArea(dir)DirSpec	*dir;		/* RootDirSpec */{D 22FileSpec *fp;FileSpec *nextfp;DirSpec	*dp;DirSpec	*nextdp;E 22I 22register FileSpec	*fp;register FileSpec	*nextfp;register DirSpec	*dp;register DirSpec	*nextdp;E 22	if(dir->files != 0){		for(fp=dir->files;fp!=0;fp=nextfp){			nextfp = fp->pnext;			free(fp);		}E 39I 39	if (dskp) {		/*D 41		 * On {DSK}, we have to make sure dir is case sensitively exisitingE 41I 41		 * On {DSK}, we have to make sure dir is case insensitively exisitingE 41		 * directory.		 */		if (true_name(dir) != -1) return(GetSmallp(-1));E 39D 41	}E 41D 39	if(dir->dirs != 0){		for(dp=dir->dirs;dp!=0;dp=nextdp){			nextdp = dp->dirs;			free(dp);E 39I 39D 41	STRING_BASE(args[1], buf);	if (!dskp) {E 41I 41		if (*ver != '\0') {			highestp = 0;			version = atoi(ver);			if (version > 0) strcpy(ver, "*");		} else {			version = 0;			for (cp = fbuf; *cp; cp++) {}			if (*(cp - 1) == ';' && *(cp - 2) != '\'') {				/*				 * An empty version is interpreted as wanting the				 * highest version.  In this case, at first enumerate				 * all version.  trim_finfo_highest will get rid of				 * lower versions.				 */				strcpy(ver, "*");				highestp = 1;			} else {				highestp = 0;			}		}		if (propp)		  count = enum_dsk_prop(dir, name, ver, &fp);		else		  count = enum_dsk(dir, name, ver, &fp);	} else {E 41		/* Makes UNIX device matchts any version. */		strcpy(ver, "*");D 41	} else {		register char	*cp;E 41D 41		cp = fbuf;		while (*cp) cp++;		if (*(cp - 1) == ';' && *(cp - 1) != '\'') {			/*			 * An empty version is interpreted as wanting the highest			 * version.			 */			highestp = 1;		} else {			highestp = 0;E 39		}E 41I 41		if (propp)		  count = enum_ufs_prop(dir, name, ver, &fp);		else		  count = enum_ufs(dir, name, ver, &fp);E 41	}I 41		switch (count) {E 41D 39}E 39I 36D 39/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 39I 39D 41	ConcNameAndVersion(name, ver, pattern);	if ((count = enum_all(dir, pattern, buf, dskp, highestp)) == -1)	  return(GetSmallp(-1));E 41I 41	      case -1:		return(GetSmallp(-1));E 41E 39E 36I 36D 39E 36ValidDirSpecP(dirName, mtime)char	*dirName;time_t	mtime;{	if(mtime == RootDirSpec.mtime && STREQ(dirName, RootDirSpec.name))		return(1);E 39I 39D 41	if (dskp)	  sortfn = dsk_filecmp;E 39	elseD 39		return(0);}E 39I 39	  sortfn = unix_filecmp;E 41I 41	      case 0:		return(GetSmallp(0));E 41E 39D 29 E 29I 29D 30E 30I 30D 34 E 34I 34I 36D 39/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 39I 39D 41	if (!file_sort(buf, count, sortfn)) return(GetSmallp(-1));E 41I 41	      default:		if (!file_sort(&fp, count, dskp ? dsk_filecmp : unix_filecmp))		  return(GetSmallp(-1));		if (dskp) {			if (highestp)			  count = trim_finfo_highest(&fp);			else if (version > 0 && count > 0) 			  count = trim_finfo_version(&fp, version);			else			  count = trim_finfo(&fp);		}E 41E 39E 36E 34E 30E 29D 39GetHighest(dir, name)	/* return highest version no */D 22DirSpec	*dir;		/* RootDirSpec */E 22I 22register DirSpec	*dir;		/* RootDirSpec */E 22char	*name;		/* foo.c */{D 22FileSpec	*fp;FileSpec	*max_fp;int	max = 0;E 22I 22register FileSpec	*fp;register FileSpec	*max_fp;register int	max = 0;E 22	if(dir->files==0)		return(-1);	for(fp=dir->files; fp!=0; fp=fp->pnext){		if(STREQ(fp->name, name)){			/* Check version */			if((fp->ver_no > max) && CheckOnlyNumber(fp->version)){				max = fp->ver_no;			}		}	}	return(max);E 39I 39D 41	return(GetSmallp(count));E 41I 41		if ((id = get_finfo_id()) < 0) return(GetSmallp(-1));		*(int *)(Addr68k_from_LADDR(args[2])) = id;		FinfoArray[id].head = fp;		FinfoArray[id].next = fp;		return(GetSmallp(count));	}E 41E 39D 29}			E 29I 29D 30}E 30I 30D 34}			E 34I 34}E 34E 30E 29I 36D 39/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 39I 39/*		D 41 * Name:	COM_bufsizeE 41I 41 * Name:	COM_next_fileE 41 * * Argument:	LispPTR	*args	args[0]D 41 *				 The pattern of file name to be enumerated in Lisp *				 format.  Includes the host field. *				args[1] *				 The place where the error number should be stored.E 41I 41 *				 Lisp pointer to UFSGFS structure.E 41 *D 41 * Value:	If succeed, returns the Lisp positive integer which represents the *		appropriate buffer size, otherwise, Lisp 0.E 41I 41 * Value:	If succeed, returns the length of the file name as a Lisp positive *		integer, otherwise -1.E 41 * * Side Effect:	None. * * Description: *D 41 * Estimates the appropriate buffer size to be allocated by Lisp to keep the result * of the directory enumeration done by C code.  This code is common to both of {DSK} * and {UNIX} devices.E 41I 41 * The implementation of NEXTFILEFN File Generator Component for DSK and UNIX device. * Because of the efficiency reason, if propp, stores properties as well as file * name. */COM_next_file(args)	register LispPTR	*args;{	register LispPTR	laddr;	register FPROP		*pp;	register FINFO		*fp;	register char		*base;	register DFINFO		*dfp;	register UFSGFS		*gfsp;	int			finfoid, propp;	ERRSETJMP(-1);	Lisp_errno = &Dummy_errno;	gfsp = (UFSGFS *)(Addr68k_from_LADDR(args[0]));	finfoid = (int)gfsp->finfoid;	if (finfoid < 0 || MAXFINFO - 1 < finfoid) return(GetSmallp(-1));	propp = gfsp->propp;	dfp = &FinfoArray[finfoid];	if (dfp->head == (FINFO *)0 || (fp = dfp->next) == (FINFO *)0)	  return(GetSmallp(-1));	dfp->next = fp->next;	laddr = gfsp->name;	STRING_BASE(laddr, base);#ifndef BYTESWAP	strncpy(base, fp->lname, fp->lname_len);#else	StrNCpyFromCToLisp(base, fp->lname, fp->lname_len);#endif BYTESWAP		if (!propp) return(GetSmallp(fp->lname_len));	pp = fp->prop;	gfsp->length = pp->length;	gfsp->wdate = pp->wdate;	gfsp->rdate = pp->rdate;	gfsp->protection = pp->protect;	laddr = gfsp->author;	STRING_BASE(laddr, base);#ifndef BYTESWAP	strncpy(base, pp->author, pp->au_len);#else	StrNCpyFromCToLisp(base, pp->author, pp->au_len);#endif BYTESWAP		gfsp->aulen = pp->au_len;	return(GetSmallp(fp->lname_len));}/*		 * Name:	COM_finish_finfoE 41 *D 41 * Note:E 41I 41 * Argument:	LispPTR	*args	args[0] *				 Finfo ID.E 41 *D 41 * 03/23/90 10:30:58 by nmE 41I 41 * Value:	If succeed, returns ATOM_T, otherwise Lisp NIL.E 41 *D 41 * This routine have to be called to let Lisp know the buffer size to be allocated. * If we decide to implement the directory wild card, this routine would exactly * walk through the specified directory, and in the course of it, it would be * possible to enumerate the files and correct the attributes which would be * requested by GENERATEFILES FDEV method.  If we could allocate a buffer which can * be efficiently accessed from Lisp with C code directly, we could avoid the second * directory lookup.E 41I 41 * Side Effect:	None.E 41 *I 41 * Description: * * When Lisp directory enumerateion file generator is exhausted or the enumerating * operation is aborted, this routine is called. * Abandon all cached information corresponding to the generator.E 41 */E 39E 36D 39LinkP(dir, ino)D 22DirSpec	*dir;ino_t	ino;E 22I 22register DirSpec	*dir;register ino_t	ino;E 39I 39D 41COM_bufsize(args)E 41I 41COM_finish_finfo(args)E 41	register LispPTR	*args;E 39E 22{D 22FileSpec	*fp;int	flag = 0;E 22I 22D 39register FileSpec	*fp;register int	flag = 0;E 22	if(dir->files==0)		return(0);	for(fp=dir->files; fp!=0; fp=fp->pnext){		if(fp->ino == ino){			if(flag)				return(1);			else				flag =1;		}	}I 21	return(0);E 21D 29}				E 29I 29D 30}E 30I 30D 34}				E 34I 34}E 39I 39D 41	char		buf[MAXPATHLEN], pattern[MAXPATHLEN], dir[MAXPATHLEN];	char		host[MAXNAMLEN], name[MAXNAMLEN], ver[VERSIONLEN];	struct stat	sbuf;	register int	dskp, rval;E 41I 41	register DFINFO		*dfp;	register FINFO		*fp;	register		finfoid;E 41E 39I 36D 39/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 39I 39D 41	ERRSETJMP(GetSmallp(0));	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));E 41I 41	ERRSETJMP(NIL);E 41	D 41	LispStringToCString(args[0], buf, MAXPATHLEN);E 41I 41	Lisp_errno = &Dummy_errno;E 41E 39E 36E 34E 30E 29D 25DSK_matchp2(name, version, filter)char	*name;E 25I 25D 39DSK_matchp2(fp, version, filter, dir)FileSpec	*fp;E 25char	*version;char	*filter;I 25DirSpec	*dir;E 25{I 22register char	*cp;I 25int	i, nv;E 25E 22char	name_name[100];char	name_extension[100];char	name_version[100];char	filter_name[100];char	filter_extension[100];char	filter_version[100];E 39I 39D 41	separate_host(buf, host);	UPCASE(host);	if (strcmp(host, "DSK") == 0)	  dskp = 1;	else if (strcmp(host, "UNIX") == 0)	  dskp = 0;	else	  return(GetSmallp(0));E 41I 41	finfoid = LispNumToCInt(args[0]);E 41E 39D 22char	*cp;E 22D 25	strcpy(name_name, name);E 25I 25D 39	strcpy(name_name, fp->name);E 25	if((cp=rindex(name_name, '.')) == 0){		/* no extension */		*name_extension = '\0';	}else{		*cp = '\0';		strcpy(name_extension, cp+1);E 39I 39D 41	if (!unixpathname(buf, pattern, dskp, 0)) return(GetSmallp(0));	if (!unpack_filename(pattern, dir, name, ver, 0)) return(GetSmallp(0));E 41I 41	if (finfoid < 0 || MAXFINFO - 1 < finfoid) return(NIL);E 41D 41	if (dskp) {		/*		 * Make sure that dir is an existing directory.  We don't need to		 * create a new directory here.		 */		if (true_name(dir) != -1) return(GetSmallp(0));E 41I 41	dfp = &FinfoArray[finfoid];	if ((fp = dfp->head) == (FINFO *)0) {		dfp->next = (FINFO *)0;		return(NIL);E 41E 39	}D 39	strcpy(name_version, version);	match_parse(filter, filter_name, filter_extension, filter_version);	if( DSK_match_part_p(name_name, filter_name) == 0)		return(0);	if( DSK_match_part_p(name_extension, filter_extension) == 0)		return(0);I 25	/* Version of filter is NULL */	if(*filter_version == '\0'){		/* Nolink versionless file matches */		if(STREQ(fp->version, "0"))			return(1);		/* Highest version file matches */D 29	 	if((i=GetHighest(dir, fp->name)) == -1){E 29I 29D 30		if((i=GetHighest(dir, fp->name)) == -1){E 30I 30D 34	 	if((i=GetHighest(dir, fp->name)) == -1){E 34I 34		if((i=GetHighest(dir, fp->name)) == -1){E 34E 30E 29			return(0);D 29	  	}else{E 29I 29D 30		}else{E 30I 30D 34	  	}else{E 34I 34		} else{E 34E 30E 29			nv = atoi(name_version);			if(nv != i){				/* Not highest file */				return(0);			}			if(fp->nlink==1){				/* No link highest file */				return(0);			}			/* highest link file match */			return(1);		}E 39I 39D 41	TIMEOUT(rval = stat(dir, &sbuf));	if (rval == -1) {		*Lisp_errno = errno;		return(GetSmallp(0));E 39	}E 41I 41	dfp->head = (FINFO *)0;	dfp->next = (FINFO *)0;	FreeFinfo(fp);E 41E 25D 39	if( DSK_match_part_p(name_version, filter_version) == 0)		return(0);	return(1);E 39I 39D 41	/*	 * The current specification does not allow to use wild card characters in	 * a directory part.  Thus, we assume the size of the directory file itself	 * would be appropriate for a buffer.   Of course, dirent C structre includs	 * other field than the file or sub directory name on the directory, we	 * ignore them, so the size returned by this routine is "big enough, not	 * "accurate".	 */	return(GetSmallp(sbuf.st_size));E 41I 41	return(ATOM_T);E 41E 39}I 39D 41E 39E 41E 18E 1