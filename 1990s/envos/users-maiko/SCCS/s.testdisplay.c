h62629s 00000/00000/00389d D 1.6 90/04/20 01:54:32 sybalsky 6 5c ning file names, bulk change.es 00018/00003/00371d D 1.5 89/04/07 13:51:56 shih 5 4c more diagnosticses 00021/00008/00353d D 1.4 89/03/10 19:01:00 shih 4 3c more debugging aidses 00108/00046/00253d D 1.3 89/03/10 15:14:14 shih 3 2c many more diagnosticses 00035/00001/00264d D 1.2 89/03/08 16:35:16 shih 2 1c restored cgfour inites 00265/00000/00000d D 1.1 89/03/08 16:27:02 shih 1 0c date and time created 89/03/08 16:27:02 by shiheuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *	file	:	testdisplay.c *	Author	:	Osamu Nakamura */#include <stdio.h>#include <sunwindow/window_hs.h>#include <sunwindow/cms.h>#include <sys/ioctl.h>#include <sys/mman.h>#include <sunwindow/win_ioctl.h>#include <pixrect/pixrect_hs.h>#include <sun/fbio.h>I 5#include <sundev/kbd.h>#include <sundev/kbio.h>E 5#include <sys/ioctl.h>#include <sys/file.h>I 3#include <sys/stat.h>E 3#include <pixrect/pr_planegroups.h>/**************************************#include "lispemul.h"#include "lispmap.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "emulglobal.h"#include "display.h"#include "devconfig.h"#include "bb.h"#include "bitblt.h"#include "pilotbbt.h"#include "dbprint.h"		****/struct screen LispScreen;struct pixrect *CursorBitMap, *InvisibleCursorBitMap;struct pixrect *SrcePixRect, *DestPixRect;int LispWindowFd;int FrameBufferFd;I 5int KeyboardFd;E 5int DisplayWidth, DisplayHeight, DisplayRasterWidth, DisplayType;int DisplayByteSize;short *DisplayRegion68k;	/* 68k addr of #{}22,0 */struct cursor CurrentCursor, InvisibleCursor;struct winlock DisplayLockArea;extern int errno;/**************************************extern DLword *EmCursorBitMap68K;extern IFPAGE *InterfacePage;int DebugDSP = T;******************************************//************** provide below so can skip the include files *******/#define BITSPER_DLWORD	16#define SUN2BW		1#define SUN4COLOR	2#define CURSORWIDTH	16#define CURSORHEIGHT	16#define DBPRINT(X)   printf X/************** provide above so can skip the include files *******//*  ================================================================  */init_display2(display_addr, display_max)	int   display_addr, display_max;{	int mmapstat;	int ioctlresult;	char *texture_base, *malloc();	struct fbtype my_screen;	char groups[PIXPG_OVERLAY+1];	struct fbgattr  FBattr;	struct pixrect *ColorFb;I 3D 5	int mask;E 5I 5	int mask, kbtype;E 5E 3	if( (LispWindowFd = win_screennew( &LispScreen )) == -1){		perror("init_display: can't create LispWindow\n");		exit( -1 );	}	else {#ifdef KBINT		int_io_open(LispWindowFd);#endif		fcntl(LispWindowFd, F_SETFL, fcntl(LispWindowFd, F_GETFL, 0)| FNDELAY);	}D 5E 5	DisplayRegion68k = (short *) display_addr;	if( (FrameBufferFd = open( LispScreen.scr_fbname, 2 )) == -1){		perror("init_display: can't open FrameBuffer\n");		exit( -1 );	}I 3D 5	DBPRINT(("LispScreen.scr_fbname %s\n", LispScreen.scr_fbname));E 5I 5	if( (KeyboardFd = open( LispScreen.scr_kbdname, 2 )) == -1){		perror("init_display: can't open Keyboard\n");		exit( -1 );	}	DBPRINT(("LispScreen.scr_kbdname %s\n", LispScreen.scr_kbdname));	DBPRINT(("LispScreen.scr_fbname  %s\n", LispScreen.scr_fbname ));        if ( ioctl ( KeyboardFd, KIOCTYPE, &kbtype ) != 0 ) {		perror ( "ioctl(KIOCTYPE,..) fails" );		}	else {		DBPRINT(("ioctl(KIOCTYPE): %d\n", kbtype ));	     }E 5E 3	/* initialize Display parameters */        if (ioctl(FrameBufferFd, FBIOGTYPE , &my_screen)== -1) {D 3        	perror("init_display: can't find screen parameters\n");E 3I 3		perror("init_display: can't find screen parameters\n");E 3                exit( -1 );        }        DisplayWidth  = my_screen.fb_width;        DisplayHeight = my_screen.fb_height;        DisplayRasterWidth = DisplayWidth / BITSPER_DLWORD;	if ((DisplayWidth * DisplayHeight) > display_max){		DisplayHeight = display_max / DisplayWidth;	}D 3 	DBPRINT(("FBIOGTYPE w x h = %d x %d\n", DisplayWidth, DisplayHeight));E 3I 3	DBPRINT(("FBIOGTYPE w x h = %d x %d\n", DisplayWidth, DisplayHeight));E 3	DBPRINT(("          type  = %d\n", my_screen.fb_type ));	DBPRINT(("          bpp   = %d\n", my_screen.fb_depth ));/** now attempt to use the FBIOGATTR call for more information **/	ioctlresult = ioctl(FrameBufferFd, FBIOGATTR, &FBattr);	if(ioctlresult >= 0 ) {D 3 	    DBPRINT(("FBIOGATTR realtype = %d\n", FBattr.real_type)); 	    DBPRINT(("   (real) w x h = %d x %d\n", FBattr.fbtype.fb_width,E 3I 3	    DBPRINT(("FBIOGATTR realtype = %d\n",   FBattr.real_type));	    DBPRINT(("   (real) w x h = %d x %d\n", FBattr.fbtype.fb_width,E 3						    FBattr.fbtype.fb_height));	    DBPRINT(("   (real) type  = %d\n", FBattr.fbtype.fb_type ));	    DBPRINT(("   (real) bpp   = %d\n", FBattr.fbtype.fb_depth ));	    DBPRINT(("          emuls    = %d %d %d %d %d\n",					FBattr.emu_types[0],					FBattr.emu_types[1],					FBattr.emu_types[2],					FBattr.emu_types[3],					FBattr.emu_types[4] ));	    }	else {D 3 	    DBPRINT(("ioctl(fd,FBIOGATTR,&FBattr) => %d\n", ioctlresult));E 3I 3	    DBPRINT(("ioctl(fd,FBIOGATTR,&FBattr) => %d\n", ioctlresult));E 3	    }	ColorFb = pr_open("/dev/fb");D 3	pr_available_plane_groups( ColorFb, sizeof(groups), groups);	DBPRINT(("plane groups = %d %d %d %d %d %d %d %d\n",		groups[0], groups[1], groups[2], groups[3],D 2		groups[4], groups[5], groups[6], groups[7] );E 2I 2		groups[4], groups[5], groups[6], groups[7] ));E 3D 3	/* try to clear enable plane if it exists */E 3I 3	DBPRINT(("pixrect w, h, depth = %d %d %d\n",		ColorFb->pr_size.x,		ColorFb->pr_size.y, ColorFb->pr_depth ));E 3D 3	if(my_screen.fb_type == FBTYPE_SUN2BW){	   if(ioctl(FrameBufferFd,FBIOGATTR,&FBattr) >= 0){	   /* Maybe it's color display */		if(FBattr.real_type== FBTYPE_SUN4COLOR){		  /* it must be color display cgfour */E 3I 3	pr_getattributes( ColorFb, &mask );	DBPRINT(("        getattrmask = %d\n", mask ));E 3D 3		  /* we've already gotten the plane groups from above */E 3I 3	groups[0]=0; groups[1]=0; groups[2]=0; groups[3]=0; groups[4]=0;	pr_available_plane_groups( ColorFb, sizeof(groups), groups);	DBPRINT(("plane groups = current: %d\n", groups[0] ));	DBPRINT(("               mono   : %d\n", groups[1] ));	DBPRINT(("               8bitcol: %d\n", groups[2] ));	DBPRINT(("               ovrlyen: %d\n", groups[3] ));	DBPRINT(("               ovrly  : %d\n", groups[4] ));E 3D 3		  if(groups[PIXPG_OVERLAY] && groups[PIXPG_OVERLAY_ENABLE]){			pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);			pr_rop(ColorFb, 0, 0, ColorFb->pr_width, ColorFb->pr_height,			PIX_SET, 0, 0, 0);			pr_set_plane_group(ColorFb, PIXPG_OVERLAY);		   }E 3I 3	pr_available_plane_groups( ColorFb, sizeof(groups), groups);E 3D 3		}		else{E 3I 3	/* try to clear enable plane if it exists */	if (groups[PIXPG_OVERLAY] &&	    groups[PIXPG_OVERLAY_ENABLE] ){	    pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);	    pr_rop(ColorFb, 0, 0, ColorFb->pr_width,				  ColorFb->pr_height, PIX_SET, 0, 0, 0);	    pr_set_plane_group(ColorFb, PIXPG_OVERLAY);	    }	{ int currgroup;	  currgroup = pr_get_plane_group( ColorFb );	  DBPRINT(("current planegroup: %d, unknown: %d\n",			currgroup, currgroup == PIXPG_CURRENT ));        }/*  ================================================================ */#ifdef NOTUSED	if (my_screen.fb_type == FBTYPE_SUN2BW){	   if ( ioctlresult ) >= 0) {	      if (FBattr.real_type == FBTYPE_SUN4COLOR) {		     /* must be color display cgfour */		     /* we've already gotten the plane groups from above */		     if (groups[PIXPG_OVERLAY] &&			 groups[PIXPG_OVERLAY_ENABLE] ){			 pr_set_plane_group(ColorFb, PIXPG_OVERLAY_ENABLE);			 pr_rop(ColorFb, 0, 0,				ColorFb->pr_width,				ColorFb->pr_height, PIX_SET, 0, 0, 0);			 pr_set_plane_group(ColorFb, PIXPG_OVERLAY);			 }		     }		  else {  /* not cgfour */E 3		     printf("initdisplay: Unsupported FBTYPE %d\n",			FBattr.real_type);D 3		 /* exit(-1);*/		}	   }	   else{	    /* Currently we don't support REAL color buffer (overlay) */	   }E 3I 3		     }	     }		/* if ioctlresult...... */E 3	}/* if ...FBTYPE_SUN2BW end */D 3	else{ /* another type */	}E 3I 3#endif/*  ================================================================ */E 3D 3E 2E 3	DisplayLockArea.wl_rect.r_width = DisplayWidth;	DisplayLockArea.wl_rect.r_height = DisplayHeight;	init_cursor();	DisplayByteSize= ((DisplayWidth * DisplayHeight / 8 + (getpagesize()-1) )D 3			& -getpagesize());E 3I 3				& -getpagesize());E 3	DBPRINT(("Display Addr: 0x%x\n",DisplayRegion68k));	DBPRINT(("length: 0x%x\n",DisplayByteSize));	DBPRINT(("page size: 0x%x\n",getpagesize()));D 3	mmapstat =		(int)mmap( DisplayRegion68k,			DisplayByteSize,			PROT_READ | PROT_WRITE,E 3I 3	mmapstat = (int)mmap( DisplayRegion68k,			      DisplayByteSize,			      PROT_READ | PROT_WRITE,E 3#ifdef OS4D 3			MAP_FIXED |E 3I 3			      MAP_FIXED |E 3#endifD 3			MAP_SHARED,			FrameBufferFd, 0 );E 3I 3			      MAP_SHARED,			      FrameBufferFd, 0 );E 3	DBPRINT(("after mmap: 0x%x\n",mmapstat));	if(mmapstat == -1){		perror("init_display: ERROR at mmap system call\n");		exit( 0 );D 3	}E 3I 3		}E 3D 4	DBPRINT(("after mem_point, before clear display\n"));E 4I 4	DBPRINT(("before clear display()\n"));E 4	clear_display();D 4	DBPRINT(("after clear_display()\n"));E 4I 4	DBPRINT(("after  clear_display()\n"));E 4D 4	/* initialize pixrect using in pilotbitblt */E 4I 4	/* initialize pixrects used in pilotbitblt (internal will change) */E 4	SrcePixRect = mem_point( 0, 0, 1, NULL );	DestPixRect = mem_point( 0, 0, 1, NULL );	DBPRINT(("before set_cursor\n"));}/*  ================================================================  */init_cursor()    {    CursorBitMap = mem_create( CURSORWIDTH, CURSORHEIGHT, 1 );    mpr_mdlinebytes(CursorBitMap) = CURSORWIDTH >> 3;/* 2(byte) */    CurrentCursor.cur_xhot = 0;    CurrentCursor.cur_yhot = 0;    CurrentCursor.cur_shape = CursorBitMap;    CurrentCursor.cur_function = PIX_SRC | PIX_DST;    /*  Invisible Cursor */    InvisibleCursorBitMap = mem_create( 0, 0, 1 );    InvisibleCursor.cur_xhot = 0;    InvisibleCursor.cur_yhot = 0;    InvisibleCursor.cur_shape = InvisibleCursorBitMap;    InvisibleCursor.cur_function = /*PIX_SRC |*/ PIX_DST;    win_setcursor( LispWindowFd, &InvisibleCursor);    win_setmouseposition(LispWindowFd, 0, 0);    }/*  ================================================================  */display_before_exit()	{	clear_display();        win_screendestroy( LispWindowFd );#ifdef KBINT		int_io_close(LispWindowFd);#endif        close( LispWindowFd );	}/*  ================================================================  */clear_display()    {    register short *word;    register int w, h;    word = DisplayRegion68k;    for (h = DisplayHeight; (h--);)	{	for (w = DisplayRasterWidth; (w--);) {*word++ = 0;}	}    }/*  ================================================================  */paint_display()    {    register short *word;    register int w, h;    word = DisplayRegion68k;    for (h = DisplayHeight; (h--);)	{	for (w = DisplayRasterWidth; (w--);) {*word++ = w;}	}    }/*  ================================================================  */I 3#define BYTESPER_PAGE 512read_datum( lispworld )    char   *lispworld;    {    int srcefile;		/* fd */D 4    int i, sysout_size;E 4I 4    int i, j, sysout_size;E 4    int lispworld_offset;    struct stat stat_buf;I 4    char *charptr;    int readresult;    char bigbuff [ BYTESPER_PAGE ];E 4    srcefile = open("fake.sysout", O_RDONLY, NULL);    /* get sysout file size in halfpage(256) */    if (fstat( srcefile, &stat_buf) == -1) {	perror("read_datum: can't get srcefile size (fstat fails)");	exit(-1);        }    sysout_size = stat_buf.st_size / BYTESPER_PAGE * 2;    DBPRINT(("file size       =   %d\n", stat_buf.st_size ));    DBPRINT(("sysout size / 2 = 0x%x\n", sysout_size / 2));    lispworld_offset = 0;    for (i = 0; i < (sysout_size / 2); i++) {	    lispworld_offset += BYTESPER_PAGE;D 4	    if (read(srcefile, lispworld +			       lispworld_offset, BYTESPER_PAGE) == -1) {		printf("reaad_datum: can't read srcefile file at %d\n", i);E 4I 4	    charptr = (char *) lispworld + lispworld_offset;#ifdef BUFFER	    readresult = read(srcefile, bigbuff, BYTESPER_PAGE);	    for ( j = 0; j < BYTESPER_PAGE; j++ ) {		*(charptr + j) = bigbuff [ j ];		}#else	    readresult = read(srcefile, charptr, BYTESPER_PAGE);#endif	    if ( readresult == -1) {		printf("read_datum: can't read srcefile file at %d\n", i);E 4		perror("read() error was");		exit(-1);		};	    };    DBPRINT(("srcefile is read completely\n"));    close(srcefile);    }/*  ================================================================  */E 3int_io_open()  {};		/* stubs for other parts of our prog. */int_io_close() {};		/* stubs for other parts of our prog. */main()    {    int maxdisplayregion;	/* in what units? */    int realaddr;D 3    realaddr = valloc( 8000000 );E 3I 3    realaddr = valloc( 5000000 );E 3    if ( realaddr == 0 ) {       printf ( "valloc returns 0\n" );       }    else {D 4       maxdisplayregion = 4000000;		/* assume 4Mb avail */E 4I 4       maxdisplayregion = 4000000;	/* assume 4Mb display reg. */E 4       init_display2( realaddr, maxdisplayregion );       paint_display();I 4       sleep ( 4 );E 4I 3I 4       DBPRINT(("before read_datum\n"));E 4       read_datum( realaddr );E 3       sleep ( 4 );       display_before_exit();       }    }E 1