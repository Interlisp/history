h24108s 00043/00022/04051d D 2.67 92/11/25 21:03:06 sybalsky 72 71c Fixing endif's with extra text => comment. \nes 00035/00015/04038d D 2.66 92/07/24 10:45:48 sybalsky 71 70c retrofit of SGI & DEC OSF1 changes \nes 00022/00013/04031d D 2.65 92/06/26 13:48:14 sybalsky 70 69c retrofit of 386 unix changes \nes 00006/00001/04038d D 2.64 92/04/23 10:54:51 sybalsky 69 68c fixing SCCS headers \nes 00005/00005/04034d D 2.63 92/04/21 17:09:37 sybalsky 68 67c shortening file names for DOS \nes 00000/00000/04039d D 2.62 92/04/17 15:22:06 nilsson 67 66c es 00010/00005/04029d D 2.61 92/01/16 12:32:44 sybalsky 66 65c 386 deltases 00001/00001/04033d D 2.60 91/09/27 04:32:17 sybalsky 65 64c ISC port change fixes 00016/00007/04018d D 2.59 91/09/27 02:21:43 sybalsky 64 63c co ether.ces 00045/00011/03980d D 2.58 91/08/26 15:27:08 sybalsky 63 62c DEC3100 change from Savoir, for freespace check.es 00003/00001/03988d D 2.57 91/05/26 17:25:15 sybalsky 62 61c Misc X Cleanup, trying to fix a bug that's in the X-server code.es 00003/00000/03986d D 2.56 91/05/01 18:13:55 sybalsky 61 60c Retrofit changes from MIPS porting center.es 00015/00002/03971d D 2.55 91/04/09 17:24:11 sybalsky 60 59c Retrofit first round of changes from MIPS porting centeres 00004/00000/03969d D 2.54 91/02/04 12:51:42 sybalsky 59 58c Fix errors in teh Savoir retrofit (placement of ifdefs &c)es 00020/00008/03949d D 2.53 91/01/25 17:55:00 sybalsky 58 57c Retrofit HP9000/RS6000 changeses 00119/00011/03838d D 2.52 90/10/09 10:47:30 fuji 57 56c Add file name length check for FDEV methodses 00000/00000/03849d D 2.51 90/10/09 10:27:27 fuji 56 55c Add the file name length check for FDEV methodses 00058/00005/03791d D 2.50 90/09/18 23:43:06 sybalsky 55 54c Retrofit changes from AIX, DEC3100, PS/2es 00003/00000/03793d D 2.49 90/08/22 12:46:16 sybalsky 54 53c If all tests fail, make locate_file return 0.es 00008/00014/03785d D 2.48 90/06/20 12:37:47 mitani 53 52c remove redundant ERRSETJMPes 00024/00045/03775d D 2.47 90/06/04 14:52:01 mitani 52 51c new directory enumerationes 00000/00000/03820d D 2.46 90/04/20 01:27:38 sybalsky 51 50c ning file names, bulk change.es 03489/01520/00331d D 2.45 90/04/19 18:23:51 mitani 50 49c Version up to 1.2es 00022/00004/01829d D 2.44 90/03/08 10:00:18 takeshi 49 48c care about byte-order in stringses 00007/00000/01826d D 2.43 89/12/29 12:58:15 sybalsky 48 47c Changes from Savoir -- string len safetyes 00002/00002/01824d D 2.42 89/12/28 15:24:23 sybalsky 47 46c es 00018/00018/01808d D 2.41 89/12/13 10:54:40 sybalsky 46 45c string conversion safetyes 00006/00003/01820d D 2.40 89/04/04 17:20:20 sybalsky 45 44c changed getfileinfo to return 0 if author is unknownes 00005/00005/01818d D 2.39 89/03/18 04:01:44 sybalsky 44 43c Changed one-d-array name from ONEDARRAAY to OneDArray.es 00001/00000/01822d D 2.38 88/12/06 10:06:47 hayata 43 42c Add one commentes 00008/00003/01814d D 2.37 88/12/06 10:04:18 hayata 42 41c To fix connection timeout problem, DSK_directorynamep is passed Lisp ERRNO cell from new lisp code.es 00097/00000/01720d D 2.36 88/12/01 14:43:42 hayata 41 40c Use ERRSETJMP insted of SETJMPes 00078/00096/01642d D 2.35 88/12/01 12:05:25 hayata 40 39c To fix error message problem (connection time out & too many files open), global var *Lisp_errno is used to keep errno.es 00019/00005/01719d D 2.34 88/11/16 01:44:18 hayata 39 38c To fix "connection timeout" problem, some SETJMP are added.es 00000/00003/01724d D 2.33 88/11/15 17:28:15 hayata 38 37c To fix "connection timeout" problem, set of errono after makepathname is removed.es 00006/00002/01721d D 2.32 88/11/09 19:44:29 hayata 37 36c Mask Bob Bane's code for apolloes 00015/00002/01708d D 2.31 88/11/09 16:44:32 hayata 36 35c Avoid opening UNIX special files, like /dev/ttya.es 00034/00005/01676d D 2.30 88/10/07 14:05:43 hayata 35 34c DSK_getfileinfo is changed to have ALL attribute feature.es 00010/00040/01671d D 2.29 88/10/06 20:08:16 hayata 34 33c New rename code is masked by FSERRORes 00064/00014/01617d D 2.28 88/10/06 17:38:25 hayata 33 32c new rename code is masked by FSERRORes 00038/00022/01609d D 2.27 88/10/06 17:01:59 hayata 32 31c change for cross device rename filees 00005/00001/01626d D 2.26 88/08/02 11:13:05 hayata 31 30c cache in LuukupFileVerion is not available.es 00001/00321/01626d D 2.25 88/08/01 11:38:01 hayata 30 29c Fix sccs problem, ci from wring date machinees 00438/00292/01191d D 2.24 88/07/29 17:38:33 hayata 29 28c To fix wrong error message, errno is informed to Lisp. This change is all inside #ifdef FSERROR. Beause they need new lisp code. I'll add -DFSERROR to makefile after new sysout is made.es 00008/00008/01509d D 2.23 88/07/26 18:58:17 hayata 28 27c move SETJMP to avoid duplicate use of jump bufferes 00012/00011/01505d D 2.22 88/07/26 15:56:23 hayata 27 26c printf is used inside OSMESSAGE_PRINTes 00086/00092/01430d D 2.21 88/07/21 18:54:40 hayata 26 25c versionarray is changed to gloval varibale, and cache versionarray is available.es 00121/00165/01401d D 2.20 88/07/21 14:20:10 hayata 25 24c add register declarations, some functions are changed to macros.es 00018/00002/01548d D 2.19 88/07/13 18:13:46 hayata 24 23c commented out some printf in order to fix a problem of full buffer of pty.es 00070/00021/01480d D 2.18 88/07/12 18:40:03 hayata 23 22c A handling of versionless file become to be case in-sensitive.es 00000/00000/01501d D 2.17 88/07/06 13:09:57 hayata 22 21c This is a comment of previous change. changelink_and_changeversion, p_version_high is refered before set, I removed 2 refer of p_version_high.es 00004/00008/01497d D 2.16 88/07/06 13:06:31 hayata 21 20c es 00026/00003/01479d D 2.15 88/07/01 10:33:14 hayata 20 19c change changelink_and_changeversion, version1 should be changed to versionless, when there is no file.es 00017/00018/01465d D 2.14 88/06/29 10:49:53 hayata 19 18c To fix TIMEOUT, SETJMP are used.es 00008/00008/01475d D 2.13 88/06/27 10:32:57 hayata 18 17c Change some OSMESSAGE comment about link.es 00834/00181/00649d D 2.12 88/06/24 14:27:16 hayata 17 16c Versionless file is added version number. The file gets highest number.es 00008/00000/00822d D 2.11 88/06/17 20:34:17 hayata 16 15c Add RemoveDodNoExtension to some places.es 00004/00000/00818d D 2.10 88/06/17 11:18:48 hayata 15 14c AddDotNoExtention macro is put on some places.es 00014/00004/00804d D 2.9 88/06/16 16:42:37 hayata 14 13c Change getoldestfile, so version 0 file is not the oldest file.es 00013/00014/00795d D 2.8 88/06/16 16:01:21 hayata 13 12c Allow some character after ".~#~", like ".~2~%".es 00000/00001/00809d D 2.7 88/06/16 10:29:30 hayata 12 11c Debug statement about opendir is removed.es 00062/00038/00748d D 2.6 88/06/13 17:34:33 hayata 11 10c Add TIMEOUTes 00003/00002/00783d D 2.5 88/06/11 17:31:00 hayata 10 9c To add SCCS key ides 00064/00020/00721d D 2.4 88/06/11 17:23:36 hayata 9 8c Change to make difference with ";0" and no version.es 00007/00004/00734d D 2.3 88/05/23 17:40:34 hayata 8 7c Add some check of library functionses 00002/00005/00736d D 2.2 88/05/17 17:29:54 hayata 7 6c Keep creation datees 00000/00000/00741d D 2.1 88/05/17 09:57:43 hayata 6 5c Version up to 2.1es 00014/00002/00727d D 1.5 88/05/13 17:07:21 hayata 5 4c Close set Ctime at not INPUT, Getfileinfo returns correct authores 00039/00014/00690d D 1.4 88/05/10 17:43:13 hayata 4 3c Add system call error message.es 00008/00000/00696d D 1.3 88/05/07 18:19:49 hayata 3 2c Add non-recog to DSK_getfilenamees 00001/00001/00695d D 1.2 88/05/02 15:28:35 hayata 2 1c change UFS_openfile's flag initialization. INPUT => RDONLY.es 00696/00000/00000d D 1.1 88/04/28 20:28:32 masinter 1 0c date and time created 88/04/28 20:28:32 by masintereuUtTI 1D 9/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 9I 9D 10/* This is G-file @(#) dsk.c Version 2.3 (5/23/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) dsk.c	2.3 5/23/88";E 10I 10D 32D 33/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 33I 33D 47/* This is G-file %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */D 34static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xeorx)";E 33E 32I 32/* This is G-file %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xeorx)";E 34I 34static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 47I 47D 49/* This is G-file @(#) dsk.c Version 2.40 (4/4/89). copyright envos & Fuji Xerox  */static char *id = "@(#) dsk.c	2.40 4/4/89		(envos & Fuji Xerox)";E 49I 49D 57/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 57I 57D 66/* @(#) dsk.c Version 2.50 (9/18/90). copyright venue & Fuji Xerox  */static char *id = "@(#) dsk.c	2.50 9/18/90		(venue & Fuji Xerox)";E 66I 66/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 66E 57E 49E 47E 34E 32I 55I 66E 66/************************************************************************//*									*/D 66/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 66I 66D 69/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*/E 69I 69/*	(C) Copyright 1989-1992 Venue. All Rights Reserved.		*/E 69/*	Manufactured in the United States of America.			*/E 66/*									*/D 66/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 66I 66/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 66/*									*//************************************************************************/E 55I 16D 26D 29E 29E 26E 16E 10E 9D 50#include	<pwd.h>I 48#include	<stdio.h>E 48#include	<sys/file.h>E 50#include	<sys/types.h>D 50#include	<sys/stat.h>E 50#include	<sys/param.h>I 58#ifndef HPUXE 58D 50#include	<sys/time.h>#include	<sys/dir.h>E 50#include	<strings.h>I 58D 72#endif HPUXE 72I 72#endif /* HPUX */E 72E 58I 50#include	<sys/file.h>#include	<sys/dir.h>#include	<sys/stat.h>#include	<sys/time.h>I 55D 71#ifndef AIXE 71I 71#ifdef sunE 71E 55#include	<sys/vfs.h>I 55D 71#endif AIXE 71I 71#endif /* sun */#ifdef HPUX#include	<sys/vfs.h>#endif /* HPUX */E 71I 61E 61I 60#ifdef RISCOS#include	<dirent.h>#include	<unistd.h>I 61#define direct direntE 61#define d_namlen d_reclenD 72#endif RISCOSE 72I 72#endif /* RISCOS */E 72I 61I 72E 72I 64#ifdef ISC#include	<dirent.h>#include	<unistd.h>#define direct dirent#define d_namlen d_reclen#define L_SET SEEK_SETD 72#endif ISCE 72I 72#endif /* ISC */E 72I 72E 72E 64E 61E 60E 55#include	<pwd.h>E 50I 29#include 	<setjmp.h>I 50#include	<fcntl.h>#include	<stdio.h>E 50E 29I 19D 30#include 	<setjmp.h>E 30E 19I 4#include	<errno.h>E 4#include	"lispemul.h"#include	"lispmap.h"D 68#include	"address68k.h"#include	"lisptypes.h"I 50#include	"lispglobal.h"E 68I 68#include	"adr68k.h"#include	"lsptypes.h"#include	"lspglob.h"E 68E 50#include	"arith.h"#include	"stream.h"I 11#include	"timeout.h"E 11D 68#include	"localfile.h"I 29#include	"osmessage.h"E 68I 68#include	"locfile.h"#include	"osmsg.h"E 68I 48#include	"dbprint.h"E 48E 29I 27D 30#include	"osmessage.h"E 30E 27I 55D 71#ifdef DEC3100 E 71I 71#ifdef ULTRIX E 71#include	<sys/mount.h>I 71#elif OSF1#include	<sys/mount.h>E 71#else#ifdef AIXD 58#ifndef AIXPS2E 58I 58#if (!defined(AIXPS2) && !defined(HPUX))E 58#include	<sys/statfs.h>D 58#endif AIXPS2E 58I 58D 72#endif AIXPS2 | HPUXE 72I 72#endif /* AIXPS2 | HPUX */E 72E 58#define d_fileno d_inoD 72#endif AIXD 71#endif DEC3100E 71I 71#endif ULTRIXE 72I 72#endif /* AIX */E 72E 71I 72#endif /* ULTRIX */E 72I 71#ifdef APOLLO#include	<sys/statfs.h>#define d_fileno d_ino#define f_bavail f_bfree#endif  /* APOLLO */E 71I 71E 71I 70#ifdef GCC386#include "inlnPS2.h"#endif	/* GCC386 */E 70E 55I 17D 50#define	LASTVERSIONARRAY	0xFFFFFFFFD 23D 29#define	VERSIONARRAYLENGTH	100E 23I 23#define	VERSIONARRAYLENGTH	200E 23D 26#define	NIL	0#define	T	1E 29I 29#define	VERSIONARRAYLENGTH	200E 29E 26E 50I 40extern	int*	Lisp_errno;extern	int	Dummy_errno;E 40D 26D 29#define	UNLINK(x){					\		TIMEOUT(rval=unlink(x));		\		if(rval == -1){				\			err_mess("unlink", errno);	\			return(0);			\		}					\		}#define LINK(x,y){					\		TIMEOUT(rval=link(x, y));		\		if(rval == -1){				\			if(errno == 2)			\				return(1);		\			else{				\				err_mess("link", errno);\				return(0);		\			}				\		}					\		}#define RENAME(x,y){					\		TIMEOUT(rval=rename(x, y));		\		if(rval == -1){				\			if(errno == 2)			\				return(1);		\			else{				\				err_mess("rename", errno);\				return(0);		\			}				\		}					\		}E 29E 26D 63typedef struct	filename_entry{	char	name[MAXPATHLEN];	/* With version, foo.~3~ or foo */	int	version_no;}FileName;E 63I 63typedef struct	filename_entry  {    char name[MAXPATHLEN];	/* With version, foo.~3~ or foo */    int	 version_no;  } FileName;E 63I 29D 63typedef struct	current_varray{	char	path[MAXPATHLEN];	/* pathname of directory */	char	file[MAXPATHLEN];	/* file name  (down cased name) */	time_t	mtime;}CurrentVArray;E 63I 63typedef struct	current_varray  {    char	path[MAXPATHLEN];	/* pathname of directory */    char	file[MAXPATHLEN];	/* file name  (down cased name) */    time_t	mtime;  } CurrentVArray;E 63FileName	VersionArray[VERSIONARRAYLENGTH];CurrentVArray	VArrayInfo;E 29I 26D 30typedef struct	current_varray{	char	path[MAXPATHLEN];	/* pathname of directory */	char	file[MAXPATHLEN];	/* file name  (down cased name) */	time_t	mtime;}CurrentVArray;FileName	VersionArray[VERSIONARRAYLENGTH];CurrentVArray	VArrayInfo;E 30E 26FileName *GetHighestVersion();FileName *GetNextHighestVersion();FileName *GetLowestVersion();FileName *VersionlessP();I 63E 63I 50/*		 * Name:	COM_openfile * * Argument:	LispPTR	*args	args[0] *				 Full file name which is following the Xerox *				 Lisp file naming convention. *				args[1] *				 Rcoginition mode.  See IRM. *				args[2] *				 Access mode.  See IRM. *				args[3] *				 The place where the creation date of the *				 opened file should be stored. *				args[4] *				 The place where the size of the opened file *				 should be stored. *				args[5] *				 The place where the error number should be *				 stored. * * Value:	If succeed, returns the Lisp smallp which represents the open *		file descriptor, otherwise Lisp NIL. * * Side Effect:	If succeed, cdate(args[3]) and size(args[4]) will hold the *		creation date and file size respectively. * * Description: * * The implementation of OPENFILE FDEV method for DSK and UNIX device.  Try to * open a specified file. */E 50E 17D 50DSK_openfile(args)D 25D 29LispPTR	*args;E 29I 29register LispPTR	*args;E 29E 25I 25D 30register LispPTR	*args;E 30E 25/* args[0]		fullname *//* args[1]		rec *//* args[2]		acc *//* args[3]		cdate *//* args[4]		size */I 29/* args[5]		errno */E 50I 50COM_openfile(args)	register LispPTR	*args;E 50E 29{D 25D 29int	id;	/* return value  of open system call. */int	flags;	/* open system call's argument */char	pathname[MAXPATHLEN];E 29I 29D 50register int	id;	/* return value  of open system call. */register int	flags;	/* open system call's argument */register int	rval;register int	linkflag =0;register int	*bufp;E 29E 25I 25D 30register int	id;	/* return value  of open system call. */register int	flags;	/* open system call's argument */register int	rval;register int	linkflag =0;register int	*bufp;E 30E 25struct stat	statbuf;D 25D 29int	*bufp;I 11int	rval;I 17int	linkflag =0;E 25I 25char	pathname[MAXPATHLEN];E 25E 29I 29char	pathname[MAXPATHLEN];#ifdef	FSERRORD 40int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[5]));	E 40I 40	Lisp_errno = (int *)(Addr68k_from_LADDR(args[5]));	E 40#endifE 50I 50D 57	char		lfname[MAXPATHLEN], file[MAXPATHLEN], host[MAXNAMLEN];E 57I 57	char		lfname[MAXPATHLEN + 5], file[MAXPATHLEN], host[MAXNAMLEN];E 57	char		dir[MAXPATHLEN], name[MAXNAMLEN], ver[VERSIONLEN];	register int	dskp, rval, fd, link_check_flg, flags, *bufp;	struct stat	sbuf;E 50I 30E 30E 29I 19D 28	SETJMP(0);E 28E 19E 17E 11D 46	LispStringToCString(args[0], pathname);E 46I 46D 50	LispStringToCString(args[0], pathname, MAXPATHLEN);E 46I 16	RemoveDodNoExtenstion(pathname);I 17	if(checklink_and_changeversion(pathname) == 0)		return(NIL);E 17E 16	LispVersionToUnixVersion(pathname);	flags = 0;I 29#ifdef	FSERRORE 50D 40	ERRSETJMP(NIL, errp);E 40I 40	ERRSETJMP(NIL);E 40D 50#else	SETJMP(NIL);#endifI 36	TIMEOUT( rval=stat(pathname, &statbuf) );	if(rval == 0){		if((statbuf.st_mode & S_IFREG) == 0){			/* Not regular file, can not open special file */			OSMESSAGE_PRINT( printf("Can not open special file: %s.\nUse UNIX device\n",pathname ) );#ifdef FSERRORD 40			*errp = 23;	/* File won't open */E 40I 40			*Lisp_errno = 23;	/* File won't open */E 40#endif			return(NIL);E 50I 50	Lisp_errno = (int *)(Addr68k_from_LADDR(args[5]));I 57	LispStringLength(args[0], rval, dskp);	/*	 * Because of the version number convention, Lisp pathname might	 * be shorter than UNIX one.  For THIN string, the difference	 * is 2 bytes, for FAT string, 4 bytes.  Add 1 byte for NULL	 * terminating character.	 */	rval = dskp ? rval + 4 + 1 : rval + 2 + 1;	/* Add five for the host name field in Lisp format. */	if (rval > MAXPATHLEN + 5) FileNameTooLong(NIL);E 57		LispStringToCString(args[0], lfname, MAXPATHLEN);	separate_host(lfname, host);	UPCASE(host);	if (strcmp(host, "DSK") == 0)	  dskp = 1;	else if (strcmp(host, "UNIX") == 0)	  dskp = 0;	else	  return(NIL);		/*	 * Convert a Lisp file name to UNIX one.  If host is DSK, we also have to	 * convert a version field.	 */	dskp ? unixpathname(lfname, file, 1, 0) : unixpathname(lfname, file, 0, 0);	/*	 * Set up the flags argument for open system call.	 * And we have to handle the non existing directory case if the device is	 * DSK.	 * link_check_flg is used to determine wheter we have to check a hard-link	 * based version control after opening a file.	 */	link_check_flg = 0;	switch (args[1]) {			      case RECOG_OLD:	      case RECOG_OLDEST:		switch (args[2]) {		      case ACCESS_INPUT:			flags = O_RDONLY;			break;		      case ACCESS_OUTPUT:			/*			 * The current implementation of Lisp page mapped device requires			 * that the output stream being "readable"!			 */			flags = O_RDWR | O_TRUNC;			break;		      case ACCESS_BOTH:			flags = O_RDWR;			break;		      case ACCESS_APPEND:			/*			 * Should be O_WRONLY | O_APPEND.  But Lisp needs it.			 */			flags = O_RDWR;			break;E 50		}D 50	}E 36E 29I 28D 30	SETJMP(0);E 30E 28	switch(args[1]){	case RECOG_OLD:	case RECOG_OLDEST:E 50D 17			break;E 17I 17		break;E 17D 50	case RECOG_NEW_OLD:I 40	case RECOG_NEW:E 40I 17		TIMEOUT( rval=access(pathname, F_OK) );		if( rval == -1 ){D 42			/*same as RECOG_NEW */E 42I 42			if(errno == 60){  /* Connection time out */#ifdef FSERROR				*Lisp_errno = 60;#endifE 50I 50	      case RECOG_NEW:	      case RECOG_OLD_NEW:		/*		 * In DSK device, the not exsting yet file can be recognized.  In this		 * case, if there is a chance to create a new file, we have to make		 * sure that all directory to reach the recognized file exists.		 * Also we have to check the versionless file is collectly maintained		 * or not when we have a chance to create a new file.		 */		switch (args[2]) {		      case ACCESS_INPUT:			if (args[1] == RECOG_NEW) {				/*				 * Opening a input stream to a new, not yet				 * existing, file does not make sense.				 */E 50				return(NIL);I 50			} else {				/*				 * Even if OLD/NEW recoginition, opening a input				 * stream never try to create a new file.  Thus,				 * without O_CREAT.				 */				flags = O_RDONLY;E 50			}E 42D 50			linkflag =1;E 50I 50			break;		      case ACCESS_OUTPUT:			flags = O_RDWR | O_TRUNC | O_CREAT;			if (dskp) {				unpack_filename(file, dir, name, ver, 1);				if (make_directory(dir) == 0) return(NIL);				link_check_flg = 1;			}			break;		      case ACCESS_BOTH:			flags = O_RDWR | O_CREAT;			if (dskp) {				unpack_filename(file, dir, name, ver, 1);				if (make_directory(dir) == 0) return(NIL);				link_check_flg = 1;			}			break;		      case ACCESS_APPEND:			flags = O_RDWR | O_CREAT;			if (dskp) {				unpack_filename(file, dir, name, ver, 1);				if (make_directory(dir) == 0) return(NIL);				link_check_flg = 1;			}			break;E 50		}D 50		flags = O_CREAT;E 50		break;I 40D 50/**E 40E 17	case RECOG_NEW:D 17			flags = O_CREAT;			break;E 17I 17D 40		linkflag = 1;	/* Link must be done after open */E 40I 40		linkflag = 1;E 40		flags = O_CREAT;		break;I 40**/E 40E 17	default:E 50I 50	      default:E 50D 17			return(NIL);E 17I 17		return(NIL);E 17	}D 50	switch(args[2]){	case	ACCESS_INPUT:D 2			flags |= O_RDWR;E 2I 2			flags |= O_RDONLY;E 50I 50	/*	 * The file name which has been passed from Lisp is sometimes different	 * from the actual file name on DSK, even after the Lisp name is converted	 * to UNIX form with unixpathname.  Lisp always recognize a file on DSK	 * with version.  If the versionless file exists and it is not correctly	 * maintained, that is it is not hard linked to the exisiting highest	 * versioned file, Lisp regards such link missing versionless file as	 * the highest versioned file, but the actual name on the file system	 * is still versionless.	 * get_old, get_oldest, get_new, get_old_new routines handle all of the	 * complicated cases correctly and let us know the "Lisp recognizing"	 * name and "Real" name.  Both of them are UNIX format.	 * At this point, we will use one of the four routines and get the	 * real name.  We can use it to open a file which is requeste from Lisp	 * with the "Lisp recognizing" name.	 */	if (dskp) {		if (unpack_filename(file, dir, name, ver, 1) == 0) return(NIL);		if (true_name(dir) != -1) return(0);		if (get_version_array(dir, name, VersionArray, &VArrayInfo) == 0)		  return(NIL);		ConcNameAndVersion(name, ver, file);			switch (args[1]) {				      case RECOG_OLD:			if (get_old(dir, VersionArray, file, name) == 0)			  return(NIL);E 50E 2			break;D 50	case	ACCESS_OUTPUT:	case	ACCESS_APPEND:			flags |= (O_RDWR | O_CREAT);E 50I 50		      case RECOG_OLDEST:			if (get_oldest(dir, VersionArray, file, name) == 0)			  return(NIL);E 50			break;D 50	case	ACCESS_BOTH:			flags |= (O_RDWR | O_CREAT);E 50I 50		      case RECOG_NEW:			if (get_new(dir, VersionArray, file, name) == 0)			  return(NIL);E 50			break;D 50	default:E 50I 50		      case RECOG_OLD_NEW:			if (get_old_new(dir, VersionArray, file, name) == 0)			  return(NIL);			break;		      default:E 50			return(NIL);I 50		}E 50	}D 11	id = open(pathname, flags, 0666);E 11I 11D 50	TIMEOUT( id=open(pathname, flags, 0666) );E 11D 4	if(id == -1)			return(NIL);	if(fstat(id, &statbuf) == -1)			return(NIL);E 4I 4	if(id == -1){		err_mess("open", errno);I 29#ifdef FSERRORD 40		*errp = errno;E 40I 40		*Lisp_errno = errno;E 40#endifE 29		return(NIL);E 50I 50	/*	 * DSK device only allow to open a regular file.	 */	if (dskp) {		TIMEOUT(rval = stat(file, &sbuf));		if (rval == 0) {			if ((sbuf.st_mode & S_IFMT) != S_IFREG) {				/*				 * The Lisp code handles this case as same as "file table				 * overflow" error.  Final error message is "File won't				 * open". 				 */				*Lisp_errno = ENFILE;				return(NIL);			}		} else {			/*			 * When stat failed, only if the reason is "file does not			 * exist" and we are trying to open a file with a mode we can			 * create a new file, we can proceed.			 */			if (errno != ENOENT || !link_check_flg) {				*Lisp_errno = errno;				return(NIL);			}		}E 50	}D 11	if(fstat(id, &statbuf) == -1){E 11I 11D 50	TIMEOUT( rval=fstat(id, &statbuf) );	if(rval == -1){E 11		err_mess("fstat", errno);I 29#ifdef FSERRORE 50I 50	if (dskp && link_check_flg) {		/*		 * When we are opening a file with a mode we might create a new file,		 * we have to make sure that versionless file is maintaied		 * correctly before we actually creating a new file, because a		 * created new file will change the status and the recognition on		 * the same file with the same recognition mode will return the		 * different result.		 * At this point, the third argument for maintain_version, forcep is		 * 1, because a lonly versionless file should be linked to version 1.		 * If we are opening a file recognized with new mode, version 2,		 * without pre-linking a versionless to version 1, the final		 * clean up maintain_version will link the versionless to version 3.		 */		TIMEOUT(rval = access(file, F_OK));		if (rval == -1) {			if (errno == ENOENT) {				/*				 * Actually we are creating a new file.  We have to				 * maintain a version status.				 */				if (maintain_version(file, (FileName *)NULL, 1) == 0) {					TIMEOUT(rval = close(fd));					*Lisp_errno = errno;					return(NIL);				}			} else {				/*				 * Because of other reason, access call failed.				 */				*Lisp_errno = errno;				return(NIL);			}		} else {			/*			 * The subjective file has already existed.  We don't need			 * to maintain a version.			 */		}	}	/*	 * If a new file is created, its actual mode is computed from the	 * third argument for open and the process's umask.  I'm pretty sure	 * 0666 would be most appropriate mode to specify here.	 */	TIMEOUT(fd = open(file, flags, 0666));	if (fd == -1) {E 50D 40		*errp = errno;E 40I 40		*Lisp_errno = errno;E 40D 50#endifI 40		TIMEOUT( close(id) );E 50E 40E 29		return(NIL);	}I 17D 50	if(linkflag == 1)		if( makenewlink(pathname) == 0){I 41#ifdef	FSERROR			ERRSETJMP(NIL);#elseE 41I 39			SETJMP(NIL);I 41#endifE 41E 39			TIMEOUT( close(id) );E 50I 50	if (dskp && link_check_flg) {		/*		 * Again we have to maintain version to clean up the directory.		 * This time we invoke maintain_version with forcep off, because		 * the entirely newly created file, versionless file, should not		 * be linked to any file.		 */		if (maintain_version(file, (FileName *)NULL, 0) == 0) {			TIMEOUT(close(fd));			*Lisp_errno = errno;E 50			return(NIL);		}I 50	}	TIMEOUT(rval = fstat(fd, &sbuf));	if (rval == -1) {		TIMEOUT(close(fd));		*Lisp_errno = errno;		return(NIL);	}E 50E 17E 4	bufp = (int *)(Addr68k_from_LADDR(args[3]));D 5	*bufp = statbuf.st_mtime;E 5I 5D 7	if(args[2] == ACCESS_INPUT)		*bufp = 0;	else		*bufp = statbuf.st_mtime;E 7I 7D 50	*bufp = ToLispTime(statbuf.st_mtime);E 50I 50	*bufp = ToLispTime(sbuf.st_mtime);E 50E 7E 5	bufp = (int *)(Addr68k_from_LADDR(args[4]));I 5D 50	bufp = (int *)(Addr68k_from_LADDR(args[4]));E 5	*bufp = statbuf.st_size;	return(GetSmallp(id));E 50I 50	if (!dskp && ((sbuf.st_mode & S_IFMT) != S_IFREG) &&	    ((sbuf.st_mode & S_IFMT) != S_IFDIR)) {		/*		 * Not a regular file or directory file.  Put on a marker.		 */		*bufp = SPECIALFILEMARK;	} else {		*bufp = sbuf.st_size;	}	return(GetSmallp(fd));E 50}D 50DSK_closefile(args)D 25D 29LispPTR	*args;E 29I 29register LispPTR	*args;E 29E 25I 25D 30register LispPTR	*args;E 30E 25/* args[0]		pathname	*//* args[1]		id	*//* args[2]		cdate	*/I 29/* args[3]		errno */E 50I 50/*		 * Name:	COM_closefile * * Argument:	LispPTR	*args	args[0] *				 Full file name which is following the Xerox *				 Lisp file naming convention.  Including a host *				 field. *				args[1] *				 The Lisp integer representing a file descriptor *				 of the file being closed. *				args[2] *				 The creation date of the file. *				args[3] *				 The place where the error number should be *				 stored. * * Value:	If succeed, returns the Lisp T otherwise, Lisp NIL. * * Side Effect:	None. * * Description: * * The implementation of CLOSEFILE FDEV method for DSK and UNIX device.  Try to * close a specified file. * The creation date file attribute in Lisp sense is kept in st_mdate field of * UNIX structure.  To keep the creation date of the file, it is maintained by * Lisp and it is passed to COM_closefile. */COM_closefile(args)	register LispPTR	*args;E 50E 29{D 25D 29int	id;	/* FileID */int	date;	/* Creatoin Date */char	pathname[MAXPATHLEN];char	*base;int	length;E 29I 29D 50register int	id;	/* FileID */register int	date;	/* Creatoin Date */register int	rval;E 29E 25I 25D 30register int	id;	/* FileID */register int	date;	/* Creatoin Date */register int	rval;E 30E 25D 32D 33struct timeval time[2];E 33I 33static struct timeval time[2];E 33E 32I 32D 34static struct timeval time[2];E 34E 32struct stat	statbuf;I 11D 25D 29int	rval;E 29I 29char	pathname[MAXPATHLEN];#ifdef	FSERRORD 40int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));	E 40I 40	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	E 40#endifE 29E 25I 25D 30char	pathname[MAXPATHLEN];E 30E 25I 19D 28	SETJMP(0);E 28E 19E 11D 46	LispStringToCString(args[0], pathname);E 46I 46	LispStringToCString(args[0], pathname, MAXPATHLEN);E 46I 16	RemoveDodNoExtenstion(pathname);I 17	if(checklink_and_changeversion(pathname) == 0)		return(NIL);E 17E 16	LispVersionToUnixVersion(pathname);	id = LispNumToCInt(args[1]);	date = LispNumToCInt(args[2]);I 29#ifdef	FSERRORE 50I 50	register int		fd, dskp, rval;	time_t			cdate;D 57	char			lfname[MAXPATHLEN], host[MAXNAMLEN];E 57I 57	char			lfname[MAXPATHLEN + 5], host[MAXNAMLEN];E 57	char			file[MAXPATHLEN], dir[MAXPATHLEN], name[MAXNAMLEN + 1];	char			ver[VERSIONLEN];	register DIR		*dirp;	register struct direct	*dp;	struct stat	        sbuf;	struct timeval		time[2];	ino_t			ino;E 50D 40	ERRSETJMP(NIL, errp);E 40I 40	ERRSETJMP(NIL);E 40D 50#else	SETJMP(NIL);#endifE 29I 28D 30	SETJMP(0);E 30E 28I 5	if(date == 0){ /* just close */D 11		if( close(id) == -1){E 11I 11		TIMEOUT( rval=close(id) );		if( rval == -1){E 11			err_mess("close", errno);I 29#ifdef FSERRORE 50I 50	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));I 57	LispStringLength(args[0], rval, dskp);	/*	 * Because of the version number convention, Lisp pathname might	 * be shorter than UNIX one.  For THIN string, the difference	 * is 2 bytes, for FAT string, 4 bytes.  Add 1 byte for NULL	 * terminating character.	 */	rval = dskp ? rval + 4 + 1 : rval + 2 + 1;	/* Add five for the host name field in Lisp format. */	if (rval > MAXPATHLEN + 5) FileNameTooLong(NIL);E 57	LispStringToCString(args[0], lfname, MAXPATHLEN);		separate_host(lfname, host);	UPCASE(host);	if (strcmp(host, "DSK") == 0)	  dskp = 1;	else if (strcmp(host, "UNIX") == 0)	  dskp = 0;	else	  return(NIL);	/*	 * Convert a Lisp file name to UNIX one.  If host is DSK, we also have to	 * convert a version field.	 */	dskp ? unixpathname(lfname, file, 1, 0) : unixpathname(lfname, file, 0, 0);	fd = LispNumToCInt(args[1]);	cdate = (time_t)LispNumToCInt(args[2]);	if (!dskp) {		TIMEOUT(rval = fstat(fd, &sbuf));		if (rval == -1) {E 50D 40			*errp = errno;E 40I 40			*Lisp_errno = errno;E 40D 50#endifE 50E 29			return(NIL);		}D 50		return(ATOM_T);E 50	}D 11	/* set Creation date and close */		E 5D 4	if(fstat(id, &statbuf) != 0)E 4I 4	if(fstat(id, &statbuf) != 0){E 11I 11D 50	/* set Creation date and close */	TIMEOUT( rval=fstat(id, &statbuf) );		if(rval != 0){E 11		err_mess("fstat", errno);I 29#ifdef FSERRORD 40		*errp = errno;E 40I 40		*Lisp_errno = errno;E 40#endifE 29E 4		return(NIL);E 50I 50			if (cdate == 0) {		/* Just close. */		TIMEOUT(rval = close(fd));		if (rval == -1) {			if (!dskp && errno == EPERM && (sbuf.st_mode & S_IFREG) == 0) {				/*				 * On {UNIX} device, closing a special file we are not				 * the owner of it.  Although I don't think close fails				 * because of EPERM, in honor of Medley 1.1 code, I put				 * this segment here.				 */				return(ATOM_T);			} else {				*Lisp_errno = errno;				return(NIL);			}		} else {			return(ATOM_T);		}E 50I 4	}E 4D 50	time[0].tv_sec = statbuf.st_atime;D 7	time[1].tv_sec = date;E 7I 7	time[1].tv_sec = ToUnixTime(date);E 7D 4	if( close(id) == -1)E 4I 4D 11	if( close(id) == -1){E 11I 11	TIMEOUT( rval=close(id) );	if( rval == -1){E 11		err_mess("close", errno);I 29#ifdef FSERRORE 50I 50	if (!unpack_filename(file, dir, name, ver, 1)) return(NIL);	if (dskp) {		/*		 * On {DSK}, we have to make sure dir is case sensitively exisiting		 * directory.		 */		if (true_name(dir) != -1) return(NIL);		/*		 * There is a very troublesom problem here.  The file name Lisp		 * recognizes is not always the same as the name which COM_openfile		 * used to open the file.  Sometimes COM_openfile uses the versionless		 * file name to open a file, although Lisp always recognizes with		 * *versioned* file name.		 * Thus, we compare i-node number of the requested file with ones of all		 * of files on the directory.   This is time spending implementation.		 * More clean up work is needed.		 */		TIMEOUT(rval = fstat(fd, &sbuf));		if (rval != 0) {			*Lisp_errno = errno;			return(NIL);		}		ino = sbuf.st_ino;		TIMEOUT(dirp = opendir(dir));		if (dirp == (DIR *)NULL) {			*Lisp_errno = errno;			return(NIL);		}		for (S_TOUT(dp = readdir(dirp)); dp != (struct direct*)NULL;		     S_TOUT(dp = readdir(dirp))) {			if (ino == (ino_t)dp->d_fileno) {				sprintf(file, "%s/%s", dir, dp->d_name);			}		}		TIMEOUT(closedir(dirp));	}	time[0].tv_sec = (long)sbuf.st_atime;	time[0].tv_usec = 0L;	time[1].tv_sec = (long)ToUnixTime(cdate);	time[1].tv_usec = 0L;	TIMEOUT(rval = close(fd));	if (rval == -1) {E 50D 40		*errp = errno;E 40I 40		*Lisp_errno = errno;E 40D 50#endifE 50E 29E 4		return(NIL);D 4	if(utimes(pathname, time) != 0)E 4I 4	}D 11	if(utimes(pathname, time) != 0){E 11I 11D 50	TIMEOUT( rval=utimes(pathname, time) );	if(rval != 0){E 11		err_mess("utimes", errno);I 9D 24D 29		printf("	FileName is %s\n", pathname);E 29I 29#ifdef FSERRORE 50I 50I 58D 60#ifdef HPUXE 60I 60D 64#if (defined(HPUX) || defined(RISCOS))E 64I 64#if (defined(HPUX) || defined(SYSVONLY))E 64E 60	TIMEOUT(rval = utime(file, time));#elseE 58	TIMEOUT(rval = utimes(file, time));I 58#endifE 58	if (rval != 0) {E 50D 40		*errp = errno;E 40I 40		*Lisp_errno = errno;E 40D 50#endifE 50E 29E 24E 9E 4		return(NIL);I 4	}I 50E 50E 4	return(ATOM_T);I 50E 50}I 50/*		 * Name:	DSK_getfilename * * Argument:	LispPTR	*args	args[0] *				 Full file name in Lisp format. *				args[1] *				 Rcoginition mode.  See IRM. *				args[2] *				 Name area where the recognized full file name *				 will be stored. *				args[3] *				 The place where the error number should be *				 stored. * * Value:	If succeed, returns the Lisp smallp which represents the length *		of the recognized full file name, otherwise Lisp NIL. * * Side Effect:	If succeed, name area (args[2]) will be replaced with the  *		recognized full file name. * * Description: * * The implementation of GETFILENAME FDEV method for DSK device.  Performs the * recognition on the specified name.  Does not check if OPENFILE actually * can open the file with the specified mode or not. */E 50DSK_getfilename(args)D 25D 29LispPTR	*args;E 29I 29D 50register LispPTR	*args;E 29E 25I 25D 30register LispPTR	*args;E 30E 25/* args[0]		pathname	*//* args[1]		rec	*//* args[2]		buffer	*/I 29/* args[3]		errno	*/E 50I 50	register LispPTR	*args;E 50E 29{D 25D 29int	length;E 29I 29D 50register int	length;register int	version_no;register char	*base;register LispPTR	*naddress;E 29E 25I 25D 30register int	length;register int	version_no;register char	*base;register LispPTR	*naddress;E 30E 25char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];char	path[MAXPATHLEN];char	name[MAXPATHLEN];char	version[VERSIONLEN];D 25D 29int	version_no;char	*base;LispPTR	*naddress;E 29I 29#ifdef	FSERRORD 40int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));	E 40I 40	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	E 40#endifE 29E 25D 46	LispStringToCString(args[0], pathname);E 46I 46	LispStringToCString(args[0], pathname, MAXPATHLEN);E 46I 29D 40#ifdef	FSERROR	if( makepathname(pathname, fullpathname, errp) == 0){D 38		*errp = errno;E 38		return(NIL);	}#elseE 40E 29	if( makepathname(pathname, fullpathname) == 0)		return(NIL);I 29D 40#endifE 40E 29	if(parse(fullpathname, path, name, version) == 0)		return(NIL);D 9	version_no = atoi(version);E 9I 9	if(*version == '\0')		version_no = MAXVERSION;	else		version_no = atoi(version);E 9	switch(args[1]){	case RECOG_OLD:		if(confirmpath(path) == 0)E 50I 50	register char	*base;	register int	len, dirp, rval;	char		lfname[MAXPATHLEN];	char		aname[MAXNAMLEN];	char		vname[MAXPATHLEN];	char		file[MAXPATHLEN];	char		dir[MAXPATHLEN];	char		name[MAXNAMLEN];	char		ver[VERSIONLEN];	  	ERRSETJMP(NIL);	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));I 57	LispStringLength(args[0], len, dirp);	/*	 * Because of the version number convention, Lisp pathname might	 * be shorter than UNIX one.  For THIN string, the difference	 * is 2 bytes, for FAT string, 4 bytes.  Add 1 byte for NULL	 * terminating character.	 */	len = dirp ? len + 4 + 1 : len + 2 + 1;	if (len > MAXPATHLEN) FileNameTooLong(NIL);E 57	LispStringToCString(args[0], lfname, MAXPATHLEN);		/*	 * Convert a Lisp file name to UNIX one.  This is a DSK device method.	 * Thus we have to convert a version field too.  Third argument for	 * unixpathname specifies it.	 */	if (unixpathname(lfname, file, 1, 0) == 0) return(NIL);	if (unpack_filename(file, dir, name, ver, 1) == 0) return(NIL);	switch (args[1]) {	      case RECOG_OLD:		/*		 * "Old" file means the "newest existing" file.  Thus, we have to		 * check dir is an existing directory or not.  The serach have to		 * be done in case insensitive manner.  true_name does this work.		 */		if (true_name(dir) != -1) {			/* No such directory. */E 50			return(NIL);D 13		if(getoldfile(path, name+1, version_no) == 0)E 13I 13D 50		if(getoldfile(path, name+1, version_no, version) == 0)E 13			return(NIL);E 50I 50		}		/*		 * At this point, trut_name has converted dir to the "true" name		 * of the directory.		 */		if (strcmp(name, "") == 0) {			/*			 * The file name is specified with a trail directory delimitor.			 * We should recognize it as a directory.			 */			strcpy(aname, dir);			strcpy(vname, dir);			dirp = 1;		} else {			/*			 * Recognizing a file on DSK device needs the version information.			 * We gather version information in a version array first.			 */			if (get_version_array(dir, name, VersionArray, &VArrayInfo) == 0)			  return(NIL);			ConcNameAndVersion(name, ver, aname);			if (get_old(dir, VersionArray, aname, vname) == 0) return(NIL);			if ((rval = true_name(aname)) == 0) return(NIL);			if (rval == -1) {				/*				 * The specified file is a directory file.				 */				strcpy(vname, aname);				dirp = 1;			} else {				dirp = 0;			}		}E 50		break;D 50	case RECOG_OLDEST:		if(confirmpath(path) == 0)E 50I 50	      case RECOG_OLDEST:		/*		 * "Oldest" file means the "oldest existing" file.  Thus, we have to		 * check dir is an existing directory or not.		 */		if (true_name(dir) != -1) {			/* No such directory. */E 50			return(NIL);D 9		if(version_no == 0){E 9I 9D 50		if(version_no == MAXVERSION){E 9			if(getoldestfile(path, name+1) == 0)				return(NIL);		}else{D 13			if(getoldfile(path, name+1, version_no) == 0)E 13I 13			if(getoldfile(path, name+1, version_no, version) == 0)E 13				return(NIL);E 50		}I 50		if (strcmp(name, "") == 0) {			/*			 * The file name is specified with a trail directory delimitor.			 * We should recognize it as a directory.			 */			strcpy(aname, dir);			strcpy(vname, dir);			dirp = 1;		} else {			if (get_version_array(dir, name, VersionArray, &VArrayInfo) == 0)			  return(NIL);			ConcNameAndVersion(name, ver, aname);			if (get_oldest(dir, VersionArray, aname, vname) == 0) return(NIL);			if ((rval = true_name(aname)) == 0) return(NIL);			if (rval == -1) {				/*				 * The specified file is a directory file.				 */				strcpy(vname, aname);				dirp = 1;			} else {				dirp = 0;			}		}E 50		break;D 50	case RECOG_NEW_OLD:		if(confirmpath(path) != 0)D 13			if(getoldfile(path, name+1, version_no) != 0)E 13I 13			if(getoldfile(path, name+1, version_no, version) != 0)E 13				break;		if(createpath(path) == 0)			return(NIL);D 9		if(version_no == 0){E 9I 9		if(version_no == MAXVERSION){E 9			if(getnewfile(path, name+1) == 0)				return(NIL);		}else{			strcat(name, ";");			strcat(name, version);E 50I 50	      case RECOG_NEW:		/*		 * "New" file means the "not existing" file.  Thus it is not		 * necessary that dir is an existing directory.  If dir is not		 * an exisiting directory, we returns the specified file name		 * as if, the subsequent OPENFILE will find the truth.		 */		if (true_name(dir) != -1) {			strcpy(vname, file);			dirp = 0;		} else if (strcmp(name, "") == 0) {			/*			 * The file name is specified with a trail directory delimitor.			 * We should recognize it as a directory.			 */			strcpy(aname, dir);			strcpy(vname, dir);			dirp = 1;		} else {			ConcDirAndName(dir, name, aname);			if ((rval = true_name(aname)) == -1) {				strcpy(vname, aname);				dirp = 1;			} else {				/*				 * Here, dir is an existing directory.  We have to perform				 * "new" recognition with the version information.				 */				if (get_version_array(dir, name, VersionArray,						      &VArrayInfo) == 0)				  return(NIL);				ConcNameAndVersion(name, ver, aname);				if (get_new(dir, VersionArray, aname, vname) == 0)				  return(NIL);				dirp = 0;			}E 50		}		break;D 50	case RECOG_NEW:		if(createpath(path) == 0)			return(NIL);D 9		if(version_no == 0){E 9I 9		if(version_no == MAXVERSION){E 9			if(getnewfile(path, name+1) == 0)				return(NIL);		}else{			strcat(name, ";");			strcat(name, version);E 50I 50	      case RECOG_OLD_NEW:		/*		 * "Old/new" file means the "newest existing" or "not existing" file.		 * Thus, if dir is not an existing directory, we can return the		 * specified file name.  If it is an existing one, we have to		 * try "old" recognition on the directory first.  If the recognition		 * fails, we try "new" recognition.		 */		if (true_name(dir) != -1) {			strcpy(vname, file);			dirp = 0;		} else {			ConcDirAndName(dir, name, aname);			if ((rval = true_name(aname)) == -1) {				strcpy(vname, aname);				dirp = 1;			} else {				if (get_version_array(dir, name, VersionArray,						      &VArrayInfo) == 0)				  return(NIL);				ConcNameAndVersion(name, ver, aname);				if (get_old_new(dir, VersionArray, aname, vname) == 0)				  return(NIL);				dirp = 0;			}E 50		}		break;I 3D 50	case RECOG_NON:		if(confirmpath(path) == 0)			return(NIL);		naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));D 44		base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));E 44I 44		base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));E 44		length = strlen(fullpathname);E 50I 50	      case RECOG_NON:		/*		 * "Non" recognition is used to recognize a sysout file.  The sysout		 * file is dealt with specially, it does not have any version, even		 * if it is on {DSK} device.  Only we have to do here is to make		 * sure the path to reach to the specified file is an existing		 * directories.  The file name itself is recognized as if.		 */		if (true_name(dir) != -1) return(NIL);		ConcDirAndName(dir, name, vname);		strcpy(aname, vname);		if (true_name(aname) == -1) {			strcpy(vname, aname);			dirp = 1;		} else {			dirp = 0;		}		if (lisppathname(vname, lfname, dirp, 0) == 0) return(NIL);		STRING_BASE(args[2], base);		len = strlen(lfname);E 50I 49#ifndef BYTESWAPE 49D 50		strncpy(base, fullpathname, length);E 50I 50		strncpy(base, lfname, len + 1);E 50I 49#elseD 50		StrNCpyFromCToLisp(base, fullpathname ,length);E 50I 50		StrNCpyFromCToLisp(base, lfname, len + 1);E 50D 72#endif BYTESWAPE 72I 72#endif /* BYTESWAP */E 72E 49D 50		return(GetSmallp(length));	E 3	default:		return(NIL);E 50I 50		return(GetSmallp(len));E 50	}I 52E 52D 50	strcat(path, name);	/*** CStringToLispString ***/	naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));D 44	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));E 44I 44	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));E 44	length = strlen(path);E 50I 50	/*I 52	 * DSK device does not recognize a directory file as a file.  Thus we should	 * return NIL when the recognized file is a directory.	 */	if (dirp) return(NIL);	/*E 52	 * Now, vname holds the "versioned" full name of the recognized file in UNIX	 * format.  We have to convert it back to Lisp format.  The version field	 * have to be converted.  The fourth argument for lisppathname specifies it.	 */	if (lisppathname(vname, lfname, dirp, (dirp ? 0 : 1)) == 0) return(NIL);	STRING_BASE(args[2], base);	len = strlen(lfname);E 50I 49#ifndef BYTESWAPE 49D 50	strncpy(base, path, length);E 50I 50	strncpy(base, lfname, len + 1);E 50I 49#elseD 50	StrNCpyFromCToLisp(base, path, length);E 50I 50	StrNCpyFromCToLisp(base, lfname, len + 1);E 50D 72#endif BYTESWAPE 72I 72#endif /* BYTESWAP */E 72E 49D 50	return(GetSmallp(length));E 50I 50I 72E 72	return(GetSmallp(len));E 50}I 63E 63I 50/*		 * Name:	DSK_deletefile * * Argument:	LispPTR	*args	args[0] *				 Full file name in Lisp format. *				args[1] *				 The place where the error number should be *				 stored. * * Value:	If succeed, returns the Lisp symbol T, otherwise Lisp NIL. * * Side Effect:	If succeed, the specified file is unlinked. * * Description: * * The implementation of DELETEFILE FDEV method for DSK device.  Try to delete * a specified file. */E 50DSK_deletefile(args)D 39LispPTR	*args;E 39I 39D 50register LispPTR	*args;E 39/*	args[0]:	Indirect pointer to buffer	*/I 40/*	args[1]:	pointer to errno	*/E 50I 50	register LispPTR	*args;E 50E 40{D 50char	pathname[MAXPATHLEN];I 40#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));	#endifE 40I 11D 25D 29int	rval;E 29E 25E 11D 46	LispStringToCString(args[0], pathname);E 46I 46	LispStringToCString(args[0], pathname, MAXPATHLEN);E 46I 16	RemoveDodNoExtenstion(pathname);I 17	if(checklink_and_changeversion(pathname) == 0)		return(NIL);E 17E 16	LispVersionToUnixVersion(pathname);D 4	if(unlink(pathname) == -1)E 4I 4D 11	if(unlink(pathname) == -1){E 11I 11D 17	TIMEOUT(rval=unlink(pathname));	if(rval == -1){E 11		err_mess("unlink", errno);E 17I 17	if(changelink_and_delete(pathname) == 0)E 17E 4		return(NIL);I 4D 17	}E 17E 4	return(ATOM_T);E 50I 50	char			file[MAXPATHLEN], fbuf[MAXPATHLEN], vless[MAXPATHLEN];	char			dir[MAXPATHLEN], ver[VERSIONLEN];D 57	int		rval;E 57I 57	int			rval, fatp;E 57	register FileName	*varray;		ERRSETJMP(NIL);	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));I 57	LispStringLength(args[0], rval, fatp);	/*	 * Because of the version number convention, Lisp pathname might	 * be shorter than UNIX one.  For THIN string, the difference	 * is 2 bytes, for FAT string, 4 bytes.  Add 1 byte for NULL	 * terminating character.	 */	rval = fatp ? rval + 4 + 1 : rval + 2 + 1;	if (rval > MAXPATHLEN) FileNameTooLong(NIL);E 57	LispStringToCString(args[0], fbuf, MAXPATHLEN);		unixpathname(fbuf, file, 1, 0);	if (unpack_filename(file, dir, fbuf, ver, 1) == 0) return(NIL);	if (get_version_array(dir, fbuf, VersionArray, &VArrayInfo) == 0) return(NIL);	varray = VersionArray;		if (NoFileP(varray)) return(NIL); /*					   * If the specified file is deleted from					   * outside of Lisp during the last time					   * Lisp recognize it and now, this case					   * will occure.					   */	/*	 * Although the file should have been recognized with "oldest" mode in Lisp	 * code, we have to recognize it again to know the "real" accessible name	 * of it.	 */	ConcNameAndVersion(fbuf, ver, file);	if (get_oldest(dir, varray, file, fbuf) == 0) return(NIL);	if (get_versionless(varray, vless, dir) == 0) {		/*		 * There is no versionless file.  All we have to do is to simply		 * try to unlink the specified file.		 */		TIMEOUT(rval = unlink(file));		if (rval == -1) {			*Lisp_errno = errno;			return(NIL);		}		return(ATOM_T);	}	/*	 * If a versionless file exists, we have to check the link status of it,	 * because deleting a versionless file or a file to which a versionless	 * file is linked will destroy the concistency of the version status.	 */	if (check_vless_link(vless, varray, fbuf, &rval) == 0) return(NIL);	if (strcmp(file, vless) == 0 || strcmp(file, fbuf) == 0) {		if (*fbuf != '\0') {			/*			 * Both of the versionless file and the file to which the			 * versionless file is linked have to be unlinked.			 */			TIMEOUT(rval = unlink(vless));			if (rval == -1) {				*Lisp_errno = errno;				return(NIL);			}			TIMEOUT(rval = unlink(fbuf));			if (rval == -1) {				*Lisp_errno = errno;				return(NIL);			}			/*			 * Finally, we have to maintain the version status.			 */			if (maintain_version(vless, (FileName *)NULL, 0) == 0)			  return(NIL);			return(ATOM_T);		} else {			/*			 * Although the versionfile is specified, it is not linked			 * to any file in varray.  We should not maintain the version			 * status after deleting the versionless file, because			 * we cannot say wheter the versionless file is actually under			 * control of the Medley DSK file system or not.			 */			TIMEOUT(rval = unlink(vless));			if (rval == -1) {				*Lisp_errno = errno;				return(NIL);			}			return(ATOM_T);		  }	} else {		/*		 * Just unlink the specified file.		 */		TIMEOUT(rval = unlink(file));		if (rval == -1) {			*Lisp_errno = errno;			return(NIL);		}		return(ATOM_T);	}E 50}I 63E 63I 50/*		 * Name:	DSK_renamefile * * Argument:	LispPTR	*args	args[0] *				 Full file name in Lisp format.  The file which *				 is being renamed. *				args[1] *				 Full file name in Lisp format.  The file to which *				 args[0] is being renamed. *				args[2] *				 The place where the error number should be *				 stored. * * Value:	If succeed, returns the Lisp symbol T, otherwise Lisp NIL. * * Side Effect:	If succeed, the specified file is unlinked. * * Description: * * The implementation of RENAMEFILE FDEV method for DSK device.  Try to rename * a specified file. */E 50DSK_renamefile(args)D 25D 29LispPTR	*args;E 29I 29D 50register LispPTR	*args;E 29E 25I 25D 30register LispPTR	*args;E 30E 25/*	args[0]:	Indirect pointer to buffer (old file name)	*//*	args[1]:	Indirect pointer to buffer (new file name)	*/I 40/*	args[2]:	pointer to errno	*/E 50I 50	register LispPTR	*args;E 50E 40{D 50char	old_pathname[MAXPATHLEN], new_pathname[MAXPATHLEN];I 33#ifdef	FSERRORD 40int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[2]));	E 40I 40	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));	E 40#endifE 33I 32D 34#ifdef	FSERRORint	*errp;	errp = (int *)(Addr68k_from_LADDR(args[2]));	#endifE 34E 32I 11D 25D 29int	rval;E 29E 25E 11D 46	LispStringToCString(args[0], old_pathname);E 46I 46	LispStringToCString(args[0], old_pathname, MAXPATHLEN);E 46I 16	RemoveDodNoExtenstion(old_pathname);I 17	if(checklink_and_changeversion(old_pathname) == 0)E 50I 50	char			src[MAXPATHLEN], dst[MAXPATHLEN];	char			fbuf[MAXPATHLEN], vless[MAXPATHLEN], svless[MAXPATHLEN];	char			dir[MAXPATHLEN], ver[VERSIONLEN];D 57	int			rval;E 57I 57	int			rval, fatp;E 57	register int		need_maintain_flg;	register FileName	*varray;		ERRSETJMP(NIL);	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));	I 57	LispStringLength(args[0], rval, fatp);	/*	 * Because of the version number convention, Lisp pathname might	 * be shorter than UNIX one.  For THIN string, the difference	 * is 2 bytes, for FAT string, 4 bytes.  Add 1 byte for NULL	 * terminating character.	 */	rval = fatp ? rval + 4 + 1 : rval + 2 + 1;	if (rval > MAXPATHLEN) FileNameTooLong(NIL);	LispStringLength(args[1], rval, fatp);	rval = fatp ? rval + 4 + 1 : rval + 2 + 1;	if (rval > MAXPATHLEN) FileNameTooLong(NIL);E 57	LispStringToCString(args[0], fbuf, MAXPATHLEN);	unixpathname(fbuf, src, 1, 0);	LispStringToCString(args[1], fbuf, MAXPATHLEN);	unixpathname(fbuf, dst, 1, 0);	if (unpack_filename(dst, dir, fbuf, ver, 1) == 0) return(NIL);	/*	 * The destination file has been recognized as new file.  Thus we have	 * to make sure that the directory exisits.	 */	if (make_directory(dir) == 0) return(NIL);	/*	 * We maintain the destination to handle the link damaged case correctly.	 */	ConcDirAndName(dir, fbuf, dst);	if (maintain_version(dst, (FileName *)NULL, 0) == 0) return(NIL);	if (get_version_array(dir, fbuf, VersionArray, &VArrayInfo) == 0) return(NIL);	varray = VersionArray;		/*	 * Although the file should have been recognized with "new" mode in Lisp	 * code, we have to recognize it again to know the "real" accessible name	 * of it.	 */	ConcNameAndVersion(fbuf, ver, dst);	if (get_new(dir, varray, dst, fbuf) == 0) return(NIL);	/*	 * At this point, there are three cases for the destination.  If there is	 * no member of the destination family, there is nothing to do.  If there	 * is only a versionless file and, if the "real" destination is not the	 * versionless, we have to rename it to version 1.  And last case, if the	 * "real" destination file is the file to which the versinless file is linked,	 * we have to unlink the versionless file.	 */	if (!NoFileP(varray)) {		if (OnlyVersionlessP(varray)) {			get_versionless(varray, vless, dir);			if (strcmp(dst, vless) != 0) {				ConcNameAndVersion(vless, "1", fbuf);				TIMEOUT(rval = rename(vless, fbuf));				if (rval == -1) {					*Lisp_errno = errno;					return(NIL);				}			}		} else {			/*			 * We are sure that the versionless file is linked to one of			 * the higher versioned file here.			 */			get_versionless(varray, vless, dir);			if (check_vless_link(vless, varray, fbuf, &rval) == 0) {				return(NIL);			}			if (strcmp(dst, fbuf) == 0) {				TIMEOUT(rval = unlink(vless));				if (rval == -1) {					*Lisp_errno = errno;					return(NIL);				}			}		}	}	if (unpack_filename(src, dir, fbuf, ver, 1) == 0) return(NIL);	if (get_version_array(dir, fbuf, varray, &VArrayInfo) == 0) return(NIL);		if (NoFileP(varray)) return(NIL); /*					   * If the specified file is deleted from					   * outside of Lisp during the last time					   * Lisp recognize it and now, this case					   * will occure.					   */	/*	 * Although the file should have been recognized with "old" mode in Lisp	 * code, we have to recognize it again to know the "real" accessible name	 * of it.	 */	ConcNameAndVersion(fbuf, ver, src);	if (get_old(dir, varray, src, fbuf) == 0) return(NIL);	if (get_versionless(varray, vless, dir) == 0) {		/*		 * There is no versionless file.  All we have to do is to simply		 * try to rename the specified file.		 */		need_maintain_flg = 0;	} else {		/*		 * If a versionless file exists, we have to check the link status		 * of it, because renaming a versionless file or a file to which a		 * versionless file is linked will destroy the concistency of the		 * version status.		 */		if (check_vless_link(vless, varray, fbuf, &rval) == 0) return(NIL);		if (strcmp(src, vless) == 0 && *fbuf != '\0') {			/*			 * At this point, we only unlink the file to which the			 * versionless is linked.  The versionless fill will be			 * renamed later.			 */			TIMEOUT(rval = unlink(fbuf));			if (rval == -1) {				*Lisp_errno = errno;				return(NIL);			}			need_maintain_flg = 1;		} else if (strcmp(src, fbuf) == 0) {			TIMEOUT(rval = unlink(vless));			if (rval == -1) {				*Lisp_errno = errno;				return(NIL);			}			need_maintain_flg = 1;		} else {			need_maintain_flg = 0;		}		strcpy(svless, vless);	}	/*	 * At this point, src holds the full file name to be renamed, and dst holds	 * the full file name to which src will be renamed.	 */	TIMEOUT(rval = rename(src, dst));	if (rval == -1) {		*Lisp_errno = errno;E 50		return(NIL);E 17E 16D 50	LispVersionToUnixVersion(old_pathname);D 46	LispStringToCString(args[1], new_pathname);E 46I 46	LispStringToCString(args[1], new_pathname, MAXPATHLEN);E 46I 16	RemoveDodNoExtenstion(new_pathname);I 17	if(checklink_and_changeversion(new_pathname) == 0)		return(NIL);E 17E 16	LispVersionToUnixVersion(new_pathname);I 33D 40#ifdef	FSERROR	if(changelink_and_rename(old_pathname, new_pathname, errp) == 0)#elseE 40I 34	if(changelink_and_rename(old_pathname, new_pathname) == 0)E 34E 33D 4	if(rename(old_pathname, new_pathname) == -1)E 4I 4D 11	if(rename(old_pathname, new_pathname) == -1){E 11I 11D 17	TIMEOUT(rval=rename(old_pathname, new_pathname));	if(rval == -1){E 11		err_mess("rename", errno);E 17I 17D 32	if(changelink_and_rename(old_pathname, new_pathname) == 0)I 33D 40#endifE 40E 33E 32I 32D 34	if(changelink_and_rename(old_pathname, new_pathname, errp) == 0)E 34E 32E 17E 4		return(NIL);I 4D 17	}E 17I 17	if(makenewlink(new_pathname) == 0)		return(NIL);E 50I 50	}	/*	 * The destination directory always have to be maintained, because it is	 * now under control of DSK device.	 * The source directory have to be maintained only if need_maintain_flg	 * is on.	 */	if (maintain_version(dst, (FileName *)NULL, 0) == 0) return(NIL);	if (need_maintain_flg) {		if (maintain_version(src, (FileName *)NULL, 0) == 0) return(NIL);	}E 50E 17E 4	return(ATOM_T);}I 63E 63I 50/* * Name:	DSK_directorynamep * * Argument:	LispPTR	*args	args[0] *				 Directory name in Lispformat.  Both of the initial *				 and trail directory delimiter are stripped by Lisp *				 code.  Only one exception is a "root directory". *				 "Root directory is represented as ">". *				args[1] *				 The place where the "true" name of the directory *				 in Lisp format will be stored. *				args[2] *				 The place where the error number should be stored. *				 Not used in the current Lisp code implementation. * * Value:	If succeed, returns the Lisp smallp which represents the length *		of the "true" name of the directory, otherwise Lisp NIL. * * Side Effect:	If the directory is recognized as a valid directory representation, *		args[1] is replaced with the "true" directory name. * * Description: * * The implementation of the DIRECTORYNAMEP FDEV method for DSK device. * Performs the recoginition as well. Accepts the directory representation which * obeys the Xerox Lisp file naming convention. The "true" name which is stored * on the area specified with the second argument also follows the Xerox Lisp * file naming convention, and it includes the initial and trail directory * delimiter. Thus the Lisp code does not have to worry about the conversion of * the directory name representation. */E 50I 48D 50E 50E 48DSK_directorynamep(args)D 39LispPTR	*args;E 39I 39D 50register LispPTR	*args;E 39/*	args[0]:	IndirectPonter to Directory Name */I 29D 39/*	args[1]:	errno */E 39I 39/*	args[1]:	errno */ /** [hh:11/15] It is not passed from LISP **/I 43			/** [hh:12/06] It is passed from new lisp code **/E 50I 50 	register LispPTR	*args;E 50E 43E 39E 29{I 29D 50struct	stat	sbuf;	/* Strucure for FileInfo. */E 29I 25D 30struct	stat	sbuf;	/* Strucure for FileInfo. */E 30E 25char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];D 25D 29struct	stat	sbuf;	/* Strucure for FileInfo. */E 29I 29#ifdef	FSERRORD 40int	*errp;D 39	errp = (int *)(Addr68k_from_LADDR(args[1]));	E 39I 39/**	errp = (int *)(Addr68k_from_LADDR(args[1]));	**/E 40I 40D 42/**	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));	**/	Lisp_errno = &Dummy_errno;E 42I 42	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));/**	Lisp_errno = &Dummy_errno; **/E 42E 40E 39#endifE 29E 25D 46	LispStringToCString(args[0], pathname);E 46I 46	LispStringToCString(args[0], pathname, MAXPATHLEN);I 48	DBPRINT(("Checking path name:  %s\n", pathname));E 48E 46I 29D 40#ifdef	FSERROR	if( makepathname(pathname, fullpathname, errp) == 0){D 38		*errp = errno;E 38		return(NIL);	}#elseE 40E 29	if( makepathname(pathname, fullpathname) == 0)		return(NIL);I 48	DBPRINT(("And full path:  %s\n", fullpathname));E 48I 29D 40#endifE 40E 29	if(confirmpath(fullpathname) == 0)		return(NIL);	return(ATOM_T);E 50I 50	char		dirname[MAXPATHLEN];	char		fullname[MAXPATHLEN];D 57	register int	len;E 57I 57	register int	len, fatp;E 57	register char	*base;	ERRSETJMP(NIL);	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));I 57	LispStringLength(args[0], len, fatp);	/*	 * Because of the version number convention, Lisp pathname might	 * be shorter than UNIX one.  For THIN string, the difference	 * is 2 bytes, for FAT string, 4 bytes.  Add 1 byte for NULL	 * terminating character.	 */	len = fatp ? len + 4 + 1 : len + 2 + 1;	/* -2 for the initial and trail directory delimitor. */	if (len > MAXPATHLEN - 2) FileNameTooLong(NIL);E 57	LispStringToCString(args[0], dirname, MAXPATHLEN);	/* Convert Xerox Lisp file naming convention to Unix one. */	if (unixpathname(dirname, fullname, 1, 0) == 0) return(NIL); 	if (true_name(fullname) != -1) return(NIL); 	/* Convert Unix file naming convention to Xerox Lisp one. */	if (lisppathname(fullname, dirname, 1, 0) == 0) return(NIL); 	len = strlen(dirname);	STRING_BASE(args[1], base); #ifndef	BYTESWAP	strncpy(base, dirname, len + 1);#else	StrNCpyFromCToLisp(base, dirname, len + 1);D 72#endif	BYTESWAPE 72I 72#endif /* BYTESWAP */E 72 	return(GetSmallp(len));E 50}I 63E 63D 50DSK_getfileinfo(args)D 25D 29LispPTR	*args;E 29I 29register LispPTR	*args;E 29E 25I 25D 30register LispPTR	*args;E 30E 25/*	args[0]:	IndirectPonter to File Name *//*	args[1]:	IndirectPonter to Attribute *//*	args[2]:	IndirectPonter to BUffer */I 29/* args[3]		buf for errno */E 50I 50/*		 * Name:	COM_getfileinfo * * Argument:	LispPTR	*args	args[0] *				 Full file name which is following the Xerox *				 Lisp file naming convention.  Including a host *				 field. *				args[1] *				 The Lisp pointer which represents the requested *				 file attribute. *				args[2] *				 The place where the requested value will be stored. *				args[3] *				 The place where the errno will be stored. * * Value:	If failed, returns Lisp NIL.  If succeed, returned value is *		different according to the attribute requested. *		In the case of LENGTH, WDATE, RDATE, and PROTECTION, returns Lisp T. *		In the case of AUTHOR and ALL, returns the length of the author name *		copied into the specified buffer. * * Side Effect:	The specified buffer will be replaced with the value of the requested *		attribute. * * Description: * * The implementation of GETFILEINFO FDEV method for DSK and UNIX device.  Try to * fetch a value of a specified file attribute. * The creation date file attribute in Lisp sense is kept in st_mdate field of * UNIX structure, and it is treated as same as the write date file attribute in * Lisp sense. */COM_getfileinfo(args)	register LispPTR	*args;E 50E 29{D 25D 29char	pathname[MAXPATHLEN];int	*buffixp;E 29I 29D 50register int	rval;D 35register int	*buffixp;E 35I 35register unsigned int	*buffixp;E 35register struct passwd *pwd;E 29E 25I 25D 30register int	rval;register int	*buffixp;register struct passwd *pwd;E 30E 25LispPTR	*naddress;char	*base;struct stat sbuf;D 25D 29struct passwd *pwd;D 11int	length;E 11I 11int	rval;E 29I 29char	pathname[MAXPATHLEN];I 35LispPTR	lisp_addr;E 35#ifdef	FSERRORD 40int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));	E 40I 40	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	E 40#endifE 29E 25I 25D 30char	pathname[MAXPATHLEN];E 30E 25I 19D 28	SETJMP(0);E 28E 19E 11D 46	LispStringToCString(args[0], pathname);E 46I 46	LispStringToCString(args[0], pathname, MAXPATHLEN);E 46I 16	RemoveDodNoExtenstion(pathname);I 17	if(checklink_and_changeversion(pathname) == 0)		return(NIL);E 17E 16	LispVersionToUnixVersion(pathname);I 29#ifdef	FSERRORE 50I 50	register int		dskp, rval;	register unsigned	*bufp;	register struct passwd	*pwd;	register char		*base;D 57	char			lfname[MAXPATHLEN], file[MAXPATHLEN], host[MAXNAMLEN];E 57I 57	char			lfname[MAXPATHLEN + 5], file[MAXPATHLEN], host[MAXNAMLEN];E 57	char			dir[MAXPATHLEN], name[MAXNAMLEN], ver[VERSIONLEN];	struct stat		sbuf;	LispPTR			laddr;E 50D 40	ERRSETJMP(NIL, errp);E 40I 40	ERRSETJMP(NIL);E 40D 50#else	SETJMP(NIL);#endifE 29I 28D 30	SETJMP(0);E 30E 28D 4	if(stat(pathname, &sbuf) != 0)E 4I 4D 11	if(stat(pathname, &sbuf) != 0){E 11I 11	TIMEOUT(rval=stat(pathname, &sbuf));	if(rval != 0){E 11		err_mess("stat", errno);I 40#ifdef	FSERRORE 50I 50	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	I 57	LispStringLength(args[0], rval, dskp);	/*	 * Because of the version number convention, Lisp pathname might	 * be shorter than UNIX one.  For THIN string, the difference	 * is 2 bytes, for FAT string, 4 bytes.  Add 1 byte for NULL	 * terminating character.	 */	rval = dskp ? rval + 4 + 1 : rval + 2 + 1;	/* Add 5 for the host name field in Lisp format. */	if (rval > MAXPATHLEN + 5) FileNameTooLong(NIL);E 57	LispStringToCString(args[0], lfname, MAXPATHLEN);	separate_host(lfname, host);	UPCASE(host);	if (strcmp(host, "DSK") == 0)	  dskp = 1;	else if (strcmp(host, "UNIX") == 0)	  dskp = 0;	else	  return(NIL);		/*	 * Convert a Lisp file name to UNIX one.  If host is DSK, we also have to	 * convert a version field.	 */	dskp ? unixpathname(lfname, file, 1, 0) : unixpathname(lfname, file, 0, 0);	/*	 * The file name which has been passed from Lisp is sometimes different	 * from the actual file name on DSK, even after the Lisp name is converted	 * to UNIX form with unixpathname.  The Lisp code for GETFILEINFO always	 * recognizes a file with old mode.  Thus, we recognize it again using	 * get_old routine.  It will let us know the "real accessible" name of	 * the file.	 */	if (dskp) {		if (unpack_filename(file, dir, name, ver, 1) == 0) return(NIL);		if (true_name(dir) != -1) return(0);		if (strcmp(name, "") == 0) {			/*			 * The directory is specified.			 */			strcpy(file, dir);		} else {			if (get_version_array(dir, name, VersionArray, &VArrayInfo) == 0)			  return(NIL);			ConcNameAndVersion(name, ver, file);			if (get_old(dir, VersionArray, file, name) == 0)			  return(NIL);		}	}	TIMEOUT(rval = stat(file, &sbuf));	if (rval != 0) {E 50		*Lisp_errno = errno;D 50#endifE 50E 40I 29D 30#ifdef FSERROR		*errp = errno;#endifE 30E 29E 4		return(NIL);I 4	}E 4D 50	switch(args[1]){	case SIZE:D 35		buffixp = (int *)(Addr68k_from_LADDR(args[2]));E 35I 35		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));E 35		*buffixp = sbuf.st_size;E 50I 50	switch (args[1]) {	      case LENGTH:		bufp = (unsigned *)(Addr68k_from_LADDR(args[2]));		*bufp = (unsigned)sbuf.st_size;E 50		return(ATOM_T);D 50	case WDATE:D 35		buffixp = (int *)(Addr68k_from_LADDR(args[2]));E 35I 35		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));E 35		*buffixp = ToLispTime(sbuf.st_mtime);E 50I 50	      case WDATE:		bufp = (unsigned *)(Addr68k_from_LADDR(args[2]));		*bufp = (unsigned)ToLispTime(sbuf.st_mtime);E 50		return(ATOM_T);D 50	case RDATE:D 35		buffixp = (int *)(Addr68k_from_LADDR(args[2]));E 35I 35		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));E 35		*buffixp= ToLispTime(sbuf.st_atime);E 50I 50	      case RDATE:		bufp = (unsigned *)(Addr68k_from_LADDR(args[2]));		*bufp = (unsigned)ToLispTime(sbuf.st_atime);E 50		return(ATOM_T);D 50	case AUTHOR:D 5		pwd = getpwuid(getuid());E 5I 5D 19D 29		pwd = getpwuid(sbuf.st_uid);E 29I 29		TIMEOUT(pwd=getpwuid(sbuf.st_uid));E 29E 19I 19D 30		TIMEOUT(pwd=getpwuid(sbuf.st_uid));E 30E 19I 8		if(pwd == NULL){I 40#ifdef FSERROR			*Lisp_errno = errno;#endifE 40D 24D 29			printf("error:getpwuid\n");E 29E 24D 45			return(0);E 45I 45		/** changed to return 0 for author's name length -was **/E 50I 50	      case PROTECTION:		bufp = (unsigned *)(Addr68k_from_LADDR(args[2]));		*bufp = sbuf.st_mode;		return(ATOM_T);	      case AUTHOR:		TIMEOUT(pwd = getpwuid(sbuf.st_uid));		if (pwd == (struct passwd *)NULL) {			/*			 * Returns Lisp 0.  Lisp code handles this case as author			 * unknown.  The returned value from Lisp GETFILEINFO			 * function would be "".			 */E 50			return(GetSmallp(0));E 45D 50		}	E 8E 5		/*** CStringToLispString ***/		naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));D 44		base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));E 44I 44		base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));E 50I 50		}		STRING_BASE(args[2], base);E 50E 44D 11		length = strlen(pwd->pw_name);		strncpy( base, pwd->pw_name, length );				return(GetSmallp(length));E 11I 11		rval = strlen(pwd->pw_name);D 49		strncpy( base, pwd->pw_name, rval );		E 49I 49#ifndef BYTESWAPD 50		strncpy( base, pwd->pw_name, rval );E 50I 50		strncpy(base, pwd->pw_name, rval);E 50#elseD 50		StrNCpyFromCToLisp( base, pwd->pw_name, rval );E 50I 50		StrNCpyFromCToLisp(base, pwd->pw_name, rval);E 50D 72#endif BYTESWAPE 72I 72#endif /* BYTESWAP */E 72D 50E 50E 49		return(GetSmallp(rval));E 11D 50	case PROTECTION:D 35		buffixp = (int *)(Addr68k_from_LADDR(args[2]));E 35I 35		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));E 35		*buffixp= sbuf.st_mode;		return(ATOM_T);I 35	case ALL:		/* length */		lisp_addr = cdr(car(args[2]));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp= sbuf.st_size;		/* wdate */		lisp_addr = cdr(car(cdr(args[2])));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp = ToLispTime(sbuf.st_mtime);		/* rdate */		lisp_addr = cdr(car(cdr(cdr(args[2]))));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp= ToLispTime(sbuf.st_atime);		/* protection */		lisp_addr = cdr(car(cdr(cdr(cdr(args[2])))));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp= sbuf.st_mode;		/* author */		TIMEOUT( pwd = getpwuid(sbuf.st_uid) );		if(pwd == NULL){I 40#ifdef FSERROR			*Lisp_errno = errno;D 45#endifE 40			return(NIL);E 45I 45#endif				/** changed to return 0 for author's name length -was **/E 50I 50	      case ALL:		/*		 * The format of the buffer which has been allocated by Lisp		 * is as follows.		 * 	((LENGTH	.	fixp)		 *	 (WDATE		.	fixp)		 *	 (RDATE		.	fixp)		 *	 (PROTECTION	.	fixp)		 *	 (AUTHOR	.	string))		 */		laddr = cdr(car(args[2]));		bufp = (unsigned *)(Addr68k_from_LADDR(laddr));		*bufp= sbuf.st_size;		laddr = cdr(car(cdr(args[2])));		bufp = (unsigned *)(Addr68k_from_LADDR(laddr));		*bufp = ToLispTime(sbuf.st_mtime);		laddr = cdr(car(cdr(cdr(args[2]))));		bufp = (unsigned *)(Addr68k_from_LADDR(laddr));		*bufp= ToLispTime(sbuf.st_atime);		laddr = cdr(car(cdr(cdr(cdr(args[2])))));		bufp = (unsigned *)(Addr68k_from_LADDR(laddr));		*bufp= sbuf.st_mode;		TIMEOUT(pwd = getpwuid(sbuf.st_uid));		if(pwd == (struct passwd *)NULL) {E 50			return(GetSmallp(0));E 45		}D 50		lisp_addr = cdr(car(cdr(cdr(cdr(cdr(args[2]))))));		naddress = (LispPTR *)(Addr68k_from_LADDR(lisp_addr));D 44		base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));E 44I 44		base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));E 50I 50		laddr = cdr(car(cdr(cdr(cdr(cdr(args[2]))))));		STRING_BASE(laddr, base);E 50E 44		rval = strlen(pwd->pw_name);D 49		strncpy( base, pwd->pw_name, rval );		E 49I 49#ifndef BYTESWAPD 50		strncpy( base, pwd->pw_name, rval );	E 50I 50		strncpy(base, pwd->pw_name, rval);	E 50#elseD 50		StrNCpyFromCToLisp( base, pwd->pw_name, rval );E 50I 50		StrNCpyFromCToLisp(base, pwd->pw_name, rval);E 50D 72#endif BYTESWAP	E 72I 72#endif /* BYTESWAP	 */E 72E 49		return(GetSmallp(rval));E 35D 50	default:E 50I 50	      default:E 50		return(NIL);	}}I 63E 63D 50DSK_setfileinfo(args)D 25D 29LispPTR	*args;E 29I 29register LispPTR	*args;E 29E 25I 25D 30register LispPTR	*args;E 30E 25/*	args[0]:	IndirectPonter to File Name *//*	args[1]:	IndirectPonter to Attribute *//*	args[2]:	IndirectPonter to BUffer */I 29/*	args[3]:	errno */E 50I 50/*		 * Name:	COM_setfileinfo * * Argument:	LispPTR	*args	args[0] *				 Full file name which is following the Xerox *				 Lisp file naming convention.  Including a host *				 field. *				args[1] *				 The Lisp pointer which represents the requested *				 file attribute. *				args[2] *				 The value to be stored on the request attribute. *				args[3] *				 The place where the error number should be *				 stored. * * Value:	If succeed, returns Lisp T, otherwise Lisp NIL. * * Side Effect:	The specified attribute of a file will be replaced with the specified *		value. * * Description: * * The implementation of SETFILEINFO FDEV method for DSK and UNIX device.  Try to * replace a value of a specified file attribute. * In this implementation, only WDATE(as well as Createion Date) and PROTECTION * make sense. */COM_setfileinfo(args)	register LispPTR	*args;E 50E 29{D 25D 29char	pathname[MAXPATHLEN];int	date;struct stat	sbuf;E 29I 29D 50register int	date;register int	rval;E 29E 25I 25D 30register int	date;register int	rval;E 30E 25D 32D 33struct timeval time[2];E 33I 33static struct timeval time[2];E 33E 32I 32D 34static struct timeval time[2];E 34E 32I 11D 25D 29int	rval;E 29I 29struct stat	sbuf;char	pathname[MAXPATHLEN];#ifdef	FSERRORD 40int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));	E 40I 40	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	E 40#endifE 29E 25I 25D 30struct stat	sbuf;char	pathname[MAXPATHLEN];E 30E 25I 19D 28	SETJMP(0);E 28E 19E 11D 46	LispStringToCString(args[0], pathname);E 46I 46	LispStringToCString(args[0], pathname, MAXPATHLEN);E 46I 16	RemoveDodNoExtenstion(pathname);I 17	if(checklink_and_changeversion(pathname) == 0)		return(NIL);E 17E 16	LispVersionToUnixVersion(pathname);I 29#ifdef	FSERRORE 50I 50	register int		dskp, rval, date;D 57	char			lfname[MAXPATHLEN], file[MAXPATHLEN], host[MAXNAMLEN];E 57I 57	char			lfname[MAXPATHLEN + 5], file[MAXPATHLEN], host[MAXNAMLEN];E 57	char			dir[MAXPATHLEN], name[MAXNAMLEN], ver[VERSIONLEN];	struct stat		sbuf;	struct timeval		time[2];E 50D 40	ERRSETJMP(NIL, errp);E 40I 40	ERRSETJMP(NIL);E 40D 50#else	SETJMP(NIL);#endifE 29I 28D 30	SETJMP(0);E 30E 28D 4	if(stat(pathname, &sbuf) != 0)E 4I 4D 11	if(stat(pathname, &sbuf) != 0){E 11I 11D 32D 33	TIMEOUT( rval=stat(pathname, &sbuf) );	if(rval != 0){E 11		err_mess("stat", errno);I 29#ifdef FSERROR		*errp = errno;#endifE 29E 4		return(NIL);I 4	}E 33E 32E 4	switch(args[1]){	case WDATE:I 33		TIMEOUT( rval=stat(pathname, &sbuf) );		if(rval != 0){			err_mess("stat", errno);#ifdef FSERRORE 50I 50	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));I 57	LispStringLength(args[0], rval, dskp);	/*	 * Because of the version number convention, Lisp pathname might	 * be shorter than UNIX one.  For THIN string, the difference	 * is 2 bytes, for FAT string, 4 bytes.  Add 1 byte for NULL	 * terminating character.	 */	rval = dskp ? rval + 4 + 1 : rval + 2 + 1;	/* Add 5 for the host name field in Lisp format. */	if (rval > MAXPATHLEN + 5) FileNameTooLong(NIL);E 57	LispStringToCString(args[0], lfname, MAXPATHLEN);	separate_host(lfname, host);	UPCASE(host);	if (strcmp(host, "DSK") == 0)	  dskp = 1;	else if (strcmp(host, "UNIX") == 0)	  dskp = 0;	else	  return(NIL);		/*	 * Convert a Lisp file name to UNIX one.  If host is DSK, we also have to	 * convert a version field.	 */	dskp ? unixpathname(lfname, file, 1, 0) : unixpathname(lfname, file, 0, 0);	/*	 * The file name which has been passed from Lisp is sometimes different	 * from the actual file name on DSK, even after the Lisp name is converted	 * to UNIX form with unixpathname.  The Lisp code for SETFILEINFO always	 * recognizes a file with old mode.  Thus, we recognize it again using	 * get_old routine.  It will let us know the "real accessible" name of	 * the file.	 */	if (dskp) {		if (unpack_filename(file, dir, name, ver, 1) == 0) return(NIL);		if (true_name(dir) != -1) return(0);		if (get_version_array(dir, name, VersionArray, &VArrayInfo) == 0)		  return(NIL);		ConcNameAndVersion(name, ver, file);		if (get_old(dir, VersionArray, file, name) == 0)		  return(NIL);	}	switch (args[1]) {	      case WDATE:		TIMEOUT(rval = stat(file, &sbuf));		if (rval != 0) {E 50D 40			*errp = errno;E 40I 40			*Lisp_errno = errno;E 40D 50#endifE 50			return(NIL);		}E 33I 32D 34		TIMEOUT( rval=stat(pathname, &sbuf) );		if(rval != 0){			err_mess("stat", errno);#ifdef FSERROR			*errp = errno;#endif			return(NIL);		}E 34E 32		date = LispNumToCInt(args[2]);D 32D 33		time[0].tv_sec = sbuf.st_atime;		time[1].tv_sec = ToUnixTime(date);E 33I 33		time[0].tv_sec = (long)sbuf.st_atime;I 50		time[0].tv_usec = 0L;E 50		time[1].tv_sec = (long)ToUnixTime(date);E 33E 32I 32D 34		time[0].tv_sec = (long)sbuf.st_atime;		time[1].tv_sec = (long)ToUnixTime(date);E 34E 32D 4		if(utimes(pathname, time) != 0)E 4I 4D 11		if(utimes(pathname, time) != 0){E 11I 11D 50		TIMEOUT(rval=utimes(pathname, time));		if(rval != 0){E 11			err_mess("utimes", errno);I 29#ifdef FSERRORE 50I 50		time[1].tv_usec = 0L;I 58D 60#ifdef HPUXE 60I 60D 64#if (defined(HPUX) || defined(RISCOS))E 64I 64#if (defined(HPUX) || defined(SYSVONLY))E 64E 60		TIMEOUT(rval = utime(file, time));#else E 58		TIMEOUT(rval = utimes(file, time));I 58D 72#endif HPUXE 72I 72#endif /* HPUX */E 72E 58		if(rval != 0) {E 50D 40			*errp = errno;E 40I 40			*Lisp_errno = errno;E 40D 50#endifE 50E 29E 4			return(NIL);I 4		}E 4		return(ATOM_T);I 33D 50	case PROTECTION:E 50I 50	      case PROTECTION:E 50		rval = LispNumToCInt(args[2]);D 50		TIMEOUT( rval=chmod(pathname, rval) );		if(rval != 0){			err_mess("chmod", errno);#ifdef FSERRORE 50I 50		TIMEOUT(rval = chmod(file, rval));		if(rval != 0) {E 50D 40			*errp = errno;E 40I 40			*Lisp_errno = errno;E 40D 50#endifE 50			return(NIL);		}		return(ATOM_T);E 33I 32D 34	case PROTECTION:		rval = LispNumToCInt(args[2]);		TIMEOUT( rval=chmod(pathname, rval) );		if(rval != 0){			err_mess("chmod", errno);#ifdef FSERROR			*errp = errno;#endif			return(NIL);		}		return(ATOM_T);E 34E 32D 50	default:E 50I 50	      default:E 50		return(NIL);	}}I 63E 63D 50DSK_dirsize(args)D 25D 29LispPTR	*args;E 29I 29register LispPTR	*args;E 29E 25I 25D 30register LispPTR	*args;E 30E 25/*	args[0]:	IndirectPonter to Directory Name *//*	args[1]:	IndirectPonter to Filter Name */I 40/*	args[2]:	Ponter to errno */E 50I 50/*		 * Name:	COM_readpage * * Argument:	LispPTR	*args	args[0] *				 The Lisp integer representing a file descriptor *				 of the file being read. *				args[1] *				 The Lisp integer representing a page number of the *				 file being read. *				args[2] *				 The place where the contents of the file will be *				 stored. *				args[3] *				 The place where the error number should be stored. * * Value:	If succeed, returns a Lisp integer representing a total number of *		bytes read, otherwise Lisp NIL. * * Side Effect:	The specified buffer will be filled with the specified region of the *		contents of the file. * * Description: * * The implementation of READPAGES FDEV method for DSK and UNIX device.  Try to * read a page into a buffer. * If a page being read is a last page in a file, and it is not a full page, the * remaining region of a buffer will be zero outed.  The size of a page is 512 bytes. */COM_readpage(args)	register LispPTR	*args;E 50E 40{I 29D 50register int	size;E 29I 25D 30register int	size;E 30E 25char	dirname[MAXPATHLEN];char	fulldirname[MAXPATHLEN];char	filter[MAXPATHLEN];D 25D 29int	size;E 29I 29#ifdef	FSERRORD 40int	errp;E 40I 40	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));	E 40#endifE 29E 25D 46	LispStringToCString(args[0], dirname);E 46I 46	LispStringToCString(args[0], dirname, MAXPATHLEN);E 46I 29D 40#ifdef	FSERROR	if( makepathname(dirname, fulldirname, &errp) == 0)#elseE 40E 29	if( makepathname(dirname, fulldirname) == 0)E 50I 50	register char	*bufp;	register char	*bp;	register int	count, fd, npage, rval;	struct	stat	sbuf;	ERRSETJMP(NIL);	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));		fd = LispNumToCInt(args[0]);	npage = LispNumToCInt(args[1]);	bufp = (char*)(Addr68k_from_LADDR(args[2]));	TIMEOUT(rval = fstat(fd, &sbuf));	if (rval != 0) {		*Lisp_errno = errno;E 50I 29D 40#endifE 40E 29		return(NIL);D 50	if(confirmpath(fulldirname) == 0)E 50I 50	}	if((sbuf.st_mode & S_IFREG) != 0){		/*		 * The request file is a regular file.  We have to make sure that		 * next byte read is at the beggning of the requested page of the		 * file.  If the request file is special file, lseek is not needed.		 */D 70		TIMEOUT(rval = lseek(fd, (npage * PAGE_SIZE), L_SET));E 70I 70sklp:		TIMEOUT(rval = lseek(fd, (npage * PAGE_SIZE), L_SET));E 70		if(rval == -1) {I 70			if (errno == EINTR) goto sklp;	/* interrupted, retry */E 70			*Lisp_errno = errno;			return(NIL);		}	}D 70	TIMEOUT(count = read(fd, bufp, PAGE_SIZE));E 70I 70rdlp:	TIMEOUT(count = read(fd, bufp, PAGE_SIZE));E 70	if(count == -1) {I 70		if (errno == EINTR) goto rdlp;	/* interrupted; retry */E 70		*Lisp_errno = errno;E 50		return(NIL);D 46	LispStringToCString(args[1], filter);E 46I 46D 50	LispStringToCString(args[1], filter, MAXPATHLEN);E 46	LispVersionToUnixVersion(filter);	size = alldirSize( fulldirname, "", 0, filter);	if(size == -1)		return(NIL);	else		return(GetSmallp(size));E 50I 50	}	/* O out the remaining part of the buffer. */	for(bp = &bufp[count], rval = count; rval < PAGE_SIZE; ++rval) *bp++ = 0;#ifdef BYTESWAP	word_swap_page(bufp, PAGE_SIZE / 4);D 72#endif BYTESWAPE 72I 72#endif /* BYTESWAP */E 72I 72E 72	return(GetSmallp(count));E 50}I 63E 63D 50DSK_readdir(args)D 25D 29LispPTR	*args;E 29I 29register LispPTR	*args;E 29E 25I 25D 30register LispPTR	*args;E 30E 25/*	args[0]:	IndirectPonter to Directory Name *//*	args[1]:	IndirectPonter to Filter Name *//*	args[2]:	IndirectPonter to BUffer */I 29/*	args[3]:	errno */E 50I 50/*		 * Name:	COM_writepage * * Argument:	LispPTR	*args	args[0] *				 The Lisp integer representing a file descriptor *				 of the file being read. *				args[1] *				 The Lisp integer representing a page number of the *				 file being written. *				args[2] *				 The place in where the next date to be written is *				 hold. *				args[3] *				 The Lisp integer representing a number of bytes *				 of data to be written. *				args[4] *				 The place where the error number should be stored. * * Value:	If succeed, returns a Lisp T, otherwise Lisp NIL. * * Side Effect:	The specified page of the file will be replaced with the contents of *		the buffer. * * Description: * * The implementation of WRITEPAGES FDEV method for DSK and UNIX device.  Try to * write a page into a buffer. * The actual size of data written is specified with args[3]. */COM_writepage(args)	register LispPTR	*args;E 50E 29{I 29D 50register int	size;register LispPTR	*naddress;register char	*base;E 29I 25D 30register int	size;register LispPTR	*naddress;register char	*base;E 30E 25char	dirname[MAXPATHLEN];char	fulldirname[MAXPATHLEN];char	filter[MAXPATHLEN];D 25D 29LispPTR	*naddress;char	*base;int	size;E 29I 29#ifdef	FSERRORD 40int	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));	E 40I 40	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	E 40#endifE 29E 25D 46	LispStringToCString(args[0], dirname);E 46I 46	LispStringToCString(args[0], dirname, MAXPATHLEN);E 46I 29D 40#ifdef	FSERROR	if( makepathname(dirname, fulldirname, errp) == 0){D 38		*errp = errno;E 38		return(NIL);	}#elseE 40E 29	if( makepathname(dirname, fulldirname) == 0)E 50I 50	register int	fd;	register int	npage;	register char	*bufp;	register int	rval, count;	ERRSETJMP(NIL);	Lisp_errno = (int *)(Addr68k_from_LADDR(args[4]));		fd = LispNumToCInt(args[0]);	npage = LispNumToCInt(args[1]);	bufp = (char*)(Addr68k_from_LADDR(args[2]));	count = LispNumToCInt(args[3]);D 70	TIMEOUT(rval = lseek(fd, (npage*PAGE_SIZE), L_SET));E 70I 70sklp2:	TIMEOUT(rval = lseek(fd, (npage*PAGE_SIZE), L_SET));E 70	if (rval == -1) {I 70		if (errno == EINTR) goto sklp2;	/* interrupted; retry */E 70		*Lisp_errno = errno;E 50		return(NIL);I 29D 40#endifE 40E 29D 50	if(confirmpath(fulldirname) == 0)E 50I 50	}#ifdef BYTESWAP	word_swap_page(bufp, (count + 3) >> 2);D 72#endif BYTESWAPE 72I 72#endif /* BYTESWAP */E 72I 72E 72D 70	TIMEOUT(rval = write(fd, bufp, count));E 70I 70wlp:	TIMEOUT(rval = write(fd, bufp, count));E 70	if ( rval == -1) {I 70		if (errno == EINTR) goto wlp;	/* interrupted; retry */E 70		*Lisp_errno = errno;E 50		return(NIL);I 49D 50	/* string in filter is right order even on i386 */E 49D 46	LispStringToCString(args[1], filter);E 46I 46	LispStringToCString(args[1], filter, MAXPATHLEN);E 46	LispVersionToUnixVersion(filter);	naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));D 44	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));E 44I 44	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));E 44	size = DSK_readAllDir(fulldirname, "", 0, filter, base);	if(size == -1)		return(NIL);	else		return(GetSmallp(size));E 50I 50	}	return(ATOM_T);E 50}I 63E 63D 50DSK_changedir(args)D 39LispPTR	*args;E 39I 39register LispPTR	*args;E 39/*	args[0]:	IndirectPonter to Directory Name */E 50I 50/*		 * Name:	COM_truncatefile * * Argument:	LispPTR	*args	args[0] *				 The Lisp integer representing a file descriptor *				 of the file being truncated. *				args[1] *				 The Lisp integer representing a requested length to be *				 truncated. *				args[2] *				 The place where the error number should be stored. * * Value:	If succeed, returns a Lisp T, otherwise Lisp NIL. * * Side Effect:	The length of the specified file will be the specified length. * * Description: * * The implementation of TRUNCATEFILE FDEV method for DSK and UNIX device.  Try to * truncate a file. */COM_truncatefile(args)	register LispPTR	*args;E 50{I 29D 50register int	rval;E 29I 25D 30register int	rval;E 30E 25char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];I 11D 25D 29int	rval;E 29I 29#ifdef	FSERRORD 40int	errp;E 40I 40	Lisp_errno = &Dummy_errno;	E 40#endifE 29E 25I 19D 28	SETJMP(0);E 28E 19E 11D 46	LispStringToCString(args[0], pathname);E 46I 46	LispStringToCString(args[0], pathname, MAXPATHLEN);E 46I 29D 40#ifdef	FSERROR	if( makepathname(pathname, fullpathname, &errp) == 0)#elseE 40E 29	if( makepathname(pathname, fullpathname) == 0)E 50I 50	register int	fd;	register int	length;	register int	rval;	struct stat	sbuf;	ERRSETJMP(NIL);	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));		fd = LispNumToCInt(args[0]);	length = LispNumToCInt(args[1]);	TIMEOUT(rval = fstat(fd, &sbuf));	if (rval == -1) {		*Lisp_errno = errno;E 50I 29D 40#endifE 40E 29		return(NIL);I 29D 50	SETJMP(0);I 41		/* No errp is passed from Lisp, so ERRSETJMP is not used */E 41E 29I 28D 30	SETJMP(0);E 30E 28D 4	if(chdir(fullpathname) != 0)E 4I 4D 11	if(chdir(fullpathname) != 0){E 11I 11	TIMEOUT(rval=chdir(fullpathname));	if(rval != 0){E 11		err_mess("chdir", errno);E 50I 50	}	if((sbuf.st_mode & S_IFREG) == 0){		/*		 * The request file is not a regular file.  We don't need to		 * truncate such file.		 */		return(ATOM_T);	}I 64D 65#ifndef ISC  /* ISC has no ftruncate; sigh */E 65E 64I 62    if ((off_t)length != sbuf.st_size)      {I 65#ifndef ISC  /* ISC has no ftruncate; sigh */E 65E 62	TIMEOUT(rval = ftruncate(fd, (off_t)length));	if (rval != 0) {		*Lisp_errno = errno;E 50E 4		return(NIL);I 4	}I 50D 64E 64I 64D 72#endif ISCE 72I 72#endif /* ISC */E 72E 64	/*	 * TRUNCATEFILE FDEV method is invoked from FORCEOUTPUT Lisp function.	 * Thus we have to sync the file state here.	 */I 69#ifdef INDIGO	TIMEOUT(rval = fsync(fd));#elseE 69I 60D 64#ifdef RISCOSE 64I 64#ifdef SYSVONLYE 64	TIMEOUT(rval = fflush(fd));#elseE 60	TIMEOUT(rval = fsync(fd));I 60D 64#endif RISCOSE 64I 64D 72#endif SYSVONLYE 72I 72#endif /* SYSVONLY */E 72I 69#endif /* INDIGO */E 69E 64E 60	if (rval != 0) {		*Lisp_errno = errno;		return(NIL);	}D 62E 62I 62      }E 62E 50E 4	return(ATOM_T);}I 63E 63I 50/*		 * Name:	COM_changedir * * Argument:	LispPTR	*args	args[0] *				 Full file directory name which is following the Xerox *				 Lisp file naming convention.  Including a host *				 field. * * Value:	If succeed, returns a Lisp T, otherwise Lisp NIL. * * Side Effect:	If succeed, the current directory of this Lisp proecess will be changed. * * Description: * * Change the current directory of the process to the specified directory. */E 50I 50COM_changedir(args)	register LispPTR	*args;{	register int		dskp, rval;D 57	char			lfname[MAXPATHLEN], dir[MAXPATHLEN], host[MAXNAMLEN];E 57I 57	char			lfname[MAXPATHLEN + 5], dir[MAXPATHLEN], host[MAXNAMLEN];E 57E 50I 50	ERRSETJMP(NIL);	Lisp_errno = &Dummy_errno;I 57	LispStringLength(args[0], rval, dskp);	/*	 * Because of the version number convention, Lisp pathname might	 * be shorter than UNIX one.  For THIN string, the difference	 * is 2 bytes, for FAT string, 4 bytes.  Add 1 byte for NULL	 * terminating character.	 */	rval = dskp ? rval + 4 + 1 : rval + 2 + 1;	/* Add 5 for the host name field in Lisp format. */	if (rval > MAXPATHLEN + 5) FileNameTooLong(NIL);E 57	LispStringToCString(args[0], lfname, MAXPATHLEN);	separate_host(lfname, host);	UPCASE(host);	if (strcmp(host, "DSK") == 0)	  dskp = 1;	else if (strcmp(host, "UNIX") == 0)	  dskp = 0;	else	  return(NIL);		if (!unixpathname(lfname, dir, 0, 0)) return(NIL);	if (dskp) {		/*		 * If {DSK} device, the directory name can be specified in a case		 * insensitive manner.  We have to convert it into a right case.		 */		if (true_name(dir) != -1) return(NIL);	}	TIMEOUT(rval = chdir(dir));	if (rval != 0) return(NIL);	return(ATOM_T);}I 55/************************************************************************//*									*/I 63/*		     C O M _ g e t f r e e b l o c k			*/E 63/*									*//*									*//*									*/D 63/*									*/E 63/************************************************************************/E 55/*		 * Name:	COM_getfreeblock * * Argument:	LispPTR	*args	args[0] *				 Full sysout in Lisp format.  Including a host field. *				args[1] *				 The place where the available free block size will *				 be stored. * * Value:	If succeed, returns a Lisp T, otherwise Lisp NIL. * * Side Effect:	None. * * Description: * * Examines the statistics of the file system on which the specified sysout file * resides, and returns the number of available free blocks thorugh the specified * buffer. * This routine is invoked just before the Lisp flushes its image on a sysout file so * as to make sure the Lisp image is gracefully written on a sysout file.  See * \MAIKO.CHECKFREESPACE in MOD44IO. * The version controll based on a file naming convention is not applicable to a * sysout file, even if the sysout file is specified on {DSK} device.  The Lisp code * strips the version field by invoking DSK_getfilename with NON recognition mode.  */COM_getfreeblock(args)D 55	register LispPTR	*args;E 55I 55	register LispPTR *args;E 55{D 55	register int		dskp, rval, *buf;	char			lfname[MAXPATHLEN], dir[MAXPATHLEN], host[MAXNAMLEN];	char			name[MAXNAMLEN + 1], file[MAXPATHLEN], ver[VERSIONLEN];	struct statfs		sfsbuf;E 55I 55	register int	dskp, rval, *buf;D 57	char		lfname[MAXPATHLEN], dir[MAXPATHLEN], host[MAXNAMLEN];E 57I 57	char		lfname[MAXPATHLEN + 5], dir[MAXPATHLEN], host[MAXNAMLEN];E 57	char		name[MAXNAMLEN + 1], file[MAXPATHLEN], ver[VERSIONLEN];D 71#ifdef DEC3100E 71I 71#ifdef ULTRIXE 71	struct fs_data	sfsbuf;#elseD 58#ifndef AIXPS2E 58I 58D 71#if (!defined(AIXPS2) && !defined(HPUX))E 71I 71#ifndef AIXPS2E 71E 58	struct statfs	sfsbuf;D 58#endif AIXPS2E 58I 58D 71#endif AIXPS2 | HPUXE 58#endif DEC3100E 71I 71D 72#endif AIXPS2#endif ULTRIXE 72I 72#endif /* AIXPS2 */E 72E 71E 55I 72#endif /* ULTRIX */E 72	ERRSETJMP(NIL);	Lisp_errno = &Dummy_errno;	I 57	LispStringLength(args[0], rval, dskp);	/*	 * Add 1 byte for NULL terminating character.	 */	rval += 1;	/* Add 5 for the host name field in Lisp format. */	if (rval > MAXPATHLEN + 5) FileNameTooLong(NIL);E 57	LispStringToCString(args[0], lfname, MAXPATHLEN);	buf = (int *)(Addr68k_from_LADDR(args[1]));	separate_host(lfname, host);	UPCASE(host);	if (strcmp(host, "DSK") == 0)	  dskp = 1;	else if (strcmp(host, "UNIX") == 0)	  dskp = 0;	else	  return(NIL);		if (!unixpathname(lfname, file, 0, 0)) return(NIL);	if (!unpack_filename(file, dir, name, ver, 0)) return(NIL);		if (dskp) {		/*		 * Although Lisp code gurantees the directory is an existing one,		 * by calling DSK_getfilename, we check it again for safety.		 */		if (true_name(dir) != -1) return(NIL);	}	/*	 * The specified file itself might be a file being created newly.  Thus,	 * we check the available block size, using the directory on which the file	 * will be exist.	 */I 55D 71#ifdef DEC3100E 71I 71#ifdef ULTRIXE 71	TIMEOUT(rval = getmnt(0, &sfsbuf, 0, STAT_ONE, dir));I 63	if (rval <= 0) {I 71D 72#ifdef OSF1E 72I 72#elif OSF1E 72	TIMEOUT(rval = statfs(dir, &sfsbuf, sizeof(struct statfs)));	if (rval <= 0) {E 71I 70#elif defined(ISC)	TIMEOUT(rval = statfs(dir, &sfsbuf, sizeof(struct statfs), 0));	if (rval != 0) {I 71#elif APOLLO	TIMEOUT(rval = statfs(dir, &sfsbuf, sizeof(struct statfs), 0));	if (rval != 0) {#elif INDIGO	TIMEOUT(rval = statfs(dir, &sfsbuf, sizeof(struct statfs), 0));	if (rval != 0) {E 71E 70E 63#elseD 58#ifndef AIXPS2E 58I 58D 71#if (!defined(AIXPS2) && !defined(HPUX))E 71I 71#ifndef AIXPS2E 71E 58E 55	TIMEOUT(rval = statfs(dir, &sfsbuf));I 55D 58#endif AIXPS2E 58I 58D 71#endif AIXPS2 | HPUXE 71I 71D 72#endif AIXPS2E 72I 72#endif /* AIXPS2 */E 72E 71E 58D 63#endif DEC3100E 63E 55	if (rval != 0) {I 63D 71#endif DEC3100E 71I 71D 72#endif ULTRIXE 72I 72#endif /* ULTRIX */E 72E 71E 63		*Lisp_errno = errno;		return(NIL);	}I 55D 71#ifdef DEC3100E 71I 71#ifdef ULTRIXE 71	*buf = sfsbuf.fd_req.bfree;D 70#elseI 59#ifdef RS6000E 70I 70#elif defined(RS6000)E 70	*buf = (sfsbuf.f_bavail) * 4;	/* AIX 3.1 returns no. of 4K blocks */D 70#elseI 60D 64#ifdef RISCOSE 64I 64#ifdef SYSVONLYE 70I 70#elif defined(ISC)	*buf = (sfsbuf.f_bfree)/2;	/* ISC claims 1K blocks, but it's really 512b */#elif defined(SYSVONLY)E 70E 64	*buf = sfsbuf.f_bfree;D 70#elseE 60E 59D 58#ifndef AIXPS2E 58I 58#if (!defined(AIXPS2) && !defined(HPUX))E 70I 70D 71#elif (!defined(AIXPS2) && !defined(HPUX))E 71I 71#elif (!defined(AIXPS2))E 71E 70E 58E 55	*buf = sfsbuf.f_bavail;I 55D 58#endif AIXPS2E 58I 58#else	*buf = 200000;	/* FAKE - pretend we have 200,000 blocks free! */D 70#endif AIXPS2 | HPUXI 60D 64#endif RISCOSE 64I 64#endif SYSVONLYE 64E 60I 59#endif RS6000E 70E 59E 58D 71#endif DEC3100E 71I 71D 72#endif ULTRIXE 72I 72#endif /* ULTRIX */E 72E 71E 55	return(ATOM_T);}I 63E 63E 50/********************************************	Subroutines********************************************/D 50parse(pathname, path, name, version)D 25D 29char	*pathname;char	*path;char	*name;E 29I 29register char	*pathname;register char	*path;register char	*name;E 29E 25I 25D 30register char	*pathname;register char	*path;register char	*name;E 30E 25char	*version;E 50I 50/*		 * Name:	unpack_filename * * Argument:	char	*file   UNIX file name in the UNIX format.  It must be an *				absolute path. *		char	*dir	The place where unpacked directory will be stored. *		char	*name	The place where unpacked "root file name" will be *				stored. "Root file name" contains the file name *				and the extension. *		char	*ver	The place where unpacked version will be stored. *		int	checkp	If 1, whether the version field contains only the *				numeric characters or not will be checked. * * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	dir, name, and  ver will be replaced with the unpacked corresponding *		fields. * * Description: * * Unpack the specified UNIX full pathname to three components.  If the file does * not include a version field, NULL string will be stored as a version. * unpack_filename assumes the pathname passed is a file, not a directory. * */unpack_filename(file, dir, name, ver, checkp)	register char	*file;	register char	*dir;	register char	*name;	register char	*ver;	register int	checkp;E 50{D 25D 29char	*cp;E 29I 29D 50register char	*cp;E 29E 25I 25D 30register char	*cp;E 30E 25	if((cp = rindex(pathname,'/')) == 0)		return(0);	if(cp == pathname)		*path = '\0';	else{		for(;pathname!=cp;)			*path++ = *pathname++;		*path = '\0';E 50I 50	register char	*cp;	if ((cp = rindex(file, '/')) == 0) return(0);	if (cp == file) {		/* File is on a root directory. */		*dir = '/';		*(dir + 1) = '\0';	} else {		while (file != cp) *dir++ = *file++;		*dir = '\0';E 50	}D 50	if((cp = index(pathname,';')) == 0){I 9		/* No version number */E 9		strcpy(name, pathname);D 9		version[0] = '0';		version[1] = '\0';E 9I 9		*version = '\0';E 9		return(1);	}	if(cp == pathname)		*name = '\0';	else{		for(;pathname!=cp;)			*name++ = *pathname++;		*name = '\0';	}	for(++pathname;*pathname!='\0';)		*version++ = *pathname++;	*version = '\0';E 50I 50	strcpy(name, cp + 1);	separate_version(name, ver, checkp);E 50	return(1);}I 50/*		 * Name:	separate_version * * Argument:	char	*name   UNIX file name.  It is recommended to pass only *				"root file name" (i.e. without directory) as *				name argument, but full file name is also *				acceptable. *		char	*ver	The place where extracted version will be stored. *		init	checkp	If 1, whether the version field contains only *				numbers or not is checked.  If 0, anything in the *				version field is stored in ver.  If GENERATEFILE *				want to contain a wild card character in a version *				field, checkp should be 0. * * Value:	void * * Side Effect:	If name contains a valid version field, name and version will *		be set to name and version respectively. * * Description: * * Check if name contains the valid version field and if so, separate version * field from name field.  After this operation, name contains only name and * version contains its version.  If name does not contain a valid version * field, version will be NULL string. * If checkp is 1, the version field which contains only numeric characters are * regarded valid. * */E 50D 50confirmpath(path)D 25D 29char	*path;E 29I 29register char	*path;E 50I 50separate_version(name, ver, checkp)	register char	*name;	register char	*ver;	register int	checkp;E 50E 29E 25I 25D 30register char	*path;E 30E 25{I 29D 50register char	*cp;register char	*savep;E 29I 25D 30register char	*cp;register char	*savep;E 30E 25char	save_path[MAXPATHLEN];D 25D 29char	*cp;char	*savep;E 29E 25	for(cp=path, savep=save_path;*cp!='\0';){		*savep++ = *cp++;		if(*cp == '/')			*savep++ = '\0';E 50I 50	register char	*start, *end, *cp;	register int	len, ver_no;		char		ver_buf[VERSIONLEN];	if ((end = index(name, '~')) != NULL) {		start = end;		cp = end + 1;		while (*cp) {			if (*cp == '~') {				start = end;				end = cp;			}			cp++;		}		if (start != end && *(start - 1) == '.' && end == (cp - 1)) {			/*			 * name ends in the form ".~###~". But we have to check			 * ### are all numbers or not, if checkp is 1.			 */			len = (int)end - (int)start - 1;			strncpy(ver_buf, start + 1, len);			ver_buf[len] = '\0';			if (checkp) {D 52				if (numeric_string_p(ver_buf)) {					/*					 * name contains a valid version field.					 */					*(start - 1) = '\0';					*end = '\0';					/*					 * Use atoi to eliminate leading 0s.					 */					ver_no = atoi(start + 1);					sprintf(ver_buf, "%d", ver_no);					strcpy(ver, ver_buf);					return;				}E 52I 52				NumericStringP(ver_buf, YES, NO);			      YES:				/*				 * name contains a valid version field.				 */				*(start - 1) = '\0';				*end = '\0';				/*				 * Use atoi to eliminate leading 0s.				 */				ver_no = atoi(start + 1);				sprintf(ver_buf, "%d", ver_no);				strcpy(ver, ver_buf);				return;E 52			} else {				*(start - 1) = '\0';				strcpy(ver, ver_buf);				return;			}		}E 50	}I 52      NO:E 52D 50	*savep++ = '\0';	*savep = '@';	*path = '\0';	for(savep = save_path;;){		if(getpathname(path, savep, 0) == 0)			return(0);		for(;*savep!='\0';savep++);		if(*(++savep) == '@')			return(1);	}E 50I 50	/* name does not contain a valid version field. */	*ver = '\0';E 50}D 50		createpath(path)D 25D 29char	*path;E 29I 29register char	*path;E 50I 50/*		 * Name:	separate_host * * Argument:	char	*lfname	Lisp full file name including host field. *		char	*host	The place where host field will be stored. * * Value:	void * * Side Effect:	lfname will be replaced with the file name except host field, *		and host will be replaced with the host field. * * Description: * * Accepts a Lisp full file name from Lisp code, and separate the host field * from other components.  The result will be appropriate form to pass to * unixpathname.  For convinience to unixpathname, the initial directory * delimiter will be removed from lfname except the case lfname specifies the * very root directory.  And if the lfname is regarded as other directory, * the trail directory delimiter is also removed. * */separate_host(lfname, host)	register char	*lfname;	register char	*host;E 50E 29E 25I 25D 30register char	*path;E 30E 25{I 29D 50register char	*cp;register char	*savep;register int	rval;E 29I 25D 30register char	*cp;register char	*savep;register int	rval;E 30E 25char	save_path[MAXPATHLEN];D 25D 29char	*cp;char	*savep;I 11int	rval;E 29E 25I 19D 28	SETJMP(0);E 28E 19E 11	for(cp=path, savep=save_path;*cp!='\0';){		*savep++ = *cp++;		if(*cp == '/')			*savep++ = '\0';	}	*savep++ = '\0';	*savep = '@';	*path = '\0';	for(savep = save_path;;){		if(getpathname(path, savep, 0) == 0){			strcat(path,savep);I 41#ifdef	FSERROR			ERRSETJMP(0);#elseE 41I 29			SETJMP(0);I 41#endifE 41E 29I 28D 30			SETJMP(0);E 30E 28D 4			if(mkdir(path, 0777) == -1)E 4I 4D 11			if(mkdir(path, 0777) == -1){E 11I 11			TIMEOUT(rval=mkdir(path, 0777));			if(rval == -1){E 11				err_mess("mkdir", errno);I 40#ifdef	FSERROR				*Lisp_errno = errno;#endifE 40E 4				return(0);I 4			}E 50I 50	register char	*cp;	register int	diff;	cp = lfname + 1;	/* Skip the initial "{". */		while (*cp != '}') *host++ = *cp++;	*host = '\0';	cp++;			/* Now, *cp == '<'. */	if (*(cp + 1) == '\0') {		/* Root directory is specified. */		*lfname = '<';		*(lfname + 1) = '\0';	} else {		diff = (int)cp - (int)lfname;		if (*cp == '<' || *cp == '/') {			/*			 * Skip the initial directory delimiter.			 */			cp++;			diff++;E 50E 4		}D 50		for(;*savep!='\0';savep++);		if(*(++savep) == '@')			return(1);E 50I 50		while (*cp) {			*(cp - diff) = *cp;			cp++;		}		if (*(cp - 1) == '>' && *(cp - 2) != '\'') {			/*			 * The last character is a not quoted directory			 * delimiter.  We have to remove it from the result			 * lfname for the convenience of unixpathname.			 */			*(cp - diff - 1) = '\0';		} else {			*(cp - diff) = '\0';		}E 50	}}D 50		getpathname(pathname, name, type)D 25D 29char	*pathname;char	*name;int	type;		/* 0: Directory, 1: File */E 29I 29register char	*pathname;register char	*name;register int	type;		/* 0: Directory, 1: File */E 50I 50/* * Name:	true_name * * Argument:	char	*path	The pathname which follows the UNIX file naming *				convention and does not include any meta character. *				Whether a tail directory delimiter is included *				in path or not is not a matter.  true_name handles *				both case correctly. *				 * Value:	If the pathname is recognized as an existing directory, returns *		-1, recognized as an existing file, returns 1, otherwise 0. * * Side Effect:	If succeed, the contents of path is replaced with the true name. * * Description: * * Try to find the file or directory specified with path.  The search is case * insensitive. * */true_name(path)	register char	*path;E 50E 29E 25I 25D 30register char	*pathname;register char	*name;register int	type;		/* 0: Directory, 1: File */E 30E 25{I 29D 50struct	stat	statbuf;E 29I 25D 30struct	stat	statbuf;E 30E 25char	newpathname[MAXPATHLEN];char	save_name[MAXPATHLEN];I 41#ifdef	FSERROR	ERRSETJMP(0);#elseE 41D 25D 29struct	stat	statbuf;E 29I 29	SETJMP(0);I 41#endifE 41E 29E 25I 19D 30	SETJMP(0);E 30E 19	strcpy(save_name, name);	switch(type){	case 0:	/* name is directory */I 48		DBPRINT(("DIRP of: %s\n", name));E 48		DIRP(pathname, save_name, newpathname);		DOWNCASE(save_name);		DIRP(pathname, save_name, newpathname);		UPCASE(save_name);		DIRP(pathname, save_name, newpathname);		break;	case 1:	/* name is file */		FILEP(pathname, save_name, newpathname);		DOWNCASE(save_name);		FILEP(pathname, save_name, newpathname);		UPCASE(save_name);		FILEP(pathname, save_name, newpathname);		break;	default:		return(0);E 50I 50	char		dir[MAXPATHLEN];	char		name[MAXNAMLEN];	register char	*sp, *cp;	register int	type, c;	if (strcmp(path, "/") == 0) return(-1);			*dir = '\0';		/*				 * locate_file does not accept the directory with				 * the trail delimiter.  Thus, for the root				 * directory, we have to set the null character				 * as directory.				 */	cp = path + 1;	while (*cp) {		/*		 * Copy the next subdirectory to name.		 * And examine if it is an existing subdirectory or the file on the		 * dir.		 * At this point dir has been guaranteed to be exist.		 */		sp = name;		for (c= *cp++, *sp++ = c; c != '/' && c != '\0';c= *cp++, *sp++ = c) {}		if (c == '/') {			/* Remove the trail delimiter */			*(sp - 1) = '\0';		} else {			/* Move back cp to '\0' character to finish the loop. */			cp--;		}		/* Try to locate name on dir*/		if ((type = locate_file(dir, name)) == 0) {			/*			 * No directory or file named name has been found on			 * dir.			 */			return(0);		}		/*		 * Now, the true name including the name has been set		 * to dir by locate_file.		 */E 50	}D 50	if(searchdir(pathname, save_name+1) == 0)		return(0);	else		return(1);E 50I 50	strcpy(path, dir);	return(type);E 50}I 50		/* * Name:	locate_file * * Argument:	char	*dir	The existing directory name.  Does not include *				the trail delimiter. *				 *		char	*name	The name which is searched on dir. *				 * Value:	If name is recognized as an existing diretory, returns -1, *		recognized as an existing file, returns 1, otherwise 0. * * Side Effect:	If succeed, the contents of dir is replaced with the true name *		including name. * * Description: * * Try to find the file or directory specified with name on the directory * specified with dir.  The search is case insensitve. * */E 50D 50searchdir(path, file)char	*path;D 25D 29char	*file;	/* UPCASEd name without '/' */E 29I 29register char	*file;	/* UPCASEd name without '/' */E 50I 50locate_file(dir, name)	register char	*dir;	register char	*name;E 50E 29E 25I 25D 30register char	*file;	/* UPCASEd name without '/' */E 30E 25{D 25D 29int	len;DIR	*dirp;E 29I 29D 50register int	len;register DIR	*dirp;register struct direct	*dp;E 29E 25I 25D 30register int	len;register DIR	*dirp;register struct direct	*dp;E 30E 25char	dirname[MAXPATHLEN];I 41#ifdef	FSERRORE 50I 50	char		path[MAXPATHLEN];	char		nb1[MAXNAMLEN], nb2[MAXNAMLEN];	register int	type, len;	DIR		*dirp;	struct direct	*dp;E 50D 53	ERRSETJMP(0);D 50#elseE 41D 25D 29struct direct	*dp;E 29I 29	SETJMP(0);I 41#endifE 41E 29E 25I 19D 30	SETJMP(0);E 30E 19	len = strlen(file);D 11	dirp = opendir(path);E 11I 11	TIMEOUT( dirp=opendir(path) );E 11D 8	if(dirp == NULL)E 8I 8	if(dirp == NULL){I 40#ifdef	FSERRORE 50I 50	E 53	/* First of all, recognize as if. */	sprintf(path, "%s/%s", dir, name);	DIR_OR_FILE_P(path, type);	if (type != 0) {		strcpy(dir, path);		return(type);	}	/* Next try with all lower case name. */	strcpy(nb1, name);	DOWNCASE(nb1);	sprintf(path, "%s/%s", dir, nb1);	DIR_OR_FILE_P(path, type);	if (type != 0) {		strcpy(dir, path);		return(type);	}	/* Next try with all upper case name. */	UPCASE(nb1);	sprintf(path, "%s/%s", dir, nb1);	DIR_OR_FILE_P(path, type);	if (type != 0) {		strcpy(dir, path);		return(type);	}	/* No way.  Read dir and compare with name. */	len = strlen(name);D 52	dirp = opendir(dir);	/* TIMOUT is needed */E 52I 52	TIMEOUT(dirp = opendir(dir));E 52	if (dirp == NULL) {E 50		*Lisp_errno = errno;D 50#endifE 50E 40D 12		printf("error:opendir\n");E 12E 8		return(0);I 8	}E 8D 11	for(dp=readdir(dirp); dp!=NULL; dp=readdir(dirp))E 11I 11D 50	for(S_TOUT(dp=readdir(dirp)); dp!=NULL; S_TOUT(dp=readdir(dirp)) )E 11		if(dp->d_namlen==len){			strcpy(dirname, dp->d_name);			UPCASE(dirname);			if(STREQ(dirname, file)){				sprintf(path, "%s/%s", path, dp->d_name);D 11				closedir(dirp);E 11I 11				TIMEOUT( closedir(dirp) );E 11				return(1);E 50I 50	for(S_TOUT(dp = readdir(dirp)); dp != NULL; S_TOUT(dp = readdir(dirp))) {		if (dp->d_namlen == len) {			strcpy(nb2, dp->d_name);			UPCASE(nb2);			if (strcmp(nb1, nb2) == 0) {				sprintf(path, "%s/%s", dir, dp->d_name);				DIR_OR_FILE_P(path, type);				if (type != 0) {					strcpy(dir, path);I 52					TIMEOUT(closedir(dirp));E 52					return(type);				}E 50			}		}D 11	closedir(dirp);E 11I 11D 50	TIMEOUT( closedir(dirp) );E 11	return(0);E 50I 50	}	TIMEOUT(closedir(dirp));I 54	return(0);E 54E 50}I 54E 54I 17D 50parseversion(name, version)D 25D 29char	*name;			/* UNIX format, .~#~ */char	*version;		/* Result is "123" or "123%%" like this */E 29I 29register char	*name;			/* UNIX format, .~#~ */register char	*version;		/* Result is "123" or "123%%" like this */E 50I 50/* * Name:	make_directory * * Argument:	char	*dir	The full directory name in UNIX format.  It does *				not include a tail delimiter. *				 * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	The directory specified as dir will be created in the file system. *		If succeed, dir will be replaced with the true name of the directory. * * Description: * * Try to create a specified directory. * */make_directory(dir)	register char	*dir;E 50E 29E 25I 25D 30register char	*name;			/* UNIX format, .~#~ */register char	*version;		/* Result is "123" or "123%%" like this */E 30E 25{D 25D 29char	*cp, *cp1;int	length;E 29I 29D 50register char	*cp, *cp1;register int	length;E 29E 25I 25D 30register char	*cp, *cp1;register int	length;E 30E 25	for(cp=name;;++cp){		switch(*cp){		case '.':			if(*(cp+1)=='~' && (cp1=index(cp+2, '~'))!=0){				*cp = '\0';				length = (int)cp1 - (int)cp - 2;				if(length == 0){					version[0] = '0';					version[1] = '\0';					return;				}else{					strncpy(version, cp+2, length);					version[length] = '\0';					strcat(version, cp1+1);					return;E 50I 50	register char	*cp, *dp;	register int	maked, rval;	char		dir_buf[MAXPATHLEN];D 53	ERRSETJMP(0);	E 53	maked = 0;		dp = dir_buf;	*dp++ = '/';		/* For a root directory. */	cp = dir + 1;		/* Skip a root directory in dir. */		for (;;) {		switch (*cp) {		      case '/':		      case '\0':			*dp = '\0';			/*			 * Now, dir_buf contains the absolute path to the next			 * subdirectory or file.  If one of the parent directories			 * are created, we have to create a new subdirectory			 * anyway.  If all of the parent directories are exisiting			 * directories, we have to check this subdirectory is an			 * exisiting or not.			 */			if (maked) {				TIMEOUT(rval = mkdir(dir_buf, 0777));				if (rval == -1) {					*Lisp_errno = errno;					return(0);E 50				}D 50			}else				break;D 25D 29#ifdef	OLD_VERSION_CONVENTION		case '~':			if( (cp1=index(cp+1, '~'))!=0 ){				*cp++ = '\0';				length = (int)cp1 - (int)cp;				if(length == 0){					version[0] = '0';					version[1] = '\0';					return;				}else{					strncpy(version, cp, length);					version[length] = '\0';					return;				}			}else				break;#endifE 29E 25		case '\0':			version[0] = '0';			version[1] = '\0';			return;E 50I 50				if (*cp == '\0') {					strcpy(dir, dir_buf);					return(1);				}				*dp++ = '/';			        cp++;			} else {				switch (true_name(dir_buf)) {				      case -1: /* Directory */					if (*cp == '\0') {						/* Every subdirectories are examined. */						strcpy(dir, dir_buf);						return(1);					} else {						dp = dir_buf;						while (*dp) dp++;						*dp++ = '/';						cp++;					}					break;				      case 1: /* Regular File */					/*					 * UNIX does not allow to make a directory					 * and a file in the same name on a directory.					 */					return(0);				      default:					/*					 * Should handle other cases. (special file).					 */					TIMEOUT(rval = mkdir(dir_buf, 0777));					if (rval == -1) {						*Lisp_errno = errno;						return(0);					}					if (*cp == '\0') return(1);					*dp++ = '/';					cp++;					maked = 1;					break;				}			}			break;		      default:			*dp++ = *cp++;			break;E 50		}	}D 52}D 50DSK_readpage()E 50I 50/*		 * Name:	numeric_string_p * * Argument:	char	*str	String. * * Value:	If str is constructed only with numeric characters, returns 1, *		otherwise 0. * * Side Effect:	None. * * Description: * * Check if the argument string is constructed only with numeric characters or * not. * */numeric_string_p(str)	char	*str;E 50{D 50/* Old entry */E 50I 50	register char	*cp;	if (*str == '\0') return(0);	for(cp = str; *cp!='\0'; ++cp)	  if(*cp < '0' || '9' < *cp)	    return(0);	return(1);E 52E 50}D 50DSK_writepage()		{/* Old entry */E 50I 50/*		 * Name:	FindHighestVersion * * Argument:	FileName *varray *				The version array.  It has to include at *				least one versioned file. *		FileName *mentry *				The place where an entry in varray corresponding *				to the highest versioned file will be stored. *		int	max_no	The place where the version number of the highest *				versioned file will be stored. * * Value:	N/A * * Side Effect:	mentry and max_no will be replaced with the highset versioned entry *		and highest version number respectively. * * Description: * * Find the highest versioned entry in varray.  Varray has to include at least * one versioned file, that is varray has to satisfy (!NoFileP(varray) && * !OnlyVersionlessP(varray)). * */#define FindHighestVersion(varray, mentry, max_no){				\										\	register FileName	*centry;					\	for (centry = varray, max_no = 0; centry->version_no != LASTVERSIONARRAY; \	     centry++) {							\		if (centry->version_no > max_no) {				\			max_no = centry->version_no;				\			mentry = centry;					\		}								\	}									\E 50}D 50DSK_getsize(){/* Old entry */E 50I 50/*		 * Name:	FindLowestVersion * * Argument:	FileName *varray *				The version array.  It has to include at *				least one versioned file. *		FileName *mentry *				The place where an entry in varray corresponding *				to the lowest versioned file will be stored. *		int	min_no	The place where the version number of the highest *				versioned file will be stored. * * Value:	N/A * * Side Effect:	mentry and min_no will be replaced with the lowest versioned entry *		and lowest version number respectively. * * Description: * * Find the lowest versioned entry in varray.  Varray has to include at least * one versioned file, that is varray has to satisfy (!NoFileP(varray) && * !OnlyVersionlessP(varray)). * */#define FindLowestVersion(varray, mentry, min_no){				\										\	register FileName	*centry;					\	for (centry = varray, min_no = MAXVERSION;				\	     centry->version_no != LASTVERSIONARRAY; centry++) {		\		if (centry->version_no < min_no && centry->version_no != 0) {	\			min_no = centry->version_no;				\			mentry = centry;					\		}								\	}									\E 50}D 50DSK_currentdir(){/* Old entry */E 50I 50/*		 * Name:	FindSpecifiedVersion * * Argument:	FileName *varray *				The version array.  It has to include at *				least one versioned file. *		FileName *sentry *				The place where an entry in varray corresponding *				to the file which has the specified version will *				be stored. *		int	ver_no	The version number to be found. * * Value:	N/A * * Side Effect:	sentry will be replaced with the specified versioned entry. * * Description: * * Find the specified versioned entry in varray. Varray has to include at least  * one versioned file, that is varray has to satisfy (!NoFileP(varray) && * !OnlyVersionlessP(varray)). * */#define FindSpecifiedVersion(varray, sentry, ver_no){				\										\	register FileName	*centry;					\										\	sentry = (FileName *)NULL;						\	for (centry = varray; centry->version_no != LASTVERSIONARRAY; centry++) \	  if (centry->version_no == ver_no) {					\		  sentry = centry;						\		  break;							\	  }									\E 50}E 17D 13getoldfile(path, file, version)E 13I 13D 50getoldfile(path, file, version, ver_field)E 13char	*path;D 17char	*file;E 17I 17D 25D 29char	*file;		/* file does not have version filed, foo.c */E 17int	version;	/* version == 0 : file does not have version number */E 29I 29register char	*file;		/* file does not have version filed, foo.c */register int	version;	/* version == 0 : file does not have version number */E 29E 25I 25D 30register char	*file;		/* file does not have version filed, foo.c */register int	version;	/* version == 0 : file does not have version number */E 30E 25I 13D 17char	*ver_field;		/* Some character may be added after number, like ;2% */E 17I 17char	*ver_field;	/* Some character may be added after number, like ;2% */E 50I 50/*		 * Name:	get_version_array * * Argument:	char	*dir	UNIX directory specified absolutely.  The caller *				must be make sure that this directory exists. *		char	*file	File name which can include version field. *				Version field is following UNIX convention, *				that is "name.~##~", not Xerox Lisp one. *				The versionless file name is also acceptable. *		FileName *varray *				The place where collected version array *				will be stored. *		CurrentVArray *cache *				The place which holds the infomation about *				just collected version array. * * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	varray will be replaced with new version information. * * Description: * * Reading dir and gather all files which match with file into varray. * Although dir name must be in the same case as the existing directory, * file name matching is case insensitive. * The versiionless file, the file which has no version field, will be indicated * by setting 0 as a value of version_no field in FileName structure. * */get_version_array(dir, file, varray, cache)	register char		*dir;	register char		*file;	register FileName	*varray;	register CurrentVArray	*cache;E 50E 17E 13{I 26D 50register FileName	*p_version_array;E 26I 25register FileName	*p_version_high;register FileName	*p_version_less;D 26register FileName	*p_version;E 26I 26FileName	*p_version;E 26char		name[MAXPATHLEN];char		ver[VERSIONLEN];E 50I 50	char			lcased_file[MAXNAMLEN];	char			name[MAXNAMLEN];	char			ver[VERSIONLEN];	register FileName	*svarray;	register DIR		*dirp;	register struct direct	*dp;	register int		rval;	struct stat		sbuf;	D 53	ERRSETJMP(0);	E 53	/*	 * First of all, prepare a lower cased file name for the case insensitve	 * serch.  Also we have to separate file name from its version field.	 */	strcpy(lcased_file, file);	separate_version(lcased_file, ver, 1);	DOWNCASE(lcased_file);E 50E 25I 17D 26D 29FileName	version_array[VERSIONARRAYLENGTH];E 26D 25FileName	*p_version_high;FileName	*p_version_less;E 29I 29D 30register FileName	*p_version_array;register FileName	*p_version_high;register FileName	*p_version_less;E 29FileName	*p_version;E 17D 29char	name[MAXPATHLEN];D 17char	save_file[MAXPATHLEN];E 17char	ver[VERSIONLEN];E 29I 29char		name[MAXPATHLEN];char		ver[VERSIONLEN];E 30E 29E 25D 17DIR	*dirp;struct direct	*dp;D 13int	v;char	*cp;E 13I 11int	rval;E 17I 17I 53/*E 53I 19D 28	SETJMP(0);E 28I 23D 25E 25E 23E 19D 50/* version number is not specified */E 17E 11D 9	if(version == 0){E 9I 9	if(version == MAXVERSION){E 9		return(getnewestfile(path, file));E 50I 50	TIMEOUT(rval = stat(dir, &sbuf));	if (rval == -1) {		*Lisp_errno = errno;		return(0);E 50	}I 53*/E 53I 9D 17	if(version == 0){		sprintf(save_file,"%s/%s",path, file);D 11		if( access(save_file, F_OK) == 0){E 11I 11		TIMEOUT( rval=access(save_file, F_OK) );		if( rval == 0){E 11			sprintf(file,"%s;%d",file, version);E 17I 17D 50/* version number is specifed */D 26D 29	if(LookUpFileVersion(path, file, version_array) == 0)E 29I 29	p_version_array = VersionArray;	if(LookUpFileVersion(path, file, p_version_array, &VArrayInfo) == 0)E 50I 50	/*	 * If the cached version array is still valid, we can return immediately.	 */	/*D 53	 * Cache machanism is invalid now, because of the strange behavior of	 * UNIX.  Sometimes even after we unlink some file on a directory, the st_mtime	 * of the directory stat structure does not change.  sync(2) has no effect on	 * such case.E 53I 53	 * Cache machaisme is not used now, because of the bug of Sun OS.	 * Sometimes just after unlinking a file on a directory, the st_mtime	 * of the directory does not change.  This will make Maiko beleive	 * cached version array is still valid, although it is already invalid.	 * sync(2) has no effect on such case.E 53	 */I 53E 53/*	if ((sbuf.st_mtime == cache->mtime) && strcmp(dir, cache->path) == 0	    && strcmp(lcased_file, cache->file) == 0) return(1);*/	    	TIMEOUT(dirp = opendir(dir));	if (dirp == NULL) {		*Lisp_errno = errno;E 50E 29E 26I 26D 30	p_version_array = VersionArray;	if(LookUpFileVersion(path, file, p_version_array, &VArrayInfo) == 0)E 30E 26		return(0);D 26D 29	if(NoFileP(version_array)){E 29I 29D 50	if(NoFileP(p_version_array)){E 29E 26I 26D 30	if(NoFileP(p_version_array)){E 30E 26		/* No file exist */		return(0);E 50	}D 26D 29	p_version_high = GetHighestVersion(version_array);	if(p_version_high && (p_version_less=VersionlessP(version_array)) && CheckOnlyNumber(ver_field)){			/* version 0 exist, and version shoud be changed */E 29I 29D 50	p_version_high = GetHighestVersion(p_version_array);	if(p_version_high && (p_version_less=VersionlessP(p_version_array)) && CheckOnlyNumber(ver_field)){			/* version 0 exist, and version shoud be changed */E 29E 26I 26D 30	p_version_high = GetHighestVersion(p_version_array);	if(p_version_high && (p_version_less=VersionlessP(p_version_array)) && CheckOnlyNumber(ver_field)){			/* version 0 exist, and version shoud be changed */E 30E 26		if(LinkWithVersionlessP(path, p_version_high->name)){			/* Highest link with versionless */			if( version==0 || version==p_version_high->version_no){				/* return highest name */				strcpy(file, p_version_high->name);				UnixVersionToLispVersion(file);				AddDodNoExtention(file);				return(1);E 50I 50	for (S_TOUT(dp = readdir(dirp)), svarray = varray; dp != NULL;	     S_TOUT(dp = readdir(dirp))) { 		strcpy(name, dp->d_name);		separate_version(name, ver, 1);		DOWNCASE(name);		if (strcmp(name, lcased_file) == 0) {			/*			 * This file can be regarded as a same file in Lisp sense.			 */			strcpy(svarray->name, dp->d_name);			if (*ver == '\0') {				/* Versionless file */				svarray->version_no = 0;			} else {				/*				 * separater_version guranteeds ver is a numeric				 * string.				 */				svarray->version_no = atoi(ver);E 50			}D 50		}else{			/* Highest does not link with versionleess */					if(version==0 || version==(p_version_high->version_no)+1 ){				/* versionless will be renamed to highest+1 */				sprintf(file, "%s.~%d~", p_version_less->name,(p_version_high->version_no)+1 );				UnixVersionToLispVersion(file);				AddDodNoExtention(file);				return(1);			}E 50I 50			svarray++;E 50		}	}D 50	/* versionless NOT exist, or NOT link, or version is NOT 0 or highest+1 */D 26D 29	for(p_version=version_array;p_version->version_no!=LASTVERSIONARRAY;++p_version){E 29I 29	for(p_version=p_version_array;p_version->version_no!=LASTVERSIONARRAY;++p_version){E 29E 26I 26D 30	for(p_version=p_version_array;p_version->version_no!=LASTVERSIONARRAY;++p_version){E 30E 26		strcpy(name, p_version->name );		parseversion(name, ver);		if( STREQ(ver, ver_field) ){			strcpy(file, p_version->name );			UnixVersionToLispVersion(file);			AddDodNoExtention(file);E 17			return(1);		}E 50I 50	/*	 * The last entry of varray is indicated by setting LASTVERSIONARRAY into	 * version_no field.	 */	svarray->version_no = LASTVERSIONARRAY;	/*	 * If more than one files have been stored in varray, we store the name	 * without version in the last marker entry.	 */	if (!NoFileP(varray)) {		strcpy(name, varray->name);		separate_version(name, ver, 1);		strcpy(svarray->name, name);E 50	}E 9D 17	/* check with case sensitiveness */I 9#ifdef	OLD_VERSION_CONVENTIONE 9D 13	sprintf(save_file,"%s/%s~%d~",path, file, version);E 13I 13	sprintf(save_file,"%s/%s~%s~",path, file, ver_field);E 13D 11	if( access(save_file, F_OK) == 0){E 11I 11	TIMEOUT( rval=access(save_file, F_OK) );	if( rval == 0){E 11D 13		sprintf(file,"%s;%d",file, version);E 13I 13		sprintf(file,"%s;%s",file, ver_field);E 13		return(1);E 17I 17D 50	return(0);}E 50D 50CheckOnlyNumber(name)char	*name;{register char	*cp;	for(cp=name; *cp!='\0';++cp)		if( *cp>'9' || *cp<'0' )			return(0);E 50I 50	/*	 * Update cache information.	 *//*	strcpy(cache->path, dir);	strcpy(cache->file, lcased_file);	cache->mtime = sbuf.st_mtime;*/	TIMEOUT(closedir(dirp));E 50	return(1);}I 50	/*		 * Name:	maintain_version * * Argument:	char	*file	The full file name in UNIX format. *		FileName *varray *				The version array. *		int	forcep	If 1, a versionless file will be linked to version *				1 file when there is no other files having the same *				name. * * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	None. * * Description: * * Try to make sure that the version control based on the name convention * is well maintained.  The versionless file corresponding to file will be * maintained.  The second argument varray is an optional.  If it is not * NULL pointer, maintain_version maintains the version control using the * version array.  If varray is NULL pointer, a version array is re collected * by this routine. * Currently, forcep is 1 only if maintain_version is called from COM_openfile * to maintain the directory on which a file is being created. */E 50D 50getnewestfile(path, file)D 25char	*path;D 29char	*file;		/* No version field */E 29I 29D 30register char	*file;		/* No version field */E 30E 29E 25I 25D 26register char	*path;E 26I 26char	*path;E 26register char	*file;		/* No version field */E 50I 50maintain_version(file, varray, forcep)	register char		*file;	register FileName	*varray;	register int		forcep;E 50E 25{I 26D 50register FileName	*p_version_array;E 26I 25register FileName	*p_version_high;register FileName	*p_version_less;E 25D 26D 29FileName	version_array[VERSIONARRAYLENGTH];D 25FileName	*p_version_high;FileName	*p_version_less;E 25	if(LookUpFileVersion(path, file, version_array) == 0)E 29I 29D 30register FileName	*p_version_array;register FileName	*p_version_high;register FileName	*p_version_less;E 30	p_version_array = VersionArray;	if(LookUpFileVersion(path, file, p_version_array, &VArrayInfo) == 0)E 29E 26I 26D 30	p_version_array = VersionArray;	if(LookUpFileVersion(path, file, p_version_array, &VArrayInfo) == 0)E 30E 26		return(0);D 26D 29	if(NoFileP(version_array)){E 29I 29	if(NoFileP(p_version_array)){E 29E 26I 26D 30	if(NoFileP(p_version_array)){E 30E 26		/* No file exist */		return(0);	}else{D 26D 29		if( (p_version_high = GetHighestVersion(version_array)) == 0)E 29I 29		if( (p_version_high = GetHighestVersion(p_version_array)) == 0)E 29E 26I 26D 30		if( (p_version_high = GetHighestVersion(p_version_array)) == 0)E 30E 26			return(0);D 26D 29		if(p_version_less = VersionlessP(version_array)){E 29I 29		if(p_version_less = VersionlessP(p_version_array)){E 29E 26I 26D 30		if(p_version_less = VersionlessP(p_version_array)){E 30E 26			/* version 0 is newest */			if(LinkWithVersionlessP(path, p_version_high->name)){				/* Highest link with versionless */				strcpy(file, p_version_high->name );				UnixVersionToLispVersion(file);				AddDodNoExtention(file);				return(1);			}else{				/* Versionless has no link */				sprintf(file, "%s;%d", p_version_less->name, p_version_high->version_no+1);				AddDodNoExtention(file);				return(1);			}		}else{			/* highest version is newest */			strcpy(file, p_version_high->name );			UnixVersionToLispVersion(file);			AddDodNoExtention(file);			return(1);		}E 17	}I 9D 17#endifD 13	sprintf(save_file,"%s/%s.~%d~",path, file, version);E 13I 13	sprintf(save_file,"%s/%s.~%s~",path, file, ver_field);E 13D 11	if( access(save_file, F_OK) == 0){E 11I 11	TIMEOUT( rval=access(save_file, F_OK) );	if( rval == 0){E 11D 13		sprintf(file,"%s;%d",file, version);E 13I 13		sprintf(file,"%s;%s",file, ver_field);E 17I 17}	E 50I 50	char			dir[MAXPATHLEN], fname[MAXNAMLEN], ver[VERSIONLEN];	char			old_file[MAXPATHLEN], vless[MAXPATHLEN];	int			highest_p;	register int		rval, max_no;	register FileName	*entry;E 50D 50getnewfile(path, file)D 25D 29char	*path;char	*file;		/* No version name, foo.c */E 29I 29register char	*path;register char	*file;		/* No version name, foo.c */E 29E 25I 25D 30register char	*path;register char	*file;		/* No version name, foo.c */E 30E 25{I 25register FileName	*p_version_high;E 25D 26D 29FileName	version_array[VERSIONARRAYLENGTH];E 26I 26register FileName	*p_version_array;E 26D 25FileName	*p_version_high;FileName	*p_version_less;E 29I 29D 30register FileName	*p_version_high;E 30register FileName	*p_version_array;E 50I 50D 53	ERRSETJMP(0);E 50E 29E 25	E 53D 26D 29	if(LookUpFileVersion(path, file, version_array) == 0){E 29I 29D 50	p_version_array = VersionArray;	if(LookUpFileVersion(path, file, p_version_array, &VArrayInfo) == 0){E 29E 26I 26D 30	p_version_array = VersionArray;	if(LookUpFileVersion(path, file, p_version_array, &VArrayInfo) == 0){E 30E 26		/* new file is versionless */		sprintf(file, "%s;%d", file, 1);E 17I 15		AddDodNoExtention(file);E 15E 13		return(1);E 50I 50	if (varray == (FileName *)NULL) {		if (unpack_filename(file, dir, fname, ver, 1) == 0) return(0);		/*		 * We have to make sure that dir is the existing directory.		 */		if (true_name(dir) != -1) return(0);		if (get_version_array(dir, fname, VersionArray, &VArrayInfo) == 0)		  return(0);		varray = VersionArray;E 50	}E 9D 17	/* check with case in-sensitiveness */	strcpy(save_file, file);	DOWNCASE(save_file);D 11	dirp = opendir(path);E 11I 11	TIMEOUT( dirp = opendir(path) );E 11	if(dirp == NULL)		return(0);D 11	for(dp=readdir(dirp); dp!=NULL; dp=readdir(dirp)){E 11I 11	for(S_TOUT(dp=readdir(dirp)); dp!=NULL; S_TOUT(dp=readdir(dirp)) ){E 11		strcpy(name, dp->d_name);		parseversion(name, ver);		DOWNCASE(name);D 13		v = atoi(ver);		if( (v == version) && STREQ(save_file, name) ){E 13I 13		if( STREQ(ver, ver_field) && STREQ(save_file, name) ){E 13				strcpy(file, dp->d_name);				UnixVersionToLispVersion(file);E 17I 17D 26D 29	if(NoFileP(version_array)){E 29I 29D 50	if(NoFileP(p_version_array)){E 29E 26I 26D 30	if(NoFileP(p_version_array)){E 30E 26		/* new file is versionless */		sprintf(file, "%s;%d", file, 1);		AddDodNoExtention(file);E 50I 50	if (NoFileP(varray)) {		/*		 * We don't need to care about such case that there is no such file		 * or an only versionless file exists.		 */E 50		return(1);D 50	}else{D 26D 29		if( (p_version_high=GetHighestVersion(version_array)) == 0 ){E 29I 29		if( (p_version_high=GetHighestVersion(p_version_array)) == 0 ){E 29E 26I 26D 30		if( (p_version_high=GetHighestVersion(p_version_array)) == 0 ){E 30E 26			/* new file is versionless */			sprintf(file, "%s;%d", file, 1);			AddDodNoExtention(file);			return(1);		}D 25D 29		if(p_version_less = VersionlessP(version_array)){E 29I 29		if(VersionlessP(p_version_array)){E 29E 25I 25D 26		if(VersionlessP(version_array)){E 26I 26D 30		if(VersionlessP(p_version_array)){E 30E 26E 25			/* versionless exists  */			if(LinkWithVersionlessP(path, p_version_high->name)){				/* Highest link with versionless */				/* newfile is highest+1 */				sprintf(file, "%s;%d", file, (p_version_high->version_no+1));E 17I 15				AddDodNoExtention(file);E 15D 11				closedir(dirp);E 11I 11D 17				TIMEOUT( closedir(dirp) );E 17E 11				return(1);I 17			}else{				/* Versionless has no link */				/* newfile is highest+2, versionless->highest+1 */				sprintf(file, "%s;%d", file, (p_version_high->version_no+2));				AddDodNoExtention(file);				return(1);E 50I 50	}	if (OnlyVersionlessP(varray)) {		if (forcep) {			/*			 * If forcep, we link the versionless file to the version			 * 1 file.			 */			get_versionless(varray, vless, dir);			ConcNameAndVersion(vless, "1", fname);			TIMEOUT(rval = link(vless, fname));			if (rval == -1) {				*Lisp_errno = errno;				return(0);E 50			}D 50		}else{			/* new file is highest+1 */			sprintf(file, "%s;%d", file, (p_version_high->version_no+1));			AddDodNoExtention(file);			return(1);E 50E 17		}I 50		return(1);E 50	}D 11	closedir(dirp);E 11I 11D 17	TIMEOUT( closedir(dirp) );E 11	return(0);E 17D 50}E 50D 17getnewestfile(path, file)E 17I 17D 50getoldestfile(path, file)E 17char	*path;D 25D 29char	*file;E 29I 29register char	*file;E 29E 25I 25D 30register char	*file;E 30E 25{I 25register FileName	*p_version_low;E 25I 17D 26D 29FileName	version_array[VERSIONARRAYLENGTH];D 25FileName	*p_version_low;E 25		if(LookUpFileVersion(path, file, version_array) == 0){E 29I 29D 30register FileName	*p_version_low;E 30register FileName	*p_version_array;	p_version_array = VersionArray;	if(LookUpFileVersion(path, file, p_version_array, &VArrayInfo) == 0)E 29E 26I 26D 30register FileName	*p_version_array;	p_version_array = VersionArray;	if(LookUpFileVersion(path, file, p_version_array, &VArrayInfo) == 0)E 30E 26		return(0);D 26D 29	}	if(NoFileP(version_array)){E 29I 29	if(NoFileP(p_version_array)){E 29E 26I 26D 30	if(NoFileP(p_version_array)){E 30E 26		/* No file exist */		return(0);	}else{D 26D 29		if(( p_version_low=GetLowestVersion(version_array)) == 0 ){E 29I 29		if(( p_version_low=GetLowestVersion(p_version_array)) == 0 ){E 50I 50	/*	 * At this point, we are sure that at least one file with version number	 * exists.  Thus, FindHighestVersion works fine from now on.	 */	if (get_versionless(varray, vless, dir) == 0) {		/*		 * There is not a versionless file, but at least one versioned file.		 * Thus, the thing we have to do is to link a versionless file		 * to the existing highest versioned file.		 */		FindHighestVersion(varray, entry, max_no);		ConcDirAndName(dir, entry->name, old_file);		/*		 * The versionless file should have the same case name as the old		 * file.		 */		strcpy(fname, entry->name);		separate_version(fname, ver, 1);		ConcDirAndName(dir, fname, vless);		TIMEOUT(rval = link(old_file, vless));		if (rval == -1) {			*Lisp_errno = errno;E 50E 29E 26I 26D 30		if(( p_version_low=GetLowestVersion(p_version_array)) == 0 ){E 30E 26			return(0);		}D 50		if( p_version_low->version_no == 0){			sprintf(file, "%s;1", p_version_low->name );			AddDodNoExtention(file);			return(1);		}else{			strcpy(file, p_version_low->name );			UnixVersionToLispVersion(file);			AddDodNoExtention(file);			return(1);		}E 50I 50		return(1);E 50	}D 50}E 50D 50checklink_and_changeversion(pathname)D 25D 29char	*pathname;	/* Lisp convetion, /users/hayata/foo.c;3, /foo.c or /foo.c;0 */E 29I 29register char	*pathname;	/* Lisp convetion, /users/hayata/foo.c;3, /foo.c or /foo.c;0 */E 29E 25I 25D 30register char	*pathname;	/* Lisp convetion, /users/hayata/foo.c;3, /foo.c or /foo.c;0 */E 30E 25{I 29register FileName	*p_version_array;register FileName	*p_version;register FileName	*p_version_high;register int	ver_no;E 29I 26D 30register FileName	*p_version_array;E 26I 25register FileName	*p_version;register FileName	*p_version_high;register int	ver_no;E 30E 25char	path[MAXPATHLEN];E 17char	name[MAXPATHLEN];D 17char	save_file[MAXPATHLEN];DIR	*dirp;struct direct	*dp;char	ver[VERSIONLEN];int	v;int	max = -1;	strcpy(save_file, file);	DOWNCASE(save_file);D 11	dirp = opendir(path);E 11I 11	TIMEOUT( dirp = opendir(path) );E 11	if(dirp == NULL)E 17I 17char	file[MAXPATHLEN];char	version[VERSIONLEN];char	version2[VERSIONLEN];E 50I 50	if (check_vless_link(vless, varray, old_file, &highest_p) == 0) return(0);E 50D 26D 29FileName	version_array[VERSIONARRAYLENGTH];E 26D 25FileName	*p_version;FileName	*p_version_high;int	ver_no;E 29E 25D 50	if(parse(pathname, path, file, version) == 0)	/* file: /foo.c, verion: 2 */E 17		return(0);D 11	for(dp=readdir(dirp); dp!=NULL; dp=readdir(dirp)){E 11I 11D 17	for(S_TOUT(dp=readdir(dirp)); dp!=NULL; S_TOUT(dp=readdir(dirp)) ){E 11		strcpy(name, dp->d_name);		parseversion(name, ver);		DOWNCASE(name);		v = atoi(ver);		if( STREQ(save_file, name) ){			if(v > max){				max = v;				strcpy(file, dp->d_name);E 17I 17	ver_no = atoi(version);D 26D 29	if(LookUpFileVersion(path, file+1, version_array) == 0){E 26I 26	p_version_array = VersionArray;	if(LookUpFileVersion(path, file+1, p_version_array, &VArrayInfo) == 0){E 26D 20		/* No file, no need to change */E 29I 29	p_version_array = VersionArray;	if(LookUpFileVersion(path, file+1, p_version_array, &VArrayInfo) == 0){		/* versionless NOT exist. version 1 is specified. It means version1 should be versionless */		if(ver_no == 1 && STREQ("1", version)){			ChangeToVersionless(pathname);			return(1);E 50I 50	if (*old_file == '\0') {		/*		 * The versionless file is not linked to any file in varray.		 * Thus, we have to link the versionless file to the file which		 * is versioned one higher than the exisiting highest version.		 */		FindHighestVersion(varray, entry, max_no);		sprintf(ver, "%d", max_no + 1);		/*		 * The old file should have the same case name as the versionless		 * file.		 */		ConcNameAndVersion(vless, ver, old_file);		TIMEOUT(rval = link(vless, old_file));		if (rval == -1) {			*Lisp_errno = errno;			return(0);E 50		}D 50		/* No file not version 1, no need to change */E 50E 29E 20I 20D 30		/* versionless NOT exist. version 1 is specified. It means version1 should be versionless */		if(ver_no == 1 && STREQ("1", version)){D 21			if(p_version_high->version_no == 0){				ChangeToVersionless(pathname);				return(1);			}E 21I 21			ChangeToVersionless(pathname);			return(1);E 21		}		/* No file not version 1, no need to change */E 30E 20		return(1);	}D 26D 29	if(NoFileP(version_array)){E 26I 26	if(NoFileP(p_version_array)){E 26D 20		/* No file, no need to change */E 29I 29D 50	if(NoFileP(p_version_array)){		/* versionless NOT exist. version 1 is specified. It means version1 should be versionless */		if(ver_no == 1 && STREQ("1", version)){			ChangeToVersionless(pathname);			return(1);		}		/* No file not version 1, no need to change */E 50I 50	if (highest_p) {		/*		 * The versionless file has been already linked to the highest		 * versioned file.  Thus, there is nothing to do.		 */E 50E 29E 20I 20D 30		/* versionless NOT exist. version 1 is specified. It means version1 should be versionless */		if(ver_no == 1 && STREQ("1", version)){D 21			if(p_version_high->version_no == 0){				ChangeToVersionless(pathname);				return(1);			}E 21I 21			ChangeToVersionless(pathname);			return(1);E 21		}		/* No file not version 1, no need to change */E 30E 20		return(1);D 50	}I 20	/* check, specified version file exist. if exist, return 1 */E 20D 26D 29	for(p_version=version_array;p_version->version_no!=LASTVERSIONARRAY;++p_version){E 29I 29D 30	/* check, specified version file exist. if exist, return 1 */E 30	for(p_version=p_version_array;p_version->version_no!=LASTVERSIONARRAY;++p_version){E 29E 26I 26D 30	for(p_version=p_version_array;p_version->version_no!=LASTVERSIONARRAY;++p_version){E 30E 26		if(p_version->version_no == ver_no){			strcpy(name, p_version->name );			parseversion(name, version2);			if( STREQ(version2, version) )				/* The specified file exist */				return(1);E 50I 50	} else {		/*		 * Although the  versionless file is linked to a file in varray,		 * the file is not the highest versioned file.  We have to unlink		 * the wrongly linked versionless file, and link the highest versioned		 * file to a versionless file.		 */		TIMEOUT(rval = unlink(vless));		if (rval == -1) {			*Lisp_errno = errno;			return(0);E 50		}D 50	}	/* specified version does not exist */D 26D 29	if(VersionlessP(version_array)){		if( (p_version_high=GetHighestVersion(version_array)) == 0 )E 29I 29	if(VersionlessP(p_version_array)){		if( (p_version_high=GetHighestVersion(p_version_array)) == 0 )E 50I 50		FindHighestVersion(varray, entry, max_no);		ConcDirAndName(dir, entry->name, old_file);		/*		 * The versionless file should have the same case name as the old		 * file.		 */		strcpy(fname, entry->name);		separate_version(fname, ver, 1);		ConcDirAndName(dir, fname, vless);		TIMEOUT(rval = link(old_file, vless));		if (rval == -1) {			*Lisp_errno = errno;E 50E 29E 26I 26D 30	if(VersionlessP(p_version_array)){		if( (p_version_high=GetHighestVersion(p_version_array)) == 0 )E 30E 26			return(0);D 50		if(ver_no == 0 && STREQ("0", version)){			ChangeToVersionless(pathname);			return(1);E 50		}D 50		if(ver_no == 1 && STREQ("1", version)){			if(p_version_high->version_no == 0){I 29				/* versionless exist, versiion 1 NOT exist */E 29I 20D 30				/* versionless exist, versiion 1 NOT exist */E 30E 20				ChangeToVersionless(pathname);				return(1);E 17			}		}I 17		if(ver_no == (p_version_high->version_no)+1){			sprintf(version2, "%d", p_version_high->version_no+1);			if( STREQ(version2, version) ){				if(LinkWithVersionlessP(path, p_version_high->name)){					/* No need to change version */					return(1);				}else{					ChangeToVersionless(pathname);					return(1);				}			}		}E 50I 50		return(1);E 50E 17	}I 29D 50	/* versionless NOT exist. version 1 is specified. It means version1 should be versionless */	if(ver_no == 1 && STREQ("1", version)){		if(p_version_high->version_no == 0){			ChangeToVersionless(pathname);E 50I 50}/*		 * Name:	get_versionless * * Argument:	FileName *varray *				The version array already filled by *				get_version_array routin. *		char	*file	The place where the full file name of the found *				versionless file will be stored. *		char	*dir	Directory absolute path following the UNIX *				file naming convention on which varray *				has been gathered. * * Value:	If a versionless file found, returns 1, otherwise 0. * * Side Effect:	file will be replaced with the full name of the found versionless *		file when it is found. * * Description: * * Accepts a version array and try to find a versionless file within it. * */get_versionless(varray, file, dir)	register FileName	*varray;	register char		*file;	register char		*dir;{	if (NoFileP(varray)) return (0);		while (varray->version_no != LASTVERSIONARRAY) {		if (varray->version_no == 0) {			ConcDirAndName(dir, varray->name, file);E 50			return(1);D 50		}E 50I 50		} else		  varray++;E 50	}E 29I 20D 30	/* versionless NOT exist. version 1 is specified. It means version1 should be versionless */	if(ver_no == 1 && STREQ("1", version)){		if(p_version_high->version_no == 0){			ChangeToVersionless(pathname);			return(1);		}	}E 30E 20D 11	closedir(dirp);E 11I 11D 17	TIMEOUT( closedir(dirp) );E 11	if(max == -1)		return(0);	UnixVersionToLispVersion(file);I 15	AddDodNoExtention(file);E 17I 17D 50	/* The specified file does not exist, no need to change */E 17E 15	return(1);E 50I 50	return(0);E 50}D 17getnewfile(path, file)char	*path;char	*file;E 17I 17D 25D 29ChangeToVersionless(pathname)char	*pathname;	/* Lisp convetion, /users/hayata/foo.c;3 or /foo.c;0 */E 17{I 17char	*cp;	if( (cp=rindex(pathname, ';')) != 0)		*cp = '\0';}E 29E 25D 50makenewlink(pathname)D 25D 29char	*pathname;	/* A file to be opend, /users/hayata/foo.c.~3~ */E 29I 29register char	*pathname;	/* A file to be opend, /users/hayata/foo.c.~3~ */E 29E 25I 25D 30register char	*pathname;	/* A file to be opend, /users/hayata/foo.c.~3~ */E 30E 25{	I 29register FileName	*p_version_array;register FileName	*p_version_nhigh;register FileName	*p_version_less;register int	rval;E 29I 26D 30register FileName	*p_version_array;E 26I 25register FileName	*p_version_nhigh;register FileName	*p_version_less;register int	rval;E 30E 25char	path[MAXPATHLEN];char	path2[MAXPATHLEN];char	file[MAXPATHLEN];char	version[VERSIONLEN];E 50I 50/*		 * Name:	check_vless_link * * Argument:	char	*vless	The full file name of the versionless file in *				UNIX format. *		FileName *varray *				The version array already filled by get_version_array. *		char	*to_file *				The place where the full file name of the file *				to which the versionless file is hard linked will *				be stored. *		int	*highest_p *				If to_file is the highest versioned file in varrray, *				highest_p will point to 1, otherwise, 0. * * Value:	If succeed, returns 1, otherwise, 0. * * Side Effect:	to_file will be replaced with the full file name to which the *		versionless file is hard linked.  highest_p will be replaced with *		1 or 0. * * Description: * * Examines the link status of a specified versionless file.  If there is a file * to which the versionless file is hard linked in a version array, it will be * stored in to_file.  If there is no such file, to_file will be NULL string. * When hard linked file is found, if highest_p is 1, the file is the highest * versioned file in the version array.  This is the such case that a versionless * file is well maintained by DSK code. * Notice that even if to_file is NULL, it does not mean that the versionless file * is not hard linked to any file.  It only means that there is no file to which the * versionless file is hard linked in the version array.  The versionless file * might be hard linked to the other file entirely differently named. * */E 50D 26D 29FileName	version_array[VERSIONARRAYLENGTH];E 26D 25FileName	*p_version_nhigh;I 23FileName	*p_version_less;E 23int	rval;E 29E 25I 41D 50#ifdef	FSERRORE 50I 50check_vless_link(vless, varray, to_file, highest_p)	register char		*vless;	register FileName	*varray;	register char		*to_file;	register int		*highest_p;{	register int		rval, max_no, found;	ino_t			vless_ino;	struct stat		sbuf;	char			dir[MAXPATHLEN], name[MAXNAMLEN], ver[VERSIONLEN];	register FileName	*max_entry, *linked_entry;D 53E 50	ERRSETJMP(0);E 53D 50#elseE 41I 29	SETJMP(0);I 41#endifE 41E 29I 19D 30	SETJMP(0);E 30E 19	if(parse(pathname, path, file, version) == 0)	/* file is /foo.c.~2~ */E 50I 50	TIMEOUT(rval = stat(vless, &sbuf));	if (rval != 0) {		*Lisp_errno = errno;E 50		return(0);D 50	parseversion(file, version);	/* file is /foo.c */D 20D 29	if(*version == '0'){E 29I 29	if( STREQ(version, "0") ){E 29E 20I 20D 30	if( STREQ(version, "0") ){E 30E 20		/* open versionless file, no need to link */		return(1);E 50	}D 26D 29	if(LookUpFileVersion(path, file+1, version_array) == 0){E 29I 29D 50	p_version_array = VersionArray;	if(LookUpFileVersion(path, file+1, p_version_array, &VArrayInfo) == 0)E 50I 50	if (sbuf.st_nlink == 1) {		/* There is no file to which vless is hard linked. */		*to_file = '\0';E 50E 29E 26I 26D 30	p_version_array = VersionArray;	if(LookUpFileVersion(path, file+1, p_version_array, &VArrayInfo) == 0)E 30E 26		return(1);D 26D 29	}	if(NoFileP(version_array)){E 29I 29D 50	if(NoFileP(p_version_array)){E 29E 26I 26D 30	if(NoFileP(p_version_array)){E 30E 26		/*open versionless file, no need to link */		return(1);E 50	}D 23D 29	if(VersionlessP(version_array)){E 29I 29D 50	if(p_version_less = VersionlessP(p_version_array)){E 29E 23I 23D 26	if(p_version_less = VersionlessP(version_array)){E 26I 26D 30	if(p_version_less = VersionlessP(p_version_array)){E 30E 26E 23			/* versionless exists  */D 26D 29		if( (p_version_nhigh=GetNextHighestVersion(version_array)) == 0 )E 29I 29		if( (p_version_nhigh=GetNextHighestVersion(p_version_array)) == 0 )E 29E 26I 26D 30		if( (p_version_nhigh=GetNextHighestVersion(p_version_array)) == 0 )E 30E 26			return(1);		if(LinkWithVersionlessP(path, p_version_nhigh->name)){			/* Next highest linked with versionless */			/* unlink versionless */D 23D 29			sprintf(path, "%s%s", path, file);E 29I 29			sprintf(path, "%s/%s", path, p_version_less->name);I 41#ifdef	FSERROR			ERRSETJMP(0);#elseE 41I 39			SETJMP(0);I 41#endifE 41E 39E 29E 23I 23D 30			sprintf(path, "%s/%s", path, p_version_less->name);E 30E 23			TIMEOUT( rval = unlink(path) );			if(rval == -1){				/* can not remove */				err_mess("unlink", errno);D 18				printf("In openfile, can not unlink %s.\n", path);E 18I 18D 27D 29				printf("Can not unlink %s.\n", path);E 29I 29				OSMESSAGE_PRINT( printf("Can not unlink %s.\n", path) );E 50I 50	vless_ino = sbuf.st_ino;	if (unpack_filename(vless, dir, name, ver, 1) == 0) return(0);		max_no = 0;	found = 0;	max_entry = NULL;	linked_entry = NULL;		while (varray->version_no != LASTVERSIONARRAY) {		if (varray->version_no > max_no) {			max_no = varray->version_no;			max_entry = varray;		}		if (!found && varray->version_no != 0) {			ConcDirAndName(dir, varray->name, name);			TIMEOUT(rval = stat(name, &sbuf));			if (rval != 0) {				*Lisp_errno = errno;E 50E 29E 27I 27D 30				OSMESSAGE_PRINT( printf("Can not unlink %s.\n", path) );E 30E 27E 18				return(0);			}D 50			/* link opening file(next highest+1) with versionless */			LINK(pathname, path);I 24#ifdef	FSMESSAGEE 24D 18			printf("In openfile, %s file is linked with %s\n", pathname, path);E 18I 18D 27D 29			printf("%s is linked with %s\n", pathname, path);E 29I 29D 30#ifdef	FSMESSAGEE 30			OSMESSAGE_PRINT( printf("%s is linked with %s\n", pathname, path) );#endifE 29E 27I 27D 30			OSMESSAGE_PRINT( printf("%s is linked with %s\n", pathname, path) );E 27I 24#endifE 30E 24E 18			return(1);		}else{			/* Versionless has no link */			/* versionless is moved to next highest+1 */			sprintf(path2, "%s%s.~%d~", path, file, (p_version_nhigh->version_no)+1 );D 23D 29			sprintf(path, "%s%s", path, file);E 29I 29			sprintf(path, "%s/%s", path, p_version_less->name);I 41#ifdef	FSERROR			ERRSETJMP(0);#elseE 41I 39			SETJMP(0);I 41#endifE 41E 39E 29E 23I 23D 30			sprintf(path, "%s/%s", path, p_version_less->name);E 30E 23			TIMEOUT( rval = rename(path, path2) );			if(rval == -1){				err_mess("rename", errno);D 18				printf("In openfile, can not rename %s to %s\n", path, path2);E 18I 18D 27D 29				printf("Can not rename %s to %s\n", path, path2);E 29I 29				OSMESSAGE_PRINT( printf("Can not rename %s to %s\n", path, path2) );E 29E 27I 27D 30				OSMESSAGE_PRINT( printf("Can not rename %s to %s\n", path, path2) );E 30E 27E 18				return(0);E 50I 50			if (sbuf.st_ino == vless_ino) {				found = 1;				linked_entry = varray;E 50			}D 50			/* link opening file(next highest+2) with versionless */			LINK(pathname, path);I 24#ifdef	FSMESSAGEE 24D 18			printf("In openfile, %s file is linked with %s\n", pathname, path);E 18I 18D 27D 29			printf("%s is linked with %s\n", pathname, path);E 29I 29D 30#ifdef	FSMESSAGEE 30			OSMESSAGE_PRINT( printf("%s is linked with %s\n", pathname, path) );#endifE 29E 27I 27D 30			OSMESSAGE_PRINT( printf("%s is linked with %s\n", pathname, path) );E 27I 24#endifE 30E 24E 18			return(1);E 50		}D 50	}else{		/* link highest with versionless */		sprintf(path, "%s%s", path, file);I 41#ifdef	FSERROR		ERRSETJMP(0);#elseE 41I 39		SETJMP(0);I 41#endifE 41E 39		LINK(pathname, path);I 24#ifdef	FSMESSAGEE 24D 18		printf("In openfile, %s file is linked with %s\n", pathname, path);E 18I 18D 27D 29		printf("%s is linked with %s\n", pathname, path);E 29I 29D 30#ifdef	FSMESSAGEE 30		OSMESSAGE_PRINT( printf("%s is linked with %s\n", pathname, path) );#endifE 29E 27I 27D 30		OSMESSAGE_PRINT( printf("%s is linked with %s\n", pathname, path) );E 27I 24#endifE 30E 24E 18		return(1);E 50I 50		varray++;E 50	}I 50		if (linked_entry != NULL) {		if (linked_entry == max_entry) {			*highest_p = 1;		} else {			*highest_p = 0;		}		strcpy(to_file, name);	} else {		*to_file = '\0';	}	return(1);E 50}I 50	  E 50D 50changelink_and_delete(pathname)D 25char	*pathname;	/* A file to be removed, /users/hayata/foo.c.~3~ */E 25I 25D 26register char	*pathname;	/* A file to be removed, /users/hayata/foo.c.~3~ */E 26I 26char	*pathname;	/* A file to be removed, /users/hayata/foo.c.~3~ */E 26E 25{	I 29register FileName	*p_version_array;register FileName	*p_version_high;register FileName	*p_version_nhigh;register FileName	*p_version_less;register int	rval;struct stat sbuf;E 29I 26D 30register FileName	*p_version_array;E 26I 25register FileName	*p_version_high;register FileName	*p_version_nhigh;register FileName	*p_version_less;register int	rval;struct stat sbuf;E 30E 25char	path[MAXPATHLEN];char	path2[MAXPATHLEN];char	file[MAXPATHLEN];char	file2[MAXPATHLEN];char	version[VERSIONLEN];E 50I 50/*		 * Name:	get_old * * Argument:	char	*dir	Directory absolute path following the UNIX *				file naming convention on which varray *				has been gathered. *		FileName *varray *				The version array already filled by *				get_version_array routin. *		char	*afile	File name.  It might include a version field. *				The version field have to be following the *				UNIX convention, that is "name.~##~", not *				Xerox Lisp one.  The versionless file is *				also acceptable. *				afile is also used as a place where the true *				name of the  recognized file will be stored. *		char	*vfile	The place where the versioned name of the *				recognized file will be stored. * * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	afile will be replaced with the full name of the recognized file *		when the recognition succeed.  vfile will be replaced with the *		versioned full name of the recognized file when the recognition *		succeed. * * Description: * * Accepts a version array and file name, and recognize a file in the version * array with the old mode. * "Old" file means the "newest existing" file. * Notice that, afile and vfile are not necessary same name, because the versionless * file is recognized as an old file, afile will hold the true versionless file name, * although vfile will hold the versioned file name anyway. * afile could be used as the real UNIX pathname to access the recognized file, on * the other hand, vfile could be used as file name from which the file name * which should be returned to Lisp could be produced. * */E 50D 26D 29FileName	version_array[VERSIONARRAYLENGTH];E 26D 25FileName	*p_version_high;FileName	*p_version_nhigh;I 23FileName	*p_version_less;E 23int	rval;struct stat sbuf;E 29E 25I 41D 50#ifdef	FSERROR	ERRSETJMP(0);#elseE 41I 29	SETJMP(0);I 41#endifE 41E 29I 19D 30	SETJMP(0);E 30E 19	TIMEOUT(rval=stat(pathname, &sbuf));	if(rval != 0){		err_mess("stat", errno);I 40#ifdef	FSERROR		*Lisp_errno = errno;#endifE 40		return(0);	}	if(sbuf.st_nlink == 1){		/* No link -> no need to change link, just unlink */		UNLINK(pathname);		return(1);	}	if(parse(pathname, path, file, version) == 0)		return(0);	parseversion(file, version);	/* file is /foo.c */D 26D 29	if(LookUpFileVersion(path, file+1, version_array) == 0){E 29I 29	p_version_array = VersionArray;	if(LookUpFileVersion(path, file+1, p_version_array, &VArrayInfo) == 0){E 29E 26I 26D 30	p_version_array = VersionArray;	if(LookUpFileVersion(path, file+1, p_version_array, &VArrayInfo) == 0){E 30E 26		return(0);	}D 26D 29	if(NoFileP(version_array)){E 29I 29	if(NoFileP(p_version_array)){E 29E 26I 26D 30	if(NoFileP(p_version_array)){E 30E 26		return(0);	}I 41#ifdef	FSERROR	ERRSETJMP(0);#elseE 41I 29	SETJMP(0);I 41#endifE 41E 29I 28D 30	SETJMP(0);E 30E 28	if(*version == '0'){		/* deleting file is versionless */D 26D 29		p_version_high = GetHighestVersion(version_array);		if(p_version_high && VersionlessP(version_array)){E 29I 29		p_version_high = GetHighestVersion(p_version_array);		if(p_version_high && VersionlessP(p_version_array)){E 29E 26I 26D 30		p_version_high = GetHighestVersion(p_version_array);		if(p_version_high && VersionlessP(p_version_array)){E 30E 26			/* versionless exists  */			if(LinkWithVersionlessP(path, p_version_high->name)){				/* Highest link with versionless */				/* unlink versionless */I 41#ifdef	FSERROR				ERRSETJMP(0);#elseE 41I 39				SETJMP(0);I 41#endifE 41E 39				UNLINK(pathname);				/* unlink highest */				sprintf(path2, "%s/%s", path, p_version_high->name); 				UNLINK(path2);				/* next highest link with versionless */D 26D 29				if( (p_version_nhigh=GetNextHighestVersion(version_array)) == 0 )E 29I 29				if( (p_version_nhigh=GetNextHighestVersion(p_version_array)) == 0 )E 29E 26I 26D 30				if( (p_version_nhigh=GetNextHighestVersion(p_version_array)) == 0 )E 30E 26					return(1);				sprintf(path2, "%s/%s", path, p_version_nhigh->name);				LINK(path2, pathname);I 24#ifdef	FSMESSAGEE 24D 27D 29				printf("%s is linked with %s\n", path2, pathname);E 29I 29D 30#ifdef	FSMESSAGEE 30				OSMESSAGE_PRINT( printf("%s is linked with %s\n", path2, pathname) );#endifE 50I 50get_old(dir, varray, afile, vfile)	register char		*dir;	register FileName	*varray;	register char		*afile;	register char		*vfile;{	char			name[MAXPATHLEN], vless[MAXPATHLEN], to_file[MAXPATHLEN];	char			ver[VERSIONLEN], vbuf[VERSIONLEN];	register int		ver_no, max_no;	int			highest_p;	register FileName	*entry;			/* "Old" file have to be existing, thus varray should not be empty. */	if (NoFileP(varray)) return(0);	strcpy(name, afile);	separate_version(name, ver, 1);		if (get_versionless(varray, vless, dir) == 0) {		/*		 * There is no versionless file, but at least one vernsioned		 * file exists.		 */		if (*ver == '\0') {			/*			 * No version is specified.  The highest versioned file			 * is an old file.			 */			FindHighestVersion(varray, entry, max_no);			ConcDirAndName(dir, entry->name, afile);			strcpy(vfile, afile);			return(1);		} else {			/*			 * A version is specified.  We have to walk thorough			 * varray and try to find the file with the specified			 * version.			 */			ver_no = atoi(ver);			FindSpecifiedVersion(varray, entry, ver_no);			if (entry != NULL) {				ConcDirAndName(dir, entry->name, afile);				strcpy(vfile, afile);E 50E 29E 27I 27D 30				OSMESSAGE_PRINT( printf("%s is linked with %s\n", path2, pathname) );E 27I 24#endifE 30E 24				return(1);D 50			}else{				/* Versionless has link with another file but highest */				/* unlink versionless, highest link with versionless */I 41#ifdef	FSERROR				ERRSETJMP(0);#elseE 41I 39				SETJMP(0);I 41#endifE 41E 39				UNLINK(pathname);				/* highest link with versionless */				sprintf(path2, "%s/%s", path,p_version_high->name); 				LINK(path2, pathname);I 24#ifdef	FSMESSAGEE 24D 27D 29				printf("%s is linked with %s\n", path2, pathname);E 29I 29D 30#ifdef	FSMESSAGEE 30				OSMESSAGE_PRINT( printf("%s is linked with %s\n", path2, pathname) );#endifE 50I 50			} else return(0);		}	} else if (OnlyVersionlessP(varray)) {		/*		 * There is only versionless file in varray.		 * If the specified version is 1 the versionless file is regarded		 * as version 1 file.		 */		if (*ver == '\0') {			/*			 * No version is specified.  The versionless file is dealt			 * with as version 1.			 */			ConcNameAndVersion(vless, "1", vfile);			strcpy(afile, vless);			return(1);		} else {			ver_no = atoi(ver);			if (ver_no == 1) {				/*				 * Version 1 is specified.  The versionless file is				 * dealt with as a version 1 file.				 */				ConcNameAndVersion(name, "1", afile);				ConcDirAndName(dir, afile, vfile);				strcpy(afile, vless);E 50E 29E 27I 27D 30				OSMESSAGE_PRINT( printf("%s is linked with %s\n", path2, pathname) );E 27I 24#endifE 30E 24				return(1);I 50			} else {				/*				 * Other versions than 1 are not recognized as an old				 * file.				 */				return(0);E 50			}D 50		}else{			/* deleting file(versionless) not exist */			return(0);E 50		}D 50	}else{		/* deleting file is not versionless */D 23D 29		if(VersionlessP(version_array)){E 29I 29		if(p_version_less = VersionlessP(p_version_array)){E 29E 23I 23D 26		if(p_version_less = VersionlessP(version_array)){E 26I 26D 30		if(p_version_less = VersionlessP(p_version_array)){E 30E 26E 23			/* versionless exists  */D 23D 29			sprintf(file2, "%s.~%s~", file, version);E 29I 29			sprintf(file2, "%s.~%s~", file+1, version);E 29E 23I 23D 30			sprintf(file2, "%s.~%s~", file+1, version);E 30E 23			if(LinkWithVersionlessP(path, file2)){				/* deleting file link with versionless */				/* unlink deleting file */I 41#ifdef	FSERROR				ERRSETJMP(0);#elseE 41I 39				SETJMP(0);I 41#endifE 41E 39				UNLINK(pathname);				/* unlink versionless */D 23D 29				sprintf(path2, "%s%s", path, file); E 29I 29				sprintf(path2, "%s/%s", path, p_version_less->name); E 29E 23I 23D 30				sprintf(path2, "%s/%s", path, p_version_less->name); E 30E 23				UNLINK(path2);				/* next highest link with versionless */D 26D 29				if( (p_version_nhigh=GetNextHighestVersion(version_array)) == 0 )E 29I 29				if( (p_version_nhigh=GetNextHighestVersion(p_version_array)) == 0 )E 50I 50	} else {		if (check_vless_link(vless, varray, to_file, &highest_p) == 0)		  return(0);		if (*to_file == '\0') {			/*			 * There is a versionless file in varray and at least one			 * versioned file exists.  The versionless file is not linked			 * to any file in varray.			 */			if (*ver == '\0') {				/*				 * No version is specified.  The one higher than an				 * exisiting maximum version is dealt with as the				 * old version, and it should be a version of the				 * link missing versionless file.				 */				FindHighestVersion(varray, entry, max_no);				sprintf(vbuf, "%d", max_no + 1);				ConcNameAndVersion(vless, vbuf, vfile);				strcpy(afile, vless);				return(1);			} else {				/* A version is specified. */				ver_no = atoi(ver);				FindHighestVersion(varray, entry, max_no);				if (ver_no == max_no + 1) {					/*					 * If the version is one higher than the					 * existing highest version is specified, it					 * is dealt with as a version of the link					 * missing versionless file.					 */					sprintf(vbuf, "%d", ver_no);					ConcNameAndVersion(vless, vbuf, vfile);					strcpy(afile, vless);E 50E 29E 26I 26D 30				if( (p_version_nhigh=GetNextHighestVersion(p_version_array)) == 0 )E 30E 26					return(1);D 50				sprintf(path, "%s/%s", path, p_version_nhigh->name);				LINK(path, path2);I 24#ifdef	FSMESSAGEE 24D 27D 29				printf("%s is linked with %s\n",path, path2);E 29I 29D 30#ifdef	FSMESSAGEE 30				OSMESSAGE_PRINT( printf("%s is linked with %s\n",path, path2) );#endifE 50I 50				} else {					/*					 * We have to walk through varray and try					 * to find the file with the specified version.					 */					FindSpecifiedVersion(varray, entry, ver_no);					if (entry != NULL) {						ConcDirAndName(dir, entry->name, afile);						strcpy(vfile, afile);						return(1);					} else return(0);				}			}		} else {			/*			 * There is a versionless file in varray and at least one			 * versioned file exists.  The versionless file is linked to			 * one of files in varray.			 */			if (*ver == '\0') {				/*				 * No version is specified.  The highest versioned file				 * in varray is an old file.				 */				FindHighestVersion(varray, entry, max_no);				ConcDirAndName(dir, entry->name, afile);				strcpy(vfile, afile);E 50E 29E 27I 27D 30				OSMESSAGE_PRINT( printf("%s is linked with %s\n",path, path2) );E 27I 24#endifE 30E 24				return(1);D 50			}else{				/*deleting file link with another file but versionless */				/* unlink deletingfile */I 41#ifdef	FSERROR				ERRSETJMP(0);#elseE 41I 39				SETJMP(0);I 41#endifE 41E 39				UNLINK(pathname);				return(1);E 50I 50			} else {				/*				 * A version is specified.  We have to walk thorough				 * varray and try to find the file with the specified				 * version.				 */				ver_no = atoi(ver);				FindSpecifiedVersion(varray, entry, ver_no);				if (entry != NULL) {					ConcDirAndName(dir, entry->name, afile);					strcpy(vfile, afile);					return(1);				} else return(0);E 50			}D 50		}else{			/* versionless not exist, just unlink deleting file */I 41#ifdef	FSERROR			ERRSETJMP(0);#elseE 41I 39			SETJMP(0);I 41#endifE 41E 39			UNLINK(pathname);			return(1);E 50		}D 50	E 50	}}I 33D 34#ifdef	FSERRORE 34I 34D 40#ifdef FSERRORE 34changelink_and_rename(pathname, newfile, errp)E 40I 40D 50changelink_and_rename(pathname, newfile)E 40char	*pathname;	/* A file to be renameed, /users/hayata/foo.c.~3~ */register char	*newfile;	/* new file name, /users/hayata/foo.c.~5~ */D 40int	*errp;		/* pointer to fixp box to keep UNIX errno */#elseE 33D 32changelink_and_rename(pathname, newfile)E 32I 32changelink_and_rename(pathname, newfile, errp)E 32D 25char	*pathname;	/* A file to be renameed, /users/hayata/foo.c.~3~ */D 29char	*newfile;	/* new file name, /users/hayata/foo.c.~5~ */E 29I 29D 30register char	*newfile;	/* new file name, /users/hayata/foo.c.~5~ */E 30E 29E 25I 25D 26register char	*pathname;	/* A file to be renameed, /users/hayata/foo.c.~3~ */E 26I 26char	*pathname;	/* A file to be renameed, /users/hayata/foo.c.~3~ */E 26register char	*newfile;	/* new file name, /users/hayata/foo.c.~5~ */I 33#endifE 40E 33I 32D 34int	*errp;		/* pointer to fixp box to keep UNIX errno */E 34E 32E 25{	I 29register FileName	*p_version_array;register FileName	*p_version_high;register FileName	*p_version_nhigh;FileName	*p_version_less;register int	rval;struct stat sbuf;E 29I 26D 30register FileName	*p_version_array;E 26I 25register FileName	*p_version_high;register FileName	*p_version_nhigh;FileName	*p_version_less;register int	rval;struct stat sbuf;E 30E 25char	path[MAXPATHLEN];char	path2[MAXPATHLEN];char	file[MAXPATHLEN];char	file2[MAXPATHLEN];char	version[VERSIONLEN];E 50I 50/*		 * Name:	get_oldeset * * Argument:	char	*dir	Directory absolute path following the UNIX *				file naming convention on which varray *				has been gathered. *		FileName *varray *				The version array already filled by *				get_version_array routin. *		char	*afile	File name.  It might include a version field. *				The version field have to be following the *				UNIX convention, that is "name.~##~", not *				Xerox Lisp one.  The versionless file is *				also acceptable. *				afile is also used as a place where the true *				name of the  recognized file will be stored. *		char	*vfile	The place where the versioned name of the *				recognized file will be stored. * * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	afile will be replaced with the full name of the recognized file *		when the recognition succeed.  vfile will be replaced with the *		versioned full name of the recognized file when the recognition *		succeed. * * Description: * * Accepts a version array and filename, and recognize a file in the version * array with oldest mode. * "Oldest" file means the "oldest existing" file. * Notice that, afile and vfile are not necessary same name, because the versionless * file is recognized as an old file, afile will hold the true versionless file name, * although vfile will hold the versioned file name anyway. * afile could be used as the real UNIX pathname to access the recognized file, on * the other hand, vfile could be used as file name from which the file name * which should be returned to Lisp could be produced. * */E 50D 26D 29FileName	version_array[VERSIONARRAYLENGTH];E 26D 25FileName	*p_version_high;FileName	*p_version_nhigh;I 23FileName	*p_version_less;E 23int	rval;struct stat sbuf;E 29E 25I 41D 50#ifdef	FSERROR	ERRSETJMP(0);#elseE 41I 29	SETJMP(0);I 41#endifE 41E 29I 19D 30	SETJMP(0);E 30E 19	TIMEOUT(rval=stat(pathname, &sbuf));	if(rval != 0){		err_mess("stat", errno);I 40#ifdef	FSERROR		*Lisp_errno = errno;#endifE 40		return(0);	}	if(sbuf.st_nlink == 1){		/* No link -> no need to change link, just rename */I 33D 40#ifdef	FSERROR		RENAME(pathname, newfile, errp);#elseE 40I 34		RENAME(pathname, newfile);E 34E 33D 32		RENAME(pathname, newfile);I 33D 40#endifE 40E 33E 32I 32D 34		RENAME(pathname, newfile, errp);E 32		return(1);E 34I 34	return(1);E 34	}	if(parse(pathname, path, file, version) == 0)		return(0);	parseversion(file, version);	/* file is /foo.c */D 26D 29	if(LookUpFileVersion(path, file+1, version_array) == 0){E 29I 29	p_version_array = VersionArray;	if(LookUpFileVersion(path, file+1, p_version_array, &VArrayInfo) == 0)E 29E 26I 26D 30	p_version_array = VersionArray;	if(LookUpFileVersion(path, file+1, p_version_array, &VArrayInfo) == 0)E 30E 26		return(0);D 26D 29	}	if(NoFileP(version_array)){E 29I 29	if(NoFileP(p_version_array)){E 29E 26I 26D 30	if(NoFileP(p_version_array)){E 30E 26		return(0);	}I 41#ifdef	FSERROR	ERRSETJMP(0);#elseE 41I 29	SETJMP(0);I 41#endifE 41E 29I 28D 30	SETJMP(0);E 30E 28	if(*version == '0'){		/* renaming file is versionless */D 26D 29		p_version_high = GetHighestVersion(version_array);		if(p_version_high && VersionlessP(version_array)){E 29I 29		p_version_high = GetHighestVersion(p_version_array);		if(p_version_high && VersionlessP(p_version_array)){E 29E 26I 26D 30		p_version_high = GetHighestVersion(p_version_array);		if(p_version_high && VersionlessP(p_version_array)){E 30E 26			/* versionless exists  */			if(LinkWithVersionlessP(path, p_version_high->name)){				/* Highest link with versionless */				/* rename versionless */I 41#ifdef	FSERROR				ERRSETJMP(0);#elseE 41I 39				SETJMP(0);I 41#endifE 41E 39I 33D 40#ifdef FSERROR				RENAME(pathname, newfile, errp);#elseE 40I 34				RENAME(pathname, newfile);E 34E 33D 32				RENAME(pathname, newfile);I 33D 40#endifE 40E 33E 32I 32D 34				RENAME(pathname, newfile, errp);E 34E 32				/* unlink highest */				sprintf(path2, "%s/%s", path, p_version_high->name); 				UNLINK(path2);				/* next highest link with versionless */D 26D 29				if( (p_version_nhigh = GetNextHighestVersion(version_array)) == 0)E 29I 29				if( (p_version_nhigh = GetNextHighestVersion(p_version_array)) == 0)E 29E 26I 26D 30				if( (p_version_nhigh = GetNextHighestVersion(p_version_array)) == 0)E 30E 26					return(1);				sprintf(path2, "%s/%s", path, p_version_nhigh->name);				LINK(path2, pathname);I 24#ifdef	FSMESSAGEE 24D 18				printf("In openfile, %s file is linked with %s\n", path2, pathname);E 18I 18D 27D 29				printf("%s is linked with %s\n", path2, pathname);E 29I 29D 30#ifdef	FSMESSAGEE 30				OSMESSAGE_PRINT( printf("%s is linked with %s\n", path2, pathname) );#endifE 50I 50get_oldest(dir, varray, afile, vfile)	register char		*dir;	register FileName	*varray;	register char		*afile;	register char		*vfile;{	char			name[MAXPATHLEN], vless[MAXPATHLEN], to_file[MAXPATHLEN];	char			ver[VERSIONLEN], vbuf[VERSIONLEN];	register int		ver_no, min_no;	int			highest_p;	register FileName	*entry;			/* "Oldest" file have to be existing, thus varray should not be empty. */	if (NoFileP(varray)) return(0);	strcpy(name, afile);	separate_version(name, ver, 1);		if (get_versionless(varray, vless, dir) == 0) {		/*		 * There is no versionless file, but at least one vernsioned		 * file exists.		 */		if (*ver == '\0') {			/*			 * No version is specified.  The lowest versioned file			 * is an oldest file.			 */			FindLowestVersion(varray, entry, min_no);			ConcDirAndName(dir, entry->name, afile);			strcpy(vfile, afile);			return(1);		} else {			/*			 * A version is specified.  We have to walk thorough			 * varray and try to find the file with the specified			 * version.			 */			ver_no = atoi(ver);			FindSpecifiedVersion(varray, entry, ver_no);			if (entry != NULL) {				ConcDirAndName(dir, entry->name, afile);				strcpy(vfile, afile);E 50E 29E 27I 27D 30				OSMESSAGE_PRINT( printf("%s is linked with %s\n", path2, pathname) );E 27I 24#endifE 30E 24E 18				return(1);D 50			}else{				/* Versionless has link with another file but highest */				/* rename versionless, highest link with versionless */I 41#ifdef	FSERROR				ERRSETJMP(0);#elseE 41I 39				SETJMP(0);I 41#endifE 41E 39I 33D 40#ifdef FSERROR				RENAME(pathname, newfile, errp);#elseE 40I 34				RENAME(pathname, newfile);E 34E 33D 32				RENAME(pathname, newfile);I 33D 40#endifE 40E 33E 32I 32D 34				RENAME(pathname, newfile, errp);E 34E 32				/* highest link with versionless */				sprintf(path2, "%s/%s", path,p_version_high->name); 				LINK(path2, pathname);I 24#ifdef	FSMESSAGEE 24D 18				printf("In openfile, %s file is linked with %s\n", path2, pathname);E 18I 18D 27D 29				printf("%s is linked with %s\n", path2, pathname);E 29I 29D 30#ifdef	FSMESSAGEE 30				OSMESSAGE_PRINT( printf("%s is linked with %s\n", path2, pathname) );#endifE 50I 50			} else return(0);		}	} else if (OnlyVersionlessP(varray)) {		/*		 * There is only versionless file in varray.		 * If the specified version is 1 the versionless file is regarded		 * as version 1 file.		 */		if (*ver == '\0') {			/*			 * No version is specified.  The versionless file is dealt			 * with as version 1.			 */			ConcNameAndVersion(vless, "1", vfile);			strcpy(afile, vless);			return(1);		} else {			ver_no = atoi(ver);			if (ver_no == 1) {				/*				 * Version 1 is specified.  The versionless file is				 * dealt with as a version 1 file.				 */				ConcNameAndVersion(name, "1", afile);				ConcDirAndName(dir, afile, vfile);				strcpy(afile, vless);E 50E 29E 27I 27D 30				OSMESSAGE_PRINT( printf("%s is linked with %s\n", path2, pathname) );E 27I 24#endifE 30E 24E 18				return(1);I 50			} else {				/*				 * Other versions than 1 are not recognized as an				 * oldest file.				 */				return(0);E 50			}D 50		}else{			/* renaming file(versionless) not exist */			return(0);E 50		}D 50	}else{		/* renaming file is not versionless */D 23D 29		if(VersionlessP(version_array)){E 29I 29		if(p_version_less = VersionlessP(p_version_array)){E 29E 23I 23D 26		if(p_version_less = VersionlessP(version_array)){E 26I 26D 30		if(p_version_less = VersionlessP(p_version_array)){E 30E 26E 23			/* versionless exists  */D 23D 29			sprintf(file2, "%s.~%s~", file, version);E 29I 29			sprintf(file2, "%s.~%s~", file+1, version);E 29E 23I 23D 30			sprintf(file2, "%s.~%s~", file+1, version);E 30E 23			if(LinkWithVersionlessP(path, file2)){				/* deleting file link with versionless */				/* rename file */I 41#ifdef	FSERROR				ERRSETJMP(0);#elseE 41I 39				SETJMP(0);I 41#endifE 41E 39I 33D 40#ifdef FSERROR				RENAME(pathname, newfile, errp);#elseE 40I 34				RENAME(pathname, newfile);E 34E 33D 32				RENAME(pathname, newfile);I 33D 40#endifE 40E 33E 32I 32D 34				RENAME(pathname, newfile, errp);E 34E 32				/* unlink versionless */D 23D 29				sprintf(path2, "%s%s", path, file); E 29I 29				sprintf(path2, "%s/%s", path, p_version_less->name); E 29E 23I 23D 30				sprintf(path2, "%s/%s", path, p_version_less->name); E 30E 23				UNLINK(path2);				/* next highest link with versionless */D 26D 29				if( (p_version_nhigh=GetNextHighestVersion(version_array)) == 0 )E 29I 29				if( (p_version_nhigh=GetNextHighestVersion(p_version_array)) == 0 )E 50I 50	} else {		if (check_vless_link(vless, varray, to_file, &highest_p) == 0)		  return(0);		if (*to_file == '\0') {			/*			 * There is a versionless file in varray and at least one			 * versioned file exists.  The versionless file is not linked			 * to any file in varray.			 */			if (*ver == '\0') {				/*				 * No version is specified.  The lowest version is				 * dealt with as the oldest version.				 */				FindLowestVersion(varray, entry, min_no);				ConcDirAndName(dir, entry->name, afile);				strcpy(vfile, afile);				return(1);			} else {				/* A version is specified. */				ver_no = atoi(ver);				FindHighestVersion(varray, entry, min_no);				if (ver_no == min_no + 1) {					/*					 * If the version is one higher than the					 * existing highest version is specified, it					 * is dealt with as a version of the link					 * missing versionless file.					 */					sprintf(vbuf, "%d", ver_no);					ConcNameAndVersion(vless, vbuf, vfile);					strcpy(afile, vless);E 50E 29E 26I 26D 30				if( (p_version_nhigh=GetNextHighestVersion(p_version_array)) == 0 )E 30E 26					return(1);D 50				sprintf(path, "%s/%s", path, p_version_nhigh->name);				LINK(path, path2);I 24#ifdef	FSMESSAGEE 24D 18				printf("In openfile, %s file is linked with %s\n",path, path2);E 18I 18D 27D 29				printf("%s is linked with %s\n",path, path2);E 29I 29D 30#ifdef	FSMESSAGEE 30				OSMESSAGE_PRINT( printf("%s is linked with %s\n",path, path2) );#endifE 50I 50				} else {					/*					 * We have to walk through varray and try					 * to find the file with the specified version.					 */					FindSpecifiedVersion(varray, entry, ver_no);					if (entry != NULL) {						ConcDirAndName(dir, entry->name, afile);						strcpy(vfile, afile);						return(1);					} else return(0);				}			}		} else {			/*			 * There is a versionless file in varray and at least one			 * versioned file exists.  The versionless file is linked to			 * one of files in varray.			 */			if (*ver == '\0') {				/*				 * No version is specified.  The lowest versioned file				 * in varray is an old file.				 */				FindLowestVersion(varray, entry, min_no);				ConcDirAndName(dir, entry->name, afile);				strcpy(vfile, afile);E 50E 29E 27I 27D 30				OSMESSAGE_PRINT( printf("%s is linked with %s\n",path, path2) );E 27I 24#endifE 30E 24E 18				return(1);D 50			}else{				/*renaming file link with another file but versionless */				/* renam file */I 41#ifdef	FSERROR				ERRSETJMP(0);#elseE 41I 39				SETJMP(0);I 41#endifE 41E 39I 33D 40#ifdef FSERROR				RENAME(pathname, newfile, errp);#elseE 40I 34				RENAME(pathname, newfile);E 34E 33D 32				RENAME(pathname, newfile);I 33D 40#endifE 40E 33E 32I 32D 34				RENAME(pathname, newfile, errp);E 34E 32				return(1);E 50I 50			} else {				/*				 * A version is specified.  We have to walk thorough				 * varray and try to find the file with the specified				 * version.				 */				ver_no = atoi(ver);				FindSpecifiedVersion(varray, entry, ver_no);				if (entry != NULL) {					ConcDirAndName(dir, entry->name, afile);					strcpy(vfile, afile);					return(1);				} else return(0);E 50			}D 50		}else{			/* versionless not exist, just rename file */I 41#ifdef	FSERROR			ERRSETJMP(0);#elseE 41I 39			SETJMP(0);I 41#endifE 41E 39I 33D 40#ifdef FSERROR			RENAME(pathname, newfile, errp);#elseE 40I 34			RENAME(pathname, newfile);E 34E 33D 32			RENAME(pathname, newfile);I 33D 40#endifE 40E 33E 32I 32D 34			RENAME(pathname, newfile, errp);E 34E 32			return(1);E 50		}D 50	E 50	}}D 50						D 26D 29LookUpFileVersion(path, file, version_array)E 29I 29LookUpFileVersion(path, file, version_array, cache)E 29E 26I 26D 30LookUpFileVersion(path, file, version_array, cache)E 30E 26char	*path;char	*file;		/* No version field */D 25D 29FileName	*version_array;E 29I 29register FileName	*version_array;CurrentVArray		*cache;E 29E 25I 25D 30register FileName	*version_array;I 26CurrentVArray		*cache;E 30E 26E 25{			I 29register DIR	*dirp;register struct direct	*dp;int	rval;struct stat stat_buf;E 29I 25D 30register DIR	*dirp;register struct direct	*dp;I 26int	rval;struct stat stat_buf;E 30E 26E 25E 17char	name[MAXPATHLEN];I 17char	ver[VERSIONLEN];E 17char	save_file[MAXPATHLEN];E 50D 25D 29DIR	*dirp;struct direct	*dp;E 29E 25D 17char	ver[VERSIONLEN];int	v;int	max = -1;E 17I 17I 41D 50#ifdef	FSERROR	ERRSETJMP(0);#elseE 41I 29	SETJMP(0);I 41#endifE 50I 50/*		 * Name:	get_new * * Argument:	char	*dir	Directory absolute path following the UNIX *				file naming convention on which varray *				has been gathered. *		FileName *varray *				The version array already filled by *				get_version_array routin. *		char	*afile	File name.  It might include a version field. *				The version field have to be following the *				UNIX convention, that is "name.~##~", not *				Xerox Lisp one.  The versionless file is *				also acceptable. *				afile is also used as a place where the true *				name of the  recognized file will be stored. *		char	*vfile	The place where the versioned name of the *				recognized file will be stored. * * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	afile will be replaced with the full name of the recognized file *		when the recognition succeed.  vfile will be replaced with the *		versioned full name of the recognized file when the recognition *		succeed. * * Description: * * Accepts a version array and filename, and recognize a file in the version * array with new mode. * "New" file means the "not yet existing" file with the version which is one * higher than the current highest version. * Notice that, afile and vfile are not necessary same name, because the versionless * file is recognized as an old file, afile will hold the true versionless file name, * although vfile will hold the versioned file name anyway. * afile could be used as the real UNIX pathname to access the recognized file, on * the other hand, vfile could be used as file name from which the file name * which should be returned to Lisp could be produced. * */E 50E 41I 31D 50/* Cache of directory cause error in auto test 22-3-1-WRITE-CHAR */D 36/* So, cacheing mechanisum is masked in the following if( 0 & ..) */E 36I 36/* So, cacheing mechanisum is masked in the following #ifdef 0... */E 36/* (02-Aug-88:Hayata) */E 50I 50get_new(dir, varray, afile, vfile)	register char		*dir;	register FileName	*varray;	register char		*afile;	register char		*vfile;{	char			name[MAXPATHLEN], vless[MAXPATHLEN], to_file[MAXPATHLEN];	char			ver[VERSIONLEN], vbuf[VERSIONLEN];	register int		ver_no, max_no;	int			highest_p;	register FileName	*entry;		strcpy(name, afile);	separate_version(name, ver, 1);E 50E 31D 50	/* Is cache availabe ? */ E 29I 19D 30	SETJMP(0);I 26	/* Is cache availabe ? */ E 30E 26E 19E 17	strcpy(save_file, file);	DOWNCASE(save_file);I 29	STAT(path, &stat_buf);I 37/*** BBob's codeE 37D 31	if( (stat_buf.st_mtime == cache->mtime) && STREQ(save_file, cache->file) && STREQ(path, cache->path) ){E 31I 31D 36	if(0 && (stat_buf.st_mtime == cache->mtime) && STREQ(save_file, cache->file) && STREQ(path, cache->path) ){E 36I 36#ifdef 0	if((stat_buf.st_mtime == cache->mtime) && STREQ(save_file, cache->file) && STREQ(path, cache->path) ){E 36E 31D 37		/* chached version_array is avilable */E 37		return(T);	}I 36#endifE 36D 37E 37I 37***/	if(0 && (stat_buf.st_mtime == cache->mtime) && STREQ(save_file, cache->file) && STREQ(path, cache->path) ){		/* chached version_array is avilable */		return(T);	}E 37	/* cached version_array must be updated */E 29I 26D 30	STAT(path, &stat_buf);	if( (stat_buf.st_mtime == cache->mtime) && STREQ(save_file, cache->file) && STREQ(path, cache->path) ){		/* chached version_array is avilable */		return(T);	}	/* cached version_array must be updated */E 30E 26D 11	dirp = opendir(path);E 11I 11	TIMEOUT( dirp = opendir(path) );E 11D 40	if(dirp == NULL)E 40I 40	if(dirp == NULL){#ifdef	FSERROR		*Lisp_errno = errno;#endifE 40D 17		return(0);E 17I 17		return(NIL);I 40	}E 40E 17D 11	for(dp=readdir(dirp); dp!=NULL; dp=readdir(dirp)){E 11I 11	for(S_TOUT(dp=readdir(dirp)); dp!=NULL; S_TOUT(dp=readdir(dirp)) ){E 11		strcpy(name, dp->d_name);		parseversion(name, ver);		DOWNCASE(name);D 17		v = atoi(ver);E 17		if( STREQ(save_file, name) ){D 17			if(v > max){				max = v;			}E 17I 17			strcpy(version_array->name, dp->d_name);			if(*ver == '\0')				version_array->version_no = 0;			else				version_array->version_no = atoi(ver) ;			++version_array;E 50I 50	if (NoFileP(varray)) {		/*		 * If there is no file with such name, "new" file is always		 * recognized.		 */		if (*ver == '\0' || strcmp(ver, "1") == 0) {			/*			 * If version is not specified or 1 is specified,			 * we can return versionless file as afile.			 */			ConcNameAndVersion(name, "1", afile);			ConcDirAndName(dir, afile, vfile);			ConcDirAndName(dir, name, afile);			return(1);		} else {			/*			 * A version other than 1 is specified.  "New" file			 * is recognized as if.			 */			ConcDirAndName(dir, afile, vfile);			strcpy(afile, vfile);			return(1);E 50E 17		}	}I 17D 50	version_array->version_no = LASTVERSIONARRAY;I 29	/* cache information is also updated */	strcpy(cache->path, path);	strcpy(cache->file, save_file);	cache->mtime = stat_buf.st_mtime;E 29I 26D 30	/* cache information is also updated */	strcpy(cache->path, path);	strcpy(cache->file, save_file);	cache->mtime = stat_buf.st_mtime;E 30E 26E 17D 11	closedir(dirp);E 11I 11	TIMEOUT( closedir(dirp) );E 11D 8/*	if(max != 0)*/E 8D 17	++max;	sprintf(file,"%s;%d", file, max);	return(1);E 17I 17	return(T);E 17}D 17getoldestfile(path, file)char	*path;char	*file;E 17I 17D 25D 29NoFileP(version_array)FileName	*version_array;E 17{I 17	if( version_array->version_no == LASTVERSIONARRAY ){		/* No file */		return(T);	}else{		return(NIL);	}}E 29E 25FileName *VersionlessP(version_array)D 25D 29FileName	*version_array;E 29I 29register FileName	*version_array;E 29E 25I 25D 30register FileName	*version_array;E 30E 25{E 17char	name[MAXPATHLEN];D 17char	save_file[MAXPATHLEN];I 14char	file_ver0[MAXPATHLEN];E 14DIR	*dirp;struct direct	*dp;E 17char	ver[VERSIONLEN];D 17int	v;int	min = MAXVERSION;I 14int	ver0_flag = 0;E 14	strcpy(save_file, file);	DOWNCASE(save_file);D 11	dirp = opendir(path);E 11I 11	TIMEOUT( dirp = opendir(path) );E 11	if(dirp == NULL)		return(0);D 11	for(dp=readdir(dirp); dp!=NULL; dp=readdir(dirp)){E 11I 11	for(S_TOUT(dp=readdir(dirp)); dp!=NULL; S_TOUT(dp=readdir(dirp))){E 11		strcpy(name, dp->d_name);		parseversion(name, ver);		DOWNCASE(name);		v = atoi(ver);		if( STREQ(save_file, name) ){D 14			if(v < min){				min = v;				strcpy(file, dp->d_name);E 14I 14			if(v == 0){	/* version 0 is skipped */ 				ver0_flag = 1;				strcpy(file_ver0, dp->d_name);			}else{				if(v < min){					min = v;					strcpy(file, dp->d_name);				}E 17I 17	for(;version_array->version_no != LASTVERSIONARRAY; ++version_array){		if(version_array->version_no == 0){			/* find version 0 */			strcpy(name, version_array->name);			parseversion(name, ver);			if(CheckOnlyNumber(ver)){				return(version_array);E 50I 50		if (get_versionless(varray, vless, dir) == 0) {		/*		 * There is no versionless file, but at least one vernsioned		 * file exists.		 */		if (*ver == '\0') {			/*			 * No version is specified.  The new file is one higher than			 * the existing highest version.			 */			FindHighestVersion(varray, entry, max_no);			sprintf(vbuf, "%d", max_no + 1);			/*			 * We weill use the file name of the exisiting highest			 * versioned file as the name of the new file, so that			 * new file is as the same case as old.			 */			strcpy(name, entry->name);			separate_version(name, ver, 1);			ConcDirAndName(dir, name, afile);			ConcNameAndVersion(afile, vbuf, vfile);			strcpy(afile, vfile);			return(1);		} else {			/*			 * A version is specified.  We have to walk thorough			 * varray and try to find the file with the specified			 * version.			 */			ver_no = atoi(ver);			FindSpecifiedVersion(varray, entry, ver_no);			if (entry != NULL) {				ConcDirAndName(dir, entry->name, afile);				strcpy(vfile, afile);				return(1);E 50E 17E 14			}I 50			/*			 * There is not a file with the specified version in varray.			 * The specified file can be recognized as if.			 * Most user will hope to create a new file in same case as			 * old.   One of case sensitive names in the files are stored			 * in the trail marker entry in varray by get_version_array			 * routine.			 * We will use it, although we cannot say all of the gathered			 * files has the name in same case.			 */			while (varray->version_no != LASTVERSIONARRAY) varray++;			ConcNameAndVersion(varray->name, ver, afile);			ConcDirAndName(dir, afile, vfile);			strcpy(afile, vfile);			return(1);E 50		}D 50	}D 11	closedir(dirp);E 11I 11D 17	TIMEOUT( closedir(dirp) );E 11	if(min == MAXVERSION)D 14		return(0);E 14I 14		if(ver0_flag == 1){/* No file is not matched, except version 0 */			strcpy(file, file_ver0);		}else			return(0);E 14	UnixVersionToLispVersion(file);I 15	AddDodNoExtention(file);E 15	return(1);E 17I 17	return(NIL);E 17}D 17parseversion(name, version)D 13char	*name;char	*version;E 13I 13char	*name;			/* UNIX format, .~#~ */char	*version;		/* Result is "123" or "123%%" like this */E 17I 17FileName *GetHighestVersion(version_array)D 25D 29FileName	*version_array;E 29I 29register FileName	*version_array;E 29E 25I 25D 30register FileName	*version_array;E 30E 25E 17E 13D 9{char	*cp,*vp;	for(cp=name, vp=version;;++cp){E 9I 9{D 17char	*cp, *cp1;int	length;	for(cp=name;;++cp){E 9		switch(*cp){I 9		case '.':			if(*(cp+1)=='~' && (cp1=index(cp+2, '~'))!=0){				*cp = '\0';				length = (int)cp1 - (int)cp - 2;				if(length == 0){					version[0] = '0';					version[1] = '\0';					return;				}else{					strncpy(version, cp+2, length);					version[length] = '\0';I 13					strcat(version, cp1+1);E 13					return;				}			}else				break;#ifdef	OLD_VERSION_CONVENTIONE 9		case '~':D 8/**		case ';': **/E 8D 9			*cp++ = '\0';			while(*cp>='0' && *cp<='9')				*vp++ = *cp++;			if(vp==version)				*vp++ = '0';			*vp = '\0';			return;E 9I 9			if( (cp1=index(cp+1, '~'))!=0 ){				*cp++ = '\0';				length = (int)cp1 - (int)cp;				if(length == 0){					version[0] = '0';					version[1] = '\0';					return;				}else{					strncpy(version, cp, length);					version[length] = '\0';					return;				}			}else				break;#endifE 9		case '\0':D 9			*vp++ = '0';			*vp = '\0';E 9I 9			version[0] = '0';			version[1] = '\0';E 9			return;E 17I 17D 25D 29FileName	*p_max;int	max = -1;E 29I 29register FileName	*p_max;register int	max = -1;E 29E 25I 25D 30register FileName	*p_max;register int	max = -1;E 30E 25char	name[MAXPATHLEN];char	ver[VERSIONLEN];	p_max = 0;	for(;version_array->version_no != LASTVERSIONARRAY; ++version_array){		if(version_array->version_no > max){			/* find large number */			strcpy(name, version_array->name);			parseversion(name, ver);			if(CheckOnlyNumber(ver)){				max = version_array->version_no;				p_max = version_array;E 50I 50	} else if (OnlyVersionlessP(varray)) {		/*		 * There is only versionless file in varray.		 * If the specified version is 1 the versionless file is regarded		 * as version 1 file.		 */		if (*ver == '\0') {			/*			 * No version is specified.  The versionless file is dealt			 * with as version 1.  Thus new version is 2.			 */			ConcNameAndVersion(vless, "2", vfile);			strcpy(afile, vfile);			return(1);		} else {			ver_no = atoi(ver);			if (ver_no == 1) {				/*				 * Version 1 is specified.  The versionless file is				 * dealt with as a version 1 file.				 */				ConcNameAndVersion(name, "1", afile);				ConcDirAndName(dir, afile, vfile);				strcpy(afile, vless);				return(1);			} else {				/*				 * Other versions than 1 are recognized as if.				 */				ConcDirAndName(dir, afile, vfile);				strcpy(afile, vfile);				return(1);E 50			}E 17		}D 50	}I 17	return(p_max);E 17}D 17DSK_readpage()E 17I 17FileName *GetNextHighestVersion(version_array)D 25D 29FileName	*version_array;E 29I 29register FileName	*version_array;E 29E 25I 25D 30register FileName	*version_array;E 30E 25E 17{D 17/* Old entry */E 17I 17D 25D 29FileName	*p_next_max;FileName	*p_max;int	max = -1;int	next_max;E 29I 29register FileName	*p_next_max;register FileName	*p_max;register int	max = -1;register int	next_max;E 29E 25I 25D 30register FileName	*p_next_max;register FileName	*p_max;register int	max = -1;register int	next_max;E 30E 25char	name[MAXPATHLEN];char	ver[VERSIONLEN];	p_next_max = 0;	for(;version_array->version_no != LASTVERSIONARRAY; ++version_array){		if(version_array->version_no > max){			/* find large number */			strcpy(name, version_array->name);			parseversion(name, ver);			if(CheckOnlyNumber(ver)){				next_max = max;				p_next_max = p_max;				max = version_array->version_no;				p_max = version_array;E 50I 50	} else {		if (check_vless_link(vless, varray, to_file, &highest_p) == 0)		  return(0);		if (*to_file == '\0') {			/*			 * There is a versionless file in varray and at least one			 * versioned file exists.  The versionless file is not linked			 * to any file in varray.			 */			if (*ver == '\0') {				/*				 * No version is specified.  The two higher than an				 * exisiting maximum version is dealt with as the				 * new version, because the one higher version is				 * dealt with as the actual version of the link				 * missing versionless file.				 */				FindHighestVersion(varray, entry, max_no);				sprintf(vbuf, "%d", max_no + 2);				ConcNameAndVersion(vless, vbuf, vfile);				strcpy(afile, vfile);				return(1);			} else {				/* A version is specified. */				ver_no = atoi(ver);				FindHighestVersion(varray, entry, max_no);				if (ver_no == max_no + 1) {					/*					 * If the version is one higher than the					 * existing highest version is specified, it					 * is dealt with as a version of the link					 * missing versionless file.					 */					sprintf(vbuf, "%d", ver_no);					ConcNameAndVersion(vless, vbuf, vfile);					strcpy(afile, vless);					return(1);				} else {					/*					 * We have to walk through varray and try					 * to find the file with the specified version.					 */					FindSpecifiedVersion(varray, entry, ver_no);					if (entry != NULL) {						ConcDirAndName(dir, entry->name, afile);						strcpy(vfile, afile);						return(1);					}					/*					 * There is not a file with the specified					 * version in varray.  The specified file can					 * be recognized as if.					 * Most user will hope to create a new file in					 * same case as old.   One of case sensitive					 * names in the files are stored in the trail					 * marker entry in varray by get_version_array					 * routine.					 * We will use it, although we cannot say all					 * of the gathered files has the name in same					 * case.					 */					while (varray->version_no != LASTVERSIONARRAY)					  varray++;					ConcNameAndVersion(varray->name, ver, afile);					ConcDirAndName(dir, afile, vfile);					strcpy(afile, vfile);					return(1);				}E 50			}D 50		}else			if(version_array->version_no > next_max){				/* update next max */				strcpy(name, version_array->name);				parseversion(name, ver);				if(CheckOnlyNumber(ver)){					next_max = version_array->version_no;					p_next_max = version_array;E 50I 50		} else {			/*			 * There is a versionless file in varray and at least one			 * versioned file exists.  The versionless file is linked to			 * one of files in varray.			 */			if (*ver == '\0') {				/*				 * No version is specified.  The one higher than the				 * exisiting highest versioned file in varray is a				 * new file.				 */				FindHighestVersion(varray, entry, max_no);				sprintf(vbuf, "%d", max_no + 1);				/*				 * We will use the name of the highest versioned file				 * as the name of the new file.				 */				strcpy(vless, entry->name);				separate_version(vless, ver, 1);				ConcDirAndName(dir, vless, afile);				ConcNameAndVersion(afile, vbuf, vfile);				strcpy(afile, vfile);				return(1);			} else {				/*				 * A version is specified.  We have to walk thorough				 * varray and try to find the file with the specified				 * version.				 */				ver_no = atoi(ver);				FindSpecifiedVersion(varray, entry, ver_no);				if (entry != NULL) {					ConcDirAndName(dir, entry->name, afile);					strcpy(vfile, afile);					return(1);E 50				}D 50			}	E 50I 50				/*				 * There is not a file with the specified				 * version in varray.  The specified file can				 * be recognized as if.				 * Most user will hope to create a new file in				 * same case as old.   We will use the name of				 * the highest versioned file as the name of the				 * new file.				 */				FindHighestVersion(varray, entry, max_no);				strcpy(vless, entry->name);				separate_version(vless, vbuf, 1);				ConcDirAndName(dir, vless, afile);				ConcNameAndVersion(afile, ver, vfile);				strcpy(afile, vfile);				return(1);			}		}E 50	}D 50	return(p_next_max);E 50E 17}D 17DSK_writepage()		E 17I 17D 50FileName *GetLowestVersion(version_array)D 25D 29FileName	*version_array;E 29I 29register FileName	*version_array;E 50I 50/*		 * Name:	get_old_new * * Argument:	char	*dir	Directory absolute path following the UNIX *				file naming convention on which varray *				has been gathered. *		FileName *varray *				The version array already filled by *				get_version_array routin. *		char	*afile	File name.  It might include a version field. *				The version field have to be following the *				UNIX convention, that is "name.~##~", not *				Xerox Lisp one.  The versionless file is *				also acceptable. *				afile is also used as a place where the true *				name of the  recognized file will be stored. *		char	*vfile	The place where the versioned name of the *				recognized file will be stored. * * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	afile will be replaced with the full name of the recognized file *		when the recognition succeed.  vfile will be replaced with the *		versioned full name of the recognized file when the recognition *		succeed. * * Description: * * Accepts a version array and filename, and recognize a file in the version * array with old/new mode. * "Old/new" file means the "newest existing" or "not yet existing" file with the * version which is one higher than the current highest version. * Notice that, afile and vfile are not necessary same name, because the versionless * file is recognized as an old file, afile will hold the true versionless file name, * although vfile will hold the versioned file name anyway. * afile could be used as the real UNIX pathname to access the recognized file, on * the other hand, vfile could be used as file name from which the file name * which should be returned to Lisp could be produced. * */get_old_new(dir, varray, afile, vfile)	register char		*dir;	register FileName	*varray;	register char		*afile;	register char		*vfile;E 50E 29E 25I 25D 30register FileName	*version_array;E 30E 25E 17{D 17/* Old entry */E 17I 17D 25D 29FileName	*p_min;FileName	*p_0;int	min = MAXVERSION;E 29I 29D 50register FileName	*p_min;register FileName	*p_0;D 46register int	min = MAXVERSION;E 46I 46register int	minv = MAXVERSION;E 46E 29E 25I 25D 30register FileName	*p_min;register FileName	*p_0;register int	min = MAXVERSION;E 30E 25char	name[MAXPATHLEN];char	ver[VERSIONLEN];E 50I 50	char			name[MAXPATHLEN], vless[MAXPATHLEN], to_file[MAXPATHLEN];	char			ver[VERSIONLEN], vbuf[VERSIONLEN];	register int		ver_no, max_no;	int			highest_p;	register FileName	*entry;		strcpy(name, afile);	separate_version(name, ver, 1);E 50D 50	p_0 = 0;	p_min = 0;	for(;version_array->version_no != LASTVERSIONARRAY; ++version_array){		if(version_array->version_no == 0){			strcpy(name, version_array->name);			parseversion(name, ver);			if(CheckOnlyNumber(ver))				p_0 = version_array;		}else{D 46			if(version_array->version_no < min){E 46I 46			if(version_array->version_no < minv){E 46				/* find large number */				strcpy(name, version_array->name);				parseversion(name, ver);				if(CheckOnlyNumber(ver)){D 46					min = version_array->version_no;E 46I 46					minv = version_array->version_no;E 46					p_min = version_array;				}			}E 50I 50	if (NoFileP(varray)) {		/*		 * If there is no file with such name, "old/new" file is always		 * recognized.		 */		if (*ver == '\0' || strcmp(ver, "1") == 0) {			/*			 * If version is not specified or 1 is specified,			 * we can return versionless file as afile.			 */			ConcNameAndVersion(name, "1", afile);			ConcDirAndName(dir, afile, vfile);			ConcDirAndName(dir, name, afile);			return(1);		} else {			/*			 * A version other than 1 is specified.  "New" file			 * is recognized as if.			 */			ConcDirAndName(dir, afile, vfile);			strcpy(afile, vfile);			return(1);E 50		}	}D 46	if( (min == MAXVERSION) && (p_0 != 0) )E 46I 46D 50	if( (minv == MAXVERSION) && (p_0 != 0) )E 46		return(p_0);	else		return(p_min);E 17}D 17DSK_getsize()E 17I 17D 19D 29/**GetVersionName(version_array, number, file)FileName	*version_array;int	number;char	*file;E 17{D 17/* Old entry */E 17I 17	for(;version_array->version_no != LASTVERSIONARRAY; ++version_array){		if(version_array->version_no == number){			strcpy(file, version_array->name);			return(T);		}	}	return(NIL);E 17}I 17***/E 17E 29E 19D 17DSK_currentdir()E 17I 17LinkWithVersionlessP(path, file)char	*path;char	*file;E 17{I 25register ino_t	ino;register int	rval;register DIR	*dirp;register struct direct	*dp;register char	*cp, *cp1;struct stat sbuf;E 25I 23char	name[MAXPATHLEN];E 23D 17/* Old entry */E 17I 17D 29char	save_file[MAXPATHLEN];E 29I 29D 30register ino_t	ino;register int	rval;register DIR	*dirp;register struct direct	*dp;register char	*cp, *cp1;E 29I 23char	ver[VERSIONLEN];D 25int	v;E 23struct stat sbuf;D 29ino_t	ino;char	*cp, *cp1;int	rval;D 23E 29I 29char	name[MAXPATHLEN];E 30char	save_file[MAXPATHLEN];char	ver[VERSIONLEN];I 41#ifdef	FSERROR	ERRSETJMP(0);#elseE 41	SETJMP(0);I 41#endifE 41E 29E 23I 23DIR	*dirp;struct direct	*dp;E 25E 23I 19D 30	SETJMP(0);E 30E 19	sprintf(save_file, "%s/%s", path, file);	if( (cp=rindex(save_file, '~'))!=0 && (cp1=index(save_file, '~'))!=0 && cp1!=cp && *(cp1-1) == '.'){		/* save_file with version */		TIMEOUT(rval=stat(save_file, &sbuf));		if(rval != 0){I 40#ifdef FSERROR			*Lisp_errno = errno;#endifE 40			err_mess("stat", errno);D 23D 29			return(NIL);E 29I 29			return(0);E 50I 50		if (get_versionless(varray, vless, dir) == 0) {		/*		 * There is no versionless file, but at least one vernsioned		 * file exists.		 */		if (*ver == '\0') {			/*			 * No version is specified.  The highest versioned file			 * is an old file.			 */			FindHighestVersion(varray, entry, max_no);			ConcDirAndName(dir, entry->name, afile);			strcpy(vfile, afile);			return(1);		} else {			/*			 * A version is specified.  We have to walk thorough			 * varray and try to find the file with the specified			 * version.			 */			ver_no = atoi(ver);			FindSpecifiedVersion(varray, entry, ver_no);			if (entry != NULL) {				ConcDirAndName(dir, entry->name, afile);				strcpy(vfile, afile);				return(1);			}			/*			 * There is not a file with the specified version in varray.			 * The specified file can be recognized as if.			 * Most user will hope to create a new file in same case as			 * old.   One of case sensitive names in the files are stored			 * in the trail marker entry in varray by get_version_array			 * routine.			 * We will use it, although we cannot say all of the gathered			 * files has the name in same case.			 */			while (varray->version_no != LASTVERSIONARRAY) varray++;			ConcNameAndVersion(varray->name, ver, afile);			ConcDirAndName(dir, afile, vfile);			strcpy(afile, vfile);			return(1);E 50E 29E 23I 23D 30			return(0);E 30E 23		}D 23D 29		if(sbuf.st_nlink == 1)			return(NIL);E 29I 29D 50		if(sbuf.st_nlink == 1){			return(0);E 50I 50	} else if (OnlyVersionlessP(varray)) {		/*		 * There is only versionless file in varray.		 * If the specified version is 1 the versionless file is regarded		 * as version 1 file.		 */		if (*ver == '\0') {			/*			 * No version is specified.  The versionless file is dealt			 * with as version 1.			 */			ConcNameAndVersion(vless, "1", vfile);			strcpy(afile, vless);			return(1);		} else {			ver_no = atoi(ver);			if (ver_no == 1) {				/*				 * Version 1 is specified.  The versionless file is				 * dealt with as a version 1 file.				 */				ConcNameAndVersion(name, "1", afile);				ConcDirAndName(dir, afile, vfile);				strcpy(afile, vless);				return(1);			} else {				/*				 * Other versions than 1 are recognized as if.				 */				ConcDirAndName(dir, afile, vfile);				strcpy(afile, vfile);				return(1);			}E 50		}E 29E 23I 23D 30		if(sbuf.st_nlink == 1){			return(0);		}E 30E 23D 50		ino = sbuf.st_ino;		/* make versionless file */		*(cp1-1) = '\0';		/* get inode of versionless file */		TIMEOUT(rval=stat(save_file, &sbuf));		if(rval != 0){D 23D 29			err_mess("stat", errno);			return(NIL);E 29I 29			if(errno != ENOENT){I 40#ifdef FSERROR				*Lisp_errno = errno;#endifE 40				err_mess("stat", errno);				return(0);			}else{				/* check with case in-sensitiveness */				strcpy(save_file, file);				if((cp=index(save_file, '~'))==0)					return(0);				/* make versionless */				*(cp-1) = '\0';				DOWNCASE(save_file);				TIMEOUT(dirp = opendir(path));				if(dirp == (DIR *)NULL){I 40#ifdef FSERROR					*Lisp_errno = errno;#endifE 40					return(0);				}				for(S_TOUT(dp=readdir(dirp)); dp!=(struct direct *)NULL; S_TOUT(dp=readdir(dirp)) ){					strcpy(name, dp->d_name);					parseversion(name, ver);					DOWNCASE(name);					rval = atoi(ver);					if( (rval == 0) && STREQ(save_file, name) ){						/* case in-sensitive versionless file exist */						sprintf(save_file, "%s/%s", path, dp->d_name);						TIMEOUT(rval=stat(save_file, &sbuf));						if(rval != 0){I 40#ifdef FSERROR							*Lisp_errno = errno;#endifE 40							err_mess("stat", errno);							TIMEOUT( closedir(dirp) );							return(0);						}						if(ino == sbuf.st_ino){							TIMEOUT( closedir(dirp) );							return(1);						}else{							TIMEOUT( closedir(dirp) );							return(0);						}	E 50I 50	} else {		if (check_vless_link(vless, varray, to_file, &highest_p) == 0)		  return(0);		if (*to_file == '\0') {			/*			 * There is a versionless file in varray and at least one			 * versioned file exists.  The versionless file is not linked			 * to any file in varray.			 */			if (*ver == '\0') {				/*				 * No version is specified.  The one higher than an				 * exisiting maximum version is dealt with as the				 * old version, and it should be a version of the				 * link missing versionless file.				 */				FindHighestVersion(varray, entry, max_no);				sprintf(vbuf, "%d", max_no + 1);				ConcNameAndVersion(vless, vbuf, vfile);				strcpy(afile, vless);				return(1);			} else {				/* A version is specified. */				ver_no = atoi(ver);				FindHighestVersion(varray, entry, max_no);				if (ver_no == max_no + 1) {					/*					 * If the version is one higher than the					 * existing highest version is specified, it					 * is dealt with as a version of the link					 * missing versionless file.					 */					sprintf(vbuf, "%d", ver_no);					ConcNameAndVersion(vless, vbuf, vfile);					strcpy(afile, vless);					return(1);				} else {					/*					 * We have to walk through varray and try					 * to find the file with the specified version.					 */					FindSpecifiedVersion(varray, entry, ver_no);					if (entry != NULL) {						ConcDirAndName(dir, entry->name, afile);						strcpy(vfile, afile);						return(1);E 50					}D 50				}/* end for(dp= .. */				TIMEOUT( closedir(dirp) );				return(0);			}/* end else part of if(errno== .. */	E 50I 50					/*					 * There is not a file with the specified					 * version in varray.  The specified file can					 * be recognized as if.					 * Most user will hope to create a new file in					 * same case as old.   One of case sensitive					 * names in the files are stored in the trail					 * marker entry in varray by get_version_array					 * routine.					 * We will use it, although we cannot say all					 * of the gathered files has the name in same					 * case.					 */					while (varray->version_no != LASTVERSIONARRAY)					  varray++;					ConcNameAndVersion(varray->name, ver, afile);					ConcDirAndName(dir, afile, vfile);					strcpy(afile, vfile);					return(1);				}			}		} else {			/*			 * There is a versionless file in varray and at least one			 * versioned file exists.  The versionless file is linked to			 * one of files in varray.			 */			if (*ver == '\0') {				/*				 * No version is specified.  The highest versioned file				 * in varray is an old file.				 */				FindHighestVersion(varray, entry, max_no);				ConcDirAndName(dir, entry->name, afile);				strcpy(vfile, afile);				return(1);			} else {				/*				 * A version is specified.  We have to walk thorough				 * varray and try to find the file with the specified				 * version.				 */				ver_no = atoi(ver);				FindSpecifiedVersion(varray, entry, ver_no);				if (entry != NULL) {					ConcDirAndName(dir, entry->name, afile);					strcpy(vfile, afile);					return(1);				}				/*				 * There is not a file with the specified				 * version in varray.  The specified file can				 * be recognized as if.				 * Most user will hope to create a new file in				 * same case as old.   We will use the name of				 * the highest versioned file as the name of the				 * new file.				 */				FindHighestVersion(varray, entry, max_no);				strcpy(vless, entry->name);				separate_version(vless, vbuf, 1);				ConcDirAndName(dir, vless, afile);				ConcNameAndVersion(afile, ver, vfile);				strcpy(afile, vfile);				return(1);			}E 50E 29E 23I 23D 30			if(errno != ENOENT){				err_mess("stat", errno);				return(0);			}else{				/* check with case in-sensitiveness */				strcpy(save_file, file);				if((cp=index(save_file, '~'))==0)					return(0);				/* make versionless */				*(cp-1) = '\0';				DOWNCASE(save_file);				TIMEOUT(dirp = opendir(path));				if(dirp == (DIR *)NULL){					return(0);				}				for(S_TOUT(dp=readdir(dirp)); dp!=(struct direct *)NULL; S_TOUT(dp=readdir(dirp)) ){					strcpy(name, dp->d_name);					parseversion(name, ver);					DOWNCASE(name);D 25					v = atoi(ver);					if( (v == 0) && STREQ(save_file, name) ){E 25I 25					rval = atoi(ver);					if( (rval == 0) && STREQ(save_file, name) ){E 25						/* case in-sensitive versionless file exist */						sprintf(save_file, "%s/%s", path, dp->d_name);						TIMEOUT(rval=stat(save_file, &sbuf));						if(rval != 0){							err_mess("stat", errno);							TIMEOUT( closedir(dirp) );							return(0);						}						if(ino == sbuf.st_ino){							TIMEOUT( closedir(dirp) );							return(1);						}else{							TIMEOUT( closedir(dirp) );							return(0);						}						}				}/* end for(dp= .. */				TIMEOUT( closedir(dirp) );				return(0);			}/* end else part of if(errno== .. */	E 30E 23		}D 23D 29		if(ino == sbuf.st_ino)			return(T);		else			return(NIL);E 29I 29D 50		if(ino == sbuf.st_ino){			return(1);		}else{			return(0);		}E 29E 23I 23D 30		if(ino == sbuf.st_ino){			return(1);		}else{			return(0);		}E 30E 23	}else{		/* save_file has no version */D 23D 29		return(NIL);E 29I 29D 30		return(0);E 30E 29E 23I 23		return(0);E 50E 23	}E 17}I 17D 50	E 50E 17E 1