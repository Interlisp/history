h24507s 00003/00003/00387d D 1.17 93/02/08 14:59:19 sybalsky 17 16c Big VM (and new CDR coding) changes for 3.0 \nes 00006/00003/00384d D 1.16 92/11/25 21:13:11 sybalsky 16 15c Fixing endif's with extra text => comment. \nes 00004/00004/00383d D 1.15 92/04/21 17:25:06 sybalsky 15 14c shortening file names for DOS \nes 00004/00004/00383d D 1.14 91/08/19 16:23:12 sybalsky 14 13c Use fillpointer for string length instead of totalsizees 00011/00002/00376d D 1.13 91/02/26 14:27:43 sybalsky 13 12c Make hashing fns know about 3-byte atomses 00000/00000/00378d D 1.12 90/04/20 01:53:59 sybalsky 12 11c ortening file names, bulk change.es 00002/00001/00376d D 1.11 90/03/29 20:29:46 sybalsky 11 10c make sxhash-string obey limit of 13 chars in making hash valuees 00013/00003/00364d D 1.10 90/03/25 16:38:38 sybalsky 10 9c cd ../bines 00005/00004/00362d D 1.9 90/03/05 14:27:52 takeshi 9 8c commented out obsolete vares 00009/00009/00357d D 1.8 90/01/31 13:31:29 sybalsky 8 7c Make byte-swap safe, the string & bit-vector hashing functions in particular.es 00008/00008/00358d D 1.7 89/03/18 04:03:37 sybalsky 7 6c OneDArrayes 00157/00004/00209d D 1.6 89/03/02 11:50:36 sybalsky 6 5c STRINGHASHBITS and STRING-EQUAL-HASHBITS added.es 00049/00068/00164d D 1.5 89/02/28 04:00:18 sybalsky 5 4c Added BIGNUM, RATIO, COMPLEX cases -- now complete.es 00000/00001/00232d D 1.4 89/02/27 12:07:07 shih 4 3c wrong sccsides 00082/00009/00151d D 1.3 89/02/24 13:44:41 sybalsky 3 2c Most other cases added. still need ratio, complex, bignum.es 00038/00009/00122d D 1.2 89/02/21 17:24:39 sybalsky 2 1c Got strings, lists working.  Need bitvectors, pathnames.es 00131/00000/00000d D 1.1 89/02/17 18:41:45 sybalsky 1 0c date and time created 89/02/17 18:41:45 by sybalskyeuUtTI 1D 8/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 8I 8D 9/* @(#) sxhash.c Version 1.7 (3/18/89). copyright envos & Fuji Xerox  */static char *id = "@(#) sxhash.c	1.7 3/18/89		(envos & Fuji Xerox)";E 9I 9/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%      %I% %G%         (venue & Fuji Xerox)";E 9E 8D 4/* %Z% %M% Version %I% (%G%). copyright John Sybalsky  */E 4/* *	Copyright (C) 1989 John Sybalsky. All rights reserved. * *	Author :  John Sybalsky * */I 10/************************************************************************//*									*//*	Copyright 1989, 1990 Venue					*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 10#include <stdio.h>#include "lispemul.h"D 15#include "lispglobal.h"E 15I 15#include "lspglob.h"E 15#include "lispmap.h"D 15#include "lisptypes.h"#include "emulglobal.h"#include "address68k.h"E 15I 15#include "lsptypes.h"#include "emlglob.h"#include "adr68k.h"E 15#include "address.h"#include "stack.h"#include "cell.h"D 2#include "gc.h"E 2I 2#include "array.h"E 2#include "arith.h"D 5#define BITSPERWORD	(16)	/* temp definition	*/#define PUNT_SXHASH {\	if(SXHASH_index==0xFFFFFFFF){				\	   SXHASH_index=get_package_atom("SXHASH",6,"LISP",4, NIL); \	   if(SXHASH_index==0xffffffff)				\		{error("SXHASH install failed");		\		return;}  }					\	ccfuncall(SXHASH_index,1,3);return;}I 3/*****************************************//* Rotates the top 7 bits to the bottom. *//*					 *//*   Matches the macro SXHASH-ROT in     *//*   the file CMLHASH, and must change   *//*   whenever it changes.                *//*****************************************//* #define rotate(value) (((temp = value)<<7) | ((temp>>9) & 0x7f)) */E 5E 3/** Follows definition in LLARRAYELT: **/#define EQHASHINGBITS(item)  ( (((item)>>16)&0xFFFF) ^ ( (((item)&0x1FFF)<<3) ^ (((item)>>9)& 0x7f) ) )I 3D 5	/******************************************/	/*        Lisp's PATHNAME datatype        */	/*                                        */	/*   This MUST change whenever the Lisp   */	/*   definition of the PATHNAME structure */	/*   changes.                             */	/*                                        */	/******************************************/typedef  struct    {      LispPTR host;      LispPTR device;      LispPTR directory;      LispPTR name;      LispPTR type;      LispPTR version;    } PATHNAME;E 5E 3  D 5LispPTR SXHASH_index; /* atom number for CL:SXHASH */D 3LispPTR PATHNAME_typename; /* Atom # for cl:pathname type name */E 3I 3LispPTR PATHNAME_typename = 0; /* Atom # for cl:pathname type name */E 3unsigned PATHNAME_type;  /* Type # for CL:PATHNAME */E 5D 5E 5/****************************************************************//*                                                              *//*                            SXHASH                            *//*								*//*         C-coded version of the hashing function SXHASH       *//*								*//****************************************************************/typedef   struct    {	LispPTR      object;     } SXHASHARG;LispPTR SX_hash (args)  register SXHASHARG *args;  {D 3    if (PATHNAME_typename == 0xFFFFFFFF)E 3I 3D 5    if (PATHNAME_typename == 0)E 3      {        PATHNAME_typename =	    get_package_atom("\004\003PATHNAMETYPE#",15,"LISP",4,NIL);        PATHNAME_type =	    (*((LispPTR*)GetVALCELL68k(PATHNAME_typename))) & 0xFFFF;      }E 5D 2    return(S_POSITIVE | (sxhash(args->object)));E 2I 2    return(S_POSITIVE | ( 0xFFFF & (sxhash(args->object))));E 2    /* Smash the top of the stack to a 0xe, offset */  }/*****************************************************************//*                             sxhash                            *//*                                                               *//* Internal function, called from SXHASH, and used for recursive *//*     calls, e.g., for hashing lists and compound objects.      *//* Fails to handle ratios, complex's, bitvectors pathnames & odd *//* cases *//*****************************************************************/sxhash (obj)  LispPTR obj;  {D 2    unsigned hashOffset;E 2I 2D 9    unsigned short hashOffset;E 9I 9   /* unsigned short hashOffset; Not Used */E 9E 2    unsigned int cell;    unsigned typen;D 7    ONEDARRAAY* str;E 7I 7    OneDArray* str;E 7D 17    switch (0xFFFF0000 & obj)E 17I 17    switch (SEGMASK & obj)E 17      {	case S_POSITIVE:	case S_NEGATIVE: return(obj & 0xFFFF);	default: switch (typen=GetTypeNumber(obj))		   {D 5		     case TYPE_FIXP: return((FIXP_VALUE(obj)) & 0xFFFF);		     case TYPE_FLOATP:				       cell = (unsigned int) FIXP_VALUE(obj);E 5I 5		     case TYPE_FIXP:   return((FIXP_VALUE(obj)) & 0xFFFF);		     case TYPE_FLOATP: cell = (unsigned int) FIXP_VALUE(obj);E 5				       return((cell&0xFFFF)^(cell>>16));I 13#ifdef BIGATOMS		     case TYPE_NEWATOM: /* as for LITATOM... */D 16#endif BIGATOMSE 16I 16#endif /* BIGATOMS */E 16E 13		     case TYPE_LITATOM: return(EQHASHINGBITS(obj));		     case TYPE_LISTP: return(sxhash_list(obj));I 5		     case TYPE_PATHNAME: return(sxhash_pathname(obj));E 5		     case TYPE_ONED_ARRAY:D 7		     case TYPE_GENERAL_ARRAY: str = (ONEDARRAAY *)E 7I 7		     case TYPE_GENERAL_ARRAY: str = (OneDArray *)E 7						     Addr68k_from_LADDR(obj);					      if (str->stringp)D 2						     return(sxhash_string(obj));E 2I 2						     return(sxhash_string(str));I 3					      if (str->bitp)						     return(sxhash_bitvec(str));E 3E 2					      return(EQHASHINGBITS(obj));D 3		     default: if (typen == PATHNAME_type) PUNT_SXHASH;E 3I 3D 5		     default: if (typen == PATHNAME_type)				return(sxhash_pathname(obj));E 3			      return(EQHASHINGBITS(obj));E 5I 5		     case TYPE_BIGNUM:			{			  LispPTR contents;			  contents = ((BIGNUM *)Addr68k_from_LADDR(obj))					  -> contents;			  return ( (unsigned short) car(contents) + 				 ( ((unsigned short) car(cdr(contents))) <<12));			}		     case TYPE_COMPLEX:	{					  COMPLEX *object;					  object = (COMPLEX *)						     Addr68k_from_LADDR(obj);					  return (sxhash(object->real)						   ^ sxhash(object->imaginary));					}		     case TYPE_RATIO:	{					  RATIO *object;					  object = (RATIO *)						     Addr68k_from_LADDR(obj);					  return (sxhash(object->numerator) ^						   sxhash(object->denominator));					}		     default: return(EQHASHINGBITS(obj));E 5		   }      }  }sxhash_string(obj)D 2  LispPTR obj;E 2I 2D 7  ONEDARRAAY* obj;E 7I 7  OneDArray* obj;E 7E 2  {D 2    return(0);E 2I 2D 5    char *thin;D 3    unsigned short *fat;E 3I 3    register unsigned short *fat;E 5E 3    unsigned i, len, offset;D 5    unsigned short hash = 0;E 5I 5    register unsigned short hash = 0;E 5D 11    len = (unsigned)obj -> totalsize;E 11I 11D 14    len = (unsigned)obj ->totalsize;E 14I 14    len = (unsigned)obj ->fillpointer;E 14    if (len > 13) len = 13;E 11    offset = (unsigned)obj -> offset;    switch (obj -> typenumber)      {D 5	case THIN_CHAR_TYPENUMBER: thin = ((char *)E 5I 5	case THIN_CHAR_TYPENUMBER: {				     register char *thin;				     register unsigned i;				     thin = ((char *)					     (Addr68k_from_LADDR(obj->base)))						 + offset;D 6				    for (i=offset;i<len;i++)E 6I 6				    for (i=0;i<len;i++)E 6D 8				      hash = sxhash_rotate(hash^(*thin++));E 8I 8				      hash = sxhash_rotate(hash^GETBYTE(thin++));E 8				    }				    break;	case FAT_CHAR_TYPENUMBER:  {				     register unsigned short *fat;				     register unsigned i;D 6				     fat = ((short *)E 6I 6				     fat = ((unsigned short *)E 6E 5					    (Addr68k_from_LADDR(obj->base)))D 5						+ offset;				   for (i=offset;i<len;i++)D 3				     hash = rotate(hash^(*thin++));E 3I 3				     hash = sxhash_rotate(hash^(*thin++));E 3				   break;	case FAT_CHAR_TYPENUMBER:  fat = ((short *)					   (Addr68k_from_LADDR(obj->base)))						+ offset;				   for (i=offset;i<len;i++)D 3				     hash = rotate(hash^(*fat++));E 3I 3				     hash = sxhash_rotate(hash^(*fat++));E 3				   break;E 5I 5						 + offset;D 6				     for (i=offset;i<len;i++)E 6I 6				     for (i=0;i<len;i++)E 6D 8				       hash = sxhash_rotate(hash^(*fat++));E 8I 8				       hash = sxhash_rotate(hash^GETWORD(fat++));E 8				    }				    break;E 5	default: error("SXHASH of a string not made of chars!\n");      }    return(hash);E 2  }I 3sxhash_bitvec(obj)D 7  ONEDARRAAY* obj;E 7I 7  OneDArray* obj;E 7  {    unsigned short *base;    unsigned i, len, offset, bitoffset;    unsigned short hash = 0;D 14    len = (unsigned)obj -> totalsize;E 14I 14    len = (unsigned)obj -> fillpointer;E 14    offset = (unsigned)obj -> offset;D 6    base = ((short *)(Addr68k_from_LADDR(obj->base))) + (offset>>4);E 6I 6    base = ((unsigned short *)(Addr68k_from_LADDR(obj->base))) + (offset>>4);E 6    if (offset == 0)      {	hash = (*base);	if (len<16) hash = hash >> (16-len);      }     else      {	bitoffset = offset & 15;D 8	hash = ((*base++)<<(bitoffset)) | ((*base)>>(16-bitoffset));E 8I 8	hash = (GETWORD(base++)<<(bitoffset)) | (GETWORD(base)>>(16-bitoffset));E 8	if ((len-offset) < 16) hash = hash >>(16-(len-offset));      }    return(hash);  }E 3sxhash_list(obj)  LispPTR obj;  {D 2    unsigned hash = 0;E 2I 2    unsigned short hash = 0;E 2    int counter;I 2    for (counter = 0; (counter<13)&&(GetTypeNumber(obj)==TYPE_LISTP); counter++)      {D 3	hash = rotate(hash^sxhash(car(obj)));E 3I 3	hash = sxhash_rotate(hash^sxhash(car(obj)));E 3	obj = cdr(obj);      }    return(hash);E 2  }D 2unsigned rotate(value)  unsigned value;E 2I 2D 3rotate(value)  unsigned short value;E 3I 3sxhash_pathname(obj)  LispPTR obj;E 3E 2  {I 3    unsigned short hash = 0;    PATHNAME *path;    path = (PATHNAME *)(Addr68k_from_LADDR(obj));    hash = sxhash_rotate( sxhash(path->host) ^ sxhash(path->device));    hash = sxhash_rotate(hash^sxhash(path->type));    hash = sxhash_rotate(hash^sxhash(path->version));    hash = sxhash_rotate(hash^sxhash(path->directory));    hash = sxhash_rotate(hash^sxhash(path->name));   return(hash);  }#ifndef SUN3_OS3_OR_OS4_IL/* Rotates the 16-bit work to the left 7 bits (or to the right 9 bits) */sxhash_rotate(value)  unsigned short value;	  {E 3    return ((value<<7) | ((value>>9) & 0x7f));  }I 3#endifI 6/****************************************************************//* 								*//*                     STRING-EQUAL-HASHBITS       		*//*								*//*	C-coded version of the hashing function 		*//*	STRING-EQUAL-HASHBITS in LLARRAYELT.			*//* 								*//****************************************************************/LispPTR STRING_EQUAL_HASHBITS(args)  SXHASHARG* args;  {     return(S_POSITIVE | ( 0xFFFF & (stringequalhash(args->object))));  } /* STRING_EQUAL_HASHBITS */stringequalhash(obj)  LispPTR obj;  {    unsigned i, len, offset, fatp, ind;    register unsigned short hash = 0;    PNCell *pnptr;    DLword *base;    PLCell *Prop;D 7    ONEDARRAAY *str;E 7I 7    OneDArray *str;E 7    switch (GetTypeNumber(obj))      {D 13	case TYPE_LITATOM: ind = ((int)obj)&0xFFFF;E 13I 13#ifdef BIGATOMS	case TYPE_NEWATOM:  /* as for LITATOM; it's all in the macros below. */D 16#endif BIGATOMSE 16I 16#endif /* BIGATOMS */E 16D 17	case TYPE_LITATOM: ind = ((int)obj)&0xFFFFFF;E 17I 17	case TYPE_LITATOM: ind = ((int)obj)&POINTERMASK;E 17E 13			   pnptr = (PNCell *) GetPnameCell(ind);			   base= (DLword *)Addr68k_from_LADDR(pnptr->pnamebase);			   Prop = (PLCell *) GetPropCell(ind);			   fatp = Prop->fatpnamep;			   offset = 1;D 9			   len = *((char *) base);E 9I 9D 10			   /*len = *((char *) base);*/			   len = GETBYTE(base);E 10I 10			   len = GETBYTE((unsigned char *)base);E 10E 9			   break;	case TYPE_ONED_ARRAY:D 7	case TYPE_GENERAL_ARRAY: str = (ONEDARRAAY *)E 7I 7	case TYPE_GENERAL_ARRAY: str = (OneDArray *)E 7				     Addr68k_from_LADDR(obj);			      if (str->stringp)				{				  fatp=(str->typenumber) == FAT_CHAR_TYPENUMBER;				  base = Addr68k_from_LADDR(str->base);				  offset = str->offset;D 14				  len = str->totalsize;E 14I 14				  len = str->fillpointer;E 14				}			       else return(EQHASHINGBITS(obj));			      break;	default: return(EQHASHINGBITS(obj));      };    if (fatp)     {	register unsigned short *fat;	register unsigned i;	fat = ((unsigned short *) base) + offset;	for (i=0;i<len;i++)	  {	    hash = hash + ((hash&0xFFF)<<2);D 8	    hash = hash + (0x20 | (*fat++)) + ((hash & 0xFF)<<8);E 8I 8	    hash = hash + (0x20 | GETWORD(fat++)) + ((hash & 0xFF)<<8);E 8	  }     }    else     {	register char *thin;	register unsigned i;	thin = ((char *) base) + offset;	for (i=0;i<len;i++)	  {	    hash = hash + ((hash&0xFFF)<<2);D 8	    hash = hash + (0x20 | (*thin++)) + ((hash & 0xFF)<<8);E 8I 8	    hash = hash + (0x20 | GETBYTE(thin++)) + ((hash & 0xFF)<<8);E 8	  }     }    return(hash);  }/****************************************************************//* 								*//*                        STRING-HASHBITS         		*//*								*//*	C-coded version of the hashing function 		*//*	STRINGHASHBITS in LLARRAYELT.				*//* 								*//****************************************************************/LispPTR STRING_HASHBITS(args)  SXHASHARG* args;  {     return(S_POSITIVE | ( 0xFFFF & (stringhash(args->object))));  } /* STRING_HASHBITS */stringhash(obj)  LispPTR obj;  {    unsigned i, len, offset, fatp, ind;    register unsigned short hash = 0;    PNCell *pnptr;    DLword *base;    PLCell *Prop;D 7    ONEDARRAAY *str;E 7I 7    OneDArray *str;E 7    switch (GetTypeNumber(obj))      {D 13	case TYPE_LITATOM: ind = ((int)obj)&0xFFFF;E 13I 13#ifdef BIGATOMS	case TYPE_NEWATOM:  /* as for LITATOM; it's all in the macros below. */D 16#endif BIGATOMSE 16I 16#endif /* BIGATOMS */E 16D 17	case TYPE_LITATOM: ind = ((int)obj)&0xFFFFFF;E 17I 17	case TYPE_LITATOM: ind = ((int)obj)&POINTERMASK;E 17E 13			   pnptr = (PNCell *) GetPnameCell(ind);			   base= (DLword *)Addr68k_from_LADDR(pnptr->pnamebase);			   Prop = (PLCell *) GetPropCell(ind);			   fatp = Prop->fatpnamep;			   offset = 1;D 10			   len = *((char *) base);E 10I 10			   len = GETBYTE((unsigned char *) base);E 10			   break;	case TYPE_ONED_ARRAY:D 7	case TYPE_GENERAL_ARRAY: str = (ONEDARRAAY *)E 7I 7	case TYPE_GENERAL_ARRAY: str = (OneDArray *)E 7				     Addr68k_from_LADDR(obj);			      if (str->stringp)				{				  fatp=(str->typenumber) == FAT_CHAR_TYPENUMBER;				  base = Addr68k_from_LADDR(str->base);				  offset = str->offset;D 14				  len = str->totalsize;E 14I 14				  len = str->fillpointer;E 14				}			       else return(EQHASHINGBITS(obj));			      break;	default: return(EQHASHINGBITS(obj));      }; /* switch */    if (fatp)     {	register unsigned short *fat;	register unsigned i;	fat = ((unsigned short *) base) + offset;	for (i=0;i<len;i++)	  {	    hash = hash + ((hash&0xFFF)<<2);D 8	    hash = hash + (*fat++) + ((hash & 0xFF)<<8);E 8I 8	    hash = hash + GETWORD(fat++) + ((hash & 0xFF)<<8);E 8	  }     }    else     {	register char *thin;	register unsigned i;	thin = ((char *) base) + offset;	for (i=0;i<len;i++)	  {	    hash = hash + ((hash&0xFFF)<<2);D 8	    hash = hash + (*thin++) + ((hash & 0xFF)<<8);E 8I 8	    hash = hash + GETBYTE(thin++) + ((hash & 0xFF)<<8);E 8	  }     }    return(hash);  }  /* stringhash */E 6E 3E 1