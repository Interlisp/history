h23916s 00007/00007/00132d D 1.3 93/02/08 14:56:37 sybalsky 3 2c Big VM (and new CDR coding) changes for 3.0 \nes 00017/00007/00122d D 1.2 92/04/22 14:02:10 sybalsky 2 1c fix SCCS headeres 00129/00000/00000d D 1.1 92/04/21 15:29:08 sybalsky 1 0c date and time created 92/04/21 15:29:08 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";D 2/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Author	:	Hiroshi Hayata */E 2I 2/************************************************************************//*									*//*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************/E 2#include <stdio.h>#include "lispemul.h"#include "lspglob.h"#include "adr68k.h"#include "lispmap.h"#include "lsptypes.h"#include "emlglob.h"/*** NOTE: these routines likely not called (see inlinedefsC.h) ***//************************************************************ N_OP_addbase	entry		ADDBASE		OPCODE[0320]	1.	<<Enter>>		TopOfStack: offset		*(CurrentStackPTR): base address	2.	if High word of TopOfStack is SMALLPL or SMALLNEG,		then add base address and offset and set result to TopOfStack.		else call ufn2incs.	4.	<<Exit>>		return: new address***********************************************************/LispPTR N_OP_addbase(base, offset)	register int base, offset;{D 3	base = 0xFFFFFF & base;	switch( (0xFFFF0000 & offset) ){E 3I 3	base = POINTERMASK & base;	switch( (SEGMASK & offset) ){E 3	case S_POSITIVE:		return(base + (offset & 0x0000FFFF));	case S_NEGATIVE:		return(base + (offset | 0xFFFF0000));	default:		switch( (GetTypeNumber(offset)) ){		case TYPE_FIXP:			/* overflow or underflow isn't check */			return(base + *(int *)Addr68k_from_LADDR(offset));		default:	/* floatp also */			ERROR_EXIT(offset);		}/* end switch */	}/* end switch */}/************************************************************ N_OP_getbasebyte	entry		GETBASEBYTE		OPCODE[0302]	1.	<<Enter>>		*(--CurrentStackPTR): base address.		TopOfStack:	Low word - byte offset.	2.	if high word of TopOfStack is not SMALLPL,		then	call ufn2incS.		else	fetch 8 bits word at (base address + byte offset).	4.	<<Exit>>		return:		Least Low Byte - fetched data***********************************************************/N_OP_getbasebyte(base_addr, byteoffset)	register LispPTR base_addr;	register int byteoffset;{D 3	switch( (0xFFFF0000 & byteoffset) ){E 3I 3	switch( (SEGMASK & byteoffset) ){E 3	case S_POSITIVE:		byteoffset =  byteoffset & 0x0000FFFF;		break;	case S_NEGATIVE:		byteoffset = byteoffset | 0xFFFF0000;		break;	default:		switch( (GetTypeNumber(byteoffset)) ){		case TYPE_FIXP:			byteoffset = *((int *)Addr68k_from_LADDR(byteoffset));			break;		default:	/* floatp also fall thru */			ERROR_EXIT(byteoffset);			}/* end switch */		break;	}/* end switch */D 3	return((0xFF & (GETBYTE((char*)Addr68k_from_LADDR((0xFFFFFF & base_addr)) + byteoffset))) | S_POSITIVE);E 3I 3	return((0xFF & (GETBYTE((char*)Addr68k_from_LADDR((POINTERMASK & base_addr)) + byteoffset))) | S_POSITIVE);E 3}/************************************************************ N_OP_putbasebyte	entry		PUTBASEBYTE		OPCODE[0307]	1.	<<Enter>>		TopOfStack:	Least Low Byte - replace data.		*((int *)(CurrentStackPTR-1)): byte offset.		*((int *)(CurrentStackPTR-2)): base address.	4.	<<Exit>>		return:		Least Low Byte - replace data ?***********************************************************/N_OP_putbasebyte(base_addr, byteoffset, tos)	register LispPTR base_addr;	register int byteoffset;	register int tos;{D 3	if(((0xFFFF0000 & tos ) != S_POSITIVE) || ((unsigned short)tos >= 256))E 3I 3	if(((SEGMASK & tos ) != S_POSITIVE) || ((unsigned short)tos >= 256))E 3		ERROR_EXIT(tos);D 3	switch( (0xFFFF0000 & byteoffset) ){E 3I 3	switch( (SEGMASK & byteoffset) ){E 3	case S_POSITIVE:		byteoffset &=  0x0000FFFF;		break;	case S_NEGATIVE:		byteoffset |=  0xFFFF0000;		break;	default:	/* ucode and ufn don't handle displacement not smallp */		ERROR_EXIT(tos);	}/* end switch */D 3	GETBYTE(((char*)Addr68k_from_LADDR(0xFFFFFF & base_addr)) + byteoffset) = 0xFF & tos;E 3I 3	GETBYTE(((char*)Addr68k_from_LADDR(POINTERMASK & base_addr)) + byteoffset) = 0xFF & tos;E 3	return ( tos );}E 1