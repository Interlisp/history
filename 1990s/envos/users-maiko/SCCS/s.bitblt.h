h12680s 00000/00000/00076d D 2.8 92/04/21 16:22:57 sybalsky 9 8c shortening file names for DOSes 00015/00001/00061d D 2.7 90/06/04 10:32:47 sybalsky 8 7c reformat, copyrightes 00004/00006/00058d D 2.6 90/02/08 09:49:43 takeshi 7 6c Fix clear_CG6/refresh_CG6es 00014/00000/00050d D 2.5 90/02/06 20:45:14 mitani 6 5c es 00009/00009/00041d D 2.4 89/01/09 17:28:52 shih 5 4c spellinges 00006/00002/00044d D 2.3 89/01/04 17:01:53 shimizu 4 3c For C-Cursor trackinges 00000/00067/00046d D 2.2 88/06/29 17:29:59 shimizu 3 2c remove obsolateses 00000/00000/00113d D 2.1 88/05/17 10:06:04 hayata 2 1c Version up to 2.1es 00113/00000/00000d D 1.1 88/05/11 20:09:31 shimizu 1 0c date and time created 88/05/11 20:09:31 by shimizueuUtTI 1D 5/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 5I 5D 8/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 8I 8/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 8E 5/* *	Copyright (C) 1988 by Fuji Xerox Co., Ltd. All rights reserved. * *	File :  bitblt.h *D 5 *	Auther :  Osamu NakamuraE 5I 5 *	Author :  Osamu NakamuraE 5 * */I 8/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 8#define	REPLACE	0#define	PAINT	2#define	ERASE	1#define	INVERT	3#define	ERROR	PIX_SRC#define PixOperation( SRCTYPE, OPERATION )	\	( SRCTYPE == ERASE ? \		(OPERATION == REPLACE ? PIX_NOT(PIX_SRC) : \D 5		(OPERATION == PAINT ? PIX_NOT(PIX_SRC) | PIX_DST : \		(OPERATION == ERASE ? PIX_NOT(PIX_SRC) & PIX_DST : \		(OPERATION == INVERT ? PIX_NOT(PIX_SRC) ^ PIX_DST : ERROR)))) : \E 5I 5		(OPERATION == PAINT   ? PIX_NOT(PIX_SRC) | PIX_DST : \		(OPERATION == ERASE   ? PIX_NOT(PIX_SRC) & PIX_DST : \		(OPERATION == INVERT  ? PIX_NOT(PIX_SRC) ^ PIX_DST : ERROR)))) : \E 5	/*  SRCTYPE == INPUT */ \		(OPERATION == REPLACE ? PIX_SRC : \D 5		(OPERATION == PAINT ? PIX_SRC | PIX_DST : \		(OPERATION == ERASE ? PIX_SRC & PIX_DST : \		(OPERATION == INVERT ? PIX_SRC ^ PIX_DST : ERROR)))))E 5I 5		(OPERATION == PAINT   ? PIX_SRC | PIX_DST : \		(OPERATION == ERASE   ? PIX_SRC & PIX_DST : \		(OPERATION == INVERT  ? PIX_SRC ^ PIX_DST : ERROR)))))E 5/*----------------------------------------------------------------------*/extern DLword	*EmMouseX68K, *EmMouseY68K;extern int DisplayRasterWidth;#define	XDELTA	50#define	YDELTA	50#define	MOUSEXL	((int)*EmMouseX68K - XDELTA)#define	MOUSEXR	((int)*EmMouseX68K + XDELTA)#define	MOUSEYL	((int)*EmMouseY68K - YDELTA)#define	MOUSEYH	((int)*EmMouseY68K + YDELTA)D 3/*#define cursorin( addrhi, addrlo, x, w, h, y, backward) \	((addrhi == DISPALY_HI) ? \		((y = addrlo / DisplayRasterWidth), \		 (y = ((backward) ? y-h : y)), \		 ((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&& \		  (y + h > MOUSEYL)) ? \			T : NIL ) \	: ((addrhi == DISPALY_HI+1) ? \		((y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth), \		 (y = ((backward) ? y-h : y)), \		 ((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&& \		  (y + h > MOUSEYL)) ? \			T : NIL ) \	: NIL))*/E 3D 3/* y is already known	*//*#define cursorin2( addrhi, x, w, h, y) \	((addrhi == DISPALY_HI) ? \		 (((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&& \		  (y + h > MOUSEYL)) ? \			T : NIL ) \	: ((addrhi == DISPALY_HI+1) ? \		 (((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&& \		  (y + h > MOUSEYL)) ? \			T : NIL ) \	: NIL))*/E 3/*----------------------------------------------------------------------*/D 4E 4I 4#ifdef OLD_CURSORE 4extern struct winlock DisplayLockArea;D 3/*E 3#define	HideCursor	\D 3{ \	DisplayLockArea.wl_rect.r_left = min( MOUSEXL, 0); \	DisplayLockArea.wl_rect.r_top = min( MOUSEYH, 0); \	DisplayLockArea.wl_rect.r_width = 2 * XDELTA; \	DisplayLockArea.wl_rect.r_height = 2 * YDELTA; \	ioctl( LispWindowFd, WINLOCKSCREEN, &DisplayLockArea); \}*/#define	HideCursor	\E 3	ioctl( LispWindowFd, WINLOCKSCREEN, &DisplayLockArea)#define ShowCursor \	ioctl( LispWindowFd, WINUNLOCKSCREEN, &DisplayLockArea)D 3/*#define	HideCursor	hidecursor()#define ShowCursor 	showcursor()*/E 3D 4E 4I 4#elseextern DLword *EmCursorX68K,*EmCursorY68K;#define	HideCursor	{ taking_mouse_down();}D 5#define ShowCursor 	{ taking_mouse_up(*EmCursorX68K,*EmCursorY68K);}E 5I 5#define ShowCursor	{ taking_mouse_up(*EmCursorX68K,*EmCursorY68K);}E 5#endifI 6D 7#ifdef DISPLAYBUFFERE 7#define refresh_CG6 										\	HideCursor;											\D 7	pr_rop(CG6FBPixRect, 0, 0, DisplayWidth, DisplayHeight,	\			PIX_SRC,LispDisplayPixRect, 0, 0);				\E 7I 7	pr_rop(ColorDisplayPixrect, 0, 0, DisplayWidth, DisplayHeight,	\			PIX_SRC,DisplayRegionPixrect, 0, 0);				\E 7	ShowCursor;#define clear_CG6											\	HideCursor;											\D 7	pr_rop(CG6FBPixRect, 0, 0, DisplayWidth, DisplayHeight,	\			PIX_CLR, CG6FBPixRect, 0, 0);					\E 7I 7	pr_rop(ColorDisplayPixrect, 0, 0, DisplayWidth, DisplayHeight,	\			PIX_CLR, ColorDisplayPixrect, 0, 0);					\E 7	ShowCursor;D 7#endifE 7E 6E 4D 3/*********************************************************************** *	function "cursorin" is defined in bitblt.c *int cursorin( addrhi, addrlo, x, w, h, y)DLword	addrhi;		** Lisp addr hi-word	**DLword	addrlo;		** Lisp addr lo-word	**register int	x, w, h, y;{		if(addrhi == DISPALY_HI)		y = addrlo / DisplayRasterWidth;	else if(addrhi == DISPALY_HI+1)		y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth;	else 		return( NIL );				if((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))		return( T );	else 		return( NIL );}**************************************************************************/E 3E 1