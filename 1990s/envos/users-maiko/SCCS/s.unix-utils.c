h54270s 00001/00001/00441d D 1.25 92/03/20 17:22:08 sybalsky 25 24c Remove RCLK call in kbd ring buffer-fill code, since the time value is never used.es 00005/00005/00437d D 1.24 91/09/27 03:11:01 sybalsky 24 23c ISC port changeses 00008/00002/00434d D 1.23 91/09/13 15:40:58 sybalsky 23 22c Fix string-length computation for Lisp-to-C string conversion, to use fillpointer.es 00004/00004/00432d D 1.22 91/08/19 16:23:27 sybalsky 22 21c Use fillpointer for Lisp string lengthes 00054/00042/00382d D 1.21 91/05/01 18:16:58 sybalsky 21 20c Retrofit changes from MIPS porting center.es 00027/00002/00397d D 1.20 91/01/27 12:17:57 sybalsky 20 19c Retrofit HP9000/RS6000 changeses 00036/00002/00363d D 1.19 90/09/18 23:25:25 sybalsky 19 18c Add "DISPLAY" option to unix_getparm, for seeing kind of display.es 00006/00002/00359d D 1.18 90/07/25 03:00:19 sybalsky 18 17c change elif's to else #if 's (SunOS3 doesn't support elif.)es 00125/00046/00236d D 1.17 90/06/26 16:36:36 sybalsky 17 16c AIX changeses 00012/00001/00270d D 1.16 90/06/04 18:10:14 sybalsky 16 15c reformat, copyrightes 00013/00005/00258d D 1.15 90/05/15 17:39:42 fuji 15 14c getparm for MACH and ARCH work on i386es 00001/00001/00262d D 1.14 90/05/10 13:31:16 fuji 14 13c c_string_to_lisp_string write trail Null character on i386es 00000/00000/00263d D 1.13 90/04/20 02:00:48 sybalsky 13 12c AIX:  shortening file names, bulk change.es 00024/00009/00239d D 1.12 90/03/08 10:02:25 takeshi 12 11c care about byte-order in stringses 00002/00004/00246d D 1.11 90/03/02 14:46:28 takeshi 11 10c Remove ifdef around RCLKes 00018/00014/00232d D 1.10 89/03/30 20:32:24 sybalsky 10 9c Byte swapped in suspend_lisp; STRING CODE NEEDS WORK!!!es 00029/00029/00217d D 1.9 89/03/20 13:56:08 shih 9 8c cosmetic cleanupes 00004/00004/00242d D 1.8 89/03/18 04:03:14 sybalsky 8 7c OneDArrayes 00043/00000/00203d D 1.7 88/10/10 19:49:46 shimizu 7 6c suspend-lisp can notice k/b transitionses 00004/00003/00199d D 1.6 88/07/26 15:57:29 hayata 6 5c printf is used inside OSMESSAGE_PRINTes 00058/00000/00144d D 1.5 88/07/19 13:56:46 masinter 5 4c add utilties for getting enviornment variables, built in parameterses 00004/00001/00140d D 1.4 88/06/21 12:06:16 greep 4 3c change suspend_lisp to suspend the process group, not just this processes 00016/00000/00125d D 1.3 88/06/17 01:31:39 greep 3 2c new function suspend_lispes 00123/00000/00002d D 1.2 88/06/14 15:12:04 greep 2 1c new file for Unix utilities (check password, get username and person-name)es 00002/00000/00000d D 1.1 88/06/14 13:56:20 greep 1 0c date and time created 88/06/14 13:56:20 by greepeuUtTI 1D 9/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 9I 9D 16/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 16I 16/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 16E 9static char *id = "%Z% %M%	%I% %G%";I 16/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 16I 2/* unix utilities subrs */#include <pwd.h>I 3#include <signal.h>I 7#include <sys/time.h>I 20#ifndef HPUXE 20I 15#include <strings.h>I 20#endif HPUXE 20#include <stdio.h>E 15E 7E 3#include "lispemul.h"#include "address68k.h"#include "lisptypes.h"#include "lispglobal.h"I 6#include "osmessage.h"I 7#include "keyboard.h"E 7E 6D 15#define NULL 0 /* defined in stdio.h which we don't use -- foo! */E 15I 15D 17/* #define NULL 0 */ /* defined in stdio.h which we don't use -- foo! */E 17I 17/************************************************************************//*									*//*		l i s p _ s t r i n g _ t o _ c _ s t r i n g		*//*									*//*	converts lisp string up to maximum length; returns 0 if it	*//*	succeeds, -1 if error (not a simple string, or too long, or	*//*	contains NS characters outside charset 0).			*//*									*//************************************************************************/E 17E 15D 17/* lisp_string_to_c_string converts lisp string up to maximum length,	returns 0 if succeeds, -1 if error (not a simple string or	too long or has xns characters) */E 17D 9int lisp_string_to_c_string(Lisp, C, length) E 9I 9int lisp_string_to_c_string(Lisp, C, length)E 9	LispPTR Lisp;	char	*C;	int	length;{D 8	ONEDARRAAY	*arrayp;	E 8I 8D 9	OneDArray	*arrayp;	E 8	char	*base, *dp;			short	*sbase;				int	i;	E 9I 9D 12	OneDArray	*arrayp;	char	*base, *dp;	short	*sbase;	int	i;E 12I 12	register OneDArray	*arrayp;	register char	*base;E 12E 9	if (GetTypeNumber(Lisp) != TYPE_ONED_ARRAY) {return (-1);}D 9		E 9I 9E 9D 8	arrayp = (ONEDARRAAY *)(Addr68k_from_LADDR(Lisp));E 8I 8	arrayp = (OneDArray *)(Addr68k_from_LADDR(Lisp));E 8D 22	if (arrayp->totalsize >= length) {return(-1);} /* too long */E 22I 22	if (arrayp->fillpointer >= length) {return(-1);} /* too long */E 22D 9		switch(arrayp->typenumber){					case THIN_CHAR_TYPENUMBER:				E 9I 9	switch(arrayp->typenumber){	case THIN_CHAR_TYPENUMBER:E 9		base = ((char *)(Addr68k_from_LADDR(arrayp->base))) +		       ((int)(arrayp->offset));I 12#ifndef BYTESWAPE 12D 9		strncpy(C, base, arrayp->totalsize);					C[arrayp->totalsize] = '\0';						return 0;								default:									return -1;			}								E 9I 9D 22		strncpy(C, base, arrayp->totalsize);E 22I 22D 23		strncpy(C, base, arrayp->fillpointer - arrayp->offset);E 23I 23		strncpy(C, base, arrayp->fillpointer);E 23E 22I 12#else	{  register int i,length ;	   register char *dp;D 22		for(i=0,dp=C, length = arrayp->totalsize;E 22I 22D 23		for(i=0,dp=C, length = arrayp->fillpointer - arrayp->offset;E 23I 23		for(i=0,dp=C, length = arrayp->fillpointer;E 23E 22			i<length;i++)						{*dp++ =(char)(GETBYTE(base++));}	}#endif BYTESWAPE 12D 22		C[arrayp->totalsize] = '\0';E 22I 22		C[arrayp->fillpointer] = '\0';E 22		return 0;	default:		return -1;	}E 9}D 17/* c_string_to_lisp_string copies a C string into an existing Lisp string        (it does not create a new Lisp string).	returns 0 if succeeds, -1 if error (Lisp string is not a simple string,	or not long enough, or has xns characters)	The string will and with a null (which the length must include). */E 17I 17/************************************************************************//*									*//*		c _ s t r i n g _ t o _ l i s p _ s t r i n g		*//*									*//*	copies a C string into an existing Lisp string (it does not 	*//*	create a new Lisp string).  Returns 0 if succeeds, -1 if	*//*	error (Lisp string is not a simple string, or not long enough,	*//*	or is FATP).  The string will end with a null, which the	*//*	length must include.						*//*									*//************************************************************************/E 17int c_string_to_lisp_string(C, Lisp)	LispPTR Lisp;	char	*C;{D 8	ONEDARRAAY	*arrayp;	E 8I 8D 9	OneDArray	*arrayp;	E 8	char	*base, *dp;			short	*sbase;				int	i;	E 9I 9D 12	OneDArray	*arrayp;	char	*base, *dp;	short	*sbase;	int	i;E 9	int	length;E 12I 12	register OneDArray	*arrayp;	char	*base;	register int	length;E 12	length = strlen(C);	if (GetTypeNumber(Lisp) != TYPE_ONED_ARRAY) {return (-1);}D 9		E 9I 9E 9D 8	arrayp = (ONEDARRAAY *)(Addr68k_from_LADDR(Lisp));E 8I 8	arrayp = (OneDArray *)(Addr68k_from_LADDR(Lisp));E 8D 9	if (arrayp->totalsize < length+1) {return(-1);} E 9I 9	if (arrayp->totalsize < length+1) {return(-1);}E 9	    /* too short for C string */D 9		switch(arrayp->typenumber){					case THIN_CHAR_TYPENUMBER:				E 9I 9	switch(arrayp->typenumber){	case THIN_CHAR_TYPENUMBER:E 9		base = ((char *)(Addr68k_from_LADDR(arrayp->base))) +		       ((int)(arrayp->offset));I 12#ifndef BYTESWAPE 12		strcpy(base, C);I 12#else	{ register int i;	  register char *dp;D 14		for(i=0,dp = C;i<length;i++)E 14I 14		for(i=0,dp = C;i<length + 1;i++)E 14		{			GETBYTE(base++) = *dp++;		}	}#endif BYTESWAPE 12D 9		return 0;								default:									return -1;			}								E 9I 9		return 0;	default:		return -1;	}E 9}I 17/************************************************************************//*									*/I 19/*		    c h e c k _ u n i x _ p a s s w o r d		*/E 19/*									*/I 19/*	Check this guy's password against what he gave us.		*/E 19/*									*/D 19/*									*//*									*/E 19/************************************************************************/E 17check_unix_password(args)     LispPTR args[];{  struct passwd *pwd;  char *password, *getpass();  char salt[3];  char name[100], pass[100];  if (lisp_string_to_c_string(args[0], name, sizeof name)) {return NIL;}  if (lisp_string_to_c_string(args[1], pass, sizeof pass)) {return NIL;}  if ((pwd = getpwnam(name)) == 0) {    return(NIL);	/* can't find entry for name */  }  salt[0] = pwd->pw_passwd[0];  salt[1] = pwd->pw_passwd[1];  salt[2] = '\0';  if (strcmp(crypt(pass, salt), pwd->pw_passwd) == 0)    return(ATOM_T);  else    return(NIL);}I 17/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 17unix_username(args)     LispPTR args[];{  struct passwd *pwd;  if ((pwd = getpwuid(getuid())) == NULL)    return NIL;  if (c_string_to_lisp_string(pwd->pw_name, args[0]))    return NIL;  return ATOM_T;}I 17/************************************************************************//*									*/I 19/*			u n i x _ g e t p a r m				*/E 19/*									*/I 19/*	Given a string name for a configuration parameter, return	*//*	a string with the value for that parameter.			*/E 19/*									*/I 19/*	PARAMETER	MEANING/VALUES					*/E 19/*									*/I 19/*	MACH		What kind of processor we're running on		*//*			(sparc, mc68020, or i386 possible)		*/E 19/*									*/I 19/*	ARCH		The kind of machine we're running on		*//*			(sun4, sun386, sun3 possible)			*//*									*//*	DISPLAY		What kind of display we're running with		*//*			(X, BUFFERED, DIRECT possible)			*//*									*//*	HOSTNAME	Name of the machine we're running on.		*//*									*//*	LOGNAME		Login ID of the user running Lisp.		*//*									*//*	FULLUSERNAME	??						*//*									*//*	HOSTID		Machine serial# or Ether ID.			*//*									*//*									*/E 19/************************************************************************/E 17I 5char* getenv();unix_getparm(args)D 17	LispPTR         args[];{	char            envname[20], result[128], *envvalue;	if (lisp_string_to_c_string(args[0], envname, sizeof envname))		return NIL;	if (strcmp(envname, "MACH") == 0) {E 17I 17  LispPTR         args[];  {    char            envname[20], result[128], *envvalue;    if (lisp_string_to_c_string(args[0], envname, sizeof envname))    	return NIL;    if (strcmp(envname, "MACH") == 0)      {E 17D 15#ifdef sparcE 15I 15#if defined(sparc)E 15D 17		envvalue = "sparc";E 17I 17	envvalue = "sparc";E 17D 15#elseE 15I 15D 18#elif defined(I386)E 18I 18#else#if defined(I386)E 18D 17		envvalue = "i386";E 17I 17	envvalue = "i386";E 17D 20#else	E 20I 20#else#ifdef RS6000	envvalue = "rs/6000";#else#ifdef HP9000	envvalue = "hp9000";#elseD 24#ifdef AIXPS2E 24I 24#ifdef ISCE 24	envvalue = "i386";I 23#ifdef RISCOS	envvalue = "mips";E 23#elseE 20E 15D 17		envvalue = "mc68020";E 17I 17	envvalue = "mc68020";E 17#endifI 18#endifI 20#endif#endif#endifI 23#endifE 23E 20E 18D 17	} else if (strcmp(envname, "ARCH") == 0) {E 17I 17      }    else if (strcmp(envname, "ARCH") == 0)      {E 17D 15#ifdef sparcE 15I 15#if defined(sparc)E 15D 17		envvalue = "sun4";E 17I 17	envvalue = "sun4";E 17D 15#elseE 15I 15D 18#elif defined(I386)E 18I 18#else#if defined(I386)E 18D 17		envvalue = "sun386";E 17I 17	envvalue = "sun386";I 20#else#ifdef RS6000	envvalue = "rs/6000";#else#ifdef HP9000	envvalue = "hp9000";#elseD 24#ifdef AIXPS2	envvalue = "ps/2";E 24I 24#ifdef ISC	envvalue = "i386";E 24I 23#ifdef RISCOS	envvalue = "mips";E 23E 20E 17#else	E 15D 17		envvalue = "sun3";E 17I 17	envvalue = "sun3";I 23#endifE 23I 18#endifE 18E 17#endifI 19D 20E 20I 20#endif#endif#endifE 20      }     else if (strcmp(envname, "DISPLAY") == 0)      {#if defined(XWINDOW)	envvalue = "X";#else#if defined(DISPLAYBUFFER)	envvalue = "BUFFERED";#else		envvalue = "DIRECT";#endif DISPLAYBUFFER#endif XWINDOWE 19I 15E 15D 17	} else if (strcmp(envname, "HOSTNAME") == 0) {		if (gethostname(result, sizeof result))			return NIL;		envvalue = result;	} else if (strcmp(envname, "LOGNAME") == 0) {		struct passwd  *pwd;		if ((pwd = getpwuid(getuid())) == NULL)			return NIL;		envvalue = pwd->pw_name;	} else if (strcmp(envname, "FULLUSERNAME") == 0) {		struct passwd  *pwd;		if ((pwd = getpwuid(getuid())) == NULL)			return NIL;		envvalue = pwd->pw_gecos;	} else if (strcmp(envname, "HOSTID") == 0) {		sprintf(result, "%x", gethostid());		envvalue = result;	} else		return NIL;E 17I 17      }     else if (strcmp(envname, "HOSTNAME") == 0)       {	if (gethostname(result, sizeof result)) return NIL;	envvalue = result;      }     else if (strcmp(envname, "LOGNAME") == 0)      {	struct passwd  *pwd;	if ((pwd = getpwuid(getuid())) == NULL) return NIL;	envvalue = pwd->pw_name;      }     else if (strcmp(envname, "FULLUSERNAME") == 0)      {	struct passwd  *pwd;	if ((pwd = getpwuid(getuid())) == NULL) return NIL;	envvalue = pwd->pw_gecos;      }    else if (strcmp(envname, "HOSTID") == 0)      {	sprintf(result, "%x", gethostid());	envvalue = result;      }    else return NIL;E 17D 17	if (c_string_to_lisp_string(envvalue, args[1]))		return NIL;	return ATOM_T;}E 17I 17    if (c_string_to_lisp_string(envvalue, args[1])) return NIL;    return ATOM_T;  }E 17I 17/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 17unix_getenv(args)	LispPTR         args[];{	char            envname[20], *envvalue;	if (lisp_string_to_c_string(args[0], envname, sizeof envname))		return NIL;	envvalue = getenv(envname);	if (!envvalue)		return NIL;	if (c_string_to_lisp_string(envvalue, args[1]))		return NIL;	return ATOM_T;}E 5I 17/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 17unix_fullname(args)     LispPTR args[];{  struct passwd *pwd;  if ((pwd = getpwuid(getuid())) == NULL)    return NIL;  if (c_string_to_lisp_string(pwd->pw_gecos, args[0]))    return NIL;I 3  return ATOM_T;}I 17/************************************************************************//*									*/I 21/*			s u s p e n d _ l i s p				*/E 21/*									*/I 21/*	Suspend execution, ala ^Z from the shell.			*/E 21/*									*/D 21/*									*//*									*/E 21/************************************************************************/E 17I 7D 21extern DLword  *EmMouseX68K, *EmMouseY68K, *EmKbdAd068K, *EmRealUtilin68K,*EmUtilin68K;extern DLword  *EmKbdAd168K,*EmKbdAd268K,*EmKbdAd368K,*EmKbdAd468K,*EmKbdAd568K;E 21I 21extern DLword  *EmMouseX68K, *EmMouseY68K, *EmKbdAd068K, 	       *EmRealUtilin68K,*EmUtilin68K;extern DLword  *EmKbdAd168K,*EmKbdAd268K,*EmKbdAd368K,	       *EmKbdAd468K,*EmKbdAd568K;E 21E 7suspend_lisp(args)D 21     LispPTR args[];{I 7extern DLword *CTopKeyevent;extern LispPTR *KEYBUFFERING68k;E 21I 21  LispPTR args[];  {    extern DLword *CTopKeyevent;    extern LispPTR *KEYBUFFERING68k;E 21D 21DLword w,r;KBEVENT *kbevent;E 21I 21    DLword w, r;    KBEVENT *kbevent;E 21E 7D 21  if(device_before_raid() < 0) {D 6    printf("Can't suspend\n");E 6I 6    OSMESSAGE_PRINT( printf("Can't suspend\n") );E 6    return NIL;  }D 6  printf("suspending...\n");E 6I 6  OSMESSAGE_PRINT( printf("suspending...\n") );E 21I 21    if(device_before_raid() < 0)      {	OSMESSAGE_PRINT( printf("Can't suspend\n") );	return NIL;      }    OSMESSAGE_PRINT( printf("suspending...\n") );E 21E 6D 4  kill(getpid(), SIGSTOP); /* Send myself a STOP signal */E 4I 4  /* Send a terminal-stop signal to the whole process-group, not     just this process, so that if we are running as part of a     C-shell file the shell will be suspended too. */D 21  killpg(getpgrp(0), SIGTSTP);E 4D 6  printf("resuming\n");E 6I 6  OSMESSAGE_PRINT( printf("resuming\n") );E 6  device_after_raid();E 21I 21D 24#ifdef RISCOSE 24I 24#ifdef SYSVONLYE 24    kill(0, SIGTSTP);#else    killpg(getpgrp(0), SIGTSTP);D 24#endif RISCOSE 24I 24#endif SYSVONLYE 24E 21I 7D 21  r=RING_READ(CTopKeyevent);  w=RING_WRITE(CTopKeyevent);E 21D 21 /*NO CARE about event queue FULL */E 21I 21    OSMESSAGE_PRINT( printf("resuming\n") );    device_after_raid();E 21D 10  *EmKbdAd068K= KB_ALLUP;  *EmKbdAd168K= KB_ALLUP;  *EmKbdAd268K= KB_ALLUP;  *EmKbdAd368K= KB_ALLUP;  *EmKbdAd468K= KB_ALLUP;  *EmKbdAd568K= KB_ALLUP;  *EmRealUtilin68K= KB_ALLUP;E 10I 10D 21  GETWORD(EmKbdAd068K)= KB_ALLUP;  GETWORD(EmKbdAd168K)= KB_ALLUP;  GETWORD(EmKbdAd268K)= KB_ALLUP;  GETWORD(EmKbdAd368K)= KB_ALLUP;  GETWORD(EmKbdAd468K)= KB_ALLUP;  GETWORD(EmKbdAd568K)= KB_ALLUP;  GETWORD(EmRealUtilin68K)= KB_ALLUP;E 21I 21    r=RING_READ(CTopKeyevent);    w=RING_WRITE(CTopKeyevent);E 21E 10D 21  kbevent=(KBEVENT*)(CTopKeyevent+ w);E 21I 21   /*NO CARE about event queue FULL */E 21I 10D 11#ifndef BYTESWAPE 11I 11E 11E 10D 21  RCLK(kbevent->time);E 21I 21    GETWORD(EmKbdAd068K)= KB_ALLUP;    GETWORD(EmKbdAd168K)= KB_ALLUP;    GETWORD(EmKbdAd268K)= KB_ALLUP;    GETWORD(EmKbdAd368K)= KB_ALLUP;    GETWORD(EmKbdAd468K)= KB_ALLUP;    GETWORD(EmKbdAd568K)= KB_ALLUP;    GETWORD(EmRealUtilin68K)= KB_ALLUP;E 21D 10  kbevent->W0= *EmKbdAd068K;  kbevent->W1= *EmKbdAd168K;  kbevent->W2= *EmKbdAd268K;  kbevent->W3= *EmKbdAd368K;  kbevent->W4= *EmKbdAd468K;  kbevent->W5= *EmKbdAd568K;  kbevent->WU= *EmRealUtilin68K;E 10I 10D 11#else  RCLK(kbevent->time_hi,kbevent->time_lo);#endifE 11I 11E 11D 21  kbevent->W0= GETWORD(EmKbdAd068K);  kbevent->W1= GETWORD(EmKbdAd168K);  kbevent->W2= GETWORD(EmKbdAd268K);  kbevent->W3= GETWORD(EmKbdAd368K);  kbevent->W4= GETWORD(EmKbdAd468K);  kbevent->W5= GETWORD(EmKbdAd568K);  kbevent->WU= GETWORD(EmRealUtilin68K);E 21I 21    kbevent=(KBEVENT*)(CTopKeyevent+ w);E 21E 10D 21  if(r==0) /* Queue was empty */E 21I 21D 25    RCLK(kbevent->time);E 25I 25/*    RCLK(kbevent->time); */E 25    kbevent->W0= GETWORD(EmKbdAd068K);    kbevent->W1= GETWORD(EmKbdAd168K);    kbevent->W2= GETWORD(EmKbdAd268K);    kbevent->W3= GETWORD(EmKbdAd368K);    kbevent->W4= GETWORD(EmKbdAd468K);    kbevent->W5= GETWORD(EmKbdAd568K);    kbevent->WU= GETWORD(EmRealUtilin68K);    if(r==0) /* Queue was empty */E 21	((RING*)CTopKeyevent)->read=w;D 21  if(w >= MAXKEYEVENT)E 21I 21    if(w >= MAXKEYEVENT)E 21	((RING*)CTopKeyevent)->write = MINKEYEVENT;D 21  elseE 21I 21    elseE 21	((RING*)CTopKeyevent)->write = w + KEYEVENTSIZE;E 7E 3D 21  return ATOM_T;}E 21I 21    return ATOM_T;  }E 21E 2E 1