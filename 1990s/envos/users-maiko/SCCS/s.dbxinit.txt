h55493s 00007/00006/00055d D 2.2 90/03/14 11:20:41 takeshi 8 7c Use MachineStatees 00000/00000/00061d D 2.1 88/05/17 09:15:05 hayata 7 6c Version up to 2.1es 00001/00000/00060d D 1.6 88/04/27 12:43:04 bane 6 5c Added "ignore IO" so IO signals won't be caught by dbxes 00001/00001/00059d D 1.5 88/04/25 15:21:17 bane 5 4c added ignore VTALRM so dbx will let timers through to maikoes 00001/00001/00059d D 1.4 88/04/20 17:33:26 krivacic 4 3c fix go buges 00001/00000/00059d D 1.3 88/04/20 15:14:23 krivacic 3 2c added go commandes 00001/00000/00058d D 1.2 88/04/07 15:03:59 shimizu 2 1c Add warn commes 00058/00000/00000d D 1.1 88/04/04 18:22:30 shimizu 1 0c date and time created 88/04/04 18:22:30 by shimizueuUtTI 1alias a aliasa   t       tracea   d       deletea   r       runa   c       conta   q       quita   h       helpa   p       printa   l       lista   s       stepI 3D 4a   go	    "run medley.sysout (\!:1)"E 4I 4D 8a   go	    "run medley.sysout \!:1"E 8I 8a   go	    "run /python/local/sysouts/LISP.SYSOUT -NF"E 8E 4E 3a   dbx     "stop in OP_dbx"a   gc      "set *(LispPTR  *)(Valspace + 2*1772) = 0114"a   engc      "set *(LispPTR  *)(Valspace + 2*1772) = 0"a   st      statusa   csf      "call sf(MachineState.pvar-10)"a   bt      "call bt()"a   btvv      "call btvv()"a   n       nextD 8a   tos         "call print(TopOfStack)"E 8I 8a   tos         "call print(MachineState.tosvalue)"E 8a   Ctos        "call print(tscache)"D 8a   csp         "call print(*((LispPTR *)(CurrentStackPTR)))"E 8I 8a   csp         "call print(*((LispPTR *)(MachineState.csp)))"E 8a   Csp         "call print(*((LispPTR *)(cspcache)))"a   do          "call doko()"D 8a   ppc         "print ((int)pccache - (int)FuncObj)"E 8I 8a   ppc         "print ((int)(MachineState.currentpc) - (int)(MachineState.currentfunc))"E 8a   sf          "call sf(fx)"a   fn          "stop in OP_fn"a   ret         "stop in OP_return"a   err         "stop in error"I 2a   warn	"stop in warn"E 2a   ifp         "print *InterfacePage"a   iop         "print *IOPage"a   pro         "print *(PROCESS *)(\!:1)"a   oct         "call printf(\"%o\n\" ,  (\!:1)"a   eve         "print *(EVENT *)(\!:1)"a   dev         "print *(FDEV *)(\!:1)"a   pac         "print *(PACKAGE *)(\!:1)"a   str         "print *(Stream *)(\!:1)"a   pque        "print *(PROCESSQUEUE *)(\!:1)"a   name        "call print_atomname((\!:1))"a   stk "call all_stack_dump((\!:1) , (\!:2) ,(\!:3))"a   astk        "call all_stack_dump(0 , 0 , 0)"a   sastk       "call all_stack_dump(0 , 0 , 1)"a   type        "call type_num(\!:1)"a   dtd         "call dtd_chain(\!:1)"a   btvv        "call btvv()"a   satom       "call S_MAKEATOM(\!:1)"a   a68k        "call a68k(\!:1)"a   la		 "call laddr(\!:1)"a   sval        "call S_TOPVAL(\!:1)"a   atom        "print MAKEATOM(\!:1)"a   val         "call GETTOPVAL(\!:1)"a   sff         "call sff((\!:1))"D 8a   stopop      "stop in \!:1 if FuncObj->framename == \!:2"a   stoppc      "stop in \!:1 if (FuncObj->framename == \!:2 && ((int )PC - (int ) FuncObj > \!:3)) "E 8I 8a   stopop      "stop in \!:1 if ((struct fnhead *)(MachineState.currentfunc))->framename == \!:2"a   stopfunc	"stop if  ((struct fnhead *)(MachineState.currentfunc))->framename == \!:1"a   stoppc      "stop in \!:1 if (((struct fnhead *)(MachineState.currentfunc))->framename == \!:2 && ((int)(MachineState.currentpc) - (int )(MachineState.currentfunc) > \!:3)) "E 8a   sop         "stop in \!:1"a sc		"call stack_check(0)"use . /python0/users/maiko/working/src /python0/users/maiko/working/incD 5E 5I 5ignore VTALRMI 6ignore IOE 6E 5E 1