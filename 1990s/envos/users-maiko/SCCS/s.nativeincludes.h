h19137s 00000/00000/00824d D 2.27 90/06/04 14:45:08 sybalsky 31 30c reformat, copyrightes 00003/00005/00821d D 2.26 88/09/27 14:46:53 krivacic 30 29c for code mergees 00001/00001/00825d D 2.25 88/09/21 11:41:29 krivacic 29 28c last changeses 00078/00038/00748d D 2.24 88/09/15 15:14:27 krivacic 28 27c to updatees 00052/00007/00734d D 2.23 88/08/12 15:43:48 krivacic 27 26c cleanupes 00070/00039/00671d D 2.22 88/08/02 17:22:59 krivacic 26 25c to do updatees 00117/00018/00593d D 2.21 88/07/27 16:10:34 krivacic 25 24c More inline macroses 00018/00004/00593d D 2.20 88/07/25 15:22:29 krivacic 24 23c N_OP_CLARITHEQUAL opcodees 00006/00006/00591d D 2.19 88/07/21 15:57:17 krivacic 23 22c CDR fixes 00099/00098/00498d D 2.18 88/07/19 16:45:19 krivacic 22 21c interfaces, opcode macroses 00031/00024/00565d D 2.17 88/06/29 22:02:53 mullins 21 20c Added inline CDR for translator.es 00094/00006/00495d D 2.16 88/06/24 18:28:41 krivacic 20 19c inline CAR & CDR (not working yet)es 00001/00000/00500d D 2.15 88/06/23 09:47:45 krivacic 19 18c add IVAR = to fn call selfes 00004/00003/00496d D 2.14 88/06/17 12:16:49 krivacic 18 17c check for a ccodep in funcallotheres 00001/00001/00498d D 2.13 88/06/16 14:44:51 krivacic 17 16c fix call to emulator to restore stack ptr before exit testes 00001/00001/00498d D 2.12 88/06/15 19:35:07 krivacic 16 15c fix for native slow returnes 00001/00001/00498d D 2.11 88/06/07 17:43:28 krivacic 15 14c fix syntax error of arg_num = (int) (Stackspace + NATIVE_CURRENTFX->blink)es 00011/00000/00488d D 2.10 88/06/07 16:27:55 krivacic 14 13c add GetTypeEntry GetTypeNumberes 00000/00001/00488d D 2.9 88/06/02 16:44:54 krivacic 13 12c remove debug printfes 00000/00001/00489d D 2.8 88/06/02 15:16:23 krivacic 12 11c remove debug printfes 00016/00013/00474d D 2.7 88/06/02 14:22:47 krivacic 11 10c put extern's together, new EndSTKP c_ret_to_dispatches 00001/00013/00486d D 2.6 88/05/31 15:20:50 masinter 10 9c remove use of redundant StkLimO, bogus resetting of Irq_Stk_End (could lose interrupts)es 00014/00008/00485d D 2.5 88/05/27 15:06:08 krivacic 9 8c GET_POPPED, Timer Irq stuffes 00037/00007/00456d D 2.4 88/05/23 15:54:32 krivacic 8 7c STACK_ONLY_CHECK TIMER_STACK_CHECKes 00027/00003/00436d D 2.3 88/05/20 18:47:36 krivacic 7 6c CALL_OP_FNes 00010/00000/00429d D 2.2 88/05/20 10:37:20 krivacic 6 5c envcall_native back ines 00000/00000/00429d D 2.1 88/05/17 09:18:54 hayata 5 4c Version up to 2.1es 00001/00001/00428d D 1.4 88/05/10 21:45:04 krivacic 4 3c do_stackoverflow(1)es 00006/00002/00423d D 1.3 88/05/10 19:39:20 krivacic 3 2c /users/maiko/SCCS/p.nativeincludes.hes 00002/00000/00423d D 1.2 88/05/02 09:57:09 krivacic 2 1c COPY_TOP SAVE_PUSH_TOPes 00423/00000/00000d D 1.1 88/04/27 20:44:00 krivacic 1 0c date and time created 88/04/27 20:44:00 by krivaciceuUtTI 1D 22/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 22I 22/* This is G-file @(#) nativeincludes.h Version 2.16 (6/24/88). copyright Xerox & Fuji Xerox  */E 22/* File: nativeincludes.h - created Jan 29, 1988 *//* Krivacic:AisNorth:Xerox *//* Copyright (C) 1988 by Xerox Corporation. All rights reserved. *//* This file contains all of the include files which   are required by the native code translations.*//* ******#include "lispemul.h"#include "emulglobal.h"#include "address.h"#include "address68k.h"#include "stack.h"#include "lispglobal.h"#include "lisptypes.h"#include "lispmap.h"#include "cell.h"****** *//* ************************************************************************* *//* **************		  EMULATOR MACROS 		************ *//* ************************************************************************* */typedef char ByteCode;typedef unsigned short  DLword;typedef unsigned int  LispPTR;I 20E 20typedef struct  consstr { 		  unsigned cdr_code : 8 ;		  unsigned car_field : 24 ;	} ConsCell;I 20#define CDR_INDIRECT           0#define CDR_NIL				128#define CDR_ONPAGE			128E 20struct state{	DLword	*ivar;	DLword	*pvar;};#define ATOM_T	0114	/* T's AtomIndex Number 114Q */#define NIL_PTR		0   /* from cell.h 24-mar-87 take */#define NOBIND_PTR	1#define FRAMESIZE	10		/* size of frameex1: 10 words */#define FNHEADSIZE	8		/* size of fnhead: 8 words */#define GET_NATIVE_ADDR(fnobject)					\		*((int *) ((int)fnobject + fnobject->startpc - 4))I 22#define CALL_NATIVE(defcell, num_args)  \D 26	asmgoto(((int *)(GET_NATIVE_ADDR(defcell)))[num_args+(5+3)]);E 26I 26D 28	asmgoto(((int *)(GET_NATIVE_ADDR(defcell)))[num_args+(5+2)]);E 28I 28	asmgoto(((int *)(GET_NATIVE_ADDR(defcell)))[num_args+(6+2)]);E 28E 26E 22I 22E 22D 11extern DLword  *CurrentStackPTR;		/* rhS,S  */extern LispPTR	TopOfStack ;		/*  TOSH(high 16),TOS (lo 16) */extern struct state MachineState;E 11#define CURRENTFX ((struct  frameex1 *)((DLword *) PVar - FRAMESIZE))#define	IVar	MachineState.ivar#define PVar	MachineState.pvarD 11extern ByteCode *PC;			/* Pointer to Current executing Byte Code   */E 11D 10extern DLword *StkLimO ;	/* for stack check */E 10#define GetLongWord(address)		(*((int *) (address)))#define LADDR_from_68k(ptr68k)	(((unsigned int)(ptr68k) - (unsigned int)Lisp_world) >>1)#define Addr68k_from_LADDR(Lisp_addr)	(Lisp_world + (Lisp_addr))#define StkOffset_from_68K(ptr68k)\	(((unsigned int)(ptr68k) - (unsigned int)Stackspace) >>1)#define Addr68k_from_StkOffset(stkoffset)\	(Stackspace + (stkoffset))I 20#define POINTER_PAGEBASE(datum)	((datum) & 0x0ffff00)E 20I 26#define GetDTD(typnum)	(DTDspace + ((typnum)<<4))E 26I 14D 20#define GetTypeEntry(address)       *(MDStypetbl + (((address) & 0x0ffff00)>>9))#define GetTypeNumber(address)     ((*(MDStypetbl +(((address) & 0x0ffff00)>>9))) & 2047)E 20I 20#define GetTypeEntry(address)       *(MDStypetbl + ((((int)address) & 0x0ffff00)>>9))#define GetTypeNumber(address)     ((*(MDStypetbl +((((int)address) & 0x0ffff00)>>9))) & 2047)#define Listp(address)    (GetTypeNumber(address) == TYPE_LISTP)E 20E 14I 14D 20E 20E 14#define  BF_MARK	0x8000#define  BF_MARK32	0x80000000#define  FX_MARK	0xc000#define  FX_MARK_NATIVE 0xc800D 8#define  STK_SAFE	2	/* added with stkmin */E 8I 8#define  STK_SAFE	32	/* added with stkmin */E 8struct fnhead{	DLword		stkmin;	/* ?? */	short		na;	/* Numbers of arguments */	short		pv;	/* ?? */	DLword		startpc;			/* head of ByteCodes, DLword offset from stkmin */	unsigned	native :1;	/* native translated? */	unsigned	nil1 :1 ; 	/* not used */	unsigned	argtype : 2;	/* ?? */	unsigned	nil2 :4 ; 	/* not used */	unsigned	framename : 24;	/* index in AtomSpace */	DLword		ntsize;		/* size of NameTable */	unsigned		nlocals :8;	/* ?? */	unsigned		fvaroffset :8;				/* DLword offset from head of NameTable */	/* NameTable of variavle length is follwing with this structure. */};typedef struct frameex1{	unsigned	flags	:3;	unsigned	fast	:1;	unsigned	native	:1;	/* This frame treats N-func */	unsigned	incall	:1;	unsigned	validnametable	:1;			/* 0: look for FunctionHeader 			   1: look for NameTable on this FrameEx */	unsigned	nopush	:1;	unsigned	usecount :8;	DLword	alink;		/* alink pointer (Low addr) */ 	DLword	lofnheader;	/* pointer to FunctionHeader (Low addr) */	unsigned hi1fnheader : 8; /* pointer to FunctionHeader (Hi1 addr) */	unsigned hi2fnheader : 8; /* pointer to FunctionHeader (Hi2 addr) */	DLword	nextblock;	/* pointer to FreeStackBlock */	DLword	pc;		/* Program counter */	DLword	lonametable;	/* pointer to NameTable of this FrameEx (Low addr) */	unsigned hi1nametable :8;	/* pointer to NameTable of this FrameEx (Hi1 addr) */	unsigned hi2nametable :8;	/* pointer to NameTable of this FrameEx (Hi2 addr) */	DLword	blink;		/* blink pointer (Low addr) */	DLword	clink;		/* clink pointer (Low addr) */} FX ;typedef struct frameex2{	unsigned	flags	:3;	unsigned	fast	:1;	unsigned	native	:1;	/* This frame treats N-func */	unsigned	incall	:1;	unsigned	validnametable	:1;			/* 0: look for FunctionHeader 			   1: look for NameTable on this FrameEx */	unsigned	nopush	:1;	unsigned	usecount :8;	DLword	alink;		/* alink pointer (Low addr) */ 	LispPTR	fnheader;	/* pointer to FunctionHeader (swapped) */	DLword	nextblock;	/* pointer to FreeStackBlock */	DLword	pc;		/* Program counter */	LispPTR	nativera;	/* address of native ra */	DLword	blink;		/* blink pointer (Low addr) */	DLword	clink;		/* clink pointer (Low addr) */} FX2 ;typedef struct basic_frame {	unsigned	flags : 3 ;	unsigned	nil   : 3 ;	unsigned	residual :1 ;	unsigned	padding  : 1 ;	unsigned	usecnt   : 8 ;	DLword		ivar ;} Bframe ;I 26/* Structure for DTD */struct dtd {	DLword dtd_name ;	DLword dtd_size ;	LispPTR dtd_free ;	unsigned unuse	:2 ;	unsigned dtd_obsolate :1 ;	unsigned dtd_finalizable :1 ;	unsigned dtd_lockedp : 1 ;	unsigned dtd_hunkp : 1 ;	unsigned dtd_gctype :2 ;	unsigned dtd_descrs : 24;	LispPTR dtd_typespecs ;	LispPTR dtd_ptrs ;	int  dtd_oldcnt;	DLword dtd_cnt0 ;	DLword dtd_nextpage ;	DLword dtd_typeentry ;	DLword dtd_supertype ;};E 26D 11 extern  DLword *Atomspace; 		/* ATOMSPACE */E 11I 26E 26D 11 extern  DLword *Stackspace;		/* STACKSPACE*/ extern  DLword *Defspace;		/* DEFSPACE */ extern  DLword *Valspace;		/* VALSPACE */ extern  DLword *Lisp_world; 		/* Lisp Start BASE */ extern  struct fnhead *FuncObj;	/* Pointer to current ccode obj */E 11#define TYPE_SMALLP			1#define TYPE_FIXP			2#define TYPE_FLOATP			3 #define TYPE_LITATOM			4 #define TYPE_LISTP			5 #define TYPE_ARRAYP			6 #define TYPE_STRINGP			7 #define TYPE_STACKP			8#define TYPE_CHARACTERP			9#define TYPE_VMEMPAGEP			10#define TYPE_STREAM			11 #define TYPE_BITMAP			12#define TYPE_COMPILED_CLOSURE		13#define TYPE_ONED_ARRAY			14#define TYPE_TWOD_ARRAY			15#define TYPE_GENERAL_ARRAY		16typedef struct compiled_closure {		unsigned int nil1	: 8 ;		unsigned int def_ptr	: 24; /* function */		unsigned int nil2	: 8 ;		unsigned int env_ptr	: 24; /* environment */  } CClosure ;typedef struct definition_cell {	unsigned	ccodep	:	1 ;	unsigned	fastp	:	1 ;	unsigned	argtype	:	2 ;	unsigned	pseudocodep :	1 ;	unsigned	nil	:	3 ;	unsigned	defpointer :	24;} DefCell ;I 20E 20#define GetDEFCELL68k(index)	((LispPTR *)Defspace + (index) )#define GetVALCELL68k(index)	((LispPTR *)Valspace + (index))#define S_POSITIVE	0xE0000#define S_NEGATIVE	0xF0000I 27#define S_CHARACTER	0x70000E 27/* ************************************************************************* *//* **************		 NATIVE ONLY MACROS 		************ *//* ************************************************************************* *//************************************************************************//*	 TOP OF STACK OPERATIONS		 			*//************************************************************************/D 25#define PUSH(x)		*((LispPTR *) CSTKPTR++) = (LispPTR) x;E 25I 25#define PUSH(x)		{*((LispPTR *) CSTKPTR++) = (LispPTR) x;}E 25#define PUSH16(x)	*((DLword *) CSTKPTR++) = x;#define PUSH16s(x, y) 	{ PUSH16(x); PUSH16(y); }#define PUSH_SWAPED(x)	{ register LispPTR temp;\			  temp = x; \			  PUSH16(temp); \			  PUSH16(swapx(temp)); \			}D 9#define POP	*((LispPTR *) --CSTKPTR)#define TOS	*((LispPTR *) CSTKPTR-1)I 2#define COPY_TOP TOS#define SAVE_PUSH_TOP TOSE 2#define PREV_TOS *((LispPTR *) CSTKPTR-2)E 9I 9#define POP		*((LispPTR *) --CSTKPTR)#define TOS		*((LispPTR *) CSTKPTR-1)#define COPY_TOP 	TOS#define SAVE_PUSH_TOP 	TOS#define PREV_TOS 	*((LispPTR *) CSTKPTR-2)#define GET_POPPED	*CSTKPTRI 14#define GET_POPPED_2	*((LispPTR *) CSTKPTR+1)I 28#define LSTACK		(CSTKPTR - 1)E 28E 14E 9I 22D 28E 28E 22I 8/************************************************************************/D 22/*	 MACROS TO SAVE & RESTORE STATE 				*/E 22I 22/*	 MACROS TO SAVE & RESTORE STATE FOR OP_xx OPCODE ROUTINES	*//* 	 TO CALL OLD STYLE OPCODE ROUTINE				*/E 22/************************************************************************/E 8I 8#define NATIVE_EXT(call_pc)						\D 22{	(unsigned int) PC =  call_pc;					\E 22I 22{	PC  =  (ByteCode *) call_pc;					\E 22	TopOfStack = POP;						\	CurrentStackPTR = (DLword *) (CSTKPTR-1);			\}#define NATIVE_RET							\{	CSTKPTR = (LispPTR *) CurrentStackPTR + 1;			\	PUSH(TopOfStack);						\}I 22#define CALL_OP_FN(callpc, nextpc, opcodefn)	{			\	NATIVE_EXT(callpc);						\	opcodefn();							\	NATIVE_RET;							\	if (nextpc != (unsigned int) PC) {				\		QUIT_NATIVE(PC); 					\	}								\}E 22E 8/************************************************************************//*	 RETURN TO DISPATCH TO EXECUTE NEW FRAME 			*//************************************************************************/#define NATIVE_CURRENTFX ((struct frameex1 *)((DLword *) PVAR - FRAMESIZE))D 22#define RETURN_TO_DISPATCH						\{ 	CurrentStackPTR = (DLword *) CSTKPTR;				\	asmgoto(&ret_to_dispatch); 					\E 22I 22#define C_RETURN_TO_DISPATCH						\{									\	asmgoto(&c_ret_to_dispatch); 					\E 22}/************************************************************************/D 7/* 	RETURN TO DISPATCH TO EXECUTE UNTRANSLATED OPCODE 		*/E 7I 7/* 	RETURN TO DISPATCH TO EXECUTE OPCODE & RETURN TO NATIVE CODE	*/E 7/************************************************************************/#define BCE(ret_pc)	{						\D 22	(unsigned int) PC =  ret_pc;					\	CurrentStackPTR = (DLword *) CSTKPTR;				\	asmgoto(&ret_to_unimpl); 					\E 22I 22	setpc_jmp(ret_pc, &ret_to_unimpl); 				\E 22}I 7/************************************************************************//* 	RETURN TO DISPATCH TO EXECUTE OPCODE & STAY IN EMULATOR		*//************************************************************************/E 7I 7D 22#define QUIT_NATIVE(ret_pc)	{					\I 9D 13	printf("Undefined Entry Point; 0x%x\n",ret_pc - (int)FuncObj); \E 13E 9	(unsigned int) PC =  ret_pc;					\	CurrentStackPTR = (DLword *) CSTKPTR;				\	asmgoto(&ret_to_dispatch); 					\E 22I 22#define QUIT_NATIVE(ret_pc)						\{ 									\	setpc_jmp(ret_pc, &ret_to_dispatch); 				\E 22}E 7/************************************************************************//* 	RETURN TO DISPATCH TO EXECUTE FN CALL 				*//************************************************************************/D 22#define RETURN_TO_FN_CALL(ret_pc, golabel)	{			\	(unsigned int) PC =  ret_pc;					\	CurrentStackPTR = (DLword *) CSTKPTR;				\	asmgoto(&golabel); 						\E 22I 22#define RETURN_TO_FN_CALL(ret_pc, golabel)				\{ 									\	setpc_jmp(ret_pc, &golabel); 					\E 22}/************************************************************************//* 	RETURN TO DISPATCH TO EXECUTE UFN CALL 				*//************************************************************************/D 22#define CALL_UFN(call_pc, opcode)	{				\	(unsigned int) PC =  call_pc;					\	CurrentStackPTR = (DLword *) CSTKPTR;				\D 7	asmgoto(&ret_to_dispatch); 					\E 7I 7	asmgoto(&ret_to_ufn); 						\E 22I 22#define CALL_UFN(call_pc, opcode)					\{ 									\	setpc_jmp(call_pc, &ret_to_ufn); 				\E 22E 7}I 7D 22/************************************************************************//* 	CALL OLD STYLE OPCODE ROUTINE	 				*//************************************************************************/E 22E 7I 7D 22#define CALL_OP_FN(callpc, nextpc, opcodefn)	{			\D 8	(unsigned int) PC =  call_pc;					\	TopOfStack = POP;						\	CurrentStackPTR = (DLword *) (CSTKPTR-1);			\E 8I 8	NATIVE_EXT(callpc);						\E 8	opcodefn();							\I 17	NATIVE_RET;							\E 17	if (nextpc != (unsigned int) PC) 				\		asmgoto(&ret_to_dispatch); 				\D 8	CSTKPTR = (LispPTR *) CurrentStackPTR + 1;			\	PUSH(TopOfStack);						\E 8I 8D 17	NATIVE_RET;							\E 17E 8}E 22E 7/************************************************************************//* 	RETURN TO DISPATCH TO EXECUTE TIMER INTERRUPT 			*//************************************************************************/D 22#define RETURN_TO_TIMER(call_pc)	{				\	(unsigned int) PC =  call_pc;					\I 9D 12if((call_pc - (int)FuncObj) < 20) printf("to timer: 0x%x\n",call_pc - (int)FuncObj);\E 12E 9	CurrentStackPTR = (DLword *) CSTKPTR;				\	asmgoto(&ret_to_timer); 					\E 22I 22#define RETURN_TO_TIMER(call_pc)					\{ 									\	setpc_jmp(call_pc, &ret_to_timer); 				\E 22}I 8/************************************************************************//* 	STACK OVERFLOW & TIMER CHECKS 					*//************************************************************************/E 8I 20#define STK_MIN(fnobj) ((fnobj->stkmin+STK_SAFE) << 1)#define STK_END_COMPUTE(stk_end,fnobj) 					\		( (int)stk_end - STK_MIN(fnobj) )#define CLR_IRQ 							\	{Irq_Stk_Check = STK_END_COMPUTE((Irq_Stk_End = (int) EndSTKP), \					 FuncObj);			\	}E 20I 8#define STACK_ONLY_CHECK(stkmin)					\D 10{	if ((int) CSTKPTR > ((int)StkLimO - ((stkmin+STK_SAFE) << 1))){	\E 10I 10D 11{	if ((int) CSTKPTR > ((int)EndSTKP - ((stkmin+STK_SAFE) << 1))){	\E 11I 11{	if ((int) CSTKPTR > (EndSTKP - ((stkmin+STK_SAFE) << 1))){	\E 11E 10D 28		NATIVE_EXT(0);						\E 28I 28		IVar = (DLword *) IVAR;				\		PVar = (DLword *) PVAR;				\		TopOfStack = POP;						\		CurrentStackPTR = (DLword *) (CSTKPTR-1);			\E 28		if (do_stackoverflow(0)) {				\I 22			printf("REAL STACK OVERFLOW\n");		\E 22			asmgoto(&ret_to_dispatch);			\			}						\D 28		NATIVE_RET;						\		IVAR = (LispPTR *) IVar;				\E 28I 28		CSTKPTR = (LispPTR *) CurrentStackPTR + 1;		\		PUSH(TopOfStack);					\		IVAR = CSTKPTR + entry_pc;				\E 28		PVAR = (LispPTR *) PVar;				\		}							\}	#define TIMER_STACK_CHECK(pc)						\D 29{	if ( (int) CSTKPTR > Irq_Stk_Check ) RETURN_TO_TIMER(pc); }E 29I 29{	if ( (int) CSTKPTR > Irq_Stk_Check ) {if(pc ==1) {printf("before timer exit\n"); do_brk();} RETURN_TO_TIMER(pc);} }E 29E 8/************************************************************************//* 	FUNCTION ENTRY SETUP	 					*//************************************************************************//* 	The code generator must expand this differently, depending on  	the number of paramaters available to the function.*/#define framesetup(x, stkmin, swapped_func_obj)	{ 			\  register int NEXTBLOCK;						\  {									\   register struct frameex1 *LocFX;					\   LocFX = NATIVE_CURRENTFX;						\   LocFX->nextblock = NEXTBLOCK = StkOffset_from_68K(IVAR);		\  }									\  IVar = (DLword *) IVAR ;						\D 7  if((unsigned int)((DLword *)CSTKPTR+stkmin+STK_SAFE) >= 		\E 7I 7D 9  if((unsigned int)((DLword *)CSTKPTR+(stkmin+STK_SAFE)) >= 		\E 9I 9D 10 /* if((unsigned int)((DLword *)CSTKPTR+(stkmin+STK_SAFE)) >= 		\E 9E 7		(unsigned int)StkLimO)					\	{CurrentStackPTR = (DLword *) CSTKPTR;				\D 3	 if (do_stackoverflow()) { RETURN_TO_DISPATCH; };		\E 3I 3D 4	 if (do_stackoverflow(T)) { RETURN_TO_DISPATCH; };		\E 4I 4	 if (do_stackoverflow(1)) { RETURN_TO_DISPATCH; };		\E 4E 3	 CSTKPTR = (LispPTR *) CurrentStackPTR;				\	 PVAR = (LispPTR *) PVar;					\	 IVAR = (LispPTR *) IVar;					\	 NEXTBLOCK = StkOffset_from_68K(IVAR);				\D 9	}								\E 9I 9	 Irq_Stk_End = (int) StkLimO;					\	}*/								\E 10  Irq_Stk_Check = ( (int)Irq_Stk_End - ( (stkmin+STK_SAFE) << 1) );	\D 10  Irq_Stk_End = (int) StkLimO;						\E 10E 9   									\ /* Set up BF */							\  PUSH((BF_MARK << 16) | NEXTBLOCK);					\  PUSH((FX_MARK_NATIVE << 16) | StkOffset_from_68K(PVAR)); 		\  PUSH(swapped_func_obj); 						\D 8  (DLword *) PVAR = PVar =  (((DLword *) CSTKPTR) += (FRAMESIZE-4)) ;	\E 8I 8D 9  (DLword *) PVAR = PVar =  (((DLword *) CSTKPTR) + (FRAMESIZE-4)) ;	\E 9I 9  (DLword *) PVAR = PVar = (DLword *) CSTKPTR = (((DLword *) CSTKPTR) + (FRAMESIZE-4)) ;	\E 9E 8} /* end framesetup *//************************************************************************//* 	FUNCTION CALL & RETURN 						*//************************************************************************/D 25#define fncall_self(args, newpcval, golabel) {				\E 25I 25#define fncall_self(args, pc_assign, newpcval, golabel) {		\E 25  NATIVE_CURRENTFX->pc = newpcval;					\I 19  IVAR = CSTKPTR - args;						\I 25  pc_assign;								\E 25E 19  goto golabel;								\} /* end fncall */I 20D 26/* ******* saveE 26E 20D 22#define fncall_other(args, currpc, newpcval, atom_index, return_label) {\D 18  register struct fnhead *newfncell;					\  if ( ( newfncell = (struct fnhead *)Addr68k_from_LADDR(		\	 ((DefCell *) GetDEFCELL68k(atom_index))->defpointer))->native) \E 18I 18  register struct fnhead *newfncell = (struct fnhead *) GetDEFCELL68k(atom_index);\  if ( (((DefCell *)newfncell)->ccodep ) &&			\	  ( newfncell = (struct fnhead *)Addr68k_from_LADDR(		\	   ((DefCell *) newfncell)->defpointer))->native) \E 22I 22D 26#define fncall_other(args, currpc, newpcval, atom_index, fn_def_cell_addr_68K, return_label) {\  if ( (((DefCell *)fn_def_cell_addr_68K)->ccodep ) &&			\	  ( newdefcell = (struct fnhead *)Addr68k_from_LADDR(		\	   ((DefCell *) fn_def_cell_addr_68K)->defpointer))->native) 	\E 22E 18	{(int) PC = -args; 						\D 22	 FuncObj = newfncell;						\E 22	 CurrentStackPTR = (DLword *) CSTKPTR;				\	 NATIVE_CURRENTFX->pc = newpcval;				\D 22	 asmgoto(GET_NATIVE_ADDR(newfncell));				\E 22I 22	 FuncObj = (struct fnhead *)newdefcell;						\	 asmgoto(GET_NATIVE_ADDR(newdefcell));				\E 22	};								\   RETURN_TO_FN_CALL(currpc, return_label);				\} /* end fncall */E 26I 22#define newdefcell  ((struct fnhead *) DATUM68K)E 22I 20D 25#define fncall_other(args, currpc, newpcval, atom_index, fn_def_cell_addr_68K, return_label) {\E 25I 25#define fncall_other(args, call_args, pc_assign, currpc, newpcval, atom_index, fn_def_cell_addr_68K, return_label) {\E 25D 22  register struct fnhead *newdefcell;						\E 22I 22 /* register struct fnhead *newdefcell;	*/					\E 22  if ( (((DefCell *)fn_def_cell_addr_68K)->ccodep ) &&			\	  ( newdefcell = (struct fnhead *)Addr68k_from_LADDR(		\	   ((DefCell *) fn_def_cell_addr_68K)->defpointer))->native) 	\D 22	{(int) PC = -args; 						\	 CurrentStackPTR = (DLword *) CSTKPTR;				\E 22I 22	{		 						\E 22	 NATIVE_CURRENTFX->pc = newpcval;				\D 22	 FuncObj = (struct fnhead *)newdefcell;						\	 asmgoto(GET_NATIVE_ADDR(newdefcell));				\E 22I 22	 FuncObj = (struct fnhead *)newdefcell;				\	 IVAR = CSTKPTR - args;						\D 25	 CALL_NATIVE(newdefcell, -args);				\E 25I 25	 pc_assign;							\	 CALL_NATIVE(newdefcell, -call_args);				\E 25E 22	};								\   RETURN_TO_FN_CALL(currpc, return_label);				\} /* end fncall */E 20I 20E 20I 6#define envcall_native(retpcval, args, fncell, native_addr_slot, environment) {\D 25	(int) PC = -args; 						\E 25	FuncObj = (struct fnhead *) fncell;				\	native_closure_env = environment;				\D 25	CurrentStackPTR = (DLword *) CSTKPTR;				\E 25	NATIVE_CURRENTFX->pc = retpcval;				\D 25	asmgoto(*((int *)(fncell + native_addr_slot)));			\E 25I 25	IVAR = CSTKPTR - args;						\D 28	IF (args > 5) {(int) PC = -args; CALL_NATIVE(fncell, -5);}	\E 28I 28	IF (args > 5) {(int) PC = -args; CALL_NATIVE(fncell, -6);}	\E 28	CALL_NATIVE(fncell, -args);					\E 25} /* end envcall */I 22#define returnFX ((struct frameex2 *) DATUM68K)E 22E 6D 25#define return_op(pcval, swapped_func_obj)	{			\D 22 register struct frameex2 *returnFX ; 					\E 22I 22 /* *** op_return(pcval,swapped_func_obj); */ \E 25I 25#define return_op(pcval, swapped_func_obj, ret_result, slow_ret_result)	\{									\ /* *** op_return(pcval,swapped_func_obj); */ 				\E 25E 22 register DLword alink; 						\ alink = NATIVE_CURRENTFX->alink;					\D 16 if ( alink & 1 )  { BCE(pcval) ; } 					\E 16I 16D 22 if ( alink & 1 )  { PUSH(IVAR[0]); BCE(pcval) ; } 			\E 22I 22D 25 if ( alink & 1 )  { PUSH(IVAR[0]); BCE(pcval); }			\E 22E 16 CSTKPTR = IVAR+1 ; 							\E 25I 25 if ( alink & 1 )  { slow_ret_result; BCE(pcval); }			\ ret_result;	/* NOTE: this smashes the BF word if fn called with 0 args */\ CSTKPTR = IVAR + 1; 							\E 25 returnFX = (struct frameex2 *) 					\	((DLword *) 							\	    (PVAR = (LispPTR *) Addr68k_from_StkOffset(alink))		\	    - FRAMESIZE); 						\ IVAR = (LispPTR *) Addr68k_from_StkOffset(*((DLword *)returnFX -1)) ; 	\ IVar = (DLword *) IVAR;						\ PVar = (DLword *) PVAR;						\D 22 if (returnFX->native) 							\	{(unsigned int) PC = (unsigned int) returnFX->pc;		\E 22I 22 if (returnFX->native) {						\E 22	 if (returnFX->fnheader == swapped_func_obj) 			\D 22	   {goto switchlabel; }						\E 22I 22	   {(unsigned int) PC = (unsigned int) returnFX->pc;		\		goto switchlabel; 					\	   }								\E 22	 else 								\	   {register struct fnhead *newfncell;				\	    newfncell = FuncObj = (struct fnhead *)			\	      Addr68k_from_LADDR(0x0ffffff & swapx(returnFX->fnheader));\D 22	    CurrentStackPTR = (DLword *) CSTKPTR;			\	    asmgoto(GET_NATIVE_ADDR(newfncell)); 			\E 22I 22	    CALL_NATIVE(newfncell, (unsigned int) returnFX->pc); 	\E 22	   }								\	}								\ else									\D 20	{								\E 20I 20	{register struct fnhead *LocFnObj;				\E 20D 22	 (unsigned int) PC = (unsigned int) returnFX->pc + 		\D 20	    (int) (FuncObj = (struct fnhead *)				\E 20I 20	    (int) (FuncObj = LocFnObj = (struct fnhead *)		\E 20	    Addr68k_from_LADDR(0x0ffffff & swapx(returnFX->fnheader)));	\E 22I 22	    FuncObj = LocFnObj = (struct fnhead *)			\	    Addr68k_from_LADDR(0x0ffffff & swapx(returnFX->fnheader));	\E 22D 20	 RETURN_TO_DISPATCH;						\E 20I 20 	Irq_Stk_Check = STK_END_COMPUTE(EndSTKP,LocFnObj);		\	if (((int)(CSTKPTR) > Irq_Stk_Check) || (Irq_Stk_End <= 0)) 	\D 22		{ CurrentStackPTR = (DLword *) CSTKPTR; 		\		  asmgoto(&ret_to_timer);				\		}							\ 	Irq_Stk_End = (int) EndSTKP;					\	RETURN_TO_DISPATCH;						\E 22I 22		RETURN_TO_TIMER(returnFX->pc + (int) FuncObj);		\	C_RETURN_TO_DISPATCH;						\E 22E 20	}								\} /* return_op end */ /************************************************************************//* 	MACORS FOR OPCODES 						*//************************************************************************/D 25#define GETBASEPTR_N(ptr, n)\	(0xFFFFFF & *((LispPTR *)Addr68k_from_LADDR((0xFFFFFF & ptr) + n)))#define GETBASE_N(ptr, n)\	(S_POSITIVE |  *((DLword *)Addr68k_from_LADDR((0xFFFFFF & ptr) + n)))E 25#define MYARGCOUNT							\D 28	{register int arg_num;						\	 if ((NATIVE_CURRENTFX->alink & 1) == 0)			\	   arg_num = (int) ((LispPTR *)(NATIVE_CURRENTFX) - 1);		\	 else								\D 15	   arg_num = (int) (Stackspace + NATIVE_CURRENTFX->blink;	\E 15I 15	   arg_num = (int) (Stackspace + NATIVE_CURRENTFX->blink);	\E 15	 PUSH ( (DLword) ((arg_num - (int) IVAR) >> 2) | S_POSITIVE);	\	}E 28I 28D 30(							\	 ( ( 						\	 (	(NATIVE_CURRENTFX->alink & 1) == 0)			\E 30I 30( ( ( 						\	 (	((NATIVE_CURRENTFX->alink & 1) == 0)			\E 30	 ?	(int) ((LispPTR *)NATIVE_CURRENTFX - 1)		\	 :	(int) (Stackspace + NATIVE_CURRENTFX->blink)	\	 )										\D 30	  - (int) IVAR) >> 2) 	\)E 30I 30	  - (int) IVAR) >> 2)  )E 30E 28#define N_OP_CHECKAPPLY(tos, abs_pc) {					\  register DefCell *defcell;						\  defcell = (DefCell *) GetDEFCELL68k(tos & 0xffff) ; 			\  if  (!(  defcell->ccodep  && ((tos & 0xffff0000) == 0)	&&	\	( ( defcell->argtype == 0 ) || ( defcell->argtype == 2 ) ) ) ) 	\  	BCE(abs_pc);							\}I 14#define N_OP_TYPEMASK(n) 						\D 27		{							\  		 if( ( ((DLword)GetTypeEntry(TOS)) & (DLword)n) == 0)	\    			TOS = NIL_PTR;					\		}E 27I 27(	( ( ((DLword)GetTypeEntry(TEMPREG = TOS)) & (DLword)n) == 0)	\    	? NIL_PTR							\	: TEMPREG							\)E 27I 25#define GETBASE_N(ptr, n)\D 27	(S_POSITIVE |  *((DLword *)Addr68k_from_LADDR((0xFFFFFF & ptr) + n)))E 27I 27	( *((DLword *)Addr68k_from_LADDR((0xFFFFFF & ptr) + n)))E 27#define GETBASEPTR_N(ptr, n)\	(0xFFFFFF & *((LispPTR *)Addr68k_from_LADDR((0xFFFFFF & ptr) + n)))#define N_OP_PUTBASEPTR_N(tos_1, tos, n)				\D 28{register LispPTR toscache, base;					\	toscache = tos;							\	base = 0xffffff & tos_1;					\	*((LispPTR *)Addr68k_from_LADDR(base + n)) = toscache;		\	PUSH(base);							\}E 28I 28	*((LispPTR *)((DLword *)Addr68k_from_LADDR(0xffffff & tos_1) + n)) = tos;E 28D 28#define N_OP_PUTBASEPTR_N_opt(tos_1, tos, n)				\{	/* tos_1 is a POP so don't pop or push it */			\	TOSCACHE = tos;							\	*((LispPTR *)((DLword *)Addr68k_from_LADDR(0xffffff & TOS) + n)) = TOSCACHE;\}E 28I 28E 28#define N_OP_PUTBASE_N(tos_1, tos, n, error_label)			\D 28{register LispPTR toscache, base;					\	toscache = tos;							\	base = 0xffffff & tos_1;					\	if ( ((unsigned short)(swapx(toscache))) != (S_POSITIVE >> 16))	\E 28I 28{									\	if ( ((unsigned short)(swapx(TEMPREG = (LispPTR)tos))) != (S_POSITIVE >> 16))	\E 28		goto error_label;					\D 28	*((DLword *)Addr68k_from_LADDR(base) + n) = tos;		\	PUSH(base);							\E 28I 28	*((DLword *)Addr68k_from_LADDR(0xffffff & tos_1) + n) = (DLword) TEMPREG;	\E 28}#define N_OP_GETBITS_N_FD(tos, offset, bit_mask, shift_amount)	\D 27	(S_POSITIVE | 							\E 27I 27	(	 							\E 27	 (( ( *((DLword *)Addr68k_from_LADDR(0xFFFFFF & tos) + offset))	\			>> shift_amount )				\			& bit_mask )					\	)#define N_OP_PUTBITS_N_FD(tos_1, tos, offset, bit_mask, shift_amount, error_label)\{register LispPTR toscache, base;					\D 28	toscache = tos;							\	base = 0xffffff & tos_1;					\	if ( ((unsigned short)(swapx(toscache))) != (S_POSITIVE >> 16))	\E 28I 28	if ( ((unsigned short)(swapx(toscache = (LispPTR)tos))) != (S_POSITIVE >> 16))	\E 28		goto error_label;					\D 28	(DLword *) DATUM68K  = (DLword *)Addr68k_from_LADDR(base) + offset;\E 28I 28	(DLword *) DATUM68K  = (DLword *)Addr68k_from_LADDR(base = 0xffffff & tos_1) + offset;\E 28	*((DLword *)DATUM68K )= 						\		(  (toscache << shift_amount) & 			\		   (bit_mask << shift_amount)) |			\		(*((DLword *)DATUM68K ) & (~(bit_mask << shift_amount)));\D 28	PUSH(base);							\E 28}#define N_OP_GETBASEBYTE(tos_1, tos, error_label)			\D 26{register LispPTR toscache, base;					\	toscache = tos;							\	base = 0xffffff & tos_1;					\		{switch( (0xFFFF0000 & toscache) ){			\	 case S_POSITIVE:						\		toscache &=  0x0000FFFF;				\		break;							\	 case S_NEGATIVE:						\		toscache |=  0xFFFF0000;				\		break;							\	 default:							\		if( GetTypeNumber(toscache) == TYPE_FIXP )		\			toscache = *((int *)Addr68k_from_LADDR(toscache));\		else							\			goto error_label;				\	 }								\	 PUSH(	(0xFF & 						\		(*((char*)Addr68k_from_LADDR((0xFFFFFF & (POP_TOS_1)))	\		   + toscache)))					\		| S_POSITIVE);						\}E 26I 26((	((TEMPREG = (TOS_CACHE = tos) & 0xffff0000) == S_POSITIVE)\	?	(*((char *) Addr68k_from_LADDR(0xffffff & tos_1) + (unsigned short) TOS_CACHE))\	:(	(TEMPREG == S_NEGATIVE)\		?	(*((char *) Addr68k_from_LADDR(0xffffff & tos_1) + (0xffff0000 | TOS_CACHE)))\		:(	( GetTypeNumber(TOS_CACHE) == TYPE_FIXP )\			?	(*((char *) Addr68k_from_LADDR(0xffffff & tos_1) + \					*((int *)Addr68k_from_LADDR(TOS_CACHE))))\			:	asmgoto(error_label)\		)\	)\D 27) | S_POSITIVE)E 27I 27))E 27E 26I 26E 26#define N_OP_PUTBASEBYTE(tos_2, tos_1, tos, error_label)		\{register LispPTR toscache, base;					\	toscache = tos;							\	TEMPREG = tos_1;						\	base = 0xffffff & tos_2;					\	if(	((0xFFFF0000 & toscache ) != S_POSITIVE) || 		\		((unsigned short)toscache >= 256))			\		goto error_label;					\	switch( (0xFFFF0000 & TEMPREG) ){				\	 case S_POSITIVE:						\	 	TEMPREG &=  0x0000FFFF;					\	 	break;							\	 case S_NEGATIVE:						\		TEMPREG |=  0xFFFF0000;					\		break;							\	 default:							\D 26		if( GetTypeNumber(TEMPREG) == TYPE_FIXP )		\			TEMPREG = *((int *)Addr68k_from_LADDR(TEMPREG));\		else							\E 26			goto error_label;				\	}								\	*((char*)Addr68k_from_LADDR(0xFFFFFF & base) + TEMPREG) =	\		 0xFF & toscache;					\D 28	PUSH(base);							\E 28}E 25I 20#define N_OP_CAR(tos, error_label) 					\ 	(Listp(TOS_CACHE = tos) 					\ 	?	(							\D 22		  (((ConsCell *)						\E 22I 22		  (((ConsCell *)					\E 22		   (DATUM68K = (LispPTR *)(Addr68k_from_LADDR(TOS_CACHE))))\		  ->cdr_code == CDR_INDIRECT) 				\D 22		 ?	((LispPTR) ( ((ConsCell *)				\E 22I 22		 ?	((LispPTR) ( ((ConsCell *)			\E 22		Addr68k_from_LADDR( ((ConsCell *)DATUM68K)->car_field))->car_field))\D 22		 : ((LispPTR)(((ConsCell *)DATUM68K)->car_field))			\E 22I 22		 : ((LispPTR)(((ConsCell *)DATUM68K)->car_field))	\E 22		)							\ 	:	( (TOS_CACHE == NIL_PTR)				\		? TOS_CACHE 						\		:							\		( ( TOS_CACHE == ATOM_T)				\		? TOS_CACHE 						\D 22		: asmgoto(error_label) 				\E 22I 22		: asmgoto(error_label) 					\E 22		)							\		)							\	)D 21#define N_OP_CDR(tos, error_label)  					\  	(Listp(TOS_CACHE = tos) 					\ 	?	( (TEMPREG = (LispPTR) 					\		   ( ((ConsCell *)					\		   (DATUM68K = ((LispPTR *)(Addr68k_from_LADDR(TOS_CACHE)))))\		  ->cdr_code) == CDR_NIL)				\		 ? (LispPTR) NIL_PTR						\		 : (LispPTR) ( (TEMPREG > CDR_ONPAGE)				\		 ?							\			/* cdr-samepage */				\			(POINTER_PAGEBASE(TOS_CACHE) + 			\			((TEMPREG & 127) << 1))				\		 : (LispPTR) ( (TEMPREG == CDR_INDIRECT)				\		 ? ((LispPTR) cdr (((ConsCell *)DATUM68K)->car_field))		\		 : (LispPTR) ((Addr68k_from_LADDR 			\		(POINTER_PAGEBASE(TOS_CACHE) + (TEMPREG << 1))))	\		)							\		)							\		)							\	:	(LispPTR) ( (TOS_CACHE == NIL_PTR) ? NIL_PTR : asmgoto(error_label))  \	)E 21I 21D 22#define N_OP_CDR(tos, error_label)  					      \(Listp(TOS_CACHE = tos)                                                     \ ? (((TEMPREG = ((DATUM68K = (ConsCell *)(Addr68k_from_LADDR(TOS_CACHE)))->cdr_code)) == CDR_NIL)                                                            \    ? NIL_PTR                                                                 \    : ((TEMPREG > CDR_ONPAGE)                                                 \       ? (POINTER_PAGEBASE(TOS_CACHE) + ((TEMPREG & 127) << 1))               \       : ((TEMPREG == CDR_INDIRECT)                                           \	  ? (cdr ((LispPTR)(DATUM68K->car_field)))                            \	  : ((ConsCell *) (Addr68k_from_LADDR (POINTER_PAGEBASE(TOS_CACHE) + (TEMPREG << 1))))->car_field)))                                                 \ : ((TOS_CACHE == NIL_PTR)                                                    \    ? NIL_PTR                                                                 \    : asmgoto(error_label)))E 22I 22#define N_OP_CDR(tos, error_label)  					\  	(Listp(TOS_CACHE = tos) 					\D 23 	?	( (TEMPREG = (LispPTR) 					\E 23I 23 	?	( ((TEMPREG = (LispPTR) 				\E 23		   ( ((ConsCell *)					\		   (DATUM68K = ((LispPTR *)(Addr68k_from_LADDR(TOS_CACHE)))))\D 23		  ->cdr_code) == CDR_NIL)				\E 23I 23		  ->cdr_code)) == CDR_NIL)				\E 23		 ? (LispPTR) NIL_PTR					\		 : (LispPTR) ( (TEMPREG > CDR_ONPAGE)			\		 ?							\			/* cdr-samepage */				\			(POINTER_PAGEBASE(TOS_CACHE) + 			\			((TEMPREG & 127) << 1))				\		 : (LispPTR) ( (TEMPREG == CDR_INDIRECT)		\		 ? ((LispPTR) cdr (((ConsCell *)DATUM68K)->car_field))	\D 23		 : (LispPTR) ((Addr68k_from_LADDR 			\		(POINTER_PAGEBASE(TOS_CACHE) + (TEMPREG << 1))))	\E 23I 23		 : (LispPTR) ((ConsCell *)(Addr68k_from_LADDR 		\		(POINTER_PAGEBASE(TOS_CACHE) + (TEMPREG << 1))))->car_field\E 23		)							\		)							\		)							\	:	(LispPTR) ( (TOS_CACHE == NIL_PTR) ? NIL_PTR : asmgoto(error_label))  \	)E 22E 21I 28#define N_OP_CDDR(tos, error_label)  					\  	(Listp(TOS_CACHE = tos) 					\ 	?	( ((TEMPREG = (LispPTR) 				\		   ( ((ConsCell *)					\		   (DATUM68K = ((LispPTR *)(Addr68k_from_LADDR(TOS_CACHE)))))\		  ->cdr_code)) == CDR_NIL)				\		 ? (LispPTR) NIL_PTR					\		 : (LispPTR) ( (TEMPREG > CDR_ONPAGE)			\		 ?							\			/* cdr-samepage */				\			(SAME_PAGE_CDR)				\		 : (LispPTR) ( (TEMPREG == CDR_INDIRECT)		\		 ? N_OP_CDR(cdr(((ConsCell *)DATUM68K)->car_field),error_label)\		 : N_OP_CDR(						\			((ConsCell *)					\				(Addr68k_from_LADDR 			\					(POINTER_PAGEBASE(TOS_CACHE) + 	\						(TEMPREG << 1)		\					)				\				)					\			)->car_field					\			, error_label)					\		)							\		)							\		)							\	:	(LispPTR) ( (TOS_CACHE == NIL_PTR) ? NIL_PTR : asmgoto(error_label))  \	)#define SAME_PAGE_CDR							\/* take CDR of List Cell */						\( 		((TEMPREG = (LispPTR) 					\		   ( ((ConsCell *)					\		   (DATUM68K = (LispPTR *)				\				(((int)DATUM68K & 0xfffffe00) |		\				(((int) TEMPREG & 127) << 2))		\		   ))							\		  ->cdr_code)) == CDR_NIL)				\		 ? (LispPTR) NIL_PTR					\		 : (LispPTR) ( (TEMPREG > CDR_ONPAGE)			\		 ?	/* cdr-samepage */				\			(POINTER_PAGEBASE(TOS_CACHE) + 			\			 ((TEMPREG & 127) << 1))			\		 : (LispPTR) ( (TEMPREG == CDR_INDIRECT)		\		 ? ((LispPTR) cdr (((ConsCell *)DATUM68K)->car_field))	\		 : (LispPTR) ((ConsCell *)(Addr68k_from_LADDR 		\		(POINTER_PAGEBASE(TOS_CACHE) + (TEMPREG << 1))))->car_field\		)							\		)							\)E 28I 22#define N_OP_FVAR(slot, dl_slot)					\(	GetLongWord(Addr68k_from_LADDR(swapx(				\	( ( ((DLword *)PVAR)[dl_slot] & 1 )				\	? native_newframe(slot)						\	: PVAR[slot]							\)))))	#define N_OP_UNBIND(tos)						\D 23/* {register LispPTR SAVE_TOS = POP; CSTKPTR = (LispPTR *) N_OP_unbind(CSTKPTR); PUSH(SAVE_TOS);} */ \	nop_unbind(tos);E 23I 23D 24 {register LispPTR SAVE_TOS = tos; CSTKPTR = (LispPTR *) N_OP_unbind(CSTKPTR); PUSH(SAVE_TOS);}  \/*	nop_unbind(tos);*/E 24I 24/* {register LispPTR SAVE_TOS = tos; CSTKPTR = (LispPTR *) N_OP_unbind(CSTKPTR); PUSH(SAVE_TOS);} */ \	nop_unbind(tos);E 24E 23#define N_OP_DUNBIND							\D 24/* { CSTKPTR = (LispPTR *) N_OP_dunbind(CSTKPTR); } */ 			\	nop_dunbind();E 24I 24D 28 { CSTKPTR = (LispPTR *) N_OP_dunbind(CSTKPTR); }  			\/*	nop_dunbind();*/E 28I 28/*  { CSTKPTR = (LispPTR *) N_OP_dunbind(CSTKPTR); }  THIS MAY NOT WORK	*/		\	nop_dunbind();E 28#define N_OP_CLARITHEQUAL(tos_1, tos, error_addr)			\(	(((TEMPREG = tos) & 0xfffe0000) == (S_POSITIVE & 0xfffe0000))	\	? 	((TEMPREG == tos_1) ? ATOM_T : NIL_PTR)			\	:	((((int) DATUM68K = GetTypeNumber(TEMPREG)) == TYPE_FIXP)\		?	((TEMPREG == tos_1) ? ATOM_T : NIL_PTR)		\		:	(((int) DATUM68K == TYPE_FLOATP)		\			?	((TEMPREG == tos_1) ? ATOM_T : NIL_PTR)	\			:	(N_OP_eqq(tos_1, TEMPREG, error_addr))	\			)						\		)							\)I 26#define N_OP_CLEQUAL_ILEQL(tos_1, tos, error_addr, op_function)		\(	(((TOS_CACHE = tos) & 0xfffe0000) <= (S_POSITIVE & 0xfffe0000))	\	? 	((TOS_CACHE == tos_1) ? ATOM_T : NIL_PTR)		\	:(	(((TEMPREG = tos_1) & 0xfffe0000) <=			\			 (S_POSITIVE & 0xfffe0000))			\		?	((TOS_CACHE == TEMPREG) ? ATOM_T : NIL_PTR)	\		:	op_function(TEMPREG, TOS_CACHE, error_addr)	\	)								\)E 26I 26#define N_OP_EQUAL(tos_1, tos, error_addr)				\(	(((TOS_CACHE = tos) & 0xffff0000) <= S_CHARACTER)		\	? 	((TOS_CACHE == tos_1) ? ATOM_T : NIL_PTR)		\	:(	(((TEMPREG = tos_1) & 0xffff0000) <= S_CHARACTER)	\		?	((TOS_CACHE == TEMPREG) ? ATOM_T : NIL_PTR)	\		:	N_OP_equal(TEMPREG, TOS_CACHE, error_addr)	\	)								\)E 26E 24I 26#define N_OP_DTEST(atom_index, exit_pc, opcode)				\{	/* must have stack up to date */				\	register struct dtd *dtd68k ;					\ for(dtd68k=(struct dtd *) GetDTD(GetTypeNumber(TOS));			\	atom_index != dtd68k->dtd_name ;				\	    dtd68k=(struct dtd *) GetDTD(dtd68k->dtd_supertype))	\	{								\		if( dtd68k->dtd_supertype == 0)				\		{							\		 CALL_UFN(exit_pc, opcode);				\		}							\	}								\}I 27#ifdef sun3	/* these take advantage of the Shift Amount Register d5 */#define NSMALLP_RANGE(x)	nop_nsmallp_range(x)#define SMALLP_UNBOX(x)		nop_smallp_unbox(x)#define SMALL_BOX(x)		nop_smallp_box(x)#else#define NSMALLP_RANGE(x)	(((int)((int)x << 15) >> 15) ^ x)#define SMALLP_UNBOX(x)		( (int) (x << 15) >> 15)#define SMALL_BOX(x)	(((unsigned int)(x << 15) >> 15) | S_POSITIVE)#endifE 27I 27#define NSMALLP(x)		(((x) >> 17) ^ 7)#define MAKE_BOX(type, value)	Create_n_Set_Cell(type, value)#define GET_BOX(type, laddr)	(* ((type *) (Addr68k_from_LADDR(laddr))))#define FIXP_UNBOX(value)						\(	NSMALLP((TEMPREG = value))					\	?	GET_BOX(int, TEMPREG)					\	:	SMALLP_UNBOX(TEMPREG)					\)#define FIXP_UNBOX_UFN(value, errorlabel)				\(	NSMALLP((TEMPREG = value))					\	?(	(GetTypeNumber(TEMPREG) == TYPE_FIXP)			\		?GET_BOX(int, TEMPREG)					\		:asmgoto(errorlabel)					\	 )								\	:	SMALLP_UNBOX(TEMPREG)					\)#define FLOATP_UNBOX(value)						\	GET_BOX(floatvalue)	#define FIXP_BOX(x)							\(	NSMALLP_RANGE((TEMPREG = x))					\	? MAKE_BOX(TYPE_FIXP, TEMPREG)					\	: SMALL_BOX(TEMPREG)						\)#define FLOATP_BOX(x) 	Create_n_Set_Cell(TYPE_FLOATP, x)E 27E 26E 22D 21E 20E 14I 14E 21E 14/************************************************************************/D 11/* 	EXTERNAL OTHER ENTRY POINTS 					*/E 11I 11/* 	EXTERNAL ENTRY POINTS 						*/E 11/************************************************************************/I 11extern DLword *Atomspace; 		/* ATOMSPACE */extern DLword *Stackspace;		/* STACKSPACE*/extern DLword *Defspace;		/* DEFSPACE */extern DLword *Valspace;		/* VALSPACE */extern DLword *Lisp_world; 		/* Lisp Start BASE */I 14extern DLword *MDStypetbl;I 26extern DLword *DTDspace;		/* DTDSPACE */E 26E 14extern DLword  *CurrentStackPTR;		/* rhS,S  */extern LispPTR	TopOfStack ;		/*  TOSH(high 16),TOS (lo 16) */I 27extern LispPTR	Scratch_CSTK ;E 27extern ByteCode *PC;			/* Pointer to executing Byte Code   */extern struct state MachineState;extern struct fnhead *FuncObj;		/* Pointer to current ccode obj */extern int EndSTKP;			/* End of Current Frame */extern int *c_ret_to_dispatch;E 11extern int *ret_to_dispatch;extern int *ret_to_unimpl;extern int *ret_to_timer;extern int *ret_to_fn0;extern int *ret_to_fn1;extern int *ret_to_fn2;extern int *ret_to_fn3;extern int *ret_to_fn4;extern int *ret_to_fnx;extern int *ret_to_apply;I 3extern int *ret_to_envcall;I 7extern int *ret_to_ufn;E 7E 3D 3extern int LoopCounter;E 3I 3extern int Irq_Stk_End;extern int Irq_Stk_Check;extern LispPTR native_closure_env;I 21D 22E 22E 21E 3E 1