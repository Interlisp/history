h43929s 00053/00014/00338d D 1.10 93/02/08 14:52:10 sybalsky 10 9c Big VM (and new CDR coding) changes for 3.0 \nes 00010/00005/00342d D 1.9 92/06/26 13:48:53 sybalsky 9 8c retrofit of 386 unix changes \nes 00003/00003/00344d D 1.8 92/04/21 17:13:00 sybalsky 8 7c shortening file names for DOS \nes 00074/00017/00273d D 1.7 92/03/04 18:55:29 sybalsky 7 6c 368es 00047/00016/00243d D 1.6 91/01/25 17:58:12 sybalsky 6 5c Add 3-byte-atom oplength table, take account of 3-byte stomses 00002/00002/00257d D 1.5 91/01/24 11:08:22 sybalsky 5 4c 3-byte atom changes: Add opcode-length table for 3-byte case.es 00041/00000/00218d D 1.4 91/01/02 16:41:32 sybalsky 4 3c Add an opcode-length table for the BIGATOMS case, because opcode lengths change with 3-byte atoms.es 00008/00002/00210d D 1.3 90/06/15 16:54:55 mitani 3 2c REC_GCLOOKUPes 00010/00004/00202d D 1.2 90/04/20 01:35:24 sybalsky 2 1c AIX:  shortening file names, bulk change.es 00206/00000/00000d D 1.1 90/04/19 23:19:25 sybalsky 1 0c date and time created 90/04/19 23:19:25 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";D 2/* @(#) gccodeblock.c Version 1.5 (3/30/89). copyright Xerox & Fuji Xerox  */static char *id = "@(#) gccodeblock.c	1.5 3/30/89";E 2I 2I 7E 7E 2/************************************************************************/I 2/*									*/D 7/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 7I 7/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 7/*									*/D 7/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 7I 7/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 7/*									*/E 2/************************************************************************/D 2/* Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	*/E 2I 2I 7E 7E 2/************************************************************************/D 2/* File Name : gccodeblock.c						*/E 2I 2/* File Name : gccode.c						*/E 2/*									*//************************************************************************//*									*//* Creation Date : Sep-25-1987						*//* Written by Tomoru Teruuchi						*//* Edit by Larry Masinter						*//************************************************************************//*									*//* Functions :								*//* reclaimcodeblock();							*//*									*//*									*//*									*//************************************************************************//* \Tomtom								*//************************************************************************/#include "lispemul.h"D 8#include "lisptypes.h"E 8I 8#include "lsptypes.h"E 8#include "address.h"D 8#include "address68k.h"#include "lispglobal.h"E 8I 8#include "adr68k.h"#include "lspglob.h"E 8#include "lispmap.h"#include "stack.h"#include "cell.h"#include "ifpage.h"#include "gc.h"#include "array.h"#define min(a,b)		((a > b)?b:a)#define ENDOFX			0#define GCONST			111#define Reprobefn(bits, index)  (((bits^((bits) >> 8)) & min(63, index)) | 1)#define Fn16bits(a, b)          ((a + b) & 0x0ffff)#define Hashingbits(item)       (HILOC(item)^( \	     ((LOLOC(item) & 0x1fff) << 3)^(LOLOC(item) >> 9)))#define Getikvalue(base, index) \        (*( LispPTR *)Addr68k_from_LADDR(base + (index << 1)))#ifndef BYTESWAPtypedefstruct implicit_key_hash_table {  LispPTR        base;  unsigned       last_index : 16;  unsigned       num_slots  : 16;  unsigned       num_keys   : 16;  unsigned       null_slots : 16;  LispPTR        key_accessor;} Ikhashtbl;#elsetypedefstruct implicit_key_hash_table {  LispPTR        base;  unsigned       num_slots  : 16;  unsigned       last_index : 16;  unsigned       null_slots : 16;  unsigned       num_keys   : 16;  LispPTR        key_accessor;} Ikhashtbl;#endifI 4D 10#ifdef BIGATOMSE 10I 10#ifdef BIGVM/* Table of opcode lengths for 4-byte atom opcode cases */#define LONGEST_OPCODE 5unsigned int oplength[256] = {0,0,0,0,0,1,4,2,4,4,4,4,4,5,0,0,0,2,0,0,1,1,0,4,0,0,0,0,0,0,1,0,0,0,0,1,2,9,0,0,9,9,9,9,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,4,0,1,1,0,0,0,4,0,0,0,0,1,1,2,4,9,0,0,0,0,0,0,0,1,1,0,0,0,2,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,4,0,1,1,0,1,1,2,9,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0};#elif defined(BIGATOMS)E 10/* Table of opcode lengths for 3-byte atom opcode cases */I 10#define LONGEST_OPCODE 4E 10E 4unsigned int oplength[256] = {I 40,0,0,0,0,1,3,2,3,3,3,3,3,4,0,0,0,2,0,0,1,1,0,3,0,0,0,0,0,0,1,0,0,0,0,1,2,9,0,0,9,9,9,9,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,3,0,1,1,0,0,0,3,0,0,0,0,1,1,2,3,9,0,0,0,0,0,0,0,1,1,0,0,0,2,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,3,0,1,1,0,1,1,2,9,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0};#else/* Table of opcode lengths for old, 2-byte atom opcodes. */I 10#define LONGEST_OPCODE 3E 10unsigned int oplength[256] = {E 40,0,0,0,0,1,2,2,2,2,2,2,2,3,0,0,0,2,0,0,1,1,0,2,0,0,0,0,0,0,1,0,0,0,0,1,2,9,0,0,9,9,9,9,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,2,0,1,1,0,0,0,2,0,0,0,0,1,1,2,3,9,0,0,0,0,0,0,0,1,1,0,0,0,2,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,2,0,1,1,0,1,1,2,9,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0};I 4D 10#endif BIGATOMSE 10I 10#endif /* BIGATOMS */E 10I 10E 10E 4typedef ByteCode *InstPtr;I 6/************************************************************************//*									*//*		    m a p _ c o d e _ p o i n t e r s			*//*									*/I 7/*	Find all pointers in a block of compiled code (they're the	*//*	the args to the GCONST opcode), and change the reference	*//*	count according to "casep".  Complains if it hits an unknown	*//*	opcode.								*/E 7/*									*/D 7/*									*/E 7/************************************************************************/E 6map_code_pointers(codeblock, casep)D 6	LispPTR		codeblock;	short		casep;{	InstPtr         codeptr;	register unsigned int opnum;	register unsigned int len;	struct fnhead  *fnbase;	fnbase = (struct fnhead *) Addr68k_from_LADDR(codeblock);	codeptr = ((InstPtr) fnbase) + fnbase->startpc;	while (T)	 {	   switch (opnum=Get_BYTE(codeptr))	    {	      case ENDOFX:	/* -X- */E 6I 6  LispPTR codeblock;  short	casep;  {    InstPtr         codeptr;    register unsigned int opnum;    register unsigned int len;    struct fnhead  *fnbase;    fnbase = (struct fnhead *) Addr68k_from_LADDR(codeblock);    codeptr = ((InstPtr) fnbase) + fnbase->startpc;D 9    while (T)E 9I 9#ifdef RESWAPPEDCODESTREAM	if (!fnbase->byteswapped) byte_swap_code_block(fnbase);#endif	while (T)E 9      {D 9	switch (opnum=Get_BYTE(codeptr))E 9I 9	switch (opnum=Get_code_BYTE(codeptr))E 9	  {	    case ENDOFX:	/* -X- */E 6		      return (NIL);D 6	      case GCONST:	/* GCONST */E 6I 6	    case GCONST:	/* GCONST */I 10#ifdef BIGVM		      {LispPTR reclaimed = (Get_code_BYTE(codeptr + 1) << 24) |			       (Get_code_BYTE(codeptr + 2) << 16) |			       (Get_code_BYTE(codeptr + 3) << 8) |				   Get_code_BYTE(codeptr + 4);#elseE 10E 6D 9		      {LispPTR reclaimed = (Get_BYTE(codeptr + 1) << 16) |			       (Get_BYTE(codeptr + 2) << 8) |			       Get_BYTE(codeptr + 3);E 9I 9		      {LispPTR reclaimed = (Get_code_BYTE(codeptr + 1) << 16) |			       (Get_code_BYTE(codeptr + 2) << 8) |			       Get_code_BYTE(codeptr + 3);I 10#endif /* BIGVM */E 10E 9		      if (reclaimed != codeblock)D 3			      {htfind(reclaimed, casep);}E 3I 3/*			      {htfind(reclaimed, casep);} */			      {REC_GCLOOKUP(reclaimed, casep);}E 3		      };	    };I 6D 10#ifdef BIGATOMSE 6D 5	  if ((len = oplength[opnum]) > 3)E 5I 5	  if ((len = oplength[opnum]) > 4)E 5D 6	   {E 6I 6#else	  if ((len = oplength[opnum]) > 3)#endif BIGATOMSE 10I 10	  if ((len = oplength[opnum]) > LONGEST_OPCODE)E 10	   { /* len > biggest possible marks an unknown opcode */E 6	     char errtext[200];	     sprintf(errtext,D 5		      "Unrecognized bytecode (0%o) in code block x%x,x%x; continue to use UFN length", opnum, (codeblock>>16)&0xFF, codeblock&0xFFFF);E 5I 5		      "Unrecognized bytecode (0%o) at offset 0%o in code block x%x,x%x; continue to use UFN length", opnum, codeptr-(InstPtr)fnbase, (codeblock>>16)&0xFF, codeblock&0xFFFF);E 5	     error(errtext);	     oplength[opnum] = len =(((UFN *)UFNTable) + (opnum))->byte_num;	   }	  codeptr += len + 1;	};}I 6/************************************************************************//*									*//*		    r e m i m p l i c i t k e y h a s h			*//*									*//*	Remove a fn defn from the implicit-key hash table of defns	*//*									*//************************************************************************/E 6/* JRB - These values are xpointers; their high bytes are not set and	shouldn't be looked at */D 10#define getikkey(value) ((*(LispPTR *)Addr68k_from_LADDR(value)) & 0xffffff)E 10I 10#define getikkey(value) ((*(LispPTR *)Addr68k_from_LADDR(value)) & POINTERMASK)E 10LispPTR remimplicitkeyhash(item, ik_hash_table)LispPTR  item, ik_hash_table;{Ikhashtbl *ik_htable; LispPTR   reprobe, bits, limits, index,           base, value, key_accessor;    ik_htable = (Ikhashtbl *)Addr68k_from_LADDR(ik_hash_table);    bits   =  Hashingbits(item);    limits = ik_htable->last_index;    index  = (bits & limits);    base   = ik_htable->base;    value  = Getikvalue(base, index);    if (value != *Deleted_Implicit_Hash_Slot_word)      { if (value != NIL)	  {if (item ==	       getikkey(value))	     {goto found;};	 }	else	  return(NIL);      };    reprobe = Reprobefn(bits, limits); lp:    index = Fn16bits(index, reprobe) & limits;    value = Getikvalue(base, index);    if (value != *Deleted_Implicit_Hash_Slot_word)      { if (value != NIL)	  {if (item ==	       getikkey(value))	     {goto found;};	 }	else	  return(NIL);      };    goto lp; found:I 3/*E 3    htfind(*Deleted_Implicit_Hash_Slot_word, ADDREF);    htfind(Getikvalue(base, index), DELREF);I 3*/    REC_GCLOOKUP(*Deleted_Implicit_Hash_Slot_word, ADDREF);    REC_GCLOOKUP(Getikvalue(base, index), DELREF);E 3    Getikvalue(base, index) = *Deleted_Implicit_Hash_Slot_word;      (ik_htable->num_keys)--;    return (T);}I 7E 7I 6/************************************************************************//*									*/I 7/*		    r e c l a i m c o d e b l o c k			*/E 7/*									*/I 7/*	Reclaim an array block that contains compiled code.  When	*//*	this happens, we need to decrement the reference counts for	*/E 7/*									*/I 7/*		* The frame name, which may be a string, list, etc.	*//*		* Any GCONSTs in the code (constants, internal fns,	*//*		  etc.), since they're no longer needed.		*/E 7/*									*/D 7/*									*/E 7/************************************************************************/E 6LispPTR reclaimcodeblock(codebase)D 7LispPTR			codebase;{struct fnhead		*fnbase;   if ((*Closure_Cache_Enabled_word != NIL) &&       (remimplicitkeyhash(codebase, *Closure_Cache_word) != NIL))     { return(T);     };   fnbase = (struct fnhead *)Addr68k_from_LADDR(codebase);D 3   htfind((0x0ffffff & fnbase->framename), DELREF);E 3I 3/*   htfind((0x0ffffff & fnbase->framename), DELREF); */   REC_GCLOOKUP((0x0ffffff & fnbase->framename), DELREF);E 3   if (fnbase->startpc != 0)	map_code_pointers(codebase,DELREF);   return(NIL);E 7I 7  LispPTR codebase;  { struct fnhead *fnbase;    if ((*Closure_Cache_Enabled_word != NIL) &&         (remimplicitkeyhash(codebase, *Closure_Cache_word) != NIL))       { return(T);       };    fnbase = (struct fnhead *)Addr68k_from_LADDR(codebase);D 10    REC_GCLOOKUP((0x0ffffff & fnbase->framename), DELREF);E 10I 10    REC_GCLOOKUP((POINTERMASK & fnbase->framename), DELREF);E 10    if (fnbase->startpc != 0) map_code_pointers(codebase,DELREF);    return(NIL);  }/************************************************************************//*									*//*		    c o d e _ b l o c k _ s i z e			*//*									*//*	Given a native pointer to a code block, return its size.	*//*									*//************************************************************************/code_block_size(codeblock68k)  LispPTR codeblock68k;  {    InstPtr         codeptr, initcodeptr;    register unsigned int opnum;    register unsigned int len;    struct fnhead  *fnbase;    fnbase = (struct fnhead *) codeblock68k;    initcodeptr = codeptr = ((InstPtr) fnbase) + fnbase->startpc;    while (T)      {	switch (opnum=Get_BYTE(codeptr))	  {	    case ENDOFX:	/* -X- */		      return (codeptr-initcodeptr);	    };D 10#ifdef BIGATOMS	  if ((len = oplength[opnum]) > 4)#else	  if ((len = oplength[opnum]) > 3)#endif BIGATOMSE 10I 10	  if ((len = oplength[opnum]) > LONGEST_OPCODE)E 10	   { /* len > biggest possible marks an unknown opcode */	     char errtext[200];	     sprintf(errtext,		      "Unrecognized bytecode (0%o) at offset 0%o in code block x%x,x%x; continue to use UFN length", opnum, codeptr-(InstPtr)fnbase, (codeblock68k>>16)&0xFF, codeblock68k&0xFFFF);	     error(errtext);	     oplength[opnum] = len =(((UFN *)UFNTable) + (opnum))->byte_num;	   }	  codeptr += len + 1;	};E 7}E 1