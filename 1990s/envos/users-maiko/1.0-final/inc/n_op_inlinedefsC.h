/* This is G-file @(#) n_op_inlinedefsC.h Version 2.26 (9/15/88). copyright Xerox & Fuji Xerox  *//* 	n_op_inlinedefsC.h *//* 	Bob Krivacic 2/23/88 *//* 		These use the N_OP interface of the opcodes.	They REQUIRE the fixsp() inline ASSEMBLY routines to operate!*/#undef ATOMCELL_N#undef DIFFERENCE#undef PLUS2	#undef QUOTIENT  #undef TIMES2	 #undef GREATERP#undef IPLUS_N#undef IDIFFERENCE_N#undef MAKENUMBER#undef BOXIPLUS#undef BOXIDIFFERENCE#undef LRSH1#undef LRSH8#undef LLSH1#undef LLSH8							#undef UFN_CALLS#define ATOMCELL_N(n)							\	{TOPOFSTACK = N_OP_atomcellN(TOPOFSTACK, n, ufn_1d);		\	 nextop2;							\	}#define DIFFERENCE							\	{TOPOFSTACK = N_OP_difference(POP_TOS_1, TOPOFSTACK, ufn_2);	\	nextop1;							\	}#define PLUS2								\	{TOPOFSTACK = N_OP_plus2(POP_TOS_1, TOPOFSTACK, ufn_2);		\	nextop1;							\	}#define QUOTIENT							\	{TOPOFSTACK = N_OP_quot(POP_TOS_1, TOPOFSTACK, ufn_2); 		\	nextop1;							\	}#define TIMES2								\	{TOPOFSTACK = N_OP_times2(POP_TOS_1, TOPOFSTACK, ufn_2); 	\	nextop1;							\	}#define	GREATERP							\	{TOPOFSTACK = N_OP_greaterp(POP_TOS_1, TOPOFSTACK, ufn_2);	\	nextop1;							\	}#undef IDIFFERENCE#undef IPLUS2	#undef IQUOTIENT  #undef ITIMES2	 #undef IGREATERP#undef IREMAINDER #define IDIFFERENCE							\	{TOPOFSTACK = N_OP_idifference(POP_TOS_1, TOPOFSTACK, ufn_2);	\	nextop1;							\	}#define IPLUS2								\	{TOPOFSTACK = N_OP_iplus2(POP_TOS_1, TOPOFSTACK, ufn_2);	\	nextop1;							\	}#define IQUOTIENT							\	{TOPOFSTACK = N_OP_iquot(POP_TOS_1, TOPOFSTACK, ufn_2); 	\	nextop1;							\	}#define ITIMES2								\	{TOPOFSTACK = N_OP_itimes2(POP_TOS_1, TOPOFSTACK, ufn_2); 	\	nextop1;							\	}#define	IGREATERP							\	{TOPOFSTACK = N_OP_igreaterp(POP_TOS_1, TOPOFSTACK, ufn_2);	\	nextop1;							\	}#define IREMAINDER							\	{TOPOFSTACK = N_OP_iremainder(POP_TOS_1, TOPOFSTACK, ufn_2); 	\	nextop1;							\	}#define IPLUS_N(n)							\	{TOPOFSTACK = N_OP_iplusn(TOPOFSTACK, n, ufn_1d);		\	nextop2;							\	}#define IDIFFERENCE_N(n)						\	{TOPOFSTACK = N_OP_idifferencen(TOPOFSTACK, n, ufn_1d);		\	nextop2;							\	}#define LRSH1								\	{TOPOFSTACK = N_OP_lrsh1(TOPOFSTACK, ufn_1);			\	nextop1;							\	}#define LRSH8								\	{TOPOFSTACK = N_OP_lrsh8(TOPOFSTACK, ufn_1);			\	nextop1;							\	}#define LLSH1								\	{TOPOFSTACK = N_OP_llsh1(TOPOFSTACK, ufn_1);			\	nextop1;							\	}#define LLSH8								\	{TOPOFSTACK = N_OP_llsh8(TOPOFSTACK, ufn_1);			\	nextop1;							\	}#undef LSH#define LSH	{ TOPOFSTACK = N_OP_lsh(POP_TOS_1,TOPOFSTACK,ufn_2); nextop1; }/* removing OPCAR and OPCDR; they are now inline code in inlinedefsC.h *//* #undef OPCAR *//* #define OPCAR	{ TOPOFSTACK = N_OP_car(TOPOFSTACK, ufn_1); nextop1; } *//* #undef OPCDR *//* #define OPCDR	{ TOPOFSTACK = N_OP_cdr(TOPOFSTACK, ufn_1); nextop1; } */#undef RPLACA#define RPLACA								\	{TOPOFSTACK = N_OP_rplaca(POP_TOS_1, TOPOFSTACK, ufn_2);	\	 nextop1;							\	}#undef RPLACD#define RPLACD								\	{TOPOFSTACK = N_OP_rplacd(POP_TOS_1, TOPOFSTACK, ufn_2);	\	 nextop1; 							\	}#undef RPLCONS#define RPLCONS								\	{ TOPOFSTACK = N_OP_rplcons(POP_TOS_1, TOPOFSTACK, ufn_2);	\	  nextop1;							\	}#define MAKENUMBER 							\		{TOPOFSTACK = N_OP_makenumber(POP_TOS_1,TOPOFSTACK,ufn_2);\		 nextop1;						\		}#define BOXIPLUS							\		{TOPOFSTACK = N_OP_boxiplus(POP_TOS_1,TOPOFSTACK,ufn_2);\		nextop1;						\		}#define BOXIDIFFERENCE							\		{TOPOFSTACK = N_OP_boxidiff(POP_TOS_1,TOPOFSTACK,ufn_2);\		nextop1;						\		}#undef EQLOP#define EQLOP	{							\		 TOPOFSTACK = N_OP_eqlop(POP_TOS_1, TOPOFSTACK, ufn_2);	\		 nextop1;						\		}#undef FMEMB#define FMEMB								\		{							\		 TOPOFSTACK = N_OP_fmemb(POP_TOS_1, TOPOFSTACK, exception_2);	\		 nextop1;						\		}#undef LISTGET#define LISTGET								\		{							\		 TOPOFSTACK = N_OP_listget(POP_TOS_1, TOPOFSTACK, exception_2C);\		 nextop1;						\		}#undef DRAWLINE	#define DRAWLINE							\		{							\		 TOPOFSTACK = N_OP_drawline(				\			POP_TOS_1, POP_TOS_1, POP_TOS_1, POP_TOS_1,	\			POP_TOS_1, POP_TOS_1, POP_TOS_1, POP_TOS_1,	\			TOPOFSTACK, ufn_9);				\		 nextop1;						\		}#undef ADDBASE#define ADDBASE								\		{ 							\		 TOPOFSTACK = N_OP_addbase(POP_TOS_1, TOPOFSTACK, ufn_2);\		 nextop1;						\		}/*** [HH: 22-Jul-88] Inline code of these opcodes are made in inlinedefsC.h#undef GETBASEBYTE#define GETBASEBYTE							\		{							\		 TOPOFSTACK = N_OP_getbasebyte(POP_TOS_1, TOPOFSTACK, ufn_2);\		 nextop1;						\		}#undef PUTBASEBYTE#define PUTBASEBYTE							\		{							\		 TOPOFSTACK = N_OP_putbasebyte(				\			POP_TOS_1, POP_TOS_1, TOPOFSTACK, ufn_3);	\		 nextop1;						\		}#undef PUTBITS_N_M#define PUTBITS_N_M(a, b)						\		{							\		 TOPOFSTACK = N_OP_putbitsnfd(POP_TOS_1, TOPOFSTACK, a, b, ufn_2d2);\		 nextop3;						\		}****/#undef UNWIND#define UNWIND(n, m)							\		{							\		 CSTKPTR = (LispPTR *)					\			N_OP_unwind(CSTKPTR, TOPOFSTACK, n, m, unwind_err);\		 POP;				\		 nextop3;						\		}#undef ARG0#define ARG0								\		{ TOPOFSTACK = N_OP_arg0(TOPOFSTACK, ufn_1);		\		 nextop1;						\		}#undef ASSOC#define ASSOC								\		{TOPOFSTACK = N_OP_assoc(POP_TOS_1, TOPOFSTACK, exception_2);	\		 nextop1;						\		}#undef STKSCAN#define STKSCAN								\		{TOPOFSTACK = N_OP_stkscan(TOPOFSTACK, ufn_1);		\		 nextop1;						\		}#undef FVARX_#define FVARX_(n)							\		{TOPOFSTACK = N_OP_fvar_(TOPOFSTACK, n);	\		 nextop2;						\		}/* probably doesn't need a UFN case */#undef BLT#define BLT								\		{TOPOFSTACK = N_OP_blt(POP_TOS_1, POP_TOS_1, TOPOFSTACK, ufn_3);\		 nextop1;						\		}/* probably doesn't need a UFN case */#undef PILOTBITBLT#define PILOTBITBLT							\		{TOPOFSTACK = N_OP_pilotbitblt(POP_TOS_1, TOPOFSTACK, ufn_2);\		 nextop1;						\		}#undef CREATECELL#define CREATECELL							\		{TOPOFSTACK = N_OP_createcell(TOPOFSTACK, ufn_1);	\		 nextop1;						\		}#undef FPLUS2#define FPLUS2	{TOPOFSTACK = N_OP_fplus2(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef FDIFFERENCE#define FDIFFERENCE	{TOPOFSTACK = N_OP_fdifference(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef FTIMES2#define FTIMES2	{TOPOFSTACK = N_OP_ftimes2(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef FQUOTIENT#define FQUOTIENT	{TOPOFSTACK = N_OP_fquotient(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef FGREATERP#define FGREATERP	{TOPOFSTACK = N_OP_fgreaterp(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef UBFLOAT1(n)#define UBFLOAT1(n)	{TOPOFSTACK = N_OP_ubfloat1(TOPOFSTACK, n, ufn_1d);\	nextop2;}#undef UBFLOAT2(n)#define UBFLOAT2(n)	{TOPOFSTACK = N_OP_ubfloat2(POP_TOS_1, TOPOFSTACK, n, ufn_2d);\	nextop2;}#undef UBFLOAT3(n)#define UBFLOAT3(n)	{TOPOFSTACK = N_OP_ubfloat3(POP_TOS_1, POP_TOS_1, TOPOFSTACK, n, ufn_3d);\	nextop2;}#undef CLFMEMB#define CLFMEMB	{TOPOFSTACK = N_OP_clfmemb(POP_TOS_1, TOPOFSTACK, exception_2);\	nextop1;}#undef CLASSOC#define CLASSOC	{TOPOFSTACK = N_OP_classoc(POP_TOS_1, TOPOFSTACK, exception_2);\	nextop1;}#undef RESTLIST(n)#define RESTLIST(n)	{TOPOFSTACK = N_OP_restlist(POP_TOS_1, TOPOFSTACK, n, ufn_2d);\	nextop2;}#undef CLEQUAL#define CLEQUAL	{TOPOFSTACK = N_OP_clequal(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef ILEQUAL#define ILEQUAL	{TOPOFSTACK = N_OP_equal(POP_TOS_1, TOPOFSTACK, ufn_2);\	nextop1;}#undef ASET1#define ASET1								\	{TOPOFSTACK = N_OP_aset1(POP_TOS_1, POP_TOS_1, TOPOFSTACK, ufn_3);\	nextop1;}#undef MISC4(n)#define MISC4(n)							\	{TOPOFSTACK = N_OP_misc4(POP_TOS_1, POP_TOS_1, POP_TOS_1, TOPOFSTACK, n, ufn_4d); nextop2;}#undef MISC3(n)#define MISC3(n)							\	{TOPOFSTACK = N_OP_misc3(POP_TOS_1, POP_TOS_1, TOPOFSTACK, n, ufn_3d); nextop2;}#undef AREF2#define AREF2	{TOPOFSTACK = N_OP_aref2(POP_TOS_1,			\                 POP_TOS_1, TOPOFSTACK, ufn_3);				\		 nextop1;}#undef ASET2#define ASET2	{TOPOFSTACK = N_OP_aset2(POP_TOS_1,			\                 POP_TOS_1, POP_TOS_1, TOPOFSTACK, ufn_4);		\		 nextop1;}/* Error Recovery & UFN calls */#define	UFN_CALLS							\									\unwind_err:	 							\	fixspn(5);							\	goto op_ufn;							\ufn_9:	fixspn(10);							\	CSTKPTR += 8;							\	goto op_ufn;							\ufn_4d:	fixspn(6);							\	CSTKPTR += 3;							\	goto op_ufn;							\ufn_3d:	fixspn(5);							\	CSTKPTR += 2;							\	goto op_ufn;							\ufn_2d:	fixspn(4);							\	CSTKPTR += 1;							\	goto op_ufn;							\ufn_2d2:fixspn(5);							\	CSTKPTR += 1;							\	goto op_ufn;							\ufn_1d:	fixsp3();							\	goto op_ufn;							\ufn_d:	fixsp2();							\	goto op_ufn;							\ufn_4:	fixspn(5);							\	CSTKPTR += 3;							\	goto op_ufn;							\ufn_3:	fixspn(4);							\	CSTKPTR += 2;							\	goto op_ufn;							\ufn_2:	fixsp3(); 							\	CSTKPTR += 1;							\	goto op_ufn;							\ufn_1:	fixsp2(); 							\	goto op_ufn;							\ufn_0:	fixsp1(); 							\	goto op_ufn;							\exception_2 : fixsp3();							\	CSTKPTR += 1;							\	if(!Irq_Stk_End){						\		 TOPOFSTACK = TopOfStack;				\		 goto check_interrupt;					\	}								\	else goto op_ufn;						\exception_2C : fixsp3();						\	if(!Irq_Stk_End){						\		 *CSTKPTR = Scratch_CSTK;				\		 CSTKPTR += 1;						\		 goto check_interrupt;					\	}								\	else {								\		CSTKPTR += 1;						\		goto op_ufn;						\	}#define OPCODEFAIL							\									\fixtos1:								\asm("fixtos1:");							\	FIXTOS1;							\	goto op_ufn;