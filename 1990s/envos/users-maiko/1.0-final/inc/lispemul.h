/* This is G-file @(#) lispemul.h Version 2.4 (7/29/88). copyright Xerox & Fuji Xerox  *//* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Author	:	Takeshi Shimizu *			Hiroshi Hayata	 *//**********************************************************************//* 		File Name :	lispemul.h(newv)		Definitions for LispEmulater  			Date :		December 07, 1987 			Edited by :	Takeshi Shimizu				04-Jan-88 Take(Get_DLword)			05-Jan-88 Take(INTSTAT)*//**********************************************************************//** typedef struct {unsigned int code : 8;} BYTECODE; **/typedef struct {unsigned code : 8;} BYTECODE;typedef char ByteCode;typedef unsigned short  DLword;typedef char  DLbyte;typedef unsigned int  LispPTR;typedef struct  consstr { 		  unsigned cdr_code : 8 ;		  unsigned car_field : 24 ;	} ConsCell;/* 32 bit Cell Chang. 14 Jan 87 take */typedef DLword mds_page ;  /* Top word of the MDS */typedef (*CFuncPTR)() ;typedef struct ufn_entry {		DLword atom_name ;   /* UFN's atomindex */		unsigned unknown : 6 ;		unsigned byte_num : 2 ; /* num of byte code */		unsigned arg_num : 8 ;  /* num of argments */	} UFN ;typedef struct closure_type {		unsigned nil1 : 8 ;		unsigned def_ptr : 24 ; /* LispPTR to definition cell */		unsigned nil2 : 8 ;		unsigned env_ptr : 24 ; /* LispPTR to environment */	} Closure ;typedef struct interrupt_state {		unsigned nil1			:3;		unsigned gcdisabled		:1;		unsigned vmemfull		:1;		unsigned stackoverflow		:1;		unsigned storagefull		:1;		unsigned waitinginterrupt	:1;		DLword   intcharcode ;	} INTSTAT ;struct state{	DLword	*ivar;	DLword	*pvar;};/* Typedef for IFPAGE */#include "ifpage.h"/* Typedef for IOPAGE */#include "iopage.h"/* Typedef for MISCSTAT */#include "miscstats.h"/**************************************************** MakeAddr:	base:	DLword*		offset:	word offset from base	return:	DLword*	****************************************************/#define MakeAddr(base, offset)		((DLword *)(base + (int)offset))/****************************************************GetHiWord:*****************************************************/#define GetHiWord(x)		((DLword)((x)>>16))/****************************************************GetLoWord:*****************************************************/#define GetLoWord(x)		((DLword)(x))/****************************************************GetLongWord:	address:	DLword*		retrun:		int*****************************************************/#define GetLongWord(address)		(*((int *) (address)))/****************************************************PopCStack:#define PopCStack	{TopOfStack = *((int *)(--CurrentStackPTR)); --CurrentStackPTR;}*****************************************************/#define PopCStack	{TopOfStack = *((LispPTR *)(CurrentStackPTR)); CurrentStackPTR -= 2;}/****************************************************PopStackTo:  CSTK -> Place#define PopStackTo(Place)	{Place= *((LispPTR *)(--CurrentStackPTR)); CurrentStackPTR--; }*****************************************************/#define PopStackTo(Place)	{Place= *((LispPTR *)(CurrentStackPTR)); CurrentStackPTR -= 2; }/****************************************************PushCStack:#define PushCStack	{*((int *)(++CurrentStackPTR)) = TopOfStack; ++CurrentStackPTR;}*****************************************************/#define PushCStack	{CurrentStackPTR += 2;*((LispPTR *)(CurrentStackPTR)) = TopOfStack; }/****************************************************PushStack:#define PushStack(x)	{*((LispPTR *)(++CurrentStackPTR))=x;CurrentStackPTR++;}*****************************************************/#define PushStack(x)	{CurrentStackPTR += 2;*((LispPTR *)(CurrentStackPTR))=x;}/****************************************************SmashStack:  #define SmashStack(x)	(*((LispPTR *)(CurrentStackPTR-1))=x)*****************************************************/#define SmashStack(x)	(*((LispPTR *)(CurrentStackPTR))=x)/*********************************************************Get_BYTE(byteptr)	byteptr: pointer to  8 bit data**********************************************************//***** OLD definition ************* 13 Nov 1987 takeshi ***#define Get_BYTE(byteptr)	(((unsigned)(*(byteptr))) & 0xff)**********************************************/#define Get_BYTE(byteptr)	(((BYTECODE *)(byteptr))->code)/**********************************************************DOSTACKOVERFLOW(argnum,bytenum) if it needs hardreturn-cleanup	then upnt to contextsw and immidiatery return**********************************************************/#define DOSTACKOVERFLOW(argnum,bytenum) { \			if(do_stackoverflow(T))  \			{	PushStack(S_POSITIVE | argnum); \				contextsw(SubovFXP,bytenum,1); \				return;\			} \		}/***** Get_DLword(ptr) ptr is char* ***/#ifdef SPARC#define Get_DLword(ptr)		((Get_BYTE(ptr) <<8) | Get_BYTE(ptr+1)) #else#define Get_DLword(ptr)		*(((DLword *)(ptr)))#endif#define	ERROR_EXIT(x) 	{return(fixra(x));}#define SAVE_ERROR_EXIT(tos , x) {TopOfStack = tos; return(fixra(x));}#define TIMER_EXIT(x)	{return(fixra(x));}#define WARN(message,operation)	{warn(message);operation;return;}#define NO_WOP	{}#define NIL	0	/* added 29-jan */#define T	1#define ATOM_T	0114	/* T's AtomIndex Number 114Q */#define NIL_PTR		0   /* from cell.h 24-mar-87 take */#define NOBIND_PTR	1		#define STKLIM		0x1FFFF#define FRAMESIZE	10		/* size of frameex1: 10 words */#define FNHEADSIZE	8		/* size of fnhead: 8 words */#define BFSIZE	2		/* size of basci frame pointer: 2 words */#define BITSPER_DLWORD		16#define BITSPER_CELL		32#define BYTESPER_DLWORD		2	#define BYTESPER_CELL		4#define BYTESPER_QUAD		8#define BYTESPER_PAGE		512#define CELLSPER_QUAD		2#define CELLSPER_PAGE		128#define CELLSPER_SEGMENT	32768#define DLWORDSPER_CELL		2#define DLWORDSPER_QUAD		4#define DLWORDSPER_PAGE		256#define DLWORDSPER_SEGMENT	65536#define PAGESPER_SEGMENT	256#define PAGESPER_MDSUNIT	2#define MDSINCREMENT		512#define GUARDSTORAGEFULL	128#define GUARD1STORAGEFULL	64#define SFS_NOTSWITCHABLE	1#define SFS_SWITCHABLE		2#define SFS_ARRAYSWITCHED	3#define SFS_FULLYSWITCHED	4#define AtomHTSIZE		256 * DLWORDSPER_PAGE#define MAXPNCHARS		255    /* Maximam length of PnChars */#define GET_NATIVE_ADDR(fnobject)					\		*((int *) ((int)fnobject + fnobject->startpc - 4))/* For bit test */typedef	struct wbits{	unsigned MSB	:1;	unsigned B1	:1;	unsigned B2	:1;	unsigned B3	:1;	unsigned B4	:1;	unsigned B5	:1;	unsigned B6	:1;	unsigned B7	:1;	unsigned B8	:1;	unsigned B9	:1;	unsigned B10	:1;	unsigned B11	:1;	unsigned B12	:1;	unsigned B13	:1;	unsigned B14	:1;	unsigned LSB	:1;}WBITS;typedef	struct lbits{	unsigned MSB	:1;	unsigned MIDDLE	:30;	unsigned LSB	:1;}LBITS;