/* This is G-file @(#) bb.h Version 1.4 (9/15/88). copyright Xerox & Fuji Xerox  *//*	bb.h		written by don charnley						*//*		COMMENTS:	This code tries to make very few assumptions about the	underlying hardware, and some are required.  The following	assumptions are made:		memory addresses are "byte addresses"		data is effectively 32 bits		the memory is most efficient at 32-bit words			(always 32-bit alligned)	Left and right shift amounts are always less than 32 bits,	and right shifted data is always masked to compensate for	possible arithemetic shifts.  Either logical or arithmetic	shifts will execute correctly.	The backwards bit of the control block is followed blindly,	except that gray is always executed forwards.  Gray bricks	are always 16 bits wide, and 1 to 16 bits high.  These	assumptions are identical to those made in the D-machine	microcode.*//*	INDEX	CONSTANTS	op_repl_src	op_fn_and	op_fn_or	op_fn_xor	CONDITIONS	alligned_loop	F_single_dst_word	F_postloop_dst_word	F_two_preloop_src	F_src_preloop_normal	F_src_word_in_postloop	B_two_preloop_src	B_src_preloop_normal	B_single_dst_word	B_postloop_dst_word	B_src_word_in_postloop	VARIABLES	F_num_loop	F_sdw_mask	F_preloop_mask	F_postloop_mask	B_num_loop	B_sdw_mask	B_preloop_mask	B_postloop_mask	OTHER	TRANSFER LOOP THINGS	ForInner	DestGetsF	DestGetsB	GetSrcF	GetSrcB	INIT	some_init	do_gray_init	F_do_init	B_do_init	F_dst_init	gray_src_init	F_src_init	B_dst_init	B_src_init	SETUPS	do_src_gray_setup	F_do_src_setup	B_do_src_setup	TRANSFERS	do_gray_transfer	F_do_transfer	B_do_transfer	do_partial_transfer	POSTLOOP	F_do_postloop_src_prep	B_do_postloop_src_prep	ADVANCES	do_gray_advance	F_do_advance	B_do_advance	do_src_gray_advance	F_do_dst_advance	F_do_src_advance	B_do_src_advance	B_do_dst_advance	NAMED VARIABLES	variables*//*   CONSTANTS   */#define	 op_repl_src	0#define	 op_fn_and	1#define	 op_fn_or	2#define	 op_fn_xor	3/*   CONDITIONS   */#define  alligned_loop  src32lbit == dst32lbit#define  F_single_dst_word  (dst32lbit + w) <= 32 #define  F_postloop_dst_word  dst32rbit != 31 #define  F_two_preloop_src  (src32lbit > dst32lbit) && ((src32lbit + w) > 32)#define  F_src_preloop_normal  src32lbit <= dst32lbit#define  F_src_word_in_postloop  src32rbit <= dst32rbit#define  B_single_dst_word  (dst32lbit + w) <= 32#define  B_two_preloop_src  (src32rbit < dst32rbit) && ((src32lbit + w) > (dst32lbit + 1))#define  B_src_preloop_normal  src32rbit >= dst32rbit#define  B_postloop_dst_word  dst32lbit != 0#define  B_src_word_in_postloop  src32lbit >= dst32lbit/*   VARIABLES   */#define  F_num_loop  ((dst32lbit + w) >> 5) - 1#define  F_sdw_mask  (F_preloop_mask) & (F_postloop_mask)#define  F_preloop_mask  ((dst32lbit) ? (~(0xFFFFFFFF << (32 - dst32lbit))) : 0xFFFFFFFF) #define  F_postloop_mask  0xFFFFFFFF << (31 - dst32rbit) #define  B_num_loop  ((w - dst32rbit - 1) > 0) ? ((w - dst32rbit - 1) >> 5) : 0#define  B_sdw_mask  (B_preloop_mask) & (B_postloop_mask)#define  B_preloop_mask  0xFFFFFFFF << (31 - dst32rbit)#define  B_postloop_mask  (~(0xFFFFFFFF << (32 - dst32lbit)))/*   OTHER   *//*   TRANSFER LOOP THINGS   */#define ForInner   for (cnt = dstnumL; cnt > 0; cnt--)#define DestGetsF(FN)   *(dst32addr++) FN shS;#define DestGetsB(FN)   *(dst32addr--) FN shS;#define GetSrcF   newS = *(src32addr++);			\  shS        = savedS | ((newS >> srcRshift) & srcRmask);	\  savedS     = newS << srcLshift;#define GetSrcCF   newS =  *(src32addr++);			\  shS        = ~(savedS | ((newS >> srcRshift) & srcRmask));	\  savedS     = newS << srcLshift;#define GetSrcB   newS =  *(src32addr--);			\  shS    = savedS | (newS << srcLshift);			\  savedS = (newS >> srcRshift) & srcRmask;#define GetSrcCB   newS = *(src32addr--);			\  shS    = ~(savedS | (newS << srcLshift));			\  savedS = (newS >> srcRshift) & srcRmask;/*   INIT   */#define  some_init						\ num_lines_remaining = h;					\ if ((h <= 0) || (w <= 0)) return;				\ op = pbt->pbtoperation;					\ fwd = !backwardflg;						\ src_comp = pbt->pbtsourcetype;					\ gray = pbt->pbtusegray;					\ if (gray) {do_gray_init}					\ else if (fwd) {F_do_init}					\ else {B_do_init}#define  do_gray_init						\ F_dst_init							\ gray_src_init#define  F_do_init						\ F_dst_init							\ F_src_init#define  B_do_init						\ B_dst_init							\ B_src_init#define  F_dst_init						\ if (dx < 0)							\ {								\   x32byta  = (int)dstbase - ((7 - dx) >> 3);			\ }								\ else								\ {								\   x32byta  = (int)dstbase + (dx >> 3);				\ }								\ x32nbyt  = x32byta & 3;					\ x32ia  = x32byta - x32nbyt;					\ dst32addr = (int *)x32ia;					\ dst32lbit = (x32nbyt << 3) + (dx & 7);				\ dst32rbit = 31 & (dst32lbit + w - 1);				\ OrigDstAddr = dst32addr;#define  gray_src_init						\ num_gray = ((TEXTUREBBT *)pbt)->pbtgrayheightlessone + 1;	\ curr_gray_line = ((TEXTUREBBT *)pbt)->pbtgrayoffset;		\ src32lbit = 15 & sx;#define  F_src_init						\ if (sx < 0)							\ {								\   x32byta  = (int)srcbase - ((7 - sx) >> 3);			\ }								\ else								\ {								\   x32byta  = (int)srcbase + (sx >> 3);				\ }								\ x32nbyt  = x32byta & 3;					\ x32ia  = x32byta - x32nbyt;					\ src32addr = (int *)x32ia;					\ src32lbit = (x32nbyt << 3) + (sx & 7);				\ src32rbit = 31 & (src32lbit + w - 1);				\ OrigSrcAddr = src32addr;#define  B_dst_init						\ abc = dx + w - 1;						\ if (abc < 0)							\ {								\   x32byta  = (int)dstbase - ((7 - abc) >> 3);			\ }								\ else								\ {								\   x32byta  = (int)dstbase + (abc >> 3);			\ }								\ x32nbyt  = x32byta & 3;					\ x32ia  = x32byta - x32nbyt;					\ dst32addr = (int *)x32ia;					\ dst32rbit = (x32nbyt << 3) + (abc & 7);			\ dst32lbit = 31 & (dst32rbit - w + 1);				\ OrigDstAddr = dst32addr;#define  B_src_init						\ abc = sx + w - 1;						\ if (abc < 0)							\ {								\   x32byta  = (int)srcbase - ((7 - abc) >> 3);			\ }								\ else								\ {								\   x32byta  = (int)srcbase + (abc >> 3);			\ }								\ x32nbyt  = x32byta & 3;					\ x32ia  = x32byta - x32nbyt;					\ src32addr = (int *)x32ia;					\ src32rbit = (x32nbyt << 3) + (abc & 7);			\ src32lbit = 31 & (src32rbit - w + 1);				\ OrigSrcAddr = src32addr;/*   SETUPS   */#define  do_src_gray_setup					\ dstnumL = F_num_loop;						\ shS = *srcbase;						\ shS |= (shS << 16);						\ srcLshift = 15 & (src32lbit - dst32lbit);			\ shS <<= srcLshift;						\ shS |= (0xFFFF & (shS >> 16));					\ if (src_comp) shS = ~shS;#define  F_do_src_setup						\ dstnumL = F_num_loop;						\ srcRshift = 31 & (dst32lbit - src32lbit);			\ srcLshift = 31 & (src32lbit - dst32lbit);			\ srcRmask  = ((srcLshift) ? ~(0xFFFFFFFF << srcLshift) : 0xFFFFFFFF);	\ if (F_two_preloop_src)						\ {								\   newS = *(src32addr++);					\   savedS = newS << srcLshift;					\   newS = *(src32addr++);					\   shS = savedS | ((newS >> srcRshift) & srcRmask);		\   savedS = (newS << srcLshift) & ~srcRmask;					\ }								\ else if (F_src_preloop_normal)					\ {								\   newS = *(src32addr++);					\   shS = ((newS >> srcRshift) & srcRmask);			\   savedS = (newS << srcLshift) & ~srcRmask;					\ }								\ else								\ {								\   newS = *(src32addr++);					\   shS = newS << srcLshift;					\ }								\ if (src_comp) shS = ~shS;#define  B_do_src_setup						\ dstnumL = B_num_loop;						\ srcRshift = 31 & (dst32lbit - src32lbit);			\ srcLshift = 31 & (src32lbit - dst32lbit);			\ srcRmask  = ((srcLshift) ? ~(0xFFFFFFFF << srcLshift) : 0);	\ if (B_two_preloop_src)						\ {								\   newS = *(src32addr--);					\   savedS = (newS >> srcRshift) & srcRmask;			\   newS = *(src32addr--);					\   shS = savedS | (newS << srcLshift);				\   savedS = (newS >> srcRshift) & srcRmask;			\ }								\ else if (B_src_preloop_normal)					\ {								\   newS = *(src32addr--);					\   shS = newS << srcLshift;					\   savedS = (newS >> srcRshift) & srcRmask;			\ }								\ else								\ {								\   newS = *(src32addr--);					\   shS = (newS >> srcRshift) & srcRmask;			\ }								\ if (src_comp) shS = ~shS;/*   TRANSFERS   */#define  do_gray_transfer					\ if (F_single_dst_word)						\ {								\   mask = F_sdw_mask;						\   goto do_fpt;							\ }								\ mask = F_preloop_mask;						\ do_partial_transfer						\ dst32addr++;							\ switch (op)							\ { register int cnt;						\   case op_repl_src: ForInner { DestGetsF(=)  } break;		\   case op_fn_and: ForInner   { DestGetsF(&=) } break;		\   case op_fn_or: ForInner    { DestGetsF(|=) } break;		\   case op_fn_xor: ForInner   { DestGetsF(^=) } break;		\ }								\ if (F_postloop_dst_word)					\ {								\   mask = F_postloop_mask;					\   goto do_fpt;							\ }								\ goto next_line;#define  F_do_transfer						\ if (F_single_dst_word)						\ {								\   mask = F_sdw_mask;						\   goto do_fpt;							\ }								\ mask = F_preloop_mask;						\ do_partial_transfer						\ dst32addr++;							\ if (alligned_loop)						\ {								\   if (src_comp) switch (op)					\   { register int cnt;							\     case op_repl_src: ForInner {*dst32addr++  = ~*src32addr++;} break;	\     case op_fn_and:   ForInner {*dst32addr++ &= ~*src32addr++;} break;	\     case op_fn_or:    ForInner {*dst32addr++ |= ~*src32addr++;} break;	\     case op_fn_xor:   ForInner {*dst32addr++ ^= ~*src32addr++;} break;	\   }									\   else switch (op)							\   { register int cnt;							\     case op_repl_src: ForInner {*dst32addr++  = *src32addr++;} break;	\     case op_fn_and:   ForInner {*dst32addr++ &= *src32addr++;} break;	\     case op_fn_or:    ForInner {*dst32addr++ |= *src32addr++;} break;	\     case op_fn_xor:   ForInner {*dst32addr++ ^= *src32addr++;} break;	\   }									\ }									\ else									\ {									\   if (src_comp) switch (op)						\   { register int cnt;							\     case op_repl_src: ForInner {GetSrcCF DestGetsF(=)  } break;	\     case op_fn_and:   ForInner {GetSrcCF DestGetsF(&=) } break;	\     case op_fn_or:    ForInner {GetSrcCF DestGetsF(|=) } break;	\     case op_fn_xor:   ForInner {GetSrcCF DestGetsF(^=) } break;	\   }									\   else switch (op)							\   { register int cnt;							\     case op_repl_src: ForInner {GetSrcF  DestGetsF(=)  } break;	\     case op_fn_and:   ForInner {GetSrcF  DestGetsF(&=) } break;	\     case op_fn_or:    ForInner {GetSrcF  DestGetsF(|=) } break;	\     case op_fn_xor:   ForInner {GetSrcF  DestGetsF(^=) } break;	\   }									\ }								\ if (F_postloop_dst_word)					\ {								\   F_do_postloop_src_prep					\   mask = F_postloop_mask;					\   goto do_fpt;							\ }								\ goto next_line;#define  B_do_transfer						\ if (B_single_dst_word)						\ {								\   mask = B_sdw_mask;						\   goto do_fpt;							\ }								\ mask = B_preloop_mask;						\ do_partial_transfer						\ dst32addr--;							\ if (alligned_loop)						\ {								\   if (src_comp) switch (op)					\   { register int cnt;							\     case op_repl_src: ForInner {*dst32addr--  = ~*src32addr--;} break;	\     case op_fn_and:   ForInner {*dst32addr-- &= ~*src32addr--;} break;	\     case op_fn_or:    ForInner {*dst32addr-- |= ~*src32addr--;} break;	\     case op_fn_xor:   ForInner {*dst32addr-- ^= ~*src32addr--;} break;	\   }									\   else switch (op)							\   { register int cnt;							\     case op_repl_src: ForInner {*dst32addr--  = *src32addr--;} break;	\     case op_fn_and:   ForInner {*dst32addr-- &= *src32addr--;} break;	\     case op_fn_or:    ForInner {*dst32addr-- |= *src32addr--;} break;	\     case op_fn_xor:   ForInner {*dst32addr-- ^= *src32addr--;} break;	\   }									\ }									\ else									\ {									\   if (src_comp) switch (op)						\   { register int cnt;							\     case op_repl_src: ForInner {GetSrcCB DestGetsB(=)  } break;	\     case op_fn_and:   ForInner {GetSrcCB DestGetsB(&=) } break;	\     case op_fn_or:    ForInner {GetSrcCB DestGetsB(|=) } break;	\     case op_fn_xor:   ForInner {GetSrcCB DestGetsB(^=) } break;	\   }									\   else switch (op)							\   { register int cnt;							\     case op_repl_src: ForInner {GetSrcB  DestGetsB(=)  } break;	\     case op_fn_and:   ForInner {GetSrcB  DestGetsB(&=) } break;	\     case op_fn_or:    ForInner {GetSrcB  DestGetsB(|=) } break;	\     case op_fn_xor:   ForInner {GetSrcB  DestGetsB(^=) } break;	\   }									\ }								\ if (B_postloop_dst_word)					\ {								\   B_do_postloop_src_prep					\   mask = B_postloop_mask;					\   goto do_fpt;							\ }								\ goto next_line;#define  do_partial_transfer					\ dstdata = *dst32addr;						\ dstold = dstdata & ~mask;					\ switch (op)							\ {								\   case op_repl_src: dstdata = shS; break;			\   case op_fn_and: dstdata &= shS; break;			\   case op_fn_or: dstdata |= shS; break;			\   case op_fn_xor: dstdata ^= shS; break;			\ }								\ dstdata &= mask;						\ dstdata |= dstold;						\ *dst32addr = dstdata;/*   POSTLOOP   */#define F_do_postloop_src_prep					\ if (F_src_word_in_postloop)					\ {								\   newS = *src32addr;						\   shS = savedS | ((newS >> srcRshift) & srcRmask);		\ }								\ else								\ {								\   shS = savedS;						\ }								\ if (src_comp) shS = ~shS;#define B_do_postloop_src_prep					\ if (B_src_word_in_postloop)					\ {								\   newS = *src32addr;						\   shS = savedS | (newS << srcLshift);				\ }								\ else								\ {								\   shS = savedS;						\ }								\ if (src_comp) shS = ~shS;/*   ADVANCES   */#define  do_gray_advance					\ F_do_dst_advance						\ do_src_gray_advance#define  F_do_advance						\ F_do_dst_advance						\ F_do_src_advance#define  B_do_advance						\ B_do_dst_advance						\ B_do_src_advance#define F_do_dst_advance					\ dst32addr = OrigDstAddr;					\ dst32lbit += dstbpl;						\ temp = dst32lbit >> 5;						\ temp <<= 2;							\ (int)dst32addr += temp;					\ dst32lbit &= 31;						\ dst32rbit = 31 & (dst32lbit + w - 1);				\ OrigDstAddr = dst32addr;#define do_src_gray_advance					\ if (++curr_gray_line >= num_gray)				\ {								\   curr_gray_line = 0;						\   srcbase = srcbase - (num_gray - 1);				\ }								\ else ++srcbase;#define F_do_src_advance					\ src32addr = OrigSrcAddr;					\ src32lbit += srcbpl;						\ temp = src32lbit >> 5;						\ temp <<= 2;							\ (int)src32addr += temp;					\ src32lbit &= 31;						\ src32rbit = 31 & (src32lbit + w - 1);				\ OrigSrcAddr = src32addr;#define B_do_src_advance					\ src32addr = OrigSrcAddr;					\ src32rbit += srcbpl;						\ if (src32rbit < 0)						\ {								\   temp = (31 - src32rbit) >> 5;				\   temp <<= 2;							\   (int)src32addr -= temp;					\ }								\ else								\ {								\   temp = src32rbit >> 5;					\   temp <<= 2;							\   (int)src32addr += temp;					\ }								\ src32rbit &= 31;						\ src32lbit = 31 & (src32rbit - w + 1);				\ OrigSrcAddr = src32addr;#define B_do_dst_advance					\ dst32addr = OrigDstAddr;					\ dst32rbit += dstbpl;						\ if (dst32rbit < 0)						\ {								\   temp = (31 - dst32rbit) >> 5;				\   temp <<= 2;							\   (int)dst32addr -= temp;					\ }								\ else								\ {								\   temp = dst32lbit >> 5;					\   temp <<= 2;							\   (int)dst32addr += temp;					\ }								\ dst32rbit &= 31;						\ dst32lbit = 31 & (dst32rbit - w + 1);				\ OrigDstAddr = dst32addr;					\/*   NAMED VARIABLES   */#define variables						\int num_lines_remaining, temp, num_gray;			\int dstnumL, src32lbit;				\int srcRmask, srcLshift, dstold, dstdata, mask;			\int x32byta, x32nbyt, x32ia, dst32lbit;				\int curr_gray_line;						\int abc, dst32rbit, src32rbit;					\int *OrigSrcAddr, *OrigDstAddr;					\int op, fwd, src_comp, gray;					\register int *dst32addr, *src32addr;				\register int shS, savedS, newS, srcRshift;