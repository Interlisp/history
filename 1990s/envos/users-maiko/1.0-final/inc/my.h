/* This is G-file @(#) my.h Version 2.5 (7/6/88). copyright Xerox & Fuji Xerox  *//*  my.h  */#define S_CHARACTER 0x70000#define IsNumber(address)     ((*(MDStypetbl +(((address) & 0x0ffff00)>>9))) & 0x1000)#define	N_MakeFloat(arg, dest, error_addr){				\	switch (0xFFFF0000 & (int)arg) {				\	case S_POSITIVE:						\		dest = (float)(0xFFFF & (int)arg);			\		break;							\	case S_NEGATIVE:						\		dest = (float)(0xFFFF0000 | (int)arg);			\		break;							\	default:							\		switch (GetTypeNumber(arg)) {				\		  case TYPE_FLOATP: 					\		    dest = *((float *)Addr68k_from_LADDR(arg));		\		    break; 						\		  case TYPE_FIXP: 					\		    dest = (float)(*((int *)Addr68k_from_LADDR(arg)));	\		    break;						\		  default: ERROR_EXIT(error_addr);			\		}							\	}								\}#define	N_GetPos(arg, dest, error_addr){				\	if ((arg & 0xFFFF0000) == S_POSITIVE)				\		dest = arg & 0xFFFF;					\	else	{							\	if (GetTypeNumber(arg) != TYPE_FIXP) ERROR_EXIT(error_addr);	\	if ((dest = *((int *)Addr68k_from_LADDR(arg))) & 0x80000000)	\		ERROR_EXIT(error_addr);					\		}							\	}#define aref_switch(type, error_addr)					\{									\    switch (type) {							\      case 38: /* pointer : 32 bits */					\         return(*(((int *)Addr68k_from_LADDR(baseL)) + index));		\      case 20: /* signed : 16 bits */					\         result = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;										\         if (result & 0x8000) return(result | S_NEGATIVE);		\         else return(result | S_POSITIVE);				\      case 67: /* Character :  8 bits */				\         return(S_CHARACTER | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF));								\      case 22: /* signed : 32 bits */					\         result = *(((int *)Addr68k_from_LADDR(baseL)) + index);	\         N_ARITH_SWITCH(result);					\      case 0: /* unsigned : 1 bit per element */			\         return(S_POSITIVE | (((*(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1));					\      case 3: /* unsigned : 8 bits per element */			\         return(S_POSITIVE | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF));								\      case 4: /* unsigned : 16 bits per element */			\         return(S_POSITIVE | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF));								\      case 54: /* Float : 32 bits */					\         wordp = createcell68k(TYPE_FLOATP);				\         *((int *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);										\         return(LADDR_from_68k(wordp));					\      case 68: /* Character :  16 bits */				\         return(S_CHARACTER | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF));								\      case 86: /* XPointer : 32 bits */					\         return(*(((int *)Addr68k_from_LADDR(baseL)) + index));		\      default: /* Illegal or Unimplemented */				\         ERROR_EXIT(error_addr);					\    }/* end switch typenumber */					\}#define aset_switch(type, error_addr)					\{									\   switch (type) {							\      case 38: /* pointer : 32 bits */					\	GCLOOKUP(0x8000,DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));										\	GCLOOKUP(0x8000,ADDREF, data);					\        *(((int *)Addr68k_from_LADDR(base)) + index) = data;		\        return(data);							\      case 20: /* signed : 16 bits */					\        new = data & 0xFFFF;						\        if ((((data & 0xFFFF0000) == S_POSITIVE) && ((data & 0x8000) == 0)) ||\	    (((data & 0xFFFF0000) == S_NEGATIVE) && (data & 0x8000)))	\        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;		\        else ERROR_EXIT(error_addr);					\        return(data);							\      case 67: /* Character :  8 bits */				\        if ((data & 0xFFFF0000) != S_CHARACTER) ERROR_EXIT(error_addr);	\        new = data & 0xFFFF;						\        if (new > 0xFF) ERROR_EXIT(error_addr);				\        *(((char *)Addr68k_from_LADDR(base)) + index) = new;		\        return(data);							\      case 22: /* signed : 32 bits */					\        N_GETNUMBER(data, new, doufn);					\        *(((int *)Addr68k_from_LADDR(base)) + index) = new;		\        return(data);							\      case 0: /* unsigned : 1 bit per element */			\        N_GetPos(data, new, error_addr);				\        if (new > 1) ERROR_EXIT(error_addr);				\        if (new) {							\          new = (1 << (7 - (index & 7)));				\          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) |= new;	\        }								\        else {								\          new = 0xFF - (1 << (7 - (index & 7)));			\          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) &= new;	\        }								\        return(data);							\      case 3: /* unsigned : 8 bits per element */			\        N_GetPos(data, new, error_addr);				\        if (new > 0xFF) ERROR_EXIT(error_addr);				\        *(((char *)Addr68k_from_LADDR(base)) + index) = new;		\        return(data);							\      case 4: /* unsigned : 16 bits per element */			\        N_GetPos(data, new, error_addr); 				\        if (new > 0xFFFF) ERROR_EXIT(error_addr);			\        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;		\        return(data);							\      case 54: /* Float : 32 bits */					\        if (GetTypeNumber(data) != TYPE_FLOATP) ERROR_EXIT(error_addr);	\        *(((int *)Addr68k_from_LADDR(base)) + index) = *((int *)Addr68k_from_LADDR(data));								\        return(data);							\      case 68: /* Character :  16 bits */				\        if ((data & 0xFFFF0000) != S_CHARACTER) ERROR_EXIT(error_addr); 										\        new = data & 0xFFFF;						\        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;		\        return(data);							\      case 86: /* XPointer : 32 bits */					\        *(((int *)Addr68k_from_LADDR(base)) + index) = data;		\        return(data);							\      default: /* Illegal or Unimplemented */				\        ERROR_EXIT(error_addr);						\    }/* end switch typenumber */					\}