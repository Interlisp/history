/* This is G-file @(#) listhandle.c Version 2.10 (8/11/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) listhandle.c	2.10 8/11/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther :  Takeshi Shimizu * *//***********************************************************************//* 		File Name :	listhandle.c  				Date :		Jul. 4, 1987 				Edited by :	Takeshi Shimizu				Changed :	16-Oct,1987 take 		Including :	OP_fmemb				OP_listget								*//**********************************************************************/#include "lispemul.h"#include "emulglobal.h"#include "lispglobal.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "cell.h"    extern int Irq_Stk_End;extern int Scratch_CSTK;/***********************************************************************//*	 N_OP_fmemb							*//**********************************************************************/LispPTR N_OP_fmemb(item, tos, error_addr)	register LispPTR item, tos;	int *error_addr;{  /* OP 34Q */#ifdef TRACE	printf("TRACE: OP_fmemb \n");	print(item);	print(tos);#endif	while(Listp(tos)) {		if(item == car(tos))			return tos;		tos = cdr(tos);		/* if we get an interrupt, punt so we can handle it safely */		if(!Irq_Stk_End) {			TopOfStack = tos; /* for continuation */			TIMER_EXIT(error_addr);		}	}	if(tos) SAVE_ERROR_EXIT(tos,error_addr);	return tos;} /* N_OP_fmemb end *//***********************************************************************//* 		Func Name :	N_OP_listget		Opcode	:	47Q *//**********************************************************************/extern struct cadr_cell cadr();	/** declaration only **/#define SAVE_ERROR_EXIT2(topcstk,x) { Scratch_CSTK= topcstk; return(fixra(x));}#define S_N_CHECKANDCADR2(sour,dest,ufn_addr,tcstk)             \                {register LispPTR parm = sour;                  \                 if(GetTypeNumber(parm) != TYPE_LISTP){         \                        SAVE_ERROR_EXIT2(tcstk,ufn_addr);       \                }else                                           \                        dest = cadr(parm);                      \                }LispPTR N_OP_listget(plist, tos, error_addr)	register LispPTR plist;	register LispPTR tos;	int *error_addr;{ register struct cadr_cell cadrobj;#ifdef TRACE	printf("TRACE: N_OP_listget \n");	print(plist);	print(tos);#endif while ( plist != NIL_PTR ) {	S_N_CHECKANDCADR2(plist, cadrobj, error_addr, plist);	if ( cadrobj.car_cell == tos ) {		if(cadrobj.cdr_cell == NIL_PTR) return NIL_PTR;		if(Listp(cadrobj.cdr_cell))			return(car(cadrobj.cdr_cell));		else    /* must punt in case car/cdrerr */			SAVE_ERROR_EXIT2(plist,error_addr);		}	if( ! Listp(cadrobj.cdr_cell) )		{ /* this list ended before we find prop */		return ( NIL_PTR );		}	S_N_CHECKANDCADR2(cadrobj.cdr_cell, cadrobj, error_addr, plist);	plist = cadrobj.cdr_cell;	if (!Irq_Stk_End) {		/* for continuation,it becomes plist on next time */		Scratch_CSTK = plist;		TIMER_EXIT(error_addr);		}	}       return(NIL_PTR); }/* N_OP_listget end */