/* This is G-file @(#) fvar.c Version 2.14 (7/26/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) fvar.c	2.14 7/26/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Author	:	Hiroshi Hayata	 */#include <stdio.h>#include "lispemul.h"#include "lispglobal.h"#include "address68k.h"#include "stack.h"#include "emulglobal.h"#include "lispmap.h"#include "gc.h"#define	MaskShift(x)	((0xFF & x) << 16)/************************************************************************* N_OP_fvarn.c	entry of OPCODE[120b-127b]: FVAR, FVARX	1. save TopOfStack to evaluation stack.	2. set address of searching FVAR slot to chain.	3. call lookfor. (It sets some content to FVAR slot)	4. get some address by caluculation of content of FVAR slot.	5. set the address to TopOfStack.**************************************************************************/  LispPTR N_OP_fvarn(n)	/* n is word offset */	register int n;{register DLword	*chain;	/* keep FVAR slot2 in CurrentFrameExtension */	chain = PVar + n;	if(((WBITS *)chain)->LSB){		/* check 15bit of FVAR slot1 in CurrentFrameExtension.			0:	bound			1:	unbound */		nfvlookup(CURRENTFX, chain, FuncObj);	}	return(	  GetLongWord( 		Addr68k_from_LADDR(0xFFFFFF & (((*(chain+1))<<16) | *chain))));}/************************************************************************** nfvlookup:	This routine is used by only OP_fvarn.		( in addition to N_OP_fvar_() )	1. get Atom index number of target fvar slot.	2. call fvlookfor.****************************************************************************/nfvlookup(apframe1, achain, apfnhead1)struct frameex1 *apframe1;	/* pointer to current frame extension */register DLword	*achain;	/* pointer to 1st word of the searching FVAR slot in CurrentFrameExtension */register struct fnhead	*apfnhead1;	/* pointer to current function heaer */{register DLword *pfh;	/* pointer to current function header */register int	paoffset;	/* 2word offset in PVAR AREA */	pfh = (DLword *)apfnhead1;	paoffset = ((int)achain - (int)PVar)>>2;		/* slot to looked for, 2word offset from PVar */	nnewframe(apframe1, achain, (*(pfh + (apfnhead1->fvaroffset + paoffset - apfnhead1->nlocals))));}/******************************************************************************N_OP_stkscan	entry	STKSCAN		OPCODE[057]	<<Enter>>	TopOfStack:	Low word - Atom index number of variable to be saned.	<<Exit>>	TopOfStack:	Address of found value.	1. call fvlookup.	2. Set *chain to TopOfStack.	3. Increment Pc by 1.******************************************************************************/LispPTR N_OP_stkscan(tos)	LispPTR tos;{register DLword	*chain;register LispPTR	temp;	int	scratch;register int	name;	scratch = tos;	nnewframe(CURRENTFX, (DLword *)&scratch, 0xFFFF & scratch );	temp = 0xFFFF & scratch;	scratch >>= 16;	return((0xFFFF0000 & (temp<<16)) | (0xFFFF & scratch));}/**************************************************N_OP_fvar_	Entry:	FVAR_		opcode[0143]	***************************************************/LispPTR N_OP_fvar_(tos, n)	register LispPTR tos;	register int n;{register DLword	*ppvar;		/* pointer to argued Fvar slot in pvar area */register DLword	*pfreeval;	/* pointer to argued free value */register int	l1;		/* return value of fvlookup() */	ppvar = PVar + n;	if(((WBITS *)ppvar)->LSB){	/* check unbound ? *//* unbound */		nfvlookup(CURRENTFX, ppvar, FuncObj);	}	pfreeval =Addr68k_from_LADDR( MaskShift((*(ppvar+1))) | *ppvar );	if( ((0xFF & *(ppvar+1)) != STK_HI)){		GCLOOKUP(0x8000,DELREF, *((LispPTR *)pfreeval));		GCLOOKUP(0x8000,ADDREF, tos);	}	*((LispPTR *)pfreeval) = tos;	return(tos);}#define FVSTACK		2#define FVGLOBAL	6#define FVIVARHI	0x0#define FVPVARHI	0x8000#define FVFVARHI	0xC000#define ENDSTACKMARK	0xb/******************************************************************************nnewframe	This routine is used by fvlookup and OP_stkscan.	1. scan Name table in new function header.	2. if found, set address of searching variable to chain address.	3. return the type of var, on stack, or global. (fs: unused, removed)******************************************************************************/nnewframe(newpfra2, achain, name)register struct frameex1 *newpfra2;	/* pointer to new frame extension */register DLword	*achain;	/* pointer to 1st word of the searching				  FVAR slot in CurrentFrameExtension */register int	name;		/* Atom index num. of target FVAR slot. */{register DLword	*pindex;	/* index to indexs of new name table */register int i;			/* temp for control */register int nametablesize;	/* NameTable size of current function header. */register int ph;		/* alink temp, also phase */newframe:	asm("_newframe_setup:");	asm("	.globl	_newframe_setup");	/* assume that apframe1 points to the next frame to be scanned */	ph = newpfra2->alink;	if(ph == ENDSTACKMARK){	/* endStack */		if(name & 0x8000){			*(achain+1) = VALS_HI + 1;			*achain = name*2;		}else{			*(achain+1) = VALS_HI;			*achain = name*2;		}		return;	}	ph &= 0xFFFE;	newpfra2 = (struct frameex1 *)(-FRAMESIZE + Stackspace + ph);	{ /* open new block to try and conserve address register */	register struct fnhead *newpfn2;	/* ptr to new fn header */	if(newpfra2->validnametable)		/* check VALIDNAMETABLE */		newpfn2 = (struct fnhead *)			(Addr68k_from_LADDR(((newpfra2->hi2nametable)<<16 |					      newpfra2->lonametable        )));	else	newpfn2 = (struct fnhead *)			(Addr68k_from_LADDR(((newpfra2->hi2fnheader)<<16 |					      newpfra2->lofnheader         )));	pindex = (DLword *)newpfn2 + FNHEADSIZE;		/* now pindex points 1st word of Nametable. */	nametablesize = newpfn2->ntsize;	}	asm("_newframe_loop:");	asm("	.globl	_newframe_loop");	i = (int) (pindex + nametablesize);	for(; i > (int) pindex;){	/* searching in NewFuncHeader */		if(*((DLword *)pindex++) == (DLword)name) {ph=1; goto foundit;}cont2:		if(*((DLword *)pindex++) == (DLword)name) {ph=2; goto foundit;}cont3:		if(*((DLword *)pindex++) == (DLword)name) {ph=3; goto foundit;}cont4:		if(*((DLword *)pindex++) == (DLword)name) {ph=0; goto foundit;}	continue;	foundit:	{			register int	fvartype;   /* probing fvar vartype */			register int	fvaroffset; /* probing fvar varoffset */			register DLword	*ppvar;	/* ptr to probing var candidate */			fvartype = *(-1 + pindex + nametablesize);			fvaroffset = 0xFF & fvartype;			fvaroffset <<= 1;			fvartype &= 0xFF00;				switch( fvartype ){			case FVPVARHI: /* 0x8000: */					ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;					/* ppvar points to argued Pvar */				if(((WBITS *)ppvar)->MSB)					/* check UNBOUND (if *ppvar is negative , unbound) */					switch ( ph ) {					    case 0 : continue;					    case 1 : goto cont2;					    case 2 : goto cont3;					    case 3 : goto cont4;					    }				*(achain+1) = STK_HI;				*achain = 0xFFFF & LADDR_from_68k( ppvar );					/* save High word of PVAR slot address to FVAR slot */					/* achain points to target FVAR slot */				return;			case FVFVARHI: /* 0xC000: */					ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;				if( ((WBITS *)ppvar)->LSB ) goto endlookfor;					/* Not Found in new FuncHeader, scan the next one. */				*((int *)achain) = *((int *)ppvar);					/* save address of frame extension to FVAR slot */					/* achain points to target FVAR slot */				return;			case FVIVARHI: /* 0x000: */					ppvar = -1 + (DLword *)newpfra2;					/* ppvar points to IVAR field in Basic  frame */				*(achain+1) = STK_HI;				*achain = *ppvar + fvaroffset;				return;			default:error("Stack corrupted: bad value in name table");			}/* end switch */		}/* end if */	}/* end for */endlookfor:	goto newframe;		/* scan the next one */}/******************************************************************************native_newframe	This routine is used by native code.	1. scan Name table in new function header.	2. if found, set address of searching variable to chain address.	3. return the pointer******************************************************************************/native_newframe(slot)int	slot;			/* index of FVAR slot. */{register struct frameex2 *newpfra2;	/* pointer to new frame extension */register DLword	*achain;	/* pointer to 1st word of the searching				  FVAR slot in CurrentFrameExtension */register int	name;		/* Atom index num. of target FVAR slot. */{					/* LOCAL temp regs */	register int rslot = slot;	register struct fnhead *fnobj = FuncObj;	register LispPTR *pvar = (LispPTR *) PVar;	name = *((DLword *)fnobj + 			 (fnobj->fvaroffset + rslot - fnobj->nlocals));		newpfra2 = (struct frameex2 *) ((DLword *) pvar - FRAMESIZE);	achain = (DLword *) (pvar + rslot);}{register DLword	*pindex;	/* index to indexs of new name table */register int i;			/* temp for control */register int nametablesize;	/* NameTable size of current function header. */register int alink;natnewframe:#ifndef NOASM	asm("natnewframe:");#endif	/* assume that apframe1 points to the next frame to be scanned */	alink = newpfra2->alink;	if(alink == ENDSTACKMARK){	/* endStack */		/*****		if(name & 0x8000){			*(achain+1) = VALS_HI + 1;			*achain = name*2;		}else{			*(achain+1) = VALS_HI;			*achain = name*2;		}		******* */		return(*((LispPTR *)achain) = newframe_vals_hi_ret(name));	}	newpfra2 = (struct frameex2 *)(-FRAMESIZE + Stackspace + (alink & 0xFFFE));	{ /* open new block to try and conserve address register */	register struct fnhead *newpfn2;	/* ptr to new fn header */	newpfn2 = (struct fnhead *) Addr68k_from_LADDR(swapx(			((newpfra2->validnametable)			? newpfra2->nametable			: newpfra2->fnheader			)) & 0x00ffffff);	pindex = (DLword *)newpfn2 + FNHEADSIZE;		/* now pindex points 1st word of Nametable. */	nametablesize = newpfn2->ntsize;	}#ifdef NOASM	for(i=nametablesize; --i >= 0;){						/* searching in NewFuncHeader */		if(*((DLword *)pindex++) == (DLword)name){#else#ifdef mc68020	i = nametablesize;	/* **** assumes: 		d7 = name		d6 = i		a3 = pindex	*** */ lookup:	asm("lookup: 	cmpw a3@+,d7");	asm("		dbeq d6,lookup");	asm("		bne natnewframe");{	{#else#ifdef sparc	for(i=nametablesize; --i >= 0;){						/* searching in NewFuncHeader */		if(*((DLword *)pindex++) == (DLword)name){#endif#endif#endif			register int	fvartype;   /* probing fvar vartype */			register int	fvaroffset; /* probing fvar varoffset */			register DLword	*ppvar;	/* ptr to probing var candidate */				fvartype = *(-1 + pindex + nametablesize);			fvaroffset = (0xFF & fvartype) << 1;			switch( fvartype >> 14 ){			case (FVPVARHI >> 14): /* 0x8000: */					ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;					/* ppvar points to argued Pvar */				if(((WBITS *)ppvar)->MSB)					/* check UNBOUND (if *ppvar is negative , unbound) */#ifdef NOASM					continue;#else#ifdef mc68020					goto lookup;#else#ifdef sparc					continue;#endif#endif#endif/* ******				*(achain+1) = STK_HI;				*achain = 0xFFFF & LADDR_from_68k( ppvar );***** */					/* save High word of PVAR slot address to FVAR slot */					/* achain points to target FVAR slot */				return(*((LispPTR *)achain) = 					newframe_stk_hi_ret(						LADDR_from_68k( ppvar )));			case (FVFVARHI >> 14): /* 0xC000: */					ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;				if( ((WBITS *)ppvar)->LSB ) goto endlookfor;					/* Not Found in new FuncHeader, scan the next one. *//* **				*((int *)achain) = *((int *)ppvar);*** */					/* save address of frame extension to FVAR slot */					/* achain points to target FVAR slot */				return(*((int *)achain) = *((int *)ppvar));			case (FVIVARHI >> 14): /* 0x000: */					ppvar = (DLword *)newpfra2 - 1;					/* ppvar points to IVAR field in Basic  frame *//* ****				*(achain+1) = STK_HI;				*achain = *ppvar + fvaroffset;*** */				return(*((LispPTR *)achain) = 					newframe_stk_hi_ret(*ppvar+fvaroffset));;			default:error("Stack corrupted: bad value in name table");			}/* end switch */		}/* end if */	}/* end for */endlookfor:	goto natnewframe;		/* scan the next one */}}