/* This is G-file @(#) arith4.c Version 2.3 (6/3/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) arith4.c	2.3 6/3/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther :  Takeshi Shimizu * *//***********************************************************************//* 		File Name :	arith4.c		Desc	:	  				Date :		Jul.15, 1987 				Edited by :	Takeshi Shimizu				Changed :	 		Including :	OP_times2 326Q(OP_itimes2 332Q)								OP_quot 327Q(OP_iquot 333Q)				OP_reminder 334Q												*//**********************************************************************/#include "lispemul.h"#include "lispmap.h"#include "emulglobal.h"#include "lispglobal.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "cell.h" #include "arith.h"#ifdef C_ONLY#define TWOS_compl(x) ((0xffff & (~(x)))+1)/**********************************************************************//*		Func name :	OP_times2(itimes2)			Date :		Jul. 15, 1987			Edited by :	Take*//**********************************************************************/OP_times2()  /* including OP_itimes2 */{  register LispPTR arg1 ; 	/* Keep val of CSTK */  register LispPTR res ;  register LispPTR  *cell68k ; 	/* Pointer to FIXP cell */  LispPTR *createcell68k();#ifdef TRACE	printPC();	printf("TRACE : OP_times2 \n");#endif  arg1 = *((LispPTR *)(CurrentStackPTR));  /* CSTK to arg1 without POP */  if((arg1 & 0xFF0000) ==  S_POSITIVE){	if((TopOfStack & 0xFF0000) == S_POSITIVE){	   /* posi * posi */	  res = (0xffff & TopOfStack) * (0xffff & arg1) ;	  goto POS;	}	else if ((TopOfStack & 0xFF0000) == S_NEGATIVE){	   /* posi * nega */	  if((arg1 & 0xffff)==0) goto ZERO; 	  res = (TWOS_compl(TopOfStack & 0xffff)) * (0xffff & arg1) ;	  goto NEG ;	}	else {		ufn(Get_BYTE(PC)); /* ufn case */		return;	     }	    } else if((arg1 & 0xFF0000) ==  S_NEGATIVE) {	  if((TopOfStack & 0xFF0000) == S_POSITIVE){	  /* nega * posi */		if((TopOfStack & 0xffff)==0) goto ZERO; 		res = (0xffff & TopOfStack) * TWOS_compl(0xffff & arg1) ;		goto NEG ;	   }	  else if ((TopOfStack & 0xFF0000) == S_NEGATIVE){		/* neg * neg */		  if(((arg1 & 0xffff)==0)||((TopOfStack & 0xffff)==0))		   {			 ufn(Get_BYTE(PC)); /* ufn case */			  return;		   }			res=TWOS_compl(arg1 & 0xffff)*TWOS_compl(0xffff & TopOfStack) ;			goto POS ;		}	}      else 	{		ufn(Get_BYTE(PC)); /* ufn case */		return;	}POS :	if(res & 0xffff0000) /* ufn case */	{	  if (res & 0x80000000) {		ufn(Get_BYTE(PC));/* MSB on? */ 		return ;	  }	  cell68k = createcell68k(TYPE_FIXP);	  *cell68k = res ;	  TopOfStack = LADDR_from_68k(cell68k);	}	else	TopOfStack=S_POSITIVE| (res&0xffff); 	CurrentStackPTR -= 2 ;	PC++; /* Increment PC */	return;NEG :	if(res & 0xffff0000) {		ufn(Get_BYTE(PC)); /* ufn case */		return;	 }	if((res = TWOS_compl(res))==0) {		ufn(Get_BYTE(PC)); /* ufn case */		return;	 }	TopOfStack=S_NEGATIVE | (res&0xffff); 	CurrentStackPTR -= 2 ;	PC++; /* Increment PC */	return;ZERO : 	TopOfStack=S_POSITIVE; 	CurrentStackPTR -= 2 ;	PC++; /* Increment PC */	return;} /* end OP_times2 *//**********************************************************************//*		Func name :	OP_quot(iquot)			Date :		Jun. 15, 1987			Edited by :	Take*//**********************************************************************/OP_quot(){ LispPTR  arg1 , res; #ifdef TRACE	printPC();	printf("TRACE : OP_quot \n");#endif  arg1 = *((LispPTR *)(CurrentStackPTR));  /* CSTK to arg1 without POP*/  if (((TopOfStack & 0xff0000) != S_POSITIVE) || ((arg1 & 0xff0000) != S_POSITIVE)	|| ((TopOfStack & 0xffff)==0))  {	ufn(Get_BYTE(PC)); /* ufn case */	return;  }  TopOfStack = S_POSITIVE | ((arg1 & 0xffff)/(TopOfStack & 0xffff)) ; 	CurrentStackPTR -= 2 ;	PC++; /* Increment PC */	return;} /* end OP_quot *//**********************************************************************//*		Func name :	OP_remainder			Date :		Jun. 15, 1987			Edited by :	Take*//**********************************************************************/OP_remainder(){ LispPTR  arg1 , res; #ifdef TRACE	printPC();	printf("TRACE : OP_remainder \n");#endif  arg1 = *((LispPTR *)(CurrentStackPTR));  /* CSTK to arg1 without POP*/  if (((TopOfStack & 0xff0000) != S_POSITIVE) || ((arg1 & 0xff0000) != S_POSITIVE)	|| ((TopOfStack & 0xffff)==0)) {	ufn(0334); /* ufn case */	return; }  TopOfStack = S_POSITIVE | ((arg1 & 0xffff)%(TopOfStack & 0xffff)) ; 	CurrentStackPTR -= 2 ;	PC++; /* Increment PC */	return;} /* end OP_remainder */#else/**********************************************************************//*		Func name :	N_OP_times2(itimes2)*//**********************************************************************/int N_OP_times2(a, b, error_addr)  /* including OP_itimes2 */	int a, b, *error_addr;{register int	arg1,arg2;register int	result;#ifdef TRACE	printPC();	printf("TRACE : N_OP_times2 \n");#endif	N_GETNUMBER( a, arg1, doufn );	N_GETNUMBER( b, arg2, doufn );	result = mpy32(arg1, arg2);	 	N_ARITH_SWITCH(result);doufn2:	asm("mpy_err:");		ERROR_EXIT(error_addr);doufn:	return(N_OP_ftimes2(a, b, doufn2));} /* end N_OP_times2 */int N_OP_itimes2(a, b, error_addr)  /* including OP_itimes2 */	int a, b, *error_addr;{register int	arg1,arg2;register int	result;#ifdef TRACE	printPC();	printf("TRACE : N_OP_itimes2 \n");#endif	N_IGETNUMBER( a, arg1, doufn );	N_IGETNUMBER( b, arg2, doufn );	result = impy32(arg1, arg2);	 	N_ARITH_SWITCH(result);	asm("impy_err:");	doufn:	ERROR_EXIT(error_addr);} /* end N_OP_times2 *//**********************************************************************//*		Func name :	N_OP_quot(iquot)*//**********************************************************************/int N_OP_quot(a, b, error_addr)	int a, b, *error_addr;{register int	arg1,arg2;register int	result;#ifdef	TRACE	printPC();	printf("TRACE: N_OP_quot()\n");#endif	N_GETNUMBER( a, arg1, doufn );	N_GETNUMBER( b, arg2, doufn );	if (arg2 == 0) goto doufn;	result = quot32(arg1, arg2);	 	N_ARITH_SWITCH(result);doufn2:	asm("quot_err:");		ERROR_EXIT(error_addr);doufn:	return(N_OP_fquotient(a, b, doufn2));	} /* end N_OP_quot */int N_OP_iquot(a, b, error_addr)	int a, b, *error_addr;{register int	arg1,arg2;register int	result;#ifdef	TRACE	printPC();	printf("TRACE: N_OP_iquot()\n");#endif	N_IGETNUMBER( a, arg1, doufn );	N_IGETNUMBER( b, arg2, doufn );	if (arg2 == 0) goto doufn;	result = iquot32(arg1, arg2);	 	N_ARITH_SWITCH(result);	asm("iquot_err:");	doufn:	ERROR_EXIT(error_addr);	} /* end N_OP_quot *//**********************************************************************//*		Func name :	N_OP_remainder*//**********************************************************************/int N_OP_remainder(a, b, error_addr)	int a, b, *error_addr;{register int	arg1,arg2;register int	result;#ifdef	TRACE	printPC();	printf("TRACE: N_OP_remainder()\n");#endif	N_GETNUMBER( a, arg1, doufn );	N_GETNUMBER( b, arg2, doufn );	if (arg2 == 0) goto doufn;	result = rem32(arg1, arg2);	 	N_ARITH_SWITCH(result);	asm("rem_err:");	doufn:	ERROR_EXIT(error_addr);		} /* end N_OP_remainder */int N_OP_iremainder(a, b, error_addr)	int a, b, *error_addr;{register int	arg1,arg2;register int	result;#ifdef	TRACE	printPC();	printf("TRACE: N_OP_iremainder()\n");#endif	N_IGETNUMBER( a, arg1, doufn );	N_IGETNUMBER( b, arg2, doufn );	if (arg2 == 0) goto doufn;	result = irem32(arg1, arg2);	 	N_ARITH_SWITCH(result);	asm("irem_err:");	doufn:	ERROR_EXIT(error_addr);		} /* end N_OP_remainder */#endif