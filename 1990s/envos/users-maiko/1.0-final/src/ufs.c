/* This is G-file @(#) ufs.c Version 2.20 (9/7/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) ufs.c	2.20 9/7/88";#include	<pwd.h>#include	<sys/file.h>#include	<sys/types.h>#include	<sys/stat.h>#include	<sys/param.h>#include	<sys/time.h>#include	<sys/vfs.h>#include	<setjmp.h>#include	<errno.h>#include	"lispemul.h"#include	"lispmap.h"#include	"address68k.h"#include	"lisptypes.h"#include	"arith.h"#include	"stream.h"#include	"timeout.h"#include	"localfile.h"char	*rindex();char	*index();UFS_openfile(args)register LispPTR	*args;/* args[0]		fullname *//* args[1]		rec *//* args[2]		acc *//* args[3]		cdate *//* args[4]		size *//* args[5]		errno */{register int	flags;	/* open system call's argument, and id of file */register int	*bufp;register int	rval;struct stat	statbuf;char	pathname[MAXPATHLEN];#ifdef	FSERRORint	*errp;	errp = (int *)(Addr68k_from_LADDR(args[5]));		ERRSETJMP(NIL, errp);#else	SETJMP(NIL);#endif	LispStringToCString(args[0], pathname);	flags = 0;	switch(args[1]){	case RECOG_OLD:	case RECOG_OLDEST:			break;	case RECOG_NEW_OLD:	case RECOG_NEW:			flags = O_CREAT;			break;	default:			return(NIL);	}	switch(args[2]){	case	ACCESS_INPUT:			flags |= O_RDONLY;			break;	case	ACCESS_OUTPUT:			unlink(pathname);			flags |= (O_RDWR | O_CREAT);			break;	case	ACCESS_APPEND:			flags |= (O_RDWR | O_CREAT);			break;	case	ACCESS_BOTH:			flags |= (O_RDWR | O_CREAT);			break;	default:			return(NIL);	}	TIMEOUT( flags=open(pathname, flags, 0666) );	if(flags == -1){		err_mess("open", errno);#ifdef FSERROR		*errp = errno;#endif		return(NIL);	}	TIMEOUT( rval=fstat(flags, &statbuf) );	if( rval == -1){		err_mess("fstat", errno);#ifdef FSERROR		*errp = errno;#endif		return(NIL);	}	bufp = (int *)(Addr68k_from_LADDR(args[3]));	*bufp = ToLispTime(statbuf.st_mtime);	bufp = (int *)(Addr68k_from_LADDR(args[4]));	*bufp = statbuf.st_size;	return(GetSmallp(flags));}UFS_closefile(args)register LispPTR	*args;/* args[0]		pathname	*//* args[1]		id	*//* args[2]		cdate	*//* args[3]		errno */{register int	id;	/* FileID */register int	date;	/* Creatoin Date */register char	*base;register int	rval;struct timeval time[2];struct stat	statbuf;char	pathname[MAXPATHLEN];#ifdef	FSERRORint	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));		ERRSETJMP(NIL, errp);#else	SETJMP(NIL);#endif	LispStringToCString(args[0], pathname);	id = LispNumToCInt(args[1]);	date = LispNumToCInt(args[2]);	if(date == 0){ /* just close */		TIMEOUT( rval=close(id) );		if( rval == -1){			err_mess("close", errno);#ifdef FSERROR			*errp = errno;#endif			return(NIL);		}		return(ATOM_T);	}	/* set Creation date and close */		TIMEOUT( rval=fstat(id, &statbuf) );		if(rval != 0){		err_mess("fstat", errno);#ifdef FSERROR		*errp = errno;#endif		return(NIL);	}	time[0].tv_sec = statbuf.st_atime;	time[1].tv_sec = ToUnixTime(date);	TIMEOUT( rval=close(id) );	if( rval == -1){		err_mess("close", errno);#ifdef FSERROR		*errp = errno;#endif		return(NIL);	}	TIMEOUT( rval=utimes(pathname, time) );	if(rval != 0){		err_mess("utimes", errno);#ifdef FSERROR		*errp = errno;#endif		return(NIL);	}	return(ATOM_T);}UFS_getfilename(args)register LispPTR	*args;/* args[0]		pathname	*//* args[1]		rec	*//* args[2]		buffer	*//* args[3]		errno	*/{register char	*base;register LispPTR	*naddress;register int	rval;char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];#ifdef	FSERRORint	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));	#endif	LispStringToCString(args[0], pathname);#ifdef	FSERROR	if( makepathname(pathname, fullpathname, errp) == 0){		*errp = errno;		return(NIL);	}#else	if( makepathname(pathname, fullpathname) == 0)		return(NIL);#endif	switch(args[1]){	case RECOG_OLD:	case RECOG_OLDEST:		SETJMP(NIL);		TIMEOUT( rval=access(fullpathname, F_OK) );		if(rval == -1){			/** There is no need to report access error. 			err_mess("access", errno);			**/			return(NIL);		}		break;	case RECOG_NEW_OLD:	case RECOG_NEW:	case RECOG_NON:		break;	default:		return(NIL);	}	/*** CStringToLispString ***/	naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));	rval = strlen(fullpathname);	strncpy(base, fullpathname, rval);	return(GetSmallp(rval));}#ifdef FSERRORmakepathname(src, dst, errp)register char	*src;register char	*dst;int	*errp;	#elsemakepathname(src, dst)register char	*src;register char	*dst;				#endif{register char	*base, *cp;register struct passwd *pwd;	base = src;	switch ( *base ) {	case '.':		if(getwd(dst) == 0){	/* set working directory */			return(0);		}		switch ( *(base+1) ){							case '.':			if(*(base+2) == '/'){	/* Now, base == "../xxxx" */				cp = rindex(dst, '/');				if(cp == 0){					return(0);				}				*cp = '\0';				strcat(dst, base+2);				return(1);								}else{									return(0);						}								case '/':			/* Now, base == "./xxx" */			strcat(dst, base+1);						return(1);								default:										return(0);						}	case '~':#ifdef FSERROR		ERRSETJMP(0, errp);#else		SETJMP(0);#endif		TIMEOUT( pwd = getpwuid( getuid()) );		if(pwd == NULL){							return(0);		}		sprintf(dst, "%s%s", pwd->pw_dir, base+1);		return(1);	default:		strcpy(dst, src);							return(1);								}}UFS_deletefile(args)LispPTR	*args;/*	args[0]:	Indirect pointer to buffer	*//*	args[1]:	errno	*/{register int	rval;char	pathname[MAXPATHLEN];#ifdef	FSERRORint	*errp;	errp = (int *)(Addr68k_from_LADDR(args[1]));		ERRSETJMP(NIL, errp);#else	SETJMP(NIL);#endif	LispStringToCString(args[0], pathname);	TIMEOUT( rval=unlink(pathname) );	if(rval == -1){		err_mess("unlink", errno);#ifdef FSERROR		*errp = errno;#endif		return(NIL);	}	return(ATOM_T);}UFS_renamefile(args)register LispPTR	*args;/*	args[0]:	Indirect pointer to buffer (old file name)	*//*	args[1]:	Indirect pointer to buffer (new file name)	*/{register int	rval;char	old_pathname[MAXPATHLEN], new_pathname[MAXPATHLEN];#ifdef	FSERRORint	*errp;	errp = (int *)(Addr68k_from_LADDR(args[2]));		ERRSETJMP(NIL, errp);#else	SETJMP(NIL);#endif	LispStringToCString(args[0], old_pathname);	LispStringToCString(args[1], new_pathname);	TIMEOUT( rval=rename(old_pathname, new_pathname) );	if( rval== -1){		err_mess("rename", errno);#ifdef FSERROR		*errp = errno;#endif		return(NIL);	}	return(ATOM_T);}/*** Common routine between DSK and UNIX. ****/UFS_readpage(args)register LispPTR	*args;/*	args[0]:	Indirect pointer to FileID	*//*	args[1]:	Indirect pointer to PageOffset	*//*	args[2]:	pointer to buffer		*/{register int	id;register int	pageoffset;register char	*bufp;register int	rval;register char	*bp;	SETJMP(NIL);	id = LispNumToCInt(args[0]);	pageoffset = LispNumToCInt(args[1]);	bufp = (char*)(Addr68k_from_LADDR(args[2]));	/* The filepointer is set to (pageoffset*PAGESIZE) bytes. */	TIMEOUT( rval=lseek(id, (pageoffset*PAGESIZE), L_SET) );	if(rval == -1){		err_mess("lseek", errno);		return(NIL);	}	/* Read BUFFSIZE bytes file contents from filepointer. */	TIMEOUT( rval=read(id, bufp, PAGESIZE) );	if(rval == -1){		err_mess("read", errno);		return(NIL);	}	/* Fill the unread part of buffer with 0. */	for(bp = &bufp[rval]; rval < PAGESIZE; ++rval, ++bp){		*bp = 0;	}	return(ATOM_T);}/*** Common routine between DSK and UNIX. ****/UFS_writepage(args)register LispPTR	*args;/*	args[0]	:	Indirect pointer to FileID *//*	args[1] :	Indirect pointer to PageOffset	*//*	args[2] :	pointer to buffer	*/	/*	args[3] :	Indirect pointer to size		*/{register int	id;register int	pageoffset;register char	*bufp;register int	rval, size;	SETJMP(NIL);	id = LispNumToCInt(args[0]);	pageoffset = LispNumToCInt(args[1]);	bufp = (char*)(Addr68k_from_LADDR(args[2]));	size = LispNumToCInt(args[3]);	/* The filepointer is set to (pageoffset*PAGESIZE) bytes. */	TIMEOUT( rval=lseek(id, (pageoffset*PAGESIZE), L_SET) );	if(rval == -1){		err_mess("lseek", errno);		return(NIL);	}	/* Read PAGESIZE bytes file contents from filepointer. */	TIMEOUT( rval=write(id, bufp, size) );	if( rval == -1){		err_mess("write", errno);		return(NIL);	}	return(ATOM_T);}UFS_getsize(args)register LispPTR	*args;/* This function set real file size. The name should be UFS_setsize *//*	args[0]:	Indirect pointer file ID to be closed *//*	args[1]:	Indirect pointer file size	*/{register int	rval;register int	id;	/* FileID */register int	size;	/* file size */struct	stat	sbuf;	/* Strucure for FileInfo. */#ifdef	FSERRORint	*errp;	errp = (int *)(Addr68k_from_LADDR(args[2]));		ERRSETJMP(NIL, errp);#else	SETJMP(NIL);#endif	id = LispNumToCInt(args[0]);	size = LispNumToCInt(args[1]);	TIMEOUT( rval=ftruncate(id, size) );	if(rval != 0){		err_mess("ftruncate", errno);#ifdef FSERROR		*errp = errno;#endif		return(NIL);	}	return(ATOM_T);}UFS_directorynamep(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to Directory Name */{register int	rval;struct	stat	sbuf;	/* Strucure for FileInfo. */char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];#ifdef	FSERRORint	*errp;	errp = (int *)(Addr68k_from_LADDR(args[1]));	#endif	LispStringToCString(args[0], pathname);#ifdef	FSERROR	if( makepathname(pathname, fullpathname, errp) == 0){		*errp = errno;		return(NIL);	}#else	if( makepathname(pathname, fullpathname) == 0)		return(NIL);#endif#ifdef	FSERROR	ERRSETJMP(NIL, errp);#else	SETJMP(NIL);#endif	TIMEOUT( rval=stat(fullpathname, &sbuf) );	if(rval != 0){		err_mess("stat", errno);#ifdef FSERROR		*errp = errno;#endif		return(NIL);	}	if((sbuf.st_mode & S_IFMT) == S_IFDIR)		return(ATOM_T);	return(NIL);}UFS_getfileinfo(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to File Name *//*	args[1]:	IndirectPonter to Attribute *//*	args[2]:	IndirectPonter to BUffer *//* args[3]		buf for errno */{register int	*buffixp;register char	*base;register struct passwd *pwd;register int	rval;LispPTR	*naddress;struct stat sbuf;char	pathname[MAXPATHLEN];#ifdef	FSERRORint	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));		ERRSETJMP(NIL, errp);#else	SETJMP(NIL);#endif	LispStringToCString(args[0], pathname);	TIMEOUT( rval=stat(pathname, &sbuf) );	if(rval != 0){		err_mess("stat", errno);#ifdef FSERROR		*errp = errno;#endif		return(NIL);	}	switch(args[1]){	case SIZE:		buffixp = (int *)(Addr68k_from_LADDR(args[2]));		*buffixp = sbuf.st_size;		return(ATOM_T);	case WDATE:		buffixp = (int *)(Addr68k_from_LADDR(args[2]));		*buffixp = ToLispTime(sbuf.st_mtime);		return(ATOM_T);	case RDATE:		buffixp = (int *)(Addr68k_from_LADDR(args[2]));		*buffixp= ToLispTime(sbuf.st_atime);		return(ATOM_T);	case AUTHOR:		TIMEOUT( pwd = getpwuid(sbuf.st_uid) );		if(pwd == NULL){			return(NIL);		}		/*** CStringToLispString ***/		naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));		base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));		rval = strlen(pwd->pw_name);		strncpy( base, pwd->pw_name, rval );				return(GetSmallp(rval));	case PROTECTION:		buffixp = (int *)(Addr68k_from_LADDR(args[2]));		*buffixp= sbuf.st_mode;		return(ATOM_T);	default:		return(NIL);	}}UFS_setfileinfo(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to File Name *//*	args[1]:	IndirectPonter to Attribute *//*	args[2]:	IndirectPonter to Value */{register int	rval;struct stat	sbuf;struct timeval time[2];char	pathname[MAXPATHLEN];#ifdef	FSERRORint	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));		ERRSETJMP(NIL, errp);#else	SETJMP(NIL);#endif	LispStringToCString(args[0], pathname);	TIMEOUT( rval=stat(pathname, &sbuf) );	if(rval != 0){		err_mess("stat", errno);#ifdef FSERROR		*errp = errno;#endif		return(NIL);	}	switch(args[1]){	case WDATE:		rval = LispNumToCInt(args[2]);		time[0].tv_sec = sbuf.st_atime;		time[1].tv_sec = ToUnixTime(rval);		TIMEOUT( rval=utimes(pathname, time) );		if(rval != 0){			err_mess("utimes", errno);#ifdef FSERROR			*errp = errno;#endif			return(NIL);		}		return(ATOM_T);	default:		return(NIL);	}}UFS_dirsize(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to Directory Name *//*	args[1]:	IndirectPonter to Filter Name */{register int	size;char	dirname[MAXPATHLEN];char	fulldirname[MAXPATHLEN];char	filter[MAXPATHLEN];#ifdef	FSERRORint	errp;#endif	LispStringToCString(args[0], dirname);#ifdef	FSERROR	if( makepathname(dirname, fulldirname, &errp) == 0)#else	if( makepathname(dirname, fulldirname) == 0)#endif		return(NIL);	LispStringToCString(args[1], filter);	size = alldirSize( fulldirname, "", 0, filter);	if(size == -1)		return(NIL);	else		return(GetSmallp(size));}UFS_readdir(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to Directory Name *//*	args[1]:	IndirectPonter to Filter Name *//*	args[2]:	IndirectPonter to BUffer */{register LispPTR	*naddress;register char	*base;register int	size;char	dirname[MAXPATHLEN];char	fulldirname[MAXPATHLEN];char	filter[MAXPATHLEN];#ifdef	FSERRORint	*errp;	errp = (int *)(Addr68k_from_LADDR(args[3]));	#endif	LispStringToCString(args[0], dirname);#ifdef	FSERROR	if( makepathname(dirname, fulldirname, errp) == 0){		*errp = errno;		return(NIL);	}#else	if( makepathname(dirname, fulldirname) == 0)		return(NIL);#endif	LispStringToCString(args[1], filter);	naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));	size = UFS_readAllDir(fulldirname, "", 0, filter, base);	if(size == -1)		return(NIL);	else		return(GetSmallp(size));}UFS_changedir(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to Directory Name */{register int	rval;char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];#ifdef	FSERRORint	errp;#endif	LispStringToCString(args[0], pathname);#ifdef	FSERROR	if( makepathname(pathname, fullpathname, &errp) == 0)#else	if( makepathname(pathname, fullpathname) == 0)#endif		return(NIL);	SETJMP(NIL);	TIMEOUT( rval=chdir(fullpathname) );	if(rval != 0){		err_mess("chdir", errno);			return(NIL);	}	return(ATOM_T);}UFS_getfreeblock(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to file Name *//*	args[1]:	IndirectPonter to buffer */{register int	*buffixp;register char	*cp;register int	rval;struct statfs	buf;char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];#ifdef	FSERRORint	errp;#endif	buffixp = (int *)(Addr68k_from_LADDR(args[1]));	LispStringToCString(args[0], pathname);	/*** SkipHostName ***/	if(*pathname == '{'){		if((cp=index(pathname, '}')) == 0)			cp = pathname;		else			++cp;	}else		cp = pathname;#ifdef	FSERROR	if( makepathname(cp, fullpathname, &errp) == 0){#else	if( makepathname(cp, fullpathname) == 0){#endif		*buffixp = 0;			return(NIL);	}	while(T){		if((cp=rindex(fullpathname, '/')) == 0){			*buffixp = 0;				return(NIL);		}		*cp = '\0';		SETJMP(NIL);		TIMEOUT( rval=statfs(fullpathname, &buf) );		if( rval == 0){			break;		}	}		*buffixp = buf.f_bavail;	return(ATOM_T);}