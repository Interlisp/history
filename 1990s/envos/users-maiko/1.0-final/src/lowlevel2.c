/* This is G-file @(#) lowlevel2.c Version 2.4 (8/1/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) lowlevel2.c	2.4 8/1/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther	:	Hiroshi Hayata	 */#include <stdio.h>#include "lispemul.h"#include "lispglobal.h"#include "address68k.h"#include "lispmap.h"#include "lisptypes.h"#include "emulglobal.h"#ifdef C_ONLY/************************************************************ OP_addbase	entry		ADDBASE		OPCODE[0320]	1. 	<<Enter>>		TopOfStack: offset		*(CurrentStackPTR): base address	2.	if High word of TopOfStack is SMALLPL or SMALLNEG,		then add base address and offset and set the result to TopOfStack.		else call ufn2incs.	3.	increment PC.	4.	<<Exit>>		TopOfStack: new address***********************************************************/OP_addbase(){register int	base;	/* base address */#ifdef	TRACE	printPC();	printf("TRACE: OP_addbase()\n");#endif/*CSP	base = 0xFFFFFF & *((int *)(--CurrentStackPTR));	*/	base = 0xFFFFFF & *((int *)(CurrentStackPTR));	switch( (0xFFFF0000 & TopOfStack) ){	case S_POSITIVE:		TopOfStack = base + (TopOfStack & 0x0000FFFF);		break;	case S_NEGATIVE:		TopOfStack = base + (TopOfStack | 0xFFFF0000);		break;	default:		switch( (GetTypeNumber(TopOfStack)) ){		case TYPE_FIXP:			/* overflow or underflow isn't check */ 			TopOfStack = base + *(int *)Addr68k_from_LADDR(TopOfStack);			break;		case TYPE_FLOATP:			/* Fixp.From.Floatp not implemented */			/* TopOfStack				 = base + ((int) *Addr68k_from_LADDR(TopOfStack)); */			error("FLOATP not implemented!");			break;		default:			error("NON-NUMERIC ARG!");			break;		}/* end switch */		break;	}/* end switch *//*CSP	--CurrentStackPTR;	*/	CurrentStackPTR-=2;	++PC;}/************************************************************ OP_getbasebyte	entry		GETBASEBYTE		OPCODE[0302]	1.	<<Enter>>		*(--CuurentStackPTR): base address.		TopOfStack: 	Low word - byte offset.	2.	if high word of TopOfStack is not SMALLPL,		then	call ufn2incS.		else	fetch 8 bits word at (base address + byte offset).	3.	increment PC by 1.	4.	<<Exit>>		TopOfStack: 	Least Low Byte - fetched data***********************************************************/OP_getbasebyte(){register LispPTR	base_addr;	/* base address, Lisp address */register int		byteoffset;	/* byte offset for fetched data. */register char *ptr;#ifdef	TRACE	printPC();	printf("TRACE: OP_getbasebyte()\n");#endif/*CSP	base_addr = *((LispPTR *)(--CurrentStackPTR));	*/	base_addr = *((LispPTR *)(CurrentStackPTR));	switch( (0xFFFF0000 & TopOfStack) ){	case S_POSITIVE:		byteoffset =  TopOfStack & 0x0000FFFF;		break;	case S_NEGATIVE:		byteoffset = TopOfStack | 0xFFFF0000;		break;	default:		switch( (GetTypeNumber(TopOfStack)) ){		case TYPE_FIXP:			byteoffset = *((int *)Addr68k_from_LADDR(TopOfStack));			break;		case TYPE_FLOATP:			/* Fixp.From.Floatp not implemented */			/* byteoffset = *Addr68k_from_LADDR((int)TopOfStack); */			error("FLOATP offset is not implemented!");			break;		default:			error("NON-NUMERIC ARG!");			break;			}/* end switch */		break;	}/* end switch */	TopOfStack = (0xFF & (*((char*)Addr68k_from_LADDR((0xFFFFFF & base_addr)) + byteoffset))) | S_POSITIVE;/*CSP	--CurrentStackPTR;	*/	CurrentStackPTR -= 2;	++PC;}/************************************************************ OP_putbasebyte	entry		PUTBASEBYTE		OPCODE[0307]	1.	<<Enter>>		TopOfStack: 	Least Low Byte - replace data.		*((int *)(CurrentStackPTR-1)): byte offset.		*((int *)(CurrentStackPTR-2)): base address.	2.	increment PC by 1.	3.	<<Exit>>		TopOfStack: 	Least Low Byte - replace data ?***********************************************************/OP_putbasebyte(){register LispPTR	base_addr;	/* base address, Lisp address */register int	byteoffset;	/* byte offset from base_addr */register char *ptr;#ifdef	TRACE	printPC();	printf("TRACE: OP_putbasebyte()\n");#endif/*CSP	byteoffset = *((int *)(CurrentStackPTR - 1));	base_addr = *((LispPTR *)((CurrentStackPTR - 3)));	*/	byteoffset = *((LispPTR *)(CurrentStackPTR));	base_addr = *((LispPTR *)((CurrentStackPTR - 2)));		if( ((0xFFFF0000 & TopOfStack ) != S_POSITIVE) || ((unsigned short)TopOfStack >= 256) )		error("ILLEGAL ARG!");	switch( (0xFFFF0000 & byteoffset) ){	case S_POSITIVE:		byteoffset &=  0x0000FFFF;		break;	case S_NEGATIVE:		byteoffset |=  0xFFFF0000;		break;	default:		switch( (GetTypeNumber(byteoffset)) ){		case TYPE_FIXP:			byteoffset = *((int *)Addr68k_from_LADDR(byteoffset));			break;		case TYPE_FLOATP:			/* Fixp.From.Floatp not implemented */			/* byteoffset = *Addr68k_from_LADDR((int)byteoffset); */			error("FLOATP offset is not implemented!");			break;		default:			error("NON-NUMERIC ARG!");			break;			}/* end switch */		break;	}/* end switch */	*(((char*)Addr68k_from_LADDR(0xFFFFFF & base_addr)) + byteoffset) = 0xFF & TopOfStack;  	CurrentStackPTR -= 4;	++PC;}#else/************************************************************ N_OP_addbase	entry		ADDBASE		OPCODE[0320]	1. 	<<Enter>>		TopOfStack: offset		*(CurrentStackPTR): base address	2.	if High word of TopOfStack is SMALLPL or SMALLNEG,		then add base address and offset and set the result to TopOfStack.		else call ufn2incs.	4.	<<Exit>>		return: new address***********************************************************/LispPTR N_OP_addbase(base, offset, error_addr)	register int base, offset;	int *error_addr;{#ifdef	TRACE	printf("TRACE: N_OP_addbase()\n");#endif	base = 0xFFFFFF & base;	switch( (0xFFFF0000 & offset) ){	case S_POSITIVE:		return(base + (offset & 0x0000FFFF));	case S_NEGATIVE:		return(base + (offset | 0xFFFF0000));	default:		switch( (GetTypeNumber(offset)) ){		case TYPE_FIXP:			/* overflow or underflow isn't check */ 			return(base + *(int *)Addr68k_from_LADDR(offset));		case TYPE_FLOATP:			ERROR_EXIT(error_addr);		default:			ERROR_EXIT(error_addr);		}/* end switch */	}/* end switch */}/************************************************************ N_OP_getbasebyte	entry		GETBASEBYTE		OPCODE[0302]	1.	<<Enter>>		*(--CurrentStackPTR): base address.		TopOfStack: 	Low word - byte offset.	2.	if high word of TopOfStack is not SMALLPL,		then	call ufn2incS.		else	fetch 8 bits word at (base address + byte offset).	4.	<<Exit>>		return: 	Least Low Byte - fetched data***********************************************************/N_OP_getbasebyte(base_addr, byteoffset, error_addr)	register LispPTR base_addr;	register int byteoffset;	int *error_addr;{register char *ptr;#ifdef	TRACE	printf("TRACE: N_OP_getbasebyte()\n");#endif	switch( (0xFFFF0000 & byteoffset) ){	case S_POSITIVE:		byteoffset =  byteoffset & 0x0000FFFF;		break;	case S_NEGATIVE:		byteoffset = byteoffset | 0xFFFF0000;		break;	default:		switch( (GetTypeNumber(byteoffset)) ){		case TYPE_FIXP:			byteoffset = *((int *)Addr68k_from_LADDR(byteoffset));			break;		case TYPE_FLOATP:			ERROR_EXIT(error_addr);		default:			ERROR_EXIT(error_addr);			}/* end switch */		break;	}/* end switch */	return((0xFF & (*((char*)Addr68k_from_LADDR((0xFFFFFF & base_addr)) + byteoffset))) | S_POSITIVE);}/************************************************************ N_OP_putbasebyte	entry		PUTBASEBYTE		OPCODE[0307]	1.	<<Enter>>		TopOfStack: 	Least Low Byte - replace data.		*((int *)(CurrentStackPTR-1)): byte offset.		*((int *)(CurrentStackPTR-2)): base address.	4.	<<Exit>>		return: 	Least Low Byte - replace data ?***********************************************************/N_OP_putbasebyte(base_addr, byteoffset, data, error_addr)	register int byteoffset;	register LispPTR base_addr;	register int data;	int *error_addr;{register char *ptr;#ifdef	TRACE	printf("TRACE: N_OP_putbasebyte()\n");#endif	if(((0xFFFF0000 & data ) != S_POSITIVE) || ((unsigned short)data >= 256))		ERROR_EXIT(error_addr);	switch( (0xFFFF0000 & byteoffset) ){	case S_POSITIVE:		byteoffset &=  0x0000FFFF;		break;	case S_NEGATIVE:		byteoffset |=  0xFFFF0000;		break;	default:	/* ucode and ufn don't handle displacement not smallp */		ERROR_EXIT(error_addr);	}/* end switch */	*(((char*)Addr68k_from_LADDR(0xFFFFFF & base_addr)) + byteoffset) = 0xFF & data;  	return ( data );}#endif