/* This is G-file @(#) arith2.c Version 2.3 (6/3/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) arith2.c	2.3 6/3/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther	:	Hiroshi Hayata	 */#include <stdio.h>#include "lispemul.h"#include "lispglobal.h"#include "emulglobal.h"#include "address68k.h"#include "lispmap.h"#include "lisptypes.h"#include "arith.h"#define	SLOWPLUS2	324#define	SLOWIPLUS2	330#define	SLOWDIFFERENCE	325#define	SLOWIDIFFERENCE	331DLword	*createcell68k();#ifdef C_ONLY/************************************************************OP_plus2	entry		PLUS2		OPCODE[0324]	entry		IPLUS2		OPCODE[0330]	1.	<<Entrer>>		*((int *)(CurrentStackPTR))	: argument 1 of PLUS2		TopOfStack			: argument 2 of PLUS2		They are SMALLPL or SMALLNEG, Lisp address.	2.	add argument 1 and argument 2.	3.	<<Exit>>		TopOfStack			: added value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_plus2(){register int	arg1,arg2;register int	result;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_plus2()\n");#endif/*CSP	GetNumber( *((int *)(CurrentStackPTR-1)), arg1 );	*/	GetNumber( *((int *)CurrentStackPTR), arg1 );	GetNumber( TopOfStack, arg2 );	if( (MIN_FIXP <= (arg1 + arg2)) && ((arg1 + arg2) <= MAX_FIXP) ){		/* MIN_FIXP <= (arg1 + arg2) <= MAX_FIXP */		result = arg1 + arg2;	 		if(0 <= result){			if(result <= MAX_SMALL)				TopOfStack = S_POSITIVE | result;			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}else{			if(MIN_SMALL <= result)				TopOfStack = S_NEGATIVE | (0xFFFF & result);			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);	}		}/* end if(0 <= result).... */	}else{		/**** call Lisp Func. ****/		if((0xFF & (*PC)) == SLOWPLUS2){			ufn(SLOWPLUS2);			return;		}else{			ufn(SLOWIPLUS2);			return;		}	}	CurrentStackPTR -= 2;	++PC;}/************************************************************OP_difference	entry		DIFFERENCE		OPCODE[0325]	entry		IDIFFERENCE		OPCODE[0331]	1.	<<Entrer>>		*((int *)(CurrentStackPTR))	: argument 1 of PLUS2		TopOfStack			: argument 2 of PLUS2		They are SMALLPL or SMALLNEG, Lisp address.	2.	subtract argument 2 from argument 1.			(arg1 - arg2)	3.	<<Exit>>		TopOfStack			: subtrated value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_difference(){register int	arg1,arg2;register int	result;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_difference()\n");#endif	GetNumber( *((int *)(CurrentStackPTR)), arg1);	GetNumber( TopOfStack, arg2 );	if( (MIN_FIXP <= (arg1 - arg2)) && ((arg1 - arg2) <= MAX_FIXP) ){		/* MIN_FIXP <= (arg1 - arg2) <= MAX_FIXP */		result = arg1 - arg2;	 		if(0 <= result){			if(result <= MAX_SMALL)				TopOfStack = S_POSITIVE | result;			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}else{			if(MIN_SMALL <= result)				TopOfStack = S_NEGATIVE | (0xFFFF & result);			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((unsigned int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}/* end if(0 <= result).... */	}else{		/**** call Lisp Func. ****/		if((0xFF & (*PC)) == SLOWDIFFERENCE){			ufn(SLOWDIFFERENCE);			return;		}else{			ufn(SLOWIDIFFERENCE);			return;		}	}	CurrentStackPTR -= 2;	++PC;}/************************************************************OP_logxor	entry		LOGXOR2		OPCODE[0346]	1.	<<Entrer>>		*((int *)(CurrentStackPTR))	: argument 1 of LOGXOR		TopOfStack			: argument 2 of LOGXOR		They are SMALLPL or SMALLNEG, Lisp address.	2.	ex-or argument 1 and argument 2.	3.	<<Exit>>		TopOfStack			: ex-ored value			It is SMALLPL or SMALLNEG, Lisp address.************************************************************/OP_logxor(){register int	arg1,arg2;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_logxor()\n");#endif/*CSP	GetNumber( *((int *)(CurrentStackPTR-1)), arg1);	*/	GetNumber( *((int *)(CurrentStackPTR)), arg1);	GetNumber( TopOfStack, arg2 );	arg1 ^= arg2;	switch(arg1 & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg1;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg1);			break;		default:			/* arg1 is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg1;			TopOfStack = LADDR_from_68k(wordp);			break;	}	CurrentStackPTR -= 2;	++PC;}/************************************************************OP_logand	entry		LOGAND2		OPCODE[0345]	1.	<<Entrer>>		*((int *)(CurrentStackPTR))	: argument 1 of LOGAND		TopOfStack			: argument 2 of LOGAND		They are SMALLPL or SMALLNEG, Lisp address.	2.	and argument 1 and argument 2.	3.	<<Exit>>		TopOfStack			: anded value			It is SMALLPL or SMALLNEG, Lisp address.************************************************************/OP_logand(){register int	arg1,arg2;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_logand()\n");#endif/*CSP	GetNumber( *((int *)(CurrentStackPTR-1)), arg1 );	*/	GetNumber( *((int *)(CurrentStackPTR)), arg1 );	GetNumber( TopOfStack, arg2 );	arg1 &= arg2;	switch(arg1 & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg1;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg1);			break;		default:			/* arg1 is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg1;			TopOfStack = LADDR_from_68k(wordp);			break;	}	CurrentStackPTR -= 2;	++PC;}/************************************************************OP_logor	entry		LOGOR2		OPCODE[0344]	1.	<<Entrer>>		*((int *)(CurrentStackPTR))	: argument 1 of LOGOR		TopOfStack			: argument 2 of LOGOR		They are SMALLPL or SMALLNEG, Lisp address.	2.	or argument 1 and argument 2.	3.	<<Exit>>		TopOfStack			: ored value			It is SMALLPL or SMALLNEG, Lisp address.************************************************************/OP_logor(){register int	arg1,arg2;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_logor()\n");#endif/*CSP	GetNumber( *((int *)(CurrentStackPTR-1)), arg1 );	*/	GetNumber( *((int *)(CurrentStackPTR)), arg1 );	GetNumber( TopOfStack, arg2 );	arg1 |= arg2;	switch(arg1 & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg1;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg1);			break;		default:			/* arg1 is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg1;			TopOfStack = LADDR_from_68k(wordp);			break;	}	CurrentStackPTR -= 2;	++PC;}/************************************************************OP_greaterp	entry		GREATERP		OPCODE[0363]	entry		IGREATERP		OPCODE[0361]	1.	<<Entrer>>		*((int *)(CurrentStackPTR))	: argument 1 of GREATERP		TopOfStack			: argument 2 of GREATERP		They are SMALLPL or SMALLNEG, Lisp address.	2.	compare argument 1 and argument 2.			arg1 > arg2  -- T			arg1 <= arg2 -- NIL	3.	<<Exit>>		TopOfStack			: T or NIL	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_greaterp(){register int	arg1,arg2;#ifdef	TRACE	printPC();	printf("TRACE: OP_greaterp()\n");#endif/*	GetNumber( *((int *)(CurrentStackPTR-1)), arg1 );	*/	GetNumber( *((int *)(CurrentStackPTR)), arg1 );	GetNumber( TopOfStack, arg2 );	if(arg1 > arg2)		TopOfStack = ATOM_T;	else		TopOfStack = NIL_PTR;	CurrentStackPTR -= 2;	++PC;}/************************************************************OP_iplusn	entry		IPLUS.N		OPCODE[0335]	1.	<<Entrer>>		TopOfStack	: argument 1 of IPLUS.N		alpha		: argument 2 of IPLUS.N		TopOfStack is SMALLPL or SMALLNEG, Lisp address.		alpha is immidiate data.	2.	add argument 1 and argument 2.			(arg1 + arg2)	3.	<<Exit>>		TopOfStack			: added value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_iplusn(){register int	arg1,arg2;register int	result;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_iplusn()\n");#endif	GetNumber( TopOfStack, arg1 );	arg2 = 0xFF & (*(PC + 1));	if( (MIN_FIXP <= (arg1 + arg2)) && ((arg1 + arg2) <= MAX_FIXP) ){		/* MIN_FIXP <= (arg1 + arg2) <= MAX_FIXP */		result = arg1 + arg2;	 		if(0 <= result){			if(result <= MAX_SMALL)				TopOfStack = S_POSITIVE | result;			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}else{			if(MIN_SMALL <= result)				TopOfStack = S_NEGATIVE | (0xFFFF & result);			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}/* end if(0 <= result).... */	}else{		/**** call Lisp Func. ****/		ufn(SLOWIPLUS2);		return;	}	/**CurrentStackPTR -= 2; ** BUG **/	PC += 2;}/************************************************************OP_idifferencen	entry		IDIFFERENCE.N		OPCODE[0336]	1.	<<Entrer>>		TopOfStack	: argument 1 of IDIFFERENCE.N		alpha		: argument 2 of IDIFFERENCE.N		TopOfStack is SMALLPL or SMALLNEG, Lisp address.		alpha is immidiate data.	2.	subtract argument 2 from argument 1.			(arg1 - arg2)	3.	<<Exit>>		TopOfStack			: subtracted value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_idifferencen(){register int	arg1,arg2;register int	result;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_idifferencen()\n");#endif	GetNumber( TopOfStack, arg1 );	arg2 = 0xFF & (*(PC + 1));	if( (MIN_FIXP <= (arg1 - arg2)) && ((arg1 - arg2) <= MAX_FIXP) ){		/* MIN_FIXP <= (arg1 - arg2) <= MAX_FIXP */		result = arg1 - arg2;	 		if(0 <= result){			if(result <= MAX_SMALL)				TopOfStack = S_POSITIVE | result;			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}else{			if(MIN_SMALL <= result)				TopOfStack = S_NEGATIVE | (0xFFFF & result);			else{				/* result is FIXP, call createcell */				wordp = createcell68k(TYPE_FIXP);				*((int *)wordp) = result;				TopOfStack = LADDR_from_68k(wordp);			}		}/* end if(0 <= result).... */	}else{		/**** call Lisp Func. ****/		ufn(SLOWIDIFFERENCE);		return;	}	/**CurrentStackPTR -= 2; BUG **/	PC += 2;}#else/************************************************************N_OP_plus2	entry		PLUS2		OPCODE[0324]	entry		IPLUS2		OPCODE[0330]	return(a = b)************************************************************/int N_OP_plus2(b, a, error_addr)	int a, b;	int *error_addr;{register int	arg1,arg2;register int	result;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: N_OP_plus2()\n");#endif	N_GETNUMBER( a, arg1, doufn );	N_GETNUMBER( b, arg2, doufn );	result = plus32(arg1, arg2);	 	N_ARITH_SWITCH(result);doufn2:	asm("plus_err:");		ERROR_EXIT(error_addr);		/* try floating pt plus */doufn:		return(N_OP_fplus2(b, a, doufn2));}int N_OP_iplus2(b, a, error_addr)	int a, b;	int *error_addr;{register int	arg1,arg2;register int	result;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: N_OP_iplus2()\n");#endif	N_IGETNUMBER( a, arg1, doufn );	N_IGETNUMBER( b, arg2, doufn );	result = iplus32(arg1, arg2);	 	N_ARITH_SWITCH(result);asm("iplus_err:");	doufn:		ERROR_EXIT(error_addr);}/************************************************************N_OP_difference	entry		DIFFERENCE		OPCODE[0325]	entry		IDIFFERENCE		OPCODE[0331]	return(a - b)************************************************************/int N_OP_difference(a, b, error_addr)	int a, b, *error_addr;{register int	arg1,arg2;register int	result;#ifdef	TRACE	printPC();	printf("TRACE: N_OP_difference()\n");#endif	N_GETNUMBER( a, arg1, doufn );	N_GETNUMBER( b, arg2, doufn );	result = sub32(arg1, arg2);	 	N_ARITH_SWITCH(result);doufn2:	asm("diff_err:");		ERROR_EXIT(error_addr);		/* try floating pt difference */doufn:	return(N_OP_fdifference(a, b, doufn2));		}int N_OP_idifference(a, b, error_addr)	int a, b, *error_addr;{register int	arg1,arg2;register int	result;#ifdef	TRACE	printPC();	printf("TRACE: N_OP_idifference()\n");#endif	N_IGETNUMBER( a, arg1, doufn );	N_IGETNUMBER( b, arg2, doufn );	result = isub32(arg1, arg2);	 	N_ARITH_SWITCH(result);asm("idiff_err:");	doufn:		ERROR_EXIT(error_addr);		}/************************************************************N_OP_logxor	entry		LOGXOR2		OPCODE[0346]	return(a ^ b)************************************************************/N_OP_logxor(a, b, error_addr)	int a, b, *error_addr;{#ifdef	TRACE	printPC();	printf("TRACE: N_OP_logxor()\n");#endif	N_IARITH_BODY_2(a, b, error_addr, ^);}/************************************************************N_OP_logand	entry		LOGAND2		OPCODE[0345]	return(a & b)************************************************************/N_OP_logand(a, b, error_addr)	int a, b, *error_addr;{#ifdef	TRACE	printPC();	printf("TRACE: N_OP_logand()\n");#endif	N_IARITH_BODY_2(a, b, error_addr, &);}/************************************************************N_OP_logor	entry		LOGOR2		OPCODE[0344]	return(a | b)************************************************************/N_OP_logor(a, b, error_addr)	int a, b, *error_addr;{#ifdef	TRACE	printPC();	printf("TRACE: N_OP_logor()\n");#endif	N_IARITH_BODY_2(a, b, error_addr, |);}/************************************************************N_OP_greaterp	entry		GREATERP		OPCODE[0363]	entry		IGREATERP		OPCODE[0361]	return(a > b)************************************************************/N_OP_greaterp(a, b, error_addr)	int a, b, *error_addr;{register int	arg1,arg2;#ifdef	TRACE	printPC();	printf("TRACE: N_OP_greaterp()\n");#endif	N_GETNUMBER( a, arg1, do_ufn);	N_GETNUMBER( b, arg2, do_ufn);	if(arg1 > arg2)		return(ATOM_T);	else		return(NIL_PTR);do_ufn2: ERROR_EXIT(error_addr);do_ufn:	 return(N_OP_fgreaterp(a, b, do_ufn2));}N_OP_igreaterp(a, b, error_addr)	int a, b, *error_addr;{register int	arg1,arg2;#ifdef	TRACE	printPC();	printf("TRACE: N_OP_igreaterp()\n");#endif	N_IGETNUMBER( a, arg1, do_ufn);	N_IGETNUMBER( b, arg2, do_ufn);	if(arg1 > arg2)		return(ATOM_T);	else		return(NIL_PTR);do_ufn:	ERROR_EXIT(error_addr);}/************************************************************N_OP_iplusn	entry		IPLUS.N		OPCODE[0335]	return(a + n)************************************************************/N_OP_iplusn(a, n, error_addr)	int a, n, *error_addr;{register int	arg1;register int	result;#ifdef	TRACE	printPC();	printf("TRACE: N_OP_iplusn()\n");#endif	N_IGETNUMBER( a, arg1, do_ufn );	result = iplus32n(arg1, n);	 	N_ARITH_SWITCH(result);asm("iplusn_err:");	do_ufn:	ERROR_EXIT(error_addr);}/************************************************************N_OP_idifferencen	entry		IDIFFERENCE.N		OPCODE[0336]	return(a - n)************************************************************/N_OP_idifferencen(a, n, error_addr)	int a, n, *error_addr;{register int	arg1;register int	result;#ifdef	TRACE	printPC();	printf("TRACE: N_OP_idifferencen()\n");#endif	N_IGETNUMBER( a, arg1, do_ufn );	result = sub32n(arg1, n);	 	N_ARITH_SWITCH(result);asm("diff_err2:");	do_ufn:	ERROR_EXIT(error_addr);}#endif