/* This is G-file @(#) bitblt.c Version 2.8 (8/10/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) bitblt.c      2.8 8/10/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Author :  Osamu Nakamura * */#include <stdio.h>#include <sys/ioctl.h>#include <pixrect/pixrect_hs.h>#include <sunwindow/window_hs.h>#include <sunwindow/win_ioctl.h>#ifdef WINDOW#include <suntool/sunview.h>#include <signal.h>#include <sunwindow/cms_mono.h>#include <suntool/canvas.h>#endif#include "lispemul.h"#include "lispglobal.h"#include "lispmap.h"#include "emulglobal.h"#include "address68k.h"#include "address.h"#include "pilotbbt.h"#include "display.h"#include "bitblt.h"extern int LispWindowFd;extern int DisplayWidth, DisplayHeight;extern struct pixrect *SrcPixRect, *DestPixRect, *TexturePixRect;extern struct cursor	CurrentCursor;/* DisplayLockArea specifies win_lock area when bitblt is operated * It specifies whole screen area. */extern struct winlock DisplayLockArea;#ifdef WINDOWextern Pixwin *Lisp_pw;extern struct pixrect *ScreenBitMap;#endifhidecursor(){	ioctl( LispWindowFd, WINLOCKSCREEN, &DisplayLockArea);}showcursor(){	ioctl( LispWindowFd, WINUNLOCKSCREEN, &DisplayLockArea);}/*****************************************************************************//*****************************************************************************//**									    **//**				N_OP_pilotbitblt			    **//**									    **//**	  The Native-code compatible version of the opcode for bitblt.	    **//**									    **//**									    **//*****************************************************************************//*****************************************************************************/LispPTR N_OP_pilotbitblt(pilot_bt_tbl, tos, error_addr)     LispPTR pilot_bt_tbl;     int tos;     int *error_addr;     {	register PILOTBBT  *pbt;#define tpbt ((TEXTUREBBT *) pbt)	register short 	*srcaddr, *destaddr;	int displayflg;	u_short pix_op;	int	sx, dx, w, h, y;		pbt = (PILOTBBT *)Addr68k_from_LADDR(pilot_bt_tbl);	/* if displayflg != 0 then source or destination is DisplayBitMap */ 	displayflg = cursorin(pbt->pbtdesthi, pbt->pbtdestlo, 			      (dx=pbt->pbtdestbit),  			      (w=pbt->pbtwidth), (h=pbt->pbtheight), y,			      pbt->pbtbackward)  || 		     cursorin(pbt->pbtsourcehi, pbt->pbtsourcelo,  		     	      (sx=pbt->pbtsourcebit), w, h, y, 			      pbt->pbtbackward); 		     	srcaddr = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,						     pbt->pbtsourcelo));	destaddr = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, 						      pbt->pbtdestlo ));	if( displayflg ) HideCursor;	/* ********************* TEXTURE BLT ************************** */	if( pbt->pbtusegray )	   {	register int textureheight, destright, h;#define TEXTURE_WIDTH	16		if((pbt->pbtdestbpl & 7) || (pbt->pbtdestbpl <= 0) ||		   (pbt->pbtwidth * pbt->pbtheight > 32767)){			bitblt_bpl1(pbt, srcaddr, pbt->pbtsourcebit, pbt->pbtsourcebpl,				    destaddr, pbt->pbtdestbit, pbt->pbtdestbpl,				    pbt->pbtwidth, pbt->pbtheight,				    PixOperation( (unsigned short)pbt->pbtsourcetype,						  (unsigned short)pbt->pbtoperation ),				    pbt->pbtbackward);			return;		}		SrcPixRect->pr_width = TEXTURE_WIDTH;		SrcPixRect->pr_height = textureheight				      = tpbt->pbtgrayheightlessone + 1;		((mpr_d(SrcPixRect))->md_image) = srcaddr - tpbt->pbtgrayoffset;		mpr_mdlinebytes(SrcPixRect) = TEXTURE_WIDTH >> 3;			/* texture rasterwidth is always 2bytes */		DestPixRect->pr_width = destright				      = tpbt->pbtdestbit + tpbt->pbtwidth;		DestPixRect->pr_height = h = tpbt->pbtheight;		(mpr_d(DestPixRect))->md_image = destaddr;			mpr_mdlinebytes(DestPixRect) = abs((pbt->pbtdestbpl+7) >> 3);		/* copy bitmap from SRCPixRect to TexturePixRect */		TexturePixRect->pr_height = textureheight;		pr_rop( TexturePixRect, 0, 0, TEXTURE_WIDTH, 			textureheight - tpbt->pbtgrayoffset, PIX_SRC, 	 		SrcPixRect, 0, tpbt->pbtgrayoffset);		pr_rop( TexturePixRect, 0, textureheight - tpbt->pbtgrayoffset,			TEXTURE_WIDTH, tpbt->pbtgrayoffset,			PIX_SRC, SrcPixRect, 0, 0);		pix_op = PixOperation( (unsigned short)pbt->pbtsourcetype,				       (unsigned short)pbt->pbtoperation );		 pr_replrop( DestPixRect, dx, 0, w, h, pix_op,	 	  	   SrcPixRect, tpbt->pbtsourcebit,			   tpbt->pbtgrayoffset); /* Dec 28 */	     }	 #ifdef sparc        else if ((pbt->pbtdisjoint != 0)                && (pbt->pbtsourcebpl==w)                 && (pbt->pbtdestbpl==w) 		&& (pbt->pbtsourcetype==0)		&& (pbt->pbtoperation==REPLACE)                && (((w*(pbt->pbtheight))&7) == 0)                && ((dx&7)==0)                && ((sx&7)==0))  {        memcpy( ((char *)destaddr)+(dx>>3),                 ((char *)srcaddr )+(sx>>3),                (w>>3)*(pbt->pbtheight));        }#endif	else	/* ********************* NORMAL BLT ************************** */	     {	register int sourcebpl, destbpl, h;	     if((pbt->pbtdestbpl & 7) || (pbt->pbtsourcebpl & 7) ||	        (pbt->pbtdestbpl == 0) || (pbt->pbtsourcebpl == 0) ||	        (pbt->pbtwidth * pbt->pbtheight > 32767) || (pbt->pbtbackward)){		     bitblt_bpl1(pbt,srcaddr, pbt->pbtsourcebit, pbt->pbtsourcebpl,			    destaddr, pbt->pbtdestbit, pbt->pbtdestbpl,			    pbt->pbtwidth, pbt->pbtheight,			    PixOperation( (unsigned short)pbt->pbtsourcetype,					  (unsigned short)pbt->pbtoperation ),			    pbt->pbtbackward);		     return;	     }	     if( pbt->pbtbackward )		  {		    register int x;		    x = (pbt->pbtdestbpl/BITSPER_DLWORD) * (pbt->pbtheight-1);		    srcaddr += x;		    destaddr += x;		  }			h = pbt->pbtheight;		SrcPixRect->pr_width = sourcebpl = abs( pbt->pbtsourcebpl ); 		SrcPixRect->pr_height = h;		(mpr_d(SrcPixRect))->md_image = srcaddr;		mpr_mdlinebytes(SrcPixRect) = ( SrcPixRect->pr_width +7) >>3;	 		DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );		DestPixRect->pr_height = h;	        mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;		if((destbpl <= pbt->pbtdestbit) && 		   (pbt->pbtwidth * pbt->pbtheight < 32768))		  {	/* Special case */		    if( destbpl % 8 == 0 )		      {			(char *)(mpr_d(DestPixRect))->md_image = 				 (char *)destaddr + ( destbpl >> 3 );			 pbt->pbtdestbit = 0;		      }		    else		      {			(mpr_d(DestPixRect))->md_image = destaddr;		      }		  }		else		  {	/* Normal Case */		    (mpr_d(DestPixRect))->md_image = destaddr;		  }			if((sourcebpl <= pbt->pbtsourcebit) &&		   (pbt->pbtwidth * pbt->pbtheight < 32768)){ /* Special case */			if( sourcebpl % 8 == 0 ){				 (char *)(mpr_d(SrcPixRect))->md_image = 					 (char *)srcaddr + ( sourcebpl >> 3 );				 pbt->pbtsourcebit = 0;			}			else{				(mpr_d(SrcPixRect))->md_image = srcaddr;			}		}		else{	/* Normal Case */			(mpr_d(SrcPixRect))->md_image = srcaddr;		}		pix_op = PixOperation( (unsigned short)pbt->pbtsourcetype,					(unsigned short)pbt->pbtoperation );		    if( pbt->pbtdisjointitems && pbt->pbtbackward )		      {			register int distance;			distance = abs(srcaddr-destaddr)/((destbpl+15) >> 4);			SrcPixRect->pr_height += distance;			if(pr_rop( SrcPixRect, pbt->pbtdestbit, distance,				   pbt->pbtwidth, h, pix_op, 				   SrcPixRect, pbt->pbtsourcebit, 0) != 0)				/* error("pilotbitblt: pr_rop failed\n"); */				ERROR_EXIT(error_addr);		      }		    else		      {			if(pr_rop( DestPixRect, pbt->pbtdestbit, 0, 				   pbt->pbtwidth, h, pix_op, 				   SrcPixRect, pbt->pbtsourcebit, 0) != 0)				/* error("pilotbitblt: pr_rop failed\n"); */				ERROR_EXIT(error_addr);		      }			    }					/* normal BLT */	if( displayflg) ShowCursor;#ifdef WINDOW	   pw_rop( Lisp_pw, 0, 0, DisplayWidth, DisplayHeight, PIX_SRC,		   ScreenBitMap, 0, 0);#endif	return(pilot_bt_tbl);     } /* end of N_OP_pilotbitblt */int cursorin  ( addrhi, addrlo, x, w, h, y, backward)     DLword	addrhi;		/* Lisp addr hi-word	*/     DLword	addrlo;		/* Lisp addr lo-word	*/     register int	x, w, h, y;     {	if (addrhi == DISPALY_HI)  y = addrlo / DisplayRasterWidth;	else if (addrhi == DISPALY_HI+1)	   y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth;	else return( NIL );	if(backward) y -= h;			if((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))	   return( T );	else 	   return( NIL );     }#define WAddr(WORD, OFFSET, INCR) \	((WORD) + (((OFFSET)+(INCR))>>4))#define BAddr( OFFSET, INCR) \	((((OFFSET)+(INCR))%16) < 0 ? (16 + (((OFFSET)+(INCR))%16)) \				: (((OFFSET)+(INCR))%16))#define	GetPixValue( BASE, OFFSET, INCR ) \	!!((*WAddr(BASE, OFFSET, INCR))&(1<<(15-BAddr( OFFSET, INCR))))#define	PutPixValue( BASE, OFFSET, INCR, VAL ) \	{ if(VAL) \	     (*WAddr(BASE,OFFSET,INCR) |=(1<<(15-BAddr( OFFSET, INCR)))); \	   else \	     (*WAddr(BASE,OFFSET,INCR) &= ~(1<<(15-BAddr( OFFSET, INCR)))); \	}bitblt_bpl1(pbt, srcbase, sx, srcbpl, dstbase, dx, dstbpl, w, h, pixop,backwordflg) register PILOTBBT  *pbt;register DLword	*srcbase, *dstbase;int	sx, srcbpl, dx, dstbpl, w, h, pixop, backwordflg;{	register int	srcbit, dstbit, sbit, dbit, x, y, i, j, line, delta,			grayflg, graywidth, graheight, graybump, lastgray;	delta = backwordflg ? -1 : 1;	line = backwordflg ? (h - 1) : 0;	if(grayflg = pbt->pbtusegray){		graywidth = ((((TEXTUREBBT *)pbt)->pbtgraywidthlessone + 1 )*16);		graheight = ((TEXTUREBBT *)pbt)->pbtgrayheightlessone + 1;		graybump  = -(graywidth * (graheight-1));		lastgray = backwordflg ? ((TEXTUREBBT *)pbt)->pbtgrayoffset :					(graheight - 1 - ((TEXTUREBBT *)pbt)->pbtgrayoffset);	}	srcbit = dstbit = 0;	for( j=0; j < h; j++, line += delta){	    for( i= 0,x = backwordflg ? (w - 1) : 0; i < w; i++, x += delta){		if(grayflg)		    sbit=GetPixValue( srcbase, srcbit, (x+sx)%abs(graywidth) );		else		    sbit = GetPixValue( srcbase, srcbit, sx+x );		dbit = GetPixValue( dstbase, dstbit, dx+x );	        switch(pixop){		    case (PIX_SRC):			dbit = sbit;			break;		    case (PIX_SRC | PIX_DST):			dbit = sbit | dbit;			break;		    case (PIX_SRC & PIX_DST):			dbit = sbit & dbit;			break;	     	    case (PIX_SRC ^ PIX_DST):			dbit = sbit ^ dbit;			break;		    case (PIX_NOT(PIX_SRC)):			dbit = !sbit;			break;		    case (PIX_NOT(PIX_SRC) | PIX_DST):			dbit = (!sbit) | dbit;			break;		    case (PIX_NOT(PIX_SRC) & PIX_DST):			dbit = (!sbit) & dbit;			break;		    case (PIX_NOT(PIX_SRC) ^ PIX_DST):			dbit = (!sbit) ^ dbit;			break;		    default:			error("bitbltbpl1: missing op");			dbit = sbit;			break;		    }		    PutPixValue(dstbase, dstbit, (dx+x), (dbit));		}	    if(grayflg)		srcbase = WAddr(srcbase, srcbit, (((line%graheight)==lastgray) ? 							graybump : graywidth) );	    else		srcbase = WAddr(srcbase, srcbit, srcbpl);	    if(grayflg)		srcbit = BAddr(srcbit, (((line%graheight)==lastgray) ? 							graybump : graywidth) );    	    else		srcbit  = BAddr(srcbit, srcbpl);	    dstbase = WAddr(dstbase, dstbit, dstbpl);	    dstbit  = BAddr(dstbit, dstbpl);	}}