/* This is G-file @(#) unixcomm.c Version 2.18 (8/16/88). copyright Xerox & Fuji Xerox  */ static char *id = "@(#) unixcomm.c	2.18 8/16/88";/*Unix Interface Communications*/#include "lispemul.h"#include "address.h"#include "address68k.h"#include "lisptypes.h"#include "lispmap.h"#include "emulglobal.h"#include "lispglobal.h"#include "cell.h"#include "stack.h"#include "arith.h"/* JRB - timeout.h needs setjmp.h */#include <setjmp.h>#include "timeout.h"#include <stdio.h>#include <sgtty.h>#include <sys/file.h>#include <signal.h>#include <sys/wait.h>#include <errno.h>#define NPROCS 100#define	LispStringToCString(Lisp, C){	\	LispPTR	*naddress;				\	char	*base;					\	int	length;					\	int	offset;					\	naddress = (LispPTR *)(Addr68k_from_LADDR(Lisp));					\	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));	\	offset = (int)(((ONEDARRAAY *)naddress)->offset);	\	length = ((ONEDARRAAY *)naddress)->totalsize;						\	strncpy(C, base + offset, length);			\	C[length] = '\0';				\	}/* The following globals are used to communicate between Unix   subprocesses and LISP */int ForkedIns[NPROCS],		/* Pipes going from Unix to LISP */    ForkedOuts[NPROCS],		/* Pipes going from LISP to Unix */    ForkedPIDs[NPROCS],		/* Process IDs of forked processes */    ForkedStatus[NPROCS];	/* The value returned by a subprocess */				/* (not shell) */#define valid_slot(slot) (slot >= 0 && slot < NPROCS && ForkedPIDs[slot])char shcom[150];		/* Here because I'm suspicious of */				/* large allocations on the stack *//* fork_Unix is the secondary process spawned right after LISP is   started, to avoid having TWO 8 mbyte images sitting around. It listens   to the pipe LispToUnix waiting for requests, and responds on UnixToLisp.   The data passed through this pipe is in 4 byte packets, of the form:   Byte 0:   Command character, one of:                   S: Fork PTY (shell) process. This is used for CHAT windows.		   F: Fork piped shell		   W: Write byte to process stdin		   R: Read byte (nohang) from process stdout		   K: Kill process		   E: Exit (kill all subprocesses)		   C: Close stdin to subprocess   Byte 1:   Process number (0 to NPROCS - 1)             Not used for S, F, and E commands   Byte 2:   Value, used as follows:             Only used for W command, contains byte to write   Byte 3:   Status, always 1.In the case of a F command, additional data follows the 4 byte packet. This consists of one byte representing the length of the shell commandstring, and the string itself.   fork_Unix will return another 4 byte packet. The bytes are the same as those of the packet received except:   F:        Byte 2 is job number             Byte 3 is 1 if successful, 0 if not   S:        Byte 2 is job number             Byte 3 is 1 if successful, 0 if not   R:        Byte 2 is value of byte read from stdin, if any             Byte 3 is 1 if successful, 2 if EOF, 0 if nothing waiting   W:        Byte 3 is 1 if successful, 0 if not (pipe full or closed)   K:        Bytes 1 and 2 are the high and low bytes of the exit status             of the process. 	     Byte 3 is 1 if an exit status was available.   E:        Always the same   C:        Always the same*/int find_process_slot(pid) /* Find a slot with the specified pid (can be 0 to find a free slot) */     register int pid;{  register int slot;    for (slot = 0; slot < NPROCS; slot++)    if (ForkedPIDs[slot] == pid)      return slot;  return -1;}fork_Unix(){  int LispToUnix[2],		/* Incoming pipe from LISP */      UnixToLisp[2],		/* Outgoing pipe to LISP */      UnixToProcess[2],		/* Temporaries */      ProcessToUnix[2],      LispPipeIn, LispPipeOut, res, pid, slot;  char IOBuf[4], tmp[2];  /* Pipes between LISP subr and process */  if (pipe(LispToUnix) == -1) {    perror("pipe");    exit(-1);  }  if (pipe(UnixToLisp) == -1) {    perror("pipe");    exit(-1);  }  if ((UnixPID = fork()) == -1) {  /* Fork off small version of the emulator */    perror("fork");    exit(-1);  }  if (UnixPID != 0) {    UnixPipeIn = UnixToLisp[0];    UnixPipeOut = LispToUnix[1];    close(LispToUnix[0]);    close(UnixToLisp[1]);        return(1);  }  LispPipeIn = LispToUnix[0];  LispPipeOut = UnixToLisp[1];  close(LispToUnix[1]);  close(UnixToLisp[0]);      for (slot = 0; slot < NPROCS; slot++)     ForkedPIDs[slot] = 0;		/* I don't trust it, do you? */  while (1) {    if (read(LispPipeIn, IOBuf, 4) != 4) {	/* Get packet */      kill_comm_processes();      exit(0);    }        wait_for_comm_processes(0);    IOBuf[3] = 1;      switch(IOBuf[0]) {    case 'S':			/* Fork PTY shell */      if ((slot = find_process_slot(0)) >= 0) { /* Find a free slot */	res = ForkUnixShell(slot);	   /* Alloc a PTY and fork  */	if (res == -1)	  IOBuf[3] = 0;	else {	  /* ForkUnixShell sets the pid and standard in/out variables */	  ForkedStatus[slot] = -1;	  IOBuf[1] = slot;	}      } else IOBuf[3] = 0;      break;    case 'F':			/* Fork pipe command */      if ((slot = find_process_slot(0)) >= 0) {	/* Find a free process slot */	pipe(ProcessToUnix);	/* Create pipe between subprocess and here */	pipe(UnixToProcess);	ForkedIns[slot] = ProcessToUnix[0];	ForkedOuts[slot] = UnixToProcess[1];	ForkedStatus[slot] = -1;        /* These calls make sure we never block trying to do IO */	res = fcntl(UnixToProcess[1], F_GETFL);	res |= FNDELAY;	res = fcntl(UnixToProcess[1], F_SETFL, res);	res = fcntl(ProcessToUnix[0], F_GETFL);	res |= FNDELAY;	res = fcntl(ProcessToUnix[0], F_SETFL, res);	/* Read in the length of the shell command, and then the command */	read(LispPipeIn, tmp, 1);	read(LispPipeIn, shcom, *tmp);	ForkedPIDs[slot] = fork(); /* Fork */	if (ForkedPIDs[slot] == 0) {	  int i;	  int status;	  /* Copy the pipes onto stdin, stdout, and stderr */	  dup2(UnixToProcess[0],0);	  dup2(ProcessToUnix[1],1);	  dup2(ProcessToUnix[1],2);	  /* Make sure everything else is closed */	  for (i = 3; i < getdtablesize(); i++)	    close(i);	  /* Run the shell command and get the result */	  status = system(shcom);	  _exit((status & ~0xff) ? (status >> 8) : status);	}	/* Make sure we don't have an IO conflict */	close(UnixToProcess[0]);	close(ProcessToUnix[1]);	/* Check for error doing the fork */	if (ForkedPIDs[slot] == -1) {	  ForkedPIDs[slot] = 0;	  close(UnixToProcess[1]);	  close(ProcessToUnix[0]);	  perror("unixcomm: fork");	  IOBuf[3] = 0;	}	else {	  IOBuf[1] = slot;	  /* We do a setpgrp so that we can easily kill all the	     little babies */	  /* setpgrp(ForkedPIDs[slot], ForkedPIDs[slot]); */	}      } else IOBuf[3] = 0; /* Couldn't get a process slot */      break;    case 'W':			/* Write byte */      slot = IOBuf[1];      /* 1 means success, 0 means error */      IOBuf[3] = (valid_slot(slot) && (ForkedStatus[slot] == -1) &&	          (write(ForkedOuts[slot], &IOBuf[2], 1) != -1));      break;    case 'R':			/* Read byte */      slot = IOBuf[1];      /* Return EOF (0) for any error other than no characters to read */      IOBuf[3] = (valid_slot(slot) ?	          ((res = read(ForkedIns[slot], &IOBuf[2], 1)) == -1 ?		   (errno == EWOULDBLOCK ? 2 : 0) :		   (res != 0)) :		  0);      break;    case 'E':			/* Kill all subprocesses */      kill_comm_processes();      break;    case 'C':			/* Close stdin to subprocess */      slot = IOBuf[1];      /* If this is a valid job */      if (valid_slot(slot)) {	  /* First check to see it hasn't already died */	  if (ForkedStatus[slot] != -1) {	    close(ForkedIns[slot]);	    ForkedIns[slot] = -1;	  }      }      break;          case 'K':			/* Kill subprocess */      slot = IOBuf[1];      /* If this is a valid job */      if (valid_slot(slot)) {	/* First check to see it hasn't already died */        if (ForkedStatus[slot] == -1) {	  int i;	  /* Kill the job */	  pid = ForkedPIDs[slot];	  /* killpg(pid, SIGKILL); *//* In case it changed its process group */	  kill(pid, SIGKILL); 	  for (i = 0; i < 10; i++) {	    /* Waiting for the process to exit is possibly risky.	       Sending SIGKILL is always supposed to kill	       a process, but on very rare occurrences this doesn't	       happen because of a Unix kernel bug, usually a user-written	       device driver which hasn't been fully debugged.  So we	       time it out just be safe. */	    if (ForkedStatus[slot] != -1)	      break;	    wait_for_comm_processes(0);	    sleep(1);	  }	}	IOBuf[1] = (ForkedStatus[slot] >> 8) & 0xff;	IOBuf[2] = ForkedStatus[slot]  & 0xff;	close(ForkedOuts[slot]);	close(ForkedIns[slot]);	ForkedPIDs[slot] = 0;      }      else /* Not a valid process number */	IOBuf[3] = 0;      break;    } /* End of switch */    /* Return the status/data packet */     write(LispPipeOut, IOBuf, 4);  }}wait_for_comm_processes(hang)     int hang;{  int pid;  union wait status;  int slot;  status.w_status = 0;  while (((pid = wait3(&status, hang ? 0 : WNOHANG, 0)) != 0) && (pid != -1)) {    /* Ignore processes which are suspended but haven't exited       (this shouldn't happen) */    if (status.w_stopval == WSTOPPED)      continue;    slot = find_process_slot(pid);    /* Ignore processes that we didn't start (shouldn't happen but       occasionally does) */    if (slot >= 0) {      if (status.w_T.w_Termsig == 0) {#ifdef  DEBUG	printf("Process %d exited status %d\n", pid, status.w_T.w_Retcode);#endif	ForkedStatus[slot] = status.w_T.w_Retcode;      }      else {#ifdef  DEBUG	printf("Process %d terminated with signal %d\n", pid, 	       status.w_T.w_Termsig);#endif	ForkedStatus[slot] = status.w_T.w_Termsig << 8;      }    }  }}kill_comm_processes() /* Kill all the subprocesses we started */{  int slot;  for (slot = 0; slot < NPROCS; slot++)    /* If this slot has an active job */    if (ForkedPIDs[slot] != 0) {      /* Kill it and all its kids */      /* killpg(ForkedPIDs[slot], SIGKILL); */      kill(ForkedPIDs[slot], SIGKILL);      ForkedPIDs[slot] = 0;      /* Close the pipes */      close(ForkedIns[slot]);      close(ForkedOuts[slot]);    }  wait_for_comm_processes();}/* Valid PTY names are [pqr][0123456789abcdef], if your system is set updifferently, change this! */#define PTYLETTERS "pqr"#define PTYNUMBERS "0123456789abcdef"/* Find the first PTY pair that is not in use */FindAvailablePty(Master, Slave)char *Master, *Slave;{  int res;  char *let, *num;  /* From p to r */  for (let = PTYLETTERS; *let != 0; let++)    /* and 0 to f */    for (num = PTYNUMBERS; *num != 0; num++) {      sprintf(Master, "/dev/pty%c%c", *let, *num);      sprintf(Slave, "/dev/tty%c%c", *let, *num);      /* Try to open the Master side */      res = open(Master, O_RDWR);      if (res != -1) return(res);    }  return(-1);}  /* Creates a PTY connection to a csh */ForkUnixShell(slot)     int slot;{  char PtyMaster[20], PtySlave[20], buf[1];  int res, PID, MasterFD, SlaveFD;  struct sgttyb tio;  /* Get a PTY pair */  MasterFD = FindAvailablePty(PtyMaster, PtySlave);  /* None available? */  if (MasterFD == -1) return(-1);  PID = fork();  if (PID == 0) {    /* Divorce ourselves from /dev/tty */    res = open("/dev/tty", O_RDWR);    if (res >= 0) {      (void) ioctl(res, TIOCNOTTY, (char *)0);      (void) close(res);    }    /* Open the slave side */    SlaveFD = open(PtySlave, O_RDWR);    if (SlaveFD == -1) {      perror("Slave Open");      exit(0);    }        /* Set the terminal up to work with CHAT */    ioctl(SlaveFD, TIOCGETP, (char *)&tio);    tio.sg_flags |= CRMOD;    tio.sg_flags |= ECHO;    ioctl(SlaveFD, TIOCSETP, (char *)&tio);    (void) dup2(SlaveFD, 0);    (void) dup2(SlaveFD, 1);    (void) dup2(SlaveFD, 2);    (void) close(SlaveFD);    /* Start up csh */    execl("/bin/csh", "csh", 0);    /* Should never get here */    perror("execl");    exit(0);  }  /* Set the process group so all the kids get the bullet too   if (setpgrp(PID, PID) != 0)    perror("setpgrp"); */  /* Set up the IO not to block */  res = fcntl(MasterFD, F_GETFL);  res |= FNDELAY;  res = fcntl(MasterFD, F_SETFL, res);  ForkedIns[slot] = ForkedOuts[slot] = MasterFD;  ForkedPIDs[slot] = PID;  return(1);}/* LISP subr to talk to fork_Unix. First argument is a number:   0 for Fork Pipe, Arg1 is a string for system(), returns Job # or NIL   1 for Write Byte, Arg1 is Job, Arg2 is Byte, returns 1 (success), NIL (fail)   2 for Read Byte, Arg1 is Job, returns Byte, NIL (no data), T (EOF)   3 for Kill Job, Arg1 is Job, returns Status or T   4 for Fork PTY, returns Job # or NIL   5 for Kill All, returns T   6 for Close (EOF), Arg1 is Job #*/   Unix_handlecomm(args)LispPTR *args;{	int command,c, dest, PID, i;	LispPTR retval;	char d[3], b[1];	/* Get command */	N_GETNUMBER(args[0], command, bad);	switch(command) {	case 0:			/* Fork pipe process */	  d[0] = 'F';	  d[3] = 1;	  write(UnixPipeOut, d, 4);	  /* Convert string to C  */	  LispStringToCString(args[1],shcom);	  /* Write string length, then string */	  *b = strlen(shcom) +1;	  write(UnixPipeOut, b, 1);	  write(UnixPipeOut, shcom, strlen(shcom)+1);	  /* Get status */	  read(UnixPipeIn, d, 4);	  /* If it worked, return job # */	  if (d[3] == 1)	    return(GetSmallp(d[1]));	  else	    return(NIL);	  break;	case 1:			/* Write byte */	  d[0] = 'W';	  /* Get job #, Byte */	  N_GETNUMBER(args[1], dest, bad);d[1] = dest;	  N_GETNUMBER(args[2], dest, bad);d[2] = dest;	  d[3] = 1;	  write(UnixPipeOut, d, 4);	  /* Get status */	  read(UnixPipeIn, d, 4);	  /* If it worked, return 1 */	  if (d[3] == 1)	    return(GetSmallp(1));	  if (d[3] == 0)	    return(NIL);	  break;	case 2:			/* Read byte */	  d[0] = 'R';	  /* Get job # */	  N_GETNUMBER(args[1], dest, bad);d[1] = dest;	  d[3] = 1;	  write(UnixPipeOut, d, 4);	  /* Get status */	  read(UnixPipeIn, d, 4);	  /* Return byte, NIL, or T (EOF) */	  if (d[3] == 1)	    return(GetSmallp(d[2]));	  if (d[3] == 2)	    return(ATOM_T);	  if (d[3] == 0)	    return(NIL);	  break;	case 3:			/* Kill process */	  d[0] = 'K';	  /* Get job # */	  N_GETNUMBER(args[1], dest, bad);d[1] = dest;	  d[3] = 1;	  write(UnixPipeOut, d, 4);	  /* Get status */	  read(UnixPipeIn, d, 4);	  /* Read 2 byte return status */	  i = d[1] << 8;	  i += d[2];	  /* If status available, return it, otherwise T */	  if (d[3] == 1)	    return(GetSmallp(i));	  else	    return(ATOM_T);	  break;	case 4:			/* Fork PTY process */	  d[0] = 'S';	  d[3] = 1;	  write(UnixPipeOut, d, 4);	  /* Get status */	  read(UnixPipeIn, d, 4);	  /* If successful, return job # */	  if (d[3] == 1)	    return(GetSmallp(d[1]));	  else	    return(NIL);	  break;	case 5:			/* Kill all the subprocesses */	  d[0] = 'E';	  d[3] = 1;	  write(UnixPipeOut, d, 4);	  /* Get status */	  read(UnixPipeIn, d, 4);	  return(ATOM_T);	  break;	case 6:			/* Kill all the subprocesses */	  d[0] = 'C';	  d[3] = 1;	  /* Get job # */	  N_GETNUMBER(args[1], dest, bad);d[1] = dest;	  d[3] = 1;	  write(UnixPipeOut, d, 4);	  /* Get status */	  read(UnixPipeIn, d, 4);	  return(ATOM_T);	  break;	default: return(NIL);	}      bad:return(NIL);      }