/* This is G-file @(#) directory.c Version 2.17 (7/28/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) directory.c	2.17 7/28/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther	:	Hiroshi Hayata	 */#include <sys/types.h>#include <sys/stat.h>#include <sys/param.h>#include <sys/file.h>#include <sys/ioctl.h>#include <sys/dir.h>#include <strings.h>#include <stdio.h>#include <errno.h>#include <setjmp.h>#include	"lispemul.h"#include	"lispmap.h"#include	"timeout.h"#include	"localfile.h"#define	TRUE	1#define	FALSE	0#define	FAILED	-1#define SEPRCHAR	'\\'#define DIRCHAR	'/'#undef	ALLDIRSEARCH#define	MAXNAMELEN 128typedef struct	dir_spec{	struct	file_spec	*files;	struct	dir_spec	*dirs;	time_t	mtime;	u_short	namlen;			/* 3 */	char	name[MAXNAMELEN];	/* bar, only root has pathname /foo/fee */}DirSpec;typedef struct	file_spec{	struct	file_spec	*pnext;	int		ver_no;		/* 3 */	ino_t		ino;	short		nlink;	char	name[MAXNAMELEN];	/* bar */	char	version[VERSIONLEN];	/* 3, 3% */}FileSpec;DirSpec	RootDirSpec;char	*SetDirsToBuffer();char	*SetFilesToBuffer();alldirSize(dirName, dir, dirlen, filter)register char *dirName;	/* Pointer to directoryname. ex. "/usr/aig/hayata" */char *dir;register int dirlen;	/* Size of directory name after dirName, initially 0 */register char *filter;	/* Potinter to filter striing. ex. "*.*;*" or "a*.l*" */{register DIR *dp;register struct direct *directp;register int	totalsize;register int	rval;struct stat stat_buf;char	full_name[MAXPATHLEN];#ifdef	ALLDIRSEARCHchar	newdir[MAXPATHLEN];#endif	SETJMP(-1);	if(index(filter, '/') == 0){		TIMEOUT( rval=stat(dirName, &stat_buf) );		if(rval != 0){			err_mess("stat", errno);			return(-1);		}		return(stat_buf.st_size);	}		totalsize = 0;	TIMEOUT( dp=opendir(dirName) );	if (dp == (DIR *)NULL)		return(-1);	for(S_TOUT(directp=readdir(dp)); directp!=(struct direct *)NULL; S_TOUT(directp=readdir(dp)) ) {		/* Skip "." and ".." */		if((*(directp->d_name))=='.'){			if(directp->d_namlen == 1)				continue;			else if((directp->d_namlen == 2) && (*((directp->d_name)+1) == '.'))				continue;		}		sprintf(full_name, "%s/%s", dirName, directp->d_name);		TIMEOUT( rval=stat(full_name, &stat_buf) );		if(rval != 0){/** When symbolic linked file have not a linked-to file, stat cause error. So this err_mess and return should be skipped.			err_mess("stat", errno);			closedir(dp);			return(-1);**/		}		else			if((*(directp->d_name) != '.') && (stat_buf.st_mode & S_IFDIR)){#ifdef	ALLDIRSEARCH				strcpy(newdir, dir);				strcat(newdir, directp->d_name);				strcat(newdir, "/");				totalsize += alldirSize(full_name, newdir, strlen(newdir), filter);#else				sprintf(full_name, "%s%s", dir, directp->d_name);				if(DSK_matchp(full_name, filter)==TRUE)						totalsize += (dirlen + directp->d_namlen + 2);					/* 2 means DIRCHAR and SEPRCHAR */		#endif			}else{				sprintf(full_name, "%s%s", dir, directp->d_name);				if(DSK_matchp(full_name, filter)==TRUE)						totalsize += (dirlen + directp->d_namlen + 10);					 /* 10 means SEPRCHAR and version */			}	}	TIMEOUT( closedir(dp) );	return(totalsize);}DSK_readAllDir(dirName, dir, dirlen, filter, buffer)register char *dirName;char *dir;int dirlen;char *filter;register char *buffer;{register int	rval;register DIR *dp;register struct direct *directp;char	*startp;struct stat stat_buf;char	pathname[MAXPATHLEN];	SETJMP(-1);	STAT(dirName, &stat_buf);	if(ValidDirSpecP(dirName, stat_buf.st_mtime)==0){		/* Free RootDirSpec and re-set RootDirSpec */		FreeArea(&RootDirSpec);		strcpy(RootDirSpec.name, dirName);		RootDirSpec.namlen = strlen(dirName);		RootDirSpec.mtime = stat_buf.st_mtime;			RootDirSpec.files = 0;			RootDirSpec.dirs = 0;			TIMEOUT( dp=opendir(dirName) );		if (dp == (DIR *)NULL)			return(-1);		for(S_TOUT(directp=readdir(dp)); directp!=(struct direct *)NULL; S_TOUT(directp=readdir(dp)) ){			sprintf(pathname, "%s/%s", dirName, directp->d_name);			TIMEOUT(rval=stat(pathname, &stat_buf));			if(rval != 0){			/* When symbolic linked file have not a linked-to file, stat cause error. So if errno = 2, skip the file */				if(errno==2){					continue;				}else{					err_mess("stat", errno);					return(-1);				}			}			if(stat_buf.st_mode & S_IFDIR){				if(SetToDirs(&RootDirSpec, directp) == -1)					return(-1);			}else{				if(SetToFiles(&RootDirSpec, directp) == -1)					return(-1);			}		}		SETJMP(-1);		TIMEOUT( closedir(dp) );	}	/* Now, RootDirSpec is valid */	startp = buffer;	buffer = SetDirsToBuffer(&RootDirSpec, buffer, filter);	buffer = SetFilesToBuffer(&RootDirSpec, buffer, filter);	*buffer = '\0';	return( (int)buffer - (int)startp );}UFS_readAllDir(dirName, dir, dirlen, filter, buffer)register char *dirName;char *dir;int dirlen;char *filter;register char *buffer;{register DIR *dp;register struct direct *directp;char	*startp;register int	length;register int	rval;struct stat stat_buf;char	full_name[MAXPATHLEN];#ifdef	ALLDIRSEARCHchar	newdir[MAXPATHLEN];#endif	SETJMP(-1);	startp = buffer;	TIMEOUT( dp=opendir(dirName) );	if (dp == (DIR *)NULL)		return(-1);	for(S_TOUT(directp=readdir(dp)); directp!=(struct direct *)NULL; S_TOUT(directp=readdir(dp))){		/* Skip "." and ".." */		if((*(directp->d_name))=='.'){			if(directp->d_namlen == 1)				continue;			else if((directp->d_namlen == 2) && (*((directp->d_name)+1) == '.'))				continue;		}		sprintf(full_name, "%s/%s", dirName, directp->d_name);		TIMEOUT( rval=stat(full_name, &stat_buf) );		if(rval != 0){/** When symbolic linked file have not a linked-to file, stat cause error. So this err_mess and return should be skipped.			err_mess("stat", errno);			closedir(dp);			return(-1);**/		}		else			if((*(directp->d_name) != '.') && (stat_buf.st_mode & S_IFDIR)){#ifdef	ALLDIRSEARCH				strcpy(newdir, dir);				strcat(newdir, directp->d_name);				strcat(newdir, "/");				buffer += UFS_readAllDir(full_name, newdir, strlen(newdir), filter, buffer);#else				sprintf(full_name, "%s%s", dir, directp->d_name);				if(matchp(full_name, filter)==TRUE){						strncpy(buffer, full_name, dirlen+directp->d_namlen);					buffer += (dirlen + directp->d_namlen);					*(buffer++) = DIRCHAR;					*(buffer++) = SEPRCHAR;				}#endif			}else{				sprintf(full_name, "%s%s", dir, directp->d_name);				if(matchp(full_name, filter)==TRUE){						length = dirlen + directp->d_namlen;					strncpy(buffer, full_name, length);					buffer += length;					*(buffer++) = SEPRCHAR;				}			}	}	TIMEOUT( closedir(dp) );	return( (int)buffer - (int)startp );}/************************************************************************	SUBROUTINES	For pattern matching check************************************************************************/matchp(name, filter)char	*name;char	*filter;{char	name_name[100];char	name_extension[100];char	name_version[100];char	filter_name[100];char	filter_extension[100];char	filter_version[100];	match_parse(name, name_name, name_extension, name_version);	match_parse(filter, filter_name, filter_extension, filter_version);	if( match_part_p(name_name, filter_name) == 0)		return(0);	if( match_part_p(name_extension, filter_extension) == 0)		return(0);	if( match_part_p(name_version, filter_version) == 0)		return(0);	return(1);}DSK_matchp(name, filter)char	*name;char	*filter;{/** Case insesitive matchp **/char	name_name[100];char	name_extension[100];char	name_version[100];char	filter_name[100];char	filter_extension[100];char	filter_version[100];	match_parse(name, name_name, name_extension, name_version);	match_parse(filter, filter_name, filter_extension, filter_version);	if( DSK_match_part_p(name_name, filter_name) == 0)		return(0);	if( DSK_match_part_p(name_extension, filter_extension) == 0)		return(0);	if( DSK_match_part_p(name_version, filter_version) == 0)		return(0);	return(1);}match_parse(path, name, extension, version)register char	*path;		/* format is foo.fee;1 or foo.fee~1~ */register char	*name;char	*extension;char	*version;{register char	*cp,*cp1;register int	length;	if( (cp=rindex(path, ';')) != 0){	/* version -- ;# */		strcpy(version, cp+1);		length = (int)cp - (int)path;		strncpy(name, path, length);	/* name & ext is saved to name buf */		name[length] = '\0';		}else if( (cp=rindex(path, '~'))!=0 && (cp1=index(path, '~'))!=0 && cp1!=cp){	 			if(*(cp1-1) == '.'){				/* version -- .~#~ */				++cp1;				length = (int)cp - (int)cp1;				strncpy(version, cp1, length);				version[length] = '\0';				length = (int)cp1 - (int)path - 2;				strncpy(name, path, length);	/* name & ext is saved to name buf */				name[length] = '\0';				}else{			/* No version */			version[0] = '\0';			strcpy(name, path);			}	}else{		/* No version */		version[0] = '\0';		strcpy(name, path);	}	if( (cp=rindex(name, '.')) != 0){		strcpy(extension, cp+1);		*cp = '\0';	}else{		/* No extension */		extension[0] = '\0';	}}match_part_p(name, filter)register char	*name;register char	*filter;{register char	*np, *fp;		for(np=name, fp=filter; *fp!='\0';){		if(*fp=='*')			if(*(++fp)=='\0'){				return(1);			}else{				for(;*fp!=*np;++np)					if(*np=='\0')						return(0);				for(;*np==*(np+1);++np);				++fp; ++np; /* Both points next of matched char */			}		else{			if(*np!=*fp)				return(0);			if(*(++fp)=='\0')				if(*(++np)=='\0'){					return(1);				}else					return(0);			++np;		}	}	if(*np=='\0')		return(1);	return(0);}DSK_match_part_p(n, f)register char	*n;register char	*f;{/** Case insensitive match_part_p **/register char	*np, *fp;char	name[100];char	filter[100];	strcpy(name, n);	strcpy(filter, f);	DOWNCASE(name);	DOWNCASE(filter);	for(np=name, fp=filter; *fp!='\0';){		if(*fp=='*')			if(*(++fp)=='\0'){				return(1);			}else{				for(;*fp!=*np;++np)					if(*np=='\0')						return(0);				for(;*np==*(np+1);++np);				++fp; ++np; /* Both points next of matched char */			}		else{			if(*np!=*fp)				return(0);			if(*(++fp)=='\0')				if(*(++np)=='\0'){					return(1);				}else					return(0);			++np;		}	}	if(*np=='\0')		return(1);	return(0);}/**********************************************************************************	SUBROUTINES	For versionless, currently theses routines are used only for DSK.**********************************************************************************/	char *SetDirsToBuffer(dirs, buffer, filter)register DirSpec	*dirs;register char	*buffer;register char	*filter;{register DirSpec	*dp;	for(dp=dirs; dp->dirs!=0;){		dp=dp->dirs;		if( DSK_matchp(dp->name, filter) ){			strncpy(buffer, dp->name, dp->namlen);			buffer += dp->namlen;			*(buffer++) = DIRCHAR;			*(buffer++) = SEPRCHAR;		}	}	return(buffer);}char *SetFilesToBuffer(dir, buffer, filter)register DirSpec	*dir;register char	*buffer;register char	*filter;{register FileSpec	*fp;register int	high_ver;register int	i;char	name[MAXPATHLEN];char	version[VERSIONLEN];	if(dir->files==0)		return(buffer);	for(fp=dir->files; fp!=0;fp=fp->pnext){		strcpy(version, fp->version);		/* change version number */		if(fp->ver_no == 0 && STREQ(fp->version, "0") ){			/* fp is versionless file */			if(fp->nlink == 1){			/* versionless is highest+1 */				if((i=GetHighest(dir, fp->name)) == -1)					continue;				sprintf(version, "%d", i+1);			}else{			/* if versionless link some one in directory, skip */				if(LinkP(dir, fp->ino)){					continue;				}else{			/* versionless has no link with file in the directory */					strcpy(version, "1");				}			}		}					if( DSK_matchp2(fp, version, filter,dir) ){			sprintf(name, "%s;%s", fp->name, version);			AddDodNoExtention(name);			i = strlen(name);			strncpy(buffer, name, i);			buffer += i;			*(buffer++) = SEPRCHAR;		}	}	return(buffer);}SetToDirs(dir, directp)register DirSpec	*dir;		/* RootDirSpec */register struct direct *directp;{register DirSpec	*newdp;register DirSpec	*dp;register int	rval;struct stat stat_buf;char	name[MAXPATHLEN];	SETJMP(-1);	/* skip . and .. */	if(STREQ(directp->d_name, ".")){		return;	}	if(STREQ(directp->d_name, "..")){		return;	}	/* scan last one */	for(dp=dir;dp->dirs!=0;dp=dp->dirs);	/* get new one */	newdp = ((DirSpec *)malloc(sizeof(DirSpec)));	/* set to new one */	strcpy(newdp->name, directp->d_name);	newdp->namlen = strlen(directp->d_name);	sprintf(name, "%s/%s", dir->name, directp->d_name);	STAT(name, &stat_buf);	newdp->mtime = stat_buf.st_mtime;	newdp->files = 0;	newdp->dirs = 0;	/* link with last */	dp->dirs = newdp;}SetToFiles(dir, directp)register DirSpec	*dir;		/* RootDirSpec */register struct direct *directp;{register FileSpec	*fp;register FileSpec	*newp;register int	rval;struct stat stat_buf;char	name[MAXPATHLEN];char	version[VERSIONLEN];	SETJMP(-1);	/* get new one */	newp = ((FileSpec *)malloc(sizeof(FileSpec)));	/* set to new one */	strcpy(name, directp->d_name);	parseversion(name, version);	strcpy(newp->name, name);	strcpy(newp->version, version);	sprintf(name, "%s/%s", dir->name, directp->d_name);	STAT(name, &stat_buf);	newp->ino = stat_buf.st_ino;	newp->nlink = stat_buf.st_nlink;	newp->ver_no = atoi(version);	newp->pnext = 0;	/* scan  and link last one */	if(dir->files==0){		dir->files = newp;	}else{		for(fp=dir->files; fp->pnext!=0;fp=fp->pnext);		fp->pnext = newp;	}	return;}FreeArea(dir)DirSpec	*dir;		/* RootDirSpec */{register FileSpec	*fp;register FileSpec	*nextfp;register DirSpec	*dp;register DirSpec	*nextdp;	if(dir->files != 0){		for(fp=dir->files;fp!=0;fp=nextfp){			nextfp = fp->pnext;			free(fp);		}	}	if(dir->dirs != 0){		for(dp=dir->dirs;dp!=0;dp=nextdp){			nextdp = dp->dirs;			free(dp);		}	}}ValidDirSpecP(dirName, mtime)char	*dirName;time_t	mtime;{	if(mtime == RootDirSpec.mtime && STREQ(dirName, RootDirSpec.name))		return(1);	else		return(0);} GetHighest(dir, name)	/* return highest version no */register DirSpec	*dir;		/* RootDirSpec */char	*name;		/* foo.c */{register FileSpec	*fp;register FileSpec	*max_fp;register int	max = 0;	if(dir->files==0)		return(-1);	for(fp=dir->files; fp!=0; fp=fp->pnext){		if(STREQ(fp->name, name)){			/* Check version */			if((fp->ver_no > max) && CheckOnlyNumber(fp->version)){				max = fp->ver_no;			}		}	}	return(max);}			LinkP(dir, ino)register DirSpec	*dir;register ino_t	ino;{register FileSpec	*fp;register int	flag = 0;	if(dir->files==0)		return(0);	for(fp=dir->files; fp!=0; fp=fp->pnext){		if(fp->ino == ino){			if(flag)				return(1);			else				flag =1;		}	}	return(0);}				DSK_matchp2(fp, version, filter, dir)FileSpec	*fp;char	*version;char	*filter;DirSpec	*dir;{register char	*cp;int	i, nv;char	name_name[100];char	name_extension[100];char	name_version[100];char	filter_name[100];char	filter_extension[100];char	filter_version[100];	strcpy(name_name, fp->name);	if((cp=rindex(name_name, '.')) == 0){		/* no extension */		*name_extension = '\0';	}else{		*cp = '\0';		strcpy(name_extension, cp+1);	}	strcpy(name_version, version);	match_parse(filter, filter_name, filter_extension, filter_version);	if( DSK_match_part_p(name_name, filter_name) == 0)		return(0);	if( DSK_match_part_p(name_extension, filter_extension) == 0)		return(0);	/* Version of filter is NULL */	if(*filter_version == '\0'){		/* Nolink versionless file matches */		if(STREQ(fp->version, "0"))			return(1);		/* Highest version file matches */	 	if((i=GetHighest(dir, fp->name)) == -1){			return(0);	  	}else{			nv = atoi(name_version);			if(nv != i){				/* Not highest file */				return(0);			}			if(fp->nlink==1){				/* No link highest file */				return(0);			}			/* highest link file match */			return(1);		}	}	if( DSK_match_part_p(name_version, filter_version) == 0)		return(0);	return(1);}