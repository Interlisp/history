/* This is G-file @(#) osmessage.c Version 2.11 (8/2/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) osmessage.c	2.11 8/2/88";#include	<pwd.h>#include	<errno.h>#include	<sys/file.h>#include	<sys/types.h>#include	<sys/stat.h>#include	<sys/ioctl.h>#include	<sys/time.h>#include	<sys/vfs.h>#include	<strings.h>#include 	<setjmp.h>#include	<stdio.h>#include	<errno.h>#include	"lispemul.h"#include	"lispmap.h"#include	"address68k.h"#include	"lisptypes.h"#include	"arith.h"#include	"stream.h"#include	"lispglobal.h"#include	"timeout.h"#include	"osmessage.h"#define	MESSAGE_BUFFER_SIZE	1024int	cons_tty;int	cons_pty;char	logfile[100];int	log_id;	int	previous_size;mess_init(){int	id;struct passwd *pwd;int	ttyfd;int	ptyfd, ptynum;char	*ptyname, *ttyname;int	temp;	ptyname = "/dev/ptypx";	ttyname = "/dev/ttypx";/* Get pty and tty */	ptynum = 0;needpty:	while( ptynum<16 ){		ptyname[9] = "0123456789abcdef"[ptynum];		if( (ptyfd=open(ptyname, 2)) >= 0 )			goto gotpty;		ptynum++;	}	return(NIL);gotpty:	ttyname[9] = ptyname[9];	if( (ttyfd=open(ttyname, 2)) < 0){		ptynum++;		close(ptyfd);		goto needpty;	}/* Set tty parameter same as stderr */	/* line discipline */	ioctl(    2, TIOCGETD, &temp);	ioctl(ttyfd, TIOCSETD, &temp);	/* tty parameters */	ioctl(    2, TIOCGETP, &temp);	ioctl(ttyfd, TIOCSETP, &temp);	/* local modes */	ioctl(    2, TIOCLGET, &temp);	ioctl(ttyfd, TIOCLSET, &temp);	/* terminal characters */	ioctl(    2, TIOCGETC, &temp);	ioctl(ttyfd, TIOCSETC, &temp);	/* local special characters */	ioctl(    2, TIOCGLTC, &temp);	ioctl(ttyfd, TIOCSLTC, &temp);/* Get console IO */	ioctl(ptyfd, FIOCLEX);	if( (ioctl(ttyfd, TIOCCONS, 0)) == -1){		OSMESSAGE_PRINT( printf("TIOCCONS erros\n") );		exit(-1);	}	cons_pty = ptyfd;	cons_tty = ttyfd;/* Initialize log file */	pwd = getpwuid(getuid());	sprintf(logfile,"/tmp/%s-lisp.log", pwd->pw_name);	if( unlink(logfile) == -1){	/* delete old log file */		if(errno != ENOENT)			return(NIL);		}	if( (log_id = open(logfile, (O_RDWR | O_CREAT), 0666)) < 0 )		return(NIL);/*	close(id);*/	previous_size = 0;}mess_reset(){	int console_fd;	close(log_id);	close(cons_pty);	close(cons_tty);	/* Try to make /dev/console be the real console again */	if ((console_fd = open("/dev/console", 0)) >= 0) {	  ioctl(console_fd, TIOCCONS, 0);	  close(console_fd);	}}static struct timeval	selecttimeout = {0, 0};mess_readp(){int	id;struct stat sbuf;char	buf[MESSAGE_BUFFER_SIZE];	/* Buffer between pty and log file */int	size;static int  rfds;int	rval;struct statfs	fsbuf;/* polling pty nd flush os message to log file */	flush_pty();/* polling log file */	SETJMP(NIL);	TIMEOUT( rval=stat(logfile, &sbuf) );	if(rval != 0){		error("osmessage error: can not find a log file under /tmp");		return(NIL);	}	if( previous_size < (int)(sbuf.st_size) ){		return(ATOM_T);	}	return(NIL);}mess_read(args)LispPTR	*args;/* args[0]		buffer	*/{int	id;struct stat sbuf;int	size, save_size;char	*base;LispPTR	*naddress;int	i;	SETJMP(NIL);	naddress = (LispPTR *)(Addr68k_from_LADDR(args[0]));	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));	close(log_id);	TIMEOUT(log_id=open(logfile, O_RDONLY));	if(log_id == -1){		return(NIL);	}	TIMEOUT(i=fstat(log_id, &sbuf));	if(i != 0){		OSMESSAGE_PRINT( printf("stat err\n") );		return(NIL);	}	save_size = (int)(sbuf.st_size);	size = save_size - previous_size;	if(size > MESSAGE_BUFFER_SIZE)		size = MESSAGE_BUFFER_SIZE;	TIMEOUT(i=lseek(log_id, previous_size, L_SET));	if(i == -1){		OSMESSAGE_PRINT( printf("seek err\n") );		return(NIL);	}	TIMEOUT(size=read(log_id, base, size));	if(size == -1){		OSMESSAGE_PRINT( printf("read err\n") );		return(NIL);	}	TIMEOUT(i=lseek(log_id, save_size, L_SET));	if(i == -1){		OSMESSAGE_PRINT( printf("seek err\n") );		return(NIL);	}/*	TIMEOUT( close(id) );*/	previous_size += size;	for(i=0;i<size;++i){		if(base[i] == '\n')			base[i] = '\000';	}	return(GetSmallp(size));}flush_pty(){int	id;struct stat sbuf;char	buf[MESSAGE_BUFFER_SIZE];	/* Buffer between pty and log file */int	size;static int  rfds;int	rval;struct statfs	fsbuf;	SETJMP(NIL);/* polling pty nd flush os message to log file */	rfds = (1 << cons_pty);	if(select(32, &rfds, NULL, NULL, &selecttimeout) < 0 ){		return(NIL);	}	if( (cons_pty >= 0) && (rfds & (1 << cons_pty)) ){		close(log_id);		TIMEOUT( log_id=open(logfile, O_WRONLY | O_APPEND, 0666) );		if( log_id == -1)			return(NIL);		size = read(cons_pty, buf, MESSAGE_BUFFER_SIZE-1);		if(size == -1){			return(NIL);		}		/* Check free space to avoid print System Error Mesage  to /dev/console */		TIMEOUT( rval=statfs("/tmp", &fsbuf) );		if( rval != 0){			return(NIL);		}		if(fsbuf.f_bavail <= (long)0){			/* No Free Space */			error("osmessage error: No free space on file system (/tmp).");			return(NIL);		}		TIMEOUT( rval=write(log_id, buf, size) );		if( rval == -1){			if(errno == 28){				/* No free space, but its too late to avoid print system Error Message. */				error("osmessage error: No free space on file system (/tmp).");				return(NIL);			}else{				error("osmessage error: can not write to log file (/tmp)");				return(NIL);			}		}else{/**			close(id);**/			return(ATOM_T);		}	}}