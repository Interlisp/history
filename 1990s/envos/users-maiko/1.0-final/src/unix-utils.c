/* This is G-file @(#) unix-utils.c Version 1.6 (7/26/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) unix-utils.c	1.6 7/26/88";/* unix utilities subrs */#include <pwd.h>#include <signal.h>#include "lispemul.h"#include "address68k.h"#include "lisptypes.h"#include "lispglobal.h"#include "osmessage.h"#define NULL 0 /* defined in stdio.h which we don't use -- foo! *//* lisp_string_to_c_string converts lisp string up to maximum length,	returns 0 if succeeds, -1 if error (not a simple string or	too long or has xns characters) */int lisp_string_to_c_string(Lisp, C, length) 	LispPTR Lisp;	char	*C;	int	length;{	ONEDARRAAY	*arrayp;		char	*base, *dp;			short	*sbase;				int	i;		if (GetTypeNumber(Lisp) != TYPE_ONED_ARRAY) {return (-1);}			arrayp = (ONEDARRAAY *)(Addr68k_from_LADDR(Lisp));	if (arrayp->totalsize >= length) {return(-1);} /* too long */		switch(arrayp->typenumber){					case THIN_CHAR_TYPENUMBER:						base = ((char *)(Addr68k_from_LADDR(arrayp->base))) +		       ((int)(arrayp->offset));		strncpy(C, base, arrayp->totalsize);					C[arrayp->totalsize] = '\0';						return 0;								default:									return -1;			}								}/* c_string_to_lisp_string copies a C string into an existing Lisp string        (it does not create a new Lisp string).	returns 0 if succeeds, -1 if error (Lisp string is not a simple string,	or not long enough, or has xns characters)	The string will and with a null (which the length must include). */int c_string_to_lisp_string(C, Lisp)	LispPTR Lisp;	char	*C;{	ONEDARRAAY	*arrayp;		char	*base, *dp;			short	*sbase;				int	i;		int	length;	length = strlen(C);	if (GetTypeNumber(Lisp) != TYPE_ONED_ARRAY) {return (-1);}			arrayp = (ONEDARRAAY *)(Addr68k_from_LADDR(Lisp));	if (arrayp->totalsize < length+1) {return(-1);} 	    /* too short for C string */		switch(arrayp->typenumber){					case THIN_CHAR_TYPENUMBER:						base = ((char *)(Addr68k_from_LADDR(arrayp->base))) +		       ((int)(arrayp->offset));		strcpy(base, C);		return 0;								default:									return -1;			}								}check_unix_password(args)     LispPTR args[];{  struct passwd *pwd;  char *password, *getpass();  char salt[3];  char name[100], pass[100];  if (lisp_string_to_c_string(args[0], name, sizeof name)) {return NIL;}  if (lisp_string_to_c_string(args[1], pass, sizeof pass)) {return NIL;}  if ((pwd = getpwnam(name)) == 0) {    return(NIL);	/* can't find entry for name */  }  salt[0] = pwd->pw_passwd[0];  salt[1] = pwd->pw_passwd[1];  salt[2] = '\0';  if (strcmp(crypt(pass, salt), pwd->pw_passwd) == 0)    return(ATOM_T);  else    return(NIL);}unix_username(args)     LispPTR args[];{  struct passwd *pwd;  if ((pwd = getpwuid(getuid())) == NULL)    return NIL;  if (c_string_to_lisp_string(pwd->pw_name, args[0]))    return NIL;  return ATOM_T;}char* getenv();unix_getparm(args)	LispPTR         args[];{	char            envname[20], result[128], *envvalue;	if (lisp_string_to_c_string(args[0], envname, sizeof envname))		return NIL;	if (strcmp(envname, "MACH") == 0) {#ifdef sparc		envvalue = "sparc";#else		envvalue = "mc68020";#endif	} else if (strcmp(envname, "ARCH") == 0) {#ifdef sparc		envvalue = "sun4";#else		envvalue = "sun3";#endif	} else if (strcmp(envname, "HOSTNAME") == 0) {		if (gethostname(result, sizeof result))			return NIL;		envvalue = result;	} else if (strcmp(envname, "LOGNAME") == 0) {		struct passwd  *pwd;		if ((pwd = getpwuid(getuid())) == NULL)			return NIL;		envvalue = pwd->pw_name;	} else if (strcmp(envname, "FULLUSERNAME") == 0) {		struct passwd  *pwd;		if ((pwd = getpwuid(getuid())) == NULL)			return NIL;		envvalue = pwd->pw_gecos;	} else if (strcmp(envname, "HOSTID") == 0) {		sprintf(result, "%x", gethostid());		envvalue = result;	} else		return NIL;	if (c_string_to_lisp_string(envvalue, args[1]))		return NIL;	return ATOM_T;}unix_getenv(args)	LispPTR         args[];{	char            envname[20], *envvalue;	if (lisp_string_to_c_string(args[0], envname, sizeof envname))		return NIL;	envvalue = getenv(envname);	if (!envvalue)		return NIL;	if (c_string_to_lisp_string(envvalue, args[1]))		return NIL;	return ATOM_T;}unix_fullname(args)     LispPTR args[];{  struct passwd *pwd;  if ((pwd = getpwuid(getuid())) == NULL)    return NIL;  if (c_string_to_lisp_string(pwd->pw_gecos, args[0]))    return NIL;  return ATOM_T;}suspend_lisp(args)     LispPTR args[];{  if(device_before_raid() < 0) {    OSMESSAGE_PRINT( printf("Can't suspend\n") );    return NIL;  }  OSMESSAGE_PRINT( printf("suspending...\n") );  /* Send a terminal-stop signal to the whole process-group, not     just this process, so that if we are running as part of a     C-shell file the shell will be suspended too. */  killpg(getpgrp(0), SIGTSTP);  OSMESSAGE_PRINT( printf("resuming\n") );  device_after_raid();  return ATOM_T;}