/* This is G-file @(#) vars3.c Version 2.7 (7/29/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) vars3.c	2.7 7/29/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Author	:	Hiroshi Hayata	 */#include	<stdio.h>#include	"lispemul.h"#include	"lispglobal.h"#include	"lispmap.h"#include	"address68k.h"#include	"emulglobal.h"#include	"cell.h"#include	"lisptypes.h"#include	"stack.h"/* def. of car_cell moved to cell.h */extern int Irq_Stk_End;struct cadr_cell cadr();#ifdef C_ONLY/***********************************************************OP_arg0	Entry:	ARG0	opcode[0141]	<Entry>	TopOfStack : slot number of IVAR area	<Exit>	TopOfStack : the contents of the slot.	No effect to CurrentStack.************************************************************/OP_arg0(){int	num;DLword	*bf;	/* index of Basic frame */int	nargs;#ifdef	TRACE	printPC();	printf("TRACE: OP_arg0()\n");#endif 	if( (0xFFFF0000 & TopOfStack ) != S_POSITIVE){		/* error("OP_arg0: Bad TopOfStack\n"); */		ufn(0141);		return;	}else		num = 0xFFFF & TopOfStack;	if(CURRENTFX->alink & 0x1){		/* slow */#ifdef	DEBUG	printf("DEBUG:OP_arg0[access BasicFrame by slow]\n");#endif		bf = Stackspace + CURRENTFX->blink;	}else{		/* fast */#ifdef	DEBUG	printf("DEBUG:OP_arg0[access BasicFrame by fast]\n");#endif		bf = ((DLword *)CURRENTFX) - BFSIZE;	/* bf : pointer to 1st word of BasicFramePointer */	}	nargs = ((int)bf - (int)IVar)>>2;		/* nargs : number of IVAR slots */	if((num ==0) || (num > nargs)){#ifdef	DEBUG		printf("DEBUG:OP_arg0[argument number is %d, target argument is %d]\n", nargs, num);#endif		/* error("OP_arg0: Bad argument number\n"); */		ufn(0141);		return;	}	TopOfStack = *((int *)IVar + num - 1);		++PC;}/*******************************************OP_assoc	Entry:	ASSOC	opcode[026]	TopOfStack -- A-list (cons cell of Lisp address)	*(int *)(CurrentStackPTR) -- Key (cons cell of Lisp address) *******************************************/OP_assoc(){register LispPTR	key;	/* address of cons cell; Lisp address */struct cadr_cell cadr1;register LispPTR	cdr;	/* address of (cdr A-list); Lisp address */	if(TopOfStack == NIL_PTR){		/* if A-list is NIL, return NIL. */ 		CurrentStackPTR -= 2;		++PC;		return;	}		if(!Listp( TopOfStack )){		TopOfStack = NIL_PTR;		CurrentStackPTR -= 2;		++PC;		return;	}	/*CSP	key = *( (LispPTR *)(CurrentStackPTR-1) );	*/	key = *( (LispPTR *)(CurrentStackPTR) );	CheckAndCadr(TopOfStack, cadr1, 026);	do{		cdr = cadr1.cdr_cell;	/* the rest of A-list */		if(Listp(cadr1.car_cell) && key == car(cadr1.car_cell)){		/* cons data found */			TopOfStack = cadr1.car_cell;			CurrentStackPTR -= 2;			++PC;			return;		}		/* search the rest of A-list */		if(Listp(cdr))			cadr1 = cadr(cdr);		else cdr = NIL;	}while(cdr != NIL_PTR);	TopOfStack = NIL_PTR;	CurrentStackPTR -= 2;	++PC;	return;}#endif/*******************************************cadr	common routine.	used by OP_assoc, OP_fmemb*******************************************/struct cadr_cellcadr(cell_adr)LispPTR	cell_adr;	/* address of cell */			/* Lisp address (word addressing) */{ConsCell	*pcons;struct cadr_cell	cadr1;	/* return value */short	offset;	if( Listp(cell_adr) == NIL)		if(cell_adr == NIL){			cadr1.car_cell = 0;			cadr1.cdr_cell = 0;			return(cadr1);		} else {			cadr1.car_cell = car(cell_adr);			cadr1.cdr_cell = cdr(cell_adr);			return(cadr1);		}	pcons = (ConsCell *)Addr68k_from_LADDR(cell_adr);	while( pcons->cdr_code == CDR_INDIRECT ){		/* CDR indirect */		cell_adr = pcons->car_field;		pcons = (ConsCell *)Addr68k_from_LADDR(pcons->car_field);	}/* skip CDR_INDIRECT cell */		cadr1.car_cell = pcons->car_field;	if( pcons->cdr_code == CDR_NIL ){		/* CDR nil */		cadr1.cdr_cell = NIL_PTR;		return(cadr1);	}		offset = (0x7F & pcons->cdr_code) << 1;	if(pcons->cdr_code > CDR_NIL){		/* CDR on page */		cadr1.cdr_cell = (0xFFFF00 & cell_adr) | offset;	}else{		/* CDR different page */		pcons = (ConsCell *)Addr68k_from_LADDR( ((0xFFFF00 & cell_adr) | offset) );		cadr1.cdr_cell = pcons->car_field;	}	return(cadr1);}#ifndef C_ONLY/***********************************************************N_OP_arg0	Entry:	ARG0	opcode[0141]	<Entry>	TopOfStack : slot number of IVAR area	<Exit>	return : the contents of the slot.	No effect to CurrentStack.************************************************************/LispPTR N_OP_arg0(tos, error_addr)	register LispPTR tos;	int *error_addr;{register int	num;register DLword	*bf;	/* index of Basic frame */register int	nargs; 	if( (0xFFFF0000 & tos ) != S_POSITIVE){		/* error("OP_arg0: Bad TopOfStack\n"); */		ERROR_EXIT(error_addr);	}else		num = 0xFFFF & tos;	if(CURRENTFX->alink & 0x1){		/* slow */		bf = Stackspace + CURRENTFX->blink;	}else{		/* fast */		bf = ((DLword *)CURRENTFX) - BFSIZE;	/* bf : pointer to 1st word of BasicFramePointer */	}	nargs = ((int)bf - (int)IVar)>>2;		/* nargs : number of IVAR slots */	if((num ==0) || (num > nargs)){		/* error("OP_arg0: Bad argument number\n"); */		ERROR_EXIT(error_addr);	}	return(*((int *)IVar + num - 1));	}/*******************************************N_OP_assoc	Entry:	ASSOC	opcode[026]	TopOfStack -- A-list (cons cell of Lisp address)	*(int *)(CurrentStackPTR) -- Key (cons cell of Lisp address) *******************************************/LispPTR N_OP_assoc(key, list, error_addr)	register LispPTR key;	register LispPTR list;	int *error_addr;{register struct cadr_cell cadr1;register LispPTR	cdr;	/* address of (cdr A-list); Lisp address */	if (list == NIL_PTR) { return(NIL_PTR); }		if (!Listp( list )) { return(NIL_PTR); }		S_N_CHECKANDCADR(list, cadr1, error_addr, list);	do{		cdr = cadr1.cdr_cell;	/* the rest of A-list */		if(Listp(cadr1.car_cell) && key == car(cadr1.car_cell)){		/* cons data found */			return(cadr1.car_cell);		}		/* search the rest of A-list */		if(Listp(cdr))			cadr1 = cadr(cdr);		else cdr = NIL;		/* check for interrupts and punt to handle one safely */		if (!Irq_Stk_End) {			TopOfStack = cdr; /* for next execution */			TIMER_EXIT(error_addr);		}	}while(cdr != NIL_PTR);	return(NIL_PTR);}#endif