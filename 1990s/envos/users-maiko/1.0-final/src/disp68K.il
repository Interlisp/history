/* This is G-file @(#) disp68K.il Version 1.16 (5/16/88). copyright Xerox & Fuji Xerox  *//* disp68K.il *//* inline dispatching support *//* Bob Krivacic, Jan 6, 1988 *//*	***************************************************************	Fast inline dispatcher.	This routine is UNSAFE, since it assumes:		a5 = PC		d6 = 000000xx		a4 = @Table	****************************************************************/.inline	_fast_dispatcher,0	movb	a5@,d6	movl	a4@(0,d6:l:4),a0	.word	0x4ed0		|jmp	a0@	to clear up optimizer error	|.word	0x4ef4, 0x6d11	|jmp	[a4@(0,d6:l:4)] compiler will re-use d6	|jmp     a4@(0,d6:l:4)@ .end/*	***************************************************************	Special Native Code Jump Routine.	****************************************************************/.inline	_asmgoto,4	movl	a7@+,a0	.word	0x4ed0		|jmp	a0@	to clear up optimizer error	movl	a0@,d0.end.inline	_asmgoto2,4	movl	a7@+,a0	.word	0x4ed0		|jmp	a0@	to clear up optimizer error.end.inline	_asmcall,4	movl	a7@+,a0	jsr	a0@.end.inline _setivar_pvar_jmp,12	movl	a7@+,a5		|set native IVAR	movl	a7@+,a4		|set native PVAR	movl	a7@+,a0		|get jump address	.word	0x4ed0		|jmp	a0@	to clear up optimizer error	movl	a0@,d0		|*** KEEP OPTIMIZER FROM REMOVING ABOVE CODE ***	movl	a4@,d1	movl	a5@,d2.end.inline _setpc_jmp,8	movl	a7@+,a5		|set the PCMAC	movl	a7@+,a0		|get the address	.word	0x4ed0		|jmp	a0@	to clear up optimizer error	movl	a0@,d0		|*** KEEP OPTIMIZER FROM REMOVING ABOVE CODE ***	movl	a5@,d1.end/*	***************************************************************	Routines to Fixup the C stack after an error return	from an Opcode Execution Routine.	****************************************************************/.inline	_fixra,4	movl	a7@+,a6@(4).end.inline	_fixsp1,0	addql	#4,a7.end.inline	_fixsp2,0	lea	a7@(8),a7.end.inline	_fixsp3,0	lea	a7@(12),a7.end.inline	_fixspn,4	movl	a7@+,d0	lea	a7@(0,d0:l:4),a7.end	/*	***************************************************************	Arithmetic Opcode Helpers	****************************************************************/.inline	_sub32,8	movl	a7@+,d0	movl	a7@+,d1	subl	d1,d0	bvs	diff_err.end.inline	_isub32,8	movl	a7@+,d0	movl	a7@+,d1	subl	d1,d0	bvs	idiff_err.end.inline	_sub32n,8	movl	a7@+,d0	movl	a7@+,d1	subl	d1,d0	bvs	diff_err2.end.inline	_mpy32,8	movl	a7@+,d0	movl	a7@+,d1	mulsl	d1,d0	bvs	mpy_err.end.inline	_impy32,8	movl	a7@+,d0	movl	a7@+,d1	mulsl	d1,d0	bvs	impy_err.end.inline	_quot32,8	movl	a7@+,d0	movl	a7@+,d1	divsl	d1,d0	bvs	quot_err.end.inline	_iquot32,8	movl	a7@+,d0	movl	a7@+,d1	divsl	d1,d0	bvs	iquot_err.end.inline	_rem32,8	movl	a7@+,d2	movl	a7@+,d1	divsll	d1,d0:d2	bvs	rem_err.end.inline	_irem32,8	movl	a7@+,d2	movl	a7@+,d1	divsll	d1,d0:d2	bvs	irem_err.end.inline	_plus32,8	movl	a7@+,d0	movl	a7@+,d1	addl	d1,d0	bvs	plus_err.end.inline	_iplus32,8	movl	a7@+,d0	movl	a7@+,d1	addl	d1,d0	bvs	iplus_err.end.inline	_iplus32n,8	movl	a7@+,d0	movl	a7@+,d1	addl	d1,d0	bvs	iplusn_err.end/*	***************************************************************	Inline Assembly help for dispatcher.	****************************************************************//* Note: that the error exit of these routines may or may not need to	fix the tos pointer.  The C code should decide when tos must	be fixed through the ifdef flats.*//* SWAP halves of a register */.inline	_swapx,4	movl	a7@+,d0	swap	d0.end/*	***************************************************************	DIFFERENCE VERSIONS sp@ - sp@(4)  i.e. (tos-1)  -  (tos)	****************************************************************/.inline	_op_difference,8	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	roll	d2,d1	subqb	#7,d1	bne	diff_err	roll	d2,d0	subqb	#7,d0	bne	diff_err	subl	d1,d0	bvs	diff_err	lsrl	d2,d0	orl	#0x000E0000,d0.end.inline	_fast_op_difference,4	movl	a7@+,d1	roll	d5,d7	subqb	#7,d7	bne	diff_err	roll	d5,d1	subqb	#7,d1	bne	diff_err	subl	d7,d1	bvs	diff_err	lsrl	d5,d1	orl	#0x000E0000,d1	movl	d1,d7.end.inline	_fast_op_idifference,4	movl	a7@+,d1	roll	d5,d7	subqb	#7,d7	bne	idiff_err	roll	d5,d1	subqb	#7,d1	bne	idiff_err	subl	d7,d1	bvs	idiff_err	lsrl	d5,d1	orl	#0x000E0000,d1	movl	d1,d7.end.inline	_fast_op_idifferencen,4	movl	a7@+,d0	roll	d5,d0	roll	d5,d7	subqb	#7,d7	bne	idiffn_err	subl	d0,d7	bvs	idiffn_err	lsrl	d5,d7	orl	#0x000E0000,d7.end/*	***************************************************************	PLUS VERSIONS sp@ + sp@(4)  i.e. (tos-1)  +  (tos)	****************************************************************/.inline	_op_plus,8	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	roll	d2,d1	subqb	#7,d1	bne	plus_err	roll	d2,d0	subqb	#7,d0	bne	plus_err	addl	d1,d0	bvs	plus_err	lsrl	d2,d0	orl	#0x000E0000,d0.end.inline	_fast_op_plus,4	movl	a7@+,d0	roll	d5,d7	subqb	#7,d7	bne	plus_err	roll	d5,d0	subqb	#7,d0	bne	plus_err	addl	d7,d0	bvs	plus_err	lsrl	d5,d0	movl	d0,d7	orl	#0x000E0000,d7.end.inline	_fast_op_iplus,4	movl	a7@+,d0	roll	d5,d7	subqb	#7,d7	bne	iplus_err	roll	d5,d0	subqb	#7,d0	bne	iplus_err	addl	d7,d0	bvs	iplus_err	lsrl	d5,d0	movl	d0,d7	orl	#0x000E0000,d7.end.inline	_fast_op_iplusn,4	movl	a7@+,d0	roll	d5,d0	roll	d5,d7	subqb	#7,d7	bne	iplusn_err	addl	d0,d7	bvs	iplusn_err	lsrl	d5,d7	orl	#0x000E0000,d7.end/*	***************************************************************	LOGAND VERSIONS sp@ & sp@(4)  i.e. (tos-1)  &  (tos)	****************************************************************/.inline	_op_logand,8	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	moveq	#7,d3	roll	d2,d1	cmpb	d3,d1	bne	logand_err	roll	d2,d0	cmpb	d3,d0	bne	logand_err	andl	d1,d0	rorl	d2,d0.end.inline	_fast_op_logand,4	movl	a7@+,d0	roll	d5,d7	cmpb	#7,d7	bne	logand_err	roll	d5,d0	cmpb	#7,d0	bne	logand_err	andl	d0,d7	rorl	d5,d7.end/*	***************************************************************	LOGOR VERSIONS sp@ | sp@(4)  i.e. (tos-1)  |  (tos)	****************************************************************/.inline	_op_logor,8	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	moveq	#7,d3	roll	d2,d1	cmpb	d3,d1	bne	logor_err	roll	d2,d0	cmpb	d3,d0	bne	logor_err	orl	d1,d0	rorl	d2,d0.end.inline	_fast_op_logor,4	movl	a7@+,d0	roll	d5,d7	cmpb	#7,d7	bne	logor_err	roll	d5,d0	cmpb	#7,d0	bne	logor_err	orl	d0,d7	rorl	d5,d7.end/*	***************************************************************	LOGXOR VERSIONS sp@ | sp@(4)  i.e. (tos-1)  |  (tos)	****************************************************************/.inline	_op_logxor,8	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	moveq	#7,d3	roll	d2,d1	subb	d3,d1	bne	logxor_err	roll	d2,d0	cmpb	d3,d0	bne	logxor_err	eorl	d1,d0	rorl	d2,d0.end.inline	_fast_op_logxor,4	movl	a7@+,d0	roll	d5,d7	cmpb	#7,d7	bne	logxor_err	roll	d5,d0	subqb	#7,d0	bne	logxor_err	eorl	d0,d7	rorl	d5,d7.end/*	***************************************************************	SHIFT OPCODE VERSIONS	****************************************************************/.inline	_op_lrsh8,4	movl	a7@+,d0	moveq	#15,d2	movl	d0,d1	swap	d1	cmpw	#0xe,d1	bne	lrsh8_err	lsrw	#8,d0.end.inline	_fast_op_lrsh8,0	movl	d7,d1	swap	d1	cmpw	#0xe,d1	bne	lrsh8_err	lsrw	#8,d7.end/* inline LRSH1 *//* 	sp@ >> 1*/.inline	_op_lrsh1,4	movl	a7@+,d0	moveq	#15,d2	movl	d0,d1	swap	d1	cmpw	#0xe,d1	bne	lrsh1_err	lsrw	#1,d0.end.inline	_fast_op_lrsh1,0	movl	d7,d1	swap	d1	cmpw	#0xe,d1	bne	lrsh1_err	lsrw	#1,d7.end.inline	_op_llsh8,4	movl	a7@+,d0	cmpw	#0x0FF,d0	bhi	llsh8_err	movl	d0,d1	swap	d1	cmpw	#0xe,d1	bne	llsh8_err	lslw	#8,d0.end.inline	_fast_op_llsh8,0	cmpw	#0x0FF,d7	bhi	llsh8_err	movl	d7,d1	swap	d1	cmpw	#0xe,d1	bne	llsh8_err	lslw	#8,d7.end.inline	_op_llsh1,4	movl	a7@+,d0	cmpw	#0x07FFF,d0	bhi	llsh1_err	movl	d0,d1	swap	d1	cmpw	#0xe,d1	bne	llsh1_err	lslw	#1,d0.end.inline	_fast_op_llsh1,0	cmpw	#0x07FFF,d7	bhi	llsh1_err	movl	d7,d1	swap	d1	cmpw	#0xe,d1	bne	llsh1_err	lslw	#1,d7.end/*	***************************************************************	GREATERP OPCODE VERSIONS	****************************************************************/.inline	_op_greaterp,8	movl	a7@+,d3	movl	a7@+,d1	moveq	#15,d2	roll	d2,d1	subqb	#7,d1	bne	greaterp_err	roll	d2,d3	subqb	#7,d3	bne	greaterp_err	clrl	d0	cmpl	d1,d3	ble	100$	moveq	#76,d0100$:.end.inline	_fast_op_greaterp,4	movl	a7@+,d1	movl	d7,d3	roll	d5,d3	subqb	#7,d3	bne	greaterp_err	roll	d5,d1	subqb	#7,d1	bne	greaterp_err	clrl	d7	cmpl	d3,d1	ble	100$	moveq	#76,d7100$:.end.inline	_fast_op_igreaterp,4	movl	a7@+,d1	movl	d7,d3	roll	d5,d3	subqb	#7,d3	bne	igreaterp_err	roll	d5,d1	subqb	#7,d1	bne	igreaterp_err	clrl	d7	cmpl	d3,d1	ble	101$	moveq	#76,d7101$:.end/*	***************************************************************	POINTER OPCODE VERSIONS	****************************************************************/.inline _addbase,8	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	roll	d2,d1	subqb	#7,d1	bne	fixtos1	asrl	d2,d1	andl	#0xFFFFFF,d0	addl	d1,d0.end.inline _fast_op_addbase,4	movl	a7@+,d0	roll	d5,d7	subqb	#7,d7	bne	addbase_err	asrl	d5,d7	andl	#0xFFFFFF,d0	addl	d0,d7.end.inline _loloc,4	movl	a7@+,d0|	commented code is messed up by the optimizer (movw -> moveq)|	swap	d0|	movw	#0x000E,d0|	swap	d0	andl	#0x0000FFFF,d0	orl	#0x000E0000,d0.end.inline _fast_op_loloc,0	andl	#0x0000FFFF,d7	orl	#0x000E0000,d7.end.inline	_hiloc,4	movl	a7@+,d0|	commented code is messed up by the optimizer (movw -> moveq)|	movw	#0x000E,d0|	swap	d0|	andw	#0x00FF,d0	swap	d0	andl	#0x0000FFFF,d0	orl	#0x000E0000,d0.end.inline	_fast_op_hiloc,0	swap	d7	andl	#0x0000FFFF,d7	orl	#0x000E0000,d7.end/* this really doesn't need to check */.inline	_vag2,8	movl	a7@+,d0	movl	a7@+,d1	swap	d0	swap	d1	cmpb	#0x0E,d0	bne	fixtos1	cmpb	#0x0E,d1	bne	fixtos1	swap	d1	movw	d1,d0.end.inline	_fast_op_vag2,4	movl	a7@+,d0	swap	d7	movw	d0,d7	swap	d7.end	/*	***************************************************************	TYPE OPCODE VERSIONS	****************************************************************//* TYPE INLINE OPCODES */.inline	_listp,4	movl	a7@+,d0	movl	d0,d1	lsrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movw	a0@(0,d1:l:1),d1	andw	#0x7FF,d1	cmpw	#5,d1	jeq	110$	clrl	d0110$:.end.inline	_fast_op_listp,0	movl	d7,d1	lsrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movw	a0@(0,d1:l:1),d1	andw	#0x7FF,d1	cmpw	#5,d1	jeq	110$	clrl	d7110$:.end.inline	_ntypex,4	movl	a7@+,d1	lsrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movl	#0x000E0000,d0	movw	a0@(0,d1:l:1),d0	andw	#0x7FF,d0.end.inline	_fast_op_ntypex,0	lsrl	#8,d7	andl	#0xFFFE,d7	movl	_MDStypetbl,a0	movw	a0@(0,d7:l:1),d7	andw	#0x7FF,d0	orl	#0x000E0000,d7.end.inline _typep,8	movl	a7@+,d1	movl	a7@+,d2	movl	d1,d0	lsrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movw	a0@(0,d1:l:1),d1	andw	#0x7FF,d1	cmpl	d2,d1	beq	115$	moveq	#0,d0115$:.end.inline _fast_op_typep,0	movl	d7,d0	lsrl	#8,d0	andl	#0xFFFE,d0	movl	_MDStypetbl,a0	movw	a0@(0,d0:l:1),d0	andw	#0x7FF,d0	moveq	#0,d1	movb	a5@(1),d1	cmpw	d1,d0	beq	115$	moveq	#0,d7115$:.end/* TYPE INLINE FUNCTIONS */.inline _GetTypeNumber,4	movl	a7@+,d1	asrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	moveq	#00,d0	movw	a0@(0,d1:l:1),d0	andw	#0x7FF,d0.end.inline _GetTypeEntry,4	movl	a7@+,d1	asrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movw	a0@(0,d1:l:1),d0.end	.inline	_opreturn,0	movl	_CurrentFX,a1		|returnFX = a1	movl	#65536,d0	movw	a1@(2),d0		|returnFX->alink	lsrl	#1,d0			|low bit to carry	jcs	ni			|jump if slow return	movl	a2,a3			|CSTKPTR = IVAR	movl	_Lisp_world,a0		|PVar=	lea	a0@(0,d0:l:4),a0	movl	a0,_PVar	moveq	#20,d1	subl	d1,a0			|returnFX = a0	movl	a0,_CurrentFX		|CURRENTFX = returnFX	movl	#65536,d0	movw	a0@(-2),d0		|returnFX -1	movl	_Lisp_world,a1	lea	a1@(0,d0:l:2),a2	|IVAR = a2	moveq	#0,d0	movb	a0@(7),d0		|returnFX->hi2fnheader	swap	d0	movw	a0@(4),d0		|returnFX->lofnheader	movl	_Lisp_world,a1	lea	a1@(0,d0:l:2),a1	movl	a1,_FuncObj		|FuncObj = a1	subl	a5,a5	movw	a0@(10),a5		|returnFX->pc a5	lea	a1@(0,a5:l:1),a5	| a5 + FuncObj	movb	a5@,d6	movl	a4@(0,d6:l:4),a0	jmp	a0@.end.inline _fn3,0	moveq	#0,d0	movw	a5@(1),d0	movl	_Defspace,a0	lea	a0@(0,d0:l:4),a1		|defcell = a1	movl	a1,d4				|save defcell in d4|	movl	a1,a6@(-20)	btst	#7,a1@	jeq	ni	movl	a1@,d0				|defcell->defpointer	andl	#16777215,d0	movl	_Lisp_world,a0	lea	a0@(0,d0:l:2),a1		|LOCFNCELL	movl	a1,d2				|save LOCFNCELL in a1, d2|	movl	a1,a6@(-12)	moveq	#0,d0	movw	a1@,d0				|LOCFNCELL->stkmin	lea	a3@(4,d0:l:2),a0|	addql	#4,a0	cmpl	_StkLimO,a0	jcc	ni				|stack overflow	lea	a3@(-8),a1			|CSTKPTR-(x<<1)+2	subl	_Lisp_world,a1	movl	a1,d3	lsrl	#1,d3|	movl	d3,a1	andl	#65535,d3			|NEXTBLOCK = d3|	movl	d0,d3	movl	_CurrentFX,a1			|a1 = _CurrentFX	movw	d3,a1@(8)			|CURRENTFX->nextblock =	movl	d3,d0	orl	#65536,d0	movl	_Lisp_world,a0	lea	a0@(0,d0:l:2),a2		|IVAR =|	movl	_CurrentFX,a0	movl	a5,d0	subl	_FuncObj,d0	addql	#3,d0	movw	d0,a1@(10)			|CURRENTFX->pc	movl	d7,a3@+				|CPushCStack	movl	d2,a1				|get LOCFNCELL = a1	movw	a1@(2),d0	tstw	d0	jlt	fn3noargs			|no function arguments|	movw	a0@(2),d0	extl	d0	moveq	#2,d1	subl	d0,d1|	movl	d1,d4	jra	fn3ly16fn3ly17:	clrl	a3@+	addql	#1,d1fn3ly16:	tstl	d1	jlt	fn3ly17|	movl	d4,d0	asll	#2,d1	subl	d1,a3fn3noargs:	movl	d3,d0				|CPush(BF_MARK32 | NEXTBLOCK)	orl	#-2147483648,d0	movl	d0,a3@+	movl	a3,_CurrentFX			|CURRENTFX =	movl	_PVar,d0|	subl	_Lisp_world,d0	subl	a0,d0	lsrl	#1,d0	andl	#65535,d0	orl	#-1073741824,d0	movl	d0,a3@				|*CSTKPTR=FX_MARK etc	movl	d4,a0				|defcell = a0	movw	a0@(2),a3@(4)			|->lofnheader = ->defpointer|	movl	a6@(-20),a0|	movl	a0@,d0|	andl	#16777215,d0|	movw	d0,a3@(4)|	movl	d4,a0|	movl	a6@(-20),a0	movb	a0@(1),a3@(7)			|hi2fnheader = *((defcell)+1)	lea	a3@(20),a3	movl	a3,_PVar			|PVar = CSTKPTR|	movl	d2,a0	movw	a1@(4),d0			||LOCFNCELL->pv	extl	d0	addql	#1,d0|	movl	d0,a6@(-8)	moveq	#-1,d1	jra	fn3ly18fn3ly19:	movl	d1,a3@+	movl	d1,a3@+	subql	#1,d0fn3ly18:	tstl	d0	jgt	fn3ly19	addqw	#4,a3				| CSTKPTR += 2|	movl	d2,a0|	moveq	#0,d0	subl	a5,a5	movw	a1@(6),a5			|LOCFNCELL->startpc	addl	a1,a5|	movl	d0,a5	movl	a1,_FuncObj.end/*	***************************************************************	CODE TO HELP FREE VARIABLE LOOKUP	****************************************************************/.inline	_newframe_stk_hi_ret,4|	STK_HI is 1|	result returned in d0	movl	a7@+,d0	swap	d0	moveq	#1,d1	orl	d1,d0		|or in the STK_HI to lower word.end.inline	_newframe_vals_hi_ret,4|	VALS_HI is 12|	result returned in d0	movl	a7@+,d0	moveq	#17,d1		|need to get shift amount	roll	d1,d0		|shift the 1st bit of name to lsb	orw	#12,d0		|or in the VALS_HI to lower word.end/*	***************************************************************	NATIVE CODE INLINE ASSEMBLY CODE	***************************************************************		Assume:		d5 = 15		Shift Amount*//*	****************************************************************//*	Boxing & Unboxing					       *//*	****************************************************************/.inline _nop_nsmallp_range,4	movl	a7@,d0	movl	d0,d1		|save value	lsll	d5,d0		|x = value << 15	asrl	d5,d0		|x = x >> 15	eorl	d1,d0		|x = x EOR value.end.inline _nop_smallp_unbox,4	movl	a7@,d0	lsll	d5,d0		|x = value << 15	asrl	d5,d0		|x = x >> 15.end	.inline _nop_smallp_box,4	movl	a7@,d0	lsll	d5,d0		|x = value << 15	lsrl	d5,d0		|x = x >> 15	orl	#0x000e0000,d0.end	/*	****************************************************************//*	UNBIND & DUNBIND					       *//*	****************************************************************/.inline _nop_unbind,4|| Assumes: 	a3 = CURRSTKP|		a4 = PVAR|	movl	a7@+,a1		|save TOS value10$:	tstl	a3@-		|look for bind mark	bpls	10$	movl	a3@,d0		|get the bind mark	movl	d0,d1		|get num of pvars to unbind	movl	#0xffff,d2	andl	d2,d0		|get pvar index	lea	a4@(4,d0:l:2),a0	swap	d1		|compute num of pvars to unbind	notw	d1	andl	d2,d1		|clear top of num	beqs	30$		|jump if none to clear	subql	#1,d1		|adjust counter for loop	moveq	#-1,d0		|set loop store value20$:	movl	d0,a0@-		|Store the unbind mark in pvars	dbra	d1,20$		|loop till pvars cleared30$:	movl	a1,a3@+		|push the old TOS.end.inline _nop_dunbind,0|| Assumes: 	a3 = CURRSTKP|		a4 = PVAR|10$:	tstl	a3@-		|look for bind mark	bpls	10$	movl	a3@,d0		|get the bind mark	movl	d0,d1		|get num of pvars to unbind	movl	#0xffff,d2	andl	d2,d0		|get pvar index	lea	a4@(4,d0:l:2),a0	swap	d1		|compute num of pvars to unbind	notw	d1	andl	d2,d1		|clear top of num	beqs	30$		|jump if none to clear	subql	#1,d1		|adjust counter for loop	moveq	#-1,d0		|set loop store value20$:	movl	d0,a0@-		|Store the unbind mark	dbra	d1,20$		|loop till pvars cleared30$:	.end/*	***************************************************************	FN RETURN	***************************************************************NOW OBSOLETE !!!!*/.inline _nop_return,8	movl 	a7@+,d2		|return pc	movl	a7@+,d3		|current swapped fn obj	moveq	#0,d0			movw	a3@(-18),d0		|get Alink	btst	#0,d0		jne	200$		lea	a4@(4),a5		|Set CSTKPTR to IVAR	movl	_Stackspace,a0		|Compute new PVAR	lea	a0@(0, d0:l:2),a3	movw	a3@(-22),d0	|compute new IVAR	lea	a0@(0,d0:l:2),a4	movl	a4,_MachineState	movl	a3,_MachineState+4	movw	a3@(-10),d0		|get the return PC	btst	#3,a3@(-20)		|native ?	jeq	201$	| NATIVE FN RETURN	movl	d0,_PC	movl 	a3@(-16),d1		|get fn obj	cmpl	d3,d1	jeq	switchlabel	andw	#0xff,d1	swap	d1	movl	_Lisp_world,a0	lea	a0@(0,d1:l:2),a0	movl	a0,_FuncObj	movl	a5,_CurrentStackPTR	movw	a0@(6),d0	movl	a0@(-4,d0:l),a0	jmp	a0@	| NORMAL FN RETURN201$:	movl 	a3@(-16),d1		|get fn obj	andw	#0xff,d1	swap	d1	movl	_Lisp_world,a0	lea	a0@(0,d1:l:2),a1	movl	a1,_FuncObj	addl	a1,d0			|add return pc	movl	d0,_PC	movl	a5,_CurrentStackPTR	moveq	#0,d0			|compute new stack end	movw	a1@,d0	moveq	#32,d7	addl	d7,d0	lsll	#1,d0	movl	_EndSTKP,d1	subl	d0,d1	 	movl	d1,_Irq_Stk_Check	cmpl	_Irq_Stk_Check,a5	jgt	202$	tstl	_Irq_Stk_End	jle	202$	movl	_EndSTKP,_Irq_Stk_End	jmp	_ret_to_dispatch202$:	jmp	_ret_to_timer200$:	movl	a4@,a5@+	movl	d2,_PC	movl	a5,_CurrentStackPTR	jmp	_ret_to_unimpl.end