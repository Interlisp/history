/* This is G-file @(#) createcell.c Version 2.4 (8/11/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) createcell.c	2.4 8/11/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Author :  Takeshi Shimizu * *//***********************************************************************//* 		File Name :	createcell.c		Desc	:	  				Date :		Jun. 4, 1987 				Edited by :	Takeshi Shimizu				Changed :	9 Jun 1987 take						26 Oct. 1987 take(add mask) 		Including :	OP_createcell								*//**********************************************************************/#include "lispemul.h"#include "lispmap.h"#include "emulglobal.h"#include "lispglobal.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "cell.h" #include "gc.h"  LispPTR *alloc_mdspage();LispPTR initmdspage();#ifdef C_ONLYOP_createcell(){  register struct dtd *dtd68k;  register DLword *ptr,*lastptr;  register LispPTR newcell ;  register unsigned int type ;#ifdef TRACE	printf("TRACE : OP_createcell");#endif  if((TopOfStack & 0xff0000) != S_POSITIVE)	error("OP_createcell : Type is not specified as SMALLP");  type = TopOfStack & 0xffff ;#ifdef DEBUG  if(type==TYPE_LISTP)	error("OP_createcell : Can't create Listp cell with CREATECELL");	check_dtd_chain(type);#endif    dtd68k = (struct dtd *)GetDTD(type);  if(dtd68k->dtd_size == 0)	error("OP_createcell : Attempt to create a cell not declared yet");retry :  if((TopOfStack=newcell=((dtd68k->dtd_free)&0xffffff)) != NIL)  {#ifdef DEBUG	if(type != GetTypeNumber(newcell)) 	  error("OP_createcell : BAD cell in dtdfree");#endif	ptr = (DLword *)Addr68k_from_LADDR(newcell);	/* replace dtd_free with newcell's top DLword (it may keep next chain)*/	dtd68k->dtd_free = (*((LispPTR *)ptr)) & 0xffffff;#ifdef DEBUG	if((dtd68k->dtd_free !=0) && (type != GetTypeNumber(dtd68k->dtd_free))) 	  error("OP_createcell : BAD cell in next dtdfree");		check_dtd_chain(type);#endif	dtd68k->dtd_oldcnt++;	/* clear 0  */	for(lastptr=ptr + dtd68k->dtd_size ;		ptr != lastptr ; ptr++)	  {  *ptr = 0 ; }	 IncAllocCnt(1);	 GCLOOKUP(0x8000,DELREF , TopOfStack);	PC++;	  }  else  {	dtd68k->dtd_free = initmdspage(alloc_mdspage(dtd68k->dtd_typeentry) , 				dtd68k->dtd_size ,NIL);	goto retry ;  }#ifdef DEBUG/*********FOR DEBUG AID **********************************//**********************************************************/	check_dtd_chain(type);#endif} /* OP_createcell end */#elseLispPTR N_OP_createcell(tos, error_addr)	register LispPTR tos;	int *error_addr;{  register struct dtd *dtd68k;  register DLword *ptr,*lastptr;  register LispPTR newcell ;  register unsigned int type ;#ifdef TRACE	printf("TRACE : N_OP_createcell");#endif  if((tos & 0xff0000) != S_POSITIVE) ERROR_EXIT(error_addr);  type = tos & 0xffff ;#ifdef DEBUG  if(type==TYPE_LISTP)	error("N_OP_createcell : Can't create Listp cell with CREATECELL");	check_dtd_chain(type);#endif    dtd68k = (struct dtd *)GetDTD(type);  if(dtd68k->dtd_size == 0) ERROR_EXIT(error_addr);  /* error("OP_createcell : Attempt to create a cell not declared yet"); */retry :  if((tos=newcell=((dtd68k->dtd_free)&0xffffff)) != NIL)  {	ptr = (DLword *)Addr68k_from_LADDR(newcell);	/* replace dtd_free with newcell's top DLword (it may keep next chain)*/	dtd68k->dtd_free = (*((LispPTR *)ptr)) & 0xffffff;	dtd68k->dtd_oldcnt++;	/* clear 0  */	for(lastptr=ptr + dtd68k->dtd_size ;		ptr != lastptr ; ptr++)	  {  *ptr = 0 ; }	 IncAllocCnt(1);	 GCLOOKUP(0x8000,DELREF , tos);	 return(tos);  }  else  {	dtd68k->dtd_free = initmdspage(alloc_mdspage(dtd68k->dtd_typeentry) , 				dtd68k->dtd_size ,NIL);	goto retry ;  }} /* N_OP_createcell end */#endifDLword *createcell68k(type) unsigned int type;{  register struct dtd *dtd68k;  register DLword *ptr,*lastptr;  register ConsCell *newcell68k;  register LispPTR newcell ;#ifdef DEBUG  if(type==TYPE_LISTP)	error("createcell : Can't create Listp cell with CREATECELL");  if(type==TYPE_STREAM) stab();	check_dtd_chain(type);#endif    dtd68k = (struct dtd *)GetDTD(type);  if(dtd68k->dtd_size == 0)	error("createcell : Attempt to create a cell not declared yet");retry :  if((newcell=(dtd68k->dtd_free & 0xffffff)) != NIL)  {#ifdef DEBUG	if(type != GetTypeNumber(newcell)) 	  error("createcell : BAD cell in dtdfree");	if(newcell > 0xFFFFFF)		error("createcell : BAD Lisp address");#endif	ptr = Addr68k_from_LADDR(newcell) ;	/* replace dtd_free with newcell's top DLword (it may keep next chain)*/	dtd68k->dtd_free = (*((LispPTR *)ptr)) & 0xFFFFFF ;#ifdef DEBUG	if((dtd68k->dtd_free!=0)&&(type != GetTypeNumber(dtd68k->dtd_free)) )	  error("createcell : BAD cell in next dtdfree");	check_dtd_chain(type);#endif	dtd68k->dtd_oldcnt++;	/* clear 0  */	for(lastptr=ptr + dtd68k->dtd_size ;		ptr != lastptr ; ptr++)	  {  *ptr = 0 ; }	IncAllocCnt(1);	GCLOOKUP(0x8000,DELREF , newcell);#ifdef DEBUG/*********FOR DEBUG AID **********************************//**********************************************************/	check_dtd_chain(type);#endif	return(Addr68k_from_LADDR(newcell));	  }  else  {	dtd68k->dtd_free = initmdspage(alloc_mdspage(dtd68k->dtd_typeentry) , 				dtd68k->dtd_size ,NIL);#ifdef DEBUG/*********FOR DEBUG AID **********************************//**********************************************************/	check_dtd_chain(type);#endif	goto retry ;  }} /* createcell68k end *//**********************************************************//*  Create a Cell of Specified Type & Set to given Value  *//*  Works with 32 bit typed values only.                  *//*  (Initially used only by native code)                  *//**********************************************************/LispPTR Create_n_Set_Cell(type, value) unsigned int type; LispPTR value;{  register struct dtd *dtd68k;  register DLword *ptr,*lastptr;  register ConsCell *newcell68k;  register LispPTR newcell ;    dtd68k = (struct dtd *)GetDTD(type);  if(dtd68k->dtd_size == 0)	error("createcell : Attempt to create a cell not declared yet");retry :  if((newcell=(dtd68k->dtd_free & 0xffffff)) != NIL)  {	ptr = Addr68k_from_LADDR(newcell) ;	/* replace dtd_free with newcell's top DLword (it may keep next chain)*/	dtd68k->dtd_free = (*((LispPTR *)ptr)) & 0xFFFFFF ;	dtd68k->dtd_oldcnt++;	/* clear 0  */	for(lastptr=ptr + dtd68k->dtd_size ;		ptr != lastptr ; ptr++)	  {  *ptr = 0 ; }	IncAllocCnt(1);	GCLOOKUP(0x8000,DELREF , newcell);	(* ((LispPTR *) Addr68k_from_LADDR(newcell))) = value;	return(newcell);	  }  else  {	dtd68k->dtd_free = initmdspage(alloc_mdspage(dtd68k->dtd_typeentry) , 				dtd68k->dtd_size ,NIL);	goto retry ;  }} /* createcell68k end */