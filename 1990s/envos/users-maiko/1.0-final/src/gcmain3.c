/* This is G-file @(#) gcmain3.c Version 1.3 (5/9/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) gcmain3.c	1.3 5/9/88";/*** ADOPTED NEW VERSION ***//*************************************************************************//*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 *//*************************************************************************//*                                                                       *//*                       File Name : gcmain3.c                           *//*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : July-7-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions : gcmapscan();                                    *//*                       gcmapunscan();                                  *//*                       gcscanstack();                                  *//*                                                                       *//*                                                                       *//*************************************************************************//*           Descreption :                                               *//*                                                                       *//*************************************************************************//*                                                               \Tomtom *//*************************************************************************/#include "lispemul.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "emulglobal.h"#include "stack.h"#include "cell.h"#include "ifpage.h"#include "gc.h"#define HTMAIN_SIZE	0x8000   /* this will be deleted in including map */#define STK_HI		1	/* This is also. */#define WORDSPERCELL	2#define CONSPAGE_LAST	0x0ffff#define MAXHTCNT	63#define PADDING	4#define FNOVERHEADWORDS	8#define GetLinkptr(entry)	(entry & 0x0fffe)#define GetSegnuminColl(entry1) 	((entry1 & 0x01fe) >> 1)#define GetCountinColl(entry1) 	((entry1 & 0x0fc00) >> 10)#define GetStkCnt(entry1)	((entry1 & 0x0fe00) >> 9)#define GetStkrefinColl(entry1)	((entry1 & 0x0200) >> 9)#define Boundp(frame_field)	((frame_field == 0)?1:0)#define Stkref(ptr)		GCLOOKUP(0x8000, STKREF, ptr)#define GcreclaimLp(ptr) 	while((ptr = gcreclaimcell(ptr)) != NIL)  \				  GCLOOKUP(0x8000, ADDREF, ptr)gcmapscan(){ struct hashentry	*entry;  LispPTR		ptr, entrylp, linklp, prevlp;  DLword		probe = HTMAIN_SIZE;  struct  htcoll	*link;  struct  htlinkptr	*htlptr; nextentry:  while((probe = gcscan1(probe)) != NIL)	{entry = (struct hashentry *)Addr68k_from_LADDR((entrylp =				LADDR_from_68k(HTmain) + probe));	 htlptr = (struct htlinkptr *)entry;	retry:			 if (entry->collision)           { prevlp = NIL; 	/* unbound mark */             link = (struct htcoll *)Addr68k_from_LADDR((linklp =			LADDR_from_68k(HTcoll) + GetLinkptr(htlptr->contents)));	     while(link->next_free != 0)		{if (GetStkCnt(link->free_ptr) == 0)	            {ptr =VAG2(GetSegnuminColl(link->free_ptr),(probe << 1));                     dellink(linklp, prevlp, entrylp);		     GcreclaimLp(ptr);		     if (htlptr->contents == 0)		            goto nextentry;		     else goto retry;	            };		 prevlp = linklp;		 link = (struct htcoll *)Addr68k_from_LADDR((linklp =				LADDR_from_68k(HTcoll) + link->next_free));		};	     if (GetStkCnt(link->free_ptr) == 0)		{ ptr =VAG2(GetSegnuminColl(link->free_ptr),(probe << 1));		  dellink(linklp, prevlp, entrylp);		  GcreclaimLp(ptr);		  if (htlptr->contents == 0)		    goto nextentry;		  else goto retry;		};	     prevlp = linklp;	     goto nextentry;	    };  	/* if (entry->collision) */	 if (GetStkCnt(htlptr->contents) == 0)		{ ptr = VAG2(entry->segnum,(probe << 1));	       	  htlptr->contents = 0;	       	  GcreclaimLp(ptr);	        };	}; /* while((probe = gcscan1(probe)) != NIL) */	return(NIL);   }gcmapunscan(){ DLword		probe = HTMAIN_SIZE;  struct hashentry	*entry;  struct htcoll		*link;  struct htlinkptr	*htlptr;  LispPTR		entrylp, linklp, prevlp;   while((probe = gcscan2(probe)) != NIL)	{ entry = (struct hashentry *)Addr68k_from_LADDR((entrylp = 				LADDR_from_68k(HTmain) + probe));	  htlptr = (struct htlinkptr *)entry;	retry:	  if (entry->collision)	     { link = (struct htcoll *)Addr68k_from_LADDR((linklp = 			LADDR_from_68k(HTcoll) + GetLinkptr(htlptr->contents)));	       	       prevlp = NIL;	    scanlp:	       if (GetStkrefinColl(link->free_ptr) == 1)		{if (GetCountinColl(link->free_ptr) == 1)	            {dellink(linklp, prevlp, entrylp);		     goto retry;		    }		 else link->free_ptr = (link->free_ptr & 0x0fdff);		};	       if (link->next_free != 0)		{ 	          prevlp = linklp;		  link = (struct htcoll *)Addr68k_from_LADDR((linklp = 				LADDR_from_68k(HTcoll) + link->next_free));		  goto scanlp;		};	      }	  else if (entry->stackref)		{if (entry->count == 1)			htlptr->contents = 0;		 else entry->stackref = 0;		};	}; 	/* while((probe = gcscan2(probe) != NIL) */	return(NIL);}gcscanstack()	{ LispPTR		scanptr,scanend;	  LispPTR		scanbase,next,ntend,qtemp;	  Bframe		*bascframe;	  Bframe		*pvars;	  struct frameex1	*frameex;	  struct fnhead		*fnheader;	  struct fnhead		*nametable;	  int			ftyp;	  int			pcou;	  int			pvcount;	  scanptr = VAG2(STK_HI,InterfacePage->stackbase);	  scanend = VAG2(STK_HI,InterfacePage->endofstack);	  bascframe = (Bframe *)Addr68k_from_LADDR(scanptr);	  while(1)/*This is endless loop until encountering tail of stack */		{		ftyp = (int)bascframe->flags;		switch(ftyp)			{ case STK_FX:				{ scanptr = LADDR_from_68k(				     frameex = (struct frameex1 *)bascframe);				  fnheader = (struct fnhead *)					Addr68k_from_LADDR(					VAG2(frameex->hi2fnheader,					     frameex->lofnheader));				  Stkref(LADDR_from_68k(fnheader));				  pvars =(Bframe *)					  Addr68k_from_LADDR(scanptr+FRAMESIZE);				  for(pcou = fnheader->nlocals;pcou-- != 0;)					{					 if Boundp(pvars->flags+pvars->nil+						pvars->residual+						pvars->padding) 					    Stkref(VAG2(pvars->usecnt,							pvars->ivar));					 ++pvars;					};				  next = qtemp = frameex->nextblock;					 /* this is offset */				  ntend = 0;	/* init flag */				  if (frameex->validnametable)					{ if (STK_HI == frameex->hi2nametable)					     { Stkref(fnheader->framename);					       qtemp = 						frameex->lonametable;						nametable =(struct fnhead *)						 Addr68k_from_LADDR(						VAG2(frameex->hi2nametable,						     frameex->lonametable));					       ntend = qtemp+FNHEADSIZE						+(nametable->ntsize)*2;					     }					   else					     Stkref(VAG2(frameex->hi2nametable,						 frameex->lonametable));					};				  scanptr +=  FRAMESIZE+PADDING+						(((fnheader->pv)+1)<<2);			scantemps:				  scanbase = LOLOC(scanptr);				  while(scanbase < qtemp)					{ pvars = (Bframe *)						    Addr68k_from_LADDR(scanptr);					  if Boundp(pvars->flags+pvars->nil+						pvars->residual+						pvars->padding) 					     Stkref(VAG2(pvars->usecnt,							pvars->ivar));					  scanptr += WORDSPERCELL;					  scanbase = LOLOC(scanptr);					};				  if (ntend != 0)					{ scanptr = VAG2(STK_HI,ntend);					  qtemp = next;					  ntend = 0;					  goto scantemps;					};				   bascframe = (Bframe *)						Addr68k_from_LADDR(scanptr);				   break;				};		  	  case STK_GUARD:/* stack's tail ? */				{if ((scanptr = LADDR_from_68k(bascframe))								 >= scanend)					 return(NIL);		  		  else { scanptr += bascframe->ivar;					 bascframe = (Bframe *)					   Addr68k_from_LADDR(scanptr);					};				  break;				};		  	  case STK_FSB:				{ scanptr = LADDR_from_68k(bascframe);				  scanptr += bascframe->ivar;				  bascframe = (Bframe *)Addr68k_from_LADDR(						scanptr);				  break;				};		  	  default:	/* must be basic frame !! */				{ while(STK_BF != bascframe->flags)					{ Stkref(VAG2(bascframe->usecnt						    ,bascframe->ivar));					  ++bascframe;					};				  ++bascframe;				}; /* default */			};	/* switch */		};	/* while(1) */}