/* This is G-file @(#) newmakeatom.c Version 1.3 (5/8/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) newmakeatom.c	1.3 5/8/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *//**********************************************************************//* 		File Name :	makeatom.c		Desc. :		Create atom  				Date :		January 29, 1987 				Edited by :	Takeshi Shimizu				Change : create_symbol					  take,30-Jun					  1 May 1987 take					  28 Aug. 1987 take		222 lines 		Including :	make_atom				compute_hash				create_symbol				compare_chars				parse_number*//**********************************************************************/#include "lispemul.h"#include "address68k.h"#include "lisptypes.h"#include "lispmap.h"#include "cell.h"#define ATOMoffset	2   /* NIL NOBIND  */#define MAX_ATOMINDEX	0xffff  /* man  number of atom */#define Atom_reprobe( hash , char )	(((char ^ hash)| 1) & 63 )extern DLword *Lisp_world ;/**********************************************************************//*		Func name :	make_atom				If the atom already existed then return				else create new atom .					Date :		January 29, 1987					Edited by :	Takeshi Shimizu					Changed : take 20-Jan					Changed : March 27 '87  take					Changed : May 1 '87 take					Changed : May 9 '87 take					Changed : May 13 '87 take						May 15 '87 take*//**********************************************************************/LispPTR make_atom(char_base,offset, length , non_numericp) /* return atomindex */char *char_base;DLword offset;DLword length;short non_numericp; /* if it is NIL then this charas. are treated as NUMBER */  /* This Prog. doesn't treat FAT code */{  extern DLword *OneCharAtomBase ; /* may  be AtomSpace +2 */  extern DLword *Spospspace ;  extern DLword *AtomSpace ;  extern DLword *AtomHT ;  extern DLword *Pnamespace  ;  LispPTR parse_number();    DLword hash;  LispPTR hash_entry ;  /* hash entry contents */  DLword atom_index ;  DLword reprobe ;  PNCell *pnptr ;  char *pname_base ;  unsigned short first_char ;#ifdef TRACE2	printf("TRACE: make_atom( %s , len= %d, non_numericp = %d)\n",char_base, length , non_numericp);#endif  first_char = (*(char_base + offset) & 0xff) ;  if (length!=0)   {	if(length==1) /* one char. atoms */	{		if (first_char > 57 ) /* greater than '9 */		  return((LispPTR)(ATOMoffset + (first_char -10)) );		else if (first_char > 47) /* between '0 to '9 */			 return((LispPTR)(S_POSITIVE + (first_char - 48)) );				/* fixed S_... mar-27-87 take */			else	/* other one char. atoms */			  return ((LispPTR)(ATOMoffset +first_char));	}  /* if(length==1.. end */	else if ((non_numericp ==NIL) &&(first_char <= '9'))  	/* more than 10 arithmetic  aon + - mixed atom process */		{			if((hash_entry = parse_number(char_base+offset,length))!=0)				return((LispPTR)hash_entry);						/* if NIL that means THE ATOM is +- mixed litatom */			/* 15 may 87 take */		}	hash = compute_hash(char_base, offset,length) ;   } /* if(lengt.. end */  else  {	hash = 0;	first_char = 255 ;	  } /* This point correspond with LP in Lisp source *//* following for loop never exit untill it finds new hash enty or same atom */ for(  reprobe=Atom_reprobe(hash ,first_char) ; 	(hash_entry= *(AtomHT+hash)) != 0 ; hash = ((hash + reprobe) & 0xffff)  )  {	atom_index = hash_entry -1 ;	 /* get pname pointer */	pnptr = (PNCell *)GetPnameCell( atom_index);	pname_base= (char *)Addr68k_from_LADDR(pnptr->pnamebase) ;	if((length == *pname_base ) && (compare_chars(++pname_base,char_base+offset,length) ==T))	 {#ifdef DEBUG		printf("The ATOM has already existed. \n");#endif		  return ( atom_index ); /* find already existed atom */	  }#ifdef DEBUG	printf("HASH doesn't HIT. reprobe!\n");#endif  } /* for end *//* we can't find such that atom , then we should make new atom */	return(0xffffffff);/** Don't create newatom now **/} /* make_atom end *//**********************************************************************//*		Func name :	compute_hash				Compute hash value from cahrs.					Date :		January 29, 1987					Chan.		Aug. 27 87 take					Edited by :	Takeshi Shimizu*//**********************************************************************/compute_hash(char_base,offset , length ) char *char_base; DLword offset; DLword length ;{  DLword hash ;  DLword number ;  DLword temp1,temp2 ;#ifdef TRACE2	printf("TRACE: compute_hash()\n");#endif  char_base +=offset;  hash = (int)(*char_base ) << 8 ; /* get first byte */  char_base++ ; /* skip length area */  for (number= 1 ; number <= length -1 ;char_base++,number++)	{		hash = (hash + ((hash & 4095)<< 2 )) & 0x0ffff ;		temp1 = (hash + ((hash & 255) << 8) & 0x0ffff ) ;		hash = (int)(temp1 + *char_base) & 0x0ffff ;	}  return (hash);} /* end compute_hash *//**********************************************************************//*		Func name :	compare_chars				Compare two strings					Date :		January 29, 1987					Edited by :	Takeshi Shimizu*//**********************************************************************/compare_chars( char1 , char2 , length )char  *char1;char  *char2;DLword length ;{ short i;#ifdef TRACE2	printf("TRACE: compare_chars()\n");#endif  for(i = 0 ; i < length ; i++,*char1++,*char2++)  {	if(*char1 != *char2) return(NIL);  } return (T);} /* end compare_chars *//**#ifndef KATANA**/#ifdef OBSOLATE/**********************************************************************//*		Func name :	create_symbol				Actualy create atom symbol					Date :		January 29, 1987					Edited by :	Takeshi Shimizu					Changed :		take(January 30, 1987)*//**********************************************************************/create_symbol(char_base , length )  char *char_base ;  DLword length ;{ extern DLword AtomFrLst ; /* Num of Atoms ever registed */ DLword *alloc_pname_chars(); DLword nword; /* number of word this ATOM needs */ DLword atom_index ; /* this ATOM's index */ char *pname_base ; /* points area keeps raw ASCII code */ LispPTR *pname_slot ; /* keep address that was translated from LADDR */ short i;#ifdef TRACE2	printf("TRACE: create_symbols()\n");#endif /* check limit */ if((atom_index = AtomFrLst) >= MAX_ATOMINDEX)   error ("ATOM exceeded ");/*******************************************************//*  COMMENT OUT January 30, 1987 *//* if((length+1)%4 == 0 )*/ /* Cell(4 byte) align ? *//*	ncell = (length+1) >>2; else	ncell = ((length+1) >>2)+1 ;*//*******************************************************/ if((length+1)%2 == 0) /*WORD allign */	nword = (length+1) >>1 ; else	nword = ((length+1) >>1)+1 ; /* get area */ pname_base= (char *)alloc_pname_chars(nword); /* Get selected PNPSPACE 68addr */ pname_slot = (LispPTR *)Pnamespace + atom_index ; /* replace selected PNPSPACE contents */ *pname_slot =(LispPTR) LADDR_from_68k(pname_base); /* write out length */ *pname_base++ = length ; /* copy char. code */ for(i=0; i<length ; i++,char_base++,pname_base++)  {	*pname_base = *char_base ;  } AtomFrLst++ ; /* add num of atoms */ return(atom_index);} /* create_symbol end */#endif/*********************************************************************//*		Func name :	parse_number		Desc	:	It can treat -65534 to 65535 interger				Returns SMALLP PTR		Date : 		1,May 1987 Take				15 May 87 take*//*********************************************************************/LispPTR parse_number(char_base,length)char *char_base;short length ;{  register LispPTR sign_mask ;  register LispPTR val ;  register int radix ;  register int *cell68k;  LispPTR *createcell68k();#ifdef TRACE2	printf("TRACE: parse_number()\n");#endif/* Check for Radix 8(Q) postfixed ?? */ if( (*(char_base +(length -1))) == 'Q')  {  radix= 8;  length--;  } else   radix = 10 ;/* Check for Sign */ sign_mask =S_POSITIVE ;  if((*char_base == '+') || (*char_base == '-'))  {	sign_mask = (*char_base++ =='+') ? S_POSITIVE : S_NEGATIVE ;	length--;  }  for(val=0;length>0;length--)  {	if ( ((*char_base) < '0' ) || ( '9' < (*char_base)) )		return(NIL);	val = radix * val + (*char_base++) - '0' ;  }  if(val > 0xffffffff)  error("parse_number : Overflow ...exceeded range of FIXP");   if((sign_mask ==S_POSITIVE)&&(val >0xffff))  {	cell68k = (int *)createcell68k(TYPE_FIXP);	*cell68k = val ;	return(LADDR_from_68k(cell68k));  }  else if((sign_mask == S_NEGATIVE) && (val >0xffff))  {	cell68k =(int *) createcell68k(TYPE_FIXP); 	*cell68k = ~val +1 ;	return(LADDR_from_68k(cell68k));  }  else if(sign_mask == S_NEGATIVE)	return(sign_mask | (~((DLword)val) + 1));  else {	return(sign_mask | val);	 }} /* end parse_number */