/* This is G-file @(#) dspsubrs.c Version 2.3 (7/21/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) dspsubrs.c	2.3 7/21/88";/*** ADOPTED NEW VERSION ***//* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther	:	Osamu Nakamura	 */#include <stdio.h>#include <sunwindow/window_hs.h>#include <pixrect/memvar.h>#include "lispemul.h"#include "lispmap.h"#include "display.h"#include "arith.h"extern int DebugDSP;extern int DisplayWidth, DisplayHeight;extern struct pixrect *ScreenBitMap;/**************************************************** * *	DSP_dspbout() entry of SUBRCALL 9 1 *			called from (DSPBOUT X) * ****************************************************/DSP_dspbout( args )LispPTR	*args;		/* args[0] :	charcode	*/{	putc( (args[0] & 0xFFFF) & 0x7f, BCPLDISPLAY );}/**************************************************** * *	DSP_showdisplay() entry of SUBRCALL 19 2 *			called from (SHOWDISPLAY BASE RASTERWIDTH) * ****************************************************/extern int DisplayInitialized ;DSP_showdisplay( args )LispPTR	*args;{	DisplayInitialized = 1;}/**************************************************** * *	DSP_VideoColor() entry of SUBRCALL 66 1 *			called from (VIDEOCLOR BLACKFLG) * ****************************************************/DSP_VideoColor( args )LispPTR	*args;		/* args[0] :	black flag	*/{	return NIL;/* this doesn't work; I don't know what it was supposed to do (LMM)if( args[0] & 0xFFFF )		(mpr_d(ScreenBitMap))->md_flags |= MP_REVERSEVIDEO;	else		(mpr_d(ScreenBitMap))->md_flags &= ~MP_REVERSEVIDEO;		pr_rop(ScreenBitMap, 0, 0, DisplayWidth, DisplayHeight, PIX_SRC,	       ScreenBitMap, 0, 0);*/}extern struct cursor CurrentCursor;	extern int LispWindowFd;extern int errno;/**************************************************** * *	DSP_Cursor() entry of SUBRCALL 64 2 *			called from \HARDCURSORUP etc. * ****************************************************/DSP_Cursor( args , argnum)LispPTR *args;	int argnum;			/* args[0] :	hot sopt X			 * args[1] :	hot spot Y			 */{ 	if (argnum == 2) {	CurrentCursor.cur_xhot=args[0] & 0xffff;	CurrentCursor.cur_yhot=args[1] & 0xffff;	};	win_setcursor( LispWindowFd, &CurrentCursor );}/**************************************************** * *	DSP_SetMousePos() entry of SUBRCALL 65 2 *			called from macro \SETMOUSEXY etc. * ****************************************************/DSP_SetMousePos( args )LispPTR *args;		/* args[0] :	X pos			 * args[1] :	Y pos			 */{	win_setmouseposition(LispWindowFd, GetSmalldata(args[0]),			                   GetSmalldata(args[1]));}/**************************************************** * *	DSP_ScreenWidth() entry of SUBRCALL 67 0 *			called from  \Katana.DisplayWidth. * ****************************************************/DSP_ScreenWidth( args )LispPTR *args;{	return( S_POSITIVE | (0xFFFF & DisplayWidth) );}/**************************************************** * *	DSP_ScreenHight() entry of SUBRCALL 68 0 *			called from  \Katana.DisplayHeight. * ****************************************************/DSP_ScreenHight( args )LispPTR *args;{	return( S_POSITIVE | (0xFFFF & DisplayHeight) );}/**************************************************** * *	flip_cursor()  * ****************************************************/extern struct pixrect *CursorBitMap;flip_cursor(){	pr_rop( CursorBitMap, 0, 0, CURSORWIDTH, CURSORHEIGHT, 		PIX_NOT(PIX_SRC), CursorBitMap, 0, 0 );		win_setcursor( LispWindowFd, &CurrentCursor );}