/* This is G-file @(#) timer.c Version 2.7 (6/30/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) timer.c	2.7 6/30/88";/********************************************************************** *	timer.c *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. **********************************************************************/#include	<sys/time.h>#include	<sys/types.h>#include	<stdio.h>#include	<signal.h>#include	<fcntl.h>#include	<sys/resource.h>#include	"lispemul.h"#include	"emulglobal.h"#include	"lispglobal.h"#include	"address68k.h"#include	"lisptypes.h"#include	"arith.h"#include	"lispmap.h"#include	"stack.h"#define	LISP_UNIX_TIME_DIFF	29969152#define	LISP_ALTO_TIME_MASK	0x80000000#define UNIX_ALTO_TIME_DIFF	2177452800/*	Interlisp time is signed; MIN.FIXP = "01-JAN-01 00:00:00 GMT" *	Interlisp 0 is at	"19-Jan-69 12:14:08 PST" *	Unix begins at		" 1-Jan-70  0:00:00 GMT" *	(CL:- (IL:IDATE	" 1-Jan-70  0:00:00 GMT") *	      (IL:IDATE "19-Jan-69 12:14:08 PST")) *	=> 29969152, amount to add to Lisp time to get Unix time *	Alto time is unsigned; 0 = "01-JAN-01 00:00:00 GMT" *      UNIX_ALTO_TIME_DIFF is amount to add to Unix time *	to get Alto time. *//**********************************************************************	init_miscstats()	called at initialization time to set 	miscstats words and periodically to update them**********************************************************************/init_miscstats(){	MiscStats->starttime = gettime(0);	MiscStats->gctime = 0;	update_miscstats();}/* update_miscstats()	updates counters and timers in the miscstats page */update_miscstats(){	struct rusage ru;	struct timeval time;	getrusage(RUSAGE_SELF, &ru);		MiscStats->totaltime	=  ru.ru_utime.tv_sec * 1000				   + ru.ru_utime.tv_usec/1000 ;	MiscStats->swapwaittime = ru.ru_stime.tv_sec * 1000 				   + ru.ru_stime.tv_usec/1000;	MiscStats->pagefaults	= ru.ru_minflt + ru.ru_majflt;	MiscStats->swapwrites	= ru.ru_majflt;	MiscStats->diskiotime	= 0; /* ?? not available ?? */	MiscStats->diskops	= ru.ru_inblock 				 /* ?? this doesn't work ???				+ ru.ru_outblock   */				;	gettimeofday(&time, NULL);	MiscStats->secondstmp =	MiscStats->secondsclock =    	   (time.tv_sec + UNIX_ALTO_TIME_DIFF);	}int gettime(casep)int casep;{struct	timeval	time;struct	timezone tz;	switch (casep) {case 0: /* elapsed time in alto milliseconds */	gettimeofday(&time, NULL);	return((time.tv_sec + UNIX_ALTO_TIME_DIFF)*1000 + time.tv_usec/1000);case 1: /* starting elapsed time in milliseconds */	return(MiscStats->starttime);case 2: /* run time, this process, in milliseconds */	update_miscstats();	return(MiscStats->totaltime); case 3: /* total GC time in milliseconds */	return(MiscStats->gctime);case 4: /* current time of day in Alto format */	gettimeofday(&time, NULL);	return (time.tv_sec + UNIX_ALTO_TIME_DIFF);case 5:	/* current time of day in Interlisp format */	gettimeofday(&time, NULL);	return(time.tv_sec + LISP_UNIX_TIME_DIFF);case 6: gettimeofday(&time, &tz);	return (98); /* this is wrong, only works in PST */case 7: gettimeofday(&time, &tz);	return (305); /* this is wrong, only works in PST */case 8: gettimeofday(&time, &tz);	return (tz.tz_minuteswest/60); /* only integral timezones supported */default:	return (0);}}/***********************************************************************	subr_gettime(args) **********************************************************************/DLword	*createcell68k();LispPTR subr_gettime(args)LispPTR	args[];{int result;	result = gettime(args[0] & 0xffff);	if (args[1])	 {	 *((int*)Addr68k_from_LADDR(args[1]) ) = result; 	  return (args[1]); }	else	  N_ARITH_SWITCH(result);} /********************************************************************** *	subr_settime() *	Get alto seconds time and set unix time *	You must be superuser **********************************************************************/subr_settime(args)LispPTR	args[];{	struct timeval time;	time.tv_sec = *((int*)Addr68k_from_LADDR(args[0])) 			- UNIX_ALTO_TIME_DIFF;	settimeofday(&time, NULL);} /* end subr_settime */subr_copytimestats(args)LispPTR args[];{   MISCSTATS *source;    MISCSTATS *dest;	source = (MISCSTATS*) Addr68k_from_LADDR(args[0]);	dest = (MISCSTATS*) Addr68k_from_LADDR(args[1]);    update_miscstats();    dest->starttime = source->starttime;    dest->totaltime = source->totaltime;    dest->swapwaittime = source->swapwaittime;    dest->pagefaults = source->pagefaults;    dest->swapwrites = source->swapwrites;    dest->diskiotime = source->diskiotime;    dest->diskops = source->diskops;    dest->gctime = source->gctime;    dest->netiotime = source->netiotime;}/********************************************************************** *	N_OP_rclk *	entry	RCLK	OPCODE[167] *	Get unix time and set microseconds time	** ADOPTED NEW VERSION **********************************************************************/LispPTR N_OP_rclk(tos)	register LispPTR tos;{struct	timeval	time;unsigned int	usec;	gettimeofday(&time, NULL);	usec = (time.tv_sec * 1000000) + time.tv_usec;#ifdef	sparc	*(short *)Addr68k_from_LADDR(tos) = usec >> 16;	*((short *)Addr68k_from_LADDR(tos)+2) = usec & 0xFFFF;#else	*((unsigned int *)(Addr68k_from_LADDR(tos))) = usec;#endif	return(tos);} /* end N_OP_rclk *//**********************************************************************/ /* update_timer called periodically */update_timer() {  	struct  timeval time;        gettimeofday(&time, NIL);	MiscStats->secondstmp = MiscStats->secondsclock =    	   (time.tv_sec + UNIX_ALTO_TIME_DIFF);  }/**********************************************************************//* timer interrupt handling system	int_init() should be called before first entering dispatch loop.	int_timer_init() is called by int_init() and arms the timer interrupt.	int_io_init() is called by int_init() and arms the I/O interrupt.	int_timer_service() catches the timer signal and sets 		Irq_Stk_Check & Irq_Stk_End to 0		so the rest of the system will see it and respond.	int_block() and int_unblock() block timer interrupts  and release them.	int_io_open(fd) should be called whenever a file that should interrupt		us is opened; it enables the interrupt on that fd.	int_io_close(fd) should be called whenever a file that should interrupt		us is closed; it disables the interrupt on that fd.*//* 25000 usec ~ 40 per second.  This should live in some machine-configuration	file somewhere - it can be changed as the -t parameter to lisp*/int TIMER_INTERVAL =  25000;	extern int Irq_Stk_Check, Irq_Stk_End;int FileIOFlag = 0;int TimerFlag = 0;extern int TTY_Fd, RS232C_Fd, ether_fd;extern u_int LispWindowFd;int_timer_service(sig, code, scp)int sig, code;struct sigcontext *scp;{/* this may have to do more in the future, like check for nested interrupts,	etc... */	Irq_Stk_Check = 0;	Irq_Stk_End = 0;	TimerFlag = 1;}static struct sigvec timerv;void int_timer_init(){struct itimerval timert, tmpt;/* first set up the signal handler */	timerv.sv_handler = int_timer_service;	timerv.sv_mask = timerv.sv_flags = 0;	sigvec(SIGVTALRM, &timerv, 0);/* then attach a timer to it and turn it loose */	timert.it_interval.tv_sec = timert.it_value.tv_sec = 0;	timert.it_interval.tv_usec = timert.it_value.tv_usec = TIMER_INTERVAL;	timerclear(&tmpt.it_value);	timerclear(&tmpt.it_interval);	setitimer(ITIMER_VIRTUAL, &timert, &tmpt);	getitimer(ITIMER_VIRTUAL, &tmpt);#ifdef  DEBUG	printf("Timer interval set to %d usec\n", timert.it_value.tv_usec);#endif}void int_io_open(fd)int fd;{#ifdef KBINT#ifdef  DEBUG	printf("int_io_opening %d\n", fd);#endif	if(fcntl(fd, F_SETOWN, getpid()) == -1 )#ifdef DEBUG		perror("fcntl F_SETOWN ERROR");#else	{};#endif	if(fcntl(fd, F_SETFL, fcntl (fd, F_GETFL, 0) | FASYNC) == -1)		perror("fcntl F_SETFL error");#endif}void int_io_close(fd)int fd;{#ifdef KBINT	fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~FASYNC);#endif}void int_io_init(){static struct sigvec timerv;extern getsignaldata();/* first set up the signal handler */#ifdef KBINT	timerv.sv_handler = getsignaldata;	timerv.sv_mask = timerv.sv_flags = 0;	sigvec(SIGIO, &timerv, 0);#ifdef  DEBUG	printf("I/O interrupts enabled\n");#endif#endif}int oldmask;void int_block(){/* temporarily turn off interrupts */	oldmask= sigsetmask(sigmask(SIGVTALRM) | sigmask(SIGIO) | sigmask(SIGALRM));}void int_unblock(){	sigsetmask(oldmask);}int_timer_on() {int_unblock();}int_timer_off() {int_block();}/*void int_timer_off(){struct sigvec tmpv, timeroffv;timeroffv.sv_handler = SIG_IGN;timeroffv.sv_mask = timeroffv.sv_flags = 0;sigvec(SIGVTALRM, &timeroffv, &tmpv);}void int_timer_on(){struct sigvec tmpv;sigvec(SIGVTALRM, &timerv, &tmpv);}*/void int_init(){	int_timer_init();	int_io_init();	int_unblock();}