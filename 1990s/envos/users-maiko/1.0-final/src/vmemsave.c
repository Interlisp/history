/* This is G-file @(#) vmemsave.c Version 2.8 (7/7/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) vmemsave.c	2.8 7/7/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *//**	vmemsave.c**	** ADOPTED NEW VERSION**/#include <stdio.h>#include <sys/file.h>#include <sys/types.h>#include <sys/stat.h>#include <sys/param.h>#include <sys/vfs.h>#include <errno.h>#include <signal.h>#include <setjmp.h>#include <sunwindow/win_cursor.h>#include "machineconfig.h"#include "lispemul.h"#include "lispmap.h"#include "lispglobal.h"#include "ifpage.h"#include "vmemsave.h"#include "timeout.h"#define	COMPLETESYSOUT	NIL#define	BADFILENAME	S_POSITIVE | 1	#define	NOFILESPACE	S_POSITIVE | 2	#define FILECANNOTOPEN	S_POSITIVE | 3#define FILECANNOTSEEK	S_POSITIVE | 4#define FILECANNOTWRITE	S_POSITIVE | 5struct stat     DEBUG_stat;extern int LispWindowFd;extern struct pixrect *ScreenBitMap, *CursorBitMap, *InvisibleCursorBitMap;extern struct cursor CurrentCursor, InvisibleCursor;char	*rindex();#undef roundup#define roundup( a, b) ((((unsigned)(a)+(b)-1)/(b))*(b))vmem_save(sysout_file_name)char	*sysout_file_name;{	int		sysout;	/* SysoutFile descriptor */	DLword	*fptovp;	/* FPTOVP */	int	vmemsize;	/* VMEMSIZE */	int	i;	char	fullpathname[MAXPATHLEN];	char	dirname[MAXPATHLEN];	struct statfs	fsbuf;	char	*cp;	int	rval;	if( makepathname(sysout_file_name, fullpathname) == 0)		return(BADFILENAME);	/* remove cursor image from screen */	win_setcursor( LispWindowFd, &InvisibleCursor);	/* set FPTOVP */	fptovp = FPtoVP + 1;	/* set VMEMSIZE */	vmemsize = InterfacePage->nactivepages;	strcpy(dirname, fullpathname);	if((cp=rindex(dirname, '/')) == 0)		return(BADFILENAME);	*cp = '\0';	SETJMP(BADFILENAME);	TIMEOUT( rval=statfs(dirname, &fsbuf) );	if( rval != 0){		err_mess("statfs", errno);		return(BADFILENAME);	}	if( (vmemsize * BYTESPER_PAGE) > (fsbuf.f_bavail * fsbuf.f_bsize) ){		printf("File Systm Resources Exceeded\n");		return(NOFILESPACE);	}	/* open sysoutfile */	TIMEOUT(sysout=open(fullpathname, O_WRONLY | O_CREAT | O_TRUNC, 0666));	if (sysout == -1) {		err_mess("open", errno);		return(FILECANNOTOPEN);	}	InterfacePage->machinetype = KATANA;	/*printf("start vmemsave\n"); */	/* store vmem to sysoutfile */	for (i = 0; i < vmemsize; i++) {		if (fptovp[i] != 0177777) {	   		TIMEOUT( rval=lseek(sysout, i * BYTESPER_PAGE, 0) );	   		if (rval == -1) {				err_mess("lseek", errno);				return(FILECANNOTSEEK);	  		}			TIMEOUT( rval=write(sysout, (char *)(Lisp_world + (fptovp[i] * DLWORDSPER_PAGE)), BYTESPER_PAGE) );			if (rval == -1) {				err_mess("write", errno);				return(FILECANNOTWRITE);			}		}  	}	/* seek to IFPAGE */	TIMEOUT(rval=lseek(sysout, (long)FP_IFPAGE, 0));	if (rval == -1) {		err_mess("lseek", errno);		return(FILECANNOTSEEK);	}	TIMEOUT(rval=write(sysout, (char *) InterfacePage, BYTESPER_PAGE) );	if (rval == -1) {		err_mess("write", errno);		return(FILECANNOTWRITE);	}    	TIMEOUT( close(sysout) );	/* restore cursor image to screen */	win_setcursor( LispWindowFd, &CurrentCursor);	/*printf("vmem is saved completely.\n");*/	return(COMPLETESYSOUT);}extern int UnixPID;/* Make sure that we kill off any Unix subprocesses before we go away */lisp_finish(){  char d[3];#ifdef  DEBUG  printf("finish lisp_finish\n");#endif  d[0] = 'E';  d[3] = 1;  write(UnixPipeOut, d, 4);	/* Send fork_Unix on a homicidal spree */  read(UnixPipeIn, d, 4);	/* Make sure it's finished */  kill(UnixPID, SIGKILL);	/* Then kill fork_Unix itself */  device_before_exit();  exit(1);	}