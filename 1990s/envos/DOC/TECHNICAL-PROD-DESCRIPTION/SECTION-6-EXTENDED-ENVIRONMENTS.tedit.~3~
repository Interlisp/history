1

TECHNICAL PRODUCT DESCRIPTION
1

TECHNICAL PRODUCT DESCRIPTION
6.  EXTENDED ENVIRONMENTS
1

6.  EXTENDED ENVIRONMENTS
1


6.	EXTENDED ENVIRONMENTS
6


Xerox continues to add to XAIE the results of its ongoing research into advanced systems. It is seldom necessary to change anything basic to XAIE in order to customize it for specific applications. Instead, extended environments can be defined as utilities and functions which fit into and on top of XAIE, giving users tools that require less time and effort for applications in there domain.
2

LOOPS
1

Xerox LOOPS (Lisp Object Oriented Programming System) adds access, object, and rule-oriented programming to the procedure-oriented programming of Interlisp-D. Including a set of utilities which can be used by knowledge engineers with little knowledge of Lisp or Prolog programming, the result is an extended environment for knowledge engineering and the creation of knowledge-based systems.
Xerox LOOPS became a fully supported product in 1987, after being widely used since 1984 as a research prototype. Early versions have been used to implement a variety of customer applications as well as internal Xerox applications, in the areas of diagnosis, planning, finance, manufacturing, simulation, monitoring, medicine, and training. Several improvements, in both features and run-time efficiency, were added to the supported product, while maintaining upward compatibility for programs written in earlier versions.
The 1983 AI Magazine article, Knowledge Programming in LOOPS (Stefik83) introduced the first versions of Xerox LOOPS, and the experimental economics domain called Truckin¹. While this has had a great deal of influence over the evolution of many AI tools since then, the design of Xerox LOOPS owes an intellectual debt to a number of other systems, including:
SmallTalk (Goldberg82) an earlier Xerox project which pioneered many of the concepts of object-oriented programming.
Flavors (Weinreb81) which supports object-oriented pro?gramming in the MIT Lisp machine environment.
KRL (Bobrow77) which explored many issues in the design of frame-based knowledge representation languages and which provoked much additional work in this area.
UNITS (Stefik79) which provided a testbed for experiments in problem solving that guided design decisions about several Xerox LOOPS language features.
EMYCIN (VanMelle80) illustrates the power of rule-oriented programming for building expert systems, as well as some of its limitations.
In object-oriented programming, behavior is determined by responses of objects (instances of classes) to messages sent between the objects. No direct access to the internal structure of an object is used. Xerox LOOPS makes it convenient to define program interfaces in terms of the independent objects which exist in an application domain and message protocols between them.
Access-oriented programming is a dual of object-oriented programming, where behavior can occur as a side effect of direct access to an object state. This makes it easy to write programs which monitor the behavor of other programs, and to implement ªblackboardº architectures for knowledge-based systems.
Rule-oriented programming is an alternative to programming in Lisp. Programs in this paradigm are organized around recursively composable sets of pattern-action rules for use in expert system design. Rules make it convenient for describing flexible responses to a wide range of events. Xerox LOOPS supports rules through an interface to the rule-oriented programming language of Xerox Quintus Prolog. And because Xerox LOOPS is integrated with XAIE, it provides access to the standard procedure-oriented programming of Common Lisp and Interlisp-D as well as use of the extensive environmental support of the XAIE system.
Experience suggests that programs are easier to build in a language when there is an available paradigm that matches the structure of the problem. The paradigms described here offer distinct ways of partitioning the organization of a program, as well as distinct ways of viewing the significance of side effects. Xerox LOOPS provides all these paradigms within a single environment.
A class in Xerox LOOPS is a description of one or more similar objects. An instance is an object described by a particular class. Every object within Xerox LOOPS is an instance of exactly one class. Classes themselves are instances of a class, usually the one called class. Classes whose instances are classes are called metaclasses. 
A class specifies the behavior of its instances in terms of their response to messages. The class associates selectors with methods, the Lisp functions that respond to the message.
Xerox LOOPS supports two kinds of variables: CVs (class variables) and IVs (instance variables). CVs are used to contain information shared by all instances of the class. A CV is typically used for information about a class taken as a whole. IVs contain the information specific to an instance. Both kinds of variables have names, values, and other properties. A class describes the structure of its instances by specifying the names and default values of its variables.
Figure X-X.  XXXXXXXXX
Sometimes a class is defined as a description, and only one instance of the class is ever needed. The prototype instance can be conveniently referred to in the standard manner, by the name prototype, with automatic creation of the prototype if it has not already occurred.
Xerox LOOPS is well integrated with XAIE. Both classes and instances are implemented as Lisp datatypes, so their processing is handled directly by the microcode and hardware of the Xerox AI workstation, thereby optimizing its performance. Classes, instances, and methods can all be saved together in disk files through the XAIE File Package. The ? = help facility of Lisp functions also works for LOOPS methods, providing a list of arguments expected for developers.
Inheritance is an important tool for organizing information in objects. it enables the easy creation of objects that are ªalmost likeº other objects with a few incremental changes. Inheritance relieves the user of having to specify redundant information and simplifies updating, since information that is common need be changed in only one place.
Xerox LOOPS objects exist in an inheritance lattice of classes. An object inherits its variable descriptions and message responses. All descriptions in a class are inherited by a subclass unless overridden in the subclass. This is implemented by a run-time search for the information, looking first in the class, and then at the super classes specified by its supers list. Each class can specify inheritance of structure and behavior from any number of super classes.
HEADING
1

Multiple super classes admit a modular programming style where methods and associated variables for implementing a particular feature are placed in a single class, and objects requiring combinations of independent features inherit then from multiple supers. For combining an inherited method with local code, Xerox LOOPS provides the special method invocation ¬ Super. This provides a form of relative addressing; it invokes the next more general method of the same name even when the specialized method invoking ¬ Super is inherited over a distance. Another form, ¬ Super Fringe, invokes the more general method for each of the super classes.
For sophisticated applications involving multiple worlds or time-sensitive data, the virtual copy feature provides a way to prevent exponential system growth. Virtual copies are to deep copies as lazy evaluation is to standard evaluation ? IVs are not really copied until they are modified. A virtual copy is a small object which grows as its IVs are referenced. The only observable difference is that virtual copies track changes in the object they copy until the IVs in the copy are modified.
To reduce the cognitive load for restructuring objects and accessing information in a complex environment, Xerox LOOPS provides browsers,  interactive graphics for ªbrowsingº information in a knowledge base. Built on the Lisp package Grapher, these provide a more effective way of making the right information visible.
A number of specializations of the general class LatticeBrowser are provided by Xerox LOOPS, and additional ones can be created by developers. LOOPS class browsers show the inheritance lattice defined between different classes, facilitating the location of variables and methods in the best locations in the lattice. Class/instance browsers and file browsers also show the static inheritance relationships, adding the display of instances and limiting the display to classes stored in a specified file, respectively. More dynamic relationships are shown by instance browsers, which can read and display relationships between instances which may not be determined until run-time.
Figure X-X.  XXXXXXXXX

In data-oriented programming, users need a way of specifying for any variable of an object whether any special procedure is to be invoked on read or write access, and if so, which. Xerox LOOPS checks on every variable access whether the value is marked as an active value or not. If so, the active value converts the access into a message which allows the proper methods to be invoked. This mechanism is thus dual to the notion of messages; messages are a way of telling objects to perform operations, which can change their variables as a side effect; active values are a way of accessing variables, which can send messages as a side effect.
The active value facility in Xerox LOOPS is an especially general implementation of what is sometimes called procedural attachment, or ªdemons.º  In LOOPS, no declaration is required on the particular IVs or CVs being made active. The generality of the implementation allows arbitrary nestling of active values, before or after the access takes effect. LOOPS implements active values via a Lisp datatype, so the performance of this facility is optimized on the Xerox AI workstation.
Several kinds of active values are supplied by Xerox LOOPS to be used intact, or as examples to be specialized for customer applications; ªLocalStateActiveValueº is the most common type; ªExplicitFnActiveValueº provides compatibility with the more limited active value facility in previous versions of LOOPS; and ªIndirectVariableº and ªFirst FetchAVº handle the very common cases of the equivalencing of two variables and of variables¹ requiring a complex initialization. Breaking and tracking active values enhance development activities. ªNotSetValueº is a special active value used internally by Xerox LOOPS to implement lazy evaluation of instances¹ inherited variables.
HEADING
1

An easily understood and immediately useful application of active values is provided by Xerox LOOPS gauges. These are a set of bitmaps which can be placed on the screen, and which react in real-time to changes in value in the variables to which they are attached. Gauges are defined as LOOPS classes, instances of which are driven by active values. They can be thought of as probes inserted into the variables of an arbitrary LOOPS program.
Gauges can be attached to variables by anyone knowing the names of instances and variables in the program, even if no source code is available. This is useful in both program development, where the gauge serves as a debugging aid, and in developing an effective user interface for a program otherwise complete. Xerox LOOPS supplies bar charts, round gauges, and digital gauges, with self-scaling and active (mouse-settable) ©©mix-ins.¹¹ Customization of a gauge via specialization is straightforward, for applications where a specific appearance is required, and is typically given as a one hour exercise in the LOOPS training class.
Figure X-X.  XXXXX
The core of decision-making expertise in many kinds of problem solving can be expressed succinctly in terms of rules. In Xerox LOOPS, rule-oriented programming is integrated with object-oriented, data-oriented, and procedure-oriented programming. The rule language provides a concise syntax for the most common operations. The rationale behind the design of the Xerox LOOPS rule language is driven by the observation that when a rule is heavy with control information, it obscures the domain knowledge that the rule is intended to convey. This lead the designers of the rule language to find ways to factor control information out of the rules.
The work space for rules in Xerox LOOPS is an arbitrary LOOPS object. The name of the IVs provide a name space for variables in the rules. Rules in Xerox LOOPS are organized into production systems called rule sets, with specified control structures for selecting and executing the rules. Like subroutines, rule sets are building blocks for organizing programs heirarchically. Rule sets can be invoked as methods by sending messages to objects, which also allows them to be triggered by active values. They can also be invoked directly from Lisp programs, and from rules either as predicates on the left-hand side of rules, or as actions on the right-hand side. This provides a way for rule sets to control the execution of other rule sets.
The Xerox LOOPS rule language comprises a simple condition-action rule structure, with a structure that separates decision knowledge from meta-knowledge such as control information, rule descriptions, debugging instructions, and audit trail descriptions. Within one RuleSet, control options include first-rule and all-rule versions of one pass execution (DO), conditional looping (WHILE), and explicit looping (the Interlisp-D FOR operator). On a rule set or individual rule basis tracing, breaking, and auditing ban be specified.
There are several alternate lexical forms for the various features of the rule language. Rules may be written with the words ªIf-Then,º or with the use of arrows. there are lexical shorthands for message sending, variable referencing, and assignment. ©©In-fix¹¹ arithmetic operators are recognized, and it is also possible to reference Lisp variables, or to include arbitrary Lisp code on either side of the rules (at the risk of confusing the rule-oriented paradigm). Meta-descriptors on a rule-by-rule basis allow specific auditing information to be recorded, or for rule execution to be limited to one-time, on-entry, or on-exit.
Development and debugging features for the rule language parallel those of XAIE for Lisp. Rules are edited using TEdit, the WYSIWYG text and graphics editor of XAIE. Rule set execution can be interrupted by a break key, at which time a special rule executive appears, including a backtrace showing rule sets currently on the stack. Each rule set compilation includes the recording of the editor¹s name and time of rule modification, so that examination of the audit trail shows this information, as well as current variable values, recorded rule text, and justification.
The rule language is compiled to Lisp immediately upon exit from TEdit during the development cycle. The Lisp code can be inspected, modified, and compiled as necessary, but overall rule execution takes place with the same speed shown by pure Lisp. Inspection of the Lisp code will show, however, that the generated Lisp code is typically much longer and less easy to read than the rule language itself.
Because Xerox LOOPS is an extended language under XAIE, it can be easily extended in a number of directions. The integration of Xerox LOOPS into XAIE, and of the multiple paradigms within it, means that the extensions can easily be consistent with existing LOOPS features. Xerox LOOPS is itself written using LOOPS.
The specialization of the general class object is usually the first step in building object-oriented applications code. Custom?ization and specialization is also the general approach used in designing special active values of specific applications. Even the rule language is easily extended, as the rule sets and rules are themselves classes, which can be added to or specialized to fit the requirements any application may have.
The basic behavior of Xerox LOOPS can be changed to a great extent simply by specializing the methods used to create, access, and destroy objects. Text books and competing products may suggest features not supplied with Xerox LOOPS, either more general or more limited. These will commonly be possible to emulate with the specialization of a few lines code, thereby allowing them to be integrated with the wide range of paradigms and features already available within Xerox LOOPS.
(Bobrow 1977)	Bobrow, D., Winograd, T. An Overview of KRL, a knowledge representation language, Cognitive Science 1:1, 1977- p. 3-46.
(Goldberg 1982)	Goldberg, A., Robson, D., Ingalls, D. Smalltalk-80: The Language and its Implementation. Addison-Wesley, 1983.
(Stefik 1979)	Stefik. M. An examination of a frame-structured representation system. Proceedings of the Sixth International Joint Conference on Artificial Intelligence, Tokyo, Japan, August 1979, pp. 845-852.
	Stefik, M., Bobrow, D., Mittal, S. and Conway, L. Knowledge Programming in LOOPS: Report on an Experimental Course. AI Magazine, Fall 1983.
	Stefik, M., Bobrow, D. Object Oriented Programming: Themes and Variations. AI Magazine, Winter 1985.
(vanMelle 1981)	VanMelle, W. System Aids in Constructing Consultation Programs. UMI Research Press, Ann Arbor, MI.
(Weinreb 1981)	Weinreb, D., Moon, D. Lisp Machine Manual. Symbolics, Inc.
	Xerox Corporation. Xerox LOOPS Reference Manual. 1987.
2

Notecards
1

NoteCards is a document authoring tool for end users, specifically designed to aid in the collection, structuring, and analysis of textual and graphical information. For system developers it is a way of interlinking documents with a general purpose user interface of great power and flexibility easily understood by new users. NoteCards integrates a number of the XAIE utilities, especially TEdit and Sketch.
The basic objects in the NoteCards system are note cards, or simply cards. Each card usually contains a small, idea-sized unit of text or graphics. Individual cards can be linked together to form networks that reflect the interconnections among the information (ideas) contained in each card. These networks rely on the notion of typed links. Links are identified by link icons, objects located in the text or graphics of the originating card that reference some destination card. The user can retrieve and display the destination card of any link by using the mouse to select an appropriate icon. The user can also display a listing of all links that are directed into and out of a card, or a browser (graphic) of all cards connected by specified types of links.
NoteCards provides a number of tools to help users collect, manipulate, and organize information. The browser displays a graphical representation of a given set of cards and the links between them. The search mechanism builds a list of all cards that have a given word or string in their titles. The source mechanism allows users to specify links to the source(s) of information associated with each card. Finally, the documentation mechanism pulls together the text and graphics stored in a specified set of cards for hardcopy.
NoteCards also includes facilities for controlling sessions and manipulating whole note files. At any point, a session in NoteCards can be ©©check-pointed,¹¹ saving all changes made since the opening of the file. There is also an abort function, which will forget all changes back to the last check-point, or to the opening of the note file if no check-points have been executed. At  any point, a card can be closed, or shrunk to an icon appropriate to the card type ? for instance, text cards shrink to the standard TEdit book icon, with the card title and card number on the cover. Shrunken cards are recognized by NoteCards as readily as opened or closed cards. There is no limit to the number of cards which can appear on the screen at once. Like all windows in XAIE, cards may overlap or cover each other, and NoteCards will bring to the surface any card which is called for, rather than bringing up a duplicate. Cards have a set default size, approximately three by five inches for text cards, but can be reshaped to any size using standard XAIE mechanisms. Entire note files can be backed up onto floppy diskettes, and damaged note files can be repaired to completely fix most errors, or recover the maximum information from any catastrophic failure.

	Table of Contents	The top level ©©file box¹¹ of each note file is called the table of contents card, and is designed for storage of links to file boxes and other note cards at the highest level of the hierarchy. There are two other special file boxes, a ªToBeFiledº box for cards not otherwise boxed when a note file is closed, and an ©©orphans¹¹ card for cards whose last link from another card has been deleted.
	Text Cards	Text cards are the default note card, and are most useful for text or mixed text and graphics. As each card is based on TEdit, multiple fonts and powerful formatting commands are available in a WYSIWYG manner, and the text can be scrolled within a card or moved between cards. NoteCard icons can be inserted in the text at any location, allowing nonhierarchical linking between all varieties of cards.
	Sketch and Idea Sketch Cards	Sketch cards are used for creating and editing sketches, line drawings, and bitmaps as supported by the XAIE Sketch utility. Lines, geometric shapes, and filling are all supported by Sketch, and sketches can be scrolled horizontally and vertically, or zoomed in and out. NoteCard icons can be inserted at any location in the sketch. Idea Sketch cards modify the Sketch utility so that linked charts are more easily created, for flow chart or organization chart styles.
	Graph Cards	The XAIE Grapher package is the basis for graph cards, cards which allow the creating and editing for node links and graph structures. Grapher data structures are used through XAIE, and are easily imported and exported from these cards.
	File Boxes	A File Box is a card containing a list of link icons representing sub-file boxes and all varieties of note cards. File boxes are used to support hierarchical organization of information according to conceptual groupings. Each file box is a TEdit window, just like a text card, but has predefined headings for file boxes and note cards, and automatically sorts new entries under the proper heading. Any note card can appear simultaneously in any number of file boxes.
	Browser Cards	Browser cards present a view of cards/boxes and the links between them in a specified portion of the current note file. Given a starting card or box and a set of link types, browser cards create a graph structure showing all note cards linked to and/or from the initial card by recursively following all links of the types specified. This assists the structuring of information, especially where it has not been limited to a hierarchical structure.
	Search Cards	Search cards search through all boxes and cards looking for titles containing a specific string of characters. A new card is created containing links to these cards, and the day and time the list was compiled.
	Document Cards	Document cards create cards that contain the textual information collected from all descendant cards and/or boxes from a specified note card. Once a document card is selected, the user is prompted for a starting box or card, and for selecting the parameters for the document. Headings may be copied from embedded file boxes, titles from note cards may be collected, and embedded card icons may be printed, expanded, or ignored.

Everything that can be done interactively with NoteCards is of course done by some Lisp function, all of which are available for programmatic access as well. For system developers and advanced users it is possible, for instance, to attach to each card a property list containing information arranged in attributed-value pairs. For example, a user might want to attach a certainty value expressing the degree to which the information on the card is believed to be true.
In an increasingly information-oriented society there are a number of complex situations for which NoteCards is an appropriate tool. In research work, complexity resides not only in the information itself, but comes from the processes of gathering it from multiple, possibly unrelated locations and sources. NoteCards allows information to be recorded and gathered in structures corresponding to the most complex situations. In synthesis work, where a number of attempts need to be made to find the optimal combination of available data, NoteCards provides the multiple link types and views necessary for solution building. The following examples show these features at work.
Thesis research and writing	Among the most complex information tasks available, research resulting in doctoral degrees has long had the reputation for consuming huge amounts of time and effort. NoteCards has been used in the writing of several dissertations, allowing more concentration on the subjects and less on the clerical tasks involved.
	Visual indexing of complex data	Keeping a database of customer information often seems a job that is never complete. NoteCards allows a database to be built at several levels, and to be indexed in multiple ways, so that the most complex information is available by selecting the appropriate icons with the mouse. Bill of materials manufacturing, marketing research materials, and geographic databases are additional types of applications involving multilayered, integrated text and graphic information.
	Cooperative work	Projects within Xerox PARC and at customer sites have taken advantage of the NoteCards link types to facilitate and investigate group work processes. Each member of a group can be given his/her own link type, and can insert comments and information from the common draft documents into his/her own section. Others in the group can prepare documents with all, none, or selected additional comments included. NoteCards is unique in its ability to support this style of work.
	Overhead slides	At a purely clerical level, it is possible to create overhead slide presentations using the large fonts in a set of text cards, and then to index them into different file boxes representing different audiences who may be addressed. Explanatory material can be inserted via links from the overheads to additional text cards, and then each presentation printed using two different document cards ? one that prints the overheads cleanly, for use on the projector, and a second that prints them with the additional material inserted, for the presenter to refer to.
	Customization of NoteCards	When used as the interface to an intelligent application, it is often possible for the system implementor to recognize the logical structure in which cards should be arranged, and to have NoteCards provide that structure to the user. For instance, in a ªLegal NoteCardsº project within Xerox, a ªcaseº note card comes up as a set of several attached subcards, representing the universal components of a legal case: subject, court dates, witnesses, evidence, etc. Each card must be filled in before the system concludes that preparation is complete. Additionally in this application, a ªcitationsº card type was created, which, given a list of information to gather automatically, dials up remote databases, initiates a set of queries, and sorts the responses into additional note cards to be added to the case.
     (LIST ((PAGE NIL (PAPERSIZE NIL STARTINGPAGE# 1) (0 0 612 792) ((FOLIO NIL (PARALOOKS (QUAD RIGHT) CHARLOOKS (SUPERSCRIPT 0 INVISIBLE OFF SELECTPOINT OFF PROTECTED OFF SIZE 10 FAMILY OPTIMA OVERLINE OFF STRIKEOUT OFF UNDERLINE OFF EXPANSION REGULAR SLOPE REGULAR WEIGHT MEDIUM INVERTED OFF USERINFO NIL STYLE NIL) FORMATINFO NIL) (270 15 288 36) NIL) (HEADING NIL (HEADINGTYPE FOOTINGR) (54 27 558 36) NIL) (TEXT NIL NIL (54 54 504 723) NIL))) (PAGE NIL (PAPERSIZE NIL) (0 0 612 792) ((FOLIO NIL (PARALOOKS (QUAD LEFT) CHARLOOKS (SUPERSCRIPT 0 INVISIBLE OFF SELECTPOINT OFF PROTECTED OFF SIZE 10 FAMILY OPTIMA OVERLINE OFF STRIKEOUT OFF UNDERLINE OFF EXPANSION REGULAR SLOPE REGULAR WEIGHT MEDIUM INVERTED OFF USERINFO NIL STYLE NIL) FORMATINFO NIL) (54 15 288 36) NIL) (HEADING NIL (HEADINGTYPE FOOTINGV) (54 27 558 36) NIL) (HEADING NIL (HEADINGTYPE VERSOHEAD) (54 762 558 36) NIL) (TEXT NIL NIL (54 54 504 684) NIL))) (PAGE NIL (PAPERSIZE NIL) (0 0 612 792) ((FOLIO NIL (PARALOOKS (QUAD RIGHT) CHARLOOKS (SUPERSCRIPT 0 INVISIBLE OFF SELECTPOINT OFF PROTECTED OFF SIZE 10 FAMILY OPTIMA OVERLINE OFF STRIKEOUT OFF UNDERLINE OFF EXPANSION REGULAR SLOPE REGULAR WEIGHT MEDIUM INVERTED OFF USERINFO NIL STYLE NIL) FORMATINFO NIL) (270 15 288 36) NIL) (HEADING NIL (HEADINGTYPE FOOTINGR) (54 27 558 36) NIL) (HEADING NIL (HEADINGTYPE RECTOHEAD) (54 762 558 36) NIL) (TEXT NIL NIL (54 54 504 684) NIL)))))      
 -    ø 2                       T         -    ø                        T         5 H Ìø       ´ Ì                              -    ø                         T         -    ø                        T         , Ì Ìø                                 , Ì Ìø                                 3 Ì Ìø        ø                   T         F    ø        ø       PAGEHEADING 	VERSOHEAD                   F    ø        ø       PAGEHEADING 	RECTOHEAD                   E    ø      ø       PAGEHEADING FOOTINGV                   E    ø      ø       PAGEHEADING FOOTINGR                   ,                                                CLASSIC          CLASSIC          CLASSIC          CLASSIC           TERMINAL           MODERN                    HRULE.GETFN  CLASSIC                                               HRULE.GETFN  CLASSIC                                                            HRULE.GETFN  CLASSIC                      	             	     HRULE.GETFN  CLASSIC                                        HRULE.GETFN  CLASSIC                     
               ‰               HRULE.GETFN  CLASSIC                                       HRULE.GETFN  CLASSIC                       ‡                        g             u             e                           —             ˆ            w            0            m                        O             µ            ×                                     Ó            [            Ô                            HRULE.GETFN  CLASSIC                       h              ˜              3              N            ï            ?            §                                      ƒ            ã            ¤                            HRULE.GETFN  CLASSIC                       ¹            z                         …            å                        y            ;            ”            <            ®            á             †                          Ñ                          f             s             J             8               HRULE.GETFN  CLASSIC                                       HRULE.GETFN  CLASSIC                       ™            ü                        ê          
               Ÿ            ž            ó             ú            ß            Ð             à            ¼          
               Õ            ¤            X            ø            ë            B            G                  kÒ Îzº