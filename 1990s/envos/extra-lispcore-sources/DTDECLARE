(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(FILECREATED "17-Jul-90 13:30:32" |{DSK}<users>sybalsky>DTDECLARE.;2| 30868        |changes| |to:|  (OPTIMIZERS \\DTEST)      |previous| |date:| " 6-Jul-90 18:00:17" |{DSK}<users>sybalsky>DTDECLARE.;1|); Copyright (c) 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1990 by Venue & Xerox Corporation.  All rights reserved.(PRETTYCOMPRINT DTDECLARECOMS)(RPAQQ DTDECLARECOMS       (        (* |;;| "declaring DATATYPES --- part of ABC too")        (FNS /DECLAREDATATYPE DECLAREDATATYPE TRANSLATE.DATATYPE \\REUSETO \\TYPEGLOBALVARIABLE)        (FUNCTIONS TYPE-VARIABLE-FROM-TYPE-NAME)        (FNS |BitFieldMask| |BitFieldShift| |BitFieldShiftedMask| |MakeBitField| |BitFieldWidth|              |BitFieldFirst|)        (OPTIMIZERS FETCHFIELD FFETCHFIELD REPLACEFIELD FREPLACEFIELD REPLACEFIELDVAL                FREPLACEFIELDVAL NCREATE \\DTEST)        (PROP DMACRO \\TESTBITS)        (FNS COMPILEDFETCHFIELD COMPILEDREPLACEFIELD COMPILEDNCREATE)        (DECLARE\: DONTCOPY (EXPORT (RECORDS |FldDsc|)))        (VARS DATATYPEFIELDTYPES)        (COMS                                                (* \;                         "Macros which convert a record access form into an address-generating form")              (MACROS LOCF INDEXF)              (FNS TRANSLATE.LOCF))        (LOCALVARS . T)        (PROP FILETYPE DTDECLARE)))(* |;;| "declaring DATATYPES --- part of ABC too")(DEFINEQ(/declaredatatype  (lambda (typename fieldspecs dlist len supertype)          (* \; "Edited 18-May-87 17:09 by Snow")    (and lispxhist typename (undosave (list '/declaredatatype typename (getfieldspecs typename)                                            nil nil (getsupertype typename))))    (cl:multiple-value-bind (dlist redeclared)           (declaredatatype typename fieldspecs dlist len supertype)           (cond              (redeclared (lispxprint (list '|datatype| typename '|redeclared|)                                 t t)))           dlist)))(declaredatatype  (lambda (typename fieldspecs dlist length supertype)       (* |Pavel| "16-Oct-86 14:52")                                                  (* |;;| "this is called twice when declaring records;  once where the DLIST and LENGTH hasn't been computed, and another time when it has.")    (let ((superspecs (cond                         (supertype (getfieldspecs supertype)))))                                                  (* \; "maybe an error if supertype doesn't exist?")         (setq fieldspecs (append superspecs fieldspecs))         (cond            ((and fieldspecs (or (not dlist)                                 (not length)))   (* \;                                   "the AND is an optimization -- do we really need to compute DLIST?")             (setq dlist (translate.datatype typename fieldspecs))             (setq length (|pop| dlist)))))    (or (and typename (litatom typename))        (lisperror "ILLEGAL ARG" typename))    (let ((ptrs (|for| p |in| dlist |when| (selectq (|fetch| |fdType| |of| p)                                               ((pointer fullpointer)                                                     t)                                               nil) |collect| (|fetch| |fdOffset| |of| p))))         (cl:multiple-value-bind (typenum redeclared)                (\\assigndatatype1 typename dlist length fieldspecs ptrs supertype)                (settopval (\\typeglobalvariable typename t)                       typenum)                (cl:values dlist redeclared)))))(translate.datatype  (lambda (typename fieldspecs)                              (* declarations\: (record spec                                                             (n len . fd)))    (declare (specvars typename unused bit offset fd))       (* \; "Edited 18-May-87 17:10 by Snow")    (cond       ((null typename))       ((or (not (litatom typename))            (eq typename '**dealloc**))        (error "Invalid type name" typename)))    (prog ((n 0)           unused           (offset 0)           (bit 0)           dlist reuse len fd)          (setq dlist (|for| s |in| fieldspecs                         |collect| (|create| spec                                          n _ (|add| n 1)                                          len _ (selectq s                                                    ((pointer xpointer)                                                          24)                                                    ((fixp floatp swappedfixp fullpointer                                                            swappedxpointer fullxpointer)                                                          bitspercell)                                                    (flag (setqq s flagbits)                                                          1)                                                    (byte (setqq s bits)                                                          bitsperbyte)                                                    (word (setqq s bits)                                                          bitsperword)                                                    (signedword (setqq s signedbits)                                                                bitsperword)                                                    (selectq (car (listp s))                                                        ((bits flagbits signedbits)                                                              (prog1 (cadr s)                                                                    (setq s (car s))))                                                        (error "invalid field spec: " s)))                                          fd _                                          (|create| |FldDsc|                                                 |fdTypeName| _ typename                                                 |fdType| _ s                                                 |fdOffset| _ nil))))          (|for| s |in| dlist             |do|             (|replace| |fdOffset| |of| (setq fd (|fetch| fd |of| s))                |with|                (selectq (|fetch| |fdType| |of| fd)                    ((pointer xpointer)                          (cond                            ((and typename                                  (|find| x |in| unused                                     |suchthat| (and (eq 0 (logand (car x)                                                                  1))                                                     (igeq (caddr x)                                                           8)                                                     (eq (iplus (cadr x)                                                                (caddr x))                                                         bitsperword)                                                     (|find| y |in| unused                                                        |suchthat| (and (eq (car y)                                                                            (add1 (car x)))                                                                        (eq (caddr y)                                                                            bitsperword))))))                                                             (* \; "unused 24 bit quantity")                                                             (* \; "this case not implemented yet")                             ))                         (cond                            ((igreaterp bit 8)               (* \;                                                              "Less than 8 bits left in this word")                             (\\reuseto bitsperword)))                         (cond                            ((oddp offset wordspercell)      (* \; "not on double word boundary")                             (\\reuseto bitsperword)))                         (cond                            ((neq bit 8)                             (\\reuseto 8 (eq bit 0))))                         (setq bit 0)                         (prog1 offset (|add| offset wordspercell)))                    ((fixp swappedfixp floatp swappedxpointer)                                                              (* \; "32 bit quantities")                         (cond                            ((neq bit 0)                             (\\reuseto bitsperword)))                         (prog1 offset (|add| offset wordspercell)))                    ((fullpointer fullxpointer)              (* \;                                                              "32 bit doubleword-aligned quantities")                         (cond                            ((neq bit 0)                             (\\reuseto bitsperword)))                         (cond                            ((oddp offset wordspercell)                             (\\reuseto bitsperword)))                         (prog1 offset (|add| offset wordspercell)))                    ((bits flagbits signedbits)                          (setq len (|fetch| len |of| s))                         (cond                            ((and typename (setq reuse (|find| x |in| unused                                                          |suchthat| (ileq len (caddr x)))))                             (rplaca (cddr reuse)                                    (idifference (car (cddr reuse))                                           len))                             (|replace| |fdType| |of| fd |with| (cons (|fetch| |fdType| |of| fd)                                                                      (|MakeBitField| (cadr reuse)                                                                             len)))                             (|add| (cadr reuse)                                    len)                             (car reuse))                            ((igreaterp len bitsperword)     (* \;                                                  "more than 1 word --- Must right justify first word")                             (setq len (idifference len bitsperword))                             (cond                                ((igreaterp len (idifference bitsperword bit))                                 (\\reuseto bitsperword)))                             (cond                                ((neq (idifference bitsperword bit)                                      len)                                 (\\reuseto (idifference bitsperword len))))                             (|replace| |fdType| |of| fd |with| (cons 'longbits (|MakeBitField|                                                                                 bit len)))                             (setq bit 0)                             (prog1 offset (|add| offset 2)))                            (t (cond                                  ((igreaterp len (idifference bitsperword bit))                                   (\\reuseto bitsperword)))                               (|replace| |fdType| |of| fd |with| (cons (|fetch| |fdType|                                                                           |of| fd)                                                                        (|MakeBitField| bit len)))                               (|add| bit len)                               (prog1 offset (cond                                                ((eq bit bitsperword)                                                 (setq bit 0)                                                 (|add| offset 1)))))))                    (shouldnt))))          (cond             (typename (cond                          ((neq bit 0)                           (\\reuseto bitsperword)))                    (|while| (oddp offset wordspercell) |do| (|add| offset 1))                    (cond                       ((igreaterp offset |\\MDSIncrement|)                        (error typename "DATATYPE TOO BIG")))))          (return (cons offset (mapcar dlist (function (lambda (x)                                                         (|fetch| fd |of| x)))))))))(\\reuseto  (lambda (n flg)                                            (* \; "Edited 18-May-87 17:11 by Snow")    (setq n (idifference n bit))    (cond       ((neq n 0)        (cond           ((and (null typename)                 (not flg))            (error "Block/datatype field not alligned properly" fd)))        (|push| unused (list offset bit n))))    (|add| bit n)    (cond       ((eq bit 16)        (setq bit 0)        (|add| offset 1)))))(\\typeglobalvariable  (lambda (typename varflg)                                  (* \; "Edited 18-May-87 17:14 by Snow")(* |;;;| "Returns a constant or a variable that contains the datatype number of TYPENAME.  It is used when compiling type tests and assigning datatypes.  If TYPENAME is a system type, it returns the number.  Otherwise it creates a variable name and puts it on GLOBALVARS.")(* |;;;| "This is a kludge that will go away when we have type resolution at load time.")(* |;;;| "If VARFLG is true, always returns a var, rather than a system constant.  This is another kludge for backward compatibility.")    (or (and (not varflg)             (|for| entry |in| \\built-in-system-types |as| i |from| 1                |when| (eq typename (car entry)) |do| (return i)))        (let ((var (type-variable-from-type-name typename)))             (cond                ((not (or (fmemb var globalvars)                          (getprop var 'globalvar)))                 (putprop var 'globalvar t)))             var)))))(CL:DEFUN TYPE-VARIABLE-FROM-TYPE-NAME (TYPE-NAME)(* |;;;| "Convert a symbol naming a type into the unique global variable that holds the number for that type.  This can be tricky during that portion of the init before packages have been turned on.")   (IF (NULL *PACKAGE*)       THEN              (* |;;| "Packages are, indeed, not on yet.  We must check the type-name symbol to see if it begins with a known init-time package prefix.  If so, we strip that off and put it back on the front.  The function NAMESTRING-CONVERSION-CLAUSE is from LLPACKAGE.")             (LET* ((BASE (|ffetch| (CL:SYMBOL PNAMEBASE) |of| TYPE-NAME))                    (LEN (|ffetch| (CL:SYMBOL PNAMELENGTH) |of| TYPE-NAME))                    (FATP (|ffetch| (CL:SYMBOL FATPNAMEP) |of| TYPE-NAME))                    (CLAUSE (NAMESTRING-CONVERSION-CLAUSE BASE 1 LEN FATP)))                   (COND                      ((NULL CLAUSE)                         (* \;                              "TYPE-NAME is homed in the  Interlisp Package. Nothing special to do.")                       (PACK* "" TYPE-NAME "TYPE#"))                      (T                                     (* \; "The symbol matched a clause.  We take the prefix off the front of the name and put it at the beginning.")                         (LET* ((PREFIX (CL:FIRST CLAUSE))                                (PREFIX-LENGTH (FFETCH (STRINGP LENGTH) OF PREFIX)))                               (PACK* PREFIX "" (SUBSTRING TYPE-NAME (CL:1+ PREFIX-LENGTH))                                      "TYPE#")))))     ELSE            (* |;;| "Packages are on; this is the normal case.")           (CL:INTERN (CONCAT "" (MKSTRING TYPE-NAME)                             "TYPE#")                  (CL:SYMBOL-PACKAGE TYPE-NAME))))(DEFINEQ(|BitFieldMask|  (lambda (fd)                                               (* \; "Edited 18-May-87 17:14 by Snow")    (sub1 (llsh 1 (|BitFieldWidth| fd)))))(|BitFieldShift|  (lambda (fd)                                               (* \; "Edited 18-May-87 17:14 by Snow")    (idifference 16 (iplus (|BitFieldFirst| fd)                           (|BitFieldWidth| fd)))))(|BitFieldShiftedMask|  (lambda (fd)                                               (* \; "Edited 18-May-87 17:15 by Snow")    (idifference (llsh 1 (idifference 16 (|BitFieldFirst| fd)))           (llsh 1 (idifference 16 (iplus (|BitFieldFirst| fd)                                          (|BitFieldWidth| fd)))))))(|MakeBitField|  (lambda (first width)                                      (* \; "Edited 18-May-87 17:15 by Snow")    (logor (llsh first 4)           (sub1 width))))(|BitFieldWidth|  (lambda (fd)                                               (* \; "Edited 18-May-87 17:16 by Snow")    (add1 (logand fd 15))))(|BitFieldFirst|  (lambda (fd)                                               (* \; "Edited 18-May-87 17:16 by Snow")    (lrsh fd 4))))(DEFOPTIMIZER FETCHFIELD (&REST X)                             (COMPILEDFETCHFIELD X))(DEFOPTIMIZER FFETCHFIELD (&REST X)                              (COMPILEDFETCHFIELD X T))(DEFOPTIMIZER REPLACEFIELD (&REST X)                               (COMPILEDREPLACEFIELD X))(DEFOPTIMIZER FREPLACEFIELD (&REST X)                                (COMPILEDREPLACEFIELD X T))(DEFOPTIMIZER REPLACEFIELDVAL (&REST ARGS)                                  (CONS '(OPENLAMBDA (DESCRIPTOR DATUM NEWVALUE)                                                (PROG1 DATUM (REPLACEFIELD DESCRIPTOR DATUM NEWVALUE)                                                       ))                                        ARGS))(DEFOPTIMIZER FREPLACEFIELDVAL (&REST ARGS)                                   (CONS '(OPENLAMBDA (DESCRIPTOR DATUM NEWVALUE)                                                 (PROG1 DATUM (FREPLACEFIELD DESCRIPTOR DATUM                                                                      NEWVALUE)))                                         ARGS))(DEFOPTIMIZER NCREATE (&REST X)                          (COMPILEDNCREATE X))(DEFOPTIMIZER \\DTEST (VALUE TYPE &ENVIRONMENT ENV)                          (COND                             ((AND (EQ (CAR TYPE)                                       'QUOTE)                                   (LITATOM (CADR TYPE)))                              (COND                                 ((FMEMB :3-BYTE (COMPILER::ENV-TARGET-ARCHITECTURE ENV))                                  `((OPCODES DTEST 0 0 (ATOM . ,(CADR TYPE)))                                    ,VALUE))                                 (T `((OPCODES DTEST 0 (ATOM . ,(CADR TYPE)))                                      ,VALUE))))                             (T 'IGNOREMACRO)))(PUTPROPS \\TESTBITS DMACRO ((X N FD)                                     (NEQ 0 (\\GETBITS X N FD))))(DEFINEQ(compiledfetchfield  (lambda (x fastflg)                                        (* \; "Edited 18-May-87 17:32 by Snow")    (cond       ((eq (car (listp (car x)))            'quote)        ((lambda (descriptor datum)           (prog (typename)                 (cond                    ((and (not fastflg)                          (setq typename (|fetch| |fdTypeName| |of| descriptor)))                     (setq datum (list (function \\dtest)                                       datum                                       (kwote typename)))))                 (return                  (selectq (|fetch| |fdType| |of| descriptor)                      ((pointer xpointer fullpointer fullxpointer)                            (list '\\getbaseptr datum (|fetch| |fdOffset| |of| descriptor)))                      (swappedxpointer                            `((openlambda (d)                                    (\\vag2 (\\getbase d ,(add1 (|fetch| |fdOffset| |of| descriptor))                                                   )                                           (\\getbase d ,(|fetch| |fdOffset| |of| descriptor))))                             ,datum))                      (floatp `(\\getbasefloatp ,datum ,(|fetch| |fdOffset| |of| descriptor)))                      (fixp `(\\getbasefixp ,datum ,(|fetch| |fdOffset| |of| descriptor)))                      (swappedfixp `((openlambda (d)                                            (\\makenumber (\\getbase d                                                                 ,(add1 (|fetch| |fdOffset|                                                                           |of| descriptor)))                                                   (\\getbase d ,(|fetch| |fdOffset| |of| descriptor)                                                          )))                                     ,datum))                      (prog ((ft (|fetch| |fdType| |of| descriptor))                             (off (|fetch| |fdOffset| |of| descriptor)))                            (return (selectq (car ft)                                        (bits (list '\\getbits datum off (cdr ft)))                                        (signedbits `(signed (\\getbits ,datum ,off                                                                    ,(cdr ft))                                                            ,(|BitFieldWidth| (cdr ft))))                                        (flagbits (list '\\testbits datum off (cdr ft)))                                        (longbits `((openlambda (d)                                                           (\\makenumber (\\getbits                                                                          d                                                                          ,off                                                                          ,(cdr ft))                                                                  (\\getbase d ,(add1 off))))                                                    ,datum))                                        (shouldnt))))))))         (cadar x)         (cadr x)))       (t 'ignoremacro))))(compiledreplacefield  (lambda (x fastflg rplvalflg)                              (* \; "Edited 18-May-87 17:29 by Snow")                    (* |;;| "compile code for replacing field values.  Goes to great length to ensure that the coerced value is returned")    (cond       ((eq (car (listp (car x)))            'quote)        ((lambda (descriptor datum newvalue)           (prog ((typename (|fetch| |fdTypeName| |of| descriptor))                  (ft (|fetch| |fdType| |of| descriptor))                  (offset (|fetch| |fdOffset| |of| descriptor)))                 (cond                    ((and (not fastflg)                          typename)                     (setq datum (list (function \\dtest)                                       datum                                       (kwote typename)))))                 (return (selectq ft                             ((pointer fullpointer)                                   (list (function \\rplptr)                                        datum offset newvalue))                             (xpointer (list (function putbaseptrx)                                             datum offset newvalue))                             (fullxpointer (list '\\putbaseptr datum offset newvalue))                             (swappedxpointer                                   `((openlambda (d r)                                           (\\putbase d ,offset (\\loloc r))                                           (\\putbase d ,(add1 offset) (\\hiloc r))                                           r)                                    ,datum                                    ,newvalue))                             (fixp `(\\putbasefixp ,datum ,offset ,newvalue))                             (swappedfixp `(\\putswappedfixp (\\addbase ,datum ,offset)                                                  ,newvalue))                             (floatp `(\\putbasefloatp ,datum ,offset ,newvalue))                             (selectq (car ft)                                 (bits (list '\\putbits datum offset (cdr ft)                                             newvalue))                                 (longbits (list (subpair '(offset ft) (list offset (cdr ft))                                                        '(openlambda (d v)                                                                (\\putbits d offset ft (\\hinum                                                                                        v))                                                                (\\putbase d (add1 offset)                                                                       (\\lonum v))                                                                v))                                                 datum newvalue))                                 (signedbits `(signed (\\putbits ,datum ,offset ,(cdr ft)                                                             (unsigned ,newvalue                                                                    ,(|BitFieldWidth| (cdr ft))))                                                     ,(|BitFieldWidth| (cdr ft))))                                 (flagbits `(neq (\\putbits ,datum ,offset ,(cdr ft)                                                        (cond                                                           (,newvalue ,(|BitFieldMask| (cdr ft)))                                                           (t 0)))                                                 0))                                 (return 'ignoremacro))))))         (cadar x)         (cadr x)         (caddr x)))       (t 'ignoremacro))))(compiledncreate  (lambda (x)                                                (* \; "Edited 18-May-87 17:34 by Snow")(* |;;;| "compiles code for NCREATEs.  Exists to eliminate the call to \\TYPENUMBERFROMNAME.")    (cond       ((eq (car (listp (car x)))            'quote)        (cond           ((null (cadr x))            (list 'createcell (\\typeglobalvariable (cadar x))))           (t (list 'ncreate2 (\\typeglobalvariable (cadar x))                    (cadr x)))))       (t 'ignoremacro)))))(DECLARE\: DONTCOPY (* "FOLLOWING DEFINITIONS EXPORTED")(DECLARE\: EVAL@COMPILE(RECORD |FldDsc| (|fdTypeName| |fdOffset| |fdType|)))(* "END EXPORTED DEFINITIONS"))(RPAQQ DATATYPEFIELDTYPES       ((FLOATP 0.0)        (FIXP 0)        (SWAPPEDFIXP 0)        (POINTER NIL)        (XPOINTER NIL)        (FULLPOINTER NIL)        (FULLXPOINTER NIL)        (SWAPPEDXPOINTER NIL)        (FLAG NIL)        (BYTE 0)        (WORD 0)        (SIGNEDWORD 0)))(* \; "Macros which convert a record access form into an address-generating form")(DECLARE\: EVAL@COMPILE (PUTPROPS LOCF DMACRO (X (TRANSLATE.LOCF X)))(PUTPROPS INDEXF DMACRO (X (TRANSLATE.LOCF X T))))(DEFINEQ(translate.locf  (lambda (args indexonly)                                   (* \; "Edited 18-May-87 17:35 by Snow")    (declare (globalvars clisparray))    (prog ((form (mkprogn args))           newform offset spec)      retry          (selectq (car (listp form))              (progn (cond                        ((not (cddr form))                   (* \;                                                 "get rid of extra PROGN's inserted by record package")                         (setq form (cadr form))                         (go retry))))              ((fetchfield ffetchfield)                    (cond                      ((and (setq offset (listp (cadr form)))                            (eq (car offset)                                'quote)                            (setq offset (cadr (setq spec (cadr offset))))                            (fixp offset))                       (return (cond                                  (indexonly offset)                                  ((eq offset 0)                                   (caddr form))                                  (t (setq form (caddr form))                    (* |;;| "loop in order to merge \\ADDBASEs.  Should actually be done by compiler optimization, but apparently that is currently broken")                                     (|repeatwhile| (selectq (car (listp form))                                                        (progn (cond                                                                  ((null (cddr form))                                                                   (setq form (cadr form))                                                                   t)))                                                        ((addbase \\addbase)                                                              (cond                                                                ((fixp (caddr form))                                                                 (|add| offset (caddr form))                                                                 (setq form (cadr form))                                                                 t)))                                                        (cond                                                           ((neq (setq newform (cl:macroexpand-1                                                                                form))                                                                 form)                                                            (setq form newform)                                                            t))))                                     (list '\\addbase form offset)))))))              (cond                 ((neq form (setq form (cl:macroexpand-1 form)))                  (go retry))))          (error "LOCF Can't figure out this argument" args)          (return 'ignoremacro)))))(DECLARE\: DOEVAL@COMPILE DONTCOPY(LOCALVARS . T))(PUTPROPS DTDECLARE FILETYPE CL:COMPILE-FILE)(PUTPROPS DTDECLARE COPYRIGHT ("Venue & Xerox Corporation" 1981 1982 1983 1984 1985 1986 1987 1990))(DECLARE\: DONTCOPY  (FILEMAP (NIL (1498 14264 (/DECLAREDATATYPE 1508 . 2091) (DECLAREDATATYPE 2093 . 3723) (TRANSLATE.DATATYPE 3725 . 12685) (\\REUSETO 12687 . 13173) (\\TYPEGLOBALVARIABLE 13175 . 14262)) (16139 17411 (|BitFieldMask| 16149 . 16325) (|BitFieldShift| 16327 . 16565) (|BitFieldShiftedMask| 16567 . 16911) (|MakeBitField| 16913 . 17099) (|BitFieldWidth| 17101 . 17259) (|BitFieldFirst| 17261 . 17409)) (19380 26943 (COMPILEDFETCHFIELD 19390 . 22672) (COMPILEDREPLACEFIELD 22674 . 26407) (COMPILEDNCREATE 26409 . 26941)) (27661 30635 (TRANSLATE.LOCF 27671 . 30633)))))STOP