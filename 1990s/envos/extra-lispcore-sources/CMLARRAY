(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(FILECREATED "16-May-90 12:57:14" |{DSK}<usr>local>lde>lispcore>sources>CMLARRAY.;2| 113866       |changes| |to:|  (FILES CMLARRAY-SUPPORT)                       (VARS CMLARRAYCOMS)      |previous| |date:| " 8-May-88 15:29:37" |{DSK}<usr>local>lde>lispcore>sources>CMLARRAY.;1|); Copyright (c) 1986, 1987, 1988, 1990 by Venue & Xerox Corporation.  All rights reserved.(PRETTYCOMPRINT CMLARRAYCOMS)(RPAQQ CMLARRAYCOMS       (        (* |;;| "Contains table driven macros")        (DECLARE\: DONTCOPY EVAL@COMPILE (EXPORT (FILES (SYSLOAD FROM VALUEOF DIRECTORIES)                                                        CMLARRAY-SUPPORT)))                (* |;;| "User entry points")        (FUNCTIONS CL:ADJUST-ARRAY CL:ADJUSTABLE-ARRAY-P CL:ARRAY-DIMENSION CL:ARRAY-DIMENSIONS                CL:ARRAY-ELEMENT-TYPE CL:ARRAY-HAS-FILL-POINTER-P ARRAY-NEEDS-INDIRECTION-P                CL:ARRAY-RANK CL:ARRAY-TOTAL-SIZE BIT CL:BIT-AND CL:BIT-ANDC1 CL:BIT-ANDC2 BIT-ARRAY-P               CL:BIT-EQV CL:BIT-IOR CL:BIT-NAND CL:BIT-NOR CL:BIT-NOT CL:BIT-ORC1 CL:BIT-ORC2                CL:BIT-VECTOR-P CL:BIT-XOR CL:CHAR CL:ARRAYP CL:STRINGP COPY-ARRAY COPY-VECTOR                DISPLACED-ARRAY-P EQUAL-DIMENSIONS-P EXTENDABLE-ARRAY-P FILL-ARRAY CL:FILL-POINTER                FILL-VECTOR CL:MAKE-ARRAY MAKE-VECTOR READ-ONLY-ARRAY-P CL:SBIT CL:SCHAR                SET-FILL-POINTER SIMPLE-ARRAY-P CL:SIMPLE-BIT-VECTOR-P CL:SIMPLE-STRING-P                CL:SIMPLE-VECTOR-P STRING-ARRAY-P CL:SVREF VECTOR-LENGTH CL:VECTOR-POP CL:VECTOR-PUSH               CL:VECTOR-PUSH-EXTEND CL:VECTORP)        (FNS CL:AREF CL:ARRAY-IN-BOUNDS-P CL:ARRAY-ROW-MAJOR-INDEX ASET CL:VECTOR)                (* |;;| "New CLtL array functions")        (COMS (FNS XCL:ROW-MAJOR-AREF CL::ROW-MAJOR-ASET)              (SETFS XCL:ROW-MAJOR-AREF))                (* |;;| "Setfs")        (SETFS CL:AREF BIT CL:CHAR CL:FILL-POINTER CL:SBIT CL:SCHAR CL:SVREF)                (* |;;| "Optimizers")        (FUNCTIONS %AREF-EXPANDER %ASET-EXPANDER)        (OPTIMIZERS CL:AREF ASET BIT CL:CHAR CL:SBIT CL:SCHAR CL:SVREF)                (* |;;| "Vars etc")                                                             (* \;                                                            "*PRINT-ARRAY* is defined in APRINT")        (VARIABLES CL:ARRAY-RANK-LIMIT CL:ARRAY-TOTAL-SIZE-LIMIT CL:ARRAY-DIMENSION-LIMIT                *DEFAULT-PUSH-EXTENSION-SIZE*)                (* |;;| "Run-time support")        (FNS %ALTER-AS-DISPLACED-ARRAY %ALTER-AS-DISPLACED-TO-BASE-ARRAY %AREF0 %AREF1 %AREF2              %ARRAY-BASE %ARRAY-CONTENT-INITIALIZE %ARRAY-ELEMENT-INITIALIZE %ARRAY-OFFSET              %ARRAY-TYPE-NUMBER %ASET0 %ASET1 %ASET2 %CHECK-SEQUENCE-DIMENSIONS %COPY-TO-NEW-ARRAY              %DO-LOGICAL-OP %EXTEND-ARRAY %FAST-COPY-BASE %FAT-STRING-ARRAY-P              %FILL-ARRAY-FROM-SEQUENCE %FLATTEN-ARRAY %MAKE-ARRAY-WRITEABLE %MAKE-DISPLACED-ARRAY              %MAKE-GENERAL-ARRAY %MAKE-ONED-ARRAY %MAKE-STRING-ARRAY-FAT %MAKE-TWOD-ARRAY %TOTAL-SIZE             SHRINK-VECTOR)                                                             (* \; "For Interlisp string hack")        (FNS %SET-ARRAY-OFFSET %SET-ARRAY-TYPE-NUMBER)                                                             (* \; "Low level predicates")        (FNS %ONED-ARRAY-P %TWOD-ARRAY-P %GENERAL-ARRAY-P %THIN-STRING-ARRAY-P)        (OPTIMIZERS %ONED-ARRAY-P %TWOD-ARRAY-P %GENERAL-ARRAY-P)                                                             (* \;                                                            "Real record def's on cmlarray-support")        (INITRECORDS GENERAL-ARRAY ONED-ARRAY TWOD-ARRAY)        (SYSRECORDS GENERAL-ARRAY ONED-ARRAY TWOD-ARRAY)        (PROP DOPVAL %AREF1 %AREF2 %ASET1 %ASET2)                (* |;;| "I/O")        (FNS %DEFPRINT-ARRAY %DEFPRINT-BITVECTOR %DEFPRINT-GENERIC-ARRAY %DEFPRINT-VECTOR              %DEFPRINT-STRING %PRINT-ARRAY-CONTENTS)        (P (DEFPRINT 'ONED-ARRAY '%DEFPRINT-VECTOR)           (DEFPRINT 'TWOD-ARRAY '%DEFPRINT-ARRAY)           (DEFPRINT 'GENERAL-ARRAY '%DEFPRINT-ARRAY))                (* |;;| "Needed at run time. low level functions for accessing, setting, and allocating raw storage. also includes cml type to typenumber converters")        (FNS %ARRAY-READ %ARRAY-WRITE %CML-TYPE-TO-TYPENUMBER %GET-CANONICAL-CML-TYPE              %GET-ENCLOSING-SIGNED-BYTE %GET-ENCLOSING-UNSIGNED-BYTE %MAKE-ARRAY-STORAGE              %REDUCE-INTEGER %REDUCE-MOD %SLOW-ARRAY-READ %SLOW-ARRAY-WRITE)        (OPTIMIZERS %ARRAY-READ %ARRAY-WRITE)                (* |;;| "Compiler options")        (DECLARE\: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY (LOCALVARS . T))        (PROP FILETYPE CMLARRAY)        (DECLARE\: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS               (ADDVARS (NLAMA)                      (NLAML)                      (LAMA CL:VECTOR ASET CL:ARRAY-ROW-MAJOR-INDEX CL:ARRAY-IN-BOUNDS-P CL:AREF)))))(* |;;| "Contains table driven macros")(DECLARE\: DONTCOPY EVAL@COMPILE (* "FOLLOWING DEFINITIONS EXPORTED")(FILESLOAD (SYSLOAD FROM VALUEOF DIRECTORIES)       CMLARRAY-SUPPORT)(* "END EXPORTED DEFINITIONS"))(* |;;| "User entry points")(CL:DEFUN CL:ADJUST-ARRAY (ADJUSTABLE-ARRAY DIMENSIONS &KEY (ELEMENT-TYPE NIL ELEMENT-TYPE-P)                                     (INITIAL-ELEMENT NIL INITIAL-ELEMENT-P)                                     (INITIAL-CONTENTS NIL INITIAL-CONTENTS-P)                                     (DISPLACED-TO NIL DISPLACED-TO-P)                                     (DISPLACED-TO-BASE NIL DISPLACED-TO-BASE-P)                                     (DISPLACED-INDEX-OFFSET 0 DISPLACED-INDEX-OFFSET-P)                                     (FILL-POINTER NIL FILL-POINTER-P)                                     FATP)   (* |;;| "Do something wonderfull")   (CL:IF (NOT (EXTENDABLE-ARRAY-P ADJUSTABLE-ARRAY))          (CL:ERROR "Not an adjustable or extendable array: ~S" ADJUSTABLE-ARRAY))   (CL:IF (NOT (CL:LISTP DIMENSIONS))       (SETQ DIMENSIONS (LIST DIMENSIONS)))   (CL:IF (CL:DOLIST (DIM DIMENSIONS NIL)              (CL:IF (OR (< DIM 0)                         (>= DIM CL:ARRAY-DIMENSION-LIMIT))                     (RETURN T)))          (CL:ERROR "Dimensions out of bounds ~S" DIMENSIONS))   (LET ((ADJUSTABLE-ARRAY-ELEMENT-TYPE (CL:ARRAY-ELEMENT-TYPE ADJUSTABLE-ARRAY))         (NELTS (%TOTAL-SIZE DIMENSIONS))         (RANK (LENGTH DIMENSIONS))         (EXTENDABLE-P (NOT (CL:ADJUSTABLE-ARRAY-P ADJUSTABLE-ARRAY))))        (* |;;| "Consistency checks")        (CL:IF (>= RANK CL:ARRAY-RANK-LIMIT)               (CL:ERROR "Too many dimensions: ~A" RANK))        (CL:IF (>= NELTS CL:ARRAY-TOTAL-SIZE-LIMIT)               (CL:ERROR "Too many elements: ~A" NELTS))        (CL:IF (NOT (EQ RANK (CL:ARRAY-RANK ADJUSTABLE-ARRAY)))               (CL:ERROR "Rank mismatch: ~S" DIMENSIONS))        (CL:IF ELEMENT-TYPE-P            (CL:IF (NOT (EQUAL ELEMENT-TYPE ADJUSTABLE-ARRAY-ELEMENT-TYPE))                   (CL:ERROR "ADJUSTABLE-ARRAY not of specified element-type: ~A" ELEMENT-TYPE))            (SETQ ELEMENT-TYPE ADJUSTABLE-ARRAY-ELEMENT-TYPE))        (CL:IF (AND FILL-POINTER-P (NULL FILL-POINTER)                    (CL:ARRAY-HAS-FILL-POINTER-P ADJUSTABLE-ARRAY))               (CL:ERROR "ADJUSTABLE-ARRAY has fill pointer"))        (CL:IF (OR (AND DISPLACED-TO-P (OR INITIAL-ELEMENT-P INITIAL-CONTENTS-P DISPLACED-TO-BASE-P))                   (AND DISPLACED-TO-BASE-P (OR INITIAL-ELEMENT-P INITIAL-CONTENTS-P DISPLACED-TO-P))                   (AND FILL-POINTER-P FILL-POINTER (NOT (CL:ARRAY-HAS-FILL-POINTER-P                                                                 ADJUSTABLE-ARRAY)))                   (AND DISPLACED-INDEX-OFFSET-P (NOT (OR DISPLACED-TO-P DISPLACED-TO-BASE-P)))                   (AND INITIAL-ELEMENT-P INITIAL-CONTENTS-P))               (CL:ERROR "Inconsistent options to adjust-array"))        (CL:IF DISPLACED-TO-P            (COND               ((NOT (%ARRAYP DISPLACED-TO))                (CL:ERROR "Not displaced to an array: ~S" DISPLACED-TO))               ((NOT (EQUAL ADJUSTABLE-ARRAY-ELEMENT-TYPE (CL:ARRAY-ELEMENT-TYPE DISPLACED-TO)))                (CL:ERROR "Not displaced to an array of the same element-type:"))               ((> (+ DISPLACED-INDEX-OFFSET NELTS)                   (CL:ARRAY-TOTAL-SIZE DISPLACED-TO))                (CL:ERROR "More elements than displaced-to array"))))        (CL:IF FILL-POINTER            (COND               ((EQ FILL-POINTER T)                (SETQ FILL-POINTER NELTS))               ((NOT (<= 0 FILL-POINTER NELTS))                (CL:ERROR "Fill pointer out of bounds: ~A" FILL-POINTER)))            (CL:IF (CL:ARRAY-HAS-FILL-POINTER-P ADJUSTABLE-ARRAY)                (SETQ FILL-POINTER (MIN (CL:FILL-POINTER ADJUSTABLE-ARRAY)                                        NELTS))))        (CL:IF EXTENDABLE-P            (COND               ((OR DISPLACED-TO-P DISPLACED-TO-BASE-P)                (CL:ERROR "Cannot adjust an extendable array to be displaced"))               ((< NELTS (CL:ARRAY-TOTAL-SIZE ADJUSTABLE-ARRAY))                (CL:ERROR "Cannot extend an extendable array to have fewer elements"))))        (* |;;| "Specs ready, do the surgury")        (COND           (DISPLACED-TO-P (%ALTER-AS-DISPLACED-ARRAY ADJUSTABLE-ARRAY DIMENSIONS DISPLACED-TO                                   DISPLACED-INDEX-OFFSET FILL-POINTER))           (DISPLACED-TO-BASE-P (%ALTER-AS-DISPLACED-TO-BASE-ARRAY ADJUSTABLE-ARRAY DIMENSIONS                                        ELEMENT-TYPE DISPLACED-TO-BASE DISPLACED-INDEX-OFFSET                                        FILL-POINTER FATP))           (T (CL:IF (EQUAL (CL:ARRAY-DIMENSIONS ADJUSTABLE-ARRAY)                            DIMENSIONS)                  (CL:IF FILL-POINTER (SET-FILL-POINTER ADJUSTABLE-ARRAY FILL-POINTER))                  (LET ((NEW-ARRAY (CL:MAKE-ARRAY DIMENSIONS :ELEMENT-TYPE ELEMENT-TYPE :FATP                                          (%FAT-STRING-ARRAY-P ADJUSTABLE-ARRAY))))                       (COND                          (INITIAL-CONTENTS-P (%ARRAY-CONTENT-INITIALIZE NEW-ARRAY                                                      INITIAL-CONTENTS))                          (T (CL:IF INITIAL-ELEMENT-P (%ARRAY-ELEMENT-INITIALIZE NEW-ARRAY                                                              INITIAL-ELEMENT))                             (%COPY-TO-NEW-ARRAY (CL:ARRAY-DIMENSIONS ADJUSTABLE-ARRAY)                                    (%FLATTEN-ARRAY ADJUSTABLE-ARRAY)                                    0 DIMENSIONS (%FLATTEN-ARRAY NEW-ARRAY)                                    0)))                       (%EXTEND-ARRAY ADJUSTABLE-ARRAY NEW-ARRAY DIMENSIONS FILL-POINTER)))))        (* |;;| "Return the adjusted array")        ADJUSTABLE-ARRAY))(CL:DEFUN CL:ADJUSTABLE-ARRAY-P (ARRAY)   (CL:IF (%ARRAYP ARRAY)       (|fetch| (ARRAY-HEADER ADJUSTABLE-P) |of| ARRAY)       (CL:ERROR "Not an array: ~S" ARRAY)))(CL:DEFUN CL:ARRAY-DIMENSION (ARRAY DIMENSION)   (COND      ((%ONED-ARRAY-P ARRAY)       (CL:IF (EQ 0 DIMENSION)           (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| ARRAY)           (CL:ERROR "Dimension out of bounds: ~A" DIMENSION)))      ((%TWOD-ARRAY-P ARRAY)       (CASE DIMENSION           (0 (|ffetch| (TWOD-ARRAY BOUND0) |of| ARRAY))           (1 (|ffetch| (TWOD-ARRAY BOUND1) |of| ARRAY))           (T (CL:ERROR "Dimension out of bounds: ~A" DIMENSION))))      ((%GENERAL-ARRAY-P ARRAY)       (LET* ((DIMS (|ffetch| (GENERAL-ARRAY DIMS) |of| ARRAY))              (RANK (LENGTH DIMS)))             (CL:IF (NOT (< -1 DIMENSION RANK))                    (CL:ERROR "Dimension out of bounds: ~A" DIMENSION))             (CL:IF (EQ RANK 1)                 (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| ARRAY)                 (CL:NTH DIMENSION DIMS))))      (T (CL:ERROR "Not an array: ~S" ARRAY))))(CL:DEFUN CL:ARRAY-DIMENSIONS (ARRAY)   (COND      ((%ONED-ARRAY-P ARRAY)       (LIST (|ffetch| (ONED-ARRAY TOTAL-SIZE) |of| ARRAY)))      ((%TWOD-ARRAY-P ARRAY)       (LIST (|ffetch| (TWOD-ARRAY BOUND0) |of| ARRAY)             (|ffetch| (TWOD-ARRAY BOUND1) |of| ARRAY)))      ((%GENERAL-ARRAY-P ARRAY)       (|ffetch| (GENERAL-ARRAY DIMS) |of| ARRAY))      (T (CL:ERROR "Not an array: ~S" ARRAY))))(CL:DEFUN CL:ARRAY-ELEMENT-TYPE (ARRAY)   (CL:IF (%ARRAYP ARRAY)       (%TYPENUMBER-TO-CML-TYPE (%ARRAY-TYPE-NUMBER ARRAY))       (CL:ERROR "Not an array: ~S" ARRAY)))(CL:DEFUN CL:ARRAY-HAS-FILL-POINTER-P (ARRAY)   (CL:IF (%ARRAYP ARRAY)       (|fetch| (ARRAY-HEADER FILL-POINTER-P) |of| ARRAY)       (CL:ERROR "Not an array: ~S" ARRAY)))(CL:DEFUN ARRAY-NEEDS-INDIRECTION-P (ARRAY)   (COND      ((OR (%ONED-ARRAY-P ARRAY)           (%TWOD-ARRAY-P ARRAY))       NIL)      ((%GENERAL-ARRAY-P ARRAY)       (|fetch| (ARRAY-HEADER INDIRECT-P) |of| ARRAY))      (T (CL:ERROR "Not an array: ~S" ARRAY))))(CL:DEFUN CL:ARRAY-RANK (ARRAY)   (COND      ((%ONED-ARRAY-P ARRAY)       1)      ((%TWOD-ARRAY-P ARRAY)       2)      ((%GENERAL-ARRAY-P ARRAY)       (LENGTH (|ffetch| (GENERAL-ARRAY DIMS) |of| ARRAY)))      (T (CL:ERROR "Not an array: ~S" ARRAY))))(CL:DEFUN CL:ARRAY-TOTAL-SIZE (ARRAY)   (CL:IF (%ARRAYP ARRAY)       (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| ARRAY)       (CL:ERROR "Not an array: ~S" ARRAY)))(CL:DEFUN BIT (BIT-ARRAY &REST INDICES)   (CL:ASSERT (TYPEP BIT-ARRAY '(CL:ARRAY BIT))          (BIT-ARRAY)          "Not a bit-array: ~S" BIT-ARRAY)   (CL:APPLY #'CL:AREF BIT-ARRAY INDICES))(CL:DEFUN CL:BIT-AND (BIT-ARRAY1 BIT-ARRAY2 &OPTIONAL BIT-RESULT)   (%EXPAND-BIT-OP AND BIT-ARRAY1 BIT-ARRAY2 BIT-RESULT))(CL:DEFUN CL:BIT-ANDC1 (BIT-ARRAY1 BIT-ARRAY2 &OPTIONAL BIT-RESULT)   (%EXPAND-BIT-OP ANDC1 BIT-ARRAY1 BIT-ARRAY2 BIT-RESULT))(CL:DEFUN CL:BIT-ANDC2 (BIT-ARRAY1 BIT-ARRAY2 &OPTIONAL BIT-RESULT)   (%EXPAND-BIT-OP ANDC2 BIT-ARRAY1 BIT-ARRAY2 BIT-RESULT))(CL:DEFUN BIT-ARRAY-P (ARRAY)   (AND (%ARRAYP ARRAY)        (|fetch| (ARRAY-HEADER BIT-P) |of| ARRAY)))(CL:DEFUN CL:BIT-EQV (BIT-ARRAY1 BIT-ARRAY2 &OPTIONAL BIT-RESULT)   (%EXPAND-BIT-OP EQV BIT-ARRAY1 BIT-ARRAY2 BIT-RESULT))(CL:DEFUN CL:BIT-IOR (BIT-ARRAY1 BIT-ARRAY2 &OPTIONAL BIT-RESULT)   (%EXPAND-BIT-OP IOR BIT-ARRAY1 BIT-ARRAY2 BIT-RESULT))(CL:DEFUN CL:BIT-NAND (BIT-ARRAY1 BIT-ARRAY2 &OPTIONAL BIT-RESULT)   (%EXPAND-BIT-OP NAND BIT-ARRAY1 BIT-ARRAY2 BIT-RESULT))(CL:DEFUN CL:BIT-NOR (BIT-ARRAY1 BIT-ARRAY2 &OPTIONAL BIT-RESULT)   (%EXPAND-BIT-OP NOR BIT-ARRAY1 BIT-ARRAY2 BIT-RESULT))(CL:DEFUN CL:BIT-NOT (BIT-ARRAY &OPTIONAL RESULT-BIT-ARRAY)   (CL:IF (NOT (BIT-ARRAY-P BIT-ARRAY))          (CL:ERROR "BIT-ARRAY not a bit array"))   (COND      ((NULL RESULT-BIT-ARRAY)       (SETQ RESULT-BIT-ARRAY (CL:MAKE-ARRAY (CL:ARRAY-DIMENSIONS BIT-ARRAY)                                     :ELEMENT-TYPE                                     'BIT)))      ((EQ RESULT-BIT-ARRAY T)       (SETQ RESULT-BIT-ARRAY BIT-ARRAY))      ((NOT (AND (BIT-ARRAY-P RESULT-BIT-ARRAY)                 (EQUAL-DIMENSIONS-P BIT-ARRAY RESULT-BIT-ARRAY)))       (CL:ERROR "Illegal result array")))   (%DO-LOGICAL-OP 'NOT BIT-ARRAY RESULT-BIT-ARRAY)   RESULT-BIT-ARRAY)(CL:DEFUN CL:BIT-ORC1 (BIT-ARRAY1 BIT-ARRAY2 &OPTIONAL BIT-RESULT)   (%EXPAND-BIT-OP ORC1 BIT-ARRAY1 BIT-ARRAY2 BIT-RESULT))(CL:DEFUN CL:BIT-ORC2 (BIT-ARRAY1 BIT-ARRAY2 &OPTIONAL BIT-RESULT)   (%EXPAND-BIT-OP ORC2 BIT-ARRAY1 BIT-ARRAY2 BIT-RESULT))(CL:DEFUN CL:BIT-VECTOR-P (VECTOR)   (AND (%VECTORP VECTOR)        (|fetch| (ARRAY-HEADER BIT-P) |of| VECTOR)))(CL:DEFUN CL:BIT-XOR (BIT-ARRAY1 BIT-ARRAY2 &OPTIONAL BIT-RESULT)   (%EXPAND-BIT-OP XOR BIT-ARRAY1 BIT-ARRAY2 BIT-RESULT))(CL:DEFUN CL:CHAR (STRING INDEX)   (CL:ASSERT (TYPEP STRING 'STRING)          (STRING)          "Not a string: ~S" STRING)   (CL:AREF STRING INDEX))(CL:DEFUN CL:ARRAYP (ARRAY)   (%ARRAYP ARRAY))(CL:DEFUN CL:STRINGP (STRING)   (%STRINGP STRING))(CL:DEFUN COPY-ARRAY (FROM-ARRAY &OPTIONAL TO-ARRAY)   (CL:IF (NOT (%ARRAYP FROM-ARRAY))          (CL:ERROR "Not an array: ~S" FROM-ARRAY))   (COND      ((NULL TO-ARRAY)       (SETQ TO-ARRAY (CL:MAKE-ARRAY (CL:ARRAY-DIMENSIONS FROM-ARRAY)                             :ELEMENT-TYPE                             (CL:ARRAY-ELEMENT-TYPE FROM-ARRAY)                             :FATP                             (%FAT-STRING-ARRAY-P FROM-ARRAY))))      ((NOT (EQUAL-DIMENSIONS-P FROM-ARRAY TO-ARRAY))       (CL:ERROR "Dimensionality mismatch")))   (CL:IF (|fetch| (ARRAY-HEADER READ-ONLY-P) |of| TO-ARRAY)          (%MAKE-ARRAY-WRITEABLE TO-ARRAY))   (LET ((FROM-TYPE-NUMBER (%ARRAY-TYPE-NUMBER FROM-ARRAY))         (TO-TYPE-NUMBER (%ARRAY-TYPE-NUMBER TO-ARRAY)))        (CL:WHEN (AND (%FAT-CHAR-TYPE-P FROM-TYPE-NUMBER)                      (%THIN-CHAR-TYPE-P TO-TYPE-NUMBER))            (%MAKE-STRING-ARRAY-FAT TO-ARRAY)            (SETQ TO-TYPE-NUMBER (%ARRAY-TYPE-NUMBER TO-ARRAY)))        (%FAST-COPY-BASE (%ARRAY-BASE FROM-ARRAY)               (%ARRAY-OFFSET FROM-ARRAY)               FROM-TYPE-NUMBER               (%ARRAY-BASE TO-ARRAY)               (%ARRAY-OFFSET TO-ARRAY)               TO-TYPE-NUMBER               (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| FROM-ARRAY))        TO-ARRAY))(CL:DEFUN COPY-VECTOR (FROM-VECTOR TO-VECTOR &KEY (START1 0)                                 END1                                 (START2 0)                                 END2)   (LET ((FROM-LENGTH (VECTOR-LENGTH FROM-VECTOR))         (TO-LENGTH (VECTOR-LENGTH TO-VECTOR)))        (CL:IF (NULL END1)               (SETQ END1 FROM-LENGTH))        (CL:IF (NULL END2)               (SETQ END2 TO-LENGTH))        (CL:IF (NOT (<= 0 START1 END1 FROM-LENGTH))               (CL:ERROR "Bad subsequence for FROM-VECTOR"))        (CL:IF (NOT (<= 0 START2 END2 TO-LENGTH))               (CL:ERROR "Bad subsequence for TO-VECTOR"))        (CL:IF (|fetch| (ARRAY-HEADER READ-ONLY-P) |of| TO-VECTOR)               (%MAKE-ARRAY-WRITEABLE TO-VECTOR))        (LET ((SUBLEN1 (- END1 START1))              (SUBLEN2 (- END2 START2))              (FROM-TYPE-NUMBER (%ARRAY-TYPE-NUMBER FROM-VECTOR))              (TO-TYPE-NUMBER (%ARRAY-TYPE-NUMBER TO-VECTOR)))             (CL:WHEN (AND (%FAT-CHAR-TYPE-P FROM-TYPE-NUMBER)                           (%THIN-CHAR-TYPE-P TO-TYPE-NUMBER))                 (%MAKE-STRING-ARRAY-FAT TO-VECTOR)                 (SETQ TO-TYPE-NUMBER (%ARRAY-TYPE-NUMBER TO-VECTOR)))             (%FAST-COPY-BASE (%ARRAY-BASE FROM-VECTOR)                    (+ START1 (%ARRAY-OFFSET FROM-VECTOR))                    FROM-TYPE-NUMBER                    (%ARRAY-BASE TO-VECTOR)                    (+ START2 (%ARRAY-OFFSET TO-VECTOR))                    TO-TYPE-NUMBER                    (MIN SUBLEN1 SUBLEN2))             TO-VECTOR)))(CL:DEFUN DISPLACED-ARRAY-P (ARRAY)   (CL:IF (%ARRAYP ARRAY)       (|fetch| (ARRAY-HEADER DISPLACED-P) |of| ARRAY)       (CL:ERROR "Not an array: ~S" ARRAY)))(CL:DEFUN EQUAL-DIMENSIONS-P (ARRAY-1 ARRAY-2)   (COND      ((%ONED-ARRAY-P ARRAY-1)       (COND          ((%ONED-ARRAY-P ARRAY-2)           (EQ (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| ARRAY-1)               (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| ARRAY-2)))          ((%TWOD-ARRAY-P ARRAY-2)           NIL)          ((%GENERAL-ARRAY-P ARRAY-2)           (AND (EQ 1 (LENGTH (|ffetch| (GENERAL-ARRAY DIMS) |of| ARRAY-2)))                (EQ (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| ARRAY-1)                    (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| ARRAY-2))))          (T NIL)))      ((%TWOD-ARRAY-P ARRAY-1)       (COND          ((%ONED-ARRAY-P ARRAY-2)           NIL)          ((%TWOD-ARRAY-P ARRAY-2)           (AND (EQ (|ffetch| (TWOD-ARRAY BOUND0) |of| ARRAY-1)                    (|ffetch| (TWOD-ARRAY BOUND0) |of| ARRAY-2))                (EQ (|ffetch| (TWOD-ARRAY BOUND1) |of| ARRAY-1)                    (|ffetch| (TWOD-ARRAY BOUND1) |of| ARRAY-2))))          ((%GENERAL-ARRAY-P ARRAY-2)           (LET ((DIMS (|ffetch| (GENERAL-ARRAY DIMS) |of| ARRAY-2)))                (AND (EQ 2 (LENGTH DIMS))                     (AND (EQ (|ffetch| (TWOD-ARRAY BOUND0) |of| ARRAY-1)                              (CAR DIMS))                          (EQ (|ffetch| (TWOD-ARRAY BOUND1) |of| ARRAY-1)                              (CADR DIMS))))))          (T NIL)))      ((%GENERAL-ARRAY-P ARRAY-1)       (LET ((DIMS (|ffetch| (GENERAL-ARRAY DIMS) |of| ARRAY-1)))            (COND               ((%ONED-ARRAY-P ARRAY-2)                (AND (EQ 1 (LENGTH DIMS))                     (EQ (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| ARRAY-1)                         (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| ARRAY-2))))               ((%TWOD-ARRAY-P ARRAY-2)                (AND (EQ 2 (LENGTH DIMS))                     (AND (EQ (CAR DIMS)                              (|ffetch| (TWOD-ARRAY BOUND0) |of| ARRAY-2))                          (EQ (CADR DIMS)                              (|ffetch| (TWOD-ARRAY BOUND1) |of| ARRAY-2)))))               ((%GENERAL-ARRAY-P ARRAY-2)                (EQUAL DIMS (|ffetch| (GENERAL-ARRAY DIMS) |of| ARRAY-2)))               (T NIL))))      (T NIL)))(CL:DEFUN EXTENDABLE-ARRAY-P (ARRAY)            (* *)   (COND      ((%ARRAYP ARRAY)       (|fetch| (ARRAY-HEADER EXTENDABLE-P) |of| ARRAY))      ((STRINGP ARRAY)       NIL)      (T (CL:ERROR "Not an array ~S" ARRAY))))(CL:DEFUN FILL-ARRAY (ARRAY VALUE)   (CL:IF (NOT (%ARRAYP ARRAY))          (CL:ERROR "Not an array: ~S" ARRAY))   (LET ((TOTAL-SIZE (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| ARRAY))         (TYPE-NUMBER (%ARRAY-TYPE-NUMBER ARRAY)))        (CL:IF (|fetch| (ARRAY-HEADER READ-ONLY-P) |of| ARRAY)               (%MAKE-ARRAY-WRITEABLE ARRAY))        (CL:WHEN (> TOTAL-SIZE 0)            (CL:WHEN (AND (%THIN-CHAR-TYPE-P TYPE-NUMBER)                          (%FAT-STRING-CHAR-P VALUE))                (%MAKE-STRING-ARRAY-FAT ARRAY)                (SETQ TYPE-NUMBER (%ARRAY-TYPE-NUMBER ARRAY)))            (CL:IF (NOT (%LLARRAY-TYPEP TYPE-NUMBER VALUE))                   (CL:ERROR "Value of incorrect type for this array: ~S" VALUE))            (LET ((BASE (%ARRAY-BASE ARRAY))                  (OFFSET (%ARRAY-OFFSET ARRAY)))        (* \; "Start things off")                 (%ARRAY-WRITE VALUE BASE TYPE-NUMBER OFFSET)                                                             (* \; "An overlapping blt")                 (%FAST-COPY-BASE BASE OFFSET TYPE-NUMBER BASE (CL:1+ OFFSET)                        TYPE-NUMBER                        (CL:1- TOTAL-SIZE))))        ARRAY))(CL:DEFUN CL:FILL-POINTER (VECTOR)   (COND      ((AND (OR (%ONED-ARRAY-P VECTOR)                (%GENERAL-ARRAY-P VECTOR))            (|fetch| (ARRAY-HEADER FILL-POINTER-P) |of| VECTOR))       (|fetch| (ARRAY-HEADER FILL-POINTER) |of| VECTOR))      ((%VECTORP VECTOR)       (CL:ERROR "vector has no fill pointer"))      (T (CL:ERROR "Not a vector: ~S" VECTOR))))(CL:DEFUN FILL-VECTOR (VECTOR VALUE &KEY (START 0)                                 END)   (CL:IF (NOT (%VECTORP VECTOR))          (CL:ERROR "Not a vector: ~S" VECTOR))   (LET ((TOTAL-SIZE (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| VECTOR)))        (CL:IF (NULL END)               (SETQ END TOTAL-SIZE))        (CL:IF (NOT (<= START END TOTAL-SIZE))               (CL:ERROR "Invalid subsequence" END))        (LET ((CNT (- END START))              (TYPE-NUMBER (%ARRAY-TYPE-NUMBER VECTOR)))             (CL:IF (|fetch| (ARRAY-HEADER READ-ONLY-P) |of| VECTOR)                    (%MAKE-ARRAY-WRITEABLE VECTOR))             (CL:WHEN (> CNT 0)                 (CL:WHEN (AND (%THIN-CHAR-TYPE-P TYPE-NUMBER)                               (%FAT-STRING-CHAR-P VALUE))                     (%MAKE-STRING-ARRAY-FAT VECTOR)                     (SETQ TYPE-NUMBER (%ARRAY-TYPE-NUMBER VECTOR)))                 (CL:IF (NOT (%LLARRAY-TYPEP TYPE-NUMBER VALUE))                        (CL:ERROR "Value of incorrect type for this array: ~S" VALUE))                 (LET ((BASE (%ARRAY-BASE VECTOR))                       (OFFSET (+ START (%ARRAY-OFFSET VECTOR))))                                                             (* \; "Start things off")                      (%ARRAY-WRITE VALUE BASE TYPE-NUMBER OFFSET)                                                             (* \; "An overlapping blt")                      (%FAST-COPY-BASE BASE OFFSET TYPE-NUMBER BASE (CL:1+ OFFSET)                             TYPE-NUMBER                             (CL:1- CNT))))             VECTOR)))(CL:DEFUN CL:MAKE-ARRAY (DIMENSIONS &KEY (ELEMENT-TYPE T)                                   (INITIAL-ELEMENT NIL INITIAL-ELEMENT-P)                                   (INITIAL-CONTENTS NIL INITIAL-CONTENTS-P)                                   (DISPLACED-TO NIL DISPLACED-TO-P)                                   (DISPLACED-TO-BASE NIL DISPLACED-TO-BASE-P)                                   (DISPLACED-INDEX-OFFSET 0 DISPLACED-INDEX-OFFSET-P)                                   FILL-POINTER ADJUSTABLE EXTENDABLE FATP READ-ONLY-P)   (* |;;| "String are by default thin unless FATP is T. DISPLACED-TO-BASE indicates displacement to a raw storage block. READ-ONLY-P indicates a read only array")   (CL:IF (NOT (CL:LISTP DIMENSIONS))       (SETQ DIMENSIONS (LIST DIMENSIONS)))   (CL:IF (CL:DOLIST (DIM DIMENSIONS NIL)              (CL:IF (OR (< DIM 0)                         (>= DIM CL:ARRAY-DIMENSION-LIMIT))                     (RETURN T)))          (CL:ERROR "Dimensions out of bounds: ~S" DIMENSIONS))   (LET ((RANK (LENGTH DIMENSIONS))         (NELTS (%TOTAL-SIZE DIMENSIONS))         ARRAY)        (* |;;| "Consistency checks")        (CL:IF (>= RANK CL:ARRAY-RANK-LIMIT)               (CL:ERROR "Too many dimensions: ~A" RANK))        (CL:IF (>= NELTS CL:ARRAY-TOTAL-SIZE-LIMIT)               (CL:ERROR "Too many elements: ~A" NELTS))        (CL:IF (OR (AND DISPLACED-TO-P (OR INITIAL-ELEMENT-P INITIAL-CONTENTS-P DISPLACED-TO-BASE-P))                   (AND DISPLACED-TO-BASE-P (OR INITIAL-ELEMENT-P INITIAL-CONTENTS-P DISPLACED-TO-P))                   (AND FILL-POINTER (NOT (EQ RANK 1)))                   (AND DISPLACED-INDEX-OFFSET-P (NOT (OR DISPLACED-TO-P DISPLACED-TO-BASE-P)))                   (AND INITIAL-ELEMENT-P INITIAL-CONTENTS-P)                   (AND ADJUSTABLE EXTENDABLE)                   (AND READ-ONLY-P (OR EXTENDABLE ADJUSTABLE)))               (CL:ERROR "Inconsistent options to make-array"))        (CL:IF DISPLACED-TO-P            (COND               ((NOT (%ARRAYP DISPLACED-TO))                (CL:ERROR "Not displaced to an array: ~s" DISPLACED-TO))               ((NOT (EQUAL (%GET-CANONICAL-CML-TYPE ELEMENT-TYPE)                            (CL:ARRAY-ELEMENT-TYPE DISPLACED-TO)))                (CL:ERROR "Not displaced to an array of the same element-type"))               ((> (+ DISPLACED-INDEX-OFFSET NELTS)                   (CL:ARRAY-TOTAL-SIZE DISPLACED-TO))                (CL:ERROR "Displaced array out of bounds"))))        (CL:IF FILL-POINTER            (COND               ((EQ FILL-POINTER T)                (SETQ FILL-POINTER NELTS))               ((NOT (AND (>= FILL-POINTER 0)                          (<= FILL-POINTER NELTS)))                (CL:ERROR "Fill pointer out of bounds ~A" FILL-POINTER))))        (* |;;| "Specs ready, make the array by case")        (SETQ ARRAY (COND                       (DISPLACED-TO-P (%MAKE-DISPLACED-ARRAY NELTS DIMENSIONS ELEMENT-TYPE                                               DISPLACED-TO DISPLACED-INDEX-OFFSET FILL-POINTER                                               READ-ONLY-P ADJUSTABLE EXTENDABLE))                       (DISPLACED-TO-BASE (CL:IF (OR (> RANK 1)                                                     ADJUSTABLE)                                              (%MAKE-GENERAL-ARRAY NELTS DIMENSIONS ELEMENT-TYPE                                                     FILL-POINTER FATP READ-ONLY-P ADJUSTABLE                                                      EXTENDABLE DISPLACED-TO-BASE                                                      DISPLACED-INDEX-OFFSET)                                              (%MAKE-ONED-ARRAY NELTS ELEMENT-TYPE FILL-POINTER                                                      FATP READ-ONLY-P EXTENDABLE DISPLACED-TO-BASE                                                      DISPLACED-INDEX-OFFSET)))                       ((AND (EQ RANK 1)                             (NOT ADJUSTABLE))                        (%MAKE-ONED-ARRAY NELTS ELEMENT-TYPE FILL-POINTER FATP READ-ONLY-P                                EXTENDABLE))                       ((AND (EQ RANK 2)                             (NOT ADJUSTABLE))                        (%MAKE-TWOD-ARRAY NELTS DIMENSIONS ELEMENT-TYPE FATP READ-ONLY-P                                EXTENDABLE))                       (T (%MAKE-GENERAL-ARRAY NELTS DIMENSIONS ELEMENT-TYPE FILL-POINTER FATP                                  READ-ONLY-P ADJUSTABLE EXTENDABLE))))        (* |;;| "Initialize the storage")        (COND           (INITIAL-CONTENTS-P (%ARRAY-CONTENT-INITIALIZE ARRAY INITIAL-CONTENTS))           (INITIAL-ELEMENT-P (%ARRAY-ELEMENT-INITIALIZE ARRAY INITIAL-ELEMENT)))        (* |;;| "Return the array")        ARRAY))(CL:DEFUN MAKE-VECTOR (SIZE &KEY (ELEMENT-TYPE T)                                (INITIAL-ELEMENT NIL INITIAL-ELEMENT-P)                                FATP)   (CL:IF (OR (< SIZE 0)              (>= SIZE CL:ARRAY-TOTAL-SIZE-LIMIT))          (CL:ERROR "Size out of bounds: ~s" SIZE))   (LET ((VECTOR (%MAKE-ONED-ARRAY SIZE ELEMENT-TYPE NIL FATP)))        (CL:IF INITIAL-ELEMENT-P (FILL-ARRAY VECTOR INITIAL-ELEMENT))        VECTOR))(CL:DEFUN READ-ONLY-ARRAY-P (ARRAY)   (CL:IF (%ARRAYP ARRAY)       (|fetch| (ARRAY-HEADER READ-ONLY-P) |of| ARRAY)       (CL:ERROR "Not an array: ~S" ARRAY)))(CL:DEFUN CL:SBIT (SIMPLE-BIT-ARRAY &REST INDICES)   (CL:ASSERT (TYPEP SIMPLE-BIT-ARRAY '(CL:SIMPLE-ARRAY BIT))          (SIMPLE-BIT-ARRAY)          "Not a bit-array: ~S" SIMPLE-BIT-ARRAY)   (CL:APPLY #'CL:AREF SIMPLE-BIT-ARRAY INDICES))(CL:DEFUN CL:SCHAR (SIMPLE-STRING INDEX)   (CL:ASSERT (TYPEP SIMPLE-STRING 'CL:SIMPLE-STRING)          (SIMPLE-STRING)          "Not a simple-string: ~S" SIMPLE-STRING)   (CL:AREF SIMPLE-STRING INDEX))(CL:DEFUN SET-FILL-POINTER (VECTOR NEWVALUE)   (COND      ((AND (OR (%ONED-ARRAY-P VECTOR)                (%GENERAL-ARRAY-P VECTOR))            (|fetch| (ARRAY-HEADER FILL-POINTER-P) |of| VECTOR))       (CL:IF (NOT (<= 0 NEWVALUE (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| VECTOR)))              (CL:ERROR "Fill pointer out of bounds: ~S" NEWVALUE))       (|replace| (ARRAY-HEADER FILL-POINTER) |of| VECTOR |with| NEWVALUE)       NEWVALUE)      ((%VECTORP VECTOR)       (CL:ERROR "Vector has no fill pointer"))      (T (CL:ERROR "Not a vector: ~S" VECTOR))))(CL:DEFUN SIMPLE-ARRAY-P (ARRAY)   (%SIMPLE-ARRAY-P ARRAY))(CL:DEFUN CL:SIMPLE-BIT-VECTOR-P (VECTOR)   (AND (%ONED-ARRAY-P VECTOR)        (|fetch| (ARRAY-HEADER SIMPLE-P) |of| VECTOR)        (|fetch| (ARRAY-HEADER BIT-P) |of| VECTOR)))(CL:DEFUN CL:SIMPLE-STRING-P (STRING)   (%SIMPLE-STRING-P STRING))(CL:DEFUN CL:SIMPLE-VECTOR-P (VECTOR)   (AND (%ONED-ARRAY-P VECTOR)        (|fetch| (ARRAY-HEADER SIMPLE-P) |of| VECTOR)        (EQ (CL:ARRAY-ELEMENT-TYPE VECTOR)            T)))(CL:DEFUN STRING-ARRAY-P (ARRAY)   (%CHAR-TYPE-P (%ARRAY-TYPE-NUMBER ARRAY)))(CL:DEFUN CL:SVREF (CL:SIMPLE-VECTOR INDEX)   (CL:ASSERT (TYPEP CL:SIMPLE-VECTOR 'CL:SIMPLE-VECTOR)          (CL:SIMPLE-VECTOR)          "Not a simple-vector: ~S" CL:SIMPLE-VECTOR)   (CL:AREF CL:SIMPLE-VECTOR INDEX))(CL:DEFUN VECTOR-LENGTH (VECTOR)   (CL:IF (%VECTORP VECTOR)       (|fetch| (ARRAY-HEADER FILL-POINTER) |of| VECTOR)       (CL:ERROR "Not a vector: ~s" VECTOR)))(CL:DEFUN CL:VECTOR-POP (VECTOR)   (COND      ((AND (OR (%ONED-ARRAY-P VECTOR)                (%GENERAL-ARRAY-P VECTOR))            (|fetch| (ARRAY-HEADER FILL-POINTER-P) |of| VECTOR))       (LET ((FILL-POINTER (|fetch| (ARRAY-HEADER FILL-POINTER) |of| VECTOR)))            (CL:IF (<= FILL-POINTER 0)                   (CL:ERROR "Can't pop from zero fill pointer"))            (SETQ FILL-POINTER (CL:1- FILL-POINTER))            (|replace| (ARRAY-HEADER FILL-POINTER) |of| VECTOR |with| FILL-POINTER)            (CL:AREF VECTOR FILL-POINTER)))      ((%VECTORP VECTOR)       (CL:ERROR "Vector has no fill pointer"))      (T (CL:ERROR "Not a vector: ~S" VECTOR))))(CL:DEFUN CL:VECTOR-PUSH (NEW-ELEMENT VECTOR)   (COND      ((AND (OR (%ONED-ARRAY-P VECTOR)                (%GENERAL-ARRAY-P VECTOR))            (|fetch| (ARRAY-HEADER FILL-POINTER-P) |of| VECTOR))       (LET ((FILL-POINTER (|fetch| (ARRAY-HEADER FILL-POINTER) |of| VECTOR)))            (CL:WHEN (< FILL-POINTER (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| VECTOR))                (ASET NEW-ELEMENT VECTOR FILL-POINTER)                (|replace| (ARRAY-HEADER FILL-POINTER) |of| VECTOR |with| (CL:1+                                                                                          FILL-POINTER                                                                                             ))                FILL-POINTER)))      ((%VECTORP VECTOR)       (CL:ERROR "Vector has no fill pointer"))      (T (CL:ERROR "Not a vector: ~S" VECTOR))))(CL:DEFUN CL:VECTOR-PUSH-EXTEND (NEW-ELEMENT VECTOR &OPTIONAL (EXTENSION-SIZE                                                                         *DEFAULT-PUSH-EXTENSION-SIZE*                                                                         ))   (* |;;| "Like VECTOR-PUSH except if VECTOR is adjustable -- in which case a push beyond (array-total-size VECTOR ) will call adjust-array")   (LET ((NEW-INDEX (CL:VECTOR-PUSH NEW-ELEMENT VECTOR)))        (CL:IF (NULL NEW-INDEX)            (COND               ((> EXTENSION-SIZE 0)                (CL:ADJUST-ARRAY VECTOR (+ (CL:ARRAY-TOTAL-SIZE VECTOR)                                           EXTENSION-SIZE))                (CL:VECTOR-PUSH NEW-ELEMENT VECTOR))               (T (CL:ERROR "Extension-size not greater than zero")))            NEW-INDEX)))(CL:DEFUN CL:VECTORP (VECTOR)   (%VECTORP VECTOR))(DEFINEQ(cl:aref  (lambda args                                           (* \; "Edited 11-Dec-87 15:32 by jop")    (cl:if (< args 1)           (cl:error "Aref takes at least one arg"))    (let ((array (arg args 1)))         (case args (1 (%aref0 array))               (2 (%aref1 array (arg args 2)))               (3 (%aref2 array (arg args 2)                         (arg args 3)))               (t (cond                     ((not (eq (cl:array-rank array)                               (cl:1- args)))                      (cl:error "Rank mismatch"))                     (t                     (* |;;| "If we've gotten this far ARRAY must be a general array")                                                             (* \; "Check indices in bounds")                        (cl:do ((i 2 (cl:1+ i))                                (dimlist (|ffetch| (general-array dims) |of| array)                                       (cdr dimlist))                                index)                               ((> i args))                               (setq index (arg args i))                               (cl:if (not (< -1 index (car dimlist)))                                      (cl:error "Index out of bounds: ~s" index)))                                                             (* \;                                                            "Now proceed to extract the element")                        (let ((row-major-index (cl:do ((i 2 (cl:1+ i))                                                       (dimlist (cdr (|ffetch| (general-array                                                                                    dims)                                                                        |of| array))                                                              (cdr dimlist))                                                       (total 0))                                                      ((eq i args)                                                       (+ total (arg args args)))                                                      (setq total (cl:* (car dimlist)                                                                        (+ total (arg args i))))))                              (base-array array))                             (%general-array-adjust-base base-array row-major-index)                             (%array-read (|fetch| (array-header base) |of| base-array)                                    (|fetch| (array-header type-number) |of| base-array)                                    (+ (%get-array-offset base-array)                                       row-major-index))))))))))(cl:array-in-bounds-p  (lambda args                                           (* \; "Edited 11-Dec-87 15:32 by jop")    (cl:if (< args 1)           (cl:error "Array-in-bounds-p takes at least one arg"))    (let ((array (arg args 1)))         (cl:if (eq (cl:array-rank array)                    (cl:1- args))                (%check-indices array 2 args)                (cl:error "Rank mismatch")))))(cl:array-row-major-index  (lambda args                                           (* \; "Edited 11-Dec-87 15:32 by jop")    (cl:if (< args 1)           (cl:error "Array-row-major-index takes at least one arg"))    (let ((array (arg args 1)))         (cond            ((not (eq (cl:array-rank array)                      (cl:1- args)))             (cl:error "Rank mismatch"))            ((not (%check-indices array 2 args))             (cl:error "Index out of bounds"))            (t (cl:do ((i 2 (cl:1+ i))                       (total 0))                      ((eq i args)                       (+ total (arg args args)))                      (setq total (cl:* (cl:array-dimension array (cl:1- i))                                        (+ total (arg args i))))))))))(aset  (lambda args                                           (* \; "Edited 11-Dec-87 15:33 by jop")    (cl:if (< args 2)           (cl:error "Aset takes at least two args"))    (let ((newvalue (arg args 1))          (array (arg args 2)))         (case args (2 (%aset0 newvalue array))               (3 (%aset1 newvalue array (arg args 3)))               (4 (%aset2 newvalue array (arg args 3)                         (arg args 4)))               (t (cond                     ((not (eq (cl:array-rank array)                               (- args 2)))                      (cl:error "Rank mismatch"))                     (t                                      (* \;                                            "If we've gotten this far array must be a general array")                    (* |;;| "Check indices")                        (cl:do ((i 3 (cl:1+ i))                                (dimlist (|ffetch| (general-array dims) |of| array)                                       (cdr dimlist))                                index)                               ((> i args))                               (setq index (arg args i))                               (cl:if (not (< -1 index (car dimlist)))                                      (cl:error "Index out of bounds: ~s" index)))                    (* |;;| "Now proceed to extract the element")                        (let ((row-major-index (cl:do ((i 3 (cl:1+ i))                                                       (dimlist (cdr (|ffetch| (general-array                                                                                    dims)                                                                        |of| array))                                                              (cdr dimlist))                                                       (total 0))                                                      ((eq i args)                                                       (+ total (arg args args)))                                                      (setq total (cl:* (car dimlist)                                                                        (+ total (arg args i))))))                              (base-array array))                             (%general-array-adjust-base base-array row-major-index)                             (let ((type-number (|fetch| (array-header type-number) |of|                                                                                        base-array)))                                  (cl:if (%check-not-writeable array type-number newvalue)                                         (cl:apply 'aset newvalue array                                                (cl:do ((i args (cl:1- i))                                                        lst)                                                       ((< i 1)                                                        lst)                                                       (setq lst (cons (arg args i)                                                                       lst))))                                         (%array-write newvalue (|fetch| (array-header base)                                                                       |of| base-array)                                                type-number                                                (+ (%get-array-offset base-array)                                                   row-major-index))))))))))))(CL:VECTOR  (LAMBDA ARGS                                               (* \; "Edited 18-Dec-86 18:09 by jop")    (LET ((VECTOR (%MAKE-ONED-ARRAY ARGS T)))         (CL:DOTIMES (I ARGS)                (ASET (ARG ARGS (CL:1+ I))                      VECTOR I))         VECTOR))))(* |;;| "New CLtL array functions")(DEFINEQ(xcl::row-major-aref  (lambda (array index)                                  (* \; "Edited 11-Dec-87 15:49 by jop")    (* |;;| "specialized aref for the one-d case. Also the punt function for the aref1 opcode.")    (cl:if (not (and (>= index 0)                     (< index (|fetch| (array-header total-size) |of| array))))           (cl:error "Index out of bounds: ~A" index)           (let ((base-array array))                (* |;;| "Now proceed to extract the element")                (%general-array-adjust-base base-array index)                (%array-read (|fetch| (array-header base) |of| base-array)                       (|fetch| (array-header type-number) |of| base-array)                       (+ (%get-array-offset base-array)                          index))))))(cl::row-major-aset  (lambda (array index newvalue)                         (* \; "Edited 11-Dec-87 15:54 by jop")    (cl:if (not (and (>= index 0)                     (< index (|fetch| (array-header total-size) |of| array))))           (cl:error "Index out of bounds: ~s" index)           (let ((row-major-index index)                 (base-array array))                    (* |;;| "Now proceed to extract the element")                (%general-array-adjust-base base-array row-major-index)                (let ((type-number (|fetch| (array-header type-number) |of| base-array)))                     (cl:if (%check-not-writeable array type-number newvalue)                            (cl::row-major-aset array index newvalue)                            (%array-write newvalue (|fetch| (array-header base) |of|                                                                                        base-array)                                   type-number                                   (+ (%get-array-offset base-array)                                      row-major-index)))))))))(CL:DEFSETF XCL:ROW-MAJOR-AREF CL::ROW-MAJOR-ASET)(* |;;| "Setfs")(CL:DEFSETF CL:AREF (ARRAY &REST INDICES) (NEWVALUE)   `(ASET ,NEWVALUE ,ARRAY ,@INDICES))(CL:DEFSETF BIT (ARRAY &REST INDICES) (NEWVALUE)   `(ASET ,NEWVALUE ,ARRAY ,@INDICES))(CL:DEFSETF CL:CHAR (ARRAY INDEX) (NEWVALUE)   `(ASET ,NEWVALUE ,ARRAY ,INDEX))(CL:DEFSETF CL:FILL-POINTER SET-FILL-POINTER)(CL:DEFSETF CL:SBIT (ARRAY &REST INDICES) (NEWVALUE)   `(ASET ,NEWVALUE ,ARRAY ,@INDICES))(CL:DEFSETF CL:SCHAR (ARRAY INDEX) (NEWVALUE)   `(ASET ,NEWVALUE ,ARRAY ,INDEX))(CL:DEFSETF CL:SVREF (ARRAY INDEX) (NEWVALUE)   `(ASET ,NEWVALUE ,ARRAY ,INDEX))(* |;;| "Optimizers")(CL:DEFUN %AREF-EXPANDER (ARRAY INDICES)   (CASE (LENGTH INDICES)       (1 `(%AREF1 ,ARRAY ,@INDICES))       (2 `(%AREF2 ,ARRAY ,@INDICES))       (T 'COMPILER:PASS)))(CL:DEFUN %ASET-EXPANDER (NEWVALUE ARRAY INDICES)   (CASE (LENGTH INDICES)       (1 `(%ASET1 ,NEWVALUE ,ARRAY ,@INDICES))       (2 `(%ASET2 ,NEWVALUE ,ARRAY ,@INDICES))       (T 'COMPILER:PASS)))(DEFOPTIMIZER CL:AREF (ARRAY &REST INDICES)                          (%AREF-EXPANDER ARRAY INDICES))(DEFOPTIMIZER ASET (NEWVALUE ARRAY &REST INDICES)                       (%ASET-EXPANDER NEWVALUE ARRAY INDICES))(DEFOPTIMIZER BIT (ARRAY &REST INDICES)                      (%AREF-EXPANDER ARRAY INDICES))(DEFOPTIMIZER CL:CHAR (STRING INDEX)                          `(%AREF1 ,STRING ,INDEX))(DEFOPTIMIZER CL:SBIT (ARRAY &REST INDICES)                          (%AREF-EXPANDER ARRAY INDICES))(DEFOPTIMIZER CL:SCHAR (STRING INDEX)                           `(%AREF1 ,STRING ,INDEX))(DEFOPTIMIZER CL:SVREF (CL:SIMPLE-VECTOR INDEX)                           `(%AREF1 ,CL:SIMPLE-VECTOR ,INDEX))(* |;;| "Vars etc")(* \; "*PRINT-ARRAY* is defined in APRINT")(CL:DEFCONSTANT CL:ARRAY-RANK-LIMIT (EXPT 2 7))(CL:DEFCONSTANT CL:ARRAY-TOTAL-SIZE-LIMIT 65534)(CL:DEFCONSTANT CL:ARRAY-DIMENSION-LIMIT CL:ARRAY-TOTAL-SIZE-LIMIT)(CL:DEFPARAMETER *DEFAULT-PUSH-EXTENSION-SIZE* 20)(* |;;| "Run-time support")(DEFINEQ(%ALTER-AS-DISPLACED-ARRAY  (LAMBDA (ADJUSTABLE-ARRAY DIMENSIONS DISPLACED-TO DISPLACED-INDEX-OFFSET FILL-POINTER)                                                             (* \; "Edited 18-Dec-86 17:11 by jop")                    (* |;;|    "Alter ADJUSTABLE-ARRAY to be displaced to displaced-to. ADJUSTABLE-ARRAY must be a general array")    (CL:IF (NULL DISPLACED-INDEX-OFFSET)           (SETQ DISPLACED-INDEX-OFFSET 0))    (LET ((DISPLACED-TO-READ-ONLY-P (|fetch| (ARRAY-HEADER READ-ONLY-P) |of| DISPLACED-TO))          (TOTAL-SIZE (%TOTAL-SIZE DIMENSIONS))          (OFFSET (OR DISPLACED-INDEX-OFFSET 0))          BASE NEED-INDIRECTION-P)         (COND            ((OR (%THIN-CHAR-TYPE-P (|fetch| (ARRAY-HEADER TYPE-NUMBER) |of| DISPLACED-TO))                 (|fetch| (ARRAY-HEADER EXTENDABLE-P) |of| DISPLACED-TO)                 (|fetch| (ARRAY-HEADER ADJUSTABLE-P) |of| DISPLACED-TO)                 (AND DISPLACED-TO-READ-ONLY-P (NOT (|fetch| (ARRAY-HEADER INDIRECT-P) |of|                                                                                          DISPLACED-TO                                                           ))))                                                             (* \; "Provide for indirection")             (SETQ BASE DISPLACED-TO)             (SETQ NEED-INDIRECTION-P T))            (T                                               (* \;                                                     "Fold double displacement to single displacement")               (SETQ BASE (|fetch| (ARRAY-HEADER BASE) |of| DISPLACED-TO))               (SETQ OFFSET (+ OFFSET (%GET-ARRAY-OFFSET DISPLACED-TO)))               (CL:IF (|fetch| (ARRAY-HEADER INDIRECT-P) |of| DISPLACED-TO)                      (SETQ NEED-INDIRECTION-P T))))         (* \;                                           "Don't need to touch the type-number since it can't change")         (UNINTERRUPTABLY             (|freplace| (GENERAL-ARRAY STORAGE) |of| ADJUSTABLE-ARRAY |with| BASE)             (|freplace| (GENERAL-ARRAY READ-ONLY-P) |of| ADJUSTABLE-ARRAY |with|                                                                              DISPLACED-TO-READ-ONLY-P                    )             (|freplace| (GENERAL-ARRAY INDIRECT-P) |of| ADJUSTABLE-ARRAY |with| NEED-INDIRECTION-P)             (|freplace| (GENERAL-ARRAY DISPLACED-P) |of| ADJUSTABLE-ARRAY |with| T)             (|freplace| (GENERAL-ARRAY FILL-POINTER-P) |of| ADJUSTABLE-ARRAY |with| FILL-POINTER)             (|freplace| (GENERAL-ARRAY OFFSET) |of| ADJUSTABLE-ARRAY |with| OFFSET)             (|freplace| (GENERAL-ARRAY FILL-POINTER) |of| ADJUSTABLE-ARRAY |with| (OR FILL-POINTER                                                                                        TOTAL-SIZE))             (|freplace| (GENERAL-ARRAY TOTAL-SIZE) |of| ADJUSTABLE-ARRAY |with| TOTAL-SIZE)             (|freplace| (GENERAL-ARRAY DIMS) |of| ADJUSTABLE-ARRAY |with| DIMENSIONS))         ADJUSTABLE-ARRAY)))(%ALTER-AS-DISPLACED-TO-BASE-ARRAY  (LAMBDA (ADJUSTABLE-ARRAY DIMENSIONS ELEMENT-TYPE DISPLACED-TO-BASE DISPLACED-INDEX-OFFSET                  FILL-POINTER FATP)                          (* \; "Edited 18-Dec-86 17:12 by jop")                    (* |;;| "Alter adjustable-array to be displaced to displaced-to-base ")    (LET ((TOTAL-SIZE (%TOTAL-SIZE DIMENSIONS))          (TYPE-NUMBER (%CML-TYPE-TO-TYPENUMBER ELEMENT-TYPE FATP)))         (UNINTERRUPTABLY             (|freplace| (GENERAL-ARRAY STORAGE) |of| ADJUSTABLE-ARRAY |with| DISPLACED-TO-BASE)             (|freplace| (GENERAL-ARRAY INDIRECT-P) |of| ADJUSTABLE-ARRAY |with| NIL)             (|freplace| (GENERAL-ARRAY DISPLACED-P) |of| ADJUSTABLE-ARRAY |with| T)             (|freplace| (GENERAL-ARRAY FILL-POINTER-P) |of| ADJUSTABLE-ARRAY |with| FILL-POINTER)             (|freplace| (GENERAL-ARRAY TYPE-NUMBER) |of| ADJUSTABLE-ARRAY |with| TYPE-NUMBER)             (|freplace| (GENERAL-ARRAY OFFSET) |of| ADJUSTABLE-ARRAY |with| (OR                                                                                DISPLACED-INDEX-OFFSET                                                                                  0))             (|freplace| (GENERAL-ARRAY FILL-POINTER) |of| ADJUSTABLE-ARRAY |with| (OR FILL-POINTER                                                                                        TOTAL-SIZE))             (|freplace| (GENERAL-ARRAY TOTAL-SIZE) |of| ADJUSTABLE-ARRAY |with| TOTAL-SIZE)             (|freplace| (GENERAL-ARRAY DIMS) |of| ADJUSTABLE-ARRAY |with| DIMENSIONS))         ADJUSTABLE-ARRAY)))(%aref0  (lambda (array)                                        (* \; "Edited 11-Dec-87 15:33 by jop")                    (* |;;| "Special aref for the zero dimensional case")    (cl:if (eq (cl:array-rank array)               0)           (let ((index 0)                 (base-array array))                    (* |;;| "Must be a general array")                (%general-array-adjust-base base-array index)                (%array-read (|fetch| (array-header base) |of| base-array)                       (|fetch| (array-header type-number) |of| base-array)                       (+ (%get-array-offset base-array)                          index)))           (cl:error "Rank mismatch"))))(%aref1  (lambda (array index)                                  (* \; "Edited 11-Dec-87 15:50 by jop")                    (* |;;|         "specialized aref for the one-d case. Also the punt function for the aref1 opcode.")    (cond       ((not (eq (cl:array-rank array)                 1))        (cl:error "Rank mismatch"))       ((not (and (>= index 0)                  (< index (|fetch| (array-header total-size) |of| array))))        (cl:error "Index out of bounds: ~A" index))       (t (* |;;| "Now proceed to extract the element")          (let ((base-array array))               (%general-array-adjust-base base-array index)               (%array-read (|fetch| (array-header base) |of| base-array)                      (|fetch| (array-header type-number) |of| base-array)                      (+ (%get-array-offset base-array)                         index)))))))(%aref2  (lambda (array i j)                                    (* \; "Edited 11-Dec-87 15:33 by jop")                    (* |;;|         "Specialized aref for the two-d case. Also the punt function for the aref 2 opcode.")    (cl:if (eq (cl:array-rank array)               2)           (let (bound0 bound1 offset)                       (* \;                                                            " ARRAY must be two-d or general")                    (* |;;| "Get bounds and offset")                (cond                   ((%twod-array-p array)                (* \; "Twod array case")                    (setq bound0 (|ffetch| (twod-array bound0) |of| array))                    (setq bound1 (|ffetch| (twod-array bound1) |of| array))                    (setq offset 0))                   (t                                        (* \; "General array case")                      (setq bound0 (car (|ffetch| (general-array dims) |of| array)))                      (setq bound1 (cadr (|ffetch| (general-array dims) |of| array)))                      (setq offset (|ffetch| (general-array offset) |of| array))))                                                             (* \; "Check indices")                (cond                   ((not (< -1 i bound0))                    (cl:error "Index out of bounds: ~A" i))                   ((not (< -1 j bound1))                    (cl:error "Index out of bounds: ~A" j))) (* \; "Extract the element")                (let ((row-major-index (+ j (cl:* bound1 i)))                      (base-array array))                     (%general-array-adjust-base base-array row-major-index)                     (%array-read (|fetch| (array-header base) |of| base-array)                            (|fetch| (array-header type-number) |of| base-array)                            (+ (%get-array-offset base-array)                               row-major-index))))           (cl:error "Rank mismatch"))))(%ARRAY-BASE  (LAMBDA (ARRAY)                                            (* \; "Edited 18-Dec-86 17:20 by jop")    (COND       ((OR (%ONED-ARRAY-P ARRAY)            (%TWOD-ARRAY-P ARRAY))        (|fetch| (ARRAY-HEADER BASE) |of| ARRAY))       ((%GENERAL-ARRAY-P ARRAY)        (|fetch| (ARRAY-HEADER BASE) |of| (CL:LOOP (CL:IF (NOT (|fetch| (ARRAY-HEADER INDIRECT-P)                                                                  |of| ARRAY))                                                          (RETURN ARRAY))                                                 (SETQ ARRAY (|fetch| (ARRAY-HEADER BASE)                                                                |of| ARRAY)))))       (T (CL:ERROR "Not an array: ~S" ARRAY)))))(%array-content-initialize  (lambda (array initial-contents)                       (* \; "Edited 11-Dec-87 15:33 by jop")    (cl:if (eq 0 (cl:array-rank array))           (%array-element-initialize array initial-contents)           (let ((dims (cl:array-dimensions array)))                (cl:if (%check-sequence-dimensions dims initial-contents)                       (%fill-array-from-sequence dims initial-contents (%flatten-array                                                                             array)                              0)                       (cl:error "Dimensionality mismatch for Initial-contents"))))))(%array-element-initialize  (lambda (array initial-element)                        (* \; "Edited 11-Dec-87 15:33 by jop")                    (* |;;| "Initialize an array with a value")    (cl:unless (eq initial-element (%typenumber-to-default-value (%array-type-number array)))           (fill-array array initial-element))))(%ARRAY-OFFSET  (LAMBDA (ARRAY)                                            (* \; "Edited 18-Dec-86 17:22 by jop")                    (* |;;| "Get the true offset for ARRAY")    (COND       ((%ONED-ARRAY-P ARRAY)        (|fetch| (ARRAY-HEADER OFFSET) |of| ARRAY))       ((%TWOD-ARRAY-P ARRAY)        0)       ((%GENERAL-ARRAY-P ARRAY)        (CL:DO ((OFFSET (|fetch| (ARRAY-HEADER OFFSET) |of| ARRAY)                       (+ OFFSET (%GET-ARRAY-OFFSET ARRAY))))               ((NOT (|fetch| (ARRAY-HEADER INDIRECT-P) |of| ARRAY))                OFFSET)               (SETQ ARRAY (|fetch| (ARRAY-HEADER BASE) |of| ARRAY))))       (T (CL:ERROR "Not an array: ~S" ARRAY)))))(%ARRAY-TYPE-NUMBER  (LAMBDA (ARRAY)                                            (* \; "Edited 18-Dec-86 17:23 by jop")                    (* |;;| "Get the true array-typenumber for ARRAY")    (COND       ((OR (%ONED-ARRAY-P ARRAY)            (%TWOD-ARRAY-P ARRAY))        (|fetch| (ARRAY-HEADER TYPE-NUMBER) |of| ARRAY))       ((%GENERAL-ARRAY-P ARRAY)        (|fetch| (ARRAY-HEADER TYPE-NUMBER) |of| (CL:LOOP (CL:IF (NOT (|fetch| (ARRAY-HEADER                                                                                       INDIRECT-P)                                                                         |of| ARRAY))                                                                 (RETURN ARRAY))                                                        (SETQ ARRAY (|fetch| (ARRAY-HEADER BASE)                                                                       |of| ARRAY)))))       (T (CL:ERROR "Not an array: ~S" ARRAY)))))(%aset0  (lambda (newvalue array)                               (* \; "Edited 11-Dec-87 15:33 by jop")                    (* |;;| "Specialized aset for the zero-d case.")    (cl:if (eq (cl:array-rank array)               0)           (let ((index 0)                 (base-array array))                    (* |;;| "Must be a general array")                (%general-array-adjust-base base-array index)                (let ((type-number (|fetch| (array-header type-number) |of| base-array)))                     (cl:if (%check-not-writeable array type-number newvalue)                            (%aset0 newvalue array)                            (%array-write newvalue (|fetch| (array-header base) |of|                                                                                        base-array)                                   type-number                                   (+ (%get-array-offset base-array)                                      index)))))           (cl:error "Rank mismatch"))))(%aset1  (lambda (newvalue array index)                         (* \; "Edited 11-Dec-87 15:34 by jop")                    (* |;;| "Specialized aset for the one-d case. Also the punt for the aset1 opcode.")    (cond       ((not (eq (cl:array-rank array)                 1))        (cl:error "Rank mismatch"))       ((not (and (>= index 0)                  (< index (|fetch| (array-header total-size) |of| array))))        (cl:error "Index out of bounds: ~s" index))       (t (* |;;| "Now proceed to extract the element")          (let ((row-major-index index)                (base-array array))               (%general-array-adjust-base base-array row-major-index)               (let ((type-number (|fetch| (array-header type-number) |of| base-array)))                    (cl:if (%check-not-writeable array type-number newvalue)                           (%aset1 newvalue array index)                           (%array-write newvalue (|fetch| (array-header base) |of|                                                                                       base-array)                                  type-number                                  (+ (%get-array-offset base-array)                                     row-major-index)))))))))(%aset2  (lambda (newvalue array i j)                           (* \; "Edited 11-Dec-87 15:34 by jop")                    (* |;;|         "Specialized aset for the two-d case. Also the punt function for the aset2 opcode.")    (cl:if (eq (cl:array-rank array)               2)           (let (bound0 bound1 offset)                    (* |;;| "Get bounds and offset")                (cond                   ((%twod-array-p array)                (* \; "Twod case")                    (setq bound0 (|ffetch| (twod-array bound0) |of| array))                    (setq bound1 (|ffetch| (twod-array bound1) |of| array))                    (setq offset 0))                   (t                                        (* \; "General Case")                      (setq bound0 (car (|ffetch| (general-array dims) |of| array)))                      (setq bound1 (cadr (|ffetch| (general-array dims) |of| array)))                      (setq offset (|ffetch| (general-array offset) |of| array))))                    (* |;;| "Check indices")                (cond                   ((not (< -1 i bound0))                    (cl:error "Index out of bounds ~s" i))                   ((not (< -1 j bound1))                    (cl:error "Index out of bounds ~s" j)))                    (* |;;| "Set element")                (let ((row-major-index (+ j (cl:* bound1 i)))                      (base-array array))                     (%general-array-adjust-base base-array row-major-index)                     (let ((type-number (|fetch| (array-header type-number) |of| base-array))                           )                          (cl:if (%check-not-writeable array type-number newvalue)                                 (%aset2 newvalue array i j)                                 (%array-write newvalue (|fetch| (array-header base)                                                               |of| base-array)                                        type-number                                        (+ (%get-array-offset base-array)                                           row-major-index))))))           (cl:error "Rank mismatch"))))(%check-sequence-dimensions  (lambda (dim-lst sequence)                             (* \; "Edited 11-Dec-87 15:34 by jop")                    (* |;;| "Returns NIL if there is a mismatch")    (cl:if (eq (car dim-lst)               (cl:length sequence))           (or (null (cdr dim-lst))               (cl:dotimes (i (car dim-lst)                              t)                      (cl:if (not (%check-sequence-dimensions (cdr dim-lst)                                         (cl:elt sequence i)))                             (return nil)))))))(%copy-to-new-array  (lambda (old-dims old-array old-offset new-dims new-array new-offset)                                                             (* \; "Edited 13-Feb-87 15:52 by jop")                    (* |;;| "It is assumed that OLD-ARRAY and NEW-ARRAY are of the same rank")    (let ((size (min (car old-dims)                     (car new-dims))))         (cl:if (cdr old-dims)                (cl:dotimes (i size)                       (%copy-to-new-array (cdr old-dims)                              old-array                              (cl:* (cadr old-dims)                                    (+ old-offset i))                              (cdr new-dims)                              new-array                              (cl:* (cadr new-dims)                                    (+ new-offset i))))                (%fast-copy-base (%array-base old-array)                       (+ (%array-offset old-array)                          old-offset)                       (%array-type-number old-array)                       (%array-base new-array)                       (+ (%array-offset new-array)                          new-offset)                       (%array-type-number new-array)                       size)))))(%DO-LOGICAL-OP  (LAMBDA (OP SOURCE DEST)                                   (* \; "Edited 18-Dec-86 17:43 by jop")    (LET ((SOURCE-BASE (%ARRAY-BASE SOURCE))          (SOURCE-OFFSET (%ARRAY-OFFSET SOURCE))          (SOURCE-SIZE (CL:ARRAY-TOTAL-SIZE SOURCE))          (DEST-BASE (%ARRAY-BASE DEST))          (DEST-OFFSET (%ARRAY-OFFSET DEST))          (GBBT (DEFERREDCONSTANT (|create| PILOTBBT                                         PBTHEIGHT _ 1                                         PBTDISJOINT _ T)))          SOURCE-OP LOG-OP)         (UNINTERRUPTABLY             (|replace| (PILOTBBT PBTSOURCE) |of| GBBT |with| SOURCE-BASE)             (|replace| (PILOTBBT PBTSOURCEBIT) |of| GBBT |with| SOURCE-OFFSET)             (|replace| (PILOTBBT PBTDEST) |of| GBBT |with| DEST-BASE)             (|replace| (PILOTBBT PBTDESTBIT) |of| GBBT |with| DEST-OFFSET)             (|replace| (PILOTBBT PBTDESTBPL) |of| GBBT |with| SOURCE-SIZE)             (|replace| (PILOTBBT PBTSOURCEBPL) |of| GBBT |with| SOURCE-SIZE)             (|replace| (PILOTBBT PBTWIDTH) |of| GBBT |with| SOURCE-SIZE)             (CASE OP (COPY (SETQ SOURCE-OP 0)                            (SETQ LOG-OP 0))                   (NOT (SETQ SOURCE-OP 1)                        (SETQ LOG-OP 0))                   (AND (SETQ SOURCE-OP 0)                        (SETQ LOG-OP 1))                   (CAND (SETQ SOURCE-OP 1)                         (SETQ LOG-OP 1))                   (OR (SETQ SOURCE-OP 0)                       (SETQ LOG-OP 2))                   (COR (SETQ SOURCE-OP 1)                        (SETQ LOG-OP 2))                   (XOR (SETQ SOURCE-OP 0)                        (SETQ LOG-OP 3))                   (CXOR (SETQ SOURCE-OP 1)                         (SETQ LOG-OP 3)))             (|replace| (PILOTBBT PBTSOURCETYPE) |of| GBBT |with| SOURCE-OP)             (|replace| (PILOTBBT PBTOPERATION) |of| GBBT |with| LOG-OP)                                                             (* \; "Execute the BLT")             (\\PILOTBITBLT GBBT 0)             DEST))))(%EXTEND-ARRAY  (LAMBDA (EXTENDABLE-ARRAY NEW-ARRAY DIMENSIONS FILL-POINTER)                                                             (* \; "Edited 18-Dec-86 17:43 by jop")                    (* |;;| "Extend ADJUSTABLE-ARRAY, using the base provided by NEW-ARRAY ")    (LET ((TYPE-NUMBER (|fetch| (ARRAY-HEADER TYPE-NUMBER) |of| NEW-ARRAY))          (TOTAL-SIZE (%TOTAL-SIZE DIMENSIONS))          (BASE (|fetch| (ARRAY-HEADER BASE) |of| NEW-ARRAY)))         (UNINTERRUPTABLY             (|replace| (ARRAY-HEADER BASE) |of| EXTENDABLE-ARRAY |with| BASE)             (|replace| (ARRAY-HEADER READ-ONLY-P) |of| EXTENDABLE-ARRAY |with| NIL)             (|replace| (ARRAY-HEADER TYPE-NUMBER) |of| EXTENDABLE-ARRAY |with| TYPE-NUMBER)             (|replace| (ARRAY-HEADER TOTAL-SIZE) |of| EXTENDABLE-ARRAY |with| TOTAL-SIZE)             (COND                ((%TWOD-ARRAY-P EXTENDABLE-ARRAY)                 (|freplace| (TWOD-ARRAY BOUND0) |of| EXTENDABLE-ARRAY |with| (CAR DIMENSIONS))                 (|freplace| (TWOD-ARRAY BOUND1) |of| EXTENDABLE-ARRAY |with| (CADR DIMENSIONS)))                (T                                           (* \; "must be oned or general")                   (|replace| (ARRAY-HEADER DISPLACED-P) |of| EXTENDABLE-ARRAY |with| NIL)                   (|replace| (ARRAY-HEADER FILL-POINTER-P) |of| EXTENDABLE-ARRAY |with| FILL-POINTER                          )                   (|replace| (ARRAY-HEADER OFFSET) |of| EXTENDABLE-ARRAY |with| 0)                   (|replace| (ARRAY-HEADER FILL-POINTER) |of| EXTENDABLE-ARRAY                      |with| (OR FILL-POINTER TOTAL-SIZE))                   (CL:WHEN (%GENERAL-ARRAY-P EXTENDABLE-ARRAY)                          (|freplace| (GENERAL-ARRAY INDIRECT-P) |of| EXTENDABLE-ARRAY |with| NIL)                          (|freplace| (GENERAL-ARRAY DIMS) |of| EXTENDABLE-ARRAY |with| DIMENSIONS)))                ))         EXTENDABLE-ARRAY)))(%fast-copy-base  (lambda (from-base from-offset from-typenumber to-base to-offset to-typenumber cnt)                                                             (* \; "Edited 11-Dec-87 15:34 by jop")                    (* |;;| "Blts one array into another of the same element-type")    (cl:if (or (not (eq from-typenumber to-typenumber))               (eq (%typenumber-to-gc-type to-typenumber)                   ptrblock.gct))           (cl:do ((i from-offset (cl:1+ i))                   (limit (+ from-offset cnt))                   (j to-offset (cl:1+ j)))                  ((eq i limit))                  (%array-write (%array-read from-base from-typenumber i)                         to-base to-typenumber j))           (let ((bits-per-element (%typenumber-to-bits-per-element to-typenumber))                 (pbbt (deferredconstant (|create| pilotbbt                                                pbtdisjoint _ t                                                pbtsourcetype _ 0                                                pbtoperation _ 0))))                    (* |;;| "Uses \\PILOTBITBLT instead of \\BLT because offsets might not be word aligned, and BITS-PER-ELEMENT may be greater than BITSPERWORD (16). ")                (uninterruptably                    (|freplace| (pilotbbt pbtsource) |of| pbbt |with| from-base)                    (|freplace| (pilotbbt pbtsourcebit) |of| pbbt |with| (cl:*                                                                                      bits-per-element                                                                                           from-offset                                                                                           ))                    (|freplace| (pilotbbt pbtdest) |of| pbbt |with| to-base)                    (|freplace| (pilotbbt pbtdestbit) |of| pbbt |with| (cl:*                                                                                      bits-per-element                                                                                          to-offset))                    (|freplace| (pilotbbt pbtdestbpl) |of| pbbt |with| bits-per-element)                    (|freplace| (pilotbbt pbtsourcebpl) |of| pbbt |with| bits-per-element                           )                    (|freplace| (pilotbbt pbtwidth) |of| pbbt |with| bits-per-element)                    (|freplace| (pilotbbt pbtheight) |of| pbbt |with| cnt)                    (\\pilotbitblt pbbt 0))                nil))))(%FAT-STRING-ARRAY-P  (LAMBDA (ARRAY)                                            (* \; "Edited 18-Dec-86 17:44 by jop")    (%FAT-CHAR-TYPE-P (%ARRAY-TYPE-NUMBER ARRAY))))(%fill-array-from-sequence  (lambda (dims sequence flattened-array offset)         (* \; "Edited 11-Dec-87 15:34 by jop")    (cl:if (cdr dims)           (cl:dotimes (i (car dims))                  (%fill-array-from-sequence (cdr dims)                         (cl:elt sequence i)                         flattened-array                         (cl:* (cadr dims)                               (+ offset i))))           (cl:do ((i 0 (cl:1+ i))                   (j offset (cl:1+ j))                   (limit (car dims)))                  ((eq i limit))                  (aset (cl:elt sequence i)                         flattened-array j)))))(%flatten-array  (lambda (array)                                        (* \; "Edited 11-Dec-87 15:34 by jop")                    (* |;;|     "Make a oned-array that shares storage with array.  If array is already oned then return array")    (cl:if (eq 1 (cl:array-rank array))           array           (cl:make-array (cl:array-total-size array)                  :element-type                  (cl:array-element-type array)                  :displaced-to array))))(%MAKE-ARRAY-WRITEABLE  (LAMBDA (ARRAY)                                            (* \; "Edited 18-Dec-86 18:40 by jop")    (CL:IF (NOT (%ARRAYP ARRAY))           (CL:ERROR "Not an array: ~S" ARRAY))    (LET ((BASE-ARRAY ARRAY)          NEW-BASE OFFSET TOTAL-SIZE TYPE-NUMBER)                    (* |;;| "Find the base array")         (CL:IF (|fetch| (ARRAY-HEADER INDIRECT-P) |of| ARRAY)                (CL:LOOP (CL:IF (|fetch| (ARRAY-HEADER INDIRECT-P) |of| BASE-ARRAY)                                (SETQ BASE-ARRAY (|fetch| (ARRAY-HEADER BASE) |of| BASE-ARRAY))                                (RETURN NIL))))         (CL:WHEN (|fetch| (ARRAY-HEADER READ-ONLY-P) |of| BASE-ARRAY)                    (* |;;| "Allocate the new storage")                                                             (* \; "Be careful about offsets")                (SETQ TOTAL-SIZE (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| BASE-ARRAY))                (SETQ OFFSET (%GET-ARRAY-OFFSET BASE-ARRAY))                (SETQ TYPE-NUMBER (|fetch| (ARRAY-HEADER TYPE-NUMBER) |of| BASE-ARRAY))                (SETQ NEW-BASE (%MAKE-ARRAY-STORAGE (+ TOTAL-SIZE OFFSET)                                      TYPE-NUMBER))                    (* |;;| "Initialize it")                (%FAST-COPY-BASE (|fetch| (ARRAY-HEADER BASE) |of| BASE-ARRAY)                       OFFSET TYPE-NUMBER NEW-BASE OFFSET TYPE-NUMBER TOTAL-SIZE)                    (* |;;| "Smash the new base into the array-header")                (UNINTERRUPTABLY                    (|replace| (ARRAY-HEADER BASE) |of| BASE-ARRAY |with| NEW-BASE)                    (|replace| (ARRAY-HEADER READ-ONLY-P) |of| BASE-ARRAY |with| NIL)))                    (* |;;| "Declare the array (and all arrays on its access chain) readable")         (UNINTERRUPTABLY             (CL:DO ((NEXT-ARRAY ARRAY (|fetch| (ARRAY-HEADER BASE) |of| NEXT-ARRAY)))                    ((NOT (|fetch| (ARRAY-HEADER INDIRECT-P) |of| NEXT-ARRAY)))                    (|replace| (ARRAY-HEADER READ-ONLY-P) |of| NEXT-ARRAY |with| NIL)))                    (* |;;| "return the original array")         ARRAY)))(%MAKE-DISPLACED-ARRAY  (LAMBDA (TOTALSIZE DIMENSIONS ELEMENT-TYPE DISPLACED-TO DISPLACED-INDEX-OFFSET FILL-POINTER                  READ-ONLY-P ADJUSTABLE EXTENDABLE)          (* \; "Edited 18-Dec-86 17:48 by jop")                    (* |;;| "Make a displaced array")    (LET ((DISPLACED-TO-TYPENUMBER (|fetch| (ARRAY-HEADER TYPE-NUMBER) |of| DISPLACED-TO))          (DISPLACE-TO-READ-ONLY-P (|fetch| (ARRAY-HEADER READ-ONLY-P) |of| DISPLACED-TO))          (OFFSET (OR DISPLACED-INDEX-OFFSET 0))          BASE NEED-INDIRECTION-P)         (COND            ((OR (%THIN-CHAR-TYPE-P DISPLACED-TO-TYPENUMBER)                 (|fetch| (ARRAY-HEADER EXTENDABLE-P) |of| DISPLACED-TO)                 (|fetch| (ARRAY-HEADER ADJUSTABLE-P) |of| DISPLACED-TO)                 (AND DISPLACE-TO-READ-ONLY-P (NOT (|fetch| (ARRAY-HEADER INDIRECT-P) |of|                                                                                          DISPLACED-TO                                                          ))))                                                             (* \; "Provide for indirection")             (SETQ BASE DISPLACED-TO)             (SETQ NEED-INDIRECTION-P T))            (T                                               (* \;                                                     "Fold double displacement to single displacement")               (SETQ BASE (|fetch| (ARRAY-HEADER BASE) |of| DISPLACED-TO))               (SETQ OFFSET (+ OFFSET (%GET-ARRAY-OFFSET DISPLACED-TO)))               (CL:IF (|fetch| (ARRAY-HEADER INDIRECT-P) |of| DISPLACED-TO)                      (SETQ NEED-INDIRECTION-P T))))         (COND            ((OR NEED-INDIRECTION-P ADJUSTABLE (> (LENGTH DIMENSIONS)                                                  1))        (* \;                                                   "Indirect strings always have %FAT-CHAR-TYPENUMBER")             (%MAKE-GENERAL-ARRAY TOTALSIZE DIMENSIONS ELEMENT-TYPE FILL-POINTER (%CHAR-TYPE-P                                                                               DISPLACED-TO-TYPENUMBER                                                                                        )                    (OR READ-ONLY-P DISPLACE-TO-READ-ONLY-P)                    ADJUSTABLE EXTENDABLE BASE OFFSET))            (T (%MAKE-ONED-ARRAY TOTALSIZE ELEMENT-TYPE FILL-POINTER (%FAT-CHAR-TYPE-P                                                                             DISPLACED-TO-TYPENUMBER)                      (OR READ-ONLY-P DISPLACE-TO-READ-ONLY-P)                      EXTENDABLE BASE OFFSET))))))(%make-general-array  (lambda (total-size dimensions element-type fill-pointer fatp read-only-p adjustable-p extendable-p                  displaced-to displaced-index-offset)    (* \; "Edited 11-Dec-87 15:35 by jop")                    (* |;;|         "General arrays cover all make-array cases, including those requiring indirection.")    (let ((type-number (%cml-type-to-typenumber element-type fatp)))         (|create| general-array                storage _ (or displaced-to (%make-array-storage total-size type-number))                read-only-p _ read-only-p                indirect-p _ (%arrayp displaced-to)                bit-p _ (%bit-type-p type-number)                string-p _ (and (%char-type-p type-number)                                (eq 1 (length dimensions)))                adjustable-p _ adjustable-p                displaced-p _ displaced-to                fill-pointer-p _ fill-pointer                extendable-p _ (or extendable-p adjustable-p)                type-number _ type-number                offset _ (or displaced-index-offset 0)                fill-pointer _ (or fill-pointer total-size)                total-size _ total-size                dims _ dimensions))))(%MAKE-ONED-ARRAY  (LAMBDA (TOTAL-SIZE ELEMENT-TYPE FILL-POINTER FATP READ-ONLY-P EXTENDABLE-P DISPLACED-TO                  DISPLACED-INDEX-OFFSET)                     (* \; "Edited 18-Dec-86 17:48 by jop")                    (* |;;| "Oned-arrays cover all one dimensional cases, except adjustable and displaced-to when indirection is necessary")    (LET ((TYPE-NUMBER (%CML-TYPE-TO-TYPENUMBER ELEMENT-TYPE FATP)))         (|create| ONED-ARRAY                BASE _ (OR DISPLACED-TO (%MAKE-ARRAY-STORAGE TOTAL-SIZE TYPE-NUMBER))                READ-ONLY-P _ READ-ONLY-P                BIT-P _ (%BIT-TYPE-P TYPE-NUMBER)                STRING-P _ (%CHAR-TYPE-P TYPE-NUMBER)                DISPLACED-P _ DISPLACED-TO                FILL-POINTER-P _ FILL-POINTER                EXTENDABLE-P _ EXTENDABLE-P                TYPE-NUMBER _ TYPE-NUMBER                OFFSET _ (OR DISPLACED-INDEX-OFFSET 0)                FILL-POINTER _ (OR FILL-POINTER TOTAL-SIZE)                TOTAL-SIZE _ TOTAL-SIZE))))(%make-string-array-fat  (lambda (array)                                        (* \; "Edited 11-Dec-87 15:35 by jop")                    (* |;;| "Like Adjust-array for the special case of Thin-string arrays")    (cl:if (not (%arrayp array))           (cl:error "Not an array" array))    (let ((base-array array)          new-base offset limit)                    (* |;;| "Find the base array")         (cl:if (|fetch| (array-header indirect-p) |of| array)                (cl:loop (cl:if (|fetch| (array-header indirect-p) |of| base-array)                                (setq base-array (|fetch| (array-header base) |of| base-array                                                        ))                                (return nil))))                    (* |;;| "Consistency check")         (cl:if (not (%thin-char-type-p (|fetch| (array-header type-number) |of| base-array))                     )                (cl:error "Not a thin string-char array: ~S" base-array))                    (* |;;| "Allocate the new storage")                                                             (* \; "Be careful about offsets")         (setq offset (%get-array-offset base-array))         (setq limit (+ (|fetch| (array-header total-size) |of| base-array)                        offset))         (setq new-base (%make-array-storage limit %fat-char-typenumber))                    (* |;;| "Initialize it")                                                             (* \;                                   "Can't use %fast-copy-base because of the differing type numbers")         (cl:do ((i offset (cl:1+ i))                 (base-array-base (|fetch| (array-header base) |of| base-array)))                ((eq i limit))                (%array-write (%array-read base-array-base %thin-char-typenumber i)                       new-base %fat-char-typenumber i))                    (* |;;| "Smash the new base into the array-header")         (uninterruptably             (|replace| (array-header base) |of| base-array |with| new-base)             (|replace| (array-header type-number) |of| base-array |with|                                                                                  %fat-char-typenumber                    ))                    (* |;;| "return the original array")         array)))(%MAKE-TWOD-ARRAY  (LAMBDA (TOTAL-SIZE DIMENSIONS ELEMENT-TYPE FATP READ-ONLY-P EXTENDABLE-P)                                                             (* \; "Edited 18-Dec-86 17:49 by jop")                    (* |;;| "Two-d arrays are only simple or extendable twod-arrays")    (LET ((BOUND0 (CAR DIMENSIONS))          (BOUND1 (CADR DIMENSIONS))          (TYPE-NUMBER (%CML-TYPE-TO-TYPENUMBER ELEMENT-TYPE FATP)))         (|create| TWOD-ARRAY                BASE _ (%MAKE-ARRAY-STORAGE TOTAL-SIZE TYPE-NUMBER)                READ-ONLY-P _ READ-ONLY-P                BIT-P _ (%BIT-TYPE-P TYPE-NUMBER)                EXTENDABLE-P _ EXTENDABLE-P                TYPE-NUMBER _ TYPE-NUMBER                BOUND0 _ BOUND0                BOUND1 _ BOUND1                TOTAL-SIZE _ TOTAL-SIZE))))(%TOTAL-SIZE  (LAMBDA (DIMS)                                             (* \; "Edited 18-Dec-86 17:53 by jop")    (CL:DO ((DIM DIMS (CDR DIM))            (PROD 1))           ((NULL DIM)            PROD)           (SETQ PROD (CL:* (CAR DIM)                            PROD)))))(SHRINK-VECTOR  (LAMBDA (VECTOR NEW-SIZE)                                  (* \; "Edited 18-Dec-86 18:08 by jop")    (COND       ((%VECTORP VECTOR)        (CL:IF (OR (< NEW-SIZE 0)                   (> NEW-SIZE (|fetch| (ARRAY-HEADER TOTAL-SIZE) |of| VECTOR)))               (CL:ERROR "Trying to shrink array ~s to bad size ~s" VECTOR NEW-SIZE))        (|replace| (ARRAY-HEADER FILL-POINTER-P) |of| VECTOR |with| T)        (|replace| (ARRAY-HEADER FILL-POINTER) |of| VECTOR |with| NEW-SIZE)        VECTOR)       (T (CL:ERROR "Not a vector: ~S" VECTOR))))))(* \; "For Interlisp string hack")(DEFINEQ(%SET-ARRAY-OFFSET  (LAMBDA (ARRAY NEWVALUE)                                   (* \; "Edited 18-Dec-86 17:51 by jop")                    (* |;;| "Set the true offset for ARRAY")    (COND       ((%ONED-ARRAY-P ARRAY)        (|replace| (ARRAY-HEADER OFFSET) |of| ARRAY |with| NEWVALUE))       ((%TWOD-ARRAY-P ARRAY)        (CL:ERROR "Twod-arrays have no offset"))       ((%GENERAL-ARRAY-P ARRAY)        (|replace| (ARRAY-HEADER OFFSET) |of| ARRAY |with| (- NEWVALUE                                                              (CL:DO* ((BASE-ARRAY                                                                        ARRAY                                                                        (|fetch| (ARRAY-HEADER BASE)                                                                           |of| BASE-ARRAY))                                                                       (OFFSET 0 (+ OFFSET                                                                                    (                                                                                    %GET-ARRAY-OFFSET                                                                                     BASE-ARRAY))))                                                                     ((NOT (|fetch| (ARRAY-HEADER                                                                                     INDIRECT-P)                                                                              |of| BASE-ARRAY))                                                                      OFFSET)))))       (T (CL:ERROR "Not an array: ~S" ARRAY)))    NEWVALUE))(%SET-ARRAY-TYPE-NUMBER  (LAMBDA (ARRAY NEWVALUE)                                   (* \; "Edited 18-Dec-86 17:52 by jop")                    (* |;;| "Set the true type-number for array")    (COND       ((OR (%ONED-ARRAY-P ARRAY)            (%TWOD-ARRAY-P ARRAY))        (|replace| (ARRAY-HEADER TYPE-NUMBER) |of| ARRAY |with| NEWVALUE))       ((%GENERAL-ARRAY-P ARRAY)        (CL:DO ((BASE-ARRAY ARRAY (|fetch| (ARRAY-HEADER BASE) |of| BASE-ARRAY)))               ((NOT (|fetch| (ARRAY-HEADER INDIRECT-P) |of| BASE-ARRAY))                (|replace| (ARRAY-HEADER TYPE-NUMBER) |of| BASE-ARRAY |with| NEWVALUE))))       (T (CL:ERROR "Not an array ~S" ARRAY)))    NEWVALUE)))(* \; "Low level predicates")(DEFINEQ(%ONED-ARRAY-P  (LAMBDA (ARRAY)                                            (* \; "Edited 18-Dec-86 17:49 by jop")    (EQ (NTYPX ARRAY)        %ONED-ARRAY)))(%TWOD-ARRAY-P  (LAMBDA (ARRAY)                                            (* \; "Edited 18-Dec-86 17:53 by jop")    (EQ (NTYPX ARRAY)        %TWOD-ARRAY)))(%GENERAL-ARRAY-P  (LAMBDA (ARRAY)                                            (* \; "Edited 18-Dec-86 17:44 by jop")    (EQ (NTYPX ARRAY)        %GENERAL-ARRAY)))(%THIN-STRING-ARRAY-P  (LAMBDA (ARRAY)                                            (* \; "Edited 18-Dec-86 17:53 by jop")    (%THIN-CHAR-TYPE-P (%ARRAY-TYPE-NUMBER ARRAY)))))(DEFOPTIMIZER %ONED-ARRAY-P (ARRAY)                                `(AND ((OPCODES TYPEP 14)                                       ,ARRAY)                                      T))(DEFOPTIMIZER %TWOD-ARRAY-P (ARRAY)                                `(AND ((OPCODES TYPEP 15)                                       ,ARRAY)                                      T))(DEFOPTIMIZER %GENERAL-ARRAY-P (ARRAY)                                   `(AND ((OPCODES TYPEP 16)                                          ,ARRAY)                                         T))(* \; "Real record def's on cmlarray-support")(/DECLAREDATATYPE 'GENERAL-ARRAY '((BITS 8)                                   POINTER FLAG FLAG FLAG FLAG FLAG FLAG FLAG FLAG (BITS 8)                                   WORD WORD WORD POINTER)       '((GENERAL-ARRAY 0 (BITS . 7))         (GENERAL-ARRAY 0 POINTER)         (GENERAL-ARRAY 2 (FLAGBITS . 0))         (GENERAL-ARRAY 2 (FLAGBITS . 16))         (GENERAL-ARRAY 2 (FLAGBITS . 32))         (GENERAL-ARRAY 2 (FLAGBITS . 48))         (GENERAL-ARRAY 2 (FLAGBITS . 64))         (GENERAL-ARRAY 2 (FLAGBITS . 80))         (GENERAL-ARRAY 2 (FLAGBITS . 96))         (GENERAL-ARRAY 2 (FLAGBITS . 112))         (GENERAL-ARRAY 2 (BITS . 135))         (GENERAL-ARRAY 3 (BITS . 15))         (GENERAL-ARRAY 4 (BITS . 15))         (GENERAL-ARRAY 5 (BITS . 15))         (GENERAL-ARRAY 6 POINTER))       '8)(/DECLAREDATATYPE 'ONED-ARRAY '((BITS 8)                                POINTER FLAG (BITS 1)                                FLAG FLAG (BITS 1)                                FLAG FLAG FLAG (BITS 8)                                WORD WORD WORD)       '((ONED-ARRAY 0 (BITS . 7))         (ONED-ARRAY 0 POINTER)         (ONED-ARRAY 2 (FLAGBITS . 0))         (ONED-ARRAY 2 (BITS . 16))         (ONED-ARRAY 2 (FLAGBITS . 32))         (ONED-ARRAY 2 (FLAGBITS . 48))         (ONED-ARRAY 2 (BITS . 64))         (ONED-ARRAY 2 (FLAGBITS . 80))         (ONED-ARRAY 2 (FLAGBITS . 96))         (ONED-ARRAY 2 (FLAGBITS . 112))         (ONED-ARRAY 2 (BITS . 135))         (ONED-ARRAY 3 (BITS . 15))         (ONED-ARRAY 4 (BITS . 15))         (ONED-ARRAY 5 (BITS . 15)))       '6)(/DECLAREDATATYPE 'TWOD-ARRAY '((BITS 8)                                POINTER FLAG (BITS 1)                                FLAG                                (BITS 4)                                FLAG                                (BITS 8)                                WORD WORD WORD)       '((TWOD-ARRAY 0 (BITS . 7))         (TWOD-ARRAY 0 POINTER)         (TWOD-ARRAY 2 (FLAGBITS . 0))         (TWOD-ARRAY 2 (BITS . 16))         (TWOD-ARRAY 2 (FLAGBITS . 32))         (TWOD-ARRAY 2 (BITS . 51))         (TWOD-ARRAY 2 (FLAGBITS . 112))         (TWOD-ARRAY 2 (BITS . 135))         (TWOD-ARRAY 3 (BITS . 15))         (TWOD-ARRAY 4 (BITS . 15))         (TWOD-ARRAY 5 (BITS . 15)))       '6)(ADDTOVAR SYSTEMRECLST(DATATYPE GENERAL-ARRAY ((NIL BITS 8)                             (STORAGE POINTER)                             (READ-ONLY-P FLAG)                             (INDIRECT-P FLAG)                             (BIT-P FLAG)                             (STRING-P FLAG)                             (ADJUSTABLE-P FLAG)                             (DISPLACED-P FLAG)                             (FILL-POINTER-P FLAG)                             (EXTENDABLE-P FLAG)                             (TYPE-NUMBER BITS 8)                             (OFFSET WORD)                             (FILL-POINTER WORD)                             (TOTAL-SIZE WORD)                             (DIMS POINTER)))(DATATYPE ONED-ARRAY ((NIL BITS 8)                          (BASE POINTER)                          (READ-ONLY-P FLAG)                          (NIL BITS 1)                          (BIT-P FLAG)                          (STRING-P FLAG)                          (NIL BITS 1)                          (DISPLACED-P FLAG)                          (FILL-POINTER-P FLAG)                          (EXTENDABLE-P FLAG)                          (TYPE-NUMBER BITS 8)                          (OFFSET WORD)                          (FILL-POINTER WORD)                          (TOTAL-SIZE WORD)))(DATATYPE TWOD-ARRAY ((NIL BITS 8)                          (BASE POINTER)                          (READ-ONLY-P FLAG)                          (NIL BITS 1)                          (BIT-P FLAG)                          (NIL BITS 4)                          (EXTENDABLE-P FLAG)                          (TYPE-NUMBER BITS 8)                          (BOUND0 WORD)                          (BOUND1 WORD)                          (TOTAL-SIZE WORD))))(PUTPROPS %AREF1 DOPVAL (2 AREF1))(PUTPROPS %AREF2 DOPVAL (3 AREF2))(PUTPROPS %ASET1 DOPVAL (3 ASET1))(PUTPROPS %ASET2 DOPVAL (4 ASET2))(* |;;| "I/O")(DEFINEQ(%defprint-array  (lambda (array stream)                                 (* \; "Edited  5-Feb-88 10:10 by jop")    (* |;;| "This is the defprint for the array type")    (cond       ((%vectorp array)        (%defprint-vector array stream))       ((not *print-array*)        (%defprint-generic-array array stream))       ((and *print-level* (<= *print-level* 0))        (\\elide.print.element stream)        t)       (t (let ((hash (cl:code-char (|fetch| (readtablep hashmacrochar) |of| *readtable*)))                (rank (cl:array-rank array))                rankstr)               (%check-circle-print array stream (setq rankstr (cl:princ-to-string rank))                                                             (* \; "Make sure we have room for #na")                      (.spacecheck. stream (+ (vector-length rankstr)                                              2))                      (cl:write-char hash stream)                      (cl:write-string rankstr stream)                      (cl:write-char (constant #\A)                             stream)                      (cl:if (eq rank 0)                             (\\prindatum (cl:aref array)                                    stream 0)                             (%print-array-contents (%flatten-array array)                                    0                                    (cl:array-dimensions array)                                    stream)))               t)))))(%defprint-bitvector  (lambda (cl:bit-vector stream)                         (* \; "Edited 11-Dec-87 15:35 by jop")                    (* |;;| "*Print-level* is handled in %defprint-vector")    (let ((hash (cl:code-char (|fetch| (readtablep hashmacrochar) |of| *readtable*)))          (size (vector-length cl:bit-vector))          end.index final.index elided sizestr)         (setq end.index (cl:1- size))         (%check-circle-print cl:bit-vector stream                (cl:unless (eq size 0)                       (cl:do ((i (cl:1- end.index)                                  (cl:1- i))                               (last.value (cl:aref cl:bit-vector end.index)))                              ((or (< i 0)                                   (not (eql (cl:aref cl:bit-vector i)                                             last.value))))                              (setq end.index i)))                (setq final.index (cond                                     ((and *print-length* (>= end.index *print-length*))                                      (setq elided t)                                      (cl:1- *print-length*))                                     (t end.index)))                (cl:if (not (eq (cl:1- size)                                end.index))                       (setq sizestr (cl:princ-to-string size)))                (.spacecheck. stream (+ (progn               (* \;                                   "#* Plus 1 for final.index being 1 less than number bits printed")                                               3)                                        (cl:if sizestr (vector-length sizestr)                                               0)                                        final.index                                        (cl:if elided (progn (* \; "Space for ...")                                                             3)                                               0)))                (cl:write-char hash stream)                (cl:if sizestr (cl:write-string sizestr stream))                (cl:write-char (constant #\*)                       stream)                (cl:do ((i 0 (cl:1+ i)))                       ((> i final.index))                       (\\outchar stream (+ (bit cl:bit-vector i)                                            (constant (cl:char-code #\0)))))                (cl:if elided (\\elide.print.tail stream)))         t)))(%DEFPRINT-GENERIC-ARRAY  (LAMBDA (ARRAY STREAM)                                     (* \; "Edited 18-Dec-86 17:40 by jop")                    (* |;;| "Invoked when *PRINT-ARRAY* is NIL")    (LET ((HASH (CL:CODE-CHAR (|fetch| (READTABLEP HASHMACROCHAR) |of| *READTABLE*))))         (%CHECK-CIRCLE-PRINT ARRAY STREAM                   (* \; "Make sure we have room for #<")                (.SPACECHECK. STREAM 2)                (CL:WRITE-CHAR HASH STREAM)                (CL:WRITE-CHAR (CONSTANT #\<)                       STREAM)                (CL:WRITE-STRING (CL:PRINC-TO-STRING 'CL:ARRAY)                       STREAM)                (CL:WRITE-CHAR (CONSTANT #\Space)                       STREAM)                (CL:WRITE-STRING (CL:PRINC-TO-STRING (CL:ARRAY-ELEMENT-TYPE ARRAY))                       STREAM)                (CL:WRITE-CHAR (CONSTANT #\Space)                       STREAM)                (CL:WRITE-STRING (CL:PRINC-TO-STRING (CL:ARRAY-DIMENSIONS ARRAY))                       STREAM)                (CL:WRITE-CHAR (CONSTANT #\Space)                       STREAM)                (CL:WRITE-CHAR (CONSTANT #\@)                       STREAM)                (CL:WRITE-CHAR (CONSTANT #\Space)                       STREAM)                (\\PRINTADDR ARRAY STREAM)                (CL:WRITE-CHAR (CONSTANT #\>)                       STREAM))         T)))(%defprint-vector  (lambda (vector stream)                                (* \; "Edited  5-Feb-88 10:11 by jop")    (* |;;| "Defprint for the oned-array type")    (cond       ((cl:stringp vector)        (%defprint-string vector stream))       ((not *print-array*)        (%defprint-generic-array vector stream))       ((and *print-level* (<= *print-level* 0))        (\\elide.print.element stream)        t)       ((cl:bit-vector-p vector)        (%defprint-bitvector vector stream))       (t (let ((hash (cl:code-char (|fetch| (readtablep hashmacrochar) |of| *readtable*)))                (size (vector-length vector))                end.index final.index elided sizestr)               (setq end.index (cl:1- size))               (%check-circle-print vector stream                      (cl:unless (eq size 0)                             (cl:do ((i (cl:1- end.index)                                        (cl:1- i))                                     (last.value (cl:aref vector end.index)))                                    ((or (< i 0)                                         (not (eql (cl:aref vector i)                                                   last.value))))                                    (setq end.index i)))                      (setq final.index (cond                                           ((and *print-length* (>= end.index *print-length*))                                            (setq elided t)                                            (cl:1- *print-length*))                                           (t end.index)))                      (cl:if (not (eq (cl:1- size)                                      end.index))                             (setq sizestr (cl:princ-to-string size)))                      (.spacecheck. stream (+ (cl:if sizestr (vector-length sizestr)                                                     0)                                              2))                      (cl:write-char hash stream)                      (cl:if sizestr (cl:write-string sizestr stream))                      (cl:write-char (constant #\()                             stream)                      (let ((*print-level* (and *print-level* (cl:1- *print-level*))))                           (cl:do ((i 0 (cl:1+ i)))                                  ((> i final.index))                                  (cl:if (> i 0)                                         (cl:write-char (constant #\Space)                                                stream))                                  (\\prindatum (cl:aref vector i)                                         stream 0)))                      (cl:if elided (\\elide.print.tail stream))                      (cl:write-char (constant #\))                             stream))               t)))))(%defprint-string  (lambda (string stream)                                (* \; "Edited 11-Dec-87 15:36 by jop")                    (* |;;| "May never get called since (IL:typename (make-string 10)) returns IL:stringp")    (let ((escapechar (|fetch| (readtablep escapechar) |of| *readtable*))          (clp (|fetch| (readtablep commonlisp) |of| *readtable*))          (size (vector-length string)))         (%check-circle-print string stream (.spacecheck. stream (cl:if clp 2 (+ 2 size)))                (cl:when *print-escape* (\\outchar stream (constant (cl:char-code #\"))))                (cl:do ((i 0 (cl:1+ i))                        ch)                       ((eq i size))                       (setq ch (cl:char-code (cl:char string i)))                       (cl:when (and *print-escape* (or (eq ch (constant (cl:char-code #\")))                                                        (eq ch escapechar)))                              (\\outchar stream escapechar))                       (\\outchar stream ch))                (cl:when *print-escape* (\\outchar stream (constant (cl:char-code #\")))))         t)))(%print-array-contents  (lambda (flat-array offset dimensions stream)          (* \; "Edited  5-Feb-88 10:11 by jop")    (let ((nelts (car dimensions))          final.index elided)         (cond            ((and *print-length* (> nelts *print-length*))             (setq elided t)             (setq final.index (cl:1- *print-length*)))            (t (setq final.index (cl:1- nelts))))         (cl:write-char (constant #\()                stream)         (cond            ((null (cdr dimensions))                         (* \;                                                          "Down to bottom level, print the elements")             (cl:do ((i offset (cl:1+ i))                     (end-index (+ offset final.index)))                    ((> i end-index))                    (cl:if (> i offset)                           (cl:write-char (constant #\Space)                                  stream))                    (\\prindatum (cl:aref flat-array i)                           stream 0)))            ((eq *print-level* 1)                            (* \; "Elide at this level")             (cl:do ((i 0 (cl:1+ i)))                    ((> i final.index))                    (cl:if (> i offset)                           (cl:write-char (constant #\Space)                                  stream))                    (\\elide.print.element stream)))            (t (let ((*print-level* (and *print-level* (cl:1- *print-level*))))                    (cl:do ((i 0 (cl:1+ i)))                           ((> i final.index))                           (cl:if (> i 0)                                  (cl:write-char (constant #\Space)                                         stream))                           (%print-array-contents flat-array (cl:* (cadr dimensions)                                                                       (+ offset i))                                  (cdr dimensions)                                  stream)))))         (cl:if elided (\\elide.print.tail stream))         (cl:write-char (constant #\))                stream)))))(DEFPRINT 'ONED-ARRAY '%DEFPRINT-VECTOR)(DEFPRINT 'TWOD-ARRAY '%DEFPRINT-ARRAY)(DEFPRINT 'GENERAL-ARRAY '%DEFPRINT-ARRAY)(* |;;| "Needed at run time. low level functions for accessing, setting, and allocating raw storage. also includes cml type to typenumber converters")(DEFINEQ(%ARRAY-READ  (LAMBDA (BASE TYPE-NUMBER INDEX)    (%SLOW-ARRAY-READ BASE TYPE-NUMBER INDEX)))(%ARRAY-WRITE  (LAMBDA (NEWVALUE BASE TYPE-NUMBER INDEX)                  (* \; "Edited 18-Dec-86 17:23 by jop")    (%SLOW-ARRAY-WRITE NEWVALUE BASE TYPE-NUMBER INDEX)))(%CML-TYPE-TO-TYPENUMBER  (LAMBDA (ELEMENT-TYPE FATP)                                (* \; "Edited 18-Dec-86 17:30 by jop")    (LET ((CANONICAL-TYPE (%GET-CANONICAL-CML-TYPE ELEMENT-TYPE)))         (CL:IF (AND FATP (EQ CANONICAL-TYPE 'CL:STRING-CHAR))                %FAT-CHAR-TYPENUMBER                (%CML-TYPE-TO-TYPENUMBER-EXPANDER CANONICAL-TYPE)))))(%GET-CANONICAL-CML-TYPE  (LAMBDA (ELEMENT-TYPE)                                     (* \; "Edited 18-Dec-86 17:46 by jop")                    (* |;;| "Returns the enclosing specialized array type")    (CL:IF (CL:CONSP ELEMENT-TYPE)           (CASE (CAR ELEMENT-TYPE)                 (CL:UNSIGNED-BYTE (%GET-ENCLOSING-UNSIGNED-BYTE ELEMENT-TYPE))                 (CL:SIGNED-BYTE (%GET-ENCLOSING-SIGNED-BYTE ELEMENT-TYPE))                 (CL:MOD (%REDUCE-MOD ELEMENT-TYPE))                 (INTEGER (%REDUCE-INTEGER ELEMENT-TYPE))                 (T (LET ((EXPANDER (TYPE-EXPANDER (CAR ELEMENT-TYPE))))                         (CL:IF EXPANDER (%GET-CANONICAL-CML-TYPE (TYPE-EXPAND ELEMENT-TYPE EXPANDER)                                                )                                T))))           (CASE ELEMENT-TYPE ((T XPOINTER CL:SINGLE-FLOAT CL:STRING-CHAR)                               ELEMENT-TYPE)                 (POINTER T)                 (FLOAT 'CL:SINGLE-FLOAT)                 (CL:FIXNUM '(CL:SIGNED-BYTE 32))                 (CL:CHARACTER 'CL:STRING-CHAR)                 (BIT '(CL:UNSIGNED-BYTE 1))                 (T (LET ((EXPANDER (TYPE-EXPANDER ELEMENT-TYPE)))                         (CL:IF EXPANDER (%GET-CANONICAL-CML-TYPE (TYPE-EXPAND ELEMENT-TYPE EXPANDER)                                                )                                T)))))))(%get-enclosing-signed-byte  (lambda (element-type)                                 (* \; "Edited  8-May-88 15:21 by jop")    (let ((nbits (cadr element-type)))         (cl:if (cl:integerp nbits)             (cond                ((<= nbits 16)                 '(cl:signed-byte 16))                ((<= nbits 32)                 '(cl:signed-byte 32))                (t t))             t))))(%get-enclosing-unsigned-byte  (lambda (element-type)                                 (* \; "Edited  8-May-88 15:21 by jop")    (let ((nbits (cadr element-type)))         (cl:if (cl:integerp nbits)             (cond                ((<= nbits 1)                 '(cl:unsigned-byte 1))                ((<= nbits 8)                 '(cl:unsigned-byte 8))                ((<= nbits 16)                 '(cl:unsigned-byte 16))                (t t))             t))))(%MAKE-ARRAY-STORAGE  (LAMBDA (NELTS TYPENUMBER INIT-ON-PAGE ALIGNMENT)          (* \; "Edited 18-Dec-86 17:47 by jop")                    (* |;;| "Allocates a raw storage block for an array of NELTS elements, of type TYPENUMBER")    (LET ((BITS-PER-ELEMENT (%TYPENUMBER-TO-BITS-PER-ELEMENT TYPENUMBER))          (GC-TYPE (%TYPENUMBER-TO-GC-TYPE TYPENUMBER)))         (\\ALLOCBLOCK (FOLDHI (CL:* NELTS BITS-PER-ELEMENT)                              BITSPERCELL)                GC-TYPE INIT-ON-PAGE ALIGNMENT))))(%reduce-integer  (lambda (element-type)                                 (* \; "Edited  8-May-88 15:27 by jop")    (let ((low (cadr element-type))          (high (caddr element-type)))         (cl:if (cl:consp low)             (setq low (cl:1+ (car low))))         (cl:if (cl:consp high)             (setq high (cl:1- (car high))))         (cl:if (and (cl:integerp low)                     (cl:integerp high))             (cl:if (>= low 0)                 (cond                    ((< high 2)                     '(cl:unsigned-byte 1))                    ((< high 256)                     '(cl:unsigned-byte 8))                    ((< high 65536)                     '(cl:unsigned-byte 16))                    (t t))                 (let ((bound (max (- low)                                   high)))                      (cond                         ((< bound 32768)                          '(cl:signed-byte 16))                         ((<= bound max.fixp)                          '(cl:signed-byte 32))                         (t t))))             t))))(%reduce-mod  (lambda (element-type)                                 (* \; "Edited  8-May-88 15:22 by jop")    (let ((modnum (cadr element-type)))         (cl:if (cl:integerp modnum)             (cond                ((<= modnum 2)                 '(cl:unsigned-byte 1))                ((<= modnum 256)                 '(cl:unsigned-byte 8))                ((<= modnum 65536)                 '(cl:unsigned-byte 16))                (t t))             t))))(%SLOW-ARRAY-READ  (LAMBDA (BASE TYPENUMBER ROW-MAJOR-INDEX)                  (* \; "Edited 18-Dec-86 17:52 by jop")                    (* |;;| "Punt function for opcode arrayread")    (%LLARRAY-TYPED-GET BASE TYPENUMBER ROW-MAJOR-INDEX)))(%SLOW-ARRAY-WRITE  (LAMBDA (NEWVALUE BASE TYPENUMBER ROW-MAJOR-INDEX)         (* \; "Edited 18-Dec-86 17:53 by jop")                    (* |;;| "Punt function for opcode arraywrite")    (CL:IF (NOT (%LLARRAY-TYPEP TYPENUMBER NEWVALUE))           (CL:ERROR "Illegal value: ~S" NEWVALUE)           (%LLARRAY-TYPED-PUT BASE TYPENUMBER ROW-MAJOR-INDEX NEWVALUE))    NEWVALUE)))(DEFOPTIMIZER %ARRAY-READ (BASE TYPENUMBER INDEX)                              `((OPCODES MISC3 9)                                ,BASE                                ,TYPENUMBER                                ,INDEX))(DEFOPTIMIZER %ARRAY-WRITE (NEWVALUE BASE TYPENUMBER INDEX)                               `((OPCODES MISC4 7)                                 ,NEWVALUE                                 ,BASE                                 ,TYPENUMBER                                 ,INDEX))(* |;;| "Compiler options")(DECLARE\: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY (DECLARE\: DOEVAL@COMPILE DONTCOPY(LOCALVARS . T)))(PUTPROPS CMLARRAY FILETYPE CL:COMPILE-FILE)(DECLARE\: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML )(ADDTOVAR LAMA CL:VECTOR ASET CL:ARRAY-ROW-MAJOR-INDEX CL:ARRAY-IN-BOUNDS-P CL:AREF))(PUTPROPS CMLARRAY COPYRIGHT ("Venue & Xerox Corporation" 1986 1987 1988 1990))(DECLARE\: DONTCOPY  (FILEMAP (NIL (35896 43767 (CL:AREF 35906 . 38655) (CL:ARRAY-IN-BOUNDS-P 38657 . 39076) (CL:ARRAY-ROW-MAJOR-INDEX 39078 . 39875) (ASET 39877 . 43462) (CL:VECTOR 43464 . 43765)) (43812 45816 (XCL:ROW-MAJOR-AREF 43822 . 44661) (CL::ROW-MAJOR-ASET 44663 . 45814)) (48049 86879 (%ALTER-AS-DISPLACED-ARRAY 48059 . 51275) (%ALTER-AS-DISPLACED-TO-BASE-ARRAY 51277 . 53017) (%AREF0 53019 . 53760) (%AREF1 53762 . 54704) (%AREF2 54706 . 56794) (%ARRAY-BASE 56796 . 57597) (%ARRAY-CONTENT-INITIALIZE 57599 . 58270) (%ARRAY-ELEMENT-INITIALIZE 58272 . 58623) (%ARRAY-OFFSET 58625 . 59371) (%ARRAY-TYPE-NUMBER 59373 . 60387) (%ASET0 60389 . 61456) (%ASET1 61458 . 62771) (%ASET2 62773 . 65045) (%CHECK-SEQUENCE-DIMENSIONS 65047 . 65624) (%COPY-TO-NEW-ARRAY 65626 . 66927) (%DO-LOGICAL-OP 66929 . 69150) (%EXTEND-ARRAY 69152 . 71292) (%FAST-COPY-BASE 71294 . 73957) (%FAT-STRING-ARRAY-P 73959 . 74147) (%FILL-ARRAY-FROM-SEQUENCE 74149 . 74823) (%FLATTEN-ARRAY 74825 . 75321) (%MAKE-ARRAY-WRITEABLE 75323 . 77631) (%MAKE-DISPLACED-ARRAY 77633 . 80337) (%MAKE-GENERAL-ARRAY 80339 . 81598) (%MAKE-ONED-ARRAY 81600 . 82645) (%MAKE-STRING-ARRAY-FAT 82647 . 85130) (%MAKE-TWOD-ARRAY 85132 . 85968) (%TOTAL-SIZE 85970 . 86266) (SHRINK-VECTOR 86268 . 86877)) (86923 89403 (%SET-ARRAY-OFFSET 86933 . 88645) (%SET-ARRAY-TYPE-NUMBER 88647 . 89401)) (89442 90169 (%ONED-ARRAY-P 89452 . 89623) (%TWOD-ARRAY-P 89625 . 89796) (%GENERAL-ARRAY-P 89798 . 89975) (%THIN-STRING-ARRAY-P 89977 . 90167)) (95114 106760 (%DEFPRINT-ARRAY 95124 . 96650) (%DEFPRINT-BITVECTOR 96652 . 99142) (%DEFPRINT-GENERIC-ARRAY 99144 . 100570) (%DEFPRINT-VECTOR 100572 . 103449) (%DEFPRINT-STRING 103451 . 104624) (%PRINT-ARRAY-CONTENTS 104626 . 106758)) (107049 112853 (%ARRAY-READ 107059 . 107162) (%ARRAY-WRITE 107164 . 107351) (%CML-TYPE-TO-TYPENUMBER 107353 . 107730) (%GET-CANONICAL-CML-TYPE 107732 . 109169) (%GET-ENCLOSING-SIGNED-BYTE 109171 . 109583) (%GET-ENCLOSING-UNSIGNED-BYTE 109585 . 110071) (%MAKE-ARRAY-STORAGE 110073 . 110609) (%REDUCE-INTEGER 110611 . 111709) (%REDUCE-MOD 111711 . 112190) (%SLOW-ARRAY-READ 112192 . 112452) (%SLOW-ARRAY-WRITE 112454 . 112851)))))STOP