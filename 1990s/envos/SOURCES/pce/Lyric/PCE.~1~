(DEFINE-FILE-INFO §PACKAGE "INTERLISP" §READTABLE "INTERLISP" §BASE 10)(FILECREATED "16-Feb-87 20:10:41" {ERINYES}<SANTOSA>PCE>PCE.;3 70574        changes to%:  (VARS PCECOMS)      previous date%: "16-Feb-87 14:59:50" {ERINYES}<SANTOSA>PCE>PCE.;2)(* "Copyright (c) 1985, 1986, 1987 by Xerox Corporation.  All rights reserved.")(PRETTYCOMPRINT PCECOMS)(RPAQQ PCECOMS        ((DECLARE%: FIRST (P (* turn off PCE processes if already loaded and running)                            (IF (CL:FBOUNDP '\PCE.TERMINATE)                                THEN                                ('\PCE.TERMINATE))                            (SETQ \PCE.INITIALIZED NIL)))        (FILES PCEDISPLAY PCEKEYBOARD PCEERD PCEFLOPPY VPCDISK)        (DECLARE%: DONTCOPY (FILES DOVEDECLS (SOURCE LOADFROM)                                   DOVEMISC))        (COMS (* User functions and variables)              (FNS PCE.BOARD.INSTALLED PCE.BOOT PCE.FREEZE PCE.QUIT PCE.RUN.STATE PCE.UNFREEZE)              (FNS PCE.PEEK PCE.PEEK.WORD PCE.POKE PCE.POKE.WORD)              (FNS PCE.PRINTER.OPENP PCE.PRINTER.GETFILE PCE.PRINTER.SETFILE PCE.PRINTER.CLOSEF)              (VARS (PCE.VERSION 2.0))              [INITVARS (PCE.DEFAULT.CONFIGURATION (COPYALL '(DISPLAYTYPE MONOCHROME RIGIDDISK NIL                                                                     BOOTDEVICE FLOPPY MEMORYSIZE 640                                                                     BIOSFILE "{DSK}PCE.BIOS" ERDFILE                                                                     "{DSK}PCE.DISK" KEYBOARDWAIT 500                                                                     KEYBOARDWAIT2 100 PRINTER NIL                                                                     PRINTERFILENAME "{NULL}"                                                                     FLOPPYDRIVES 1 PHYSICALFLOPPY 0                                                                     FLOPPYFILE0 "{DSK}PCE.FLOPPY"                                                                     FLOPPYPROTECTED0 NIL FLOPPYFILE1                                                                     "{DSK}PCE.FLOPPY1"                                                                     FLOPPYPROTECTED1 NIL FLOPPYFILE2                                                                     "{DSK}PCE.FLOPPY2"                                                                     FLOPPYPROTECTED2 NIL FLOPPYFILE3                                                                     "{DSK}PCE.FLOPPY3"                                                                     FLOPPYPROTECTED3 NIL]              (INITVARS (PCE.CONFIGURATION (COPYALL PCE.DEFAULT.CONFIGURATION)))              (INITVARS (PCE.PRINTER.FN))              (GLOBALVARS PCE.VERSION PCE.CONFIGURATION PCE.DEFAULT.CONFIGURATION PCE.PRINTER.FN))        (COMS (* Booting, configuring PC)              (FNS \PCE.FORK.AGENTS \PCE.NOTIFY \PCE.OPENSTREAM \PCE.SYSTEM.ERROR \PCE.TERMINATE)              (FNS \PCE.CONFIGURE \PCE.CONFIGURE.GETSWITCH)              (VARS (\PCE.DEBUG.FLG NIL))              (VARS \PCE.BOOTDRIVESWITCHES \PCE.DISPLAYSWITCHES \PCE.FLOPPYSWITCHES                     \PCE.MEMORYSWITCHES)              (GLOBALVARS \PCE.DEBUG.FLG \PCE.BOOTDRIVESWITCHES \PCE.DISPLAYSWITCHES                      \PCE.FLOPPYSWITCHES \PCE.MEMORYSWITCHES))        (COMS (* printer agent)              (FNS \PCE.PRINTER.Configure \PCE.PRINTER.Init \PCE.PRINTER.Notify                    \PCE.PRINTER.NotifyProcedure \PCE.PRINTER.Terminate)              (INITVARS (\PCE.PRINTER.Present)                     (\PCE.PRINTER.Condition)                     (\PCE.PRINTER.gotUpNotify)                     (\PCE.PRINTER.Process)                     (\PCE.PRINTER.Stream)                     (\PCE.PRINTER.FileName))              (GLOBALVARS \PCE.PRINTER.Present \PCE.PRINTER.Condition \PCE.PRINTER.gotUpNotify                      \PCE.PRINTER.Process \PCE.PRINTER.Stream \PCE.PRINTER.FileName))        (COMS (* Up notify watcher)              (FNS \PCE.UP.Terminate \PCE.UP.Init \PCE.UP.Watcher)              (INITVARS (\PCE.UP.Process))              (GLOBALVARS \PCE.UP.Process))        (COMS (* fns for loading the BIOS into the PC memory)              (FNS \PCE.OMF.ADVANCE \PCE.OMF.CHECK \PCE.OMF.LOAD \PCE.OMF.OPEN \PCE.OMF.MERGE)              (VARS \OMF.RECORDTYPES)              (GLOBALVARS \OMF.RECORDTYPES))        (COMS (* accessing PC memory and FCBs)              (FNS \PCE.AROUNDEXITFN \PCE.CHECK.INITIALIZED \PCE.CHECK.MACHINE \PCE.CLEARSUFI                    \PCE.GET.PC.PTR \PCE.INIT.FCB.POINTERS \PCE.INIT.MEMORY)              (ADDVARS (AROUNDEXITFNS \PCE.AROUNDEXITFN))              (VARS \PCE.MEMORY.BANK.LIST)              (INITVARS (\PCE.INITIALIZED)                     (\PCE.MEMORY.BANK.ARRAY)                     (\PCE.SUFIBLOCK)                     (\PCE.SUFIFIRSTRP)                     (\PCE.SUFILASTRP)                     (\PCE.SUFIBLOCKSIZE))              (GLOBALVARS \PCE.INITIALIZED \PCE.MEMORY.BANK.LIST \PCE.MEMORY.BANK.ARRAY                      \PCE.SUFIBLOCK \PCE.SUFIFIRSTRP \PCE.SUFILASTRP \PCE.SUFIBLOCKSIZE))        (COMS (* The PCE.xxxFCB records are mesarecords used for accessing the "mailboxes" used for                  communicating between IOP and lisp.)              (DECLARE%: DONTCOPY (RECORDS \PCE.DISPATCHER.FCB \PCE.DISPLAY.FCB \PCE.FLOPPY.FCB                                          \PCE.KEYBOARD.FCB \PCE.PRINTER.FCB \PCE.RIGIDDISK.FCB))              (INITRECORDS \PCE.DISPATCHER.FCB \PCE.DISPLAY.FCB \PCE.FLOPPY.FCB \PCE.KEYBOARD.FCB                      \PCE.PRINTER.FCB \PCE.RIGIDDISK.FCB)              (INITVARS (\PCE.DISPATCHER.FCBPTR)                     (\PCE.FLOPPY.FCBPTR)                     (\PCE.DISPLAY.FCBPTR)                     (\PCE.KEYBOARD.FCBPTR)                     (\PCE.PRINTER.FCBPTR)                     (\PCE.RIGIDDISK.FCBPTR))              (GLOBALVARS \PCE.DISPATCHER.FCBPTR \PCE.FLOPPY.FCBPTR \PCE.DISPLAY.FCBPTR                      \PCE.KEYBOARD.FCBPTR \PCE.PRINTER.FCBPTR \PCE.RIGIDDISK.FCBPTR))        [DECLARE%: DONTCOPY (ADDVARS (* just in case there is a break in the keyboard process, which                                         resets the keyaction table)                                   (BREAKRESETFORMS (SETQ \CURRENTKEYACTION \DEFAULTKEYACTION]        (CONSTANTS \PCE.ConfigureNotifyMask \PCE.PRINTERSWITCH \PCE.RIGIDBOOTSWITCH                \PCE.RIGIDDISKSWITCH \PCE.ExitNotifyMask \PCE.BOOTMASK \VMAP.CLEAN \PCE.agentPauseMask               )))(DECLARE%: FIRST (* turn off PCE processes if already loaded and running)(IF (CL:FBOUNDP '\PCE.TERMINATE)    THEN    ('\PCE.TERMINATE))(SETQ \PCE.INITIALIZED NIL))(FILESLOAD PCEDISPLAY PCEKEYBOARD PCEERD PCEFLOPPY VPCDISK)(DECLARE%: DONTCOPY (FILESLOAD DOVEDECLS (SOURCE LOADFROM)       DOVEMISC))(* User functions and variables)(DEFINEQ(PCE.BOARD.INSTALLED  [LAMBDA NIL                                                (* mjs "18-Apr-86 14:04")                    (* Returns T if this computer is an |1185/6| with a PC option board installed,           otherwise NIL)    (AND (EQ 'DOVE (MACHINETYPE))         (NOT (ZEROP (PROG NIL                    (* in releases beyond Koto, this PROG should be replaced by a call to the           function \DoveMisc.ReadPCType -- unfortunately, this fn was left out of Koto)                           (\DoveMisc.DoProcessorCommand \DoveMisc.ReadPCType)                           (RETURN (\DoveIO.ByteSwap (\GETBASE (fetch (Dove.ProcessorFCB Data)                                                                  of \DoveProcessor.FCBPointer)                                                            0])(PCE.BOOT  [LAMBDA (CONFIG)                                           (* mjs " 2-Jul-86 14:39")                    (* Configures the PC according to the property list CONFIG, and boots the PC.          If CONFIG is NIL, the value of the global PCE.CONFIGURATION is used.)                                                             (* see BootPC in PCEDISPATCHER.MESA)    (if (NULL CONFIG)        then (SETQ CONFIG PCE.CONFIGURATION))    (\PCE.CHECK.INITIALIZED)    (PCE.QUIT)    (\PCE.NOTIFY \PCE.ExitNotifyMask)    (with \PCE.DISPATCHER.FCB \PCE.DISPATCHER.FCBPTR         (* wait until IOP tasks are stopped)          (while (EQ 255 pcIOPTasksActive) do (BLOCK 100))          (SETQ pceUpNotifyBits 0))                    (* Load BIOS code into PC mem. Note that this must be done before configuring,           because \PCE.ERD.Configure smashes location in BIOS memory if ERD is not           present.)    (\PCE.OMF.LOAD (LISTGET CONFIG 'BIOSFILE))                    (* configure PC according to value of CONFIG.          Also configures I/O devices)    (\PCE.CONFIGURE CONFIG)                                  (* fork processes for lisp agents                                                              handling display, keyboard, etc.)    (\PCE.FORK.AGENTS)                                       (* actually boot the PC)    (\PCE.NOTIFY \PCE.BOOTMASK])(PCE.FREEZE  [LAMBDA NIL                                                (* mjs " 2-Jul-86 14:39")                    (* If the PC is running, it is paused, by clearing the pause bit in the runPCE           field. If the PC is halted or frozen, this function does nothing.)    (\PCE.CHECK.INITIALIZED)    (if (EQ T (PCE.RUN.STATE))        then (with \PCE.DISPATCHER.FCB \PCE.DISPATCHER.FCBPTR (SETQ runPCE (BITCLEAR runPCE                                                                                   \PCE.agentPauseMask                                                                                  ])(PCE.QUIT  [LAMBDA NIL                                                (* mjs " 2-Jul-86 14:39")                    (* Halts the PC, and deletes and lisp agent processes.          After calling PCE.QUIT, it is necessary to call PCE.BOOT to restart the PC           again.)    (\PCE.CHECK.INITIALIZED)    (replace (\PCE.DISPATCHER.FCB runPCE) of \PCE.DISPATCHER.FCBPTR with 0)                                                             (* flush lisp agent processes)    (\PCE.TERMINATE])(PCE.RUN.STATE  [LAMBDA NIL                                                (* mjs " 2-Jul-86 14:39")                    (* Returns NIL if the PC is halted, FROZEN if the PC is in the paused state,           otherwise T if the PC is running.)    (\PCE.CHECK.INITIALIZED)    (PROG ((STATE (fetch (\PCE.DISPATCHER.FCB runPCE) of \PCE.DISPATCHER.FCBPTR)))          (RETURN (if (EQ STATE 0)                      then NIL                    elseif (NULL (BITTEST \PCE.agentPauseMask STATE))                      then 'FROZEN                    else T])(PCE.UNFREEZE  [LAMBDA NIL                                                (* mjs " 2-Jul-86 14:39")                    (* If the PC is frozen it is unfrozen, by setting the pause bit in the runPCE           field. If the PC is halted or running, this function does nothing.)    (\PCE.CHECK.INITIALIZED)    (if (EQ 'FROZEN (PCE.RUN.STATE))        then (with \PCE.DISPATCHER.FCB \PCE.DISPATCHER.FCBPTR (SETQ runPCE (BITSET runPCE                                                                                   \PCE.agentPauseMask                                                                                  ]))(DEFINEQ(PCE.PEEK  [LAMBDA (PCADDR)                                           (* mjs "18-Apr-86 15:21")                    (* Returns the byte stored in PC memory byte address PCADDR.          Only the lower 20 bits of PCADDR are used;          no error is signalled if PCADDR is not in the range |0-1048576.|)                    (* The PC has an address space of 1048576 bytes, so PC addresses are 20 bits.          The top 4 bits indicate a 64KB memory block and the lower 16 bits the byte in           that memory block. \PCE.MEMORY.BANK.ARRAY is a 16-element array of pointers           mapping the PC memory blocks to the real memory.)    (\PCE.CHECK.INITIALIZED)    (\GETBASEBYTE (ELT \PCE.MEMORY.BANK.ARRAY (LOGAND 15 (LRSH PCADDR BITSPERWORD)))           (LOGAND PCADDR MAX.SMALLP])(PCE.PEEK.WORD  [LAMBDA (PCADDR)                                           (* mjs "18-Apr-86 15:21")                    (* Returns the 16-bit word stored in PC mem byte locations PCADDR and PCADDR+1.          We assume that the word is stored LEAST-SIGNIFICANT-BYTE first, to conform with           PC conventions)    (\PCE.CHECK.INITIALIZED)    (PROG ([BASE (ELT \PCE.MEMORY.BANK.ARRAY (LOGAND 15 (LRSH PCADDR BITSPERWORD]           (PCOFFSET (LOGAND PCADDR MAX.SMALLP)))          (RETURN (if (EQP PCOFFSET MAX.SMALLP)                      then                     (* if PCADDR is last byte of |64K| block, get bytes separately)                           (LOGOR (PCE.PEEK PCADDR)                                  (LLSH (PCE.PEEK (ADD1 PCADDR))                                        8))                    else                     (* note that we can't use \GETBASE, since PCADDR may not be word-aligned.)                         (LOGOR (\GETBASEBYTE BASE PCOFFSET)                                (LLSH (\GETBASEBYTE BASE (ADD1 PCOFFSET))                                      8])(PCE.POKE  [LAMBDA (PCADDR VAL)                                       (* mjs "18-Apr-86 15:21")                    (* Stores low-order byte of VAL into PC memory byte address PCADDR.          Only the lower 20 bits of PCADDR are used;          no error is signalled if PCADDR is not in the range |0-1048576.|)    (\PCE.CHECK.INITIALIZED)    (\PUTBASEBYTE (ELT \PCE.MEMORY.BANK.ARRAY (LOGAND 15 (LRSH PCADDR BITSPERWORD)))           (LOGAND PCADDR MAX.SMALLP)           (LOGAND VAL 255])(PCE.POKE.WORD  [LAMBDA (PCADDR VAL)                                       (* mjs "18-Apr-86 15:21")                    (* Stored low-order word of VAL into PC mem byte locations PCADDR and PCADDR+1.          We assume that the word is stored LEAST-SIGNIFICANT-BYTE first, to conform with           PC conventions)    (\PCE.CHECK.INITIALIZED)    (PROG ([BASE (ELT \PCE.MEMORY.BANK.ARRAY (LOGAND 15 (LRSH PCADDR BITSPERWORD]           (PCOFFSET (LOGAND PCADDR MAX.SMALLP)))          (if (EQP PCOFFSET MAX.SMALLP)              then                     (* if PCADDR is last byte of |64K| block, put bytes separately)                   (PCE.POKE PCADDR VAL)                   (PCE.POKE (ADD1 PCADDR)                          (LRSH (LOGAND VAL 65535)                                8))            else                     (* note that we can't use \PUTBASE, since PCADDR may not be word-aligned.)                 (\PUTBASEBYTE BASE PCOFFSET (LOGAND VAL 255))                 (\PUTBASEBYTE BASE (ADD1 PCOFFSET)                        (LRSH (LOGAND VAL 65535)                              8)))          (RETURN 0]))(DEFINEQ(PCE.PRINTER.OPENP  [LAMBDA NIL                                                (* mjs "18-Apr-86 15:30")                    (* Returns the printer stream if it is open, otherwise NIL)    (AND (STREAMP \PCE.PRINTER.Stream)         (OPENP \PCE.PRINTER.Stream])(PCE.PRINTER.GETFILE  [LAMBDA NIL                                                (* mjs "18-Apr-86 15:30")                                                             (* Returns the current printer file                                                              name)    \PCE.PRINTER.FileName])(PCE.PRINTER.SETFILE  [LAMBDA (FILENAME)                                         (* mjs "18-Apr-86 15:30")                    (* Sets the current printer file name. This also closes the printer stream if           it is open, so that the printer file name always corresponds to the stream.)    (SETQ \PCE.PRINTER.FileName FILENAME)    (PCE.PRINTER.CLOSEF])(PCE.PRINTER.CLOSEF  [LAMBDA NIL                                                (* mjs "18-Apr-86 15:30")                                                             (* Closes the current printer stream,                                                              if open.)    (if (PCE.PRINTER.OPENP)        then (PROG ((STREAM \PCE.PRINTER.Stream))                    (* Reset \PCE.PRINTER.Stream first, so that PC can send chars to new printer           stream while current stream is being closed <which may take awhile>)                   (SETQ \PCE.PRINTER.Stream NIL)                   (CLOSEF STREAM]))(RPAQQ PCE.VERSION 2.0)(RPAQ? PCE.DEFAULT.CONFIGURATION        (COPYALL '(DISPLAYTYPE MONOCHROME RIGIDDISK NIL BOOTDEVICE FLOPPY MEMORYSIZE 640 BIOSFILE                         "{DSK}PCE.BIOS" ERDFILE "{DSK}PCE.DISK" KEYBOARDWAIT 500 KEYBOARDWAIT2 100                         PRINTER NIL PRINTERFILENAME "{NULL}" FLOPPYDRIVES 1 PHYSICALFLOPPY 0                         FLOPPYFILE0 "{DSK}PCE.FLOPPY" FLOPPYPROTECTED0 NIL FLOPPYFILE1                         "{DSK}PCE.FLOPPY1" FLOPPYPROTECTED1 NIL FLOPPYFILE2 "{DSK}PCE.FLOPPY2"                         FLOPPYPROTECTED2 NIL FLOPPYFILE3 "{DSK}PCE.FLOPPY3" FLOPPYPROTECTED3 NIL)))(RPAQ? PCE.CONFIGURATION (COPYALL PCE.DEFAULT.CONFIGURATION))(RPAQ? PCE.PRINTER.FN )(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS PCE.VERSION PCE.CONFIGURATION PCE.DEFAULT.CONFIGURATION PCE.PRINTER.FN))(* Booting, configuring PC)(DEFINEQ(\PCE.FORK.AGENTS  [LAMBDA NIL                                                (* mjs "16-Jul-86 14:39")                                                             (* Creates processes for lisp agents                                                              handling various PCE I/O.)    (\PCE.DISPLAY.Init)    (\PCE.KEYBOARDINIT)    (\PCE.ERD.Init)    (\PCE.PRINTER.Init)    (\PCE.FLOPPY.Init)                    (* The up notify process should not be called until all others have been           created, since it expects the others to be available to handle requests from           the PC)    (\PCE.UP.Init])(\PCE.NOTIFY  [LAMBDA (MASK)                                             (* mjs " 2-Jul-86 14:39")                    (* * sends down notify from lisp agent to IOP, using the mask MASK, and locking           the access to the dispatcher FCB)                    (* * Currently, only \PCE.CONFIGURE and PCE.BOOT call \PCE.NOTIFY.          Most lisp agents just call \DoveIO.NotifyIOP which translates into an opcode)                    (* * see DownNotify in PCEDispatcher.mesa)    (\DoveIO.LockMem \DoveIO.OR (\DoveIO.IORegionOffset (LOCF (fetch (\PCE.DISPATCHER.FCB                                                                             pceWorkingDNWord)                                                                 of \PCE.DISPATCHER.FCBPTR)))           MASK           (fetch (\PCE.DISPATCHER.FCB pceLockMask) of \PCE.DISPATCHER.FCBPTR))    (\DoveIO.NotifyIOP (fetch (\PCE.DISPATCHER.FCB pceMesaWorkMask) of \PCE.DISPATCHER.FCBPTR])(\PCE.OPENSTREAM  [LAMBDA (FILE ACCESS RECOG PARAMETERS)                     (* mjs "22-Apr-86 13:25")                    (* * opens file for PCE, with appropriate error message and retry behavior           <<really, something like this should be in OPENSTREAM>>)    (bind STREAM until (AND [SETQ STREAM (CAR (NLSETQ (OPENSTREAM FILE ACCESS RECOG PARAMETERS]                            (OPENP STREAM)) do (SETQ FILE (if (ERROR (CONCAT "PCE can't open file: "                                                                             FILE)                                                                     "To retry opening the same file name, type: RETURNTo try a different file name, type:     RETURN '{host}<dir>newname")                                                            else FILE)) finally (RETURN STREAM])(\PCE.SYSTEM.ERROR  [LAMBDA (MSG1 MSG2)                                        (* mjs "24-Apr-86 15:01")                    (* * Called for all PCE errors that the user could not be expected to           understand or correct.)    (ERROR (CONCAT "PCE System Error: " MSG1)           MSG2])(\PCE.TERMINATE  [LAMBDA NIL                                                (* mjs "16-Jul-86 14:40")                    (* * Terminate all PCE agents)                    (* * Note%: All of the termination fns are called under NLSETQ so that           \PCE.TERMINATE can be called when the file is loaded to terminate all active           PCE processes, even if some of these fns are not defined yet.          Also note that none of these fns should do anything with PCE memory structures,           since they may be called before the memory is initialized.)                    (* Up notify process must be flushed first, since it tries to notify other           agents)    (NLSETQ (\PCE.UP.Terminate))    (NLSETQ (\PCE.KEYBOARD.TERMINATE))    (NLSETQ (\PCE.DISPLAY.Terminate))    (NLSETQ (\PCE.ERD.Terminate))    (NLSETQ (\PCE.PRINTER.Terminate))    (NLSETQ (\PCE.FLOPPY.Terminate]))(DEFINEQ(\PCE.CONFIGURE  [LAMBDA (CONFIG)                                           (* mjs "16-Jul-86 12:01")                    (* * Configures the PC according the property list CONFIG.          First sets the values of three simulated dip switches, to tell the PC what I/O           is connected, then calls seperate fns to configure each of the I/O devices.)                    (* * This is just a copy of SetPseudoConfigSwitches in PCEDispatcher.mesa)    (PROG ((SWITCH0 0)           (SWITCH1 0)           (SWITCH2 0))                    (* * Set SWITCH0. The only thing here that is interesting is the printer          (or absence of printer))          (if (LISTGET CONFIG 'PRINTER)              then (SETQ SWITCH0 (BITSET SWITCH1 \PCE.PRINTERSWITCH)))                    (* * Set switch 1.0 The first bit is always 1)          (SETQ SWITCH1 (BITSET SWITCH1 1))                    (* * set the number of floppies)          (SETQ SWITCH1 (BITSET SWITCH1 (\PCE.CONFIGURE.GETSWITCH CONFIG 'FLOPPYDRIVES                                                \PCE.FLOPPYSWITCHES)))                    (* * set the display type)          (SETQ SWITCH1 (BITSET SWITCH1 (\PCE.CONFIGURE.GETSWITCH CONFIG 'DISPLAYTYPE                                                \PCE.DISPLAYSWITCHES)))                    (* * set the memory size)          (SETQ SWITCH1 (BITSET SWITCH1 (\PCE.CONFIGURE.GETSWITCH CONFIG 'MEMORYSIZE                                                \PCE.MEMORYSWITCHES)))                    (* * Set SWITCH2. Note that 80187 bit always 0)          (if (EQ (LISTGET CONFIG 'BOOTDEVICE)                  'FLOPPY)              then (SETQ SWITCH2 (BITSET SWITCH2 (\PCE.CONFIGURE.GETSWITCH CONFIG 'BOOTDRIVE                                                         \PCE.BOOTDRIVESWITCHES)))            else (SETQ SWITCH2 (BITSET SWITCH2 \PCE.RIGIDBOOTSWITCH)))                    (* * Set Rigid disk)          (if (LISTGET CONFIG 'RIGIDDISK)              then (SETQ SWITCH2 (BITSET SWITCH2 \PCE.RIGIDDISKSWITCH)))                    (* * Set available memory again. Note that we don't have to worry about the           value of LISTGET not being a number or NIL, since it was checked against           \PCE.MEMORYSWITCHES above.)          [SETQ SWITCH2 (LOGOR SWITCH2 (LOGAND 255 (IQUOTIENT (if (LISTGET CONFIG 'MEMORYSIZE)                                                                else 640)                                                          64]                    (* * Put the switch values in the FCB)          (with \PCE.DISPATCHER.FCB \PCE.DISPATCHER.FCBPTR (SETQ pseudoConfigSwitch0 SWITCH0)                (SETQ pseudoConfigSwitch1 SWITCH1)                (SETQ pseudoConfigSwitch2 SWITCH2))                    (* * configure each of the I/O devices)          (\PCE.KEYBOARD.CONFIGURE CONFIG)          (\PCE.DISPLAY.Configure CONFIG)          (\PCE.FLOPPY.Configure CONFIG)          (\PCE.PRINTER.Configure CONFIG)          (\PCE.ERD.Configure CONFIG)                    (* * Tell the IOP to configure the PC)          (\PCE.NOTIFY \PCE.ConfigureNotifyMask T])(\PCE.CONFIGURE.GETSWITCH  [LAMBDA (CONFIG PROPNAME SWITCH.ALIST)                     (* mjs "18-Apr-86 16:17")                    (* The property values on PCE.CONFIGURATION are fairly understandable, but           \PCE.CONFIGURE wants these mapped to numeric values for setting the PC           pseudo-dip switches. This is done using a set of association lists.          \PCE.CONFIGURE.GETSWITCH finds PROPNAME on the property list CONFIG, and maps           it through the assoc list SWITCH.ALIST to get a switch value.          If not found, causes an uncontinuable error.)    (if (CDR (ASSOC (LISTGET CONFIG PROPNAME)                    SWITCH.ALIST))      else (ERROR "Bad configuration value" (LIST PROPNAME (LISTGET CONFIG PROPNAME)))           (ERROR!]))(RPAQQ \PCE.DEBUG.FLG NIL)(RPAQQ \PCE.BOOTDRIVESWITCHES ((NIL . 0)                               (A . 0)                               (B . 32)                               (C . 64)                               (D . 96)                               (0 . 0)                               (1 . 32)                               (2 . 64)                               (3 . 96)))(RPAQQ \PCE.DISPLAYSWITCHES ((NIL . 48)                             (MONOCHROME . 48)                             (COLOR40 . 16)                             (COLOR80 . 32)                             (COLOR . 32)))(RPAQQ \PCE.FLOPPYSWITCHES ((NIL . 0)                            (1 . 0)                            (2 . 64)                            (3 . 128)                            (4 . 192)))(RPAQQ \PCE.MEMORYSWITCHES ((NIL . 12)                            (128 . 4)                            (256 . 12)                            (384 . 12)                            (512 . 12)                            (640 . 12)))(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.DEBUG.FLG \PCE.BOOTDRIVESWITCHES \PCE.DISPLAYSWITCHES \PCE.FLOPPYSWITCHES        \PCE.MEMORYSWITCHES))(* printer agent)(DEFINEQ(\PCE.PRINTER.Configure  [LAMBDA (CONFIG)                                           (* mjs "24-Apr-86 13:53")                    (* * Set variables used by printer agent, if printer is specified in CONFIG.          Note that we do not open \PCE.PRINTER.Stream now ---          it is opened when the first char is sent to the printer port.)    (\PCE.PRINTER.Terminate)    (if (LISTGET CONFIG 'PRINTER)        then (SETQ \PCE.PRINTER.Present T)             (SETQ \PCE.PRINTER.FileName (LISTGET CONFIG 'PRINTERFILENAME))             (SETQ \PCE.PRINTER.Stream NIL)      else (SETQ \PCE.PRINTER.Present NIL])(\PCE.PRINTER.Init  [LAMBDA NIL                                                (* mjs "28-Jul-86 10:45")                    (* * Create printer agent process, if the PC is configured to have a printer.          \PCE.PRINTER.Condition and \PCE.PRINTER.gotUpNotify are used to signal the           printer agent process that an up notify has been received)    (if \PCE.PRINTER.Present        then (SETQ \PCE.PRINTER.Condition (CREATE.EVENT 'PRINTER.Condition))             (SETQ \PCE.PRINTER.gotUpNotify NIL)             (SETQ \PCE.PRINTER.Process (ADD.PROCESS (LIST (FUNCTION \PCE.PRINTER.NotifyProcedure))                                               'NAME                                               'PCE-PRINTER                                               'AFTEREXIT                                               'DELETE                                               'RESTARTABLE                                               'HARDRESET                                               'RESTARTFORM                                               (LIST (FUNCTION \PCE.PRINTER.Init])(\PCE.PRINTER.Notify  [LAMBDA NIL                                                (* mjs " 1-May-86 12:41")                    (* * Notifies the printer agent that an up notify for the printer has been           received.)    (SETQ \PCE.PRINTER.gotUpNotify T)    (if (TYPENAMEP \PCE.PRINTER.Condition 'EVENT)        then (NOTIFY.EVENT \PCE.PRINTER.Condition)      elseif \PCE.DEBUG.FLG        then (\PCE.SYSTEM.ERROR "\PCE.PRINTER.Condition not an event" \PCE.PRINTER.Condition])(\PCE.PRINTER.NotifyProcedure  [LAMBDA NIL                                                (* mjs " 2-Jul-86 14:48")                    (* * This is the printer agent procedure, that is spawned as a process.          It loops forever, waiting for an up notify, and handling the request)                    (* * See NotifyProcedure in PCEPrinter.mesa)    (while T bind (BUFFERPTR _ (LOCF (fetch (\PCE.PRINTER.FCB printerBuffer) of \PCE.PRINTER.FCBPTR))                         )                  (g.lockForGet _ 0)                  (g.bufferOut _ 0)                  [g.lockAddress _ (\DoveIO.IORegionOffset (LOCF (fetch (\PCE.PRINTER.FCB prLock)                                                                    of \PCE.PRINTER.FCBPTR]                  (g.lockMask _ (fetch (\PCE.DISPATCHER.FCB pceLockMask) of \PCE.DISPATCHER.FCBPTR))       do                                                    (* repeat forever)                    (* * Note%: The printer agent is different from the other agents in that it has           to tell the IOP when it is waiting to receive another up notify.          This is done for performance, so that the printer can grab multiple chars from           the IOP's buffer, only asking for an up notify when the buffer is empty.)          (replace (\PCE.PRINTER.FCB needUpNotify) of \PCE.PRINTER.FCBPTR with 1)                     (* * Wait for up notify)          (until \PCE.PRINTER.gotUpNotify do (AWAIT.EVENT \PCE.PRINTER.Condition))          (SETQ \PCE.PRINTER.gotUpNotify NIL)                     (* * Send chars to the printer until it is empty.)          (with \PCE.PRINTER.FCB \PCE.PRINTER.FCBPTR                (until (ZEROP count) for BLOCKCNT from 1 bind \PCE.PRINTER.BYTE.SPECVAR                   declare%: (SPECVARS \PCE.PRINTER.BYTE.SPECVAR)                   do (if (IGREATERP BLOCKCNT 80)                          then                               (* block at least once every line or                                                              so)                               (SETQ BLOCKCNT 1)                               (BLOCK))                     (* * get byte from ring buffer, and update buffer pointer)                      (SETQ \PCE.PRINTER.BYTE.SPECVAR (\GETBASEBYTE BUFFERPTR g.bufferOut))                      (SETQ g.bufferOut (if (EQ g.bufferOut 253)                                            then 0                                          else (ADD1 g.bufferOut)))                     (* Print char under NLSETQ, in case an error occurs while opening the printer           file or calling the user print fn or BOUT'ing the char.          If an error occurs, only the one char is lost.)                      (NLSETQ (if PCE.PRINTER.FN                                  then                     (* if user has own printer function, just pass the byte to it)                                       (APPLY* PCE.PRINTER.FN \PCE.PRINTER.BYTE.SPECVAR)                                else                     (* if no user fn, send to printer stream, opening it first if it is closed.)                                     [if (NOT (PCE.PRINTER.OPENP))                                         then (SETQ \PCE.PRINTER.Stream (\PCE.OPENSTREAM                                                                                \PCE.PRINTER.FileName                                                                               'OUTPUT                                                                               'NEW]                                     (BOUT \PCE.PRINTER.Stream \PCE.PRINTER.BYTE.SPECVAR)))                     (* * obtain lock for "count" field, looping indefinitely until it is free)                      (for CNT from 0 while (ZEROP (SETQ g.lockForGet (\DoveIO.LockMem \DoveIO.XCHG                                                                              g.lockAddress                                                                              g.lockForGet g.lockMask)                                                    )) do (if (IGREATERP CNT 10)                                                              then                                                              (* must block occasionally)                                                                   (SETQ CNT 0)                                                                   (BLOCK 100)))                     (* * decrement "count" field safely. We have to be careful since the IOP can be           adding chars to the buffer while we are printing them.)                      (SETQ count (SUB1 count))                     (* * release lock on "count" field)                      (SETQ g.lockForGet (\DoveIO.LockMem \DoveIO.XCHG g.lockAddress g.lockForGet                                                 g.lockMask])(\PCE.PRINTER.Terminate  [LAMBDA NIL                                                (* mjs "24-Apr-86 14:59")                    (* * flush printer agent process, and reset printer agent variables)    (if (PROCESSP \PCE.PRINTER.Process)        then (DEL.PROCESS \PCE.PRINTER.Process))    (SETQ \PCE.PRINTER.Present NIL)    (SETQ \PCE.PRINTER.Condition NIL)    (SETQ \PCE.PRINTER.gotUpNotify NIL)    (SETQ \PCE.PRINTER.Process NIL)    (if (PCE.PRINTER.OPENP)        then                                                 (* Close printer stream, if open)             (CLOSEF \PCE.PRINTER.Stream))    (SETQ \PCE.PRINTER.Stream NIL]))(RPAQ? \PCE.PRINTER.Present )(RPAQ? \PCE.PRINTER.Condition )(RPAQ? \PCE.PRINTER.gotUpNotify )(RPAQ? \PCE.PRINTER.Process )(RPAQ? \PCE.PRINTER.Stream )(RPAQ? \PCE.PRINTER.FileName )(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.PRINTER.Present \PCE.PRINTER.Condition \PCE.PRINTER.gotUpNotify \PCE.PRINTER.Process        \PCE.PRINTER.Stream \PCE.PRINTER.FileName))(* Up notify watcher)(DEFINEQ(\PCE.UP.Terminate  [LAMBDA NIL                                                (* mjs "24-Apr-86 16:16")                    (* * Flush up watcher process)    (if (PROCESSP \PCE.UP.Process)        then (DEL.PROCESS \PCE.UP.Process))    (SETQ \PCE.UP.Process NIL)                    (* * make sure that any blinking chars are showing, and the caret is down <the           up watcher handles blinking chars and caret because it is the only PCE process           that it always running>)    (\PCE.BLINK.CHARS.SET T)    (\PCE.BLINK.CARET.SET NIL])(\PCE.UP.Init  [LAMBDA NIL                                                (* mjs "28-Jul-86 10:45")                    (* * Create up notify watcher process, which passes any up notifies to the           appropriate lisp agent)    (SETQ \PCE.UP.Process (ADD.PROCESS (LIST (FUNCTION \PCE.UP.Watcher))                                 'NAME                                 'PCE-UP-WATCHER                                 'AFTEREXIT                                 'DELETE                                 'RESTARTABLE                                 'HARDRESET])(\PCE.UP.Watcher  [LAMBDA NIL                                                (* mjs " 2-Jul-86 14:39")                    (* * This is the up watcher procedure, that is spawned as a process.          It loops forever, passing any up notifies to the appropriate lisp agent)                    (* * See PCEUpNotifyWatcher in PCEDispatcher.mesa)                    (* * Note%: The up watcher process is also used for blinking the blinking chars           and the caret on the PCE display, because this is the only PCE process that is           always running. <I really hate doing this, but I don't want to create any more           PCE processes than necessary>)    (while T bind [lockAddress _ (\DoveIO.IORegionOffset (LOCF (fetch (\PCE.DISPATCHER.FCB                                                                              pceUpNotifyBits)                                                                  of \PCE.DISPATCHER.FCBPTR]                  (lockMask _ (fetch (\PCE.DISPATCHER.FCB pceLockMask) of \PCE.DISPATCHER.FCBPTR))                  UpNotifyBits       do (* * Safely grab up notify bits, and notify lisp agents if their bit is set)          (SETQ UpNotifyBits (\DoveIO.ByteSwap (\DoveIO.LockMem \DoveIO.XCHG lockAddress 0 lockMask))           )          (bind (MASK _ 32768) until (OR (ZEROP UpNotifyBits)                                         (ZEROP MASK))             do (if (BITTEST MASK UpNotifyBits)                    then [SELECTQ MASK                             (32768 (\PCE.DISPLAY.Notify))                             (16384 (\PCE.FLOPPY.Notify))                             (8192 (\PCE.ERD.Notify))                             (4096 (\PCE.PRINTER.Notify))                             (PROGN                          (* known unimplemented up notifies%:                                                             (2048 (* up notify for timer) NIL)                                                             (1024 (* up notify for keyboard) NIL))                                    (if \PCE.DEBUG.FLG                                        then (\PCE.SYSTEM.ERROR "Unrecognized Up Notify bits" MASK]                     (* clear bits so we can stop scanning after the last on bit is interpreted)                         (BITCLEAR UpNotifyBits MASK))                (SETQ MASK (LRSH MASK 1)))                     (* * check blinking chars and caret)          (\PCE.BLINK)          (BLOCK]))(RPAQ? \PCE.UP.Process )(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.UP.Process))(* fns for loading the BIOS into the PC memory)(DEFINEQ(\PCE.OMF.ADVANCE  [LAMBDA (STREAM)                                           (* mjs "21-Apr-86 16:24")                    (* * Looks at the next OMF record on the stream STREAM <at the filepos stored           as the CURRENTRECORD stream prop>, and returns a cons cell whose CAR is the           type of record, and whose CDR is the length of the record.)    (PROG ((RECTYPE NIL)           RECLEN RECLENLO RECLENHI)          (SETFILEPTR STREAM (STREAMPROP STREAM 'CURRENTRECORD))          [if (EOFP STREAM)              then (RETURN (CONS 'EOF 'EOF]          (SETQ RECTYPE (BIN STREAM))          (if (NOT (FASSOC RECTYPE \OMF.RECORDTYPES))              then (ERROR "Bad BIOS file" (FULLNAME STREAM)))          (SETQ RECLENLO (BIN STREAM))          (SETQ RECLENHI (BIN STREAM))          (SETQ RECLEN (IPLUS (ITIMES RECLENHI 256)                              RECLENLO))          (STREAMPROP STREAM 'CURRENTRECORD (IPLUS (GETFILEPTR STREAM)                                                   RECLEN))          (RETURN (CONS (CDR (FASSOC RECTYPE \OMF.RECORDTYPES))                        RECLEN])(\PCE.OMF.CHECK  [LAMBDA (FILE)                                             (* mjs "21-Apr-86 16:37")                    (* * Reads FILE as an "OMF format" file, and prints out info about all of the           records in the file, including the record type, record size, and <for           PHYSICALENUMERATEDDATA records> the PC address where the block would be loaded.)    (PROG ((STREAM (\PCE.OPENSTREAM FILE 'INPUT))           RECTYPE RECTYPENUM RECLEN RECLENLO RECLENHI PCADDR OLDFILEPTR)          (SETFILEPTR STREAM 0)          (repeatuntil (EOFP STREAM) do (SETQ RECTYPENUM (BIN STREAM))                                        (SETQ RECTYPE (CDR (FASSOC RECTYPENUM \OMF.RECORDTYPES)))                                        (SETQ RECLENLO (BIN STREAM))                                        (SETQ RECLENHI (BIN STREAM))                                        (SETQ RECLEN (IPLUS (ITIMES RECLENHI 256)                                                            RECLENLO))                                        (printout T "Type " (if RECTYPE                                                              else (CONCAT "<<<unknown type #"                                                                           RECTYPENUM ">>>"))                                               " at "                                               (IDIFFERENCE (GETFILEPTR STREAM)                                                      3)                                               " is size " RECLEN " bytes")                                        (SETQ OLDFILEPTR (GETFILEPTR STREAM))                                        (if (EQ RECTYPE 'PHYSICALENUMERATEDDATA)                                            then (SETQ PCADDR (BIN STREAM))                                                 [SETQ PCADDR (IPLUS PCADDR (ITIMES 256 (BIN STREAM]                                                 (SETQ PCADDR (IPLUS (ITIMES PCADDR 16)                                                                     (BIN STREAM)))                                                 (RADIX 16)                                                 (printout T "    Block starts at " PCADDR)                                                 (RADIX 10))                                        (SETFILEPTR STREAM (IPLUS OLDFILEPTR RECLEN))                                        (printout T T))          (CLOSEF STREAM])(\PCE.OMF.LOAD  [LAMBDA (FILENAME)                                         (* mjs "21-Apr-86 16:24")                    (* * Loads the file FILENAME in "OMF format" into the PC's memory.          This is used to load the file PCE.BIOS, containing the BIOS code that is           normally stored in a ROM in a real PC)                    (* * Note%: Only the PHYSICALENUMERATEDDATA block is interpreted.          All other types of blocks <declarations, etc.> are ignored.)    (\PCE.CHECK.INITIALIZED)    (PROG ((STREAM (\PCE.OMF.OPEN FILENAME))           RECORDINFO PCADDR PCMEMPTR)          (do (SETQ RECORDINFO (\PCE.OMF.ADVANCE STREAM))              (SELECTQ (CAR RECORDINFO)                  (EOF (ERROR "Bad BIOS file" (FULLNAME STREAM)))                  (PHYSICALENUMERATEDDATA                        (SETQ PCADDR (BIN STREAM))                       (SETQ PCADDR (IPLUS PCADDR (ITIMES (BIN STREAM)                                                         256)))                       (SETQ PCADDR (IPLUS (ITIMES PCADDR 16)                                           (BIN STREAM)))                       (SETQ PCMEMPTR (\PCE.GET.PC.PTR PCADDR))                    (* major bug was caused by using (IDIFFERENCE          (CDR RECORDINFO) 5) instead -- caused last byte of BIOS routines not to be           loaded)                       (\BINS STREAM PCMEMPTR 0 (IDIFFERENCE (CDR RECORDINFO)                                                       4)))                  (MODULEEND (RETURN))                  (PROGN NIL)))          (CLOSEF STREAM)      NIL])(\PCE.OMF.OPEN  [LAMBDA (FILE)                                             (* mjs "21-Apr-86 16:11")                    (* * Opens OMF format file, and initializes CURRENTRECORD property <used by           \PCE.OMF.ADVANCE>)    (PROG (NEWSTREAM)          (SETQ NEWSTREAM (\PCE.OPENSTREAM FILE 'INPUT))          (SETFILEPTR NEWSTREAM 0)          (STREAMPROP NEWSTREAM 'CURRENTRECORD 0)          (RETURN NEWSTREAM])(\PCE.OMF.MERGE  [LAMBDA (TOFILENAME FROMFILENAMES)                         (* mjs "21-Apr-86 16:37")                    (* * Merges the OMF format files in the list FROMFILENAMES, producing the new           OMF file TOFILENAME. Only the PHYSICALENUMERATEDDATA records are copied --          all others are ignored.)    (PROG ((OUTSTREAM (\PCE.OPENSTREAM TOFILENAME 'OUTPUT 'NEW))           RECTYPE RECLEN RECLENLO RECLENHI)          (for INFILENAME in (MKLIST FROMFILENAMES) bind INSTREAM             do (SETQ INSTREAM (\PCE.OPENSTREAM INFILENAME 'INPUT))                (SETFILEPTR INSTREAM 0)                [repeatuntil (EOFP INSTREAM)                   do (SETQ RECTYPE (BIN INSTREAM))                      (if (NOT (FASSOC RECTYPE \OMF.RECORDTYPES))                          then (HELP "UNRECOGNIZED OMF RECORD TYPE" RECTYPE))                      (SETQ RECLENLO (BIN INSTREAM))                      (SETQ RECLENHI (BIN INSTREAM))                      (SETQ RECLEN (IPLUS (ITIMES RECLENHI 256)                                          RECLENLO))                      (SELECTQ (CDR (FASSOC RECTYPE \OMF.RECORDTYPES))                          (PHYSICALENUMERATEDDATA                                (BOUT OUTSTREAM RECTYPE)                               (BOUT OUTSTREAM RECLENLO)                               (BOUT OUTSTREAM RECLENHI)                               (for X from 1 to RECLEN do (BOUT OUTSTREAM (BIN INSTREAM))))                          (MODULEEND                     (* if module ends, don't want to read any more from this file)                                     (SETFILEPTR INSTREAM (GETEOFPTR INSTREAM)))                          (PROGN                             (* just ignore any other types of                                                              records)                                 (SETFILEPTR INSTREAM (IPLUS (GETFILEPTR INSTREAM)                                                             RECLEN]                (CLOSEF INSTREAM))                    (* * add MODULEEND record as end of file, including magic bytes 2 0 0 116 found           in old OMF file)          [BOUT OUTSTREAM (CAR (for X in \OMF.RECORDTYPES thereis (EQ (CDR X)                                                                      'MODULEEND]          (for X in '(2 0 0 116) do (BOUT OUTSTREAM X))          (CLOSEF OUTSTREAM]))(RPAQQ \OMF.RECORDTYPES ((110 . RHEADER)                         (112 . REGISTERINITIALIZATION)                         (114 . RELOCATABLEENUMERATEDDATA)                         (116 . RELOCATABLEITERATEDDATA)                         (118 . OVERLAYDEFINITION)                         (120 . ENDRECORD)                         (122 . BLOCKDEFINITION)                         (124 . BLOCKEND)                         (126 . DEBUGSYMBOL)                         (128 . THEADER)                         (130 . LHEADER)                         (132 . PHYSICALENUMERATEDDATA)                         (134 . PHYSICALITERATEDDATA)                         (136 . COMMENT)                         (138 . MODULEEND)                         (140 . EXTERNALDEFINITION)                         (142 . TYPEDEFINITION)                         (144 . PUBLICDEFINITION)                         (146 . LOCALSYMBOL)                         (148 . LINENUMBER)                         (150 . LISTOFNAMES)                         (152 . SEGMENTDEFINITION)                         (154 . GROUPDEFINITION)                         (156 . FIXUP)                         (160 . LOGICALENUMERATEDDATA)                         (162 . LOGICALITERATEDDATA)                         (164 . LIBRARYHEADER)                         (166 . LIBRARYMODULENAMES)                         (168 . LIBRARYMODULELOCATIONS)                         (170 . LIBRARYDICTIONARY)))(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \OMF.RECORDTYPES))(* accessing PC memory and FCBs)(DEFINEQ(\PCE.AROUNDEXITFN  [LAMBDA (EVENT)                                            (* mjs "18-Apr-86 15:42")                    (* After any type of logout, we MUST remember to re-initialize the memory           pointers. All of the PCE entries check \PCE.INITIALIZED and reinit the memory           if it is NIL.)    (SELECTQ EVENT        ((AFTERLOGOUT AFTERSAVEVM AFTERSYSOUT AFTERMAKESYS)              (SETQ \PCE.INITIALIZED NIL))        NIL])(\PCE.CHECK.INITIALIZED  [LAMBDA NIL                                                (* mjs "18-Apr-86 15:47")                    (* This is called by all of the PCE entry functions, to make sure that the           memory pointers have been initialized. If the memory pointers are not           initialized, the symptoms are MP 9305, MP 9318, etc.          \PCE.INITIALIZED is reset to NIL by \PCE.AROUNDEXITFN, which is called after           any lisp exit.)    (if (NULL \PCE.INITIALIZED)        then (\PCE.CHECK.MACHINE)             (\PCE.INIT.FCB.POINTERS)             (\PCE.INIT.MEMORY)             (SETQ \PCE.INITIALIZED T])(\PCE.CHECK.MACHINE  [LAMBDA NIL                                                (* mjs "18-Apr-86 15:50")                    (* Checks that this computer is an |1185/6| with a PC board.          If not, causes a non-continuable error.)    (if (NEQ (MACHINETYPE)             'DOVE)        then (ERROR "Can't run PC emulation --- bad machine type" (MACHINETYPE))             (ERROR!)      elseif (NOT (PCE.BOARD.INSTALLED))        then (ERROR "Can't run PC emulation - no PC board, or not configured")             (ERROR!])(\PCE.CLEARSUFI  [LAMBDA NIL                                                (* mjs "18-Apr-86 15:53")                                                             (* Clears the PC memory)    (\PCE.CHECK.INITIALIZED)    (\CLEARWORDS \PCE.SUFIBLOCK (ITIMES WORDSPERPAGE \PCE.SUFIBLOCKSIZE])(\PCE.GET.PC.PTR  [LAMBDA (PCADDR)                                           (* mjs "18-Apr-86 16:46")                    (* * Returns a pointer into the real memory location used by the PC that           corresponds to PC byte address PCADD. Assumes PCADDR is word aligned)    (\ADDBASE (ELT \PCE.MEMORY.BANK.ARRAY (LOGAND 15 (LRSH PCADDR BITSPERWORD)))           (LRSH (LOGAND PCADDR MAX.SMALLP)                 1])(\PCE.INIT.FCB.POINTERS  [LAMBDA NIL                                                (* mjs " 2-Jul-86 14:28")                    (* Sets variables pointing to FCBs for PC devices.          Each FCB is a "mailbox" used for communicating information between the IOP and           the various lisp agents.)    (SETQ \PCE.DISPATCHER.FCBPTR (\DoveIO.GetHandlerIORegionPtr DoveIO.pceDispatchHandler))    (SETQ \PCE.FLOPPY.FCBPTR (\DoveIO.GetHandlerIORegionPtr DoveIO.pceFloppyHandler))    (SETQ \PCE.DISPLAY.FCBPTR (\DoveIO.GetHandlerIORegionPtr DoveIO.pceDisplayHandler))    (SETQ \PCE.KEYBOARD.FCBPTR (\DoveIO.GetHandlerIORegionPtr DoveIO.pceKeyHandler))    (SETQ \PCE.PRINTER.FCBPTR (\DoveIO.GetHandlerIORegionPtr DoveIO.pcePrinterHandler))    (SETQ \PCE.RIGIDDISK.FCBPTR (\DoveIO.GetHandlerIORegionPtr DoveIO.pceHardDiskHandler])(\PCE.INIT.MEMORY  [LAMBDA NIL                                                (* mjs " 3-Jun-86 09:55")                    (* * This function establishes access to the PCE's real memory and sets up           memory pointers accordingly. This must be called before doing any references to           the PC memory, otherwise you will get MP 9305)                    (* * WARNING%: The calls to \WRITEMAP below will cause MP 9318 <?> if           interpreted -- this function must be compiled to run)                    (* PC real memory starts right after end of Lisp memory, and goes to the end of           the real memory)    (SETQ \PCE.SUFIFIRSTRP (REALMEMORYSIZE))    (SETQ \PCE.SUFILASTRP (IPLUS (REALMEMORYSIZE)                                 1535))                    (* Currently, PC memory always uses 1536 real pages = |768K| bytes)    (SETQ \PCE.SUFIBLOCKSIZE 1536)    (if (NULL \PCE.SUFIBLOCK)        then                     (* only want to set \PCE.SUFIBLOCK once in any lisp memory image, since it           grabs a large chunk of virtual address space.)             (SETQ \PCE.SUFIBLOCK (\ALLOCVIRTUALPAGEBLOCK \PCE.SUFIBLOCKSIZE)))                    (* Establish mapping between virtual pages in \PCE.SUFIBLOCK and real memory           pages beyond end of lisp memory. This must be done to establish the page           mapping before any calculations with \PCE.SUFIBLOCK)    (for I from \PCE.SUFIFIRSTRP to \PCE.SUFILASTRP bind (BASE _ \PCE.SUFIBLOCK)       do (\WRITEMAP (fetch (POINTER PAGE#) of BASE)                 I \VMAP.CLEAN)          (SETQ BASE (\ADDBASE BASE WORDSPERPAGE)))                    (* The PC has an address space of 1048576 bytes, so PC addresses are 20 bits.          The top 4 bits indicate a 64KB memory block and the lower 16 bits the byte in           that memory block. \PCE.MEMORY.BANK.ARRAY is a 16-element array of pointers           mapping the PC memory blocks to the real memory.)                    (* Warning%: Some sections of PC memory "overlap" The PC uses the upper parts           of its address space for BIOS code, display memory, and other system memory.          In order to save memory space, the PCE software overlaps some regions of this           system memory. This is only possible because the PC system uses fixed regions           of the system memory that don't intersect when they are overlapped.          It is important for the user to understand this overlapping scheme when using           the peek and poke functions to modify system memory.          Specifically, memory locations |655360-720895| <block A> overlap locations           |786432-851967| <block C> and locations |917504-983039| <block E> %.          In addition, memory locations |720896-786431| <block B> overlap locations           |851968-917503| <block D> and locations |983040-1048575| <block F>.)    (SETQ \PCE.MEMORY.BANK.ARRAY (ARRAY 16 'POINTER NIL 0))                    (* \PCE.MEMORY.BANK.LIST is a list showing order of PC memory banks in real           memory)    [for BLOCKNUM from 0 to 15 as BLOCKMAPNUM in \PCE.MEMORY.BANK.LIST       do (* LRSH is used below because \ADDBASE uses words, and          (LLSH BLOCKMAPNUM BITSPERWORD) is the address of the beginning of the block IN           BYTES)          (SETA \PCE.MEMORY.BANK.ARRAY BLOCKNUM (\ADDBASE \PCE.SUFIBLOCK (LRSH (LLSH BLOCKMAPNUM                                                                                      BITSPERWORD)                                                                               1]                    (* * Set up pointers into PC memory used by display routines)    (\PCE.DISPLAY.INIT.MEMORY)    NIL]))(ADDTOVAR AROUNDEXITFNS \PCE.AROUNDEXITFN)(RPAQQ \PCE.MEMORY.BANK.LIST        (2 3 4 5 6 7 8 9 10 11 0 1 0 1 0 1))(RPAQ? \PCE.INITIALIZED )(RPAQ? \PCE.MEMORY.BANK.ARRAY )(RPAQ? \PCE.SUFIBLOCK )(RPAQ? \PCE.SUFIFIRSTRP )(RPAQ? \PCE.SUFILASTRP )(RPAQ? \PCE.SUFIBLOCKSIZE )(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.INITIALIZED \PCE.MEMORY.BANK.LIST \PCE.MEMORY.BANK.ARRAY \PCE.SUFIBLOCK        \PCE.SUFIFIRSTRP \PCE.SUFILASTRP \PCE.SUFIBLOCKSIZE))(* The PCE.xxxFCB records are mesarecords used for accessing the "mailboxes" used for communicating between IOP and lisp.)(DECLARE%: DONTCOPY (DECLARE%: EVAL@COMPILE(MESARECORD \PCE.DISPATCHER.FCB (                    (* * FCB that controls up/down notifications between IOP and lisp agents)                    (* * see PCEDispatcherIOFace.mesa)                    (* * tasks)                                 (pceFromMesaTask DoveIO.TaskContextBlock)                                                             (* IOP tasks)                                 (pceFromPCTask DoveIO.TaskContextBlock)                                                             (* IOP tasks)                    (* * Dispatching data structure)                                 (pceUpNotifyBits WORD)                    (* Up notify bits signalling which I/O agent should be called.          16 bits, one per agent)                                 (pceLockMask WORD)                    (* used for "safely" accessing FCB words when it is important that the IOP           doesn't change them during the lisp operation)                                 (pceClientCondition DoveIO.ClientCondition)                                                             (* ??)                    (* * IO trap variables)                                 (ioTrappedData WORD)        (* copy of PC<?> hardware registers                                                              for trapping I/O instructions)                                 (ioTrappedAddress WORD)                                 (ioTrappedStatus BYTE)                    (* * pseudo configuration switches)                                 (pseudoConfigSwitch0 BYTE)                                 (pseudoConfigSwitch1 BYTE)                                 (pseudoConfigSwitch2 BYTE)                    (* * variables used in PCDsptch)                                 (pNMIVectorBufferIP WORD)   (* ignore)                                 (pNMIVectorBufferCS WORD)   (* ignore)                                 (panelValue WORD)           (* counter incremented once for every                                                              trapped PC I/O)                    (* * init/exit variables)                                 (runPCE BYTE)               (* enables PC running)                                 (hbActivated BYTE)          (* ignore)                                 (pcIOPTasksActive BYTE)     (* ignore)                                 (dummyByte BYTE)            (* ignore)                    (* * following vars only used on the IOP side)                                 (hBufferindex WORD)                                 (IOCount BYTE)                                 (FtlErr BYTE)                                 (conditionPCEWork WORD)                                 (pceMesaWorkMask WORD)      (* down notify bits??)                                 (pceWorkingDNWord WORD)                                 (p8255PortA BYTE)           (* controls for timer??)                                 (p8255PortB BYTE)                                 (p8255PortC BYTE)                                 (p8255Control BYTE)                    (* * OpieAddresses for SetPCEMapping on IOP side)                                 (firstAddress Dove.OpieAddress)                                 (numberOfPCBlocks BYTE)                                 (pDummyByte BYTE)))(MESARECORD \PCE.DISPLAY.FCB (                    (* * FCB for controlling the display)                    (* * see PCEDisplayIOFace.mesa)                    (* * Note%: This conforms to the POST-KOTO implementation of the display FCB)                              (pceDisplayTask DoveIO.TaskContextBlock)                                                             (* IOP task)                              (dirtyBitArray 8 BYTE)                    (* array of bits indicating which display lines have been altered)                              (errorNumber WORD)             (* error on display ops)                              (serviceReqBits WORD)                    (* bits indicate what needs to be changed in the display --          includes cursorShapeChange, cursorLocationChange, and dirtyBitsDirty.          <see PCEmulation.mesa>)                              (colorByte BYTE)               (* ??)                              (display BYTE)                 (* type of display)                              (displayMode BYTE)             (* ??)                              (dirtBitsState BYTE)                    (* agent sets to zero when dirty bits have been read)                    (* * monochrome registers)                              (MonoDummyArray 5 WORD)        (* for IOP use only)                              (mfMonoCursorStart BYTE)       (* start,end scan line of mono cursor)                              (mfMonoCursorEnd BYTE)                              (mfMonoPageStartAddr WORD)                              (mfMonoCursorAddr WORD)                              (lastMDummyWord WORD)                    (* * color registers)                              (ColorDummyArray 5 WORD)                              (mfColorCursorStart BYTE)      (* start,end scan line of color cursor)                              (mfColorCursorEnd BYTE)                              (mfColorPageStartAddr WORD)                              (mfColorCursorAddr WORD)                              (lastCDummyWord WORD)                    (* * for IOP use only)                              (trapBase WORD)                              (statusPorts WORD)                              (indexPorts WORD)                              (bytesToLoad WORD)))(BLOCKRECORD \PCE.FLOPPY.FCB (                    (* * FCB for controlling the real and virtual floppy drives)                    (* * see PCEFLOPPYIOFACE.MESA)                              (pceMemSize 2 WORD)                    (* PC memory size, in bytes -- stored with low byte first)                              (pceHasRealDrive BYTE)                    (* set to 1 if PC can access the real floppy drive)                              (pFDCRealDrive BYTE)                    (* drive number used by FDC to select the physical drive)                              (pFlopLogicalDrive BYTE)                    (* number of the logical drive that gets mapped to physical drive %# 0)                              (pDORRealDrive BYTE)                    (* one high nybble bit is set to correspond to the above pFlopLogicalDrive           variable)                              (pceFloppyWorkMask WORD)       (* mask for down notifies)                              (pceIOCB 77 WORD)              (* partial IOCB built by the                                                              pceFloppyEmulator)                              ))(MESARECORD \PCE.KEYBOARD.FCB (                    (* * FCB for communicating with keyboard)                    (* * see PCEKEYBOARDIOFACE.MESA)                               (KeyboardTask DoveIO.TaskContextBlock)                                                             (* IOP task?)                               (KeyboardWorkMask.BS WORD)    (* notify mask for down notifies)                               (KeyboardHandlerState.BS WORD)(* handler state -                                                             running or sleep)                               (KBBufferIN.BS BYTE)          (* byte addr in buffer to enqueue                                                              scancodes)                               (KBBufferOUT.BS BYTE)         (* byte addr in buffer to dequeue                                                              scancodes)                               (KBBuffer 64 BYTE)            (* 64-byte scancode ring buffer)                               ))(MESARECORD \PCE.PRINTER.FCB (                    (* * FCB for controlling the Printer)                    (* * see PCEPRINTERIOFACE.MESA)                    (* * Note%: This conforms to the POST-KOTO implementation of the printer port)                              (pceFromMesaTask DoveIO.TaskContextBlock)                                                             (* IOP task?)                              (pcePrinterWorkMask WORD)                    (* notify mask for down notifies <apparently not used by printer agent??>)                              (printerBuffer 254 BYTE)       (* 254-byte ring buffer for printer                                                              chars)                              (prLock WORD)                  (* used to lock access to "count"                                                              field)                              (count BYTE)                   (* number of characters in buffer)                              (needUpNotify BYTE)                    (* TRUE=1, FALSE=0 -- set to 1 to tell IOP that the buffer is empty, and we           need an up notify when more chars appear)                              (testCount1 BYTE)                    (* * the following are only used on the IOP side)                              (printerStatusByte BYTE)       (* printer ready = 152)                              (printerDataByte BYTE)         (* temp place to store char)                              (pceSetCntrlportSgnl BYTE)                              (ptrFlag BYTE)                 (* printer available = 0, not                                                              available = 8)                              (inPtr BYTE)                              (putLock WORD)                              (pcePrinterIOCondition WORD)                              (pcePrinterConditionWork WORD)))(MESARECORD \PCE.RIGIDDISK.FCB (                    (* * FCB for controlling the Emulated Rigid Disk)                    (* * see PCERIGIDDISKIOFACE.MESA)                                (ALReg BYTE)                 (* number of sectors)                                (AHReg BYTE)                 (* input operation code)                                (BXReg WORD)                 (* offset of buffer address)                                (CLReg BYTE)                 (* sector number)                                (CHReg BYTE)                 (* cylinder number)                                (DLReg BYTE)                 (* drive number)                                (DHReg BYTE)                 (* head number)                                (ESReg WORD)                 (* base of buffer address)                                (maxCylinders WORD)          (* max. no. of cylinders)                                (pceDiskHandlerState BYTE)   (* state of handler)                                (extraByte BYTE)             (* dummy for word alignment)                                (pceDiskWorkMask WORD)       (* notify mask for down notifies)                                (pceRegs 2 WORD)                    (* Opie address offset with C800 segment where Xbios saves the PC registers)                                (pceDiskTask DoveIO.TaskContextBlock)                                                             (* IOP task?)                                (pceDiskConditionWork WORD)  (* IOP condition)                                (pceDiskWaitIO WORD)         (* IOP condition)                                ))))(RPAQ? \PCE.DISPATCHER.FCBPTR )(RPAQ? \PCE.FLOPPY.FCBPTR )(RPAQ? \PCE.DISPLAY.FCBPTR )(RPAQ? \PCE.KEYBOARD.FCBPTR )(RPAQ? \PCE.PRINTER.FCBPTR )(RPAQ? \PCE.RIGIDDISK.FCBPTR )(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.DISPATCHER.FCBPTR \PCE.FLOPPY.FCBPTR \PCE.DISPLAY.FCBPTR \PCE.KEYBOARD.FCBPTR        \PCE.PRINTER.FCBPTR \PCE.RIGIDDISK.FCBPTR))(DECLARE%: DONTCOPY (ADDTOVAR BREAKRESETFORMS (SETQ \CURRENTKEYACTION \DEFAULTKEYACTION)))(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.ConfigureNotifyMask 16384)(RPAQQ \PCE.PRINTERSWITCH 2)(RPAQQ \PCE.RIGIDBOOTSWITCH 128)(RPAQQ \PCE.RIGIDDISKSWITCH 16)(RPAQQ \PCE.ExitNotifyMask 8192)(RPAQQ \PCE.BOOTMASK 32768)(RPAQQ \VMAP.CLEAN 0)(RPAQQ \PCE.agentPauseMask 128)(CONSTANTS \PCE.ConfigureNotifyMask \PCE.PRINTERSWITCH \PCE.RIGIDBOOTSWITCH \PCE.RIGIDDISKSWITCH        \PCE.ExitNotifyMask \PCE.BOOTMASK \VMAP.CLEAN \PCE.agentPauseMask))(PUTPROPS PCE COPYRIGHT ("Xerox Corporation" 1985 1986 1987))(DECLARE%: DONTCOPY  (FILEMAP (NIL (6986 11830 (PCE.BOARD.INSTALLED 6996 . 7850) (PCE.BOOT 7852 . 9346) (PCE.FREEZE 9348 . 10005) (PCE.QUIT 10007 . 10551) (PCE.RUN.STATE 10553 . 11163) (PCE.UNFREEZE 11165 . 11828)) (11831 15563 (PCE.PEEK 11841 . 12681) (PCE.PEEK.WORD 12683 . 13843) (PCE.POKE 13845 . 14369) (PCE.POKE.WORD 14371 . 15561)) (15564 17229 (PCE.PRINTER.OPENP 15574 . 15854) (PCE.PRINTER.GETFILE 15856 . 16176) (PCE.PRINTER.SETFILE 16178 . 16565) (PCE.PRINTER.CLOSEF 16567 . 17227)) (18128 21979 (\PCE.FORK.AGENTS 18138 . 18806) (\PCE.NOTIFY 18808 . 19821) (\PCE.OPENSTREAM 19823 . 20702) (\PCE.SYSTEM.ERROR 20704 . 21020) (\PCE.TERMINATE 21022 . 21977)) (21980 26106 (\PCE.CONFIGURE 21990 . 25282) (\PCE.CONFIGURE.GETSWITCH 25284 . 26104)) (27347 35485 (\PCE.PRINTER.Configure 27357 . 28012) (\PCE.PRINTER.Init 28014 . 29148) (\PCE.PRINTER.Notify 29150 . 29678) (\PCE.PRINTER.NotifyProcedure 29680 . 34799) (\PCE.PRINTER.Terminate 34801 . 35483)) (35923 39713 (\PCE.UP.Terminate 35933 . 36525) (\PCE.UP.Init 36527 . 37117) (\PCE.UP.Watcher 37119 . 39711)) (39867 48114 (\PCE.OMF.ADVANCE 39877 . 41031) (\PCE.OMF.CHECK 41033 . 43494) (\PCE.OMF.LOAD 43496 . 45149) (\PCE.OMF.OPEN 45151 . 45598) (\PCE.OMF.MERGE 45600 . 48112)) (49687 57003 (\PCE.AROUNDEXITFN 49697 . 50173) (\PCE.CHECK.INITIALIZED 50175 . 50869) (\PCE.CHECK.MACHINE 50871 . 51444) (\PCE.CLEARSUFI 51446 . 51757) (\PCE.GET.PC.PTR 51759 . 52204) (\PCE.INIT.FCB.POINTERS 52206 . 53069) (\PCE.INIT.MEMORY 53071 . 57001)))))STOP