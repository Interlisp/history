(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "ROOMS")(il:filecreated "12-Mar-88 20:13:18" il:|{POGO:AISNORTH:XEROX}<ROOMS>NEXT>ROOMS-PLACEMENT-EDITOR.;45| 23905        il:|changes| il:|to:|  (il:functions pe-room-changed-fn)      il:|previous| il:|date:| "26-Feb-88 15:57:20" il:|{POGO:AISNORTH:XEROX}<ROOMS>NEXT>ROOMS-PLACEMENT-EDITOR.;44|); Copyright (c) 1987, 1988 by Xerox Corporation.  All rights reserved.(il:prettycomprint il:rooms-placement-editorcoms)(il:rpaqq il:rooms-placement-editorcoms ((file-environments il:rooms-placement-editor) (il:p (require "ROOMS")) (il:structures placement-editor pe-placement) (il:variables *placement-editors*) (il:functions get-pe make-pe pe-closefn find-pe pe-window-p update-pe? update-pe update-peps re-scale-peps update-pe-window placed-region pe-repaintfn pe-reshapefn pe-totopfn) (il:coms (il:* il:\; "display") (il:variables *default-icon-size* *pe-title-font* *pep-title-font* *pep-included-shade* *pe-border*) (il:functions display-pe-title display-pe-border display-peps display-pep print-pep-title print-pep-title-string) (il:variables *display-pe-depth*) (il:window-types :placement-editor)) (il:functions (il:* il:\; "mouse trackers") pe-buttoneventfn pe-rightbuttonfn pe-track-left-button pe-track-middle-button pep-getboxposition pep-getboxposition-internal) (il:coms (il:* il:\; "editing") (il:functions pe-room-changed-fn pep-selected expand-placement pep-selected-copy-or-move pe-room-selected) (il:p (pushnew (quote pe-room-changed-fn) *room-changed-functions*))) (il:globalvars il:tinyfont il:crosshairs)))(define-file-environment il:rooms-placement-editor :compiler :compile-file :package "ROOMS" :readtable "XCL")(require "ROOMS")(defstruct (placement-editor (:conc-name "PE-") (:constructor make-pe-internal) (:print-function (lambda (pe stream depth) (format stream "#<Placement Editor for ~S>" (pe-room-name pe))))) (up-to-date? nil :type (member t nil)) (room-name nil) (scale *one-to-one* :type scale) (peps nil :type list) (window nil) (title-text nil :type text) (clipping-region nil :type region))(defstruct (pe-placement (:conc-name "PEP-")) (placement nil :type placement) (scaled-region nil :type region) (immediate? nil :type (member t nil)))(defglobalvar *placement-editors* (make-hash-table :test (quote equal)))(defun get-pe (room-name &optional region) (il:* il:|;;;| "returns the PE for ROOM, creating one if required.  if REGION is provided then the PE will occupy it.") (let ((pe (find-pe room-name))) (if pe (il:* il:|;;| "this code optimized so there is never more than one redisplay when entering overview") (let* ((window (pe-window pe)) (icon (window-icon window))) (il:* il:|;;| "this gets smashed when window closed") (il:windowprop window :placement-editor pe) (il:* il:|;;| "make sure window is not hidden") (un-hide-window window) (unless (and (il:openwp window) (null region)) (il:shapew window (or region (il:getregion)))) (il:* il:|;;| "make sure it's open, on top & up to date.") (il:openw window) (il:totopw window t) (update-pe? pe) pe) (make-pe room-name region))))(defun make-pe (room-name &optional region) (il:* il:|;;;| "don't call this.  call GET-PE instead.  we depend on there only being on PE per room.") (let* ((window (il:createw region nil 0)) (pe (make-pe-internal :room-name room-name :window window :title-text (make-text :string (if (stringp room-name) room-name (princ-to-string room-name)) :shadows t :font *pe-title-font*)))) (il:windowprop window (quote il:closefn) (quote pe-closefn)) (il:windowprop window :placement-editor pe) (il:windowprop window (quote il:buttoneventfn) (quote pe-buttoneventfn)) (il:windowprop window (quote il:rightbuttonfn) (quote pe-rightbuttonfn)) (il:windowprop window (quote il:repaintfn) (quote pe-repaintfn)) (il:windowprop window (quote il:reshapefn) (quote pe-reshapefn)) (il:windowprop window (quote il:totopfn) (quote pe-totopfn)) (il:windowprop window (quote il:aftermovefn) (quote pe-totopfn)) (il:windowprop window (quote il:openfn) (quote pe-totopfn)) (il:dspfont *pep-title-font* window) (setf (find-pe room-name) pe) (il:* il:|;;| "update things") (update-pe-window pe) (update-pe pe) pe))(defun pe-closefn (window) (il:* il:|;;| "remove circularity") (il:windowprop window :placement-editor nil))(defmacro find-pe (room-name) (il:bquote (gethash (il:\\\, room-name) *placement-editors*)))(defun pe-window-p (window) (placement-editor-p (il:windowprop window :placement-editor)))(defun update-pe? (pe) (unless (pe-up-to-date? pe) (update-pe pe)))(defun update-pe (pe) (il:* il:|;;;| "update PE per the current state of rooms") (let* ((room (room-named (pe-room-name pe)))) (when room (update-peps pe) (display-peps pe (il:getstream (pe-window pe))) (setf (pe-up-to-date? pe) t))))(defun update-peps (pe) (il:* il:|;;| "re-scale the PEPs in PE per its scale") (il:* il:|;;| "note: code under here should not be window specific, as we call this from PE-HARDCOPYFN.") (il:* il:|;;| "we presume UPDATE-PLACEMENTS has already been called") (let ((room (room-named (pe-room-name pe)))) (when room (let ((immediate-placements (room-placements room)) (scale (pe-scale pe))) (setf (pe-peps pe) (mapcar (function (lambda (placement) (make-pe-placement :placement placement :immediate? (when (member placement immediate-placements :test (quote eq)) t)))) (find-placements room))) (re-scale-peps pe)))))(defun re-scale-peps (pe) (il:* il:|;;;| "compute the scaled-region for each PEP in PE ") (let ((scale (pe-scale pe))) (dolist (pep (pe-peps pe)) (setf (pep-scaled-region pep) (scale-region (placed-region (pep-placement pep)) scale)))))(defun update-pe-window (pe) (let* ((window (pe-window pe)) (dsp (il:getstream window)) (window-region (window-region window)) (window-height (region-height window-region)) (text (pe-title-text pe)) (height (- window-height (text-%height text))) (twice-border (* *pe-border* 2)) (clipping-region (make-region :left *pe-border* :bottom *pe-border* :width (- (region-width window-region) twice-border) :height (- height twice-border)))) (il:* il:|;;| "update scale & clipping region") (setf (pe-clipping-region pe) clipping-region) (setf (pe-scale pe) (make-scale clipping-region)) (setf (text-position text) (make-position *pe-border* height)) (display-pe-title pe) (display-pe-border pe)))(defun placed-region (placement) (il:* il:|;;;| "returns the region PLACEMENT would occupy on the screen.  for non-shrunken placements this is just the PLACEMENT-REGION, but for shrunken placements we need to figure what the region of the icon would be.") (if (placement-shrunken? placement) (let* ((icon-position (placement-icon-position placement)) (icon (window-icon (placement-window placement))) (icon-region (if icon (window-region icon)))) (make-region :left (position-x icon-position) :bottom (position-y icon-position) :width (if icon (region-width icon-region) *default-icon-size*) :height (if icon (region-height icon-region) *default-icon-size*))) (placement-region placement)))(defun pe-repaintfn (window &rest ignore) (let ((pe (il:windowprop window :placement-editor))) (display-pe-title pe) (display-pe-border pe) (if (pe-up-to-date? pe) (display-peps pe (il:getstream window)) (update-pe pe))))(defun pe-reshapefn (window &rest ignore) (let ((pe (il:windowprop window :placement-editor))) (update-pe-window pe) (re-scale-peps pe) (display-peps pe (il:getstream window))))(defun pe-totopfn (window) (il:totopw window t) (let ((pe (il:windowprop window :placement-editor))) (when pe (display-pe-title pe) (update-pe? pe))))(il:* il:\; "display")(defvar *default-icon-size* (il:* il:|;;;| "when we draw a placement for a non-existant icon, we draw it as a square with this many (scaled) pixels per side.") 75)(defglobalvar *pe-title-font* (il:fontcreate (quote il:helvetica) 36 (quote (il:bold il:regular il:regular)) nil (quote il:display)))(defglobalparameter *pep-title-font* (il:fontcreate il:tinyfont nil nil nil (quote il:display)))(defglobalparameter *pep-included-shade* 4680)(defglobalparameter *pe-border* 4)(defun display-pe-title (pe) (let* ((window (pe-window pe)) (window-region (window-region window)) (dsp (il:getstream window)) (text (pe-title-text pe)) (window-height (region-height window-region)) (bottom (- window-height (text-%height text)))) (il:* il:|;;| "blt the background into the title bar") (il:bitblt (il:windowprop window (quote il:imagecovered)) 0 bottom dsp 0 bottom (region-width window-region) (- window-height bottom)) (setf (text-shadows text) (if (equal (pe-room-name pe) *back-door-room-name*) (il:* il:|;;| "the title of the back door room gets special shadows ") (maplist (function (lambda (tail) (if (rest tail) (first tail) (il:constant (make-text-shadow :source-type (quote il:merge) :texture 42405 :operation (quote il:invert)))))) (get-text-shadows-internal *pe-title-font*)) (il:* il:|;;| "others get normal shadows") t)) (display-text text dsp)))(defun display-pe-border (pe) (let* ((window (pe-window pe)) (window-region (window-region window))) (il:* il:|;;| "draw the window border & clear inside it") (draw&fill-box-within (make-region :left 0 :bottom 0 :width (region-width window-region) :height (- (region-height window-region) (text-%height (pe-title-text pe)))) (il:getstream window) :border-width (floor *pe-border* 2))))(defun display-peps (pe dsp) (il:* il:|;;;| "displays PE on DSP ") (let ((room (room-named (pe-room-name pe))) (clipping-region (pe-clipping-region pe))) (when room (paint-background room dsp :scale (pe-scale pe) :no-text t :clipping-region clipping-region) (dolist (pep (pe-peps pe)) (display-pep pep dsp clipping-region)))))(defun display-pep (pep dsp clipping-region) (il:* il:|;;;| "displays a PE-PLACEMENT") (il:* il:|;;| "draw a box around the region & fill it if it represents an immediate placement in the room of this PEP.") (draw&fill-box-within (pep-scaled-region pep) dsp :border-width 1 :shade (if (pep-immediate? pep) il:whiteshade *pep-included-shade*) :clipping-region clipping-region) (let (old-clipping-region) (unwind-protect (progn (setq old-clipping-region (il:dspclippingregion clipping-region dsp)) (print-pep-title pep dsp)) (when old-clipping-region (il:dspclippingregion old-clipping-region dsp)))))(defun print-pep-title (pep dsp) (il:* il:|;;| "print something within the box drawn for PEP on DSP ") (let* ((window-type (window-type (placement-window (pep-placement pep)) t))) (when window-type (let ((title (window-type-prop window-type :title))) (il:* il:|;;| "interpret the TITLE property of the window type of the placement this PEP represents") (cond ((null title) (il:* il:|;;| "if none specified, just print the name of the type") (print-pep-title-string (string (window-type-name window-type)) (pep-scaled-region pep) dsp :no-title-bar? (placement-shrunken? (pep-placement pep)))) ((stringp title) (il:* il:|;;| "if it's a string, print it") (print-pep-title-string title (pep-scaled-region pep) dsp :no-title-bar? (placement-shrunken? (pep-placement pep)))) (t (il:* il:|;;| "otherwise assume it's a function & call it") (funcall title (pep-placement pep) (pep-scaled-region pep) dsp)))))))(defun print-pep-title-string (string region dsp &key (font *pep-title-font*) no-title-bar?) (il:* il:|;;;| "prints STRING in the top left corner of REGION if it will fit.") (let* ((string (if (stringp string) string (princ-to-string string))) (font-height (il:fontheight font)) (title-y (- (+ (region-bottom region) (region-height region)) font-height (if no-title-bar? 1 0))) (string-width (il:stringwidth string font))) (when (and (< string-width (- (region-width region) 2)) (< font-height (- (region-height region) 2))) (unless no-title-bar? (il:bltshade il:blackshade dsp (region-left region) (1- title-y) (region-width region) font-height (quote il:paint))) (il:dspoperation (if no-title-bar? (quote il:paint) (quote il:invert)) dsp) (il:dspfont font dsp) (il:moveto (+ (region-left region) (if no-title-bar? (- (floor (region-width region) 2) (floor string-width 2)) 2)) (if no-title-bar? (+ (region-bottom region) (- (floor (region-height region) 2) (floor font-height 2)) (il:fontdescent font)) (+ title-y (il:fontdescent font))) dsp) (check-type dsp stream) (il:\\sout string dsp) (il:dspoperation (quote il:replace) dsp))))(defparameter *display-pe-depth* 1 "Depth to recursivly display placement editors within placement editors")(def-window-type :placement-editor :recognizer (lambda (window) (placement-editor-p (il:windowprop window :placement-editor))) :abstracter (lambda (window) (let ((pe (il:windowprop window :placement-editor))) (when pe (il:bquote (:region (il:\\\, (externalize-region (window-region (pe-window pe)))) :room-name (il:\\\, (pe-room-name (il:windowprop window :placement-editor)))))))) :reconstituter (lambda (plist) (pe-window (get-pe (getf plist :room-name) (internalize-region (getf plist :region))))) :title (lambda (placement region dsp) (let ((pe (il:windowprop (placement-window placement) :placement-editor))) (when pe (print-pep-title-string (let ((name (pe-room-name pe))) (if (stringp name) name (princ-to-string name))) region dsp) (when (> *display-pe-depth* 0) (let ((*display-pe-depth* (1- *display-pe-depth*)) (old-scale (pe-scale pe)) (old-peps (pe-peps pe)) (old-clipping-region (pe-clipping-region pe)) (new-clipping-region (make-region :left (+ (region-left region) 1) :bottom (+ (region-bottom region) 1) :width (- (region-width region) 2) :height (- (region-height region) 2 (il:fontheight *pep-title-font*))))) (unwind-protect (progn (setf (pe-scale pe) (make-scale new-clipping-region)) (update-peps pe) (il:* il:|;;| "recursively display pictogram") (setf (pe-clipping-region pe) new-clipping-region) (display-peps pe dsp)) (setf (pe-scale pe) old-scale) (setf (pe-peps pe) old-peps) (setf (pe-clipping-region pe) old-clipping-region))))))))(defun pe-buttoneventfn (window) (il:totopw window) (let ((pe (il:windowprop window :placement-editor)) (*timer* (il:setuptimer *button-help-delay*))) (declare (special *timer*)) (if (il:insidep (pe-clipping-region pe) (il:lastmousex window) (il:lastmousey window)) (loop (cond ((il:lastmousestate (il:only il:left)) (let ((selected-pep (pe-track-left-button pe))) (when selected-pep (return (pep-selected selected-pep pe))))) ((il:lastmousestate il:middle) (let ((room-selected? (pe-track-middle-button pe))) (when room-selected? (return (pe-room-selected pe))))) (t (return))) (when (and *timer* (il:timerexpired? *timer*)) (notify-user "Use LEFT to select placements, MIDDLE Rooms.") (setq *timer* nil))) (unless (eq *current-room* *overview-room*) (case (menu (quote (("ReFetch" :re-fetch)))) (:re-fetch (update-placements)))))))(defun pe-rightbuttonfn (window) (unless (eq *current-room* *overview-room*) (il:dowindowcom window)))(defun pe-track-left-button (pe peps) (declare (special *timer*)) (let ((selected-pep nil) (clipping-region (pe-clipping-region pe)) (window (pe-window pe)) (il:* il:|;;| "need PEPS in top down order to handle occlusion correctly") (peps (reverse (pe-peps pe)))) (macrolet ((invert-selected-pep nil (il:bquote (let ((region (pep-scaled-region selected-pep))) (il:bltshade il:blackshade window (region-left region) (region-bottom region) (region-width region) (region-height region) (quote il:invert) clipping-region))))) (loop (unless (il:mousestate (il:only il:left)) (return (when selected-pep (il:* il:|;;| "restore the display") (invert-selected-pep) (unless (il:lastmousestate il:middle) (il:* il:|;;| "return the PEP if there's one selected & the button event fn should be exited.") selected-pep)))) (dolist (il:* il:|;;| "loop down the occlusion stack") (pep peps (when selected-pep (il:* il:|;;| "bottomed out -- must be in the background") (il:* il:|;;| "have to de-select selection") (invert-selected-pep) (setq selected-pep nil))) (when (il:insidep (pep-scaled-region pep) (il:lastmousex window) (il:lastmousey window)) (il:* il:|;;| "we're in a PEP") (unless (eq pep selected-pep) (il:* il:|;;| "it's a new selection") (when selected-pep (il:* il:|;;| "unselect the current selection") (invert-selected-pep)) (il:* il:|;;| "select the new one") (setq selected-pep pep) (invert-selected-pep)) (il:* il:|;;| "pop to the outer loop") (return))) (when (and *timer* (il:timerexpired? *timer*)) (notify-user "Use LEFT to select placements, MIDDLE Rooms.") (setq *timer* nil)) (il:block)))))(defun pe-track-middle-button (pe) (declare (special *timer*)) (let* ((window (pe-window pe)) (selected? t) (clipping-region (pe-clipping-region pe))) (il:invertw window) (loop (unless (il:mousestate il:middle) (return (when selected? (il:invertw window) (unless (il:lastmousestate (il:only il:left)) (il:* il:|;;| "return true if selected & the button event fn should be exited.") t)))) (if (il:insidep clipping-region (il:lastmousex window) (il:lastmousey window)) (unless selected? (il:invertw window) (setq selected? t)) (when selected? (if (il:topwp window) (il:invertw window) (progn (il:invertw window) (display-pe-title pe))) (setq selected? nil))) (when (and *timer* (il:timerexpired? *timer*)) (notify-user "Use LEFT to select placements, MIDDLE Rooms.") (setq *timer* nil)) (il:block))))(defun pep-getboxposition (pe pep) (il:* il:|;;;| "called when a placement is MOVE or COPY selected to get the new position for the placement.") (il:* il:|;;;| "returns two values - a position and a PE - or NIL") (let* ((old-cursor (il:cursor)) (old-tty (il:tty.process))) (unwind-protect (progn (il:cursor il:crosshairs) (il:tty.process (il:this.process)) (il:cursorposition (make-position (region-left (pep-scaled-region pep)) (region-bottom (pep-scaled-region pep))) (pe-window pe)) (do* ((placed-region (placed-region (pep-placement pep))) (height (region-height placed-region)) (width (region-width placed-region)) (window nil (il:* il:|;;| "the window the cursor is over (if any)") (il:whichw)) (pe nil (il:* il:|;;| "the PE the cursor is over (if any)") (if (and window (pe-window-p window)) (il:windowprop window :placement-editor))) (position nil (il:* il:|;;| "the selected position within PE (if any)") (if pe (let ((clipping-region (pe-clipping-region pe)) (scale (pe-scale pe))) (if (il:insidep clipping-region (il:lastmousex window) (il:lastmousey window)) (il:* il:|;;| "have to rescale box for each PE") (pep-getboxposition-internal (scale-width width scale) (scale-height height scale) (pe-clipping-region pe) window) (il:getmousestate))) (il:getmousestate)))) ((or position (il:lastmousestate (or il:left il:middle il:right))) (when position (values (un-scale-position position (pe-scale pe)) pe))))) (il:cursor old-cursor) (il:tty.process old-tty))))(defun pep-getboxposition-internal (width height clipping-region window) (il:* il:|;;;| "track a box WIDTH by HEIGHT within CLIPPING-REGION in WINDOW.  if a button goes down return the X,Y position.  if cursor goes outside CLIPPING-REGION then return NIL.") (let* ((dsp (il:getstream window)) (old-operation (il:dspoperation nil dsp)) (last-x (il:lastmousex dsp)) (last-y (il:lastmousey dsp))) (macrolet ((invert-box nil (il:bquote (il:drawgraybox last-x last-y (+ last-x width) (+ last-y height) dsp il:grayshade)))) (unwind-protect (progn (il:totopw window) (il:dspoperation (quote il:invert) dsp) (invert-box) (loop (unless (il:insidep clipping-region last-x last-y) (return-from pep-getboxposition-internal)) (when (il:mousestate (or il:left il:middle il:right)) (return-from pep-getboxposition-internal (make-position last-x last-y))) (unless (and (= (il:lastmousex dsp) last-x) (= (il:lastmousey dsp) last-y)) (il:uninterruptably (il:* il:|;;| "un-draw old") (invert-box) (setq last-x (il:lastmousex dsp)) (setq last-y (il:lastmousey dsp)) (il:* il:|;;| "re-draw new") (invert-box))))) (invert-box) (il:dspoperation old-operation dsp)))))(il:* il:\; "editing")(defun pe-room-changed-fn (room reason) (when (eq reason :deleted) (il:* il:|;;| "if ROOM has been deleted then delete the placement editor") (let ((pe (find-pe (room-name room)))) (when pe (let ((window (pe-window pe))) (il:* il:|;;| "delete the placement editor") (un-hide-window window) (close-window window) (remhash (room-name room) *placement-editors*))))) (let ((includers (room-includers room t))) (il:* il:|;;| "ensure PE's for all rooms which include ROOM will be redisplayed") (dolist (includer includers) (let ((pe (find-pe (room-name includer)))) (when pe (let ((window (pe-window pe))) (if (and (il:openwp window) (not (window-hidden? window))) (il:* il:|;;| "update the PE if it's visible") (update-pe pe) (il:* il:|;;| "otherwise mark it as needing update") (setf (pe-up-to-date? pe) nil))))))))(defun pep-selected (pep pe) (il:* il:|;;;| "called when a placement is selected in PE") (let ((op (cond ((copy-key-down-p) :copy) ((move-key-down-p) :move) ((delete-key-down-p) :delete) ((expand-key-down-p) :expand) (t (ov-operation))))) (case op ((:copy :move) (pep-selected-copy-or-move op pep pe)) (:delete (interactive-close-window (placement-window (pep-placement pep)) (room-named (pe-room-name pe)))) (:expand (expand-placement (pep-placement pep))) (t (notify-user "Use a modifier (eg. COPY, MOVE or DELETE)")))))(defun expand-placement (placement) (let ((window (placement-window placement))) (if (window-hidden? window) (progn (notify-user "Click LEFT when finished") (place-placement placement) (loop (when (il:mousestate il:left) (return))) (hide-window window)) (il:flashwindow (if (shrunken? window) (window-icon window) window)))))(defun pep-selected-copy-or-move (op pep pe) (multiple-value-bind (destination-pos destination-pe) (pep-getboxposition pe pep) (if destination-pos (let* ((old-placement (pep-placement pep)) (new-placement (copy-placement old-placement))) (il:* il:|;;| "adjust the position of the new placement") (if (placement-shrunken? new-placement) (setf (placement-icon-position new-placement) destination-pos) (setf (placement-region new-placement) (make-region :left (position-x destination-pos) :bottom (position-y destination-pos) :width (region-width (placement-region new-placement)) :height (region-height (placement-region new-placement))))) (il:* il:|;;| "do the move/copy") (let ((pe-room (room-named (pe-room-name pe))) (destination-room (room-named (pe-room-name destination-pe)))) (multiple-value-bind (placement source-room) (il:* il:|;;| "find the room this placement is due to") (find-placement (placement-window old-placement) pe-room) (ecase op (:move (if (eq pe destination-pe) (il:* il:|;;| "Allow inherited placements to be moved in place -- w/o moving them to the room they're visible in.") (setq destination-room source-room) (unless (eq destination-room source-room) (il:* il:|;;| "We don't bother deleting first when source & destination are same, as we know ADD-PLACEMENT will delete the old & we only want to redisplay once") (delete-placement placement source-room))) (add-placement new-placement destination-room)) (:copy (add-placement new-placement destination-room)))))) (notify-user "Invalid destination."))))(defun pe-room-selected (pe) (il:* il:|;;;| "called when a room is selected in PE") (let ((room (room-named (pe-room-name pe))) (op (cond ((il:keydownp (quote il:space)) :enter) ((edit-key-down-p) :edit) ((copy-key-down-p) :copy) ((move-key-down-p) :move) ((delete-key-down-p) :delete) (t (if (eq *current-room* *overview-room*) (ov-operation) :enter))))) (case op (:edit (edit-room room)) (:copy (interactive-copy-room room)) (:move (interactive-rename-room room)) (:delete (interactive-delete-room room)) (:enter (go-to-room room)) (t (notify-user "Use a modifier (eg. COPY, DELETE or GO TO).")))))(pushnew (quote pe-room-changed-fn) *room-changed-functions*)(il:declare\: il:doeval@compile il:dontcopy(il:globalvars il:tinyfont il:crosshairs))(il:putprops il:rooms-placement-editor il:copyright ("Xerox Corporation" 1987 1988))(il:declare\: il:dontcopy  (il:filemap (nil)))il:stop