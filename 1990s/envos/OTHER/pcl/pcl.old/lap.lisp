;;;-*-Mode: LISP; Package:(PCL LISP 1000); Base:10; Syntax:Common-lisp -*-;;;;;; *************************************************************************;;; Copyright (c) 1985, 1986, 1987, 1988 Xerox Corporation.;;; All rights reserved.;;;;;; Use and copying of this software and preparation of derivative works;;; based upon this software are permitted.  Any distribution of this;;; software or derivative works must comply with all applicable United;;; States export control laws.;;; ;;; This software is made available AS IS, and Xerox Corporation makes no;;; warranty about the software, its performance or its conformity to any;;; specification.;;; ;;; Any person obtaining a copy of this software is requested to send their;;; name and post office or electronic mail address to:;;;   CommonLoops Coordinator;;;   Xerox PARC;;;   3333 Coyote Hill Rd.;;;   Palo Alto, CA 94304;;; (or send Arpanet mail to CommonLoops-Coordinator.pa@Xerox.arpa);;;;;; Suggestions, comments and requests for improvements are also welcome.;;; *************************************************************************;;;(in-package 'pcl)#||The PCL abstract LAP code mechanism exists to provide PCL with a way tocreate high-performance method lookup functions.  Using this mechanism,PCL can produce `LAP closures' which do the method lookup.  By allowingPCL to specify these closures using abstract LAP code rather that Lispcode we hope to achieve the following:  * Better runtime performance.  By using abstract LAP code, we    will get better instruction sequences than by compiling Lisp    code.   * Better load and update time performance.  Because it should    be possible to `assemble' the LAP code more quickly than    compiling Lisp code, PCL will spend less time building the    method lookup code.  * Ability to use PCL without a compiler.  The LAP assembler will    still be required but this should be much smaller than the full    lisp compiler.An important point is why we have chosen to take this route rather thanhave each implementation implement the method lookup codes itself.  Itis true, that at a later stage, having each implementation do this willprobably be appropriate.  On the other hand, this scheme retains morePCL control over cache an instance structure.  Because code sequenceswhich manipulate caches are generated by PCL, they can also be modifiedby PCL.Production of LAP closures is a two step process.  In the first step,the function MAKE-LAP-CLOSURE-GENERATOR is used to take abstract LAPcode and produce a function which can then be called to produce actualclosures.  These functions, called `lap closure generators' are calledwith the values of the closure variables for the LAP closure.  Theyreturn the actual LAP closure.The intermediary of the lap closure generators provides an importantoptimization.  Because it is assumed that producing the LAP closuregenerator can take much longer than producing a LAP closure from thegenerator, PCL attempts to make only one closure generator for eachsequence of LAP code.  Because of the way PCL generates the LAP codesequences, this is quite easy to do in PCL.The rest of this document is divided into six parts.    * the metatypes std-instance and fsc-instance  * an abstraction for simple vector indices  * important optimizations  * the function MAKE-LAP-CLOSURE-GENERATOR  * the actual abstract LAP code  * examples*** The metatypes STD-INSTANCE and FSC-INSTANCE ***In PCL, instances with metaclass STANDARD-CLASS are represented usingthe metatype STD-INSTANCE.  (Note that in Cinco de Mayo PCL, thismetatype is called IWMC-CLASS.)  Each port must implement this metatype.The metatype could be implemented by the following DEFSTRUCT.   (defstruct (std-instance                 (:predicate std-instance-p)                (:conc-name %std-instance-)                (:constructor %allocate-std-instance (wrapper slots))                (:constructor %allocate-std-instance-1 ())                (:print-function print-std-instance))     (wrapper nil)     (slots nil)) PCL itself will guarantee correct access to this structure and the accessors and constructors.  With this in mind, the following are important. * Being able to type test this structure quickly is critical. See    the :TYPE-TEST opcode. * The allocation functions should compile inline and be as fast as   possible. * The accessor functions should compile inline, do no checking of their   arguments and be as fast as possible.  SETF of the accessors should   do the same.The port is also required to implement the metatype FSC-INSTANCE (calledFUNCALLABLE-INSTANCE in Cinco de Mayo PCL).  These kinds of instancesalso have two fields and have predicates, print-functions, constructorsand accessors as follows:  fsc-instance-p  print-fsc-instance  %fsc-instance-wrapper  %fsc-instance-slots  %allocate-fsc-instance (wrapper slots)  %allocate-fsc-instance-1 ()*** Index Operations ***Indexes are an abstraction for indexes into a simple vector.  Thisabstraction is used to make it possible to generate more efficientcode to access simple vectors.  The idea being that this may make itpossible to alternate addressing modes to address these.The `index value' of an index is defined to be the fixnum of which thatindex is an alternate form.  So, using the Lisp function SVREF with theindex value of an index accesses the same element as using the indexwith the appropriate access function or operand.The format of an index is unspecified, but is assumed to be somethinglike a fixnum with certain bits ignored.  Accessing a vector using anindex must be done using the appropriate special accessor function oropcode.Conversion from index values to indices and vice-versa can be done withfollowing functions:INDEX-VALUE->INDEX (index-value)INDEX->INDEX-VALUE (index)The following constant indicates the maximum index value an index canhave in a given port.  This must be at least 2^4 and should be at least2^11.INDEX-VALUE-LIMIT  - a fixnum, must be greater than or equal to 2^42The function IREF can be used from Lisp to access a simple vector usingan index.  SETF can be used with the function.  The :IREF operand hasthe same behavior as this function but cannot be the destination of a:MOVE.IREF (<vector> <index>)The following function can increment an index by 1 index value.  Thiscould be implemented easily using the conversion functions and 1+ but isspecified separately anyways.I1+ (<index>)Note: I1+ could be implemented by:       (defun i1+ (index)         (index-value->index (1+ (index->index-value index))))ILOGANDILOGXORISHIFTMAKE-INDEX-MASK (<size> <words-per-entry>)(See the PCL function MAKE-CACHE-MASK)*** Optimizations ***This section discusses two important optimizations related to LAPclosures.  The first relates to calling LAP closures themeselves, thesecond relates to calling other functions from LAP closures.The important point about calling LAP closures is that almost all of thetime, LAP closures will be used as the funcallable-instance-function offuncallable instances.  It is required that LAP closures be funcallablethemeselves, but usually they will be stored in a FIN and the fin willthen be funcalled.  This brings up several optimizations, including oneshaving to do with access to the closure variables of a LAP closure.When a LAP closure is used to do method lookup, the function the LAPclosure ends up calling has the same number of required arguments as theLAP closure itself.  Since the LAP closure must check its requiredarguments to do the lookup, it is redundant for the function called todo so as well.  Since LAP closures do all calls in a tail recursive way,it should even be possible to optimize out certain parts of the normalstack frame initialization.A similar same situation occurs between effective method functions andthe individual method functions; the difference is that in effectivemethod functions, the calls are not necessarily tail recursive.Consequently, it would be nice to have a way to call certain functionsand inhibit the checking of required arguments.  This is made possibleby use of the SYSTEM::PCL-FAST-APPLY and SYSTEM::PCL-FAST-FUNCALL macrostogether with the SYSTEM::PCL-FAST-CALL compiler declaration.The SYSTEM::PCL-FAST-CALL compiler declaration declares that a functionmay be fast called.  Not all callers of the function will necessarilyfast call it, but most probably will.The SYSTEM::PCL-FAST-APPLY and SYSTEM::PCL-FAST-FUNCALL macros are usedto fast call a function.  The function argument must be a compiledfunction that has the SYSTEM::PCL-FAST-CALL compiler declaration in itslambda declarations.The basic idea is that the SYSTEM::PCL-FAST-CALL compiler declarationcauses the compiler to set up an additional entrypoint to the function.This entrypoint comes after checking of required arguments but beforeprocessing of other arguments.Note:  When FAST-APPLY is used, the required arguments will be given asseparate arguments and all other arguments will appear as a singlespread argument.  For example:(let ((fn (compile () '(lambda (a b &optional (c 'z))			 (declare (system::pcl-fast-call))			 (list a b c)))))  (system::pcl-fast-apply fn 'x 'y ())		;legal  (system::pcl-fast-apply fn 'x 'y '(foo))	;legal  (system::pcl-fast-apply fn '(a b c))		;illegal  )*** Producing LAP Closure Generators ***MAKE-LAP-CLOSURE-GENERATOR (<closure-slots> <args> <lap>)This returns a lap-closure generator.  A lap-closure generator is afunction which when called with a single argument which is a list ofclosure slot values returns a lap closure.  PCL takes care of keepingtrack of lap-closure-generators it already has on hand and reusing them.The function RESET-LAP-CLOSURE-GENERATORS can be called to force PCL toforget all the lap closure generators it has remembered.  <args> A list of symbols.  This provides a way to name particular arguments.Arguments which will not be referenced by name are given as NIL.  Allrequired arguments to the generic function will be supplied.  If &RESTappears at the end of arguments it means that more arguments thanspecified are allowed, these will be processed by the methods.  If &RESTdoes not appear at the end of arguments, the lap closure should signalan error if more than the indicated number of arguments are supplied.Examples: -  (obj-0 obj-1)    Specifies a two argument lap closure.  If more or less than    two arguments are supplied an error is signalled.  Within    the actual lap code, both arguments can be referenced by    name (see the :ARG operand). -  (obj-0 nil &rest)    Specifies a two or more argument lap closure.  If less than    two arguments are supplied an error is signalled.  Within    the actual lap code, the first argument can be referenced by    name (see the :ARG operand).  <closure-slots>A list of symbols.  The closure will have these as closure variables.Within the lap code these can be accessed by name.  The values will beas specified in <closure-slot-values>.  The lap code cannot change thesevalues.  SET-FUNCALLABLE-INSTANCE-FUNCTION is permitted to have thespecial knowledge that there are at most ?? of these and to be preparedto do something special when the fin-function of a fin is set to a lapclosure.  <lap>The actual lap code for this closure.  This is a list of LAP codeopcodes.  See the section `Abstract LAP Code' for more details.*** Abstract LAP Code ***Each lap code operand has the form: (opcode operand1 ... operandn).In some cases, the distinction between an operand and an opcode issomewhat arbitrary.  In general, opcodes have a significant `action'component to their behavior.  Operands select a piece of data to operateon.  Some operands select their data in a more complex way, but they areoperands anyways.>> The operands are:  (:reg <n>)   A pseudo register.  <n> is an integer in the range [0 , 31].A particular implementation can map this to a real register, a memorylocation or the stack.  The abstract LAP code itself does not includethe notion of a stack.PCL will attempt to optimize register use in two ways.  PCL itself willattempt to re-use registers whenever possible.  That is, the port shouldnot have to worry with analyzing activity windows for the registers.  Inaddition, PCL will consider lower numbered registers to be `faster' thanhigher numbered ones. (:cvar <name>)A closure variable of the lap-closure.  <name> is a symbol.  Note that:cvar cannot be the destination of a :move (this corresponds to therestriction that the value of a LAP closure variable cannot be changed). (:arg <name>)An argument to the LAP closure.  <name> is a symbol.  Note that :argcannot be the destination of a :move. (:std-wrapper <from>) (:fsc-wrapper <from>) (:built-in-wrapper <from>) (:structure-wrapper <from>) (:other-wrapper <from>)Get the class wrapper of <from>.  For std-instances and fsc-instancesthis just fetches the wrapper field.  The specific port is required toimplement fast access to the wrappers of built-in, structure and othermetatypes.  A callback mechanism allows the port to ask PCL to generatea class and wrapper for objects for which no class and wrapper existsyet.  This mechanism is <<to be spec'd out>>. (:std-slots <operand>) (:fsc-slots <operand>)Fetch the slots field of a std-instance or a fsc-instance.  <operand>must be a :REG operand.  These operands cannot be the destination of a:move. (:svref <vector> <constant>)Like the SVREF function.  <vector> must contain a simple vector and be a:REG operand.  <constant> is a fixnum.  This is used by PCL to implementaccess to specific fields of class wrappers and other such structures. (:iref <vector> <index>)Like the SVREF function.  <vector> must contain a simple vector and be a:REG operand.  <index> must contain an index and be a :REG operand.  Seethe section on index operations for more information on indexoperations. (:i1+ <index>)Like the 1+ function.  <index> must contain an index and be a :REGoperand.  See the section on index operations. (:i+ <index1> <index2>) (:i- <index1> <index2>)Like the + and - functions.  <index1> and <index2> must contain indicesand be :REG operands.  See the section on index operations. (:ilogand <index> <mask>)Like the LOGAND function.  <index> must contain an index and be a :REGoperand.  <mask> must contain an index mask (or an index) and be a :REGoperand.  See the section on index operations. (:ilogxor <index1> <index2>)Like the LOGXOR function.  <index1> and <index2> must contain indicesand be a :REG operands.  See the section on index operations. (:ishift <index> <constant>)Like the LSH function.  <index> must contain an index and be a :REGoperand.  <constant> is a fixnum.  See the section on index operations.>> The opcodes are: (:move <from> <to>)A full word move operation.  The <to> operand must be :REG.  The <from>operand must be one of: <<fill this in>>  The <to> register must notappear in the <from> operand. (:eq <from1> <from2> <label>) (:neq <from1> <from2> <label>)EQ and NOT EQ conditional branches.  If the value contained in <from1>is EQ (or not) to the value contained in <from2>, jump to <label>.Otherwise continue execution at the next opcode.  <from1> and <from2>must be :REG operands.  <label> is a symbol. (:fix= <from1> <from2> <label>)A fixnum = conditional branch. (:std-instance-p <from> <destination-label>) (:built-in-instance-p <from> <destination-label>) (:structure-instance-p <from> <destination-label>)Test the metatype of <from> and dispatch.  If the metatype of from is ofthe specified type execution jumps to <destination-label>.  Otherwise,execution proceeds normally at the next opcode.  See the :xxx-wrapperoperands. (:jmp <function>)fcn contains a function to call.  <function> must be a :REG operand.The call should be `tail recursive' in that whatever values it returnsshould be returned immediately from the LAP closure itself.Method lookup is implemented by finding a function in the cache and thenusing :JMP to call it.  The various kinds of traps are implemented byusing :JMP to call a trap function that was stored in one of the closurevariables. (:label <label>)Identifies a point in the lap code.  <label> is a symbol.  This can bethe target of any of the control transfer opcodes (:GO, :EQ, :NEQ,:TYPECASE) (:go <label>)Jump to the label <label>.  <label> is a symbol.*** Examples ***Here is an example of the use of this dcode.  It doesn't use the XOR orshift operation, but it uses all the others and is representative of theLAP sequences PCL will use.Several things are worth noting:  * This is, I believe, just about the simplest such sequence.  There    are some others of comparable simplicity, but none much simpler.  * A total of only 5 registers are used.  I haven't checked, but I    am pretty sure most all such code sequences will get by with 16    or less and many will stay under 8.	(defun make-1-arg-std-dfun ()  (make-lap-closure-generator    '(cache mask reflect trap)    '(a0)    '((:move (:arg a0) (:reg 0))      (:std-instance-p (:reg 0) std-instance)      (:go trap)      (:label std-instance)      ;;      ;; The stable register pattern for the rest of the code is:      ;;   0   Cache      ;;   1   Cache count      ;;   2   Wrapper      ;;   3   index under consideration      ;;      ;; Whenever we jump to HIT, this pattern must be in force.      ;;               (:move (:std-wrapper (:reg 0)) (:reg 2))	        ;Wrapper      --> 2      (:move (:cvar cache) (:reg 0))		        ;Cache        --> 0      (:move (:svref (:reg 0) 0) (:reg 1))	        ;Cache count  --> 1      (:move (:svref (:reg 2) 0) (:reg 4))	        ;index        --> 4      (:move (:cvar mask) (:reg 5))            		;mask         --> 5      (:move (:ilogand (:reg 4) (:reg 5)) (:reg 3))	;masked-index --> 3      (:move (:iref (:reg 0) (:reg 3)) (:reg 4))	;key          --> 4      (:eq (:reg 2) (:reg 4) hit)		        ;hit?      (:move (:cvar reflect) (:reg 4))		        ;reflect      --> 4      (:move (:reg 3) (:reg 5))			        ;index        --> 5      (:move (:i- (:reg 4) (:reg 5)) (:reg 3))	        ;mirror-index --> 3      (:move (:iref (:reg 0) (:reg 3)) (:reg 4))	;key          --> 4      (:eq (:reg 2) (:reg 4) hit)		        ;hit?      (:go trap)      ;;      ;; To do the hit, we use registers as follows:      ;;   0   cache comes in here      ;;   1   cache count comes in here      ;;   2   use this for the function      ;;   3   index comes in here      ;;   4   1+ index, then new count      ;;         (:label hit)      (:move (:i1+ (:reg 3)) (:reg 4))      (:move (:iref (:reg 0) (:reg 4)) (:reg 2))      (:move (:svref (:reg 0) 0) (:reg 4))      (:fix= (:reg 1) (:reg 4) call)      (:go trap)      (:label call)      (:jmp (:reg 2))      (:label trap)      (:move (:cvar trap) (:reg 0))      (:jmp (:reg 0))      )))||#;;;;;; A portable implementation of an abstract LAP code assembler.  and;;; related functions.  This implementation works by assembling the LAP;;; code into LISP and then compiling the LISP.  Needless to say, this;;; doesn't really get any of the advantages the LAP mechanism is really;;; for.  This portable implementation is mostly for debugging and early;;; stages of doing a new port of PCL.;;;;;; NOTE:;;;   This portable LAP implementation is designed to be relatively ;;;   fast at run time, but do a fair amount of error checking at LAP;;;   assembly time.  That makes it useful for debugging the parts of;;;   PCL that generate LAP closures.  Implementation specific code;;;   for LAP closures should be as fast as possible at runtime and;;;   LAP assembly time.  That code should not take time to check the;;;   LAP code at assembly time.;;;(defmacro lap-case (operand &body cases)  (once-only (operand)    `(ecase (car ,operand)       ,@(mapcar #'(lambda (case)		     `(,(car case)		       (destructuring-bind ,(cadr case)					   (cdr ,operand)			 ,@(cddr case))))		 cases))))(defvar *plap-optimize-declaration* '((speed 3) (safety 0) (size 0)))(defvar *plap-cvars*)(defvar *plap-args*)(defvar *plap-rest-p*)(defvar *plap-registers*)(defun make-lap-closure-generator (closure-var-names arg-names lap-code)  (compile-lambda    (emit-lap-closure-constructor closure-var-names arg-names lap-code)))(defun emit-lap-closure-constructor (cvars args lap)  (dolist (x cvars)    (unless (and x (symbolp x))      (error "Illegal closure variable (~S) for a LAP closure." x)))  (dolist (x args)    (unless (and x (symbolp x))      (error "Illegal argument (~S) for a LAP closure." x)))  (let* ((rest (memq '&rest args))	 (ldiff (and rest (ldiff args rest))))    (when rest (setq args (nconc ldiff '(&rest .plap-rest-arg.))))    (let* ((*plap-cvars* cvars)	   (*plap-args* (if rest ldiff args))	   (*plap-rest-p* rest)	   (*plap-registers* ())	   	   (code (mapcar #'emit-opcode lap)))      `(lambda ,cvars	 (declare (optimize . ,*plap-optimtize-declaration*))	 #'(lambda ,args	     (declare (optimize . ,*plap-optimize-declaration*))	     (prog ,*plap-registers* ,.code))))))(defun emit-opcode (opcode)  (labels ((emit-reg (reg) (emit-operand reg :reg opcode))	   (emit-regs (fn &rest regs) (cons fn (mapcar #'emit-reg regs))))        (lap-case opcode      (:break (message . args)       `(break ,message ,.(mapcar #'emit-operand args)))          (:move (from to)  `(setf ,(emit-reg to) ,(emit-operand from)))          (:go   (label)      `(go ,label))          (:label (label) label)          (:jmp (fn)       `(return ,(if *plap-rest-p*		     `(apply ,(emit-reg fn) ,@*plap-args* .plap-rest-arg.)		     `(funcall ,(emit-reg fn) ,@*plap-args*))))      ((:eq :neq :fix=) (arg1 arg2 label)       (let ((test (ecase (car opcode) (:eq 'eq) (:neq 'neq) (:fix= '=))))	 `(when ,(emit-regs test arg1 arg2) (go ,label))))          (:std-instance-p (from label)       `(when (iwmc-class-p ,(emit-reg from)) (go ,label)))            )))(defun emit-operand (operand &optional restriction from)  (unless (or (null restriction)	      (if (listp restriction)		  (memq (car operand) restriction)		  (eq (car operand) restriction)))    (error "In ~S, argument number ~D isn't valid."	   from (position operand from)))  (labels ((emit-reg (reg) (emit-operand reg :reg operand))	   (emit-regs (fn &rest regs) (cons fn (mapcar #'emit-reg regs))))    ;;    ;;    ;;	      (lap-case operand      (:reg (n)       (if (and (numberp n) (> n -1) (< n 32))	   (let ((symbol (intern (format nil "REG~D" n) *the-pcl-package*)))	     (pushnew symbol *plap-registers*)	     symbol)	   (error "Invalid register number ~S." n)))      (:cvar (name)       (if (memq name *plap-cvars*)	   name	   (error "The argument to :CVAR (~S) is not a closure var." name)))      (:arg  (name)       (if (memq name *plap-args*)	   name	   (error "The argument to :ARG (~S) is not a argument name."		  name)))      (:svref (vector i)       (if (typep i 'fixnum)	   `(svref ,(emit-operand vector :reg operand) ,i)	   (error "The second argument to :SVREF is not a fixnum.")))            (:std-wrapper (from)       `(iwmc-class-class-wrapper ,(emit-operand from)))      (:iref    (vector index)  (emit-regs 'svref vector index))            (:ilogand (index1 index2) (emit-regs 'logand index1 index2))      (:ilogxor (index1 index2) (emit-regs 'logxor index1 index2))      (:i+      (index1 index2) (emit-regs '+ index1 index2))      (:i-      (index1 index2) (emit-regs '- index1 index2))      (:i1+     (index)         (emit-regs '1+ index))      )))