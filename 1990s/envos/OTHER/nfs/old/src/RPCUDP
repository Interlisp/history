(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "RPC2")(il:filecreated "23-May-89 19:09:03" il:{piglet/n}<piglet>nfs>sources>rpcudp\;4 23769        il:|changes| il:|to:|  (il:functions exchange-udp-packets)      il:|previous| il:|date:| "16-May-89 19:02:18" il:{piglet/n}<piglet>nfs>sources>rpcudp\;3); Copyright (c) 1988, 1989 by Xerox Corporation.  All rights reserved.(il:prettycomprint il:rpcudpcoms)(il:rpaqq il:rpcudpcoms ((il:* il:|;;| "Definitions for UDP transport of RPC") (il:props (il:rpcudp il:makefile-environment il:filetype)) (eval-when (eval compile) (il:files il:rpcdecls) (il:p (load-tcp-exports))) (il:coms (il:* il:\; "I'd like these to be inside the eval-when, too, but then they don't get eval'ed when I load the file prop!") (il:variables *udp-fixed-overhead-bytes*) (il:functions udp-output-base)) (il:variables *udp-rpc-methods*) (il:functions rpc-create-udp-stream udp-initialize udp-close exchange-udp-packets program-unavailable-reply-p udp-handle-icmp udp-recover-socket udp-getbyte udp-putbyte udp-getcell udp-getunsigned udp-putcell udp-getoffset udp-getrawbytes udp-putrawbytes udp-skipbytes udp-zerobytes) (il:fns il:udp.get.bytes il:\\udp.set.checksum.zero) (il:coms (il:* il:\; "Prettier printing") (il:fns il:printudp il:rpc.graphic.charp il:printrpc.anything il:printrpc.auth il:printrpcdata) (il:addvars (il:udpignoreports 520)) (il:globalvars il:udpignoreports)) (eval-when (load) (il:p (unless (fboundp (quote il:\\udp.handle.icmp)) (il:filesload (il:sysload) il:iprpcpatch)) (il:changename (quote il:udp.send) (quote il:\\udp.set.checksum) (quote il:\\udp.set.checksum.zero))) (il:files (il:sysload) il:medley-ippatches))))(il:* il:|;;| "Definitions for UDP transport of RPC")(il:putprops il:rpcudp il:makefile-environment (:readtable "XCL" :package "RPC2"))(il:putprops il:rpcudp il:filetype :compile-file)(eval-when (eval compile)(il:filesload il:rpcdecls)(load-tcp-exports))(il:* il:\; "I'd like these to be inside the eval-when, too, but then they don't get eval'ed when I load the file prop!")(defconstant *udp-fixed-overhead-bytes* (+ il:\\udpovlen (unfold (il:indexf (il:|fetch| (il:etherpacket il:epbody) il:|of| inpacket)) *bytes-per-word*)) "Number of bytes of fixed overhead in a UDP packet before you get to data.  Have to add variable IP header length to this.")(defmacro udp-output-base (packet) "Pointer to start of IP image in packet.  Output byte pointers are relative to this." (il:bquote (il:|fetch| (il:ip il:ipbase) il:|of| (il:\\\, packet))))(defglobalparameter *udp-rpc-methods* (il:* il:|;;| "These quotes should really be #', but in Xerox Lisp the former is significantly nicer on some machines, and the result is the same.") (make-rpc-methods :protocol (quote udp) :getbyte (quote udp-getbyte) :putbyte (quote udp-putbyte) :getcell (quote udp-getcell) :getunsigned (quote udp-getunsigned) :getoffset (quote udp-getoffset) :putcell (quote udp-putcell) :skipbytes (quote udp-skipbytes) :zerobytes (quote udp-zerobytes) :getrawbytes (quote udp-getrawbytes) :putrawbytes (quote udp-putrawbytes) :close (quote udp-close) :initialize (quote udp-initialize) :exchange (quote exchange-udp-packets)) "Op vector for UDP version of RPC")(defun rpc-create-udp-stream (&optional destaddr destsocket) "Create a new RPC Stream with the vector of functions set up to for UDP Protocol Datagrams." (make-rpc-stream :methods *udp-rpc-methods* :ipsocket (il:udp.open.socket nil nil (quote udp-handle-icmp)) :inbyteptr 0 :outstream nil :destaddr (and destaddr (if (integerp destaddr) destaddr (rpc-resolve-host destaddr))) :destsocket (and destsocket (if (integerp destsocket) destsocket (rpc-resolve-prog destsocket nil (quote udp))))))(defun udp-initialize (stream destaddr destsocket) (when (typep (rpc-stream-instream stream) (quote il:etherpacket)) (il:* il:|;;| "Release  Etherpacket used for previous input from remote host. This could be done earlier, when PARSE-RPC-STREAM finishes with the packet, but since *RPCSTREAM* still points at the stream for debugging, it is better to wait until now..") (il:\\release.etherpacket (rpc-stream-instream stream)) (setf (rpc-stream-instream stream) nil)) (let ((packet (rpc-stream-outstream stream))) (il:* il:|;;| "Construct an empty UDP packet.  Our INBYTEPTR is meaningless until a packet arrives.  OUTBYTEPTR is relative to IPBASE.") (when destaddr (unless (integerp destaddr) (setq destaddr (rpc-resolve-host destaddr))) (setf (rpc-stream-destaddr stream) destaddr)) (cond (nil (when (null packet) (setf (rpc-stream-outstream stream) (setq packet (il:\\allocate.etherpacket)))) (il:udp.setup packet (or destaddr (rpc-stream-destaddr stream)) nil 0 (rpc-stream-ipsocket stream))) ((null packet) (il:* il:\; "First time thru, give us a packet") (setq packet (il:\\allocate.etherpacket)) (il:udp.setup packet (or destaddr (rpc-stream-destaddr stream)) nil 0 (rpc-stream-ipsocket stream)) (setf (rpc-stream-outstream stream) packet)) (destaddr (il:* il:\; "May have wanted to change address") (setf (il:|fetch| (il:ip il:ipdestinationaddress) il:|of| packet) destaddr))) (when destsocket (il:* il:\; "We'll deal with the socket later") (setf (rpc-stream-destsocket stream) (if (integerp destsocket) destsocket (rpc-resolve-prog destsocket nil (quote udp))))) (let ((emptyudplen (+ il:\\ipovlen il:\\udpovlen))) (setf (rpc-stream-inbyteptr stream) -1 (il:|fetch| (il:udp il:udplength) il:|of| packet) il:\\udpovlen (il:|fetch| (il:ip il:iptotallength) il:|of| packet) emptyudplen (rpc-stream-outbyteptr stream) emptyudplen)) t))(defun udp-close (rpcstream) "Deallocate an RPC Stream. Tries to cleanup after itself." (il:udp.close.socket (rpc-stream-ipsocket rpcstream)))(defun exchange-udp-packets (rpcstream errorflg xid) "Given the specified timeout and time between tries, this routine continues to send out UDP packets until it either gets a reply or times out." (let ((timer (and *msec-until-timeout* (il:setuptimer *msec-until-timeout*))) (timeout *msec-between-tries*) (outpacket (rpc-stream-outstream rpcstream)) (socket (rpc-stream-ipsocket rpcstream)) (length (rpc-stream-outbyteptr rpcstream)) (timeout-count 0) (destsocket (rpc-stream-destsocket rpcstream)) inpacket tried-new-socket) (incf (il:|fetch| (il:udp il:udplength) il:|of| outpacket) (- length (il:|fetch| (il:ip il:iptotallength) il:|of| outpacket))) (il:|replace| (il:ip il:iptotallength) il:|of| outpacket il:|with| length) (il:* il:\; "Adjust the lengths in the packet to reflect what we've written") (when (and (numberp *debug*) (> *debug* 5)) (break "About to send packet (rpc-stream-outstream *rpc-stream*)")) (loop (il:* il:|;;| "This loop keeps sending a packet and waiting for replies until someone explicitly returns something") (when (or (null destsocket) (let ((soc destsocket)) (il:* il:|;;| "Need to fill in the destination socket.  We didn't do this in initialize, because we could get timeouts on this as well, in which case we want to be here to do the error handling.") (cond ((and (not (consp soc)) (or (integerp soc) (integerp (setq soc (rpc-find-socket (rpc-stream-destaddr rpcstream) destsocket (quote udp) :returnerrors))))) (setf (il:|fetch| (il:udp il:udpdestport) il:|of| outpacket) soc) (setq destsocket nil) t) (t (il:* il:\; "Got an error back, either from RPC-FIND-SOCKET or UDP-RECOVER-SOCKET on a previous iteration.") (cond ((and (eq (cadr soc) (quote rpc-timeout)) timer) (il:* il:\; "Drop thru to timeout handling code") (il:setuptimer 0 timer) (setq destsocket nil)) (t (return-from exchange-udp-packets (rpc-signal-error errorflg (cdr soc))))))))) (il:\\udp.flush.socket.queue socket) (il:udp.send socket outpacket) (il:block) (loop (il:* il:|;;| "This loop tries to get a packet in reply to what we just sent out") (cond ((not (setq inpacket (il:udp.get socket timeout))) (il:* il:\; "Nothing came in timeout, so try again.  Back off a little, too.") (setq timeout (min (ash timeout 1) 10000)) (return)) ((not (eq (il:|fetch| (il:ip il:ipprotocol) il:|of| inpacket) il:\\udp.protocol)) (il:* il:\; "ICMP packet saying port unreachable.  Go fix up the socket cache.") (cond ((il:\\ip.broadcast.address (il:|fetch| (il:ip il:ipdestinationaddress) il:|of| outpacket)) (il:* il:\; "This was a broadcast rpc, so ignore this stupid response")) ((setq destsocket (udp-recover-socket outpacket rpcstream)) (il:* il:\; "Got a new socket, so try again") (setq tried-new-socket t) (when (and (integerp destsocket) timer) (il:* il:|;;| "Actually got a new socket # back, so reset timer as if we only now just started.  Alternative is we got a program back, which really means that portmapper timed out, but we want to do the looping here.") (il:setuptimer *msec-until-timeout* timer)) (return)) (t (il:* il:\; "Failed--give up.  This looks a lot like the RPC reply \"no such program\"") (return-from exchange-udp-packets (rpc-signal-error errorflg (il:bquote (program-unavailable (il:\\\, *program*) "No process at destination"))))))) (t (setf (rpc-stream-instream rpcstream) inpacket) (setf (rpc-stream-inbyteptr rpcstream) (+ *udp-fixed-overhead-bytes* (unfold (il:|fetch| (il:ip il:ipheaderlength) il:|of| inpacket) *bytes-per-cell*))) (il:* il:\; "Byte offset of start of udp data") (when (and (numberp *debug*) (> *debug* 5)) (break "A reply is in (rpc-stream-instream *rpc-stream*)")) (cond ((= (getunsigned rpcstream) xid) (il:* il:\; "ID's match, so it's ok") (when (and (not tried-new-socket) (program-unavailable-reply-p rpcstream) (setq destsocket (udp-recover-socket outpacket rpcstream))) (il:* il:\; "Moby Kludge!!!  Sometimes when servers crash and return, old socket has a different program on it, which returns this \"program unavailable\" error.  Ought to catch this in Parse-rpc-reply, but the recovery is much more awkward there.") (setq tried-new-socket t) (when (and (integerp destsocket) timer) (il:* il:|;;| "Actually got a new socket # back, so reset timer as if we only now just started.  Alternative is we got a program back, which really means that portmapper timed out, but we want to do the looping here.") (il:setuptimer *msec-until-timeout* timer)) (return)) (return-from exchange-udp-packets t)) ((and (numberp *debug*) (> *debug* 1)) (format-t " (discarded packet with wrong ID)"))) (il:* il:\; "So go around the loop again"))))) (when (and timer (il:timerexpired? timer)) (il:* il:\; "Timed out") (unless (and (not tried-new-socket) (progn (il:* il:\; "Time out could be because server crashed, is using new socket, and process on old socket doesn't return error packets.  If UDP-RECOVER-SOCKET returns other than integer, we did not succeed in getting a new socket") (setq tried-new-socket t) (integerp (setq destsocket (udp-recover-socket outpacket rpcstream))))) (let ((result (rpc-handle-timeout rpcstream (incf timeout-count) errorflg))) (unless (eq result :continue) (return-from exchange-udp-packets result)))) (il:setuptimer *msec-until-timeout* timer) (il:* il:\; "Reset the timer and keep going") (setq timeout *msec-between-tries*)))))(defun program-unavailable-reply-p (rpcstream) (il:* il:|;;| "True if the reply waiting in RPCSTREAM is \"Program Unavailable\".  What a kludge.") (il:* il:|;;| "Code here is heavily optimized.") (macrolet ((eql-getbasecell (base celloffset expected) (il:* il:|;;| "True if the 32-bit number at CELLOFFSET from BASE is EXPECTED") (let ((offset (if (integerp celloffset) (il:llsh celloffset 1) 0))) (il:bquote (let ((base (il:\\\, (if (integerp celloffset) base (il:bquote (il:\\addbase (il:\\\, base) (il:llsh (il:\\\, celloffset) 1))))))) (and (eq (il:\\getbase base (+ (il:\\\, offset) 1)) (logand (il:\\\, expected) 65535)) (eq (il:\\getbase base (il:\\\, offset)) (ash (il:\\\, expected) -16)))))))) (let ((replybase (il:\\addbase (rpc-stream-instream rpcstream) (il:lrsh (rpc-stream-inbyteptr rpcstream) 1)))) (il:* il:|;;| "REPLYBASE=> [reply] [accepted] [authtype] [authstring] [accept-stat] data") (and (eql-getbasecell replybase 1 *rpc-reply-accepted*) (eql-getbasecell replybase (+ (getbase-unsigned replybase (* *bytes-per-cell* 3)) (il:* il:\; "Length of authentication string") 4) *rpc-accept-program-unavailable*) (eql-getbasecell replybase 0 *rpc-msg-reply*)))))(defun udp-handle-icmp (icmp sentip socket) (il:* il:|;;| "Handle an ICMP destination unreachable packet sent in response to SENTIP on this SOCKET.") (when (eql (il:|fetch| (il:icmp il:icmpcode) il:|of| icmp) il:\\icmp.port.unreachable) (il:* il:\; "Need to know about Port unreachable so we can recache the socket.  Queue this up so it will be read by EXCHANGE-UDP-PACKETS") (il:\\ip.default.inputfn icmp socket)))(defun udp-recover-socket (outpacket rpcstream) (il:* il:|;;| "Called when we get a port unreachable when trying to send OUTPACKET.  This typically happens if server boots and assigns the service a different socket.  Returns a new port, or NIL to fail.") (let ((program (rpc-stream-destsocket rpcstream))) (and (typep program (quote rpc-program)) (let* ((destaddr (rpc-stream-destaddr rpcstream)) (prognum (rpc-program-number program)) (version (rpc-program-version program)) (oldentry (find-if (function (lambda (entry) (and (eql (car entry) destaddr) (eql (car (setq entry (cdr entry))) prognum) (eql (car (setq entry (cdr entry))) version) (eq (car (setq entry (cdr entry))) (quote udp))))) *rpc-socket-cache*)) (oldsocket (il:|fetch| (il:udp il:udpdestport) il:|of| outpacket)) newsocket cachedsocket) (cond ((and oldentry (not (eql (setq cachedsocket (fifth oldentry)) oldsocket))) (il:* il:\; "There's a different socket in cache, maybe someone looked it up already, or called us with out of date info") cachedsocket) ((not (integerp (setq newsocket (let ((*rpc-ok-to-cache* nil)) (il:* il:\; "Don't let it find the old socket") (rpc-find-socket destaddr program (quote udp) :returnerrors))))) (il:* il:\; "Portmapper failed.  We'll just send back the error (or program object if timeout) and let exchange-udp-packets handle it") (or newsocket program)) ((eql newsocket oldsocket) (il:* il:\; "Server still thinks it's on this socket, so no use trying again") nil) (t (il:* il:\; "good, service moved to a different socket, so use that, and record the change") (if oldentry (setf (fifth oldentry) newsocket) (cache-socket program destaddr newsocket)) newsocket))))))(defun udp-getbyte (rpcstream) (let ((offset (rpc-stream-inbyteptr rpcstream))) (prog1 (il:\\getbasebyte (rpc-stream-instream rpcstream) offset) (setf (rpc-stream-inbyteptr rpcstream) (1+ offset)))))(defun udp-putbyte (rpcstream byte) (let ((offset (rpc-stream-outbyteptr rpcstream))) (il:\\putbasebyte (udp-output-base (rpc-stream-outstream rpcstream)) offset byte) (setf (rpc-stream-outbyteptr rpcstream) (1+ offset))))(defun udp-getcell (rpcstream) (let ((byteoffset (rpc-stream-inbyteptr rpcstream))) (prog1 (getbase-integer (rpc-stream-instream rpcstream) byteoffset) (setf (rpc-stream-inbyteptr rpcstream) (+ byteoffset *bytes-per-cell*)))))(defun udp-getunsigned (rpcstream) (let ((byteoffset (rpc-stream-inbyteptr rpcstream))) (prog1 (getbase-unsigned (rpc-stream-instream rpcstream) byteoffset) (setf (rpc-stream-inbyteptr rpcstream) (+ byteoffset *bytes-per-cell*)))))(defun udp-putcell (rpcstream value) "Write a 32-bit value to udp stream." (let ((offset (rpc-stream-outbyteptr rpcstream))) (putbase-integer (udp-output-base (rpc-stream-outstream rpcstream)) offset value) (setf (rpc-stream-outbyteptr rpcstream) (+ offset *bytes-per-cell*))))(defun udp-getoffset (rpcstream) (cons (rpc-stream-instream rpcstream) (rpc-stream-inbyteptr rpcstream)))(defun udp-getrawbytes (rpcstream base offset nbytes) "Get NBYTES bytes from rpc stream, store them at base,offset." (let ((soffset (rpc-stream-inbyteptr rpcstream))) (il:\\movebytes (rpc-stream-instream rpcstream) soffset base offset nbytes) (setf (rpc-stream-inbyteptr rpcstream) (+ soffset nbytes)) base))(defun udp-putrawbytes (rpcstream base offset nbytes) "Put NBYTES bytes to rpc stream from base,offset." (let ((pktoffset (rpc-stream-outbyteptr rpcstream))) (il:\\movebytes base offset (udp-output-base (rpc-stream-outstream rpcstream)) pktoffset nbytes) (setf (rpc-stream-outbyteptr rpcstream) (+ pktoffset nbytes))))(defun udp-skipbytes (rpcstream nbytes) (incf (rpc-stream-inbyteptr rpcstream) nbytes))(defun udp-zerobytes (rpcstream nbytes) (let ((base (udp-output-base (rpc-stream-outstream rpcstream))) (offset (rpc-stream-outbyteptr rpcstream))) (dotimes (i nbytes) (il:\\putbasebyte base offset 0) (incf offset)) (setf (rpc-stream-outbyteptr rpcstream) offset)))(il:defineq(il:udp.get.bytes(il:lambda (il:udp il:soffset il:dest il:doffset il:nbytes) (il:* il:\; "Edited 24-Aug-88 12:05 by bvm") (il:* il:|;;;| "Move bytes out of UDP Packet to another buffer without string creation.  Used to fetch off UDPCONTENTS, but we've adjusted pointers.  This relic is solely for benefit of nfs-readpage.") (il:\\movebytes il:udp il:soffset il:dest il:doffset il:nbytes) il:dest))(il:\\udp.set.checksum.zero(il:lambda (il:udp) (il:* il:\; "Edited 27-Apr-88 21:52 by drc:") (il:* il:|;;;| "Avoid doing a UDP checksum. Packet already gets IP Checksum.") (il:|replace| (il:udp il:udpchecksum) il:|of| il:udp il:|with| 0))))(il:* il:\; "Prettier printing")(il:defineq(il:printudp(il:lambda (il:udp il:file) (il:* il:\; "Edited 23-Feb-89 19:20 by bvm") (let ((il:source (il:|fetch| (il:udp il:udpsourceport) il:|of| il:udp)) (il:dest (il:|fetch| (il:udp il:udpdestport) il:|of| il:udp))) (il:|printout| il:file "UDP Source: " il:source " Dest: " il:dest " Len: " (il:|fetch| (il:udp il:udplength) il:|of| il:udp) " Chksm: " (il:|fetch| (il:udp il:udpchecksum) il:|of| il:udp) t) (cond ((and il:udpignoreports (or (il:fmemb il:source il:udpignoreports) (il:fmemb il:dest il:udpignoreports)))) ((or (eq il:dest il:\\tftp.socket) (eq il:source il:\\tftp.socket)) (il:printtftp il:udp il:file)) (t (il:printrpcdata (il:|fetch| (il:udp il:udpcontents) il:|of| il:udp) (- (il:|fetch| (il:udp il:udplength) il:|of| il:udp) il:\\udpovlen) il:file))))))(il:rpc.graphic.charp(il:lambda (il:code) (il:* il:\; "Edited 28-Apr-88 12:45 by bvm") (and (>= il:code (il:charcode il:space)) (< il:code (il:charcode il:del)))))(il:printrpc.anything(il:lambda (il:base il:nwords il:file) (il:* il:\; "Edited 24-Aug-88 15:02 by bvm") (il:|while| (> il:nwords 0) il:|bind| il:hiword il:hibyte il:i il:|do| (il:setq il:hiword (il:\\getbase il:base 0)) (il:|if| (or (eq (il:setq il:hibyte (il:lrsh il:hiword 8)) 0) (eq il:hiword il:max.smallp)) il:|then| (il:* il:\; "Looks like some sort of integer in [0, 2^24] or some sort of small negative.") (format il:file "{~D}" (il:\\makenumber il:hiword (il:\\getbase il:base 1))) il:|elseif| (and (il:rpc.graphic.charp il:hibyte) (il:|for| il:|old| il:i il:|from| 1 il:|to| 3 il:|always| (or (il:rpc.graphic.charp (il:\\getbasebyte il:base il:i)) (and (il:|for| il:j il:|from| il:i il:|to| 3 il:|always| (eq (il:\\getbasebyte il:base il:j) 0)) (return t))))) il:|then| (il:* il:\; "Probably a string, possibly with trailing padding") (il:|for| il:j il:|from| 0 il:|to| (il:sub1 il:i) il:|do| (il:\\outchar il:file (il:\\getbasebyte il:base il:j))) (il:|if| (< il:i 4) il:|then| (il:* il:\; "Indicate padding") (il:\\outchar il:file (il:charcode "[")) (il:rptq (- 4 il:i) (il:\\outchar il:file (il:charcode "0"))) (il:\\outchar il:file (il:charcode "]"))) il:|else| (il:* il:\; "Random bytes") (format il:file "{~D,~D,~D,~D}" il:hibyte (il:\\getbasebyte il:base 1) (il:\\getbasebyte il:base 2) (il:\\getbasebyte il:base 3))) (il:setq il:base (il:\\addbase il:base il:wordspercell)) (il:setq il:nwords (- il:nwords il:wordspercell)))))(il:printrpc.auth(il:lambda (il:base il:maxwords il:file) (il:* il:\; "Edited 31-Aug-88 18:48 by bvm") (il:* il:|;;| "Print an authentication object.  Return number of words printed") (let* ((il:strlen (il:\\getbasefixp il:base il:wordspercell)) (il:strwords (il:unfold (il:foldhi il:strlen il:bytespercell) il:wordspercell))) (il:prin1 "[Auth" il:file) (il:|if| (< il:maxwords (+ 4 il:strwords)) il:|then| (il:prin1 " too short]" il:file) (il:printrpc.anything il:base il:maxwords il:file) il:maxwords il:|else| (il:prin1 (il:selectq (il:\\getbasefixp il:base 0) (0 "Null") (1 "Unix") (2 "Short") "Unknown") il:file) (il:|if| (il:neq 0 il:strlen) il:|then| (format il:file ": {~D}" il:strlen) (il:printrpc.anything (il:\\addbase il:base (il:times 2 il:wordspercell)) il:strwords il:file)) (il:prin1 "]" il:file) (+ 4 il:strwords)))))(il:printrpcdata(il:lambda (il:base il:nbytes il:file) (il:* il:\; "Edited 19-Sep-88 17:44 by bvm") (il:* il:|;;| "Interpret BASE for NBYTES as RPC contents") (let (il:op il:nwords il:i) (or il:file (il:setq il:file *standard-output*)) (il:|if| (not (evenp il:nbytes il:bytespercell)) il:|then| (il:prin1 "Length not a multiple of 4! " il:file) (il:printpacketdata il:base 0 (quote (il:bytes)) il:nbytes) il:|else| (format il:file "~A ID = ~D" (il:selectq (il:setq il:op (il:\\getbasefixp il:base il:wordspercell)) (0 "Call") (1 "Rply") "unknown") (il:\\getbasefixp il:base 0)) (il:setq il:nwords (il:foldhi il:nbytes il:bytesperword)) (il:selectq il:op (0 (il:* il:\; "Call") (il:prin1 "; " il:file) (il:|if| (il:neq (il:\\getbasefixp il:base (il:times 2 il:wordspercell)) *rpc-version*) il:|then| (format il:file "RPC version ~D " (il:\\getbasefixp il:base (il:times 2 il:wordspercell)))) (let ((il:pgm (il:\\getbasefixp il:base (il:times 3 il:wordspercell))) (il:version (il:\\getbasefixp il:base (il:times 4 il:wordspercell))) (il:proc (il:\\getbasefixp il:base (il:times 5 il:wordspercell))) (il:def)) (format il:file "Program ~D[~D] Proc ~D" il:pgm il:version il:proc) (il:|if| (il:setq il:def (find-rpc-program :number il:pgm :version il:version :protocol (quote udp))) il:|then| (format il:file " (~:(~A.~A~))" (rpc-program-name il:def) (il:|for| il:p il:|in| (rpc-program-procedures il:def) il:|when| (eq (rpc-procedure-procnum il:p) il:proc) il:|do| (return (rpc-procedure-name il:p)) il:|finally| (return "unknown")))) (il:terpri)) (il:setq il:i (il:times 6 il:wordspercell)) (il:|add| il:i (il:printrpc.auth (il:\\addbase il:base il:i) (- il:nwords il:i) il:file)) (il:|add| il:i (il:printrpc.auth (il:\\addbase il:base il:i) (- il:nwords il:i) il:file))) (1 (il:terpri il:file) (il:* il:\; "Reply") (il:|if| (not (eq (il:\\getbasefixp il:base (il:times 2 il:wordspercell)) 0)) il:|then| (format il:file "Reject ~A " (il:selectq (il:\\getbasefixp il:base (il:times 3 il:wordspercell)) (0 "RPC mismatch") (1 "Authentication error") "unknown")) (il:setq il:i (il:times 4 il:wordspercell)) il:|else| (il:setq il:i (il:times 3 il:wordspercell)) (il:|add| il:i (il:printrpc.auth (il:\\addbase il:base il:i) (- il:nwords il:i) il:file)) (il:|if| (il:neq (il:setq il:op (il:\\getbasefixp il:base il:i)) 0) il:|then| (il:* il:\; "Failure") (il:prin1 " Failed: " il:file) (il:prin1 (il:selectq il:op (1 "Program unavailable") (2 "Program mismatch") (3 "Procedure unavailable") (4 "Garbage args") "Unknown") il:file)) (il:|add| il:i il:wordspercell))) (progn (il:terpri il:file) (il:* il:\; "Unknown case") (il:setq il:i (il:times 2 il:wordspercell)))) (il:printrpc.anything (il:\\addbase il:base il:i) (- il:nwords il:i) il:file) (il:terpri))))))(il:addtovar il:udpignoreports 520)(il:declare\: il:doeval@compile il:dontcopy(il:globalvars il:udpignoreports))(eval-when (load)(unless (fboundp (quote il:\\udp.handle.icmp)) (il:filesload (il:sysload) il:iprpcpatch))(il:changename (quote il:udp.send) (quote il:\\udp.set.checksum) (quote il:\\udp.set.checksum.zero))(il:filesload (il:sysload) il:medley-ippatches))(il:putprops il:rpcudp il:copyright ("Xerox Corporation" 1988 1989))(il:declare\: il:dontcopy  (il:filemap (nil (16564 17229 (il:udp.get.bytes 16577 . 16980) (il:\\udp.set.checksum.zero 16982 . 17227)) (17271 23290 (il:printudp 17284 . 18066) (il:rpc.graphic.charp 18068 . 18237) (il:printrpc.anything 18239 . 19690) (il:printrpc.auth 19692 . 20532) (il:printrpcdata 20534 . 23288)))))il:stop