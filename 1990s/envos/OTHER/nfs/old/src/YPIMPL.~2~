(DEFINE-FILE-INFO PACKAGE "YP" READTABLE "XCL" BASE 10)(il:filecreated "13-Mar-90 13:53:32" "{piglet/n}<piglet>nfs>sources>YPIMPL;9" 14894        il:|changes| il:|to:|  (il:functions get-user-gids)      il:|previous| il:|date:| "13-Nov-89 18:54:01" "{piglet/n}<piglet>nfs>sources>YPIMPL;8"); Copyright (c) 1988, 1989, 1990 by Xerox Corporation.  All rights reserved.(il:prettycomprint il:ypimplcoms)(il:rpaqq il:ypimplcoms ((il:* il:|;;| "Meat of YP.  Separate file to avoid recompiling the rpc def all the time") (eval-when (eval) (il:props (il:ypimpl il:makefile-environment) (il:ypimpl il:filetype))) (il:p (export (quote (yp yp-restart *yp-domain* *yp-servers* *yp-net-hints* *gids-from-user-map* yp-call yp-match get-uid get-user-gids group-gid uid-name gid-name host-address host-name read-map integer-from-string)))) (eval-when (eval compile) (il:p (proclaim (quote (global il:\\ip.hostnumbers il:\\ip.hostnames il:\\10mblocalndb il:\\ip.default.gateway il:networkostypes))) (proclaim (quote (special il:promptwindow))))) (il:variables *uid-to-name-table* *gid-to-name-table* *gids-from-user-map* *yp-domain* *yp-servers* *yp-net-hints* *yp-program* *yp-lock* *broadcasting*) (il:functions yp-restart read-yp-init-file broadcast-for-servers maiko-broadcast-for-servers d-broadcast-for-servers) (il:functions yp-call yp-match uid-name gid-name group-gid get-uid get-user-gids host-address record-host-address host-name read-map integer-from-string) (eval-when (load) (il:appendvars (il:restartetherfns yp-restart)) (il:p (il:* il:|;;| "Read the YP.INIT file right now so it's in the world when saved out.  Don't look for servers yet; we wouldn't use them if we did.") (yp-restart))) (il:advise il:iphostaddress)))(il:* il:|;;| "Meat of YP.  Separate file to avoid recompiling the rpc def all the time")(eval-when (eval)(il:putprops il:ypimpl il:makefile-environment (:package "YP" :readtable "XCL" :base 10))(il:putprops il:ypimpl il:filetype :compile-file))(export (quote (yp yp-restart *yp-domain* *yp-servers* *yp-net-hints* *gids-from-user-map* yp-call yp-match get-uid get-user-gids group-gid uid-name gid-name host-address host-name read-map integer-from-string)))(eval-when (eval compile)(proclaim (quote (global il:\\ip.hostnumbers il:\\ip.hostnames il:\\10mblocalndb il:\\ip.default.gateway il:networkostypes)))(proclaim (quote (special il:promptwindow))))(defvar *uid-to-name-table* (make-hash-table))(defvar *gid-to-name-table* (make-hash-table))(defvar *gids-from-user-map* nil "Name of map that returns list of GIDs given user name.  If NIL, we invert (painfully) group.byname.")(defvar *yp-domain* nil)(defvar *yp-servers* nil)(defvar *yp-net-hints* nil)(defvar *yp-program* nil "Pointer to YP program object.  Set by YP-RESTART")(defglobalvar *yp-lock* (il:create.monitorlock "YP calls"))(defvar *broadcasting* nil "True inside broadcast for servers call")(defun yp-restart (&optional event) (il:* il:|;;| "Called by around exit events and restart.ether.  Clear our knowledge of yp servers and start afresh") (case event ((il:afterlogout il:aftermakesys il:aftersysout il:aftersavevm il:restart nil) (setq *yp-program* (rpc2:find-rpc-program :name (quote yp))) (il:* il:\; "Cache this") (rpc2:clear-cache *yp-program*) (il:* il:\; "Forget about old sockets") (dolist (s *yp-servers*) (il:* il:\; "Close old streams") (when (third s) (rpc2:close-rpcstream (third s)) (rplacd (cdr s) nil))) (setq *yp-servers* nil) (clrhash *uid-to-name-table*) (when (or (null *yp-net-hints*) (null *yp-domain*)) (il:* il:|;;| "If we haven't a clue, read the file.") (read-yp-init-file)))))(defun read-yp-init-file nil (cond ((probe-file "{dsk}yp.init") (with-open-file (ypinitfile "{dsk}yp.init") (declare (special il:promptwindow)) (format il:promptwindow "~&Reading ~A" (namestring ypinitfile)) (setq *yp-domain* (read ypinitfile) *yp-net-hints* (read ypinitfile)))) ((null *yp-domain*) (warn "No YP.INIT file found.  You need to set yp:*yp-domain* in order to use yp."))))(defun broadcast-for-servers nil (cond ((null *yp-domain*) (format il:promptwindow "~&YP:*YP-DOMAIN* is not set.") nil) ((cond ((eq (il:machinetype) (quote il:maiko)) (maiko-broadcast-for-servers)) (t (d-broadcast-for-servers)))) (t (format il:promptwindow "~&Couldn't find YP server for domain ~A." *yp-domain*) nil)))(defun maiko-broadcast-for-servers nil (il:* il:|;;| "On Sun, we can't do broadcast call.  Just ask the local machine who a YP host is.") (let ((s (il:create-process-stream (concatenate (quote string) "ypwhich -d " *yp-domain*)))) (unwind-protect (let ((server (read-line s))) (cond ((and (> (length server) 0) (not (position #\Space server))) (il:* il:|;;| "Assume any non-null response that's just one word is ok.") (format il:promptwindow "~&Using YP server ~A." server) (push (setq server (list *yp-domain* server)) *yp-servers*) server))) (il:unix-stream-close s))))(defun d-broadcast-for-servers nil (format il:promptwindow "~&Searching for YP server for domain ~A... " *yp-domain*) (let ((*broadcasting* t) (hints *yp-net-hints*) (args (list *yp-domain*))) (when il:\\10mblocalndb (il:* il:\; "Assume YP servers are only on 10mb nets.  Try local net first") (push 0 hints)) (dotimes (i 2) (dolist (hint hints) (multiple-value-bind (results port address) (let ((rpc2:*msec-until-timeout* 1000) (rpc2:*msec-between-tries* 300)) (il:* il:\; "Bind these in here so they don't affect the call to host-name below") (condition-case (rpc2:call-via-portmapper hint (quote yp) (quote serve-domain-p-no-nack) args) (rpc2:rpc-timeout nil))) (when address (let ((server (list *yp-domain* address))) (push server *yp-servers*) (rpc2:cache-socket *yp-program* address port) (format il:promptwindow " found ~a~%" (or (host-name address) (il:\\ip.address.to.string address))) (return-from d-broadcast-for-servers server)))))) (il:* il:|;;| "Failed after 2 tries") nil))(defun yp-call (proc args) (il:* il:|;;| "Ask a YP server to do the call PROC on ARGS") (il:with.monitor *yp-lock* (prog ((restarted *broadcasting*) server) restart (return (cond ((setq server (cond ((and *yp-servers* (eq (caar *yp-servers*) *yp-domain*)) (il:* il:\; "Small optimization for this usual case") (car *yp-servers*)) ((null *yp-domain*) nil) ((assoc *yp-domain* *yp-servers* :test (function string-equal))) (t (broadcast-for-servers)))) (let ((strm (third server))) (when (null strm) (il:* il:\; "Cache an RPC stream here") (rplacd (cdr server) (list (setq strm (rpc2:open-rpcstream (quote rpc2:udp) (second server) (quote yp) nil (function (lambda (stream count) (il:* il:\; "If this call times out, we want to search for other servers") (throw (quote yp-restart) (quote yp-restart))))))))) (let ((result (handler-bind ((rpc2:rpc-error (if restarted (function (lambda (condition) (il:* il:\; "If get RPC error again, just report it") (format il:promptwindow "~&YP call ~A failed because: ~A" proc condition) (throw (quote yp-restart) nil))) (function (lambda (condition) (il:* il:\; "If get RPC error (e.g., no such program), give up on this server") (throw (quote yp-restart) (quote yp-restart))))))) (catch (quote yp-restart) (rpc2:perform-rpc nil nil *yp-program* proc strm args nil))))) (cond ((not (eq result (quote yp-restart))) (il:* il:\; "Valid result") result) (restarted (il:* il:\; "Already tried restarting once, so just return nil") (format il:promptwindow "~&YP server timed out ~A call" proc) nil) (t (il:* il:\; "No response from server, so try another server") (setq restarted t) (setq *yp-servers* (delete server *yp-servers*)) (rpc2:close-rpcstream strm) (go restart)))))))))))(defun yp-match (map data &optional (domain *yp-domain*)) (il:* il:|;;| "Call YP's MATCH-KEY procedure with the specified map, data and domain.  Returns NIL or a string of data") (destructuring-bind (status value-data) (yp-call (quote match-key) (list domain map data)) (and (eq status (quote t)) value-data)))(defun uid-name (uid) (or (gethash uid *uid-to-name-table*) (setf (gethash uid *uid-to-name-table*) (let ((line (yp-match "passwd.byuid" (write-to-string uid :base 10 :radix nil)))) (and line (subseq line 0 (position #\: line)))))))(defun gid-name (gid) (or (gethash gid *gid-to-name-table*) (setf (gethash gid *gid-to-name-table*) (let ((line (yp-match "group.bygid" (write-to-string gid :base 10 :radix nil)))) (and line (subseq line 0 (position #\: line)))))))(defun group-gid (group-name) (let ((line (yp-match "group.byname" group-name)) colon) (il:* il:|;;| "Format of response data is \"group:*:gid:\"") (and line (setq colon (position #\: line)) (setq colon (position #\: line :start (1+ colon))) (integer-from-string line (1+ colon) (position #\: line :start (1+ colon))))))(defun get-uid (&optional (user-name (car (il:\\internal/getpassword (quote il:--nfs--) nil nil nil nil (quote il:unix))))) "Return values UID, GID, HOMEDIR" (let* ((uname (string-downcase (string user-name))) (line (yp-match "passwd.byname" (if (> (length uname) 8) (subseq uname 0 8) uname)))) (cond (line (il:* il:|;;| "Format is \"name:encryptedpasswd:uid:gid:fullname:homedir:shell\"") (let* ((firstcolon (position #\: line)) (secondcolon (position #\: line :start (1+ firstcolon))) (thirdcolon (position #\: line :start (1+ secondcolon))) (fourthcolon (position #\: line :start (1+ thirdcolon))) (fifthcolon (position #\: line :start (1+ fourthcolon))) (sixthcolon (position #\: line :start (1+ fifthcolon)))) (values (integer-from-string line (1+ secondcolon) thirdcolon) (integer-from-string line (1+ thirdcolon) fourthcolon) (subseq line (1+ fifthcolon) sixthcolon)))))))(defun get-user-gids (user-name) (unless (stringp user-name) (setq user-name (string user-name))) (let ((gids (cond (*gids-from-user-map* (il:* il:\; "There's already a nice inverted map, use it.") (let ((entry (yp-match *gids-from-user-map* (if (> (length user-name) 8) (subseq user-name 0 8) user-name)))) (and entry (let ((*read-base* 10)) (read-from-string entry))))) (t (il:* il:|;;| "Ugh, have to invert group.bygid manually.  I.e., enumerate it, and search for user-name in each entry.") (let ((name-length (length user-name))) (read-map "group.bygid" (function (lambda (key line) (il:* il:|;;| "Format of LINE is \"groupname:*:id:members\", where members is list of users separated by commas") (let ((colon (position #\: line))) (and colon (setq colon (position #\: line :start (1+ colon))) (setq colon (position #\: line :start (1+ colon))) (il:* il:\; "Proper format so far, so search for username among members") (let ((start (+ colon 2)) end) (loop (unless (setq start (il:strpos user-name line start)) (il:* il:\; "Gosh, I'd use SEARCH instead, but STRPOS is 10 times faster") (return nil)) (setq end (+ start name-length)) (case (char line (- start 2)) ((#\: #\,) (il:* il:\; "Good, name started on name boundary") (when (or (>= end (length line)) (eql (char line (1- end)) #\,)) (il:* il:\; "Good, name ends on name boundary") (return (integer-from-string key))))) (setq start end))))))))))))) (if (listp gids) gids (format il:promptwindow "~&Couldn't find group IDs for user ~A because ~A" user-name gids))))(defun host-address (hostname) (let ((line (yp-match "hosts.byname" (string-downcase (string hostname))))) (if line (let* ((wspos (il:strposl (quote (#\Space #\Tab #\Linefeed #\Newline)) line)) (address (il:\\ip.read.string.address (il:substring line 1 (and wspos (1- wspos)))))) (cond ((and address (not (eql address 0))) (il:* il:\; "Guard against malformed entries") (record-host-address (il:mkatom (il:u-case hostname)) address) address))))))(defun record-host-address (hostsymbol address) (setf (gethash hostsymbol il:\\ip.hostnames) (il:|create| il:hosts.txt.entry il:hte.addresses il:_ (list address) il:hte.type il:_ (quote il:host) il:hte.names il:_ (list hostsymbol) il:hte.machine.type il:_ (quote il:sun) il:hte.os.type il:_ (quote il:unix))) (pushnew (cons hostsymbol (quote il:unix)) il:networkostypes :key (quote car)) (pushnew (cons address hostsymbol) il:\\ip.hostnumbers :key (quote car)))(defun host-name (address) (let* ((string (yp-match "hosts.byaddr" (etypecase address (integer (il:\\ip.address.to.string address)) (string address) (symbol (string address))))) shortname) (when string (do* ((name) (length most-positive-fixnum) (thisname) (thislength) (lastws nil ws) (ws (il:strposl (quote (#\Space #\Tab #\Newline #\Linefeed)) string) (il:strposl (quote (#\Space #\Tab #\Newline #\Linefeed)) string (1+ ws)))) ((null ws) (setq shortname (if (< (length (setq thisname (il:substring string (1+ lastws)))) length) thisname name))) (when (and lastws (< (setq thislength (length (setq thisname (il:substring string (1+ lastws) (1- ws))))) length)) (setq name thisname length thislength))) (let ((hostsymbol (il:mkatom (string-upcase shortname)))) (pushnew (cons (if (integerp address) address (setq address (il:\\ip.read.string.address address))) hostsymbol) il:\\ip.hostnumbers :key (quote car)) (unless (gethash hostsymbol il:\\ip.hostnames) (record-host-address hostsymbol address)) hostsymbol))))(defun read-map (mapname &optional (predicate (quote list))) (il:* il:|;;| "Collect all the elements of a YP map.  If PREDICATE is supplied, then it is called for each item (args: key line) and the non-NIL values returned from it are collected into a list.  Otherwise, returns a list of ALL items, each in the form (key line). ") (loop (block retry (return-from read-map (let* ((args (list *yp-domain* mapname "")) (proc (quote first-pair)) value) (with-collection (loop (destructuring-bind (status value-data key-data) (yp-call proc args) (case status ((t) (il:* il:\; "Good response") (setf (third args) key-data) (when (setq value (funcall predicate key-data value-data)) (collect value))) (:no-more (il:* il:\; "No more entries, we're done") (return)) ((nil) (il:* il:\; "No response ") (cerror "Retry YP call" "YP server not responding for map ~A" mapname) (il:* il:\; "Continue from error means try over again") (return-from retry)) (otherwise (il:* il:\; "Some sort of error return") (return-from read-map status)))) (setq proc (quote next-pair)))))))))(defun integer-from-string (str &optional start end) (il:* il:|;;| "Like PARSE-INTEGER but returns NIL on failure instead of erroring") (multiple-value-bind (n j) (parse-integer str :junk-allowed t :start (or start 0) :end (or end (setq end (length str)))) (and (eql j end) n)))(eval-when (load)(il:appendtovar il:restartetherfns yp-restart)(il:* il:|;;| "Read the YP.INIT file right now so it's in the world when saved out.  Don't look for servers yet; we wouldn't use them if we did.")(yp-restart))(reinstall-advice (quote il:iphostaddress) :around (quote ((:last (or il:* (host-address il:name))))))(il:readvise il:iphostaddress)(il:putprops il:ypimpl il:copyright ("Xerox Corporation" 1988 1989 1990))(il:declare\: il:dontcopy  (il:filemap (nil)))il:stop