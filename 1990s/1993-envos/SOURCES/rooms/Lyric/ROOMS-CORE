(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "ROOMS")(il:filecreated "12-Mar-88 20:50:59" il:|{POGO:AISNORTH:XEROX}<ROOMS>NEXT>ROOMS-CORE.;46| 23687        il:|changes| il:|to:|  (il:functions rename-room)      il:|previous| il:|date:| "26-Feb-88 15:09:55" il:|{POGO:AISNORTH:XEROX}<ROOMS>NEXT>ROOMS-CORE.;44|); Copyright (c) 1987, 1988 by Xerox Corporation.  All rights reserved.(il:prettycomprint il:rooms-corecoms)(il:rpaqq il:rooms-corecoms ((il:* il:|;;| "core rooms code") (file-environments il:rooms-core) (il:p (export (quote (room make-room *current-room* copy-room rename-room room-prop room-named delete-room placement-prop make-placement copy-placement move-placement *pocket-room-name* *room-entry-functions* *room-exit-functions* go-to-room update-placements find-placement *room-changed-functions* room-changed do-inclusions reset))) (require "ROOMS")) (il:coms (il:* il:|;;| "the room -- a named object") (il:structures room) (il:variables *rooms* *current-room*) (il:functions in-room? make-room copy-room rename-room room-prop do-rooms all-rooms room-sort-function room-named delete-room)) (il:coms (il:* il:|;;| "placements") (il:structures placement) (il:functions placement-prop make-placement copy-placement move-placement add-placement delete-placement)) (il:* il:|;;| "going from one room to another") (il:variables *pocket-room-name* *monitor-lock* *room-entry-functions* *room-exit-functions*) (il:functions go-to-room go-to-room-process go-to-room-internal call-entry-functions call-exit-functions update-placements find-placement find-placement-in-room update-placement place-placements find-placements place-placement) (il:functions update-tty-process place-tty-process) (il:* il:|;;| "other essentials") (il:functions find-rooms-containing) (il:coms (il:variables *room-changed-functions*) (il:functions room-changed)) (il:functions do-inclusions room-includers) (il:* il:|;;| "bootstrapping & resetting") (il:variables *reset-forms*) (il:functions reset) (il:globalvars il:promptwindow) (il:prop il:argnames go-to-room)))(il:* il:|;;| "core rooms code")(define-file-environment il:rooms-core :compiler :compile-file :package "ROOMS" :readtable "XCL")(export (quote (room make-room *current-room* copy-room rename-room room-prop room-named delete-room placement-prop make-placement copy-placement move-placement *pocket-room-name* *room-entry-functions* *room-exit-functions* go-to-room update-placements find-placement *room-changed-functions* room-changed do-inclusions reset)))(require "ROOMS")(il:* il:|;;| "the room -- a named object")(defstruct (room (:constructor make-room-internal) (:copier copy-room-internal) (:print-function (lambda (room stream depth) (format stream "#<Room ~S>" (room-name room))))) (name nil :type string :read-only t) (placements nil :type list) (il:* il:|;;| "list of PLACEMENT objects") (inclusions nil :type list) (il:* il:|;;| "list of names of included rooms") (background nil :type background) (il:* il:|;;| "how to paint the background") (tty-process nil) (il:* il:|;;| "which process has the TTY in this room") (props nil :type list) (il:* il:|;;| "property list"))(defvar *rooms* (make-hash-table :test (quote equal)) "A hash table mapping from room names to rooms.")(defglobalvar *current-room* nil "The room the user is currently in.")(defun in-room? (room) (il:* il:|;;;| "true if ROOM is a sub-room of the current room") (do-inclusions (included-room *current-room*) (when (equal (room-name room) (room-name included-room)) (return-from do-inclusions t))))(defun make-room (name &rest rest-keys &key placements inclusions (background nil background-specified?) tty-process props) (il:* il:|;;| "check whether a room with this already exists") (when (room-named name) (cerror "Delete existing room named ~S (will close windows)" "A room named ~S already exists" name) (delete-room (room-named name))) (il:* il:|;;| "check the types of the placements") (dolist (placement placements) (check-type placement placement)) (il:* il:|;;| "default the background to contain the name of the room") (unless background-specified? (setq background (il:bquote ((:text (il:\\\, name)))))) (let ((room (make-room-internal :name name :placements placements :inclusions inclusions :background (make-background background) :tty-process tty-process :props (let ((props (copy-list rest-keys))) (dolist (keyword (quote (:placements :inclusions :background :tty-process))) (remf props keyword)) props)))) (setf (room-named name) room) (when *current-room* (when (equal name (room-name *current-room*)) (setq *current-room* room)) (room-changed room :created)) room))(defun copy-room (room new-name) (update-placements) (apply (quote make-room) new-name :placements (mapcar (function copy-placement) (room-placements room)) :inclusions (copy-list (room-inclusions room)) :background (let* ((background (copy-tree (background-external-form (room-background room)))) (old-name (room-name room)) (text (find-if (function (lambda (command) (and (eq (first command) :text) (equal (second command) old-name)))) background))) (when text (setf (second text) new-name)) background) (copy-tree (room-props room))))(defun rename-room (room new-name) (let ((old-name (room-name room))) (prog1 (copy-room room new-name) (delete-room room) (let ((suite-name (find-suite-containing old-name))) (il:* il:|;;| "if its in a suite, rename it there too") (when suite-name (setf (suite-rooms suite-name) (substitute new-name old-name (suite-rooms suite-name) :test (quote equal))))) (do-rooms (room) (il:* il:|;;| "rename it in inclusions of other rooms") (when (member old-name (room-inclusions room) :test (quote equal)) (il:* il:|;;| "don't need to call UPDATE-PLACEMENTS as COPY-ROOM has already called it for us. ") (setf (room-inclusions room) (substitute new-name old-name (room-inclusions room) :test (quote equal))) (room-changed room :edited))))))(defmacro room-prop (room prop &optional (new-value nil new-value-supplied)) (if new-value-supplied (il:bquote (setf (getf (room-props (il:\\\, room)) (il:\\\, prop)) (il:\\\, new-value))) (il:bquote (getf (room-props (il:\\\, room)) (il:\\\, prop)))))(defmacro do-rooms ((room-var) &body body) (il:* il:|;;;| "evaluate BODY once for each room with ROOM-VAR bound to the room.") (il:bquote (block do-rooms (maphash (function (lambda ((il:\\\, (gensym)) (il:\\\, room-var)) (il:\\\,@ body))) *rooms*))))(defun all-rooms (&optional sorted?) (il:* il:|;;;| "return a list of all rooms.  if SORTED? is true, sort them alphabetically by name") (let ((all-rooms (with-collection (do-rooms (room) (collect room))))) (if sorted? (sort all-rooms (function room-sort-function)) all-rooms)))(defun room-sort-function (room-1 room-2) (il:* il:|;;;| "used as the predicate for sorting lists of rooms.  we sort alphabetically by the name of the room.") (macrolet ((stringify (name) (il:bquote (if (stringp (il:\\\, name)) (il:\\\, name) (princ-to-string (il:\\\, name)))))) (let ((name-1 (room-name room-1)) (name-2 (room-name room-2))) (string-lessp (stringify name-1) (stringify name-2)))))(defmacro room-named (name) (il:bquote (gethash (il:\\\, name) *rooms*)))(defun delete-room (room) (il:* il:|;;| "first close all the windows which only have placements in this room") (let ((only-this-room (list room))) (dolist (window (all-windows t)) (when (equal (find-rooms-containing window) only-this-room) (un-hide-window window) (close-window (if (shrunken? window) (window-icon window) window))))) (when (do-rooms (rm) (when (eq room rm) (return-from do-rooms t))) (il:* il:|;;| "if it's in the name table, remove it.  this is so deleting an un-named room (like the Overview) doesn't cause a room named \"Overview\" to also disappear.") (remhash (room-name room) *rooms*)) (il:* il:|;;| "tell the world we've deleted it") (room-changed room :deleted))(il:* il:|;;| "placements")(defstruct (placement (:constructor make-placement-internal) (:copier copy-placement-internal)) window region shrunken? icon-position props)(defmacro placement-prop (placement prop &optional (new-value nil new-value-supplied)) (if new-value-supplied (il:bquote (setf (getf (placement-props (il:\\\, placement)) (il:\\\, prop)) (il:\\\, new-value))) (il:bquote (getf (placement-props (il:\\\, placement)) (il:\\\, prop)))))(defun make-placement (window) (let ((placement (make-placement-internal :window window))) (update-placement placement) placement))(defun copy-placement (placement) (il:* il:|;;| "make sure PROPS gets copied.  it is not important that REGION & ICON-POSITION are copied, but seems safer.") (make-placement-internal :window (placement-window placement) :region (copy-region (placement-region placement)) :shrunken? (placement-shrunken? placement) :icon-position (copy-tree (placement-icon-position placement)) :props (copy-tree (placement-props placement))))(defun move-placement (placement from-room to-room &optional copy?) (add-placement (copy-placement placement) to-room) (unless copy? (delete-placement placement from-room) (let* ((window (placement-window placement)) (inherited (find-placement window))) (hide-window window) (when inherited (place-placement inherited)))))(defun add-placement (placement room) (il:* il:|;;;| "add PLACEMENT to ROOM's placements.  does not update screen. ") (il:* il:|;;| "first delete any old placements for same window") (setf (room-placements room) (delete (placement-window placement) (room-placements room) :test (quote eq) :key (function placement-window))) (il:* il:|;;| "add it") (push placement (room-placements room)) (il:* il:|;;| "notify system that ROOM has changed.") (room-changed room :placements))(defun delete-placement (placement room) (il:* il:|;;| "delete PLACEMENT from ROOM.  does not remove placement from screen.") (setf (room-placements room) (delete (placement-window placement) (room-placements room) :test (quote eq) :key (function placement-window))) (il:* il:|;;| "notify system that ROOM has changed.") (room-changed room :placements))(il:* il:|;;| "going from one room to another")(defvar *pocket-room-name* nil "The name of the room to be the pockets or NIL.")(defglobalvar *monitor-lock*)(defvar *room-entry-functions* nil "A list of functions to be called before a room is entered")(defvar *room-exit-functions* nil "A list of functions to be called before a room is left")(defun go-to-room (&rest args) (il:* il:|;;;| "skip to GO-TO-ROOM-INTERNAL for details...") (il:* il:|;;| "can't run under mouse, as mouse switches TTY around.  have to spawn our own process, let the mouse return the TTY, then we'll be run.  ") (check-type (first args) room) (il:resetvar il:\\proc.run.next.flg t (il:* il:|;;| "ensure that we'll be the next process run when the mouse blocks.") (il:add.process (il:bquote (go-to-room-process (quote (il:\\\, args)))) (quote il:name) "Go To Room")))(defun go-to-room-process (args) (let ((old-cursor (il:cursor))) (unwind-protect (if (il:obtain.monitorlock *monitor-lock* t) (progn (il:cursor il:waitingcursor) (il:\\caret.down nil il:max.fixp) (apply (quote go-to-room-internal) args)) (notify-user "Can't!  Rooms is busy.")) (il:release.monitorlock *monitor-lock*) (il:cursor old-cursor) (il:caret t))))(defun go-to-room-internal (room &key no-update baggage) (check-type room room) (il:* il:|;;;| "Leave the current room & enter ROOM.  BAGGAGE is a list of additional placements to be placed in ROOM.") (il:* il:|;;| "call exit hooks on current room") (call-exit-functions *current-room*) (unless no-update (il:* il:|;;| "update the current room per the screen") (update-placements *current-room*)) (il:* il:|;;| "note which process has the keyboard") (update-tty-process *current-room*) (il:* il:|;;| "clear the screen") (hide-all-windows) (unwind-protect (progn (il:* il:|;;| "paint the background") (paint-background room *screen-bitmap*) (il:* il:|;;| "call entry hooks") (call-entry-functions room)) (il:* il:|;;| "set *CURRENT-ROOM*.") (setq *current-room* room)) (il:* il:|;;| "place placements from ROOM -- inherited & direct") (place-placements room baggage) (il:* il:|;;| "place the caret ") (place-tty-process room))(defun call-entry-functions (room) (il:* il:|;;| "first call global entry functions") (dolist (fn *room-entry-functions*) (funcall fn room)) (il:* il:|;;| "then call inherited entry functions") (do-inclusions (sub-room room) (dolist (fn (room-prop sub-room :before-entry-functions)) (funcall fn room))))(defun call-exit-functions (room) (il:* il:|;;| "first call global room exit functions") (dolist (fn *room-exit-functions*) (funcall fn room)) (il:* il:|;;| "then call inherited functions on ROOM") (do-inclusions (sub-room room) (dolist (fn (room-prop sub-room :before-exit-functions)) (funcall fn room))))(defun update-placements (&optional (for-room *current-room*)) (il:* il:|;;;| "called when leaving a room to update it's placements") (il:* il:|;;;| "returns the new list of placements ") (let ((new-placements nil) (changed-rooms nil) (old-placements (room-placements for-room)) (all-windows (all-windows))) (dolist (window all-windows) (multiple-value-bind (placement in-room) (find-placement window for-room) (unless placement (il:* il:|;;| "new  window in this room - make a placement") (setq placement (make-placement window)) (setq in-room for-room) (il:* il:|;;| "note change to this room") (pushnew for-room changed-rooms :test (quote eq))) (il:* il:|;;| "collect placements in this room in top to bottom order.") (when (eq in-room for-room) (push placement new-placements)) (il:* il:|;;| "update the placement") (when (update-placement placement) (il:* il:|;;| "placement has changed - note it") (pushnew in-room changed-rooms :test (quote eq))))) (dolist (placement (find-placements for-room)) (unless (member (placement-window placement) all-windows :test (quote eq)) (il:* il:|;;| "it's a window that's been closed") (do-inclusions (room for-room) (when (member placement (room-placements room) :test (quote eq)) (il:* il:|;;| "delete its placement") (unless (eq room for-room) (il:* il:|;;| "unless we'll delete it below anyway") (delete-placement placement room)) (il:* il:|;;| "note that this room has changed") (pushnew room changed-rooms :test (quote eq)) (return-from do-inclusions))))) (unless (equal new-placements old-placements) (il:* il:|;;| "check if occlusion order of placements has changed") (pushnew for-room changed-rooms :test (quote eq))) (setf (room-placements for-room) new-placements) (dolist (room changed-rooms) (room-changed room :placements)) t))(defun find-placement (window &optional (from-room *current-room*)) (il:* il:|;;;| "returns the placement which caused WINDOW to be in ROOM.") (il:* il:|;;;| "does a breadth-first search through ROOM & its inclusions for a placement containing WINDOW.  second value is room placement was found in. ") (do-inclusions (room from-room) (let ((placement (find-placement-in-room window room))) (when placement (return-from find-placement (values placement room))))))(defmacro find-placement-in-room (window room) (il:bquote (find (il:\\\, window) (room-placements (il:\\\, room)) :test (quote eq) :key (function placement-window))))(defun update-placement (placement) (il:* il:|;;;| "called when leaving a room on each placement in the room.  returns true if placement has changed since the last time it was updated.") (let* ((window (placement-window placement)) (icon-position (icon-position window)) (region (window-region window)) (shrunken? (shrunken? window)) (changed? nil)) (unless (equal icon-position (placement-icon-position placement)) (setf (placement-icon-position placement) (copy-tree icon-position)) (setq changed? t)) (unless (equal region (placement-region placement)) (setf (placement-region placement) (copy-region region)) (setq changed? t)) (unless (eq shrunken? (placement-shrunken? placement)) (setf (placement-shrunken? placement) shrunken?) (setq changed? t)) (il:* il:|;;| "call the user hook") (let ((window-type (window-type window t))) (when window-type (let ((updater (window-type-updater window-type))) (when updater (funcall (window-type-updater window-type) placement))))) changed?))(defun place-placements (room &optional baggage) (dolist (placement (find-placements room)) (place-placement placement)) (dolist (placement baggage) (place-placement placement)))(defun find-placements (room) (il:* il:|;;;| "returns the list of placements to be displayed in room, ordered in bottom first (i.e. the order they should be displayed in)") (let (placements) (do-inclusions (inclusion room) (dolist (placement (room-placements inclusion)) (il:* il:|;;| "save one placement for each window on the way down") (pushnew placement placements :key (function placement-window)))) placements))(defun place-placement (placement) (il:* il:|;;;| "Called on each placement in a room when it's visited to place PLACEMENT's window per the rest of PLACEMENT.") (il:* il:|;;;| "This will probably require a lot of work in a different window system.") (let* ((window (placement-window placement)) (il:* il:|;;| "we copy as window system sometimes seems to smash these") (placement-region (copy-region (placement-region placement))) (placement-icon-position (copy-tree (placement-icon-position placement))) (window-region (window-region window)) (window-icon (window-icon window))) (when (window-hidden? window) (il:* il:|;;| "if it's not hidden, it's been closed & we ignore it") (il:* il:|;;| "move them over to our screen") (un-hide-window window) (cond ((placement-shrunken? placement) (il:* il:|;;| "ensure the expansion is placed correctly") (unless (equal placement-region window-region) (shape-window window placement-region window-region)) (il:* il:|;;| "place the icon") (cond ((shrunken? window) (unless (equal (window-position window-icon) placement-icon-position) (move-window window-icon placement-icon-position) (open-window window-icon))) (t (move-window (shrink-window window placement-icon-position) placement-icon-position)))) (t (when placement-icon-position (il:* il:|;;| "ensure the icon is placed correctly") (unless window-icon (setq window-icon (shrink-window window placement-icon-position))) (move-window window-icon placement-icon-position) (when (and (il:openwp window-icon) (not (shrunken? window))) (il:* il:|;;| "we opened the icon by moving it") (il:\\closew1 window-icon))) (il:* il:|;;| "place the window") (when (shrunken? window) (expand-window window)) (unless (equal placement-region window-region) (shape-window window placement-region window-region)) (open-window window) (unless placement-icon-position (delete-window-icon window)))) (il:* il:|;;| "call the user hook") (let ((window-type (window-type window t))) (when (and window-type (window-type-placer window-type)) (funcall (window-type-placer window-type) placement))))))(defun update-tty-process (room) (il:* il:|;;;| "update ROOM's notion of which process has the keyboard.") (setf (room-tty-process room) (il:tty.process)))(defun place-tty-process (room) (il:* il:|;;;| "place the keyboard per ROOM's TTY-PROCESS field") (let ((process (room-tty-process room))) (il:tty.process (if (il:processp process) process (il:* il:|;;| "if no process specified, or the specified process is dead, then we give the TTY to the MOUSE process ") (il:find.process (quote il:mouse))))))(il:* il:|;;| "other essentials")(defun find-rooms-containing (window) (il:* il:|;;;| "return a list of all rooms which directly contain a placement for WINDOW") (let ((rooms)) (do-rooms (room) (when (find-placement-in-room window room) (push room rooms))) (il:* il:|;;| "we need a general way of handling un-named rooms, but as there is only one now, we can just special case it.") (when (find-placement-in-room window *overview-room*) (push *overview-room* rooms)) rooms))(defglobalvar *room-changed-functions* nil)(defun room-changed (room reason) (il:* il:|;;;| "called when we notice a room has changed to ensure display is up to date.") (ecase reason ((:edited :created :deleted) (when (in-room? room) (il:* il:|;;| "if we're in this room, redisplay whole screen") (il:* il:|;;| "note: we depend upon our caller to update placements") (il:process.result (go-to-room *current-room* :no-update t) t))) (:placements (il:* il:|;;| "we presume our caller & the hooks handle these cases"))) (il:* il:|;;| "call hooks") (dolist (fn *room-changed-functions*) (funcall fn room reason)))(defmacro do-inclusions ((room-var room-form) &body body) (il:* il:|;;;| "descend breadth-first, left to right down the inclusions of a room, performing BODY with ROOM-VAR bound to each room. ") (il:bquote (block do-inclusions (do* ((si::$all-rooms$) (si::$rooms$ (list (il:\\\, room-form)) (mapcan (function (lambda ((il:\\\, room-var)) (il:* il:|;;| "only do each inclusion once, also stop circles") (unless (member (il:\\\, room-var) si::$all-rooms$ :test (quote eq)) (il:\\\,@ body) (push (il:\\\, room-var) si::$all-rooms$) (let ((inclusions (room-inclusions (il:\\\, room-var)))) (if (listp inclusions) (with-collection (dolist (included-room-name inclusions) (let ((included-room (room-named included-room-name))) (when included-room (collect included-room))))) (return-from do-inclusions)))))) si::$rooms$))) ((null si::$rooms$) (il:* il:|;;| "room named \"Pockets\" gets included in every room") (let (((il:\\\, room-var) (and *pocket-room-name* (room-named *pocket-room-name*)))) (when (and (il:\\\, room-var) (not (member (il:\\\, room-var) si::$all-rooms$ :test (quote eq)))) (il:\\\,@ body))))))))(defun room-includers (room &optional sorted?) (il:* il:|;;;| "returns the list of rooms which include ROOM.") (il:* il:|;;;| "note that every room implicitly includes itself.  the motivation for this is that most code which wants to map over includers also wants the root.") (if (equal (room-name room) *pocket-room-name*) (il:* il:|;;| "special case: all rooms include the pocket room") (all-rooms sorted?) (do* ((includers nil) (il:* il:\; "list of included rooms") (queue (list room)) (il:* il:\; "list of rooms to examine ") (includer room (pop queue)) (il:* il:\; "room being examined") (includer-name (room-name includer) (room-name includer))) ((null queue) (if sorted? (sort includers (function room-sort-function)) includers)) (unless (member includer includers :test (quote eq)) (push includer includers) (do-rooms (room) (let ((inclusions (room-inclusions room))) (when (and (listp inclusions) (member includer-name inclusions :test (quote equal))) (pushnew room queue :test (quote eq)))))))))(il:* il:|;;| "bootstrapping & resetting")(defvar *reset-forms* nil "List of forms to be EVALled when Rooms is reset.")(defun reset nil (il:* il:|;;| "add our entries to system menus") (install-menu-items) (il:* il:|;;| "delete all existing rooms") (clrhash *rooms*) (il:* il:|;;| "bootstrap *CURRENT-ROOM*") (setq *current-room* nil) (setq *pocket-room-name* "Pockets") (make-room *pocket-room-name* :placements (il:* il:|;;| "put promptwindow in pockets") (list (make-placement il:promptwindow)) :background (copy-tree (quote ((:whole-screen (:eval il:windowbackgroundshade)))))) (setq *current-room* (make-room "Original")) (setq *monitor-lock* (il:create.monitorlock "Rooms")) (il:process.result (go-to-room *current-room*) t) (dolist (form *reset-forms*) (eval form)) (il:* il:|;;| "may have lost some windows...") (check-lost-windows))(il:declare\: il:doeval@compile il:dontcopy(il:globalvars il:promptwindow))(il:putprops go-to-room il:argnames (room &key no-update baggage))(il:putprops il:rooms-core il:copyright ("Xerox Corporation" 1987 1988))(il:declare\: il:dontcopy  (il:filemap (nil)))il:stop