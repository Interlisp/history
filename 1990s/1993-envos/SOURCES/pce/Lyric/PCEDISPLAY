(DEFINE-FILE-INFO §READTABLE "INTERLISP" §PACKAGE "INTERLISP")(FILECREATED "13-Feb-87 12:48:47" {ERINYES}<SANTOSA>PCE>PCEDISPLAY.;1 146850       changes to%:  (VARS PCEDISPLAYCOMS \PCE.PCToNSCharArray)                    (FNS PCE.GET.WINDOW PCE.INVERT.WINDOW PCE.INVERT.WINDOW.STATE                          PCE.PCTERMINAL.ARRAY PCE.SET.WINDOW \PCE.STUFF.WINDOW                          \PCE.WINDOW.ATTACH.PROCESS \PCE.WINDOW.DETACH.PROCESS \PCE.WINDOW.OPENFN                          \PCE.WINDOW.REPAINTFN \PCE.WINDOW.RESHAPEFN \PCE.WINDOW.SCROLLFN                          \PCE.DISPLAY.Configure \PCE.DISPLAY.Init \PCE.DISPLAY.Notify                          \PCE.DISPLAY.NotifyProcedure \PCE.DISPLAY.Terminate \PCE.ALLOC.BITMAPS                          \PCE.CREATE.BBT \PCE.CREATE.FONT.BM \PCE.CREATE.WIDE.FONT.BM                          \PCE.DECODE.TEXT.ATTRIBUTES \PCE.DISPLAY.ALLOC.SHADES                          \PCE.DISPLAY.INIT.MEMORY \PCE.DISPLAY.REPAINT.GRAPHICS                          \PCE.DISPLAY.REPAINT.TEXT \PCE.DISPLAY.UPDATE \PCE.DISPLAY.UPDATE.GRAPHICS                          \PCE.DISPLAY.UPDATE.TEXT \PCE.BLINK \PCE.BLINK.CARET.SET \PCE.BLINK.CHARS                          \PCE.BLINK.CHARS.SET \PCE.CARET.DRAW \PCE.CARET.INVERT \PCE.CARET.MOVE                          \PCE.CARET.RESHAPE \PCE.CARET.SET.TYPE \PCE.COPY.UNDERLINE.DRAW                          \PCE.DISPLAY.COPY.INIT.VARS \PCE.DISPLAY.COPY.UNDERLINE                          \PCE.PCDISPLAY.TO.NS.STRING \PCE.POS.TO.CHARNUM                          \PCE.WINDOW.COPYBUTTONEVENTFN \PCE.WINDOW.LASTCHAR \PCE.WINDOW.MIDCHAR)      previous date%: "29-Jul-86 15:25:33" {ERIS}<LISPCORE>INTERNAL>LIBRARY>PCEDISPLAY.;1)(* "Copyright (c) 1986, 1987 by Xerox Corporation.  All rights reserved.")(PRETTYCOMPRINT PCEDISPLAYCOMS)(RPAQQ PCEDISPLAYCOMS        ((DECLARE%: FIRST (P (* turn off PCE processes if already loaded and running)                            (NLSETQ (\PCE.TERMINATE))                            (* \PCE.WINDOW and \PCE.DISPLAY.SCRATCH.BM are reset on reloading pkg, so                                that all re-initialization will be done)                            (SETQ \PCE.WINDOW NIL)                            (SETQ \PCE.DISPLAY.SCRATCH.BM NIL)))        [DECLARE%: DONTCOPY (P (LOADFNS NIL 'ADISPLAY NIL '(CARET1]        (COMS (* user fns)              (FNS PCE.GET.WINDOW PCE.INVERT.WINDOW PCE.INVERT.WINDOW.STATE PCE.PCTERMINAL.ARRAY                    PCE.SET.WINDOW)              (INITVARS (PCE.PC.TO.NS.ARRAY))              (GLOBALVARS PCE.PC.TO.NS.ARRAY))        (COMS (* PC window)              (FNS \PCE.STUFF.WINDOW \PCE.WINDOW.ATTACH.PROCESS \PCE.WINDOW.DETACH.PROCESS                    \PCE.WINDOW.OPENFN \PCE.WINDOW.REPAINTFN \PCE.WINDOW.RESHAPEFN                    \PCE.WINDOW.SCROLLFN)              (INITVARS (\PCE.WINDOW)                     (\PCE.WINDOW.LOCK)                     (\PCE.WINDOW.COPY.LOCK))              (GLOBALVARS \PCE.WINDOW \PCE.WINDOW.LOCK \PCE.WINDOW.COPY.LOCK))        (COMS (* PCE Display updating process)              (FNS \PCE.DISPLAY.Configure \PCE.DISPLAY.Init \PCE.DISPLAY.Notify                    \PCE.DISPLAY.NotifyProcedure \PCE.DISPLAY.Terminate)              (INITVARS (\PCE.DISPLAY.Condition)                     (\PCE.DISPLAY.gotUpNotify)                     (\PCE.DISPLAY.Process))              (GLOBALVARS \PCE.DISPLAY.Condition \PCE.DISPLAY.gotUpNotify \PCE.DISPLAY.Process))        (COMS (* updating the PC window from the PC display memory)              (FNS \PCE.ALLOC.BITMAPS \PCE.CREATE.BBT \PCE.CREATE.FONT.BM \PCE.CREATE.WIDE.FONT.BM                    \PCE.DECODE.TEXT.ATTRIBUTES \PCE.DISPLAY.ALLOC.SHADES \PCE.DISPLAY.INIT.MEMORY                    \PCE.DISPLAY.REPAINT.GRAPHICS \PCE.DISPLAY.REPAINT.TEXT \PCE.DISPLAY.UPDATE                    \PCE.DISPLAY.UPDATE.GRAPHICS \PCE.DISPLAY.UPDATE.TEXT)              (INITVARS (\PCE.DISPLAY.MODE)                     (\PCE.DISPLAY.MODE.HAS.TEXT)                     (\PCE.DISPLAY.BASE)                     (\PCE.DISPLAY.MONO.BASE)                     (\PCE.DISPLAY.COLOR.BASE)                     (\PCE.DISPLAY.COLOR.PAGE.OFFSET)                     (\PCE.DISPLAY.INVERTED))              (GLOBALVARS \PCE.DISPLAY.MODE \PCE.DISPLAY.MODE.HAS.TEXT \PCE.DISPLAY.BASE                      \PCE.DISPLAY.MONO.BASE \PCE.DISPLAY.COLOR.BASE \PCE.DISPLAY.COLOR.PAGE.OFFSET                      \PCE.DISPLAY.INVERTED)              (INITVARS (\PCE.DISPLAY.SCRATCH.BM)                     (\PCE.DISPLAY.FONT.BM)                     (\PCE.DISPLAY.FONT.BBT)                     (\PCE.DISPLAY.WIDEFONT.BM)                     (\PCE.DISPLAY.WIDEFONT.BBT)                     (\PCE.DISPLAY.BOLDFONT.BM)                     (\PCE.DISPLAY.BOLDFONT.BBT)                     (\PCE.DISPLAY.UNDERFONT.BM)                     (\PCE.DISPLAY.UNDERFONT.BBT)                     (\PCE.DISPLAY.UNDERBOLDFONT.BM)                     (\PCE.DISPLAY.UNDERBOLDFONT.BBT)                     (\PCE.DISPLAY.OLDCHARS))              (GLOBALVARS \PCE.DISPLAY.SCRATCH.BM \PCE.DISPLAY.FONT.BM \PCE.DISPLAY.FONT.BBT                      \PCE.DISPLAY.WIDEFONT.BM \PCE.DISPLAY.WIDEFONT.BBT \PCE.DISPLAY.BOLDFONT.BM                      \PCE.DISPLAY.BOLDFONT.BBT \PCE.DISPLAY.UNDERFONT.BM \PCE.DISPLAY.UNDERFONT.BBT                      \PCE.DISPLAY.UNDERBOLDFONT.BM \PCE.DISPLAY.UNDERBOLDFONT.BBT                      \PCE.DISPLAY.OLDCHARS)              (* repainting pseudo-color display)              (INITVARS (\PCE.DISPLAY.COLOR.TO.SCRATCH.BBT)                     (\PCE.DISPLAY.COLOR.ODDLINEBLOCK.BASE)                     (\PCE.DISPLAY.COLOR.EVENLINEBLOCK.BASE)                     (\PCE.DISPLAY.COLOR.BRICKS.BM)                     (\PCE.DISPLAY.COLOR.BRICKS.BBT)                     (\PCE.DISPLAY.COLOR.BACK.GRAYBIT)                     (\PCE.DISPLAY.COLOR.FORE.GRAYBIT)                     (\PCE.DISPLAY.MEDRES.GRAY.BM)                     (\PCE.DISPLAY.MEDRES.GRAY.BBT))              (GLOBALVARS \PCE.DISPLAY.COLOR.TO.SCRATCH.BBT \PCE.DISPLAY.COLOR.ODDLINEBLOCK.BASE                      \PCE.DISPLAY.COLOR.EVENLINEBLOCK.BASE \PCE.DISPLAY.COLOR.BRICKS.BM                      \PCE.DISPLAY.COLOR.BRICKS.BBT \PCE.DISPLAY.COLOR.BACK.GRAYBIT                      \PCE.DISPLAY.COLOR.FORE.GRAYBIT \PCE.DISPLAY.MEDRES.GRAY.BM                      \PCE.DISPLAY.MEDRES.GRAY.BBT))        (COMS (* blinking chars and caret)              (FNS \PCE.BLINK \PCE.BLINK.CARET.SET \PCE.BLINK.CHARS \PCE.BLINK.CHARS.SET                    \PCE.CARET.DRAW \PCE.CARET.INVERT \PCE.CARET.MOVE \PCE.CARET.RESHAPE                    \PCE.CARET.SET.TYPE)              (INITVARS (\PCE.BLINK.STATE)                     (\PCE.BLINK.NUMCHARS 0)                     (\PCE.BLINK.CHARS.ENABLED T)                     (\PCE.BLINK.CHARS.STATE T)                     (\PCE.BLINK.CARET.STATE NIL)                     (\PCE.BLINK.BITMAP)                     (\PCE.BLINK.ON.RATE 333)                     (\PCE.BLINK.OFF.RATE 333)                     (\PCE.BLINK.TIMER)                     (\PCE.CARET.BITMAP)                     (\PCE.CARET.CARET1)                     (\PCE.CARET.XPOS)                     (\PCE.CARET.YPOS)                     (\PCE.CARET.TYPE 'MONO))              (GLOBALVARS \PCE.BLINK.NUMCHARS \PCE.BLINK.STATE \PCE.BLINK.CHARS.ENABLED                      \PCE.BLINK.CHARS.STATE \PCE.BLINK.CARET.STATE \PCE.BLINK.BITMAP                      \PCE.BLINK.ON.RATE \PCE.BLINK.OFF.RATE \PCE.BLINK.TIMER \PCE.CARET.BITMAP                      \PCE.CARET.CARET1 \PCE.CARET.XPOS \PCE.CARET.YPOS \PCE.CARET.TYPE))        (COMS (* shift-select from PC window)              (FNS \PCE.COPY.UNDERLINE.DRAW \PCE.DISPLAY.COPY.INIT.VARS \PCE.DISPLAY.COPY.UNDERLINE                    \PCE.PCDISPLAY.TO.NS.STRING \PCE.POS.TO.CHARNUM \PCE.WINDOW.COPYBUTTONEVENTFN                    \PCE.WINDOW.LASTCHAR \PCE.WINDOW.MIDCHAR)              (INITVARS (\PCE.WINDOW.LASTCHAR.ARRAY)                     (\PCE.WINDOW.COPY.STARTCHARNUM)                     (\PCE.WINDOW.COPY.ENDCHARNUM))              (GLOBALVARS \PCE.WINDOW.LASTCHAR.ARRAY \PCE.WINDOW.COPY.STARTCHARNUM                      \PCE.WINDOW.COPY.ENDCHARNUM))        (COMS (* PC fonts)              (INITVARS (\PCE.FONTCHARWIDTH)                     (\PCE.FONTCHARHEIGHT)                     (\PCE.FONTCHARDESCENT))              (VARS \PCE.PCToNSCharArray)              (GLOBALVARS \PCE.FONTCHARWIDTH \PCE.FONTCHARHEIGHT \PCE.FONTCHARDESCENT                      \PCE.PCToNSCharArray))        (COMS (* masks for sensing bits in REQBITS field of display FCB -- each bit specifies a                  different action to be performed)              (CONSTANTS \PCE.DISPLAY.disableVideo \PCE.DISPLAY.dirtyBitsDirty                      \PCE.DISPLAY.modeControlSet \PCE.DISPLAY.pageChange \PCE.DISPLAY.colorChange                      \PCE.DISPLAY.cursorLocationChange \PCE.DISPLAY.cursorShapeChange                      \PCE.DISPLAY.extraWork)              (* special values used to configure PC for mono or color display)              (CONSTANTS \PCE.DISPLAY.pseudo80Or40Sw \PCE.DISPLAY.pseudoMono)              (* special display modes specifying that mono blinking should be enabled or disabled)              (CONSTANTS \PCE.DISPLAY.MonoBlinkEnabled \PCE.DISPLAY.MonoBlinkDisabled)              (* PC memory addresses of the beginning of mono display memory and color display                  memory.)              (CONSTANTS \PCE.DISPLAY.COLOR.ADDR \PCE.DISPLAY.MONO.ADDR)              (* 4-bit numbers corresponding to each "color" that can be specified in the character                  attribute byte, which contains one blinking bit, 3 bits of background color, and                  four bits of fourground color.)              (CONSTANTS \PCE.DISPLAY.COLOR.black \PCE.DISPLAY.COLOR.blue \PCE.DISPLAY.COLOR.green                      \PCE.DISPLAY.COLOR.cyan \PCE.DISPLAY.COLOR.red \PCE.DISPLAY.COLOR.magenta                      \PCE.DISPLAY.COLOR.brown \PCE.DISPLAY.COLOR.white \PCE.DISPLAY.COLOR.gray                      \PCE.DISPLAY.COLOR.lightBlue \PCE.DISPLAY.COLOR.lightGreen                      \PCE.DISPLAY.COLOR.lightCyan \PCE.DISPLAY.COLOR.lightRed                      \PCE.DISPLAY.COLOR.lightMagenta \PCE.DISPLAY.COLOR.yellow                      \PCE.DISPLAY.COLOR.intenseWhite)              (* display mode numbers used to specify different type of color displays)              (CONSTANTS \PCE.DISPLAY.Text40x25BWVal \PCE.DISPLAY.Text40x25BWNoBlinkingVal                      \PCE.DISPLAY.Text40x25ColorVal \PCE.DISPLAY.Text40x25ColorNoBlinkingVal                      \PCE.DISPLAY.Text80x25BWVal \PCE.DISPLAY.Text80x25BWNoBlinkingVal                      \PCE.DISPLAY.Text80x25ColorVal \PCE.DISPLAY.Text80x25ColorNoBlinkingVal                      \PCE.DISPLAY.GraphMedResBWVal \PCE.DISPLAY.GraphMedResBWAltVal                      \PCE.DISPLAY.GraphMedResColorVal \PCE.DISPLAY.GraphMedResColorAltVal                      \PCE.DISPLAY.GraphHiResVal \PCE.DISPLAY.GraphHiResAltVal)              (* for each shade <white-black>, tells which number shade this is <0-16>. This is used                  when setting up \PCE.DISPLAY.COLOR.BACK.GRAYBIT)              (CONSTANTS \PCE.DISPLAY.white \PCE.DISPLAY.g1 \PCE.DISPLAY.g2 \PCE.DISPLAY.g4                      \PCE.DISPLAY.g6 \PCE.DISPLAY.half \PCE.DISPLAY.g10 \PCE.DISPLAY.g12                      \PCE.DISPLAY.g14 \PCE.DISPLAY.g15 \PCE.DISPLAY.black)              (* 16-bit textures used for each shade of gray)              (CONSTANTS \PCE.DISPLAY.BRICK.white \PCE.DISPLAY.BRICK.g1 \PCE.DISPLAY.BRICK.g2                      \PCE.DISPLAY.BRICK.g4 \PCE.DISPLAY.BRICK.g6 \PCE.DISPLAY.BRICK.half                      \PCE.DISPLAY.BRICK.g10 \PCE.DISPLAY.BRICK.g12 \PCE.DISPLAY.BRICK.g14                      \PCE.DISPLAY.BRICK.g15 \PCE.DISPLAY.BRICK.black))))(DECLARE%: FIRST (* turn off PCE processes if already loaded and running)(NLSETQ (\PCE.TERMINATE))(* \PCE.WINDOW and \PCE.DISPLAY.SCRATCH.BM are reset on reloading pkg, so that all re-initialization    will be done)(SETQ \PCE.WINDOW NIL)(SETQ \PCE.DISPLAY.SCRATCH.BM NIL))(DECLARE%: DONTCOPY (LOADFNS NIL 'ADISPLAY NIL '(CARET1)))(* user fns)(DEFINEQ(PCE.GET.WINDOW  [LAMBDA NIL                                                (* mjs "25-Apr-86 15:41")                    (* * Returns the current PCE window, if there is one, else NIL)    (WINDOWP \PCE.WINDOW])(PCE.INVERT.WINDOW  [LAMBDA NIL                                                (* mjs "15-Jul-86 14:39")                    (* * Inverts PC display window if open, and sets \PCE.DISPLAY.INVERTED so that           redisplay will maintain inversion)    [if (OPENWP \PCE.WINDOW)        then (WITH.MONITOR \PCE.WINDOW.LOCK (BLTSHADE BLACKSHADE \PCE.WINDOW 0 0 MAX.SMALLP                                                    MAX.SMALLP 'INVERT]    (SETQ \PCE.DISPLAY.INVERTED (NOT \PCE.DISPLAY.INVERTED])(PCE.INVERT.WINDOW.STATE  [LAMBDA NIL                                                (* mjs "15-Jul-86 14:40")    (NOT (NULL \PCE.DISPLAY.INVERTED])(PCE.PCTERMINAL.ARRAY  [LAMBDA NIL                                                (* mjs "30-Apr-86 09:14")                    (* * Returns a 256-element array <suitable for being assigned as the value of           PCE.PC.TO.NS.ARRAY > mapping from the PC char codes to NS charcodes in the           PCTERMINAL character set. Returns a new array each time it is called <since we           don't want to allow the user to change \PCE.PCToNSCharArray which we use when           creating the font bitmaps>.)    (COPYARRAY \PCE.PCToNSCharArray])(PCE.SET.WINDOW  [LAMBDA (WIN)                                              (* mjs " 2-Jul-86 13:45")                    (* * PCE.SET.WINDOW initializes the PC window variables, and sets the           appropriate windowprops of the window WIN so that it will redisplay, shape,           open like the PC emulation window. Finally, the global variable \PCE.WINDOW is           set to this new window, so that all of the PC functions will reference it)                    (* * If WIN is not a window, initialization is done, but no new window is set           up. This provides a way of doing the slow one-time initialization <such as           reading the PC fonts> without opening the PC window)                    (* * Note%: this fn does not do anything to close the old PC window, or clear           its window properties. However, the PCE windowprop functions are noops if not           attached to the PC window.)    (PROG NIL          (\PCE.CHECK.INITIALIZED)                    (* * disable current PC emulation window)          (SETQ \PCE.WINDOW NIL)                    (* * Allocate data structures <including font bitmaps> if they haven't been           allocated yet)          (\PCE.ALLOC.BITMAPS)                    (* * Initialize copy-select variables)          (\PCE.DISPLAY.COPY.INIT.VARS)                    (* * reset monitor locks used to control access to the PCE window)          (SETQ \PCE.WINDOW.LOCK (CREATE.MONITORLOCK '\PCE.WINDOW.LOCK))          (SETQ \PCE.WINDOW.COPY.LOCK (CREATE.MONITORLOCK '\PCE.WINDOW.COPY.LOCK))                    (* * initialize blinking chars and caret vars)          (SETQ \PCE.BLINK.NUMCHARS 0)          (SETQ \PCE.BLINK.CARET.STATE NIL)          (SETQ \PCE.BLINK.CHARS.STATE T)          (SETQ \PCE.BLINK.CHARS.ENABLED T)          (SETQ \PCE.BLINK.TIMER (SETUPTIMER \PCE.BLINK.OFF.RATE))          (SETQ \PCE.CARET.XPOS 0)          (SETQ \PCE.CARET.YPOS 0)                    (* * If WIN is not a window, the initialization is done, but no window is set           up)          (if (NOT (WINDOWP WIN))              then (RETURN))                    (* * set up windowprops on WIN)          [WINDOWPROP WIN 'MAXSIZE (CONS (WIDTHIFWINDOW (ITIMES \PCE.FONTCHARWIDTH 80))                                         (HEIGHTIFWINDOW (ITIMES \PCE.FONTCHARHEIGHT 25)                                                (WINDOWPROP WIN 'TITLE]          (WINDOWPROP WIN 'REPAINTFN (FUNCTION \PCE.WINDOW.REPAINTFN))          (WINDOWPROP WIN 'RESHAPEFN (FUNCTION \PCE.WINDOW.RESHAPEFN))          (WINDOWADDPROP WIN 'EXPANDFN (FUNCTION \PCE.WINDOW.OPENFN))          (WINDOWADDPROP WIN 'OPENFN (FUNCTION \PCE.WINDOW.OPENFN))          (WINDOWPROP WIN 'SCROLLFN (FUNCTION \PCE.WINDOW.SCROLLFN))                    (* * note%: must set SCROLLEXTENTUSE, even though \PCE.WINDOW.SCROLLFN doesn't           use it, because SCROLL.HANDLER uses it when determining whether to bring the           scroll bars up)          (WINDOWPROP WIN 'SCROLLEXTENTUSE 'LIMIT)          (WINDOWPROP WIN 'EXTENT (CREATEREGION 0 0 (ITIMES \PCE.FONTCHARWIDTH 80)                                         (ITIMES \PCE.FONTCHARHEIGHT 25)))          (WINDOWPROP WIN 'COPYBUTTONEVENTFN (FUNCTION \PCE.WINDOW.COPYBUTTONEVENTFN))                    (* * Set this as the new PC window)          (SETQ \PCE.WINDOW WIN)                    (* * Attach kbd process to this window. note that \PCE.WINDOW.ATTACH.PROCESS           uses \PCE.WINDOW, so it has to be set first)          (\PCE.WINDOW.ATTACH.PROCESS)          (if (OPENWP WIN)              then (REDISPLAYW WIN))          (RETURN WIN]))(RPAQ? PCE.PC.TO.NS.ARRAY )(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS PCE.PC.TO.NS.ARRAY))(* PC window)(DEFINEQ(\PCE.STUFF.WINDOW  [LAMBDA (CHARS ATTRIB FROMCHAR TOCHAR)                     (* mjs " 2-Jul-86 15:31")                    (* * This is a useful utility function that stuffs characters into the PC           monodisplay memory. CHARS is a string or a list of PC charcodes or NIL           <defaults to "ABCDEFGabcdefg" > or T <defaults to a string of all the PC           charcodes>. ATTRIB is the attrib number or a list of attrib numbers or NIL           <defaults to 2, the regular attrib> or T <defaults to a list of all of the           attribs>. FROMCHAR <default 0> and TOCHAR <default 1999> specify which chars           should be written. If the range is larger than the number of chars or attribs           specified, they repeat.)                    (* * Note that this does NOT redisplay the PC window)    (\PCE.CHECK.INITIALIZED)    (PROG NIL          (SETQ CHARS (if (NULL CHARS)                          then (CHCON "ABCDEFGabcdefg")                        elseif (LISTP CHARS)                          then CHARS                        elseif (EQ CHARS T)                          then (for X from 0 to 255 collect X)                        else (CHCON CHARS)))          (SETQ ATTRIB           (if (NULL ATTRIB)               then 2             elseif (EQ ATTRIB T)               then '(0 1 2 9 10 112 128 129 130 137 138 240)             else ATTRIB))          (SETQ FROMCHAR (if (AND (NUMBERP FROMCHAR)                                  (IGEQ FROMCHAR 0))                             then FROMCHAR                           else 0))          (SETQ TOCHAR (if (AND (NUMBERP TOCHAR)                                (ILEQ TOCHAR 1999))                           then TOCHAR                         else 1999))          (for CHARNUM from FROMCHAR to TOCHAR             bind (ATTRIBLIST _ (SETQ ATTRIB (MKLIST ATTRIB)))                  (CHARLIST _ CHARS)                  (BASE _ (if (MEMB \PCE.DISPLAY.MODE '(MONO NIL))                              then \PCE.DISPLAY.MONO.BASE                            else \PCE.DISPLAY.COLOR.BASE))             do [\PUTBASE BASE CHARNUM (IPLUS (CAR ATTRIBLIST)                                              (ITIMES 256 (CAR CHARLIST]                (SETQ ATTRIBLIST (if (CDR ATTRIBLIST)                                   else ATTRIB))                (SETQ CHARLIST (if (CDR CHARLIST)                                 else CHARS])(\PCE.WINDOW.ATTACH.PROCESS  [LAMBDA NIL                                                (* mjs "30-Apr-86 15:05")                    (* * If the PC window is set, and the PC keyboard process is active, make them           point at each other, so that clicking in the PC window will switch the tty to           the pc kbd process.)    (if (AND (PCE.GET.WINDOW)             (PCE.KBD.PROC))        then (PROCESSPROP (PCE.KBD.PROC)                    'WINDOW                    (PCE.GET.WINDOW))             (WINDOWPROP (PCE.GET.WINDOW)                    'PROCESS                    (PCE.KBD.PROC])(\PCE.WINDOW.DETACH.PROCESS  [LAMBDA NIL                                                (* mjs "28-Jul-86 12:32")                    (* * Break links between the PC window and the PC kbd process, if there are           any. This should be done before resetting the kbd process, because when this           process is deleted, the process system will try to break these links.)                    (* * This problem was discovered while implementing HARDRESET re-starting,           because the old kbd proc still had a handle to the PC window, and consequently           smashed the PROCESS prop of the PC window when it was deleted.)    (if (PCE.GET.WINDOW)        then (WINDOWPROP (PCE.GET.WINDOW)                    'PROCESS NIL))    (if (PCE.KBD.PROC)        then                     (* must use explicit processes record reference here instead of PROCESSPROP,           because of "AR 6236: (PROCESSPROP <proc> 'WINDOW NIL) is a noop" %.)             (replace (PROCESS PROCWINDOW) of (PCE.KBD.PROC) with NIL])(\PCE.WINDOW.OPENFN  [LAMBDA (WINDOW)                                           (* mjs "30-Apr-86 16:02")                    (* * If WINDOW is the PC window, it is redisplayed, to show any changes that           the PC may have made while the window was closed.          If WINDOW is not the PC window, this is a noop.)    (if (EQ WINDOW (PCE.GET.WINDOW))        then (REDISPLAYW WINDOW])(\PCE.WINDOW.REPAINTFN  [LAMBDA (WINDOW REG)                                       (* mjs " 2-Jul-86 12:05")                    (* * If WINDOW is the PC window, redisplay it.          If WINDOW is not the PC window, this is a noop.)    (if (EQ WINDOW (PCE.GET.WINDOW))        then (\PCE.CHECK.INITIALIZED)                     (* * Redisplay current state of lock keys.)             (\PCE.SHOW.LOCKS)             (WITH.MONITOR \PCE.WINDOW.LOCK                     (* * redisplay all lines, and reset caret shape and position)                    (\PCE.DISPLAY.UPDATE T)                    (* * redraw copy-select underline, if any.          This allows you to scroll the PC window while copy-selecting chars out of it.)                    (\PCE.COPY.UNDERLINE.DRAW \PCE.WINDOW.COPY.STARTCHARNUM                            \PCE.WINDOW.COPY.ENDCHARNUM])(\PCE.WINDOW.RESHAPEFN  [LAMBDA (WINDOW)                                           (* mjs "30-Apr-86 16:16")                    (* * When reshaping, we want to make sure that no area outside the extent is           visible, so we call \PCE.WINDOW.SCROLLFN which also does a redisplay on the           whole visable window. If WINDOW is not the PC window, this is a noop.)    (if (EQ WINDOW (PCE.GET.WINDOW))        then (\PCE.WINDOW.SCROLLFN WINDOW 0 0])(\PCE.WINDOW.SCROLLFN  [LAMBDA (WINDOW XDELTA YDELTA CONTINUOUSFLG)               (* mjs "30-Apr-86 16:24")                    (* * This is just a simplified copy of SCROLLBYREPAINTFN, except that 1%: this           always redisplays ALL of the window that is visible <necessary to allow           scrolling text containing blinking chars without losing track of which chars           are blinking>, and 2%: this assumes that EXTENTUSE=LIMIT.)    (if (EQ WINDOW (PCE.GET.WINDOW))        then (\PCE.CHECK.INITIALIZED)             (PROG ((DSP (WINDOWPROP WINDOW 'DSP))                    (EXTENT (WINDOWPROP WINDOW 'EXTENT))                    CR CRHEIGHT CRWIDTH CRLEFT CRBOTTOM)                   (SETQ CR (DSPCLIPPINGREGION NIL DSP))                   (SETQ CRLEFT (fetch (REGION LEFT) of CR))                   (SETQ CRBOTTOM (fetch (REGION BOTTOM) of CR))                   (SETQ CRWIDTH (fetch (REGION WIDTH) of CR))                   (SETQ CRHEIGHT (fetch (REGION HEIGHT) of CR))                    (* * calculate the amount to be moved in X)                   [if (FLOATP XDELTA)                       then                     (* thumb scroll, XDELTA gives the fraction of the way from the left margin the           cursor was.)                            (PROG (OLDX NEWX)                                  [SETQ NEWX (IPLUS (fetch (REGION LEFT) of EXTENT)                                                    (FIXR (FTIMES XDELTA (IDIFFERENCE                                                                          (fetch (REGION WIDTH)                                                                             of EXTENT)                                                                          CRWIDTH]                                  (SETQ OLDX (WXOFFSET NIL DSP))                                  (SETQ XDELTA (IDIFFERENCE OLDX NEWX]                   [if CONTINUOUSFLG                       then                                  (* if continuous set it scroll by the                                                              linefeed height)                            (if (EQ XDELTA 0)                              elseif (IGREATERP XDELTA 0)                                then                         (* linefeed height is normally                                                              negative.)                                     (SETQ XDELTA (IMINUS (DSPLINEFEED NIL DSP)))                              else (SETQ XDELTA (DSPLINEFEED NIL DSP]                    (* * calculate the amount to be moved in Y)                   [if (FLOATP YDELTA)                       then                     (* thumb scroll, YDELTA gives the fraction of the way from the top margin the           cursor was.)                            (PROG (OLDY NEWY)                                  (SETQ NEWY (IPLUS (FIXR (FTIMES (FDIFFERENCE 1.0 YDELTA)                                                                 (IDIFFERENCE (fetch (REGION HEIGHT)                                                                                 of EXTENT)                                                                        CRHEIGHT)))                                                    (fetch (REGION BOTTOM) of EXTENT)))                                  (SETQ OLDY (WYOFFSET NIL DSP))                                  (SETQ YDELTA (IDIFFERENCE OLDY NEWY]                   [if CONTINUOUSFLG                       then                                  (* if continuous set it scroll by the                                                              linefeed height)                            (if (EQ YDELTA 0)                              elseif (IGREATERP YDELTA 0)                                then                         (* linefeed height is normally                                                              negative.)                                     (SETQ YDELTA (IMINUS (DSPLINEFEED NIL DSP)))                              else (SETQ YDELTA (DSPLINEFEED NIL DSP]                    (* always adjust X and Y clipping region, even if XDELTA or YDELTA is 0, just           to insure that we don't display outside the extent --          (\PCE.WINDOW.SCROLLFN 0 0) is called by \PCE.RESHAPEFN to readjust clipping           region)                   (SETQ XDELTA (IMIN (IDIFFERENCE CRLEFT (fetch (REGION LEFT) of EXTENT))                                      (IMAX (IDIFFERENCE (IPLUS CRLEFT CRWIDTH)                                                   (fetch (REGION PRIGHT) of EXTENT))                                            XDELTA)))                   (WXOFFSET XDELTA DSP)                   (SETQ YDELTA (IMIN (IDIFFERENCE CRBOTTOM (fetch (REGION BOTTOM) of EXTENT))                                      (IMAX (IDIFFERENCE (IPLUS CRBOTTOM CRHEIGHT)                                                   (fetch (REGION PTOP) of EXTENT))                                            YDELTA)))                   (WYOFFSET YDELTA DSP)                   (REDISPLAYW WINDOW]))(RPAQ? \PCE.WINDOW )(RPAQ? \PCE.WINDOW.LOCK )(RPAQ? \PCE.WINDOW.COPY.LOCK )(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.WINDOW \PCE.WINDOW.LOCK \PCE.WINDOW.COPY.LOCK))(* PCE Display updating process)(DEFINEQ(\PCE.DISPLAY.Configure  [LAMBDA (CONFIG)                                           (* mjs " 2-Jul-86 14:40")                    (* * Initializes display FCB for the correct type of display.)    (\PCE.DISPLAY.Terminate)    (SELECTQ (LISTGET CONFIG 'DISPLAYTYPE)        ((NIL MONOCHROME)                                    (* 80*25 monochrome display)             (replace (\PCE.DISPLAY.FCB display) of \PCE.DISPLAY.FCBPTR with \PCE.DISPLAY.pseudoMono)             (SETQ \PCE.DISPLAY.MODE 'MONO))        (PROGN                                               (* pseudo-color graphics display)               (replace (\PCE.DISPLAY.FCB display) of \PCE.DISPLAY.FCBPTR with                                                                           \PCE.DISPLAY.pseudo80Or40Sw                      )               (SETQ \PCE.DISPLAY.MODE (SELECTQ (LISTGET CONFIG 'DISPLAYTYPE)                                           (COLOR40 'COLOR40)                                           (COLOR80 'COLOR80)                                           NIL])(\PCE.DISPLAY.Init  [LAMBDA NIL                                                (* mjs "28-Jul-86 14:26")                    (* * Create display agent process, \PCE.DISPLAY.Condition and           \PCE.DISPLAY.gotUpNotify are used to signal the display agent process that an           up notify has been received)    (SETQ \PCE.DISPLAY.Condition (CREATE.EVENT 'DISPLAY.Condition))    (SETQ \PCE.DISPLAY.gotUpNotify NIL)    (SETQ \PCE.DISPLAY.Process (ADD.PROCESS (LIST (FUNCTION \PCE.DISPLAY.NotifyProcedure))                                      'NAME                                      'PCE-DISPLAY                                      'AFTEREXIT                                      'DELETE                                      'RESTARTABLE                                      'HARDRESET                                      'RESTARTFORM                                      (LIST (FUNCTION \PCE.DISPLAY.Init])(\PCE.DISPLAY.Notify  [LAMBDA NIL                                                (* mjs " 1-May-86 12:41")                    (* * Notifies the display agent that an up notify for the display has been           received <except if the PC window is not open>.)    (if (OPENWP \PCE.WINDOW)        then (SETQ \PCE.DISPLAY.gotUpNotify T)             (if (TYPENAMEP \PCE.DISPLAY.Condition 'EVENT)                 then (NOTIFY.EVENT \PCE.DISPLAY.Condition)               elseif \PCE.DEBUG.FLG                 then (\PCE.SYSTEM.ERROR "\PCE.DISPLAY.Condition not an event" \PCE.DISPLAY.Condition                             ])(\PCE.DISPLAY.NotifyProcedure  [LAMBDA NIL                                                (* mjs "28-Jul-86 14:26")                    (* * This is the display agent procedure, that is spawned as a process.          It loops forever, waiting for an up notify, and handling the request)    (PROG NIL                    (* * Redisplay window, to clear dirtBitsState in case a hard reset occured           while there was a redisplay in progress)          (if (OPENWP (PCE.GET.WINDOW))              then (REDISPLAYW (PCE.GET.WINDOW)))                    (* * loop forever, hanlding display updates)          (while T do                     (* * Wait for an up notify.)                      (until \PCE.DISPLAY.gotUpNotify do (AWAIT.EVENT \PCE.DISPLAY.Condition))                      (SETQ \PCE.DISPLAY.gotUpNotify NIL)                     (* * ignore up notifies if the window is not open.          The window will be redisplayed when it is opened.)                      (if (OPENWP \PCE.WINDOW)                          then                     (* * the \PCE.WINDOW.COPY.LOCK monitor lock is used to make sure that           COPY-selecting is not started until all pending up display notifies have been           handled, and the display accuraterly reflects the state of the PC display mem.          This works because \PCE.WINDOW.COPYBUTTONEVENTFN freezes the PC before grabbing           this monitor lock, and because the only BLOCK not under the monitor lock is the           AWAIT.EVENT in \PCE.DISPLAY.NotifyProcedure.          Therefore, be careful about putting BLOCKs in this proc.)                               (WITH.MONITOR \PCE.WINDOW.COPY.LOCK (\PCE.DISPLAY.UPDATE])(\PCE.DISPLAY.Terminate  [LAMBDA NIL                                                (* mjs "30-Apr-86 11:16")                    (* * flush display agent process, and reset display agent variables)    (if (PROCESSP \PCE.DISPLAY.Process)        then (DEL.PROCESS \PCE.DISPLAY.Process))    (SETQ \PCE.DISPLAY.Condition NIL)    (SETQ \PCE.DISPLAY.gotUpNotify NIL)    (SETQ \PCE.DISPLAY.Process NIL]))(RPAQ? \PCE.DISPLAY.Condition )(RPAQ? \PCE.DISPLAY.gotUpNotify )(RPAQ? \PCE.DISPLAY.Process )(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.DISPLAY.Condition \PCE.DISPLAY.gotUpNotify \PCE.DISPLAY.Process))(* updating the PC window from the PC display memory)(DEFINEQ(\PCE.ALLOC.BITMAPS  [LAMBDA NIL                                                (* mjs "29-Jul-86 15:12")                    (* * Allocates all bitmaps and memory blocks used by the mono display,           including the font bitmaps and the pilotbbt tables from the font bitmaps to the           scratch bitmap.)                    (* * Will not reallocate data structures if it looks like they have already           been allocated. "(AND..." below checks many vars to take care of unlikely cases           where people reload PCE over an old version.)    (if (NOT (AND (BITMAPP \PCE.CARET.BITMAP)                  (BITMAPP \PCE.DISPLAY.SCRATCH.BM)                  (BITMAPP \PCE.BLINK.BITMAP)                  (TYPENAMEP \PCE.DISPLAY.UNDERBOLDFONT.BBT 'PILOTBBT)                  \PCE.DISPLAY.OLDCHARS))        then (PROG (PCFONT PCBOLDFONT)                   (SETQ PCFONT (FONTCREATE 'PCTERMINAL 14 'MRR 0 'DISPLAY))                   (SETQ PCBOLDFONT (FONTCOPY PCFONT 'FACE 'BRR))                    (* * load all fontsets of PC fonts)                   (for FONTSET in '(0 33 34 38 40 238 239 241 253) bind CH                      do (SETQ CH (IPLUS 32 (ITIMES 256 FONTSET)))                         (GETCHARBITMAP CH PCFONT)                         (GETCHARBITMAP CH PCBOLDFONT))                    (* * Set char width and height. Note%: Currently, these MUST be 8 and 16, since           there are parts of the code that do not use these variables.)                   (SETQ \PCE.FONTCHARWIDTH 8)                   (SETQ \PCE.FONTCHARHEIGHT 16)                   (SETQ \PCE.FONTCHARDESCENT 4)                   (if [AND \PCE.DEBUG.FLG (OR (NEQ \PCE.FONTCHARWIDTH (CHARWIDTH (CHARCODE A)                                                                              PCFONT))                                               (NEQ \PCE.FONTCHARHEIGHT (FONTPROP PCFONT 'HEIGHT))                                               (NEQ \PCE.FONTCHARDESCENT (FONTPROP PCFONT                                                                                'DESCENT]                       then (\PCE.SYSTEM.ERROR "PCTERMINAL14 fonts wrong size"))                    (* * \PCE.DISPLAY.SCRATCH.BM is the bitmap that is updated from the PC mono           display memory, and then this bitmap is blt-ed to the pc emulation window)                   (SETQ \PCE.DISPLAY.SCRATCH.BM (BITMAPCREATE (ITIMES 80 \PCE.FONTCHARWIDTH)                                                        (ITIMES 25 \PCE.FONTCHARHEIGHT)))                    (* * Set up bitmaps containing all of the characters in each of the PC fonts in           order of the PC character codes. Then, set up pilot bbt tables going from the           font bitmaps to \PCE.DISPLAY.SCRATCH.BM)                   (SETQ \PCE.DISPLAY.FONT.BM (\PCE.CREATE.FONT.BM PCFONT NIL))                   (SETQ \PCE.DISPLAY.FONT.BBT (\PCE.CREATE.BBT \PCE.DISPLAY.FONT.BM                                                       \PCE.DISPLAY.SCRATCH.BM))                   (SETQ \PCE.DISPLAY.BOLDFONT.BM (\PCE.CREATE.FONT.BM PCBOLDFONT NIL))                   (SETQ \PCE.DISPLAY.BOLDFONT.BBT (\PCE.CREATE.BBT \PCE.DISPLAY.BOLDFONT.BM                                                           \PCE.DISPLAY.SCRATCH.BM))                   (SETQ \PCE.DISPLAY.UNDERFONT.BM (\PCE.CREATE.FONT.BM PCFONT T))                   (SETQ \PCE.DISPLAY.UNDERFONT.BBT (\PCE.CREATE.BBT \PCE.DISPLAY.UNDERFONT.BM                                                            \PCE.DISPLAY.SCRATCH.BM))                   (SETQ \PCE.DISPLAY.UNDERBOLDFONT.BM (\PCE.CREATE.FONT.BM PCBOLDFONT T))                   (SETQ \PCE.DISPLAY.UNDERBOLDFONT.BBT (\PCE.CREATE.BBT                                                                \PCE.DISPLAY.UNDERBOLDFONT.BM                                                                \PCE.DISPLAY.SCRATCH.BM))                    (* * \PCE.DISPLAY.WIDEFONT.BM is a double-wide font, created by doubling each           bit in \PCE.DISPLAY.BOLDFONT.BM)                   (SETQ \PCE.DISPLAY.WIDEFONT.BM (\PCE.CREATE.WIDE.FONT.BM \PCE.DISPLAY.BOLDFONT.BM)                    )                   (SETQ \PCE.DISPLAY.WIDEFONT.BBT (\PCE.CREATE.BBT \PCE.DISPLAY.WIDEFONT.BM                                                           \PCE.DISPLAY.SCRATCH.BM))                   (replace (PILOTBBT PBTWIDTH) of \PCE.DISPLAY.WIDEFONT.BBT with 16)                    (* * \PCE.DISPLAY.OLDCHARS is a block of memory used to save the old contents           of the mono display memory, so we know which chars have changed and need to be           repainted.)                   (SETQ \PCE.DISPLAY.OLDCHARS (\ALLOCBLOCK (IQUOTIENT (ITIMES 80 25)                                                                   2)                                                      UNBOXEDBLOCK.GCT))                    (* * \PCE.BLINK.BITMAP is a bitmap of the "on" state of all of the blinking           chars. This is bitblt-ed with \PCE.DISPLAY.SCRATCH.BM to invert the chars.)                   (SETQ \PCE.BLINK.BITMAP (BITMAPCREATE (ITIMES \PCE.FONTCHARWIDTH 80)                                                  (ITIMES \PCE.FONTCHARHEIGHT 25)))                    (* * create shade bitmaps, used to simulate different colors)                   (\PCE.DISPLAY.ALLOC.SHADES)                    (* * \PCE.CARET.BITMAP contains the bitmap of the PC caret.          \PCE.CARET.CARET1 is a lisp CARET1 record pointing at the PC caret bitmap,           passed to lisp caret-blinking fns.)                   (SETQ \PCE.CARET.BITMAP (BITMAPCREATE 8 16))                   (SETQ \PCE.CARET.CARET1 (create CARET1                                                  CURSOR _ (CURSORCREATE \PCE.CARET.BITMAP)                                                  RATE _ 0                                                  STREAMX _ 0                                                  STREAMY _ 0])(\PCE.CREATE.BBT  [LAMBDA (SOURCEBM DESTBM)                                  (* mjs "30-Apr-86 11:54")                    (* * Creates and returns a pilot bitblt table going from SOURCEBM to DESTBM.          PBTWIDTH and PBTHEIGHT are initialized assuming that this bbt will be used to           paint fixed-size pc chars from the font bitmap to the scratch bitmap.)    (create PILOTBBT           PBTSOURCEBPL _ (UNFOLD (ffetch (BITMAP BITMAPRASTERWIDTH) of SOURCEBM)                                 BITSPERWORD)           PBTSOURCE _ (ffetch (BITMAP BITMAPBASE) of SOURCEBM)           PBTDESTBPL _ (UNFOLD (ffetch (BITMAP BITMAPRASTERWIDTH) of DESTBM)                               BITSPERWORD)           PBTDEST _ (ffetch (BITMAP BITMAPBASE) of DESTBM)           PBTWIDTH _ \PCE.FONTCHARWIDTH           PBTHEIGHT _ \PCE.FONTCHARHEIGHT])(\PCE.CREATE.FONT.BM  [LAMBDA (FONT UNDERLINEFLG)                                (* mjs "30-Apr-86 11:56")                    (* * For the given pc font, creates and returns a bitmap containing all of the           PC characters from 0 to 255)                    (* * if UNDERLINEFLG is non-NIL, all of the characters are underlined)    (PROG (BM DSP BBT)          (SETQ BM (BITMAPCREATE (ITIMES \PCE.FONTCHARWIDTH 256)                          \PCE.FONTCHARHEIGHT))          (SETQ DSP (DSPCREATE BM))          (DSPFONT FONT DSP)          (DSPRIGHTMARGIN MAX.SMALLP DSP)          (for X from 0 to 255 do                            (* reposition before each character,                                                              just in case)                                  (MOVETO (ITIMES X \PCE.FONTCHARWIDTH)                                         \PCE.FONTCHARDESCENT DSP)                     (* \PCE.PCToNSCharArray maps from PC charcodes to NS charcodes in the           PCTERMINAL14 font.)                                  (PRIN1 (CHARACTER (ELT \PCE.PCToNSCharArray X))                                         DSP))          (if UNDERLINEFLG              then (BLTSHADE BLACKSHADE BM 0 1 MAX.SMALLP 1 'INVERT))          (RETURN BM])(\PCE.CREATE.WIDE.FONT.BM  [LAMBDA (THINFONTBM)                                       (* mjs " 2-Jul-86 13:45")    (PROG ((THIN.WIDTH (BITMAPWIDTH THINFONTBM))           (THIN.HEIGHT (BITMAPHEIGHT \PCE.DISPLAY.BOLDFONT.BM))           BM BBT)          (SETQ BM (BITMAPCREATE (ITIMES THIN.WIDTH 2)                          THIN.HEIGHT))          (SETQ BBT           (create PILOTBBT              using (\PCE.CREATE.BBT THINFONTBM BM)                    PBTSOURCEBPL _ 1 PBTDESTBPL _ 2 PBTSOURCEBIT _ 0 PBTDESTBIT _ 0 PBTWIDTH _ 1                     PBTHEIGHT _ (ITIMES THIN.WIDTH THIN.HEIGHT)))          (\SETPBTFUNCTION BBT 'INPUT 'REPLACE)          (\PILOTBITBLT BBT 0)          (replace (PILOTBBT PBTDESTBIT) of BBT with 1)          (\PILOTBITBLT BBT 0)          (RETURN BM])(\PCE.DECODE.TEXT.ATTRIBUTES  [LAMBDA (ATTRIBUTE)                                        (* mjs " 3-Jun-86 13:57")                    (* * Takes ATTRIBUTE the attribute byte of a character, and returns an atom           describing the type of mono type attribute it is.          Currently, ignores blinking attribute.)    (PROG ((BACKCOLOR (LRSH (LOGAND 112 ATTRIBUTE)                            4))           (FORECOLOR (LOGAND 15 ATTRIBUTE)))          (RETURN (if (AND (EQ BACKCOLOR \PCE.DISPLAY.COLOR.black)                           (OR (EQ FORECOLOR \PCE.DISPLAY.COLOR.black)                               (EQ FORECOLOR \PCE.DISPLAY.COLOR.gray)))                      then                                   (* invisible)                           'INVISIBLE                    elseif (AND (EQ BACKCOLOR \PCE.DISPLAY.COLOR.white)                                (OR (EQ FORECOLOR \PCE.DISPLAY.COLOR.black)                                    (EQ FORECOLOR \PCE.DISPLAY.COLOR.gray)))                      then 'REVERSE                    elseif (IGREATERP FORECOLOR \PCE.DISPLAY.COLOR.white)                      then                                   (* bright chars)                           (if (OR (EQ FORECOLOR \PCE.DISPLAY.COLOR.blue)                                   (EQ FORECOLOR \PCE.DISPLAY.COLOR.lightBlue))                               then 'BRIGHT.UNDERLINE                             else 'BRIGHT)                    else                                     (* normal intensity characters)                         (if (OR (EQ FORECOLOR \PCE.DISPLAY.COLOR.blue)                                 (EQ FORECOLOR \PCE.DISPLAY.COLOR.lightBlue))                             then 'UNDERLINE                           else 'NORMAL])(\PCE.DISPLAY.ALLOC.SHADES  [LAMBDA NIL                                                (* mjs " 7-Jul-86 14:25")                    (* * Initializes texture bitmaps used in color display modes to simulate           different colors.)                    (* * Loosely derived from InitPatterns in PCDisplayDataImpl.mesa)    (PROG ((BACKNUM.TO.GRAYNUM (ARRAY 16 'SMALLP 0 0)))                    (* * \PCE.DISPLAY.BRICK.white through \PCE.DISPLAY.BRICK.black are constants           that contain the integer textures used to simulate colors in the color display           modes. These textures are painted into the bitmap \PCE.DISPLAY.COLOR.BRICKS.BM,           which is 16 bits wide so it can be used as a texture bitmap.          The constants \PCE.DISPLAY.white through \PCE.DISPLAY.black contain the           integers |0-10| used to index these shades in the bitmap.)          (SETQ \PCE.DISPLAY.COLOR.BRICKS.BM (BITMAPCREATE 16 (ITIMES 4 11)))          (for Y from 40 to 0 by -4 as TEXTURE             in (CONSTANT (LIST \PCE.DISPLAY.BRICK.white \PCE.DISPLAY.BRICK.g1 \PCE.DISPLAY.BRICK.g2                                 \PCE.DISPLAY.BRICK.g4 \PCE.DISPLAY.BRICK.g6 \PCE.DISPLAY.BRICK.half                                 \PCE.DISPLAY.BRICK.g10 \PCE.DISPLAY.BRICK.g12 \PCE.DISPLAY.BRICK.g14                                 \PCE.DISPLAY.BRICK.g15 \PCE.DISPLAY.BRICK.black))             do (BLTSHADE TEXTURE \PCE.DISPLAY.COLOR.BRICKS.BM 0 Y 16 4))                    (* * \PCE.DISPLAY.COLOR.BACK.GRAYBIT is an integer array mapping from the           background color |0-16| to the bit offset in \PCE.DISPLAY.COLOR.BRICKS.BM Note           that these are not all distinct grays. The grays used were based on the           intensity of the different bit patterns.)          (SETQ \PCE.DISPLAY.COLOR.BACK.GRAYBIT (ARRAY 16 'SMALLP 0 0))          (for BACKNUM from 0 to 15 as BACK.GRAYNUM             in (CONSTANT (LIST \PCE.DISPLAY.black \PCE.DISPLAY.g14 \PCE.DISPLAY.g6 \PCE.DISPLAY.g4                                 \PCE.DISPLAY.g12 \PCE.DISPLAY.g10 \PCE.DISPLAY.half                                 \PCE.DISPLAY.white \PCE.DISPLAY.g15 \PCE.DISPLAY.g10 \PCE.DISPLAY.g4                                 \PCE.DISPLAY.g2 \PCE.DISPLAY.g6 \PCE.DISPLAY.g4 \PCE.DISPLAY.g1                                 \PCE.DISPLAY.white)) do (SETA \PCE.DISPLAY.COLOR.BACK.GRAYBIT BACKNUM                                                              (ITIMES BACK.GRAYNUM 4 16))                     (* temporarily save map of back num to gray num for use in setting up           \PCE.DISPLAY.COLOR.FORE.GRAYBIT)                                                        (SETA BACKNUM.TO.GRAYNUM BACKNUM BACK.GRAYNUM                                                              ))                    (* * \PCE.DISPLAY.COLOR.FORE.GRAYBIT is an array mapping from the foreground           AND background color spec |0-255| to the bit offset in           \PCE.DISPLAY.COLOR.BRICKS.BM for the gray shade of the foreground color.          You need to specify both the fore and background color because the foreground           shade used depends on the background color.          The fore and back color are packed into 8 bits as%: bbbbffff.)          (SETQ \PCE.DISPLAY.COLOR.FORE.GRAYBIT (ARRAY 256 'SMALLP 0 0))          [for BACKNUM from 0 to 15 bind BACK.GRAYNUM             do (SETQ BACK.GRAYNUM (ELT BACKNUM.TO.GRAYNUM BACKNUM))                (for FORENUM from 0 to 15 bind FORE.GRAYNUM TEXTURE                   do (SETQ FORE.GRAYNUM (ELT BACKNUM.TO.GRAYNUM FORENUM))                      (SETQ FORE.GRAYNUM (if (EQP BACKNUM FORENUM)                                             then                     (* if the foreground color is the same as the background, use the background           color -- the character is invisible.)                                                  BACK.GRAYNUM                                           elseif (OR (AND (EQP BACKNUM \PCE.DISPLAY.COLOR.lightRed)                                                           (EQP FORENUM \PCE.DISPLAY.COLOR.green))                                                      (AND (EQP BACKNUM \PCE.DISPLAY.COLOR.magenta)                                                           (EQP FORENUM \PCE.DISPLAY.COLOR.lightBlue)                                                           ))                                             then                     (* These are special case combinations not handled by the other rules.)                                                  \PCE.DISPLAY.white                                           elseif (IGREATERP BACK.GRAYNUM \PCE.DISPLAY.g12)                                             then                     (* background color is dark, so set foreground to gray if it is darker than           gray, otherwise white.)                                                  (if (IGEQ FORE.GRAYNUM \PCE.DISPLAY.half)                                                      then \PCE.DISPLAY.half                                                    else \PCE.DISPLAY.white)                                           elseif (ILESSP BACK.GRAYNUM \PCE.DISPLAY.g6)                                             then                     (* background color is light, so set foreground to gray if it is lighter than           gray, otherwise white.)                                                  (if (ILEQ FORE.GRAYNUM \PCE.DISPLAY.half)                                                      then \PCE.DISPLAY.half                                                    else \PCE.DISPLAY.black)                                           else                     (* background must be gray, so set foreground to black or white, depending on           whether it is darker or lighter than the background.)                                                (if (ILESSP FORE.GRAYNUM BACK.GRAYNUM)                                                    then \PCE.DISPLAY.white                                                  else \PCE.DISPLAY.black)))                      (SETA \PCE.DISPLAY.COLOR.FORE.GRAYBIT (LOGOR (LLSH BACKNUM 4)                                                                   FORENUM)                            (ITIMES FORE.GRAYNUM 4 16]                    (* * Set up the bbt going from \PCE.DISPLAY.COLOR.BRICKS.BM to the scratch           bitmap. Note that this bitmap will always be used as a texture bitmap)          (SETQ \PCE.DISPLAY.COLOR.BRICKS.BBT           (create PILOTBBT using (\PCE.CREATE.BBT \PCE.DISPLAY.COLOR.BRICKS.BM                                          \PCE.DISPLAY.SCRATCH.BM)                                  PBTUSEGRAY _ T PBTGRAYOFFSET _ 0 PBTGRAYWIDTHLESSONE _ 0                                   PBTGRAYHEIGHTLESSONE _ 3))                    (* * \PCE.DISPLAY.MEDRES.GRAY.BM is the texture bitmap containing the "|b1010101010101010"           texture used for masking out every second bit on the second line of med-res           graphics display, in order to display four distinct shades.)          (SETQ \PCE.DISPLAY.MEDRES.GRAY.BM (BITMAPCREATE 32 2))          (BLTSHADE 43690 \PCE.DISPLAY.MEDRES.GRAY.BM 0 0 MAX.SMALLP MAX.SMALLP)          (SETQ \PCE.DISPLAY.MEDRES.GRAY.BBT           (create PILOTBBT              using (\PCE.CREATE.BBT \PCE.DISPLAY.MEDRES.GRAY.BM \PCE.DISPLAY.SCRATCH.BM)                    PBTUSEGRAY _ T PBTGRAYOFFSET _ 0 PBTGRAYWIDTHLESSONE _ 0 PBTGRAYHEIGHTLESSONE _ 0                     PBTWIDTH _ 640 PBTHEIGHT _ 1))          (\SETPBTFUNCTION \PCE.DISPLAY.MEDRES.GRAY.BBT 'INVERT 'ERASE])(\PCE.DISPLAY.INIT.MEMORY  [LAMBDA NIL                                                (* mjs "15-Jul-86 13:18")                    (* * Set up pointers into PC memory used by display routines.          This is called from \PCE.INIT.MEMORY so these pointers are re-initialized           whenever the PC memory is. Note that we cannot initialize these in           PCE.SET.WINDOW, because they must be re-initialized over logouts, sysouts, etc.)                    (* * set the pointer to PC loc "|xB0000" used for the |80x25| monochrome           display)    (SETQ \PCE.DISPLAY.MONO.BASE (\PCE.GET.PC.PTR \PCE.DISPLAY.MONO.ADDR))                    (* * Clear the display memory, in case there is garbage there.)    (\CLEARWORDS \PCE.DISPLAY.MONO.BASE 2000)                    (* * set pointer to PC loc "|xB8000" used for color graphics memory)    (SETQ \PCE.DISPLAY.COLOR.BASE (\PCE.GET.PC.PTR \PCE.DISPLAY.COLOR.ADDR))                    (* * two base pointers used when accessing even and odd-line blocks of color           memory)    (SETQ \PCE.DISPLAY.COLOR.EVENLINEBLOCK.BASE \PCE.DISPLAY.COLOR.BASE)    (SETQ \PCE.DISPLAY.COLOR.ODDLINEBLOCK.BASE (\ADDBASE \PCE.DISPLAY.COLOR.EVENLINEBLOCK.BASE 4096))    (SETQ \PCE.DISPLAY.COLOR.TO.SCRATCH.BBT (create PILOTBBT))                    (* * clear |16K| memory block used for color graphics)    (\CLEARWORDS \PCE.DISPLAY.COLOR.BASE 8192)                    (* * Setup display mode variables, in case we try doing mem references to           display memory like copy-selection or \PCE.STUFF.WINDOW before we have ever           redisplayed the window.)    (SETQ \PCE.DISPLAY.MODE 'MONO)    (SETQ \PCE.DISPLAY.MODE.HAS.TEXT T)    (SETQ \PCE.DISPLAY.BASE \PCE.DISPLAY.MONO.BASE)    (SETQ \PCE.DISPLAY.COLOR.PAGE.OFFSET 0])(\PCE.DISPLAY.REPAINT.GRAPHICS  [LAMBDA (REDISPLAYFLG DIRTYBITSLIST)                       (* mjs "15-Jul-86 14:46")                    (* * Repaints medium or high-resolution graphics display.          DIRTYBITSLIST is a list of four 16-bit integers, each bit of which is on if the           corresponding 320-byte section of PC display memory has been changed.          This function scans down all of these bits, updating the PC window if the           display memory has changed. If REDISPLAYFLG is non-NIL, all of the display is           updated.)    (PROG ((HIRESFLG (EQ \PCE.DISPLAY.MODE 'HIRES))           WORDSPERBMLINE BITSPERBMLINE)                    (* * HIRESFLG is non-NIL if the current display mode is hi-resulution graphics,           as compared to medium-resolution graphics.          WORDSPERBMLINE and BITSPERBMLINE are the words and bits per each row in the           scratch bitmap.)          (SETQ WORDSPERBMLINE (ffetch (BITMAP BITMAPRASTERWIDTH) of \PCE.DISPLAY.SCRATCH.BM))          (SETQ BITSPERBMLINE (ITIMES WORDSPERBMLINE BITSPERWORD))                    (* * The following loop scans through the bits in the four dirty bit integers,           updating each display line that is marked dirty.          LASTBITON is used to keep track of the previous bit, because a given display           line may have more than one dirty bit "tracking" it, and we don't want to           redisplay a line twice.)          [for DIRTYBITS in (if REDISPLAYFLG                                then '(65535 65535 65535 65535)                              else DIRTYBITSLIST) as FIRSTBITNUM from 0 by 16             bind (CURRENTBITON _ NIL)                  (LASTBITON _ NIL) when (if (ZEROP DIRTYBITS)                                             then            (* if the dirtybit number is zero,                                                              clear CURRENTBITON flg)                                                  (SETQ CURRENTBITON NIL)                                                  NIL                                           else T)             do (BLOCK)                (for BITNUM from FIRSTBITNUM to 50 as (MASKBIT _ 32768) by (LRSH MASKBIT 1)                   until (ZEROP MASKBIT) bind DISPLAYBASE LOW HIGH                   do (SETQ LASTBITON CURRENTBITON)                      (SETQ CURRENTBITON (BITTEST DIRTYBITS MASKBIT))                      (if CURRENTBITON                          then                     (* * Dirty bits |0-24| correspond to the even lines on the display;          bits |25-50| correspond to the odd lines.          Here's how the dirty bits map to memory.          Note overlap among bits 25..50%: "dirty bit 0 => evenRows[0..3] => scratchBitmap 0,4,8,12;"           "dirty bit 1 => evenRows[4..7] => scratchBitmap 16,20,24,28;"           "dirty bit 2 => evenRows[8..11] => scratchBitmap 32,36,40,44;"           "             . . .               "           "dirty bit 24 => evenRows[96..99] => scratchBitmap 384,388,392,396;"           "dirty bit 25 => oddRows[0..1] => scratchBitmap 2,6;"           "dirty bit 26 => oddRows[1..5] => scratchBitmap 6,10,14,18,22;"           "dirty bit 27 => oddRows[5..9] => scratchBitmap 22,26,30,34,38;"           "             . . .               "           "dirty bit 50 => oddRows[97..99] => scratchBitmap 390,394,398.")                    (* * Set DISPLAYBASE to point to the even or odd line display memory block, and           set LOW and HIGH to the first and last display line to be updated.)                    (* * See HighUpdate in PCDisplayColorImpl.mesa)                               (SETQ DISPLAYBASE \PCE.DISPLAY.COLOR.ODDLINEBLOCK.BASE)                               [if (ILEQ BITNUM 24)                                   then (SETQ LOW (ITIMES BITNUM 16))                                        (SETQ HIGH (IPLUS LOW 12))                                        (SETQ DISPLAYBASE \PCE.DISPLAY.COLOR.EVENLINEBLOCK.BASE)                                 elseif (EQ BITNUM 25)                                   then (SETQ LOW 2)                                        (SETQ HIGH 6)                                 else (SETQ LOW (IPLUS (ITIMES (IDIFFERENCE BITNUM 26)                                                              16)                                                       6))                                      (SETQ HIGH (IPLUS LOW (if (EQ BITNUM 50)                                                                then 8                                                              else 16)))                     (* if previous bit is set, ignore the overlapping row that must have been           repainted already.)                                      (if LASTBITON                                          then (SETQ LOW (IPLUS LOW 4]                               (for LINE from LOW to HIGH by 4                                  do                     (* * copy one line from PC display memory to scratch bitmap)                                     (with PILOTBBT \PCE.DISPLAY.COLOR.TO.SCRATCH.BBT (SETQ                                                                                        PBTSOURCEBPL                                                                                        BITSPERBMLINE)                                           (SETQ PBTDESTBPL BITSPERBMLINE)                                           [SETQ PBTSOURCE (\ADDBASE DISPLAYBASE                                                                  (ITIMES WORDSPERBMLINE                                                                         (LRSH LINE 2]                                           (SETQ PBTSOURCEBIT 0)                                           (SETQ PBTDEST (\ADDBASE (ffetch (BITMAP BITMAPBASE)                                                                      of \PCE.DISPLAY.SCRATCH.BM)                                                                (ITIMES LINE WORDSPERBMLINE)))                                           (SETQ PBTDESTBIT 0)                                           (SETQ PBTWIDTH 640)                                           (SETQ PBTHEIGHT 1))                                     (\SETPBTFUNCTION \PCE.DISPLAY.COLOR.TO.SCRATCH.BBT 'INPUT                                            'REPLACE)                                     (\PILOTBITBLT \PCE.DISPLAY.COLOR.TO.SCRATCH.BBT 0)                     (* * copy from PC display mem to second line)                                     (with PILOTBBT \PCE.DISPLAY.COLOR.TO.SCRATCH.BBT (SETQ                                                                                        PBTDESTBIT                                                                                        BITSPERBMLINE)                                           )                                     (\PILOTBITBLT \PCE.DISPLAY.COLOR.TO.SCRATCH.BBT 0)                     (* * Currently, we are not supporting PC medium-resolution color palettes.          Instead, we just map each of the four 2-bit colors "00, 01, 10, 11" to a           distinct shade. As in hires display mode, we first copy the PC display mem line           to two scratch bitmap lines, giving the shades "00/00, 01/01, 10/10, 11/11."           Unfortunately, the shades "01/01" and "10/10" are not distinct.          Therefore, we clear every second bit on the second line, then OR the line           shifted one bit with itself, constructing the four shades "00/00, 01/00, 10/11, 11/11")                                     (if (NOT HIRESFLG)                                         then                     (* AND gray pattern to second line, erasing every second bit)                                              (replace (PILOTBBT PBTDEST) of                                                                          \PCE.DISPLAY.MEDRES.GRAY.BBT                                                 with (fetch (PILOTBBT PBTDEST) of                                                                     \PCE.DISPLAY.COLOR.TO.SCRATCH.BBT                                                             ))                                              (with PILOTBBT \PCE.DISPLAY.MEDRES.GRAY.BBT (SETQ                                                                                            PBTDESTBIT                                                                                         BITSPERBMLINE                                                                                           ))                                              (\PILOTBITBLT \PCE.DISPLAY.MEDRES.GRAY.BBT 0)                     (* OR seond line with itself shifted one bit to the right)                                              (with PILOTBBT \PCE.DISPLAY.COLOR.TO.SCRATCH.BBT                                                    (SETQ PBTSOURCE PBTDEST)                                                    (SETQ PBTSOURCEBIT BITSPERBMLINE)                                                    (SETQ PBTDESTBIT (ADD1 BITSPERBMLINE))                                                    (SETQ PBTWIDTH 639))                                              (\SETPBTFUNCTION \PCE.DISPLAY.COLOR.TO.SCRATCH.BBT                                                     'INPUT                                                     'PAINT)                                              (\PILOTBITBLT \PCE.DISPLAY.COLOR.TO.SCRATCH.BBT 0]          (if (OPENWP \PCE.WINDOW)              then                     (* bits in PC graphics memory are inverted from the lisp sense.          If \PCE.DISPLAY.INVERTED blt them directly, otherwise invert them.)                   (BITBLT \PCE.DISPLAY.SCRATCH.BM 0 0 \PCE.WINDOW 0 0 MAX.SMALLP MAX.SMALLP                          (if \PCE.DISPLAY.INVERTED                              then 'INPUT                            else 'INVERT)                          'REPLACE])(\PCE.DISPLAY.REPAINT.TEXT  [LAMBDA (REDISPLAYFLG DIRTYBITS)                           (* mjs "15-Jul-86 14:43")                    (* * Repaints \PCE.WINDOW from the PC text display memory, by repainting any           chars in \PCE.DISPLAY.SCRATCH.BM that have changed, and then bitblting that           bitmap into \PCE.WINDOW. This routine handles repainting all three text modes%:           |80x25| mono, |80-25| color, and |40x25| color.          This routine tries not to repaint characters if they have not been changed,           unless REDISPLAYFLG is non-NIL)                    (* * DIRTYBITS is an integer, each bit of which determines whether 320 bytes of           display memory have been changed <two lines in 80-col modes, four lines in           40-col mode>. If REDISPLAYFLG is non-NIL, all chars are repainted.)                    (* * Note%: This fn has been tuned to be as fast as possible.          For example, some loops use repeated addition to generate certain quantities,           rather than doing multiplication within the loop Unfortunately, this means that           this fn is not as easy to understand <or document> as it could be.)    (if REDISPLAYFLG        then                     (* if we want to redisplay all characters, zero out saved info.)             (\ZEROBYTES \PCE.DISPLAY.OLDCHARS 0 3999)             (BLTSHADE WHITESHADE \PCE.DISPLAY.SCRATCH.BM 0 0 MAX.SMALLP MAX.SMALLP)             (BLTSHADE WHITESHADE \PCE.BLINK.BITMAP 0 0 MAX.SMALLP MAX.SMALLP)             (SETQ \PCE.BLINK.NUMCHARS 0)             (SETQ DIRTYBITS 65535))    (PROG ((MINROW MAX.SMALLP)           (MAXROW MIN.SMALLP)           (MINCOL MAX.SMALLP)           (MAXCOL MIN.SMALLP)           (MASKBIT 32768)           (BMWIDTH.TIMES.CHARHEIGHT (ITIMES (ffetch (BITMAP BITMAPRASTERWIDTH) of                                                                               \PCE.DISPLAY.SCRATCH.BM                                                    )                                            \PCE.FONTCHARHEIGHT))           (FONTBM \PCE.DISPLAY.BOLDFONT.BM)           (FONTBBT \PCE.DISPLAY.BOLDFONT.BBT)           (MAXCOLS 80)           (FONTCHARWIDTH \PCE.FONTCHARWIDTH)           (ROWS.PER.DIRTYBIT 2)           (MONOFLG (EQ \PCE.DISPLAY.MODE 'MONO))           BLINK.CHARBM)                    (* * MINROW MAXROW MINCOL MAXCOL are used to keep track of the minumum region           containing chars that have to be repainted, so the final bitblt from           \PCE.DISPLAY.SCRATCH.BM to \PCE.WINDOW can be as small as possible.          MASKBIT is a single bit that is shifted to test each bit in DIRTYBITS.          BMWIDTH.TIMES.CHARHEIGHT is the number of *words* in the scratch bitmap between           the upper-right bit of a row and the upper-right bit of the next row.)                    (* * FONTBM and FONTBBT are the font bitmap and pilotbbt for the current font           bitmap. In mono mode, this can be changed for each character, but only one font           bitmap <for the bold font> is used for the color text modes.          MAXCOLS is the number of columns per line.          FONTCHARWIDTH is the width of a text character.          ROWS.PER.DIRTYBIT is the number of rows corresponding to each bit in DIRTYBITS.)          (if (EQ \PCE.DISPLAY.MODE 'COLOR40)              then (SETQ FONTBM \PCE.DISPLAY.WIDEFONT.BM)                   (SETQ FONTBBT \PCE.DISPLAY.WIDEFONT.BBT)                   (SETQ MAXCOLS 40)                   (SETQ FONTCHARWIDTH (ITIMES \PCE.FONTCHARWIDTH 2))                   (SETQ ROWS.PER.DIRTYBIT 4))                    (* * BLINK.CHARBM is the font bitmap used when painting chars into the blink           bitmap. This is constant for the color text modes, but can change depending on           the char attributes in the mono text mode.)          (SETQ BLINK.CHARBM FONTBM)                    (* * Set the bbt width for the texture bitmap to the charwidth.)          (freplace (PILOTBBT PBTWIDTH) of \PCE.DISPLAY.COLOR.BRICKS.BBT with FONTCHARWIDTH)          [for ROW from 0 to 24 as DIRTYBIT.COUNTDOWN from ROWS.PER.DIRTYBIT by -1 as                                                                                 SCRATCH.BITMAP.OFFSET             from 0 by BMWIDTH.TIMES.CHARHEIGHT as FIRSTCHARNUM from 0 by MAXCOLS as YPOS             from (ITIMES \PCE.FONTCHARHEIGHT 24) by (MINUS \PCE.FONTCHARHEIGHT)             when (PROGN (if (ILEQ DIRTYBIT.COUNTDOWN 0)                             then                     (* every two rows, <four rows if wide chars> shift MASKBIT and block)                                  (SETQ DIRTYBIT.COUNTDOWN ROWS.PER.DIRTYBIT)                                  (SETQ MASKBIT (LRSH MASKBIT 1))                                  (BLOCK))                         (BITTEST MASKBIT DIRTYBITS)) bind LINEBASE OLDLINEBASE DEST             do                     (* * SCRATCH.BITMAP.OFFSET is the number of *words* from the top-left bit of           the scratch bitmap to the top-left bit of the current line.          FIRSTCHARNUM is the charnum <from 0 to 2000> of the first char on the current           line. YPOS is the y-position of the bottom of the characters in the current           row, in the scratch or blink bitmap. DIRTYBIT.COUNTDOWN is used to count how           many rows correspond to each dirty bit ---          we know to shift MASKBIT when this goes to zero.          We put all of these in the FOR statement so we don't have to do multiplications           below)                                                             (* Update MINROW MAXROW)                (SETQ MINROW (IMIN MINROW ROW))                (SETQ MAXROW (IMAX MAXROW ROW))                     (* * LINEBASE points to the begining of the current line in the PC display           memory. OLDLINEBASE points to the begining of the current line in the block           \PCE.DISPLAY.OLDCHARS containing the old state of the display.          DEST points to the upper-left bit of the scratch bitmap.)                (SETQ LINEBASE (\ADDBASE \PCE.DISPLAY.BASE FIRSTCHARNUM))                (SETQ OLDLINEBASE (\ADDBASE \PCE.DISPLAY.OLDCHARS FIRSTCHARNUM))                (SETQ DEST (\ADDBASE (ffetch (BITMAP BITMAPBASE) of \PCE.DISPLAY.SCRATCH.BM)                                  SCRATCH.BITMAP.OFFSET))                     (* * Update all font bbts to point to the correct word of the scratch bitmap)                (if (NOT MONOFLG)                    then (replace (PILOTBBT PBTDEST) of FONTBBT with DEST)                         (replace (PILOTBBT PBTDEST) of \PCE.DISPLAY.COLOR.BRICKS.BBT with DEST)                  else (replace (PILOTBBT PBTDEST) of \PCE.DISPLAY.FONT.BBT with DEST)                       (replace (PILOTBBT PBTDEST) of \PCE.DISPLAY.BOLDFONT.BBT with DEST)                       (replace (PILOTBBT PBTDEST) of \PCE.DISPLAY.UNDERFONT.BBT with DEST)                       (replace (PILOTBBT PBTDEST) of \PCE.DISPLAY.UNDERBOLDFONT.BBT with DEST))                     (* * For each char on the line where the word <char byte and attrib byte> in           the PC display memory is not the same as the saved value in \PCE.MONO.OLDCHARS,           repaint the char.)                (for COL from 0 to (SUB1 MAXCOLS) as XPOS from 0 by FONTCHARWIDTH                   bind (LAST.ATTRIB.BYTE _ NIL)                        (ATTRIB _ NIL)                        (CHAR.IS.BLINKING _ NIL)                        ATTRIB.BYTE FONT.BITMAP.XPOS PCWORD OLDPCWORD                   unless (AND (EQ (SETQ PCWORD (\GETBASE LINEBASE COL))                                   (SETQ OLDPCWORD (\GETBASE OLDLINEBASE COL)))                               (NOT REDISPLAYFLG))                   do                                        (* char attributes are stored in the                                                              low-order byte)                      (SETQ ATTRIB.BYTE (LOGAND 255 PCWORD))                     (* if the top bit is on, the char is blinking)                      (SETQ CHAR.IS.BLINKING (BITTEST ATTRIB.BYTE 128))                                                              (* update \PCE.DISPLAY.OLDCHARS)                      (\PUTBASE OLDLINEBASE COL PCWORD)      (* update MINCOL and MAXCOL)                      (SETQ MINCOL (IMIN MINCOL COL))                      (SETQ MAXCOL (IMAX MAXCOL COL))                     (* For the mono display, it is expensive to decode the attribute byte, switch           the current font bbt, etc., so we only do this if the attrib byte is different           from the last one processed. This is based on the assumption that the attribute           does not change that often between characters.          Note that LAST.ATTRIB.BYTE is set to NIL at the beginning of each line, so we           always re-interpret the attribute at least once.)                      [if (AND MONOFLG (NOT (EQ ATTRIB.BYTE LAST.ATTRIB.BYTE)))                          then (SETQ ATTRIB (\PCE.DECODE.TEXT.ATTRIBUTES ATTRIB.BYTE))                               (SETQ LAST.ATTRIB.BYTE ATTRIB.BYTE)                                                              (* set current font bitmap and bbt)                               (SELECTQ ATTRIB                                   (BRIGHT (SETQ FONTBM \PCE.DISPLAY.BOLDFONT.BM)                                           (SETQ FONTBBT \PCE.DISPLAY.BOLDFONT.BBT))                                   (BRIGHT.UNDERLINE                                         (SETQ FONTBM \PCE.DISPLAY.UNDERBOLDFONT.BM)                                        (SETQ FONTBBT \PCE.DISPLAY.UNDERBOLDFONT.BBT))                                   (UNDERLINE (SETQ FONTBM \PCE.DISPLAY.UNDERFONT.BM)                                              (SETQ FONTBBT \PCE.DISPLAY.UNDERFONT.BBT))                                   (PROGN (SETQ FONTBM \PCE.DISPLAY.FONT.BM)                                          (SETQ FONTBBT \PCE.DISPLAY.FONT.BBT)))                     (* If this is a blinking underlined char, and the blink state is off, set           FONTBM to the regular font bitmap, which has a space char with no underline           <blinking chars are mapped to space if the blink state is off>.          This allows blinking underline chars to blink the underline too, which is what           happens on the PC. The old value of FONTBM is saved in BLINK.CHARBM so that it           can be used for blting the blinking char on-state to \PCE.BLINK.BITMAP.)                               (SETQ BLINK.CHARBM FONTBM)                               (if [AND CHAR.IS.BLINKING (NULL \PCE.BLINK.CHARS.STATE)                                        (OR (EQ ATTRIB 'BRIGHT.UNDERLINE)                                            (EQ ATTRIB 'UNDERLINE]                                   then (SETQ FONTBM \PCE.DISPLAY.FONT.BM)                                        (SETQ FONTBBT \PCE.DISPLAY.FONT.BBT))                                                              (* Set bitblt type and operation in                                                              the bbt.)                               (if (EQ ATTRIB 'REVERSE)                                   then (\SETPBTFUNCTION FONTBBT 'INVERT 'REPLACE)                                 else (\SETPBTFUNCTION FONTBBT 'INPUT 'REPLACE]                     (* Get the character byte of the current character <or space if the char attrib           is invisible>, calculate the X position of this character in FONTBM, and change           the source of FONTBBT to point there. Note that in the color text modes, ATTRIB           is always NIL.)                      [SETQ FONT.BITMAP.XPOS (if (EQ ATTRIB 'INVISIBLE)                                                 then (ITIMES FONTCHARWIDTH (CHARCODE SPACE))                                               else (ITIMES FONTCHARWIDTH (LOGAND 255 (                                                                                     \DoveIO.ByteSwap                                                                                       PCWORD]                      (freplace (PILOTBBT PBTSOURCEBIT) of FONTBBT with FONT.BITMAP.XPOS)                     (* * make font and shade bbt point to correct position in scratch bitmap)                      (freplace (PILOTBBT PBTDESTBIT) of FONTBBT with XPOS)                      (freplace (PILOTBBT PBTDESTBIT) of \PCE.DISPLAY.COLOR.BRICKS.BBT with XPOS)                     (* * If the current char or its old value is a blinking char, update the count           of blinking chars and \PCE.BLINK.BITMAP.)                      (if CHAR.IS.BLINKING                          then                     (* If the current char is blinking, and the last char was not blinking,           increment blink char count)                               (if (NOT (BITTEST 128 OLDPCWORD))                                   then (SETQ \PCE.BLINK.NUMCHARS (ADD1 \PCE.BLINK.NUMCHARS)))                        elseif (BITTEST 128 OLDPCWORD)                          then                     (* if the current char is not blinking, but this char WAS blinking, then be           sure to decrement the blink char count and clear the blink bitmap for this char)                               (SETQ \PCE.BLINK.NUMCHARS (SUB1 \PCE.BLINK.NUMCHARS))                               (BLTSHADE WHITESHADE \PCE.BLINK.BITMAP XPOS YPOS FONTCHARWIDTH                                       \PCE.FONTCHARHEIGHT))                     (* * paint the char using one or several calls to \PILOTBITBLT depending on           whether the text mode is mono or color. Also handles updating the blink bitmap,           if the char is blinking.)                      (if MONOFLG                          then                     (* * in mono text mode, paint the char from the font bitmap)                               [if CHAR.IS.BLINKING                                   then                     (* BITBLT the on-state of the blinking char onto \PCE.BLINK.BITMAP.          This bitmap is used to invert all of the blinking chars in           \PCE.MONO.SCRATCH.BM.)                                        (BITBLT BLINK.CHARBM FONT.BITMAP.XPOS 0 \PCE.BLINK.BITMAP                                                XPOS YPOS FONTCHARWIDTH \PCE.FONTCHARHEIGHT                                               'REPLACE                                               (if (EQ ATTRIB 'REVERSE)                                                   then 'INVERT                                                 else 'INPUT))                     (* if the blinking char is off, map it to the space character)                                        (if (NULL \PCE.BLINK.CHARS.STATE)                                            then (freplace (PILOTBBT PBTSOURCEBIT) of FONTBBT                                                    with (ITIMES FONTCHARWIDTH (CHARCODE SPACE]                               (\PILOTBITBLT FONTBBT 0)                        else                     (* * In color text mode, paint char using correct shades for foreground and           background, by doing several bitblts. This is a somewhat modified version of           the algorithm in ColorText in PCDisplayTextImpl.mesa.)                    (* * Clear the high-order bit of ATTRIB.BYTE that specifies a blinking           character. Currently, we do not support the mode where we simulate 16           background shades, instead of blinking. <neither does VP PCE>.)                             (SETQ ATTRIB.BYTE (LOGAND ATTRIB.BYTE 127))                             (PROG [(BACKGROUND.BIT (ELT \PCE.DISPLAY.COLOR.BACK.GRAYBIT                                                         (LRSH ATTRIB.BYTE 4]                    (* * Paint region with background shade.)                                   (freplace (PILOTBBT PBTSOURCEBIT) of \PCE.DISPLAY.COLOR.BRICKS.BBT                                      with BACKGROUND.BIT)                                   (\SETPBTFUNCTION \PCE.DISPLAY.COLOR.BRICKS.BBT 'INPUT 'REPLACE)                                   (\PILOTBITBLT \PCE.DISPLAY.COLOR.BRICKS.BBT 0)                    (* * XOR region with foreground shade <except if foreground=15=white>)                                   (if (NOT (EQP (LOGAND PCWORD 15)                                                 15))                                       then (freplace (PILOTBBT PBTSOURCEBIT) of                                                                         \PCE.DISPLAY.COLOR.BRICKS.BBT                                               with (ELT \PCE.DISPLAY.COLOR.FORE.GRAYBIT ATTRIB.BYTE)                                                   )                                            (\SETPBTFUNCTION \PCE.DISPLAY.COLOR.BRICKS.BBT                                                   'INPUT                                                   'INVERT)                                            (\PILOTBITBLT \PCE.DISPLAY.COLOR.BRICKS.BBT 0))                    (* * AND the character bitmap <by erasing the inverse of the char>)                                   (\SETPBTFUNCTION FONTBBT 'INVERT 'ERASE)                                   (\PILOTBITBLT FONTBBT 0)                    (* * copy "(FORE xor BACK) and CHAR" to the blink bitmap, if this is a blinking           char.)                                   (if CHAR.IS.BLINKING                                       then (BITBLT \PCE.DISPLAY.SCRATCH.BM XPOS YPOS                                                    \PCE.BLINK.BITMAP XPOS YPOS FONTCHARWIDTH                                                    \PCE.FONTCHARHEIGHT 'REPLACE 'INPUT))                    (* * XOR the background shade, so that the char shape currently shaded "(FORE xor BACK)"           is changed to the foreground shade, and the rest <currently white> is shaded           with the background shade.)                    (* * Note%: If the char is blinking, and the blink state is currently off, do a           REPLACE of the background shade, instead of XOR.)                                   (freplace (PILOTBBT PBTSOURCEBIT) of \PCE.DISPLAY.COLOR.BRICKS.BBT                                      with BACKGROUND.BIT)                                   (if (AND CHAR.IS.BLINKING (NULL \PCE.BLINK.CHARS.STATE))                                       then (\SETPBTFUNCTION \PCE.DISPLAY.COLOR.BRICKS.BBT                                                   'INPUT                                                   'REPLACE)                                     else (\SETPBTFUNCTION \PCE.DISPLAY.COLOR.BRICKS.BBT 'INPUT                                                 'INVERT))                                   (\PILOTBITBLT \PCE.DISPLAY.COLOR.BRICKS.BBT 0]                    (* * If any of the chars needed to be repainted, and the PC window is open,           calculate the size of the region that has to be redisplayed and blt it to the           window)          (if (AND (ILEQ MINROW MAXROW)                   (ILEQ MINCOL MAXCOL)                   (OPENWP \PCE.WINDOW))              then (PROG [(X (ITIMES FONTCHARWIDTH MINCOL))                          (Y (ITIMES \PCE.FONTCHARHEIGHT (IDIFFERENCE 24 MAXROW)))                          [WIDTH (ITIMES FONTCHARWIDTH (ADD1 (IDIFFERENCE MAXCOL MINCOL]                          (HEIGHT (ITIMES \PCE.FONTCHARHEIGHT (ADD1 (IDIFFERENCE MAXROW MINROW]                                                             (* invert bitmap if the display is                                                              inverted)                         (BITBLT \PCE.DISPLAY.SCRATCH.BM X Y \PCE.WINDOW X Y WIDTH HEIGHT                                (if \PCE.DISPLAY.INVERTED                                    then 'INVERT                                  else 'INPUT)                                'REPLACE)                    (* If the caret is on, and it is in the area that we just replaced, invert it.)                         (if (AND \PCE.BLINK.CARET.STATE (IGEQ \PCE.CARET.XPOS X)                                  (IGEQ \PCE.CARET.YPOS Y)                                  (ILESSP \PCE.CARET.XPOS (IPLUS X WIDTH))                                  (ILESSP \PCE.CARET.YPOS (IPLUS Y HEIGHT)))                             then (\PCE.CARET.INVERT])(\PCE.DISPLAY.UPDATE  [LAMBDA (REDISPLAYFLG)                                     (* mjs " 3-Jul-86 16:00")                    (* * Updates the PCE display according to the display FCB.          This proc mainly checks to see if the display mode has been changed, and then           calls either \PCE.DISPLAY.UPDATE.TEXT or \PCE.DISPLAY.UPDATE.GRAPHICS)                    (* * If REDISPLAYFLG is non-NIL, everything is updated <this is called by           \PCE.WINDOW.REPAINTFN>.)                    (* * See ColorProcedure and MonochromeProcedure in PCEDisplay.mesa)    (if (OPENWP \PCE.WINDOW)        then (PROG ([REQBITS (if REDISPLAYFLG                                 then                        (* on redisplay, update everything)                                      65535                               else (\DoveIO.LockMem \DoveIO.XCHG (\DoveIO.IORegionOffset                                                                   (LOCF (fetch (\PCE.DISPLAY.FCB                                                                                 serviceReqBits)                                                                            of \PCE.DISPLAY.FCBPTR)))                                           0                                           (fetch (\PCE.DISPATCHER.FCB pceLockMask) of                                                                                \PCE.DISPATCHER.FCBPTR                                                  ]                    (DISPLAYERROR (fetch (\PCE.DISPLAY.FCB errorNumber) of \PCE.DISPLAY.FCBPTR))                    DISPLAYMODE)                    (* * Check for display error. <<<I don't know under what circumstances you           would ever get such an error>>>)                   (if (AND (NOT (ZEROP DISPLAYERROR))                            \PCE.DEBUG.FLG)                       then (\PCE.SYSTEM.ERROR "Display error" (\DoveIO.ByteSwap DISPLAYERROR)))                    (* * Check whether to change display mode.          Cannot change display mode is in mono text mode.          In any case, do complete redisplay, and check caret type.)                   (if (BITTEST REQBITS \PCE.DISPLAY.modeControlSet)                       then                                  (* cannot change display mode if in                                                              mono text mode)                                                             (* if we are switching display mode,                                                              redisplay everything)                            (SETQ REDISPLAYFLG T)                            (SETQ REQBITS 65535)                            [if (NOT (EQ \PCE.DISPLAY.MODE 'MONO))                                then                         (* cannot change display mode if in                                                              mono text mode)                                     (SETQ DISPLAYMODE (fetch (\PCE.DISPLAY.FCB displayMode)                                                          of \PCE.DISPLAY.FCBPTR))                                     (SETQ \PCE.DISPLAY.MODE                                      (SELECTC DISPLAYMODE                                          ((LIST \PCE.DISPLAY.Text40x25BWVal                                                  \PCE.DISPLAY.Text40x25BWNoBlinkingVal                                                  \PCE.DISPLAY.Text40x25ColorVal                                                  \PCE.DISPLAY.Text40x25ColorNoBlinkingVal)                                                'COLOR40)                                          ((LIST \PCE.DISPLAY.Text80x25BWVal                                                  \PCE.DISPLAY.Text80x25BWNoBlinkingVal                                                  \PCE.DISPLAY.Text80x25ColorVal                                                  \PCE.DISPLAY.Text80x25ColorNoBlinkingVal)                                                'COLOR80)                                          ((LIST \PCE.DISPLAY.GraphHiResVal                                                  \PCE.DISPLAY.GraphHiResAltVal)                                                'HIRES)                                          ((LIST \PCE.DISPLAY.GraphMedResBWVal                                                  \PCE.DISPLAY.GraphMedResBWAltVal                                                  \PCE.DISPLAY.GraphMedResColorVal                                                  \PCE.DISPLAY.GraphMedResColorAltVal)                                                'MEDRES)                                          (PROGN (if (AND (NEQ DISPLAYMODE 0)                                                          \PCE.DEBUG.FLG)                                                     then (\PCE.SYSTEM.ERROR "Bad Color Mode"                                                                  DISPLAYMODE))                                                 NIL]                            [SETQ \PCE.DISPLAY.MODE.HAS.TEXT (MEMB \PCE.DISPLAY.MODE                                                                   '(MONO COLOR40 COLOR80]                            (\PCE.CARET.SET.TYPE (if \PCE.DISPLAY.MODE.HAS.TEXT                                                     then \PCE.DISPLAY.MODE                                                   else NIL))                            (SETQ \PCE.DISPLAY.BASE (if (EQ \PCE.DISPLAY.MODE 'MONO)                                                        then \PCE.DISPLAY.MONO.BASE                                                      else \PCE.DISPLAY.COLOR.BASE)))                    (* * Call appropriate routine for text or graphics display update)                   (if \PCE.DISPLAY.MODE.HAS.TEXT                       then (\PCE.DISPLAY.UPDATE.TEXT REDISPLAYFLG REQBITS)                     elseif \PCE.DISPLAY.MODE                       then (\PCE.DISPLAY.UPDATE.GRAPHICS REDISPLAYFLG REQBITS)                     else                                    (* if display disabled, ignore dirty                                                              bits.)                          (if (BITTEST REQBITS \PCE.DISPLAY.dirtyBitsDirty)                              then (replace (\PCE.DISPLAY.FCB dirtBitsState) of \PCE.DISPLAY.FCBPTR                                      with 0])(\PCE.DISPLAY.UPDATE.GRAPHICS  [LAMBDA (REDISPLAYFLG REQBITS)                             (* mjs " 7-Jul-86 14:34")                    (* * Updates graphics display. If REDISPLAYFLG is non-NIL, everything is           updated. REQBITS is the integer whose bits are decoded to determine what needs           to be updated.)    (PROG NIL                    (* * If the color map has been changed, redisplay everything)          (if (BITTEST REQBITS \PCE.DISPLAY.colorChange)              then (SETQ REDISPLAYFLG T))                    (* * If any of the dirty bits are on, some bytes in the display mem have been           changed --- repaint them.)          (if (BITTEST REQBITS \PCE.DISPLAY.dirtyBitsDirty)              then (PROG [(DBARRAYBASE (LOCF (fetch (\PCE.DISPLAY.FCB dirtyBitArray) of                                                                                   \PCE.DISPLAY.FCBPTR                                                    ]                         (PROG [(\PCE.DIRTYBITSLIST.SPECVAR (LIST (\GETBASE DBARRAYBASE 0)                                                                  (\GETBASE DBARRAYBASE 1)                                                                  (\GETBASE DBARRAYBASE 2)                                                                  (\GETBASE DBARRAYBASE 3]                               (DECLARE (SPECVARS \PCE.DIRTYBITSLIST.SPECVAR))                               (replace (\PCE.DISPLAY.FCB dirtBitsState) of \PCE.DISPLAY.FCBPTR                                  with 0)                    (* \PCE.WINDOW.LOCK prevents a window-menu redisplay from interferring with a           PC-initiated update. This is necessary because \PCE.DISPLAY.REPAINT.GRAPHICS           calls BLOCK every few lines.)                               (WITH.MONITOR \PCE.WINDOW.LOCK (\PCE.DISPLAY.REPAINT.GRAPHICS                                                                      REDISPLAYFLG                                                                      \PCE.DIRTYBITSLIST.SPECVAR])(\PCE.DISPLAY.UPDATE.TEXT  [LAMBDA (REDISPLAYFLG REQBITS)                             (* mjs "15-Jul-86 13:47")                    (* * Updates text display, by repainting any characters that have been changed,           and updating the caret shape and position if changed.          If REDISPLAYFLG is non-NIL, everything is updated.          REQBITS is the integer whose bits are decoded to determine what needs to be           updated.)    (PROG [(MONOFLG (EQ \PCE.DISPLAY.MODE 'MONO]                    (* * If the page address has changed, reset the offset, and do a complete           redisplay)          (if (BITTEST REQBITS \PCE.DISPLAY.pageChange)              then (SETQ \PCE.DISPLAY.COLOR.PAGE.OFFSET (if MONOFLG                                                            then 0                                                          else (fetch (\PCE.DISPLAY.FCB                                                                              mfColorPageStartAddr)                                                                  of \PCE.DISPLAY.FCBPTR)))                   (SETQ \PCE.DISPLAY.BASE (if MONOFLG                                               then \PCE.DISPLAY.MONO.BASE                                             else (\ADDBASE \PCE.DISPLAY.COLOR.BASE                                                          \PCE.DISPLAY.COLOR.PAGE.OFFSET)))                   (SETQ REQBITS 65535)                   (SETQ REDISPLAYFLG T))                    (* * If any of the dirty bits are on, some characters in the display mem have           been changed --- repaint them.)                    (* * Note%: If the display page offset is not zero, don't bother figuring out           which dirty bits correspond to which lines ---          just redisplay all lines. Tests indicate that this only takes 0.2 secs more per           2000-char redisplay.)          [if (BITTEST REQBITS \PCE.DISPLAY.dirtyBitsDirty)              then (PROG ((\PCE.DIRTYBITS.SPECVAR (if (ZEROP \PCE.DISPLAY.COLOR.PAGE.OFFSET)                                                      then (\GETBASE (LOCF (fetch (\PCE.DISPLAY.FCB                                                                                   dirtyBitArray)                                                                              of \PCE.DISPLAY.FCBPTR)                                                                           )                                                                  0)                                                    else 65535)))                         (DECLARE (SPECVARS \PCE.DIRTYBITS.SPECVAR))                    (* Note%: when this fn is called to redisplay after opening the window, setting           dirtBitsState will acknowledge any changes that were made while the window was           closed, so we will start getting up notifies again.)                         (replace (\PCE.DISPLAY.FCB dirtBitsState) of \PCE.DISPLAY.FCBPTR                            with 0)                    (* \PCE.WINDOW.LOCK prevents a window-menu redisplay from interferring with a           PC-initiated update. This is necessary because \PCE.DISPLAY.REPAINT.TEXT calls           BLOCK every few lines.)                         (WITH.MONITOR \PCE.WINDOW.LOCK (\PCE.DISPLAY.REPAINT.TEXT REDISPLAYFLG                                                                \PCE.DIRTYBITS.SPECVAR]                    (* * Update caret shape if it has changed.)          (if (BITTEST REQBITS \PCE.DISPLAY.cursorShapeChange)              then [WITH.MONITOR \PCE.WINDOW.LOCK (with \PCE.DISPLAY.FCB \PCE.DISPLAY.FCBPTR                                                        (if MONOFLG                                                            then (\PCE.CARET.RESHAPE                                                                         mfMonoCursorStart                                                                         mfMonoCursorEnd)                                                          else (\PCE.CARET.RESHAPE mfColorCursorStart                                                                       mfColorCursorEnd]                   (BLOCK))                    (* * Update caret location if it has changed.)          (if (BITTEST REQBITS \PCE.DISPLAY.cursorLocationChange)              then                                           (* check if cursor has been moved)                   [WITH.MONITOR \PCE.WINDOW.LOCK (with \PCE.DISPLAY.FCB \PCE.DISPLAY.FCBPTR                                                        (if MONOFLG                                                            then (\PCE.CARET.MOVE mfMonoCursorAddr)                                                          else (\PCE.CARET.MOVE (IDIFFERENCE                                                                                     mfColorCursorAddr                                                                        \PCE.DISPLAY.COLOR.PAGE.OFFSET                                                                                       ]                   (BLOCK]))(RPAQ? \PCE.DISPLAY.MODE )(RPAQ? \PCE.DISPLAY.MODE.HAS.TEXT )(RPAQ? \PCE.DISPLAY.BASE )(RPAQ? \PCE.DISPLAY.MONO.BASE )(RPAQ? \PCE.DISPLAY.COLOR.BASE )(RPAQ? \PCE.DISPLAY.COLOR.PAGE.OFFSET )(RPAQ? \PCE.DISPLAY.INVERTED )(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.DISPLAY.MODE \PCE.DISPLAY.MODE.HAS.TEXT \PCE.DISPLAY.BASE \PCE.DISPLAY.MONO.BASE        \PCE.DISPLAY.COLOR.BASE \PCE.DISPLAY.COLOR.PAGE.OFFSET \PCE.DISPLAY.INVERTED))(RPAQ? \PCE.DISPLAY.SCRATCH.BM )(RPAQ? \PCE.DISPLAY.FONT.BM )(RPAQ? \PCE.DISPLAY.FONT.BBT )(RPAQ? \PCE.DISPLAY.WIDEFONT.BM )(RPAQ? \PCE.DISPLAY.WIDEFONT.BBT )(RPAQ? \PCE.DISPLAY.BOLDFONT.BM )(RPAQ? \PCE.DISPLAY.BOLDFONT.BBT )(RPAQ? \PCE.DISPLAY.UNDERFONT.BM )(RPAQ? \PCE.DISPLAY.UNDERFONT.BBT )(RPAQ? \PCE.DISPLAY.UNDERBOLDFONT.BM )(RPAQ? \PCE.DISPLAY.UNDERBOLDFONT.BBT )(RPAQ? \PCE.DISPLAY.OLDCHARS )(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.DISPLAY.SCRATCH.BM \PCE.DISPLAY.FONT.BM \PCE.DISPLAY.FONT.BBT        \PCE.DISPLAY.WIDEFONT.BM \PCE.DISPLAY.WIDEFONT.BBT \PCE.DISPLAY.BOLDFONT.BM        \PCE.DISPLAY.BOLDFONT.BBT \PCE.DISPLAY.UNDERFONT.BM \PCE.DISPLAY.UNDERFONT.BBT        \PCE.DISPLAY.UNDERBOLDFONT.BM \PCE.DISPLAY.UNDERBOLDFONT.BBT \PCE.DISPLAY.OLDCHARS))(* repainting pseudo-color display)(RPAQ? \PCE.DISPLAY.COLOR.TO.SCRATCH.BBT )(RPAQ? \PCE.DISPLAY.COLOR.ODDLINEBLOCK.BASE )(RPAQ? \PCE.DISPLAY.COLOR.EVENLINEBLOCK.BASE )(RPAQ? \PCE.DISPLAY.COLOR.BRICKS.BM )(RPAQ? \PCE.DISPLAY.COLOR.BRICKS.BBT )(RPAQ? \PCE.DISPLAY.COLOR.BACK.GRAYBIT )(RPAQ? \PCE.DISPLAY.COLOR.FORE.GRAYBIT )(RPAQ? \PCE.DISPLAY.MEDRES.GRAY.BM )(RPAQ? \PCE.DISPLAY.MEDRES.GRAY.BBT )(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.DISPLAY.COLOR.TO.SCRATCH.BBT \PCE.DISPLAY.COLOR.ODDLINEBLOCK.BASE        \PCE.DISPLAY.COLOR.EVENLINEBLOCK.BASE \PCE.DISPLAY.COLOR.BRICKS.BM        \PCE.DISPLAY.COLOR.BRICKS.BBT \PCE.DISPLAY.COLOR.BACK.GRAYBIT \PCE.DISPLAY.COLOR.FORE.GRAYBIT        \PCE.DISPLAY.MEDRES.GRAY.BM \PCE.DISPLAY.MEDRES.GRAY.BBT))(* blinking chars and caret)(DEFINEQ(\PCE.BLINK  [LAMBDA NIL                                                (* mjs " 3-Jul-86 10:01")                    (* * \PCE.BLINK is called periodically to invert blinking chars and caret.          The caret is only blinked if the pc kbd process has the tty.)    (if (AND \PCE.DISPLAY.MODE.HAS.TEXT (OPENWP \PCE.WINDOW)             (TIMEREXPIRED? \PCE.BLINK.TIMER))        then (SETQ \PCE.BLINK.STATE (NOT \PCE.BLINK.STATE))                     (* when inverting chars off->on, want to invert chars BEFORE inverting caret,           to prevent caret jittering <<caret is turned on, caret erased when blinking           char bitmap is bltblted, caret repainted>>.          When inverting chars on->off, want to invert caret first.          Note that it is OK to call \PCE.BLINK.CHARS.SET twice, since it remembers the           blinking char state.)             (if \PCE.BLINK.STATE                 then (\PCE.BLINK.CHARS.SET \PCE.BLINK.STATE))             (\PCE.BLINK.CARET.SET (if (TTY.PROCESSP (PCE.KBD.PROC))                                       then \PCE.BLINK.STATE                                     else NIL))             (\PCE.BLINK.CHARS.SET \PCE.BLINK.STATE)             (SETQ \PCE.BLINK.TIMER (SETUPTIMER (if \PCE.BLINK.STATE                                                    then \PCE.BLINK.ON.RATE                                                  else \PCE.BLINK.OFF.RATE)                                           \PCE.BLINK.TIMER])(\PCE.BLINK.CARET.SET  [LAMBDA (NEWSTATE)                                         (* mjs "30-Apr-86 10:05")                    (* * Sets the caret state to NEWSTATE <non-NIL is on, NIL is off>, inverting           the caret if necessary.)    (if (NEQ \PCE.BLINK.CARET.STATE NEWSTATE)        then (\PCE.CARET.INVERT)             (SETQ \PCE.BLINK.CARET.STATE NEWSTATE])(\PCE.BLINK.CHARS  [LAMBDA NIL                                                (* mjs "15-Jul-86 14:47")                    (* * Inverts any blinking chars by inverting the blinking chars in           \PCE.MONO.SCRATCH.BM, blting this to the window, and repainting the caret if it           was on. This is expensive, so don't do it unless \PCE.BLINK.NUMCHARS > 0)    (if (AND (IGREATERP \PCE.BLINK.NUMCHARS 0)             (OPENWP \PCE.WINDOW))        then (BITBLT \PCE.BLINK.BITMAP 0 0 \PCE.DISPLAY.SCRATCH.BM 0 0 MAX.SMALLP MAX.SMALLP                    'INPUT                    'INVERT)             (BITBLT \PCE.DISPLAY.SCRATCH.BM 0 0 \PCE.WINDOW 0 0 MAX.SMALLP MAX.SMALLP                    (if \PCE.DISPLAY.INVERTED                        then 'INVERT                      else 'INPUT)                    'REPLACE)             (if \PCE.BLINK.CARET.STATE                 then                                        (* repaint caret if it is on)                      (\PCE.CARET.INVERT])(\PCE.BLINK.CHARS.SET  [LAMBDA (NEWSTATE)                                         (* mjs "30-Apr-86 10:17")                    (* * Sets the blinking chars state to NEWSTATE <non-NIL is on, NIL is off>,           inverting the chars if necessary.)                    (* * The blinking chars state is not changed if \PCE.BLINK.CHARS.ENABLED is           NIL. This is used to disable blinking chars during copy-select from the pc           window, since otherwise we would have to redraw the copy-select underline each           time the blinking chars were inverted.)    (if (AND \PCE.BLINK.CHARS.ENABLED (NEQ \PCE.BLINK.CHARS.STATE NEWSTATE))        then (\PCE.BLINK.CHARS)             (SETQ \PCE.BLINK.CHARS.STATE NEWSTATE])(\PCE.CARET.DRAW  [LAMBDA (STARTLINE ENDLINE)                                (* mjs " 5-Jun-86 16:50")                    (* * Shades appropriate rows in \PCE.CARET.BITMAP, according to the PC cursor           specs STARTLINE and ENDLINE)    (PROG (MONO.DISPLAY.P LASTVIS STARTY ENDY)               (* clear cursor bitmap)          (BLTSHADE WHITESHADE \PCE.CARET.BITMAP 0 0 MAX.SMALLP MAX.SMALLP)          (if (NULL \PCE.CARET.TYPE)              then                                           (* not a text display, so leave empty                                                              caret bitmap)                   (RETURN))          (SETQ MONO.DISPLAY.P (EQ \PCE.CARET.TYPE 'MONO))          (SETQ LASTVIS (if MONO.DISPLAY.P                            then                             (* color text caret has 8 lines)                                 13                          else                               (* mono text caret has 14 lines)                               7))          (if (OR (ILESSP STARTLINE 0)                  (IGREATERP STARTLINE LASTVIS))              then                                           (* start line not visible ---> blank                                                              cursor)                   (RETURN))          (if (OR (ILESSP ENDLINE 0)                  (IGREATERP ENDLINE LASTVIS))              then                     (* start line visible, but end line not visible ---> solid black cursor)                   (SETQ STARTLINE 0)                   (SETQ ENDLINE LASTVIS))          (if MONO.DISPLAY.P              then                                           (* mono text caret has 14 lines)                   (SETQ STARTY (if (ZEROP STARTLINE)                                    then 0                                  else (IPLUS STARTLINE 2)))                   (SETQ ENDY (if (EQP ENDLINE LASTVIS)                                  then 15                                else (IPLUS ENDLINE 2)))            else                                             (* color text caret has 8 lines)                 (SETQ STARTY (ITIMES 2 STARTLINE))                 (SETQ ENDY (ITIMES 2 ENDLINE)))          (SETQ STARTY (IDIFFERENCE 15 STARTY))          (SETQ ENDY (IDIFFERENCE 15 ENDY))          (if (ILEQ STARTLINE ENDLINE)              then                     (* start, end visible, and start <= end ---> single black line between start           and end)                   (BLTSHADE BLACKSHADE \PCE.CARET.BITMAP 0 ENDY MAX.SMALLP (ADD1 (IDIFFERENCE                                                                                          ENDLINE                                                                                          STARTLINE)))            else                     (* start, end visible, and start > end ---> two black blocks)                 (BLTSHADE BLACKSHADE \PCE.CARET.BITMAP 0 ENDY MAX.SMALLP (ADD1 (IDIFFERENCE 15 ENDY)                                                                                ))                 (BLTSHADE BLACKSHADE \PCE.CARET.BITMAP 0 0 MAX.SMALLP (ADD1 STARTY])(\PCE.CARET.INVERT  [LAMBDA NIL                                                (* mjs "29-Jul-86 15:13")                    (* * Inverts the caret directly on \PCE.WINDOW)                    (* * We set up the CARET1 record and call \CARET.SHOW so that the PCE window           will not be brought to the top unless the caret is occluded.)                    (* * Also, do not invert caret unless caret type is not NIL <MONO, COLOR80, or           COLOR40>.)    (if (AND \PCE.CARET.TYPE (OPENWP \PCE.WINDOW))        then                                                 (* when we did the bitblt ourselves%:                                                             (BITBLT \PCE.CARET.BITMAP 0 0                                                              \PCE.WINDOW \PCE.CARET.XPOS                                                              \PCE.CARET.YPOS 8 16                                                             (QUOTE INPUT) (QUOTE INVERT)))             [with CARET1 \PCE.CARET.CARET1 (SETQ STREAMX \PCE.CARET.XPOS)                   (SETQ STREAMY \PCE.CARET.YPOS)                   (SETQ STREAM (WINDOWPROP \PCE.WINDOW 'DSP]             (\CARET.SHOW \PCE.CARET.CARET1])(\PCE.CARET.MOVE  [LAMBDA (CARET.POS)                                        (* mjs " 5-Jun-86 17:07")                    (* * Moves the caret to CARET.POS <a number from 0 to 1999 indicating the           character number in the |80x25| monochrome display memory>)    (PROG ((CHARS.ON.LINE (if (EQ \PCE.CARET.TYPE 'COLOR40)                              then 40                            else 80))           (CHARWIDTH (if (EQ \PCE.CARET.TYPE 'COLOR40)                          then (ITIMES \PCE.FONTCHARWIDTH 2)                        else \PCE.FONTCHARWIDTH))           CARET.XPOS CARET.YPOS CARET.LINE)          [SETQ CARET.YPOS (ITIMES \PCE.FONTCHARHEIGHT (IDIFFERENCE 24 (IQUOTIENT CARET.POS                                                                               CHARS.ON.LINE]          (SETQ CARET.XPOS (ITIMES CHARWIDTH (IMOD CARET.POS CHARS.ON.LINE)))          (if (AND (EQ CARET.YPOS \PCE.CARET.YPOS)                   (EQ CARET.XPOS \PCE.CARET.XPOS))              then (RETURN))          (if \PCE.BLINK.CARET.STATE              then (\PCE.CARET.INVERT))          (SETQ \PCE.CARET.YPOS CARET.YPOS)          (SETQ \PCE.CARET.XPOS CARET.XPOS)          (if \PCE.BLINK.CARET.STATE              then (\PCE.CARET.INVERT])(\PCE.CARET.RESHAPE  [LAMBDA (STARTLINE ENDLINE)                                (* mjs "30-Apr-86 10:49")                    (* * Reshapes the PC caret according to the PC caret shape parameters STARTLINE           and ENDLINE. These numbers specify which rows in the caret are black in a           rather strange way <see \PCE.CARET.DRAW>)    (if \PCE.BLINK.CARET.STATE        then (\PCE.CARET.INVERT))    (\PCE.CARET.DRAW STARTLINE ENDLINE)    (if \PCE.BLINK.CARET.STATE        then (\PCE.CARET.INVERT])(\PCE.CARET.SET.TYPE  [LAMBDA (NEWTYPE)                                        (* ; "Edited 13-Feb-87 10:44 by SANTOSA")                    (* * Sets the caret type to NEWTYPE, which should be one of NIL <no caret>,           MONO <monochrome caret>, COLOR80 <80x25 color text caret>, or COLOR40 <40x25           color text caret>. The location and shape parameters of the caret are           interpreted differently depending on the caret type.)    (PROG NIL          (if (EQ \PCE.CARET.TYPE NEWTYPE)              then (RETURN))          (if \PCE.BLINK.CARET.STATE              then (\PCE.CARET.INVERT))          (SETQ \PCE.CARET.TYPE NEWTYPE)          (SETQ \PCE.CARET.BITMAP (BITMAPCREATE (if (EQ NEWTYPE 'COLOR40)                                                    then 16                                                  else 8)                                         16))          (replace (CARET1 CURSOR) of \PCE.CARET.CARET1 with (create CURSOR                                                                    CUIMAGE _ \PCE.CARET.BITMAP))          (if \PCE.BLINK.CARET.STATE              then (\PCE.CARET.INVERT]))(RPAQ? \PCE.BLINK.STATE )(RPAQ? \PCE.BLINK.NUMCHARS 0)(RPAQ? \PCE.BLINK.CHARS.ENABLED T)(RPAQ? \PCE.BLINK.CHARS.STATE T)(RPAQ? \PCE.BLINK.CARET.STATE NIL)(RPAQ? \PCE.BLINK.BITMAP )(RPAQ? \PCE.BLINK.ON.RATE 333)(RPAQ? \PCE.BLINK.OFF.RATE 333)(RPAQ? \PCE.BLINK.TIMER )(RPAQ? \PCE.CARET.BITMAP )(RPAQ? \PCE.CARET.CARET1 )(RPAQ? \PCE.CARET.XPOS )(RPAQ? \PCE.CARET.YPOS )(RPAQ? \PCE.CARET.TYPE 'MONO)(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.BLINK.NUMCHARS \PCE.BLINK.STATE \PCE.BLINK.CHARS.ENABLED \PCE.BLINK.CHARS.STATE        \PCE.BLINK.CARET.STATE \PCE.BLINK.BITMAP \PCE.BLINK.ON.RATE \PCE.BLINK.OFF.RATE        \PCE.BLINK.TIMER \PCE.CARET.BITMAP \PCE.CARET.CARET1 \PCE.CARET.XPOS \PCE.CARET.YPOS        \PCE.CARET.TYPE))(* shift-select from PC window)(DEFINEQ(\PCE.COPY.UNDERLINE.DRAW  [LAMBDA (STARTCHARNUM ENDCHARNUM)                          (* mjs " 3-Jul-86 11:14")                    (* * Inverts a gray copy-select underline under PC chars STARTCHARNUM through           ENDCHARNUM <each a number from 0 to 1999 specifying a char position in the           monochrome display memory>.)    (if (AND (SMALLP STARTCHARNUM)             (SMALLP ENDCHARNUM))        then (PROG (CHARS.PER.LINE CHARWIDTH STARTX STARTY ENDX ENDY)                   (if (EQ \PCE.DISPLAY.MODE 'COLOR40)                       then (SETQ CHARS.PER.LINE 40)                            (SETQ CHARWIDTH (IPLUS \PCE.FONTCHARWIDTH \PCE.FONTCHARWIDTH))                     else (SETQ CHARS.PER.LINE 80)                          (SETQ CHARWIDTH \PCE.FONTCHARWIDTH))                    (* * make sure that STARTCHARNUM <= ENDCHARNUM)                   (if (ILESSP ENDCHARNUM STARTCHARNUM)                       then (swap STARTCHARNUM ENDCHARNUM))                    (* * STARTX and STARTY specify the position of the lower-left corner of the           first char)                   (SETQ STARTX (ITIMES CHARWIDTH (IMOD STARTCHARNUM CHARS.PER.LINE)))                   [SETQ STARTY (ITIMES \PCE.FONTCHARHEIGHT (IDIFFERENCE 24 (IQUOTIENT STARTCHARNUM                                                                                    CHARS.PER.LINE]                    (* * ENDX and ENDY specify the position of the lower-right corner of the last           char)                   [SETQ ENDX (IPLUS CHARWIDTH (ITIMES CHARWIDTH (IMOD ENDCHARNUM CHARS.PER.LINE]                   [SETQ ENDY (ITIMES \PCE.FONTCHARHEIGHT (IDIFFERENCE 24 (IQUOTIENT ENDCHARNUM                                                                                  CHARS.PER.LINE]                    (* * For each row of characters, draw a separate underline.          After the first row, STARTX is set to start from the lower-left corner of the           first char on the line. For each row except the last one, the underline should           extend to the lower-right of the last copy-able character on the line <as           determined by \PCE.WINDOW.LASTCHAR>)                   (for Y from STARTY by (IMINUS \PCE.FONTCHARHEIGHT) as LINENUM                      from (IQUOTIENT STARTCHARNUM CHARS.PER.LINE) until (ILESSP Y ENDY)                      do (BLTSHADE GRAYSHADE \PCE.WINDOW STARTX Y                                (IDIFFERENCE (if (EQP Y ENDY)                                                 then ENDX                                               else (IPLUS CHARWIDTH (ITIMES (IMOD (                                                                                 \PCE.WINDOW.LASTCHAR                                                                                    LINENUM)                                                                                   CHARS.PER.LINE)                                                                            CHARWIDTH)))                                       STARTX)                                2                                'INVERT)                         (SETQ STARTX 0])(\PCE.DISPLAY.COPY.INIT.VARS  [LAMBDA NIL                                                (* mjs "30-Apr-86 11:11")                    (* * Initializes the variables used during copy-selection.)                    (* * \PCE.WINDOW.LASTCHAR.ARRAY is used to store pointers to the last char on           each line, so you can't select beyond the end of the line.          Array entries of -1 signify that the last char hasn't been calculated for this           line yet.)    (if (NOT (ARRAYP \PCE.WINDOW.LASTCHAR.ARRAY))        then (SETQ \PCE.WINDOW.LASTCHAR.ARRAY (ARRAY 25 'FIXP -1 0)))    (for X from 0 to 24 do (SETA \PCE.WINDOW.LASTCHAR.ARRAY X -1))                    (* * \PCE.WINDOW.COPY.STARTCHARNUM and \PCE.WINDOW.COPY.ENDCHARNUM are the           character numbers <from 0 to 1999> of the beginning and end of the copy-select           underline currently drawn.)    (SETQ \PCE.WINDOW.COPY.STARTCHARNUM NIL)    (SETQ \PCE.WINDOW.COPY.ENDCHARNUM NIL])(\PCE.DISPLAY.COPY.UNDERLINE  [LAMBDA (NEWSTARTCHARNUM NEWENDCHARNUM)                    (* mjs "30-Apr-86 11:13")                    (* * Redraws the copy-select underline if the first and last chars have           changed.)    (if (OR (NEQ NEWSTARTCHARNUM \PCE.WINDOW.COPY.STARTCHARNUM)            (NEQ NEWENDCHARNUM \PCE.WINDOW.COPY.ENDCHARNUM))        then                                                 (* undraw old underline)             (\PCE.COPY.UNDERLINE.DRAW \PCE.WINDOW.COPY.STARTCHARNUM \PCE.WINDOW.COPY.ENDCHARNUM)                                                              (* draw new underline)             (\PCE.COPY.UNDERLINE.DRAW NEWSTARTCHARNUM NEWENDCHARNUM)             (SETQ \PCE.WINDOW.COPY.STARTCHARNUM NEWSTARTCHARNUM)             (SETQ \PCE.WINDOW.COPY.ENDCHARNUM NEWENDCHARNUM])(\PCE.PCDISPLAY.TO.NS.STRING  [LAMBDA (STARTCHARNUM ENDCHARNUM)                          (* mjs " 3-Jul-86 11:21")                    (* * Returns an NS string containing the characters in the PC display from           STARTCHARNUM to ENDCHARNUM)                    (* * If the user has set PCE.PC.TO.NS.ARRAY to a zero-based array with at least           256 elements, it is used to map from PC charcodes to NS charcodes.          Otherwise, all PC charcodes map to the equivalent NS charcode.)    (PROG (CHARMAP.ARRAY CHARLIST)                    (* * Check that STARTCHARNUM and ENDCHARNUM are legitamite, and in the right           order)          (if (NOT (AND (SMALLP STARTCHARNUM)                        (SMALLP ENDCHARNUM)))              then (RETURN ""))          (if (IGREATERP STARTCHARNUM ENDCHARNUM)              then (swap STARTCHARNUM ENDCHARNUM))                    (* * Check whether we can use PCE.PC.TO.NS.ARRAY)          (SETQ CHARMAP.ARRAY (if (AND (ARRAYP PCE.PC.TO.NS.ARRAY)                                       (ZEROP (ARRAYORIG PCE.PC.TO.NS.ARRAY))                                       (IGEQ (ARRAYSIZE PCE.PC.TO.NS.ARRAY)                                             256))                                  then PCE.PC.TO.NS.ARRAY                                else NIL))                    (* * Gathering the correct chars is more complicated than simply looping from           STARTCHARNUM to ENDCHARNUM, because we don't want to grab any chars more than           one char beyond the last non-space char on each line.          Furthermore, the last char on each line should map to a CR, if it is a space.          All of this is designed to simulate the Tedit method of selecting chars, so           that users are not copy-selecting large amounts of blank chars at the end of           each line.)          [SETQ CHARLIST           (bind (CHARNUM _ STARTCHARNUM)                 (CHARS.PER.LINE _ (if (EQ \PCE.DISPLAY.MODE 'COLOR40)                                       then 40                                     else 80)) while (ILEQ CHARNUM ENDCHARNUM)              join              (PROG ((LAST.CHAR.ON.LINE (\PCE.WINDOW.LASTCHAR (IQUOTIENT CHARNUM CHARS.PER.LINE)))                     [FIRST.CHAR.ON.NEXT.LINE (ITIMES CHARS.PER.LINE (ADD1 (IQUOTIENT CHARNUM                                                                                   CHARS.PER.LINE]                     CHARS)                    (* Grab all of the chars on this line, and set CHARNUM to the first char on the           next line.)                    [SETQ CHARS                     (for X from CHARNUM to (IMIN ENDCHARNUM LAST.CHAR.ON.LINE)                        collect (CHARACTER                                 (PROG [(BYTE (LOGAND 255 (\DoveIO.ByteSwap (\GETBASE                                                                                    \PCE.DISPLAY.BASE                                                                                    X]                                       (RETURN (if (AND (EQP X LAST.CHAR.ON.LINE)                                                        (EQP BYTE (CHARCODE SPACE)))                                                   then                     (* if this is the last char on the line, and it is a space, turn it into a CR)                                                        (CHARCODE CR)                                                 elseif CHARMAP.ARRAY                                                   then                     (* if the user supplied a correct PCE.PC.TO.NS.ARRAY, and the appropriate value           is a smallp, use it, otherwise just use the byte untranslated.)                                                        (if (SMALLP (ELT CHARMAP.ARRAY BYTE))                                                          else BYTE)                                                 else BYTE]                    (SETQ CHARNUM FIRST.CHAR.ON.NEXT.LINE)                    (RETURN CHARS]          (RETURN (CONCATLIST CHARLIST])(\PCE.POS.TO.CHARNUM  [LAMBDA (POS)                                              (* mjs " 3-Jul-86 11:11")                    (* * POS is a position in the coordinate system of \PCE.WINDOW.          Returns the character number <a number from 0 to 1999> that this position is           pointing to, if any, else NIL. If this character is beyond the last char that           can be selected <according to \PCE.WINDOW.LASTCHAR> then that char num is           returned.)    (PROG ((LINE (IDIFFERENCE 24 (IQUOTIENT (fetch (POSITION YCOORD) of POS)                                        \PCE.FONTCHARHEIGHT)))           POS.ON.LINE CHARS.PER.LINE CHARWIDTH)          (if (EQ \PCE.DISPLAY.MODE 'COLOR40)              then (SETQ CHARS.PER.LINE 40)                   (SETQ CHARWIDTH (IPLUS \PCE.FONTCHARWIDTH \PCE.FONTCHARWIDTH))            else (SETQ CHARS.PER.LINE 80)                 (SETQ CHARWIDTH \PCE.FONTCHARWIDTH))          (SETQ POS.ON.LINE (IQUOTIENT (fetch (POSITION XCOORD) of POS)                                   CHARWIDTH))          (RETURN (if (AND (IGEQ LINE 0)                           (ILEQ LINE 24)                           (IGEQ POS.ON.LINE 0)                           (ILEQ POS.ON.LINE CHARS.PER.LINE))                      then (IMIN (IPLUS POS.ON.LINE (ITIMES CHARS.PER.LINE LINE))                                 (\PCE.WINDOW.LASTCHAR LINE))                    else NIL])(\PCE.WINDOW.COPYBUTTONEVENTFN  [LAMBDA (WINDOW)                                           (* mjs "15-Jul-86 16:34")                    (* * Handle copy-selecting characters out of the PC window.          Noop if WINDOW is not the PC window.)                    (* * Note%: There is one case where what you see in the PC window is not what           you copy out --- this is where you have just booted the 1186, and the PC window           is open showing the last state of the PC screen.          I could call REDISPLAYW here in this case, which would clear the PC window, but           in this case the user probably is more concerned with seeing the info on the           screen than having the result of the copy-select be absolutely consistant with           what is displayed on the screen.)    (if (AND \PCE.DISPLAY.MODE.HAS.TEXT (EQ WINDOW (PCE.GET.WINDOW)))        then        (\PCE.CHECK.INITIALIZED)        (RESETLST                    (* * Temporarily stop PC if it is running, so that it will not change the           display while we copy-selecting chars from it.)         [if (EQ T (PCE.RUN.STATE))             then (PCE.FREEZE)                  (RESETSAVE NIL '(PCE.UNFREEZE]                    (* * make sure that blinking chars are showing, and then temporarily disable           blinking chars)         (\PCE.BLINK.CHARS.SET T)         (RESETSAVE \PCE.BLINK.CHARS.ENABLED NIL)                    (* * \PCE.WINDOW.COPY.LOCK is used to ensure that the PC window correctly           reflects the state of the PC display memory <<<see the comments in           \PCE.DISPLAY.NotifyProcedure>>>. \PCE.WINDOW.LOCK ensures that noone else tries           to update the PC window.)         (WITH.MONITOR          \PCE.WINDOW.COPY.LOCK          (WITH.MONITOR           \PCE.WINDOW.LOCK           (PROG ((WINDOW.REGION (WINDOWPROP \PCE.WINDOW 'REGION))                  (STARTCHARNUM NIL)                  (ENDCHARNUM NIL)                  (EXTENDING.RIGHT.FLG T)                  CHARNUM)                                   (* init copy underline vars)                 (\PCE.DISPLAY.COPY.INIT.VARS)                    (* while any copy key is down, update the copy-select underline)                 (while (OR (SHIFTDOWNP 'SHIFT)                            (KEYDOWNP 'COPY))                    do (if (NOT (INSIDEP WINDOW.REGION LASTMOUSEX LASTMOUSEY))                           then (SCROLL.HANDLER \PCE.WINDOW)                         elseif (SETQ CHARNUM (\PCE.POS.TO.CHARNUM (CURSORPOSITION NIL \PCE.WINDOW)))                           then                     (* * Here is the logic of making and extending the copy selection%: If the left           or middle button is down, the current char only is selected.          The first time the right button is pressed after all buttons are up           <<<EXTENDING.RIGHT.FLG is NIL>>> we extend or truncate one side the current           selection depending on which side of the middle of the selection the mouse is           at. After the right button has been depressed <<<EXTENDING.RIGHT.FLG is T>>> it           can be used to extend or truncate the current selection.)                                (if (MOUSESTATE (OR LEFT MIDDLE))                                    then (SETQ STARTCHARNUM CHARNUM)                                         (SETQ ENDCHARNUM CHARNUM)                                         (SETQ EXTENDING.RIGHT.FLG T)                                  elseif (AND (MOUSESTATE RIGHT)                                              (SMALLP STARTCHARNUM)                                              (SMALLP ENDCHARNUM))                                    then (if EXTENDING.RIGHT.FLG                                             then (SETQ ENDCHARNUM CHARNUM)                                           else (PROG ((MIDDLECHARNUM (\PCE.WINDOW.MIDCHAR                                                                              STARTCHARNUM ENDCHARNUM)                                                              )                                                       (MINOLDCHARNUM (IMIN STARTCHARNUM ENDCHARNUM))                                                       (MAXOLDCHARNUM (IMAX STARTCHARNUM ENDCHARNUM))                                                       )                                                      (SETQ STARTCHARNUM                                                       (if (ILESSP CHARNUM MIDDLECHARNUM)                                                           then MAXOLDCHARNUM                                                         else MINOLDCHARNUM))                                                      (SETQ ENDCHARNUM CHARNUM)                                                      (SETQ EXTENDING.RIGHT.FLG T)))                                  else (SETQ EXTENDING.RIGHT.FLG NIL)))                     (* * Display current state of copy-select underline, and block.)                       (\PCE.DISPLAY.COPY.UNDERLINE STARTCHARNUM ENDCHARNUM)                       (BLOCK))                    (* * Erase copy-select underline.)                 (\PCE.DISPLAY.COPY.UNDERLINE NIL NIL)                    (* * Shove chars from selected range into kbd buffer)                 (BKSYSBUF (\PCE.PCDISPLAY.TO.NS.STRING STARTCHARNUM ENDCHARNUM])(\PCE.WINDOW.LASTCHAR  [LAMBDA (LINENUM)                                          (* mjs " 3-Jul-86 11:15")                    (* * Returns the charnum <from 0 to 1999> of the last copy-selectable character           on line number LINENUM <from 0 to 24>. The last copy-selectable char is defined           as the first space char after the last non-space char on the line.          If the line is all spaces, it is the first char.          If the last char on the line is not a space, it is the the last copy-selectable           char. Confused? The result is a selection scheme that looks like Tedit, where           selecting way to the right of a line selects the space ending the line.)                    (* * Since it takes time to scan the line to find the last non-space char, the           results for each line are cached in \PCE.WINDOW.LASTCHAR.ARRAY.          The value -1 indicates that the value hasn't been calculated for this line yet.)    [if (ILESSP (ELT \PCE.WINDOW.LASTCHAR.ARRAY LINENUM)               0)        then (PROG (FIRSTCHARNUM LASTCHARNUM CHARNUM)                   (if (EQ \PCE.DISPLAY.MODE 'COLOR40)                       then (SETQ FIRSTCHARNUM (ITIMES 40 LINENUM))                            (SETQ LASTCHARNUM (IPLUS 39 FIRSTCHARNUM))                     else (SETQ FIRSTCHARNUM (ITIMES 80 LINENUM))                          (SETQ LASTCHARNUM (IPLUS 79 FIRSTCHARNUM)))                   [SETQ CHARNUM (for X from LASTCHARNUM to FIRSTCHARNUM by -1                                    thereis (NEQ (CHARCODE SPACE)                                                 (LOGAND 255 (\DoveIO.ByteSwap (\GETBASE                                                                                     \PCE.DISPLAY.BASE                                                                                       X]                   (SETA \PCE.WINDOW.LASTCHAR.ARRAY LINENUM (if (NULL CHARNUM)                                                                then                                                              (* If line is all spaces, use the                                                              first char)                                                                     FIRSTCHARNUM                                                              elseif (EQP CHARNUM LASTCHARNUM)                                                                then                     (* If last char on line is not a space, use it.)                                                                     LASTCHARNUM                                                              else                                                              (* Otherwise, use 1+CHARNUM)                                                                   (ADD1 CHARNUM]    (ELT \PCE.WINDOW.LASTCHAR.ARRAY LINENUM])(\PCE.WINDOW.MIDCHAR  [LAMBDA (STARTCHARNUM ENDCHARNUM)                          (* mjs "15-Jul-86 16:48")                    (* * given the two character positions, returns the character position of the           character in the "middle" of the two, only counting characters that can be           copy-selected <i.e. not spaces at the end of lines>)    (PROG ((CHARS.PER.LINE (if (EQ \PCE.DISPLAY.MODE 'COLOR40)                               then 40                             else 80))           STARTCHAR.LINENUM ENDCHAR.LINENUM NUM.REAL.CHARS.BETWEEN MID.CHAR)          (if (ILESSP ENDCHARNUM STARTCHARNUM)              then (swap STARTCHARNUM ENDCHARNUM))          (SETQ STARTCHAR.LINENUM (IQUOTIENT STARTCHARNUM CHARS.PER.LINE))          (SETQ ENDCHAR.LINENUM (IQUOTIENT ENDCHARNUM CHARS.PER.LINE))                    (* * Calculate number of real chars between STARTCHARNUM and ENDCHARNUM           <inclusive>)          [SETQ NUM.REAL.CHARS.BETWEEN (for LINENUM from STARTCHAR.LINENUM to ENDCHAR.LINENUM                                          sum (ADD1 (IDIFFERENCE (IMIN (\PCE.WINDOW.LASTCHAR LINENUM)                                                                       ENDCHARNUM)                                                           (IMAX STARTCHARNUM (ITIMES LINENUM                                                                                      CHARS.PER.LINE]                    (* * Calculate middle char by scanning through lines, and subtracting number of           real chars on each line from NUM.CHARS.TO.ADD until this is less than the           number of real chars on the line.)          (for LINENUM from STARTCHAR.LINENUM to ENDCHAR.LINENUM bind (NUM.CHARS.TO.ADD _                                                                             (IQUOTIENT                                                                                NUM.REAL.CHARS.BETWEEN                                                                                     2))                                                                      REAL.CHARS.ON.LINE             until [ILEQ NUM.CHARS.TO.ADD (SETQ REAL.CHARS.ON.LINE                                           (ADD1 (IDIFFERENCE (IMIN (\PCE.WINDOW.LASTCHAR LINENUM)                                                                    ENDCHARNUM)                                                        (IMAX STARTCHARNUM (ITIMES LINENUM                                                                                   CHARS.PER.LINE]             do (SETQ NUM.CHARS.TO.ADD (IDIFFERENCE NUM.CHARS.TO.ADD REAL.CHARS.ON.LINE))             finally (SETQ MID.CHAR (IPLUS (IMAX (ITIMES LINENUM CHARS.PER.LINE)                                                 STARTCHARNUM)                                           NUM.CHARS.TO.ADD)))          (RETURN MID.CHAR]))(RPAQ? \PCE.WINDOW.LASTCHAR.ARRAY )(RPAQ? \PCE.WINDOW.COPY.STARTCHARNUM )(RPAQ? \PCE.WINDOW.COPY.ENDCHARNUM )(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.WINDOW.LASTCHAR.ARRAY \PCE.WINDOW.COPY.STARTCHARNUM \PCE.WINDOW.COPY.ENDCHARNUM))(* PC fonts)(RPAQ? \PCE.FONTCHARWIDTH )(RPAQ? \PCE.FONTCHARHEIGHT )(RPAQ? \PCE.FONTCHARDESCENT )(RPAQ \PCE.PCToNSCharArray (READARRAY 256 (QUOTE SMALLPOSP) 0))(32 61407 61151 61132 61133 61390 61387 61286 60993 8830 61013 8553 8554 213 61141 61135 61119 61118 61109 61050 182 167 61150 61110 173 175 174 172 61149 61266 8741 8743 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 60986 61741 61925 61873 61859 61863 61857 61864 61869 61874 61877 61872 61892 61888 61886 61735 61736 61745 241 225 61905 61908 61903 61921 61919 61933 61780 61797 162 163 165 61348 61346 61858 61887 61904 61920 61900 61772 227 235 191 61034 61290 189 188 161 171 187 61024 61310 61025 61412 10281 10320 10321 10322 10323 10324 10325 10326 10327 10328 10329 10276 10278 10282 10280 10279 61413 61414 10330 10331 10332 10333 10334 10335 10336 10337 10338 10339 10340 10341 10342 10343 10344 10345 10346 10347 10348 10277 10275 61113 61114 61116 61115 61117 9825 251 9796 9843 9814 9846 9839 9848 9818 9803 9821 9829 8551 9850 9830 61270 61299 177 8550 8549 61165 61166 184 61305 176 183 199 61308 64936 178 60970 61217 NIL)(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.FONTCHARWIDTH \PCE.FONTCHARHEIGHT \PCE.FONTCHARDESCENT \PCE.PCToNSCharArray))(* masks for sensing bits in REQBITS field of display FCB -- each bit specifies a different action to be performed)(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.DISPLAY.disableVideo 1)(RPAQQ \PCE.DISPLAY.dirtyBitsDirty 2)(RPAQQ \PCE.DISPLAY.modeControlSet 4)(RPAQQ \PCE.DISPLAY.pageChange 8)(RPAQQ \PCE.DISPLAY.colorChange 16)(RPAQQ \PCE.DISPLAY.cursorLocationChange 32)(RPAQQ \PCE.DISPLAY.cursorShapeChange 64)(RPAQQ \PCE.DISPLAY.extraWork 128)(CONSTANTS \PCE.DISPLAY.disableVideo \PCE.DISPLAY.dirtyBitsDirty \PCE.DISPLAY.modeControlSet        \PCE.DISPLAY.pageChange \PCE.DISPLAY.colorChange \PCE.DISPLAY.cursorLocationChange        \PCE.DISPLAY.cursorShapeChange \PCE.DISPLAY.extraWork))(* special values used to configure PC for mono or color display)(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.DISPLAY.pseudo80Or40Sw 4)(RPAQQ \PCE.DISPLAY.pseudoMono 8)(CONSTANTS \PCE.DISPLAY.pseudo80Or40Sw \PCE.DISPLAY.pseudoMono))(* special display modes specifying that mono blinking should be enabled or disabled)(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.DISPLAY.MonoBlinkEnabled 41)(RPAQQ \PCE.DISPLAY.MonoBlinkDisabled 9)(CONSTANTS \PCE.DISPLAY.MonoBlinkEnabled \PCE.DISPLAY.MonoBlinkDisabled))(* PC memory addresses of the beginning of mono display memory and color display memory.)(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.DISPLAY.COLOR.ADDR 753664)(RPAQQ \PCE.DISPLAY.MONO.ADDR 720896)(CONSTANTS \PCE.DISPLAY.COLOR.ADDR \PCE.DISPLAY.MONO.ADDR))(* 4-bit numbers corresponding to each "color" that can be specified in the character attribute byte, which contains one blinking bit, 3 bits of background color, and four bits of fourground color.)(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.DISPLAY.COLOR.black 0)(RPAQQ \PCE.DISPLAY.COLOR.blue 1)(RPAQQ \PCE.DISPLAY.COLOR.green 2)(RPAQQ \PCE.DISPLAY.COLOR.cyan 3)(RPAQQ \PCE.DISPLAY.COLOR.red 4)(RPAQQ \PCE.DISPLAY.COLOR.magenta 5)(RPAQQ \PCE.DISPLAY.COLOR.brown 6)(RPAQQ \PCE.DISPLAY.COLOR.white 7)(RPAQQ \PCE.DISPLAY.COLOR.gray 8)(RPAQQ \PCE.DISPLAY.COLOR.lightBlue 9)(RPAQQ \PCE.DISPLAY.COLOR.lightGreen 10)(RPAQQ \PCE.DISPLAY.COLOR.lightCyan 11)(RPAQQ \PCE.DISPLAY.COLOR.lightRed 12)(RPAQQ \PCE.DISPLAY.COLOR.lightMagenta 13)(RPAQQ \PCE.DISPLAY.COLOR.yellow 14)(RPAQQ \PCE.DISPLAY.COLOR.intenseWhite 15)(CONSTANTS \PCE.DISPLAY.COLOR.black \PCE.DISPLAY.COLOR.blue \PCE.DISPLAY.COLOR.green        \PCE.DISPLAY.COLOR.cyan \PCE.DISPLAY.COLOR.red \PCE.DISPLAY.COLOR.magenta        \PCE.DISPLAY.COLOR.brown \PCE.DISPLAY.COLOR.white \PCE.DISPLAY.COLOR.gray        \PCE.DISPLAY.COLOR.lightBlue \PCE.DISPLAY.COLOR.lightGreen \PCE.DISPLAY.COLOR.lightCyan        \PCE.DISPLAY.COLOR.lightRed \PCE.DISPLAY.COLOR.lightMagenta \PCE.DISPLAY.COLOR.yellow        \PCE.DISPLAY.COLOR.intenseWhite))(* display mode numbers used to specify different type of color displays)(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.DISPLAY.Text40x25BWVal 44)(RPAQQ \PCE.DISPLAY.Text40x25BWNoBlinkingVal 12)(RPAQQ \PCE.DISPLAY.Text40x25ColorVal 40)(RPAQQ \PCE.DISPLAY.Text40x25ColorNoBlinkingVal 8)(RPAQQ \PCE.DISPLAY.Text80x25BWVal 45)(RPAQQ \PCE.DISPLAY.Text80x25BWNoBlinkingVal 13)(RPAQQ \PCE.DISPLAY.Text80x25ColorVal 41)(RPAQQ \PCE.DISPLAY.Text80x25ColorNoBlinkingVal 9)(RPAQQ \PCE.DISPLAY.GraphMedResBWVal 46)(RPAQQ \PCE.DISPLAY.GraphMedResBWAltVal 14)(RPAQQ \PCE.DISPLAY.GraphMedResColorVal 42)(RPAQQ \PCE.DISPLAY.GraphMedResColorAltVal 10)(RPAQQ \PCE.DISPLAY.GraphHiResVal 30)(RPAQQ \PCE.DISPLAY.GraphHiResAltVal 62)(CONSTANTS \PCE.DISPLAY.Text40x25BWVal \PCE.DISPLAY.Text40x25BWNoBlinkingVal        \PCE.DISPLAY.Text40x25ColorVal \PCE.DISPLAY.Text40x25ColorNoBlinkingVal        \PCE.DISPLAY.Text80x25BWVal \PCE.DISPLAY.Text80x25BWNoBlinkingVal        \PCE.DISPLAY.Text80x25ColorVal \PCE.DISPLAY.Text80x25ColorNoBlinkingVal        \PCE.DISPLAY.GraphMedResBWVal \PCE.DISPLAY.GraphMedResBWAltVal        \PCE.DISPLAY.GraphMedResColorVal \PCE.DISPLAY.GraphMedResColorAltVal        \PCE.DISPLAY.GraphHiResVal \PCE.DISPLAY.GraphHiResAltVal))(* for each shade <white-black>, tells which number shade this is <0-16>. This is used when setting up \PCE.DISPLAY.COLOR.BACK.GRAYBIT)(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.DISPLAY.white 0)(RPAQQ \PCE.DISPLAY.g1 1)(RPAQQ \PCE.DISPLAY.g2 2)(RPAQQ \PCE.DISPLAY.g4 3)(RPAQQ \PCE.DISPLAY.g6 4)(RPAQQ \PCE.DISPLAY.half 5)(RPAQQ \PCE.DISPLAY.g10 6)(RPAQQ \PCE.DISPLAY.g12 7)(RPAQQ \PCE.DISPLAY.g14 8)(RPAQQ \PCE.DISPLAY.g15 9)(RPAQQ \PCE.DISPLAY.black 10)(CONSTANTS \PCE.DISPLAY.white \PCE.DISPLAY.g1 \PCE.DISPLAY.g2 \PCE.DISPLAY.g4 \PCE.DISPLAY.g6        \PCE.DISPLAY.half \PCE.DISPLAY.g10 \PCE.DISPLAY.g12 \PCE.DISPLAY.g14 \PCE.DISPLAY.g15        \PCE.DISPLAY.black))(* 16-bit textures used for each shade of gray)(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.DISPLAY.BRICK.white 0)(RPAQQ \PCE.DISPLAY.BRICK.g1 64)(RPAQQ \PCE.DISPLAY.BRICK.g2 4160)(RPAQQ \PCE.DISPLAY.BRICK.g4 5140)(RPAQQ \PCE.DISPLAY.BRICK.g6 18970)(RPAQQ \PCE.DISPLAY.BRICK.half 23130)(RPAQQ \PCE.DISPLAY.BRICK.g10 55930)(RPAQQ \PCE.DISPLAY.BRICK.g12 60395)(RPAQQ \PCE.DISPLAY.BRICK.g14 32735)(RPAQQ \PCE.DISPLAY.BRICK.g15 65503)(RPAQQ \PCE.DISPLAY.BRICK.black 65535)(CONSTANTS \PCE.DISPLAY.BRICK.white \PCE.DISPLAY.BRICK.g1 \PCE.DISPLAY.BRICK.g2 \PCE.DISPLAY.BRICK.g4        \PCE.DISPLAY.BRICK.g6 \PCE.DISPLAY.BRICK.half \PCE.DISPLAY.BRICK.g10 \PCE.DISPLAY.BRICK.g12        \PCE.DISPLAY.BRICK.g14 \PCE.DISPLAY.BRICK.g15 \PCE.DISPLAY.BRICK.black))(PUTPROPS PCEDISPLAY COPYRIGHT ("Xerox Corporation" 1986 1987))(DECLARE%: DONTCOPY  (FILEMAP (NIL (12379 17719 (PCE.GET.WINDOW 12389 . 12620) (PCE.INVERT.WINDOW 12622 . 13156) (PCE.INVERT.WINDOW.STATE 13158 . 13320) (PCE.PCTERMINAL.ARRAY 13322 . 13905) (PCE.SET.WINDOW 13907 . 17717)) (17845 29442 (\PCE.STUFF.WINDOW 17855 . 20463) (\PCE.WINDOW.ATTACH.PROCESS 20465 . 21118) (\PCE.WINDOW.DETACH.PROCESS 21120 . 22233) (\PCE.WINDOW.OPENFN 22235 . 22667) (\PCE.WINDOW.REPAINTFN 22669 . 23596) (\PCE.WINDOW.RESHAPEFN 23598 . 24100) (\PCE.WINDOW.SCROLLFN 24102 . 29440)) (29679 34699 (\PCE.DISPLAY.Configure 29689 . 30797) (\PCE.DISPLAY.Init 30799 . 31755) (\PCE.DISPLAY.Notify 31757 . 32431) (\PCE.DISPLAY.NotifyProcedure 32433 . 34266) (\PCE.DISPLAY.Terminate 34268 . 34697)) (34993 101915 (\PCE.ALLOC.BITMAPS 35003 . 41189) (\PCE.CREATE.BBT 41191 . 42104) (\PCE.CREATE.FONT.BM 42106 . 43439) (\PCE.CREATE.WIDE.FONT.BM 43441 . 44270) (\PCE.DECODE.TEXT.ATTRIBUTES 44272 . 46130) (\PCE.DISPLAY.ALLOC.SHADES 46132 . 54125) (\PCE.DISPLAY.INIT.MEMORY 54127 . 56009) (\PCE.DISPLAY.REPAINT.GRAPHICS 56011 . 66425) (\PCE.DISPLAY.REPAINT.TEXT 66427 . 87805) (\PCE.DISPLAY.UPDATE 87807 . 94408) (\PCE.DISPLAY.UPDATE.GRAPHICS 94410 . 96555) (\PCE.DISPLAY.UPDATE.TEXT 96557 . 101913)) (104112 115678 (\PCE.BLINK 104122 . 105696) (\PCE.BLINK.CARET.SET 105698 . 106105) (\PCE.BLINK.CHARS 106107 . 107176) (\PCE.BLINK.CHARS.SET 107178 . 107964) (\PCE.CARET.DRAW 107966 . 111263) (\PCE.CARET.INVERT 111265 . 112536) (\PCE.CARET.MOVE 112538 . 113870) (\PCE.CARET.RESHAPE 113872 . 114440) (\PCE.CARET.SET.TYPE 114442 . 115676)) (116539 139136 (\PCE.COPY.UNDERLINE.DRAW 116549 . 119868) (\PCE.DISPLAY.COPY.INIT.VARS 119870 . 120917) (\PCE.DISPLAY.COPY.UNDERLINE 120919 . 121786) (\PCE.PCDISPLAY.TO.NS.STRING 121788 . 126064) (\PCE.POS.TO.CHARNUM 126066 . 127562) (\PCE.WINDOW.COPYBUTTONEVENTFN 127564 . 133159) (\PCE.WINDOW.LASTCHAR 133161 . 136145) (\PCE.WINDOW.MIDCHAR 136147 . 139134)))))STOP