(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)(FILECREATED "18-Apr-88 15:02:41" {ERIS}<PCE2.0>LYRIC>PCEFLOPPY.;3 57501        changes to%:  (VARS PCEFLOPPYCOMS)                    (FNS PCE.CREATE.FLOPPYFILE \PCE.FLOPPY.Configure)      previous date%: "13-Feb-87 14:25:07" {ERIS}<PCE2.0>LYRIC>PCEFLOPPY.;1)(* "Copyright (c) 1986, 1987, 1988 by Xerox Corporation.  All rights reserved.")(PRETTYCOMPRINT PCEFLOPPYCOMS)(RPAQQ PCEFLOPPYCOMS        ([DECLARE%: FIRST (P                                  (* ;                                              "turn off PCE processes if already loaded and running")                            (NLSETQ (\PCE.TERMINATE]        (DECLARE%: DONTCOPY (FILES (SOURCE LOADFROM)                                   DOVEFLOPPY DOVEMISC))        (FNS PCE.CREATE.FLOPPYFILE)        (FNS \PCE.FLOPPY.DriveStatus \PCE.FLOPPY.Format \PCE.FLOPPY.GetMemBufferPtr              \PCE.FLOPPY.InterruptStatus \PCE.FLOPPY.LongByteSwap \PCE.FLOPPY.MoveData              \PCE.FLOPPY.NoDrive \PCE.FLOPPY.Read \PCE.FLOPPY.ReadID \PCE.FLOPPY.ReadOnly              \PCE.FLOPPY.Recalibrate \PCE.FLOPPY.Seek \PCE.FLOPPY.SeekToCylinder              \PCE.FLOPPY.StoreResultBytes \PCE.FLOPPY.Unformatted \PCE.FLOPPY.Unimplemented              \PCE.FLOPPY.Write)        (FNS \PCE.FLOPPY.Configure \PCE.FLOPPY.Init \PCE.FLOPPY.Notify \PCE.FLOPPY.NotifyProcedure              \PCE.FLOPPY.NO.VIRTUAL.Notify \PCE.FLOPPY.Terminate)        (INITVARS (\PCE.FLOPPY.Condition)               (\PCE.FLOPPY.Process)               (\PCE.FLOPPY.gotUpNotify)               (\PCE.FLOPPY.status 0)               (\PCE.FLOPPY.VIRTUALS.OPEN)               (\PCE.FLOPPY.DRIVE.ARRAY (ARRAY 4 NIL NIL 0)))        (GLOBALVARS \PCE.FLOPPY.Condition \PCE.FLOPPY.Process \PCE.FLOPPY.DRIVE.ARRAY                \PCE.FLOPPY.gotUpNotify \PCE.FLOPPY.status \PCE.FLOPPY.VIRTUALS.OPEN)        (INITVARS (\PCE.FLOPPY.st0 0)               (\PCE.FLOPPY.st1 0)               (\PCE.FLOPPY.st2 0)               (\PCE.FLOPPY.st3 0)               (\PCE.FLOPPY.id.cylinder)               (\PCE.FLOPPY.id.head)               (\PCE.FLOPPY.id.sector)               (\PCE.FLOPPY.id.next)               (\PCE.FLOPPY.previousCylinder 0))        (GLOBALVARS \PCE.FLOPPY.st0 \PCE.FLOPPY.st1 \PCE.FLOPPY.st2 \PCE.FLOPPY.st3                \PCE.FLOPPY.id.cylinder \PCE.FLOPPY.id.head \PCE.FLOPPY.id.sector \PCE.FLOPPY.id.next                \PCE.FLOPPY.previousCylinder)        (INITVARS (\PCE.FLOPPY.IOCB.PTR)               (\PCE.FLOPPY.COMMAND.PTR)               (\PCE.FLOPPY.RESULT.PTR)               (\PCE.FLOPPY.head)               (\PCE.FLOPPY.drive)               (\PCE.FLOPPY.command)               (\PCE.FLOPPY.drive.object))        (GLOBALVARS \PCE.FLOPPY.IOCB.PTR \PCE.FLOPPY.COMMAND.PTR \PCE.FLOPPY.RESULT.PTR                \PCE.FLOPPY.head \PCE.FLOPPY.drive \PCE.FLOPPY.command \PCE.FLOPPY.drive.object)        (DECLARE%: DONTCOPY (RECORDS FloppyBuffer FloppyDrive)               (MACROS GetFloppyCommandByte PutFloppyResultByte Set-st0 Set-st1))        (COMS (CONSTANTS \PCE.FLOPPY.HeadBit \PCE.FLOPPY.DriveNumberBits \PCE.FLOPPY.CommandBits                      \PCE.FLOPPY.InvalidCmndError \PCE.FLOPPY.OperationCompleted                      \PCE.FLOPPY.MultiTrackBit \PCE.FLOPPY.IncrementDestination)                                                             (* ; "codes for floppy commands")              (CONSTANTS \PCE.FLOPPY.fdcFormatTrackCommand \PCE.FLOPPY.fdcReadDataCommand                      \PCE.FLOPPY.fdcReadDeletedDataCommand \PCE.FLOPPY.fdcReadIDCommand                      \PCE.FLOPPY.fdcReadTrackCommand \PCE.FLOPPY.fdcRecalibrateCommand                      \PCE.FLOPPY.fdcScanEqualCommand \PCE.FLOPPY.fdcScanHighOrEqualCommand                      \PCE.FLOPPY.fdcScanLowOrEqualCommand \PCE.FLOPPY.fdcSeekCommand                      \PCE.FLOPPY.fdcSenseDriveStatusCommand                      \PCE.FLOPPY.fdcSenseInterruptStatusCommand \PCE.FLOPPY.fdcSpecifyCommand                      \PCE.FLOPPY.fdcWriteDataCommand \PCE.FLOPPY.fdcWriteDeletedDataCommand)                        (* ;; "bit masks used for manipulating bits of \PCE.FLOPPY.st0 \PCE.FLOPPY.st1 \PCE.FLOPPY.st2 \PCE.FLOPPY.st3")              (CONSTANTS \PCE.FLOPPY.st0.InterruptType.MASK                      \PCE.FLOPPY.st0.InterruptType.NormalTermination                      \PCE.FLOPPY.st0.InterruptType.AbnormalTermination                      \PCE.FLOPPY.st0.InterruptType.InvalidCommandIssued                      \PCE.FLOPPY.st0.InterruptType.ReadyLineChangedDuringCommandExecution                      \PCE.FLOPPY.st0.SeekEnd \PCE.FLOPPY.st0.EquipmentCheckError                      \PCE.FLOPPY.st0.NotReadyError \PCE.FLOPPY.st0.HeadAddress                      \PCE.FLOPPY.st0.DriveNumber.MASK)              (CONSTANTS \PCE.FLOPPY.st1.EndOfTrackError \PCE.FLOPPY.st1.NotUsed1                      \PCE.FLOPPY.st1.DataError \PCE.FLOPPY.st1.OverRunError \PCE.FLOPPY.st1.NotUsed2                      \PCE.FLOPPY.st1.SectorNotFoundError \PCE.FLOPPY.st1.WriteProtectError                      \PCE.FLOPPY.st1.MissingAddressMarkError)              (CONSTANTS \PCE.FLOPPY.st2.NotUsed0 \PCE.FLOPPY.st2.ControlMark                      \PCE.FLOPPY.st2.DataErrorInDataField \PCE.FLOPPY.st2.WrongCylinder                      \PCE.FLOPPY.st2.ScanEqualHit \PCE.FLOPPY.st2.ScanNotSatisfied                      \PCE.FLOPPY.st2.BadCylinder \PCE.FLOPPY.st2.MissingAddressMarkInDataField)              (CONSTANTS \PCE.FLOPPY.st3.Fault \PCE.FLOPPY.st3.WriteProtected \PCE.FLOPPY.st3.Ready                      \PCE.FLOPPY.st3.Track0 \PCE.FLOPPY.st3.TwoSided \PCE.FLOPPY.st3.theHeadAddress                      \PCE.FLOPPY.st3.theDriveNumber.MASK))))(DECLARE%: FIRST                                                              (* ;                                              "turn off PCE processes if already loaded and running")(NLSETQ (\PCE.TERMINATE)))(DECLARE%: DONTCOPY (FILESLOAD (SOURCE LOADFROM)       DOVEFLOPPY DOVEMISC))(DEFINEQ(PCE.CREATE.FLOPPYFILE  [LAMBDA (NAME SIZE)                                   (* ; "Edited 14-Apr-88 18:12 by murage")          (* ;; "NAME is the name of the virtual floppy file to be created")          (* ;; "SIZE is one of")          (* ;; "    360 -- create a 360Kb floppy (40 tracks, 2 sides, 9 sectors)")          (* ;; "    NIL -- (the same)")          (* ;; "    1.2 -- create a 1.2Mb floppy (AT Size, 80 tracks, 2 sides, 15 sectors)")    (LET [(SIZE-IN-BYTES (COND                            ((NULL SIZE)                             (ITIMES 40 2 9 512))                            ((= SIZE 360)                             (ITIMES 40 2 9 512))                            ((= SIZE 1.2)                             (ITIMES 80 2 15 512))                            (T (ITIMES 40 2 9 512]         (CL:WITH-OPEN-STREAM (OUTSTREAM (OPENSTREAM NAME 'OUTPUT 'NEW))                (SETFILEPTR OUTSTREAM (SUB1 SIZE-IN-BYTES))                (\BOUT OUTSTREAM 0]))(DEFINEQ(\PCE.FLOPPY.DriveStatus  [LAMBDA NIL                                                (* mjs "17-Jul-86 10:38")                    (* * returns the status of the drive)    (SETQ \PCE.FLOPPY.st3 0)    (SETQ \PCE.FLOPPY.st3 (LOGOR (GetFloppyCommandByte 2)                                 7))    (SETQ \PCE.FLOPPY.st3 (BITSET \PCE.FLOPPY.st3 \PCE.FLOPPY.st3.Ready))    (SETQ \PCE.FLOPPY.st3 (BITSET \PCE.FLOPPY.st3 \PCE.FLOPPY.st3.TwoSided))    (PutFloppyResultByte 1 \PCE.FLOPPY.st3])(\PCE.FLOPPY.Format  [LAMBDA NIL                                                (* mjs "22-Jul-86 09:41")                    (* * Formats a single track of the virtual floppy, by adjusting the virtual           floppy backing file size <if necessary>, and filling the track with a given           byte. The track is specified by the last cylinder seeked, and \PCE.FLOPPY.head.          The number of sectors per tack to use is passed from the PC, but unfortunately,           the PC does not pass the number of sides to use.          Therefore, we always do two-sided formatting, and allocate the backing file           accordingly, even if the PC only uses half of the tracks.)                    (* * See Format in PCEFloppy.mesa and FormatTrack in VirtualFDC.mesa)    (PROG ((STREAM (fetch (FloppyDrive STREAM) of \PCE.FLOPPY.drive.object))           ENCODED.BYTES.PER.SECTOR SECTORS.PER.TRACK FILL.BYTE SIDES.PER.FLOPPY CURRENT.FILE.LENGTH            DESIRED.FILE.LENGTH)          (SETQ \PCE.FLOPPY.st0 0)          (SETQ \PCE.FLOPPY.st1 0)          (SETQ \PCE.FLOPPY.st2 0)          (if (OR (\PCE.FLOPPY.NoDrive)                  (\PCE.FLOPPY.ReadOnly))              then (RETURN))          (SETQ ENCODED.BYTES.PER.SECTOR (GetFloppyCommandByte 3))          (SETQ SECTORS.PER.TRACK (GetFloppyCommandByte 4))          (SETQ FILL.BYTE (GetFloppyCommandByte 6))          (SETQ SIDES.PER.FLOPPY 2)          [if [NOT (AND (EQP ENCODED.BYTES.PER.SECTOR 2)                        (MEMB SECTORS.PER.TRACK '(8 9 17))                        (MEMB SIDES.PER.FLOPPY '(1 2))                        (NOT (AND (EQP SECTORS.PER.TRACK 17)                                  (EQP SIDES.PER.FLOPPY 1]              then                                           (* bad formatting parameters)                   (Set-st0 InterruptType AbnormalTermination)                   (Set-st0 EquipmentCheckError T)            else (SETQ CURRENT.FILE.LENGTH (GETFILEINFO STREAM 'LENGTH))                 (SETQ DESIRED.FILE.LENGTH (ITIMES 512 SECTORS.PER.TRACK SIDES.PER.FLOPPY 40))                 (if (NOT (EQUAL CURRENT.FILE.LENGTH DESIRED.FILE.LENGTH))                     then                     (* If changing the length of the file, do it slowly, blocking frequently)                          (if (ILESSP CURRENT.FILE.LENGTH DESIRED.FILE.LENGTH)                              then (for LEN from CURRENT.FILE.LENGTH to DESIRED.FILE.LENGTH                                      by 512 do (BLOCK)                                                (SETFILEINFO STREAM 'LENGTH LEN))                            elseif (IGREATERP CURRENT.FILE.LENGTH DESIRED.FILE.LENGTH)                              then (for LEN from CURRENT.FILE.LENGTH to DESIRED.FILE.LENGTH                                      by -512 do (BLOCK)                                                 (SETFILEINFO STREAM 'LENGTH LEN)))                          (SETFILEINFO STREAM 'LENGTH DESIRED.FILE.LENGTH))                 (with FloppyDrive \PCE.FLOPPY.drive.object (SETQ numberSides SIDES.PER.FLOPPY)                       (SETQ sectorsPerTrack SECTORS.PER.TRACK)                       (SETQ unformatted NIL))               (* set fileptr to beginning of track)                 [SETFILEPTR STREAM (ITIMES SECTORS.PER.TRACK (IPLUS \PCE.FLOPPY.head                                                                     (ITIMES 40 (fetch (FloppyDrive                                                                                                                                                                            cylinderUnderHead                                                                                        )                                                                                   of                                                                              \PCE.FLOPPY.drive.object                                                                                       ]                                                              (* fill track with FILL.BYTE <blocking                                                              every so often>)                 (for SECTOR from 1 to SECTORS.PER.TRACK                    do (BLOCK)                       (for X from 1 to 512 do (BOUT STREAM FILL.BYTE]          (Set-st0 HeadAddress \PCE.FLOPPY.head)          (\PCE.FLOPPY.StoreResultBytes])(\PCE.FLOPPY.GetMemBufferPtr  [LAMBDA NIL                                                (* mjs "17-Jul-86 12:44")                    (* * Returns a ptr to a buffer in PC real memory starting at the PC location           specified by the DATAADDRESS field of the virtual floppy IOCB.          Because this can start on a non-word-aligned byte, it is returned as an           FloppyBuffer record, which includes a byte offset.)    (PROG (pcAddress)          (SETQ pcAddress (\PCE.FLOPPY.LongByteSwap (\GETBASEFIXP (LOCF (fetch (DOVEFLOPPYIOCB                                                                                       DATAADDRESS)                                                                           of \PCE.FLOPPY.IOCB.PTR))                                                           0)))          (RETURN (create FloppyBuffer                         MemoryPointer _ (\PCE.GET.PC.PTR pcAddress)                         ByteOffset _ (LOGAND pcAddress 1])(\PCE.FLOPPY.InterruptStatus  [LAMBDA NIL                                                (* mjs "17-Jul-86 11:00")                    (* * Return status of previous command)                    (* * Note%: I consider it very peculiar that this command uses the values of           \PCE.FLOPPY.st0 and \PCE.FLOPPY.previousCylinder because these are always reset           to zero before any of the floppy commands is called.)    (PutFloppyResultByte 1 \PCE.FLOPPY.st0)    (PutFloppyResultByte 2 \PCE.FLOPPY.previousCylinder)    (SETQ \PCE.FLOPPY.st0 0)    (SETQ \PCE.FLOPPY.previousCylinder 0])(\PCE.FLOPPY.LongByteSwap  [LAMBDA (NUM)                                              (* mjs "17-Jul-86 12:29")                    (* * take 32-bit fixp with bytes ABCD, and change it to DCBA)    (IPLUS (\DoveIO.ByteSwap (LOGAND (LRSH NUM 16)                                    65535))           (LLSH (\DoveIO.ByteSwap (LOGAND NUM 65535))                 16])(\PCE.FLOPPY.MoveData  [LAMBDA (OPERATION MEMPTR NUMBYTES MULTITRACK)             (* mjs "21-Jul-86 11:43")                    (* * Copies NUMBYTES bytes between the PC memory buffer specified by MEMPTR and           the virtual floppy pages specified by \PCE.FLOPPY.drive and \PCE.FLOPPY.id.          If MULTITRACK is non-NIL, multi-track file ops <on the same cylinder> are           allowed.)    (PROG ((STREAM (fetch (FloppyDrive STREAM) of \PCE.FLOPPY.drive.object))           (NUMSIDES (fetch (FloppyDrive numberSides) of \PCE.FLOPPY.drive.object))           (SECTORS.PER.TRACK (fetch (FloppyDrive sectorsPerTrack) of \PCE.FLOPPY.drive.object))           (READFLG (EQ OPERATION 'READ))           FILEPTR bytesLeftOnTrack bytesToTransfer)          [SETQ FILEPTR (ITIMES 512 (IPLUS (SUB1 \PCE.FLOPPY.id.sector)                                           (ITIMES SECTORS.PER.TRACK (IPLUS \PCE.FLOPPY.id.head                                                                            (ITIMES NUMSIDES                                                                               \PCE.FLOPPY.id.cylinder                                                                                   ]          [SETQ bytesLeftOnTrack (ITIMES 512 (ADD1 (IDIFFERENCE SECTORS.PER.TRACK                                                           \PCE.FLOPPY.id.sector]                    (* * if the specified track is on head 0 of a two-sides floppy, and MULTITRACK           is non-NIL, then we can do a transfer accross the track boundary.          Since the head-1 track is stored right after the head-0 track in the virtual           floppy backing file, all we need to do is to extend the size of the max           permissable transfer.)          [if (AND (EQP NUMSIDES 2)                   (EQP \PCE.FLOPPY.id.head 0)                   MULTITRACK)              then (SETQ bytesLeftOnTrack (IPLUS bytesLeftOnTrack (ITIMES 512 SECTORS.PER.TRACK]          (SETQ bytesToTransfer (IMIN NUMBYTES bytesLeftOnTrack))          (if (IGREATERP bytesToTransfer 0)              then (if (NULL MEMPTR)                       then                     (* if the mem pointer is NIL, don't transfer the data)                            (SETFILEPTR STREAM (IPLUS FILEPTR bytesToTransfer))                     else (SETFILEPTR STREAM FILEPTR)                          (if READFLG                              then (\BINS STREAM (fetch (FloppyBuffer MemoryPointer) of MEMPTR)                                          (fetch (FloppyBuffer ByteOffset) of MEMPTR)                                          bytesToTransfer)                            else (\BOUTS STREAM (fetch (FloppyBuffer MemoryPointer) of MEMPTR)                                        (fetch (FloppyBuffer ByteOffset) of MEMPTR)                                        bytesToTransfer)                     (* on write, fill any unwritten portion of a \PCE.FLOPPY.id.sector with zeroes.)                                 (if (NOT (EVENP bytesToTransfer 512))                                     then (for X from 1 to (IMOD bytesToTransfer 512)                                             do (BOUT STREAM 0])(\PCE.FLOPPY.NoDrive  [LAMBDA NIL                                                (* mjs "21-Jul-86 11:47")                    (* * Checks if the drive accessed has a floppy diskette.          If no diskette then sets up st0 & st1 to indicate error and returns T)    (if (NULL \PCE.FLOPPY.drive.object)        then (Set-st0 InterruptType AbnormalTermination)             (Set-st0 NotReadyError T)             (Set-st1 SectorNotFoundError T)             (\PCE.FLOPPY.StoreResultBytes)             T      else NIL])(\PCE.FLOPPY.Read  [LAMBDA NIL                                                (* mjs "21-Jul-86 11:48")                    (* * Reads some number of sectors)    (PROG (multiTrack PCMEMPTR NUMBYTES)          (SETQ \PCE.FLOPPY.st0 0)          (SETQ \PCE.FLOPPY.st1 0)          (SETQ \PCE.FLOPPY.st2 0)          (if (OR (\PCE.FLOPPY.NoDrive)                  (\PCE.FLOPPY.Unformatted))              then (RETURN))          (SETQ multiTrack (BITTEST (GetFloppyCommandByte 1)                                  \PCE.FLOPPY.MultiTrackBit))          (SETQ \PCE.FLOPPY.id.cylinder (GetFloppyCommandByte 3))          (SETQ \PCE.FLOPPY.id.head (GetFloppyCommandByte 4))          (SETQ \PCE.FLOPPY.id.sector (GetFloppyCommandByte 5))          (SETQ \PCE.FLOPPY.id.next (GetFloppyCommandByte 6))          (SETQ NUMBYTES (\DoveIO.ByteSwap (fetch (DOVEFLOPPYIOCB BYTESTOTRANSFER) of                                                                                  \PCE.FLOPPY.IOCB.PTR                                                  )))          (SETQ PCMEMPTR (if (BITTEST (\DoveIO.ByteSwap (fetch (DOVEFLOPPYIOCB FIRSTDMACONTROLWORD)                                                           of \PCE.FLOPPY.IOCB.PTR))                                    \PCE.FLOPPY.IncrementDestination)                             then (\PCE.FLOPPY.GetMemBufferPtr)                           else                     (* if this is a verify operation then set block pointer to NIL)                                NIL))          (\PCE.FLOPPY.MoveData 'READ PCMEMPTR NUMBYTES multiTrack)          (Set-st0 HeadAddress \PCE.FLOPPY.id.head)          (\PCE.FLOPPY.StoreResultBytes])(\PCE.FLOPPY.ReadID  [LAMBDA NIL                                                (* mjs "21-Jul-86 11:45")                    (* * reads the ID of the first sector in this track)    (PROG NIL          (SETQ \PCE.FLOPPY.st0 0)          (SETQ \PCE.FLOPPY.st1 0)          (SETQ \PCE.FLOPPY.st2 0)          (if (OR (\PCE.FLOPPY.NoDrive)                  (\PCE.FLOPPY.Unformatted))              then (RETURN))          (SETQ \PCE.FLOPPY.id.cylinder (fetch (FloppyDrive cylinderUnderHead) of                                                                              \PCE.FLOPPY.drive.object                                               ))          (SETQ \PCE.FLOPPY.id.head \PCE.FLOPPY.head)          (SETQ \PCE.FLOPPY.id.sector 1)          (SETQ \PCE.FLOPPY.id.next 512)          (Set-st0 HeadAddress \PCE.FLOPPY.id.head)          (\PCE.FLOPPY.StoreResultBytes])(\PCE.FLOPPY.ReadOnly  [LAMBDA NIL                                                (* mjs "21-Jul-86 11:47")                    (* * Checks is the current virtual floppy is marked read-only, setting the           error bit and returning T if so.)    (if (fetch (FloppyDrive writeProtected) of \PCE.FLOPPY.drive.object)        then (Set-st0 InterruptType AbnormalTermination)             (Set-st1 WriteProtectError T)             (\PCE.FLOPPY.StoreResultBytes)             T      else NIL])(\PCE.FLOPPY.Recalibrate  [LAMBDA NIL                                                (* mjs "21-Jul-86 11:40")                    (* * Recalibrate is equivalent to a Seek to cylinder 0)    (SETQ \PCE.FLOPPY.st0 0)                    (* * Pretend recal is sucessful even without a diskette, since this is what           happens in the case of the real physical drive)    (if \PCE.FLOPPY.drive.object        then (\PCE.FLOPPY.Seek \PCE.FLOPPY.drive.object 0))    (Set-st0 SeekEnd T)    (Set-st0 HeadAddress \PCE.FLOPPY.head)    (Set-st0 DriveNumber \PCE.FLOPPY.drive)    (SETQ \PCE.FLOPPY.previousCylinder 0])(\PCE.FLOPPY.Seek  [LAMBDA (DRIVE CYLINDER)                                   (* mjs "18-Jul-86 14:26")    (replace (FloppyDrive cylinderUnderHead) of DRIVE with CYLINDER])(\PCE.FLOPPY.SeekToCylinder  [LAMBDA NIL                                                (* mjs "21-Jul-86 11:40")    (PROG ((CYLINDER (GetFloppyCommandByte 3)))          (SETQ \PCE.FLOPPY.st0 0)                    (* * Pretend seek is sucessful even without a diskette, since this is what           happens in the case of the real physical drive)          (if \PCE.FLOPPY.drive.object              then (\PCE.FLOPPY.Seek \PCE.FLOPPY.drive.object CYLINDER))          (Set-st0 SeekEnd T)          (Set-st0 HeadAddress \PCE.FLOPPY.head)          (Set-st0 DriveNumber \PCE.FLOPPY.drive)          (SETQ \PCE.FLOPPY.previousCylinder CYLINDER])(\PCE.FLOPPY.StoreResultBytes  [LAMBDA NIL                                                (* mjs "21-Jul-86 09:48")                    (* * The results of the requested operation are built in global variables like           st0. This proc stores them in the IOCB)    (PutFloppyResultByte 1 \PCE.FLOPPY.st0)    (PutFloppyResultByte 2 \PCE.FLOPPY.st1)    (PutFloppyResultByte 3 \PCE.FLOPPY.st2)    (PutFloppyResultByte 4 \PCE.FLOPPY.id.cylinder)    (PutFloppyResultByte 5 \PCE.FLOPPY.id.head)    (PutFloppyResultByte 6 \PCE.FLOPPY.id.sector)    (PutFloppyResultByte 7 \PCE.FLOPPY.id.next])(\PCE.FLOPPY.Unformatted  [LAMBDA NIL                                                (* mjs "21-Jul-86 11:47")                    (* * Checks if the specified virtual drive contains a formatted floppy, and           returns T if unformatted.)    (if (fetch (FloppyDrive unformatted) of \PCE.FLOPPY.drive.object)        then (Set-st0 InterruptType AbnormalTermination)             (Set-st1 SectorNotFoundError T)             (\PCE.FLOPPY.StoreResultBytes)             T      else NIL])(\PCE.FLOPPY.Unimplemented  [LAMBDA NIL                                                (* mjs "21-Jul-86 11:19")                    (* * While the FDC hardware supports 15 commands the VirtualFDC supports only a           subset of these 15.0 If the PCE-186 attempts to execute a command not supported           by the VirtualFDC then Unimplemented proc gets invoked.          A error is returned in the IOCB to tell PCE-186 that the request failed.)    (PROG NIL          (Set-st0 InterruptType ReadyLineChangedDuringCommandExecution)          (Set-st1 SectorNotFoundError T)          (\PCE.FLOPPY.StoreResultBytes])(\PCE.FLOPPY.Write  [LAMBDA NIL                                                (* mjs "21-Jul-86 14:03")                    (* * Reads some number of sectors)    (PROG (multiTrack PCMEMPTR NUMBYTES)          (SETQ \PCE.FLOPPY.st0 0)          (SETQ \PCE.FLOPPY.st1 0)          (SETQ \PCE.FLOPPY.st2 0)          (if (OR (\PCE.FLOPPY.NoDrive)                  (\PCE.FLOPPY.Unformatted)                  (\PCE.FLOPPY.ReadOnly))              then (RETURN))          (SETQ multiTrack (BITTEST (GetFloppyCommandByte 1)                                  \PCE.FLOPPY.MultiTrackBit))          (SETQ \PCE.FLOPPY.id.cylinder (GetFloppyCommandByte 3))          (SETQ \PCE.FLOPPY.id.head (GetFloppyCommandByte 4))          (SETQ \PCE.FLOPPY.id.sector (GetFloppyCommandByte 5))          (SETQ \PCE.FLOPPY.id.next (GetFloppyCommandByte 6))          (SETQ NUMBYTES (\DoveIO.ByteSwap (fetch (DOVEFLOPPYIOCB BYTESTOTRANSFER) of                                                                                  \PCE.FLOPPY.IOCB.PTR                                                  )))          (SETQ PCMEMPTR (\PCE.FLOPPY.GetMemBufferPtr))          (\PCE.FLOPPY.MoveData 'WRITE PCMEMPTR NUMBYTES multiTrack)          (Set-st0 HeadAddress \PCE.FLOPPY.head)          (\PCE.FLOPPY.StoreResultBytes]))(DEFINEQ(\PCE.FLOPPY.Configure  [LAMBDA (CONFIG)                                       (* ; "Edited 18-Apr-88 13:53 by jds")(* ;;; "Configures the FCB for the floppy drive.  See FloppyConfig and FloppyBoot in PCEFloppy.mesa")(* ;;; "note: currently, only configures for 1 real drive, mapped to drive 0, and no virtual drives")    (\PCE.FLOPPY.Terminate)    (PROG [(MEMSIZE (if (LISTGET CONFIG 'MEMORYSIZE)                      else 640))           (MAXFLOPPYDRIVE (SUB1 (if (MEMB (LISTGET CONFIG 'FLOPPYDRIVES)                                               '(1 2 3 4))                                     then (LISTGET CONFIG 'FLOPPYDRIVES)                                   else                  (* ;                                                      "if FLOPPYDRIVES is not 1-4, the default is 1")                                         1)))           (PHYSICALFLOPPYDRIVE (LISTGET CONFIG 'PHYSICALFLOPPY](* ;;; "if PHYSICALFLOPPYDRIVE is not 0-3, then if NIL it defaults to 0, otherwise to NONE.  The physical floppy is also disabled if PHYSICALFLOPPYDRIVE is greater than the number of floppy drives.")          [if [NOT (MEMB PHYSICALFLOPPYDRIVE '(0 1 2 3]              then (SETQ PHYSICALFLOPPYDRIVE (if (NULL PHYSICALFLOPPYDRIVE)                                                     then 0                                                   else 'NONE]          (if (AND (FIXP PHYSICALFLOPPYDRIVE)                       (IGREATERP PHYSICALFLOPPYDRIVE MAXFLOPPYDRIVE))              then (SETQ PHYSICALFLOPPYDRIVE 'NONE))          (\DOVEFLOPPY.RESET)          (\DOVEFLOPPY.SETCONTEXT 'DOUBLE 512)          [\PUTBASEFIXP (LOCF (fetch (\PCE.FLOPPY.FCB pceMemSize) of \PCE.FLOPPY.FCBPTR))                 0                 (\PCE.FLOPPY.LongByteSwap (SUB1 (ITIMES 1024 (if (LISTGET CONFIG                                                                                 'MEMORYSIZE)                                                                    else 640](* ;;; "If the user opts for the physical floppy drive then pceHasRealDrive is set to 1, otherwise 0.0 The user also chooses which drive (A/B/C/D) gets associated with the physical floppy.  If physical=A, pFlopLogicalDrive=0 and pDORRealDrive=10H.  If physical=B, pFlopLogicalDrive=1 and pDORRealDrive=20H.  If physical=C, pFlopLogicalDrive=2 and pDORRealDrive=40H.  If physical=D, pFlopLogicalDrive=3 and pDORRealDrive=80H.  If physical=none, pFlopLogicalDrive=0 and pDORRealDrive=0.")          (with \PCE.FLOPPY.FCB \PCE.FLOPPY.FCBPTR       (* ;                                                            "assuming physical drive is at FDC # 0")                 (SETQ pFDCRealDrive 0)                 (SETQ pceHasRealDrive (if (FIXP PHYSICALFLOPPYDRIVE)                                           then 1                                         else 0))                 (SETQ pFlopLogicalDrive (if (FIXP PHYSICALFLOPPYDRIVE)                                             then PHYSICALFLOPPYDRIVE                                           else 0))                 (SETQ pDORRealDrive (SELECTQ PHYSICALFLOPPYDRIVE                                         (0 16)                                         (1 32)                                         (2 64)                                         (3 128)                                         0)))(* ;;; "Open backing files for virtual floppies")(* ;;; "\PCE.FLOPPY.VIRTUALS.OPEN is T if there are any virtual floppy backing files open.")          (SETQ \PCE.FLOPPY.VIRTUALS.OPEN NIL)          (for FLOPPYDRIVE from 0 to MAXFLOPPYDRIVE as VIRTUALFILE.PROPNAME             in '(FLOPPYFILE0 FLOPPYFILE1 FLOPPYFILE2 FLOPPYFILE3) as                                                                         VIRTUAL.WRITEPROTECT.PROPNAME             in '(FLOPPYPROTECTED0 FLOPPYPROTECTED1 FLOPPYPROTECTED2 FLOPPYPROTECTED3)             unless (EQ FLOPPYDRIVE PHYSICALFLOPPYDRIVE) bind STREAM LEN SIDES.PER.FLOPPY                                                                    SECTORS.PER.TRACK WRITEPROTECTED             do [SETQ WRITEPROTECTED (NOT (NULL (LISTGET CONFIG VIRTUAL.WRITEPROTECT.PROPNAME]                   (SETQ STREAM (\PCE.OPENSTREAM (LISTGET CONFIG VIRTUALFILE.PROPNAME)                                       (if WRITEPROTECTED                                           then 'INPUT                                         else 'BOTH)                                       'OLD))                   (WHENCLOSE STREAM 'CLOSEALL 'NO)                   (SETQ LEN (GETFILEINFO STREAM 'LENGTH))                   (if (EQP LEN 163840)                       then (SETQ SIDES.PER.FLOPPY 1)                             (SETQ SECTORS.PER.TRACK 8)                     elseif (EQP LEN 184320)                       then (SETQ SIDES.PER.FLOPPY 1)                             (SETQ SECTORS.PER.TRACK 9)                     elseif (EQP LEN 327680)                       then (SETQ SIDES.PER.FLOPPY 2)                             (SETQ SECTORS.PER.TRACK 8)                     elseif (EQP LEN 368640)                       then (SETQ SIDES.PER.FLOPPY 2)                             (SETQ SECTORS.PER.TRACK 9)                     elseif (EQP LEN 696320)                       then (SETQ SIDES.PER.FLOPPY 2)                             (SETQ SECTORS.PER.TRACK 17)                     else (SETQ SIDES.PER.FLOPPY NIL)                           (SETQ SECTORS.PER.TRACK NIL))                   (SETA \PCE.FLOPPY.DRIVE.ARRAY FLOPPYDRIVE                         (create FloppyDrive                                STREAM _ STREAM                                cylinderUnderHead _ 0                                numberSides _ SIDES.PER.FLOPPY                                sectorsPerTrack _ SECTORS.PER.TRACK                                unformatted _ (NULL (AND SIDES.PER.FLOPPY SECTORS.PER.TRACK))                                writeProtected _ WRITEPROTECTED))                   (SETQ \PCE.FLOPPY.VIRTUALS.OPEN T])(\PCE.FLOPPY.Init  [LAMBDA NIL                                                (* mjs "28-Jul-86 10:45")                    (* * Sets the FLOPPY agent variables, and spawns the FLOPPY agent process, if           there is at least one virtual floppy backing file open.          \PCE.FLOPPY.Condition and \PCE.FLOPPY.gotUpNotify are used to signal           \PCE.FLOPPY.NotifyProcedure process that an up notify has been received.          \PCE.FLOPPY.status is the status of last FLOPPY operation)    (if \PCE.FLOPPY.VIRTUALS.OPEN        then (SETQ \PCE.FLOPPY.Condition (CREATE.EVENT 'FLOPPY.Condition))             (SETQ \PCE.FLOPPY.gotUpNotify NIL)             (SETQ \PCE.FLOPPY.status 0)             (SETQ \PCE.FLOPPY.Process (ADD.PROCESS (LIST (FUNCTION \PCE.FLOPPY.NotifyProcedure))                                              'NAME                                              'PCE-FLOPPY                                              'AFTEREXIT                                              'DELETE                                              'RESTARTABLE                                              'HARDRESET                                              'RESTARTFORM                                              (LIST (FUNCTION \PCE.FLOPPY.Init])(\PCE.FLOPPY.Notify  [LAMBDA NIL                                                (* mjs "16-Jul-86 13:58")                    (* * Notifies the FLOPPY agent that an up notify has been received.)    (if \PCE.FLOPPY.VIRTUALS.OPEN        then (SETQ \PCE.FLOPPY.gotUpNotify T)             (if (TYPENAMEP \PCE.FLOPPY.Condition 'EVENT)                 then (NOTIFY.EVENT \PCE.FLOPPY.Condition)               elseif \PCE.DEBUG.FLG                 then (\PCE.SYSTEM.ERROR "\PCE.FLOPPY.Condition not an event" \PCE.FLOPPY.Condition))      else                     (* if there are no virtual floppies, handle the "SenseInterruptState" command.)           (\PCE.FLOPPY.NO.VIRTUAL.Notify])(\PCE.FLOPPY.NotifyProcedure  [LAMBDA NIL                                                (* mjs "28-Jul-86 14:26")                    (* * This is the floppy agent procedure, that is spawned as a process.          It loops forever, waiting for an up notify, and handling the request)                    (* * See NotifyProcedure in PCEFloppy.mesa)    (PROG (FDCCOMMANDPTR)                    (* * set up pointers inside IOCB inside of the floppy FCB)          (SETQ \PCE.FLOPPY.IOCB.PTR (LOCF (fetch (\PCE.FLOPPY.FCB pceIOCB) of \PCE.FLOPPY.FCBPTR)))          (SETQ FDCCOMMANDPTR (LOCF (fetch (DOVEFLOPPYIOCB FDCCOMMANDS) of \PCE.FLOPPY.IOCB.PTR)))          (SETQ \PCE.FLOPPY.COMMAND.PTR (LOCF (fetch (DOVEFLOPPYFDCCOMMAND COMMANDBYTES) of                                                                                         FDCCOMMANDPTR                                                     )))          (SETQ \PCE.FLOPPY.RESULT.PTR (LOCF (fetch (DOVEFLOPPYFDCCOMMAND RESULTBYTES) of                                                                                         FDCCOMMANDPTR                                                    )))                    (* * Acknowledge any pending floppy command by returning the bad-command error.          This keeps the PC from waiting forever for an floppy operation to complete, if           a hard reset occurs in the middle of it.)          (PutFloppyResultByte 1 \PCE.FLOPPY.InvalidCmndError)          (replace (DOVEFLOPPYIOCB OPERATIONSTATE) of \PCE.FLOPPY.IOCB.PTR with                                                                        \PCE.FLOPPY.OperationCompleted                 )          (\DoveIO.NotifyIOP (fetch (\PCE.FLOPPY.FCB pceFloppyWorkMask) of \PCE.FLOPPY.FCBPTR))                    (* * now, loop forever, handling floppy commands)          (while T do                     (* * wait for an up notify)                      (until \PCE.FLOPPY.gotUpNotify do (AWAIT.EVENT \PCE.FLOPPY.Condition))                      (SETQ \PCE.FLOPPY.gotUpNotify NIL)                     (* * Clear status variables)                      (SETQ \PCE.FLOPPY.st0 0)                      (SETQ \PCE.FLOPPY.st1 0)                      (SETQ \PCE.FLOPPY.st2 0)                      (SETQ \PCE.FLOPPY.st3 0)                      (SETQ \PCE.FLOPPY.id.cylinder 0)                      (SETQ \PCE.FLOPPY.id.head 0)                      (SETQ \PCE.FLOPPY.id.sector 0)                      (SETQ \PCE.FLOPPY.id.next 0)                      (SETQ \PCE.FLOPPY.previousCylinder 0)                     (* * process floppy command)                      (SETQ \PCE.FLOPPY.head (if (BITTEST \PCE.FLOPPY.HeadBit (GetFloppyCommandByte                                                                               2))                                                 then 1                                               else 0))                      (SETQ \PCE.FLOPPY.drive (LOGAND \PCE.FLOPPY.DriveNumberBits (                                                                                 GetFloppyCommandByte                                                                                   2)))                      (SETQ \PCE.FLOPPY.drive.object (ELT \PCE.FLOPPY.DRIVE.ARRAY \PCE.FLOPPY.drive))                      (SETQ \PCE.FLOPPY.command (LOGAND \PCE.FLOPPY.CommandBits (GetFloppyCommandByte                                                                                 1)))                      (SELECTC \PCE.FLOPPY.command                          (\PCE.FLOPPY.fdcFormatTrackCommand                                (\PCE.FLOPPY.Format))                          (\PCE.FLOPPY.fdcReadDataCommand                                (\PCE.FLOPPY.Read))                          (\PCE.FLOPPY.fdcReadDeletedDataCommand                                (\PCE.FLOPPY.Unimplemented))                          (\PCE.FLOPPY.fdcReadIDCommand                                (\PCE.FLOPPY.ReadID))                          (\PCE.FLOPPY.fdcReadTrackCommand                                (\PCE.FLOPPY.Read))                          (\PCE.FLOPPY.fdcRecalibrateCommand                                (\PCE.FLOPPY.Recalibrate))                          (\PCE.FLOPPY.fdcScanEqualCommand                                (\PCE.FLOPPY.Unimplemented))                          (\PCE.FLOPPY.fdcScanHighOrEqualCommand                                (\PCE.FLOPPY.Unimplemented))                          (\PCE.FLOPPY.fdcScanLowOrEqualCommand                                (\PCE.FLOPPY.Unimplemented))                          (\PCE.FLOPPY.fdcSeekCommand                                (\PCE.FLOPPY.SeekToCylinder))                          (\PCE.FLOPPY.fdcSenseDriveStatusCommand                                (\PCE.FLOPPY.DriveStatus))                          (\PCE.FLOPPY.fdcSenseInterruptStatusCommand                                (\PCE.FLOPPY.InterruptStatus))                          (\PCE.FLOPPY.fdcSpecifyCommand     (* Specify command is noop)                               NIL)                          (\PCE.FLOPPY.fdcWriteDataCommand                                (\PCE.FLOPPY.Write))                          (\PCE.FLOPPY.fdcWriteDeletedDataCommand                                (\PCE.FLOPPY.Unimplemented))                          (PROGN (if \PCE.DEBUG.FLG                                     then (\PCE.SYSTEM.ERROR "Unimplemented virtual floppy command"                                                 (LIST \PCE.FLOPPY.command \PCE.FLOPPY.drive                                                        \PCE.FLOPPY.head)))                    (* if user types RETURN from error, return InvalidCmndError to PC)                                 (PutFloppyResultByte 1 \PCE.FLOPPY.InvalidCmndError)                                 (SETQ \PCE.FLOPPY.st0 \PCE.FLOPPY.InvalidCmndError)))                      (with DOVEFLOPPYFDCCOMMAND FDCCOMMANDPTR (SETQ NUMBEROFCOMMANDBYTESWRITTEN                                                                 NUMBEROFCOMMANDBYTES)                            (SETQ NUMBEROFRESULTBYTESREAD NUMBEROFRESULTBYTES))                      (replace (DOVEFLOPPYIOCB OPERATIONSTATE) of \PCE.FLOPPY.IOCB.PTR with                                                                        \PCE.FLOPPY.OperationCompleted                             )                      (\DoveIO.NotifyIOP (fetch (\PCE.FLOPPY.FCB pceFloppyWorkMask) of                                                                                    \PCE.FLOPPY.FCBPTR                                                ])(\PCE.FLOPPY.NO.VIRTUAL.Notify  [LAMBDA NIL                                                (* mjs "16-Jul-86 14:39")                    (* * This is a very minimal implementation of a virtual floppy notify watcher,           that just implements the "SenseInterruptState" command.          See performTask and InterruptStatus in PCEFloppy.mesa)                    (* * This is called if a virtual floppy command is received, and there are no           virtual floppies defined. Actually, no virtual floppy commands should be           received in this case, However, when booting from the ERD for the second and           subsequent times, the virtual floppy command "SenseInterruptState" is sent up,           even though the PC is configured not to have virtual floppies.          Sending down 0 as a result seems to keep it happy.          Conjecture%: this is a long-standing bug in the IOP code, which OSD never           detected because they have always had virtual floppy agent implemented.)                    (* * this function checks the virtual floppy command, to make sure that it is a           "SenseInterruptState" command. If not, an error occurs, displaying the bad           virtual floppy command, so that we will know if the virtual floppy starts           sending other commands.)                    (* * note%: This function uses the records DOVEFLOPPYIOCB and           DOVEFLOPPYFDCCOMMAND from the lisp system file DOVEFLOPPY)    (PROG ((IOCBPTR (LOCF (fetch (\PCE.FLOPPY.FCB pceIOCB) of \PCE.FLOPPY.FCBPTR)))           FDCCOMMANDPTR COMMANDBYTESPTR RESULTBYTESPTR COMMAND DRIVE HEAD)          (SETQ FDCCOMMANDPTR (LOCF (fetch (DOVEFLOPPYIOCB FDCCOMMANDS) of IOCBPTR)))          (SETQ COMMANDBYTESPTR (LOCF (fetch (DOVEFLOPPYFDCCOMMAND COMMANDBYTES) of FDCCOMMANDPTR)))          (SETQ RESULTBYTESPTR (LOCF (fetch (DOVEFLOPPYFDCCOMMAND RESULTBYTES) of FDCCOMMANDPTR)))          (SETQ COMMAND (LOGAND 31 (\GETBASEBYTE COMMANDBYTESPTR 0)))          (SETQ DRIVE (LOGAND 3 (\GETBASEBYTE COMMANDBYTESPTR 1)))          (SETQ HEAD (if (LOGAND 4 (\GETBASEBYTE COMMANDBYTESPTR 1))                         then 1                       else 0))          (SELECTQ COMMAND              (8                                             (* sense interrupt status)                 (\PUTBASEBYTE RESULTBYTESPTR 0 0)                 (\PUTBASEBYTE RESULTBYTESPTR 1 0))              (PROGN (if \PCE.DEBUG.FLG                         then (\PCE.SYSTEM.ERROR "Unimplemented virtual floppy command"                                     (LIST COMMAND DRIVE HEAD)))                    (* if user types RETURN from error, return InvalidCmndError to PC)                     (\PUTBASEBYTE RESULTBYTESPTR 0 128)))          (with DOVEFLOPPYFDCCOMMAND FDCCOMMANDPTR (SETQ NUMBEROFCOMMANDBYTESWRITTEN                                                     NUMBEROFCOMMANDBYTES)                (SETQ NUMBEROFRESULTBYTESREAD NUMBEROFRESULTBYTES))          (replace (DOVEFLOPPYIOCB OPERATIONSTATE) of IOCBPTR with 6)          (\DoveIO.NotifyIOP (fetch (\PCE.FLOPPY.FCB pceFloppyWorkMask) of \PCE.FLOPPY.FCBPTR])(\PCE.FLOPPY.Terminate  [LAMBDA NIL                                                (* mjs "18-Jul-86 10:50")                    (* * Delete Floppy agent process, reset Floppy agent variables, and close           Floppy backing file.)    (if (PROCESSP \PCE.FLOPPY.Process)        then                                                 (* flushes Floppy process)             (DEL.PROCESS \PCE.FLOPPY.Process))    (SETQ \PCE.FLOPPY.Condition NIL)    (SETQ \PCE.FLOPPY.gotUpNotify NIL)    (SETQ \PCE.FLOPPY.status 0)    (SETQ \PCE.FLOPPY.Process NIL)    (for X from 0 to 3 when (ELT \PCE.FLOPPY.DRIVE.ARRAY X)       do                                                    (* close all floppy streams)          (CLOSEF? (fetch (FloppyDrive STREAM) of (ELT \PCE.FLOPPY.DRIVE.ARRAY X)))          (SETA \PCE.FLOPPY.DRIVE.ARRAY X NIL))    (SETQ \PCE.FLOPPY.VIRTUALS.OPEN NIL]))(RPAQ? \PCE.FLOPPY.Condition )(RPAQ? \PCE.FLOPPY.Process )(RPAQ? \PCE.FLOPPY.gotUpNotify )(RPAQ? \PCE.FLOPPY.status 0)(RPAQ? \PCE.FLOPPY.VIRTUALS.OPEN )(RPAQ? \PCE.FLOPPY.DRIVE.ARRAY (ARRAY 4 NIL NIL 0))(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.FLOPPY.Condition \PCE.FLOPPY.Process \PCE.FLOPPY.DRIVE.ARRAY \PCE.FLOPPY.gotUpNotify        \PCE.FLOPPY.status \PCE.FLOPPY.VIRTUALS.OPEN))(RPAQ? \PCE.FLOPPY.st0 0)(RPAQ? \PCE.FLOPPY.st1 0)(RPAQ? \PCE.FLOPPY.st2 0)(RPAQ? \PCE.FLOPPY.st3 0)(RPAQ? \PCE.FLOPPY.id.cylinder )(RPAQ? \PCE.FLOPPY.id.head )(RPAQ? \PCE.FLOPPY.id.sector )(RPAQ? \PCE.FLOPPY.id.next )(RPAQ? \PCE.FLOPPY.previousCylinder 0)(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.FLOPPY.st0 \PCE.FLOPPY.st1 \PCE.FLOPPY.st2 \PCE.FLOPPY.st3 \PCE.FLOPPY.id.cylinder        \PCE.FLOPPY.id.head \PCE.FLOPPY.id.sector \PCE.FLOPPY.id.next \PCE.FLOPPY.previousCylinder))(RPAQ? \PCE.FLOPPY.IOCB.PTR )(RPAQ? \PCE.FLOPPY.COMMAND.PTR )(RPAQ? \PCE.FLOPPY.RESULT.PTR )(RPAQ? \PCE.FLOPPY.head )(RPAQ? \PCE.FLOPPY.drive )(RPAQ? \PCE.FLOPPY.command )(RPAQ? \PCE.FLOPPY.drive.object )(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \PCE.FLOPPY.IOCB.PTR \PCE.FLOPPY.COMMAND.PTR \PCE.FLOPPY.RESULT.PTR \PCE.FLOPPY.head        \PCE.FLOPPY.drive \PCE.FLOPPY.command \PCE.FLOPPY.drive.object))(DECLARE%: DONTCOPY (DECLARE%: EVAL@COMPILE(RECORD FloppyBuffer (MemoryPointer . ByteOffset))(RECORD FloppyDrive (STREAM cylinderUnderHead numberSides sectorsPerTrack writeProtected                                unformatted)))(DECLARE%: EVAL@COMPILE [PUTPROPS GetFloppyCommandByte MACRO ((BYTE)                                      (\GETBASEBYTE \PCE.FLOPPY.COMMAND.PTR (SUB1 BYTE](PUTPROPS PutFloppyResultByte MACRO ((BYTE VAL)                                     (\PUTBASEBYTE \PCE.FLOPPY.RESULT.PTR (SUB1 BYTE)                                            VAL)))[PUTPROPS Set-st0 MACRO (X (LIST 'SETQ '\PCE.FLOPPY.st0                                 (COND ((SELECTQ (CAR X)                                               [(SeekEnd EquipmentCheckError NotReadyError)                                                (COND ((MEMB (CADR X)                                                             '(NIL T))                                                       `(%, (COND ((NULL (CADR X))                                                                   'BITCLEAR)                                                                  (T 'BITSET))                                                            \PCE.FLOPPY.st0 %, (PACK* '                                                                                     \PCE.FLOPPY.st0.                                                                                      (CAR X]                                               [InterruptType (COND                                                               ((MEMB (CADR X)                                                                      '(NormalTermination                                                                               AbnormalTermination                                                                               InvalidCommandIssued                                                                ReadyLineChangedDuringCommandExecution                                                                              ))                                                                `(LOGOR (BITCLEAR \PCE.FLOPPY.st0                                                                    \PCE.FLOPPY.st0.InterruptType.MASK                                                                               )                                                                        %,                                                                        (PACK* '                                                                       \PCE.FLOPPY.st0.InterruptType.                                                                               (CADR X]                                               [HeadAddress `(if (ZEROP %, (CADR X))                                                                 then                                                                 (BITCLEAR \PCE.FLOPPY.st0                                                                         \PCE.FLOPPY.st0.HeadAddress)                                                                 else                                                                 (BITSET \PCE.FLOPPY.st0                                                                         \PCE.FLOPPY.st0.HeadAddress]                                               [DriveNumber `(LOGOR (BITCLEAR \PCE.FLOPPY.st0                                                                      \PCE.FLOPPY.st0.DriveNumber.MASK                                                                           )                                                                    (LOGAND                                                                      \PCE.FLOPPY.st0.DriveNumber.MASK                                                                            %, (CADR X]                                               NIL))                                       (T (ERROR "Set-st0 cannot handle this expression" X][PUTPROPS Set-st1 MACRO (X (LIST 'SETQ '\PCE.FLOPPY.st1                                 (COND ((SELECTQ (CAR X)                                               [(EndOfTrackError NotUsed1 DataError OverRunError                                                        NotUsed2 SectorNotFoundError WriteProtectError                                                        MissingAddressMarkError)                                                (COND ((MEMB (CADR X)                                                             '(NIL T))                                                       `(%, (COND ((NULL (CADR X))                                                                   'BITCLEAR)                                                                  (T 'BITSET))                                                            \PCE.FLOPPY.st1 %, (PACK* '                                                                                     \PCE.FLOPPY.st1.                                                                                      (CAR X]                                               NIL))                                       (T (ERROR "Set-st1 cannot handle this expression" X]))(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.FLOPPY.HeadBit 4)(RPAQQ \PCE.FLOPPY.DriveNumberBits 3)(RPAQQ \PCE.FLOPPY.CommandBits 31)(RPAQQ \PCE.FLOPPY.InvalidCmndError 128)(RPAQQ \PCE.FLOPPY.OperationCompleted 6)(RPAQQ \PCE.FLOPPY.MultiTrackBit 128)(RPAQQ \PCE.FLOPPY.IncrementDestination 8192)(CONSTANTS \PCE.FLOPPY.HeadBit \PCE.FLOPPY.DriveNumberBits \PCE.FLOPPY.CommandBits        \PCE.FLOPPY.InvalidCmndError \PCE.FLOPPY.OperationCompleted \PCE.FLOPPY.MultiTrackBit        \PCE.FLOPPY.IncrementDestination))(* ; "codes for floppy commands")(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.FLOPPY.fdcFormatTrackCommand 13)(RPAQQ \PCE.FLOPPY.fdcReadDataCommand 6)(RPAQQ \PCE.FLOPPY.fdcReadDeletedDataCommand 12)(RPAQQ \PCE.FLOPPY.fdcReadIDCommand 10)(RPAQQ \PCE.FLOPPY.fdcReadTrackCommand 2)(RPAQQ \PCE.FLOPPY.fdcRecalibrateCommand 7)(RPAQQ \PCE.FLOPPY.fdcScanEqualCommand 17)(RPAQQ \PCE.FLOPPY.fdcScanHighOrEqualCommand 29)(RPAQQ \PCE.FLOPPY.fdcScanLowOrEqualCommand 25)(RPAQQ \PCE.FLOPPY.fdcSeekCommand 15)(RPAQQ \PCE.FLOPPY.fdcSenseDriveStatusCommand 4)(RPAQQ \PCE.FLOPPY.fdcSenseInterruptStatusCommand 8)(RPAQQ \PCE.FLOPPY.fdcSpecifyCommand 3)(RPAQQ \PCE.FLOPPY.fdcWriteDataCommand 5)(RPAQQ \PCE.FLOPPY.fdcWriteDeletedDataCommand 9)(CONSTANTS \PCE.FLOPPY.fdcFormatTrackCommand \PCE.FLOPPY.fdcReadDataCommand        \PCE.FLOPPY.fdcReadDeletedDataCommand \PCE.FLOPPY.fdcReadIDCommand        \PCE.FLOPPY.fdcReadTrackCommand \PCE.FLOPPY.fdcRecalibrateCommand        \PCE.FLOPPY.fdcScanEqualCommand \PCE.FLOPPY.fdcScanHighOrEqualCommand        \PCE.FLOPPY.fdcScanLowOrEqualCommand \PCE.FLOPPY.fdcSeekCommand        \PCE.FLOPPY.fdcSenseDriveStatusCommand \PCE.FLOPPY.fdcSenseInterruptStatusCommand        \PCE.FLOPPY.fdcSpecifyCommand \PCE.FLOPPY.fdcWriteDataCommand        \PCE.FLOPPY.fdcWriteDeletedDataCommand))(* ;; "bit masks used for manipulating bits of \PCE.FLOPPY.st0 \PCE.FLOPPY.st1 \PCE.FLOPPY.st2 \PCE.FLOPPY.st3")(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.FLOPPY.st0.InterruptType.MASK 192)(RPAQQ \PCE.FLOPPY.st0.InterruptType.NormalTermination 0)(RPAQQ \PCE.FLOPPY.st0.InterruptType.AbnormalTermination 64)(RPAQQ \PCE.FLOPPY.st0.InterruptType.InvalidCommandIssued 128)(RPAQQ \PCE.FLOPPY.st0.InterruptType.ReadyLineChangedDuringCommandExecution 192)(RPAQQ \PCE.FLOPPY.st0.SeekEnd 32)(RPAQQ \PCE.FLOPPY.st0.EquipmentCheckError 16)(RPAQQ \PCE.FLOPPY.st0.NotReadyError 8)(RPAQQ \PCE.FLOPPY.st0.HeadAddress 4)(RPAQQ \PCE.FLOPPY.st0.DriveNumber.MASK 3)(CONSTANTS \PCE.FLOPPY.st0.InterruptType.MASK \PCE.FLOPPY.st0.InterruptType.NormalTermination        \PCE.FLOPPY.st0.InterruptType.AbnormalTermination        \PCE.FLOPPY.st0.InterruptType.InvalidCommandIssued        \PCE.FLOPPY.st0.InterruptType.ReadyLineChangedDuringCommandExecution \PCE.FLOPPY.st0.SeekEnd        \PCE.FLOPPY.st0.EquipmentCheckError \PCE.FLOPPY.st0.NotReadyError \PCE.FLOPPY.st0.HeadAddress        \PCE.FLOPPY.st0.DriveNumber.MASK))(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.FLOPPY.st1.EndOfTrackError 128)(RPAQQ \PCE.FLOPPY.st1.NotUsed1 64)(RPAQQ \PCE.FLOPPY.st1.DataError 32)(RPAQQ \PCE.FLOPPY.st1.OverRunError 16)(RPAQQ \PCE.FLOPPY.st1.NotUsed2 8)(RPAQQ \PCE.FLOPPY.st1.SectorNotFoundError 4)(RPAQQ \PCE.FLOPPY.st1.WriteProtectError 2)(RPAQQ \PCE.FLOPPY.st1.MissingAddressMarkError 1)(CONSTANTS \PCE.FLOPPY.st1.EndOfTrackError \PCE.FLOPPY.st1.NotUsed1 \PCE.FLOPPY.st1.DataError        \PCE.FLOPPY.st1.OverRunError \PCE.FLOPPY.st1.NotUsed2 \PCE.FLOPPY.st1.SectorNotFoundError        \PCE.FLOPPY.st1.WriteProtectError \PCE.FLOPPY.st1.MissingAddressMarkError))(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.FLOPPY.st2.NotUsed0 128)(RPAQQ \PCE.FLOPPY.st2.ControlMark 64)(RPAQQ \PCE.FLOPPY.st2.DataErrorInDataField 32)(RPAQQ \PCE.FLOPPY.st2.WrongCylinder 16)(RPAQQ \PCE.FLOPPY.st2.ScanEqualHit 8)(RPAQQ \PCE.FLOPPY.st2.ScanNotSatisfied 4)(RPAQQ \PCE.FLOPPY.st2.BadCylinder 2)(RPAQQ \PCE.FLOPPY.st2.MissingAddressMarkInDataField 1)(CONSTANTS \PCE.FLOPPY.st2.NotUsed0 \PCE.FLOPPY.st2.ControlMark \PCE.FLOPPY.st2.DataErrorInDataField        \PCE.FLOPPY.st2.WrongCylinder \PCE.FLOPPY.st2.ScanEqualHit \PCE.FLOPPY.st2.ScanNotSatisfied        \PCE.FLOPPY.st2.BadCylinder \PCE.FLOPPY.st2.MissingAddressMarkInDataField))(DECLARE%: EVAL@COMPILE (RPAQQ \PCE.FLOPPY.st3.Fault 128)(RPAQQ \PCE.FLOPPY.st3.WriteProtected 64)(RPAQQ \PCE.FLOPPY.st3.Ready 32)(RPAQQ \PCE.FLOPPY.st3.Track0 16)(RPAQQ \PCE.FLOPPY.st3.TwoSided 8)(RPAQQ \PCE.FLOPPY.st3.theHeadAddress 4)(RPAQQ \PCE.FLOPPY.st3.theDriveNumber.MASK 3)(CONSTANTS \PCE.FLOPPY.st3.Fault \PCE.FLOPPY.st3.WriteProtected \PCE.FLOPPY.st3.Ready        \PCE.FLOPPY.st3.Track0 \PCE.FLOPPY.st3.TwoSided \PCE.FLOPPY.st3.theHeadAddress        \PCE.FLOPPY.st3.theDriveNumber.MASK))(PUTPROPS PCEFLOPPY COPYRIGHT ("Xerox Corporation" 1986 1987 1988))(DECLARE%: DONTCOPY  (FILEMAP (NIL (6147 7169 (PCE.CREATE.FLOPPYFILE 6157 . 7167)) (7170 26255 (\PCE.FLOPPY.DriveStatus 7180 . 7687) (\PCE.FLOPPY.Format 7689 . 12323) (\PCE.FLOPPY.GetMemBufferPtr 12325 . 13352) (\PCE.FLOPPY.InterruptStatus 13354 . 13986) (\PCE.FLOPPY.LongByteSwap 13988 . 14372) (\PCE.FLOPPY.MoveData 14374 . 17739) (\PCE.FLOPPY.NoDrive 17741 . 18301) (\PCE.FLOPPY.Read 18303 . 20058) (\PCE.FLOPPY.ReadID 20060 . 20983) (\PCE.FLOPPY.ReadOnly 20985 . 21528) (\PCE.FLOPPY.Recalibrate 21530 . 22188) (\PCE.FLOPPY.Seek 22190 . 22388) (\PCE.FLOPPY.SeekToCylinder 22390 . 23072) (\PCE.FLOPPY.StoreResultBytes 23074 . 23693) (\PCE.FLOPPY.Unformatted 23695 . 24234) (\PCE.FLOPPY.Unimplemented 24236 . 24896) (\PCE.FLOPPY.Write 24898 . 26253)) (26256 45733 (\PCE.FLOPPY.Configure 26266 . 32530) (\PCE.FLOPPY.Init 32532 . 33848) (\PCE.FLOPPY.Notify 33850 . 34593) (\PCE.FLOPPY.NotifyProcedure 34595 . 41475) (\PCE.FLOPPY.NO.VIRTUAL.Notify 41477 . 44785) (\PCE.FLOPPY.Terminate 44787 . 45731)))))STOP