%   Package: types.pl%   Author : Richard A. O'Keefe%   Updated: 4/10/87%   Purpose: More and better type tests.%   Adapted from shared code written by the same author; all changes%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved./*  This file adds the type tests	symbol(X)		== atom(X)	constant(X)		== atomic(X)	callable(X)		== atom or compound	compound(X)	simple(X)		== \+ compound	ground(X)	proper_list(X)    which come from my "Draft Proposed Standard for Prolog Evaluable    Predicates", and also the checks	must_be_integer(X,	N, Goal)	must_be_number(X,	N, Goal)	must_be_symbol(X,	N, Goal)	must_be_constant(X,	N, Goal)	must_be_callable(X,	N, Goal)	must_be_nonvar(X,	N, Goal)	must_be_var(X,		N, Goal)	must_be_ground(X,	N, Goal)	must_be_oneof(X, L,	N, Goal)	must_be_nonneg(X,	N, Goal)	must_be_proper_list(X,  N, Goal)	must_be_between(X, L,U,	N, Goal)    which check for a condition and report a useful message if the    argument has the wrong type.  The idea is that arg(N,Goal,X) is    supposed to be true.	*** This file is unsupported in the sense that it is meant	*** for use only by Quintus.  The fact that library files	*** which use this file generate error reports will not be	*** changed, but the manner in which errors are detected &	*** reported is likely to change DRAMATICALLY before long.	*** Feel free to use this stuff, but be prepared for it to	*** be replaced by something much better!    The checks must_be_xxx are not meant for YOUR use, but for OURS.    Other library files use them to do error checking.  You shouldn't    rely on them, because in the next release of the library, error    checking may be done in a completely different way.  The main reason    for having this file, apart from defining a collection of type tests    which are useful in their own right, is to provide a set of checks    that I can put into my code so that I do something sensible in the    event of an error, so that when something better is designed I will    have existing code to update rather than having to go through and    install completely new code.    Note that although one of the arguments of these routines is    described as a "goal", we are NOT going to call it, and it would    only make things more obscure to declare these predicates as    meta_predicates.  We are just going to print those "goals".*/:- module(types, [	callable/1,	complex/1,			% for the future	compound/1,	constant/1,	ground/1,	proper_list/1,	rational/1,			% for the future	simple/1,	symbol/1,	term_type/2,	must_be_atom/3,	must_be_between/5,	must_be_callable/3,	must_be_compound/3,	must_be_constant/3,	must_be_ground/3,	must_be_integer/3,	must_be_nonneg/3,	must_be_nonvar/3,	must_be_oneof/4,	must_be_proper_list/3,	must_be_symbol/3,	must_be_var/3   ]).sccs_id('"@(#)87/04/10 types.pl	99.1"').callable(Term) :-	nonvar(Term),	functor(Term, Symbol, _Arity),	atom(Symbol).complex(Term) :-			% for the future	float(Term).compound(Term) :-	nonvar(Term),	functor(Term, _Symbol, Arity),	Arity > 0.constant(Term) :-			% Probably the same as atomic(Term),	nonvar(Term),			% but I'm playing safe here.	functor(Term, Term, 0).		% atomic was defined as integer|atomground(Term) :-	nonvar(Term),	functor(Term, _, Arity),	ground(Arity, Term).ground(0, _) :- !.ground(N, Term) :-	arg(N, Term, Arg),	ground(Arg),	M is N-1,	ground(M, Term).proper_list(0) :- !, fail.		% catches variablesproper_list([]).proper_list([_|L]) :-	proper_list(L).rational(Term) :-			% for the future	integer(Term).simple(Term) :-	var(Term), !.simple(Term) :-	functor(Term, Term, 0).symbol(Term) :-	atom(Term).%   term_type(+Term, ?Type)%   is a type testing predicate designed for incorporation into coroutining%   Prologs like MU Prolog and NU Prolog.  In general, the rule is that when%   a predicate *would* delay in a coroutining system, it *must* report an%   instantiation fault in a non-coroutining system like Quintus Prolog.%   This predicate is no exception: the Term must be instantiated when you%   call term_type/2 because knowing the Type doesn't give you enough%   information to reconstruct the Term.  If you supply the Type, as in%   term_type(X, constant), this is a perfectly good logical test.  It is%   not as fast as atomic(X) would be, but it is "sound".  In order to%   preserve the logical character of this predicate, if you leave Type%   unbound, all the types which Term has will be enumerated.term_type(Term, Type) :-	(   var(Term)  -> must_be_(nonvar, Term, 1, term_type(Term,Type))	;   atom(Type) -> term_type_(Type, Term)	;   var(Type)  -> term_type_(Type, Term)	;   must_be_(symbol, Type, 2, term_type(Term,Type))	).term_type_(compound, Term) :- compound(Term).term_type_(callable, Term) :- callable(Term).term_type_(constant, Term) :- atomic(Term).term_type_(number,   Term) :- number(Term).term_type_(symbol,   Term) :- atom(Term).%         (string,   Term) :- string(Term).term_type_(integer,  Term) :- integer(Term).term_type_(rational, Term) :- rational(Term).term_type_(float,    Term) :- float(Term).term_type_(complex,  Term) :- complex(Term).instantiation_fault(ArgumentNumber, Goal) :-	functor(Goal, Symbol, Arity),	format(user_error,	    '~N! Instantiation fault in argument ~w of ~w/~w~n! Goal: ~q~n',	    [ArgumentNumber, Symbol, Arity, Goal]),	fail.	/* THIS IS NOT QUITE RIGHT */must_be_(_, DudArgument, ArgumentNumber, Goal) :-	var(DudArgument),	!,	instantiation_fault(ArgumentNumber, Goal).must_be_(Type, DudArgument, ArgumentNumber, Goal) :-	functor(Goal, Symbol, Arity),	format(user_error,	    '~N! Type failure in argument ~w of ~w/~w~n',	    [ArgumentNumber, Symbol, Arity]),	format(user_error,	    '! ~w expected, but found ~q~n! Goal: ~q~n',	    [Type, DudArgument, Goal]),	fail.must_be_atom(Arg, N, Goal) :-	must_be_symbol(Arg, N, Goal).must_be_callable(Arg, _N, _Goal) :-	nonvar(Arg),	functor(Arg, Symbol, _Arity),	atom(Symbol),	!.must_be_callable(Arg, N, Goal) :-	must_be_(callable, Arg, N, Goal).must_be_compound(Arg, _N, _Goal) :-	nonvar(Arg),	functor(Arg, _Symbol, Arity),	Arity > 0,	!.must_be_compound(Arg, N, Goal) :-	must_be_(compound, Arg, N, Goal).must_be_constant(Arg, _N, _Goal) :-	atomic(Arg),	!.must_be_constant(Arg, N, Goal) :-	must_be_(constant, Arg, N, Goal).must_be_ground(Arg, _N, _Goal) :-	ground(Arg),	!.must_be_ground(_, N, Goal) :-	functor(Goal, Symbol, Arity),	format(user_error,	    '~N! Instantiation fault in argument ~w of ~w/~w~n! Goal: ~q~n',	    [N, Symbol, Arity, Goal]),	fail.	/* THIS IS NOT QUITE RIGHT */must_be_integer(Arg, _N, _Goal) :-	integer(Arg),	!.must_be_integer(Arg, N, Goal) :-	must_be_(integer, Arg, N, Goal).must_be_number(Arg, _N, _Goal) :-	number(Arg),	!.must_be_number(Arg, N, Goal) :-	must_be_(number, Arg, N, Goal).must_be_nonvar(Arg, _N, _Goal) :-	nonvar(Arg),	!.must_be_nonvar(Arg, N, Goal) :-	must_be_(nonvar, Arg, N, Goal).must_be_proper_list(Arg, _, _) :-	proper_list(Arg),	!.must_be_proper_list(Arg, N, Goal) :-	\+ length(Arg, _),		% can't be filled out to a list	!,				% so is no list at all.	must_be_('proper list', Arg, N, Goal).must_be_proper_list(_, N, Goal) :-	% improper list	instantiation_fault(N, Goal).must_be_symbol(Arg, _N, _Goal) :-	atom(Arg),	!.must_be_symbol(Arg, N, Goal) :-	must_be_(symbol, Arg, N, Goal).must_be_var(Arg, _N, _Goal) :-	var(Arg),	!.must_be_var(Arg, N, Goal) :-	must_be_(var, Arg, N, Goal).must_be_oneof(Arg, List, _N, _Goal) :-	nonvar(Arg),	mb_oneof(List, Arg),	!.must_be_oneof(Arg, List, N, Goal) :-	must_be_(oneof(List), Arg, N, Goal).mb_oneof([X|_], X) :- !.	%  This is memberchk/2,mb_oneof([_|T], X) :-		%  but types.pl doesn't use basics.pl otherwise	mb_oneof(T, X).must_be_nonneg(Arg, _N, _Goal) :-	integer(Arg),	Arg >= 0,	!.must_be_nonneg(Arg, N, Goal) :-	must_be_('non-negative integer', Arg, N, Goal).must_be_between(L, U, Arg, _N, _Goal) :-	integer(Arg),	Arg >= L, Arg =< U,	!.must_be_between(L, U, Arg, N, Goal) :-	must_be_(between(L,U), Arg, N, Goal).