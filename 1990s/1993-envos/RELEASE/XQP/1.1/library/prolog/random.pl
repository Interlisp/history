%   Package: random%   Author : Richard A. O'Keefe%   Updated: 4/3/87%   Purpose: Provide a portable random number generator./*  This package uses algorithm AS 183 from the journal Applied Statistics    as the basic random number generator.  RANDOM.LSP contains a Lisp    version of the code.  "C" and Prolog versions exist too.  Exactly the    same underlying sequence will be produced in all versions of Quintus    Prolog; the actual results may not be identical because of differences    in floating-point arithmetic.    The operations are	getrand(OldState)	setrand(NewState)	    -- allow saving and restoring the generator state	maybe(P) {Peter Schachte's brain-child}	    -- succeed with probability P, fail with probability 1-P	maybe(P, N)	    -- succeed with probability P/N	random(X)	    -- bind X to a random float in [0.0,1.0)	random(L, U, X)	    -- bind X to a random element of [L,U)	    -- if L, U are integers, X will be an integer.	random_member(Elem, List)	    -- unifies Elem with a random element of List.	    -- Reports an error if List is not a proper list.	random_select(Elem, List, Rest)	    -- is like select(Elem, List, Rest), but picks a random	    -- element of the list.  You can use it to insert Elem in	    -- a random place in Rest, yielding List, or to delete a	    -- random Elem of List, yielding Rest.	    -- Either List or Rest should be proper.	    -- This used to be called rand_elem/3.	random_subseq(List, Sbsq, Cmpl)	    -- is like subseq(List, Sbsq, Cmpl), but picks a random	    -- subsequence of List rather than enumerating all of them.	    -- Either List, or both Sbsq and Cmpl, should be proper.	random_permutation(L1, L2)	    -- unify L2 with a random permutation of L1.	    -- like permutation(L1, L2), either of the arguments may	    -- be proper and the other will be solved for.	    -- This used to be rand_perm/2.*/:- module(random, [	getrand/1,			% save the state	setrand/1,			% reset the state	maybe/1,			% random success/failure	maybe/2,			% random success/failure	random/1,			% uniform [0,1)	random/3,			% uniform [L,U)	random_member/2,		% Elem <- List	random_select/3,		% Elem <- List -> Rest	random_subseq/3,		% List -> Sbsq x Cmpl	random_permutation/2		% List -> Perm   ]).:- mode	setrand(+),	maybe(+),	maybe(+, +),	random(?),	random(+, -, -),	random_member(?, +),	    random_member(+, +, ?),	    'proper length'(+, +, -),	random_select(?, ?, ?),	    random_select(+, +, ?, +),	    'one longer'(?, ?, -),	    'common length'(?, ?, +, -),	random_subseq(?, ?, ?),	random_permutation(?, ?),	    random_permutation(+, +, -, +),		random_partition(+, +, +, -, -).sccs_id('"@(#)87/04/03 random.pl	99.1"').:- lisp_predicate('QP.RAND.GET', 'QP.RAND.GET'([-])).:- lisp_predicate('QP.RAND.PUT', 'QP.RAND.PUT'(+,+,+)).:- lisp_predicate('QP.RAND.VAL', random([-])).:- lisp_predicate('QP.RAND.MYB', 'QP.RAND.MYB'(+,+,[-])).:- load_foreign_files([library('RANDOM')], []).%   getrand(-RandomState)%   returns the random number generator's current stategetrand(random(X,Y,Z)) :-	'QP.RAND.GET'([X,Y,Z]).%   setrand(+RandomState)%   sets the random number generator's state to RandomState.%   If RandomState is not a valid random state, it reports%   an error, and then fails.setrand(random(X,Y,Z)) :-	integer(X), integer(Y), integer(Z),	'QP.RAND.PUT'(X, Y, Z, 'T'),	!.setrand(RandomState) :-	format(user_error, '~N! Bad random state: ~q~n! Goal: ~q~n',	    [RandomState, setrand(RandomState)]),	fail.%   maybe(P) succeeds determinately with probability P,%   fails with probability 1-P.  If P < 0, it acts like 0.%   If P > 1, it acts like 1.  If P is not a number, an%   error will be reported.maybe(P) :-	random(X),	X < P.%   maybe(P, N) succeeds determinately with probability P,%   where 0 =< P =< N and P and N are integers.  If this%   condition is not met, it fails.  It is equivalent to%   random(0, N, X), X < P, but is somewhat faster.maybe(P, N) :-	'QP.RAND.MYB'(P, N, 'T').%   random(R) binds R to a new random number in [0.0,1.0)%   It is coded in Lisp for speed rather than portability.%   random(L, U, R) binds R to a random integer in [L,U)%   when L and U are integers (note that U will NEVER be generated),%   or to a random floating number in [L,U) otherwise.%   If either L or U is not a number, it quietly fails.random(L, U, R) :-	integer(L), integer(U),	random(X), !,	R is integer((U-L)*X) + L.random(L, U, R) :-	number(L), number(U),	random(X), !,	R is (U-L)*X + L./*----------------------------------------------------------------------+|		    Randomised list-processing				|+----------------------------------------------------------------------*/%   random_member(+List, ?Elem)%   unifies Elem with a random element of List, which must be proper.%   Takes O(N) time (average and best case).random_member(Elem, List) :-	'proper length'(List, 0, N),	!,	random(0, N, I),	random_member(I, List, Elem).random_member(Elem, List) :-	format(user_error,	    '~N! Improper argument to ~q~n! Goal: ~q~n',	    [random_member/2, random_member(Elem,List)]),	fail.%   random_member/3 has the same arguments and meaning as nth0/3%   in library(lists), but only works one way around.random_member(0, [Elem|_], Elem) :- !.random_member(N, [_|List], Elem) :-	M is N-1,	random_member(M, List, Elem).%   'proper length'(List, N0, N)%   is true when List is a proper list and N-N0 is its length.'proper length'(var, _, _) :- !, fail.'proper length'([], N, N).'proper length'([_|Tail], N0, N) :-	N1 is N0+1,	'proper length'(Tail, N1, N).%   random_select(?Elem, ?List, ?Rest)%   unifies Elem with a random element of List and Rest with all the%   other elements of List (in order).  Either List or Rest should%   be proper, and List should/will have one more element than Rest.%   Takes O(N) time (average and best case).random_select(List, Elem, Rest) :-	'one longer'(List, Rest, N),	random(0, N, I),	random_select(I, List, Elem, Rest).%   random_select/4 has the same arguments and meaning as nth0/4%   in library(lists), but only works one way around.random_select(0, [Elem|Rest], Elem, Rest) :- !.random_select(N, [Head|Tail], Elem, [Head|Rest]) :-	M is N-1,	random_select(M, Tail, Elem, Rest).%   'one longer'(+List, +Rest, -N) is true when List and Rest are lists,%   List has N elements, and Rest has N-1 elements.  It is assumed%   that either List or Rest is proper.'one longer'([_|List], Rest, N) :-	'common length'(List, Rest, 1, N).%   'common length'(L1, L2, N0, N) is true when L1 and L2 are%   lists of the same length, and N-N0 is that common length.%   same_length/3 in library(lists) was derived from this.'common length'([], [], N, N).'common length'([_|X], [_|Y], K, N) :-	L is K+1,	'common length'(X, Y, L, N).%   random_subseq(List, Sbsq, Cmpl)%   unifies Sbsq with a random sub-sequence of List, and Cmpl with its%   complement.  After this, subseq(List, Sbsq, Cmpl) will be true.%   Each of the 2**length(List) solutions is equally likely.  Like its%   name-sake subseq/3, if you supply Sbsq and Cmpl it will interleave%   them to find List.  Takes O(N) time.random_subseq([], [], []).random_subseq([Elem|List], Sbsq, Cmpl) :-	random(X),	(   X >= 0.5 ->	    Sbsq = [Elem|Sbs1],	    random_subseq(List, Sbs1, Cmpl)	;   /* also with probability 0.5 */	    Cmpl = [Elem|Cmp1],	    random_subseq(List, Sbsq, Cmp1)	).%   random_permutation(List, Perm)%   unifies Perm with a random permutation of List.  Either List or Perm%   should be proper, and they should/will have the same length. Each of%   the factorial(length(List)) permutations is equally likely.%   The old rand_perm/2 predicate took O(N**2) time and only worked one%   way around; this takes O(N.lgN) time and is bidirectional.random_permutation(List, Perm) :-	'common length'(List, Perm, 0, N),	random_permutation(N, List, Ans, []),	Perm = Ans.random_permutation(0, _, X, X) :- !.random_permutation(1, [X], [X|L], L) :- !.random_permutation(2, [X,Y], [U,V|L], L) :- !,	(   maybe(0.5) ->	    U = X, V = Y	;   U = Y, V = X	).random_permutation(N, List, Front, Back) :-	Z is N>>1,	A is N-Z,	random_partition(List, A, N, Alist, Zlist),	random_permutation(Z, Zlist, Middle, Back),	random_permutation(A, Alist, Front, Middle).random_partition(L, 0, _, [], L) :- !.random_partition([], _, _, [], []).random_partition([X|L], P , N, [X|A], B) :-	random(Q),	Q*N <P,	!,	O is P-1,	M is N-1,	random_partition(L, O, M, A, B).random_partition([X|L], P, N, A, [X|B]) :-	M is N-1,	random_partition(L, P, M, A, B).