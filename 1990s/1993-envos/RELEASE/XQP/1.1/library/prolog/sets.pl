%   Module : sets%   Authors: Lawrence Byrd + Richard A. O'Keefe%   Updated: 4/28/87%   Purpose: Set manipulation utilities%   SeeAlso: ordsets%   Adapted from shared code written by the same authors; all changes%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved.%   Sets are represented as lists with no repeated elements.%   The ordered representation used in `ordsets' is much more%   efficient, but these routines were designed before sort/2%   entered the language, and have some pretence to being logic.%   Before the introduction of modules, it used to be the case%   that if you loaded library(sets), you got library(basics) too.%   Now if you want {member,memberchk,nonmember}/2, you have to%   ask for library(basics) yourself.  Eheu.  We could export%   them from sets, but then you'd have trouble if you did load%   library(basics).  Eheu again.:- module(sets, [	add_element/3,		%  Elem x Set -> Set	del_element/3,		%  Elem x Set -> Set	is_set/1,		%  List ->	disjoint/2,		%  Set x Set ->	intersect/2,		%  Set x Set ->	intersect/3,		%  Set x Set -> Set	intersection/2,		%  list(Set) -> Set	intersection/3,		%  Set x Set -> Set	list_to_set/2,		%  List -> Set	pairfrom/4,		%  Set -> Elem x Elem x Set	power_set/2,		%  Set -> Set of Sets	select/3,		%  Elem <- Set -> Set	seteq/2,		%  Set x Set ->	setproduct/3,		%  Set x Set -> Pairs	subset/2,		%  Set x Set ->	subtract/3,		%  Set x Set -> Set	symdiff/3,		%  Set x Set -> Set	union/2,		%  list(Set) -> Set	union/3			%  Set x Set -> Set   ]).:- use_module(library(basics)). /*	append/3,		%  used by union/2	member/2,		%  Elem x Set ->	memberchk/2,		%  Elem x Set ->	nonmember/2		%  Elem x Set ->   */:- mode	add_element(+, +, -),	del_element(+, +, -),	disjoint(+, +),	is_set(+),	select(?, ?, ?),	pairfrom(?, ?, ?, ?),	intersect(+, +),	subset(+, +),	seteq(+, +),	list_to_set(+, ?),	power_set(?, ?),	    ps(+, ?),		ps(+, +, +, ?),	intersect(+, +, ?),		% obsolete	intersection(+, +, ?),	intersection(+, ?),	    intersection1(+, +, ?),	    memberchk_all(+, +),	setproduct(?, ?, ?),	    setproduct(?, ?, ?, -),	subtract(+, +, ?),	symdiff(+, +, ?),	    symdiff(+, +, ?, ?),	union(+, +, ?),	union(+, ?),	    union1(+, ?),		union2(+, ?).sccs_id('"@(#)87/04/28 sets.pl	10.1"').%   add_element(Elem, Set1, Set2)%   is true when Set1 and Set2 are sets represented as unordered lists,%   and Set2 = Set1 U {Elem}.  It may only be used to calculate Set2%   given Elem and Set1.  However, if Set1 is a list with a variable at%   the end, it may still be used, and will add new elements at the end.add_element(Elem, Set, Set) :-	memberchk(Elem, Set),	!.add_element(Elem, Set, [Elem|Set]).%   del_element(Elem, Set1, Set2)%   is true when Set1 and Set2 are sets represented as unordered lists,%   and Set2 = Set1 \ {Elem}.  It may only be used to calculate Set2%   given Elem and Set1.  If Set1 does not contain Elem, Set2 and Set1%   will be equal.  I wanted to call this predicate 'delete', but other%   Prologs have used that for 'select'.  If Set1 is not an unordered%   set, but contains more than one copy of Elem, only the first will%   be removed.  See delete/3 for a predicate which will delete all the%   copies of a given element.del_element(Elem, [Elem|Set2], Set2) :- !.del_element(Elem, [X|Set1], [X|Set2]) :- !,	del_element(Elem, Set1, Set2).del_element(_, [], []).%   disjoint(+Set1, +Set2)%   is true when the two given sets have no elements in common.%   It is the opposite of intersect/2.disjoint(Set1, Set2) :-	member(Element, Set1),	memberchk(Element, Set2),	!, fail.disjoint(_, _).%   is_set(+List)%   is true when List is a proper list that contains no repeated elements.%   That, is, List represents a set in the style used by this package.%   See the description of nonmember/2 for some restrictions.is_set([Head|Tail]) :- !,	nonmember(Head, Tail),	is_set(Tail).is_set([]).%   select(?Element, ?Set, ?Residue)%   is true when Set is a list, Element occurs in Set, and Residue is%   everything in Set except Element (things stay in the same order).select(Element, [Element|Rest], Rest).select(Element, [Head|Tail], [Head|Rest]) :-	select(Element, Tail, Rest).%   pairfrom(?Set, ?Element1, ?Element2, ?Residue)%   is true when Set is a list, Element1 occurs in list, Element2%   occurs in list after Element1, and Residue is everything in Set%   bar the two Elements.  The point of this thing is to select%   pairs of elements from a set without selecting the same pair%   twice in different orders.pairfrom([Element1|Set], Element1, Element2, Residue) :-	select(Element2, Set, Residue).pairfrom([Head|Tail], Element1, Element2, [Head|Rest]) :-	pairfrom(Tail, Element1, Element2, Rest).%   intersect(Set1, Set2)%   is true when the two sets have a member in common.  It assumes%   that both sets are known, and that you don't care which element%   it is that they share.intersect(Set1, Set2) :-	member(Element, Set1),		%  generates Elements from Set1	memberchk(Element, Set2),	%  tests them against Set2	!.				%  if it succeeds once, is enough.%   subset(+Set1, +Set2)%   is true when each member of Set1 occurs in Set2.%   It can only be used to test two given sets; it cannot be used%   to generate subsets.  At the moment there is NO predicate for%   generating subsets, but select/3 takes you part-way.subset([], _).subset([Element|Residue], Set) :-	memberchk(Element, Set),	subset(Residue, Set).%   seteq(+Set1, +Set2)%   is true when each Set is a subset of the other.  There are two%   ways of doing this.  One is commented out.seteq(Set1, Set2) :-	subset(Set1, Set2),	subset(Set2, Set1).%	sort(Set1, Ord1),%	sort(Set2, Ord2),%	Ord1 == Ord2.%   list_to_set(+List, ?Set)%   is true when List and Set are lists, and Set has the same elements%   as List in the same order, except that it contains no duplicates.%   The two are thus equal considered as sets.  If you really want to%   convert a list to a set, list_to_ord_set is faster, but this way%   preserves as much of the original ordering as possible.list_to_set([], []).list_to_set([Head|Tail], Set) :-	memberchk(Head, Tail), !,	list_to_set(Tail, Set).list_to_set([Head|Tail], [Head|Set]) :-	list_to_set(Tail, Set).%   power_set(?Set, ?PowerSet)%   is true when Set is a list and PowerSet is a list of lists which%   represents the power set of the set that Set represents.  The%   particular representation of the power set chosen has this defining%   property: if A subset-of B subset-of Set, then B appears *BEFORE*%   A in PowerSet.  In particular, the first element of PowerSet must%   be Set itself, and the last element of PowerSet must be [].  As an%   example, power_set([a,b], X) binds X=[[a,b],[a],[b],[]].%   Note that length(PowerSet) = 2**length(Set), so that for Sets with%   more than about 18 elements, this isn't a very practical operation.power_set(Set, [Set|Rest]) :-	ps(Set, [Set|Rest]).ps([], [[]]).ps([Head|Tail], ListPow) :-	ps(Tail, TailPow),	ps(TailPow, Head, TailPow, ListPow).ps([], _, ListPow, ListPow).ps([Subset|Subsets], Element, TailPow, [[Element|Subset]|ListPow]) :-	ps(Subsets, Element, TailPow, ListPow).%   intersection(+Set1, +Set2, ?Intersection)%   is true when all three arguments are lists representing sets,%   and Intersection contains every element of Set1 which is also%   an element of Set2, the order of elements in Intersection%   being the same as in Set1.  That is, Intersection represents%   the intersection of the sets represented by Set1 and Set2.%   If Set2 is a partial list, Intersection will be empty, which%   is not, of course, correct.  If Set1 is a partial list, this%   predicate will run away on backtracking.  Set1 and Set2 should%   both be proper lists, but this is not checked.  Duplicates in%   Set1 may survive in Intersection.  It is worthy of note that%   if Set1 is an ordset, Intersection is an ordset, despite Set2.intersection([], _, []).intersection([Element|Elements], Set, Intersection) :-	memberchk(Element, Set),	!,	Intersection = [Element|Rest],	intersection(Elements, Set, Rest).intersection([_|Elements], Set, Intersection) :-	intersection(Elements, Set, Intersection).%   intersection(+ListOfSets, ?Intersection)%   is true when Intersection is the intersection of all the sets in%   ListOfSets.  The order of elements in Intersection is taken from%   the first set in ListOfSets.  This has been turned inside out to%   minimise the storage turnover.intersection([Set|Sets], Intersection) :-	intersection1(Set, Sets, Intersection).intersection1([], _, []).intersection1([Element|Elements], Sets, Intersection) :-	memberchk_all(Sets, Element),	!,	Intersection = [Element|Rest],	intersection1(Elements, Sets, Rest).intersection1([_|Elements], Sets, Intersection) :-	intersection1(Elements, Sets, Intersection).memberchk_all([], _).memberchk_all([Set|Sets], Element) :-	memberchk(Element, Set),	memberchk_all(Sets, Element).%   intersect(+Set1, +Set2, ?Intersection)%   is an obsolete synonym of intersection/3.intersect(Set1, Set2, Intersection) :-	intersection(Set1, Set2, Intersection).%   subtract(+Set1, +Set2, ?Difference)%   is like intersect, but this time it is the elements of Set1 which%   *are* in Set2 that are deleted.subtract([], _, []).subtract([Element|Residue], Set, Difference) :-	memberchk(Element, Set), !,	subtract(Residue, Set, Difference).subtract([Element|Residue], Set, [Element|Difference]) :-	subtract(Residue, Set, Difference).%   symdiff(+Set1, +Set2, ?Diff)%   is true when Diff is the symmetric difference of Set1 and Set2,%   that is, if each element of Union occurs in one of Set1 and Set2,%   but not both.  The construction method is such that the answer%   will contain no duplicates even if the Sets do.symdiff(Set1, Set2, Diff) :-	symdiff(Set1, Set2, Diff, Mid),	symdiff(Set2, Set1, Mid, []).symdiff([Elem|Rest], Avoid, Diff, Tail) :-	memberchk(Elem, Avoid), !,	symdiff(Rest, Avoid, Diff, Tail).symdiff([Elem|Rest], Avoid, [Elem|Diff], Tail) :- !,	symdiff(Rest, [Elem|Avoid], Diff, Tail).symdiff([], _, Tail, Tail).%   setproduct(Set1, Set2, CartesianProduct)%   is true when Set1 is a set (list) and Set2 is a set (list) and%   CartesianProduct is a set of Elt1-Elt2 pairs, with a pair for%   for each element Elt1 of Set1 and Elt2 of Set2.setproduct([], _, []).setproduct([H|T], L, Product) :-	setproduct(L, H, Product, Rest),	setproduct(T, L, Rest).setproduct([], _, L, L).setproduct([H|T], X, [X-H|TX], TL) :-	setproduct(T, X, TX, TL).%   union(+Set1, +Set2, ?Union)%   is true when subtract(Set1,Set2,Diff) and append(Diff,Set2,Union),%   that is, when Union is the elements of Set1 that do not occur in%   Set2, followed by all the elements of Set2.union([], Union, Union).union([Element|Elements], Set, Union) :-	memberchk(Element, Set), !,	union(Elements, Set, Union).union([Element|Elements], Set, [Element|Union]) :-	union(Elements, Set, Union).%   union(+ListOfSets, ?Union)%   is true when Union is the union of all the sets in ListOfSets.%   It has been arranged with storage turnover in mind.union(Sets, Union) :-	union1(Sets, Answer),	append(Answer, [], Answer),	% cauterise it	!,	Union = Answer.union1([], _).union1([Set|Sets], Answer) :-	union2(Set, Answer),	union1(Sets, Answer).union2([], _).union2([Element|Elements], Answer) :-	memberchk(Element, Answer),	% add_element hack	union2(Elements, Answer).