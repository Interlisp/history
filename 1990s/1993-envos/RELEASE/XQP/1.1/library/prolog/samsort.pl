%   Package: samsort%   Author : Richard A. O'Keefe%   Updated: 3/26/87%   Purpose: a sorting routine which exploits existing order%   Adapted from shared code written by the same author; all changes%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved./*  There are two sorting routines:	samsort(RawList, OrderedList).	samsort(Order, RawList, OrderedList).    OrderedList is unified with the sorted version of RawList, which    must be supplied as a proper list.  samsort/2 is like sort/2 but    doesn't eliminate duplicate elements.  samsort/3 allows you to    supply your own comparison routine, which is to act like @< .    Note that the predicates in library(order) want an equivalent of    @=<, while this wants an equivalent of @<.  Sorry about that.    The name "samsort" comes from "Smooth Applicative Merge sort".    The algorithm is of my own invention.  It is a variant of the    natural merge, and can exploit descending order in the RawList    as well as asscending order.    The sorting routines use two merging routines which may be of    use in themselves:	merge(X, Y, Combined)	merge(Order, X, Y, Combined)    The former is based on the built in predicate @<, while the    latter lets you supply your own ordering routine, which should    resemble @<.*/:- module(samsort, [	keymerge/3,	merge/3,	merge/4,	samkeysort/2,	samsort/2,	samsort/3   ]).:- use_module(library(call), [	call/3   ]).:- meta_predicate	merge(2, +, +, ?),	    sam_merge(+, +, 2, ?),	samsort(2, +, ?),	    sam_sort(+, 2, +, +, ?),		sam_run(+, +, +, 2, -, -),		    sam_rest(+, +, +, +, 2, -, -),		sam_fuse(+, 2, +, ?).sccs_id('"@(#)87/03/26 samsort.pl	98.1"').%   samsort(+RawList, ?Sorted)%   is given a proper list RawList and unifies Sorted with a list%   having exactly the same elements as RawList but in ascending%   order according to the standard order on terms.  That is,%   append(_, [X,Y|_], Sorted) -> \+(Y@<X).samsort([], []) :- !.samsort(List, Sorted) :-	sam_sort(List, [], 0, Sorted).sam_sort([], Stack, _, Sorted) :-	sam_fuse(Stack, 0, [Sorted]).sam_sort([Head|Tail], Stack, R, Sorted) :-	sam_run(Tail, [Head|Queue], [Head|Queue], Run, Rest),	S is R+1,	sam_fuse([Run|Stack], S, NewStack),	sam_sort(Rest, NewStack, S, Sorted).sam_fuse([A,B|Rest], K, Ans) :-	0 is K /\ 1,	!,	J is K >> 1,	merge(A, B, C),	sam_fuse([C|Rest], J, Ans).sam_fuse(Stack, _, Stack).sam_run([], Run, [_], Run, []).sam_run([Head|Tail], QH, QT, Run, Rest) :-	sam_rest(QH, QT, Head, Tail, Run, Rest).sam_rest([Ah|At], Qt, H, T, Run, Rest) :-	H @< Ah,	!,	sam_run(T, [H,Ah|At], Qt, Run, Rest).sam_rest(Qh, [Qt], H, T, Qh, [H|T]) :-	H @< Qt,	!.sam_rest(Qh, [_,H|Nt], H, T, Run, Rest) :-	sam_run(T, Qh, [H|Nt], Run, Rest).%   merge(+List1, +List2, -Merged)%   is true when Merged is the stable merge of the two given lists.%   If the two lists are not ordered, the merge doesn't mean a great%   deal.  Merging is perfectly well defined when the inputs contain%   duplicates, and all copies of an element are preserved in the%   output, e.g. merge("122357", "34568", "12233455678").merge(List1, [], List1) :- !.merge([], List2, List2) :- !.merge([Head1|Tail1], [Head2|Tail2], [Head2|Merged]) :-	Head2 @< Head1,	!,	merge([Head1|Tail1], Tail2, Merged).merge([Head1|Tail1], List2, [Head1|Merged]) :-	merge(Tail1, List2, Merged).%   samsort(+Order, +RawList, ?SortedList)%   is given a proper list RawList and a binary predicate Order%   (note that it may be an N-ary predicate with the first N-2%   arguments already filled in) and unifies SortedList with a%   sorted version of RawList, in that append(_, [X,Y|_], Sorted)%   -> \+Order(Y,X).  This is only supposed to work when Order%   is transitive.samsort(_, [], []) :- !.samsort(Order, List, Sorted) :-	sam_sort(List, Order, [], 0, Sorted).sam_sort([], Order, Stack, _, Sorted) :-	sam_fuse(Stack, Order, 0, [Sorted]).sam_sort([Head|Tail], Order, Stack, R, Sorted) :-	sam_run(Tail, [Head|Queue], [Head|Queue], Order, Run, Rest),	S is R+1,	sam_fuse([Run|Stack], Order, S, NewStack),	sam_sort(Rest, Order, NewStack, S, Sorted).sam_fuse([A,B|Rest], Order, K, Ans) :-	0 is K /\ 1,	!,	J is K >> 1,	sam_merge(A, B, Order, C),	sam_fuse([C|Rest], Order, J, Ans).sam_fuse(Stack, _, _, Stack).sam_run([], Run, [_], _, Run, []).sam_run([Head|Tail], QH, QT, Order, Run, Rest) :-	sam_rest(QH, QT, Head, Tail, Order, Run, Rest).sam_rest([Ah|At], Qt, H, T, Order, Run, Rest) :-	call(Order, H, Ah),	!,	sam_run(T, [H,Ah|At], Qt, Order, Run, Rest).sam_rest(Qh, [Qt], H, T, Order, Qh, [H|T]) :-	call(Order, H, Qt),	!.sam_rest(Qh, [_,H|Nt], H, T, Order, Run, Rest) :-	sam_run(T, Qh, [H|Nt], Order, Run, Rest).%   merge(+Order, +List1, +List2, -Merged)%   is like merge/3 except that it takes an Order predicate as its%   first arguments, like all the generalised ordering routines.%   For efficiency, it calls sam_merge/4.merge(Order, List1, List2, Merged) :-	sam_merge(List1, List2, Order, Merged).sam_merge(List1, [], _, List1) :- !.sam_merge([], List2, _, List2) :- !.sam_merge([Head1|Tail1], [Head2|Tail2], Order, [Head2|Merged]) :-	call(Order, Head2, Head1),	!,	sam_merge([Head1|Tail1], Tail2, Order, Merged).sam_merge([Head1|Tail1], List2, Order, [Head1|Merged]) :-	sam_merge(Tail1, List2, Order, Merged).%   samkeysort(+RawList, ?Sorted)%   is given a proper list RawList of Key-Value pairs, and unifies%   Sorted with a list having exactly the same elements as RawList%   but in ascending order according to the standard order on the%   keys.  That is, append(_, [X-_,Y-_|_], Sorted) -> \+(Y@<X).samkeysort([], []) :- !.samkeysort(List, Sorted) :-	sam_key_sort(List, [], 0, Sorted).sam_key_sort([], Stack, _, Sorted) :-	sam_key_fuse(Stack, 0, [Sorted]).sam_key_sort([Head|Tail], Stack, R, Sorted) :-	sam_key_run(Tail, [Head|Queue], [Head|Queue], Run, Rest),	S is R+1,	sam_key_fuse([Run|Stack], S, NewStack),	sam_key_sort(Rest, NewStack, S, Sorted).sam_key_fuse([A,B|Rest], K, Ans) :-	0 is K /\ 1,	!,	J is K >> 1,	keymerge(A, B, C),	sam_key_fuse([C|Rest], J, Ans).sam_key_fuse(Stack, _, Stack).sam_key_run([], Run, [_], Run, []).sam_key_run([Head|Tail], QH, QT, Run, Rest) :-	sam_key_rest(QH, QT, Head, Tail, Run, Rest).sam_key_rest([Ah|At], Qt, H, T, Run, Rest) :-	'key @<'(H, Ah),	!,	sam_key_run(T, [H,Ah|At], Qt, Run, Rest).sam_key_rest(Qh, [Qt], H, T, Qh, [H|T]) :-	'key @<'(H, Qt),	!.sam_key_rest(Qh, [_,H|Nt], H, T, Run, Rest) :-	sam_key_run(T, Qh, [H|Nt], Run, Rest).%   keymerge(+List1, +List2, -Merged)%   is like merge/3 except that it compares only the keys of its input%   lists.  Note that it will not work properly when Merged is already%   instantiated.keymerge(List1, [], List1) :- !.keymerge([], List2, List2) :- !.keymerge([Head1|Tail1], [Head2|Tail2], [Head2|Merged]) :-	'key @<'(Head2, Head1),	!,	keymerge([Head1|Tail1], Tail2, Merged).keymerge([Head1|Tail1], List2, [Head1|Merged]) :-	keymerge(Tail1, List2, Merged).%   'key @<'/2 is like @</2 except that it compares the keys of its%   two arguments.  You'll find a keycompare/3 in library(qsort).'key @<'(KeyOfX-_, KeyOfY-_) :-	KeyOfX @< KeyOfY.