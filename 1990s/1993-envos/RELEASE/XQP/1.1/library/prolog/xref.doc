@(#)xref.doc	98.1  3/26/87			XREF: CROSS-REFERENCING PROGRAMThe xref program can be used to generate a list of all the cross referencesfor each predicate.  It has considerable flexibility for excluding orincluding desired predicates.A second function of xref is to aid in the formation of module statements,which are supported beginning with Release 2.0.  xref can list of all of therequired module/2 and use_module/2 statements by file.  These module/2 anduse_module/2 statements can not only be collected into a single file, buteach set of statements can also automatically be included at the top of eachappropriate file, thereby doing most of the work required to convert a Prologprogram which spans more than one file into a set of Prolog modules.The details are described in Section III.The user may extend the program by providing definition files, whichsupply  xref with additional information.  For example, a definition filecan specify that certain predicates, although built-in, should be includedin the cross-reference anyway.   Also, it can be used to answer in advancevarious questions which would otherwise require user interaction at run time.The details appear in Section II.This program was written by  various people in the Dept of Artificial Intelligence at the University of Edinburgh, and Quintus, including Chris Mellish, Dave Bowen, and Richard O'Keefe.  It was modified for use with the Quintus module system by Vince Pecora  and Allen Van Gelder.I.  BASIC USE OF THE PROGRAMThe simplest way to use the program is to type	| ?- compile(library(xref)).The top level predicate now available is:go/0	starts the cross-reference program which then runs as described	below.Once  the  program is started, the prompt "Next file: " appears and a file nameshould be typed in, followed by a carriage-return.  Note: you should not put  in a period  unless  it  is  part of the file name.  This is true of all thequestions xref asks you.  The prompt is repeated so that as many file names  asdesired may be entered.  E.g.  	Next file: *foodefs	Next file: @foolist	Next file: foo.pl	Next file:When  all  the required files have been entered, this input phase is terminatedby just typing a carriage-return by itself.  The preceding '*' and '@'are not part of the file names, but are explained below.Three types of files may be supplied to xref.	1.  Prolog files to be cross-referenced.  If a specified file	    loads a file by a compile, consult, ensure_loaded or use_module	    directive, the loaded file is included in the cross-reference	    unless the file name in the directive is of the form	    library(filename).	2.  Definition files. These are identified by an * prefix as shown	    in the example, or by having a ".def" extension.	    Definition files are described in Section II.	3.  Indirect files.  These are identified by an @ prefix as shown	    above, or by having ".ccl" extension.  An indirect file is just	    a file containing one file name per line.  These file names	    are processed as though they had been entered by the user.	    As when responding to the "Next file:" prompt, periods should	    appear only if they are part of the file name, and	    preceding '@' and '*' are permitted.At this point, the user may be prompted for additional information, unlessthat information was found in one of the definition files:	An output file  name.  Extension xrf (e.g., foo.xrf) is recommended.	A  title.	Text width for the output, e.g., 79.  May be 50-150.	Whether 'module' and 'use_module' declarations should be created.		Type the letter "y"  (or  "yes")  if  they are.	A request for a file name to which the 'module' and 'use_module' 		statements  are  to  be written.	Whether the files which have been cross-referenced should have		their 'module' and 'use_module' declarations updated.		If in doubt, answer "no" to this question;		the implications of answering "yes" are described in		Section III.If no information is missing, or after all information is supplied, xref beginsthe cross-reference phase.  Normally, no further user input is required, butunder very unusual circumstances, a later prompt may be given.After the output files are written, "go" succeeds.  At this point another xrefmay be begun by again entering "go." as the goal, and answering the prompts.II.  DEFINITION FILESThe  user  may  provide  his  own definition file(s).  Definition files calledmydefs and my.def can be loaded into xref as shown:	Next file: *mydefs	Next file: my.defNote that  any file name ending with ".def" will be treated as a definitionfile automatically.  Also, unlike indirect files, statements indefinition files are terminated by periods and use full Prolog syntax.II-A.  OUTPUT CONTROL AND FORMATThe following can be used to save having to repeatedly type the same answers tothe questions asked by xref at run time.cross_ref_file(<file name>).		This defines the filename for the cross-reference listing.		An extension of ".xrf" is recommended.title(<atom or string>).		This defines the title for the cross-reference listing.width(<text width>).		This   defines   the   text   width   (in  characters)  of  the		cross-reference listing.globals_file(<filename>).globals_file(no).		This defines the filename for the listing of the 'module' and 		'use_module' declarations (organized by file).		An extension of ".xrg" is recommended.		If it is 'no', then no listing will be produced.update_module_declarations(yes).update_module_declarations(no).		This  determines  whether  or  not  it is required to alter the		'module' and 'use_module' declarations in each file.II-B.  DECLARATIONS AND OVERRIDESxref automatically recognizes Prolog built-in predicates for  whichcross-referencing  is  not normally required.For example, to have xref list the uses of the built-in predicate length/2,the user may put either of the following in a definition file:	system_used(length(_,_)).	system_used(length/2).Also, to obtain cross-referencing of ALL built-in predicates, the definitionfile should contain:	system_used(P) :- predicate_property(P, built_in).Note that these are regular Prolog clauses and must be terminated with periods.Several  other kinds of terms are allowed in a definition file:op(<priority>, <associativity>, <operator symbol list>).		These  terms  simply  declare  operators  as  in the normal way		except that they take the form of assertions rather than  goals		(the  preceding  ':-'  is  omitted).  It  is not necessary to		declare operators in  the  definition  file  unless  their  use		precedes their declaration in the files to be processed.known(<predicate>, <file where defined>).known(<predicate>, <file where defined>, <module where defined>).		This  is  useful  for  utility  predicates   for   which   full		cross-referencing is not required.  It simply tells the program		where a particular procedure is defined,  so  that  it  is  not		necessary  to  process the module which contains the definition		of that procedure.called(<predicate>).called(<module>:<predicate>).		This informs xref that <predicate> is called.  This  is  useful		for top level routines which are to be called by the user.		It avoids the possibility of a warning message claiming that 		the predicate is not called.   It also ensures that the 		predicate is included in the list of exported predicates for 		the file, so that automatic insertion of 'module' declarations		will work properly.II-C.  META PREDICATESxref knows about built-in predicates whose arguments contain embedded goals,such as "setof" and "\+".  The user can specify additional predicates with this"meta-predicate" property through the use of "applies" facts in the definitionfile.  However, the "meta_predicate" declaration facility of Release 2.0 ofQuintus Prolog provides a superior method, and is recognized by xref.applies(<pred_skel>, <term>).applies(<module>:<pred_skel>, <term>).		This  can be used to indicate that a given predicate, specified		by <pred_skel>,  takes some other predicate as an argument and		causes that predicate to  be called.  <pred_skel> is of the		form <pred_name>(A1, ..., An).  <term> is of the form Ai + k.		The example below explains how these entries are constructed.		If the "meta predicate," specified by <pred_skel>, is defined		in a module, that module should contain a meta_predicate		declaration, and then an "applies" statement is unnecessary.		To show the correspondence between meta_predicate declarations		and "applies" statements, the meta_predicate declaration:			:- meta_predicate maplist(2, ?, ?).		in the Prolog file corresponds to			applies( maplist(Pred, _, _), Pred+2 ).		in the definition file.		Both declare that maplist/3 uses its first argument as a goal		and expands it with two additional arguments.For example, maplist/3 could take a predicate and two lists  as arguments, e.g.	:- maplist(foo,[X1,X2,X3],[Y1,Y2,Y3]).and successively apply the predicate to the i-th elements of each of the lists.I.e.  the above goal clause would be equivalent to 	:- foo(X1,Y1), foo(X2,Y2), foo(X3,Y3).This expresses the fact that the first argument of  maplist is  a predicate andthat it is to be called with two additional arguments, i.e.  the  above call ofmaplist/3 results in calls to foo/2.   The '+2'  would be  omitted if maplist/3called foo with no additional arguments, i.e.  if  foo/0 was  to be referenced.Note that  if  maplist is  called with  a variable  as its  first argument, thecross-referencer cannot determine what predicate(s) are to be called  and so nospecial action is taken.  VERY IMPORTANT NOTE: The compound term which is the first argument of applies/2is a skeleton, that is all of its arguments MUST  be variables  as indicated inthe example.  This term will be matched against the calls in  your program, andif you fill it in with random constants it won't unify.  II-D.  ADDED DETAILSThe user can modify the standard definitions as described in xrefdefns.pl,which is preserved for compatibility, but no longer contains any activestatements.  That file mentions addition details not covered here for unusualsituations.III.  AUTOMATIC UPDATING OF 'module' AND 'use_module' DECLARATIONSIn order to make  use  of  this  facility  it  is  necessary  to  surround  thedeclarations part of each file with special markers like this:  	%declarations%	:- module ...<whatever>	%end%Everything  between  the two markers will be destroyed, and a new set of 'module' and 'use_module' declarations will be inserted. If  there  are  no  'module' or 'use_module'  declarations in the file to start with, the marker %here% may be used in place of the pair %declarations% %end%.However, the xref program cannot do intelligent modularization for you.  Usersare advised to consider how they would like their system to be modularized anduse xref only as a aid in this regard.As described in Sections I and II, xref will format module and use_modulestatements for all files and write them into one so-called "globals file".The user can use this as a template for inserting actual declarationsinto the files to be modularized.  It is quite possible that the user willchoose to group several files into one module for semantic reasons, butxref can not make any grouping; it will just make each file a separatemodule.