%   Package: caseconv%   Author : Richard A. O'Keefe%   Updated: 19 May 1987%   Defines: upper-casing and lower-casing.%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved.:- module(caseconv, [	lower/1,	lower_chars/1,	lower/2,	lower_chars/2,	mixed/1,	mixed_chars/1,	mixed/2,	mixed_chars/2,	upper/1,	upper_chars/1,	upper/2,	upper_chars/2   ]).:- use_module(library(ctypes), [	is_alpha/1,	is_lower/1,	is_upper/1,	to_lower/2,	to_upper/2   ]),   use_module(library(strings), [    %	atom_chars/2,		% 2.0: built-in    %	number_chars/2,		% 2.0: built-in	string_chars/2,	string_char/3,	string/1   ]).sccs_id('"@(#)87/03/26 caseconv.pl	98.1"')./*  This file is intended as an example of how trivially easy it    is to crunch characters in Prolog, without needing a special    string data type.  As Xerox Quintus Prolog has strings forced    on it by Lisp, this package will work nicely with strings if    it has to (hence the use of library(strings)).  The first    argument of all of these predicates must be a text object.    That is, a string (in Xerox Quintus Prolog) or an atom.    lower(X, Y) converts X to a constant of the same type with	all upper case letters forced to lower case, binds Y to it.    upper(X, Y) converts X to a constant of the same type with	all lower case letters forced to upper case, binds Y to it.    mixed(X, Y) converts X to a constant of the same type with	the first letter of each group of letters in upper case,	subsequent letters of each group in lower case, binds Y to it.    {lower,upper,mixed}_chars(X, Y) convert a list of character codes    X to a list of character codes Y.  We need separate predicates    because the empty list of characters "" is the empty list [],    which in Xerox Quintus Prolog is the atom NIL, which contains    letters in its name.  You would expect lower_chars("", "") to    be true, and it is, but lower("", X) means lower('NIL', X),    and would bind X to nil.    lower(X) is true when the name of X has no upper case letters.    upper(X) is true when the name of X has no lower case letters.    mixed(X) is true when the name of X has letters of both cases.    {lower,upper,mixed}_chars(X) are true when X is a list of    character codes of the indicated sort.  Again, we have to have    separate predicates because lower_chars("") should be true,    but lower("") means lower('NIL') which is false.*/%   same_type_of_name(X, Y, Chars)%   is true when X and Y are the same kind of constant (both are numbers,%   or both are atoms, or both are strings -- if they exist), and%   the name of Y is the list of ASCII codes Chars.  This really%   belongs in library(strings) and may move there later.same_type_of_name(X, Y, Chars) :-	(   atom(X)   -> atom_chars(Y, Chars)	;   string(X) -> string_chars(Y, Chars)	).lower(Mixed, Lower) :-	name(Mixed, Mixedchars),	lower_chars(Mixedchars, Lowerchars),	same_type_of_name(Mixed, Lower, Lowerchars).lower_chars([], []).lower_chars([M|Ms], [L|Ls]) :-	to_lower(M, L),	lower_chars(Ms, Ls).upper(Mixed, Upper) :-	name(Mixed, Mixedchars),	upper_chars(Mixedchars, Upperchars),	same_type_of_name(Mixed, Upper, Upperchars).upper_chars([], []).upper_chars([M|Ms], [U|Us]) :-	to_upper(M, U),	upper_chars(Ms, Us).mixed(Given, Mixed) :-	name(Given, GivenChars),	mixed_chars(GivenChars, MixedChars, 0),	same_type_of_name(Given, Mixed, MixedChars).mixed_chars(GivenChars, MixedChars) :-	mixed_chars(GivenChars, MixedChars, 0).mixed_chars([], [], _).mixed_chars([G|Gs], [M|Ms], Flag) :-	is_alpha(G),	!,	(   Flag =:= 0 -> to_upper(G, M)	;   /* not 1st */ to_lower(G, M)	),	mixed_chars(Gs, Ms, 1).mixed_chars([C|Gs], [C|Ms], _) :-	mixed_chars(Gs, Ms, 0).lower(Text) :-	\+ (	    string_char(_, Text, Upper),	    is_upper(Upper)	).lower_chars(Chars) :-	\+ (	    chars_char(Chars, Upper),	    is_upper(Upper)	).upper(Text) :-	\+ (	    string_char(_, Text, Lower),	    is_lower(Lower)	).upper_chars(Chars) :-	\+ (	    chars_char(Chars, Lower),	    is_lower(Lower)	).mixed(Text) :-	string_char(_, Text, Lower), is_lower(Lower),	!,	string_char(_, Text, Upper), is_upper(Upper),	!.mixed_chars(Chars) :-	chars_char(Chars, Lower), is_lower(Lower),	!,	chars_char(Chars, Upper), is_upper(Upper),	!.chars_char([Char|_], Char).		% this is just member/2chars_char([_|Chars], Char) :-		% with the argument swapped.	chars_char(Chars, Char).