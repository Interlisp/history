%   Package: ordered%   Author : Richard A. O'Keefe%   Updated: 3/26/87%   Purpose: Define the "ordered" predicates.%   Adapted from shared code written by the same author; all changes%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved.:- module(ordered, [	ordered/1,	ordered/2,	select_max/3,	select_max/4,	select_min/3,	select_min/4   ]).:- meta_predicate	ordered(2, +),	    ordered_(+, +, 2),	select_min(2, ?, +, ?),	    sel_min_gen(+, ?, 2, ?),		sel_min_gen(+, ?, +, 2, -, ?),	select_max(2, ?, +, ?),	    sel_max_gen(+, ?, 2, ?),		sel_max_gen(+, ?, +, 2, -, ?).:- use_module(library(call), [	call/3   ])./* pred	ordered(list(T)),	    ordered_(list(T), T),	ordered(void(T,T), list(T)),	    ordered_(list(T), T, void(T,T)),	select_min(S, list(S), list(S)),	    sel_min_trm(list(S), list(S), S),		sel_min_trm(list(S), list(S), S, list(S), list(S)),	select_max(S, list(S), list(S)),	    sel_max_trm(list(S), list(S), S),		sel_max_trm(list(S), list(S), S, list(S), list(S)),	select_min(void(T,T), T, list(T), list(T)),	    sel_min_gen(list(T), list(T), void(T,T), T),		sel_min_gen(list(T), list(T), T, void(T,T), list(T), list(T)),	select_max(void(T,T), T, list(T), list(T)),	    sel_max_gen(list(T), list(T), void(T,T), T),		sel_max_gen(list(T), list(T), T, void(T,T), list(T), list(T)).*/sccs_id('"@(#)87/03/26 ordered.pl	98.2"').%   ordered(List)%   is true when List is a list of terms [T1,T2,...,Tn] such that%   for all k in 2..n Tk-1 @=< Tk, i.e. T1 @=< T2 @=< T3 ...%   The output of keysort/2 is always ordered, and so is that of%   sort/2.  Beware: just because a list is ordered does not mean%   that it is the representation of an ordered set; it might contain%   duplicates.  E.g. L = [1,2,2,3] & sort(L,M) => ordered(L) & M\=L.ordered([]).ordered([Head|Tail]) :-	ordered_(Tail, Head).ordered_([], _).ordered_([Head|Tail], Left) :-	Left @=< Head,	ordered_(Tail, Head).%   ordered(P, [T1,T2,...,Tn]) means P(T1,T2) & P(T2,T3) & ...%   i.e. that the second argument is ordered if you regard the%   first argument as =<.  This is good for generating prefixes%   of sequences, e.g. L = [1,_,_,_,_] & ordered(times(2),L) yields%   L = [1,2,4,8,16].ordered(_, []).ordered(Relation, [Head|Tail]) :-	ordered_(Tail, Head, Relation).ordered_([], _, _).ordered_([Head|Tail], Left, Relation) :-	call(Relation, Left, Head),	ordered_(Tail, Head, Relation)./*  Here we define four predicates:	select_min(Minimum, Set, Residue)	select_max(Maximim, Set, Residue)	select_min(Pred, Minimum, Set, Residue)	select_max(Pred, Maximum, Set, Residue)    The general idea is that they select an item out of a list in the    style of select/3 (see library(sets)), and that item is the left-    most (minimum,maximum) using the (standard term ordering @=<, the    ordering defined by Pred).  An earlier version of this file used    arithmetic ordering as the default; this was changed to use term    ordering for consistency with orderd/2 and library(ordprefix).    Set is always a list, Minimum (or Maximum) is a member of that    list, and Residue is the whole of Set except for the one element.    We could have defined select_min/3 this way:    select_min(Minimum, Set, Residue) :-	    append(Front, [Minimum|Back], Set),	    append(Front, Back, Residue),	    forall(member(X,Front), \+(X =< Minimum)),	    forall(member(X,Back),     Minimum =< X ).    That is, Minimum is less than every element preceding it in Set,    and less than or equal to every element following it in Set.    The two predicates with a Pred argument use that instead of =< .    The advantage of this code is that it uses O(N) comparisons,    whereas the more obvious code could do O(N^2).    With these routines, we could define selection sort:	ssort([], []).	ssort(List, [Minimum|Sorted]) :-		select_min(Minimum, List, Rest),		ssort(Rest, Sorted).    Considering the requirements for this kind of use led directly    to the code in this file.*/%   select_min(Element, Set, Residue%   find the least Element of Set.select_min(Element, Set, Residue) :-	sel_min_trm(Set, Residue, Element).sel_min_trm([Head|Tail], Residue, Element) :-	sel_min_trm([Head|Tail], Residue, Head, List1, Residue1),	!,	sel_min_trm(List1, Residue1, Element).sel_min_trm([Head|Tail], Tail, Head).sel_min_trm([], _, _, _, _) :- !, fail.sel_min_trm([Head|Tail], [Head|Residue], Current, List1, Residue1) :-	Current @=< Head,	!,	sel_min_trm(Tail, Residue, Current, List1, Residue1).sel_min_trm(List, Residue, _, List, Residue).  % non-empty list!%   select_min(Pred, Element, Set, Residue)%   find the least Element of Set, i.e. Pred(Element,X) for all X in Set.select_min(Pred, Element, Set, Residue) :-	sel_min_gen(Set, Residue, Pred, Element).sel_min_gen([Head|Tail], Residue, Pred, Element) :-	sel_min_gen([Head|Tail], Residue, Head, Pred, List1, Residue1),	!,	sel_min_gen(List1, Residue1, Pred, Element).sel_min_gen([Head|Tail], Tail, _, Head).sel_min_gen([], _, _, _, _, _) :- !, fail.sel_min_gen([Head|Tail], [Head|Residue], Current, Pred, List1, Residue1) :-	call(Pred, Current, Head),	!,	sel_min_gen(Tail, Residue, Current, Pred, List1, Residue1).sel_min_gen(List, Residue, _, _, List, Residue).  % non-empty list!%   select_max(Maximum, Set, Residue)%   binds Maximum to the (leftmost) maximum element of the Set,%   and Residue to the other elements in the same order.select_max(Element, Set, Residue) :-	sel_max_trm(Set, Residue, Element).sel_max_trm([Head|Tail], Residue, Element) :-	sel_max_trm([Head|Tail], Residue, Head, List1, Residue1),	!,	sel_max_trm(List1, Residue1, Element).sel_max_trm([Head|Tail], Tail, Head).sel_max_trm([], _, _, _, _) :- !, fail.sel_max_trm([Head|Tail], [Head|Residue], Current, List1, Residue1) :-	Head @=< Current,	!,	sel_max_trm(Tail, Residue, Current, List1, Residue1).sel_max_trm(List, Residue, _, List, Residue).  % non-empty list!%   select_min(Pred, Element, Set, Residue)%   find the least Element of Set, i.e. Pred(Element,X) for all X in Set.select_max(Pred, Element, Set, Residue) :-	sel_max_gen(Set, Residue, Pred, Element).sel_max_gen([Head|Tail], Residue, Pred, Element) :-	sel_max_gen([Head|Tail], Residue, Head, Pred, List1, Residue1),	!,	sel_max_gen(List1, Residue1, Pred, Element).sel_max_gen([Head|Tail], Tail, _, Head).sel_max_gen([], _, _, _, _, _) :- !, fail.sel_max_gen([Head|Tail], [Head|Residue], Current, Pred, List1, Residue1) :-	call(Pred, Head, Current),	!,	sel_max_gen(Tail, Residue, Current, Pred, List1, Residue1).sel_max_gen(List, Residue, _, _, List, Residue).  % non-empty list!