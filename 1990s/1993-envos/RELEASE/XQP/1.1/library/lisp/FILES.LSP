;;; File   : FILES.LSP;;; Author : Richard A. O'Keefe;;; Purpose: support for library(files);;; Updated: Friday September 11th, 1987.;;; The Prolog end of this stuff wants NIL for success,;;; non-NIL for failure, and would prefer the non-NIL result;;; to be an error code.  The Lisp functions in this file;;; are expressed in terms of NIL for failure, so QP.PROTECT;;; inverts this.(CL:IN-PACKAGE "IL")(CL:DEFMACRO QP.PROTECT (&REST FORMS)    ;; The idea is that (QP.PROTECT E1 ... En)    ;; is the same as (AND E1 ... En) except that any error    ;; occurring in any Ei is treated as failure (NIL).   `(LET ((RESULT (NLSETQ ,(CONS 'AND FORMS))))	(OR (NULL RESULT) (NOT (CAR RESULT)) )))(CL:DEFUN QP.RENAME.FILE (OLDFILE NEWFILE)    ;; returns the new full name of the file if successful,    ;; NIL otherwise.  (A full name can't be NIL.)    ;; How come RENAMEFILE signals an error but DELFILE doesn't?    (QP.PROTECT	(SETQ OLDFILE (FULLNAME OLDFILE 'OLD))	(SETQ NEWFILE (FULLNAME NEWFILE 'NEW))	(RENAMEFILE OLDFILE NEWFILE)    ))(CL:DEFUN QP.BACKUP.FILE (OLDFILE NEWFILE)    ;; returns the new full name of the backed up version if successul,    ;; NIL otherwise.  Foo.Baz;N -> Foo.BAK;1 in general.    (QP.PROTECT	(SETQ OLDFILE (FULLNAME OLDFILE 'OLD))	(SETQ NEWFILE (FULLNAME (PACKFILENAME 'EXTENSION 'BAK 'VERSION NIL				  'BODY OLDFILE) 'NEW))	(RENAMEFILE OLDFILE NEWFILE)    ))(CL:DEFUN QP.DELETE.FILE (OLDFILE)    ;; returns the full name of the no-longer existing file if successful,    ;; NIL otherwise.  Note that the DELFILE is not supposed to raise any    ;; errors, but let's not be too unwary.    (QP.PROTECT	(SETQ OLDFILE (FULLNAME OLDFILE 'OLDEST))	(DELFILE OLDFILE)    ))(CL:DEFUN QP.ACCESS.FILE (OLDFILE ACCESS)    ;; ACCESS is "exists", "input", "output", or "append",    ;; coded as an integer for compatibility with the UNIX/VMS version.    ;; FULLNAME isn't documented as signalling an error, but the    ;; network functions may time out.    (QP.PROTECT	(if (NEQ (LOGAND ACCESS 3) 0) then	    ;;  OUTPUT OR APPEND	    (if (NEQ (LOGAND ACCESS 4) 0) then		;;  AND INPUT		(FULLNAME OLDFILE 'OLD/NEW)	    else		(FULLNAME OLDFILE 'NEW)	    )	else	    ;;  INPUT OR EXISTS	    (FULLNAME OLDFILE 'OLD)	)    ))(CL:DEFUN QP.CANOPEN.FILE (FILE ACCESS STREAM)    ;; Alas, the only way of telling whether you would be able to    ;; open a file is to try it and see.  We really need that QP.PROTECT    ;; here.  Actually, this should really have an UNWIND-PROTECT in it.    (QP.PROTECT	(SETQ STREAM (OPENSTREAM FILE ACCESS))	(SETQ FILE (FULLNAME STREAM))	(CLOSEF STREAM)	(if (AND (EQ ACCESS 'OUTPUT) FILE) then (DELFILE FILE) else FILE)    ))STOP