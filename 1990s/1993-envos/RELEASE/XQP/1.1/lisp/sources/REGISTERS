(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(FILECREATED "30-Jul-87 15:36:38" {DSK}<LISPFILES>DCOMS>REGISTERS.\;4 57025        |changes| |to:|  (FUNCTIONS XQP::|put.4|)      |previous| |date:| "28-Jul-87 10:28:23" {DSK}<LISPFILES>DCOMS>REGISTERS.\;3); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(PRETTYCOMPRINT REGISTERSCOMS)(RPAQQ REGISTERSCOMS ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>REGISTERS.LSP;3, loaded 16-Jun-87 14:55:29")                                          (* |;;| "SCCS   : @(#)REGISTERS.LSP	8204.2 3/13/87 File   : $xerox/registers.lsp Author : Richard A. O'Keefe Purpose: Define the register access macros.")                      (* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")                                          (* |;;| "The first working version of the Lisp emulator stored the simulated registers of the Prolog machine in Lisp variables (bound in a PROG). So indeed does this version.  However, the mixed Lisp/micro-code one will store the Prolog registers in physical hardware-type registers, so that referencing them freely as Lisp variables will no longer be possible.  This file (together with tags.lsp, cell.lsp, and code.lsp) defines a set of macros which explicitly indicates register access (get.nn X) explicitly indicates register update (put.nn X V) enables the most common macros to dispense with this. For example, (get.cell X N) is only supposed to work when X is the name of a 24-bit register, so we can leave IT to do the checking, and just write (get.cell R 0) rather than (get.cell (get.24 R) 0). A benefit of this change is that the macros now CHECK that their arguments are the right sort of thing.")                      (FUNCTIONS XQP::|PrologZeroExtend| XQP::|PrologMentionTwice|)                                          (* |;;| "define functions and optimizers to directly access and set Prolog registers.  This enables one to run code interpreted, and still have register loading and storing compiled inline.  This is more than worth the effort of using optimizers.  All the uses of (OPCODES x) forms in the XQP sources are hidden in these few macros.  Actually, the functional forms don't have to be around at runtime except for debugging the system, so perhaps they should be moved to DEBUG.LSP or some such.  Note that the functional forms MUST be compiled in order to work.")                      (FUNCTIONS XQP::|\\RdPrologPtr| XQP::|\\RdPrologTag| XQP::|\\WrtPtr&0Tag|                              XQP::|\\WrtPtr&Tag|)                      (OPTIMIZERS XQP::|\\RdPrologPtr| XQP::|\\RdPrologTag| XQP::|\\WrtPtr&0Tag|                              XQP::|\\WrtPtr&Tag|)                                          (* |;;| "The following macros further hide details of register access.")                      (FUNCTIONS XQP::\\GET.HI.16 XQP::\\GET.LO.16 XQP::\\PUT.HI.16 XQP::\\PUT.LO.16)                                          (* |;;| "So that the debugger can read out of arbitrary registers, we need a version of these routines which evaluates the register name, For lack of a better naming convention, I have called these new routines DynReadProlog{Tag,Ptr,Nbr}.")                      (FUNCTIONS XQP::|DynReadPrologTag| XQP::|DynReadPrologPtr|                              XQP::|DynReadPrologNbr|)                                          (* |;;| "There is one 4-bit register, W. The idea is that this register is OR-ed with the top byte of the op-code. W is the mode register.  It is also set in calls to the general unifier, which uses it to decide how many operand words to skip over. In the Lisp version of the emulator, W is actually a 16-bit register, and the \"1\" value for the mode bit is actually 1<<8 (=256).")                      (FUNCTIONS XQP::|get.4| XQP::|put.4|)                                          (* |;;| "There are two 16-bit registers, N and I. In source positions, I also allow integers <n>, and, because it makes some macros easier to write, (get.code P 0).")                      (FUNCTIONS XQP::|get.16| XQP::|put.16| |zero| XQP::|decrement.counter|                              XQP::|increment.counter|)                                          (* |;;| "There are 11 24-bit registers.  Of them, B0, TR, and CP can go in slow registers.  Of the rest, S is free more often than the others.")                      (CONSTANTS XQP::QP.32 XQP::QP.24)                      (FUNCTIONS XQP::|get.24| XQP::|put.24|)                                          (* |;;|           "There are only two 32-bit registers (apart from the A registers), and they are T0 and T1.")                      (PROPERTIES XQP::|get.32|)                                          (* |;;| "Storing a 32-bit quantity into a register is similar to storing it in memory, except that it is easier to store the tag and pointer form than the 16+16 form.  See put.cell in cell.lsp.")                      (FUNCTIONS XQP::|put.32| XQP::|put.32.macro|)                                          (* |;;| "The two registers T0,T1 are also used as a \"stack\" for arithmetic. In the Sun and Vax versions of the emulator, these registers hold unboxed numbers, and the mode (W) says whether they are integers (mode=READ) or floats (mode=WRITE).  In this version of the emulator, we don't do that; they just hold Lisp pointers.  One reason for this is the simplicity of the approach.  Another reason is that the Koto release of Interlisp-D has bignums, so that an \"unboxed\" integer can be almost any size, not just 32 bits.")                                          (* |;;| "The macros (put.nb Tx --) and (get.nb Tx) are really just versions of put.24 and get.24, except that (a) they check that we are talking about T0 or T1 (the only registers which are supposed to hold arithmetic results), and (b) they make it clear that we are putting just number addresses into these registers and not 32-bit cells. We could put proper tags on these registers, and the next version of the emulator may well do that, but for now we don't bother.")                                          (* |;;| "This distinction was briefly useful for another purpose: put.nb used to \\ADDREF everything.  Now that the GC hook has been installed, this is no longer done, and ADD.REF is only called when things are put into memory.")                      (FUNCTIONS XQP::|get.nb| XQP::|put.nb|)                                          (* |;;| "(QP.BLOCK '(k1 ... kn)) creates an n-(16-bit)-word block, and initialises it. (def.block T0 T1 k1 ... kn) declares two global variables T0 and T1. T0 is initialised to (QP.BLOCK (LIST k1 ... kn)). T1 is initialised to B0+1. The coding of def.block is rather tricky because we have to hack around the file package's poisonous LIFO habit.  A pair of consecutive def.var's *cannot* be used!")                      (FUNCTIONS XQP::QP.BLOCK XQP::|def.block|)                                          (* |;;| "The macros (get.Aval x) (put.Aval x val) are register versions of get.Amem and put.Amem. When we are talking about particular registers in the code, it is convenient to refer to them as 1, 2, 3, 4.  But when the register number is held in a 16-bit register, namely I or N, the number is actually 0, 2, 4, or 6.")                                          (* |;;| "(aregB <reg>) maps an A register to the 16-bit mask which should be given to RDPROLOGPTR to read the whole 32-bit register.")                      (VARIABLES XQP::|aregB0| XQP::|aregB1|)                      (P (EVAL (REMOVE-COMMENTS '(PROGN (SETQ XQP::|aregB0|                                                              (XQP::QP.BLOCK                                                               (LIST (XQP::|PrologNameToURegs|                                                                      'A1)                                                                                                                                  (* \; "0->A1")                                                                     0                                                                                                                                  (* \; "1")                                                                     (XQP::|PrologNameToURegs|                                                                      'A2)                                                                                                                                  (* \; "2->A2")                                                                     0                                                                                                                                  (* \; "3")                                                                     (XQP::|PrologNameToURegs|                                                                      'A3)                                                                                                                                  (* \; "4->A3")                                                                     0                                                                                                                                  (* \; "5")                                                                     (XQP::|PrologNameToURegs|                                                                      'A4)                                                                                                                                  (* \; "6->A4")                                                                     0                                                                                                                                  (* \; "7"))))                                                        (SETQ XQP::|aregB1| (\\ADDBASE XQP::|aregB0|                                                                                    1))))))                      (FUNCTIONS XQP::|aregB|)                                          (* |;;| "(aregW <reg> h/l) maps an A register to the 16-bit mask which should be given to WRTPTR&0TAG to store 16 bits.  If h/l is 0, the high register is wanted, if h/l is 1, the low register is wanted.")                      (VARIABLES XQP::|aregW0| XQP::|aregW1|)                      (P (EVAL (REMOVE-COMMENTS                                '(PROGN (SETQ XQP::|aregW0| (XQP::QP.BLOCK                                                             (LIST (XQP::|PrologMentionTwice|                                                                    (XQP::|PrologNameToHiUReg|                                                                     'A1))                                                                                                                                (* \; "0 -> A1.hi")                                                                   (XQP::|PrologMentionTwice|                                                                    (XQP::|PrologNameToLoUReg|                                                                     'A1))                                                                                                                                (* \; "1 -> A1.lo")                                                                   (XQP::|PrologMentionTwice|                                                                    (XQP::|PrologNameToHiUReg|                                                                     'A2))                                                                                                                                (* \; "2 -> A2.hi")                                                                   (XQP::|PrologMentionTwice|                                                                    (XQP::|PrologNameToLoUReg|                                                                     'A2))                                                                                                                                (* \; "3 -> A2.lo")                                                                   (XQP::|PrologMentionTwice|                                                                    (XQP::|PrologNameToHiUReg|                                                                     'A3))                                                                                                                                (* \; "4 -> A3.hi")                                                                   (XQP::|PrologMentionTwice|                                                                    (XQP::|PrologNameToLoUReg|                                                                     'A3))                                                                                                                                (* \; "5 -> A3.lo")                                                                   (XQP::|PrologMentionTwice|                                                                    (XQP::|PrologNameToHiUReg|                                                                     'A4))                                                                                                                                (* \; "6 -> A4.hi")                                                                   (XQP::|PrologMentionTwice|                                                                    (XQP::|PrologNameToLoUReg|                                                                     'A4))                                                                                                                                (* \; "7 -> A4.lo"))))                                        (SETQ XQP::|aregW1| (\\ADDBASE XQP::|aregW0| 1))))))                      (FUNCTIONS XQP::|aregW|)                                          (* |;;| "(aregR <reg> h/l) maps an A register to the 16-bit mask which should be given to RDPROLOGPTR to read 16 bits.  If h/l is 0, the high register is wanted, if h/l is 1, the low register is wanted.")                      (VARIABLES XQP::|aregR0| XQP::|aregR1|)                      (P (EVAL (REMOVE-COMMENTS                                '(PROGN (SETQ XQP::|aregR0| (XQP::QP.BLOCK                                                             (LIST (XQP::|PrologZeroExtend|                                                                    (XQP::|PrologNameToHiUReg|                                                                     'A1))                                                                                                                                (* \; "0 -> A1.hi")                                                                   (XQP::|PrologZeroExtend|                                                                    (XQP::|PrologNameToLoUReg|                                                                     'A1))                                                                                                                                (* \; "1 -> A1.lo")                                                                   (XQP::|PrologZeroExtend|                                                                    (XQP::|PrologNameToHiUReg|                                                                     'A2))                                                                                                                                (* \; "2 -> A2.hi")                                                                   (XQP::|PrologZeroExtend|                                                                    (XQP::|PrologNameToLoUReg|                                                                     'A2))                                                                                                                                (* \; "3 -> A2.lo")                                                                   (XQP::|PrologZeroExtend|                                                                    (XQP::|PrologNameToHiUReg|                                                                     'A3))                                                                                                                                (* \; "4 -> A3.hi")                                                                   (XQP::|PrologZeroExtend|                                                                    (XQP::|PrologNameToLoUReg|                                                                     'A3))                                                                                                                                (* \; "5 -> A3.lo")                                                                   (XQP::|PrologZeroExtend|                                                                    (XQP::|PrologNameToHiUReg|                                                                     'A4))                                                                                                                                (* \; "6 -> A4.hi")                                                                   (XQP::|PrologZeroExtend|                                                                    (XQP::|PrologNameToLoUReg|                                                                     'A4))                                                                                                                                (* \; "7 -> A4.lo"))))                                        (SETQ XQP::|aregR1| (\\ADDBASE XQP::|aregR0| 1))))))                      (FUNCTIONS XQP::|aregR|)                                          (* |;;| "(get.Aval Reg)")                      (PROPERTIES XQP::|get.Aval|)                      (FUNCTIONS XQP::|put.Aval.macro| XQP::|put.Aval|)                      (PROP MAKEFILE-ENVIRONMENT)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>REGISTERS.LSP;3, loaded 16-Jun-87 14:55:29")(* |;;| "SCCS   : @(#)REGISTERS.LSP	8204.2 3/13/87 File   : $xerox/registers.lsp Author : Richard A. O'Keefe Purpose: Define the register access macros.")(* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")(* |;;| "The first working version of the Lisp emulator stored the simulated registers of the Prolog machine in Lisp variables (bound in a PROG). So indeed does this version.  However, the mixed Lisp/micro-code one will store the Prolog registers in physical hardware-type registers, so that referencing them freely as Lisp variables will no longer be possible.  This file (together with tags.lsp, cell.lsp, and code.lsp) defines a set of macros which explicitly indicates register access (get.nn X) explicitly indicates register update (put.nn X V) enables the most common macros to dispense with this. For example, (get.cell X N) is only supposed to work when X is the name of a 24-bit register, so we can leave IT to do the checking, and just write (get.cell R 0) rather than (get.cell (get.24 R) 0). A benefit of this change is that the macros now CHECK that their arguments are the right sort of thing.")(XQP::|def.subr| XQP::|PrologZeroExtend| (|Reg|) (LOGOR (LLSH |Reg| 8)                                                        (XQP::|PrologNameToLoUReg| 'XQP::|Zero|)))(XQP::|def.subr| XQP::|PrologMentionTwice| (|Reg|) (ITIMES |Reg| 257))(* |;;| "define functions and optimizers to directly access and set Prolog registers.  This enables one to run code interpreted, and still have register loading and storing compiled inline.  This is more than worth the effort of using optimizers.  All the uses of (OPCODES x) forms in the XQP sources are hidden in these few macros.  Actually, the functional forms don't have to be around at runtime except for debugging the system, so perhaps they should be moved to DEBUG.LSP or some such.  Note that the functional forms MUST be compiled in order to work.")(XQP::|def.subr| XQP::|\\RdPrologPtr| (XQP::|RegNumber|) ((OPCODES RDPROLOGPTR)                                                          XQP::|RegNumber|))(XQP::|def.subr| XQP::|\\RdPrologTag| (XQP::|RegNumber|) ((OPCODES RDPROLOGTAG)                                                          XQP::|RegNumber|))(XQP::|def.subr| XQP::|\\WrtPtr&0Tag| (XQP::|RegNumber| XQP::|Val|) ((OPCODES WRTPTR&0TAG)                                                                     XQP::|RegNumber| XQP::|Val|))(XQP::|def.subr| XQP::|\\WrtPtr&Tag| (XQP::|RegNumber| XQP::|Val| XQP::|Tag|) ((OPCODES WRTPTR&TAG)                                                                               XQP::|RegNumber|                                                                                XQP::|Val| XQP::|Tag|))(DEFOPTIMIZER XQP::|\\RdPrologPtr| (XQP::|RegNumber|) `((OPCODES RDPROLOGPTR)                                                        ,XQP::|RegNumber|))(DEFOPTIMIZER XQP::|\\RdPrologTag| (XQP::|RegNumber|) `((OPCODES RDPROLOGTAG)                                                        ,XQP::|RegNumber|))(DEFOPTIMIZER XQP::|\\WrtPtr&0Tag| (XQP::|RegNumber| XQP::|Val|) `((OPCODES WRTPTR&0TAG)                                                                   ,XQP::|RegNumber|                                                                   ,XQP::|Val|))(DEFOPTIMIZER XQP::|\\WrtPtr&Tag| (XQP::|RegNumber| XQP::|Val| XQP::|Tag|) `((OPCODES WRTPTR&TAG)                                                                             ,XQP::|RegNumber|                                                                             ,XQP::|Val|                                                                             ,XQP::|Tag|))(* |;;| "The following macros further hide details of register access.")(XQP::|def.macro| XQP::\\GET.HI.16 (|Reg|) `(\\LOLOC (XQP::|\\RdPrologPtr| ,(XQP::|PrologZeroExtend|                                                                             (                                                                            XQP::|PrologNameToHiUReg|                                                                              |Reg|)))))(XQP::|def.macro| XQP::\\GET.LO.16 (|Reg|) `(\\LOLOC (XQP::|\\RdPrologPtr| ,(XQP::|PrologZeroExtend|                                                                             (                                                                            XQP::|PrologNameToLoUReg|                                                                              |Reg|)))))(XQP::|def.macro| XQP::\\PUT.HI.16 (|Reg| XQP::|Val|) `(XQP::|\\WrtPtr&0Tag|                                                        ,(XQP::|PrologMentionTwice| (                                                                            XQP::|PrologNameToHiUReg|                                                                                     |Reg|))                                                        ,XQP::|Val|))(XQP::|def.macro| XQP::\\PUT.LO.16 (|Reg| XQP::|Val|) `(XQP::|\\WrtPtr&0Tag|                                                        ,(XQP::|PrologMentionTwice| (                                                                            XQP::|PrologNameToLoUReg|                                                                                     |Reg|))                                                        ,XQP::|Val|))(* |;;| "So that the debugger can read out of arbitrary registers, we need a version of these routines which evaluates the register name, For lack of a better naming convention, I have called these new routines DynReadProlog{Tag,Ptr,Nbr}.")(XQP::|def.subr| XQP::|DynReadPrologTag| (|Reg|) (XQP::|\\RdPrologTag| (XQP::|PrologNameToURegs|                                                                        |Reg|)))(XQP::|def.subr| XQP::|DynReadPrologPtr| (|Reg|) (XQP::|\\RdPrologPtr| (XQP::|PrologNameToURegs|                                                                        |Reg|)))(XQP::|def.subr| XQP::|DynReadPrologNbr| (|Reg|) (\\LOLOC (XQP::|\\RdPrologPtr| (                                                                              XQP::|PrologZeroExtend|                                                                                 (                                                                            XQP::|PrologNameToLoUReg|                                                                                  |Reg|)))))(* |;;| "There is one 4-bit register, W. The idea is that this register is OR-ed with the top byte of the op-code. W is the mode register.  It is also set in calls to the general unifier, which uses it to decide how many operand words to skip over. In the Lisp version of the emulator, W is actually a 16-bit register, and the \"1\" value for the mode bit is actually 1<<8 (=256).")(XQP::|def.macro| XQP::|get.4| (X) (|if| (NEQ X 'W)                                       |then| (SHOULDNT 'XQP::|get.4|))                                   `(XQP::\\GET.LO.16 W))(XQP::|def.macro| XQP::|put.4| (X V) (|if| (NEQ X 'W)                                         |then| (SHOULDNT 'XQP::|put.4|))                                     `(XQP::\\PUT.LO.16 W ,(|if| (EQ V 'READ)                                                               |then| 0                                                             |elseif| (EQ V 'WRITE)                                                               |then| 256                                                             |elseif| (SMALLP V)                                                               |then| V                                                             |elseif| (CL:SYMBOLP V)                                                               |then| V                                                             |else| (SHOULDNT 'XQP::|put.4|))))(* |;;| "There are two 16-bit registers, N and I. In source positions, I also allow integers <n>, and, because it makes some macros easier to write, (get.code P 0).")(XQP::|def.macro| XQP::|get.16| (X) (|if| (SMALLP X)                                        |then| X                                      |elseif| (MEMB X '(N I))                                        |then| `(XQP::\\GET.LO.16 ,X)                                      |elseif| (AND (LISTP X)                                                    (EQ (CAR X)                                                        'XQP::|get.code|))                                        |then| X                                      |else| (SHOULDNT 'XQP::|get.16|)))(XQP::|def.macro| XQP::|put.16| (X Y) (|if| (MEMB X '(N I))                                          |then| `(XQP::\\PUT.LO.16 ,X ,Y)                                        |else| (SHOULDNT 'XQP::|put.16|)))(XQP::|def.macro| |zero| (X) `(EQ (XQP::|get.16| ,X)                                  0))(XQP::|def.macro| XQP::|decrement.counter| (X) `(XQP::|put.16| ,X (IPLUS (XQP::|get.16| ,X)                                                                         -1)))(XQP::|def.macro| XQP::|increment.counter| (X) `(XQP::|put.16| ,X (IPLUS (XQP::|get.16| ,X)                                                                         1)))(* |;;| "There are 11 24-bit registers.  Of them, B0, TR, and CP can go in slow registers.  Of the rest, S is free more often than the others.")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::QP.32 (XQP::T0                                   (* \; "scratch, TOS in arithmetic")                         T1                                                             (* \; "scratch. TOS-1 in arithmetic")                         A1 A2 A3 A4                         (* \;                                                  "the first four A\"registers\" are really registers")))(RPAQQ XQP::QP.24 (P                                         (* \; "next instruction pointer")                     CP                                                             (* \; "continuation (envsize) pointer")                     R                                                             (* \;                                                              "scratch, usually associated with T0")                     C                                                             (* \;                                                              "scratch, usually associated with T1")                     S                                                             (* \;                                                              "points into heap, used in unification")                     E                                                             (* \; "current environment pointer")                     B                                                             (* \; "current choice-point pointer")                     B0                                                             (* \;                                                "which choice-point was active when this call started")                     H                                                             (* \;                                                              "points to the top of the global stack")                     XQP::HB                                                             (* \; "where H was when B was set")                     TR                                                             (* \; "points to the top of the trail")                     XQP::|CurClause|                                                             (* \; "new hack for interpret.me")))(CONSTANTS XQP::QP.32 XQP::QP.24))(XQP::|def.macro| XQP::|get.24| (X) (|if| (MEMB X XQP::QP.24)                                        |then| `(XQP::|ReadPrologPtr| ,X)                                      |elseif| (MEMB X '(NIL XQP::|membot| XQP::|init.E|                                                              XQP::|init.H| XQP::|memtop|))                                        |then| X                                      |elseif| (AND (LISTP X)                                                    (EQ (CAR X)                                                        'GETTOPVAL))                                        |then| X                                      |else| (SHOULDNT 'XQP::|get.24|)))(XQP::|def.macro| XQP::|put.24| (X Y) (|if| (MEMB X XQP::QP.24)                                          |then| `(XQP::|WritePrologPtrAnd0Tag| ,X ,Y)                                        |else| (SHOULDNT 'XQP::|put.24|)))(* |;;| "There are only two 32-bit registers (apart from the A registers), and they are T0 and T1.")(XQP::|def.props| XQP::|get.32| HI (LAMBDA (|Reg|)                                     `(XQP::\\GET.HI.16 ,|Reg|))                                   LO                                   (LAMBDA (|Reg|)                                     `(XQP::\\GET.LO.16 ,|Reg|))                                   XQP::|Tag|                                   (LAMBDA (|Reg|)                                     `(XQP::|ReadPrologTag| ,|Reg|))                                   XQP::|Ptr|                                   (LAMBDA (|Reg|)                                     `(XQP::|ReadPrologPtr| ,|Reg|)))(* |;;| "Storing a 32-bit quantity into a register is similar to storing it in memory, except that it is easier to store the tag and pointer form than the 16+16 form.  See put.cell in cell.lsp.")(XQP::|def.macro| XQP::|put.32| (|Reg| XQP::|Val|) (XQP::|put.32.macro| |Reg| XQP::|Val|))(XQP::|def.subr| XQP::|put.32.macro| (|Reg| XQP::|Val|)   (|if| (NOT (AND (MEMB |Reg| XQP::QP.32)                   (* \; "Reg is a 32-bit register")                   (LISTP XQP::|Val|)                        (* \; "Val is an expression")                   (LITATOM (CAR XQP::|Val|))                (* \; "whose function is an atom")                   ))       |then| (SHOULDNT 'XQP::|put.32|)     |elseif| (EQ (CAR XQP::|Val|)                  'XQP::|tag.ref|)       |then| `(XQP::|WritePrologPtrAnd0Tag| ,|Reg| (XQP::|get.24| ,(CADR XQP::|Val|)))     |elseif| (GETPROP (CAR XQP::|Val|)                     'XQP::|Loc|)       |then| `(LET ((SOURCE ,(APPLY (GETPROP (CAR XQP::|Val|)                                            'XQP::|Loc|)                                     (CDR XQP::|Val|))))                    (XQP::|WritePrologTagAndPtr| ,|Reg| (\\GETBASEBYTE SOURCE 0)                           (\\GETBASEPTR SOURCE 0)))     |elseif| (GETPROP (CAR XQP::|Val|)                     'XQP::|Ptr|)       |then| `(XQP::|WritePrologTagAndPtr| ,|Reg| ,(APPLY (GETPROP (CAR XQP::|Val|)                                                                  'XQP::|Tag|)                                                           (CDR XQP::|Val|))                      ,(APPLY (GETPROP (CAR XQP::|Val|)                                     'XQP::|Ptr|)                              (CDR XQP::|Val|)))     |elseif| (GETPROP (CAR XQP::|Val|)                     'HI)       |then| `(PROGN (XQP::\\PUT.HI.16 ,|Reg| ,(APPLY (GETPROP (CAR XQP::|Val|)                                                              'HI)                                                       (CDR XQP::|Val|)))                      (XQP::\\PUT.LO.16 ,|Reg| ,(APPLY (GETPROP (CAR XQP::|Val|)                                                              'LO)                                                       (CDR XQP::|Val|))))     |elseif| (CL:MACRO-FUNCTION (CAR XQP::|Val|))       |then| (XQP::|put.32.macro| |Reg| (CL:MACROEXPAND XQP::|Val|))     |else| (SHOULDNT 'XQP::|put.cell|)))(* |;;| "The two registers T0,T1 are also used as a \"stack\" for arithmetic. In the Sun and Vax versions of the emulator, these registers hold unboxed numbers, and the mode (W) says whether they are integers (mode=READ) or floats (mode=WRITE).  In this version of the emulator, we don't do that; they just hold Lisp pointers.  One reason for this is the simplicity of the approach.  Another reason is that the Koto release of Interlisp-D has bignums, so that an \"unboxed\" integer can be almost any size, not just 32 bits.")(* |;;| "The macros (put.nb Tx --) and (get.nb Tx) are really just versions of put.24 and get.24, except that (a) they check that we are talking about T0 or T1 (the only registers which are supposed to hold arithmetic results), and (b) they make it clear that we are putting just number addresses into these registers and not 32-bit cells. We could put proper tags on these registers, and the next version of the emulator may well do that, but for now we don't bother.")(* |;;| "This distinction was briefly useful for another purpose: put.nb used to \\ADDREF everything.  Now that the GC hook has been installed, this is no longer done, and ADD.REF is only called when things are put into memory.")(XQP::|def.macro| XQP::|get.nb| (X) (|if| (MEMB X XQP::QP.32)                                        |then| `(XQP::|ReadPrologPtr| ,X)                                      |else| (SHOULDNT 'XQP::|get.nb|)))(XQP::|def.macro| XQP::|put.nb| (X Y) (|if| (MEMB X XQP::QP.32)                                          |then| `(XQP::|WritePrologTagAndPtr| ,X XQP::|boxed.tag.8|                                                         ,Y)                                        |else| (SHOULDNT 'XQP::|put.nb|)))(* |;;| "(QP.BLOCK '(k1 ... kn)) creates an n-(16-bit)-word block, and initialises it. (def.block T0 T1 k1 ... kn) declares two global variables T0 and T1. T0 is initialised to (QP.BLOCK (LIST k1 ... kn)). T1 is initialised to B0+1. The coding of def.block is rather tricky because we have to hack around the file package's poisonous LIFO habit.  A pair of consecutive def.var's *cannot* be used!")(XQP::|def.subr| XQP::QP.BLOCK (ARGS) (LET ((B (\\ALLOCBLOCK (LENGTH ARGS))))                                           (FOR X IN ARGS AS I FROM 0                                              DO (\\PUTBASE B I X))                                           B))(XQP::|def.macro| XQP::|def.block| ARGS                                   `(PROGN (XQP::|def.global| (\\\, (CAR ARGS)) )                                           (XQP::|def.global| (\\\, (CADR ARGS)) )                                           (XQP::|def.init|                                            (PROGN (SETQ ,(CAR ARGS)                                                    (XQP::QP.BLOCK (LIST ,@(CDDR ARGS))))                                                   (SETQ ,(CADR ARGS) (\\ADDBASE ,(CAR ARGS) 1))))))(* |;;| "The macros (get.Aval x) (put.Aval x val) are register versions of get.Amem and put.Amem. When we are talking about particular registers in the code, it is convenient to refer to them as 1, 2, 3, 4.  But when the register number is held in a 16-bit register, namely I or N, the number is actually 0, 2, 4, or 6.")(* |;;| "(aregB <reg>) maps an A register to the 16-bit mask which should be given to RDPROLOGPTR to read the whole 32-bit register.")(XQP::|def.global| XQP::|aregB0| )(XQP::|def.global| XQP::|aregB1| )(EVAL (REMOVE-COMMENTS '(PROGN (SETQ XQP::|aregB0| (XQP::QP.BLOCK (LIST (XQP::|PrologNameToURegs|                                                                         'A1)                                                                                                                                     (* \; "0->A1")                                                                        0                                                                                                                                     (* \; "1")                                                                        (XQP::|PrologNameToURegs|                                                                         'A2)                                                                                                                                     (* \; "2->A2")                                                                        0                                                                                                                                     (* \; "3")                                                                        (XQP::|PrologNameToURegs|                                                                         'A3)                                                                                                                                     (* \; "4->A3")                                                                        0                                                                                                                                     (* \; "5")                                                                        (XQP::|PrologNameToURegs|                                                                         'A4)                                                                                                                                     (* \; "6->A4")                                                                        0                                                                                                                                     (* \; "7"))))                               (SETQ XQP::|aregB1| (\\ADDBASE XQP::|aregB0| 1)))))(XQP::|def.subr| XQP::|aregB| (|Reg|) (SELECTQ |Reg|                                          (1 (\\GETBASE XQP::|aregB0| 0))                                          (2 (\\GETBASE XQP::|aregB0| 2))                                          (3 (\\GETBASE XQP::|aregB0| 4))                                          (4 (\\GETBASE XQP::|aregB0| 6))                                          (I '(\\GETBASE XQP::|aregB0| (XQP::|get.16| I)))                                          (N '(\\GETBASE XQP::|aregB0| (XQP::|get.16| N)))                                          (SHOULDNT "aregB")))(* |;;| "(aregW <reg> h/) maps an A register to the 16-bit mask which should be given to WRTPTR&0TAG to store 16 bits.  If h/l is 0, the high register is wanted, if h/l is 1, the low register is wanted.")(XQP::|def.global| XQP::|aregW0| )(XQP::|def.global| XQP::|aregW1| )(EVAL (REMOVE-COMMENTS '(PROGN (SETQ XQP::|aregW0| (XQP::QP.BLOCK (LIST (XQP::|PrologMentionTwice|                                                                         (XQP::|PrologNameToHiUReg|                                                                          'A1))                                                                                                                                     (* \; "0 -> A1.hi")                                                                        (XQP::|PrologMentionTwice|                                                                         (XQP::|PrologNameToLoUReg|                                                                          'A1))                                                                                                                                     (* \; "1 -> A1.lo")                                                                        (XQP::|PrologMentionTwice|                                                                         (XQP::|PrologNameToHiUReg|                                                                          'A2))                                                                                                                                     (* \; "2 -> A2.hi")                                                                        (XQP::|PrologMentionTwice|                                                                         (XQP::|PrologNameToLoUReg|                                                                          'A2))                                                                                                                                     (* \; "3 -> A2.lo")                                                                        (XQP::|PrologMentionTwice|                                                                         (XQP::|PrologNameToHiUReg|                                                                          'A3))                                                                                                                                     (* \; "4 -> A3.hi")                                                                        (XQP::|PrologMentionTwice|                                                                         (XQP::|PrologNameToLoUReg|                                                                          'A3))                                                                                                                                     (* \; "5 -> A3.lo")                                                                        (XQP::|PrologMentionTwice|                                                                         (XQP::|PrologNameToHiUReg|                                                                          'A4))                                                                                                                                     (* \; "6 -> A4.hi")                                                                        (XQP::|PrologMentionTwice|                                                                         (XQP::|PrologNameToLoUReg|                                                                          'A4))                                                                                                                                     (* \; "7 -> A4.lo"))))                               (SETQ XQP::|aregW1| (\\ADDBASE XQP::|aregW0| 1)))))(XQP::|def.subr| XQP::|aregW| (|Reg| \x) (|if| (EQ \x 0)                                             |then|          (* \; "x = 0")                                                   (SELECTQ |Reg|                                                       (1 (\\GETBASE XQP::|aregW0| 0))                                                       (2 (\\GETBASE XQP::|aregW0| 2))                                                       (3 (\\GETBASE XQP::|aregW0| 4))                                                       (4 (\\GETBASE XQP::|aregW0| 6))                                                       (I '(\\GETBASE XQP::|aregW0| (XQP::|get.16|                                                                                     I)))                                                       (N '(\\GETBASE XQP::|aregW0| (XQP::|get.16|                                                                                     N)))                                                       (SHOULDNT 'XQP::|aregW|))                                           |else|            (* \; "x = 1")                                                 (SELECTQ |Reg|                                                     (1 (\\GETBASE XQP::|aregW1| 0))                                                     (2 (\\GETBASE XQP::|aregW1| 2))                                                     (3 (\\GETBASE XQP::|aregW1| 4))                                                     (4 (\\GETBASE XQP::|aregW1| 6))                                                     (I '(\\GETBASE XQP::|aregW1| (XQP::|get.16|                                                                                   I)))                                                     (N '(\\GETBASE XQP::|aregW1| (XQP::|get.16|                                                                                   N)))                                                     (SHOULDNT 'XQP::|aregW|))))(* |;;| "(aregR <reg> h/l) maps an A register to the 16-bit mask which should be given to RDPROLOGPTR to read 16 bits.  If h/l is 0, th,e high register is wanted, if h/l is 1, the low register is wanted.")(XQP::|def.global| XQP::|aregR0| )(XQP::|def.global| XQP::|aregR1| )(EVAL (REMOVE-COMMENTS '(PROGN (SETQ XQP::|aregR0| (XQP::QP.BLOCK (LIST (XQP::|PrologZeroExtend|                                                                         (XQP::|PrologNameToHiUReg|                                                                          'A1))                                                                                                                                     (* \; "0 -> A1.hi")                                                                        (XQP::|PrologZeroExtend|                                                                         (XQP::|PrologNameToLoUReg|                                                                          'A1))                                                                                                                                     (* \; "1 -> A1.lo")                                                                        (XQP::|PrologZeroExtend|                                                                         (XQP::|PrologNameToHiUReg|                                                                          'A2))                                                                                                                                     (* \; "2 -> A2.hi")                                                                        (XQP::|PrologZeroExtend|                                                                         (XQP::|PrologNameToLoUReg|                                                                          'A2))                                                                                                                                     (* \; "3 -> A2.lo")                                                                        (XQP::|PrologZeroExtend|                                                                         (XQP::|PrologNameToHiUReg|                                                                          'A3))                                                                                                                                     (* \; "4 -> A3.hi")                                                                        (XQP::|PrologZeroExtend|                                                                         (XQP::|PrologNameToLoUReg|                                                                          'A3))                                                                                                                                     (* \; "5 -> A3.lo")                                                                        (XQP::|PrologZeroExtend|                                                                         (XQP::|PrologNameToHiUReg|                                                                          'A4))                                                                                                                                     (* \; "6 -> A4.hi")                                                                        (XQP::|PrologZeroExtend|                                                                         (XQP::|PrologNameToLoUReg|                                                                          'A4))                                                                                                                                     (* \; "7 -> A4.lo"))))                               (SETQ XQP::|aregR1| (\\ADDBASE XQP::|aregR0| 1)))))(XQP::|def.subr| XQP::|aregR| (|Reg| \x) (|if| (EQ \x 0)                                             |then|          (* \; "x = 0")                                                   (SELECTQ |Reg|                                                       (1 (\\GETBASE XQP::|aregR0| 0))                                                       (2 (\\GETBASE XQP::|aregR0| 2))                                                       (3 (\\GETBASE XQP::|aregR0| 4))                                                       (4 (\\GETBASE XQP::|aregR0| 6))                                                       (I '(\\GETBASE XQP::|aregR0| (XQP::|get.16|                                                                                     I)))                                                       (N '(\\GETBASE XQP::|aregR0| (XQP::|get.16|                                                                                     N)))                                                       (SHOULDNT 'XQP::|aregR|))                                           |else|            (* \; "x = 1")                                                 (SELECTQ |Reg|                                                     (1 (\\GETBASE XQP::|aregR1| 0))                                                     (2 (\\GETBASE XQP::|aregR1| 2))                                                     (3 (\\GETBASE XQP::|aregR1| 4))                                                     (4 (\\GETBASE XQP::|aregR1| 6))                                                     (I '(\\GETBASE XQP::|aregR1| (XQP::|get.16|                                                                                   I)))                                                     (N '(\\GETBASE XQP::|aregR1| (XQP::|get.16|                                                                                   N)))                                                     (SHOULDNT 'XQP::|aregR|))))(* |;;| "(get.Aval Reg)")(XQP::|def.props| XQP::|get.Aval| HI (LAMBDA (|Reg|)                                       `(\\LOLOC (XQP::|\\RdPrologPtr| ,(XQP::|aregR| |Reg| 0))))                                     LO                                     (LAMBDA (|Reg|)                                       `(\\LOLOC (XQP::|\\RdPrologPtr| ,(XQP::|aregR| |Reg| 1))))                                     XQP::|Tag|                                     (LAMBDA (|Reg|)                                       `(XQP::|\\RdPrologTag| ,(XQP::|aregB| |Reg|)))                                     XQP::|Ptr|                                     (LAMBDA (|Reg|)                                       `(XQP::|\\RdPrologPtr| ,(XQP::|aregB| |Reg|))))(XQP::|def.subr| XQP::|put.Aval.macro| (|Reg| XQP::|Val|)   (|if| (NOT (AND (LISTP XQP::|Val|)                        (* \; "Val is an expression")                   (LITATOM (CAR XQP::|Val|))))       |then|                                                (* \; "whose function is an atom")             (SHOULDNT 'XQP::|put.Aval|)     |elseif| (EQ (CAR XQP::|Val|)                  'XQP::|tag.ref|)       |then| `(XQP::|\\WrtPtr&0Tag| ,(XQP::|aregB| |Reg|) (XQP::|get.24| ,(CADR XQP::|Val|)))     |elseif| (GETPROP (CAR XQP::|Val|)                     'XQP::|Loc|)       |then| `(LET ((SOURCE ,(APPLY (GETPROP (CAR XQP::|Val|)                                            'XQP::|Loc|)                                     (CDR XQP::|Val|))))                    (XQP::|\\WrtPtr&Tag| ,(XQP::|aregB| |Reg|) (\\GETBASEBYTE SOURCE 0)                           (\\GETBASEPTR SOURCE 0)))     |elseif| (GETPROP (CAR XQP::|Val|)                     'XQP::|Ptr|)       |then| `(XQP::|\\WrtPtr&Tag| ,(XQP::|aregB| |Reg|) ,(APPLY (GETPROP (CAR XQP::|Val|)                                                                         'XQP::|Tag|)                                                                  (CDR XQP::|Val|))                      ,(APPLY (GETPROP (CAR XQP::|Val|)                                     'XQP::|Ptr|)                              (CDR XQP::|Val|)))     |elseif| (GETPROP (CAR XQP::|Val|)                     'HI)       |then| `(PROGN (XQP::|\\WrtPtr&0Tag| ,(XQP::|aregW| |Reg| 0) ,(APPLY (GETPROP (CAR XQP::|Val|)                                                                                   'HI)                                                                            (CDR XQP::|Val|)))                      (XQP::|\\WrtPtr&0Tag| ,(XQP::|aregW| |Reg| 1) ,(APPLY (GETPROP (CAR XQP::|Val|)                                                                                   'LO)                                                                            (CDR XQP::|Val|))))     |elseif| (CL:MACRO-FUNCTION (CAR XQP::|Val|))       |then| (XQP::|put.Aval.macro| |Reg| (CL:MACROEXPAND XQP::|Val|))     |else| (SHOULDNT 'XQP::|put.cell|)))(XQP::|def.macro| XQP::|put.Aval| (|Reg| XQP::|Val|) (XQP::|put.Aval.macro| |Reg| XQP::|Val|))(PUTPROPS REGISTERS COPYRIGHT ("Quintus Computer Systems, Inc" 1987))(DECLARE\: DONTCOPY  (FILEMAP (NIL)))STOP