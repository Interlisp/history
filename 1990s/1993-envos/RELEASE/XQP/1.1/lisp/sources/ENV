(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "INTERLISP")(filecreated "31-Dec-87 10:29:14" {dsk}<lispfiles>dcoms>env.\;4 9849         |changes| |to:|  (functions xqp::host.version)      |previous| |date:| "14-Dec-87 16:38:34" {dsk}<lispfiles>dcoms>env.\;3); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(prettycomprint envcoms)(rpaqq envcoms        ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>ENV.LSP;3, loaded 16-Jun-87 18:18:38")                    (* |;;| "@ (#) ENV.LSP 8205.1 5/27/87 ENV.LSP BAK		 ;; --------------------------------------------------------;; ;; WARNING: This material is CONFIDENTIAL and proprietary ;; to Quintus Computer Systems Inc.		 ;; ;; ;; Copyright (C) 1985,  Quintus Computer Systems, Inc.   ;; All rights reserved.					 ;; ;; --------------------------------------------------------;; ;;")        (functions xqp::does.not.have.extension getenv xqp::machine xqp::host.version                xqp::absolute.path xqp::analyze.nonxqp.symbol xqp::name.part xqp::path.part                xqp::relative.file.name xqp::canonical.file.name xqp::remlistprop xqp::file.exists                xqp::find.nonxqp.symbol xqp::full.file.name xqp::add.file.to.path                xqp::possibly.add.pl.extension)        (prop makefile-environment)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>ENV.LSP;3, loaded 16-Jun-87 18:18:38")(* |;;| "@ (#) ENV.LSP 8205.1 5/27/87 ENV.LSP BAK		 ;; --------------------------------------------------------;; ;; WARNING: This material is CONFIDENTIAL and proprietary ;; to Quintus Computer Systems Inc.		 ;; ;; ;; Copyright (C) 1985,  Quintus Computer Systems, Inc.   ;; All rights reserved.					 ;; ;; --------------------------------------------------------;; ;;")(xqp::defunc xqp::does.not.have.extension (filename) (if (null (filenamefield filename 'extension))                                                         then 1                                                       else 0))(xqp::defunc getenv (type) (declare (globalvars loginhost/dir))                           (selectq type                               (home loginhost/dir)                               (shouldnt 'getenv)))(xqp::defunc xqp::machine nil (* |;;;| "This function returns information that may be useful in handling bug reports or duplicating problems.  The information returned, in general, is as follows: ")                    (* |;;| "machine manufacturer (e.g., DEC, Sun, Xerox, Apollo)")                    (* |;;| "machine model line name or number  (e.g, VAX, sun3, Xerox 1186, Domain) ")                    (* |;;| "machine submodel (e.g., ' 780' , '/50',  '', ' 330') constructed so that it can be printed immediately after model")                    (* |;;| "os family (e.g., 'vms', 'unix', 'xerox', 'aegis')")                    (* |;;| "os major release (e.g., 'VMS 4.5', 'unix 3.2', 'Lyric', 'Aegis 9.3')")                   (* |;;| "os minor release (e.g., ???, ???, 'Lyric of 18-Aug-87 15:56:13', ???)")(* |;;;| "I don't know if this will be useful for anything, but here it is.")                              (cl:values '|Xerox| (mkatom (cl:machine-type))                                     '||                                     'xqp::|xerox|                                     (l-case makesysname t)                                     (mkatom (concat (l-case makesysname t)                                                    " of "                                                    (cl:software-version)))))(xqp::defunc xqp::host.version nil                     (* |;;| "This routine should pick versions in some consistent way. returns: code version (SCCS major number of lisp code), 1 if released else 0, major Prolog version, minor Prolog version")                                   (cl:values 703 1 2 0))(xqp::defunc xqp::absolute.path (path)                     (* |;;|         "Returns PATH with omitted filename fields filled in with current connected directory fields") (let* ((xqp::cwd (directoryname t))        (xqp::pathhost (filenamefield path 'host))        (xqp::pathdev (filenamefield path 'device)))       (|if| (or (and xqp::pathhost (neq (filenamefield xqp::cwd 'host)                                         xqp::pathhost))                 (and xqp::pathdev (neq (filenamefield xqp::cwd 'device)                                        xqp::pathdev)))           |then| path         |else| (packfilename 'body path 'body xqp::cwd))))(cl:defun xqp::analyze.nonxqp.symbol (symbol) (* |;;;| "Returns 2 values:  the name and package of SYMBOL, each as symbols in the XQP package.  SYMBOL is not effected in any way.  In particular, it is not imported into XQP.") (cl:values (cl:intern (cl:symbol-name symbol)                   xqp::xqp-package                          (* \;                                                   "XQP-PACKAGE is globally bound to the XQP package.")                   )        (cl:intern (cl:package-name (cl:symbol-package symbol))               xqp::xqp-package)))(xqp::defunc xqp::name.part (filename) (packfilename 'host nil 'device nil 'directory nil                                              'version nil 'body filename))(xqp::defunc xqp::path.part (filename)                     (* |;;| "Returns FILENAME's HOST, DEVICE, and DIRECTORY fields, packed") (packfilename 'name nil 'extension nil 'version nil 'body filename))(xqp::defunc xqp::relative.file.name (filename) (if (or (not (atom filename))                                                        (eq filename '|user|)                                                        (filenamefield filename 'directory)                                                        (filenamefield filename 'device)                                                        (filenamefield filename 'host))                                                    then 0                                                  else 1))(xqp::defunc xqp::canonical.file.name (fl)                     (* |;;| "Returns FL sans version number") (packfilename 'version nil 'body fl))(xqp::defunc xqp::remlistprop (list item) (cl:do (result (list1 list (cddr list1)))                                                 ((null list1)                                                  result)                                                 (cond                                                    ((eq (car list1)                                                         item))                                                    (t (setq result (append (list (car list1)                                                                                  (cadr list1))                                                                           result))))))(xqp::defunc xqp::file.exists (path) (cond                                        ((infilep path)                                         1)                                        (t 0)))(cl:defun xqp::find.nonxqp.symbol (name package) (* |;;;| "Actually, more similar to CL:INTERN than to FIND-SYMBOL, in that it creates the symbol if it doesn't already exist.  NAME and PACKAGE are both SYMBOLS, not strings.") (cl:intern (cl:symbol-name name)        (cl:find-package package)))(xqp::defunc xqp::full.file.name (filename mode) (* |;;;| "Returns two values:  the full name of FILENAME in MODE (read, write, or append), and a status.  If the file could be opened in the indicated mode, status = 0, else status is an error number indicating why the file can't be opened.") (let ((full (fullname filename (selectq mode                                    (|read| 'old)                                    (xqp::|write| 'new)                                    (xqp::|append| 'old)                                    (error "invalid mode argument to full_file_name" mode)))))      (|if| full          |then| (cl:values full 0)        |else| (cl:values (packfilename 'body filename 'body (directoryname t))                      (gethash 'xqp::io_nofile xqp::error.table)))))(xqp::defunc xqp::add.file.to.path (path xqp::partslist)                     (* |;;| "add a > to \"fred\" \"{fred}<foo>baz\" \"{fred}<foo\" but not \"{fred}\" Also \"fred>jim\" will be <fred>jim>\". problem: \"{fred}foo\" should become \"{fred}<foo>\" but doesn't.") (cond    ((and (neq (nthcharcode path -1)               (charcode >))          (or (strpos "<" path)              (strpos ">" path)              (neq (chcon1 path)                   (charcode {))))     (setq xqp::partslist (cons ">" xqp::partslist)))) (setq xqp::partslist (cons path xqp::partslist))                    (* |;;| "Supply a missing \"<\" at the front.") (cond    ((and (neq (chcon1 path)               (charcode {))          (not (strpos "<" path)))     (setq xqp::partslist (cons "<" xqp::partslist)))) (pack xqp::partslist))(xqp::defunc xqp::possibly.add.pl.extension (xqp::absname)                     (* |;;| "Given ABSNAME, an absolute file name, add a pl extension if it doesn't have an extension, and if ABSNAME.pl exists;; otherwise, return ABSNAME intact.)") (if (litatom xqp::absname)     then (or (and (null (filenamefield xqp::absname 'extension))                   (infilep (packfilename 'extension '|pl| 'body xqp::absname)))              (infilep xqp::absname)              xqp::absname)   else xqp::absname))(putprops env copyright ("Quintus Computer Systems, Inc" 1987))(declare\: dontcopy  (filemap (nil)))stop 