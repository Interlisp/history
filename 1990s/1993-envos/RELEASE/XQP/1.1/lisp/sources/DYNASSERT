(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(FILECREATED "26-Jun-87 15:18:41" {ERIS}<PROLOGCORE>LYRIC>LISP>DYNASSERT.\;5 81158        |changes| |to:|  (FNS XQP::COLLECT.CLAUSES XQP::UNLINK.NONINDEXED.CLAUSE)      |previous| |date:| "25-Jun-87 19:05:02" {ERIS}<PROLOGCORE>LYRIC>LISP>DYNASSERT.\;4); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(PRETTYCOMPRINT DYNASSERTCOMS)(RPAQQ DYNASSERTCOMS (                    (* |;;| "Code for assertion, retraction, and reclamation of dynamic code.  Much of this code replaces Prolog code in the non-Xerox version of Quintus Prolog.")                                                             (* \; "code for assertion")                      (FNS XQP::DYN.CREATE.AND.INIT.INDEX XQP::DYN.INSERT.IN.INDEX                            XQP::DYN.FIND.SUBCHAIN XQP::APPEND.TO.SUBCHAIN                            XQP::DYN.INCREASE.POPULATION XQP::DYN.INSERT.IN.BUCKET)                                                             (* \; "Code for clause reclamation")                      (FNS XQP::CLEAN.UP.CLAUSES XQP::MAYBE.CLEAN.UP XQP::PERHAPS.CLEAN.UP                            XQP::REALLY.CLEAN.UP)                      (FNS XQP::COLLECT.CLAUSE.CHAIN XQP::COLLECT.CLAUSES XQP::DISPOSE.CLAUSE                            XQP::EMPTY.OUT.CLAUSE XQP::INDEX.BUCKET XQP::INDEX.CORRECT.LINK                            XQP::PUT.CLAUSE.ON.DEAD.CHAIN XQP::RECLAIM.UNATTACHED.CLAUSE                            XQP::REMOVE.FROM.INDEX XQP::TABLE.BUCKET XQP::TRAVERSE.DEAD.CHAIN                            XQP::TRAVERSE.STACK XQP::UNLINK.INDEXED.CLAUSE                            XQP::UNLINK.NONINDEXED.CLAUSE)                      (MACROS XQP::UNNEEDED.CLAUSE)                      (INITVARS XQP::DEAD.CLAUSE.CHAIN (XQP::DEAD.CLAUSE.COUNT 0)                             (XQP::THRASHING.COUNT 0)                             (XQP::ACTIVE.PROC.TABLE (HASHARRAY 50 2.0)))                                                             (* \; "variables")                      (GLOBALVARS XQP::DEAD.CLAUSE.CHAIN XQP::DEAD.CLAUSE.COUNT XQP::THRASHING.COUNT                              XQP::ACTIVE.PROC.TABLE)                                                             (* \; "Debugging code")                      (FNS XQP::CLEAN XQP::CHECK.BUCKET XQP::CHECK.INDEX XQP::CHECK.INDEXED                            XQP::CHECK.PROC XQP::CHECK.SINGLE XQP::CHECK.SUBCHAIN XQP::CHECK.UNINDEXED                           )                      (GLOBALVARS XQP::BOTCH)                      (PROP MAKEFILE-ENVIRONMENT)))(* |;;| "Code for assertion, retraction, and reclamation of dynamic code.  Much of this code replaces Prolog code in the non-Xerox version of Quintus Prolog.")(* \; "code for assertion")(DEFINEQ(XQP::DYN.CREATE.AND.INIT.INDEX  (LAMBDA (CLAUSE)                                           (* XQP::|pds:| " 1-May-87 14:50")                    (* * |Create| \a |new| |index| |and| |initialize| |it| |to| XQP::|contain|           CLAUSE |as| |its| |only| XQP::|clause.| XQP::|Returns| |the| |new|           XQP::|index.| XQP::|Does| NOT |actually| |index| XQP::CLAUSE\, |just| |puts|           |it| |as| |the| |only| XQP::|clause| |in| |the| XQP::|unindexable| |path|           |through| |the| XQP::|index.| XQP::|Equivalent| |to| XQP::|dyn_create_index/1|           |and| XQP::|dyn_init_index/2| |in| XQP::|dynindex.pl.|)                    (* * |This| |fn| |is| |called| |from| |Prolog.|)    (LET ((INDEX (\\ALLOCBLOCK XQP::|dynindex.size|))          (TABLE (\\ALLOCBLOCK 1)))         (\\ADDREF INDEX)         (\\ADDREF TABLE)         (\\PUTBASE INDEX XQP::|dynindex.instr| (XQP::HI.CODE 'XQP::|dynamic.index|                                                        XQP::|unindexed.offset|))         (\\PUTBASEPTR INDEX XQP::|dynindex.born| -65536)    (* XQP::|INDEXes| |are| |always|                                                              XQP::|alive.|)         (\\PUTBASEPTR INDEX XQP::|dynindex.died| NIL)         (\\PUTBASE INDEX XQP::|dynindex.mask| 0)         (\\PUTBASE INDEX XQP::|dynindex.population| 0)         (\\PUTBASEPTR INDEX XQP::|dynindex.first| CLAUSE)         (\\PUTBASEPTR INDEX XQP::|dynindex.list| XQP::FAILURE.CLAUSE)         (\\PUTBASEPTR INDEX XQP::|dynindex.table| TABLE)         (\\PUTBASEPTR CLAUSE XQP::|clause.next| INDEX)         (\\PUTBASEBYTE CLAUSE XQP::|clause.next.tagbyte| 255)         (\\PUTBASEPTR CLAUSE XQP::|clause.prev| CLAUSE)         (\\PUTBASE TABLE 0 0)         INDEX)))(XQP::DYN.INSERT.IN.INDEX  (LAMBDA (TYPE XQP::POLE INDEX CLAUSE)                      (* XQP::|pds:| " 2-May-87 19:34")                    (* * |Put| CLAUSE |in| XQP::INDEX. TYPE XQP::|indicates| XQP::|whether| |the|           |key| |is| \a XQP::|cons| XQP::|cell| |or| |not| XQP::|<by_key| -> XQP::|no,|           XQP::|by_list| -> XQP::|yes>.| XQP::POLE XQP::|indicates| XQP::|whether| |this|           XQP::|clause| |should| |be| |added| |before| |or| |after| |other| |clauses|           |for| |the| |same| XQP::|key.| |Note| |that| |this| |code| |need| |only|           |added| CLAUSE |to| |the| |indexed| |path| |through| |the| XQP::|index,|           |other| |code| |will| |take| XQP::|care| |of| XQP::|putting| |the|           XQP::|clause| |in| |the| |index| |for| XQP::|unindexable| XQP::|calls.|)                    (* * |This| |fn| |is| |called| |from| |Prolog.|)    (LET ((SUBITEM (\\ADDBASE CLAUSE XQP::|clause.subitem|)))         (|if| (EQ TYPE 'XQP::|by_key|)             |then|                                          (* |it| XQP::|goes| |in| |the|                                                              XQP::|hash| |table|)                   (LET ((XQP::CHAINPTR (XQP::DYN.FIND.SUBCHAIN (XQP::INDEX.BUCKET INDEX SUBITEM)                                               (\\GETBASE SUBITEM XQP::|subitem.key|)                                               (\\GETBASE SUBITEM XQP::|subitem.key.low|))))                        (|if| XQP::CHAINPTR                            |then|                           (* |there| |are| |other| |clauses|                                                              |with| |the| |same| XQP::|key.|)                                  (XQP::APPEND.TO.SUBCHAIN XQP::POLE XQP::CHAINPTR SUBITEM T)                          |else|                             (* |new| |key|)                                (XQP::DYN.INCREASE.POPULATION INDEX)                     (* * XQP::NB\: |The| XQP::|following| |call| |to| XQP::INDEX.BUCKET MUST |be|           XQP::|repeated,| |as| |the| |call| |to| XQP::DYN.INCREASE.POPULATION |may|           |have| XQP::|created| \a |new| XQP::|hash| XQP::|table.|          W\e XQP::|wouldn't| XQP::|want| |to| XQP::|write| |into| |the| |old|           XQP::|one,| |would| XQP::|we?|)                                (XQP::DYN.INSERT.IN.BUCKET (XQP::INDEX.BUCKET INDEX SUBITEM)                                       (\\ADDBASE SUBITEM XQP::|subitem.guardedsubitem|)                                       INDEX)))           |elseif| (EQ TYPE 'XQP::|by_list|)             |then|                                          (* XQP::|put| |it| |in| |the|                                                              |special| |list| |case| XQP::|slot|)                   (|if| (EQ (\\GETBASEPTR INDEX XQP::|dynindex.list|)                             XQP::FAILURE.CLAUSE)                       |then| (\\PUTBASEPTR INDEX XQP::|dynindex.list| SUBITEM)                             (\\PUTBASEPTR SUBITEM XQP::|subitem.next| INDEX)                             (\\PUTBASEBYTE SUBITEM XQP::|subitem.next.tagbyte| 255)                             (\\PUTBASEPTR SUBITEM XQP::|subitem.prev| SUBITEM)                     |else| (XQP::APPEND.TO.SUBCHAIN XQP::POLE (\\ADDBASE INDEX XQP::|dynindex.list|)                                   SUBITEM NIL))           |else| (SHOULDNT 'XQP::DYN.INSERT.IN.INDEX)))))(XQP::DYN.FIND.SUBCHAIN  (LAMBDA (BUCKET XQP::HIKEY XQP::LOKEY)                     (* XQP::|pds:| " 1-May-87 12:45")                    (* * |return| \a |pointer| |to| \a |pointer| |to| |the| XQP::|subchain| |that|           XQP::|matches| |the| 32 |bit| |key| XQP::|described| |by| XQP::HIKEY |and|           XQP::LOKEY\, |each| 16 XQP::|bits.| BUCKET |is| \a |pointer| |to| |the|           XQP::|hash| XQP::|bucket| |that| |should| XQP::|contain| |the| XQP::|guarded|           XQP::|subchain,| |if| XQP::|it's| XQP::|there.|          I\f |it| |can't| |be| |found,| |return| XQP::NIL.)    (LET ((TAG (\\GETBASEBYTE BUCKET 0))          (CONTENTS (\\GETBASEPTR BUCKET 0)))         (|if| (AND (EQ TAG 8)                    (AND (EQ (\\GETBASE CONTENTS 0)                             XQP::HIKEY)                         (EQ (\\GETBASE CONTENTS 1)                             XQP::LOKEY)))             |then|                                          (* XQP::|Matching| XQP::|singleton|                                                              XQP::|slot|)                   BUCKET           |elseif| (EQ TAG 128)             |then|                                          (* XQP::|crowded| XQP::|slot|)                   (|bind| (LINK _ CONTENTS)                          CHAIN |while| LINK                      |do| (|if| (AND (EQ (\\GETBASE (SETQ CHAIN (\\GETBASEPTR LINK 2))                                                 0)                                          XQP::HIKEY)                                      (EQ (\\GETBASE CHAIN 1)                                          XQP::LOKEY))                               |then|                     (* |return| \a |pointer| |to| |the| XQP::|jump| |field| |of| |the|           XQP::INDEX.LINK)                                     (RETURN (\\ADDBASE LINK 2)))                           (SETQ LINK (\\GETBASEPTR LINK 0)))           |else| NIL))))(XQP::APPEND.TO.SUBCHAIN  (LAMBDA (XQP::POLE XQP::CHAINPTR SUBITEM XQP::GUARDED?)    (* XQP::|pds:| " 8-May-87 15:34")                    (* * XQP::|Append| |or| XQP::|prepend| SUBITEM |to| |the| XQP::|subitem|           |chain| XQP::|pointed| |to| |by| |the| XQP::|cell| XQP::|pointed| |to| |by|           XQP::CHAINPTR. XQP::POLE |is| \z |for| XQP::|APpend| |and| \a |for|           XQP::|PREpend.| I\f XQP::GUARDED? |then| |it| |is| \a XQP::|guarded|           XQP::|chain,| |else| XQP::|not.| I\f XQP::|it's| \a XQP::|guarded|           XQP::|chain,| |then| |the| |pointer| XQP::|pointed| |to| |by| XQP::CHAINPTR           XQP::|points| |to| \a XQP::|copy| |of| |the| |key| |to| XQP::|match,| |which|           |is| XQP::|immediately| XQP::|followed| |by| |an| XQP::|interpret.me|           XQP::|instruction.| XQP::|Otherwise,| |it| |just| XQP::|points| |to| |the|           XQP::|interpret.me| XQP::|instruction.| |Note| |that| |all| |the| |next| |and|           XQP::|prev| |pointers| |point| |to| |an| XQP::|interpret.me|           XQP::|instruction,| |not| |the| XQP::|key,| |even| |for| XQP::|guarded|           XQP::|subchains.| |The| |only| XQP::|difference| |is| |where| |the| |pointer|           |into| |the| |chain| XQP::|points.| |This| |code| |only| XQP::|touches| |the|           XQP::|top| 7 |words| |of| |the| XQP::|clause,| |which| XQP::|comprise| |the|           XQP::|subchain.|)    (LET ((XQP::OLDFIRST (|if| XQP::GUARDED?                             |then| (\\ADDBASE (\\GETBASEPTR XQP::CHAINPTR 0)                                           (MINUS XQP::|subitem.key|))                           |else| (\\GETBASEPTR XQP::CHAINPTR 0))))                                                             (* XQP::OLDFIRST XQP::|points| |to|                                                              |the| XQP::|interpret.me| XQP::|instr|)         (|if| (EQ XQP::POLE '\a)             |then| (\\PUTBASEPTR SUBITEM XQP::|subitem.next| XQP::OLDFIRST)                   (\\PUTBASEPTR SUBITEM XQP::|subitem.prev| (\\GETBASEPTR XQP::OLDFIRST                                                                     XQP::|subitem.prev|))                   (\\PUTBASEPTR XQP::OLDFIRST XQP::|subitem.prev| SUBITEM)                     (* * |Note:| |we| |must| |be| XQP::|careful| |to| XQP::|maintain| |the| |high|           8 |bits| |of| |the| XQP::|chainptr,| |since| |it| |may| |be| \a XQP::|hash|           XQP::|bucket.| I\f XQP::|it's| XQP::|not,| |no| XQP::|harm| |done.|)                   (LET ((XQP::OLDTAG (\\GETBASEBYTE XQP::CHAINPTR 0)))                        (\\PUTBASEPTR XQP::CHAINPTR 0 (|if| XQP::GUARDED?                                                          |then| (\\ADDBASE SUBITEM                                                                         XQP::|subitem.key|)                                                        |else| SUBITEM))                        (\\PUTBASEBYTE XQP::CHAINPTR 0 XQP::OLDTAG))           |elseif| (EQ XQP::POLE '\z)             |then| (LET ((OLDLAST (\\GETBASEPTR XQP::OLDFIRST XQP::|subitem.prev|)))                         (\\PUTBASEPTR SUBITEM XQP::|subitem.next| (\\GETBASEPTR OLDLAST                                                                           XQP::|subitem.next|))                         (\\PUTBASEBYTE SUBITEM XQP::|subitem.next.tagbyte| 255)                         (\\PUTBASEPTR SUBITEM XQP::|subitem.prev| OLDLAST)                         (\\PUTBASEPTR OLDLAST XQP::|subitem.next| SUBITEM)                         (\\PUTBASEPTR XQP::OLDFIRST XQP::|subitem.prev| SUBITEM))           |else| (SHOULDNT 'XQP::DYN.INSERT.IN.INDEX)))))(XQP::DYN.INCREASE.POPULATION  (LAMBDA (INDEX)                                            (* XQP::|pds:| "22-May-87 18:00")                    (* * XQP::C\f. XQP::ADD1.INDEX |in| XQP::ASSERT.LSP.          |Increment| |the| XQP::|population| |of| XQP::INDEX.          I\f |there| |are| |now| |more| |distinct| |keys| |in| |the| |table| |than|           |there| |are| |slots,| |double| |the| XQP::|size| |of| |the| |table| |and|           XQP::|redistribute| |the| |table| XQP::|entries.|)    (LET ((XQP::OLDPOPULATION (\\GETBASE INDEX XQP::|dynindex.population|))          (XQP::OLDMASK (\\GETBASE INDEX XQP::|dynindex.mask|)))         (\\PUTBASE INDEX XQP::|dynindex.population| (ADD1 XQP::OLDPOPULATION))                    (* * |the| XQP::|mask| |is| |always| |one| XQP::|less| |than| |the| |maximum|           XQP::|occupancy| |of| |the| XQP::|table.|)         (|if| (IGREATERP XQP::OLDPOPULATION XQP::OLDMASK)             |then|                                          (* W\e |must| XQP::|expand| |the|                                                              XQP::|hash| |table|)                   (LET* ((XQP::NEWMASK (ADD1 (LLSH XQP::OLDMASK 1)))                          (XQP::NEWTABLE (\\ALLOCBLOCK (LLSH (ADD1 XQP::NEWMASK)                                                             1)))                          (XQP::OLDTABLE (\\GETBASEPTR INDEX XQP::|dynindex.table|)))                         (\\ADDREF XQP::NEWTABLE)                    (* * |Note:| |in| |the| |code| XQP::|below,| |we| |find| |the| |word| |offset|           |of| |the| |last| XQP::|bucket| |in| |the| |table| |by| XQP::|noticing| |that|           |the| XQP::|mask| |for| \a |table| |is| XQP::|exactly| |the| |index| |of| |the|           |last| XQP::|item.| XQP::S\o |its| |word| |offset| |is| |twice| XQP::|that,|           |or| (LLSH XQP::|<mask>| 1)\, |which| |is| |used| |twice| XQP::|below.|)                    (* * |Clear| |out| |new| |table|)                         (|for| I |from| 0 |to| (LLSH XQP::NEWMASK 1) |by| 2                            |do|                     (* XQP::|actually,| |we| |just| |need| |the| |high| |byte| |of| |each| |table|           |entry| |to| |be| XQP::0\; |we| |don't| XQP::|care| XQP::|about| |the| |other|           3 XQP::|bytes.| XQP::|But| |this| |should| |be| XQP::|about| |the|           XQP::|cheapest| |way| |to| XQP::|achieve| XQP::|this.|)                                 (\\PUTBASE XQP::NEWTABLE I 0))                    (* * |Copy| |old| |table| |into| |new|)                         (|bind| OLDCONTENTS |for| I |from| 0 |to| (LLSH XQP::OLDMASK 1) |by| 2                            |do| (SETQ OLDCONTENTS (\\GETBASEPTR XQP::OLDTABLE I))                                 (SELECTQ (\\GETBASEBYTE XQP::OLDTABLE (LLSH I 1))                                     (0                      (* |empty|)                                        NIL)                                     (8                      (* XQP::|singleton|)                    (* * NIL INDEX |arg| |to| XQP::DYN.INSERT.IN.BUCKET |means| |we're|           XQP::|inserting| \a XQP::|whole| XQP::|subchain,| |not| |just| \a |single|           XQP::|clause.|)                                        (XQP::DYN.INSERT.IN.BUCKET (XQP::TABLE.BUCKET XQP::NEWTABLE                                                                          (\\GETBASE OLDCONTENTS                                                                         XQP::|guardedsubitem.key.low|                                                                                 )                                                                          XQP::NEWMASK)                                               OLDCONTENTS NIL))                                     (128                    (* XQP::|crowded|)                    (* |for| |each| XQP::INDEX.LINK |in| |the| XQP::|crowded| XQP::|slot,| |insert|           |it| |in| |the| |new| XQP::|table,| |and| XQP::|kill| |the| |old|           XQP::INDEX.LINK.)                                          (|bind| (LINK _ OLDCONTENTS)                                                 XQP::GUARDEDSUBCHAIN                                             |do| (SETQ XQP::GUARDEDSUBCHAIN (\\GETBASEPTR LINK 2))                     (* * NIL INDEX |arg| |to| XQP::DYN.INSERT.IN.BUCKET |means| |we're|           XQP::|inserting| \a XQP::|whole| XQP::|subchain,| |not| |just| \a |single|           XQP::|clause.|)                                                  (XQP::DYN.INSERT.IN.BUCKET (XQP::TABLE.BUCKET                                                                              XQP::NEWTABLE                                                                              (\\GETBASE                                                                                  XQP::GUARDEDSUBCHAIN                                                                         XQP::|guardedsubitem.key.low|                                                                                     )                                                                              XQP::NEWMASK)                                                         XQP::GUARDEDSUBCHAIN NIL)                                             |repeatwhile| (SETQ LINK (\\GETBASEPTR LINK 0)))                    (* * XQP::|\\DELREFfing| |the| |first| |in| \a XQP::|subitem| |chain| |will|           \\DELREF XQP::|everything| |in| |the| XQP::|chain,| |since| |the| LINK |field|           |is| |known| |to| |lisp| |to| |be| |of| |type| XQP::|pointer.|)                                          (\\DELREF OLDCONTENTS))                                     (SHOULDNT 'XQP::DYN.INCREASE.POPULATION)))                         (\\PUTBASEPTR INDEX XQP::|dynindex.table| XQP::NEWTABLE)                         (\\PUTBASE INDEX XQP::|dynindex.mask| XQP::NEWMASK)                         (\\DELREF XQP::OLDTABLE))))))(XQP::DYN.INSERT.IN.BUCKET  (LAMBDA (XQP::BUCKETPTR XQP::GUARDEDSUBITEM INDEX)         (* XQP::|pds:| " 2-May-87 15:59")                    (* * |Insert| XQP::GUARDEDSUBITEM |into| |the| XQP::|hash| XQP::|bucket|           XQP::|pointed| |to| |by| XQP::BUCKETPTR.          XQP::INDEX\, |if| XQP::|non-NIL| XQP::|points| |to| |the| |index| |this|           XQP::|clause| |is| |to| |be| |added| XQP::|to.|          XQP::I\n |this| XQP::|case,| |we| XQP::|know| |that| |this| |is| |the| |first|           XQP::|clause| |with| |this| |key| |to| |be| |added| |to| |this| XQP::|index.|          I\f INDEX |is| NIL\, |then| XQP::GUARDEDSUBITEM |is| |actually| |an|           XQP::|entire| XQP::|subchain| |to| |be| |added| |to| |the| XQP::|bucket.|          |This| |will| |be| |the| |case| |when| |we're| |copying| |from| |one|           XQP::|hash| |table| |to| XQP::|another.|)    (|if| INDEX        |then|                     (* |This| |is| |the| |first| XQP::|clause| |with| |this| XQP::|key,| |so| |set|           |up| XQP::|it's| XQP::|subitem| |next| |and| XQP::|prev| XQP::|fields.|)              (LET ((SUBITEM (\\ADDBASE XQP::GUARDEDSUBITEM XQP::|guardedsubitem.subitem|)))                   (\\PUTBASEPTR SUBITEM XQP::|subitem.next| INDEX)                   (\\PUTBASEBYTE SUBITEM XQP::|subitem.next.tagbyte| 255)                   (\\PUTBASEPTR SUBITEM XQP::|subitem.prev| SUBITEM)))                    (* * XQP::|What's| |in| |the| XQP::|bucket| XQP::|now?|)    (SELECTQ (\\GETBASEBYTE XQP::BUCKETPTR 0)        (0                                                   (* |empty|)           (\\PUTBASEPTR XQP::BUCKETPTR 0 XQP::GUARDEDSUBITEM)                                                             (* |now| XQP::|singleton|)           (\\PUTBASEBYTE XQP::BUCKETPTR 0 8))        (8                                                   (* XQP::|singleton|)           (LET ((XQP::SECONDLINK (|create| XQP::INDEX.LINK))                 (XQP::FIRSTLINK (|create| XQP::INDEX.LINK)))                    (* * XQP::|Unfortunately,| |the| JUMP |field| |of| XQP::INDEX.LINK |is|           XQP::|declared| |to| |be| XQP::FIXP\, |so| |we| |can't| |initialize| |it| |in|           |the| |create| XQP::|call,| |nor| |can| |we| |set| |it| |with| XQP::|replace.|)                (\\ADDREF XQP::SECONDLINK)                (\\ADDREF XQP::FIRSTLINK)                (\\PUTBASEPTR XQP::SECONDLINK 0 NIL)                (\\PUTBASEPTR XQP::SECONDLINK 2 (\\GETBASEPTR XQP::BUCKETPTR 0))                (\\PUTBASEPTR XQP::FIRSTLINK 0 XQP::SECONDLINK)                (\\PUTBASEPTR XQP::FIRSTLINK 2 XQP::GUARDEDSUBITEM)                (\\PUTBASEPTR XQP::BUCKETPTR 0 XQP::FIRSTLINK)                                                             (* |now| XQP::|crowded|)                (\\PUTBASEBYTE XQP::BUCKETPTR 0 128)))        (128                                                 (* XQP::|crowded|)             (LET ((XQP::NEWLINK (|create| XQP::INDEX.LINK)))                    (* * XQP::|Unfortunately,| |the| |second| |field| |of| XQP::INDEX.LINK |is|           XQP::|declared| |to| |be| XQP::FIXP\, |so| |we| |can't| |initialize| |it| |in|           |the| |create| XQP::|call,| |nor| |can| |we| |set| |it| |with| XQP::|replace.|)                  (\\ADDREF XQP::NEWLINK)                    (* * XQP::NB\: |since| |this| |list| |is| |only| XQP::|searched| |when| \a           |call| |is| XQP::|indexable,| XQP::|it's| |not| XQP::|necessary| |to|           XQP::|keep| |this| |list| XQP::|properly| XQP::|ordered.|          XQP::|Since| XQP::|it's| XQP::|easiest| |to| XQP::|put| \a |new|           XQP::|subchain| |at| |the| XQP::|beginning| |of| |the| XQP::|list,| |we| |do|           XQP::|that.|)                  (\\PUTBASEPTR XQP::NEWLINK 0 (\\GETBASEPTR XQP::BUCKETPTR 0))                  (\\PUTBASEPTR XQP::NEWLINK 2 XQP::GUARDEDSUBITEM)                  (\\PUTBASEPTR XQP::BUCKETPTR 0 XQP::NEWLINK)                                                             (* |now| |even| |more| XQP::|crowded|)                  (\\PUTBASEBYTE XQP::BUCKETPTR 0 128)))        (SHOULDNT 'XQP::DYN.INSERT.IN.BUCKET)))))(* \; "Code for clause reclamation")(DEFINEQ(XQP::CLEAN.UP.CLAUSES  (LAMBDA NIL                                                (* XQP::|pds:| "26-May-87 17:55")                    (* * XQP::|Called| |by| XQP::|clean_up_clauses/0| |in| |Prolog.|          XQP::|Always| XQP::|cleans| |up.|)    (|if| (NEQ 0 XQP::DEAD.CLAUSE.COUNT)        |then| (UNINTERRUPTABLY                   (XQP::TRAVERSE.STACK)                   (XQP::TRAVERSE.DEAD.CHAIN)                   (SETQ XQP::THRASHING.COUNT 0)))))(XQP::MAYBE.CLEAN.UP  (LAMBDA NIL                                                (* XQP::|pds:| "26-May-87 17:56")                    (* * |called| |by| XQP::|maybe_clean_up/0| |in| |Prolog.|          XQP::|Like| XQP::PERHAPS.CLEAN.UP\, XQP::|except| |doesn't| XQP::|bother|           |with| XQP::|thrashing| |stuff.|)    (|if| (IGEQ XQP::DEAD.CLAUSE.COUNT (LRSH (XQP::\\BASEDIFFERENCE (XQP::|get.24| B)                                                    XQP::|init.E|)                                             7))        |then| (XQP::REALLY.CLEAN.UP))))(XQP::PERHAPS.CLEAN.UP  (LAMBDA NIL                                                (* XQP::|pds:| "26-May-87 17:58")                    (* * XQP::|Called| |from| XQP::|perhaps_clean_up/0| |in| |Prolog.|          XQP::|Clean| |up| |if| |there| |are| XQP::|lots| |of| XQP::|dead| |clauses|           XQP::|relative| |to| XQP::|local| |stack| XQP::|size,| XQP::|or,| |if|           XQP::|we've| |been| XQP::|thrashing,| XQP::|lots| |of| XQP::NEWLY XQP::|dead|           |clauses| XQP::|relative| |to| XQP::|local| |stack| XQP::|size.|)    (|if| (IGEQ XQP::DEAD.CLAUSE.COUNT (IPLUS XQP::THRASHING.COUNT (LRSH (XQP::\\BASEDIFFERENCE                                                                          (XQP::|get.24| B)                                                                          XQP::|init.E|)                                                                         6)))        |then| (XQP::REALLY.CLEAN.UP))))(XQP::REALLY.CLEAN.UP  (LAMBDA NIL                                                (* XQP::|pds:| "26-May-87 17:59")                    (* * XQP::|Clean| |up| XQP::|unneeded| XQP::|dead| XQP::|clauses,| XQP::|like|           XQP::|really_clean_up/0| |in| |Prolog.| |After| XQP::|clean| XQP::|up,|           XQP::|determine| XQP::|whether| |we're| XQP::|thrashing.|)    (UNINTERRUPTABLY        (XQP::TRAVERSE.STACK)        (XQP::TRAVERSE.DEAD.CHAIN)        (|if| (IGEQ XQP::DEAD.CLAUSE.COUNT (LRSH (XQP::\\BASEDIFFERENCE (XQP::|get.24| B)                                                        XQP::|init.E|)                                                 6))            |then| (SETQ XQP::THRASHING.COUNT XQP::DEAD.CLAUSE.COUNT)          |else| (SETQ XQP::THRASHING.COUNT 0))))))(DEFINEQ(XQP::COLLECT.CLAUSE.CHAIN  (LAMBDA (XQP::FIRSTDYN XQP::ININDEX?)                      (* XQP::|pds:| "21-May-87 12:01")                    (* * XQP::FIRSTDYN XQP::|points| |to| |the| XQP::|<nonindexed>|           XQP::|interpret.me| XQP::|instruction| |of| \a XQP::|clause,| |or| |the|           XQP::|dynamic.index| XQP::|instruction| |of| |an| XQP::|index.|          XQP::|Starting| |from| XQP::|there,| XQP::|put| |this| XQP::|clause| |and|           |all| |the| |clauses| XQP::|accessible| |from| |there| |on| |the| XQP::|dead|           XQP::|clause| XQP::|chain.|)    (|bind| (XQP::DYN _ XQP::FIRSTDYN) |do| (|if| (EQ (\\GETBASEBYTE XQP::DYN 0)                                                      (CONSTANT (XQP::OP.CODE 'XQP::|dynamic.index|))                                                      )                                                |then|       (* XQP::|It's| |an| XQP::|index:|                                                              |collect| |its| |clauses|)                    (* * |This| XQP::|recursive| |call| |should| |never| XQP::|recurse| |more|           |than| |one| XQP::|deep.|)                                                      (XQP::COLLECT.CLAUSE.CHAIN (\\GETBASEPTR                                                                                         XQP::DYN                                                                                 XQP::|dynindex.first|                                                                                        )                                                             T)                                              |elseif| (NULL (\\GETBASEPTR XQP::DYN                                                                     XQP::|clause.died|))                                                |then|                     (* |Must| |be| \a XQP::|regular| XQP::|clause:| XQP::|it's| |not| |already|           XQP::|dead,| |so| |collect| XQP::|it.|)                                                      (XQP::PUT.CLAUSE.ON.DEAD.CHAIN XQP::DYN)                                                      (|add| XQP::DEAD.CLAUSE.COUNT 1))                                            (|if| (NEQ 0 (\\GETBASEBYTE XQP::DYN                                                                 XQP::|dyn.next.tagbyte|))                                                |then| (|if| (NOT XQP::ININDEX?)                                                           |then|                     (* |end| |of| XQP::|chain:| XQP::|make| |last| |point| |to| XQP::|first,|           XQP::|rather| |than| XQP::|parent| XQP::|<proc| |or| XQP::|index>.|          |Must| |use| \a |special| |tag| XQP::<127> |to| XQP::|distinguish| \a           XQP::|regular| |last| XQP::|ptr| |from| \a |first| XQP::|ptr.|          |Note| |that| XQP::|interpret.me| |and| XQP::|dynamic.index| MUST XQP::|treat|           |this| |special| |tag| |just| |as| |it| XQP::|does| \a XQP::|regular| |last|           XQP::|ptr.|)                                                                 (\\PUTBASEPTR XQP::DYN                                                                         XQP::|dyn.next| XQP::FIRSTDYN                                                                        )                                                                 (\\PUTBASEBYTE XQP::DYN                                                                         XQP::|dyn.next.tagbyte| 127))                                                      (RETURN))                                            (SETQ XQP::DYN (\\GETBASEPTR XQP::DYN XQP::|dyn.next|)))))(XQP::COLLECT.CLAUSES  (LAMBDA (PROC)                                             (* \; "Edited 26-Jun-87 14:38 by pds")                    (* * XQP::|Collect| |the| |clauses| |of| XQP::|interpreted| XQP::|procedure|           PROC |on| |the| XQP::|dead| XQP::|clause| |chain| |for| XQP::|later|           XQP::|reclamation.|)    (LET ((XQP::FIRSTDYN (XQP::PROC.LASTCLAUSE PROC)))         (|if| (NEQ XQP::FIRSTDYN XQP::FAILURE.CLAUSE)             |then| (XQP::COLLECT.CLAUSE.CHAIN XQP::FIRSTDYN)                   (CL:SETF (XQP::PROC.LASTCLAUSE PROC)                          XQP::FAILURE.CLAUSE)                     (* * |Only| XQP::|increment| |clock| |once| |per| XQP::|abolish,| |and| |only|           |if| |the| |proc| |has| XQP::|clauses.|)                   (|add| XQP::CLOCK.TIME 1)))))(XQP::DISPOSE.CLAUSE  (LAMBDA (CLAUSE)                                           (* XQP::|pds:| "26-May-87 18:00")                    (* * CLAUSE |has| |been| XQP::|retracted,| |and| |can| |no| |longer| |be|           XQP::|used,| |so| |it| |is| XQP::|safe| |to| XQP::|unlink| XQP::|it.|          N\o |need| |to| \\DELREF XQP::|it,| |since| |its| |only| XQP::|reference| |is|           |from| |the| XQP::|dead| XQP::|clause| XQP::|chain,| |from| |which| |it| |is|           XQP::|about| |to| |be| XQP::|removed.|)                    (* * XQP::|Make| XQP::|sure| |we| XQP::|haven't| XQP::|freed| |this|           XQP::|clause| |already|)    (|if| (NEQ 0 (\\GETBASE CLAUSE (ADD1 XQP::|clause.indexed.instr|)))        |then| (ERROR "Clause freed twice" CLAUSE))    (\\PUTBASE CLAUSE (ADD1 XQP::|clause.indexed.instr|)           55)                                               (* 55 |is| \a XQP::|random| |number|                                                              XQP::!= 0)                    (* * XQP::|First| XQP::|deal| |with| |indexed| XQP::|linkage|)    (LET ((XQP::HIGHKEY (\\GETBASE CLAUSE XQP::|clause.key|)))         (|if| (EQ XQP::|ref.tag.16| XQP::HIGHKEY)             |then|                                          (* XQP::|nonindexable| XQP::|clause:|                                                              |just| XQP::|unlink| XQP::|it.|)                   (XQP::UNLINK.NONINDEXED.CLAUSE CLAUSE)           |else|                                            (* XQP::|indexable| XQP::|clause:|                                                              |get| XQP::|rid| |of| |indexed|                                                              XQP::|linkage| |first|)                 (XQP::REMOVE.FROM.INDEX (\\ADDBASE CLAUSE XQP::|clause.subitem|)                        (NEQ XQP::|list.tag.16| XQP::HIGHKEY))                                                              (* |now| XQP::|unlink| XQP::|clause|)                 (XQP::UNLINK.INDEXED.CLAUSE CLAUSE)))                    (* * \\DELREF |all| XQP::|reference| XQP::|counted| |pointers| |in| |the|           XQP::|clause.| N\o |need| |to| \\DELREF |the| XQP::|clause| XQP::|itself,| |as|           |it| |was| XQP::|\\DELREFfed| |when| |it| |was| XQP::|placed| |on| |the|           XQP::|dead| XQP::|clause| XQP::|chain.| |Once| |it| |is| XQP::|removed| |from|           |the| XQP::|chain,| XQP::|it's| XQP::|gone.|)    (XQP::EMPTY.OUT.CLAUSE CLAUSE)))(XQP::EMPTY.OUT.CLAUSE  (LAMBDA (CLAUSE)                                           (* XQP::|pds:| "26-May-87 14:59")                    (* * XQP::|Carefully| \\DELREF |all| XQP::|reference| XQP::|counted| |lisp|           |objects| |in| |the| XQP::|skeleton| |of| XQP::CLAUSE.)    (|for| I |from| XQP::|clause.skel| |to| (IDIFFERENCE (LLSH (\\GETBASE CLAUSE XQP::|clause.size|)                                                               1)                                                   XQP::|clauseheader.words|) |by| 2       |when| (IGEQ (\\GETBASE CLAUSE I)                    XQP::|other.tag.16|) |do| (\\DELREF (\\GETBASEPTR CLAUSE I)))))(XQP::INDEX.BUCKET  (LAMBDA (INDEX SUBITEM)                                    (* XQP::|pds:| " 1-May-87 15:29")                    (* * SUBITEM |is| \a |pointer| |to| |the| XQP::INDEXED XQP::|interpret.me|           XQP::|instruction| |of| \a XQP::|clause,| |and| INDEX |is| |the| |index| |the|           XQP::|clause| |is| XQP::|in.| |The| |key| |of| SUBITEM |must| NOT |be| "."           XQP::|<ie,| \a XQP::|list>.| XQP::|Returns| \a |pointer| |to| |the|           XQP::|bucket| |the| XQP::|clause| |is| XQP::|in.|)    (\\ADDBASE (\\GETBASEPTR INDEX XQP::|dynindex.table|)           (LLSH (LOGAND (\\GETBASE SUBITEM XQP::|subitem.key.low|)                        (\\GETBASE INDEX XQP::|dynindex.mask|))                 1))))(XQP::INDEX.CORRECT.LINK  (LAMBDA (INDEX SUBITEM)                                    (* XQP::|pds:| " 1-May-87 15:32")                    (* * SUBITEM |is| \a |pointer| |to| |the| XQP::INDEXED XQP::|interpret.me|           XQP::|instruction| |of| \a XQP::|clause,| |and| INDEX |is| |the| |index| |the|           XQP::|clause| |is| XQP::|in.| |The| |key| |of| SUBITEM |must| NOT |be| "."           XQP::|<ie,| \a XQP::|list>.| XQP::|Returns| \a |pointer| |to| |the| XQP::|cell|           |that| XQP::|points| |to| |the| |first| XQP::|clause| |in| INDEX XQP::|having|           |the| |same| |key| |as| XQP::INDEXEDCLAUSE.)    (LET ((BUCKET (XQP::INDEX.BUCKET INDEX SUBITEM)))         (SELECTQ (\\GETBASEBYTE BUCKET 0)             (8                                              (* \a XQP::|singleton:| XQP::|bucket|                                                              XQP::|points| |directly| |to| |the|                                                              XQP::|clause|)                BUCKET)             (128                     (* XQP::|crowded| XQP::|slot:| XQP::|bucket| XQP::|points| |to| \a |chain| |of|           XQP::INDEX.LINK\s. XQP::|Return| \a |pointer| |to| |the| JUMP |field| |of|           |the| |right| XQP::|link.|)                  (|bind| (LINK _ (\\GETBASEPTR BUCKET 0))                         (XQP::KEYHIGH _ (\\GETBASE SUBITEM XQP::|subitem.key|))                         (XQP::KEYLOW _ (\\GETBASE SUBITEM XQP::|subitem.key.low|))                         XQP::KEYPTR |while| LINK                     |do| (|if| (AND (EQ XQP::KEYLOW (\\GETBASE (SETQ XQP::KEYPTR (\\GETBASEPTR                                                                                   LINK 2))                                                            XQP::|guardedsubitem.key.low|))                                     (EQ XQP::KEYHIGH (\\GETBASE XQP::KEYPTR                                                              XQP::|guardedsubitem.key|)))                              |then| (RETURN (\\ADDBASE LINK 2)))                          (SETQ LINK (\\GETBASEPTR LINK 0)) |finally| (SHOULDNT)))             (SHOULDNT)))))(XQP::PUT.CLAUSE.ON.DEAD.CHAIN  (LAMBDA (CLAUSE)                                           (* XQP::|pds:| "21-May-87 12:07")                    (* * XQP::|We're| XQP::|retracting| XQP::CLAUSE.          XQP::|Kill| |it| |by| XQP::|giving| |it| |the| XQP::|current| |time| |as|           XQP::|it's| XQP::|died| XQP::|time,| |and| XQP::|put| |it| |on| |the|           XQP::|dead| XQP::|clause| XQP::|chain.|)    (\\PUTBASEPTR CLAUSE XQP::|clause.died| XQP::CLOCK.TIME)                    (* * XQP::O\n |the| |Xerox| XQP::|port| |we| |use| \a XQP::|much|           XQP::|simplified| XQP::|dead| XQP::|clause| XQP::|chain,| |which| |is| |just|           \a |linear| |list| |of| |the| XQP::|retracted| XQP::|clauses.|          |This| |is| XQP::|okay| |because| |we| |don't| XQP::|suffer| \a           XQP::|performance| XQP::|penalty| |by| XQP::|having| \a XQP::|lot| |of|           XQP::|unreclaimed| |clauses| XQP::|laying| XQP::|around.|          XQP::|Therefore,| |we| |only| |try| |to| XQP::|reclaim| |when| |we| |get| |to|           XQP::|top| XQP::|level,| |or| |when| XQP::|we've| XQP::|retracted| \a XQP::LOT           |of| XQP::|clauses.| |This| |should| XQP::|usually| |be| XQP::|efficient|           XQP::|enough,| |and| |is| \a XQP::|lot| XQP::|simpler| |than| |the|           XQP::|non-Xerox| XQP::|code.|)    (|push| XQP::DEAD.CLAUSE.CHAIN CLAUSE)                    (* |This| |is| XQP::|okay| |because| |it| |will| |have| \a XQP::|counted|           XQP::|reference| |from| |being| |on| |the| XQP::|dead| XQP::|clause|           XQP::|chain.|)    (\\DELREF CLAUSE)))(XQP::RECLAIM.UNATTACHED.CLAUSE  (LAMBDA (CLAUSE)                                           (* XQP::|pds:| "26-May-87 15:04")                    (* * XQP::|Reclaim| \a XQP::|clause| |that| |was| |never| XQP::|put| |into| \a           XQP::|procedure| |or| XQP::|index,| |never| |in| \a XQP::|clause|           XQP::|linkage.| XQP::I\t |must| |also| |be| XQP::|guaranteed| |that| |no| |one|           |else| |will| XQP::|ever| |try| |to| |use| XQP::CLAUSE\, |since| |after|           XQP::|this,| XQP::|it's| XQP::|gone.| |This| |code| |is| XQP::|written| |just|           |for| XQP::|copy_term/2,| |which| |creates| \a XQP::|clause| |just| XQP::|long|           XQP::|enough| |to| XQP::|copy| |the| XQP::|term,| |and| |then| |has| |not|           XQP::|further| |use| |for| XQP::|it.|)    (XQP::EMPTY.OUT.CLAUSE CLAUSE)    (\\DELREF CLAUSE)))(XQP::REMOVE.FROM.INDEX  (LAMBDA (SUBITEM XQP::GUARDED?)                            (* XQP::|pds:| "22-May-87 18:14")                    (* * SUBITEM XQP::|points| |to| |the| |indexed| XQP::|interpret.me|           XQP::|instruction| |of| \a XQP::|clause.|          XQP::|Remove| |that| XQP::|clause| |from| |the| |index| XQP::|it's| |in,| |and|           XQP::|make| |the| |index| XQP::|consistent.|          N\o |need| |to| XQP::|reclaim| |the| |index| XQP::|itself,| |as| |other| |code|           |will| |take| XQP::|care| |of| XQP::|that.|)    (LET*     ((NEXT (\\GETBASEPTR SUBITEM XQP::|subitem.next|))      (PREV (\\GETBASEPTR SUBITEM XQP::|subitem.prev|))      (TAG (\\GETBASEBYTE SUBITEM XQP::|subitem.next.tagbyte|))      (XQP::PREVTAG (\\GETBASEBYTE PREV XQP::|subitem.next.tagbyte|)))     (|if| (EQ PREV SUBITEM)         |then|                     (* |Only| XQP::|clause| |in| |this| |index| |with| |this| XQP::|key.|          |This| |is| |the| XQP::|usual| XQP::|case.|)                    (* * NEXT XQP::|points| |to| |the| |index| |this| XQP::|clause| |is| XQP::|in.|          |Find| |the| |right| XQP::|hash| XQP::|bucket,| |and| |remove| |this| |key|           |from| XQP::|it.|)               (|if| XQP::GUARDED?                   |then|                                    (* XQP::|regular| |indexed| |case|)                         (LET ((BUCKET (XQP::INDEX.BUCKET NEXT SUBITEM)))                              (SELECTQ (\\GETBASEBYTE BUCKET 0)                                  (8                         (* |Was| \a XQP::|singleton,| |empty|                                                              |now|)                                     (\\PUTBASEBYTE BUCKET 0 0))                                  (128                       (* |Was| XQP::|crowded|)                    (* * |first| |remove| |key| |from| |index|)                                       (|bind| (TARGET _ (\\ADDBASE SUBITEM                                                                 XQP::|subitem.guardedsubitem|))                                              (PREV _ BUCKET)                                              PTR |while| (SETQ PTR (\\GETBASEPTR PREV 0))                                          |do| (|if| (EQ (\\GETBASEPTR PTR 2)                                                         TARGET)                                                   |then| (\\PUTBASEPTR PREV 0 (\\GETBASEPTR PTR 0))                                                         (\\PUTBASEPTR PTR 0 NIL)                                                              (* XQP::|Avoid| XQP::|reclaiming|                                                              XQP::|rest| |of| |chain|)                                                         (\\DELREF PTR)                                                         (RETURN))                                               (SETQ PREV PTR) |finally| (SHOULDNT))                    (* * |is| XQP::|bucket| XQP::|still| XQP::|crowded?|)                                       (LET ((XQP::FIRSTLINK (\\GETBASEPTR BUCKET 0)))                                            (|if| (NULL (\\GETBASEPTR XQP::FIRSTLINK 0))                                                |then|       (* |now| XQP::|singleton|)                                                      (\\PUTBASEPTR BUCKET 0 (\\GETBASEPTR                                                                                     XQP::FIRSTLINK 2)                                                             )                                                      (\\PUTBASEPTR XQP::FIRSTLINK 0 NIL)                                                              (* XQP::|Avoid| XQP::|reclaiming|                                                              XQP::|rest| |of| |chain|                                                              XQP::|<shouldn't| |be|                                                              XQP::|necessary>|)                                                      (\\DELREF XQP::FIRSTLINK)                                                      (\\PUTBASEBYTE BUCKET 0 8)                                              |else|         (* XQP::|still| XQP::|crowded|)                                                    (\\PUTBASEBYTE BUCKET 0 128))))                                  (SHOULDNT)))                     (* * XQP::|Finally,| XQP::|decrement| |index| XQP::|population|)                         (\\PUTBASE NEXT XQP::|dynindex.population| (SUB1 (\\GETBASE NEXT                                                                            XQP::|dynindex.population|                                                                                 )))                 |else|                                      (* |list| |case|)                       (\\PUTBASEPTR NEXT XQP::|dynindex.list| XQP::FAILURE.CLAUSE))       |elseif| (NEQ TAG 0)         |then|                                              (* XQP::|Last| XQP::|clause| |in|                                                              |this| |index| |with| |this|                                                              XQP::|key.|)                    (* * XQP::|copy| |tag| |as| |well| |as| |pointer| |to| |next| |field| |of|           XQP::|prev|)               (\\PUTBASEPTR PREV XQP::|subitem.next| NEXT)               (\\PUTBASEBYTE PREV XQP::|subitem.next.tagbyte| TAG)                     (* * XQP::|Make| |first| |point| |to| |new| XQP::|last.|          |Note| |that| XQP::INDEX.CORRECT.LINK |returns| \a |pointer| |to| \a |pointer|           |to| \a XQP::GUARDED XQP::|subitem.|)               (|if| XQP::GUARDED?                   |then| (\\PUTBASEPTR (\\GETBASEPTR (XQP::INDEX.CORRECT.LINK NEXT SUBITEM)                                               0)                                 XQP::|guardedsubitem.prev| PREV)                 |else| (\\PUTBASEPTR (\\GETBASEPTR NEXT XQP::|dynindex.list|)                               XQP::|subitem.prev| PREV))       |elseif| (NEQ XQP::PREVTAG 0)         |then|                                              (* XQP::|First| XQP::|clause| |in|                                                              |this| |index| |with| |this|                                                              XQP::|key.|)               (\\PUTBASEPTR NEXT XQP::|subitem.prev| PREV)                     (* * XQP::|Make| |index| |point| |to| |new| |first|)               (|if| XQP::GUARDED?                   |then| (LET* ((BUCKET (XQP::INDEX.CORRECT.LINK (\\GETBASEPTR PREV                                                                          XQP::|subitem.next|)                                                SUBITEM))                                 (XQP::BUCKETTAG (\\GETBASEBYTE BUCKET 0)))                                (\\PUTBASEPTR BUCKET 0 (\\ADDBASE NEXT XQP::|subitem.guardedsubitem|)                                       )                    (* * |Now| XQP::|put| |the| |tag| XQP::|back.|          |Note| |that| |if| |this| XQP::|clause| XQP::|lives| |in| \a XQP::|crowded|           XQP::|slot,| |then| BUCKET |isn't| \a XQP::|bucket| |in| |the| XQP::|hash|           XQP::|table,| |but| \a |pointer| |into| |the| XQP::INDEX.LINK |that|           XQP::|points| |to| |the| |first| XQP::|clause| |with| |this| XQP::|key.|          XQP::I\n |this| XQP::|case,| |there's| |no| |reason| |to| |be| XQP::|playing|           |with| |the| |tag| XQP::|byte,| |but| |no| XQP::|harm,| XQP::|either.|          XQP::I\t |just| XQP::|simplifies| |the| XQP::|code.|)                                (\\PUTBASEBYTE BUCKET 0 XQP::BUCKETTAG))                 |else| (\\PUTBASEPTR (\\GETBASEPTR PREV XQP::|subitem.next|)                               XQP::|dynindex.list| NEXT))       |else|                                                (* XQP::|middle| XQP::|clause| |in|                                                              |proc| |or| |index|)             (\\PUTBASEPTR PREV XQP::|subitem.next| NEXT)             (\\PUTBASEPTR NEXT XQP::|subitem.prev| PREV)))))(XQP::TABLE.BUCKET  (LAMBDA (TABLE XQP::KEYLOW16 MASK)                         (* XQP::|pds:| " 1-May-87 15:23")                    (* * XQP::|Returns| \a |pointer| |to| |the| XQP::|bucket| |in| TABLE |that|           |the| |key| |in| XQP::GUARDEDSUBITEM XQP::|belongs| XQP::|in.|          |The| XQP::|hash| XQP::|mask| |is| XQP::MASK.)    (\\ADDBASE TABLE (LLSH (LOGAND XQP::KEYLOW16 MASK)                           1))))(XQP::TRAVERSE.DEAD.CHAIN  (LAMBDA (XQP::DEBUG?)                                      (* XQP::|pds:| "26-May-87 18:07")                    (* * XQP::|Remove| |from| XQP::DEAD.CLAUSE.CHAIN |the| |clauses| |that| |are|           |no| |longer| XQP::|needed.| XQP::TRAVERSE.STACK |has| |just| |been|           XQP::|completed,| |so| |we| XQP::|know| XQP::|what's| |on| |the| XQP::|stack.|)                    (* * |The| XQP::|outer| XQP::|<first>| |loop| |of| |this| |code| XQP::|pops|           |the| |first| XQP::|element| |off| |of| |the| |list| |as| |many| |times| |as|           |it| XQP::|can.| |The| XQP::|inner| XQP::|<second>| |loop| |then|           XQP::|removes| |the| XQP::|rest| |of| |the| XQP::|unneeded| |clauses| |from|           |the| XQP::|list.| |Note| |that| |the| |clauses| |on| |this| |list| |have|           |only| |one| XQP::|reference| XQP::|count:| |the| |one| |from| |the|           XQP::|list.| XQP::|Therefore,| XQP::|removing| \a XQP::|clause| |from| |this|           |list| |is| XQP::|enough| |to| XQP::|ensure| |that| |it| |will| |be|           XQP::|reclaimed.|)    (|bind| HD (LST _ XQP::DEAD.CLAUSE.CHAIN)           (CNT _ XQP::DEAD.CLAUSE.COUNT) |eachtime| (SETQ HD (CAR LST))       |while| (AND LST (XQP::UNNEEDED.CLAUSE HD)) |do| (XQP::DISPOSE.CLAUSE HD XQP::DEBUG?)                                                        (SETQ CNT (SUB1 CNT))                                                        (|pop| LST)       |finally| (SETQ XQP::DEAD.CLAUSE.CHAIN LST)             (|while| (CDR LST) |do| (SETQ HD (CADR LST))                                     (|if| (XQP::UNNEEDED.CLAUSE HD)                                         |then| (XQP::DISPOSE.CLAUSE HD XQP::DEBUG?)                                               (SETQ CNT (SUB1 CNT))                                               (RPLACD LST (CDDR LST))                                       |else| (|pop| LST)) |finally| (SETQ XQP::DEAD.CLAUSE.COUNT CNT                                                                      )))))(XQP::TRAVERSE.STACK  (LAMBDA NIL                                                (* XQP::|pds:| "26-May-87 17:52")                    (* * XQP::|traverse| |the| XQP::|Prolog| |stack| |looking| |for|           XQP::|interpreted| XQP::|choicepoints,| XQP::|storing| |the| XQP::EARLIEST           |call| |clock| |time| |for| |each| XQP::|procedure| |in| XQP::|hash| |table|           XQP::ACTIVE.PROC.TABLE. |Note| |that| |the| XQP::|earliest| |call| |to| \a           XQP::|procedure| |will| |be| |the| LAST |one| |we| XQP::|come| |to|           XQP::|scanning| |the| XQP::|choicepoints| |from| |the| XQP::|most|           XQP::|recent| XQP::|back.|)    (CLRHASH XQP::ACTIVE.PROC.TABLE)    (|bind| (CP _ (XQP::|get.24| B))           XQP::DYN OPCODE |while| (XQP::\\BASELESSP XQP::|init.E| CP)       |do| (|if| (EQ (SETQ OPCODE (\\GETBASEBYTE (SETQ XQP::DYN (\\GETBASEPTR CP -6))                                          0))                      (CONSTANT (XQP::OP.CODE 'XQP::|interpret.me|)))                |then|                     (* XQP::|instr| |to| XQP::|backtrack| |into| |is| XQP::|interpret.me:| |note|           |the| |proc| |and| |call| |clock|)                    (* * XQP::|First| |byte| |after| XQP::|instr| XQP::|indicates| XQP::|how|           |many| |words| |after| |the| |word| |after| |the| XQP::|instr| |the|           XQP::|born| XQP::|field.| |From| |here,| |we| |can| |find| |the| |proc|           XQP::|field.|)                      (PUTHASH (\\GETBASEPTR XQP::DYN (IDIFFERENCE (\\GETBASEBYTE XQP::DYN 1)                                                             (CONSTANT (IDIFFERENCE                                                                               XQP::|clause.born|                                                                               XQP::|clause.procedure|                                                                              ))))                             (\\GETBASEPTR CP -20)                             XQP::ACTIVE.PROC.TABLE)              |elseif| (EQ OPCODE (CONSTANT (XQP::OP.CODE 'XQP::|dynamic.index|)))                |then|                     (* XQP::|instr| |to| XQP::|backtrack| |into| |is| XQP::|dynamic.index:| |note|           |the| |proc| |and| |call| |clock|)                      (PUTHASH (\\GETBASEPTR (\\GETBASEPTR XQP::DYN XQP::|dynindex.first|)                                      XQP::|clause.procedure|)                             (\\GETBASEPTR CP -20)                             XQP::ACTIVE.PROC.TABLE))            (SETQ CP (\\GETBASEPTR CP -8)))))(XQP::UNLINK.INDEXED.CLAUSE  (LAMBDA (CLAUSE)                                           (* XQP::|pds:| "22-May-87 18:26")                    (* * XQP::|Unlink| XQP::CLAUSE\, |which| IS XQP::|indexable,| |from| |its|           XQP::|neighbors.| XQP::D\o |all| |the| |right| |things| |to| XQP::|make| |the|           |index| XQP::|it's| |in| XQP::|consistent.|)    (LET* ((NEXT (\\GETBASEPTR CLAUSE XQP::|clause.next|))           (PREV (\\GETBASEPTR CLAUSE XQP::|clause.prev|))           (TAG (\\GETBASEBYTE CLAUSE XQP::|clause.next.tagbyte|))           (XQP::PREVTAG (\\GETBASEBYTE PREV XQP::|clause.next.tagbyte|)))          (|if| (EQ PREV CLAUSE)              |then|                                         (* |Only| XQP::|clause| |in|                                                              XQP::|index:| XQP::|unlink| |index|                                                              |from| XQP::|procedure|)                    (|if| (NEQ 0 (\\GETBASE NEXT XQP::|dynindex.population|))                        |then|                     (* * |index| |should| |be| XQP::|empty!|)                              (SHOULDNT))                    (XQP::UNLINK.NONINDEXED.CLAUSE NEXT)                    (\\DELREF (\\GETBASEPTR NEXT XQP::|dynindex.table|))                                                              (* XQP::|make| XQP::|sure| XQP::|hash|                                                              |table| |is| XQP::|collected|)                    (\\DELREF NEXT)                          (* |explicitly| XQP::|kill|                                                              XQP::|index.|)                    NIL            |elseif| (NEQ TAG 0)              |then|                                         (* XQP::|Last| XQP::|clause| |in|                                                              |index|)                    (* * XQP::|copy| |tag| |as| |well| |as| |pointer| |to| |next| |field| |of|           XQP::|prev|)                    (\\PUTBASEPTR PREV XQP::|clause.next| NEXT)                    (\\PUTBASEBYTE PREV XQP::|clause.next.tagbyte| TAG)                     (* * XQP::|Make| |first| |point| |to| |new| |last|)                    (\\PUTBASEPTR (\\GETBASEPTR NEXT XQP::|dynindex.first|)                           XQP::|clause.prev| PREV)            |elseif| (NEQ XQP::PREVTAG 0)              |then|                                         (* XQP::|First| XQP::|clause| |in|                                                              |index|)                    (\\PUTBASEPTR NEXT XQP::|clause.prev| PREV)                     (* * XQP::|Make| |index| |point| |to| |new| |first|)                    (\\PUTBASEPTR (\\GETBASEPTR PREV XQP::|clause.next|)                           XQP::|dynindex.first| NEXT)            |else|                                           (* XQP::|middle| XQP::|clause| |in|                                                              |index|)                  (\\PUTBASEPTR PREV XQP::|clause.next| NEXT)                  (\\PUTBASEPTR NEXT XQP::|clause.prev| PREV)))))(XQP::UNLINK.NONINDEXED.CLAUSE  (LAMBDA (CLAUSE)                                           (* \; "Edited 26-Jun-87 14:38 by pds")                    (* * XQP::|Unlink| XQP::CLAUSE\, |which| |is| \a XQP::|non-indexable|           XQP::|clause| |or| |an| XQP::|index,| |from| |its| XQP::|neighbors.|          XQP::D\o |all| |the| |right| |things| |to| XQP::|make| |the| XQP::|procedure|           XQP::|it's| |in| XQP::|consistent.|)    (LET* ((NEXT (\\GETBASEPTR CLAUSE XQP::|dyn.next|))           (PREV (\\GETBASEPTR CLAUSE XQP::|dyn.prev|))           (TAG (\\GETBASEBYTE CLAUSE XQP::|dyn.next.tagbyte|))           (XQP::PREVTAG (\\GETBASEBYTE PREV XQP::|dyn.next.tagbyte|)))          (|if| (EQ PREV CLAUSE)              |then|                                         (* |Only| XQP::|clause| |in| |proc|)                    (|if| (EQ 255 TAG)                        |then|                               (* |Not| XQP::|dead| XQP::|last:|                                                              XQP::|parent| |is| |now| |empty|)                              (CL:SETF (XQP::PROC.LASTCLAUSE NEXT)                                     XQP::FAILURE.CLAUSE))            |elseif| (NEQ TAG 0)              |then|                                         (* XQP::|Last| XQP::|clause| |in|                                                              |proc|)                    (* * XQP::|copy| |tag| |as| |well| |as| |pointer| |to| |next| |field| |of|           XQP::|prev|)                    (\\PUTBASEPTR PREV XQP::|dyn.next| NEXT)                    (\\PUTBASEBYTE PREV XQP::|dyn.next.tagbyte| TAG)                     (* * XQP::|Make| |first| |point| |to| |new| |last|)                    (\\PUTBASEPTR (|if| (EQ TAG 127)                                      |then|                 (* XQP::|tagged| |as| XQP::|dead|                                                              XQP::|last:| NEXT |is| XQP::|really|                                                              |first|)                                            NEXT                                    |else|                     (* NEXT XQP::|points| |to| XQP::|proc:| |get| |first| |from| XQP::|there,|           |stored| |in| XQP::LAST.CLAUSE XQP::|slot|)                                          (XQP::PROC.LASTCLAUSE NEXT))                           XQP::|dyn.prev| PREV)            |elseif| (NEQ XQP::PREVTAG 0)              |then|                                         (* XQP::|First| XQP::|clause| |in|                                                              |proc|)                    (\\PUTBASEPTR NEXT XQP::|dyn.prev| PREV)                     (* * XQP::|Make| |proc| |point| |to| |new| |first|)                    (|if| (EQ XQP::PREVTAG 255)                        |then|                     (* XQP::|Proc| XQP::|points| |to| XQP::|clause,| |and| |must| |be| XQP::|fixed|           |to| |point| |to| XQP::|next.| I\f PREV XQP::|had| |been| XQP::|tagged| |as|           XQP::|dead| XQP::|last,| |there| |would| |have| |been| |no| |pointer| |to|           |first| XQP::|clause| |to| |be| XQP::|fixed.|)                              (CL:SETF (XQP::PROC.LASTCLAUSE (\\GETBASEPTR PREV XQP::|dyn.next|))                                     NEXT))            |else|                                           (* XQP::|middle| XQP::|clause| |in|                                                              |proc|)                  (\\PUTBASEPTR PREV XQP::|dyn.next| NEXT)                  (\\PUTBASEPTR NEXT XQP::|dyn.prev| PREV))))))(DECLARE\: EVAL@COMPILE (PUTPROPS XQP::UNNEEDED.CLAUSE MACRO ((CLAUSE)                                      (PROGN (* * XQP::|Returns| XQP::|non-NIL| XQP::|iff| CLAUSE                                                 XQP::|died| BEFORE XQP::|earliest| XQP::|active|                                                 |call| |to| |its| |proc| |found| |on| |the|                                                 XQP::|stack,| |or| |if| |there| |are| |no|                                                 XQP::|active| |calls| |to| XQP::|it.|)                                             (LET ((XQP::EARLIESTCALL (GETHASH (\\GETBASEPTR CLAUSE                                                                               XQP::|clause.procedure|                                                                                      )                                                                             XQP::ACTIVE.PROC.TABLE))                                                   )                                                  (NOT (AND XQP::EARLIESTCALL (IGEQ (\\GETBASEPTR                                                                                     CLAUSE                                                                                    XQP::|clause.died|                                                                                     )                                                                                    XQP::EARLIESTCALL                                                                                    ))))))))(RPAQ? XQP::DEAD.CLAUSE.CHAIN NIL)(RPAQ? XQP::DEAD.CLAUSE.COUNT 0)(RPAQ? XQP::THRASHING.COUNT 0)(RPAQ? XQP::ACTIVE.PROC.TABLE (HASHARRAY 50 2.0))(* \; "variables")(DECLARE\: DOEVAL@COMPILE DONTCOPY(GLOBALVARS XQP::DEAD.CLAUSE.CHAIN XQP::DEAD.CLAUSE.COUNT XQP::THRASHING.COUNT XQP::ACTIVE.PROC.TABLE       ))(* \; "Debugging code")(DEFINEQ(XQP::CLEAN  (LAMBDA (XQP::DEBUG?)                                      (* XQP::|pds:| "23-Apr-87 15:39")    (XQP::TRAVERSE.STACK)    (XQP::TRAVERSE.DEAD.CHAIN XQP::DEBUG?)    XQP::DEAD.CLAUSE.COUNT))(XQP::CHECK.BUCKET  (LAMBDA (PROC INDEX TAG PTR ALST STREAM)                   (* XQP::|pds:| " 5-May-87 18:22")    (SELECTQ TAG        (0 (AND (NEQ STREAM 'NO)                (PRINTOUT STREAM |,,| "empty" T)))        (8 (AND (NEQ STREAM 'NO)                (PRINTOUT STREAM |,,| "singleton "))           (XQP::CHECK.SUBCHAIN PROC INDEX PTR ALST T STREAM))        (128 (AND (NEQ STREAM 'NO)                  (AND (NEQ STREAM 'NO)                       (PRINTOUT STREAM |,,| "crowded ")))             (XQP::CHECK.SUBCHAIN PROC INDEX (GETBASEPTR PTR 2)                    ALST T STREAM)             (|bind| (LINK _ (GETBASEPTR PTR 0)) |while| LINK                |do| (AND (NEQ STREAM 'NO)                          (PRINTOUT STREAM "             " |,,|))                     (XQP::CHECK.SUBCHAIN PROC INDEX (GETBASEPTR LINK 2)                            ALST T STREAM)                     (SETQ LINK (GETBASEPTR LINK 0))))        (PROGN (AND (NEQ STREAM 'NO)                    (PRINTOUT STREAM |,,| "bogus tag on slot" T))               (SETQ XQP::BOTCH T)))))(XQP::CHECK.INDEX  (LAMBDA (PROC INDEX STREAM)                                (* XQP::|pds:| " 5-May-87 18:18")    (AND (NEQ STREAM 'NO)         (PRINTOUT STREAM "Index "))    (|if| (NEQ (GETBASEBYTE INDEX 1)               XQP::|unindexed.offset|)        |then| (AND (NEQ STREAM 'NO)                    (PRINTOUT STREAM "(argument is smashed) "))              (SETQ XQP::BOTCH T))    (|if| (OR (NEQ -65536 (GETBASEPTR INDEX XQP::|dynindex.born|))              (GETBASEPTR INDEX XQP::|dynindex.died|))        |then| (AND (NEQ STREAM 'NO)                    (PRINTOUT STREAM "(timestamp is smashed) "))              (SETQ XQP::BOTCH T))    (AND (NEQ STREAM 'NO)         (PRINTOUT STREAM T "    mask:  " (GETBASE INDEX XQP::|dynindex.mask|)                " population:  "                (GETBASE INDEX XQP::|dynindex.population|)                T))    (LET ((CLAUSES (XQP::CHECK.INDEXED PROC INDEX (GETBASEPTR INDEX XQP::|dynindex.first|)                          (GETBASE INDEX XQP::|dynindex.population|)                          NIL STREAM)))         (|if| (NEQ (GETBASEPTR INDEX XQP::|dynindex.list|)                    XQP::FAILURE.CLAUSE)             |then| (AND (NEQ STREAM 'NO)                         (PRINTOUT STREAM |,,,| "list case clauses:  "))                   (XQP::CHECK.SUBCHAIN PROC INDEX (GETBASEPTR INDEX XQP::|dynindex.list|)                          CLAUSES NIL STREAM)           |else| (AND (NEQ STREAM 'NO)                       (PRINTOUT STREAM |,,,| "no list case" T)))         (|bind| (TABLE _ (GETBASEPTR INDEX XQP::|dynindex.table|)) |for| I |from| 0            |to| (LLSH (GETBASE INDEX XQP::|dynindex.mask|)                       1) |by| 2 |do| (AND (NEQ STREAM 'NO)                                           (PRINTOUT STREAM XQP::|.I4| (LRSH I 1)                                                  ":"))                                      (XQP::CHECK.BUCKET PROC INDEX (GETBASEBYTE TABLE                                                                           (LLSH I 1))                                             (GETBASEPTR TABLE I)                                             CLAUSES STREAM)))))(XQP::CHECK.INDEXED  (LAMBDA (PROC INDEX CLAUSE XQP::POPULATION XQP::GUARDED? STREAM)                                                             (* XQP::|pds:| " 1-May-87 17:46")    (|bind| (CL _ CLAUSE)           (PREV _ (GETBASEPTR CLAUSE XQP::|clause.prev|))           (LST _ NIL)           (CNT _ 0) |do| (|add| CNT 1)                          (|push| LST (CONS CL CNT))                          (AND (NEQ STREAM 'NO)                               (PRINTOUT STREAM |,,,| XQP::|.I3| CNT ":  " CL \,))                          (|if| (NEQ PREV (GETBASEPTR CL XQP::|clause.prev|))                              |then| (AND (NEQ STREAM 'NO)                                          (PRINTOUT STREAM "(prev field is wrong)"))                                    (SETQ XQP::BOTCH T))                          (|if| (EQ (GETBASEBYTE CL XQP::|clause.instr|)                                    (CONSTANT (XQP::OP.CODE 'XQP::|dynamic.index|)))                              |then| (AND (NEQ STREAM 'NO)                                          (PRINTOUT STREAM "(index within an index)" T))                                    (SETQ XQP::BOTCH T)                            |elseif| (EQ (GETBASEBYTE CL XQP::|clause.instr|)                                         (CONSTANT (XQP::OP.CODE 'XQP::|interpret.me|)))                              |then| (XQP::CHECK.SINGLE PROC CL T STREAM)                            |else| (AND (NEQ STREAM 'NO)                                        (PRINTOUT STREAM "bogus instruction!" T))                                  (SETQ XQP::BOTCH T))                          (SETQ PREV CL) |repeatwhile| (AND (EQ (GETBASEBYTE CL                                                                        XQP::|clause.next.tagbyte|)                                                                0)                                                            (SETQ CL (GETBASEPTR CL                                                                             XQP::|clause.next|)))       |finally| (|if| (NEQ CL (GETBASEPTR CLAUSE XQP::|clause.prev|))                     |then| (AND (NEQ STREAM 'NO)                                 (PRINTOUT STREAM "prev of first does not point to last!" T))                           (SETQ XQP::BOTCH T))             (|if| (EQ (GETBASEBYTE CL XQP::|clause.next.tagbyte|)                       255)                 |then| (|if| (NEQ (GETBASEPTR CL XQP::|clause.next|)                                   INDEX)                            |then| (AND (NEQ STREAM 'NO)                                        (PRINTOUT STREAM "last clause does not point to index" T))                                  (SETQ XQP::BOTCH T))               |else| (AND (NEQ STREAM 'NO)                           (PRINTOUT STREAM "invalid tag on NEXT field!!!" (GETBASEBYTE CL                                                                            XQP::|clause.next.tagbyte|                                                                                  )                                  T))                     (SETQ XQP::BOTCH T))             (RETURN LST))))(XQP::CHECK.PROC  (LAMBDA (PROC XQP::QUIET?)                                 (* XQP::|pds:| "23-Apr-87 18:10")    (SETQ XQP::BOTCH NIL)    (|if| (AND (EQ (XQP::PROC.CLAUSES PROC)                   XQP::INTERPRET.CLAUSE)               (NOT (EQ (XQP::PROC.LASTCLAUSE PROC)                        XQP::FAILURE.CLAUSE)))        |then| (XQP::CHECK.UNINDEXED PROC (XQP::PROC.LASTCLAUSE PROC)                      (|if| XQP::QUIET?                          |then| 'NO                        |else| NIL)))    (NOT XQP::BOTCH)))(XQP::CHECK.SINGLE  (LAMBDA (PROC CLAUSE XQP::ININDEX? STREAM)                 (* XQP::|pds:| "13-May-87 15:56")    (|if| (NOT XQP::ININDEX?)        |then| (AND (NEQ STREAM 'NO)                    (PRINTOUT STREAM CLAUSE ":  ")))    (|if| (OR (NOT (TYPENAMEP (GETBASEPTR CLAUSE XQP::|clause.procedure|)                          'XQP::PROCEDURE.RECORD))              (AND PROC (NEQ PROC (GETBASEPTR CLAUSE XQP::|clause.procedure|))))        |then| (AND (NEQ STREAM 'NO)                    (PRINTOUT STREAM "(proc is wrong"))              (SETQ XQP::BOTCH T))    (|if| (OR (NOT (SMALLP (GETBASEPTR CLAUSE XQP::|clause.born|)))              (AND (GETBASEPTR CLAUSE XQP::|clause.died|)                   (NOT (SMALLP (GETBASEPTR CLAUSE XQP::|clause.died|)))))        |then| (AND (NEQ STREAM 'NO)                    (PRINTOUT STREAM "(timestamp is messed up)"))              (SETQ XQP::BOTCH T)      |elseif| (GETBASEPTR CLAUSE XQP::|clause.died|)        |then| (AND (NEQ STREAM 'NO)                    (PRINTOUT STREAM "dead ")))    (|if| (OR (NEQ (GETBASE CLAUSE XQP::|clause.instr|)                   (CONSTANT (XQP::HI.CODE 'XQP::|interpret.me| XQP::|unindexed.offset|)))              (NEQ (GETBASE CLAUSE XQP::|clause.indexed.instr|)                   (CONSTANT (XQP::HI.CODE 'XQP::|interpret.me| XQP::|indexed.offset|))))        |then| (AND (NEQ STREAM 'NO)                    (PRINTOUT STREAM "(instruction is messed up)"))              (SETQ XQP::BOTCH T))    (AND (NEQ STREAM 'NO)         (TERPRI STREAM))))(XQP::CHECK.SUBCHAIN  (LAMBDA (PROC INDEX SUBITEM ALST XQP::GUARDED? STREAM)     (* XQP::|pds:| " 5-May-87 18:29")    (|bind| XQP::SUBI XQP::KEYHIGH XQP::KEYLOW PREV NUMBER       |first| (|if| XQP::GUARDED?                   |then| (SETQ XQP::SUBI (ADDBASE SUBITEM XQP::|guardedsubitem.subitem|))                         (SETQ XQP::KEYHIGH (GETBASE SUBITEM XQP::|guardedsubitem.key|))                         (SETQ XQP::KEYLOW (GETBASE SUBITEM XQP::|guardedsubitem.key.low|))                         (|if| (EQ XQP::KEYHIGH XQP::|symbol.tag.16|)                             |then| (AND (NEQ STREAM 'NO)                                         (PRINTOUT STREAM (\\VAG2 0 XQP::KEYLOW)))                                   (|if| (NEQ 0 (LOGAND XQP::KEYHIGH 255))                                       |then| (AND (NEQ STREAM 'NO)                                                   (PRINTOUT STREAM "/" (LOGAND XQP::KEYHIGH 255))))                           |else| (AND (NEQ STREAM 'NO)                                       (PRINTOUT STREAM (GETBASEPTR SUBITEM 0))))                         (AND (NEQ STREAM 'NO)                              (PRINTOUT STREAM ": "))                 |else| (SETQ XQP::SUBI SUBITEM)                       (SETQ XQP::KEYHIGH (GETBASE SUBITEM XQP::|subitem.key|)))             (SETQ PREV (GETBASEPTR XQP::SUBI XQP::|subitem.prev|))       |do| (SETQ NUMBER (CDR (ASSOC (ADDBASE XQP::SUBI (CONSTANT (MINUS XQP::|clause.subitem|)))                                     ALST)))            (|if| NUMBER                |then| (AND (NEQ STREAM 'NO)                            (PRINTOUT STREAM \, NUMBER))              |else| (AND (NEQ STREAM 'NO)                          (PRINTOUT STREAM " (clause not in this index)"))                    (SETQ XQP::BOTCH T))            (|if| (NEQ (GETBASE XQP::SUBI XQP::|subitem.instr|)                       (CONSTANT (XQP::HI.CODE 'XQP::|interpret.me| XQP::|indexed.offset|)))                |then| (AND (NEQ STREAM 'NO)                            (PRINTOUT STREAM "_(instr is wrong)"))                      (SETQ XQP::BOTCH T))            (|if| (NEQ PREV (GETBASEPTR XQP::SUBI XQP::|subitem.prev|))                |then| (AND (NEQ STREAM 'NO)                            (PRINTOUT STREAM "_(prev is wrong)"))                      (SETQ XQP::BOTCH T))            (|if| (|if| XQP::GUARDED?                      |then| (OR (NEQ XQP::KEYHIGH (GETBASE XQP::SUBI XQP::|subitem.key|))                                 (NEQ XQP::KEYLOW (GETBASE XQP::SUBI XQP::|subitem.key.low|)))                    |else| (NEQ XQP::|list.tag.16| XQP::KEYHIGH))                |then| (AND (NEQ STREAM 'NO)                            (PRINTOUT STREAM "_(key is wrong)"))                      (SETQ XQP::BOTCH T))            (SETQ PREV XQP::SUBI) |repeatwhile| (AND (EQ 0 (GETBASEBYTE XQP::SUBI                                                                   XQP::|subitem.next.tagbyte|))                                                     (SETQ XQP::SUBI (GETBASEPTR XQP::SUBI                                                                             XQP::|subitem.next|)))       |finally| (|if| (NEQ XQP::SUBI (GETBASEPTR (|if| XQP::GUARDED?                                                      |then| (ADDBASE SUBITEM                                                                     XQP::|guardedsubitem.subitem|)                                                    |else| SUBITEM)                                             XQP::|subitem.prev|))                     |then| (AND (NEQ STREAM 'NO)                                 (PRINTOUT STREAM " (prev of first does not point to last!)"))                           (SETQ XQP::BOTCH T))             (|if| (EQ (GETBASEBYTE XQP::SUBI XQP::|subitem.next.tagbyte|)                       255)                 |then| (|if| (NEQ (GETBASEPTR XQP::SUBI XQP::|subitem.next|)                                   INDEX)                            |then| (AND (NEQ STREAM 'NO)                                        (PRINTOUT STREAM " (last clause does not point to index)"))                                  (SETQ XQP::BOTCH T))               |else| (AND (NEQ STREAM 'NO)                           (PRINTOUT STREAM " (invalid tag on NEXT field: " (GETBASEBYTE XQP::SUBI                                                                           XQP::|subitem.next.tagbyte|                                                                                   )                                  ")"))                     (SETQ XQP::BOTCH T))             (AND (NEQ STREAM 'NO)                  (TERPRI STREAM)))))(XQP::CHECK.UNINDEXED  (LAMBDA (PROC SUBITEM STREAM)                              (* XQP::|pds:| " 1-May-87 18:07")    (|bind| (XQP::SUBI _ SUBITEM)           (PREV _ (GETBASEPTR SUBITEM XQP::|subitem.prev|))       |do| (AND (NEQ STREAM 'NO)                 (PRINTOUT STREAM XQP::SUBI ":  "))            (|if| (NEQ PREV (GETBASEPTR XQP::SUBI XQP::|subitem.prev|))                |then| (AND (NEQ STREAM 'NO)                            (PRINTOUT STREAM "(prev field is wrong)"))                      (SETQ XQP::BOTCH T))            (|if| (EQ (GETBASE XQP::SUBI XQP::|subitem.instr|)                      (CONSTANT (XQP::HI.CODE 'XQP::|dynamic.index| XQP::|unindexed.offset|)))                |then| (XQP::CHECK.INDEX PROC XQP::SUBI STREAM)              |elseif| (EQ (GETBASE XQP::SUBI XQP::|subitem.instr|)                           (CONSTANT (XQP::HI.CODE 'XQP::|interpret.me| XQP::|unindexed.offset|)))                |then| (XQP::CHECK.SINGLE PROC XQP::SUBI NIL STREAM)              |else| (AND (NEQ STREAM 'NO)                          (PRINTOUT STREAM "bogus instruction!" T))                    (SETQ XQP::BOTCH T))            (SETQ PREV XQP::SUBI) |repeatwhile| (AND (EQ (GETBASEBYTE XQP::SUBI                                                                 XQP::|subitem.next.tagbyte|)                                                         0)                                                     (SETQ XQP::SUBI (GETBASEPTR XQP::SUBI                                                                             XQP::|subitem.next|)))       |finally| (|if| (NEQ XQP::SUBI (GETBASEPTR SUBITEM XQP::|subitem.prev|))                     |then| (AND (NEQ STREAM 'NO)                                 (PRINTOUT STREAM "prev of first does not point to last!" T))                           (SETQ XQP::BOTCH T))             (|if| (EQ (GETBASEBYTE XQP::SUBI XQP::|subitem.next.tagbyte|)                       127)                 |then| (|if| (NEQ SUBITEM (GETBASEPTR XQP::SUBI XQP::|subitem.next|))                            |then| (AND (NEQ STREAM 'NO)                                        (PRINTOUT STREAM "dead last clause does not point to first" T                                               ))                                  (SETQ XQP::BOTCH T)                          |else| (AND (NEQ STREAM 'NO)                                      (PRINTOUT STREAM "procedure is abolished" T)))               |elseif| (EQ (GETBASEBYTE XQP::SUBI XQP::|subitem.next.tagbyte|)                            255)                 |then| (|if| (NEQ (GETBASEPTR XQP::SUBI XQP::|subitem.next|)                                   PROC)                            |then| (AND (NEQ STREAM 'NO)                                        (PRINTOUT STREAM "last clause does not point to PROC" T))                                  (SETQ XQP::BOTCH T))               |else| (AND (NEQ STREAM 'NO)                           (PRINTOUT STREAM "invalid tag on NEXT field!!!" (GETBASEBYTE XQP::SUBI                                                                           XQP::|subitem.next.tagbyte|                                                                                  )                                  T))                     (SETQ XQP::BOTCH T))))))(DECLARE\: DOEVAL@COMPILE DONTCOPY(GLOBALVARS XQP::BOTCH))(PUTPROPS DYNASSERT COPYRIGHT ("Quintus Computer Systems, Inc" 1987))(DECLARE\: DONTCOPY  (FILEMAP (NIL (2857 24590 (XQP::DYN.CREATE.AND.INIT.INDEX 2867 . 4669) (XQP::DYN.INSERT.IN.INDEX 4671 . 8252) (XQP::DYN.FIND.SUBCHAIN 8254 . 10287) (XQP::APPEND.TO.SUBCHAIN 10289 . 14098) (XQP::DYN.INCREASE.POPULATION 14100 . 20271) (XQP::DYN.INSERT.IN.BUCKET 20273 . 24588)) (24636 27570 (XQP::CLEAN.UP.CLAUSES 24646 . 25144) (XQP::MAYBE.CLEAN.UP 25146 . 25749) (XQP::PERHAPS.CLEAN.UP 25751 . 26731) (XQP::REALLY.CLEAN.UP 26733 . 27568)) (27571 61869 (XQP::COLLECT.CLAUSE.CHAIN 27581 . 31345) (XQP::COLLECT.CLAUSES 31347 . 32205) (XQP::DISPOSE.CLAUSE 32207 . 34820) (XQP::EMPTY.OUT.CLAUSE 34822 . 35525) (XQP::INDEX.BUCKET 35527 . 36299) (XQP::INDEX.CORRECT.LINK 36301 . 38558) (XQP::PUT.CLAUSE.ON.DEAD.CHAIN 38560 . 40253) (XQP::RECLAIM.UNATTACHED.CLAUSE 40255 . 41158) (XQP::REMOVE.FROM.INDEX 41160 . 49579) (XQP::TABLE.BUCKET 49581 . 50035) (XQP::TRAVERSE.DEAD.CHAIN 50037 . 52204) (XQP::TRAVERSE.STACK 52206 . 54891) (XQP::UNLINK.INDEXED.CLAUSE 54893 . 58124) (XQP::UNLINK.NONINDEXED.CLAUSE 58126 . 61867)) (63810 81003 (XQP::CLEAN 63820 . 64044) (XQP::CHECK.BUCKET 64046 . 65162) (XQP::CHECK.INDEX 65164 . 67411) (XQP::CHECK.INDEXED 67413 . 70640) (XQP::CHECK.PROC 70642 . 71208) (XQP::CHECK.SINGLE 71210 . 72801) (XQP::CHECK.SUBCHAIN 72803 . 77605) (XQP::CHECK.UNINDEXED 77607 . 81001)))))STOP