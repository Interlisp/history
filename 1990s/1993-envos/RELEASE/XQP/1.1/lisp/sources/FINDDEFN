(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(filecreated "24-Nov-87 18:34:50" {core}finddefn.\;1 26007        |changes| |to:|  (fns xqp::find.definition.part.two xqp::locate.predicate.for.fd                             xqp::find.more.definition xqp::find.definition)      |previous| |date:| "20-Nov-87 13:16:39" {dsk}<lispfiles>dcoms>finddefn.\;2); Copyright (c) 1986, 1987 by Quintus Computer Systems, Inc.  All rights reserved.(prettycomprint finddefncoms)(rpaqq finddefncoms (                                        (* \;             "WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.")                                         (* |;;| "Find-definition: Pre-Prolog call stage --- gather the predicate name and arity from the cursor position and a user prompt.")                     (fns xqp::get.cursor)                     (macros xqp::valid.upper.case.char xqp::char.is.white.space)                     (fns xqp::skip.white.space)                     (macros xqp::skip.over.char.in.pred.head)                     (fns xqp::find.pred.beginning)                     (macros xqp::name.includes.arity)                     (fns xqp::get.name.arity.default)                     (macros xqp::convert.name.arity.to.name)                     (fns xqp::remove.spaces)                     (macros xqp::get.user.name.arity)                     (macros xqp::get.user.name.arity.no.default)                     (fns xqp::get.name.from.string)                     (fns xqp::get.arity.from.string)                     (fns xqp::find.definition)                                         (* |;;| "Find-definition: Post-Prolog call stage: display the file that the predicate was defined in and show the definition.")                                         (* |;;| "Note that the global variable FIND.DEFINITION.SOURCE.FILES holds the list of files to be visited for the predicate definitions for find.definition.part.two.  It is declared global in the file TELLEDITOR.LSP")                     (fns xqp::find.definition.part.two)                     (fns xqp::locate.predicate.for.fd)                     (macros xqp::fd.get.filename)                                         (* |;;| "fd-get-filename takes the filenames off the top/front of the list and then removes the filename from the list.  The original file insertion mechanism in &fd-insert inserts the file names at the bottom/end of the list.  FD.FILE adds filenames to the end of the list stored in FIND.DEFINITION.SOURCE.FILES")                     (fns xqp::find.more.definition)                     (fns xqp::locate.definition)                     (prop makefile-environment)))(* \; "WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.")(* |;;| "Find-definition: Pre-Prolog call stage --- gather the predicate name and arity from the cursor position and a user prompt.")(defineq(XQP::GET.CURSOR  (LAMBDA (STREAM)                                           (* XQP::|pds:| "20-Jan-86 11:07")    (LET ((SEL (TEDIT.GETSEL STREAM)))         (SELECTQ (|fetch| (SELECTION POINT) |of| SEL)             (LEFT (|fetch| (SELECTION CH#) |of| SEL))             (RIGHT (IDIFFERENCE (|fetch| (SELECTION CHLIM) |of| SEL)                           1))             (|fetch| (SELECTION CH#) |of| SEL))))))(declare\: eval@compile (putprops xqp::valid.upper.case.char macro (xqp::**macroarg**                                            (let ((char (car (nth xqp::**macroarg** 1))))                                                 `(progn (and (igeq ,char (charcode a))                                                              (ileq ,char (charcode z)))))))(putprops xqp::char.is.white.space macro (xqp::**macroarg**                                          (let ((char (car (nth xqp::**macroarg** 1))))                                               `(progn (or (eq ,char (charcode space))                                                           (eq ,char (charcode tab))                                                           (eq ,char (charcode eol))))))))(defineq(XQP::SKIP.WHITE.SPACE  (LAMBDA (STREAM)                    (* |This| XQP::|routine| |will| |return| |either| |the| |next|           XQP::|non-white-space| |character,| |or| XQP::|nil| |if| |it| |found| |the| EOF           XQP::|first.|)    (LET ((CHAR (XQP::GET.NEXT.CHAR STREAM)))         (|while| (AND (NOT (NULL CHAR))                       (XQP::CHAR.IS.WHITE.SPACE CHAR)) |do| (SETQ CHAR (XQP::GET.NEXT.CHAR STREAM)))         (\\BACKBIN STREAM)         CHAR))))(declare\: eval@compile (putprops xqp::skip.over.char.in.pred.head macro ((char)                                                  (or (eq char (charcode space))                                                      (eq char (charcode tab))                                                      (eq char (charcode eol))                                                      (eq char 44)                                                      (eq char (charcode \;))                                                      (eq char (charcode \())                                                      (eq char (charcode >))                                                      (eq char (charcode [))                                                      (eq char (charcode {))))))(defineq(XQP::FIND.PRED.BEGINNING  (LAMBDA (STREAM)                                           (* \; "Edited 30-Sep-87 15:31 by pds")                                                             (* \;                                              "1st make sure the file pointer is where the cursor is:")    (\\SETUPGETCH (XQP::GET.CURSOR STREAM)           (TEXTOBJ STREAM))    (LET ((CHAR (XQP::GET.NEXT.CHAR STREAM)))         (SELCHARQ CHAR              (NIL NIL)              (* \; "No character")              ((SPACE TAB EOL)                               (* \;                                                              "The routine started in white-space")                   (LET ((CHAR (XQP::SKIP.WHITE.SPACE STREAM)))                                                             (* \;                                                              "not at EOF, not at EOL, not a variable")                        (AND (NOT (NULL CHAR))                             (NOT (EQ CHAR (CHARCODE EOL)))                             (NOT (XQP::VALID.UPPER.CASE.CHAR CHAR)))))              (LET ((POSITION (\\TEXTGETFILEPTR STREAM))                    (XQP::BACKMODE NIL))                   (|while| (AND (NEQ POSITION 0)                                 (NOT (XQP::SKIP.OVER.CHAR.IN.PRED.HEAD CHAR)))                      |do| (SETQ CHAR (\\BACKBIN STREAM))                           (SETQ POSITION (SUB1 POSITION))                           (SETQ XQP::BACKMODE T))                   (|if| (XQP::SKIP.OVER.CHAR.IN.PRED.HEAD CHAR)                       |then| (|if| XQP::BACKMODE                                  |then| (\\BIN STREAM)      (* \; "Now at first valid character"))                             (SETQ CHAR (\\BIN STREAM))                             (\\BACKBIN STREAM))                   (|if| (NOT (XQP::VALID.UPPER.CASE.CHAR CHAR))                       |then| T)))))))(declare\: eval@compile (putprops xqp::name.includes.arity macro (xqp::**macroarg** (let ((name (car (nth xqp::**macroarg** 1                                                                                  ))))                                                                 `(progn (memb (charcode /)                                                                               ,name))))))(defineq(XQP::GET.NAME.ARITY.DEFAULT  (LAMBDA (STREAM)                                           (* \; "Edited 30-Sep-87 15:32 by pds")                    (* |;;| "This returns a list consisting of the character codes that represent the predicate name followed by the character code for a '/' followed by the arity number (not character code)")    (LET     ((CHAR (XQP::GET.NEXT.CHAR STREAM)))                    (* \; "see FINDPRED.LSP for source")     (|if| (NEQ CHAR (CHARCODE EOL))         |then|                                              (* \; "a default value was attempted")         (LET ((XQP::FND.FLAG (XQP::FIND.PRED.BEGINNING STREAM))               (XQP::ORI.POSITION (ADD1 (\\TEXTGETFILEPTR STREAM))))              (|if| XQP::FND.FLAG                  |then|                                     (* \; "now at the beginning of the name")                                                             (* \;                                                        "see FINDPRED.LSP for source of GET.PRED.NAME")                        (LET* ((XQP::P.NAME (XQP::GET.PRED.NAME STREAM))                               (XQP::ARITY.LIST (XQP::NAME.INCLUDES.ARITY XQP::P.NAME)))                              (|if| (NOT XQP::ARITY.LIST)                                  |then| (\\BACKBIN STREAM)                                        (LET ((XQP::P.ARITY (XQP::FIND.ARITY.AUX STREAM (TEXTOBJ                                                                                         STREAM)                                                                   XQP::ORI.POSITION)))                                             (|if| (AND XQP::P.NAME XQP::P.ARITY)                                                 |then| (APPEND XQP::P.NAME (LIST (CHARCODE /)                                                                                  XQP::P.ARITY))))                                |else|                       (* \;                                                             "P.NAME includes arity but as char codes")                                                             (* \; "convert the arity char codes")                                      (APPEND (CAR (LASTN XQP::P.NAME (SUB1 (LENGTH XQP::ARITY.LIST))                                                          ))                                             (LIST (PACKC (CDR XQP::ARITY.LIST)))))))))))))(declare\: eval@compile (putprops xqp::convert.name.arity.to.name macro       (xqp::**macroarg** (let ((xqp::name.arity (car (nth xqp::**macroarg** 1))))                               `(progn (packc (car (lastn ,xqp::name.arity 2))))))))(defineq(XQP::REMOVE.SPACES  (LAMBDA (STRING)                    (* |This| XQP::|trick| |taken| |from| TEDIT |source| |file| TEDITWINDOW           XQP::I\t XQP::|removes| |the| |leading| |and| XQP::|trailing| XQP::|blanks|)    (LET ((FIRSTNONSPACE (STRPOSL '(\ ) STRING NIL T))          (LASTNONSPACE (STRPOSL '(\ ) STRING NIL T T)))         (|if| (AND FIRSTNONSPACE LASTNONSPACE)             |then| (SUBSTRING STRING FIRSTNONSPACE LASTNONSPACE)           |else| STRING)))))(declare\: eval@compile (putprops xqp::get.user.name.arity macro (xqp::**macroarg**                                          (let ((name (car (nth xqp::**macroarg** 1)))                                                (xqp::arity (car (nth xqp::**macroarg** 2))))                                               `(xqp::remove.spaces (tedit.getinput                                                                     (textobj stream)                                                                     "name/arity = "                                                                     (concat ,name "/" ,xqp::arity)))                                               ))))(declare\: eval@compile (putprops xqp::get.user.name.arity.no.default macro (xqp::**macroarg**                                                     (let nil `(xqp::remove.spaces                                                                (tedit.getinput (textobj stream)                                                                       "name/arity = "))))))(defineq(XQP::GET.NAME.FROM.STRING  (LAMBDA (STRING)    (LET ((XQP::SLASH.POSITION (STRPOS "/" STRING 1)))         (SELECTQ XQP::SLASH.POSITION             (1 "no_name")             (NIL STRING)             (SUBSTRING STRING 1 (SUB1 XQP::SLASH.POSITION)))))))(defineq(XQP::GET.ARITY.FROM.STRING  (LAMBDA (STRING)    (LET ((XQP::SLASH.POSITION (STRPOS "/" STRING 1))          (XQP::STRING.LENGTH (NCHARS STRING)))         (|if| (OR (NOT XQP::SLASH.POSITION)                   (EQ XQP::SLASH.POSITION XQP::STRING.LENGTH))             |then| "No_arity"           |else| (PACK (UNPACK (SUBSTRING STRING (ADD1 XQP::SLASH.POSITION)                                       (NCHARS STRING)))))))))(defineq(xqp::find.definition  (lambda (stream)                                           (* \; "Edited 24-Nov-87 15:40 by pds")    (setq xqp::fd.ori.stream stream)    (clearw (|fetch| (textobj promptwindow) |of| (textobj stream)))    (xqp::clear.fd.buffer)    (|if| (prolog.is.ready)        |then| (let ((xqp::default.name.arity (xqp::get.name.arity.default stream))                     (abort nil)                     xqp::user.input xqp::p.name xqp::p.arity)                    (|if| xqp::default.name.arity                        |then|                               (* \; "a default was found")                              (setq xqp::p.arity (car (last xqp::default.name.arity)))                              (setq xqp::p.name (xqp::convert.name.arity.to.name                                                        xqp::default.name.arity))                              (setq xqp::user.input (xqp::get.user.name.arity xqp::p.name                                                            xqp::p.arity))                      |else|                                 (* \; "no default was found")                            (setq xqp::user.input (xqp::get.user.name.arity.no.default)))                    (|if| (not (equal xqp::user.input "NIL"))                        |then|                               (* \; "process any user input")                                                             (* \; "There was user input")                              (setq xqp::p.name (xqp::get.name.from.string xqp::user.input))                              (setq xqp::p.arity (xqp::get.arity.from.string xqp::user.input))                      |else|                                 (* \; "There was no user input")                            (|if| (not xqp::default.name.arity)                                |then| (setq abort t)))                    (clearw (|fetch| (textobj promptwindow) |of| (textobj stream)))                    (|if| (not abort)                        |then| (tedit.promptprint stream " finding definition ..." t)                              (prolog 'xqp::|find_predicate1| (list (cl:intern xqp::p.name "XQP")                                                                    xqp::p.arity))                      |else| (tedit.promptprint stream " find-definition canceled" t)))      |else| (tedit.promptprint stream                     "cannot use find-definition unless Prolog is not running, or is at top-level" t))    )))(* |;;| "Find-definition: Post-Prolog call stage: display the file that the predicate was defined in and show the definition.")(* |;;| "Note that the global variable FIND.DEFINITION.SOURCE.FILES holds the list of files to be visited for the predicate definitions for find.definition.part.two.  It is declared global in the file TELLEDITOR.LSP")(defineq(xqp::find.definition.part.two  (lambda (data)                                             (* \; "Edited 24-Nov-87 17:49 by pds")    (let*     ((status (car (|fetch| (prolog.term prolog.args) |of| data)))      (xqp::calledfrom (cadr (|fetch| (prolog.term prolog.args) |of| data)))      (xqp::msgstream (selectq xqp::calledfrom                          (xqp::|ed| xqp::fd.ori.stream)                          (xqp::|debug| (textstream xqp::prolog.window.handle))                          (shouldnt))))     (selectq status         (|ok| (|if| xqp::find.definition.source.files                   |then| (|bind| filename pred name xqp::arity xqp::working.stream |for| term                             |in| xqp::find.definition.source.files                             |do| (setq filename (cadr (|fetch| (prolog.term prolog.args)                                                          |of| term)))                                  (setq pred (car (|fetch| (prolog.term prolog.args) |of| term)))                                  (setq name (car (|fetch| (prolog.term prolog.args) |of| pred)))                                  (setq xqp::arity (cadr (|fetch| (prolog.term prolog.args)                                                            |of| pred)))                                  (tedit.promptprint xqp::msgstream (concat name "/" xqp::arity                                                                            " found")                                         t)                                  (setq xqp::working.stream (xqp::qp.textstream filename))                                  (|if| (not xqp::working.stream)                                      |then|                 (* \; "no open stream.")                                            (xqp::find.more.definition                                             (textstream (tedit filename nil nil '(xqp::tedit.mode                                                                                   xqp::|Prolog|)))                                             name xqp::arity xqp::calledfrom (concat "/" xqp::arity))                                    |elseif| (not (xqp::tedit.window filename))                                      |then| (tedit.promptprint xqp::msgstream                                                    (concat name "/" xqp::arity " has been lost")                                                    t)                                    |else| (promptprint "   Revisiting: " filename)                                          (xqp::find.more.definition xqp::working.stream name                                                  xqp::arity xqp::calledfrom (concat "/" xqp::arity)))                                 )                 |else| (tedit.promptprint xqp::msgstream (concat name "/" xqp::arity " not found")                               t)))         (xqp::|built_in|               (tedit.promptprint xqp::msgstream (concat xqp::find.definition.bad.pred                                                        " is a built-in predicate")                     t))         (|none| (tedit.promptprint xqp::msgstream (concat "no file associated with "                                                           xqp::find.definition.bad.pred)                        t))         (|undefined| (tedit.promptprint xqp::msgstream (concat xqp::find.definition.bad.pred                                                                " is undefined")                             t))         (tedit.promptprint xqp::msgstream (concat "find definition error = " status)                t))     (|if| (eq xqp::calledfrom 'xqp::|ed|)         |then| (tty.process (windowprop (xqp::tedit.window xqp::fd.ori.stream)                                    'process))       |else| (tty.process (find.process xqp::prolog.name)))))))(defineq(xqp::locate.predicate.for.fd  (lambda (name xqp::arity status xqp::calledfrom xqp::working.stream)                                                             (* \; "Edited 24-Nov-87 13:41 by pds")    (let ((xqp::fd.slash.arity (|if| (equal xqp::arity '_)                                   |then| ""                                 |else| (concat "/" xqp::arity))))         (clearw (|fetch| (textobj promptwindow) |of| (textobj xqp::working.stream)))         (|if| (eq 'xqp::|built_in| status)             |then| (tedit.promptprint xqp::working.stream (concat name xqp::fd.slash.arity                                                                   " is a built-in predicate")                           t)           |elseif| (eq '|undefined| status)             |then| (tedit.promptprint xqp::working.stream (concat name xqp::fd.slash.arity                                                                   " is undefined")                           t)           |elseif| (eq '|none| status)             |then| (tedit.promptprint xqp::working.stream (concat "no file associated with " name                                                                   xqp::fd.slash.arity)                           t)           |elseif| (eq '|ok| status)             |then| (|if| (equal name "")                        |then|                               (* \; "No Pred Name")                              (tedit.promptprint xqp::working.stream                                      "you must use find-definition first" t)                      |else| (xqp::find.more.definition xqp::working.stream name xqp::arity                                     xqp::calledfrom xqp::fd.slash.arity))           |else| (tedit.promptprint xqp::working.stream (concat "find definition error = " status)                         t))                                 (* \;                               "Last transfer control to the editor window if calling from the editor")         (|if| xqp::fd.ori.stream             |then| (tedit.promptprint xqp::fd.ori.stream " " t)                   (setq xqp::fd.ori.stream nil))         (|if| (eq xqp::calledfrom 'xqp::|ed|)             |then| (tty.process (windowprop (xqp::tedit.window xqp::working.stream)                                        'process))           |else| (tty.process (find.process xqp::prolog.name)))))))(declare\: eval@compile (putprops xqp::fd.get.filename macro (nil (|pop| xqp::find.definition.source.files))))(* |;;| "fd-get-filename takes the filenames off the top/front of the list and then removes the filename from the list.  The original file insertion mechanism in &fd-insert inserts the file names at the bottom/end of the list.  FD.FILE adds filenames to the end of the list stored in FIND.DEFINITION.SOURCE.FILES")(defineq(xqp::find.more.definition  (lambda (stream name xqp::arity environment xqp::fd.slash.arity)                                                             (* \; "Edited 24-Nov-87 13:31 by pds")    (let ((xqp::fd.file.name (xqp::fd.get.filename)))         (|if| (not xqp::fd.file.name)             |then|                                          (* \; "filename is a null string")                   (setq xqp::find.definition.source.files nil)                   (tedit.promptprint stream (concat "no more source files for " name                                                     xqp::fd.slash.arity)                          t)           |elseif| (equal "user" xqp::fd.file.name)             |then| (tedit.promptprint stream (concat name xqp::fd.slash.arity                                                      "was defined from user"                                                     (|if| xqp::find.definition.source.files                                                         |then| " - type \"^X,\" for more"                                                       |else| ""))                           t)           |else|                                            (* \; "we must have a valid filename")                                                             (* \;                                              "need an if statement on the environment = 'debug' case")                 (xqp::locate.definition stream name xqp::arity))))))(defineq(XQP::LOCATE.DEFINITION  (LAMBDA (STREAM NAME XQP::ARITY)    (LET ((STOP NIL)          (TEXT (TEXTOBJ STREAM))          (START 1)          (POS (TEDIT.FIND STREAM NAME 1)))         (|while| (AND POS (NOT STOP))            |do| (|if| POS                     |then| (\\SETUPGETCH POS TEXT)                           (|if| (EQ (XQP::FIND.ARITY STREAM NAME)                                     XQP::ARITY)                               |then| (SETQ STOP T)                             |else| (SETQ START (ADD1 POS))                                   (SETQ POS (TEDIT.FIND STREAM (CONCAT (CHARACTER (CHARCODE CR))                                                                       NAME)                                                    START))                                   (|if| POS                                       |then| (SETQ POS (ADD1 POS)))                                                              (* XQP::|skip| |the| CR))                   |else| (SETQ STOP T)))         (|if| POS             |then|                                          (* |found| |it|)                   (LET ((SELECTION (TEDIT.SETSEL STREAM POS 1 'LEFT)))                        (TEDIT.NORMALIZECARET TEXT SELECTION)                        (TEDIT.SETSEL STREAM SELECTION))           |else| (TEDIT.PROMPTPRINT STREAM (CONCAT "cannot find " NAME "/" XQP::ARITY)                         T))))))(putprops finddefn copyright ("Quintus Computer Systems, Inc" 1986 1987))(declare\: dontcopy  (filemap (nil (3019 3488 (xqp::get.cursor 3029 . 3486)) (4259 4772 (xqp::skip.white.space 4269 . 4770)) (5553 7547 (xqp::find.pred.beginning 5563 . 7545)) (7946 10438 (xqp::get.name.arity.default 7956 . 10436)) (10681 11192 (xqp::remove.spaces 10691 . 11190)) (12239 12511 (xqp::get.name.from.string 12249 . 12509)) (12512 12967 (xqp::get.arity.from.string 12522 . 12965)) (12968 15572 (xqp::find.definition 12978 . 15570)) (15939 19933 (xqp::find.definition.part.two 15949 . 19931)) (19934 22439 (xqp::locate.predicate.for.fd 19944 . 22437)) (22878 24423 (xqp::find.more.definition 22888 . 24421)) (24424 25910 (xqp::locate.definition 24434 . 25908)))))stop