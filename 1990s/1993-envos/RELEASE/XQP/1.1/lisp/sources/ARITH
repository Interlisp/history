(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(FILECREATED "25-Jun-87 18:50:49" {ERIS}<PROLOGCORE>LYRIC>LISP>ARITH.\;5 37618        |previous| |date:| "22-Jun-87 14:29:38" {ERIS}<PROLOGCORE>LYRIC>LISP>ARITH.\;4); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(PRETTYCOMPRINT ARITHCOMS)(RPAQQ ARITHCOMS ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>ARITH.LSP;2, loaded 22-Jun-87 13:48:25")                                      (* |;;| "SCCS   : @(#)ARITH.LSP	8204.1 3/24/87 File   : $xerox/arith.lsp Author : Richard A. O'Keefe Purpose: Define the arithmetic instructions.")                  (* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")                  (* |;;;| "------------------------------------------------------------------------  The D-machine version of the arithmetic instructions differs from the VAX and Sun emulators.  Instead of holding unboxed numbers, T0 and T1 hold ordinary Lisp pointers to SMALLPs, FIXPs, FLOATPs, or whatever.  There are several reasons for this.  One is that it is easiest to do it this way.  Another important one is that in Koto BIGNUMS were added to InterLisp, so that the two-fold distinction which that VAX and Sun emulators assume will not be adequate.  As a consequence of this change, there is no distinction between the two modes here as there is in the VAX/Sun versions: we always stay in whatever mode we happened to be in when we started.  A difference between the Lisp emulator and the existing emulators is the way that division by zero is handled.  The existing emulators check for zero and simply fail.  Arithmetic overflow is handling by taking whatever the hardware gives you for integers, and infinities for floating point numbers.  Allowing infinities was a glaringly stupid mistake, we cannot possibly make that work on the VAX nor on the 1108, and we may change the SUN version to trap floating point overflows as well.  The Koto version of Lisp supports bignums, so integer overflow isn't a problem.  But we want to do something sensible with floating pointer overflow and all kinds of integer division as well, so we run with ")                  (P (OVERFLOW T))                  (* |;;;| "  enabled.  Floating overflow is supposed to be caught; for some reason zero divide is slipping through.")                                      (* |;;| "(raw.float) Takes the floating point number in T0 and turns it into a FIXP with the same bits.  T0 is first floated, if necessary. ASSUMPTION: floats are 32 bits exactly.")                  (INSTRUCTIONS XQP::|raw.float|)                                      (* |;;| "(float) ensures that T0 is a floating point number.")                  (INSTRUCTIONS XQP::|float|)                                      (* |;;| "(fix) ensures that T0 is a fixed point number. Pre-Koto this could cause an overflow trap.  Now it can't.")                  (INSTRUCTIONS |fix|)                                      (* |;;| "(minus) negates a number.")                  (INSTRUCTIONS XQP::|minus|)                                      (* |;;| "(boolean.not) takes the complement of an integer.")                  (INSTRUCTIONS XQP::|boolean.not|)                                      (* |;;| "All the two-argument arithmetic operations follow a common pattern. They just apply a Lisp function to T0 and T1, and put the result in T0.  So, to save my effort, they are defined via a definer.")                  (FUNCTIONS XQP::|def.binop|)                  (INSTRUCTIONS |add| XQP::|subtract| |multiply| XQP::|divide| XQP::|integer.divide|                          XQP::|modulus| XQP::|boolean.and| XQP::|boolean.or| XQP::|boolean.xor|                          XQP::|left.shift|)                                                             (* \; "*NOT* LLSH")                  (INSTRUCTIONS |right.shift|)                                                             (* \; "*NOT* LRSH")                                      (* |;;| "There are two versions of each arithmetic relation. (foo) succeeds if the relation holds, fails otherwise. (foo.else L) falls through if the relation holds, or jumps to L if the relation fails to hold.  For convenience, the jump instructions are like other jumps, [opcode:8|addr:24] and the other ones are [extend:8|opcode:8].  As a matter of fact, these instructions can only appear at the end of a block of arithmetic instructions, so if we arranged for load instructions to set read mode, we could double up the other arithmetic instructions, particularly the jumps and stores.")                  (FUNCTIONS XQP::|def.relop|)                  (INSTRUCTIONS XQP::|equal.to| XQP::|less.than| XQP::|greater.than|)                                      (* |;;| "(store.variable.Xn n) stores the number in T0 in the previously uninitialised variable Xn. We set the tag of T0, but it is safe to continue in arithmetic mode, because the arithmetic operations ignore that tag.  The different versions of store.variable used to take up 13% of the time of the naive reverse benchmark running interpreted; the very hairy code we have here now is an attempt to reduce this.  The original code tested the type of T0 three times; this does it once.  Note that we have to use the equivalent of tag.other here, because thanks to improved choice point code, T0 might be a Prolog choice point handle. I am sorry to include the calls to ADD.REF in what should have been pure code to calculate the tag, but console yourself with the thought that logically it is an identity function.")                  (PROPERTIES |tag|)                  (FUNCTIONS XQP::|store.variable|)                  (INSTRUCTIONS XQP::|store.variable.Xn|)                                      (* |;;| "(store.variable.XnM n) is for the X registers stored in memory.")                  (INSTRUCTIONS XQP::|store.variable.XnM|)                                      (* |;;| "(store.variable.Yn n) is much the same.")                  (INSTRUCTIONS XQP::|store.variable.Yn|)                                      (* |;;| "(store.value.Xn n) and (store.value.Yn n) are really a form of unification.  For the moment, the simplest thing to do is to set up T0 and T1 and go ahead with a call to the general unifier.  We could save some time by making a special case unify.constant routine, but it wouldn't save all that much effort, as we still have to check for boxed numbers.   Because maintaining Lisp reference counts is so expensive, we want to avoid calling ADD.REF if we possibly can.  The same criteria apply to all flavours of store value, even store.value.Xn, as Xn might hold an unbound variable.  So the store.value macro packages up the reference count maintenance and tag repair for all flavours of store.value.  We use tag.other because gettopval is sometimes used to load procedure record addresses! I've now hacked this to work like store.value; the conceptual load of having two different mechanisms didn't seem worth while. Note that we avoid the call to ADD.REF when T1 is bound.")                  (FUNCTIONS XQP::|store.value|)                  (INSTRUCTIONS XQP::|store.value.Xn| XQP::|store.value.XnM| XQP::|store.value.Yn|)                                      (* |;;| "(store.integer cell) and (store.float cell) could be done the same way, by just going off to the general unifier. Indeed, the whole of the \"store\" family could be handled by just the store.variable.An instruction, followed by unification against that A register.  store.integer can check immediately for a FIXP, and store.float can check immediately for a FLOATP; this is no real gain as these instructions are vanishingly rare.")                  (INSTRUCTIONS XQP::|store.integer| XQP::|store.float|)                                      (* |;;| "In an earlier version of this file, the load instructions used to demand that an integer or float be yielded.  But now that BIGNUMS are available, this is no longer right, and more importantly, the pseudo-Prolog code that maintains dynamic clauses expects X =\\= 0 to work correctly for any \"address\" X.  So now we accept any kind of constant.   If we do arithmetic on a non-numeric value, Inter- LOSS is perfectly capable of spotting the error and reporting it. As we don't check, \"Y = a, X is Y\" will succeed in compiled code, and it isn't supposed to (and won't in interpreted code).  We can live with that.  When we find a constant, we leave the tag in T0. It doesn't matter, nothing is going to look at it.  The final (?) idea is to reject atoms but accept \"others\". To push T0 into T1, we used to say (put.32 T1 (get.32 T0))		; 15.4 usec We now rely on the fact that this is arithmetic mode, so that if we care what the thing is, any arithmetic tag will do, and call (put.nb T1 (get.nb T0))		; 13.6 usec for a saving of 1.8 usec.  This is pretty small, but no-one ever lost money by taking an easy small profit.")                  (FUNCTIONS XQP::|push.T0.into.T1| XQP::|load.value.error| XQP::|load.value|)                  (INSTRUCTIONS XQP::|load.value.Xn| XQP::|load.value.XnM| XQP::|load.value.Yn|)                                      (* |;;| "The following three instructions switch to read mode so that all arithmetic instructions can assume they will be executed in read mode, and thus can use their write mode opcode for another arithmetic instruction.")                                      (* |;;| "When it comes to loading a constant, we don't need to have separate load.integer and load.float instructions.  The Sun/VAX emulators use them so that (1) they can work out fast what mode they are supposed to be in, and (2) they can put 32-bit boxed numbers in line in the code.  We don't use the mode that way, and there isn't any advantage to having in-line constants.  Indeed, it'd cost us more boxing. So there is only the (load.constant cell) instruction, which copies the pointer part of the cell to T0.  (The tag is copied too, but nobody cares about that.)")                  (INSTRUCTIONS XQP::|load.constant|)                                      (* |;;| "There are four instructions which take 16-bit integer arguments. load.{pos/neg}.word are there for compactness; they are one word shorter than load.cell.  All things considered, I wonder if I am wise to keep them?")                  (INSTRUCTIONS XQP::|load.pos.word| XQP::|load.neg.word|)                                      (* |;;| "add.{pos/neg}.word add a 17-bit integer to T0.  They have to do this without disturbing T1, so we use R as a scratch register. This really needs some thought.  add.constant would be one word longer, and would not be all that much slower.")                  (INSTRUCTIONS XQP::|add.pos.word| XQP::|add.neg.word|)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>ARITH.LSP;2, loaded 22-Jun-87 13:48:25")(* |;;| "SCCS   : @(#)ARITH.LSP	8204.1 3/24/87 File   : $xerox/arith.lsp Author : Richard A. O'Keefe Purpose: Define the arithmetic instructions.")(* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")(* |;;;| "------------------------------------------------------------------------  The D-machine version of the arithmetic instructions differs from the VAX and Sun emulators.  Instead of holding unboxed numbers, T0 and T1 hold ordinary Lisp pointers to SMALLPs, FIXPs, FLOATPs, or whatever.  There are several reasons for this.  One is that it is easiest to do it this way.  Another important one is that in Koto BIGNUMS were added to InterLisp, so that the two-fold distinction which that VAX and Sun emulators assume will not be adequate.  As a consequence of this change, there is no distinction between the two modes here as there is in the VAX/Sun versions: we always stay in whatever mode we happened to be in when we started.  A difference between the Lisp emulator and the existing emulators is the way that division by zero is handled.  The existing emulators check for zero and simply fail.  Arithmetic overflow is handling by taking whatever the hardware gives you for integers, and infinities for floating point numbers.  Allowing infinities was a glaringly stupid mistake, we cannot possibly make that work on the VAX nor on the 1108, and we may change the SUN version to trap floating point overflows as well.  The Koto version of Lisp supports bignums, so integer overflow isn't a problem.  But we want to do something sensible with floating pointer overflow and all kinds of integer division as well, so we run with ")(OVERFLOW T)(* |;;;| "  enabled.  Floating overflow is supposed to be caught; for some reason zero divide is slipping through.")(* |;;| "(raw.float) Takes the floating point number in T0 and turns it into a FIXP with the same bits.  T0 is first floated, if necessary. ASSUMPTION: floats are 32 bits exactly.")(XQP::|def.both.mode| XQP::|raw.float| (XQP::|extend|) (LET ((XQP::|Ptr| (FLOAT (XQP::|get.nb|                                                                                        XQP::T0))))                                                            (XQP::|put.nb| XQP::T0                                                                   (\\MAKENUMBER (\\GETBASE                                                                                         XQP::|Ptr| 0)                                                                          (\\GETBASE XQP::|Ptr| 1))))                                                       (XQP::|continue| 0))(* |;;| "(float) ensures that T0 is a floating point number.")(XQP::|def.both.mode| XQP::|float| (XQP::|extend|) (|if| (NOT (FLOATP (XQP::|get.nb| XQP::T0)))                                                       |then| (XQP::|put.nb| XQP::T0                                                                     (FLOAT (XQP::|get.nb| XQP::T0)))                                                         )                                                   (XQP::|continue| 0))(* |;;| "(fix) ensures that T0 is a fixed point number. Pre-Koto this could cause an overflow trap.  Now it can't.")(XQP::|def.both.mode| |fix| (XQP::|extend|) (|if| (FLOATP (XQP::|get.nb| XQP::T0))                                                |then| (XQP::|put.nb| XQP::T0 (FIX (XQP::|get.nb|                                                                                    XQP::T0))))                                            (XQP::|continue| 0))(* |;;| "(minus) negates a number.")(XQP::|def.both.mode| XQP::|minus| (XQP::|extend|) (XQP::|put.nb| XQP::T0 (MINUS (XQP::|get.nb|                                                                                  XQP::T0)))                                                   (XQP::|continue| 0))(* |;;| "(boolean.not) takes the complement of an integer.")(XQP::|def.both.mode| XQP::|boolean.not| (XQP::|extend|) (XQP::|put.nb| XQP::T0 (LOGNOT (                                                                                        XQP::|get.nb|                                                                                         XQP::T0)))                                                         (XQP::|continue| 0))(* |;;| "All the two-argument arithmetic operations follow a common pattern. They just apply a Lisp function to T0 and T1, and put the result in T0.  So, to save my effort, they are defined via a definer.")(DEFDEFINER XQP::|def.binop| INSTRUCTIONS (XQP::O\p XQP::F\n)                                   `(XQP::|def.both.mode| (\\\, XQP::O\p) (XQP::|extend|)                                       (XQP::|put.nb| XQP::T0 (,XQP::F\n (XQP::|get.nb| T1)                                                                     (XQP::|get.nb| XQP::T0)))                                       (XQP::|continue| 0)))(XQP::|def.binop| |add| PLUS)(XQP::|def.binop| XQP::|subtract| DIFFERENCE)(XQP::|def.binop| |multiply| TIMES)(XQP::|def.binop| XQP::|divide| FQUOTIENT)(XQP::|def.binop| XQP::|integer.divide| IQUOTIENT)(XQP::|def.binop| XQP::|modulus| REMAINDER)(XQP::|def.binop| XQP::|boolean.and| LOGAND)(XQP::|def.binop| XQP::|boolean.or| LOGOR)(XQP::|def.binop| XQP::|boolean.xor| LOGXOR)(XQP::|def.binop| XQP::|left.shift| LSH)(* \; "*NOT* LLSH")(XQP::|def.binop| |right.shift| RSH)(* \; "*NOT* LRSH")(* |;;| "There are two versions of each arithmetic relation. (foo) succeeds if the relation holds, fails otherwise. (foo.else L) falls through if the relation holds, or jumps to L if the relation fails to hold.  For convenience, the jump instructions are like other jumps, [opcode:8|addr:24] and the other ones are [extend:8|opcode:8].  As a matter of fact, these instructions can only appear at the end of a block of arithmetic instructions, so if we arranged for load instructions to set read mode, we could double up the other arithmetic instructions, particularly the jumps and stores.")(DEFDEFINER XQP::|def.relop| INSTRUCTIONS (O E N D TEST)                    (* |;;| "O is the Opcode for if-TEST-then-true-else-fail")                    (* |;;| " E is the opcode for if-TEST-then-true-else-jump ")                    (* |;;| "N is the opcode for if-TEST-then-fail-else-true")                    (* |;;| " D is the opcode for if-TEST-then-jump-else-true")                                   `(PROGN (XQP::|def.singlemode| (\\\, O) NIL                                                                           (|if| ,TEST                                                                               |then| (                                                                                      XQP::|continue|                                                                                       0)                                                                             |else| (XQP::|fast.fail|                                                                                     )))                                           (XQP::|def.singlemode| (\\\, N) NIL                                                                           (|if| ,TEST                                                                               |then| (                                                                                     XQP::|fast.fail|                                                                                       )                                                                             |else| (XQP::|continue|                                                                                     0)))                                           (XQP::|def.singlemode| (\\\, E) (|address|)                                              (|if| ,TEST                                                  |then| (XQP::|continue| 1)                                                |else| (XQP::|continue.reading.at| (                                                                               XQP::|address.operand|                                                                                    ))))                                           (XQP::|def.singlemode| (\\\, D) (|address|)                                              (|if| ,TEST                                                  |then| (XQP::|continue.reading.at| (                                                                               XQP::|address.operand|                                                                                      ))                                                |else| (XQP::|continue| 1)))))(XQP::|def.relop| XQP::|equal.to| XQP::|equal.to.else| XQP::|not.equal.to| XQP::|not.equal.to.else|                                        (EQP (XQP::|get.nb| T1)                                             (XQP::|get.nb| XQP::T0)))(XQP::|def.relop| XQP::|less.than| XQP::|less.than.else| XQP::|not.less.than|                                          XQP::|not.less.than.else| (LESSP (XQP::|get.nb| T1)                                                                          (XQP::|get.nb| XQP::T0)))(XQP::|def.relop| XQP::|greater.than| XQP::|greater.than.else| XQP::|not.greater.than|                                             XQP::|not.greater.than.else| (GREATERP (XQP::|get.nb|                                                                                    T1)                                                                                (XQP::|get.nb|                                                                                        XQP::T0)))(* |;;| "(store.variable.Xn n) stores the number in T0 in the previously uninitialised variable Xn. We set the tag of T0, but it is safe to continue in arithmetic mode, because the arithmetic operations ignore that tag.  The different versions of store.variable used to take up 13% of the time of the naive reverse benchmark running interpreted; the very hairy code we have here now is an attempt to reduce this.  The original code tested the type of T0 three times; this does it once.  Note that we have to use the equivalent of tag.other here, because thanks to improved choice point code, T0 might be a Prolog choice point handle. I am sorry to include the calls to ADD.REF in what should have been pure code to calculate the tag, but console yourself with the thought that logically it is an identity function.")(XQP::|def.props| |tag|                                      (* \; "(tag Tag Ptr)") XQP::|Tag| (LAMBDA (XQP::|Tag| XQP::|Ptr|)              XQP::|Tag|)       XQP::|Ptr|       (LAMBDA (XQP::|Tag| XQP::|Ptr|)         XQP::|Ptr|))(XQP::|def.macro| XQP::|store.variable| (XQP::|store|)   `(LET ((XQP::|Ptr| (XQP::|get.nb| XQP::T0)))         (,XQP::|store| N (|tag| (SELECTC (NTYPX XQP::|Ptr|)                                     ((NTYPX 1)              (* \; "(SMALLP Ptr)")                                          XQP::|immed.tag.8|)                                     ((NTYPX (LSH 1 17))     (* \; "(FIXP Ptr)")                                          (XQP::ADD.REF XQP::|Ptr|)                                          XQP::|boxed.tag.8|)                                     ((NTYPX 1.0)            (* \; "(FLOATP Ptr)")                                          (XQP::ADD.REF XQP::|Ptr|)                                          XQP::|float.tag.8|)                                     ((NTYPX (LSH 1 40))     (* \; "(BIGNUM Ptr)")                                          (XQP::ADD.REF XQP::|Ptr|)                                          XQP::|boxed.tag.8|)                                     ((NTYPX 'ONE)           (* \; "(LITATOM Ptr)")                                          XQP::|symbol.tag.8|)                                     (PROGN                  (* \; "(\\BLOCKDATAP Ptr), maybe")                                            XQP::|other.tag.8|))                                                             (* \; "that was the tag to store")                                 XQP::|Ptr|))                (* \; "that was the datum")         (XQP::|continue| 0)))(XQP::|def.singlemode| XQP::|store.variable.Xn| (XQP::|areg|) (XQP::|store.variable| XQP::|put.Aval|))(* |;;| "(store.variable.XnM n) is for the X registers stored in memory.")(XQP::|def.singlemode| XQP::|store.variable.XnM| (XQP::|amem|) (XQP::|store.variable| XQP::|put.Amem|                                                                      ))(* |;;| "(store.variable.Yn n) is much the same.")(XQP::|def.singlemode| XQP::|store.variable.Yn| (XQP::|yreg|) (XQP::|store.variable| XQP::|put.Yval|))(* |;;| "(store.value.Xn n) and (store.value.Yn n) are really a form of unification.  For the moment, the simplest thing to do is to set up T0 and T1 and go ahead with a call to the general unifier.  We could save some time by making a special case unify.constant routine, but it wouldn't save all that much effort, as we still have to check for boxed numbers.   Because maintaining Lisp reference counts is so expensive, we want to avoid calling ADD.REF if we possibly can.  The same criteria apply to all flavours of store value, even store.value.Xn, as Xn might hold an unbound variable.  So the store.value macro packages up the reference count maintenance and tag repair for all flavours of store.value.  We use tag.other because gettopval is sometimes used to load procedure record addresses! I've now hacked this to work like store.value; the conceptual load of having two different mechanisms didn't seem worth while. Note that we avoid the call to ADD.REF when T1 is bound.")(XQP::|def.macro| XQP::|store.value| (|fetch|)   `(LET ((XQP::|Ptr| (XQP::|get.nb| XQP::T0)))         (XQP::|put.32| T1 (,|fetch| N))         (XQP::|put.32| XQP::T0 (|tag|                       (* \; "from here on is common")                                       (SELECTC (NTYPX XQP::|Ptr|)                                           ((NTYPX 1)        (* \; "(SMALLP Ptr)")                                                XQP::|immed.tag.8|)                                           ((NTYPX (LSH 1 17))                                                              (* \; "(FIXP Ptr)")                                                (|if| (EQ (XQP::|tag.of| T1)                                                          XQP::|ref.tag.8|)                                                    |then| (XQP::ADD.REF XQP::|Ptr|))                                                XQP::|boxed.tag.8|)                                           ((NTYPX 1.0)      (* \; "(FLOATP Ptr)")                                                (|if| (EQ (XQP::|tag.of| T1)                                                          XQP::|ref.tag.8|)                                                    |then| (XQP::ADD.REF XQP::|Ptr|))                                                XQP::|float.tag.8|)                                           ((NTYPX (LSH 1 40))                                                              (* \; "(BIGNUM Ptr)")                                                (|if| (EQ (XQP::|tag.of| T1)                                                          XQP::|ref.tag.8|)                                                    |then| (XQP::ADD.REF XQP::|Ptr|))                                                XQP::|boxed.tag.8|)                                           ((NTYPX 'ONE)     (* \; "(LITATOM Ptr)")                                                XQP::|symbol.tag.8|)                                           (PROGN            (* \; "(\\BLOCKDATAP Ptr), maybe")                                                  XQP::|other.tag.8|))                                                             (* \; "that was the tag to store")                                       XQP::|Ptr|))          (* \; "that was the datum")         (XQP::|unify.and.continue| 0)))(XQP::|def.singlemode| XQP::|store.value.Xn| (XQP::|areg|) (XQP::|store.value| XQP::|get.Aval|))(XQP::|def.singlemode| XQP::|store.value.XnM| (XQP::|amem|) (XQP::|store.value| XQP::|get.Amem|))(XQP::|def.singlemode| XQP::|store.value.Yn| (XQP::|yreg|) (XQP::|store.value| XQP::|get.Yval|))(* |;;| "(store.integer cell) and (store.float cell) could be done the same way, by just going off to the general unifier. Indeed, the whole of the \"store\" family could be handled by just the store.variable.An instruction, followed by unification against that A register.  store.integer can check immediately for a FIXP, and store.float can check immediately for a FLOATP; this is no real gain as these instructions are vanishingly rare.")(XQP::|def.both.mode| XQP::|store.integer| (XQP::|cell|) (XQP::|put.32| T1 (XQP::|cell.operand|))                                                         (|if| (AND (FIXP (XQP::|get.nb| XQP::T0))                                                                    (EQP (XQP::|get.nb| XQP::T0)                                                                         (XQP::|get.nb| T1)))                                                             |then| (XQP::|continue| 2)                                                           |else| (XQP::|fast.fail|)))(XQP::|def.both.mode| XQP::|store.float| (XQP::|cell|) (XQP::|put.32| T1 (XQP::|cell.operand|))                                                       (|if| (AND (FLOATP (XQP::|get.nb| XQP::T0))                                                                  (EQP (XQP::|get.nb| XQP::T0)                                                                       (XQP::|get.nb| T1)))                                                           |then| (XQP::|continue| 2)                                                         |else| (XQP::|fast.fail|)))(* |;;| "In an earlier version of this file, the load instructions used to demand that an integer or float be yielded.  But now that BIGNUMS are available, this is no longer right, and more importantly, the pseudo-Prolog code that maintains dynamic clauses expects X =\\= 0 to work correctly for any \"address\" X.  So now we accept any kind of constant.   If we do arithmetic on a non-numeric value, Inter- LOSS is perfectly capable of spotting the error and reporting it. As we don't check, \"Y = a, X is Y\" will succeed in compiled code, and it isn't supposed to (and won't in interpreted code).  We can live with that.  When we find a constant, we leave the tag in T0. It doesn't matter, nothing is going to look at it.  The final (?) idea is to reject atoms but accept \"others\". To push T0 into T1, we used to say (put.32 T1 (get.32 T0))		; 15.4 usec We now rely on the fact that this is arithmetic mode, so that if we care what the thing is, any arithmetic tag will do, and call (put.nb T1 (get.nb T0))		; 13.6 usec for a saving of 1.8 usec.  This is pretty small, but no-one ever lost money by taking an easy small profit.")(XQP::|def.macro| XQP::|push.T0.into.T1| NIL `(XQP::|put.nb| T1 (XQP::|get.nb| XQP::T0)))(XQP::|def.subr| XQP::|load.value.error| NIL                 (* \; "print an error message")                                             (XQP::PUT.TOKEN.SIMPLE XQP::CURRENT.OUTPUT "[Warning: Arithmetic predicate has failed - tried to evaluate a non number][         Use the interpreter and debugger to locate this error]")                                             (XQP::|fast.fail|))(XQP::|def.macro| XQP::|load.value| (|fetch|)   `(LET (XQP::|Tag| R)         (XQP::|push.T0.into.T1|)         (XQP::|put.32| XQP::T0 (,|fetch| N))                (* \; "then common")         (|while| (AND (EQ (SETQ XQP::|Tag| (XQP::|tag.of| XQP::T0))                           XQP::|ref.tag.8|)                 (* \; "is a var")                       (NEQ (SETQ R (XQP::|untag.ref| XQP::T0))                                                             (* \; "dereference")                            (PROGN (XQP::|put.32| XQP::T0 (XQP::|get-cell-for-apply| R 0))                                   (XQP::|untag.ref| XQP::T0)))) |do|                                                              (* \; "not same var")                                                                      NIL)         (|if| (ILESSP XQP::|Tag| XQP::|immed.tag.8|)             |then| (XQP::|load.value.error|)                (* \; "not a constant")           |else| (XQP::|continue.reading| 0)                (* \;                                                              "a smallp, fixp, floatp, or \"other\"")                                                             (* \; "switch to read mode so that all arithmetic instructions can assume they will be executed in read mode, and thus can use their write mode opcode for another arithmetic instruction.")                 )))(XQP::|def.both.mode| XQP::|load.value.Xn| (XQP::|areg|) (XQP::|load.value| XQP::|get.Aval|))(XQP::|def.both.mode| XQP::|load.value.XnM| (XQP::|amem|) (XQP::|load.value| XQP::|get.Amem|))(XQP::|def.both.mode| XQP::|load.value.Yn| (XQP::|yreg|) (XQP::|load.value| XQP::|get.Yval|))(* |;;| "The following three instructions switch to read mode so that all arithmetic instructions can assume they will be executed in read mode, and thus can use their write mode opcode for another arithmetic instruction.")(* |;;| "When it comes to loading a constant, we don't need to have separate load.integer and load.float instructions.  The Sun/VAX emulators use them so that (1) they can work out fast what mode they are supposed to be in, and (2) they can put 32-bit boxed numbers in line in the code.  We don't use the mode that way, and there isn't any advantage to having in-line constants.  Indeed, it'd cost us more boxing. So there is only the (load.constant cell) instruction, which copies the pointer part of the cell to T0.  (The tag is copied too, but nobody cares about that.)")(XQP::|def.both.mode| XQP::|load.constant| (XQP::|extend| XQP::|cell|) (XQP::|push.T0.into.T1|)                                                                       (XQP::|put.32| XQP::T0 (                                                                                  XQP::|cell.operand|                                                                                               ))                                                                       (XQP::|continue.reading|                                                                        2))(* |;;| "There are four instructions which take 16-bit integer arguments. load.{pos/neg}.word are there for compactness; they are one word shorter than load.cell.  All things considered, I wonder if I am wise to keep them?")(XQP::|def.both.mode| XQP::|load.pos.word| (XQP::|extend| |word|) (XQP::|push.T0.into.T1|)                                                                  (XQP::|put.nb| XQP::T0                                                                         (XQP::|get.code| P 0))                                                                  (XQP::|continue.reading| 1))(XQP::|def.both.mode| XQP::|load.neg.word| (XQP::|extend| |word|) (XQP::|push.T0.into.T1|)                                                                  (XQP::|put.nb|                                                                   XQP::T0                                                                   (\\VAG2 (CONSTANT (\\HILOC -1))                                                                          (XQP::|get.code| P 0)))                                                                  (XQP::|continue.reading| 1))(* |;;| "add.{pos/neg}.word add a 17-bit integer to T0.  They have to do this without disturbing T1, so we use R as a scratch register. This really needs some thought.  add.constant would be one word longer, and would not be all that much slower.")(XQP::|def.singlemode| XQP::|add.pos.word| (|word|) (XQP::|put.nb| XQP::T0 (PLUS (XQP::|get.nb|                                                                                  XQP::T0)                                                                                 (XQP::|get.code|                                                                                  P 0)))                                                    (XQP::|continue| 1))(XQP::|def.singlemode| XQP::|add.neg.word| (|word|) (XQP::|put.nb| XQP::T0                                                           (PLUS (XQP::|get.nb| XQP::T0)                                                                 (\\VAG2 (CONSTANT (\\HILOC -1))                                                                        (XQP::|get.code| P 0))))                                                    (XQP::|continue| 1))(PUTPROPS ARITH COPYRIGHT ("Quintus Computer Systems, Inc" 1987))(DECLARE\: DONTCOPY  (FILEMAP (NIL)))STOP