(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(filecreated "16-Dec-87 18:51:46" {dsk}<lispfiles>dcoms>prologgc.\;3 97221        |changes| |to:|  (fns gc)      |previous| |date:| "20-Oct-87 17:20:47" {dsk}<lispfiles>dcoms>prologgc.\;2); Copyright (c) 1986, 1900, 1987 by Quintus Computer Systems, Inc.  All rights reserved.(prettycomprint prologgccoms)(rpaqq prologgccoms        (            (* |;;| "This file implements a Prolog garbage collector;  i.e., a collector of inaccessible cells in the Prolog heap.  Of the 3 stacks in the WAM, only the heap can contain garbage.  Note that this garbage collector does not collect inaccessible atoms or procedure records.")                    (* |;;| "This file is divided into 6 parts: garbaqe collector top level and misc., the marker, the compactor, variables and constants, Lisp extensions for this file, and finally debugging aids.")        (* |;;;| "Top level of the garbage collector, and misc minor stuff")        (fns xqp::garbage.collect.heap gc xqp::gc.flipcursor xqp::init.gc xqp::init.stats              xqp::last.collected.choicepoint xqp::make.consistent.for.gc              xqp::mark.collected.choicepoints xqp::pre.gc.criteria xqp::print.post.gc.trace.options              xqp::print.post.mark.stats xqp::print.pre.gc.trace.options xqp::process.perm.vars              xqp::reset.gc.cursor xqp::set.gc.cursor xqp::update.stats xqp::|opcode.FROM.POINTER|)        (macros xqp::b.of.b xqp::e.of.b xqp::h.of.b xqp::tr.of.b xqp::h.of.b.ptr xqp::set.h.of.b)        (macros xqp::arity.from.pr xqp::in.collectable.heap xqp::in.heap xqp::pointer.in.range                xqp::trace.gc xqp::\\basedifference xqp::\\clearbasebits xqp::\\setbasebits                xqp::\\testallbasebits xqp::\\testanybasebits)        (* |;;;| "The marker")        (fns xqp::heap.top.during.unification xqp::initialize.trace.stack peek xqp::trace.and.mark              xqp::trace.and.mark.argument.registers xqp::trace.and.mark.from.s              xqp::trace.and.mark.local.stack xqp::trace.and.mark.pdl              xqp::trace.and.mark.prologified.term xqp::trace.and.mark.trail.references xqp::trace.ptr             )        (macros xqp::is.marked xqp::is.pointer.tag xqp::mark.unmarked.cell xqp::pop.trace.stack                xqp::push.trace.stack xqp::tag.is.marked xqp::tag.marked.as xqp::tag.sans.mark.bit                xqp::tag.with.mark.bit xqp::within.heap.non.gc xqp::within.stack.non.gc)        (* |;;;| "The compactor")        (fns xqp::collect.the.garbage xqp::collector.downsweep xqp::collector.upsweep              xqp::reverse.argument.registers xqp::reverse.local.stack.pointers              xqp::reverse.trail.stack.pointers xqp::update.registers.after.gc)        (macros xqp::reverse.pointer reversed.pointerp xqp::mark.as.reversed xqp::unmark.as.reversed                xqp::valid.pointer)        (* |;;;| "Constants and variables")        (constants (xqp::markbit.mask 4)               (xqp::markbit.mask.16 1024))        (declare\: eval@load dontcopy (vars (xqp::s.register.memory.location (\\addbase xqp::|membot|                                                                                     512))                                            (xqp::t0.register.memory.location (\\addbase                                                                       xqp::s.register.memory.location                                                                                      2))                                            (xqp::t1.register.memory.location (\\addbase                                                                      xqp::t0.register.memory.location                                                                                      2))                                            (xqp::c.register.memory.location (\\addbase                                                                      xqp::t1.register.memory.location                                                                                     2))                                            (xqp::r.register.memory.location (\\addbase                                                                       xqp::c.register.memory.location                                                                                     2))))        (globalvars xqp::s.register.memory.location xqp::t0.register.memory.location                xqp::t1.register.memory.location xqp::c.register.memory.location                xqp::r.register.memory.location)        (vars xqp::debuggable xqp::debugging)        (initvars (xqp::gc.trace 0)               (xqp::gc.cursor.mask 65295)               (xqp::gc.saved.trace.stack.segments nil)               (xqp::gc.trace.stack nil)               (xqp::gc.trace.stack.ptr 65536)               (xqp::gc.trace.stack.segments nil))        (globalvars xqp::debuggable xqp::debugging xqp::gc.trace xqp::gc.cursor.mask                xqp::gc.saved.trace.stack.segments xqp::gc.trace.stack xqp::gc.trace.stack.ptr                xqp::gc.trace.stack.segments)        (cursors xqp::|PrologGCCursor|)        (globalvars xqp::gc.enabled xqp::gc.incremental xqp::gc.minimum.heap xqp::gc.margin)        (initvars (xqp::gc.collection.threshold 1000)               xqp::gc.count xqp::gc.freed.heap.cells xqp::gc.time xqp::gc.trail.gc)        (globalvars xqp::gc.collection.threshold xqp::gc.count xqp::gc.freed.heap.cells xqp::gc.time                xqp::gc.trail.gc xqp::trail.gc xqp::traceblock)        (globalvars xqp::gc.heap xqp::gc.heap.gc xqp::gc.heap.p xqp::gc.heap.p.for.compaction                xqp::gc.trail.p xqp::gc.trail xqp::gc.trail.gc xqp::gc.stack xqp::gc.stack.gc                xqp::gc.stack.p xqp::gc.a.regs xqp::gc.a.regs.gc xqp::gc.a.regs.p)        (* |;;;| "Stuff to make Interlisp more hospitable to operations on the Prolog memory.")        (i.s.oprs xqp::|fromcell| xqp::|tocell| xqp::|downtocell|)        (prop clispword xqp::fromcell)        (prop clispword xqp::tocell)        (prop clispword xqp::downtocell)        (prop (clispword changeword)              xqp::|subtract|)        (prop clispword subtract)                                                             (* \; "Finally: do the initialization.")        (p (xqp::init.gc))        (* |;;;| "Debugging stuff")        (fns xqp::alternatives xqp::clearmem xqp::marked.cells microcode xqp::current.instr              xqp::find.refs xqp::scan.for.garbage xqp::maybe.gc xqp::maybe.gc.now              xqp::zero.out.garbage xqp::ptr.state)        (macros xqp::if.debugging)        (initvars (xqp::maybe.gc.count 0)               (xqp::maybe.gc.events '(20 21 22 23 24 25))               (xqp::maybe.gc.interval 1000))        (vars xqp::traceblock xqp::zeroing)                    (* |;;| "Try to beat the file manager into shape")        (prop makefile-environment)))(* |;;| "This file implements a Prolog garbage collector;  i.e., a collector of inaccessible cells in the Prolog heap.  Of the 3 stacks in the WAM, only the heap can contain garbage.  Note that this garbage collector does not collect inaccessible atoms or procedure records.")(* |;;| "This file is divided into 6 parts: garbaqe collector top level and misc., the marker, the compactor, variables and constants, Lisp extensions for this file, and finally debugging aids.")(* |;;;| "Top level of the garbage collector, and misc minor stuff")(defineq(XQP::GARBAGE.COLLECT.HEAP  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:21 by pds")(* |;;;| "This is the Prolog interface for explicitly calling the garbage collector by garbage_collect/0.")    (GC 22)))(gc  (lambda (xqp::overflow.event)                              (* \; "Edited 16-Dec-87 18:47 by pds")(* |;;;| "The main entry point into the garbage collector.  One call does it all.")    (|if| (xqp::pre.gc.criteria xqp::overflow.event)        |then| (xqp::print.pre.gc.trace.options)              (xqp::init.stats)              (let* ((xqp::s.is.alive? (xqp::make.consistent.for.gc xqp::overflow.event))                     (xqp::garbage.count (idifference (iquotient (xqp::\\basedifference                                                                         xqp::gc.heap.p.for.compaction                                                                         xqp::gc.heap.gc)                                                             2)                                                (xqp::trace.and.mark xqp::overflow.event                                                        xqp::s.is.alive?))))                    (xqp::print.post.mark.stats xqp::garbage.count)                    (xqp::if.debugging gc                           (|if| (and (or (eq xqp::overflow.event 23)                                          (eq xqp::overflow.event 13))                                      (or (eq (\\getbasebyte (xqp::|get.24| p)                                                     -2)                                              150)                                          (eq (\\getbasebyte (xqp::|get.24| p)                                                     -2)                                              151)))                               |then| (|if| (eq xqp::gc.heap.p (xqp::|get.24| h))                                          |then| (printout t "Woops!  forgot about PDL!!!" t))                                     (printout t "interpret.me garbage collection during unification"                                             t "checking HB to H ...")                                     (|if| (|bind| (top _ (\\addbase xqp::gc.heap.p -2)) |for| i                                              xqp::fromcell (xqp::|get.24| xqp::hb) xqp::tocell                                                                                    top                                              |thereis| (not (xqp::is.marked i)))                                         |then| (printout t t                                                        "uh-oh!!!!  Interpreted clause got trashed!" t                                                       )                                               (break1 t t t)                                       |else| (printout t t "AOK." t))))                    (|if| (igeq xqp::garbage.count xqp::gc.collection.threshold)                        |then| (* |;;;| "(BLOCK.EVENTS)")                              (xqp::if.debugging gc (let ((xqp::zeroed.cells (xqp::zero.out.garbage))                                                          )                                                         (|if| (not (eqp xqp::zeroed.cells                                                                          xqp::garbage.count))                                                             |then| (error                                                                       "Wrong number of garbage cells"                                                                           (cons xqp::zeroed.cells                                                                                  xqp::garbage.count))                                                               )))                              (xqp::collect.the.garbage xqp::garbage.count xqp::overflow.event                                      xqp::s.is.alive?)                              (xqp::unblock.events)                              (xqp::update.registers.after.gc xqp::garbage.count xqp::overflow.event                                      xqp::s.is.alive?) (* |;;;| "for incremental GC: mark what has been collected already so it doesn't have to be done again.")                              (xqp::mark.collected.choicepoints)                              (xqp::update.stats)                              (xqp::print.post.gc.trace.options)                              (xqp::if.debugging gc (|if| (xqp::scan.for.garbage xqp::overflow.event)                                                        |then| (break1 10 t 10)))                              t                      |else| (|if| (eq xqp::overflow.event 22)                                 |then|                      (* \;                                                           "EV_OVHEAPGC: explicit GC, must not abort.")                                       (|bind| tag (top _ (\\addbase xqp::gc.heap.p -2)) |for| i                                          xqp::|fromcell| xqp::gc.heap.gc xqp::|tocell| top                                          |when| (xqp::tag.is.marked (setq tag (\\getbasebyte i 0)))                                          |do| (putbasebyte i 0 (xqp::tag.sans.mark.bit tag)))                                       (xqp::trace.gc                                               "[ Garbage Collection of the Heap Stack Punted ]" t t)                                       (xqp::reset.gc.cursor)                               else (printout (xqp::qio.stream xqp::standard.error)                                                                                "[ Garbage collection failed:  not enough garbage to collect. ]"                                            t))                            nil)))))(XQP::GC.FLIPCURSOR  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:22 by pds")(* |;;;| "Similar to (FLIPCURSOR), used during lisp garbage collection, except that instead of completely inverting the cursor, it inverts stripes of the cursor.  It is its own inverse.  Try it.")(* |;;;| "This function is not used in the garbage collector.  It is replaced by SET.GC.CURSOR and RESET.GC.CURSOR, which look better.")    (BITBLT NIL NIL NIL (CURSORBITMAP)           NIL NIL NIL NIL 'TEXTURE 'INVERT XQP::GC.CURSOR.MASK)))(XQP::INIT.GC  (LAMBDA NIL                                                (* \; "Edited 14-Aug-87 11:06 by pds")(* |;;;| "This is called during setup.")(* |;;;| "The following are variables local to PROLOGGC which are accumulators for statistics/0,2.")    (SETQ XQP::GC.COUNT 0)    (SETQ XQP::GC.FREED.HEAP.CELLS 0)    (SETQ XQP::GC.TIME 0)(* |;;;| "The following are accessed from Prolog directly, via cll and ass.")    (SETQ XQP::GC.ENABLED 1)    (SETQ XQP::GC.INCREMENTAL 1)    (SETQ XQP::GC.TRACE 0)))(XQP::INIT.STATS  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:22 by pds")(* |;;;| "Just about to start garbage collection: save away some information so that when gc is completed, we can see what happened and how long it took.")    (SETQ XQP::START.CPU.TIME (CLOCK 0))    (SETQ XQP::START.HEAP.SIZE (IQUOTIENT (XQP::\\BASEDIFFERENCE XQP::GC.HEAP.P XQP::GC.HEAP)                                      2))))(XQP::LAST.COLLECTED.CHOICEPOINT  (LAMBDA NIL                                                (* \; "Edited 19-Aug-87 11:34 by pds")(* |;;;| "Chain backwards through active choicepoints looking for the first one that is marked.  Return the one just before that.  This choicepoint indicates the parts of the stacks that were not considered by the last GC <because they were created since> and therefore must be considered by this GC.  As described in MARK.COLLECTED.CHOICEPOINTS, which is responsible for installing the marks in the first place, the mark is placed on the B slot of the choicepoint.  8 is the offset to the B slot.")    (|if| (EQ XQP::GC.INCREMENTAL 1)        |then| (|bind| XQP::B.OF.B (B _ (XQP::|get.24| B))                  |until| (OR (NOT (XQP::\\BASELESSP XQP::|init.E| (SETQ XQP::B.OF.B (XQP::B.OF.B                                                                                      B))))                              (XQP::\\TESTANYBASEBITS B -8 XQP::MARKBIT.MASK.16))                  |do| (SETQ B XQP::B.OF.B) |finally| (RETURN B))      |else| XQP::|init.E|)))(xqp::make.consistent.for.gc  (lambda (xqp::overflow.event)                              (* \; "Edited 19-Oct-87 16:13 by pds")(* |;;;| "Badly named function that gets the system ready to collect garbage.  Mostly sets up global variables.  Returns T iff the S register is currently active, and needs to be traced and updated after compaction.")    (let ((xqp::arity.of.current.execute (selectq xqp::overflow.event                                             (12             (* \; "EV_OVHEAPEXECUTE")                                                 (xqp::arity.from.pr))                                             (13             (* \; "EV_OVTRAIL")                                                 255)                                             (20             (* \; "EV_OVCHKHEAP")                                                 255)                                             (21             (* \;                       "EV_OVHEAPFUNCTOR <heap check is performed AFTER functor, so A regs are dead.>")                                                 0)                                             (22             (* \; "EV_OVHEAPGC <explicit gc>")                                                 0)                                             (23             (* \; "EV_OVHEAPUNIFY")                                                 255)                                             (24             (* \; "EV_OVHEAPINTERPME")                                                 1)                                             (25             (* \; "EV_OVHEAPPROLOGIFY")                                                 255)                                             (shouldnt 'xqp::make.consistent.for.gc)))          (xqp::s.is.alive? (and (or (eq xqp::overflow.event 13)                                     (eq xqp::overflow.event 23)                                     (eq xqp::overflow.event 25))                                 (let ((xqp::nextinstr (\\getbasebyte (xqp::|get.24| p)                                                              (|if| (eq xqp::overflow.event 25)                                                                  |then| 0                                                                |else| (xqp::|get.4| w)))))                                      (xqp::if.debugging gc (printout t "Next instruction:  "                                                                   (elt xqp::|QP.opcode|                                                                         xqp::nextinstr)                                                                   t))                                                             (* \;                                    "next instruction is a unify, so S is valid and we must trace it.")                                      (and (igeq xqp::nextinstr (constant (xqp::op.code '                                                                                 xqp::|unify.boxed|))                                                 )                                           (ileq xqp::nextinstr (constant (add1 (xqp::op.code                                                                                 'xqp::|unify.void|))                                                                       ))))))          (xqp::last.collected.cp (xqp::last.collected.choicepoint)))(* |;;;| "Store the A registers that live in real registers, and the S, T0, and T1 registers, if they are active, in their memory slots.")         (xqp::|put.Amem| 1 (xqp::|get.Aval| 1))         (xqp::|put.Amem| 2 (xqp::|get.Aval| 2))         (xqp::|put.Amem| 3 (xqp::|get.Aval| 3))         (xqp::|put.Amem| 4 (xqp::|get.Aval| 4))         (|if| xqp::s.is.alive?             |then|                                          (* \;                                                        "Must make sure S register gets updated, too.")                   (\\putbaseptr xqp::s.register.memory.location 0 (xqp::|get.24| s)))         (|if| (eq xqp::overflow.event 23)             |then|                                          (* \;                                                     "EV_OVHEAPUNIFY: must maintain T0, T1, R, and C.")                   (\\putbaseptr xqp::t0.register.memory.location 0 (xqp::|ReadPrologPtr| xqp::t0))                   (\\putbasebyte xqp::t0.register.memory.location 0 (xqp::|ReadPrologTag| xqp::t0))                   (\\putbaseptr xqp::t1.register.memory.location 0 (xqp::|ReadPrologPtr| t1))                   (\\putbasebyte xqp::t1.register.memory.location 0 (xqp::|ReadPrologTag| t1))                   (\\putbaseptr xqp::c.register.memory.location 0 (xqp::|get.24| c))                   (\\putbaseptr xqp::r.register.memory.location 0 (xqp::|get.24| r)))(* |;;;| "Set the pointers demarking the parts of the stack, trail, and heap, and A regs.  The pointers are named GC.stuff, where stuff is made up of two parts: the area name <HEAP, TRAIL, STACK, or A.REGS> , and an indication of which part of the area the pointer points to: the base of the area (no suffix), the top of the area <.P suffix>, or the base of the part of this area that needs to be considered for garbage collection <.GC suffix>.")(* |;;;| "GC.HEAP.P.FOR.COMPACTION is different from GC.HEAP.P only when the PDL is active on top of the heap.  In this case, GC.HEAP.P.FOR.COMPACTION points after the top of the PDL, and GC.HEAP.P, as always, points after the top of the stack.  For tracing, GC.HEAP.P indicates the heap bound, but when compacting, GC.HEAP.P.FOR.COMPACTION is the interesting bound, because the PDL must be relocated with the heap.")         (setq xqp::gc.heap xqp::|init.H|)         (setq xqp::gc.heap.gc (xqp::h.of.b xqp::last.collected.cp))         (|if| (or (eq xqp::overflow.event 23)                   (eq xqp::overflow.event 13))             |then|                                          (* \;                "EV_OVHEAPUNIFY or EV_OVTRAIL, which means that the PDL is active on top of the heap.")                   (setq xqp::gc.heap.p.for.compaction (\\addbase (xqp::|get.24| h)                                                              6))                   (setq xqp::gc.heap.p (xqp::heap.top.during.unification))           |else| (setq xqp::gc.heap.p (setq xqp::gc.heap.p.for.compaction (xqp::|get.24| h))))         (setq xqp::gc.trail.p (xqp::|get.24| tr))         (setq xqp::gc.trail (\\addbase xqp::|init.E| -2))         (setq xqp::gc.trail.gc (xqp::tr.of.b xqp::last.collected.cp))         (setq xqp::gc.stack xqp::|init.E|)         (setq xqp::gc.stack.gc (xqp::e.of.b xqp::last.collected.cp))         (setq xqp::gc.stack.p (|if| (|before| e b)                                   |then| (xqp::|get.24| b)                                 |else| (selectq xqp::overflow.event                                            ((12 22)         (* \;                                                 "GC at call time: can get env size from CP register.")                                                 (xqp::|E.plus.env.size.from.CP|))                                            ((13 20 21 23 24 25)                                                              (* \;                                               "GC at another time: must make pessimistic assumption.")                                                 (let ((xqp::worst (xqp::|add.cell| e 258)))                                                      (|if| (\\baselessp xqp::|memtop| xqp::worst)                                                          |then| xqp::|memtop|                                                        |else| xqp::worst)))                                            (shouldnt 'xqp::make.consistent.for.gc))))         (setq xqp::gc.a.regs (xqp::|loc.Amem| 1))         (setq xqp::gc.a.regs.gc (xqp::|add.cell| xqp::|membot| xqp::arity.of.current.execute))         (setq xqp::gc.a.regs.p (\\addbase (xqp::|loc.Amem| 255)                                       2))         (|if| (|before| tr h)             |then| (error "The heap has overwritten the trail"))         (xqp::initialize.trace.stack)         xqp::s.is.alive?)))(XQP::MARK.COLLECTED.CHOICEPOINTS  (LAMBDA NIL                                                (* \; "Edited 19-Aug-87 11:22 by pds")(* |;;;| "B is the current contents of the B register <i.e., it points to the top choicepoint>.  Chain through all the choicepoints in the local stack marking them as having been collected.  A choicepoint is marked by setting the mark bit in the tag <which is ignored by all operations on choicepoints> of the B slot of the choicepoint.")    (|bind| (B _ (XQP::|get.24| B)) |while| (XQP::\\BASELESSP XQP::GC.STACK.GC B)       |do| (XQP::\\SETBASEBITS B -8 XQP::MARKBIT.MASK.16)   (* \; "-8 is the offset to the B slot")            (SETQ B (XQP::B.OF.B B)))))(XQP::PRE.GC.CRITERIA  (LAMBDA (XQP::OVERFLOW.EVENT)                              (* \; "Edited 11-Aug-87 10:24 by pds")(* |;;;| "Determines whether or not to do a gc.  Since Xhas no stack shifter, this is much simpler than the C version, which may choose to stack-shift.")    (OR (EQ XQP::OVERFLOW.EVENT 22)        (AND (NEQ XQP::GC.ENABLED 0)             (OR (EQ XQP::OVERFLOW.EVENT 12)                 (EQ XQP::OVERFLOW.EVENT 13)                 (AND (IGEQ XQP::OVERFLOW.EVENT 20)                      (ILEQ XQP::OVERFLOW.EVENT 29)))))))(XQP::PRINT.POST.GC.TRACE.OPTIONS  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:48 by pds")(* |;;;| "Print out summary information after garbage collection.")    (XQP::TRACE.GC "[ Garbage Collection of the Heap Stack Finished ]" T T)    (XQP::RESET.GC.CURSOR)))(XQP::PRINT.POST.MARK.STATS  (LAMBDA (XQP::GARBAGECELLS)                                (* \; "Edited 11-Aug-87 10:48 by pds")(* |;;;| "Mark phase completed: print out info about marked cells <if tracing is verbose>.")    (LET ((XQP::HEAPSIZE (IQUOTIENT (XQP::\\BASEDIFFERENCE XQP::GC.HEAP.P XQP::GC.HEAP)                                2)))         (XQP::TRACE.GC "[ " XQP::|.I8| (ITIMES XQP::HEAPSIZE 4)                " : Heap Size in Bytes ]" T "[ " XQP::|.I8| (ITIMES (IDIFFERENCE XQP::HEAPSIZE                                                                            XQP::GARBAGECELLS)                                                                   4)                " : Accessible Heap in Bytes ]" T "[ " XQP::|.I8| (ITIMES XQP::GARBAGECELLS 4)                " : Inaccessible Heap in Bytes ]" T "[ " XQP::|.F7.1| (FTIMES (FQUOTIENT                                                                                     XQP::GARBAGECELLS                                                                                      XQP::HEAPSIZE)                                                                             100)                "% : Percent Garbage ]" T))))(XQP::PRINT.PRE.GC.TRACE.OPTIONS  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:48 by pds")(* |;;;| "Garbage collection is about to begin: print out message announcing this.")    (XQP::SET.GC.CURSOR)    (XQP::TRACE.GC "[ Garbage Collection of the Heap Stack Started ]" T)))(XQP::PROCESS.PERM.VARS  (LAMBDA (XQP::FUNCT XQP::PREVIOUS.ITEM E)                  (* \; "Edited 11-Aug-87 10:24 by pds")(* |;;;| "Brought over from the C code.  No longer needed.")    (PROG1 E (|for| E1 |from| E |to| (SUB1 XQP::PREVIOUS.ITEM) |do| (APPLY* XQP::FUNCT E1)))))(XQP::RESET.GC.CURSOR  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:25 by pds")(* |;;;| "Switch back to the cursor in use before garbage collection began.")    (SETCURSOR XQP::SAVED.CURSOR)))(XQP::SET.GC.CURSOR  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:25 by pds")(* |;;;| "Switch cursor to something indicating that Prolog garbage collection is in progress.")    (SETQ XQP::SAVED.CURSOR (CURSOR XQP::|PrologGCCursor|))))(XQP::UPDATE.STATS  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:25 by pds")(* |;;;| "Garbage collection has been completed: update variables that maintain info for statistics/2,0.")    (|add| XQP::GC.TIME (IDIFFERENCE (CLOCK 0)                               XQP::START.CPU.TIME))    (|add| XQP::GC.COUNT 1)    (|add| XQP::GC.FREED.HEAP.CELLS (IDIFFERENCE XQP::START.HEAP.SIZE (IQUOTIENT (                                                                                XQP::\\BASEDIFFERENCE                                                                                  (XQP::|get.24|                                                                                   H)                                                                                  XQP::GC.HEAP)                                                                             2)))))(XQP::|opcode.FROM.POINTER|  (LAMBDA (PTR)                                              (* \; "Edited 11-Aug-87 10:25 by pds")(* |;;;| "Returns the name of the Prolog instruction pointed to by PTR.")(* |;;;| "Not actually used by the garbage collector.")    (LET ((OPCODE (\\GETBASEBYTE PTR 0)))         (|if| (OR (EQ OPCODE (CONSTANT (XQP::OP.CODE 'XQP::|extend|)))                   (EQ OPCODE (CONSTANT (ADD1 (XQP::OP.CODE 'XQP::|extend|)))))             |then| (ELT OPCODE (IPLUS 256 (\\GETBASEBYTE PTR 1)))           |else| (ELT OPCODE OPCODE))))))(declare\: eval@compile (putprops xqp::b.of.b macro ((xqp::bptr)                             (progn (* |;;;| "Returns the B pointer from the choicepoint pointed to by BPTR.")                                    (\\getbaseptr xqp::bptr -8))))(putprops xqp::e.of.b macro ((xqp::bptr)                             (progn (* |;;;| "Returns the E pointer from the choicepoint pointed to by BPTR.")                                    (\\getbaseptr xqp::bptr -12))))(putprops xqp::h.of.b macro ((xqp::bptr)                             (progn (* |;;;| "Returns the H pointer from the choicepoint pointed to by BPTR.")                                    (\\getbaseptr xqp::bptr -2))))(putprops xqp::tr.of.b macro ((xqp::bptr)                              (progn (* |;;;| "Returns the TR pointer from the choicepoint pointed to by BPTR.")                                     (\\getbaseptr xqp::bptr -4))))(putprops xqp::h.of.b.ptr macro ((xqp::bptr)                                 (progn (* |;;;| "Returns a pointer to the H pointer field of the choicepoint pointed to by BPTR.")                                        (\\addbase xqp::bptr -2))))(putprops xqp::set.h.of.b macro ((xqp::bptr xqp::newh)                                 (progn (* |;;;| "Sets the H field of the choicepoint pointed to by BPTR to NEWH")                                        (\\putbaseptr xqp::bptr -2 xqp::newh)))))(declare\: eval@compile (putprops xqp::arity.from.pr macro (nil (progn (* |;;;| "Get the arity of the currently running procedure from the C register, which corresponds to PR in the usual Q Prolog machine.")                                               (|fetch| (xqp::procedure.record xqp::arity)                                                      |of|                                                      (xqp::|get.24| c)))))(putprops xqp::in.collectable.heap macro ((ptr)                                          (progn (* |;;;| "Returns T if PTR is in the collectable part of the heap.  I.e., between GC.HEAP.GC and GC.HEAP.P.")                                                 (and (not (\\baselessp ptr xqp::gc.heap.gc))                                                      (\\baselessp ptr xqp::gc.heap.p)))))(putprops xqp::in.heap macro ((ptr)                              (progn (* |;;;| "Returns T if PTR is in the heap.  I.e., between GC.HEAP and GC.HEAP.P.")                                     (and (not (\\baselessp ptr xqp::gc.heap))                                          (\\baselessp ptr xqp::gc.heap.p)))))(putprops xqp::pointer.in.range macro ((xqp::cellptr low high)                                       (progn (* |;;;| "Returns non-NIL iff CELLPTR is GEQ LOW and less than HIGH.")                                              (and (not (\\baselessp xqp::cellptr low))                                                   (\\baselessp xqp::cellptr high)))))(putprops xqp::trace.gc macro (forms (progn (* |;;;| "Form is: (TRACE.GC  FORMS...) If current gc tracing level is >= TRACELEVEL <which is evaluated at compile-time> printout FORMS...  The forms are given to PRINTOUT, so PRINTOUT-style formats will work.")                                            `(|if| (igreaterp xqp::gc.trace 0)                                                   |then|                                                   (printout (xqp::qio.stream xqp::standard.error)                                                          ,@forms)))))(putprops xqp::\\basedifference macro ((xqp::cell1 xqp::cell2)                                       (progn (* |;;;| "Returns the number of words between CELL2 and CELL1, as a number, not a pointer.")                                              (iplus (llsh (idifference (\\hiloc xqp::cell1)                                                                  (\\hiloc xqp::cell2))                                                           16)                                                     (\\loloc xqp::cell1)                                                     (minus (\\loloc xqp::cell2))))))(putprops xqp::\\clearbasebits macro ((base offset mask)                                      (progn (* |;;;| "Reset all the bits in the word refered to by BASE and OFFSET corresponding to 1 bits in MASK.")                                             (\\putbase base offset (logand (\\getbase base offset)                                                                           (lognot mask))))))(putprops xqp::\\setbasebits macro ((base offset mask)                                    (progn (* |;;;| "Set all the bits in the word refered to by BASE and OFFSET corresponding to 1 bits in MASK.")                                           (\\putbase base offset (logor (\\getbase base offset)                                                                         mask)))))(putprops xqp::\\testallbasebits macro ((base offset mask)                                        (progn (* |;;;| "Returns T iff ALL the bits in the word refered to by BASE and OFFSET corresponding to 1 bits in MASK are set.")                                               (eq mask (logand (\\getbase base offset)                                                               mask)))))(putprops xqp::\\testanybasebits macro ((base offset mask)                                        (progn (* |;;;| "Returns T iff ANY of the bits in the word refered to by BASE and OFFSET corresponding to 1 bits in MASK are set.")                                               (neq 0 (logand (\\getbase base offset)                                                             mask))))))(* |;;;| "The marker")(defineq(XQP::HEAP.TOP.DURING.UNIFICATION  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:25 by pds")(* |;;;| "During general unification, H points to the top of the PDL, not the top of the heap.  This function returns the real top of the heap in this case.")    (|bind| (I _ (XQP::|get.24| H)) |until| (EQ 0 (\\GETBASE I 5)) |do| (SETQ I (\\ADDBASE I -6))       |finally| (RETURN I))))(XQP::INITIALIZE.TRACE.STACK  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:25 by pds")    (SETQ XQP::GC.SAVED.TRACE.STACK.SEGMENTS (UNION XQP::GC.TRACE.STACK.SEGMENTS                                                     XQP::GC.SAVED.TRACE.STACK.SEGMENTS))    (|if| (AND (ARRAYP XQP::GC.TRACE.STACK)               (NOT (MEMB XQP::GC.TRACE.STACK XQP::GC.SAVED.TRACE.STACK.SEGMENTS)))        |then| (|push| XQP::GC.SAVED.TRACE.STACK.SEGMENTS XQP::GC.TRACE.STACK))    (SETQ XQP::GC.TRACE.STACK NIL)    (SETQ XQP::GC.TRACE.STACK.SEGMENTS NIL)    (SETQ XQP::GC.TRACE.STACK.PTR 65534)))(PEEK  (LAMBDA (I)                                                (* \; "Edited 11-Aug-87 10:26 by pds")(* |;;;| "Peek at element I (numbering from 0) of the GC trace stack.")    (LET ((BASE (|fetch| (ARRAYP BASE)                       XQP::GC.TRACE.STACK)))         (CONS (\\GETBASEBYTE BASE (ITIMES I 2))               (\\GETBASEPTR BASE (ITIMES I 2))))))(XQP::TRACE.AND.MARK  (LAMBDA (XQP::OVERFLOW.EVENT XQP::S.IS.ALIVE?)             (* \; "Edited 11-Aug-87 10:49 by pds")(* |;;;| "Trace and mark the heap, starting from all <live> cells in the local stack, trail, and argument registers that point into the heap.  This is the top level of the marker.")(* |;;;| "(bind (CNT _ 0) (TOP _ (\\ADDBASE GC.HEAP.P -2)) for I fromcell GC.HEAP.GC tocell TOP do (MARK.UNMARKED.CELL I CNT) finally (RETURN CNT))")    (LET ((XQP::START.TRACE.TIME (CLOCK 0)))         (PROG1 (IPLUS (|if| (OR (EQ XQP::OVERFLOW.EVENT 23)                                 (EQ XQP::OVERFLOW.EVENT 13))                           |then|                            (* \; "EV_OVHEAPUNIFY, but S is dead.")                                 (IPLUS (XQP::TRACE.AND.MARK.PDL)                                        (|if| XQP::S.IS.ALIVE?                                            |then|           (* \; "EV_OVHEAPUNIFY, and S is alive.")                                                  (XQP::TRACE.AND.MARK.FROM.S)                                          |else| 0))                         |elseif| (EQ XQP::OVERFLOW.EVENT 25)                           |then|                            (* \; "EV_OVHEAPPROLOGIFY")                                 (XQP::TRACE.AND.MARK.PROLOGIFIED.TERM)                         |else| 0)                       (XQP::TRACE.AND.MARK.LOCAL.STACK)                       (XQP::TRACE.AND.MARK.ARGUMENT.REGISTERS)                       (XQP::TRACE.AND.MARK.TRAIL.REFERENCES))                (XQP::TRACE.GC "[ " XQP::|.I8| (IDIFFERENCE (CLOCK 0)                                                      XQP::START.TRACE.TIME)                       " : Tracing and Marking Time in Milliseconds ]" T)))))(XQP::TRACE.AND.MARK.ARGUMENT.REGISTERS  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:39 by pds")(* |;;;| "Trace and mark all heap cells accessible from any <active> argument registers.")    (|for| CELL XQP::|fromcell| XQP::GC.A.REGS XQP::|tocell| XQP::GC.A.REGS.GC       |sum| (XQP::TRACE.PTR CELL))))(xqp::trace.and.mark.from.s  (lambda nil                                                (* \; "Edited 19-Oct-87 16:12 by pds")(* |;;;| "When garbage collecting during head unification, we must make sure that the term that we are unifying with is marked, where necessary.  The current Quintus compiler has a bug/feature/optimization  in its register allocation code that allows it to reuse an argument/temporary register as soon as the S register has been made to point to the arguments of the term or list it points to.  Therefore, it is possible that the only pointer to such a term will be from S.  This function ensures that in this case, the term is marked.  Actually, it is only necessary to trace and mark from the argument S points to, and those following it, since those preceeding it have already been unified, and so there will be other paths to them.  Returns the number of cells marked.")    (let* ((xqp::curr.s (xqp::|get.24| s))           (xqp::cells.to.functor (|bind| xqp::arity (xqp::cells.seen _ 0)                                         (bottom _ (\\addbase xqp::curr.s -512)) |for| i                                     xqp::|fromcell| (\\addbase xqp::curr.s -2) xqp::|downtocell|                                                                                bottom                                     |until| (and (eq (xqp::tag.sans.mark.bit (\\getbasebyte i 0))                                                      xqp::|symbol.tag.8|)                                                  (neq (setq xqp::arity (\\getbasebyte i 1))                                                       0)) |do| (|add| xqp::cells.seen 1)                                     |finally| (return (idifference xqp::arity xqp::cells.seen))))           (xqp::cells.to.mark (|if| (igreaterp xqp::cells.to.functor 0)                                   |then| xqp::cells.to.functor                                 |else|                      (* \; "it must be a list")                                       2)))          (xqp::if.debugging marker (printout t "tracing " xqp::cells.to.mark " cells from S" t))          (|bind| (total _ 0)                 (top _ (\\addbase xqp::curr.s (itimes (sub1 xqp::cells.to.mark)                                                      2))) |for| i xqp::|fromcell| xqp::curr.s             xqp::|tocell| top |do| (|add| total (xqp::trace.ptr i))                                    (|if| (not (xqp::is.marked i))                                        |then| (xqp::mark.unmarked.cell i total))             |finally| (return total)))))(XQP::TRACE.AND.MARK.LOCAL.STACK  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:39 by pds")(* |;;;| "Trace and mark all heap cells accessible from the local stack.")(* |;;;| "(bind (MARKCOUNT _ 0) for I fromcell GC.STACK.P downtocell GC.STACK.GC sum (TRACE I))")    (|bind| (B _ (XQP::|get.24| B))           (MARKCOUNT _ 0) |for| I XQP::|fromcell| (\\ADDBASE XQP::GC.STACK.P -2) XQP::|downtocell|                                                                                  XQP::GC.STACK.GC       |do| (|for| |old| I XQP::|downtocell| B |do| (|add| MARKCOUNT (XQP::TRACE.PTR I))) (* |;;;| "Skip over fixed part of choicepoint.  Fixed part of choicepoint is 7 cells, or 14 words.  However, inner for loop will leave I already decremented.  Also, outer for loop, due to the inadequacy of my tocell and downtocell clisp forms, will subtract another cell.  Therefore, this assignment needs to account for only 5 of those 7 cells.")            (SETQ I (\\ADDBASE I -10))            (SETQ B (XQP::B.OF.B B)) |finally| (RETURN MARKCOUNT))))(XQP::TRACE.AND.MARK.PDL  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:39 by pds")(* |;;;| "When garbage collecting during general unification, we must trace and mark the things referred to by the PDL.  For now, the easy way is to trace and mark the two things that were originally to be unified, which are stored in the bottom PDL frame.")    (IPLUS (XQP::TRACE.PTR XQP::GC.HEAP.P)           (XQP::TRACE.PTR (\\ADDBASE XQP::GC.HEAP.P 2))           (|bind| (TOTAL _ 0)                  (TOP _ (\\ADDBASE XQP::GC.HEAP.P.FOR.COMPACTION -2)) |for| I XQP::|fromcell|                                                                                      XQP::GC.HEAP.P              XQP::|tocell| TOP |do| (XQP::MARK.UNMARKED.CELL I TOTAL) |finally| (RETURN TOTAL)))))(XQP::TRACE.AND.MARK.PROLOGIFIED.TERM  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:29 by pds")(* |;;;| "If garbage collection happens during prologification, which it can, there may be many cells built on the heap with no references to them, waiting for upcoming unification instructions to bind them.  In this way, gc during prologification is much like gc during general unification.  In the case of prologification, though, we just want to mark all the cells between S and H.  What is on the heap there won't be a complete structure, so we don't want to trace it.")    (|bind| (TOTAL _ 0)           (TOP _ (\\ADDBASE (XQP::|get.24| H)                         -2))           (BOTTOM _ (XQP::|get.24| S)) |for| I XQP::|fromcell| BOTTOM XQP::|tocell| TOP       |do| (* |;;;| "First make sure any garbage pointers are cleared out.  This is important, as any uninitialized cells that happen to point into the part of the heap before S will cause death sometime down the road, after GC!")            (|if| (AND (XQP::IS.POINTER.TAG (\\GETBASEBYTE I 0))                       (NOT (LET ((PTR (\\GETBASEPTR I 0)))                                 (XQP::POINTER.IN.RANGE PTR BOTTOM TOP))))                |then| (\\PUTBASEPTR I 0 NIL)                      (\\PUTBASEBYTE I 0 XQP::|symbol.tag.8|))            (|if| (NOT (XQP::IS.MARKED I))                |then| (XQP::MARK.UNMARKED.CELL I TOTAL)) |finally| (RETURN TOTAL))))(XQP::TRACE.AND.MARK.TRAIL.REFERENCES  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:39 by pds")(* |;;;| "Trace and mark all heap cells accessible from the collectable part of the trail.  This only needs to be done if we are scanning less than the whole stack and heap.")    (|if| (OR (NEQ XQP::GC.HEAP.GC XQP::GC.HEAP)              (NEQ XQP::GC.STACK.GC XQP::GC.STACK))        |then| (|bind| XQP::TRAIL.REF |for| CELL XQP::|fromcell| XQP::GC.TRAIL.P XQP::|tocell|                                                                                      XQP::GC.TRAIL.GC                  |when| (OR (XQP::WITHIN.STACK.NON.GC (SETQ XQP::TRAIL.REF (\\GETBASEPTR CELL 0)))                             (XQP::WITHIN.HEAP.NON.GC XQP::TRAIL.REF)) |sum| (XQP::TRACE.PTR                                                                                     XQP::TRAIL.REF))      |else| 0)))(XQP::TRACE.PTR  (LAMBDA (XQP::TRACEFROM)                                   (* \; "Edited 11-Aug-87 10:06 by pds")(* |;;;| "Given TRACEFROM as a starting point, trace and mark all cells in the heap that are accessible from there.  Keeps track of the number of cells it marks, and returns the total.")(* |;;;| "The main loop maintains a pointer and a number of cells to trace starting from there and proceding sequentially.  Whenever the cell being examined is a pointer that must be followed (it is a variable, structure, or list pointer), the current pointer and count are pushed onto a stack maintained just for garbage collection, and the current pointer and count are reset to correspond to the variable, list cell, or structure.  If the examined cell is not a pointer, it is marked, and we examine the next cell.  If the count indicates that we've finished the current chunk, then we pop the stack.  Thus this is a left-to-right, depth first tracing algorithm.")(* |;;;| "some optimizations have been incorporated into the macros, most notably: if we go to push a pointer and count, and there are no more cells to examine after it, we push nothing.  This is tail recursion optimization, and means that, e.g., when tracing a flat list we consume no stack.")    (PROG (CONTENTS (TAG (\\GETBASEBYTE XQP::TRACEFROM 0))                 (XQP::CELLPTR XQP::TRACEFROM)                 (XQP::NUMCELLS 1)                 (MARKCOUNT 0))      LOOP          (* |;;;| "Invariant: If the cell pointed to by CELLPTR needs to be marked, it is.")(* |;;;| "Invariant: TAG is the tag byte (before being marked this iteration) of the cell pointed to by CELLPTR.")          (XQP::IF.DEBUGGING MARKER (XQP::STACK.WINDOW.SELECT XQP::CELLPTR))          (XQP::IF.DEBUGGING MARKER (BLOCK XQP::TRACEBLOCK))          (|if| (AND (XQP::IS.POINTER.TAG TAG)                     (NOT (XQP::TAG.IS.MARKED TAG))                     (NEQ XQP::CELLPTR (SETQ CONTENTS (\\GETBASEPTR XQP::CELLPTR 0))))              |then|              (|if| (XQP::IN.COLLECTABLE.HEAP CONTENTS)                  |then| (XQP::PUSH.TRACE.STACK XQP::NUMCELLS XQP::CELLPTR)                        (SETQ XQP::CELLPTR CONTENTS)                        (SELECTC TAG                            (XQP::|ref.tag.8|                                  (SETQ XQP::NUMCELLS 1))                            (XQP::|struct.tag.8|                                  (SETQ XQP::NUMCELLS (ADD1 (\\GETBASEBYTE XQP::CELLPTR 1)))                                 (XQP::IF.DEBUGGING                                  GC                                  (|if| (OR (NEQ (LOGAND (\\GETBASEBYTE XQP::CELLPTR 0)                                                        (CONSTANT (LOGNOT XQP::MARKBIT.MASK)))                                                 XQP::|symbol.tag.8|)                                            (ILESSP XQP::NUMCELLS 1))                                      |then| (PRINTOUT T "struct pointer not to functor."))))                            (XQP::|list.tag.8|                                  (SETQ XQP::NUMCELLS 2))                            (SHOULDNT 'XQP::TRACE.PTR))                        (SETQ TAG (\\GETBASEBYTE XQP::CELLPTR 0))                        (|if| (NOT (XQP::TAG.IS.MARKED TAG))                            |then| (XQP::MARK.UNMARKED.CELL XQP::CELLPTR MARKCOUNT)                                  (XQP::IF.DEBUGGING MARKER (XQP::STACK.WINDOW.REFRESH.ITEMS                                                                    XQP::CELLPTR)))                        (GO LOOP)                |else| (|if| (NOT (XQP::IN.HEAP CONTENTS))                           |then| (GO EXIT))))          (|if| (EQ 0 (XQP::|subtract| XQP::NUMCELLS 1))              |then| (|if| (NOT (XQP::POP.TRACE.STACK XQP::NUMCELLS XQP::CELLPTR))                         |then|                              (* \; "Stack is empty: we're done.")                               (GO EXIT))                    (XQP::IF.DEBUGGING MARKER (|if| (NOT (XQP::IN.COLLECTABLE.HEAP XQP::CELLPTR))                                                  |then| (BREAK1 NIL T)))            |else| (SETQ XQP::CELLPTR (\\ADDBASE XQP::CELLPTR 2))                  (|if| (NOT (XQP::\\BASELESSP XQP::CELLPTR XQP::GC.HEAP.P))                      |then| (XQP::IF.DEBUGGING MARKER (PRINTOUT T                                                               "Tracing past top of heap:  quitting" T                                                              ))                            (GO EXIT)))          (SETQ TAG (\\GETBASEBYTE XQP::CELLPTR 0))          (|if| (NOT (XQP::TAG.IS.MARKED TAG))              |then| (XQP::MARK.UNMARKED.CELL XQP::CELLPTR MARKCOUNT)                    (XQP::IF.DEBUGGING MARKER (XQP::STACK.WINDOW.REFRESH.ITEMS XQP::CELLPTR)))          (XQP::IF.DEBUGGING MARKER (LET ((X (|pop| XQP::STACK.WINDOWS.SELECTEDLABELS)))                                         (|if| X                                             |then| (XQP::STACK.WINDOW.INVERT.SELECTION (CAR X)                                                           (CDR X)                                                           'LABEL                                                           'NORMAL))))          (GO LOOP)      EXIT          (XQP::IF.DEBUGGING MARKER (LET ((X (|pop| XQP::STACK.WINDOWS.SELECTEDLABELS)))                                         (|if| X                                             |then| (XQP::STACK.WINDOW.INVERT.SELECTION (CAR X)                                                           (CDR X)                                                           'LABEL                                                           'NORMAL))))          (RETURN MARKCOUNT)))))(declare\: eval@compile (putprops xqp::is.marked macro ((xqp::cellptr)                                (progn (* |;;;| "Returns non-NIL if the cell pointed to by CELLPTR has been marked.")                                       (xqp::\\testanybasebits xqp::cellptr 0 xqp::markbit.mask.16)))       )(putprops xqp::is.pointer.tag macro ((tag)                                     (progn (* |;;;| "Returns T iff TAG is a pointer tag, i.e., a ref, struct, or list tag.")                                            (neq (logand tag 192)                                                 192))))(putprops xqp::mark.unmarked.cell macro ((cell markcount)                                         (progn (* |;;;| "Set the mark bit for CELL")                                                (xqp::\\setbasebits cell 0 xqp::markbit.mask.16)                                                (|add| markcount 1))))(putprops xqp::pop.trace.stack macro ((num ptr)                                      (progn (* |;;;| "Pop the top <NUM PTR> pair off the stack, placing them into NUM and PTR, which are side effected to hold the new values.  If the stack is empty, PTR becomes NIL, and NUM is undefined.")                                             (* |;;;| "See PUSH.TRACE.STACK for a description of the stack.")                                             (|if| xqp::gc.trace.stack |then|                                                   (let ((base (|fetch| (arrayp base)                                                                      |of| xqp::gc.trace.stack)))                                                        (|change| num (\\getbasebyte base                                                                             (itimes                                                                               xqp::gc.trace.stack.ptr                                                                                     2)))                                                        (|change| ptr (\\getbaseptr base                                                                              xqp::gc.trace.stack.ptr)                                                               ))                                                   (|if| (ilessp (xqp::|subtract|                                                                         xqp::gc.trace.stack.ptr 2)                                                                0)                                                         |then|                                                         (|push| xqp::gc.saved.trace.stack.segments                                                                 xqp::gc.trace.stack)                                                         (setq xqp::gc.trace.stack (|pop|                                                                          xqp::gc.trace.stack.segments                                                                                          ))                                                         (setq xqp::gc.trace.stack.ptr 65534))                                                   ptr))))(putprops xqp::push.trace.stack macro       ((num ptr)        (progn (* |;;;| "Push the element <NUM-1, PTR+1cell> onto the GC trace stack.  Nothing is pushed if NUM <= 1, since when popped, it would be ignored anyway.  After this operation, NUM and PTR are unchanged.  Returns non-NIL if something is pushed.")               (* |;;;| "The stack is represented as several of arrays of 32768 cells, each cell holding a pointer in the low 24 bits, and a count in the high 8 bits.  There is a current array, GC.STACK, and a stack pointer, GC.STACK.PTR, refering to the top of the stack.  GC.STACK.PTR is an integer.  When the GC.STACK fills up, it is saved on a list of stack segments, GC.STACK.SEGMENTS, and GC.STACK becomes a new, empty stack segment.  GC.SAVED.STACK.SEGMENTS is a list of 32768-element arrays that can be reused as stack segments;  if GC.SAVED.STACK.SEGMENTS is not empty, one of its stack segments is reused, if not, a new segment is allocated.  When popping <NUM PTR> pairs off the stack, empty segments are saved back on GC.SAVED.STACK.SEGMENTS.")               (|if| (igreaterp num 1)                     |then|                     (|if| (igreaterp (|add| xqp::gc.trace.stack.ptr 2)                                  65535)                           |then|                           (|push| xqp::gc.trace.stack.segments xqp::gc.trace.stack)                           (setq xqp::gc.trace.stack (|pop| xqp::gc.saved.trace.stack.segments))                           (setq xqp::gc.trace.stack.ptr 0)                           (|if| (null xqp::gc.trace.stack)                                 |then|                                 (setq xqp::gc.trace.stack (array 32768 '(bits 32) nil 0))))                     (let ((base (|fetch| (arrayp base)                                        |of| xqp::gc.trace.stack)))                          (\\putbaseptr base xqp::gc.trace.stack.ptr (\\addbase ptr 2))                                                             (* \;                   "Must do \\PUTBASEBYTE after \\PUTBASEPTR, since \\PUTBASEPTR changes all 32 bits.")                          (\\putbasebyte base (itimes xqp::gc.trace.stack.ptr 2)                                 (sub1 num)))))))(putprops xqp::tag.is.marked macro ((tag)                                    (progn (* |;;;| "Given a TAG as an integer, return non-NIL iff its mark bit is set")                                           (bittest tag xqp::markbit.mask))))(putprops xqp::tag.marked.as macro ((tag xqp::tag.to.copy.from)                                    (progn (* |;;;| "Returns TAG with the mark bit set or cleared, just as in TAG.TO.COPY.FROM.  I.e., copies the mark bit from TAG TAG.TO.COPY.FROM.")                                           (logor (xqp::tag.sans.mark.bit tag)                                                  (logand xqp::tag.to.copy.from xqp::markbit.mask))))       )(putprops xqp::tag.sans.mark.bit macro ((tag)                                        (progn (* |;;;| "Returns TAG with the mark bit masked off")                                               (logand tag (constant (lognot xqp::markbit.mask))))))(putprops xqp::tag.with.mark.bit macro ((tag)                                        (progn (* |;;;| "Returns TAG with the mark bit set.")                                               (logor tag xqp::markbit.mask))))(putprops xqp::within.heap.non.gc macro ((ptr)                                         (progn (* |;;;| "Returns non-NIL iff PTR is within the GC-able part of the heap.")                                                (xqp::pointer.in.range ptr xqp::gc.heap                                                        xqp::gc.heap.gc))))(putprops xqp::within.stack.non.gc macro ((ptr)                                          (progn (* |;;;| "Returns non-NIL iff PTR is within the non-GC-able part of the local stack.")                                                 (xqp::pointer.in.range ptr xqp::gc.stack                                                         xqp::gc.stack.gc)))))(* |;;;| "The compactor")(defineq(XQP::COLLECT.THE.GARBAGE  (LAMBDA (XQP::GARBAGECELLS XQP::OVERFLOW.EVENT XQP::S.IS.ALIVE?)                                                             (* \; "Edited 11-Aug-87 10:49 by pds")(* |;;;| "This is the top level of the compactor.  GARBAGECELLS is the count of inaccessible cells, which are to be compressed out.  This is an adaptation of the Morris algorithm published in CACM vol.  21 no.  8, August 1978, pp 662-5.")    (LET ((STARTTIME (CLOCK 0)))         (XQP::IF.DEBUGGING XQP::COMPACTOR (XQP::TRACE.GC "Compacting from " XQP::GC.HEAP.GC " to "                                                   XQP::GC.HEAP.P.FOR.COMPACTION ", "                                                   XQP::GARBAGECELLS " cells garbage" T                                                   "Sweeping trail pointers" T))         (XQP::REVERSE.TRAIL.STACK.POINTERS)         (XQP::IF.DEBUGGING XQP::COMPACTOR (XQP::TRACE.GC "Sweeping argument registers" T))         (XQP::REVERSE.ARGUMENT.REGISTERS)         (XQP::IF.DEBUGGING XQP::COMPACTOR (XQP::TRACE.GC "Sweeping local stack pointers" T))         (XQP::REVERSE.LOCAL.STACK.POINTERS)         (|if| XQP::S.IS.ALIVE?             |then|                                          (* \;                                                        "Must make sure S register gets updated, too.")                   (|if| (NOT (XQP::IS.MARKED (XQP::|get.24| S)))                       |then| (SHOULDNT "S register not properly traced"))                   (XQP::REVERSE.POINTER XQP::S.REGISTER.MEMORY.LOCATION))         (|if| (EQ XQP::OVERFLOW.EVENT 23)             |then|                                          (* \; "EV_OVHEAPUNIFY")                   (XQP::REVERSE.POINTER XQP::T0.REGISTER.MEMORY.LOCATION)                   (XQP::REVERSE.POINTER XQP::T1.REGISTER.MEMORY.LOCATION)                   (XQP::REVERSE.POINTER XQP::C.REGISTER.MEMORY.LOCATION)                   (XQP::REVERSE.POINTER XQP::R.REGISTER.MEMORY.LOCATION))         (XQP::COLLECTOR.DOWNSWEEP XQP::GARBAGECELLS)         (XQP::COLLECTOR.UPSWEEP XQP::GARBAGECELLS)         (XQP::TRACE.GC "[ " XQP::|.I8| (IDIFFERENCE (CLOCK 0)                                               STARTTIME)                " : Compacting and Relocating Time in Milliseconds ]" T))))(XQP::COLLECTOR.DOWNSWEEP  (LAMBDA (XQP::GARBAGECELLS)                                (* \; "Edited 11-Aug-87 11:25 by pds")(* |;;;| "Sweep updating downwards pointers and those from the outside")    (XQP::IF.DEBUGGING XQP::COLLECTOR (XQP::TRACE.GC "Starting down sweep." T))    (XQP::IF.DEBUGGING XQP::DOWNSWEEP (XQP::STACK.WINDOW.SELECT (XQP::|get.24| B))           (BLOCK XQP::TRACEBLOCK))    (|bind| (I _ (\\ADDBASE XQP::GC.HEAP.P.FOR.COMPACTION -2))           (B _ (XQP::|get.24| B))           (N _ (\\ADDBASE XQP::GC.HEAP.P.FOR.COMPACTION (MINUS (ITIMES XQP::GARBAGECELLS 2))))           M |while| (XQP::\\BASELESSP XQP::GC.HEAP.GC I)       |do| (|while| (AND (XQP::\\BASELESSP XQP::GC.STACK.GC B)                          (NEQ XQP::GC.HEAP.P.FOR.COMPACTION (SETQ M (XQP::H.OF.B B)))                          (NOT (XQP::POINTER.IN.RANGE M XQP::GC.HEAP.GC XQP::GC.HEAP.P.FOR.COMPACTION                                      )))               |do| (XQP::IF.DEBUGGING GC (|if| (NOT (XQP::POINTER.IN.RANGE (XQP::B.OF.B B)                                                            XQP::GC.STACK.GC XQP::GC.STACK.P))                                              |then| (BREAK1 5 T 5)))                    (SETQ B (XQP::B.OF.B B))                    (XQP::IF.DEBUGGING GC (|if| (AND (XQP::POINTER.IN.RANGE (XQP::H.OF.B B)                                                            XQP::GC.HEAP.GC XQP::GC.HEAP.P)                                                     (NOT (XQP::POINTER.IN.RANGE (XQP::H.OF.B B)                                                                 XQP::GC.HEAP.GC XQP::GC.HEAP.P)))                                              |then| (BREAK1 6 T 6)))                    (XQP::IF.DEBUGGING XQP::DOWNSWEEP (XQP::STACK.WINDOW.POP.SELECTION)                           (XQP::STACK.WINDOW.SELECT B)                           (BLOCK XQP::TRACEBLOCK)) |finally| (|if| (NOT (XQP::\\BASELESSP                                                                                 XQP::GC.STACK.GC B))                                                                  |then| (SETQ M XQP::GC.HEAP.GC)))            (XQP::IF.DEBUGGING XQP::DOWNSWEEP (XQP::STACK.WINDOW.POP.SELECTION)                   (XQP::STACK.WINDOW.SELECT M)                   (BLOCK 5000)                   (XQP::STACK.WINDOW.POP.SELECTION))            (|bind| J XQP::JTAG K |for| |old| I XQP::|downtocell| M |when| (XQP::IS.MARKED I)               |do| (XQP::IF.DEBUGGING XQP::DOWNSWEEP (XQP::STACK.WINDOW.SELECT I))                    (SETQ N (\\ADDBASE N -2))                    (SETQ J (\\GETBASEPTR I 0))                    (SETQ XQP::JTAG (\\GETBASEBYTE I 0))                    (|if| (REVERSED.POINTERP J XQP::JTAG)                        |then|                               (* \; "update pointers to I")                              (|bind| XQP::NEXTJ XQP::NEXTJTAG                                 |do| (* |;;;| "This loop is a bit different than the corresponding C code for the mainline system.  It has been optimized not to do unnecessary memory accesses.  What it does is to follow the chain of reversed pointers making each point to the new, post-gc location of cell I.  Finally, the end of the list is an unreversed cell which is stored back in cell I.")                                      (SETQ K (XQP::UNMARK.AS.REVERSED J))                                      (XQP::IF.DEBUGGING GC (|if| (NOT (XQP::POINTER.IN.RANGE K                                                                               XQP::|membot|                                                                               XQP::|memtop|))                                                                |then| (BREAK1 8 T 8)))                                      (SETQ XQP::NEXTJ (\\GETBASEPTR K 0))                                      (SETQ XQP::NEXTJTAG (\\GETBASEBYTE K 0))                                      (\\PUTBASEPTR K 0 N)                                      (\\PUTBASEBYTE K 0 (XQP::TAG.MARKED.AS XQP::JTAG XQP::NEXTJTAG)                                             )                                      (SETQ J XQP::NEXTJ)                                      (SETQ XQP::JTAG XQP::NEXTJTAG)                                      (XQP::IF.DEBUGGING XQP::DOWNSWEEP (                                                                      XQP::STACK.WINDOW.REFRESH.ITEMS                                                                         K)                                             (BLOCK XQP::TRACEBLOCK)) |repeatwhile| (                                                                                    REVERSED.POINTERP                                                                                     J XQP::JTAG)                                 |finally| (\\PUTBASEPTR I 0 J)                                       (\\PUTBASEBYTE I 0 (XQP::TAG.WITH.MARK.BIT XQP::JTAG))                                       (XQP::IF.DEBUGGING XQP::DOWNSWEEP (                                                                      XQP::STACK.WINDOW.REFRESH.ITEMS                                                                          I)                                              (BLOCK XQP::TRACEBLOCK))))                    (|if| (XQP::VALID.POINTER J XQP::JTAG XQP::GC.HEAP.GC I)                        |then|                               (* \; "J is a down pointer: reverse it.")                              (XQP::IF.DEBUGGING GC (|if| (EQ (\\GETBASEPTR J 0)                                                              (CONSTANT (\\VAG2 255 65535)))                                                        |then| (BREAK1 11 T 11)))                              (\\PUTBASEPTR I 0 (\\GETBASEPTR J 0))                              (\\PUTBASEBYTE I 0 (XQP::TAG.WITH.MARK.BIT (\\GETBASEBYTE J 0)))                              (\\PUTBASEPTR J 0 (XQP::MARK.AS.REVERSED I))                              (\\PUTBASEBYTE J 0 (XQP::TAG.WITH.MARK.BIT XQP::JTAG))                                                              (* \;                             "before reversing, I was marked, and pointed to J, so J was marked, too.")                              (XQP::IF.DEBUGGING XQP::DOWNSWEEP (XQP::STACK.WINDOW.REFRESH.ITEMS                                                                 I)                                     (XQP::STACK.WINDOW.REFRESH.ITEMS J)                                     (BLOCK XQP::TRACEBLOCK)))                    (XQP::IF.DEBUGGING XQP::DOWNSWEEP (XQP::STACK.WINDOW.POP.SELECTION)))            (XQP::IF.DEBUGGING GC (|if| (AND (XQP::\\BASELESSP XQP::GC.STACK.GC B)                                             (NOT (XQP::POINTER.IN.RANGE (XQP::B.OF.B B)                                                         XQP::GC.STACK XQP::GC.STACK.P)))                                      |then| (BREAK1 4 T 4)))            (|if| (XQP::\\BASELESSP XQP::GC.STACK.GC B)                |then| (XQP::SET.H.OF.B B N)                      (SETQ B (XQP::B.OF.B B))))))(XQP::COLLECTOR.UPSWEEP  (LAMBDA (XQP::GARBAGECELLS)                                (* \; "Edited 11-Aug-87 11:26 by pds")(* |;;;| "Sweep updating upwards and self pointers and compacting")    (XQP::IF.DEBUGGING XQP::COLLECTOR (XQP::TRACE.GC "Unreversed backtrack heap pointers relocated."                                              T "Starting up sweep." T))    (|bind| (N _ XQP::GC.HEAP.GC)           J XQP::JTAG K XQP::TEMPJ XQP::TEMPJTAG |for| I XQP::|fromcell| XQP::GC.HEAP.GC       XQP::|tocell| XQP::GC.HEAP.P.FOR.COMPACTION |when| (XQP::IS.MARKED I)       |do| (* |;;;| "J and JTAG hold what should be in the cell pointed to by I.  Ultimately, however, we don't care what is in I, since it's contents will be copied to the cell pointed to by N, and then will be either overwritten later, or beyond the top of the new <collected> heap.  Therefore, we never need to write J and JTAG into the cell pointed to by I.")            (SETQ J (\\GETBASEPTR I 0))            (SETQ XQP::JTAG (\\GETBASEBYTE I 0))            (XQP::IF.DEBUGGING XQP::UPSWEEP (XQP::STACK.WINDOW.SELECT I)                   (BLOCK XQP::TRACEBLOCK))            (|while| (REVERSED.POINTERP J XQP::JTAG) |do| (SETQ K (XQP::UNMARK.AS.REVERSED J))                                                          (SETQ J (\\GETBASEPTR K 0))                                                          (SETQ XQP::TEMPJTAG (\\GETBASEBYTE K 0))                                                          (\\PUTBASEPTR K 0 N)                                                          (\\PUTBASEBYTE K 0 (XQP::TAG.MARKED.AS                                                                              XQP::JTAG XQP::TEMPJTAG                                                                              ))                                                              (* \; "K is marked iff it was before.")                                                          (SETQ XQP::JTAG XQP::TEMPJTAG)                                                          (XQP::IF.DEBUGGING XQP::UPSWEEP                                                                 (XQP::STACK.WINDOW.REFRESH.ITEMS                                                                  K)                                                                 (BLOCK XQP::TRACEBLOCK)))            (|if| (XQP::VALID.POINTER J XQP::JTAG I XQP::GC.HEAP.P.FOR.COMPACTION)                |then| (|if| (EQ I J)                           |then| (SETQ J N)                         |else| (SETQ XQP::TEMPJ (\\GETBASEPTR J 0))                               (SETQ XQP::TEMPJTAG (\\GETBASEBYTE J 0))                               (\\PUTBASEPTR J 0 (XQP::MARK.AS.REVERSED N))                               (\\PUTBASEBYTE J 0 (XQP::TAG.WITH.MARK.BIT XQP::JTAG))                                                              (* \;                                      "J better have been marked, else we wouldn't be pointing to it.")                               (XQP::IF.DEBUGGING XQP::UPSWEEP (XQP::STACK.WINDOW.REFRESH.ITEMS                                                                J))                               (SETQ J XQP::TEMPJ)                               (SETQ XQP::JTAG XQP::TEMPJTAG)))            (\\PUTBASEPTR N 0 J)            (\\PUTBASEBYTE N 0 (XQP::TAG.SANS.MARK.BIT XQP::JTAG))            (XQP::IF.DEBUGGING XQP::UPSWEEP (XQP::STACK.WINDOW.POP.SELECTION)                   (XQP::STACK.WINDOW.SELECT N)                   (XQP::STACK.WINDOW.REFRESH.ITEMS N)                   (BLOCK XQP::TRACEBLOCK)                   (XQP::STACK.WINDOW.POP.SELECTION))            (SETQ N (\\ADDBASE N 2)))))(XQP::REVERSE.ARGUMENT.REGISTERS  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:32 by pds")(* |;;;| "The initial phase of the garbage compactor is to reverse all pointers into the heap from outside.  This function reverses pointers from the argument registers.")    (|for| XQP::ARGREG XQP::|fromcell| XQP::GC.A.REGS XQP::|tocell| XQP::GC.A.REGS.GC       |do| (XQP::REVERSE.POINTER XQP::ARGREG))))(XQP::REVERSE.LOCAL.STACK.POINTERS  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:32 by pds")(* |;;;| "The initial phase of the garbage compactor is to reverse all pointers into the heap from outside.  This function reverses pointers from the local stack.")(* |;;;| "(bind (B _ (get.24 B)) PTR.TO.H.SLOT first (SETQ PTR.TO.H.SLOT (H.OF.B.PTR B)) for I fromcell GC.STACK.P downtocell GC.STACK do (if (EQ I PTR.TO.H.SLOT) then (SETQ B (B.OF.B B)) (SETQ PTR.TO.H.SLOT (H.OF.B B)) else (REVERSE.POINTER I)))")    (|bind| (B _ (XQP::|get.24| B)) |for| I XQP::|fromcell| (\\ADDBASE XQP::GC.STACK.P -2)       XQP::|downtocell| XQP::GC.STACK.GC |do| (|for| |old| I XQP::|downtocell| B                                                  |do| (XQP::REVERSE.POINTER I)) (* |;;;| "Skip over fixed part of choicepoint.  Fixed part of choicepoint is 7 cells, or 14 words.  However, inner for loop will leave I already decremented.  Also, outer for loop, due to the inadequacy of my tocell and downtocell clisp forms, will subtract another cell.  Therefore, this assignment needs to account for only 5 of those 7 cells.")                                               (SETQ I (\\ADDBASE I -10))                                               (SETQ B (XQP::B.OF.B B)))))(XQP::REVERSE.TRAIL.STACK.POINTERS  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:32 by pds")(* |;;;| "The initial phase of the garbage compactor is to reverse all pointers into the heap from outside.  This function reverses pointers from the trail.")    (|bind| XQP::TRAILREF |for| PTR XQP::|fromcell| XQP::GC.TRAIL.P XQP::|tocell| XQP::GC.TRAIL       |do| (SETQ XQP::TRAILREF (\\GETBASEPTR PTR 0))            (|if| (OR (XQP::WITHIN.STACK.NON.GC XQP::TRAILREF)                      (XQP::WITHIN.HEAP.NON.GC XQP::TRAILREF))                |then| (XQP::REVERSE.POINTER XQP::TRAILREF)              |elseif| (XQP::IS.MARKED XQP::TRAILREF)                |then| (XQP::REVERSE.POINTER PTR)              |elseif| (XQP::IN.HEAP XQP::TRAILREF)                |then| (* |;;;| "This is a garbage trail pointer, a pointer to a dead heap cell.  If we leave it, later failure might try to reset something it shouldn't.  We could mark the cell we point to, and not collect it, but it is just as easy, and saves space, to make the trail element point to a cell that can be reset without problems: itself.")                      (\\PUTBASEPTR PTR 0 PTR)))))(XQP::UPDATE.REGISTERS.AFTER.GC  (LAMBDA (XQP::GARBAGECELLS XQP::OVERFLOW.EVENT XQP::S.IS.ALIVE?)                                                             (* \; "Edited 11-Aug-87 10:33 by pds")    (DECLARE (GLOBALVARS XQP::|prologify.baseptr|))    (XQP::|put.Aval| 1 (XQP::|get.Amem| 1))    (XQP::|put.Aval| 2 (XQP::|get.Amem| 2))    (XQP::|put.Aval| 3 (XQP::|get.Amem| 3))    (XQP::|put.Aval| 4 (XQP::|get.Amem| 4))    (XQP::IF.DEBUGGING XQP::COLLECTOR (PRINTOUT T "restored A1-4" T))    (LET* ((H (XQP::|get.24| H))           (XQP::NEWH (\\ADDBASE H (MINUS (ITIMES XQP::GARBAGECELLS 2)))))          (XQP::IF.DEBUGGING XQP::COLLECTOR (PRINTOUT T "H=" H T "NEWH=" XQP::NEWH T))          (XQP::|put.24| H XQP::NEWH)          (XQP::|put.24| XQP::HB (XQP::H.OF.B (XQP::|get.24| B)))          (|if| XQP::S.IS.ALIVE?              |then| (XQP::|put.24| S (\\GETBASEPTR XQP::S.REGISTER.MEMORY.LOCATION 0)))          (|if| (EQ XQP::OVERFLOW.EVENT 23)              |then|                                         (* \; "EV_OVHEAPUNIFY")                    (XQP::|WritePrologTagAndPtr| XQP::T0 (\\GETBASEBYTE                                                                 XQP::T0.REGISTER.MEMORY.LOCATION 0)                           (\\GETBASEPTR XQP::T0.REGISTER.MEMORY.LOCATION 0))                    (XQP::|WritePrologTagAndPtr| T1 (\\GETBASEBYTE XQP::T1.REGISTER.MEMORY.LOCATION 0                                                           )                           (\\GETBASEPTR XQP::T1.REGISTER.MEMORY.LOCATION 0))                    (XQP::|put.24| C (\\GETBASEPTR XQP::C.REGISTER.MEMORY.LOCATION 0))                    (XQP::|put.24| R (\\GETBASEPTR XQP::R.REGISTER.MEMORY.LOCATION 0))            |elseif| (EQ XQP::OVERFLOW.EVENT 25)              |then|                                         (* \; "EV_OVHEAPPROLOGIFY")                    (SETQ XQP::|prologify.baseptr| (\\ADDBASE XQP::|prologify.baseptr|                                                          (ITIMES (MINUS XQP::GARBAGECELLS)                                                                 2))))          (XQP::IF.DEBUGGING XQP::COLLECTOR (PRINTOUT T "saved new H in H" T))          (XQP::IF.DEBUGGING GC (|for| I XQP::|fromcell| (|if| (OR (EQ XQP::OVERFLOW.EVENT 23)                                                                   (EQ XQP::OVERFLOW.EVENT 13))                                                             |then| (\\ADDBASE XQP::NEWH 6)                                                           |else| XQP::NEWH) XQP::|tocell| H                                   |do| (\\PUTBASEPTR I 0 (CONSTANT (\\VAG2 255 65533)))))))))(declare\: eval@compile (putprops xqp::reverse.pointer macro ((cell)                                      (progn (* |;;;| "CELL is a pointer to a cell in Prolog memory.  If that cell points to another Prolog memory cell, make the destination cell point to the source cell, and the source cell have the old contents of the destination cell.  Note that the <old> destination cell's pointer to the <old> source cell is marked as having been reversed. ")                                             (* |;;;| "NB: this macro assumes that the cell pointed to by CELL is unmarked.  This will always be the case for pointers from outside the heap.  Therefore, this macro should only be used to reverse pointers into the heap from OUTSIDE.")                                             (let* ((xqp::cellptr (\\getbaseptr cell 0))                                                    (xqp::celltag (\\getbasebyte cell 0)))                                                   (* |;;;| "(if (TAG.IS.MARKED CELLTAG) then (SHOULDNT 'reversing internal pointer')) (if (AND (VALID.POINTER CELLPTR CELLTAG GC.HEAP GC.HEAP.P.FOR.COMPACTION) (NOT (IS.MARKED CELLPTR))) then (SHOULDNT 'trying to reverse unmarked pointer'))")                                                   (|if| (and (xqp::valid.pointer xqp::cellptr                                                                      xqp::celltag xqp::gc.heap.gc                                                                      xqp::gc.heap.p.for.compaction)                                                              (xqp::is.marked xqp::cellptr))                                                         |then|                                                         (\\putbaseptr cell 0 (\\getbaseptr                                                                                      xqp::cellptr 0))                                                         (\\putbasebyte cell 0                                                                (xqp::tag.sans.mark.bit (                                                                                        \\getbasebyte                                                                                         xqp::cellptr                                                                                          0)))                                                         (\\putbaseptr xqp::cellptr 0 (                                                                                xqp::mark.as.reversed                                                                                       cell))                                                         (\\putbasebyte xqp::cellptr 0 (                                                                               xqp::tag.with.mark.bit                                                                                        xqp::celltag)                                                                ))))))(putprops reversed.pointerp macro (args (let ((ptr (car args))                                              (tag (cadr args)))                                             (* |;;;| "Returns non-NIL iff PTR (and TAG, if it is supplied) comprise a cell that is a reversed pointer.")                                             (|if| tag |then|                                                   `(and (ileq ,tag (constant (xqp::tag.with.mark.bit                                                                               xqp::|list.tag.8|)))                                                         (oddp (\\loloc ,ptr))) |else|                                                   `(oddp (\\loloc ,ptr))))))(putprops xqp::mark.as.reversed macro ((cell)                                       (progn (* |;;;| "Returns CELL, a pointer into the Prolog stacks, marked as being reversed.  This is done by making it odd.  Pointers to any point in Prolog memory should always be even, so an odd pointer is always known to be reversed.")                                              (\\addbase cell 1))))(putprops xqp::unmark.as.reversed macro ((cell)                                         (progn (* |;;;| "Returns CELL, a pointer into the Prolog stacks which is marked as being reversed, marked as NOT being reversed.  This is done by making it even.  Pointers to any point in Prolog memory should always be even, so an odd pointer is always known to be reversed.")                                                (\\addbase cell -1))))(putprops xqp::valid.pointer macro ((xqp::cellptr xqp::celltag low high)                                    (progn (* |;;;| "Returns non-NIL iff CELLPTR and CELLTAG comprise a cell that is a pointer pointing between LOW and HIGH.")                                           (and (ileq xqp::celltag (constant (xqp::tag.with.mark.bit                                                                              xqp::|list.tag.8|)))                                                (xqp::pointer.in.range xqp::cellptr low high))))))(* |;;;| "Constants and variables")(declare\: eval@compile (rpaqq xqp::markbit.mask 4)(rpaqq xqp::markbit.mask.16 1024)(constants (xqp::markbit.mask 4)       (xqp::markbit.mask.16 1024)))(declare\: eval@load dontcopy (rpaq xqp::s.register.memory.location (\\addbase xqp::|membot| 512))(rpaq xqp::t0.register.memory.location (\\addbase xqp::s.register.memory.location 2))(rpaq xqp::t1.register.memory.location (\\addbase xqp::t0.register.memory.location 2))(rpaq xqp::c.register.memory.location (\\addbase xqp::t1.register.memory.location 2))(rpaq xqp::r.register.memory.location (\\addbase xqp::c.register.memory.location 2)))(declare\: doeval@compile dontcopy(globalvars xqp::s.register.memory.location xqp::t0.register.memory.location        xqp::t1.register.memory.location xqp::c.register.memory.location        xqp::r.register.memory.location))(rpaqq xqp::debuggable nil)(rpaqq xqp::debugging nil)(rpaq? xqp::gc.trace 0)(rpaq? xqp::gc.cursor.mask 65295)(rpaq? xqp::gc.saved.trace.stack.segments nil)(rpaq? xqp::gc.trace.stack nil)(rpaq? xqp::gc.trace.stack.ptr 65536)(rpaq? xqp::gc.trace.stack.segments nil)(declare\: doeval@compile dontcopy(globalvars xqp::debuggable xqp::debugging xqp::gc.trace xqp::gc.cursor.mask        xqp::gc.saved.trace.stack.segments xqp::gc.trace.stack xqp::gc.trace.stack.ptr        xqp::gc.trace.stack.segments))(rpaq xqp::|PrologGCCursor| (cursorcreate (quote #*(16 16)CLALFFCFDCFCLADAH@D@H@D@H@D@H@D@HOD@HAD@LCDADBFCFFCFCLAL@@@@@@@@) (quote nil) 8 8))(declare\: doeval@compile dontcopy(globalvars xqp::gc.enabled xqp::gc.incremental xqp::gc.minimum.heap xqp::gc.margin))(rpaq? xqp::gc.collection.threshold 1000)(rpaq? xqp::gc.count nil)(rpaq? xqp::gc.freed.heap.cells nil)(rpaq? xqp::gc.time nil)(rpaq? xqp::gc.trail.gc nil)(declare\: doeval@compile dontcopy(globalvars xqp::gc.collection.threshold xqp::gc.count xqp::gc.freed.heap.cells xqp::gc.time        xqp::gc.trail.gc xqp::trail.gc xqp::traceblock))(declare\: doeval@compile dontcopy(globalvars xqp::gc.heap xqp::gc.heap.gc xqp::gc.heap.p xqp::gc.heap.p.for.compaction xqp::gc.trail.p        xqp::gc.trail xqp::gc.trail.gc xqp::gc.stack xqp::gc.stack.gc xqp::gc.stack.p xqp::gc.a.regs        xqp::gc.a.regs.gc xqp::gc.a.regs.p))(* |;;;| "Stuff to make Interlisp more hospitable to operations on the Prolog memory.")(declare\: eval@compile (i.s.opr 'xqp::|fromcell| nil '(first (setq i.v. body)))(i.s.opr 'xqp::|tocell| nil '(until (\\baselessp body i.v.)                                    by                                    (\\addbase i.v. 2)))(i.s.opr 'xqp::|downtocell| nil '(until (\\baselessp i.v. body)                                        by                                        (\\addbase i.v. -2))))(putprops xqp::fromcell clispword (forword . xqp::|fromcell|))(putprops xqp::tocell clispword (forword . xqp::|tocell|))(putprops xqp::downtocell clispword (forword . xqp::|downtocell|))(putprops xqp::|subtract| clispword (changetran . xqp::|subtract|))(putprops xqp::|subtract| changeword (lambda (form)                                            `(datum_ (difference datum (plus ,@(cddr form))))))(putprops subtract clispword (changetran . xqp::|subtract|))(* \; "Finally: do the initialization.")(xqp::init.gc)(* |;;;| "Debugging stuff")(defineq(XQP::ALTERNATIVES  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:33 by pds")(* |;;;| "Returns a list of clause pointers for current alternative clauses.")    (|bind| (B _ (XQP::|get.24| B)) |while| (XQP::\\BASELESSP XQP::|init.E| B)       |collect| (PROG1 (\\GETBASEPTR B -6)                        (SETQ B (\\GETBASEPTR B -8))))))(XQP::CLEARMEM  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:34 by pds")(* |;;;| "Clear out a bunch of  Prolog memory at the bottom of the stack and heap")    (|for| I |from| 1 |to| 2000 |as| PTR XQP::|fromcell| XQP::|membot| |by| (\\ADDBASE PTR 2)       |do| (\\PUTBASEPTR PTR 0 NIL))    (|for| I |from| 1 |to| 2000 |as| PTR XQP::|fromcell| (\\ADDBASE XQP::|init.E| -200)       |by| (\\ADDBASE PTR 2) |do| (\\PUTBASEPTR PTR 0 NIL))))(XQP::MARKED.CELLS  (LAMBDA (FROMPTR)                                          (* \; "Edited 11-Aug-87 10:34 by pds")    (|for| I XQP::|fromcell| FROMPTR XQP::|tocell| XQP::GC.HEAP.P |when| (XQP::IS.MARKED I)       |collect| I)))(MICROCODE  (LAMBDA (XQP::ON?)                                         (* \; "Edited 11-Aug-87 10:34 by pds")(* |;;;| "if ON?  is non-NIL then turn microcode on, else turn it off.")    (DECLARE (GLOBALVARS PROLOG.ENABLE.PUFN.TABLE))    (|bind| (STATE _ (|if| XQP::ON?                         |then| 1                       |else| 0)) |for| I |from| 0 |to| 255 |do| (SETA PROLOG.ENABLE.PUFN.TABLE I                                                                        STATE))    (|if| XQP::ON?        |then| 'ON      |else| 'OFF)))(XQP::CURRENT.INSTR  (LAMBDA NIL                                                (* \; "Edited 11-Aug-87 10:35 by pds")    (ELT XQP::|opcode| (\\GETBASEBYTE (XQP::|get.24| P)                              -2))))(XQP::FIND.REFS  (LAMBDA (ADDR)                                             (* \; "Edited 11-Aug-87 11:21 by pds")(* |;;;| "Returns a list of all references to ADDR, tagged as var, struct, or list, in the A regs, stack, heap, or trail.")    (XQP::|put.Amem| 1 (XQP::|get.Aval| 1))    (XQP::|put.Amem| 2 (XQP::|get.Aval| 2))    (XQP::|put.Amem| 3 (XQP::|get.Aval| 3))    (XQP::|put.Amem| 4 (XQP::|get.Aval| 4))    (LET ((XQP::REVADDR (XQP::MARK.AS.REVERSED ADDR)))         (APPEND (|bind| DESTADDR (TOP _ (\\ADDBASE (XQP::|get.24| H)                                                -2)) |for| I XQP::|fromcell| XQP::|membot|                    XQP::|tocell| TOP |when| (AND (XQP::IS.POINTER.TAG (\\GETBASEBYTE I 0))                                                  (OR (EQ ADDR (SETQ DESTADDR (\\GETBASEPTR I 0)))                                                      (EQ XQP::REVADDR DESTADDR))) |collect| I)                (|bind| DESTADDR (TOP _ (\\ADDBASE (XQP::|get.24| E)                                               516)) |for| I XQP::|fromcell| (XQP::|get.24| TR)                   XQP::|tocell| TOP |when| (AND (XQP::IS.POINTER.TAG (\\GETBASEBYTE I 0))                                                 (OR (EQ ADDR (SETQ DESTADDR (\\GETBASEPTR I 0)))                                                     (EQ XQP::REVADDR DESTADDR))) |collect| I)))))(XQP::SCAN.FOR.GARBAGE  (LAMBDA (XQP::OVERFLOW.EVENT)                              (* \; "Edited 11-Aug-87 10:36 by pds")    (|bind| X |for| I XQP::|fromcell| (\\ADDBASE (|if| (EQ XQP::OVERFLOW.EVENT 25)                                                     |then| (XQP::|get.24| S)                                                   |else| (XQP::|get.24| H))                                             -2) XQP::|downtocell| XQP::|init.H|       |thereis| (OR (EQ (SETQ X (\\GETBASEPTR I 0))                         (CONSTANT (\\VAG2 255 65535)))                     (EQ X (CONSTANT (\\VAG2 255 65533)))))))(XQP::MAYBE.GC  (LAMBDA (EVENT)                                            (* \; "Edited 11-Aug-87 10:36 by pds")    (|if| (AND (IGEQ (|add| XQP::MAYBE.GC.COUNT 1)                     XQP::MAYBE.GC.INTERVAL)               (FMEMB EVENT XQP::MAYBE.GC.EVENTS))        |then| (SETQ XQP::MAYBE.GC.COUNT 0)              (PRINTOUT T "starting pseudo-random GC (event " EVENT ", " (XQP::|opcode.FROM.POINTER|                                                                          (\\ADDBASE (XQP::|get.24|                                                                                      P)                                                                                 -1))                     ") ..." T)              (GC EVENT))))(XQP::MAYBE.GC.NOW  (LAMBDA (EVENT)                                            (* \; "Edited 11-Aug-87 10:36 by pds")    (|if| (AND (IGEQ (|add| XQP::MAYBE.GC.COUNT 1)                     XQP::MAYBE.GC.INTERVAL)               (FMEMB EVENT XQP::MAYBE.GC.EVENTS))        |then| (SETQ XQP::MAYBE.GC.COUNT 0)              (PRINTOUT T "starting pseudo-random GC (event " EVENT ", " (XQP::|opcode.FROM.POINTER|                                                                          (\\ADDBASE (XQP::|get.24|                                                                                      P)                                                                                 -1))                     ") ..." T)              T)))(XQP::ZERO.OUT.GARBAGE  (LAMBDA (XQP::CLEARMARKS)                                  (* \; "Edited 11-Aug-87 10:50 by pds")(* |;;;| "This function is just for testing.  It zeros out the unmarked cells, and resets all mark bits.  This lets you test code to see if you've forgotten to mark something important.")    (|bind| (STARTTIME _ (CLOCK 0))           (LAST _ (\\ADDBASE XQP::GC.HEAP.P.FOR.COMPACTION -2))           (XQP::MARKED _ 0)           TAG |for| I XQP::|fromcell| XQP::GC.HEAP.GC XQP::|tocell| LAST       |sum| (|if| (XQP::TAG.IS.MARKED (SETQ TAG (\\GETBASEBYTE I 0)))                 |then| (|add| XQP::MARKED 1)                       (|if| XQP::CLEARMARKS                           |then| (PUTBASEBYTE I 0 (XQP::TAG.SANS.MARK.BIT TAG)))                       0               |else| (|if| XQP::ZEROING                          |then| (\\PUTBASE I 0 255)                                (\\PUTBASE I 1 65535))                     1) |finally| (XQP::TRACE.GC "[ " XQP::|.I8| (IDIFFERENCE (CLOCK 0)                                                                        STARTTIME)                                         " : Zeroing Time in Milliseconds ]" T))))(XQP::PTR.STATE  (LAMBDA (XQP::STARTPTR XQP::ENDPTR)                        (* \; "Edited 11-Aug-87 10:37 by pds")(* |;;;| "Returns a list of what the cells between STARTPTR and ENDPTR point to, if they are pointers, else what they contain.")    (|bind| CONTENTS |for| I XQP::|fromcell| XQP::STARTPTR XQP::|tocell| XQP::ENDPTR       |eachtime| (SETQ CONTENTS (\\GETBASEPTR I 0))       |collect| (|if| (AND (XQP::IS.POINTER.TAG (\\GETBASEBYTE I 0))                            (XQP::POINTER.IN.RANGE CONTENTS XQP::|membot| XQP::|memtop|))                     |then| (\\GETBASEPTR CONTENTS 0)                   |else| CONTENTS)))))(declare\: eval@compile (putprops xqp::if.debugging macro (args  (progn   (* |;;;| "Allows the inclusion of code that can be omitted from the system by setting variables to indicate what parts of the system is to be debugged.  The form of the macro is (IF.DEBUGGING FEATURE-OR-LIST EXPR...) If FEATURE-OR-LIST is an atom on the list DEBUGGING, or is a list of atoms at least one of which is on DEBUGGING, then the EXPR...  forms are evaluated and the last is returned, else they are ignored and NIL is returned.  If DEBUGGABLE is NIL when this form is compiled, no code will be generated, making this an efficient way to put in debugging code.")   (|if|    xqp::debuggable |then|    (let     ((xqp::feature (car args))      (body (cdr args)))     `(|if| ,(|if| (atom xqp::feature)                   |then|                   `(fmemb ',xqp::feature xqp::debugging) |else|                   `(or ,@(|for| f |in| xqp::feature |collect| `(fmemb ',xqp::feature xqp::debugging)                                 ))) |then| ,@body)))))))(rpaq? xqp::maybe.gc.count 0)(rpaq? xqp::maybe.gc.events '(20 21 22 23 24 25))(rpaq? xqp::maybe.gc.interval 1000)(rpaqq xqp::traceblock 1000)(rpaqq xqp::zeroing t)(* |;;| "Try to beat the file manager into shape")(putprops prologgc copyright ("Quintus Computer Systems, Inc" 1986 1900 1987))(declare\: dontcopy  (filemap (nil (7572 30359 (xqp::garbage.collect.heap 7582 . 7857) (gc 7859 . 13648) (xqp::gc.flipcursor 13650 . 14232) (xqp::init.gc 14234 . 14778) (xqp::init.stats 14780 . 15249) (xqp::last.collected.choicepoint 15251 . 16393) (xqp::make.consistent.for.gc 16395 . 24777) (xqp::mark.collected.choicepoints 24779 . 25509) (xqp::pre.gc.criteria 25511 . 26077) (xqp::print.post.gc.trace.options 26079 . 26407) (xqp::print.post.mark.stats 26409 . 27613) (xqp::print.pre.gc.trace.options 27615 . 27954) (xqp::process.perm.vars 27956 . 28269) (xqp::reset.gc.cursor 28271 . 28524) (xqp::set.gc.cursor 28526 . 28822) (xqp::update.stats 28824 . 29760) (xqp::|opcode.FROM.POINTER| 29762 . 30357)) (36151 53041 (xqp::heap.top.during.unification 36161 . 36616) (xqp::initialize.trace.stack 36618 . 37272) (peek 37274 . 37659) (xqp::trace.and.mark 37661 . 39506) (xqp::trace.and.mark.argument.registers 39508 . 39893) (xqp::trace.and.mark.from.s 39895 . 42585) (xqp::trace.and.mark.local.stack 42587 . 43751) (xqp::trace.and.mark.pdl 43753 . 44613) (xqp::trace.and.mark.prologified.term 44615 . 46152) (xqp::trace.and.mark.trail.references 46154 . 47137) (xqp::trace.ptr 47139 . 53039)) (60376 79557 (xqp::collect.the.garbage 60386 . 62749) (xqp::collector.downsweep 62751 . 69972) (xqp::collector.upsweep 69974 . 73718) (xqp::reverse.argument.registers 73720 . 74194) (xqp::reverse.local.stack.pointers 74196 . 75561) (xqp::reverse.trail.stack.pointers 75563 . 76825) (xqp::update.registers.after.gc 76827 . 79555)) (88142 95816 (xqp::alternatives 88152 . 88559) (xqp::clearmem 88561 . 89116) (xqp::marked.cells 89118 . 89383) (microcode 89385 . 89993) (xqp::current.instr 89995 . 90220) (xqp::find.refs 90222 . 91659) (xqp::scan.for.garbage 91661 . 92318) (xqp::maybe.gc 92320 . 93094) (xqp::maybe.gc.now 93096 . 93861) (xqp::zero.out.garbage 93863 . 95123) (xqp::ptr.state 95125 . 95814)))))stop