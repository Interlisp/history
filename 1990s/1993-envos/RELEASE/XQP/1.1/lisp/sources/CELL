(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "INTERLISP")(FILECREATED " 9-Sep-87 17:46:52" {DSK}<LISPFILES>DCOMS>CELL.\;3 30570        |changes| |to:|  (VARS CELLCOMS)                       (FUNCTIONS \\BASELESSP)                       (OPTIMIZERS \\BASELESSP)      |previous| |date:| "26-Jun-87 14:05:31" {DSK}<LISPFILES>DCOMS>CELL.\;1); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(PRETTYCOMPRINT CELLCOMS)(RPAQQ CELLCOMS ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>CELL.LSP;1, loaded 15-Jun-87 18:11:36")                                     (* |;;| "SCCS   : @(#)CELL.LSP	8204.1 3/13/87 File   : $xerox/cell.lsp Author : Richard A. O'Keefe Purpose: Define the \"cell\" macros.")                 (* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")                                     (* |;;| "The Prolog stacks are held in a single array of 32-bit integers, stacks.  memtop is the size of this array. The first 256 locations are dedicated to holding the A registers. Another 128 locations after that are reserved for pseudo-Prolog variables.  The initial values cannot be given here, as Interlisp cannot save them using the file package or restore them.  See the PROLOG.INIT.REGISTERS function.")                 (VARIABLES XQP::|init.H|)                                                             (* \; "initial H")                 (VARIABLES XQP::|init.E|)                                                             (* \; "initial E")                 (VARIABLES XQP::|membot|)                                                             (* \; "base of Prolog area")                 (VARIABLES XQP::|memtop|)                                                             (* \; "end of Prolog area")                                     (* |;;| "(QP.reset) sets the A registers, the bottom part of the heap, and the bottom part of the stack to zeros.  This isn't strictly necessary, as Prolog ought not use anything it hasn't initialised, but it makes it easier to see what is going on in the debugging windows.  Indeed, as this function's just for debugging, it could have gone in DEBUG.LSP, but it is here as it uses init.E and membot, which are defined here.")                 (FUNCTIONS XQP::|QP.reset|)                                     (* |;;| "(FIXP.CONSTANTP form) is true when `form' is a constant expression, and the value of that expression is an integer.  The details of how this works are hidden in the function CONSTANTEXPRESSIONP, which is part of the InterLost-D compiler.  The true value which we return is the value of the constant expression.  We can get away with this because NIL (false) is not an integer.")                 (FUNCTIONS XQP::FIXP.CONSTANTP)                                     (* |;;| "Because the Dandelion addresses 16-bit words, and because it is clearest in the source code to use cell offsets rather than word offsets, we need to convert between word and cell offsets.  The function Twice does that, and is intended for use in macros.  It does the constant folding which a better Lisp compiler would render superfluous.")                 (FUNCTIONS XQP::|Twice|)                                     (* |;;| "(get.cell Ptr Offset) takes a \"pointer\" into the stacks and an Offset (expressed in terms of *cells*, and returns the contents of that cell.  This is now handled by the 32-bit stores.")                 (PROP HI XQP::|get.cell|)                 (PROP LO XQP::|get.cell|)                 (PROP XQP::|Tag| XQP::|get.cell|)                 (PROP XQP::|Ptr| XQP::|get.cell|)                 (PROP XQP::|Loc| XQP::|get.cell|)                                     (* |;;| "(get.addr Ptr Offset) takes a pointer into the stacks and an offset, and returns the 24-bit address stored at that location. It is only used when the cell is expected to contain a proper pointer in any case.")                 (FUNCTIONS XQP::|get.addr|)                                     (* |;;| "(get.word Ptr Offset) takes a pointer into the heap and an offset (in *cells*) and returns the LOW-order 16 bits of that cell.  This is for storing integers in the heap.")                 (FUNCTIONS XQP::|get.word|)                                     (* |;;| "(put.cell Ptr Offset Val) stores the 32-bit tagged quantity Val at the location specified by Ptr and Offset")                                     (* |;;| "Storing a 32-bit cell is rather tricky.  Some things we can store as two 16-bit words.  Others we have to store as a tag and a pointer. The way I have hacked this is that all the macros which used, in the type safe version, to yield 32-bit numbers, now have either HI+LO properties or Tag+Ptr properties or both, and that these functions work out how to yield up the parts of a cell, and put.cell works out how to store them.  The cases are  - the value is not a list, or its CAR is not a symbol : error - the value's CAR has a HI property, store two 16-bit chunks - the value's CAR has a Ptr property, store tag and pointer - the value's CAR has a MACRO property, expand and try again - otherwise, error.  tag.ref crops up often enough to be worth making a special case of.")                 (FUNCTIONS XQP::|put.cell.macro| XQP::|put.cell|)                                     (* |;;| "(put.addr Ptr Offset Val) stores a 24-bit pointer in cell Ptr+Offset of the stack. the tag that is stored is also 0.  This just happens to be what \\PUTBASEPTR stores anyway, not always convenient.")                 (FUNCTIONS XQP::|put.addr|)                                     (* |;;| "(put.word Ptr Offset Val) stores a 16-bit integer in the LOW word of the cell addressed by Ptr and Offset (which is in *cells*).  This is used for updating counters held in the stacks.  The HIGH word is set to 0.  I'll have to make plain in the text where this is necessary and where the zero is already there.  I use a hack here: \\PUTBASEPTR sets the high byte to 0.  The possibilities for Val are 0, 1, and (get.16 I) or (get.16 N).  Now when Val is a constant, we can evaluate (\\VAG2 0 Val) at macro-expansion time.  When it is (get.16 {I,N}) we can get a zero-extended result from the registers easily enough.")                 (FUNCTIONS XQP::|put.word|)                                     (* |;;| "(add.cell Ptr Offset) adds an offset expressed in *cells* to a \"pointer\". There is no check that this pointer lies within the stack area, and I currently rely on subscript checking to catch this when it is used.  There is no add.addr or add.both; use add.cell.")                 (FUNCTIONS XQP::|add.cell|)                                     (* |;;| "increment.cell.pointer and decrement.cell pointer are macros which add or subtract one \"cell\" to a \"pointer\" variable. Just to be nice to myself, the macros check.  These macros will not need to be changed in the risky version.")                 (FUNCTIONS XQP::|increment.cell.pointer| XQP::|decrement.cell.pointer|)                                     (* |;;| "(before X Y) is true when the \"pointer\" X points lower in the stacks than the \"pointer\" Y.  This was relatively expensive, but now there is a Lisp opcode for it.")                 (FUNCTIONS \\BASELESSP |before|)                 (OPTIMIZERS \\BASELESSP)                                     (* |;;| "Now teach the compiler about the BASE-< opcode")                 (P (CL:SETF (CDR (ASSOC 223 \\OPCODES))                           '(BASE-< 0 T -1 \\BASE-<.UFN (|4K| |12K| DORODO)))                    (SETQ \\OPCODEARRAY NIL)                    (PUTPROP 'BASE-< 'DOPCODE (ASSOC 223 \\OPCODES)))                                     (* |;;| "(waybefore X Y) is supposed to be a cheap version of before which only needs to check the top 8 bits of the addresses.  If it is true, it doesn't just mean that X is before Y, it also means that there is \"lots of room\" between X and Y.  Since the safe version doesn't have to be fast, we check for a gap of 1000 cells.")                 (FUNCTIONS XQP::|waybefore|)                                     (* |;;| "(same.addr X Y) is used to test whether two 24-bit pointers are equal or not.  It is only supposed to work when they both point into the stacks.")                 (FUNCTIONS XQP::|same.addr|)                                     (* |;;| "(same.cell X Y) is used to test whether two 32-bit tagged cells are the same.  It should only be used when X is T0 and Y is T1. See tags.lsp for the definition of is.unbound, which is similar.")                 (FUNCTIONS XQP::|same.cell|)                                     (* |;;| "(same.cont T0 T1) is used when T0 and T1 are tagged pointers to the same kind of 32-bit boxed number.  That is, T0 and T1 are both of the form [Boxed|^X] or both of the form [Float|^X].  We want to check whether the numbers thus pointed to are equal.  When/ if bignums come along, I'll have to rethink this, but right now the easy thing to do is to look at the contents of the boxes directly.  I use ReadPrologPtr directly here, rather than get.24, as T0 and T1 are involved.  This macro is used in GETREAD.LSP and nowhere else.")                 (FUNCTIONS XQP::|same.cont|)                                     (* |;;| "The A (X) registers are currently all held in memory, in the first part of the stack area.  Eventually some of them will be held in real registers, but when we bounce out into the Lisp version of the emulator they will be stored in the memory locations, so it comes to much the same thing.  We never want the address of one of these things.  I used to use (CHANGE (Aval N) X) but InterLOST didn't want to know.  Pshaw.")                 (FUNCTIONS XQP::|loc.Amem| XQP::|get.Amem| XQP::|put.Amem|)                                     (* |;;| "The Y variables are held relative in the current environment.  The variable which the source code refers to as Yn is actually held at offset 2+n (e.g. Y2 is at offset 4) from the E register; it is up to the loader to perform this mapping. (get.Yreg N)		-- to fetch (put.Yreg N X)		-- to store (ref.Yreg N)		-- to form an address")                 (FUNCTIONS XQP::|loc.Yval| XQP::|get.Yval| XQP::|put.Yval|)                 (PROP MAKEFILE-ENVIRONMENT)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>CELL.LSP;1, loaded 15-Jun-87 18:11:36")(* |;;| "SCCS   : @(#)CELL.LSP	8204.1 3/13/87 File   : $xerox/cell.lsp Author : Richard A. O'Keefe Purpose: Define the \"cell\" macros.")(* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")(* |;;| "The Prolog stacks are held in a single array of 32-bit integers, stacks.  memtop is the size of this array. The first 256 locations are dedicated to holding the A registers. Another 128 locations after that are reserved for pseudo-Prolog variables.  The initial values cannot be given here, as Interlisp cannot save them using the file package or restore them.  See the PROLOG.INIT.REGISTERS function.")(XQP::|def.global| XQP::|init.H| )(* \; "initial H")(XQP::|def.global| XQP::|init.E| )(* \; "initial E")(XQP::|def.global| XQP::|membot| )(* \; "base of Prolog area")(XQP::|def.global| XQP::|memtop| )(* \; "end of Prolog area")(* |;;| "(QP.reset) sets the A registers, the bottom part of the heap, and the bottom part of the stack to zeros.  This isn't strictly necessary, as Prolog ought not use anything it hasn't initialised, but it makes it easier to see what is going on in the debugging windows.  Indeed, as this function's just for debugging, it could have gone in DEBUG.LSP, but it is here as it uses init.E and membot, which are defined here.")(XQP::|def.subr| XQP::|QP.reset| NIL (|if| (MOUSECONFIRM "Restart Prolog process?")                                         |then| (RESTART.PROCESS (FIND.PROCESS XQP::PROLOG.NAME))                                       |elseif| (MOUSECONFIRM "Halt Prolog process?")                                         |then| (DEL.PROCESS (FIND.PROCESS XQP::PROLOG.NAME))))(* |;;| "(FIXP.CONSTANTP form) is true when `form' is a constant expression, and the value of that expression is an integer.  The details of how this works are hidden in the function CONSTANTEXPRESSIONP, which is part of the InterLost-D compiler.  The true value which we return is the value of the constant expression.  We can get away with this because NIL (false) is not an integer.")(XQP::|def.subr| XQP::FIXP.CONSTANTP (X) (SETQ X (CONSTANTEXPRESSIONP X))                                         (AND (LISTP X)                                              (FIXP (CAR X))))(* |;;| "Because the Dandelion addresses 16-bit words, and because it is clearest in the source code to use cell offsets rather than word offsets, we need to convert between word and cell offsets.  The function Twice does that, and is intended for use in macros.  It does the constant folding which a better Lisp compiler would render superfluous.")(XQP::|def.subr| XQP::|Twice| (XQP::|Base| |Offset|) (|if| (XQP::FIXP.CONSTANTP XQP::|Base|)                                                         |then| (IPLUS (LLSH (XQP::FIXP.CONSTANTP                                                                              XQP::|Base|)                                                                             1)                                                                       |Offset|)                                                       |elseif| (EQ |Offset| 0)                                                         |then| `(LLSH ,XQP::|Base| 1)                                                       |else| `(IPLUS (LLSH ,XQP::|Base| 1)                                                                      ,|Offset|)))(* |;;| "(get.cell Ptr Offset) takes a \"pointer\" into the stacks and an Offset (expressed in terms of *cells*, and returns the contents of that cell.  This is now handled by the 32-bit stores.")(PUTPROPS XQP::|get.cell| HI (LAMBDA (XQP::|Ptr| |Offset|)                                    `(\\GETBASE (XQP::|get.24| ,XQP::|Ptr|)                                            ,(XQP::|Twice| |Offset| 0))))(PUTPROPS XQP::|get.cell| LO (LAMBDA (XQP::|Ptr| |Offset|)                                    `(\\GETBASE (XQP::|get.24| ,XQP::|Ptr|)                                            ,(XQP::|Twice| |Offset| 1))))(PUTPROPS XQP::|get.cell| XQP::|Tag| (LAMBDA (XQP::|Ptr| |Offset|)                                            `(\\GETBASEBYTE (XQP::|get.24| ,XQP::|Ptr|)                                                    ,(XQP::|Twice| (XQP::|Twice| |Offset| 0)                                                            0))))(PUTPROPS XQP::|get.cell| XQP::|Ptr| (LAMBDA (XQP::|Ptr| |Offset|)                                            `(\\GETBASEPTR (XQP::|get.24| ,XQP::|Ptr|)                                                    ,(XQP::|Twice| |Offset| 0))))(PUTPROPS XQP::|get.cell| XQP::|Loc| (LAMBDA (XQP::|Ptr| |Offset|)                                            `(\\ADDBASE (XQP::|get.24| ,XQP::|Ptr|)                                                    ,(XQP::|Twice| |Offset| 0))))(* |;;| "(get.addr Ptr Offset) takes a pointer into the stacks and an offset, and returns the 24-bit address stored at that location. It is only used when the cell is expected to contain a proper pointer in any case.")(XQP::|def.macro| XQP::|get.addr| (XQP::|Ptr| |Offset|) `(\\GETBASEPTR (XQP::|get.24| ,XQP::|Ptr|)                                                                ,(XQP::|Twice| |Offset| 0)))(* |;;| "(get.word Ptr Offset) takes a pointer into the heap and an offset (in *cells*) and returns the LOW-order 16 bits of that cell.  This is for storing integers in the heap.")(XQP::|def.macro| XQP::|get.word| (XQP::|Ptr| |Offset|) `(\\GETBASE (XQP::|get.24| ,XQP::|Ptr|)                                                                ,(XQP::|Twice| |Offset| 1)))(* |;;| "(put.cell Ptr Offset Val) stores the 32-bit tagged quantity Val at the location specified by Ptr and Offset")(* |;;| "Storing a 32-bit cell is rather tricky.  Some things we can store as two 16-bit words.  Others we have to store as a tag and a pointer. The way I have hacked this is that all the macros which used, in the type safe version, to yield 32-bit numbers, now have either HI+LO properties or Tag+Ptr properties or both, and that these functions work out how to yield up the parts of a cell, and put.cell works out how to store them.  The cases are  - the value is not a list, or its CAR is not a symbol : error - the value's CAR has a HI property, store two 16-bit chunks - the value's CAR has a Ptr property, store tag and pointer - the value's CAR has a MACRO property, expand and try again - otherwise, error.  tag.ref crops up often enough to be worth making a special case of.")(XQP::|def.subr| XQP::|put.cell.macro| (XQP::|Ptr| |Offset| XQP::|Val|)   (|if| (NOT (AND (LISTP XQP::|Val|)                   (LITATOM (CAR XQP::|Val|))))       |then| (SHOULDNT 'XQP::|put.cell|)     |elseif| (EQ (CAR XQP::|Val|)                  'XQP::|tag.ref|)       |then| `(\\PUTBASEPTR (XQP::|get.24| ,XQP::|Ptr|)                      ,(XQP::|Twice| |Offset| 0)                      (XQP::|get.24| ,(CADR XQP::|Val|)))     |elseif| (GETPROP (CAR XQP::|Val|)                     'XQP::|Loc|)       |then| `(LET ((SOURCE ,(APPLY (GETPROP (CAR XQP::|Val|)                                            'XQP::|Loc|)                                     (CDR XQP::|Val|))))                    (\\PUTBASEPTR (XQP::|get.24| ,XQP::|Ptr|)                           ,(XQP::|Twice| |Offset| 0)                           (\\VAG2 (\\GETBASE SOURCE 0)                                  (\\GETBASE SOURCE 1))))     |elseif| (GETPROP (CAR XQP::|Val|)                     'HI)       |then| `(\\PUTBASEPTR (XQP::|get.24| ,XQP::|Ptr|)                      ,(XQP::|Twice| |Offset| 0)                      (\\VAG2 ,(APPLY (GETPROP (CAR XQP::|Val|)                                             'HI)                                      (CDR XQP::|Val|)) ,(APPLY (GETPROP (CAR XQP::|Val|)                                                                       'LO)                                                                (CDR XQP::|Val|))))     |elseif| (GETPROP (CAR XQP::|Val|)                     'XQP::|Ptr|)       |then| `(LET ((DEST (\\ADDBASE (XQP::|get.24| ,XQP::|Ptr|)                                  ,(XQP::|Twice| |Offset| 0))))                    (\\PUTBASEPTR DEST 0 ,(APPLY (GETPROP (CAR XQP::|Val|)                                                        'XQP::|Ptr|)                                                 (CDR XQP::|Val|)))                    (\\PUTBASEBYTE DEST 0 ,(APPLY (GETPROP (CAR XQP::|Val|)                                                         'XQP::|Tag|)                                                  (CDR XQP::|Val|))))     |elseif| (CL:MACRO-FUNCTION (CAR XQP::|Val|))       |then| (XQP::|put.cell.macro| XQP::|Ptr| |Offset| (CL:MACROEXPAND XQP::|Val|))     |else| (SHOULDNT 'XQP::|put.cell|)))(XQP::|def.macro| XQP::|put.cell| (XQP::|Ptr| |Offset| XQP::|Val|) (XQP::|put.cell.macro| XQP::|Ptr|                                                                           |Offset| XQP::|Val|))(* |;;| "(put.addr Ptr Offset Val) stores a 24-bit pointer in cell Ptr+Offset of the stack. the tag that is stored is also 0.  This just happens to be what \\PUTBASEPTR stores anyway, not always convenient.")(XQP::|def.macro| XQP::|put.addr| (XQP::|Ptr| |Offset| XQP::|Val|) `(\\PUTBASEPTR (XQP::|get.24|                                                                                   ,XQP::|Ptr|)                                                                           ,(XQP::|Twice| |Offset| 0)                                                                           ,XQP::|Val|))(* |;;| "(put.word Ptr Offset Val) stores a 16-bit integer in the LOW word of the cell addressed by Ptr and Offset (which is in *cells*).  This is used for updating counters held in the stacks.  The HIGH word is set to 0.  I'll have to make plain in the text where this is necessary and where the zero is already there.  I use a hack here: \\PUTBASEPTR sets the high byte to 0.  The possibilities for Val are 0, 1, and (get.16 I) or (get.16 N).  Now when Val is a constant, we can evaluate (\\VAG2 0 Val) at macro-expansion time.  When it is (get.16 {I,N}) we can get a zero-extended result from the registers easily enough.")(XQP::|def.macro| XQP::|put.word| (XQP::|Ptr| |Offset| XQP::|Val|)   (SETQ XQP::|Val| (|if| (SMALLP XQP::|Val|)                        |then| `',(\\VAG2 0 XQP::|Val|)                      |elseif| (AND (LISTP XQP::|Val|)       (* \; "(get.16 I) or")                                    (EQ (CAR XQP::|Val|)                                        'XQP::|get.16|)      (* \; "(get.16 N)")                                    (MEMB (CADR XQP::|Val|)                                          '(I N)))                        |then| `(XQP::|\\RdPrologPtr| ,(XQP::|PrologZeroExtend| (                                                                            XQP::|PrologNameToLoUReg|                                                                                 (CADR XQP::|Val|))))                      |elseif| (AND (LITATOM XQP::|Val|)                                    (MEMB XQP::|Val| '(I N)))                        |then| `(XQP::|\\RdPrologPtr|        (* \; "bare I or N")                                       ,(XQP::|PrologZeroExtend| (XQP::|PrologNameToLoUReg|                                                                         XQP::|Val|)))                      |else| (SHOULDNT 'XQP::|put.word|)))   `(\\PUTBASEPTR (XQP::|get.24| ,XQP::|Ptr|)           ,(XQP::|Twice| |Offset| 0)           ,XQP::|Val|))(* |;;| "(add.cell Ptr Offset) adds an offset expressed in *cells* to a \"pointer\". There is no check that this pointer lies within the stack area, and I currently rely on subscript checking to catch this when it is used.  There is no add.addr or add.both; use add.cell.")(XQP::|def.macro| XQP::|add.cell| (XQP::|Ptr| |Offset|)   (|if| (XQP::FIXP.CONSTANTP |Offset|)       |then| `(\\ADDBASE (XQP::|get.24| ,XQP::|Ptr|)                      ,(XQP::|Twice| |Offset| 0))     |else| `(\\ADDBASE (XQP::|get.24| ,XQP::|Ptr|)                    (LLSH ,|Offset| 1))))(* |;;| "increment.cell.pointer and decrement.cell pointer are macros which add or subtract one \"cell\" to a \"pointer\" variable. Just to be nice to myself, the macros check.  These macros will not need to be changed in the risky version.")(XQP::|def.macro| XQP::|increment.cell.pointer| (R N) (OR N (SETQ N 1))                                                      `(XQP::|put.24| ,R (XQP::|add.cell|                                                                          ,R                                                                          ,N)))(XQP::|def.macro| XQP::|decrement.cell.pointer| (R N) (SETQ N (|if| N                                                                  |then| (MINUS N)                                                                |else| -1))                                                      `(XQP::|put.24| ,R (XQP::|add.cell|                                                                          ,R                                                                          ,N)))(* |;;| "(before X Y) is true when the \"pointer\" X points lower in the stacks than the \"pointer\" Y.  This was relatively expensive, but now there is a Lisp opcode for it.")(XQP::|def.subr| \\BASELESSP (X Y) (* |;;;| "Is the virtual address of X less than the virtual address of Y?  Returns T or NIL") (* |;;;| "The old code, before we had an instruction to do the work:")(* |;;;| "(OR (ILESSP (\\\\HILOC X) (\\\\HILOC Y)) (AND (EQ (\\\\HILOC X) (\\\\HILOC Y)) (ILESSP (\\\\LOLOC X) (\\\\LOLOC Y))))") ((OPCODES BASE-<)  X Y))(XQP::|def.macro| |before| (X Y) `(\\BASELESSP (XQP::|get.24| ,X)                                         (XQP::|get.24| ,Y)))(DEFOPTIMIZER \\BASELESSP (X Y) (* |;;;| "Is address X strictly less than address Y?") `((OPCODES BASE-<)   ,X   ,Y))(* |;;| "Now teach the compiler about the BASE-< opcode")(CL:SETF (CDR (ASSOC 223 \\OPCODES))       '(BASE-< 0 T -1 \\BASE-<.UFN (|4K| |12K| DORODO)))(SETQ \\OPCODEARRAY NIL)(PUTPROP 'BASE-< 'DOPCODE (ASSOC 223 \\OPCODES))(* |;;| "(waybefore X Y) is supposed to be a cheap version of before which only needs to check the top 8 bits of the addresses.  If it is true, it doesn't just mean that X is before Y, it also means that there is \"lots of room\" between X and Y.  Since the safe version doesn't have to be fast, we check for a gap of 1000 cells.")(XQP::|def.macro| XQP::|waybefore| (X Y) `(ILESSP (ADD1 (\\HILOC (XQP::|get.24| ,X)))                                                 (\\HILOC (XQP::|get.24| ,Y))))(* |;;| "(same.addr X Y) is used to test whether two 24-bit pointers are equal or not.  It is only supposed to work when they both point into the stacks.")(XQP::|def.macro| XQP::|same.addr| (X Y) `(EQ (XQP::|get.24| ,X)                                              (XQP::|get.24| ,Y)))(* |;;| "(same.cell X Y) is used to test whether two 32-bit tagged cells are the same.  It should only be used when X is T0 and Y is T1. See tags.lsp for the definition of is.unbound, which is similar.")(XQP::|def.macro| XQP::|same.cell| (X Y) `(AND (EQ (XQP::\\GET.HI.16 ,X)                                                   (XQP::\\GET.HI.16 ,Y))                                               (EQ (XQP::\\GET.LO.16 ,X)                                                   (XQP::\\GET.LO.16 ,Y))))(* |;;| "(same.cont T0 T1) is used when T0 and T1 are tagged pointers to the same kind of 32-bit boxed number.  That is, T0 and T1 are both of the form [Boxed|^X] or both of the form [Float|^X].  We want to check whether the numbers thus pointed to are equal.  When/ if bignums come along, I'll have to rethink this, but right now the easy thing to do is to look at the contents of the boxes directly.  I use ReadPrologPtr directly here, rather than get.24, as T0 and T1 are involved.  This macro is used in GETREAD.LSP and nowhere else.")(XQP::|def.macro| XQP::|same.cont| (X Y) (|if| (OR (NEQ X 'XQP::T0)                                                   (NEQ Y 'T1))                                             |then| (SHOULDNT 'XQP::|same.cont|))                                         '(AND (EQ (\\GETBASE (XQP::|ReadPrologPtr| XQP::T0)                                                          0)                                                   (\\GETBASE (XQP::|ReadPrologPtr| T1)                                                          0))                                               (EQ (\\GETBASE (XQP::|ReadPrologPtr| XQP::T0)                                                          1)                                                   (\\GETBASE (XQP::|ReadPrologPtr| T1)                                                          1))))(* |;;| "The A (X) registers are currently all held in memory, in the first part of the stack area.  Eventually some of them will be held in real registers, but when we bounce out into the Lisp version of the emulator they will be stored in the memory locations, so it comes to much the same thing.  We never want the address of one of these things.  I used to use (CHANGE (Aval N) X) but InterLOST didn't want to know.  Pshaw.")(XQP::|def.macro| XQP::|loc.Amem| (N) `(XQP::|add.cell| XQP::|membot| (XQP::|get.16| ,N)))(XQP::|def.macro| XQP::|get.Amem| (N) `(XQP::|get.cell| XQP::|membot| (XQP::|get.16| ,N)))(XQP::|def.macro| XQP::|put.Amem| (N XQP::|Val|) `(XQP::|put.cell| XQP::|membot| (XQP::|get.16|                                                                                  ,N)                                                         ,XQP::|Val|))(* |;;| "The Y variables are held relative in the current environment.  The variable which the source code refers to as Yn is actually held at offset 2+n (e.g. Y2 is at offset 4) from the E register; it is up to the loader to perform this mapping. (get.Yreg N)		-- to fetch (put.Yreg N X)		-- to store (ref.Yreg N)		-- to form an address")(XQP::|def.macro| XQP::|loc.Yval| (N) `(XQP::|add.cell| E (XQP::|get.16| ,N)))(XQP::|def.macro| XQP::|get.Yval| (N) `(XQP::|get.cell| E (XQP::|get.16| ,N)))(XQP::|def.macro| XQP::|put.Yval| (N XQP::|Val|) `(XQP::|put.cell| E (XQP::|get.16| ,N)                                                         ,XQP::|Val|))(PUTPROPS CELL COPYRIGHT ("Quintus Computer Systems, Inc" 1987))(DECLARE\: DONTCOPY  (FILEMAP (NIL)))STOP