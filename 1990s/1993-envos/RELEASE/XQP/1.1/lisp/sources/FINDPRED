(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(FILECREATED "25-Jun-87 16:52:44" {ERIS}<PROLOGCORE>LYRIC>LISP>FINDPRED.\;5 25830        |previous| |date:| "25-Jun-87 09:42:06" {ERIS}<PROLOGCORE>LYRIC>LISP>FINDPRED.\;4); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(PRETTYCOMPRINT FINDPREDCOMS)(RPAQQ FINDPREDCOMS ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>FINDPRED.LSP;1, loaded 16-Jun-87 18:31:56")                                         (* |;;| "@(#)FINDPRED.LSP	3.8   11/21/85  FINDPRED.LSP   Vince Pecora	 ; --------------------------------------------------------; ; WARNING: This material is CONFIDENTIAL and proprietary ; to Quintus Computer Systems Inc.		 ; ; ; Copyright (C) 1985,  Quintus Computer Systems, Inc.   ; All rights reserved.					 ; ; --------------------------------------------------------; ;")                                         (* |;;| "Copyright (c) 1985 by Quintus Computer Systems, Inc. All rights reserved.")                                         (* |;;| "note that in this code, a predicate name starting with a \"/\"  will break the algorithm.  This is currently also true  of the Sun version of this software as well ")                                         (* |;;| "-------------------------find-predicate------------------------- ")                     (FUNCTIONS XQP::FIND.PREDICATE)                                         (* |;;| "for debugging only add this after the last statement above: (PRINTOUT NIL \"Name = \" (for X in NAME collect (CHARACTER X)) 0 \"Arity = \" ARITY 0 )")                                         (* |;;| "The following function finds the top boundary for the predicate The argument \"TOP\" simply is the beginning of the first predicate that was found before calling this routine, as the name and arity that is  being looked for is needed anyway")                                         (* |;;| "------------------------- find-top ------------------------- ")                     (FUNCTIONS XQP::FIND.TOP)                                         (* |;;| "Returns a character of NIL if at the end of the file ")                     (FUNCTIONS XQP::GET.NEXT.CHAR)                                         (* |;;| "------------------------- find-next-pred-down ---------------- The following function expects to start by reading the first character  in the beginning of a line and will move down at least one line.  At the  end of file, it will simply return the beginning of the last line")                     (FUNCTIONS XQP::FIND.NEXT.PRED.DOWN)                                         (* |;;| "-------------------------find-bottom-------------------------  This function finds the bottom limit of the predicate.")                     (FUNCTIONS XQP::FIND.BOTTOM)                                         (* |;;| "----- This function returns a nil if there was an error, otherwise  ----- it positions the cursor right after the ending period of a clause  Note that MAX.STRING.LENGTH is a global variable defined in  FINDARITY.LSP")                     (FUNCTIONS XQP::FIND.END)                                         (* |;;| "------------------------- get-name  ------------------------- ")                     (FUNCTIONS XQP::GET.PRED.NAME)                                         (* |;;| "-------------------------find-first-predicate ---------------------- --------------------------------------------------------------------")                     (FUNCTIONS XQP::FIND.FIRST.PREDICATE)                                         (* |;;| "---------------------------------------------------------------------- This function assumes that the file pointer is in column 1 of the line")                     (FUNCTIONS XQP::FIND.FIRST.PREDICATE.AUX XQP::BEGINNING.OF.LINE XQP::END.OF.LINE                            )                     (PROP MAKEFILE-ENVIRONMENT)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>FINDPRED.LSP;1, loaded 16-Jun-87 18:31:56")(* |;;| "@(#)FINDPRED.LSP	3.8   11/21/85  FINDPRED.LSP   Vince Pecora	 ; --------------------------------------------------------; ; WARNING: This material is CONFIDENTIAL and proprietary ; to Quintus Computer Systems Inc.		 ; ; ; Copyright (C) 1985,  Quintus Computer Systems, Inc.   ; All rights reserved.					 ; ; --------------------------------------------------------; ;")(* |;;| "Copyright (c) 1985 by Quintus Computer Systems, Inc. All rights reserved.")(* |;;| "note that in this code, a predicate name starting with a \"/\"  will break the algorithm.  This is currently also true  of the Sun version of this software as well ")(* |;;| "-------------------------find-predicate------------------------- ")(XQP::DEFUNC XQP::FIND.PREDICATE (STREAM SELECTION) (LET ((TEXT (TEXTOBJ STREAM))                                                          (START (XQP::FIND.FIRST.PREDICATE SELECTION                                                                        ))                                                          (NAME (XQP::GET.PRED.NAME STREAM)))                                                         (|if| (NOT (EOFP STREAM))                                                              (* \; "Backbin to use find.arity.aux")                                                             |then| (\\BACKBIN STREAM)                                                              (* \; "properly after finding Name"))                                                         (LET* ((XQP::ARITY (XQP::FIND.ARITY.AUX                                                                             STREAM TEXT START))                                                                (TOP (XQP::FIND.TOP STREAM START NAME                                                                             XQP::ARITY))                                                                (BOTTOM (XQP::FIND.BOTTOM STREAM                                                                                START NAME XQP::ARITY)                                                                       ))                                                               (TEDIT.SETSEL STREAM TOP                                                                      (ADD1 (IDIFFERENCE BOTTOM TOP))                                                                      'RIGHT))))(* |;;| "for debugging only add this after the last statement above: (PRINTOUT NIL \"Name = \" (for X in NAME collect (CHARACTER X)) 0 \"Arity = \" ARITY 0 )")(* |;;| "The following function finds the top boundary for the predicate The argument \"TOP\" simply is the beginning of the first predicate that was found before calling this routine, as the name and arity that is  being looked for is needed anyway")(* |;;| "------------------------- find-top ------------------------- ")(XQP::DEFUNC XQP::FIND.TOP (STREAM TOP NAME XQP::ARITY)   (LET ((XQP::ORI.POSITION (\\TEXTGETFILEPTR STREAM))         (TEXT (TEXTOBJ STREAM))         (STOP NIL)         XQP::NEW.ARITY XQP::NEW.TOP TMP)        (|if| (NEQ TOP 1)                                    (* \; "This is character position #1")            |then| (\\SETUPGETCH (SUB1 TOP)                          TEXT)                              (* \; "FIND.FIRST.PREDICATE.AUX must")                  (XQP::BEGINNING.OF.LINE STREAM)            (* \; "be used at the Beginning of Line")                  (WHILE (AND (NOT STOP)                              (SETQ XQP::NEW.TOP (XQP::FIND.FIRST.PREDICATE.AUX STREAM))                              (EQUAL NAME (XQP::GET.PRED.NAME STREAM)))                     DO (\\BACKBIN STREAM)                        (SETQ XQP::NEW.ARITY (XQP::FIND.ARITY.AUX STREAM TEXT XQP::NEW.TOP))                        (|if| (AND (EQ XQP::NEW.ARITY XQP::ARITY)                                   (NEQ XQP::NEW.TOP TOP))                            |then| (SETQ TOP XQP::NEW.TOP)                                  (|if| (NEQ XQP::NEW.TOP 1)                                      |then| (\\SETUPGETCH (SUB1 XQP::NEW.TOP)                                                    TEXT)                                    |else| (SETQ STOP T)                                          (SETQ TOP 1))                          |else| (SETQ STOP T))))        TOP))(* |;;| "Returns a character of NIL if at the end of the file ")(XQP::DEFUNC XQP::GET.NEXT.CHAR (STREAM) (|if| (NOT (EOFP STREAM))                                             |then| (\\BIN STREAM)))(* |;;| "------------------------- find-next-pred-down ---------------- The following function expects to start by reading the first character  in the beginning of a line and will move down at least one line.  At the  end of file, it will simply return the beginning of the last line")(XQP::DEFUNC XQP::FIND.NEXT.PRED.DOWN (STREAM) (LET ((CHAR (XQP::GET.NEXT.CHAR STREAM)))                                                    (\\BACKBIN STREAM)                                                    (WHILE (AND (NEQ CHAR NIL)                                                                (OR (EQ CHAR (CHARCODE EOL))                                                             (* \; "carriage return")                                                                    (EQ CHAR (CHARCODE SPACE))                                                             (* \; "space")                                                                    (EQ CHAR (CHARCODE TAB))                                                             (* \; "tab")                                                                    (EQ CHAR (CHARCODE %))                                                             (* \; "percent sign")                                                                    (EQ CHAR (CHARCODE /))                                                             (* \; "slash")                                                                    )) DO (XQP::END.OF.LINE STREAM)                                                                          (SETQ CHAR (                                                                                   XQP::GET.NEXT.CHAR                                                                                      STREAM))                                                                          (\\BACKBIN STREAM))                                                    (|if| (NOT (NULL CHAR))                                                        |then| (ADD1 (\\TEXTGETFILEPTR STREAM)))))(* |;;| "-------------------------find-bottom-------------------------  This function finds the bottom limit of the predicate.")(XQP::DEFUNC XQP::FIND.BOTTOM (STREAM START NAME XQP::ARITY)   (LET ((TEXT (TEXTOBJ STREAM))         (STOP NIL)         (XQP::NEW.NAME NIL)         (XQP::NEW.BOTTOM NIL)         TOP BOTTOM XQP::NEW.TOP)        (\\SETUPGETCH START TEXT)        (|if| (XQP::FIND.END STREAM)                         (* \;                                                              "Find the end of the current clause")            |then| (SETQ TOP START)                          (* \; "Initialize TOP and BOTTOM")                  (SETQ BOTTOM (\\TEXTGETFILEPTR STREAM))                  (XQP::END.OF.LINE STREAM)                  (* \;                                                              "Set up to read 1st char from next line")                  (SETQ XQP::NEW.TOP (XQP::FIND.NEXT.PRED.DOWN STREAM))                  (|if| (NEQ XQP::NEW.TOP NIL)                      |then|                                 (* \; "We found another lower clause")                            (SETQ XQP::NEW.NAME (XQP::GET.PRED.NAME STREAM))                            (\\BACKBIN STREAM)                    |else|                                   (* \; "No lower clause")                          (SETQ STOP T))          |else|                                             (* \;                                                              "Current clause did not end before EOF")                (SETQ BOTTOM START)                (SETQ STOP T))        (WHILE (AND (NOT STOP)                               (* \; "The next clause down has same")                    (EQUAL NAME XQP::NEW.NAME)               (* \; "name and arity")                    (EQ XQP::ARITY (XQP::FIND.ARITY.AUX STREAM TEXT XQP::NEW.TOP)))           DO (XQP::FIND.END STREAM)                         (* \; "Find the end of this clause")              (SETQ BOTTOM (\\TEXTGETFILEPTR STREAM))              (XQP::END.OF.LINE STREAM)                      (* \;                                                              "Set up to read 1st char from next line")              (SETQ TOP XQP::NEW.TOP)                        (* \; "Reset the TOP marker")              (SETQ XQP::NEW.TOP (XQP::FIND.NEXT.PRED.DOWN STREAM))              (|if| (NEQ XQP::NEW.TOP NIL)                  |then| (SETQ XQP::NEW.NAME (XQP::GET.PRED.NAME STREAM))                                                              (* \; "check the name")                        (\\BACKBIN STREAM)                   (* \;                                                              "Needed to position for find-arity-aux")                |else| (SETQ STOP T)))        BOTTOM))(* |;;| "----- This function returns a nil if there was an error, otherwise  ----- it positions the cursor right after the ending period of a clause  Note that MAX.STRING.LENGTH is a global variable defined in  FINDARITY.LSP")(XQP::DEFUNC XQP::FIND.END (STREAM)   (LET ((XQP::ORI.POSITION (ADD1 (\\TEXTGETFILEPTR STREAM)))         (XQP::CHAR.COUNT 0)         (XQP::STOP.COUNT XQP::MAX.STRING.LENGTH)            (* \; "Set upper limit on string ")         (XQP::TMP.COUNT 0)                                  (* \;                                                           "length so as not to scan the entire file ")         (XQP::STOP.CHAR 0)                                  (* \;                                                             "if a string is not terminated properly.")         (STOP 0)         (XQP::PREV.CHAR 0)         (ERR NIL)         CHAR)        (WHILE (AND (ILESSP XQP::CHAR.COUNT XQP::STOP.COUNT)                    (EQ STOP 0)                    (NOT (EOFP STREAM)))           DO (SETQ CHAR (\\BIN STREAM))              (SETQ XQP::CHAR.COUNT (ADD1 XQP::CHAR.COUNT))              (|if| (EQ CHAR 46)                             (* \; "period")                  |then| (SETQ STOP 1)                |elseif|                                     (* \;                                                          "do not mistake radix notation for a string")                      (AND (EQ CHAR 39)                      (* \; "quote")                           (AND (IGEQ XQP::PREV.CHAR 48)     (* \; "zero")                                (ILEQ XQP::PREV.CHAR 57)     (* \; "nine")                                ))                  |then| NIL                |elseif|                                     (* \;                                                              "we have the start of a string or atom")                      (OR (EQ CHAR 34)                       (* \; "double quote")                          (EQ CHAR 39)                       (* \; "single quote")                          )                  |then| (SETQ XQP::STOP.CHAR CHAR)                        (SETQ XQP::PREV.CHAR CHAR)                        (SETQ CHAR (\\BIN STREAM))                        (SETQ XQP::TMP.COUNT 0)                        (WHILE (AND (NEQ CHAR XQP::STOP.CHAR)                                    (ILESSP XQP::TMP.COUNT XQP::STOP.COUNT)                                    (NOT (EOFP STREAM))) DO (SETQ XQP::PREV.CHAR CHAR)                                                            (SETQ CHAR (\\BIN STREAM))                                                            (SETQ XQP::TMP.COUNT (ADD1 XQP::TMP.COUNT                                                                                       )))                        (|if| (OR (EQ XQP::TMP.COUNT XQP::STOP.COUNT)                                  (EOFP STREAM))                            |then| (SETQ ERR (LIST 3 (SUB1 XQP::STOP.COUNT)                                                   STREAM))                                  (SETQ STOP 1))                |elseif| (AND (EQ CHAR 42)                              (EQ XQP::PREV.CHAR 47))                  |then| (SETQ CHAR (\\BIN STREAM))                        (SETQ XQP::TMP.COUNT 0)                        (WHILE                               (* \; "we have a slash star comment")                               (AND (NOT (AND (EQ CHAR 47)   (* \; "slash")                                              (EQ XQP::PREV.CHAR 42)                                                             (* \; "star")                                              ))                                    (NOT (EOFP STREAM))                                    (ILESSP XQP::TMP.COUNT XQP::STOP.COUNT))                               (SETQ XQP::PREV.CHAR CHAR)                               (SETQ CHAR (\\BIN STREAM))                               (SETQ XQP::TMP.COUNT (ADD1 XQP::TMP.COUNT)))                        (|if| (OR (EQ XQP::TMP.COUNT XQP::STOP.COUNT)                                  (EOFP STREAM))                            |then| (SETQ ERR (LIST 4 (SUB1 XQP::STOP.COUNT)                                                   STREAM))                                  (SETQ STOP 1))                |elseif|                                     (* \; "we have a percent comment")                      (EQ CHAR 37)                           (* \; "percent")                  |then| (XQP::END.OF.LINE STREAM))              (SETQ XQP::PREV.CHAR CHAR))        (|if| (OR ERR (AND (EOFP STREAM)                           (NEQ CHAR 46)                     (* \; "period")                           ))            |then| (\\SETUPGETCH XQP::ORI.POSITION (TEXTOBJ STREAM))                  (XQP::TEDIT.ERROR.MESSAGE ERR)             (* \;                                                           "See FINDARITY.LSP for TEDIT.ERROR.MESSAGE")          |elseif| (EOFP STREAM)            |then| (\\TEXTGETFILEPTR STREAM)          |else| (ADD1 (\\TEXTGETFILEPTR STREAM)))))(* |;;| "------------------------- get-name  ------------------------- ")(XQP::DEFUNC XQP::GET.PRED.NAME (STREAM)   (LET ((NAME.LIST NIL)         CHAR RESULT)        (SETQ RESULT (WHILE (AND (SETQ CHAR (\\BIN STREAM))                                 (NOT (OR (EQ CHAR (CHARCODE \())                                                             (* \; ")")                                          (EQ CHAR (CHARCODE SPACE))                                          (EQ CHAR (CHARCODE :||))                                          (EQ CHAR (CHARCODE \.))                                          (EQ CHAR (CHARCODE LF))                                          (EQ CHAR (CHARCODE EOL))                                          (EQ CHAR (CHARCODE TAB))                                          (EQ CHAR (CHARCODE \,))                                          (EQ CHAR (CHARCODE -))                                          (EQ CHAR (CHARCODE \;))))                                 (NOT (EOFP STREAM))) |collect| CHAR))        (|if| (NOT (EOFP STREAM))            |then| RESULT          |else| NIL)))(* |;;| "-------------------------find-first-predicate ---------------------- --------------------------------------------------------------------")(XQP::DEFUNC XQP::FIND.FIRST.PREDICATE (SELECTION) (LET* ((TEXT (|fetch| (SELECTION \\TEXTOBJ)                                                                   |of| SELECTION))                                                          (STREAM (|fetch| (TEXTOBJ STREAMHINT)                                                                     |of| TEXT))                                                          (XQP::LINE.DESC (CAR (|fetch| (SELECTION                                                                                         LN)                                                                                  |of| SELECTION)))                                                          (FIRST (|fetch| (LINEDESCRIPTOR CHAR1)                                                                    |of| XQP::LINE.DESC)))                                                         (\\SETUPGETCH (IMIN FIRST                                                                             (|fetch| (TEXTOBJ                                                                                              TEXTLEN)                                                                                |of| TEXT))                                                                TEXT)                                                         (XQP::FIND.FIRST.PREDICATE.AUX STREAM)))(* |;;| "---------------------------------------------------------------------- This function assumes that the file pointer is in column 1 of the line")(XQP::DEFUNC XQP::FIND.FIRST.PREDICATE.AUX (STREAM)   (LET* ((FOUND NIL)          CHAR POS)         (SETQ POS (ADD1 (\\TEXTGETFILEPTR STREAM)))         (SETQ CHAR (\\BIN STREAM))         (\\BACKBIN STREAM)         (WHILE (AND (NEQ POS 1)                     (OR (EQ CHAR 13)                        (* \; "carriage return")                         (EQ CHAR 32)                        (* \; "space")                         (EQ CHAR 9)                         (* \; "tab")                         (EQ CHAR 37)                        (* \; "percent sign")                         (EQ CHAR 47)                        (* \; "slash")                         )) DO (\\BACKBIN STREAM)                               (XQP::BEGINNING.OF.LINE STREAM)                               (SETQ CHAR (\\BIN STREAM))                               (\\BACKBIN STREAM)                               (SETQ POS (ADD1 (\\TEXTGETFILEPTR STREAM))))         (|if| (AND (NEQ CHAR 42)                    (OR (NEQ POS 1)                        (AND (EQ POS 1)                             (NEQ CHAR 13)                   (* \; "carriage return")                             (NEQ CHAR 32)                   (* \; "space")                             (NEQ CHAR 9)                    (* \; "tab")                             (NEQ CHAR 37)                   (* \; "percent sign")                             (NEQ CHAR 47)                   (* \; "slash")                             )))             |then| (SETQ FOUND POS)           |else| (XQP::END.OF.LINE STREAM)                 (WHILE (AND (NOT (EOFP STREAM))                             (OR (EQ CHAR 13)                                 (EQ CHAR 32)                                 (EQ CHAR 9)                                 (EQ CHAR 37)                                 (EQ CHAR 47)                                 (EQ CHAR 42)))                        (SETQ CHAR (\\BIN STREAM))                        (\\BACKBIN STREAM)                        (XQP::END.OF.LINE STREAM))                 (|if| (EOFP STREAM)                     |then| (XQP::BEGINNING.OF.LINE STREAM)                   |else| (\\BACKBIN STREAM)                         (XQP::BEGINNING.OF.LINE STREAM)                         (SETQ FOUND (ADD1 (\\TEXTGETFILEPTR STREAM)))))         FOUND))(XQP::DEFUNC XQP::BEGINNING.OF.LINE (STREAM) (LET ((POS (ADD1 (\\TEXTGETFILEPTR STREAM)))                                                   CHAR)                                                  (|if| (IGREATERP POS 1)                                                      |then| (REPEATUNTIL (OR (EQ CHAR 13)                                                                              (EQ POS 1))                                                                DO (SETQ CHAR (\\BACKBIN STREAM))                                                                   (SETQ POS (SUB1 POS))))                                                             (* \;                                                  "This is needed in case the beginning of a line is ")                                                  (|if| (EQ CHAR 13)                                                      |then| (\\BIN STREAM))                                                             (* \; "also the beginning of file")                                                  ))(XQP::DEFUNC XQP::END.OF.LINE (STREAM) (UNTIL (OR (EOFP STREAM)                                                  (EQ (\\BIN STREAM)                                                      13)) DO T))(PUTPROPS FINDPRED COPYRIGHT ("Quintus Computer Systems, Inc" 1987))(DECLARE\: DONTCOPY  (FILEMAP (NIL)))STOP