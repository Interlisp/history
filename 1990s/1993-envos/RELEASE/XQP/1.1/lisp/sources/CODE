(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)(FILECREATED "25-Jun-87 14:45:56" {ERIS}<PROLOGCORE>LYRIC>LISP>CODE.\;5 17451        |previous| |date:| "24-Jun-87 19:39:36" {ERIS}<PROLOGCORE>LYRIC>LISP>CODE.\;4); Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.(PRETTYCOMPRINT CODECOMS)(RPAQQ CODECOMS ((* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>CODE.LSP;1, loaded 15-Jun-87 18:12:55")                                     (* |;;| "SCCS   : @(#)CODE.LSP	8204.8  5/19/87 File   : $xerox/code.lsp Author : Richard A. O'Keefe Purpose: define macros for accessing the code stream")                 (* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")                                     (* |;;| "code.24 is the list of registers that could hold code pointers")                 (CONSTANTS XQP::|code.24|)                                     (* |;;| "(get.code Ptr Offset) fetches a 16-bit integer from the code pointer Ptr+Offset.")                 (FUNCTIONS XQP::|get.code|)                                     (* |;;|           "(get.code.ptr Ptr Offset) fetches a 24-bit pointer from the code pointer Ptr+Offset.")                 (FUNCTIONS XQP::|get.code.ptr|)                                     (* |;;| "(get.code.byte Ptr Offset Byte) fetches an 8-bit byte from the code pointer Ptr+Offset.  If Byte=0, fetch the most significant byte of the word; if Byte=1, fetch the least significant byte.")                 (FUNCTIONS XQP::|get.code.byte|)                                     (* |;;|           "(put.code Ptr Offset Value) stores a 16-bit integer at the code pointer Ptr+Offset.")                 (FUNCTIONS XQP::|put.code|)                                     (* |;;|           "(put.code.ptr Ptr Offset Value) stores a 24-bit pointer at the code pointer Ptr+Offset.")                 (FUNCTIONS XQP::|put.code.ptr|)                                     (* |;;| "(put.code.byte Ptr Offset Byte Value) stores an 8-bit byte at the code pointer Ptr+Offset.  If Byte=0, store in the most significant byte of the word; if Byte=1, store in the least significant byte.")                 (FUNCTIONS XQP::|put.code.byte|)                                     (* |;;|      "(add.code Ptr Offset) adds an Offset (expressed in units of 16-bit opcodes) to a code pointer.")                 (FUNCTIONS XQP::|add.code|)                                     (* |;;| "This macro fetches a 24-bit instruction or procedure address from the code stream.  It does not advance P, because P will change in a short while anyway.  It is used by instructions (address ?other). The code used to read (\\VAG2 (get.16 N) (get.code P 0)), and the callers are carefully written to ensure that N is not changed. That is a good thing to do in micro-code, but in Lisp macro-code the old version took 10.2 usec, while this takes 8.7 usec.")                                     (* |;;| "news flash:  The newer, faster version  (\\GETBASEPTR (get.24 P) -1) died a horrible death when crossing a page boundry, so this had to be changed back to the old \\VAG2 version.")                 (FUNCTIONS XQP::|address.operand|)                                     (* |;;| "This macro fetches a 24-bit clause address from the code stream.  It is only used by the interpret.me and dynamic.index instructions. The address will be doubleword aligned.  Therefore, since P is incremented when the instruction is being executed, and since the interpret.me and dynamic.index instructions are both always doubleword aligned, we must skip over the word following P in order for the next field to be doubleword aligned.")                 (CONSTANTS XQP::|after.dyn.next|)                 (FUNCTIONS XQP::|next.address.operand|)                                     (* |;;| "This macro fetches a 32-bit tagged cell from the code stream.  It does not advance P, and leaves that up to the caller. Several instructions take a cell as an operand. This involves fetching from P twice.  A full 32-bit value is returned.  This is particularly hairy, because we have to be able to put it in a register or in memory.  Register moves want Tag and Ptr, memory moves want HI and LO.  Alas, the register moves have to make do with HI and LO, as GETBASEPTR isn't supposed to work when P is odd.")                 (PROP HI XQP::|cell.operand|)                 (PROP LO XQP::|cell.operand|)                                     (* |;;| "This macro is used in call.lisp and index.lisp. It calculates the top of the local stack as E + env_size(CP)*cells where CP points to a 16-bit word.")                 (FUNCTIONS XQP::|E.plus.env.size.from.CP|)                                     (* |;;| "These macros used to be part of the interpreter. They are all the various ways of ending an instruction, other than failing.  In the mixed LISP/ucode emulator, all they have to do is return the desired value of P, and perhaps set the W register. Only continue.{reading.|writing.|}at has to return an absolute PC. The other instructions *could* do so (and once did), but now the \\ADDBASE is done in the micro-code, so they just return the offset (in 16-bit words).  This offset is one less than the size of the instruction, but we can't build that into the dispatch table, as most of the instructions can fail, and (fast.fail) returns an absolute PC.")                 (FUNCTIONS XQP::|continue| XQP::|read.continue| XQP::|write.continue|                         XQP::|continue.reading| XQP::|continue.writing|)                                     (* |;;| "The preceding forms were for offsets.  These forms are for absolute addresses.  With the current microcode, they are identical, but this was not always true and may not be true in another port.  Previously, continue.at and continue.reading.at were synonyms.  This is no longer so.  continue.at now DOES NOT CHANGE the W register.")                 (FUNCTIONS XQP::|continue.reading.at| XQP::|continue.writing.at| XQP::|continue.at|)                                     (* |;;| "The purpose of this function is to convince the file package to create a .DCOM file which it otherwise doesn't want to do.")                 (FUNCTIONS XQP::|dummy.code|)                 (PROP MAKEFILE-ENVIRONMENT)))(* |;;;| "This file was generated from {ERIS}<PROLOGCORE>LISPNEW>CODE.LSP;1, loaded 15-Jun-87 18:12:55")(* |;;| "SCCS   : @(#)CODE.LSP	8204.8  5/19/87 File   : $xerox/code.lsp Author : Richard A. O'Keefe Purpose: define macros for accessing the code stream")(* |;;;| "------------------------------------------------------------------------  WARNING: This material is CONFIDENTIAL and proprietary to Quintus Computer Systems Inc.  This notice is protection against inadvertent disclosure and does not constitute publication or reflect any intent to publish.  Copyright (C) 1985, by Quintus Computer Systems, Inc. All rights reserved.  CAVEAT LECTOR: This software is under development.  No warrantee is made that it is any use for anything at all.  ------------------------------------------------------------------------")(* |;;| "code.24 is the list of registers that could hold code pointers")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|code.24| (P E CP S R C XQP::|CurClause|))(CONSTANTS XQP::|code.24|))(* |;;| "(get.code Ptr Offset) fetches a 16-bit integer from the code pointer Ptr+Offset.")(XQP::|def.macro| XQP::|get.code| (XQP::|Ptr| |Offset|) (|if| (NOT (MEMB XQP::|Ptr| XQP::|code.24|))                                                            |then| (SHOULDNT 'XQP::|get.code|))                                                        `(\\GETBASE (XQP::|get.24| ,XQP::|Ptr|)                                                                ,|Offset|))(* |;;| "(get.code.ptr Ptr Offset) fetches a 24-bit pointer from the code pointer Ptr+Offset.")(XQP::|def.macro| XQP::|get.code.ptr| (XQP::|Ptr| |Offset|) (|if| (NOT (MEMB XQP::|Ptr|                                                                              XQP::|code.24|))                                                                |then| (SHOULDNT 'XQP::|get.code|))                                                            `(\\GETBASEPTR (XQP::|get.24|                                                                            ,XQP::|Ptr|)                                                                    ,|Offset|))(* |;;| "(get.code.byte Ptr Offset Byte) fetches an 8-bit byte from the code pointer Ptr+Offset.  If Byte=0, fetch the most significant byte of the word; if Byte=1, fetch the least significant byte.")(XQP::|def.macro| XQP::|get.code.byte| (XQP::|Ptr| |Offset| XQP::|Byte|)   (|if| (NOT (MEMB XQP::|Ptr| XQP::|code.24|))       |then| (SHOULDNT 'XQP::|get.code|))   `(\\GETBASEBYTE (XQP::|get.24| ,XQP::|Ptr|)           (IPLUS (ITIMES ,|Offset| 2)                  ,XQP::|Byte|)))(* |;;| "(put.code Ptr Offset Value) stores a 16-bit integer at the code pointer Ptr+Offset.")(XQP::|def.macro| XQP::|put.code| (XQP::|Ptr| |Offset| XQP::|Value|)   (|if| (NOT (MEMB XQP::|Ptr| XQP::|code.24|))       |then| (SHOULDNT 'XQP::|put.code|))   `(\\PUTBASE (XQP::|get.24| ,XQP::|Ptr|)           ,|Offset|           ,XQP::|Value|))(* |;;| "(put.code.ptr Ptr Offset Value) stores a 24-bit pointer at the code pointer Ptr+Offset.")(XQP::|def.macro| XQP::|put.code.ptr| (XQP::|Ptr| |Offset| XQP::|Value|)   (|if| (NOT (MEMB XQP::|Ptr| XQP::|code.24|))       |then| (SHOULDNT 'XQP::|put.code|))   `(\\PUTBASEPTR (XQP::|get.24| ,XQP::|Ptr|)           ,|Offset|           ,XQP::|Value|))(* |;;| "(put.code.byte Ptr Offset Byte Value) stores an 8-bit byte at the code pointer Ptr+Offset.  If Byte=0, store in the most significant byte of the word; if Byte=1, store in the least significant byte.")(XQP::|def.macro| XQP::|put.code.byte| (XQP::|Ptr| |Offset| XQP::|Byte| XQP::|Value|)   (|if| (NOT (MEMB XQP::|Ptr| XQP::|code.24|))       |then| (SHOULDNT 'XQP::|put.code|))   `(\\PUTBASEBYTE (XQP::|get.24| ,XQP::|Ptr|)           (IPLUS (ITIMES ,|Offset| 2)                  ,XQP::|Byte|)           ,XQP::|Value|))(* |;;| "(add.code Ptr Offset) adds an Offset (expressed in units of 16-bit opcodes) to a code pointer.")(XQP::|def.macro| XQP::|add.code| (XQP::|Ptr| |Offset|)   (|if| (NOT (MEMB XQP::|Ptr| XQP::|code.24|))       |then| (SHOULDNT 'XQP::|add.code|))   (|if| (EQ |Offset| 0)       |then| `(XQP::|get.24| ,XQP::|Ptr|)     |else| `(\\ADDBASE (XQP::|get.24| ,XQP::|Ptr|)                    ,|Offset|)))(* |;;| "This macro fetches a 24-bit instruction or procedure address from the code stream.  It does not advance P, because P will change in a short while anyway.  It is used by instructions (address ?other). The code used to read (\\VAG2 (get.16 N) (get.code P 0)), and the callers are carefully written to ensure that N is not changed. That is a good thing to do in micro-code, but in Lisp macro-code the old version took 10.2 usec, while this takes 8.7 usec.")(* |;;| "news flash:  The newer, faster version  (\\GETBASEPTR (get.24 P) -1) died a horrible death when crossing a page boundry, so this had to be changed back to the old \\VAG2 version.")(XQP::|def.open| XQP::|address.operand| NIL (\\VAG2 (XQP::|get.16| N)                                                   (XQP::|get.code| P 0)))(* |;;| "This macro fetches a 24-bit clause address from the code stream.  It is only used by the interpret.me and dynamic.index instructions. The address will be doubleword aligned.  Therefore, since P is incremented when the instruction is being executed, and since the interpret.me and dynamic.index instructions are both always doubleword aligned, we must skip over the word following P in order for the next field to be doubleword aligned.")(DECLARE\: EVAL@COMPILE (RPAQQ XQP::|after.dyn.next| 1)(CONSTANTS XQP::|after.dyn.next|))(XQP::|def.open| XQP::|next.address.operand| NIL (XQP::|get.code.ptr| P XQP::|after.dyn.next|))(* |;;| "This macro fetches a 32-bit tagged cell from the code stream.  It does not advance P, and leaves that up to the caller. Several instructions take a cell as an operand. This involves fetching from P twice.  A full 32-bit value is returned.  This is particularly hairy, because we have to be able to put it in a register or in memory.  Register moves want Tag and Ptr, memory moves want HI and LO.  Alas, the register moves have to make do with HI and LO, as GETBASEPTR isn't supposed to work when P is odd.")(PUTPROPS XQP::|cell.operand| HI (LAMBDA NIL '(XQP::|get.code| P 0)))(PUTPROPS XQP::|cell.operand| LO (LAMBDA NIL '(XQP::|get.code| P 1)))(* |;;| "This macro is used in call.lisp and index.lisp. It calculates the top of the local stack as E + env_size(CP)*cells where CP points to a 16-bit word.")(XQP::|def.open| XQP::|E.plus.env.size.from.CP| NIL (XQP::|add.code| E (XQP::|get.code| CP 0)))(* |;;| "These macros used to be part of the interpreter. They are all the various ways of ending an instruction, other than failing.  In the mixed LISP/ucode emulator, all they have to do is return the desired value of P, and perhaps set the W register. Only continue.{reading.|writing.|}at has to return an absolute PC. The other instructions *could* do so (and once did), but now the \\ADDBASE is done in the micro-code, so they just return the offset (in 16-bit words).  This offset is one less than the size of the instruction, but we can't build that into the dispatch table, as most of the instructions can fail, and (fast.fail) returns an absolute PC.")(XQP::|def.macro| XQP::|continue| (N) (|if| (NOT (SMALLP N))                                          |then| (SHOULDNT 'XQP::|continue|))                                      N)(XQP::|def.macro| XQP::|read.continue| (N) (|if| (NOT (SMALLP N))                                               |then| (SHOULDNT 'XQP::|read.continue|))                                           N)(XQP::|def.macro| XQP::|write.continue| (N) (|if| (NOT (SMALLP N))                                                |then| (SHOULDNT 'XQP::|write.continue|))                                            N)(XQP::|def.macro| XQP::|continue.reading| (N) (|if| (NOT (SMALLP N))                                                  |then| (SHOULDNT 'XQP::|continue.reading|))                                              `(PROGN (XQP::|put.4| W READ)                                                      ,N))(XQP::|def.macro| XQP::|continue.writing| (N) (|if| (NOT (SMALLP N))                                                  |then| (SHOULDNT 'XQP::|continue|))                                              `(PROGN (XQP::|put.4| W WRITE)                                                      ,N))(* |;;| "The preceding forms were for offsets.  These forms are for absolute addresses.  With the current microcode, they are identical, but this was not always true and may not be true in another port.  Previously, continue.at and continue.reading.at were synonyms.  This is no longer so.  continue.at now DOES NOT CHANGE the W register.")(XQP::|def.macro| XQP::|continue.reading.at| (X) (|if| (OR (NULL X)                                                           (NUMBERP X))                                                     |then| (SHOULDNT 'XQP::|continue.reading.at|))                                                 `(PROGN (XQP::|put.4| W READ)                                                         ,X))(XQP::|def.macro| XQP::|continue.writing.at| (X) (|if| (OR (NULL X)                                                           (NUMBERP X))                                                     |then| (SHOULDNT 'XQP::|continue.writing.at|))                                                 `(PROGN (XQP::|put.4| W WRITE)                                                         ,X))(XQP::|def.macro| XQP::|continue.at| (X) (|if| (OR (NULL X)                                                   (NUMBERP X))                                             |then| (SHOULDNT 'XQP::|continue.at|))                                         X)(* |;;| "The purpose of this function is to convince the file package to create a .DCOM file which it otherwise doesn't want to do.")(XQP::|def.subr| XQP::|dummy.code| NIL NIL)(PUTPROPS CODE COPYRIGHT ("Quintus Computer Systems, Inc" 1987))(DECLARE\: DONTCOPY  (FILEMAP (NIL)))STOP