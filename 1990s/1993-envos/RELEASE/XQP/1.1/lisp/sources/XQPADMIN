(DEFINE-FILE-INFO READTABLE "INTERLISP" PACKAGE (PROGN (FILESLOAD "XQPSETUP") "IL"))(FILECREATED "30-Nov-87 19:01:16" {DSK}<LISPFILES>DCOMS>XQPADMIN.;2 42480        changes to%:  (FNS XQP::QP.MAKE.ATOMSMASHER)      previous date%: "29-Sep-87 17:03:57" {DSK}<LISPFILES>DCOMS>XQPADMIN.;1)(* "Copyright (c) 1987 by Quintus Computer Systems, Inc.  All rights reserved.")(PRETTYCOMPRINT XQPADMINCOMS)(RPAQQ XQPADMINCOMS        ((* ;;; "This file defines functions necessary to administer the XQP system; it replaces NEWMAKEFILE, which is made obsolete by the Lyric port.  Note that the development methodology it assumes is much simpler than NEWMAKEFILE.  It is now assumed that all the files are copied to a development directory (usually on the local disk of the development machine), and all modifications are made there.  When release time comes, files are copied back to a central location and checked (back) into SCCS.  Also, since all files are now managed (ie, maintained by the file manager), it is no longer necessary to maintain all the messy and confusing code that loaded text files and informed the file manager about functions, variables, etc., so that the files could be compiled.")        (FILES "XQPLISTS"                                    (* ; "lots of data pertinent to the administration of the XQP system.  Kept in a separate file to make changes easier."))        (GLOBALVARS XQP::QP.DEFAULT.LISP.NO.SOURCE.HOST/DIR XQP::QP.DEFAULT.LISP.SOURCE.HOST/DIR                XQP::QP.DEFAULT.LISP.OBJECT.HOST/DIR XQP::QP.DEFAULT.PROLOG.SOURCE.HOST/DIR                XQP::QP.DEFAULT.PROLOG.OBJECT.HOST/DIR COMPILE.EXT NETWORKOSTYPES)        (GLOBALVARS XQP::QP.RELEASE.LISP.FILES XQP::QP.RELEASE.LISP.EXTRAS                XQP::QP.GENERATED.LISP.FILES XQP::QP.GENERATED.PROLOG.FILES                XQP::QP.NON.SYSOUT.RELEASE.FILES XQP::QP.XEROX.LISP.FILES XQP::QP.XEROX.LISP.EXTRAS                XQP::QP.XEROX.NON.SYSOUT.RELEASE.FILES XQP::QP.DEVELOPMENT.LISP.FILES                XQP::QP.DEVELOPMENT.LISP.LOAD.AFTER XQP::QP.LISP.LIBRARY.FILES                XQP::QP.DEVELOPMENT.LISP.LIBRARY.FILES XQP::QP.PROLOG.USERS.LISP.FILES                XQP::QP.NO.DCOM.FILES XQP::QP.NO.SOURCE.FILES XQP::DNGLIST)        (FUNCTIONS XQP::COMPILE-XQP XQP::LOAD-XQP)        (FNS XQP::QP.LISP.FILES XQP::QP.MAKE.ATOMSMASHER)        (FNS XQP::QP.COPY.DNGS XQP::QP.COPY.NO.SOURCE.FILES XQP::QP.GENERATE.FILES              XQP::QP.LOAD.DNGLIST XQP::QP.LOAD.DNGS XQP::QP.LOAD.PREREQUISITES              XQP::QP.MAKE.PROLOGBOOT)        (* ;;; "Our definers are now in this file, so as not to be in the release.  Ultimately, macros and constants should be taken out of releases, too.  This requires a technology for loading the definers, macros, and constants in order to do development work.  Someday.")        (* ;;; "Bill's definers")        (FUNCTIONS XQP::DEFMACROC XQP::DEFRECORD XQP::DEFUNC XQP::def.interface.fn)        (* ;;; "Richard's definers")        (FUNCTIONS XQP::def.global XQP::def.macro XQP::def.nlambda XQP::def.open XQP::def.props                XQP::def.struct XQP::def.subr XQP::def.var)        (* ;;; "Auxilliary functions from Bill's and Richard setup files (UTIL.LSP and BASIC.LSP) ")        (FUNCTIONS XQP::CANONICAL.REST XQP::DEFMACROC.ARGLIST XQP::DEFMACROC.BODY)        (FNS XQP::GLOBALVAR.ON.FILE)        (PROP MAKEFILE-ENVIRONMENT XQPADMIN)))(* ;;; "This file defines functions necessary to administer the XQP system; it replaces NEWMAKEFILE, which is made obsolete by the Lyric port.  Note that the development methodology it assumes is much simpler than NEWMAKEFILE.  It is now assumed that all the files are copied to a development directory (usually on the local disk of the development machine), and all modifications are made there.  When release time comes, files are copied back to a central location and checked (back) into SCCS.  Also, since all files are now managed (ie, maintained by the file manager), it is no longer necessary to maintain all the messy and confusing code that loaded text files and informed the file manager about functions, variables, etc., so that the files could be compiled.")(FILESLOAD "XQPLISTS")(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS XQP::QP.DEFAULT.LISP.NO.SOURCE.HOST/DIR XQP::QP.DEFAULT.LISP.SOURCE.HOST/DIR        XQP::QP.DEFAULT.LISP.OBJECT.HOST/DIR XQP::QP.DEFAULT.PROLOG.SOURCE.HOST/DIR        XQP::QP.DEFAULT.PROLOG.OBJECT.HOST/DIR COMPILE.EXT NETWORKOSTYPES))(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS XQP::QP.RELEASE.LISP.FILES XQP::QP.RELEASE.LISP.EXTRAS XQP::QP.GENERATED.LISP.FILES        XQP::QP.GENERATED.PROLOG.FILES XQP::QP.NON.SYSOUT.RELEASE.FILES XQP::QP.XEROX.LISP.FILES        XQP::QP.XEROX.LISP.EXTRAS XQP::QP.XEROX.NON.SYSOUT.RELEASE.FILES        XQP::QP.DEVELOPMENT.LISP.FILES XQP::QP.DEVELOPMENT.LISP.LOAD.AFTER XQP::QP.LISP.LIBRARY.FILES        XQP::QP.DEVELOPMENT.LISP.LIBRARY.FILES XQP::QP.PROLOG.USERS.LISP.FILES XQP::QP.NO.DCOM.FILES        XQP::QP.NO.SOURCE.FILES XQP::DNGLIST))(CL:DEFUN XQP::COMPILE-XQP (&OPTIONAL XQP::MAKE? (XQP::STORE-INCORE? T)                                  (XQP::STARTWITH 1))   (if (NOT (GETPROP 'EXPORTS.ALL 'FILE))       then (LOAD 'EXPORTS.ALL))   (LET ((FILES (XQP::QP.LISP.FILES)))        (for FL in (if (AND (SMALLP XQP::STARTWITH)                            (>= XQP::STARTWITH 1)                            (<= XQP::STARTWITH (LENGTH FILES)))                       then (NTH FILES XQP::STARTWITH)                     elseif (MEMB XQP::STARTWITH FILES)                       then (MEMB XQP::STARTWITH FILES)                     else (ERROR "STARTWITH not valid" XQP::STARTWITH))           do (if XQP::MAKE?                  then (MAKEFILE FL '(NEW C ST))                else (PRINTOUT T "Compiling " FL "..." T)                     (CL:COMPILE-FILE FL)                     (if XQP::STORE-INCORE?                         then (LOAD (PACKFILENAME.STRING 'EXTENSION "dfasl" 'BODY FL)))                     (PRINTOUT NIL FL " compiled" T)))))(CL:DEFUN XQP::LOAD-XQP (&OPTIONAL XQP::SOURCE? XQP::COMS-ONLY? XQP::PROP? (XQP::STARTWITH 1))   (if (NOT (GETPROP 'EXPORTS.ALL 'FILE))       then (LOAD 'EXPORTS.ALL))   (LET ((FILES (XQP::QP.LISP.FILES)))        (for FL in (if (AND (SMALLP XQP::STARTWITH)                            (>= XQP::STARTWITH 1)                            (<= XQP::STARTWITH (LENGTH FILES)))                       then (NTH FILES XQP::STARTWITH)                     elseif (MEMB XQP::STARTWITH FILES)                       then (MEMB XQP::STARTWITH FILES)                     else (ERROR "STARTWITH not valid" XQP::STARTWITH))           do (if XQP::SOURCE?                  then (LOAD FL (if XQP::PROP?                                    then 'PROP))                elseif XQP::COMS-ONLY?                  then (LOADVARS (FILECOMS FL)                              FL)                else (APPLY* #'FILESLOAD FL)))))(DEFINEQ(XQP::QP.LISP.FILES  (LAMBDA NIL                                                (* ; "Edited 13-Jul-87 15:36 by pds")    (APPEND XQP::QP.DEVELOPMENT.LISP.FILES XQP::QP.RELEASE.LISP.FILES XQP::QP.RELEASE.LISP.EXTRAS            XQP::QP.DEVELOPMENT.LISP.LOAD.AFTER)))(XQP::QP.MAKE.ATOMSMASHER  (LAMBDA NIL                                                (* ; "Edited 30-Nov-87 18:18 by pds")    (LET*     ((XQP::FILESET (APPEND '("FASTPROLOG" "PROLOGBOOT") XQP::QP.RELEASE.LISP.FILES)                                                             (* ; "the files to smash atoms in")             )      (XQP::POSSIBLY.REDUNDANT       (SORT (APPEND XQP::QP.PROLOG.SYSTEM.MODULES                    (bind FNAME COMSNAME XQP::UNLOADED for FL in XQP::FILESET                       join (SETQ COMSNAME (FILECOMS (SETQ FNAME (MKATOM FL))))                            (if (SETQ XQP::UNLOADED (NOT (AND (BOUNDP COMSNAME)                                                              (EVAL COMSNAME))))                                then                     (* ;; "first make sure that the file's coms are around!")                                     (LOADVARS COMSNAME (PACKFILENAME.STRING 'NAME FNAME 'BODY                                                                XQP::QP.DEFAULT.LISP.OBJECT.HOST/DIR))                                )                            (PROG1 (APPEND (for ITEM in (FILECOMSLST FNAME 'VARS) collect ITEM                                              when (AND (LITATOM ITEM)                                                        (NEQ ITEM COMSNAME)))                                          (bind FNNAME for ITEM in (FILECOMSLST FNAME '                                                                          XQP::WRITE-INSTRUCTIONS)                                             when (AND (SETQ FNNAME (CL:FIND-SYMBOL (CONCAT "W." ITEM                                                                                           )                                                                           "XQP"))                                                       (LITATOM FNNAME)) collect FNNAME)                                          (bind FNNAME for ITEM in (FILECOMSLST FNAME 'INSTRUCTIONS)                                             when (AND (SETQ FNNAME (OR (CL:FIND-SYMBOL (CONCAT                                                                                         "R." ITEM)                                                                               "XQP")                                                                        (CL:FIND-SYMBOL (CONCAT                                                                                         "B." ITEM)                                                                               "XQP")                                                                        (CL:FIND-SYMBOL (CONCAT                                                                                         "S." ITEM)                                                                               "XQP")))                                                       (LITATOM FNNAME)) collect FNNAME)                                          (for TYPE                                             in '(PROPERTIES XQP::WRITE-INSTRUCTIONS INSTRUCTIONS                                                         STRUCTURES SETFS I.S.OPRS USERMACROS RECORDS                                                         PROPS MACROS FNS FIELDS EXPRESSIONS ALISTS                                                         SPECIAL-FORMS TYPES VARIABLES FUNCTIONS                                                         DEFINE-TYPES)                                             join (for ITEM in (FILECOMSLST FNAME TYPE) collect                                                                                        ITEM                                                     when (LITATOM ITEM))))                                   (if XQP::UNLOADED                                       then                  (* ; "restore file to unloaded state")                                            (SMASHFILECOMS FNAME)                                            (DREMOVE FNAME FILELST)                                            (REMPROP FNAME 'FILE)                                            (REMPROP FNAME 'FILEDATES)                                            (REMPROP FNAME 'COPYRIGHT)))))             #'(LAMBDA (X Y)                 (< (fetch (LITATOM PNAMECELL PNAMEBASE PNAMELENGTH) of X)                  (fetch (LITATOM PNAMECELL PNAMEBASE PNAMELENGTH) of Y))))                                                             (* ;                  "the list of candidate atoms to smash, sorted by length, with possible duplications")       )      (XQP::TO.PRUNE (INTERSECTION XQP::POSSIBLY.REDUNDANT XQP::POSSIBLY.REDUNDANT)                                                             (* ;                                       "the list of candidate atoms to smash, with duplicates removed")             )      (XQP::TO.SMASH (LDIFFERENCE XQP::TO.PRUNE XQP::ATOMS.NOT.TO.SMASH)                                                             (* ; "The list of atoms to smash")             ))     (SETQ ATOMSMASHERCOMS      `(            (* ;; (\, (CONCAT "ATOMSMASHER generated "          (DATE) " by (QP.MAKE.ATOMSMASHER)")))                                                             (* ; "Render XQP secure by smashing all the symbols in the system with something unreadable.  Of course, some symbols must not be smashed.")        (P (bind (FL _ (if XQP::ATOM.SMASHER.ANTIDOTE.FILE                           then (OPENSTREAM XQP::ATOM.SMASHER.ANTIDOTE.FILE 'OUTPUT)))              first (if FL                        then (PRINTOUT FL (LIST (FUNCTION VERIFY.ATOM.SMASH.SYSOUT)                                                (KWOTE (SETQ XQP::\AtomSmashSysout (LIST (IDATE)                                                                                                                                                                              \MY.NSHOSTNUMBER                                                                                         ))))                                    T)) for ATM in ',XQP::TO.SMASH              do (if FL                     then (PRINTOUT FL "(\UnSmashAtom " |.I5| (\LOLOC ATM)                                 " %"" ATM "%" %"" (CL:PACKAGE-NAME (CL:SYMBOL-PACKAGE ATM))                                 "%")" T))                 (\SmashAtom ATM) finally (if FL                                              then (PRINTOUT FL T "STOP" T)                                                   (PRINTOUT T                                                           "Atom smasher antidote file written in "                                                          (CLOSEF FL)                                                          T))))))     (ADDFILE 'XQP::ATOMSMASHER)     (MAKEFILE 'XQP::ATOMSMASHER '(NEW))))))(DEFINEQ(XQP::QP.COPY.DNGS  (LAMBDA (FILES XQP::FROMDIR XQP::TODIR XQP::STARTWITH XQP::ENDWITH)                                                             (* ; "Edited 29-Sep-87 16:33 by pds")(* ;;; "Copy the files on list FILES from FROMDIR to TODIR.  FROMDIR defaults to QP.DEFAULT.PROLOG.SOURCE.HOST/DIR;  TODIR defaults to QP.DEFAULT.PROLOG.OBJECT.HOST/DIR.  If FROMDIR is T, then copy from the current connected directory.  If TODIR is T, then copy to the current connected directory.  FILES defaults to QP.SYSTEM.FILES")                    (* ;; "If STARTWITH is supplied, it must be either an integer or an element of the list indicating which element to start copying with.  If ENDWITH is supplied, it must be either an integer or an element of the list indicating which element to stop copying with.  By default the whole list will be copied.")    (if (NULL FILES)        then (SETQ FILES XQP::DNGLIST)      elseif (NOT (LISTP FILES))        then (SETQ FILES (LIST FILES)))    (if (NULL XQP::FROMDIR)        then (SETQ XQP::FROMDIR XQP::QP.DEFAULT.PROLOG.SOURCE.HOST/DIR)      elseif (EQ XQP::FROMDIR T)        then (SETQ XQP::FROMDIR (DIRECTORYNAME T T)))    (if (NULL XQP::TODIR)        then (SETQ XQP::TODIR XQP::QP.DEFAULT.PROLOG.OBJECT.HOST/DIR)      elseif (EQ XQP::TODIR T)        then (SETQ XQP::TODIR (DIRECTORYNAME T T)))    (SETQ XQP::STARTWITH (OR (FIXP XQP::STARTWITH)                             (AND (ATOM XQP::STARTWITH)                                  (CL:POSITION XQP::STARTWITH FILES))                             (AND (NULL XQP::STARTWITH)                                  1)                             (ERROR "STARTWITH not on list of files" XQP::STARTWITH)))    (SETQ XQP::ENDWITH (OR (FIXP XQP::ENDWITH)                           (AND (ATOM XQP::ENDWITH)                                (CL:POSITION XQP::ENDWITH FILES))                           (AND (NULL XQP::ENDWITH)                                (LENGTH FILES))                           (ERROR "ENDWITH not on list of files" XQP::ENDWITH)))    (SETQ FILES (NTH FILES XQP::STARTWITH))    (printout T T "Copying " (ADD1 (IDIFFERENCE XQP::ENDWITH XQP::STARTWITH))           " files from " XQP::FROMDIR " to " XQP::TODIR ":" T T)    (bind SOURCEFILE TEMPFILE (XQP::THRUTEMP _ (ASSOC (FILENAMEFIELD (OR XQP::FROMDIR (DIRECTORYNAME                                                                                       T))                                                             'HOST)                                                      NETWORKOSTYPES)) for I from 0       to (IDIFFERENCE XQP::ENDWITH XQP::STARTWITH) as FILE in FILES       eachtime (SETQ SOURCEFILE (PACKFILENAME 'BODY FILE 'BODY XQP::FROMDIR))             (SETQ TEMPFILE (PACKFILENAME 'BODY FILE 'BODY 'XQP::{CORE}))       do (if (INFILEP SOURCEFILE)              then (printout T "copying " SOURCEFILE " ...")                   (if XQP::THRUTEMP                       then (COPYFILE SOURCEFILE TEMPFILE)                            (COPYFILE TEMPFILE (PACKFILENAME 'BODY FILE 'BODY XQP::TODIR))                            (DELFILE TEMPFILE)                     else (COPYFILE SOURCEFILE (PACKFILENAME 'BODY FILE 'BODY XQP::TODIR)))                   (printout T "done" T)            else (ERROR "can't find file" SOURCEFILE)))))(XQP::QP.COPY.NO.SOURCE.FILES  (LAMBDA (XQP::FILE.OR.LIST XQP::FROMDIR XQP::TODIR)        (* ; "Edited 14-Jul-87 11:24 by pds")(* ;;; "Copy FILE.OR.LIST from FROMDIR to TODIR.  FILE.OR.LIST may be either a single file name or a list, and defaults to QP.NO.SOURCE.FILES.  FROMDIR defaults to QP.DEFAULT.LISP.NO.SOURCE.HOST/DIR;  TODIR defaults to QP.DEFAULT.LISP.OBJECT.HOST/DIR.")    (DECLARE (GLOBALVARS COMPILE.EXT))    (if (NULL XQP::FILE.OR.LIST)        then (SETQ XQP::FILE.OR.LIST XQP::QP.NO.SOURCE.FILES)      elseif (NOT (LISTP FILES))        then (SETQ XQP::FILE.OR.LIST (LIST XQP::FILE.OR.LIST)))    (if (NULL XQP::FROMDIR)        then (SETQ XQP::FROMDIR XQP::QP.DEFAULT.LISP.NO.SOURCE.HOST/DIR))    (if (NULL XQP::TODIR)        then (SETQ XQP::TODIR XQP::QP.DEFAULT.LISP.OBJECT.HOST/DIR))    (PRINTOUT T "Copying from " XQP::FROMDIR " to " XQP::TODIR ":" T)    (for FL in XQP::FILE.OR.LIST do (PRINTOUT T "Copying " FL "...")                                    (COPYFILE (PACKFILENAME 'NAME FL 'EXTENSION COMPILE.EXT                                                     'BODY XQP::FROMDIR)                                           (PACKFILENAME 'NAME FL 'EXTENSION COMPILE.EXT 'BODY                                                   XQP::TODIR))                                    (PRINTOUT T "done" T))))(XQP::QP.GENERATE.FILES  (LAMBDA (FILEORLIST)                                       (* ; "Edited 25-Sep-87 20:30 by pds")    (if (NULL FILEORLIST)        then (SETQ FILEORLIST XQP::QP.GENERATED.LISP.FILES)      elseif (NOT (LISTP FILEORLIST))        then (SETQ FILEORLIST (LIST FILEORLIST)))    (RESETLST (RESETSAVE (/CNDIR XQP::QP.DEFAULT.LISP.OBJECT.HOST/DIR)                     `(/CNDIR ,(DIRECTORYNAME T)))           (for FL in FILEORLIST do (PRINTOUT T "Generating " FL "...")                                    (if (OR (CL:STRING= FL "FASTPROLOG")                                            (CL:STRING= FL "SLOWPROLOG"))                                        then (FILESLOAD (FROM VALUEOF                                                               XQP::QP.DEFAULT.LISP.OBJECT.HOST/DIR)                                                    "GEN")                                             (XQP::PROLOG.GEN.EMULATOR (CL:STRING= FL "SLOWPROLOG"))                                      elseif (CL:STRING= FL "PROLOGBOOT")                                        then (XQP::QP.MAKE.PROLOGBOOT)                                      elseif (CL:STRING= FL "ATOMSMASHER")                                        then (XQP::QP.MAKE.ATOMSMASHER)                                      elseif (CL:STRING= FL "ERRORTAB")                                        then (COPYFILE (PACKFILENAME 'NAME "ERRORTAB" 'BODY                                                               XQP::QP.DEFAULT.PROLOG.SOURCE.HOST/DIR)                                                    "ERRORTAB")                                      else (ERROR "don't know how to generate" FL))                                    (PRINTOUT T "done" T))           NIL)))(XQP::QP.LOAD.DNGLIST  (LAMBDA NIL                                                (* XQP::pds%: "23-May-86 13:43")    (LOAD (PACKFILENAME 'NAME '#:DNGFILES 'BODY XQP::QP.DEFAULT.PROLOG.SOURCE.HOST/DIR))))(XQP::QP.LOAD.DNGS  (LAMBDA (FILES XQP::HOST.DIR XQP::STARTWITH XQP::ENDWITH)  (* ; "Edited 29-Sep-87 16:32 by pds")(* ;;; "Reconsult the files on list FILES.  Default HOST.DIR is QP.DEFAULT.PROLOG.OBJECT.HOST/DIR.  If HOST.DIR is T, then load from the current connected directory.  FILES defaults to QP.PROLOG.FILES")                    (* ;; "If STARTWITH is supplied, it must be either an integer or an element of the list indicating which element to start loading with.  If ENDWITH is supplied, it must be either an integer or an element of the list indicating which element to stop loading with.  By default the whole list will be loaded.")    (if (NULL FILES)        then (SETQ FILES XQP::DNGLIST)      elseif (NOT (LISTP FILES))        then (SETQ FILES (LIST FILES)))    (if (NULL XQP::HOST.DIR)        then (SETQ XQP::HOST.DIR XQP::QP.DEFAULT.PROLOG.OBJECT.HOST/DIR)      elseif (EQ XQP::HOST.DIR T)        then (SETQ XQP::HOST.DIR (DIRECTORYNAME T)))    (SETQ XQP::STARTWITH (OR (FIXP XQP::STARTWITH)                             (AND (ATOM XQP::STARTWITH)                                  (CL:POSITION XQP::STARTWITH FILES))                             (AND (NULL XQP::STARTWITH)                                  1)                             (ERROR "STARTWITH not on list of files" XQP::STARTWITH)))    (SETQ XQP::ENDWITH (OR (FIXP XQP::ENDWITH)                           (AND (ATOM XQP::ENDWITH)                                (CL:POSITION XQP::ENDWITH FILES))                           (AND (NULL XQP::ENDWITH)                                (LENGTH FILES))                           (ERROR "ENDWITH not on list of files" XQP::ENDWITH)))    (SETQ FILES (NTH FILES XQP::STARTWITH))    (bind FULLNAME for I from 0 to (IDIFFERENCE XQP::ENDWITH XQP::STARTWITH) as FILE in FILES       join (if (INFILEP (SETQ FULLNAME (PACKFILENAME 'BODY XQP::HOST.DIR 'BODY FILE)))                then (printout T "Reconsulting " FULLNAME " ...")                     (XQP::RECONSULT FULLNAME)                     (printout T "done" T)                     (LIST FULLNAME)              else (printout T "Can't find " FULLNAME T)                   NIL))))(XQP::QP.LOAD.PREREQUISITES  (LAMBDA NIL                                                (* ; "Edited 14-Jul-87 11:27 by pds")(* ;;; "Load the files that must be loaded before loading any other sources.")    (APPLY* #'FILESLOAD '(FROM VALUEOF LISPUSERSDIRECTORIES) XQP::QP.DEVELOPMENT.LISP.LIBRARY.FILES            XQP::QP.LISP.LIBRARY.FILES '(FROM VALUEOF XQP::QP.DEFAULT.LISP.OBJECT.HOST/DIR)            XQP::QP.XEROX.LISP.FILES)))(XQP::QP.MAKE.PROLOGBOOT  (LAMBDA NIL                                                (* ; "Edited 26-Sep-87 20:44 by pds")(* ;;; "Set up the COMs for the PROLOGBOOT file, and then make the file.")(* ;;; "In order to run this function you must have the variable DNGLIST bound.  This is accomplished by loading the file DNGFILES, which is built by Prolog when making a new system.")    (if (NOT (BOUNDP 'XQP::DNGLIST))        then (XQP::QP.LOAD.DNGLIST))    (SETQ PROLOGBOOTCOMS `(                    (* ;; (\, (CONCAT "PROLOGBOOT generated "          (DATE) " by (QP.MAKE.PROLOGBOOT)")))                                                             (* ;                                 "All and only what is needed to build a Xerox Quintus Prolog SYSOUT.")                           (INITVARS XQP::QP.USE.SLOW.EMULATOR (XQP::QP.DEFAULT.LISP.OBJECT.HOST/DIR                                                                (CAR (TTYIN                                                              "Enter directory for Lisp object code: "                                                                             NIL NIL '(NORAISE))))                                  (XQP::QP.DEFAULT.PROLOG.OBJECT.HOST/DIR (CAR (TTYIN                                                            "Enter directory for Prolog object code: "                                                                                       NIL NIL                                                                                      '(NORAISE))))                                  (XQP::QP.SETUP.HELP.DIRECTORY (CAR (TTYIN                       "Enter directory for help system files XQPM.FILETITLES and XQPM.INDEX files:  "                                                                             NIL NIL '(NORAISE))))                                  (XQP::SMASHATOMS? (AND (NOT XQP::QP.USE.SLOW.EMULATOR)                                                         (EQ 'Y (ASKUSER NIL NIL "Smash atoms? "))))                                  (XQP::ATOM.SMASHER.ANTIDOTE.FILE                                   (if XQP::SMASHATOMS?                                       then (CAR (TTYIN                                    "Enter full PATH and NAME of file to hold atom-smasher antidote: "                                                         NIL NIL '(NORAISE)))                                     else 'NOBIND))                                  (XQP::QP.TERMINALFONTDIRECTORIES (TTYIN                                                              "Enter name(s) of font directory(ies): "                                                                           NIL NIL '(NORAISE)))                                  (XQP::QP.LISPUSERSDIRECTORY (CAR (TTYIN                                                 "Enter name of directory to get TEDIT & TEXEC from: "                                                                           NIL NIL '(NORAISE))))                                  (XQP::OLDDISPLAYFONTDIRECTORIES DISPLAYFONTDIRECTORIES))                           (P (SETTOPVAL 'DISPLAYFONTDIRECTORIES XQP::QP.TERMINALFONTDIRECTORIES))                           (FILES (SYSLOAD FROM VALUEOF XQP::QP.LISPUSERSDIRECTORY)                                  ,@XQP::QP.LISP.LIBRARY.FILES)                           (FILES (SYSLOAD FROM VALUEOF XQP::QP.DEFAULT.LISP.OBJECT.HOST/DIR)                                  ,@(APPEND XQP::QP.NO.SOURCE.FILES XQP::QP.XEROX.LISP.FILES                                            XQP::QP.RELEASE.LISP.EXTRAS XQP::QP.RELEASE.LISP.FILES)                                   "ERRORTAB")                           (P (SETTOPVAL 'DISPLAYFONTDIRECTORIES (GETTOPVAL '                                                                       XQP::OLDDISPLAYFONTDIRECTORIES                                                                        )))                           (P (XQP::INITIALIZE.PROLOG)                              (RESETLST (RESETSAVE (/CNDIR XQP::QP.DEFAULT.PROLOG.OBJECT.HOST/DIR)                                               (LIST '/CNDIR (DIRECTORYNAME T)))                                     ,@(for DNG in XQP::DNGLIST                                          collect `(XQP::RECONSULT ,DNG)))                              (if XQP::QP.USE.SLOW.EMULATOR                                  then (FILESLOAD (SYSLOAD FROM VALUEOF                                                          XQP::QP.DEFAULT.LISP.OBJECT.HOST/DIR)                                              ,@(APPEND XQP::QP.DEVELOPMENT.LISP.FILES                                                        XQP::QP.DEVELOPMENT.LISP.LOAD.AFTER)                                               "SLOWPROLOG")                                       (PROLOG.INIT.MEMORY)                                       (for I from 0 to 255 do (SETA PROLOG.ENABLE.PUFN.TABLE I 0))                                       (SETQ XQP::QP.stop T)                                       (PROMPTPRINT                                "Using slow emulator, with microcode turned off.  You're ready to go."                                              )                                else (FILESLOAD (SYSLOAD FROM VALUEOF                                                        XQP::QP.DEFAULT.LISP.OBJECT.HOST/DIR)                                            "FASTPROLOG"))                              (XQPM.SETUP XQP::QP.SETUP.HELP.DIRECTORY)                              (AND (WINDOWP LOGOW)                                   (OPENWP LOGOW)                                   (CLOSEW LOGOW))                              (if XQP::SMASHATOMS?                                  then (FILESLOAD (SYSLOAD FROM VALUEOF                                                          XQP::QP.DEFAULT.LISP.OBJECT.HOST/DIR)                                              "ATOMSMASHER")))))    (PUTPROP 'PROLOGBOOT 'MAKEFILE-ENVIRONMENT '(:READTABLE "INTERLISP" :PACKAGE (PROGN (FILESLOAD                                                                                         (SYSLOAD)                                                                                         "XQPSETUP")                                                                                        "IL")))    (ADDFILE 'PROLOGBOOT)    (MAKEFILE 'PROLOGBOOT '(NEW)))))(* ;;; "Our definers are now in this file, so as not to be in the release.  Ultimately, macros and constants should be taken out of releases, too.  This requires a technology for loading the definers, macros, and constants in order to do development work.  Someday.")(* ;;; "Bill's definers")(DEFDEFINER XQP::DEFMACROC FUNCTIONS (&REST ARGLIST)                                 (LET* ((NAME (CAR ARGLIST))                                        (ARGS (XQP::CANONICAL.REST (CADR ARGLIST)))                                        (XQP::REST.ARG (CAR ARGS))                                        (XQP::REG.ARGS (CDR ARGS))                                        (BODY (CDDR ARGLIST)))                    (* ;; "(QP.ADDTOFILE NAME 'FUNS)")(* ;;; "`(PUTPROP ',NAME 'MACRO ',(LIST '**MACROARG** `(LET (\, (DEFMACROC.ARGLIST REG.ARGS REST.ARG)) ,@BODY)))")                                       `(DEFMACRO (\,@ ARGLIST) )))(DEFDEFINER XQP::DEFRECORD STRUCTURES                           (NAME TYPE &REST FIELDS)                    (* ;; "(QP.ADDTOFILE NAME 'STRUCTS)")                           (LET* ((SLOTS (MAPCAR FIELDS '(LAMBDA (FIELD)                                                           (COND                                                              ((ATOM FIELD)                                                               FIELD)                                                              (T (CAR FIELD))))))                                  (XQP::ACCESSORS                                   (MAPCAR SLOTS '(LAMBDA (XQP::SLOT)                                                    `(XQP::DEFMACROC (\, XQP::SLOT) (X)                                                        (LIST 'FETCH ',XQP::SLOT 'OF X)))))                                  (XQP::SETFFORMS                                   (MAPCAR SLOTS '(LAMBDA (XQP::SLOT)                                                    `(CL:DEFSETF (\, XQP::SLOT) (DATUM)                                                        (NEWVALUE)                                                        (LIST 'REPLACE ',XQP::SLOT 'OF DATUM                                                              'WITH NEWVALUE))))))                                 `(PROGN (,TYPE ,NAME ,SLOTS)                                         ,@XQP::ACCESSORS                                         ,@XQP::SETFFORMS)))(DEFDEFINER (XQP::DEFUNC (:PROTOTYPE (LAMBDA (NAME)                                       (AND (CL:SYMBOLP NAME)                                            `(XQP::DEFUNC (\, NAME) ("args") "body" ))))) FUNCTIONS (NAME ARGS &REST BODY)                    (* ;; "(QP.ADDTOFILE NAME 'FUNS)")           (if (EQ ARGS 'FEXPR)               then `(DEFINEQ (,NAME (NLAMBDA ,(CAR BODY)                                       ,@(CDR BODY))))             elseif (EQ ARGS 'EXPR)               then `(CL:DEFUN (\, NAME) ,(CAR BODY) ,@(CDR BODY))             elseif (CL:LISTP ARGS)               then `(CL:DEFUN (\, NAME) ,ARGS ,@BODY)             else `(DEFINEQ (,NAME ,ARGS ,@BODY))))(DEFDEFINER (XQP::def.interface.fn (:PROTOTYPE (LAMBDA (NAME)                                                 (AND (CL:SYMBOLP NAME)                                                      `(XQP::def.interface.fn (\, NAME) ("arguments")                                                                                                "body"                                                          ))))) FUNCTIONS (NAME ARGS &BODY BODY)(* ;;; "Defines NAME to be a function with arguments ARGS and body BODY.  This function is called directly from Prolog, so it must be accessible from the IL package.")           (if (NEQ (CL:SYMBOL-PACKAGE NAME)                    (CL:FIND-PACKAGE "IL"))               then (IMPORT NAME "IL"))           `(CL:DEFUN (\, NAME) (&OPTIONAL ,@ARGS) ,@BODY))(* ;;; "Richard's definers")(DEFDEFINER XQP::def.global VARIABLES (X)(* ;;; "(def.global <id>) declares <id> as a Lisp GLOBALVAR.  Unlike def.var (see below) it does NOT cause the variable to be initialised when it is read in.  Before such variables are used, some function should initialise them.")                    (* ;;           "(if (NOT (GLOBALVAR.ON.FILE X)) then (QP.ADDTOFILE X 'VBLS)) ; otherwise already declared")                                  `(pushnew GLOBALVARS ',X))(DEFDEFINER XQP::def.macro FUNCTIONS (NAME ARGS &REST BODY)                    (* ;; "(def.macro <id> (<args>) . <body>) defines a macro whose arguments will be unevaluated, which works by interpreting body in the usual Lisp sense.  The body is often a back-quoted form.")                    (* ;; "(QP.ADDTOFILE NAME 'FUNS)")(* ;;; "`(PUTPROP ',NAME 'MACRO ',(COND ((NULL ARGS) ; (def.macro x () . body) `(NAME (PROGN ,@BODY))) ((LITATOM ARGS) ; (def.macro x a . body) `(,ARGS (PROGN ,@BODY))) ((LISTP ARGS) ; (def.macro x (a...) . body) `(NAME (APPLY (FUNCTION (LAMBDA (\, ARGS) ,@BODY)) NAME))) (T (SHOULDNT 'def.macro))))")                                 `(DEFMACRO (\, NAME) ,(IF (AND ARGS (LITATOM ARGS))                                                           THEN                                                           `(&REST ,ARGS) ELSE ARGS) ,@BODY))(DEFDEFINER XQP::def.nlambda FUNCTIONS (NAME ARGS &REST BODY)(* ;;; "(def.nlambda <id> <args> . <body>) defines <id> to be an NLAMBDA expression with the given arguments and body.  More than that, it tells the file package about the definition (the function QP.ADDTOFILE, defined in UTIL.LSP, is used for this), and adjusts the compiler's lists NLAMA and NLAML appropriatelly. A function should have one definition, redefinitions should preserve its type.")                    (* ;; "(QP.ADDTOFILE NAME 'FUNS)")                                   `(DEFINEQ (,NAME (NLAMBDA ,ARGS                                                      ,@BODY))))(DEFDEFINER XQP::def.open   FUNCTIONS (NAME ARGS &BODY BODY)(* ;;; "(def.open <id> <args> . <body>) has much the same effect as (PUTDQ ,<id> (LAMBDA ,<args> ,@<body>)) except that it defines an OPENLAMBDA macro rather than a real function.")                    (* ;; "(QP.ADDTOFILE NAME 'FUNS)")(* ;;; "`(PUTPROP ',NAME 'MACRO '(OPENLAMBDA ,ARGS ,@BODY))")         `(DEFMACRO (\, NAME) ,ARGS (LIST* 'LET                                           (LIST ,@(MAPCAR ARGS (FUNCTION (LAMBDA (ARG)                                                                            `(LIST                                                                              ',ARG                                                                              ,ARG)))))                                           ',BODY)))(DEFDEFINER XQP::def.props PROPERTIES                           (NAME &REST PROPLIST)                           (if (ODDP (LENGTH PROPLIST))                               then (ERROR "Odd length property list" PROPLIST))                    (* ;; "(QP.ADDTOFILE NAME 'PROPERTIES)")                           `(PROGN ,@(for X on PROPLIST by (CDDR X)                                        collect `(PUTPROP ',NAME ',(CAR X) ',(CADR X)))))(DEFDEFINER XQP::def.struct STRUCTURES (&REST FORM)(* ;;; "(def.struct <id> . <fields>) declares a Lisp record type and advises the file package of it. Note that I save a pair of parentheses, at the price of not allowing all the options that (DATATYPE ...) would.")                    (* ;; "(QP.ADDTOFILE (CAR FORM) 'STRUCTS)")                                  `(DATATYPE ,(CAR FORM) ,(CDR FORM)))(DEFDEFINER XQP::def.subr FUNCTIONS (NAME ARGS &BODY BODY)(* ;;; "To match the other definition forms, (def.subr <id> <args> . <body>) defines <id> to be a LAMBDA expression with the given arguments and body.  It advises the file package of the definition.")                    (* ;; "(QP.ADDTOFILE NAME 'FUNS)")                                `(CL:DEFUN (\, NAME) (&OPTIONAL ,@ARGS) ,@BODY))(DEFDEFINER XQP::def.var VARIABLES (X XQP::Val)(* ;;; "(def.var <id> <form>) has the effect of SETQ, but advises the file package.  It also makes the variable GLOBAL.  If the variable is already global, it assumes that this file has been loaded before, and doesn't advise the file package, but at PDS's (I think misguided) request it does reset the variable.  The form which goes in the filecoms tells the file package to use this expression to initialise the variable when it is read back in, not to save the value the variable happens to have when we do a makefile.")                    (* ;;           "(if (NOT (GLOBALVAR.ON.FILE X)) then (QP.ADDTOFILE X 'VBLS)) ; otherwise already declared")                               `(PROGN (pushnew GLOBALVARS ',X)                                                             (* ; "make this variable global")                                       (SETTOPVAL ',X ,XQP::Val)))(* ;;; "Auxilliary functions from Bill's and Richard setup files (UTIL.LSP and BASIC.LSP) ")(CL:DEFUN XQP::CANONICAL.REST (ARGS) (COND                                        ((NOT (NULL (CDR (LAST ARGS))))                                         (LET ((LASTN (LASTN ARGS 1)))                                              (CONS (CDR LASTN)                                                    (CAR LASTN))))                                        (T (LET ((LASTN (LASTN ARGS 2)))                                                (COND                                                   ((MEMB (CADR LASTN)                                                          '(&REST XQP::&rest))                                                    (CONS (CADDR LASTN)                                                          (CAR LASTN)))                                                   (T (CONS NIL ARGS)))))))(CL:DEFUN XQP::DEFMACROC.ARGLIST (XQP::REG.ARGS XQP::REST.ARG)   (LET* ((LENGTH (LENGTH XQP::REG.ARGS))          (XQP::REG.ARG.PART (COND                                ((NULL XQP::REG.ARGS)                                 NIL)                                (T (FOR I FROM 1 TO LENGTH                                      COLLECT `(,(CAR (NTH XQP::REG.ARGS I))                                                (CAR (NTH XQP::**MACROARG** ,I)))))))          (XQP::REST.ARG.PART (COND                                 ((NULL XQP::REST.ARG)                                  NIL)                                 (T `((,XQP::REST.ARG (NTH XQP::**MACROARG** ,(ADD1 LENGTH))))))))         (NCONC XQP::REG.ARG.PART XQP::REST.ARG.PART)))(CL:DEFUN XQP::DEFMACROC.BODY (XQP::ARGBODY) (COND                                                ((EQP (LENGTH XQP::ARGBODY)                                                      1)                                                 (CAR XQP::ARGBODY))                                                (T (CONS 'LIST XQP::ARGBODY))))(DEFINEQ(XQP::GLOBALVAR.ON.FILE  (LAMBDA (VAR)                                              (* ; "Edited 13-Jul-87 14:30 by pds")    (if (BOUNDP 'XQP::SOURCE.FILE)        then (MEMB VAR (FILECOMSLST XQP::SOURCE.FILE 'VARIABLES))))))(PUTPROPS XQPADMIN MAKEFILE-ENVIRONMENT (:READTABLE "INTERLISP" :PACKAGE (PROGN (FILESLOAD "XQPSETUP"                                                                                       )                                                                                "IL")))(PUTPROPS XQPADMIN COPYRIGHT ("Quintus Computer Systems, Inc" 1987))(DECLARE%: DONTCOPY  (FILEMAP (NIL (7166 14510 (XQP::QP.LISP.FILES 7176 . 7456) (XQP::QP.MAKE.ATOMSMASHER 7458 . 14508)) (14511 30632 (XQP::QP.COPY.DNGS 14521 . 17975) (XQP::QP.COPY.NO.SOURCE.FILES 17977 . 19377) (XQP::QP.GENERATE.FILES 19379 . 21220) (XQP::QP.LOAD.DNGLIST 21222 . 21440) (XQP::QP.LOAD.DNGS 21442 . 23713) (XQP::QP.LOAD.PREREQUISITES 23715 . 24178) (XQP::QP.MAKE.PROLOGBOOT 24180 . 30630)) (41845 42104 (XQP::GLOBALVAR.ON.FILE 41855 . 42102)))))STOP