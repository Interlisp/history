ref-20-6                    Xerox Quintus Prolog Reference Manual                  Section 20-6: Tail Recursion OptimizationAnother important efficiency feature of Xerox Quintus Prolog is tail recursionoptimization.  This is a space and speed optimization technique which applieswhen a procedure is determinate at the point where it is about to call the lastgoal in the body of a clause.  For example,% for(Int, Lower, Upper)% Lower and Upper should be integers such that Lower =< Upper.% Int should be uninstantiated; it will be bound successively on% backtracking to Lower, Lower+1, ... Upper.for(Int, Int, _Upper).for(Int, Lower, Upper) :-        Lower < Upper,        Next is Lower + 1,        for(Int, Next, Upper).This procedure is determinate at the point where the recursive call is about tobe made, since this is the last clause and the preceding goals ('<'/2 and is/2)are determinate.  Thus tail recursion optimization can be applied; effectively,the stack space being used for the current procedure call is reclaimed beforethe recursive call is made.  This means that this procedure uses only aconstant amount of space, no matter how deep the recursion.To take best advantage of this feature, make sure that goals in recursiveprocedures are determinate, and whenever possible put recursive calls at theends of procedures.