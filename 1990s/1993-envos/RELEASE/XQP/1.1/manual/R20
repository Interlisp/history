ref-20                    Xerox Quintus Prolog Reference Manual                       Chapter 20: Built-in PredicatesFollowing is a complete list of Xerox Quintus Prolog built-in predicates.abolish(F)        abolish the predicate(s) specified by Fabolish(F, N)     abolish the predicate named F of arity Nabort             abort execution of the program; return to top levelabsolute_file_name(R, A)                  A is the absolute name of file Rancestors(L)      the list of interpreted ancestors of the current clause is Larg(N, T, A)      the Nth argument of term T is Aassert(C)         clause C (for dynamic predicate) is added to data baseassert(C, R)      clause C is asserted; reference R is returnedasserta(C)        clause C is asserted before existing clausesasserta(C, R)     clause C is asserted before existing clauses; reference R is                  returnedassertz(C)        clause C is asserted after existing clausesassertz(C, R)     clause C is asserted after existing clauses; reference R is                  returnedatom(T)           term T is an atomatom_chars(A, L)  A is the atomic representation of the list of characters Latomic(T)         term T is an atom or a numberbagof(X, P, B)    the bag of instances of X such that P is provable is Bbreak             break at the next procedure call'C'(S1, T, S2)    (grammar rules) S1 is connected to S2 by the terminal Tcall(P)           prove (execute) Pcharacter_count(S, N)                  N is the number of characters read/written on stream Sclause(P, Q)      there is a clause for a dynamic predicate with head P and                  body Qclause(P, Q, R)   there is a clause for a dynamic predicate with head P, body                  Q, and reference Rclose(F)          close file or stream Fcompare(C, X, Y)  C is the result of comparing terms X and Ycompile(F)        add compiled procedures from file (or list of files) F to the                  data baseconsult(F)        add interpreted procedures from file (or list of files) F to                  the data basecopy_term(T, C)   C is a copy of T in which all variables have been replaced by                  new, unique variablescurrent_atom(A)   A is a currently available atom (nondeterminate)current_functor(X, Y)                  dummy routine included for DEC-10 Prolog compatibilitycurrent_input(S)  S is the current input streamcurrent_key(N, K) N is the name and K is the key of a recorded termcurrent_module(M) M is the name of a current modulecurrent_module(M, F)                  F is the name of the file in which M's module declaration                  appearscurrent_op(P, T, A)                  atom A is an operator of type T with precedence Pcurrent_output(S) S is the current output streamcurrent_predicate(A, P)                  A is the name of a predicate with most general goal Pcurrent_stream(F, M, S)                  S is a stream open on file F in mode Mdebug             switch on debuggingdebugging         display debugging status informationdepth(D)          the current interpreted invocation depth is Ddisplay(T)        write term T to the user output stream in prefix notationensure_loaded(F)  compile F if not already loadederase(R)          erase the clause or record with reference Rexpand_term(T, X) term T expands to term X using term_expansion/2 or grammar                  rule expansionfail              backtrack immediatelyfalse             (same as fail)fileerrors        enable reporting of file errorsfloat(N)          N is a floating-point numberflush_output(S)   flush the output buffer for stream Sforeign(F, P)     (UNIX and VMS systems only) user-defined; C function F is                  attached to predicate Pforeign(F, L, P)  (UNIX and VMS systems only) user-defined; function F in                  language L is attached to Pforeign_file(F, L)                  (UNIX and VMS systems only) user-defined; file F defines                  foreign functions in list Lformat(C, A)      write arguments A according to control string Cformat(S, C, A)   write arguments A on stream S according to control string Cfunctor(T, F, N)  the principal functor of term T has name F and arity Ngarbage_collect   force an immediate garbage collectiongc                enable garbage collectiongcguide(F, O, N)  (VMS systems only) change garbage collection parameter F from                  O to Nget(C)            C is the next non-blank character on the current input streamget(S, C)         C is the next non-blank character on input stream Sget0(C)           C is the next character on the current input streamget0(S, C)        C is the next character on input stream Shalt              exit from Prologhelp              display a help messagehelp(T)           give help on topic Tincore(P)         (same as call/1)instance(R, T)    T is an instance of the clause or term referenced by Rinteger(T)        term T is an integerY is X            Y is the value of arithmetic expression Xkeysort(L, S)     the list L sorted by key yields S'LC'              dummy routine included for DEC-10 Prolog compatibilityleash(M)          set the debugger's leashing mode to Mlength(L, N)      the length of list L is Nlibrary_directory(D)                  user-defined; D is a library directory that will be searchedline_count(S, N)  N is the number of lines read/written on stream Sline_position(S, N)                  N is the number of characters read/written on the current                  line of Slisp_apply(F, L, R)                  (Xerox Quintus Prolog only) apply Lisp function F to list L;                  return value Rlisp_predicate(F, P)                  (Xerox Quintus Prolog only) link predicate P to function F to                  be called by the Lisp interfacelisting           list all interpreted procedureslisting(P)        list the interpreted procedure(s) specified by Pload_foreign_files(F, L)                  load object files from list F using libraries Llog               obsolete; superseded by editor interfacemanual            access the top level of the on-line manualmanual(X)         access the specified manual sectionmaxdepth(D)       limit the invocation depth to D (interpreted code only)module(M)         make M the type-in modulename(A, L)        the list of characters of atom or number A is Lnl                send a newline to the current output streamnl(S)             send a newline to stream Sno_style_check(A) switch off style checking of type Anodebug           switch off debuggingnofileerrors      disable reporting of file errorsnogc              disable garbage collection'NOLC'            dummy routine included for DEC-10 Prolog compatibilitynolog             obsolete; superseded by editor interfacenonvar(T)         term T is a non-variable (that is, T is instantiated)nospy(P)          remove spypoints from the procedure(s) specified by Pnospyall          remove all spypointsnotrace           switch off debugging (same as nodebug/0)number(N)         N is a numbernumber_chars(N, L)                  N is the numeric representation of list of characters Lnumbervars(T, M, N)                  number the variables in term T from M to N-1op(P, T, A)       make atom A an operator of type T with precedence Popen(F, M, S)     file F is opened in mode M returning stream Sopen_null_stream(S)                  new output to stream S goes nowhereotherwise         (same as true/0)phrase(P, L)      list L can be parsed as a phrase of type Pphrase(P, L, R)   R is what remains of list L after phrase P has been foundplsys(X)          obsolete; replaced by unix/1, vms/1, and lisp_apply/3portray(T)        user-defined; tells print/1 what to doportray_clause(C) write clause C to the current output streampredicate_property(P, Prop)                  Prop is a property of the loaded predicate Pprint(T)          display the term T on the current output stream using                  portray/1 or write/1print(S, T)       display the term T on stream S using portray/1 or write/2prolog_flag(F, V)  V is the current value of Prolog flag Fprolog_flag(F, O, N)                  O is the old value of Prolog flag F; N is the new valueprompt(A, B)      change the user input prompt from A to Bput(C)            send character C to the current output streamput(S, C)         send character C to stream Sread(T)           read term T from the current input streamread(S, T)        read term T from stream Sreconsult(F)      obsolete; equivalent to consult/1recorda(K, T, R)  make term T the first record under key K; reference R is                  returnedrecorded(K, T, R) term T is recorded under key K with reference Rrecordz(K, T, R)  make term T the last record under key K; reference R is                  returnedreinitialise      abort and consult the user's prolog.ini filerepeat            succeed repeatedlyrestore(S)        (UNIX and VMS systems only) restore the state saved in file Srestore(S, X)     variant of restore/1retract(C)        erase the first interpreted clause that matches Cretractall(H)     erase every clause whose head matches Hrevive(X, Y)      dummy routine included for DEC-10 Prolog compatibilitysave(F)           (UNIX and VMS systems only) save the current state of Prolog                  in file Fsave(F, R)        (UNIX and VMS systems only) like save(F), but R is 0 when                  save/2 is done, 1 after a restore/1save_program(F)   (UNIX and VMS systems only) save the current state of the                  Prolog data base in file Fsee(F)            make file F the current input streamseeing(N)         the current input stream is named Nseen              close the current input streamset_input(S)      select S as the current input streamset_output(S)     select S as the current output streamsetof(X, P, S)    S is the set of instances of X such that P is provableskip(C)           skip input on the current input stream until after character                  Cskip(S, C)        skip input on stream S until after character Csort(L, S)        sorting the list L into order yields Ssource_file(F)    F is a loaded filesource_file(P, F) P is a predicate defined in the loaded file Fspy(P)            set spypoints on the procedure(s) specified by Pstatistics        display various execution statisticsstatistics(K, V)  the execution statistic with key K has value Vstream_code(S, U) U is the unique integer associated with stream Sstream_position(S, P)                  P is the current position of stream Sstream_position(S, O, N)                  O is the old position of stream S; N is the new positionstyle_check(A)    turn on style checking of type Asubgoal_of(G)     G is an interpreted ancestor goal of the current clausetab(N)            send N spaces to the current output streamtab(S, N)         send N spaces to stream Stell(F)           make file F the current output streamtelling(N)        the current output stream is named Nterm_expansion(T, N)                  user-defined; tells expand_term/2 what to dotold              close the current output streamtrace             switch on debugging and start tracing immediatelytrimcore          reduce free stack space to a minimum                  (not available on Xerox systems)true              succeedttyflush          transmit all outstanding terminal outputttyget(C)         the next non-blank character input from the terminal is Cttyget0(C)        the next character read in from the terminal is Cttynl             display a new line on the terminalttyput(C)         the next character sent to the terminal is Cttyskip(C)        skip over terminal input until after character Cttytab(N)         send N spaces to the terminalunix(T)           (UNIX systems only) give access to UNIX facilitiesunknown(A, B)     change action on unknown procedures from A to Buse_module(F)     import the module-file(s) F, loading them if necessaryuse_module(F, I)  import the procedure(s) I from the module-file Fuser_help         user-defined; tells help/1 what to dovar(T)            term T is a variable (that is, T is uninstantiated)version           display system identification messagesversion(A)        add the atom A to the list of introductory messagesvms(T)            (VMS systems only) give access to VMS facilitieswrite(T)          write term T on the current output streamwrite(S, T)       write term T on stream Swrite_canonical(T)                  write term T on the current output stream so that it can be                  read back inwrite_canonical(S, T)                  write term T on stream S so that it can be read back inwriteq(T)         write term T on the current output stream, quoting atoms                  where necessarywriteq(S, T)      write term T on stream S, quoting atoms where necessary!                 cut any choices taken in the current procedure\+ P              goal P is not provableX ^ P             there exists an X such that P is provableX =:= Y           the results of evaluating terms X and Y as arithmetic                  expressions are equalX =\= Y           the results of evaluating terms X and Y as arithmetic                  expressions are not equalX < Y             the result of evaluating X as an arithmetic expression is                  less than the result of evaluating Y as an arithmetic                  expression.X >= Y            the result of evaluating X as an arithmetic expression X is                  not less than the result of evaluating Y as an arithmetic                  expression.X > Y             the result of evaluating X as an arithmetic expression X is                  greater than the result of evaluating Y as an arithmetic                  expression.X =< Y            the result of evaluating X as an arithmetic expression X is                  not greater than the result of evaluating Y as an arithmetic                  expression.X == Y            terms X and Y are strictly identicalX \== Y           terms X and Y are not strictly identicalX @< Y            term X precedes term Y in standard order for termsX @>= Y           term X follows or is identical to term Y in standard order                  for termsX @> Y            term X follows term Y in standard order for termsX @=< Y           term X precedes or is identical to term Y in standard order                  for termsX = Y             terms X and Y are equal (that is, unified)T =.. L           the functor and arguments of term T comprise the list L