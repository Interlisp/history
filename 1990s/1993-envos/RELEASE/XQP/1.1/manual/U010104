user-1-1-4                      Xerox Quintus Prolog User's Guide                          Section 1-1-4: UnificationThe program above does not take full advantage of one of the most powerfulProlog concepts; that of unification.  Unification is the process by whichsimilar Prolog terms are matched with one another.  One constant matchesanother only if they are identical; however, a variable will match either aconstant (simple term) or a compound term.  An example of a compound term is apredicate-name together with its arguments.  Two compound terms match if theirpredicate-names match, and if their arguments match according to the rulesabove.Unification allows you to write programs which include variables, thus avoidingthe necessity for writing down every possible fact or rule explicitly.  As wesaw earlier, a fact is a conclusion which is true without needing premisesproved to support it; for example,            it_is_cold(tuesday).is a fact, and can be viewed as equivalent to the rule below (we may sometimesneed to perform this translation in order to unify a fact with a rule):            it_is_cold(tuesday) :-                true.that is, "If true, then it is cold on Tuesday."If the data base contains facts such as            it_is_cold(monday).            it_is_cold(tuesday).                    .                    .                    .            it_is_raining(tuesday).                    .                    .                    .then we do not wish to have to write a separate rule to decide whether or notto drive on each day of the week, as in:            drive_to_work(monday) :-                it_is_cold(monday),                it_is_raining(monday).            drive_to_work(tuesday) :-                it_is_cold(tuesday),                it_is_raining(tuesday).            drive_to_work(wednesday) :-                it_is_cold(wednesday),                it_is_raining(wednesday).                    .                    .                    .which would require seven rules.  If we wished to have the program work forevery day of the year, 365 separate rules would be needed!  Instead, usingvariables (which denote classes or groups of objects instead of specificobjects, and which are distinguished from constants and predicate-names in thatvariables always begin with an uppercase letter), we can write a single rule:            drive_to_work(Day) :-                it_is_cold(Day),                it_is_raining(Day).This means that in order to prove that I should drive to work on any given'Day', I should first determine that it is cold on that day, then determinethat it is raining on the same day.  Say that I have determined that it will becold on Monday, Tuesday, Wednesday, and Thursday; and that it will be rainy onTuesday, Wednesday, and Friday.  I enter this knowledge into the Prolog database (how to do this will be explained in {manual(user-1-2-1)}).  Now the database contains, along with the rule above, the facts            it_is_cold(monday).            it_is_cold(tuesday).            it_is_cold(wednesday).            it_is_cold(thursday).            it_is_raining(tuesday).            it_is_raining(wednesday).            it_is_raining(friday).Now, if we wish to determine whether we should drive to work on Tuesday, wetype            drive_to_work(tuesday).At this point, the system will look for a clause for drive_to_work/1 whoseargument unifies with 'tuesday' (remember that a fact will unify because it isequivalent to a rule whose head is that fact, and whose body is 'true').  Therule whose head is 'drive_to_work(Day)' will unify, by binding the variable'Day' to the constant 'tuesday'.  Now, for as long as we continue attempting toprove the goal using this rule, 'Day' will remain bound to 'tuesday'.  Thus,the rule is effectively            drive_to_work(tuesday) :-                it_is_cold(tuesday),                it_is_raining(tuesday).At this point, the system will, as before, note that 'drive_to_work(tuesday)'is true if 'it_is_cold(tuesday)' is true and 'it_is_raining(tuesday)' is true.Since both of these propositions are in the data base as facts, the rule willsucceed, and the system will respond with "yes".More than this, if we wish to determine whether there is any day this week onwhich we should drive to work, we can type            drive_to_work(AnyDay).In this case, the system will unify 'drive_to_work(AnyDay)' with'drive_to_work(Day)', at which point our rule will effectively be            drive_to_work(AnyDay) :-                it_is_cold(AnyDay),                it_is_raining(AnyDay).The system will now attempt to find clauses whose heads match'it_is_cold(AnyDay)'; these clauses (from the set above) are            it_is_cold(monday).            it_is_cold(tuesday).            it_is_cold(wednesday).            it_is_cold(thursday).corresponding to the following set of values for AnyDay:            { monday, tuesday, wednesday, thursday }For each of these values of AnyDay, the system will now attempt to find clauseswhose heads match 'it_is_raining(AnyDay)'.  These clauses are            it_is_raining(tuesday).            it_is_raining(wednesday).('it_is_raining(friday)' does not match because 'friday' is not in the set ofvalues of AnyDay already chosen by the 'it_is_cold(AnyDay)' clause).Therefore, the set of values for AnyDay which satisfy both 'it_is_cold(AnyDay)'and 'it_is_raining(AnyDay)' is            { tuesday, wednesday }and the system will return these values to you, indicating that you shoulddrive to work on Tuesday and Wednesday because it will be both cold and rainyon those days.Now let us see how the Prolog programming environment is used to solve thisproblem.