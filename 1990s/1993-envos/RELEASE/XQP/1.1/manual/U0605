user-6-5                      Xerox Quintus Prolog User's Guide           Section 6-5: Tracing Every Step of a Procedure ExecutionOnce you type 'trace.' to turn on the debugger, you can begin tracing theexecution of a procedure by typing a call to the procedure at the main Prologprompt.  For example, to trace the execution of a procedure works_for/2, youtype a call to that procedure at the main Prolog prompt, as shown below:              | ?- works_for(X, Y).The system will begin to execute the procedure in the normal way (instantiatingvariables, backtracking when necessary, and so on).  Since the debugger isactivated, the system will also show when each procedure is called and whetheror not it is successfully executed.A sample trace is shown below for the procedure call works_for(X, Y).works_for/2 is defined as follows:works_for(X, Y) :- works_directly_for(X, Y).works_for(X, Z) :- works_directly_for(X, Y), works_for(Y, Z).works_directly_for(john, mary).works_directly_for(mary, george).| ?- works_for(X, Y).   (1) 0 Call: works_for(_93,_108) ? <CR>   (2) 1 Call: works_directly_for(_93,_108) ? <CR>   (2) 1 Exit: works_directly_for(john,mary) ? <CR>   (1) 0 Exit: works_for(john,mary) ? <CR>X = john,Y = mary ;   (1) 0 Redo: works_for(john,mary) ? <CR>   (2) 1 Redo: works_directly_for(john,mary) ? <CR>   (2) 1 Exit: works_directly_for(mary,george) ? <CR>   (1) 0 Exit: works_for(mary,george) ? <CR>X = mary,Y = george ;   (1) 0 Redo: works_for(mary,george) ? <CR>   (2) 1 Redo: works_directly_for(mary,george) ? <CR>   (2) 1 Fail: works_directly_for(_93,_108) ? <CR>   (3) 1 Call: works_directly_for(_93,_228) ? <CR>   (3) 1 Exit: works_directly_for(john,mary) ? <CR>   (4) 1 Call: works_for(mary,_108) ? <CR>   (5) 2 Call: works_directly_for(mary,_108) ? <CR>   (5) 2 Exit: works_directly_for(mary,george) ? <CR>   (4) 1 Exit: works_for(mary,george) ? <CR>   (1) 0 Exit: works_for(john,george) ? <CR>X = john,Y = george <CR>| ?-As shown above, when you type a query, the system displays a message tellingyou that it is calling the procedure you've specified, for example                (1) 0 Call: works_for(_93,_108) ?In Prolog an underscore, or an alphanumeric string preceded by an underscore,represents a variable.  The character strings _93 and _108 shown in the exampleabove are unique system representations of the variables X and Y. The advantageof using this representation of variables is that it shows, for example, thatthe variable _93 in the first call to works_directly_for is the same as thevariable _93 in the later calls to works_directly_for.  If the real variablename (X) were used, it could create confusion because the variable name X mightoccur in many different clauses.To direct the debugger to execute the call to the specified procedure and toshow the program step immediately following that call, press the Return key.The system then executes the call to that procedure and displays the nextprogram step.  You can direct the system to continue displaying each successivestep in the execution of the program simply by pressing the Return key eachtime the system displays a procedure call followed by a question mark.  Thissingle-stepping mode of execution is known as "creeping".If you want to see the final result of the query but you do not want thedebugger to continue displaying each step of the execution, type 'n' (fornodebug) in response to the question mark.  If you want to abandon execution ofthe procedure, type 'a' (for abort) in response to the question mark.  If youwant to recompile or reconsult a procedure, you may move to a text window andselect the Consult or Compile option from the TEdit menu (see{manual(user-3-3)}).As the debugger displays the program's execution, check for instances whereprocedures behave differently than you expect.  Check especially for procedurecalls that fail unexpectedly and variables that aren't instantiated as youexpect them to be.