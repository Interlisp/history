sysdep-3-1-0            Xerox Quintus Prolog System-Dependent Features Manual                         Section 3-1-0: IntroductionXerox Quintus Prolog uses three data areas:  program space identified with thenormal Xerox Lisp CONSing areas, local stack space, and global data space.Local stack space and global data space are fixed; program space is expandable.The compiled and interpreted code and recorded terms of Xerox Quintus Prologare stored in the array space of Xerox Lisp.  Atoms are stored in the symbolspace.  The space occupied by interpreted code and recorded terms is recoveredwhen it is no longer needed, but the space occupied by compiled code and atomsis not recovered.The global stack space contains the global stack (heap) and the trail, whichgrow inward toward one another.  The global stack contains all the datastructures constructed in an execution of the program, and the trail containsreferences to all the variables that need to be reset when backtracking occurs.Both of these areas grow with forward execution and shrink on backtracking.The local stack contains all the control information and variable bindingsneeded in a Prolog execution.  Space on the local stack is reclaimed ondeterminate success of predicates and by tail recursion optimization, as wellas on backtracking.Xerox Quintus Prolog uses the heap to construct compound terms, includinglists.  Heap space is used as Prolog execution moves forward.  When Prologbacktracks, it automatically reclaims space on the heap.  However, if a programuses a large amount of space before failure and backtracking occur, this typeof reclamation may be inadequate.Abnormal termination of execution due to lack of heap space can occur even ifthere are structures in the heap that are no longer accessible to thecomputation (these structures are what is meant by "garbage").  The proportionof garbage to non-garbage terms varies during execution and with the Prologcode being executed.  The heap may contain no garbage at all, or may be nearlyall garbage.For example, without garbage collection, the command sequence             :- assert(( p(_) :- p([a) )), p(_).  ] causes the heap to fill until the Prolog process eventually runsout of space.  With garbage collection enabled, the above sequence continuesindefinitely.  The list built on the heap by each recursive call isinaccessible to future calls (since p/1 ignores its argument) and can bereclaimed by the garbage collector.Garbage collection does not guarantee freedom from out-of-space errors,however.  The command sequence            :- assert(( p(X) :- p([X]) )), p(a).expands the heap until the Prolog process eventually runs out of space.  Thishappens in spite of the garbage collector, because all the terms built on theheap are accessible to future computation and cannot be reclaimed.