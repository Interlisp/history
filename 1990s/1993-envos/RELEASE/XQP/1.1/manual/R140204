ref-14-2-4                    Xerox Quintus Prolog Reference Manual                           Section 14-2-4: ExampleConsider the procedure foo/0 defined by            :- dynamic foo/0.            foo :- assertz(foo), fail.Each call to foo/0 asserts a new last clause for foo/0.  After the Nth call tofoo/0 there will be N+1 clauses for foo/0.  When the first call to foo/0 ismade, the procedure has exactly one clause.  Under releases of Xerox QuintusProlog prior to 2.0, the change to the Prolog data base made by assertz/1 tookeffect as soon as the call to assertz/1 succeeded.  Suddenly the procedure hadtwo clauses.  fail/0 then forced the call to foo/0 to backtrack.  Thebacktracking call found the newly asserted clause and succeeded.  For example,under Xerox Quintus Prolog Release 1.6,| ?- compile(user).| :- dynamic foo/0.| foo :- assertz(foo), fail.|[user compiled 0.117 sec 188 bytes]yes| ?- foo. % The asserted clause succeeds (under earlier releases)yes| ?-Beginning with Xerox Quintus Prolog Release 2.0, when foo/0 is first called, avirtual copy of the procedure is made, effectively freezing the definition offoo/0 for that call.  At the time of the call, foo/0 has exactly one clause.Thus, when fail/0 forces backtracking, the call to foo/0 simply fails:  itfinds no alternatives.  For example,| ?- compile(user).| :- dynamic foo/0.| foo :- assertz(foo), fail.|[user compiled 0.100 sec 204 bytes]yes| ?- foo.  % The asserted clause is not found (under Release 2.0)no| ?- foo.  % A later call does find it, howeveryes| ?-Even though the virtual copy of foo/0 being run by the first call is notchanged by the assertion, the Prolog data base is.  Thus, when a second call tofoo/0 is made, the virtual copy for that call contains two clauses.  The firstclause fails, but on backtracking the second clause is found and the callsucceeds.