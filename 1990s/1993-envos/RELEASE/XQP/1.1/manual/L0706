lib-7-6                     Xerox Quintus Prolog Library Manual          Section 7-6: Yes-no Questions, and Others -- library(ask)The file library(ask) defines a set of commands for asking questions whoseanswer is a single character, and for asking for file names.  library(ask) usesseveral commands from library(prompt), but if you want to use them in yourprogram you should explicitly include the directive            :- ensure_loaded(library(prompt)).in your program.  The principal such command is prompt/1, which is used toprint the question or prompt.yesno(+Question)            writes Question (using write/1) to the terminal, regardless of the            current output stream, and reads an answer.  The prompt is followed            by "? ", so you should not put a question mark in the question            yourself.  The answer is the first character typed in response;            anything following on the same line will be thrown away.  If the            answer is 'y' or 'Y', yesno/1 succeeds.  If the answer is 'n' or            'N', yesno/1 fails.  Otherwise it repeats the question.  The user            has to explicitly type a 'y' or 'n' before it will stop.  Because            the rest of the line is thrown away, the user can type "yes",            "Yes", "You'd better not", and so forth with exactly the same            effect as a plain 'y'.  If the user just presses the return key,            that is not taken as "yes".yesno(+Question, +Default)            is like yesno(Question) except that               - Default may be an atom (the first character of whose name                 will be used), a string (whose first character will be                 used) or an ASCII code, and will be written in brackets                 before the question mark; and               - if the user just presses carriage return, Default will be                 used as the answer.            For example,            yesno('Do you want an extended trace', yes)            prints            Do you want an extended trace [y]? _            and leaves the terminal's cursor where the underscore is.  If the            user presses carriage return, this call to yesno/1 will succeed.            If the user answers "yes" it will succeed.  If the user answers            "no" it will fail.  If the first non-layout character of the user's            answer is neither "n", "N", "y", nor "Y", the question will be            repeated.ask(+Question, -Answer)            writes Question to the terminal as yesno(Question) would, and reads            a single character Answer.  Answer must be a "graphic" character (a            printing character other than space).  ask/2 will continue asking            until it is given such a character.  The remainder of the input            line will be thrown away.ask(+Question, +Default, -Answer)            uses Default as the default character the way that yesno/2 does,            and mentions the default in brackets just before the question mark.            If the user presses carriage return, Default will be returned as            his Answer.  Answer can be instantiated, in which case the call to            ask/2 or ask/3 will fail if the user does not give that answer.            For example, yesno/2 could (almost) have been defined as                        yesno(Question, Default) :-                                ask(Question, Default, 0'y).ask_file(+Question, +Mode, -FileName)            writes Question to the terminal and reads a file name from the            terminal, regardless of the current I/O streams.  If the user            presses carriage return, ask_file/3 just fails; an empty file name            is taken as an indication that the user has finished entering file            names.  A reply beginning with a question mark will cause a brief            help message to be printed (explaining that a file name is wanted,            and how to enter one), and the question will be repeated.            Otherwise, ask_file/3 checks that the file can be opened in the            mode specified by Mode (read, write, or append).  If it is not            possible to open the file in mode Mode, the operating system's            error result is reported and the question is repeated.  If it is            possible to open the file in this mode, the name of the file is            returned as FileName.  However, ask_file/3 does not open the file            for you, it simply checks that it is possible to open the file.            Here is an example "dialogue":            | ?- ask_file('Where should the cross-reference go? ',                 write, File).            Where should the cross-reference go? ?            Please enter the name of a file which can be opened            in write mode, followed by a RETURN.  To end this            operation, just type a RETURN with no file name.            Where should the cross-reference go? call.pl            ! Can't open call.pl in write mode.            ! UNIX error EACCES (Permission denied).            Where should the cross-reference go? call.xref            File = 'call.xref'            | ?- ask_file('Next file: ', read, File).            Next file: call.pl            ! Can't open call.pl in read mode.            ! UNIX error EACCES (Permission denied).            Next file: call.xref            ! Can't open call.xref in read mode.            ! UNIX error ENOENT (No such file or directory).            Next file: <CR>            no            Points to note:               - ask_file/3 does not add a question mark and space to the                 prompt; you must put them in the question yourself.               - Although the first call to ask_file/3 found that it was                 possible to open call.xref for output, it did not open                 it, so the second call to ask_file/3 could not find any                 such file.ask_between(+Prompt, +Lower, +Upper[, +Default], -Answer)            writes Prompt on the terminal, and reads a line in response.  If            the line read represents a Prolog integer between Lower and Upper            inclusive, this line is unified with Answer.  The line may contain            only digits and perhaps a leading minus sign.  If the line is empty            and there is a Default argument, Answer is unified with Default.            This happens regardless of whether Default is an integer or in the            indicated range.  If the answer read is not acceptable, the user is            told what sort of answer is wanted and is prompted again.  For            example, after defining            p(X) :-               ask_between('Number of samples', 1, 20, [none], X),               integer(X).            the following conversation might take place.            | ?- p(X).            Number of samples [none]: ?            Please enter an integer between 1 and 20            Do not add a full stop.            Number of samples [none]: 0            Please enter an integer between 1 and 20            Do not add a full stop.            Number of samples [none]: 9            X = 9            | ?- p(X).            Number of samples [none]: <CR>            no            The prompt which is printed is "Prompt [Default]: " if there is a            Default argument, "Prompt: " otherwise, so that you can use the            same prompt whether or not there is a default argument.ask_oneof(+Prompt, +Constants[, +Default], -Answer)            prints Prompt on the terminal, and reads a line in response.            Constants should be a list of constants (terms which are acceptable            as the first argument of name/2).  If the user's response is the            full name of one of the constants, Answer is unified with that            constant.  Failing that, if the user's response is a prefix of            exactly one of the constants, Answer is unified with that constant.            If the response is just a carriage return, and there is a Default            argument, Answer is unified with Default (which need not be a            constant, nor need it be an element of Constants).  If nothing else            works, the user is told what sort of response is wanted, and is            prompted again.            The prompt which is printed is "Prompt [Default]: " if there is a            Default argument, "Prompt: " otherwise, so that you can use the            same prompt whether or not there is a default argument.You should find it straightforward to define your own simple queries using thiskit.  As a general rule, try to arrange things so that if the user types aquestion mark s/he is told what sort of response is wanted.  All the queriesdefined in this section do that.The commands for reading English sentences do nothing special when their inputis a single question mark.  Here is an example of how you can build a queryfrom them which does something sensible in this case.ask_sentence(Prompt, Sentence) :-    repeat,        prompt(Prompt),        read_in(X),        (   X = [?] ->            format(user_output,                'Please enter an English sentence.~n', []),            fail        ;   true        ),    !,    Sentence = X.