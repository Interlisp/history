ref-12-1                    Xerox Quintus Prolog Reference Manual                          Section 12-1: IntroductionThe module system allows the user to divide a large Prolog program into smallersub-programs (modules) and to define the interfaces between those modules.Each module has its own name space; that is, a predicate defined in one moduleis distinct from any predicates with the same name and arity which may bedefined in other modules.  The module system encourages a group of programmersto define the dependence each has on others' work before any code is written,and subsequently allows all to work on their own parts independently.  It alsohelps to make library predicates behave as extensions of the existing set ofbuilt-in predicates.The Xerox Quintus Prolog library uses the module system and can therefore serveas an extended example of the concepts presented in the following text.  Thedesign of the module system is such that loading library files and callinglibrary predicates can be done without knowledge of the module system.  Inparticular, programs which were written using early versions of the library(those versions which were distributed with Xerox Quintus Prolog releases priorto 2.0) do not need to be changed.Some points to note about the module system are that:   - It is based on procedural modularity rather than on data modularity;     that is, atoms and functors are global.   - It is flat rather than hierarchical; any module may refer to any     other module by its name -- there is no need to specify a path of     modules.   - It is not strict; modularity rules can be explicitly overridden.     This is primarily for flexibility during debugging.   - It is efficient; procedure calls to predicates across module     boundaries incur little or no overhead.   - It is compatible with previous releases of Xerox Quintus Prolog;     existing Prolog code should run unchanged.   - Data base references adhere to the same modularity rules as do other     predicates.