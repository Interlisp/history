ref-14-3-1                    Xerox Quintus Prolog Reference Manual                       Section 14-3-1: retract(+Clause)retract(Clause) erases the first clause in the data base that matches Clause.retract/1 is nondeterminate.  If control backtracks into the call to retract/1,successive clauses matching Clause are erased.  If and when no clauses match,the call to retract/1 fails.For the purpose of this matching, unit clauses (clauses with no body) aretreated as if they had a body consisting of the single goal 'true'.  Thus             | ?- retract((foo(X) :- Body)), fail.is guaranteed to retract all the clauses for foo/1, including any unit clauses,providing of course that foo/1 is dynamic.  Since retract/1 is nondeterminate,it can be a good idea, if you only want to retract a single clause, to use acut to eliminate the alternatives so generated.  See {manual(ref-14-3-2)} formore information on the use of cuts in retract/1.If Clause is instantiated to a term which does not correspond to a dynamicprocedure, retract/1 fails.  If Clause is not instantiated, or is instantiatedto an illegal term, an error message is sent to the standard error stream andthe clause fails.Under releases of Xerox Quintus Prolog prior to 2.0, retracted clauses weremade invisible immediately:| ?- assert(p(1)), assert(p(2)), assert(p(3)).yes| ?- p(N), write(N), nl, retract(p(2)), retract(p(3)), fail.1no| ?-Three clauses are first asserted into the (previously empty) procedure p/1,then a query is made.  The call to p/1 succeeds, first binding N to 1 andwriting out N. The two retractions then take place, the retracted clausesbecoming invisible before fail/0 is called.  On backtracking, the call to p/1finds no further clauses, so the call to p/1 fails.  Thus the query fails.Beginning with Xerox Quintus Prolog Release 2.0, the side effects caused byretract/1 go unrecognized by the backtracking call, but are seen by asubsequent call to p/1:| ?- assert(p(1)), assert(p(2)), assert(p(3)).yes| ?- p(N), write(N), nl, retract(p(2)), retract(p(3)), fail.123no| ?- p(N), write(N), fail.1no| ?-At the first call to p/1, the procedure has three clauses.  These remainvisible throughout execution of the call to p/1.  Thus, when backtracking isforced by fail/0, N is bound to 2 and written.  The retraction is againattempted, causing backtracking into p/1.  N is bound to 3 and written out.The call to retract/1 fails.  There are no more clauses in p/1, so the queryfinally fails.  A subsequent call to p/1, made after the retractions, sees onlyone clause.The space occupied by a clause which is retracted is reclaimed.  Thereclamation does not necessarily happen immediately, but is not delayed untilbacktracking past the call to retract/1, as in some implementations.