ref-2-1-1                    Xerox Quintus Prolog Reference Manual                   Section 2-1-1: Predicate SpecificationsA predicate is uniquely identified by its name and arity (number of arguments).In Xerox Quintus Prolog these are the ways of specifying a predicate as anargument of a predicate:   1. The form Module:Name(Term1,Term2, ...,TermN) is called the skeletal      predicate specification.  It identifies the predicate Name of arity      N in module Module.  It is required by predicates when the      specification was likely to have been obtained from predicates such      as ancestors/1, clause/[2,3], etc.  This is the case when one is      manipulating Prolog programs themselves.  Module is optional; if      omitted, the user is assumed to refer to the source module.  When      the skeletal specification is used as an input argument, the values      of Term1,Term2, ...,TermN are not significant; they only serve as      place-holders for determining the arity of Name.  For example,                   | ?- predicate_property(put(97), P1),                       predicate_property(put(98), P2).                  P1 = P2 = built_in ;                  no      When the skeletal specification is used as an output argument,      Module:Name(Term1,Term2, ...,TermN) is made to be the most general      term with name Name and arity N (that is, Term1, Term2, ..., TermN      are each made to be variables, distinct from each other and any      others in the system).  For example,                   | ?- compile(user).                  | foo(1, 2, 3).                  | end_of_file.                  [user compiled (0.100 sec 196 bytes)]                  yes                  | ?- source_file(X, user).                  X = foo(_224,_225,_226) ;                  no                  | ?- source_file(foo(7,8,9), user).                  yes   2. The Module:Name/Arity form is an alternative representation to the      skeletal form.  Arity can be a single arity, or a list of arities      and/or arity ranges.  Module is optional; if omitted, the user is      assumed to refer to the current module.  For example,      prog1:foo/1 specifies predicate foo, arity 1 in module prog1.      foo/1 specifies predicate foo of arity 1 in the current module.      foo/[1] specifies predicate foo/1 in the current module.      prog2:foo/[1,2] specifies foo/1 and foo/2 in module prog2.      foo/[1-2] specifies foo/1 and foo/2 in the current module.      foo/[1-3] specifies foo/1, foo/2, and foo/3 in the current                  module.      foo/[1-3,5] specifies foo/1, foo/2, foo/3, and foo/5 in the                  current module.      NOTE:  The form Name/[Arities] is used only by some library packages      and for demonstrative purposes in this manual.  Currently, it is not      used by any supported built-in predicates.   3. The Module:Name/[Arities] form is required by declarations that take      a predicate specification (or a list of predicate specifications) as      an argument.  For most predicates, this form requires fewer      characters, which is desirable because these specifications will      likely be typed by the user.  It is possible for this form to be a      syntactically invalid Prolog term as a result of current operator      declarations or the fact that slash (/) is a symbol_char (see      {manual(ref-1-8-4)}).  If Name is a prefix operator with precedence      greater than that of slash (i.e., greater than 400), the predicate      name should be enclosed in parentheses.  For example, the      specification                  (dynamic)/1      is required because 'dynamic' is a prefix operator with precedence      1150 and slash (/) has precedence 400.  If Name consists only of      characters from the set { + - * / \ ^ < > ` ~ : . ? @ # $ & }, then      Name must be either:           a. enclosed in single quotes,         b. separated from the slash (/) by one or more space characters,            or         c. enclosed in parentheses.        If none of these is done then the slash (/) becomes part of Name and      a syntax error will result.   4. abolish/2 is the only predicate which does not use either of the      above specifications.  Its first argument is the Name of the      predicate and the second argument is the Arity.  For consistency, it      is recommended that abolish/1 be used instead.The following predicate can be used to convert between the Name/Arityspecification and the skeletal specification, or to verify that twospecifications identify the same predicate.  predicate_specification(NameAritySpec, SkeletalSpec) :-       (nonvar(NameAritySpec) ; nonvar(SkeletalSpec)),        !,        NameAritySpec = Name/Arity,        functor(SkeletalSpec, Name, Arity),        atom(Name).