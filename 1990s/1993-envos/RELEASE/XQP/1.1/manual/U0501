user-5-1                      Xerox Quintus Prolog User's Guide                          Section 5-1: Normal LayoutRecommended layout conventions are enumerated below.  Those marked with stars(***) are necessary in order for the Find Definition option to work, and inorder to allow you to use the middle mouse button to mark a procedure to load.The unstarred conventions simply contribute to program clarity.   1. (***) Group Prolog clauses of the same name and arity together.      That is, do not intersperse clauses of one procedure with clauses of      another.  Normally you will get a style warning if you breach this      restriction (see {manual(user-3-7)}).   2. (***) Start the heads of all Prolog clauses at the beginning of the      line; indent any additional lines for those clauses.   3. (***) If a comment continues onto another line, indent the      continuation line(s).   4. (***) Do not write clause definitions that use operators in the      heads of the clauses.  For example, if you want to define clauses      for '+'/2, then write the head of the clause in the form "+(A,B)"      and not "A + B".   5. Insert blank lines between procedures but not between clauses for      the same procedure.   6. Write each goal on its own line.   7. Write a "/* text */" comment immediately above each procedure to      detail any assumptions that are made about the procedure's      arguments, and to explain what the procedure is supposed to do.  In      the example below, each procedure is preceded by a comment line in      which a '+', '-', or '?' precedes each argument, to indicate whether      the variable representing the argument is generally an input, an      output, or either (respectively) when the procedure is called.   8. Where useful, write single-line (%) comments to the right of goals      in the body of the program.  Do not use the '/* */' comment notation      on lines of code.   9. Try to give variables meaningful names.  A convention illustrated in      qsort/3 below is to have a series of variable names such as R0, R1,      ..., R where R0 is initially given, R1 is derived from R0, R2 is      derived from R1, and so on up to R, which is the final result.The following example demonstrates the recommended layout conventions./* ---------------------------------------------------------   quicksort(+List, -SortedList) sorts a list   ------------------------------------------------------ */quicksort(List, SortedList) :- qsort(List, [], SortedList)./* ---------------------------------------------------------   qsort(+List, +R0, -R).  Sorts the List of numbers and   concatenates the result with R0 to give R.  This works by   partitioning the List into two sublists consisting of   those elements of the list which are less than the first   element and those which are greater.  Then the two   sublists are sorted by the recursive calls.   ------------------------------------------------------ */qsort([X|List], R0, R) :-   partition(List, X, Below, Above),   qsort(Above, R0, R1),   qsort(Below, [X|R1], R).qsort([], R, R)./* ---------------------------------------------------------   partition(+List, +X, -Below, -Above) returns in Below all   those elements of List which are =< X, and in Above all   those elements which are > X.   ------------------------------------------------------ */partition([X|List], Y, [X|Below], Above) :-   X @=< Y, !,   partition(List, Y, Below, Above).partition([X|List], Y, Below, [X|Above]) :-   X > Y,   partition(List, Y, Below, Above).partition([], _, [], []).