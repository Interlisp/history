(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE (DEFPACKAGE "PSO") BASE 10)(il:filecreated " 7-Dec-87 20:23:59" il:{eris}<snow>4045>new>pso.\;11 49607        il:|changes| il:|to:|  (il:functions open-file)                             (il:variables port-ready)      il:|previous| il:|date:| " 7-Dec-87 17:00:16" il:{eris}<snow>4045>new>pso.\;9); Copyright (c) 1987 by Xerox Corporation.  All rights reserved.(il:prettycomprint il:psocoms)(il:rpaqq il:psocoms           ((il:prop (il:filetype il:makefile-environment)                  il:pso)                               (il:* il:|;;| "functions that are used in records.")           (il:functions get-command-word put-command-word)           (il:declare\: il:dontcopy (il:files (il:sysload)                                            il:mesatypes                                            (il:loadcomp)                                            il:doveinputoutput                                            (il:source)                                            il:dovedecls                                            (il:loadcomp)                                            il:dovemisc)                                      (il:* il:|;;| "constants.  Note, if you change the PSO::CLOCK-COUNTER-VALUE, you must also change the PSO::CONFIG-REGR-IMAGE-WRD-VAL. the 2 -VAL constants are figured out by creating the associated record type and noting the wrd-val value when all the fields are set properly.")                  (il:variables clock-counter-value command-regr-image-wrd-val                          config-regr-image-wrd-val dma-byte-transfer-count.bs                          dma-cntrl-wrd-block-output.bs dma-cntrl-wrd-byte-output.bs                          transfer-command-word-value update-status-command transfer-config-byte-mode                          transfer-config-word-mode reset-command ioregion-offset status-ready                          config-regr-for-diagnostic command-regr-for-diagnostic                          run-diagnostic-command port-ready)                                      (il:* il:|;;| "descriptions of the records follow because mesarecords strip comments.")                                      (il:* il:|;;| "--Board-status-rec state-id-4-bits of FF hex indicates PROM error.")                                      (il:* il:|;;| "--The TCB PREV-STATE and PRESENT-STATE can have the following values; un-initialized=0, jammed=2, wait-for-system=4, wait-for-time=5, wait-for-condition=6, wait-for-interrupt=7, system=8, system-waiting-restart=9, system-waiting-jam=10, interrupt=12, interrupt-waiting-restart=13, interrupt-waiting-jam=14.  the TCB TASK-HANDLER-ID is one of private=0, first=1, measprocessor=16, last=127")                                      (il:* il:|;;| "--The TRANSFER-CONFIG-REC TRANSFER-MODE is one of 0= output block, 1= output byte, 2= input byte,  3= input block")                                      (il:* il:|;;| "--The PSO-FCB WORK-MASK is really the NOTIFY-MASK.")                                      (il:* il:|;;| "--The TRANSFER-CONFIG is one of: 0=  output block, 256= output byte, 512= input byte,  768= input block")                                      (il:* il:|;;|        "--COMMAND-STATUS is one of: not-ready=0, ready=1, in-progress=2, incomplete=3, exceptional=4")                  (il:records client-condition-rec config-regr-rec board-status-rec command-rec                          command-regr-rec port-status-rec task-context-block transfer-config-rec                          pso-fcb))                               (il:* il:|;;| "Specials.")           (il:variables *buffer-sizes* *buffers* *free-index* *full-index* *max-buffers* *trace*                   *trace-window* *tracefile* *max-buffer-size* *device* %pso-fcb%)                               (il:* il:|;;| "top level functions")           (il:functions port-ready-p pso-trace trace-packet allocate-buffers increment-counter half                   transfer-done-p lpo-watcher open-file close-file get-next-buffer pso-force-output                   eventfn write-block port-error)                               (il:* il:|;;| "low-level functions")           (il:functions set-stream-buffer transfer-block transfer-byte wait-until-transfer-done                   cleanup-port initialize-pso-port reset-port ioregion-offset update-status lock-mem                   notify-iop byte-swap)                               (il:* il:|;;| "test and reset functions ")           (il:functions reset-pso-port do-diagnostic-pattern get-diagnostic-result test-pso-port)           (il:p (export '(reset-pso-port test-pso-port pso-trace))                 (if (eql (il:machinetype)                          'il:dove)                     (initialize-pso-port)                     (error "The ~s has no parallel port." (il:machinetype))))))(il:putprops il:pso il:filetype :compile-file)(il:putprops il:pso il:makefile-environment (:readtable "XCL" :package (xcl:defpackage "PSO")                                                   :base 10))(il:* il:|;;| "functions that are used in records.")(defun get-command-word (datum) (il:* il:|;;;| "return the actual word value for the record instead of the record.  this is useful when or'ing with command data or similar occurences.") (il:\\getbase (il:fetch (pso-fcb command) il:of datum)        0))(defun put-command-word (datum value) (il:* il:|;;;| "fills in the command word with a word instead of  a record.  * for faster access") (il:\\putbase (il:fetch (pso-fcb command) il:of datum)        0 value) t)(il:declare\: il:dontcopy (il:filesload (il:sysload)       il:mesatypes       (il:loadcomp)       il:doveinputoutput       (il:source)       il:dovedecls       (il:loadcomp)       il:dovemisc)(defconstant clock-counter-value 5 "Clock counter value")(defconstant command-regr-image-wrd-val 3840 "go: t, 20usecrule: t, not-clear-intrp: t, not-reset: t")(defconstant config-regr-image-wrd-val 50432                     "This means DMA enable, enable intrp, maint-mode nil, use-ack t, clock-counter 9")(defconstant dma-byte-transfer-count.bs 256 "byte swapped transfer count for one byte.")(defconstant dma-cntrl-wrd-block-output.bs 34583 "dma control word for block output, byte swapped")(defconstant dma-cntrl-wrd-byte-output.bs 34327 "byte swapped control word for byte output")(defconstant transfer-command-word-value 1279 "Word value for a transfer command")(defconstant update-status-command 256)(defconstant transfer-config-byte-mode 256                                           "the value of the transfer-config word for byte transfers.")(defconstant transfer-config-word-mode 0 "value of transfer rec for word transfers.")(defconstant reset-command 512 "the reset flag in the command-rec.")(defconstant ioregion-offset 97 "Offset into the ioregion where the PSO lives.")(defconstant status-ready 256 "PSO command-status ready flag on.")(defconstant config-regr-for-diagnostic 24576 "Config regr value for diagnostic to avoid CONSing.")(defconstant command-regr-for-diagnostic 3328 "Command regr value for diagnostics to avoid CONSing.")(defconstant run-diagnostic-command 2048 "Run a diagnostic on the PSO port.")(defconstant port-ready 61998)(il:declare\: il:eval@compile(il:mesarecord client-condition-rec ((handler-id byte)                                     (crmp byte)                                     (condptr il:word)                                     (maskvalue il:word)))(il:mesarecord config-regr-rec                ((dma-enable il:flag)                (enable-intrp il:flag)                (maint-mode il:flag)                (use-ack il:flag)                (clock-counter il:bits 4)                (use-scan-port il:flag)                (do-scan il:flag)                (nil il:bits 6))               (il:blockrecord config-regr-rec ((wrd-val il:word)))               dma-enable il:_ t enable-intrp il:_ t maint-mode il:_ nil use-ack il:_ nil                clock-counter il:_ 0 use-scan-port il:_ nil do-scan il:_ nil)(il:mesarecord board-status-rec ((state-id-4-bits il:bits 4)                                 (unused-bit il:bits 1)                                 (has-hi-byte il:flag)                                 (has-lo-byte il:flag)                                 (dma-request il:flag)                                 (unused-byte byte)))(il:mesarecord command-rec                ((4-unused-bits il:bits 4)                (diagnostic-cmd il:flag)                (transfer-cmd il:flag)                (reset-cmd il:flag)                (update-status-cmd il:flag)                (command-pending-byte byte))               (il:blockrecord command-rec ((wrd-val il:word)))               diagnostic-cmd il:_ nil transfer-cmd il:_ nil reset-cmd il:_ nil update-status-cmd                il:_ nil command-pending-byte il:_ il:|\\DoveIO.ByteFALSE|)(il:mesarecord command-regr-rec                ((unused-4-bits il:bits 4)                (pso-go il:flag)                (enforce-20-usec-rule il:flag)                (not-clear-intrp il:flag)                (not-reset il:flag)                (unused-byte byte))               (il:blockrecord command-regr-rec ((wrd-val il:word)))               unused-4-bits il:_ 0 pso-go il:_ t enforce-20-usec-rule il:_ t not-clear-intrp il:_ t                not-reset il:_ t unused-byte il:_ 0)(il:mesarecord port-status-rec ((bit7 il:flag)                                (bit6 il:flag)                                (bit5 il:flag)                                (bit4 il:flag)                                (acknowledge il:flag)                                (busy il:flag)                                (select il:flag)                                (fault il:flag)                                (bit15 il:flag)                                (bit14 il:flag)                                (pin36 il:flag)                                (pin34 il:flag)                                (pin33 il:flag)                                (pin18 il:flag)                                (pin15 il:flag)                                (pin12 il:flag))                               (il:blockrecord port-status-rec ((wrd-val il:word))))(il:mesarecord task-context-block ((task-queue 2 il:word)                                   (task-condition il:word)                                   (task-ic-ptr il:word)                                   (task-sp il:word)                                   (return-spss 2 il:word)                                   (prev-state il:bits 4)                                   (present-state il:bits 4)                                   (task-handler-id byte)                                   (timer-value il:word)))(il:mesarecord transfer-config-rec ((transfer-mode byte)                                    (nil byte)))(il:mesarecord pso-fcb ((main-task-tcb il:|DoveIO.TaskContextBlock|)                        (intrp-task-tcb il:|DoveIO.TaskContextBlock|)                        (dma1-intrp-task-tcb il:|DoveIO.TaskContextBlock|)                        (client-condition client-condition-rec)                        (work-condition il:word)                        (lock-mask il:word)                        (work-mask il:word)                        (dma1-cntrl-wrd-val il:word)                        (dma-transfer-count il:word)                        (dma-source-ptr il:|Dove.OpieAddress|)                        (cmd-regr-val il:word)                        (config-regr-val il:word)                        (intrp-regr-val il:word)                        (command command-rec)                        (transfer-config il:word)                        (port-status port-status-rec)                        (board-status board-status-rec)                        (command-status il:word)                        (config-regr-image config-regr-rec)                        (cmd-regr-image command-regr-rec)                        (byte-io il:word)                        (eeprom-image il:word)                        (interrupt-word il:word)                        (diag-test-pattern il:word)                        (diag-return-pattern il:word)                        (intrp-cnt byte)                        (bad-intrp-cnt byte)                        (bad-dma1-intrp-cnt byte)                        (debug-byte0 byte)                        (debug-word0 il:word)                        (debug-word1 il:word))                       (il:accessfns (command-word (get-command-word il:datum)                                            (put-command-word il:datum il:newvalue))))))(il:* il:|;;| "Specials.")(xcl:defglobalvar *buffer-sizes* nil)(xcl:defglobalvar *buffers* nil)(xcl:defglobalvar *free-index* nil)(xcl:defglobalvar *full-index* nil)(xcl:defglobalvar *max-buffers* 10)(defvar *trace* nil)(defvar *trace-window* nil)(defvar *tracefile* nil)(xcl:defglobalvar *max-buffer-size* 512)(xcl:defglobalvar *device* nil)(xcl:defglobalvar %pso-fcb% nil)(il:* il:|;;| "top level functions")(defun port-ready-p nil (eq (logand port-ready (il:ffetch (port-status-rec wrd-val)                                                  il:of (il:ffetch (pso-fcb port-status) il:of                                                                                             %pso-fcb%                                                               )))                            port-ready))(defun pso-trace (mode) (cond                           ((or (eq mode t)                                (eq mode :peek))                            (setq *trace-window* (il:createw nil "PSO Trace Window"))                            (setq *tracefile* (il:getstream *trace-window* 'il:output))                            (il:dspfont '(il:gacha 8) *tracefile*)                            (il:dspscroll 'il:on *tracefile*)                            (cond                               ((il:windowp *trace-window*)                                (il:windowprop *trace-window* 'il:closefn                                       #'(lambda (window)                                                (setq *trace* nil)))                                (il:windowprop *trace-window* 'il:buttoneventfn                                       #'(lambda (window)                                                (and (il:mousestate (not il:up))                                                     (setq *trace* (case *trace* ((t)                                                                                  (format *tracefile*                                                                              "~%[Tracing now peek]~%"                                                                                         )                                                                                  :peek)                                                                         (:peek (format *tracefile*                                                                               "~%[Tracing now off]~%"                                                                                       )                                                                                nil)                                                                         (otherwise (format                                                                                           *tracefile*                                                                                "~%[Tracing now on]~%"                                                                                           )                                                                                t))))))))))                        (setq *trace* mode))(defun trace-packet (packet &optional byte) (case *trace* ((t)                                                           (if packet (format *tracefile* "[~s]"                                                                              packet)                                                               (format *tracefile* "<~s>" byte)))                                                  (:peek (if packet (princ "!" *tracefile*)                                                             (princ "." *tracefile*)))))(defun allocate-buffers nil (il:* il:|;;;| "pre-allocate the buffers for the LPO device.")                            (setq *buffers* (make-array *max-buffers*))                            (setq *buffer-sizes* (make-array *max-buffers*))                            (dotimes (i *max-buffers*)                                   (setf (aref *buffers* i)                                         (il:ncreate 'il:vmempagep)))                            (cleanup-port)                            t)(defmacro increment-counter (counter) `(progn (incf ,counter)                                              (if (eq ,counter *max-buffers*)                                                  (setq ,counter 0))))(defmacro half (val) `(ash ,val -1))(defun transfer-done-p nil (il:* il:|;;;| "return t if the transfer is done.")                           (update-status)                           (and (eq (il:fetch (pso-fcb command-status) il:of %pso-fcb%)                                    status-ready)                                (eq (il:fetch (command-rec command-pending-byte)                                       il:of (il:fetch (pso-fcb command) il:of %pso-fcb%))                                    il:|\\DoveIO.ByteFALSE|)))(defun lpo-watcher nil (il:* il:|;;;| "this is the function that watches the parallel port and tries to send down a page at a time.  If the page is has an extra byte at the end, then it will be dealt with here.  The functions TRANSFER-BYTE  and TRANSFER-BLOCK will check the port status and error if there is something wrong with the hardware.")                       (let (packet size odd-packet)                            (loop (il:block)                                  (cond                                     ((transfer-done-p)                                      (when packet           (il:* il:\;                                                              "there was a packet being transferred.")                                            (when odd-packet                     (il:* il:|;;| "The packet length was odd, and since the LPO can only transfer blocks in increments of words, it was given n-1 for the packet length, and we have to transfer the last byte now.")                                                  (transfer-byte (il:\\getbasebyte packet                                                                        (1- size)))                    (il:* il:|;;| "wait until the transfer is really done.")                                                  (wait-until-transfer-done)                    (il:* il:|;;| "reset the flag.")                                                  (setq odd-packet nil))                    (il:* il:|;;| "now put the packet back into the free-buffers list.")                                            (setf (aref *buffer-sizes* *full-index*)                                                  nil)                                            (increment-counter *full-index*))                    (il:* il:|;;| "get the next full packet, ")                                      (cond                                         ((aref *buffer-sizes* *full-index*)                                          (setq packet (aref *buffers* *full-index*))                                          (setq size (aref *buffer-sizes* *full-index*)))                                         (t (setq packet nil)))                    (il:* il:|;;| "if there is one, transfer it.")                                      (and packet (cond                                                     ((oddp size)                    (il:* il:|;;| "the length is odd, so we have to transfer normally the first n-1 bytes of the packet, and then transfer the final byte using byte IO.")                                                      (setq odd-packet t)                                                      (if (> size 1)                    (il:* il:|;;| "otherwise this thing will transfer 64K of data!")                                                          (transfer-block packet (1- size))))                                                     (t (transfer-block packet size)))))))))(defun open-file (name access recog parameters device) (il:* il:|;;;| "open a stream to the lpo port. ") (declare (special il:promptwindow)) (cond    (*device* (unless (transfer-done-p)                    (il:* il:|;;| "if the transfer wasn't done, then wait around and reset the port.  There was probably an error causing the old transfer to hang.")                     (il:dismiss 1000)                     (reset-port))           (if (transfer-done-p)                    (il:* il:|;;| "transfer-done also checks to see if the port is \"ready\"")               (if (or (eql access 'il:output)                       (eql access 'il:append))                   (let ((oldstream (il:fetch (il:fdev il:deviceinfo) il:of device)))                        (if (not (eql (il:machinetype)                                      'il:dove))                            (error "PSO is not implemented on a ~s." (il:machinetype)))                        (if oldstream (error "Only one output stream allowed at a time ~s" name)                            (progn (unless (il:find.process 'lpo-watcher)                                          (il:add.process `(lpo-watcher) 'il:restartable t))                                   (setf (il:fetch (il:fdev il:deviceinfo) il:of device)                                         (il:create stream                                                il:device il:_ device                                                il:fullfilename il:_ "{pso}")))))                   (error "Only output is implemented"))               (format il:promptwindow "~%[PSO: Port is not ready, check printer!]~%")))    (t (error "The PSO port was not initialized."))))(defun close-file (stream &optional abort?) (il:* il:|;;;| "close the LPO file") (unless abort? (il:bout stream 12)                          (il:* il:\;                                       "send out a FORM-FEED to make sure the last page gets printed.")        (pso-force-output stream t)                          (il:* il:\; "if it wasn't aborted, send out the last packet.  forceoutput will wait until the stream has been cleared.")        ) (il:del.process (il:find.process 'lpo-watcher)) (cleanup-port)                                              (il:* il:\;                                                "CLEANUP-PORT will fix all the pointers for the port.") (reset-port) (setf (il:fetch (il:fdev il:deviceinfo) il:of (il:fetch (stream il:device) il:of stream))       nil))(defun get-next-buffer (stream whatfor &optional noerrorflg) (il:* il:|;;;| "get a new buffer and error if you can't.") (case whatfor (il:read                     (il:* il:|;;| "they want to read from the parallel port.  This isn't supported.")                      (error "Read not supported on PSO streams."))       (write                     (il:* il:|;;| "get a new packet for the stream.  Always BLOCK first to allow a packet to go out.  Also BLOCK if you can't get a new packet, waiting for one to get free.")              (il:block)              (when (or (il:ffetch (stream il:cbufdirty) il:of stream)                        (null (il:ffetch (stream il:cbufptr) il:of stream)))                    (il:* il:|;;| "change the buffers 'cause they are dirty.")                    (let ((buffer (aref *buffers* *free-index*))                          (index *free-index*)                          (retry-count 0))                         (loop (cond                                  ((or (not (eq *free-index* *full-index*))                                       (null (aref *buffer-sizes* index)))                    (il:* il:|;;| "increment *FREE-INDEX* mod *MAX-BUFFERS*")                                   (increment-counter *free-index*)                                   (return))                                  (t                     (il:* il:|;;| "wait until there is a buffer, error if you wait too long.")                                     (when (> retry-count 500)                                           (port-error)                                           (update-status)   (il:* il:\; "reset the port.")                                           (setq retry-count 0))                                     (il:block)              (il:* il:\;                                                          "let the watcher try and move some buffers.")                                     (incf retry-count)      (il:* il:\; "increment the retry count")                                     )))                         (set-stream-buffer stream buffer index)))              t)       (otherwise (il:shouldnt))))(defun pso-force-output (stream waitforfinish) (il:* il:|;;;| "force the stream to put out the packets it has.") (cond    (waitforfinish (get-next-buffer stream 'write t)           (loop (if (null (aref *buffer-sizes* *full-index*))                     (return)                                (il:* il:\;                                                         "otherwise wait until the buffers are clear.")                     (il:block))))    (t (get-next-buffer stream 'write t))))(defun eventfn (device event) (il:* il:|;;;| "gets called when a major system event occurs.") (case event ((il:afterlogout il:aftersysout il:aftermakesys il:aftersavevm)              (if (eql (il:machinetype)                       'il:dove)                  (reset-port)                  (error "PSO is not implemented on a ~s." (il:machinetype))))) nil)(defun write-block (stream base off nbytes) (il:* il:|;;;| "for doing fast output of blocks of information.  This could be done by direct calls to transfer-block.") (il:\\buffered.bouts (il:\\dtest stream 'stream)        base off nbytes))(defun port-error nil (il:* il:|;;;| "error based on the status of the port.")                      (declare (special il:promptwindow))                      (let ((status (il:ffetch (port-status-rec wrd-val) il:of (il:ffetch                                                                                (pso-fcb port-status)                                                                                  il:of %pso-fcb%)))                            (abortflg t))                           (unwind-protect (progn (case status (59182 (xcl:help                                                                  "Parallel Port device is not ready "                                                      "please reset, and then type RETURN to continue"                                                                             ))                                                        (59183 (xcl:help                                                                  "Parallel Port device is not ready "                                                "please check paper, and then type RETURN to continue"                                                                      ))                                                        (58406 (xcl:help                                                                       "Parallel Port device is dead "                                                    "please turn on, and then type RETURN to continue"                                                                      ))                                                        (otherwise (if (> (logand status 102)                                                                          0)                                                                       (xcl:help                                                                    "Parallel Port device is offline "                                                      "please reset, and then type RETURN to continue"                                                                              )                                                                       (if (> (logand status 179)                                                                              0)                                                                           (xcl:help                                                                "Parallel Port device buffer is full "                                                      "please reset, and then type RETURN to continue"                                                                                  )                                                                           (xcl:help                                                                  "Parallel Port device is not ready "                                                             "please fix, and type RETURN to continue"                                                                                  )))))                                                  (setq abortflg nil))                                  (when abortflg (format il:promptwindow                                                         "[PSO: Error! Output aborted!]")                                        (il:\\closefile (il:ffetch (il:fdev il:deviceinfo)                                                           il:of *device*)                                               t)                                        (update-status)))))(il:* il:|;;| "low-level functions")(defun set-stream-buffer (stream buffer index) (il:* il:|;;;| "set the current buffer pointer to the new buffer. ") (if (il:ffetch (stream il:cbufptr) il:of stream)                    (il:* il:|;;| "there already is a buffer and it is full, so deal with it.")     (setf (aref *buffer-sizes* (il:ffetch (stream il:f1) il:of stream))           (il:ffetch (stream il:coffset) il:of stream))) (il:freplace (stream il:cbufmaxsize) il:of stream il:with *max-buffer-size*) (il:freplace (stream il:cbufsize) il:of stream il:with *max-buffer-size*) (il:freplace (stream il:coffset) il:of stream il:with 0) (il:freplace (stream il:cbufptr) il:of stream il:with buffer) (il:freplace (stream il:cbufdirty) il:of stream il:with nil) (il:freplace (stream il:f1) il:of stream il:with index))(defun transfer-block (packet size) (il:* il:|;;;| "transfer the block given.  Check the port to see if everything is ok first.") (let ((retry-count 0)       status)      (loop (wait-until-transfer-done)            (cond               ((port-ready-p)                    (il:* il:|;;| "it is ok to transfer stuff.")                (il:freplace (pso-fcb config-regr-val) il:of %pso-fcb% il:with                                                                             config-regr-image-wrd-val                       )                (il:freplace (pso-fcb cmd-regr-val) il:of %pso-fcb% il:with                                                                           command-regr-image-wrd-val)                (il:freplace (pso-fcb transfer-config) il:of %pso-fcb% il:with                                                                             transfer-config-word-mode                       )                (il:freplace (pso-fcb dma1-cntrl-wrd-val) il:of %pso-fcb% il:with                                                                         dma-cntrl-wrd-block-output.bs                       )                (il:freplace (pso-fcb dma-transfer-count) il:of %pso-fcb% il:with (byte-swap                                                                                   (half size)))                (il:freplace (il:|Dove.OpieAddress| il:|LispPointer|) il:of (il:ffetch (pso-fcb                                                                                                                                                                               dma-source-ptr                                                                                        )                                                                               il:of %pso-fcb%)                   il:with packet)                    (il:* il:|;;| "initiate the transfer.")                (lock-mem transfer-command-word-value)       (il:* il:\;                                          "give the IOP the command to transfer, and tell it to DOIT.")                (notify-iop)                (return))               (t (when (> retry-count 3)                        (port-error))                  (update-status)                            (il:* il:\; "update the status")                  (il:dismiss 100)                           (il:* il:\;                                                             "go away to let the update do something.")                  )))      (trace-packet size)))(defun transfer-byte (byte) (il:* il:|;;;| "transfer the byte given.  Check the port first.") (let ((retry-count 0)       status)      (loop (wait-until-transfer-done)            (cond               ((port-ready-p)                    (il:* il:|;;| "it is ok to transfer stuff.")                    (il:* il:|;;| "initialize the command-registers.")                (il:freplace (pso-fcb config-regr-val) il:of %pso-fcb% il:with                                                                             config-regr-image-wrd-val                       )                (il:freplace (pso-fcb cmd-regr-val) il:of %pso-fcb% il:with                                                                           command-regr-image-wrd-val)                    (il:* il:|;;| "set up dma of one byte.")                (il:freplace (pso-fcb transfer-config) il:of %pso-fcb% il:with                                                                             transfer-config-byte-mode                       )                (il:freplace (pso-fcb dma1-cntrl-wrd-val) il:of %pso-fcb% il:with                                                                          dma-cntrl-wrd-byte-output.bs                       )                (il:freplace (pso-fcb byte-io) il:of %pso-fcb% il:with (byte-swap byte))                    (il:* il:|;;| "256 is byte swapped 1.  ie. transfer 1 byte.")                (il:freplace (pso-fcb dma-transfer-count) il:of %pso-fcb% il:with 256)                (il:freplace (il:|Dove.OpieAddress| il:|LispPointer|) il:of (il:ffetch (pso-fcb                                                                                                                                                                               dma-source-ptr                                                                                        )                                                                               il:of %pso-fcb%)                   il:with (il:locf (il:ffetch (pso-fcb byte-io) il:of %pso-fcb%)))                    (il:* il:|;;| "initiate the transfer.")                (lock-mem transfer-command-word-value)                (notify-iop)                (return))               (t (when (> retry-count 3)                        (port-error))                  (update-status)                            (il:* il:\; "update the status")                  (il:dismiss 100)                           (il:* il:\;                                                    "block to let the update do something, and retry.")                  )))      (trace-packet nil byte)))(defun wait-until-transfer-done nil (il:* il:|;;;| "wait until the transfer is done.  This is called when doing a byte transfer only.  256 is byte-swapped 1 which indicates the LPO is READY.")                                    (let ((retry-count 0))                                         (loop (if (transfer-done-p)                                                             (il:* il:\; "the transfer was done.")                                                   (return))                    (il:* il:|;;| "error if the transfer is not completing.")                                               (when (> retry-count 1000)                                                     (port-error)                                                     (setq retry-count 0)                                                             (il:* il:\;                                                        "you have to update the status after a return")                                                     (update-status)                                                             (il:* il:\;                                                        "It takes a while for the update to complete.")                                                     (il:dismiss 100))                                               (il:block)    (il:* il:\;                                                              "block to let the other code run.")                                               (incf retry-count))))(defun cleanup-port nil (il:* il:|;;;| "fixes all the port packet pointers to their original state.")                        (setq *free-index* 0)                        (setq *full-index* 0)                        (dotimes (i *max-buffers*)                               (setf (aref *buffer-sizes* i)                                     nil)))(defun initialize-pso-port nil (il:* il:|;;;| "initialize the PSO software.")                               (cond                                  ((eql (il:machinetype)                                        'il:dove)                                   (setq %pso-fcb% (il:|\\DoveIO.GetHandlerIORegionPtr|                                                           ioregion-offset))                                   (unless *device*                                          (setq *device*                                                (il:create il:fdev                                                       il:devicename il:_ 'il:pso                                                       il:resetable il:_ nil                                                       il:randomaccessp il:_ nil                                                       il:pagemapped il:_ nil                                                       il:fdbinable il:_ nil                                                       il:fdboutable il:_ t                                                       il:buffered il:_ t                                                       il:closefile il:_ (il:function close-file)                                                       il:deletefile il:_ (il:function il:nill)                                                       il:getfileinfo il:_ (il:function il:nill)                                                       il:openfile il:_ (il:function open-file)                                                       il:readpages il:_ (il:function                                                                           il:\\is.not.randaccessp)                                                       il:setfileinfo il:_ (il:function il:nill)                                                       il:generatefiles il:_ (il:function                                                                               il:\\generatenofiles)                                                       il:truncatefile il:_ (il:function il:nill)                                                       il:writepages il:_ (il:function                                                                            il:\\is.not.randaccessp)                                                       il:getfilename il:_ (il:function il:nill)                                                       il:reopenfile il:_ (il:function il:nill)                                                       il:eventfn il:_ (il:function eventfn)                                                       il:directorynamep il:_ (il:function il:nill)                                                       il:hostnamep il:_ (il:function il:nill)                                                       il:bin il:_ (il:function il:\\illegal.deviceop                                                                    )                                                       il:bout il:_ (il:function il:\\buffered.bout)                                                       il:readp il:_ (il:function il:nill)                                                       il:eofp il:_ (il:function il:nill)                                                       il:peekbin il:_ (il:function                                                                         il:\\illegal.deviceop)                                                       il:getfileptr il:_ (il:function il:nill)                                                       il:setfileptr il:_ (il:function il:nill)                                                       il:backfileptr il:_ (il:function il:nill)                                                       il:blockin il:_ (il:function                                                                         il:\\illegal.deviceop)                                                       il:blockout il:_ (il:function write-block)                                                       il:unreadchar il:_ (il:function                                                                            il:\\illegal.deviceop)                                                       il:peekchar il:_ (il:function                                                                          il:\\illegal.deviceop)                                                       il:writechar il:_ (il:function                                                                           il:\\buffered.bout)                                                       il:readchar il:_ (il:function                                                                          il:\\illegal.deviceop)                                                       il:getnextbuffer il:_ (il:function                                                                               get-next-buffer)                                                       il:forceoutput il:_ (il:function                                                                             pso-force-output)                                                       il:lastc il:_ (il:function                                                                       il:\\illegal.deviceop)                                                       il:geteofptr il:_ (il:function                                                                           il:\\is.not.randaccessp)))                                          (il:\\definedevice 'il:pso *device*))                                   (allocate-buffers)                                   t)                                  (t (error "PSO:: there is no PSO port on this machine!"))))(defun reset-port nil (il:* il:|;;;| "Resets the LPO port.  512 is the Reset-Cmd flag in the command-rec. ")                      (lock-mem reset-command)               (il:* il:\; "and do the notify.")                      (notify-iop)                      (il:dismiss 500))(defmacro ioregion-offset (location) `(- (il:\\loloc ,location)                                         (il:\\loloc il:|\\DoveIORegion|)))(defun update-status nil (il:* il:|;;;| "update the status of the port.")                         (lock-mem update-status-command)    (il:* il:\; "and notify the IOP.")                         (notify-iop))(defmacro lock-mem (value) (il:* il:|;;;| "this macro is especially for use with the PSO.  It is a special case of calling Lock Mem where you need only the values here.  The first argument is the Lock-Mask, the second arg is the value, the third is the address, and the fourth is the operation. ") `((il:opcodes il:dovemisc 5)   (il:fetch (pso-fcb lock-mask) il:of %pso-fcb%)   ,value   (+ (ioregion-offset %pso-fcb%)      40)   il:|\\DoveIO.OR|))(defmacro notify-iop nil '(il:|\\DoveIO.NotifyIOP| (il:fetch (pso-fcb work-mask) il:of %pso-fcb%)))(defmacro byte-swap (byte) `((il:opcodes il:dovemisc 4)                             ,byte))(il:* il:|;;| "test and reset functions ")(defun reset-pso-port nil (let ((output-stream (il:ffetch (il:fdev il:deviceinfo) il:of *device*)))                    (il:* il:|;;| "kill the watcher process first to make sure nothing else gets out.")                               (il:del.process (il:find.process 'lpo-watcher))                    (il:* il:|;;| "if there is a stream, close it.")                               (if (and output-stream (streamp output-stream)                                        (il:openp output-stream 'il:output))                                   (il:\\closefile output-stream t))                    (il:* il:|;;| "make sure you do the cleanups on the port.")                               (cleanup-port)                               (reset-port)                               (setf (il:ffetch (il:fdev il:deviceinfo) il:of *device*)                                     nil)                               t))(defun do-diagnostic-pattern (pattern) (il:* il:|;;;| "run a diagnostic on the PSO with PATTERN.") (il:freplace (pso-fcb config-regr-val) il:of %pso-fcb% il:with config-regr-for-diagnostic) (il:freplace (pso-fcb cmd-regr-val) il:of %pso-fcb% il:with command-regr-for-diagnostic) (il:freplace (pso-fcb diag-test-pattern) il:of %pso-fcb% il:with (byte-swap pattern)) (lock-mem run-diagnostic-command) (notify-iop) (il:block))(defun get-diagnostic-result nil (il:* il:|;;;| "get the diagnostic result.")                                 (byte-swap (il:ffetch (pso-fcb diag-return-pattern) il:of %pso-fcb%)                                        ))(defun test-pso-port (&optional short?)                     (il:* il:|;;| "test the pso port.") (let ((error-count 0)       (repetitions (if short? 2000 65535)))      (format *standard-output* "~%;;Beginning hardware diagnostics:~%")      (dotimes (pattern repetitions)             (do-diagnostic-pattern pattern)             (if (zerop (mod pattern 1000))                 (princ "." *standard-output*))             (if (zerop (mod pattern 10000))                 (princ "!" *standard-output*))             (unless (eq pattern (get-diagnostic-result))                    (format *standard-output* "~%PSO diagnostic failed at ~s.~%" pattern)                    (incf error-count))             (when (> error-count 15)                   (format *standard-output* "Too many errors, aborting diagnostic.~%")                   (format *standard-output* "The port may be bad or improperly installed.~%")                   (return-from test-pso-port)))      (format *standard-output* "~%;;hardware test complete, ~s errors detected.~%" error-count))                    (il:* il:|;;|           "it succeeded in the internal diagnostics, now let's try the rest of the port.") (princ ";;Printing a test page..." *standard-output*) (terpri *standard-output*) (with-open-stream (output-stream (open "{pso}" :direction :output))        (dotimes (row 55)               (print "0123456789012345678901234567890123456789012345678901234567890" output-stream))                    (il:* il:|;;| "a form feed to make it print.")        (il:bout output-stream 12)) (format *standard-output* ";;Test complete.~%") t)(export '(reset-pso-port test-pso-port pso-trace))(if (eql (il:machinetype)         'il:dove)    (initialize-pso-port)    (error "The ~s has no parallel port." (il:machinetype)))(il:putprops il:pso il:copyright ("Xerox Corporation" 1987))(il:declare\: il:dontcopy  (il:filemap (nil)))il:stop