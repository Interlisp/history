(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "ROOMS")(il:filecreated " 1-Nov-88 11:57:20" il:|{EG:PARC:XEROX}<CUTTING>ROOMS>ROOMS-INTERACTIVE.;2| 20666        il:|changes| il:|to:|  (il:vars il:rooms-interactivecoms)      il:|previous| il:|date:| "22-Jul-88 10:25:23" il:|{EG:PARC:XEROX}<CUTTING>ROOMS>ROOMS-INTERACTIVE.;1|); Copyright (c) 1987, 1988 by Xerox Corporation.  All rights reserved.(il:prettycomprint il:rooms-interactivecoms)(il:rpaqq il:rooms-interactivecoms ((il:* il:|;;| "mostly portable interactive code (joke?)") (file-environments il:rooms-interactive) (il:p (export (quote (interactive-go-to-room-named interactive-copy-placement interactive-move-placement))) (require "ROOMS")) (il:variables *background-item* *move-item* *close-item*) (il:functions install-menu-items install-menu-item) (il:p (pushnew (quote (install-menu-items)) *reset-forms* :test (quote equal))) (il:functions interactive-close-window interactive-go-to-room interactive-go-to-overview interactive-go-to-room-named interactive-edit-room edit-room interactive-edit-placements interactive-include-room interactive-exclude-room interactive-delete-room interactive-find-placement interactive-copy-placement interactive-move-placement interactive-copy-placement-to-this-room interactive-move-placement-to-pockets interactive-move-or-copy-placement interactive-reset select-room interactive-make-room interactive-copy-room interactive-rename-room interactive-make-door make-door retrieve-windows check-lost-windows eval-walk) (il:coms (il:* il:|;;| "back doors") (il:variables *back-door-room-name*) (il:functions make-back-door back-door-entry-function) (il:p (pushnew (quote back-door-entry-function) *room-entry-functions*))) (il:globalvars il:promptwindow il:crosshairs)))(il:* il:|;;| "mostly portable interactive code (joke?)")(define-file-environment il:rooms-interactive :compiler :compile-file :package "ROOMS" :readtable "XCL")(export (quote (interactive-go-to-room-named interactive-copy-placement interactive-move-placement)))(require "ROOMS")(defglobalparameter *background-item* (il:bquote ("Rooms" (quote (with-button (quote (interactive-go-to-overview)) "Overview" "Enter the overview")) "Enter the overview" (il:subitems ("Go to Room" (quote (with-button (quote (interactive-go-to-room :allow-new? t)) "Go to Room" "Go to a room, possibly new.")) "Go to a room, possibly new.") ("Make Room" (quote (with-button (quote (interactive-make-room)) "Make Room" "Make a new room.")) "Make a new room.") ("Edit Room" (quote (with-button (quote (interactive-edit-room)) "Edit Room" "Edit a selected room.")) "Edit a selected room." (il:subitems ("Edit This Room" (quote (with-button (quote (edit-room *current-room*)) "Edit This Room" "Edit the current room.")) "Edit a selected room.") ("Edit Placements" (quote (with-button (quote (interactive-edit-placements)) "Edit Placements" "Edit placements of a selected room")) "Edit placements of a selected room") ("Exclude Room" (quote (with-button (quote (interactive-exclude-room)) "Exclude Room" "Exclude a room from another.")) "Exclude a room from another." (il:subitems ("From This Room" (quote (with-button (quote (interactive-exclude-room *current-room*)) "Exclude From This Room" "Exclude a room from the current room.")) "Exclude a room from another."))) ("Include Room" (quote (with-button (quote (interactive-include-room)) "Include Room" "Include a room in another.")) "Include a room in another." (il:subitems ("In This Room" (quote (with-button (quote (interactive-include-room *current-room*)) "Include In This Room" "Include a room in the current room.")) "Include a room in the current room."))))) ("Delete Room" (quote (with-button (quote (interactive-delete-room)) "Delete Room" "Delete a room.")) "Delete a room.") ("" nil "No-op") ("Retrieve Windows" (quote (with-button (quote (retrieve-windows)) "Retrieve Windows" "Retrieve windows lost from all rooms.")) "Retrieve windows lost from all rooms.") ("Suites" (quote (with-button (quote (suite-menu)) "Suites" "Save a set of rooms to a file")) "Save a set of rooms to a file" (il:subitems (il:\\\,@ *suite-menu-items*))) ("Make Door" (quote (interactive-make-door :allow-new? t)) "Make a door to a room - a button to enter it." (il:subitems ("Make Back Door" (quote (make-back-door)) "Make a back door - a door to the previous room.")))))))(defparameter *move-item* (quote (il:|Move| (quote il:movew) "Moves window by a corner" (il:subitems ("Move to another room" (quote interactive-move-placement) "Move this placement to another room" (il:subitems ("Move to pockets" (quote interactive-move-placement-to-pockets) "Move this placement to the pocket room"))) ("Copy to another room" (quote interactive-copy-placement) "Copy this placement to another room" (il:subitems ("Copy to this room" (quote interactive-copy-placement-to-this-room) "Copy this placement to this room"))) ("Where is?" (quote interactive-find-placement) "Find which room this placement is in.")))))(defparameter *close-item* (quote (il:|Close| (quote interactive-close-window) "Closes a window")))(defun install-menu-items nil (install-menu-item *background-item* (quote il:|BackgroundMenuCommands|) (quote il:|BackgroundMenu|)) (install-menu-item *move-item* (quote il:|WindowMenuCommands|) (quote il:|WindowMenu|)) (install-menu-item *move-item* (quote il:|IconWindowMenuCommands|) (quote il:|IconWindowMenu|)) (install-menu-item *close-item* (quote il:|WindowMenuCommands|) (quote il:|WindowMenu|)) (install-menu-item *close-item* (quote il:|IconWindowMenuCommands|) (quote il:|IconWindowMenu|)))(defun install-menu-item (item items-var menu-var) (let* ((items (copy-tree (symbol-value items-var))) (old-entry (assoc (first item) items :test (quote equal)))) (if old-entry (setf (rest old-entry) (rest item)) (nconc items (list item))) (set items-var items) (il:* il:|;;| "force the menu to be rebuilt") (set menu-var (quote nil))))(pushnew (quote (install-menu-items)) *reset-forms* :test (quote equal))(defun interactive-close-window (window &optional (from-room *current-room*)) (il:* il:|;;;| "this should probably be called interactive-delete-placement.  it's whats called from the window menu & is used by the placement editor.") (il:* il:|;;;| "we need to catch the case where a room has multiple placements and query the user as to which are to be deleted -- all or just the most immediate.") (let ((main-window (main-window window)) (window-to-close window)) (when (and (not (icon? window)) (not (eq window main-window))) (il:* il:|;;| "it's an attached window") (let ((pass-to-main-coms (il:windowprop window (quote il:passtomaincoms)))) (il:* il:|;;| "have to simulate IL:DOATTACHEDWINDOWCOM") (unless (or (eq pass-to-main-coms t) (member (quote il:closew) pass-to-main-coms :test (quote eq))) (il:* il:|;;| "this window closes locally") (close-window window) (return-from interactive-close-window)) (setq window-to-close main-window))) (let ((rooms (find-rooms-containing main-window))) (il:* il:|;;| "note: this needs to run fairly quickly, so we don't call UPDATE-PLACEMENTS.") (if (null rooms) (il:* il:|;;| "new window -- just close it") (close-window window-to-close) (case (if (and (endp (rest rooms)) (find-placement main-window from-room)) (il:* il:|;;| "we're looking at the only placement") (if (eq from-room (first rooms)) (il:* il:|;;| "it's an immediate placement  -  just delete it") :all (il:* il:|;;| "it's inherited - get confirmation") (if (confirm "This placement is in the included room ~S.~%Are you sure you want to delete it?" (room-name (first rooms))) :all)) (menu (quote (("All placements" :all) ("Just this placement" :this))) "Delete?" "This window has placements in more than one room")) (:all (let ((hidden? (window-hidden? main-window))) (il:* il:|;;| "note whether window was hidden & make it not") (when hidden? (un-hide-window main-window)) (il:* il:|;;| "try to close visible part ") (close-window (if (shrunken? main-window) (window-icon main-window) main-window)) (if (and hidden? (or (il:openwp main-window) (il:openwp (window-icon main-window)))) (il:* il:|;;| "if close failed & window was hidden before, then re-hide it") (hide-window main-window) (il:* il:|;;| "otherwise go ahead & delete all its placements") (dolist (room rooms) (let ((placement (find-placement-in-room main-window room))) (when placement (delete-placement placement room))))))) (:this (multiple-value-bind (placement in-room) (find-placement main-window from-room) (when placement (delete-placement placement in-room)) (il:* il:|;;| "don't actually close -- just hide it") (hide-window main-window) (setq placement (find-placement main-window *current-room*)) (when placement (il:* il:|;;| "we now inherit it from somewhere else") (place-placement placement)))))))))(defun interactive-go-to-room (&key room allow-new?) (let ((name (if room (room-name room) (select-room :allow-new? allow-new? :reason "Go to room" :name-only? t)))) (when name (with-button (il:bquote (interactive-go-to-room-named (quote (il:\\\, name)))) name (format nil "Go to room named ~S." name)))))(defun interactive-go-to-overview nil (update-placements) (go-to-room *overview-room* :baggage (select-baggage) :no-update t))(defun interactive-go-to-room-named (name) (let ((room (room-named name))) (if room (progn (update-placements *current-room*) (go-to-room room :baggage (select-baggage) :no-update t)) (notify-user "No room named ~S exists!" name))))(defun interactive-edit-room nil (let ((name (select-room :reason "Edit" :name-only? t))) (when name (with-button (il:bquote (edit-room (room-named (quote (il:\\\, name))))) (format nil "Edit ~A" name) (format nil "Edit room named ~S." name)))))(defun edit-room (room) (let* ((room (cond ((and (room-p room) (room-named (room-name room))) room) ((room-named room)) (t (notify-user "Can't edit room ~S" room) (return-from edit-room)))) (external-form (il:bquote (:inclusions (il:\\\, (copy-tree (room-inclusions room))) :background (il:\\\, (copy-tree (background-external-form (room-background room)))) (il:\\\,@ (copy-tree (room-props room))))))) (with-profile (find-profile "XCL") (il:edite external-form nil (room-name room) (quote il:|Expression|) (function (lambda (&rest ignore) (il:* il:|;;| "in case ROOM has been redefined") (setq room (room-named (room-name room))) (setf (room-background room) (make-background (copy-tree (getf external-form :background)))) (when (in-room? room) (update-placements)) (setf (room-inclusions room) (copy-tree (getf external-form :inclusions))) (let ((props (copy-list external-form))) (dolist (prop (quote (:inclusions :background))) (remf props prop)) (setf (room-props room) (copy-tree props))) (room-changed room :edited))) (quote (:dontwait))))))(defun interactive-edit-placements nil (let ((name (select-room :reason "Edit Placements" :name-only? t))) (when name (with-button (il:bquote (get-pe (quote (il:\\\, name)))) (format nil "Edit ~A's Placements" name) (format nil "Edit the placements of ~S." name)))))(defun interactive-include-room (&optional in-room) (let* ((all-rooms (all-rooms t)) (room (or in-room (select-room :allow-new? t :reason "Include in ..." :from-rooms all-rooms)))) (when room (unless (listp (room-inclusions room)) (return-from interactive-include-room (notify-user "Can't add inclusions to ~S." room))) (let ((inclusion (select-room :allow-new? t :reason (format nil "Include in ~A" (room-name room)) :from-rooms (remove room all-rooms)))) (when inclusion (when (member (room-name inclusion) (room-inclusions room) :test (quote equal)) (return-from interactive-include-room (notify-user "~S is already included in ~S" (room-name inclusion) (room-name room)))) (update-placements) (when (and (equal (background-external-form (room-background inclusion)) (il:bquote ((:text (il:\\\, (room-name inclusion)))))) (equal (background-external-form (room-background room)) (il:bquote ((:text (il:\\\, (room-name room))))))) (il:* il:|;;| "feature: when both names are in default position we delete name of included room s.t. they don't overwrite.") (setf (room-background inclusion) (make-background (il:bquote ((:text (il:\\\, "")))))) (room-changed inclusion :edited)) (push (room-name inclusion) (room-inclusions room)) (room-changed room :edited) (notify-user "Included ~S in ~S." (room-name inclusion) (room-name room)) t)))))(defun interactive-exclude-room (&optional from-room) (let ((room (or from-room (select-room :reason "Exclude from ...")))) (when room (unless (consp (room-inclusions room)) (return-from interactive-exclude-room (notify-user "~S has no inclusions." room))) (let ((inclusion (menu (room-inclusions room) (format nil "Exclude from ~A" (room-name room))))) (when inclusion (update-placements) (setf (room-inclusions room) (remove inclusion (room-inclusions room :test (quote equal)))) (room-changed room :edited) (notify-user "~S is no longer included in ~S." inclusion (room-name room)) t)))))(defun interactive-delete-room (&optional room) (flet ((delete? (room) (when (and room (confirm " Delete room ~S?  (will close windows)" (room-name room))) (delete-room room)))) (let ((rooms (rooms-not-in-any-suite t))) (if room (if (member room rooms :test (quote eq)) (delete? room) (notify-user "Delete ~S from suite ~S before deleting" (room-name room) (find-suite-containing (room-name room)))) (if rooms (delete? (select-room :reason "Delete" :from-rooms rooms)) (notify-user "All rooms belong to some suite."))))))(defun interactive-find-placement (window) (let ((window (main-window window))) (update-placements) (notify-user "This placement is in ~S." (room-name (multiple-value-bind (placement room) (find-placement window) room)))))(defun interactive-copy-placement (window &optional room-name) (un-hide-window window) (let ((name (or room-name (select-room :reason "Copy this placement to" :allow-new? t :name-only? t)))) (when name (interactive-move-or-copy-placement window name t))))(defun interactive-move-placement (window &optional room-name) (un-hide-window window) (let ((name (or room-name (select-room :reason "Move this placement to" :allow-new? t :name-only? t)))) (when name (interactive-move-or-copy-placement window name nil))))(defun interactive-copy-placement-to-this-room (window) (interactive-move-or-copy-placement window (room-name *current-room*) t))(defun interactive-move-placement-to-pockets (window) (if *pocket-room-name* (interactive-move-or-copy-placement window *pocket-room-name* nil) (notify-user "There is no pocket room.")))(defun interactive-move-or-copy-placement (window to-room-named copy?) (let ((window (main-window window)) (to-room (or (room-named to-room-named) (progn (notify-user "There is no room named ~S." to-room-named) nil)))) (when to-room (update-placements) (multiple-value-bind (placement from-room) (find-placement window) (cond ((eq from-room to-room) (notify-user "This placement is already in ~S." (room-name from-room)) :noop) (t (move-placement placement from-room to-room copy?) (notify-user "~A this placement from ~S to ~S." (if copy? "Copied" "Moved") (room-name from-room) to-room-named) t))))))(defun interactive-reset nil (when (confirm "Reset Rooms?  (Will lose windows.)") (reset)))(defun select-room (&key allow-new? name-only? (from-rooms (all-rooms t)) (reason "Select Room")) (let ((items (with-collection (dolist (room from-rooms) (collect (il:bquote ((il:\\\, (room-name room)) (quote (il:\\\, room)))) items)) (when allow-new? (collect (quote ("<new room>" :new))))))) (if items (let* ((choice (menu items reason)) (room (if (and allow-new? (eq choice :new)) (interactive-make-room) choice))) (when room (if name-only? (room-name room) room))) (progn (notify-user "No rooms!") nil))))(defun interactive-make-room nil (let ((name (prompt-user "Name:" "Type name of new room (CR to abort)."))) (when name (if (room-named name) (notify-user "A room named ~S already exists.  Aborted." name) (make-room name)))))(defun interactive-copy-room (&optional room) (let ((room (or room (select-room :reason "Copy")))) (when room (let ((name (prompt-user "New Name:" "Copying room ~S." (room-name room)))) (when name (if (room-named name) (notify-user "A room named ~S already exists." name) (progn (copy-room room name) (notify-user "Copied room ~S to ~S." (room-name room) name))))))))(defun interactive-rename-room (&optional room) (let ((room (or room (select-room :reason "Rename")))) (when room (let ((name (prompt-user "New Name:" "Renaming room ~S." (room-name room)))) (when name (if (room-named name) (notify-user "A room named ~S already exists." name) (progn (rename-room room name) (notify-user "Renamed room ~S to be ~S." (room-name room) name))))))))(defun interactive-make-door (&key allow-new?) (let ((name (select-room :name-only? t :allow-new? allow-new?))) (when name (let ((button-type (select-button-type))) (when button-type (make-door :room-name name :button-type button-type))))))(defun make-door (&key room-name (button-type *default-button-type*) position) (make-button-window (make-button :text room-name :action (il:bquote (interactive-go-to-room-named (il:\\\, (if (constantp room-name) room-name (list (quote quote) room-name))))) :help (format nil "Go to room named ~S" room-name) :type button-type) position))(defun retrieve-windows nil (il:* il:|;;;| "un-hide all lost windows, telling the user what you've done.") (let ((lost-windows (lost-windows))) (if lost-windows (progn (dolist (window lost-windows) (un-hide-window window)) (notify-user "~S window(s) retrieved." (length lost-windows))) (notify-user "All windows are in some room."))))(defun check-lost-windows nil (let ((lost-windows (lost-windows))) (when lost-windows (notify-user "~D lost window(s).  Try \"Retrieve Windows\"." (length lost-windows)))))(defun eval-walk (expression) (il:* il:|;;| "an inverted evaluator:  expressions are implicitly quoted unless wrapped in :EVAL.  Only conses when it must, i.e. structure w/o EVALs in it will be shared.") (if (consp expression) (if (and (consp (first expression)) (eq (first (first expression)) :eval)) (cons (eval (second (first expression))) (eval-walk (rest expression))) (let* ((old-first (first expression)) (old-rest (rest expression)) (new-first (eval-walk old-first)) (new-rest (eval-walk old-rest))) (if (and (eq old-first new-first) (eq old-rest new-rest)) expression (cons new-first new-rest)))) expression))(il:* il:|;;| "back doors")(defglobalvar *back-door-room-name* nil)(defun make-back-door (&key position button-type) (make-button-window (make-button :text-form (quote (symbol-value (quote *back-door-room-name*))) :action (quote (interactive-go-to-room-named *back-door-room-name*)) :type (or button-type :door) :help "Go to the previous room." :inverted? t) position))(defun back-door-entry-function (entering-room) (il:* il:|;;;| "called whenever we enter a room") (il:* il:|;;;| "maintains the value of *BACK-DOOR-ROOM-NAME* to be the name of the last named room we were in before the current room.") (let* ((leaving-room *current-room*) (leaving-name (room-name leaving-room)) (entering-name (room-name entering-room))) (unless *back-door-room-name* (il:* il:|;;| "bootstrapping  ") (setq *back-door-room-name* leaving-name)) (when (not (equal entering-name leaving-name)) (il:* il:|;;| "ignore screen refreshes") (if (room-named leaving-name) (if (room-named entering-name) (il:* il:|;;| "simple case - going between named rooms") (setq *back-door-room-name* leaving-name) (progn (il:* il:|;;| "when entering an un-named room from a named room we save the current back door on the room we're entering & update the global back door ") (room-prop entering-room :back-door *back-door-room-name*) (setq *back-door-room-name* leaving-name))) (if (room-named entering-name) (il:* il:|;;| "entering a named room from an unnamed one") (when (equal *back-door-room-name* entering-name) (il:* il:|;;| "if popping back to room we came from then restore back door we saved upon entering. global will be correct, making passage through un-named rooms transparent.") (setq *back-door-room-name* (room-prop leaving-room :back-door))) (il:* il:|;;| "going between un-named rooms we just pass along the saved back door, & don't update the global") (room-prop entering-room :back-door (room-prop leaving-room :back-door)))))))(pushnew (quote back-door-entry-function) *room-entry-functions*)(il:declare\: il:doeval@compile il:dontcopy(il:globalvars il:promptwindow il:crosshairs))(il:putprops il:rooms-interactive il:copyright ("Xerox Corporation" 1987 1988))(il:declare\: il:dontcopy  (il:filemap (nil)))il:stop