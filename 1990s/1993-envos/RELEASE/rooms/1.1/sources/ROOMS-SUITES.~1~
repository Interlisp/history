(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "ROOMS")(il:filecreated "18-Aug-88 15:20:10" il:|{POGO:AISNORTH:XEROX}<ROOMS>NEXT>SOURCES>ROOMS-SUITES.;5| 16647        il:|changes| il:|to:|  (il:functions install-suite)      il:|previous| il:|date:| "19-Jul-88 16:44:31" il:|{POGO:AISNORTH:XEROX}<ROOMS>NEXT>SOURCES>ROOMS-SUITES.;4|); Copyright (c) 1987, 1988 by Xerox Corporation.  All rights reserved.(il:prettycomprint il:rooms-suitescoms)(il:rpaqq il:rooms-suitescoms ((file-environments il:rooms-suites) (il:p (export (quote (*suite-file-type* *suite-directories* defsuite))) (require "ROOMS")) (il:define-types il:suites) (il:variables *defsuite-version* *suites* *suite-directories* *suite-file-type*) (il:p (pushnew (quote (clrhash *suites*)) *reset-forms* :test (quote equal))) (il:* il:|;;| "loading suites") (il:functions defsuite make-suite suite-rooms install-suite install-suite-body install-room install-placement) (il:sedit-formats defsuite) (il:* il:|;;| "deleting suites") (il:functions delete-suite) (il:* il:|;;| "constructing suites") (il:functions dump-suite update-suite construct-defsuite all-windows-in-rooms construct-windows construct-files construct-placements) (il:functions rooms-not-in-any-suite find-suite-containing augment-suite delete-room-from-suite) (il:* il:|;;| "interactive code") (il:variables *suite-menu-items* *suite-menu*) (il:functions suite-menu interactive-load-suite interactive-dump-suite interactive-make-suite interactive-update-suite interactive-delete-suite interactive-show-suite interactive-augment-suite interactive-delete-room-from-suite select-suite prompt-for-suite-name)))(define-file-environment il:rooms-suites :compiler :compile-file :package "ROOMS" :readtable "XCL")(export (quote (*suite-file-type* *suite-directories* defsuite)))(require "ROOMS")(def-define-type il:suites "Room Suites")(defconstant *defsuite-version* 1)(defglobalvar *suites* (make-hash-table :test (quote equal)))(defparameter *suite-directories* (il:* il:|;;| "initially just the connected directory") (list t))(defvar *suite-file-type* "SUITE")(pushnew (quote (clrhash *suites*)) *reset-forms* :test (quote equal))(il:* il:|;;| "loading suites")(defdefiner (defsuite (:undefiner (lambda (name) (remhash name *suites*)))) il:suites (name &body body) (il:bquote (install-suite (quote (il:\\\, name)) (quote (il:\\\, body)))))(defun make-suite (suite-name room-names) (when (suite-rooms suite-name) (cerror "Delete all rooms in existing suite named ~S" "Attempt to redefine suite ~S" suite-name) (delete-suite suite-name t)) (setf (suite-rooms suite-name) room-names) suite-name)(defmacro suite-rooms (suite-name) (il:bquote (gethash (il:\\\, suite-name) *suites*)))(defun install-suite (suite-name suite-body) (il:* il:|;;;| "do the work of DEFSUITE.") (il:* il:|;;| "first check for suite redefinition.  MAKE-SUITE will do this for us, but by checking first we assure things will be left consistent should the user abort.") (when (suite-rooms suite-name) (cerror "Delete all rooms in existing suite named ~S" "Attempt to redefine suite ~S" suite-name) (delete-suite suite-name t)) (let ((room-names (with-collection (dolist (spec suite-body) (case (first spec) (:room (collect (second spec)))))))) (dolist (room-name room-names) (il:* il:|;;| "check for room redefinitions.  MAKE-ROOM will do this again, but checking here leaves us in a much more consitstent state should the user choose to abort rather than continue.  ") (when (room-named room-name) (cerror "Delete existing room named ~S (will close windows)" "A room named ~S already exists" room-name) (delete-room (room-named room-name)))) (il:* il:|;;| "make the rooms") (install-suite-body suite-body) (il:* il:|;;| "remember what rooms were in this suite") (make-suite suite-name room-names) (check-lost-windows)))(defun install-suite-body (suite-body) (il:with.monitor *monitor-lock* (let ((windows (make-hash-table)) (version nil)) (il:* il:|;;| "first load files & parse version") (dolist (spec suite-body) (ecase (first spec) (:files (il:dofilesload (rest spec))) ((:window :room)) (:version (setq version (second spec)) (when (> version *defsuite-version*) (error "DEFSUITE version ~S too high." version))))) (unless version (warn "No version found in DEFSUITE.  Presuming current.") (setq version *defsuite-version*)) (il:* il:|;;| "now make all the windows") (update-placements) (dolist (spec suite-body) (case (first spec) (:window (let ((window (reconstitute-window (fourth spec) (nthcdr 4 spec)))) (when (il:windowp window) (setf (gethash (second spec) windows) window) (unless (find-placement window) (hide-window window))))))) (il:* il:|;;| "finally make the rooms") (dolist (spec suite-body) (case (first spec) (:room (apply (function install-room) windows (rest spec))))))))(defun install-room (windows name &rest rest-keys &key placements &allow-other-keys) (apply (quote make-room) name :placements (with-collection (dolist (placement-spec placements) (let ((placement (apply (function install-placement) windows placement-spec))) (when placement (collect placement))))) (let ((rest (copy-list rest-keys))) (remf rest :placements) rest)))(defun install-placement (windows name &rest rest-keys &key region shrunken? icon-position &allow-other-keys) (let ((window (gethash name windows))) (when window (make-placement-internal :window window :region (internalize-region region) :shrunken? shrunken? :icon-position (when icon-position (internalize-position icon-position)) :props (let ((props (copy-list rest-keys))) (dolist (keyword (quote (:region :shrunken? :icon-position))) (remf props keyword)) props)))))(sedit:def-list-format defsuite :args (nil :keyword nil) :indent (1))(il:* il:|;;| "deleting suites")(defun delete-suite (suite-name &optional rooms-too?) (il:* il:|;;| "delete all the rooms in the suite") (when rooms-too? (dolist (room-name (suite-rooms suite-name)) (let ((room (room-named room-name))) (when room (delete-room room))))) (il:* il:|;;| "delete the suite") (remhash suite-name *suites*))(il:* il:|;;| "constructing suites")(defun dump-suite (suite-name &optional quiet?) (update-suite suite-name) (il:* il:|;;| "dump it to a file") (let ((file (or (first (il:whereis suite-name (quote il:suites))) (intern (namestring (make-pathname :name (string-upcase suite-name) :type *suite-file-type* :host nil :device nil :directory nil)) "IL"))) full-name) (unless (and (il:hasdef file (quote il:files)) (il:infilecoms? suite-name (quote il:suites) (il:filecoms file))) (il:putdef file (quote file-environments) (il:bquote (define-file-environment (il:\\\, file) :package (defpackage "ROOMS" (:use "LISP" "XCL") (:shadow cl:room)) :readtable "XCL" :compiler :compile-file))) (il:putdef file (quote il:files) (il:bquote (((il:files il:rooms) (file-environments (il:\\\, file)) (il:suites (il:\\\, suite-name))))))) (unless quiet? (notify-user "Making file ~A ..." file)) (il:allow.button.events) (setq full-name (pathname (il:makefile file (quote (il:fast il:new))))) (unless quiet? (notify-user "Made file ~A" (namestring full-name))) (setq il:notcompiledfiles (remove file il:notcompiledfiles)) (setq il:notlistedfiles (remove file il:notlistedfiles)) full-name))(defun update-suite (suite-name) (let ((il:dfnflg (quote il:prop))) (il:putdef suite-name (quote il:suites) (construct-defsuite suite-name (suite-rooms suite-name)))))(defun construct-defsuite (suite-name room-names) (let* ((rooms (with-collection (dolist (name room-names) (let ((room (room-named name))) (if room (collect room) (warn "No room named ~S exists." name)))))) (window-names (make-hash-table)) (window-abstractions (construct-windows (all-windows-in-rooms rooms) window-names))) (il:bquote (defsuite (il:\\\, suite-name) (:version (il:\\\, *defsuite-version*)) (:files (il:\\\,@ (construct-files window-names))) (il:\\\,@ window-abstractions) (il:\\\,@ (mapcar (function (lambda (room) (il:bquote (:room (il:\\\, (room-name room)) :placements (il:\\\, (construct-placements room window-names)) :inclusions (il:\\\, (room-inclusions room)) :background (il:\\\, (background-external-form (room-background room))) (il:\\\,@ (room-props room)))))) rooms))))))(defun all-windows-in-rooms (rooms) (il:* il:|;;;| "return a list containing all the windows in ROOMS") (update-placements) (let (windows) (dolist (room rooms) (dolist (placement (room-placements room)) (pushnew (placement-window placement) windows :test (quote eq)))) (nreverse windows)))(defun construct-windows (windows window-names) (il:* il:|;;;| "construct the list of window abstractions for WINDOWS.  store a name for each window in WINDOW-NAMES. ") (with-collection (let ((window-number 0)) (dolist (window windows) (let ((abstraction (abstract-window window))) (when abstraction (collect (il:bquote (:window (il:\\\, window-number) (il:\\\,@ abstraction)))) (setf (gethash window window-names) window-number) (incf window-number)))))))(defun construct-files (window-names) (il:* il:|;;;| "returns the appended list of all the :FILES properties of all the window types of all the windows in WINDOW-NAMES. ") (let ((all-files nil)) (maphash (function (lambda (window name) (dolist (file (window-type-prop (window-type window) :files)) (pushnew file all-files)))) window-names) (reverse all-files)))(defun construct-placements (room window-names) (il:* il:|;;| "construct a list of external representations for the placements in ROOM, using the hash table WINDOW-NAMES to name windows.  these external representations are installed by INSTALL-PLACEMENT") (with-collection (dolist (placement (room-placements room)) (let ((window-name (gethash (placement-window placement) window-names))) (when window-name (il:* il:|;;| "unnamed windows are ones that could not be abstracted -- we ignore them here. ") (collect (il:bquote ((il:\\\, window-name) :region (il:\\\, (externalize-region (placement-region placement))) (il:\\\,@ (when (placement-icon-position placement) (list :shrunken? (placement-shrunken? placement) :icon-position (externalize-position (placement-icon-position placement))))) (il:\\\,@ (placement-props placement))))))))))(defun rooms-not-in-any-suite (&optional for-deletion?) (il:* il:|;;;| "returns a list of all the rooms which are not in any suite") (with-collection (dolist (room (all-rooms t)) (let ((name (room-name room))) (unless (or (unless for-deletion? (il:* il:|;;| "Original & Pockets implicitly belong to the bootstrap suite & we don't want them added to others.") (or (equal name "Pockets") (equal name "Original"))) (find-suite-containing name)) (collect room))))))(defun find-suite-containing (room-name) (maphash (function (lambda (suite-name room-names) (when (member room-name room-names :test (quote equal)) (return-from find-suite-containing suite-name)))) *suites*))(defun augment-suite (suite-name room-name) (pushnew room-name (suite-rooms suite-name) :test (quote equal)))(defun delete-room-from-suite (room-name suite-name) (setf (suite-rooms suite-name) (delete room-name (suite-rooms suite-name) :test (quote equal))))(il:* il:|;;| "interactive code")(defglobalparameter *suite-menu-items* (quote (("Save Suite" (quote (with-button (quote (interactive-dump-suite)) "Save Suite" "Save a set of rooms to a file")) "Save a set of rooms to a file" (il:subitems ("Update Suite" (quote (with-button (quote (interactive-update-suite)) "Update Suite" "Update the DEFSUITE form of a suite")) "Update the DEFSUITE form of a suite"))) ("Restore Suite" (quote (with-button (quote (interactive-load-suite)) "Restore Suite" "Load a set of rooms from a file")) "Load a set of rooms from a file") ("Show Suite" (quote (with-button (quote (interactive-show-suite)) "Show Suite" "List the rooms in a suite")) "List the rooms in a suite") ("Augment Suite" (quote (with-button (quote (interactive-augment-suite)) "Augment Suite" "Add a room to a suite")) "Add a room to a suite") ("Delete Suite" (quote (with-button (quote (interactive-delete-suite)) "Delete Suite" "Delete a suite, and optionally all the rooms in it.")) "Delete a suite, and optionally all the rooms in it." (il:subitems ("Delete Room From Suite" (quote (with-button (quote (interactive-delete-room-from-suite)) "Delete Room From Suite"))))))))(defglobalvar *suite-menu* nil)(defun suite-menu nil (or *suite-menu* (setq *suite-menu* (il:create il:menu il:items il:_ *suite-menu-items* il:title il:_ "Suites" il:centerflg il:_ t))) (let* ((item (il:menu *suite-menu*))) (when item (il:* il:\; "to be 100% compatible w/ background menu") (il:eval item))))(defun interactive-load-suite nil (let ((suite-name (prompt-for-suite-name))) (when suite-name (if (suite-rooms suite-name) (notify-user "A suite named ~S already exists." suite-name) (let ((found (il:findfile (namestring (merge-pathnames suite-name (make-pathname :type *suite-file-type* (il:* il:|;;| "override default defaults") :host nil :device nil :directory nil :version nil) nil)) t *suite-directories*))) (if found (il:add.process (il:bquote (funcall (quote (il:\\\, (function (lambda nil (let ((load-completed? (quote nil))) (unwind-protect (progn (load found) (setq load-completed? t)) (let ((window (il:wfromds nil t))) (when window (il:closew window))) (when load-completed? (notify-user "Restored suite ~S." suite-name)))))))))) (quote il:name) "Restore Suite") (notify-user "Can't find suite ~S on *SUITE-DIRECTORIES*" suite-name)))))))(defun interactive-dump-suite nil (let ((suite-name (select-suite :reason "Save" :allow-new? t))) (when suite-name (with-button (il:bquote (il:resetform (il:ttydisplaystream (get-message-stream)) (dump-suite (quote (il:\\\, suite-name))))) (format nil "Save ~A" suite-name) (format nil "Save suite named ~S." suite-name)))))(defun interactive-make-suite nil (let ((rooms (rooms-not-in-any-suite))) (if (null rooms) (notify-user "All rooms are already in some suite.") (let ((suite-name (prompt-for-suite-name))) (when suite-name (if (suite-rooms suite-name) (notify-user "A suite named ~S already exists" suite-name) (let ((room-names (with-collection (notify-user "Select rooms to go in ~S.~%Click outside menu when finished." suite-name) (loop (when (null rooms) (return)) (let ((room (select-room :from-rooms rooms))) (cond (room (setq rooms (delete room rooms :test (quote eq))) (collect (room-name room))) (t (return)))))))) (when room-names (make-suite suite-name room-names)))))))))(defun interactive-update-suite nil (let ((suite-name (select-suite :reason "Update" :allow-new? t))) (when suite-name (with-button (il:bquote (il:resetform (il:ttydisplaystream (get-message-stream)) (update-suite (quote (il:\\\, suite-name))))) (format nil "Update ~A" suite-name) (format nil "Update suite named ~S." suite-name)))))(defun interactive-delete-suite nil (let ((suite-name (select-suite :reason "Delete"))) (when (and suite-name (confirm "Delete suite ~S?" suite-name)) (delete-suite suite-name (confirm "Delete all rooms in ~S too? (will close windows)" suite-name)) (notify-user "Suite ~S deleted." suite-name))))(defun interactive-show-suite nil (let ((suite-name (select-suite :reason "Show"))) (when suite-name (notify-user "Suite ~S contains rooms:~{ ~S~}." suite-name (suite-rooms suite-name)))))(defun interactive-augment-suite nil (let ((rooms (rooms-not-in-any-suite))) (if (null rooms) (notify-user "All rooms are already in some suite.") (let ((suite-name (select-suite :reason "Augment Suite"))) (when suite-name (notify-user "Select room to add to suite ~S" suite-name) (let ((room-name (select-room :from-rooms rooms :name-only? t))) (when room-name (augment-suite suite-name room-name))))))))(defun interactive-delete-room-from-suite nil (let ((suite-name (select-suite :reason "Delete room from"))) (when suite-name (let ((room-name (menu (suite-rooms suite-name) "Select Room"))) (when room-name (delete-room-from-suite room-name suite-name) (notify-user "Deleted room ~S from suite ~S." room-name suite-name))))))(defun select-suite (&key reason allow-new?) (let ((items (when allow-new? (quote (("<new suite>" :new)))))) (maphash (function (lambda (suite-name suite-body) (push suite-name items))) *suites*) (if items (let ((suite-name (menu items reason))) (if (and allow-new? (eq suite-name :new)) (interactive-make-suite) suite-name)) (progn (notify-user "No suites!") nil))))(defun prompt-for-suite-name (&optional (prompt "Suite Name:")) (let ((string (prompt-user prompt))) (when string (string-upcase string))))(il:putprops il:rooms-suites il:copyright ("Xerox Corporation" 1987 1988))(il:declare\: il:dontcopy  (il:filemap (nil)))il:stop