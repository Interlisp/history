(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE (LET ((*PACKAGE* *PACKAGE*)) (CLIN-PACKAGE (DEFPACKAGE 
"TEXTMODULES" (USE "LISP" "XCL") (PREFIX-NAME "TM"))) (FILESLOAD EVAL-WHEN-PATCH) *PACKAGE*) BASE 
10)
(IL:FILECREATED " 1-Oct-91 15:15:47" ("compiled on " 
IL:|{PELE:MV:ENVOS}<LISPUSERS>MEDLEY>TEXTMODULES.;1|) "27-Aug-91 19:40:51" IL:|bcompl'd| IL:|in| 
"Medley 28-Aug-91 ..." IL:|dated| "28-Aug-91 09:16:07")
(IL:FILECREATED "24-Sep-87 18:50:13" IL:{DSK}<LISPFILES>WORK>TEXTMODULES.\;14 28587 IL:|changes| 
IL:|to:| (IL:FUNCTIONS READ-HASH-BAR-COMMENT READ-PREFIX-QUOTE TRANSLATE-HASH-COMMA TRANSLATE-HASH-DOT
 READ-READ-TIME-CONDITIONAL TRANSLATE-READ-TIME-CONDITIONAL PRINT-READ-TIME-CONDITIONAL 
MAKE-LISP-FILE-READTABLE MAKE-LISP-CONDITIONAL-READTABLE READ-DISABLED-HASH 
UNTRANSLATABLE-PRESENTATION PRINT-DISABLED-HASH DEFPRESENTATION TRANSLATE-PREFIX-QUOTE TRANSLATE-FORM 
PRINT-PREFIX-QUOTE) (IL:VARS IL:TEXTMODULESCOMS) (IL:STRUCTURES READ-TIME-CONDITIONAL) (IL:VARIABLES 
SPECIFIER-TYPES *DELETE-FORM* COMMENT-LEVEL-MARKERS) (IL:PRESENTATIONS DISABLED-HASH HASH-R HASH-MINUS
 HASH-PLUS HASH-COMMA HASH-DOT) IL:|previous| IL:|date:| "11-Sep-87 16:38:00" 
IL:{DSK}<LISPFILES>WORK>TEXTMODULES.\;1)
(IL:PRETTYCOMPRINT IL:TEXTMODULESCOMS)
(IL:RPAQQ IL:TEXTMODULESCOMS ((IL:* IL:|;;;| 
"TEXTMODULES, a text file to file manager conversion utility.") (IL:* IL:|;;| 
"Semicolon comments are special cased in this code, because rewriting the SEdit support for that presentation would be hard."
) (IL:FUNCTIONS ADD-FORM AFTER-PRINT-FUNCTIONS AFTER-READ-FUNCTIONS BEFORE-MAKE-TEXTMODULE-FUNCTIONS 
DEFPRESENTATION FORM-SPECIFIER-TYPE INSTALL-FORM INSTALL-READ-MACRO LOAD-TEXTMODULE 
MAKE-LISP-FILE-READTABLE MAKE-TEXTMODULE NAME-OF PARSE-ENVIRONMENT-SETUP-SPECIFIERS PRINT-AND-EVAL 
PRINT-COMMENT-LINE PRINT-ENVIRONMENT-FORMS PRINT-FORM PRINT-PREFIX-QUOTE PRINT-READ-TIME-CONDITIONAL 
PRINT-SEMICOLON-COMMENT READ-HASH-BAR-COMMENT READ-PREFIX-QUOTE READ-READ-TIME-CONDITIONAL 
READ-SEMICOLON-COMMENT REMOVE-PRESENTATION SEMICOLON-COMMENT-P SPECIFIER-OF SPECIFIER-TYPE 
TOP-LEVEL-FORM-FORM TOP-LEVEL-FORM-P TRANSLATE-FORM TRANSLATE-HASH-COMMA TRANSLATE-HASH-DOT 
TRANSLATE-PREFIX-QUOTE TRANSLATE-READ-TIME-CONDITIONAL) (IL:STRUCTURES PRESENTATION PREFIX-QUOTE 
PRESENTATION-OPS READ-TIME-CONDITIONAL SEMICOLON-COMMENT SPECIFIER-TYPE UNKNOWN-FORM UNKNOWN-SPECIFIER
) (IL:VARIABLES *DELETE-FORM* COMMENT-LEVEL-MARKERS EOF-MARKER SPECIFIER-TYPES) (IL:P (
MAKE-LISP-FILE-READTABLE)) (IL:DEFINE-TYPES IL:PRESENTATIONS) (IL:PRESENTATIONS HASH-B HASH-COMMA 
HASH-DOT HASH-MINUS HASH-O HASH-PLUS HASH-X) (IL:ADVISE REMOVE-COMMENTS (IL:EVAL :IN 
IL:\\DO-DEFINE-FILE-INFO)) (IL:PROP (IL:FILETYPE IL:MAKEFILE-ENVIRONMENT) IL:TEXTMODULES)))
(DEFUN ADD-FORM (FORM CONTENTS &OPTIONAL (TYPE (FORM-SPECIFIER-TYPE FORM))) 
"Call appropriate functions to make definition editable, return new contents." (FUNCALL (
SPECIFIER-TYPE-ADD TYPE) FORM CONTENTS))
(DEFUN AFTER-PRINT-FUNCTIONS (FORM) (IF (EQ (QUOTE IN-PACKAGE) (FIRST FORM)) (EVAL FORM)) FORM)
(DEFUN AFTER-READ-FUNCTIONS (FORM) 
"Performs any processing on the form needed after it has been read." (IL:* IL:|;;| 
"Eventually this will be used to smash together adjacent same level comments.") FORM)
(DEFUN BEFORE-MAKE-TEXTMODULE-FUNCTIONS (MODULE STREAM) 
"Things to do before the main body of the textmodule is printed." (PRINT-COMMENT-LINE (GET MODULE (
QUOTE IL:MAKEFILE-ENVIRONMENT)) STREAM) (PRINT-ENVIRONMENT-FORMS (GET MODULE (QUOTE 
IL:MAKEFILE-ENVIRONMENT)) STREAM) (TERPRI STREAM))
(DEFDEFINER DEFPRESENTATION IL:PRESENTATIONS (NAME &KEY FIELDS INCLUDE PRINT-FUNCTION (READ-MACRO NIL)
 (TRANSLATOR (FUNCTION UNTRANSLATABLE-PRESENTATION))) "Define a presentation type." (IL:BQUOTE (PROGN 
(DEFSTRUCT ((IL:\\\, NAME) (:INCLUDE (IL:\\\,@ (IF (NULL INCLUDE) (LIST (QUOTE PRESENTATION)) (
ETYPECASE INCLUDE (SYMBOL (LIST INCLUDE)) (LIST INCLUDE)))) (OPS (MAKE-PRESENTATION-OPS :READ-MACRO (
QUOTE (IL:\\\, READ-MACRO)) :TRANSLATOR (QUOTE (IL:\\\, TRANSLATOR))))) (:PRINT-FUNCTION (IL:\\\, 
PRINT-FUNCTION))) (IL:\\\,@ FIELDS)) (IL:\\\,@ (UNLESS (NULL READ-MACRO) (LIST (IL:BQUOTE (
INSTALL-READ-MACRO (QUOTE (IL:\\\, READ-MACRO)) (IL:FIND-READTABLE "LISP-FILE")))))) (QUOTE (IL:\\\, 
NAME)))))
(DEFUN FORM-SPECIFIER-TYPE (FORM) 
"If the form has a specifier return the specifier's defining structure." (OR (SOME (FUNCTION (LAMBDA (
TYPE) (AND (FUNCALL (SPECIFIER-TYPE-IDENTIFIER TYPE) FORM) TYPE))) SPECIFIER-TYPES) (IL:NILL (WARN (
QUOTE UNKNOWN-FORM) :FORM FORM))))
(DEFUN INSTALL-FORM (FORM &OPTIONAL (TYPE (FORM-SPECIFIER-TYPE FORM))) 
"Install a definition as current and executable." (WHEN (NOT (MEMBER IL:DFNFLG (QUOTE (IL:PROP 
IL:ALLPROP)))) (FUNCALL (SPECIFIER-TYPE-INSTALLER TYPE) FORM)))
(DEFUN INSTALL-READ-MACRO (READ-MACRO TABLE) (COND ((AND (CHARACTERP (FIRST READ-MACRO)) (CHARACTERP (
SECOND READ-MACRO))) (MAKE-DISPATCH-MACRO-CHARACTER (FIRST READ-MACRO) T TABLE) (
SET-DISPATCH-MACRO-CHARACTER (FIRST READ-MACRO) (SECOND READ-MACRO) (THIRD READ-MACRO) TABLE)) ((
CHARACTERP (FIRST READ-MACRO)) (SET-MACRO-CHARACTER (FIRST READ-MACRO) (SECOND READ-MACRO) T TABLE)) (
T (ERROR "Bad read macro spec ~s" READ-MACRO))))
(DEFUN LOAD-TEXTMODULE (PATHNAME &KEY (MODULE (PATHNAME-NAME PATHNAME)) (IL:* IL:\; 
"Name of module which has these contents.") (INSTALL T) (IL:* IL:\; "Install definitions as current?")
 (PACKAGE (FIND-PACKAGE "USER")) (IL:* IL:\; "Package to read file in.")) 
"Load a text file, creating a content description." (SETQ PATHNAME (MERGE-PATHNAMES PATHNAME ".LISP"))
 (LET ((IL:DFNFLG (IF (NULL INSTALL) (QUOTE IL:PROP) INSTALL)) (*PACKAGE* (IF (PACKAGEP PACKAGE) 
PACKAGE (FIND-PACKAGE PACKAGE))) (*READTABLE* (IL:FIND-READTABLE "LISP-FILE")) (CONTENTS NIL)) (
WITH-OPEN-FILE (STREAM PATHNAME :DIRECTION :INPUT) (LET (FORM) (LOOP (SETQ FORM (READ STREAM NIL 
EOF-MARKER)) (WHEN (EQ FORM EOF-MARKER) (RETURN NIL)) (SETQ FORM (AFTER-READ-FUNCTIONS FORM)) (LET ((
TYPE (FORM-SPECIFIER-TYPE FORM))) (SETQ CONTENTS (ADD-FORM FORM CONTENTS TYPE)) (INSTALL-FORM FORM 
TYPE))))) (MULTIPLE-VALUE-BIND (CONTENTS ENVIRONMENT) (PARSE-ENVIRONMENT-SETUP-SPECIFIERS CONTENTS) (
LET* ((NAME (INTERN MODULE "INTERLISP")) (FILEVAR (IL:FILECOMS NAME))) (SETF (SYMBOL-VALUE FILEVAR) 
CONTENTS) (IL:ADDFILE NAME) (SETF (GET NAME (QUOTE IL:FILETYPE)) :COMPILE-FILE) (IL:ADDTOFILE (IL:BQUOTE
 ((IL:\\\, NAME) IL:FILETYPE)) (QUOTE IL:PROPS) NAME) (SETF (GET NAME (QUOTE IL:MAKEFILE-ENVIRONMENT))
 ENVIRONMENT) (IL:ADDTOFILE (IL:BQUOTE ((IL:\\\, NAME) IL:MAKEFILE-ENVIRONMENT)) (QUOTE IL:PROPS) NAME
)))) MODULE)
(DEFUN MAKE-LISP-FILE-READTABLE NIL "Build and name the LISP-FILE readtable." (LET ((TABLE (OR (
IL:FIND-READTABLE "LISP-FILE") (COPY-READTABLE (IL:FIND-READTABLE "LISP"))))) (INSTALL-READ-MACRO (
QUOTE (#\; READ-SEMICOLON-COMMENT)) TABLE) (INSTALL-READ-MACRO (QUOTE (#\# #\| READ-HASH-BAR-COMMENT))
 TABLE) (IL:READTABLEPROP TABLE (QUOTE IL:NAME) "LISP-FILE") TABLE))
(DEFUN MAKE-TEXTMODULE (MODULE &KEY (TYPE ".LISP") (PATHNAME (MERGE-PATHNAMES MODULE (MERGE-PATHNAMES 
TYPE))) (CONTENTS (SYMBOL-VALUE (IL:FILECOMS MODULE))) (WIDTH 80)) 
"Writes out the contents of the named module." (SETQ MODULE (FIND-SYMBOL (SYMBOL-NAME MODULE) 
"INTERLISP")) (LET ((*PACKAGE* (FIND-PACKAGE "USER")) (*READTABLE* (IL:FIND-READTABLE "LISP-FILE")) (
IL:*PRINT-SEMICOLON-COMMENTS* T) (*PRINT-PRETTY* T)) (DECLARE (SPECIAL IL:*PRINT-SEMICOLON-COMMENTS*))
 (WITH-OPEN-FILE (STREAM PATHNAME :DIRECTION :OUTPUT) (IL:LINELENGTH WIDTH STREAM) (IL:* IL:\; 
"For Interlisp prettyprinter.") (BEFORE-MAKE-TEXTMODULE-FUNCTIONS MODULE STREAM) (DOLIST (SPECIFIER 
CONTENTS) (LET ((TYPE (SPECIFIER-TYPE SPECIFIER))) (WHEN TYPE (WRITE (AFTER-PRINT-FUNCTIONS (
PRINT-FORM SPECIFIER TYPE)) :STREAM STREAM)))) MODULE)))
(DEFUN NAME-OF (FORM) (FUNCALL (GET (CAR FORM) (QUOTE IL:DEFINITION-NAME)) (REMOVE-COMMENTS FORM)))
(DEFUN PARSE-ENVIRONMENT-SETUP-SPECIFIERS (CONTENTS) 
"Parse out any environment specifiers, returning the reduced contents list and an environment object."
 (IL:* IL:|;;| 
"If you change anything in here you must change the printer in print-environment-forms.") (WHEN (AND (
SEMICOLON-COMMENT-P (FIRST CONTENTS)) (EQL 0 (SEARCH "-*-" (SEMICOLON-COMMENT-STRING (FIRST CONTENTS))
))) (IL:* IL:\; "Discard EMACS comment line") (POP CONTENTS)) (LET ((PACKAGE-FORM NIL) (IL:* IL:\; 
"Collects the package setup forms.") (BASE 10) (IL:* IL:\; "Default.")) (IL:* IL:|;;| 
"Most of the mechanism below handles comments between the setup forms in the filecoms.  CONTENTS names the last parsed position. NEXT-TOP-LEVEL-FORM slides NEXT-TAIL past the comments to the next top-level form.  WHEN-RECOGNIZED checks the form and if recognized pops the in-between comments onto PACKAGE-FORM."
) (LET ((NEXT-TAIL CONTENTS) (IL:* IL:\; "Contains tail at next top-level form.") FORM (IL:* IL:\; 
"Contains next top level form.")) (BLOCK PARSE-COMPLETE (FLET ((NEXT-TOP-LEVEL-FORM NIL (IL:* IL:|;;| 
"Find tail containing the next top level form.") (LOOP (WHEN (NULL NEXT-TAIL) (RETURN NIL)) (LET ((
HEAD (FIRST NEXT-TAIL))) (COND ((TOP-LEVEL-FORM-P HEAD) (SETQ FORM (TOP-LEVEL-FORM-FORM HEAD)) (RETURN
 NIL)) ((NOT (SEMICOLON-COMMENT-P HEAD) (RETURN-FROM PARSE-COMPLETE NIL))))) (POP NEXT-TAIL))) (
POP-FORMS NIL (IL:* IL:|;;| 
"Comments between CONTENTS and (not including) NEXT-TAIL are popped onto PACKAGE-FORMs.  The form in NEXT-TAIL is discarded and CONTENTS is updated."
) (LOOP (WHEN (EQ CONTENTS NEXT-TAIL) (RETURN NIL)) (PUSH (POP CONTENTS) PACKAGE-FORM)))) (MACROLET ((
WHEN-RECOGNIZED (TEST &BODY FORMS) (IL:* IL:|;;| 
"Find the next top level form.  Use TEST to recognize whether its an environment setup form.  Then execute the body and discard the processed form."
) (IL:BQUOTE (PROGN (NEXT-TOP-LEVEL-FORM) (WHEN (IL:\\\, TEST) (POP-FORMS) (IL:\\\,@ FORMS) (POP 
NEXT-TAIL) (SETQ CONTENTS NEXT-TAIL)))))) (IL:* IL:|;;| "package setup forms") (WHEN-RECOGNIZED (EQ (
FIRST FORM) (QUOTE PROVIDE)) (PUSH FORM PACKAGE-FORM)) (WHEN-RECOGNIZED (EQ (FIRST FORM) (QUOTE 
IN-PACKAGE)) (PUSH FORM PACKAGE-FORM)) (WHEN-RECOGNIZED (EQ (FIRST FORM) (QUOTE SHADOW)) (PUSH FORM 
PACKAGE-FORM)) (WHEN-RECOGNIZED (EQ (FIRST FORM) (QUOTE EXPORT)) (PUSH FORM PACKAGE-FORM)) (
WHEN-RECOGNIZED (MEMBER (FIRST FORM) (QUOTE (REQUIRE IL:FILESLOAD)) :TEST (FUNCTION EQ)) (PUSH FORM 
PACKAGE-FORM)) (WHEN-RECOGNIZED (EQ (FIRST FORM) (QUOTE USE-PACKAGE)) (PUSH FORM PACKAGE-FORM)) (
WHEN-RECOGNIZED (EQ (FIRST FORM) (QUOTE IMPORT)) (PUSH FORM PACKAGE-FORM)) (WHEN-RECOGNIZED (EQ (FIRST
 FORM) (QUOTE SHADOWING-IMPORT)) (PUSH FORM PACKAGE-FORM)) (IL:* IL:|;;| "read-base") (WHEN-RECOGNIZED
 (AND (EQ (FIRST FORM) (QUOTE SETF)) (EQ (SECOND FORM) (QUOTE *READ-BASE*))) (SETQ BASE (THIRD FORM)))
)))) (IL:* IL:|;;| "Return the new contents and a environment.") (VALUES CONTENTS (IL:BQUOTE (
:READTABLE "XCL" :PACKAGE (IL:\\\, (IF PACKAGE-FORM (IL:BQUOTE (LET ((*PACKAGE* *PACKAGE*)) (IL:\\\,@ 
(REVERSE PACKAGE-FORM)) *PACKAGE*)) "USER")) :BASE (IL:\\\, BASE))))))
(DEFMACRO PRINT-AND-EVAL (FORM STREAM) (IL:BQUOTE (LET ((FORM (IL:\\\, FORM))) (WRITE FORM :STREAM (
IL:\\\, STREAM)) (TERPRI (IL:\\\, STREAM)) (EVAL FORM))))
(DEFUN PRINT-COMMENT-LINE (ENVIRONMENT STREAM) 
"Prints a mode line onto the STREAM based on the ENVIRONMENT." (FORMAT STREAM ";;; -*- Mode: LISP") (
DO ((TAIL ENVIRONMENT (CDDR TAIL))) ((NULL TAIL)) (LET ((NAME (FIRST TAIL)) (VALUE (SECOND TAIL))) (
CASE NAME (:READTABLE) (:PACKAGE (COND ((STRINGP VALUE) (FORMAT STREAM "; Package: ~a" VALUE)) ((EQ (
FIRST VALUE) (QUOTE DEFPACKAGE)) (FORMAT STREAM "; Package: (~a (~{~a~}) 1000)" (STRING (SECOND VALUE)
) (OR (MAPCAR (FUNCTION STRING) (CDR (ASSOC :USE (CDDR VALUE)))) (LIST "LISP")))) ((EQ (FIRST VALUE) (
QUOTE LET)) (LET ((FORM (ASSOC (QUOTE IN-PACKAGE) (CDDR VALUE)))) (FORMAT STREAM 
"; Package: (~a (~{~a~}) 1000)" (STRING (SECOND FORM)) (OR (MAPCAR (FUNCTION STRING) (CDR (GETF FORM 
:USE NIL))) (LIST "LISP"))))) (T (ERROR "Unknown package specifier in environment ~s" VALUE)))) (:BASE
 (FORMAT STREAM "; Base: ~a" VALUE))))) (FORMAT STREAM " -*-") (TERPRI STREAM))
(DEFUN PRINT-ENVIRONMENT-FORMS (ENVIRONMENT STREAM) 
"Print the environment initializing forms from ENVIRONMENT onto STREAM." (DO ((TAIL ENVIRONMENT (CDDR 
TAIL))) ((NULL TAIL)) (LET ((NAME (FIRST TAIL)) (VALUE (SECOND TAIL))) (ECASE NAME (:READTABLE) (
:PACKAGE (TYPECASE VALUE (NULL (ERROR "NIL given as package name")) ((OR SYMBOL STRING) (
PRINT-AND-EVAL (IL:BQUOTE (IN-PACKAGE (IL:\\\, VALUE))) STREAM)) (CONS (CASE (FIRST VALUE) (DEFPACKAGE
 (IL:* IL:\; 
"We only cover the portable options to defpackage.  Note that they're converted once but not back.") (
PRINT-AND-EVAL (IL:BQUOTE (IN-PACKAGE (IL:\\\, (STRING (SECOND VALUE))) (IL:\\\,@ (LET ((NICKNAMES (
CDR (ASSOC :NICKNAMES (CDDR VALUE))))) (WHEN NICKNAMES (IL:BQUOTE (:NICKNAMES (IL:\\\, NICKNAMES))))))
)) STREAM) (MAPC (FUNCTION (LAMBDA (OPTION FUNCTION) (LET ((VALUE (CDR (ASSOC :USE (CDDR VALUE))))) (
WHEN VALUE (PRINT-AND-EVAL (IL:BQUOTE ((IL:\\\, FUNCTION) (QUOTE (IL:\\\, VALUE)))) STREAM))))) (QUOTE
 (:SHADOW :EXPORT :USE :IMPORT :SHADOWING-IMPORT)) (QUOTE (SHADOW EXPORT USE-PACKAGE IMPORT 
SHADOWING-IMPORT)))) (LET (IL:* IL:\; "A fancy LET environment!") (MAPCAR (FUNCTION (LAMBDA (FORM) (
PRINT-AND-EVAL FORM STREAM))) (BUTLAST (CDDR VALUE)) (IL:* IL:\; 
"Avoid the LET, its bindings and the returned *package*."))))) (T (ERROR 
"Unknown package specifier in environment ~s" VALUE)))) (:BASE (PRINT-AND-EVAL (IL:BQUOTE (SETF 
*READ-BASE* (IL:\\\, VALUE))) STREAM))))))
(DEFUN PRINT-FORM (SPECIFIER &OPTIONAL (TYPE (SPECIFIER-TYPE SPECIFIER))) 
"Get the print form of a specifier." (FUNCALL (SPECIFIER-TYPE-PRINT-FORM TYPE) SPECIFIER))
(DEFUN PRINT-PREFIX-QUOTE (OBJECT STREAM DEPTH) (IF (EQ *PRINT-CASE* :DOWNCASE) (PRINC (
PREFIX-QUOTE-PREFIX OBJECT) STREAM) (PRINC (STRING-UPCASE (PREFIX-QUOTE-PREFIX OBJECT)) STREAM)) (
PRINC (PREFIX-QUOTE-CONTENTS OBJECT) STREAM))
(DEFUN PRINT-READ-TIME-CONDITIONAL (OBJECT STREAM DEPTH) (PRINC #\# STREAM) (ETYPECASE OBJECT (
HASH-PLUS (PRINC #\+ STREAM)) (HASH-MINUS (PRINC #\- STREAM))) (LET ((*PACKAGE* IL:*KEYWORD-PACKAGE*))
 (PRIN1 (READ-TIME-CONDITIONAL-FEATURE OBJECT) STREAM)) (IF (READ-TIME-CONDITIONAL-UNREAD-P OBJECT) (
PRINC (READ-TIME-CONDITIONAL-FORM OBJECT) STREAM) (PRIN1 (READ-TIME-CONDITIONAL-FORM OBJECT) STREAM)))
(DEFUN PRINT-SEMICOLON-COMMENT (FORM STREAM) 
"Print a semicolon comment.  Depends on IL:*PRINT-SEMICOLON-COMMENTS* being true." (WRITE FORM :STREAM
 STREAM))
(DEFUN READ-HASH-BAR-COMMENT (STREAM SUB-CHAR INTEGER) 
"Read the characters of a hash bar comment, creating a comment object." (WHEN INTEGER (WARN 
"Spurious integer argument to hash macro ignored.")) (LET ((COMMENT-BUFFER (MAKE-ARRAY 1024 
:ELEMENT-TYPE (QUOTE CHARACTER) :FILL-POINTER 0 :ADJUSTABLE T))) (LOOP (SETQ SUB-CHAR (READ-CHAR 
STREAM NIL EOF-MARKER)) (WHEN (EQ SUB-CHAR EOF-MARKER) (RETURN (MAKE-SEMICOLON-COMMENT :MARKER (QUOTE 
IL:\|) :STRING COMMENT-BUFFER))) (WHEN (EQL SUB-CHAR #\|) (SETQ SUB-CHAR (READ-CHAR STREAM NIL 
EOF-MARKER)) (WHEN (EQL SUB-CHAR #\#) (RETURN (MAKE-SEMICOLON-COMMENT :MARKER (QUOTE IL:\|) :STRING 
COMMENT-BUFFER))) (VECTOR-PUSH-EXTEND #\| COMMENT-BUFFER)) (VECTOR-PUSH-EXTEND SUB-CHAR COMMENT-BUFFER
))))
(DEFUN READ-PREFIX-QUOTE (STREAM SUB-CHAR INTEGER) "Reads hash quoted forms." (WHEN INTEGER (WARN 
"Spurious integer argument to hash macro ignored.")) (FUNCALL (ECASE SUB-CHAR (#\. (FUNCTION 
MAKE-HASH-DOT)) (#\, (FUNCTION MAKE-HASH-COMMA)) ((#\O #\o) (FUNCTION MAKE-HASH-O)) ((#\X #\x) (
FUNCTION MAKE-HASH-X)) ((#\B #\b) (FUNCTION MAKE-HASH-B))) :CONTENTS (LET ((*READ-BASE* (ECASE 
SUB-CHAR ((#\. #\,) *READ-BASE*) ((#\B #\b) 2) ((#\O #\o) 8) ((#\X #\x) 16)))) (READ STREAM NIL T))))
(DEFUN READ-READ-TIME-CONDITIONAL (STREAM SUB-CHAR INTEGER) (WHEN INTEGER (WARN 
"Spurious integer argument to hash macro ignored.")) (LET* ((FEATURE (LET ((*PACKAGE* 
IL:*KEYWORD-PACKAGE*)) (READ STREAM))) (UNREAD-P (ECASE SUB-CHAR (#\- (IL:CMLREAD.FEATURE.PARSER 
FEATURE)) (#\+ (NOT (IL:CMLREAD.FEATURE.PARSER FEATURE))))) (FORM (COND (UNREAD-P (LET ((START (
FILE-POSITION STREAM))) (LET ((*READ-SUPPRESS* T)) (READ STREAM)) (LET ((LENGTH (- (FILE-POSITION 
STREAM) START))) (FILE-POSITION STREAM START) (LET ((BUFFER (MAKE-STRING LENGTH))) (DOTIMES (I LENGTH 
BUFFER) (SETF (SVREF BUFFER I) (READ-CHAR STREAM))))))) (T (READ STREAM))))) (FUNCALL (CASE SUB-CHAR (
#\+ (FUNCTION MAKE-HASH-PLUS)) (#\- (FUNCTION MAKE-HASH-MINUS))) :FEATURE FEATURE :UNREAD-P UNREAD-P 
:FORM FORM)))
(DEFUN READ-SEMICOLON-COMMENT (STREAM DISP-CHAR &AUX CHAR (IL:* IL:\; "Current character.") (LEVEL 0) 
(IL:* IL:\; "Comment level.") (STARTING T) (IL:* IL:\; "In semicolons?") (COMMENT-BUFFER (MAKE-ARRAY 
128 :ELEMENT-TYPE (QUOTE CHARACTER) :FILL-POINTER 0 :ADJUSTABLE T))) 
"Reads the characters of a comment, building a Xerox Lisp style comment." (IL:* IL:|;;| 
"Adjacent comments of the same level are smashed together during an after-read pass over the structure."
) (LOOP (SETQ CHAR (READ-CHAR STREAM NIL EOF-MARKER)) (WHEN (OR (EQL CHAR EOF-MARKER) (EQL CHAR 
#\Newline)) (RETURN (MAKE-SEMICOLON-COMMENT :MARKER (ELT COMMENT-LEVEL-MARKERS (MIN LEVEL (1- (LENGTH 
COMMENT-LEVEL-MARKERS)))) :STRING COMMENT-BUFFER))) (IF STARTING (SETQ STARTING (IF (EQL CHAR #\;) (
INCF LEVEL) NIL)) (VECTOR-PUSH-EXTEND CHAR COMMENT-BUFFER))))
(DEFUN REMOVE-PRESENTATION (SEQUENCE INDEX) "Translates a presentation by removing it." (COND ((EQL 
INDEX 0) (SUBSEQ SEQUENCE 1)) ((EQL INDEX (1- (LENGTH SEQUENCE))) (SUBSEQ SEQUENCE 0 INDEX)) (T (
CONCATENATE (IF (LISTP SEQUENCE) (QUOTE LIST) (TYPE-OF SEQUENCE)) (SUBSEQ SEQUENCE 0 INDEX) (SUBSEQ 
SEQUENCE (1+ INDEX))))))
(DEFUN SEMICOLON-COMMENT-P (FORM) "Is FORM a semicolon comment?" (IL:* IL:|;;| 
"All info about the structure of semicolon comments is encapsulated in this function and the semicolon-comment structure."
) (AND (CONSP FORM) (EQ (FIRST FORM) (QUOTE IL:*)) (MEMBER (SECOND FORM) COMMENT-LEVEL-MARKERS :TEST (
FUNCTION EQ)) (STRINGP (THIRD FORM)) (NULL (NTHCDR 3 FORM))))
(DEFUN SPECIFIER-OF (FORM) "Examines a form and returns its specifier (file command)." (GET (CAR FORM)
 (QUOTE IL:DEFINER-FOR)))
(DEFUN SPECIFIER-TYPE (SPECIFIER) "If the form has a specifier type return its defining structure." (
OR (SOME (FUNCTION (LAMBDA (TYPE) (AND (FUNCALL (SPECIFIER-TYPE-SPECIFIERP TYPE) SPECIFIER) TYPE))) 
SPECIFIER-TYPES) (IL:NILL (WARN (QUOTE UNKNOWN-SPECIFIER) :SPECIFIER SPECIFIER))))
(DEFMACRO TOP-LEVEL-FORM-FORM (PLACE) "Return the form in the top-level form specifier." (IL:BQUOTE (
SECOND (SECOND (IL:\\\, PLACE)))))
(DEFUN TOP-LEVEL-FORM-P (SPECIFIER) (EQ (QUOTE IL:P) (FIRST SPECIFIER)))
(DEFUN TRANSLATE-FORM (SEQUENCE) "Create an evaluable form from one with presentations in it." (COND (
(LISTP SEQUENCE) (SETQ SEQUENCE (COPY-LIST SEQUENCE)) (IL:* IL:\; 
"An optimization for lists, since it would be terrible to ELT into them at each position.") (DO ((TAIL
 SEQUENCE) (LAST NIL)) ((NOT (CONSP TAIL)) SEQUENCE) (LET ((HEAD (FIRST TAIL))) (COND ((
SEMICOLON-COMMENT-P HEAD) (IL:* IL:\; "Special case for old style comments.") (IF (NULL LAST) (SETQ 
SEQUENCE (CDR TAIL)) (RPLACD LAST (CDR TAIL))) (IL:* IL:\; "Last stays the same in either case.") (POP
 TAIL)) ((PRESENTATION-P HEAD) (LET* ((INSTALLER (PRESENTATION-OPS-TRANSLATOR (PRESENTATION-OPS HEAD))
) (RESULT (IF (EQ INSTALLER :DELETE) *DELETE-FORM* (FUNCALL INSTALLER HEAD)))) (COND ((EQ RESULT 
*DELETE-FORM*) (IF (NULL LAST) (SETQ SEQUENCE (CDR TAIL)) (RPLACD LAST (CDR TAIL))) (IL:* IL:\; 
"Last stays the same in either case.") (POP TAIL)) (T (RPLACA TAIL RESULT) (SETQ LAST TAIL) (POP TAIL)
)))) ((TYPEP HEAD (QUOTE SEQUENCE)) (RPLACA TAIL (TRANSLATE-FORM HEAD)) (SETQ LAST TAIL) (POP TAIL)) (
T (SETQ LAST TAIL) (POP TAIL)))))) ((AND (NOT (STRINGP SEQUENCE)) (TYPEP SEQUENCE (QUOTE SEQUENCE))) (
IL:* IL:\; "Optimization: avoid strings.") (SETQ SEQUENCE (COPY-SEQ SEQUENCE)) (IL:* IL:\; 
"The general case of a sequence.") (DO ((INDEX 0) (LENGTH (LENGTH SEQUENCE))) ((EQL INDEX LENGTH) 
SEQUENCE) (LET ((HEAD (ELT SEQUENCE INDEX))) (COND ((PRESENTATION-P HEAD) (LET* ((INSTALLER (
PRESENTATION-OPS-TRANSLATOR (PRESENTATION-OPS HEAD))) (RESULT (IF (EQ INSTALLER :DELETE) *DELETE-FORM*
 (FUNCALL INSTALLER HEAD)))) (COND ((EQ RESULT *DELETE-FORM*) (SETQ SEQUENCE (REMOVE-PRESENTATION 
SEQUENCE INDEX)) (DECF LENGTH)) (T (SETF (ELT SEQUENCE INDEX) RESULT) (INCF INDEX))))) ((TYPEP HEAD (
QUOTE SEQUENCE)) (SETF (ELT SEQUENCE INDEX) (TRANSLATE-FORM HEAD)) (INCF INDEX)) (T (INCF INDEX)))))) 
((PRESENTATION-P SEQUENCE) (LET* ((INSTALLER (PRESENTATION-OPS-TRANSLATOR (PRESENTATION-OPS SEQUENCE))
) (RESULT (IF (EQ INSTALLER :DELETE) *DELETE-FORM* (FUNCALL INSTALLER SEQUENCE)))) (IF (EQ RESULT 
*DELETE-FORM*) NIL RESULT))) (T SEQUENCE)))
(DEFUN TRANSLATE-HASH-COMMA (OBJECT) (COND (*READ-SUPPRESS* NIL) (COMPILER::*COMPILER-IS-READING* (
COMPILER::MAKE-EVAL-WHEN-LOAD :FORM (PREFIX-QUOTE-CONTENTS OBJECT))) ((IL:FETCH (READTABLEP 
IL:COMMONLISP) IL:OF *READTABLE*) (EVAL (PREFIX-QUOTE-CONTENTS OBJECT))) (T (IL:EVAL (
PREFIX-QUOTE-CONTENTS OBJECT)))))
(DEFUN TRANSLATE-HASH-DOT (OBJECT) (COND (*READ-SUPPRESS* NIL) ((IL:FETCH (READTABLEP IL:COMMONLISP) 
IL:OF *READTABLE*) (EVAL (PREFIX-QUOTE-CONTENTS OBJECT))) (T (IL:EVAL (PREFIX-QUOTE-CONTENTS OBJECT)))
))
(DEFUN TRANSLATE-PREFIX-QUOTE (OBJECT) (IL:* IL:\; "This only has to handle numeric base types.") (
PREFIX-QUOTE-CONTENTS OBJECT))
(DEFUN TRANSLATE-READ-TIME-CONDITIONAL (OBJECT) (IF (ETYPECASE OBJECT (HASH-MINUS (NOT (
IL:CMLREAD.FEATURE.PARSER (READ-TIME-CONDITIONAL-FEATURE OBJECT)))) (HASH-PLUS (
IL:CMLREAD.FEATURE.PARSER (READ-TIME-CONDITIONAL-FEATURE OBJECT)))) (IF (
READ-TIME-CONDITIONAL-UNREAD-P OBJECT) (WITH-INPUT-FROM-STRING (INPUT-STRING (
READ-TIME-CONDITIONAL-FORM OBJECT)) (LET ((*READTABLE* (IL:FIND-READTABLE "LISP"))) (READ INPUT-STRING
 NIL T))) (READ-TIME-CONDITIONAL-FORM OBJECT)) *DELETE-FORM*))
(DEFSTRUCT PRESENTATION OPS)
(DEFSTRUCT (PREFIX-QUOTE (:INCLUDE PRESENTATION) (:PRINT-FUNCTION PRINT-PREFIX-QUOTE)) TYPE PREFIX 
CONTENTS)
(DEFSTRUCT (PRESENTATION-OPS (:TYPE LIST)) READ-MACRO (IL:* IL:\; 
"A list with one or two characters followed by a read macro function.  Installed in the text file readtable to read this presentation."
) TRANSLATOR (IL:* IL:\; 
"Either a function on PRESENTATION which translates it, or :DELETE which always removes it (eg, comments)."
))
(DEFSTRUCT (READ-TIME-CONDITIONAL (:INCLUDE PRESENTATION) (:PRINT-FUNCTION PRINT-READ-TIME-CONDITIONAL
)) FEATURE UNREAD-P FORM)
(DEFSTRUCT (SEMICOLON-COMMENT (:TYPE LIST) (:PREDICATE NIL) (IL:* IL:\; 
"The real one is SEMICOLON-COMMENT-P")) (TAG (QUOTE IL:*)) (MARKER (QUOTE IL:\;)) (STRING ""))
(DEFSTRUCT (SPECIFIER-TYPE (:TYPE LIST)) NAME (IL:* IL:\; "A string naming the specifier.") SPECIFIERP
 (IL:* IL:\; 
"Predicate on FORM (a content specifier) which recognizes the specifier in the contents description of a file."
) IDENTIFIER (IL:* IL:\; 
"Predicate on FORM (a form from the text file), answers true if this is the specifier for the definition in FORM."
) ADD (IL:* IL:\; 
"Function of FORM and CONTENTS which adds a specifier for FORM to the file CONTENTS description.") 
INSTALLER (IL:* IL:\; 
"Function of a FORM which installs the definition of FORM (may remove presentations).  Should not actually install the definition if il:dfnflg is il:prop or il:allprop."
) PRINT-FORM (IL:* IL:\; "Function of SPECIFIER which returns the form to be printed."))
(DEFINE-CONDITION UNKNOWN-FORM WARNING :REPORT-FUNCTION (LAMBDA (CONDITION STREAM) (FORMAT STREAM 
"Can't find specifier (filecom) for ~s" (UNKNOWN-FORM-FORM CONDITION))) FORM)
(DEFINE-CONDITION UNKNOWN-SPECIFIER WARNING :REPORT-FUNCTION (LAMBDA (CONDITION STREAM) (FORMAT STREAM
 "Unknown specifier (filecom) ~s" (UNKNOWN-SPECIFIER-SPECIFIER CONDITION))) SPECIFIER)
(DEFVAR *DELETE-FORM* "<delete form marker>")
(DEFCONSTANT COMMENT-LEVEL-MARKERS (QUOTE (IL:\; IL:|;;| IL:|;;;| IL:|;;;;| IL:\|)) 
"Comment markers for availible levels.")
(DEFCONSTANT EOF-MARKER "eof" "Unique object passed through read at EOF.")
(DEFPARAMETER SPECIFIER-TYPES (LIST (MAKE-SPECIFIER-TYPE :NAME "Comment" :SPECIFIERP (FUNCTION 
SEMICOLON-COMMENT-P) :IDENTIFIER (FUNCTION SEMICOLON-COMMENT-P) :ADD (FUNCTION (LAMBDA (FORM CONTENTS)
 (APPEND CONTENTS (LIST FORM)))) :INSTALLER (FUNCTION IDENTITY) :PRINT-FORM (FUNCTION IDENTITY)) (
MAKE-SPECIFIER-TYPE :NAME "eval-when top level form" :SPECIFIERP (FUNCTION (LAMBDA (FORM) (EQ (FIRST 
FORM) (QUOTE IL:EVAL-WHEN)))) :IDENTIFIER (FUNCTION (LAMBDA (FORM) (AND (LISTP FORM) (EQ (FIRST FORM) 
(QUOTE EVAL-WHEN))))) :ADD (FUNCTION (LAMBDA (FORM CONTENTS) (APPEND CONTENTS (LIST (IL:BQUOTE (
IL:EVAL-WHEN (IL:\\\, (SECOND FORM)) (IL:\\\,@ (LET ((CONTENTS NIL)) (MAPC (FUNCTION (LAMBDA (FORM) (
SETQ CONTENTS (ADD-FORM FORM CONTENTS)))) (CDDR FORM)) CONTENTS)))))))) :INSTALLER (FUNCTION (LAMBDA (
FORM) (WHEN (MEMBER (QUOTE EVAL) (SECOND FORM)) (DOLIST (FORM (CDDR FORM)) (INSTALL-FORM FORM))))) 
:PRINT-FORM (FUNCTION (LAMBDA (SPECIFIER) (IL:BQUOTE (EVAL-WHEN (IL:\\\, (SECOND SPECIFIER)) (IL:\\\,@
 (MAPCAR (FUNCTION (LAMBDA (SPECIFIER) (PRINT-FORM SPECIFIER))) (CDDR SPECIFIER)))))))) (
MAKE-SPECIFIER-TYPE :NAME "Definer" :SPECIFIERP (FUNCTION (LAMBDA (SPECIFIER) (GET (FIRST SPECIFIER) (
QUOTE IL:DEFINED-BY)))) :IDENTIFIER (FUNCTION (LAMBDA (FORM) (AND (LISTP FORM) (GET (CAR FORM) (QUOTE 
IL:DEFINER-FOR))))) :ADD (FUNCTION (LAMBDA (FORM CONTENTS) (LET ((IL:DFNFLG (QUOTE IL:PROP))) (EVAL 
FORM)) (APPEND CONTENTS (LIST (IL:BQUOTE ((IL:\\\, (SPECIFIER-OF FORM)) (IL:\\\, (NAME-OF FORM))))))))
 :INSTALLER (FUNCTION (LAMBDA (FORM) (LET ((IL:DFNFLG T)) (EVAL FORM)))) :PRINT-FORM (FUNCTION (LAMBDA
 (SPECIFIER) (IL:GETDEF (SECOND SPECIFIER) (FIRST SPECIFIER))))) (MAKE-SPECIFIER-TYPE :NAME 
"Top-level read-time conditional" :SPECIFIERP (FUNCTION (LAMBDA (FORM) NIL)) :IDENTIFIER (FUNCTION 
READ-TIME-CONDITIONAL-P) :ADD (FUNCTION (LAMBDA (FORM CONTENTS) (APPEND CONTENTS (LIST (IL:BQUOTE (IL:P
 (TRANSLATE-FORM (IL:\\\, FORM)))))))) :INSTALLER (FUNCTION (LAMBDA (FORM) (EVAL (TRANSLATE-FORM FORM)
))) :PRINT-FORM (FUNCTION (LAMBDA (SPECIFIER) (SECOND (SECOND SPECIFIER))))) (MAKE-SPECIFIER-TYPE 
:NAME "Top level form" :SPECIFIERP (FUNCTION TOP-LEVEL-FORM-P) :IDENTIFIER (FUNCTION TRUE) :ADD (
FUNCTION (LAMBDA (FORM CONTENTS) (APPEND CONTENTS (LIST (IL:BQUOTE (IL:P (TRANSLATE-FORM (IL:\\\, FORM
)))))))) :INSTALLER (FUNCTION (LAMBDA (FORM) (EVAL (TRANSLATE-FORM FORM)))) :PRINT-FORM (FUNCTION (
LAMBDA (SPECIFIER) (TOP-LEVEL-FORM-FORM SPECIFIER))))) 
"A list of all content specifier types for text files.")
(MAKE-LISP-FILE-READTABLE)
(DEF-DEFINE-TYPE IL:PRESENTATIONS "presentation types")
(DEFPRESENTATION HASH-B :INCLUDE (PREFIX-QUOTE (TYPE :HASH-B) (PREFIX "#b")) :PRINT-FUNCTION 
PRINT-PREFIX-QUOTE :READ-MACRO (#\# #\b READ-PREFIX-QUOTE) :TRANSLATOR TRANSLATE-PREFIX-QUOTE)
(DEFPRESENTATION HASH-COMMA :INCLUDE (PREFIX-QUOTE (TYPE :HASH-COMMA) (PREFIX "#,")) :PRINT-FUNCTION 
PRINT-PREFIX-QUOTE :READ-MACRO (#\# #\, READ-PREFIX-QUOTE) :TRANSLATOR TRANSLATE-HASH-COMMA)
(DEFPRESENTATION HASH-DOT :INCLUDE (PREFIX-QUOTE (TYPE :HASH-DOT) (PREFIX "#.")) :PRINT-FUNCTION 
PRINT-PREFIX-QUOTE :READ-MACRO (#\# #\. READ-PREFIX-QUOTE) :TRANSLATOR TRANSLATE-HASH-DOT)
(DEFPRESENTATION HASH-MINUS :INCLUDE READ-TIME-CONDITIONAL :PRINT-FUNCTION PRINT-READ-TIME-CONDITIONAL
 :READ-MACRO (#\# #\+ READ-READ-TIME-CONDITIONAL) :TRANSLATOR TRANSLATE-READ-TIME-CONDITIONAL)
(DEFPRESENTATION HASH-O :INCLUDE (PREFIX-QUOTE (TYPE :HASH-O) (PREFIX "#o")) :PRINT-FUNCTION 
PRINT-PREFIX-QUOTE :READ-MACRO (#\# #\o READ-PREFIX-QUOTE) :TRANSLATOR TRANSLATE-PREFIX-QUOTE)
(DEFPRESENTATION HASH-PLUS :INCLUDE READ-TIME-CONDITIONAL :PRINT-FUNCTION PRINT-READ-TIME-CONDITIONAL 
:READ-MACRO (#\# #\+ READ-READ-TIME-CONDITIONAL) :TRANSLATOR TRANSLATE-READ-TIME-CONDITIONAL)
(DEFPRESENTATION HASH-X :INCLUDE (PREFIX-QUOTE (TYPE :HASH-X) (PREFIX "#x")) :PRINT-FUNCTION 
PRINT-PREFIX-QUOTE :READ-MACRO (#\# #\x READ-PREFIX-QUOTE) :TRANSLATOR TRANSLATE-PREFIX-QUOTE)
(REINSTALL-ADVICE (QUOTE REMOVE-COMMENTS) :AROUND (QUOTE ((:LAST (TRANSLATE-FORM IL:X)))))
(REINSTALL-ADVICE (QUOTE (IL:EVAL :IN IL:\\DO-DEFINE-FILE-INFO)) :BEFORE (QUOTE ((:LAST (SETQ IL:U (
TRANSLATE-FORM IL:U))))))
(IL:READVISE REMOVE-COMMENTS (IL:EVAL :IN IL:\\DO-DEFINE-FILE-INFO))
(IL:PUTPROPS IL:TEXTMODULES IL:FILETYPE :COMPILE-FILE)
(IL:PUTPROPS IL:TEXTMODULES IL:MAKEFILE-ENVIRONMENT (:READTABLE "XCL" :PACKAGE (LET ((*PACKAGE* 
*PACKAGE*)) (IN-PACKAGE (DEFPACKAGE "TEXTMODULES" (:USE "LISP" "XCL") (:PREFIX-NAME "TM"))) (
IL:FILESLOAD IL:EVAL-WHEN-PATCH) *PACKAGE*) :BASE 10))
(IL:PUTPROPS IL:TEXTMODULES IL:COPYRIGHT ("Xerox Corporation" 1987))
NIL
