(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)(FILECREATED "27-Jul-90 09:46:57" {DSK}<usr>local>lde>loops>src>SYSTEM>LOOPSACTIVEVALUES.;2 42212        changes to%:  (VARS LOOPSACTIVEVALUESCOMS)      previous date%: "24-Feb-88 08:56:36" {DSK}<usr>local>lde>loops>src>SYSTEM>LOOPSACTIVEVALUES.;1)(* ; "Copyright (c) 1985, 1986, 1987, 1988, 1990 by Venue & Xerox Corporation.  All rights reserved.")(PRETTYCOMPRINT LOOPSACTIVEVALUESCOMS)(RPAQQ LOOPSACTIVEVALUESCOMS ((CLASSES ActiveValue AppendSuperValue ExplicitFnActiveValue FirstFetchAV IndirectVariable InheritingAV LocalStateActiveValue NestedNotSetValue NoUpdatePermittedAV NotSetValue ReplaceMeAV) (METHODS ActiveValue.AVPrintSource ActiveValue.AddActiveValue ActiveValue.CopyActiveValue ActiveValue.DeleteActiveValue ActiveValue.DeleteNestedActiveValue ActiveValue.GetWrappedValue ActiveValue.GetWrappedValueOnly ActiveValue.HasAV? ActiveValue.NestActiveValue ActiveValue.PutWrappedValue ActiveValue.PutWrappedValueOnly ActiveValue.ReplaceActiveValue ActiveValue.ReplaceNestedActiveValue ActiveValue.WrapOutside? ActiveValue.WrappingPrecedence AppendSuperValue.CopyActiveValue AppendSuperValue.GetWrappedValue ExplicitFnActiveValue.AVPrintSource ExplicitFnActiveValue.GetWrappedValue ExplicitFnActiveValue.PutWrappedValue FirstFetchAV.AVPrintSource FirstFetchAV.GetWrappedValue IndirectVariable.AddActiveValue IndirectVariable.GetWrappedValueOnly IndirectVariable.PutWrappedValueOnly IndirectVariable.WrappingPrecedence InheritingAV.InheritedValue LocalStateActiveValue.DeleteActiveValue LocalStateActiveValue.GetWrappedValueOnly LocalStateActiveValue.NewInstance LocalStateActiveValue.PutWrappedValueOnly NestedNotSetValue.AVPrintSource NoUpdatePermittedAV.PutWrappedValue NotSetValue.AVPrintSource NotSetValue.CopyActiveValue NotSetValue.GetWrappedValue NotSetValue.GetWrappedValueOnly NotSetValue.HasAV? NotSetValue.PutWrappedValue NotSetValue.PutWrappedValueOnly NotSetValue.WrappingPrecedence ReplaceMeAV.PutWrappedValue) (* ;;; "Fix NotSetValue.  It was given a bogus value earlier for bootstraping purposes;  now give it the right value") (P (replace annotatedValue of NotSetValue with (_ ($ NotSetValue) Prototype))) (* ;;; "Set up the WrappedNotSetValue") (INITVARS (NestedNotSetValue (create annotatedValue annotatedValue _ (_ ($ NestedNotSetValue) Prototype)))) (GLOBALVARS NestedNotSetValue) (* ;;; "The _AV macro") (FUNCTIONS _AV) (ALISTS (PRETTYPRINTMACROS _AV)) (* ;;; "Set up for automatic translation from annotatedValues to their active values") (CLASSES AnnotatedValue) (METHODS AnnotatedValue.MessageNotUnderstood AnnotatedValue.GetValue) (P (PUTHASH (QUOTE annotatedValue) ($ AnnotatedValue) LispClassTable)) (* ;;; "Defered values") (FUNCTIONS Defer) (FNS \Defer) (* ;;; "For ExplicitFnActiveValue avs") (FNS DefAVP) (* ;;; "Editing AnnotatedValues") (FNS AnnotatedValueEditSource AnnotatedValueInstallEditSource) (ADDVARS (DT.EDITMACROS (annotatedValue AnnotatedValueEditSource AnnotatedValueInstallEditSource))) (* ;;; "Printing and reading annotated values") (FNS PrintAnnotatedValue $A $AV) (INITVARS (DefaultActiveValueClassName (QUOTE ExplicitFnActiveValue))) (GLOBALVARS DefaultActiveValueClassName) (P (DEFPRINT (QUOTE annotatedValue) (QUOTE PrintAnnotatedValue))) (DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA $AV) (NLAML $A) (LAMA)))))(DEFCLASSES ActiveValue AppendSuperValue ExplicitFnActiveValue FirstFetchAV IndirectVariable InheritingAV LocalStateActiveValue NestedNotSetValue NoUpdatePermittedAV NotSetValue ReplaceMeAV)(DEFCLASS ActiveValue   (MetaClass AbstractClass Edited%: (* smL "21-Apr-86 13:05")) (Supers Object))(DEFCLASS AppendSuperValue   (MetaClass Class Edited%: (* smL " 8-May-86 14:06")) (Supers ReplaceMeAV InheritingAV LocalStateActiveValue))(DEFCLASS ExplicitFnActiveValue   (MetaClass Class Edited%: (* smL "23-Sep-85 14:45")) (Supers LocalStateActiveValue) (InstanceVariables (getFn NIL doc (* the getFn for this activeValue)) (putFn NIL doc (* the putFn for this activeValue))))(DEFCLASS FirstFetchAV   (MetaClass Class Edited%: (* smL " 7-May-86 12:53")) (Supers ReplaceMeAV LocalStateActiveValue))(DEFCLASS IndirectVariable   (MetaClass Class doc (* Active Value for redirecting references to another variable) Edited%: (* smL " 9-May-86 09:52")) (Supers ActiveValue) (InstanceVariables (object NIL doc (* The object with the "real" variable)) (varName NIL doc (* The name of the "real" variable)) (propName NIL doc (* The prop name of the "real" variable)) (type NIL doc (* The type of the "real" variable))))(DEFCLASS InheritingAV   (MetaClass AbstractClass Edited%: (* smL " 8-May-86 18:24")) (Supers ActiveValue))(DEFCLASS LocalStateActiveValue   (MetaClass Class Edited%: (* smL "16-Apr-86 10:37")) (Supers ActiveValue) (InstanceVariables (localState NIL doc (* The local state of the active value))))(DEFCLASS NestedNotSetValue   (MetaClass Class Edited%: (* smL "14-Jan-87 16:21")) (Supers NotSetValue) (ClassVariables (Prototype #,($& NestedNotSetValue (JNW0.%:F5.C38.O\; . 60)))))(DEFCLASS NoUpdatePermittedAV   (MetaClass Class doc (* Acitve value that prevents the variable from being changed) Edited%: (* smL " 7-May-86 13:50")) (Supers LocalStateActiveValue))(DEFCLASS NotSetValue   (MetaClass Class doc (* Used to trigger IV inheritance. If the value of an IV is an instance of NotSetValue, getting the value will send the IVValueMissing message.) Edited%: (* smL "15-Apr-86 15:18")) (Supers ActiveValue) (ClassVariables (Prototype #,($& NotSetValue (APV0.C=N5.zA8 . 35)) doc (* Undocumented CV added by LANNING))))(DEFCLASS ReplaceMeAV   (MetaClass AbstractClass Edited%: (* smL " 7-May-86 12:29")) (Supers ActiveValue))(\BatchMethodDefs)(METH ActiveValue  AVPrintSource NIL      "Construct the print-source for the ActiveValue so it can be read back in by the #. macro" (category (ActiveValue)))(METH ActiveValue  AddActiveValue (containingObj varName propName type annotatedValue)      "Wrap the annotatedValue around the value specified by containingObj varName propName and type type. - If no annotatedValue is given, create a new one with self as the active value. - Return the added annotatedValue" (category (ActiveValue)))(METH ActiveValue  CopyActiveValue (annotatedValue)      "Copy the annotatedValue containing self" (category (ActiveValue)))(METH ActiveValue  DeleteActiveValue (containingObj varName propName type)      "Remove the active value self from the specified variable. - Return the deleted annotatedValue or NIL if the active value was not found" (category (ActiveValue)))(METH ActiveValue  DeleteNestedActiveValue (containingObj varName propName type activeValue)      "Remove the given nested active value from the specified variable. - Return the deleted annotatedValue or NIL if the active value was not found." (category (ActiveValue)))(METH ActiveValue  GetWrappedValue (containingObj varName propName type)      "Fetch the value wrapped in the active value" (category (ActiveValue)))(METH ActiveValue  GetWrappedValueOnly NIL      "Fetch the value wrapped in the active value without triggering any side-effects." (category (ActiveValue)))(METH ActiveValue  HasAV? (av)      "Is the given active value nested inside of self, or eq to self?" (category (ActiveValue)))(METH ActiveValue  NestActiveValue (containingObj varName propName type annotatedValue)      "Nest the given annotatedValue inside self, without changing the currently wrapped value. This is part of the protocol for adding an active value to a variable." (category (ActiveValue)))(METH ActiveValue  PutWrappedValue (containingObj varName newValue propName type)      "Replace the value wrapped in the active value" (category (ActiveValue)))(METH ActiveValue  PutWrappedValueOnly (newValue)      "Replace the value wrapped in the active value without triggering any side-effects." (category (ActiveValue)))(METH ActiveValue  ReplaceActiveValue (newVal containingObject varName propName type)      "Replace the annotated value containing self with the given value" (category (ActiveValue)))(METH ActiveValue  ReplaceNestedActiveValue (containedAVObj newVal containingObj varName propName type)      "Replace the nested active value containedAVObj in self with newVal" (category (Internal ActiveValue)))(METH ActiveValue  WrapOutside? (activeValue)      "Should self be wrapped around the activeValue, or nested inside? Return TRUE iff self should be wrapped around, FALSE if nested." (category (ActiveValue)))(METH ActiveValue  WrappingPrecedence NIL      "What is the wrapping precedence for this active value? The larger the number, the more the active value wants to be on the outside. NIL forces innermost nesting, T forces outermost nesting." (category (ActiveValue)))(METH AppendSuperValue  CopyActiveValue (annotatedValue)      "Copy the annotatedValue containing self" (category (ActiveValue)))(METH AppendSuperValue  GetWrappedValue (containingObj varName propName type)      "Fetch the value wrapped in the active value" (category (ActiveValue)))(METH ExplicitFnActiveValue  AVPrintSource NIL      "Construct the print-source for the ExplicitFnActiveValue so it can be read back in by the #. macro" (category (ActiveValue)))(METH ExplicitFnActiveValue  GetWrappedValue (containingObj varName propName type)      "Fetch the value wrapped in the active value" (category (ActiveValue)))(METH ExplicitFnActiveValue  PutWrappedValue (containingObj varName newValue propName type)      "Specialization" (category (ActiveValue)))(METH FirstFetchAV  AVPrintSource NIL      "Construct the print-source for the ActiveValue so it can be read back in by the #. macro" (category (ActiveValue)))(METH FirstFetchAV  GetWrappedValue (containingObj varName propName type)      "A FirstFetchAV evaluates the local state and replaces the active value with the result" (category (ActiveValue)))(METH IndirectVariable  AddActiveValue (containingObj varName propName type annotatedValue)      "Add an IndirectVariable ActiveValue to an object" (category (ActiveValue)))(METH IndirectVariable  GetWrappedValueOnly NIL      "Fetch the value wrapped in the active value without triggereing any side-effects." (category (ActiveValue)))(METH IndirectVariable  PutWrappedValueOnly (newValue)      "Replace the value wrapped in the active value without triggereing any side-effects." (category (ActiveValue)))(METH IndirectVariable  WrappingPrecedence NIL      "What is the wrapping precedence for this active value? The larger the number, the more the active value wants to be on the outside. NIL forces innermost nesting, T forces outermost nesting." (category (ActiveValue)))(METH InheritingAV  InheritedValue (containingObj varName propName type)      "What value would have been inherited had this active value not been in the way?" (category (InheritingAV)))(METH LocalStateActiveValue  DeleteActiveValue (containingObj varName propName type)      "Remove the active value self from the specified variable. - Return the deleted annotatedValue or NIL if the active value was not found" (category (ActiveValue)))(METH LocalStateActiveValue  GetWrappedValueOnly NIL      "Fetch the value wrapped in the active value without triggereing any side-effects." (category (ActiveValue)))(METH LocalStateActiveValue  NewInstance (name arg1 arg2 arg3 arg4 arg5)      "This allows initialization by the classes of objects themselves, rather than going to a metaClass" (category (Object)))(METH LocalStateActiveValue  PutWrappedValueOnly (newValue)      "Replace the value wrapped in the active value without triggereing any side-effects." (category (ActiveValue)))(METH NestedNotSetValue  AVPrintSource NIL      "Construct the print-source for the ActiveValue so it can be read back in by the #. macro" (category (ActiveValue)))(METH NoUpdatePermittedAV  PutWrappedValue (containingObj varName newValue propName type)      "Replace the value wrapped in the active value" (category (ActiveValue)))(METH NotSetValue  AVPrintSource NIL      "Construct the print-source for the ActiveValue so it can be read back in by the #. macro" (category (ActiveValue)))(METH NotSetValue  CopyActiveValue (annotatedValue)      "Copy the annotatedValue containing self" (category (ActiveValue)))(METH NotSetValue  GetWrappedValue (containingObj varName propName type)      "Fetch the value of the ActiveValue" (category (ActiveValue)))(METH NotSetValue  GetWrappedValueOnly NIL      "Fetch the value wrapped in the active value without triggereing any side-effects." (category (ActiveValue)))(METH NotSetValue  HasAV? (av)      "Is the given active value nested inside of self, or eq to self?" (category (ActiveValue)))(METH NotSetValue  PutWrappedValue (containingObj varName newValue propName type)      "Replace the value of the local state" (category (ActiveValue)))(METH NotSetValue  PutWrappedValueOnly (newValue)      "Replace the value wrapped in the active value without triggereing any side-effects." (category (ActiveValue)))(METH NotSetValue  WrappingPrecedence NIL      "What is the wrapping precedence for this active value? The larger the number, the more the active value wants to be on the outside. NIL forces innermost nesting, T forces outermost nesting." (category (ActiveValue)))(METH ReplaceMeAV  PutWrappedValue (containingObj varName newValue propName type)      "Replace the value wrapped in the active value" (category (ActiveValue)))(Method ((ActiveValue AVPrintSource) self) (* ; "smL 25-Sep-85 11:15") "Construct the print-source for the ActiveValue so it can be read back in by the #. macro" (CONS (CONSTANT (CONCAT LoopsReadMacroChar ",")) (CONS (QUOTE $AV) (CDR (_ self MakeFileSource)))))(Method ((ActiveValue AddActiveValue) self containingObj varName propName type annotatedValue) (* ; "smL  5-May-86 17:15") "Wrap the annotatedValue around the value specified by containingObj varName propName and type type. - If no annotatedValue is given, create a new one with self as the active value. - Return the added annotatedValue" (LET ((annotatedValue (OR annotatedValue (create annotatedValue annotatedValue _ self))) (localValue (SELECTQ type ((NIL IV) (GetIVHere containingObj varName propName)) (CV (GetClassValueOnly containingObj varName propName)) (CLASS (GetClassHere containingObj varName)) (METHOD (GetMethodHere containingObj varName propName)) (HELPCHECK "Unknown access type" type))) activeValue) (SETQ activeValue (fetch annotatedValue of annotatedValue)) (if (OR (NOT (type? annotatedValue localValue)) (NOT (_AV localValue WrapOutside? activeValue))) then (* The new annotated value goes on the outside of the current value.) (_ activeValue PutWrappedValueOnly localValue) (SELECTQ type ((NIL IV) (PutValueOnly containingObj varName annotatedValue propName)) (CV (PutClassValueOnly containingObj varName annotatedValue propName)) (CLASS (PutClassValueOnly containingObj varName annotatedValue propName)) (METHOD (PutMethodOnly containingObj varName annotatedValue propName)) (HELPCHECK "Unknown access type" type)) else (* The current value is an annotated value, and the new one should go on the inside of it.) (_AV localValue NestActiveValue containingObj varName propName type annotatedValue)) annotatedValue))(Method ((ActiveValue CopyActiveValue) self annotatedValue) (* ; "smL  6-May-86 14:22") "Copy the annotatedValue containing self" (LET ((newav (CopyInstance self))) (for ivName in (_ newav ListAttribute! (QUOTE IVs)) bind ivValue eachtime (SETQ ivValue (GetIVHere newav ivName)) when (type? annotatedValue ivValue) do (PutValueOnly newav ivName (_AV ivValue CopyActiveValue ivValue))) (create annotatedValue annotatedValue _ newav)))(Method ((ActiveValue DeleteActiveValue) self containingObj varName propName type) (* ; "smL  5-May-86 17:13") "Remove the active value self from the specified variable. - Return the deleted annotatedValue or NIL if the active value was not found" (LET ((localValue (SELECTQ type ((NIL IV) (GetIVHere containingObj varName propName)) (CV (GetClassValueOnly containingObj varName propName)) (CLASS (GetClassHere containingObj varName)) (METHOD (GetMethodHere containingObj varName propName)) (HELPCHECK "Unknown access type" type)))) (if (NOT (type? annotatedValue localValue)) then (* Not found) NIL elseif (EQ self (fetch annotatedValue of localValue)) then (LET ((localState (_ self GetWrappedValueOnly))) (SELECTQ type ((NIL IV) (PutValueOnly containingObj varName localState propName)) (CV (PutClassValueOnly containingObj varName localState propName)) (CLASS (PutClassValueOnly containingObj varName localState propName)) (METHOD (PutMethodOnly containingObj varName localState propName)) (HELPCHECK "Unknown access type" type))) localValue else (_AV localValue DeleteNestedActiveValue containingObj varName propName type self))))(Method ((ActiveValue DeleteNestedActiveValue) self containingObj varName propName type activeValue) (* ; "smL  5-May-86 17:14") "Remove the given nested active value from the specified variable. - Return the deleted annotatedValue or NIL if the active value was not found." (LET ((localState (_ self GetWrappedValueOnly))) (if (NOT (type? annotatedValue localState)) then (* Not found) NIL elseif (EQ activeValue (fetch annotatedValue of localState)) then (* Found it) (_ self PutWrappedValueOnly (_ activeValue GetWrappedValueOnly)) else (* Look still deeper) (_AV localState DeleteNestedActiveValue containingObj varName propName type activeValue))))(Method ((ActiveValue GetWrappedValue) self containingObj varName propName type) (* ; "smL 27-May-86 14:12") "Fetch the value wrapped in the active value" (ExtractRealValue containingObj varName (_ self GetWrappedValueOnly) propName type))(Method ((ActiveValue GetWrappedValueOnly) self) (* ; "smL 15-May-86 11:04") "Fetch the value wrapped in the active value without triggering any side-effects." (SubclassResponsibility))(Method ((ActiveValue HasAV?) self av) (* ; "smL  8-May-86 14:35") "Is the given active value nested inside of self, or eq to self?" (OR (EQ self (if (type? annotatedValue av) then (fetch annotatedValue of av) else av)) (LET ((localState (_ self GetWrappedValueOnly))) (if (type? annotatedValue localState) then (_AV localState HasAV? av) else NIL))))(Method ((ActiveValue NestActiveValue) self containingObj varName propName type annotatedValue) (* ; "smL  5-May-86 17:14") "Nest the given annotatedValue inside self, without changing the currently wrapped value. This is part of the protocol for adding an active value to a variable." (LET ((localValue (_ self GetWrappedValueOnly))) (if (OR (NOT (type? annotatedValue localValue)) (NOT (_AV localValue WrapOutside? (fetch annotatedValue of annotatedValue)))) then (* The nested annotated value should go immediatly inside self) (_AV annotatedValue PutWrappedValueOnly localValue) (_ self PutWrappedValueOnly annotatedValue) else (* The nested annotated value needs to be nested deeper still.) (_AV localValue NestActiveValue containingObj varName propName type annotatedValue))))(Method ((ActiveValue PutWrappedValue) self containingObj varName newValue propName type) (* ; "smL  5-May-86 18:37") "Replace the value wrapped in the active value" (LET ((localValue (_ self GetWrappedValueOnly))) (if (EQ localValue NestedNotSetValue) then (* ;; "Possible funky case here is that the default value may itself be an active value.  Trick is to grab the current contents of (containingObj varName propName type), smash it to NIL, let Object.IVValueMissing get the default value, then put it all back.") (LET ((outerActiveValue (GetItOnly containingObj varName propName type)) successfulDefault) (PutItOnly containingObj varName NIL propName type) (CL:UNWIND-PROTECT (PROGN (_ containingObj IVValueMissing varName propName (QUOTE PutValue) newValue) (SETQ successfulDefault T)) (* ;; "If the IVValueMissing fails, restore the NestedNotSetValue") (CL:UNWIND-PROTECT (_ self PutWrappedValueOnly (if successfulDefault then (GetItOnly containingObj varName propName type) else NestedNotSetValue)) (PutItOnly containingObj varName outerActiveValue propName type)))) elseif (type? annotatedValue localValue) then (_ (fetch annotatedValue of localValue) PutWrappedValue containingObj varName newValue propName type) else (_ self PutWrappedValueOnly newValue))))(Method ((ActiveValue PutWrappedValueOnly) self newValue) (* ; "smL 15-May-86 11:04") "Replace the value wrapped in the active value without triggering any side-effects." (SubclassResponsibility))(Method ((ActiveValue ReplaceActiveValue) self newVal containingObject varName propName type) (* ; "smL 15-Apr-87 14:04") "Replace the annotated value containing self with the given value" (LET ((localValue (SELECTQ type ((NIL IV) (GetIVHere containingObject varName propName)) (CV (GetClassValueOnly containingObject varName propName)) (CLASS (GetClassHere containingObject varName)) (METHOD (GetMethodHere containingObject varName propName)) (HELPCHECK "Unknown access type" type)))) (COND ((AND (NOT (type? instance containingObject)) (NOT (type? class containingObject))) (* ; "Hmmm, no active value found ;JRB - I think classes are also OK here.") (ERROR "Can't find the active value, so can't replace it")) ((EQ self (fetch annotatedValue of localValue)) (* ; "The active value to replace is the local value") (SELECTQ type ((NIL IV) (PutValueOnly containingObject varName newVal propName)) ((CV CLASS) (PutClassValueOnly containingObject varName newVal propName)) (METHOD (PutMethodOnly containingObject varName newVal propName)) (HELPCHECK "Unknown access type" type))) ((AND (MEMB type (QUOTE (NIL IV))) (NotSetValue localValue)) (* ; "The active value must be inherited") (LET ((classValue (GetClassIV (Class containingObject) varName propName))) (COND ((NOT (type? annotatedValue classValue)) (* ; "Don't know where the active value is") (ERROR "Can't find the active value, so can't replace it")) ((EQ self (fetch annotatedValue of classValue)) (* ; "No need to copy the default value, since it is just the active value") (PutValueOnly containingObject varName newVal propName)) (T (* ; "Have to copy the default value down, since the desired active value is nested") (LET ((avCopy (_AV classValue CopyActiveValue classValue))) (PutValueOnly containingObject varName avCopy propName) (* ; "Then retry it") (_AV avCopy ReplaceNestedActiveValue self newVal containingObject varName propName type)))))) (T (* ; "The active value must be nested;JRB  there used to be a (|fetch| |annotatedValue| |of| |localValue|) below; I believe it was a bug") (_AV localValue ReplaceNestedActiveValue self newVal containingObject varName propName type)))))(Method ((ActiveValue ReplaceNestedActiveValue) self containedAVObj newVal containingObj varName propName type) (* ; "smL 15-Apr-87 13:59") "Replace the nested active value containedAVObj in self with newVal" (LET ((localState (_ self GetWrappedValueOnly))) (if (NOT (type? annotatedValue localState)) then (* Not found) (ERROR "Can't find the active value, so can't replace it") elseif (EQ containedAVObj (fetch annotatedValue of localState)) then (* Found it) (_ self PutWrappedValueOnly newVal) else (* Look still deeper) (_AV localState ReplaceNestedActiveValue containedAVObj newVal containingObj varName propName type))))(Method ((ActiveValue WrapOutside?) self activeValue) (* ; "smL  1-May-86 17:27") "Should self be wrapped around the activeValue, or nested inside? Return TRUE iff self should be wrapped around, FALSE if nested." (LET ((myPrecedence (_ self WrappingPrecedence)) (otherPrecedence (_ activeValue WrappingPrecedence))) (if (OR (AND (NULL myPrecedence) (NULL otherPrecedence)) (AND (EQ myPrecedence T) (EQ otherPrecedence T))) then (HELPCHECK "Conflicting active value wrapping precedence" self activeValue otherPrecedence) elseif (OR (NULL myPrecedence) (EQ otherPrecedence T)) then NIL elseif (OR (EQ myPrecedence T) (NULL otherPrecedence)) then T else (GREATERP myPrecedence otherPrecedence))))(Method ((ActiveValue WrappingPrecedence) self) (* ; "smL  1-May-86 17:38") "What is the wrapping precedence for this active value? The larger the number, the more the active value wants to be on the outside. NIL forces innermost nesting, T forces outermost nesting." 100)(Method ((AppendSuperValue CopyActiveValue) self annotatedValue) (* ; "smL  8-May-86 18:23") "Copy the annotatedValue containing self" (if annotatedValue then annotatedValue else (create annotatedValue annotatedValue _ self)))(Method ((AppendSuperValue GetWrappedValue) self containingObj varName propName type) (* ; "smL  9-May-86 09:45") "Fetch the value wrapped in the active value" (APPEND (_ self InheritedValue containingObj varName propName type) (_Super)))(Method ((ExplicitFnActiveValue AVPrintSource) self) (* ; "smL  2-Jan-86 16:45") "Construct the print-source for the ExplicitFnActiveValue so it can be read back in by the #. macro" (LIST (CONCAT LoopsReadMacroChar ",") (QUOTE $A) (GetIVHere self (QUOTE localState)) (@ getFn) (@ putFn)))(Method ((ExplicitFnActiveValue GetWrappedValue) self containingObj varName propName type) (* ; "smL  2-May-86 10:53") "Fetch the value wrapped in the active value" (LET ((getFn (@ getFn)) (localState (_Super))) (if getFn then (APPLY* getFn containingObj varName localState propName self type) else localState)))(Method ((ExplicitFnActiveValue PutWrappedValue) self containingObj varName newValue propName type) (* ; "smL 23-Sep-85 17:26") "Specialization" (LET ((putFn (@ putFn))) (if putFn then (* This is not right!!!) (APPLY* putFn containingObj varName newValue propName self type) else (_Super))))(Method ((FirstFetchAV AVPrintSource) self) (* ; "smL 19-Jun-86 11:34") "Construct the print-source for the ActiveValue so it can be read back in by the #. macro" (CONS (CONCAT LoopsReadMacroChar ",") (BQUOTE (Defer (\, (@ localState))))))(Method ((FirstFetchAV GetWrappedValue) self containingObj varName propName type) (* ; "smL 14-Apr-87 17:23") "A FirstFetchAV evaluates the local state and replaces the active value with the result" (_ self PutWrappedValue containingObj varName (EVAL (_Super)) propName type))(Method ((IndirectVariable AddActiveValue) self containingObj varName propName type annotatedValue) "Add an IndirectVariable ActiveValue to an object" (* ;;; "The super method here will trigger the indirect variable on installation and smash the thing it's supposed to be tracking.  The trick is to GetItOnly the remote variable, smash it to NIL (to keep any ActiveValues on it from triggering), let the super smash that, then PutItOnly to restore the original value (yuck).") (LET ((trackedVal (GetItOnly (@ object) (@ varName) (@ propName) (@ type)))) (CL:UNWIND-PROTECT (PROGN (PutItOnly (@ object) (@ varName) NIL (@ propName) (@ type)) (_Super self AddActiveValue containingObj varName propName type annotatedValue)) (PutItOnly (@ object) (@ varName) trackedVal (@ propName) (@ type)))))(Method ((IndirectVariable GetWrappedValueOnly) self) (* ; "smL 13-Aug-86 17:44") "Fetch the value wrapped in the active value without triggereing any side-effects." (SELECTQ (@ type) ((NIL IV) (GetValueOnly (@ object) (@ varName) (@ propName))) (CV (GetClassValueOnly (@ object) (@ varName) (@ propName))) (HELPCHECK "Invalid type" (@ type))))(Method ((IndirectVariable PutWrappedValueOnly) self newValue) (* ; "smL 18-Jun-86 18:10") "Replace the value wrapped in the active value without triggereing any side-effects." (SELECTQ (@ type) ((NIL IV) (PutValueOnly (@ object) (@ varName) newValue (@ propName))) (CV (PutClassValueOnly (@ object) (@ varName) newValue (@ propName))) (HELPCHECK "Invalid type" (@ type))))(Method ((IndirectVariable WrappingPrecedence) self) "What is the wrapping precedence for this active value? The larger the number, the more the active value wants to be on the outside. NIL forces innermost nesting, T forces outermost nesting." (* ;; "JRB this fixes AR 9181 ") 50)(Method ((InheritingAV InheritedValue) self containingObj varName propName type) (* ; "smL 17-Apr-87 09:38") "What value would have been inherited had this active value not been in the way?" (LET* ((class (if (type? instance containingObj) then (Class containingObj) else containingObj)) (superWithAV (for super in-supers-of class bind valueFromClass thereis (SETQ valueFromClass (SELECTQ type ((NIL IV) (GetClassIVHere super varName propName)) (CV (GetCVHere super varName propName)) (LoopsHelp type "not a valid variable type"))) (AND (NOT (NotSetValue valueFromClass)) (type? annotatedValue valueFromClass) (_AV valueFromClass HasAV? self)))) (remainingSupers (if superWithAV then (CDR (MEMB superWithAV (CONS class (Supers class)))) else (CONS class (Supers class))))) (for super in remainingSupers bind valueFromClass when (SELECTQ type ((NIL IV) (_ super HasIV varName)) (CV (_ super HasCV varName)) (LoopsHelp type "not a valid variable type")) do (SETQ valueFromClass (SELECTQ type ((NIL IV) (GetClassIV super varName propName)) (CV (GetCVHere super varName propName)) (LoopsHelp type "not a valid variable type"))) (if (NOT (NotSetValue valueFromClass)) then (* ; "Got a real value") (RETURN (ExtractRealValue containingObj varName valueFromClass propName type))) finally (RETURN NoValueFound))))(Method ((LocalStateActiveValue DeleteActiveValue) self containingObj varName propName type) (* ; "smL 14-Jan-87 17:40") "Remove the active value self from the specified variable. - Return the deleted annotatedValue or NIL if the active value was not found" (PROG1 (_Super) (if (AND (MEMB type (QUOTE (NIL IV))) (EQ NestedNotSetValue (GetIVHere containingObj varName propName))) then (PutValueOnly containingObj varName NotSetValue propName))))(Method ((LocalStateActiveValue GetWrappedValueOnly) self) (* ; "smL  5-May-86 17:16") "Fetch the value wrapped in the active value without triggereing any side-effects." (GetValueOnly self (QUOTE localState)))(Method ((LocalStateActiveValue NewInstance) self name arg1 arg2 arg3 arg4 arg5) (* ; "smL 14-Jan-87 17:43") "This allows initialization by the classes of objects themselves, rather than going to a metaClass" (PROG1 (_Super) (* There is a problem with having no local value for the localState IV - If the active value is inheirited from the class of the containing object, you get a stack overflow when you try to fetch the iv of the containing object. - Here's what happens%: first, the AV is copied from the class into the instance. Then the GetWrappedValue msg is sent to the av. It gets the local state of its localState IV, notices that it is an active value, and triggers it as if it were local to the outside object. But this activevalue is NotSetValue, which starts the whole process over again... - We avoid this all by copying down the inherited value when the object is first created. This means that the localState IV no longer tracks the value in the class, but what can you do?) (if (NotSetValue (GetValueOnly self (QUOTE localState))) then (LET ((classValue (GetValue (Class self) (QUOTE localState)))) (PutValueOnly self (QUOTE localState) (if (AnnotatedValue? classValue) then (_AV classValue CopyActiveValue classValue) else classValue))))))(Method ((LocalStateActiveValue PutWrappedValueOnly) self newValue) (* ; "smL 14-Jan-87 17:44") "Replace the value wrapped in the active value without triggereing any side-effects." (PutValueOnly self (QUOTE localState) (if (NotSetValue newValue) then NestedNotSetValue else newValue)))(Method ((NestedNotSetValue AVPrintSource) self) (* ; "smL 14-Jan-87 17:39") "Construct the print-source for the ActiveValue so it can be read back in by the #. macro" (CONS (CONCAT LoopsReadMacroChar ",") (QUOTE NestedNotSetValue)))(Method ((NoUpdatePermittedAV PutWrappedValue) self containingObj varName newValue propName type) (* ; "smL  7-May-86 13:49") "Replace the value wrapped in the active value" (ERROR "No update permitted!"))(Method ((NotSetValue AVPrintSource) self) (* ; "smL 14-Apr-86 18:35") "Construct the print-source for the ActiveValue so it can be read back in by the #. macro" (CONS (CONCAT LoopsReadMacroChar ",") (QUOTE NotSetValue)))(Method ((NotSetValue CopyActiveValue) self annotatedValue) (* ; "smL 18-Apr-86 14:56") "Copy the annotatedValue containing self" annotatedValue)(Method ((NotSetValue GetWrappedValue) self containingObj varName propName type) (* ; "smL  5-May-86 11:08") "Fetch the value of the ActiveValue" (SELECTQ type ((IV NIL) (_ containingObj IVValueMissing varName propName (QUOTE GetValue))) (CV (_ (if (type? class containingObj) then containingObj else (Class containingObj)) CVValueMissing varName propName (QUOTE GetValue))) (METHOD NotSetValue) (CLASS NotSetValue) (HELPCHECK "Unknown access type " type)))(Method ((NotSetValue GetWrappedValueOnly) self) (* ; "smL  5-May-86 17:16") "Fetch the value wrapped in the active value without triggereing any side-effects." NotSetValue)(Method ((NotSetValue HasAV?) self av) (* ; "smL  8-May-86 14:36") "Is the given active value nested inside of self, or eq to self?" (if (type? annotatedValue av) then (EQ av NotSetValue) else (EQ av self)))(Method ((NotSetValue PutWrappedValue) self containingObj varName newValue propName type) (* ; "smL 18-Sep-86 14:31") "Replace the value of the local state" (SELECTQ type ((IV NIL) (_ containingObj IVValueMissing varName propName (QUOTE PutValue) newValue)) (CV (PutClassValueOnly (if (type? class containingObj) then containingObj else (Class containingObj)) varName newValue propName)) (METHOD (PutMethodOnly containingObj varName newValue propName)) (CLASS (if (NULL varName) then (PutClassOnly containingObj newValue propName) else (PutClassValueOnly containingObj varName newValue propName))) (HELPCHECK "Unknown access type " type)))(Method ((NotSetValue PutWrappedValueOnly) self newValue) (* ; "smL  5-May-86 17:17") "Replace the value wrapped in the active value without triggereing any side-effects." (HELPCHECK "Can't set the local state of #.NotSetValue"))(Method ((NotSetValue WrappingPrecedence) self) (* ; "smL  1-May-86 17:27") "What is the wrapping precedence for this active value? The larger the number, the more the active value wants to be on the outside. NIL forces innermost nesting, T forces outermost nesting." NIL)(Method ((ReplaceMeAV PutWrappedValue) self containingObj varName newValue propName type) (* ; "smL  7-May-86 12:30") "Replace the value wrapped in the active value" (_ self ReplaceActiveValue newValue containingObj varName propName type) newValue)(\UnbatchMethodDefs)(* ;;; "Fix NotSetValue.  It was given a bogus value earlier for bootstraping purposes;  now give it the right value")(replace annotatedValue of NotSetValue with (_ ($ NotSetValue) Prototype))(* ;;; "Set up the WrappedNotSetValue")(RPAQ? NestedNotSetValue (create annotatedValue annotatedValue _ (_ ($ NestedNotSetValue) Prototype)))(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS NestedNotSetValue))(* ;;; "The _AV macro")(DEFMACRO _AV (annotatedValue message &REST args) (* * Send the message to the active value contained in the annotatedValue) (BQUOTE (_ (fetch annotatedValue of (\, annotatedValue)) (\, message) (\,. args))))(ADDTOVAR PRETTYPRINTMACROS (_AV . PrettyPrintLoopsForm))(* ;;; "Set up for automatic translation from annotatedValues to their active values")(DEFCLASSES AnnotatedValue)(DEFCLASS AnnotatedValue   (MetaClass AbstractClass Edited%: (* smL " 5-May-86 13:13") doc (* The Loops class for the Lisp datatype annotatedValue. If you should attept to treat an annotatedValue as a Loops object, this class will determine its behavior)) (Supers Tofu))(\BatchMethodDefs)(METH AnnotatedValue  MessageNotUnderstood (selector messageArguments superFlg)      "Forward the message on to the wrapped active value" (category (Tofu)))(METH AnnotatedValue  GetValue (varName propName)      "Get the value of an iv from self" (category (AnnotatedValue)))(Method ((AnnotatedValue MessageNotUnderstood) self selector messageArguments superFlg) (* ; "smL  5-May-86 13:22") "Forward the message on to the wrapped active value" (APPLY (FetchMethodOrHelp (fetch annotatedValue of self) selector) (CONS (fetch annotatedValue of self) (CDR messageArguments))))(Method ((AnnotatedValue GetValue) self varName propName) (* ; "smL  8-Apr-87 14:56") "Get the value of an iv from self" (GetValue (fetch annotatedValue of self) varName propName))(\UnbatchMethodDefs)(PUTHASH (QUOTE annotatedValue) ($ AnnotatedValue) LispClassTable)(* ;;; "Defered values")(DEFMACRO Defer (form) (* * Defer evaluation of the form until it is fetched out of an IV) (BQUOTE (\Defer (QUOTE (\, form)))))(DEFINEQ(\Defer  (LAMBDA (form)                                             (* smL "19-Jun-86 11:32")                    (* * Create an active value that will evaluate the defered form when the           variable is first accessed.)    (LET ((deferedObject (_ ($ FirstFetchAV)                            New)))         (change (@ deferedObject localState)                form)         (create annotatedValue                annotatedValue _ deferedObject)))))(* ;;; "For ExplicitFnActiveValue avs")(DEFINEQ(DefAVP  (LAMBDA (fnName putFlg)                                    (* mjs%: "17-FEB-83 12:52")                    (* Defines a form for an active value procedure, and throws you in the editor           to complete it. putFlg is used to determine if a newValue argument should be           used)    (DEFINE (SUBPAIR '(fnName) (LIST fnName)                   (COND                      (putFlg '((fnName (self varName newValue propName activeVal type)                    (* This is a putFn. ***NOTE*** The value of this function will be returned as           the value of any enclosing PutValue. This usually means that you want to return           the value returned by PutLocalState.)                                       (PutLocalState activeVal newValue self varName propName type))                                ))                      (T '((fnName (self varName localSt propName activeVal type)                    (* This is a getFn. The value of this getFn is returned as the value of the           enclosing GetValue.)                                  localSt))))                   T))    (APPLY* 'EDITF fnName))))(* ;;; "Editing AnnotatedValues")(DEFINEQ(AnnotatedValueEditSource  (LAMBDA (annotatedValue)                                   (* smL " 3-Oct-85 14:52")                    (* * Make a list for the structure editor to use)    (ObjSource (fetch annotatedValue of annotatedValue))))(AnnotatedValueInstallEditSource  (LAMBDA (annotatedValue expr)                              (* smL " 3-Oct-85 14:52")                    (* * Install the edited source for the annotated value)    (ObjInstallSource (fetch annotatedValue of annotatedValue)           expr))))(ADDTOVAR DT.EDITMACROS (annotatedValue AnnotatedValueEditSource AnnotatedValueInstallEditSource))(* ;;; "Printing and reading annotated values")(DEFINEQ(PrintAnnotatedValue  (LAMBDA (av file)                                          (* smL "20-May-86 14:57")                    (* * Print an active value to the current output file.          Set up by a calls to DEFPRINT)    (_ (fetch annotatedValue of av)       AVPrintSource)))($A  (NLAMBDA (localState getFn putFn)                          (* edited%: " 3-Apr-86 17:45")                    (* * Used to read in ExplicitFnActiveValues)    (LET ((avObj (_ ($! DefaultActiveValueClassName)                    New)))         (PutValueOnly avObj 'localState localState)         (PutValueOnly avObj 'getFn getFn)         (PutValueOnly avObj 'putFn putFn)         (create annotatedValue                annotatedValue _ avObj))))($AV  [NLAMBDA L                                                 (* ; "Edited  1-Nov-87 20:58 by jrb:")(* ;;; "Used to read back in an ActiveValue --- see HashMacro")    (LET ((className (CAR L))          (names (CADR L))          (descr (CDDR L))          obj class)                    (* ;; "Set up the class of the active value object")         (SETQ class (GetClassRec className))         [COND            ((NULL class)                                    (* ; "")             (printout T className " has no class defined for it" T "Defining one now:" T)             (SETQ class (_ ($ Class)                            New className '(ActiveValue))]   (* ;                                                           "Set up the UID of the active value object")         [SETQ obj (LET [(UID (COND                                 ((LISTP names)              (* ; "Last one is UID")                                  (SETQ names (REVERSE names))                                  (pop names))                                 (T (PROG1 names (SETQ names NIL]                        (OR (GetObjFromUID UID)                            (NewObject class UID)                            (BlankInstance class obj]         (COND            (descr (AND names (NameObject obj names))                   (FillInst descr obj)))         (create annotatedValue                annotatedValue _ obj]))(RPAQ? DefaultActiveValueClassName (QUOTE ExplicitFnActiveValue))(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS DefaultActiveValueClassName))(DEFPRINT (QUOTE annotatedValue) (QUOTE PrintAnnotatedValue))(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA $AV)(ADDTOVAR NLAML $A)(ADDTOVAR LAMA))(PUTPROPS LOOPSACTIVEVALUES COPYRIGHT ("Venue & Xerox Corporation" 1985 1986 1987 1988 1990))(DECLARE%: DONTCOPY  (FILEMAP (NIL (37131 37603 (\Defer 37141 . 37601)) (37652 38810 (DefAVP 37662 . 38808)) (38853 39389 (AnnotatedValueEditSource 38863 . 39106) (AnnotatedValueInstallEditSource 39108 . 39387)) (39546 41761 (PrintAnnotatedValue 39556 . 39841) ($A 39843 . 40299) ($AV 40301 . 41759)))))STOP