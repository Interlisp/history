(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "LISP")(il:filecreated "13-Jun-90 14:47:51" il:|{PELE:MV:ENVOS}<LISPCORE>SOURCES>DEFSTRUCT.;4| 55356        il:|changes| il:|to:|  (il:structures ps) (il:variables %defstruct-options %defstruct-export-options) (il:functions define-accessors define-constructors define-copiers defstruct-parse-options ensure-consistent-ps establish-accessors process-type)      il:|previous| il:|date:| " 8-Jun-90 13:23:15" il:|{PELE:MV:ENVOS}<LISPCORE>SOURCES>DEFSTRUCT.;3|); Copyright (c) 1986, 1987, 1900, 1988, 1989, 1990 by Venue & Xerox Corporation.  All rights reserved.(il:prettycomprint il:defstructcoms)(il:rpaqq il:defstructcoms ((il:* il:|;;;| "Implementation of Structure facilities of Commmon Lisp.  (Chapter 19 of CLtL).") (il:* il:|;;;| "public interface ") (il:define-types il:structures) (il:functions defstruct) (il:* il:|;;;| "top-level ") (il:declare\: il:docopy il:donteval@load (il:files il:defstruct-run-time)) (il:* il:|;;;| "parsing code") (il:variables %default-defstruct-type %default-slot-type %default-structure-include %defstruct-options %no-constructor %no-predicate %no-copier %defstruct-consp-options %defstruct-export-options) (il:functions assign-slot-accessor remove-documentation record-documentation ensure-valid-type parse-slot defstruct-parse-options ensure-consistent-ps ps-number-of-slots ps-type-specifier) (il:* il:|;;;| "slot resolution code") (il:functions assign-slot-offset resolve-slots insert-included-slot merge-slots name-slot dummy-slot offset-slot) (il:* il:|;;;| "data layout code") (il:functions assign-structure-representation coerce-type %structure-type-to-fieldspec assign-field-descriptors structure-pointer-slots) (il:* il:|;;;| "type system hooks") (il:functions process-type predicate-body type-expand-structure type-expand-named-structure ps-name-slot-position default-predicate-name defstruct-shared-predicate-optimizer cache-predicate-info) (il:variables %function-defining-form-keywords) (il:* il:|;;;| "accessors and setfs") (il:functions setf-name) (il:functions accessor-body process-accessors establish-accessors define-accessors defstruct-shared-accessor-optimizer defstruct-shared-setf-expander cache-slot-info) (il:functions %make-accessor-closure %make-list-accessor %make-array-accessor %make-pointer-accessor %make-bit-accessor %make-flag-accessor %make-word-accessor %make-fixp-accessor %make-small-fixp-accessor %make-float-accessor) (il:* il:|;;;| "constructor definition code") (il:functions define-constructors define-boa-constructor argument-names boa-arg-list-with-initial-values boa-slot-setfs find-slot raw-constructor build-constructor-arglist build-constructor-slot-setfs boa-constructor-p default-constructor-name) (il:* il:|;;;| "copiers") (il:functions define-copiers build-copier-slot-setfs build-copier-type-check) (il:* il:|;;;| "print functions") (il:variables %default-print-function) (il:* il:|;;;| "internal stuff.") (il:setfs il:ffetchfield) (il:* il:|;;;| "utilities") (il:functions defstruct-assert-subtypep) (il:* il:|;;;| "inspecting structures") (il:functions structure-object-p inspect-structure-object structure-object-inspect-fetchfn structure-object-inspect-propprintfn structure-object-inspect-storefn structure-object-propcommandfn) (il:* il:|;;| "Defined last so functions required to load a defstruct are loaded first") (il:structures ps parsed-slot) (il:* il:|;;| "Mapping between names of generated functions and their associated structures") (il:functions structure-function-p structure-functions) (il:* il:|;;;| "Editing structures") (il:functions structures.hasdef structures.editdef) (il:p (il:filepkgtype (quote il:structures) (quote il:hasdef) (quote structures.hasdef) (quote il:editdef) (quote structures.editdef))) (il:addvars (il:shadow-types (il:structures il:fns))) (il:declare\: il:docopy il:donteval@load (il:addvars (il:inspectmacros ((il:function structure-object-p) . inspect-structure-object)))) (il:* il:|;;;| "file properties") (il:prop il:filetype il:defstruct) (il:prop il:makefile-environment il:defstruct)))(il:* il:|;;;| "Implementation of Structure facilities of Commmon Lisp.  (Chapter 19 of CLtL).")(il:* il:|;;;| "public interface ")(xcl:def-define-type il:structures "Common Lisp structures")(xcl:defdefiner (defstruct (:name (lambda (whole) (let ((name-and-options (second whole))) (if (consp name-and-options) (car name-and-options) name-and-options)))) (:prototype (lambda (name) (and (symbolp name) (il:bquote (defstruct ((il:\\\, name) (":option" "value")) "documentation string" ("slot-name" "initial-value"))))))) il:structures (name &rest slot-descriptions) (let* ((ps (defstruct-parse-options name)) (slot-descriptions (remove-documentation ps slot-descriptions))) (resolve-slots slot-descriptions ps) (il:bquote (progn (eval-when (eval compile load) (setf (parsed-structure (quote (il:\\\, (ps-name ps))) t) (quote (il:\\\, ps)))) (il:\\\,@ (assign-structure-representation ps)) (il:\\\,@ (process-type ps)) (il:\\\,@ (process-accessors ps)) (eval-when (eval compile load) (establish-setfs-and-optimizers (quote (il:\\\, (ps-name ps))))) (il:\\\,@ (define-constructors ps)) (il:\\\,@ (define-copiers ps)) (il:\\\,@ (record-documentation ps))))))(il:* il:|;;;| "top-level ")(il:declare\: il:docopy il:donteval@load (il:filesload il:defstruct-run-time))(il:* il:|;;;| "parsing code")(defvar %default-defstruct-type (quote datatype) "The type of structures when no :type option is specified")(defvar %default-slot-type (quote t) "the type of any slot which does not specifiy a :type option")(defconstant %default-structure-include (quote structure-object) "datatype included by every structure")(defparameter %defstruct-options (quote (:conc-name :constructor :copier :predicate :include :print-function :type :initial-offset :named :inline :fast-accessors :template :export)))(defconstant %no-constructor (quote :none) "the value which says that no constructor was specified.")(defconstant %no-predicate (quote :none) "the value which says that no constructor was specified")(defconstant %no-copier (quote :none))(defparameter %defstruct-consp-options (remove (quote :named) %defstruct-options))(defparameter %defstruct-export-options (quote (:accessor :constructor :predicate :copier)))(defun assign-slot-accessor (slot conc-name) (il:* il:|;;| "assigns the accessor name to a slot") (if (pslot-accessor slot) (setf (pslot-accessor slot) (values (intern (concatenate (quote string) (string conc-name) (string (pslot-name slot))))))))(defun remove-documentation (ps slot-descriptions) (il:* il:|;;| "Records it if there is any documentation string.") (let ((doc? (car slot-descriptions))) (cond ((stringp doc?) (il:* il:|;;| " save it and return the rest of the slots.") (setf (ps-documentation-string ps) doc?) (rest slot-descriptions)) (t (il:* il:|;;| "no doc string, return the whole thing.") slot-descriptions))))(defun record-documentation (ps) (il:* il:|;;| "Returns a form which saves the documentation string for a structure.") (let ((parsed-docstring (ps-documentation-string ps))) (if parsed-docstring (il:bquote ((setf (documentation (quote (il:\\\, (ps-name ps))) (quote structure)) (il:\\\, parsed-docstring)))))))(defun ensure-valid-type (type-form) (il:* il:|;;| "Bogus right now ") type-form)(defun parse-slot (description &optional (generate-accessor t)) (il:* il:|;;| "Takes a slot description from the defstruct body or included slots and returns a parsed version") (let* ((description (if (consp description) description (list description))) (slot (make-parsed-slot))) (xcl:destructuring-bind (name &optional initial-value &rest slot-options) description (if (symbolp name) (setf (pslot-name slot) name) (error "Slot name not symbol: ~S" name)) (setf (pslot-initial-value slot) initial-value) (il:* il:|;;| "some variant of PCL's keyword-bind would be easier here, but it's incapable of producing reasonable error msgs for the user.  Maybe later.") (do ((option-pair slot-options (cddr option-pair))) ((null option-pair)) (case (car option-pair) (:type (setf (pslot-type slot) (ensure-valid-type (cadr option-pair)))) (:read-only (setf (pslot-read-only slot) (and (cadr option-pair) t))) (otherwise (if (keywordp initial-value) (error "Initial value must be specified to use slot options. ~S" description) (error "Illegal slot option ~S in slot ~S" (car option-pair) name))))) (if generate-accessor (setf (pslot-accessor slot) t))) slot))(defun defstruct-parse-options (name&options) (il:* il:|;;| "Returns a structure representing the options in a defstruct call.") (let* ((options (if (listp name&options) name&options (list name&options))) (name (pop options)) (ps (make-ps :name name :conc-name (concatenate (quote string) (string name) "-")))) (dolist (option options) (cond ((listp option) (xcl:destructuring-bind (option-keyword &optional (option-value nil argument-provided) &rest further-arguments) option (case option-keyword (:conc-name (il:* il:|;;| "if the option is specified, but the option value is nil, then use the empty string as conc-name") (setf (ps-conc-name ps) (or option-value ""))) (:constructor (il:* il:|;;| "multiple constructors are allowed.  If NIL is provided, then define no constructor.") (cond ((not option-value) (if argument-provided (il:* il:|;;| "NIL was specified.  Record that no constructor is to be built.") (setf (ps-constructors ps) nil) (il:* il:|;;| "otherwise, it as though the option weren't specified (p. 312 cltl) so leave the default value there."))) ((eq (ps-constructors ps) %no-constructor) (il:* il:|;;| "this is the first constructor specified.  Make the field be a list now.") (setf (ps-constructors ps) (list (if further-arguments (cdr option) option-value)))) (t (il:* il:|;;| "just push another one on the list of constructors.") (push (if further-arguments (cdr option) option-value) (ps-constructors ps))))) (:copier (il:* il:|;;| "if the argument is specified (even if it is nil), use it.  Otherwise use the default COPY- form already in the ps.") (if argument-provided (setf (ps-copier ps) option-value))) (:predicate (if argument-provided (setf (ps-predicate ps) option-value))) (:include (setf (ps-include ps) option-value) (il:* il:|;;| "if there are any included slots record them") (setf (ps-included-slots ps) (cddr option))) (:print-function (cond ((and argument-provided (null option-value)) (il:* il:|;;| "extension to CLtL, if NIL is specified as the defprint, then the internal print function is specified.") (setf (ps-print-function ps) (quote il:\\print-using-address))) (argument-provided (setf (ps-print-function ps) option-value)))) (:type (setf (ps-type ps) (cond ((eq option-value (quote list)) (quote list)) ((eq option-value (quote vector)) (il:* il:\; "default the vector type to t") (setf (ps-vector-type ps) t) (quote vector)) ((and (consp option-value) (eq (car option-value) (quote vector))) (setf (ps-vector-type ps) (il:%get-canonical-cml-type (cadr option-value))) (quote vector)) (t (error "the specified :type is not list or subtype of vector: ~S" option-value))))) (:initial-offset (if (not (typep option-value (quote (integer 0 *)))) (error ":initial-offset isn't a non-negative integer: ~S" option-value)) (setf (ps-initial-offset ps) option-value)) (:inline (il:* il:|;;| "Is one or both of  :accessor, and  :predicate or t, which is equivalent to both") (il:* il:|;;| "Default is '(:accessor :predicate) ") (il:* il:|;;| "option (:inline :only) implies no funcallable accessors or predicate is generated") (if argument-provided (setf (ps-inline ps) option-value))) (:fast-accessors (il:* il:|;;| "Is either t or nil,  t implying no type checks for all accessors") (if argument-provided (setf (ps-fast-accessors ps) option-value))) (:template (il:* il:|;;| "Is either t or nil -- t  implying type datatype, no copier, predicate, print-function or constructors, and fast accessors, and no new datatype declared.") (if argument-provided (setf (ps-template ps) option-value))) (:export (il:* il:|;;| "Edited by TT(13-June-90) Export Option is added for DEFSTRUCT(Medley 1.2). The Specified functions(ex. :constructor, :copier...) will be exported.") (if further-arguments (error "The specified export functions is not list or atom : ~S" (cons :export (cons option-value further-arguments))) (if argument-provided (setf (ps-export ps) option-value) (setf (ps-export ps) t)))) (otherwise (error "Bad option to defstruct: ~S." option))))) (t (case option (:named (setf (ps-named ps) t)) (otherwise (if (member option %defstruct-consp-options :test (function eq)) (error "defstruct option ~s must be in parentheses with its value" option) (error "Bad option to defstruct: ~S." option))))))) (ensure-consistent-ps ps) ps))(defun ensure-consistent-ps (ps) (il:* il:|;;| "Accomplishes the consistency checks that can't occur until all the options have been parsed.") (if (ps-include ps) (let* ((include (ps-include ps)) (included-pstructure (parsed-structure include))) (il:* il:|;;| "ensure that the user is not suicidal.  If a structure includes itself, a *very* tight ucode loop will  occur in the instancep opcode.") (if (eq include (ps-name ps)) (error "You probably don't want ~S to include ~S." include include)) (il:* il:|;;| "ensure that the included structure is defined.") (if (or (null included-pstructure) (ps-template included-pstructure)) (error "Included structure ~s is unknown or not instantiated." include)) (il:* il:|;;| "make sure the type of the included structure is the same") (if (or (not (eq (ps-type included-pstructure) (ps-type ps))) (not (eq (ps-vector-type included-pstructure) (ps-vector-type ps)))) (error "~s must be same type as included structure ~s" (ps-name ps) include)))) (let ((inline (ps-inline ps)) (possible-keywords (quote (:accessor :predicate)))) (case inline ((t) (il:* il:|;;| "this is the default case, so make the default be that only the accessors, predicates are inline.") (setf (ps-inline ps) possible-keywords)) ((nil :only)) (otherwise (mapcar (function (lambda (keyword) (if (not (member keyword possible-keywords :test (function eq))) (error "~s must be one of ~s." keyword possible-keywords)))) (if (consp inline) inline (setf (ps-inline ps) (list inline))))))) (cond ((ps-template ps) (if (not (eq (ps-type ps) %default-defstruct-type)) (error "Templated defstructs may not be of type: ~s" (ps-type ps))) (if (or (not (eq (ps-constructors ps) %no-constructor)) (not (eq (ps-predicate ps) %no-predicate)) (not (eq (ps-copier ps) %no-copier)) (ps-print-function ps)) (error "Templated defstructs may not have constructors predicates copiers or print functions"))) (t (if (ps-print-function ps) (if (not (eq (ps-type ps) %default-defstruct-type)) (error "A print-function can't be specified for structures of type ~s" (ps-type ps))) (let ((include (ps-include ps))) (if include (il:* il:|;;| "CLtL is silent, but we inherit print-functions") (setf (ps-print-function ps) (ps-print-function (parsed-structure include))) (il:* il:|;;| "otherwise, use the default #s style printer") (setf (ps-print-function ps) %default-print-function)))) (if (and (eq (ps-type ps) (quote vector)) (eq (ps-named ps) t)) (il:* il:|;;| "check that the vector type can actually hold the symbol required for the name.") (defstruct-assert-subtypep (quote symbol) (ps-vector-type ps) ("vector of ~S cannot contain the symbol required for the :named options" (ps-vector-type ps)))) (if (eq (ps-predicate ps) %no-predicate) (il:* il:|;;| "there is no predicate. (Note that this is not a null check.  If this field is NIL the user explicitly gave NIL as the predicate.)  ") (if (or (eq (ps-type ps) (quote datatype)) (ps-named ps)) (il:* il:|;;| "If this structure is type datatype or named, use the default name") (setf (ps-predicate ps) (default-predicate-name (ps-name ps))) (il:* il:|;;| "now set it to NIL to signal no predicate to the predicate builder.") (setf (ps-predicate ps) nil))) (if (eq (ps-copier ps) %no-copier) (il:* il:|;;| "Note that this is not a null check.  If this field is NIL the user explicitly gave NIL as the copier  ") (setf (ps-copier ps) (intern (concatenate (quote string) "COPY-" (string (ps-name ps)))))) (let ((exportnames (ps-export ps))) (il:* il:|;;| "If export-slot is nil, functions will not be exported. otherwise, export the specified functions.[Edited by TT (13-June-90)") (and exportnames (or (eq exportnames t) (and (not (listp exportnames)) (not (setf (ps-export ps) (setq exportnames (list exportnames))))) (dolist (exportname exportnames t) (or (member exportname %defstruct-export-options) (error "~S is not valid option keyword for :EXPORT" exportname)))))) (cond ((eq (ps-constructors ps) %no-constructor) (il:* il:|;;| "There were no constructors specified.  Default the value.") (setf (ps-constructors ps) (il:bquote ((il:\\\, (default-constructor-name (ps-name ps)))))))))))(defun ps-number-of-slots (ps) "the number of slots in an instance of this structure" (length (ps-all-slots ps)))(defun ps-type-specifier (ps) "returns list, vector, or (vector foo)" (ecase (ps-type ps) (list (quote list)) (vector (let ((element-type (ps-vector-type ps))) (if (il:neq element-type t) (il:bquote (vector (il:\\\, element-type))) (quote vector))))))(il:* il:|;;;| "slot resolution code")(defun assign-slot-offset (ps) (il:* il:|;;| "Assigns the offsets for each slot for type vector and list.") (let* ((name (ps-name ps)) (slots (ps-all-slots ps))) (ecase (ps-type ps) ((vector list) (il:* il:|;;| "the field descriptor is just the offset.") (do ((i 0 (1+ i)) (slot slots (cdr slot))) ((null slot)) (setf (pslot-field-descriptor (car slot)) i))))))(defun resolve-slots (local-slot-descriptions ps) (il:* il:|;;| "Combines the slot descriptions from the defstruct call with the included slot-descriptions from supers and the :includes option, and installs the decription in the parsed-structure") (let ((local-slots (mapcar (function parse-slot) local-slot-descriptions)) (included-slots (mapcar (function parse-slot) (ps-included-slots ps))) (includes (ps-include ps))) (when (ps-named ps) (il:* il:|;;| "Adds the slot representing the name pseudo-slot. ") (if (not (ps-named ps)) (error ":named not supplied for this defstruct")) (push (name-slot ps) local-slots)) (when (not (eq 0 (ps-initial-offset ps))) (il:* il:|;;| "Adds parsed-slots to the local-slots to represent the initial offset.") (setq local-slots (nconc (xcl:with-collection (dotimes (i (ps-initial-offset ps)) (xcl:collect (offset-slot)))) local-slots))) (if includes (let ((super-slots (il:* il:|;;| "must copy the slots, since the accessor-name will be destructively modified to use the new conc-name.") (mapcar (function copy-parsed-slot) (ps-all-slots (parsed-structure includes))))) (il:* il:|;;| "update the super-slots according to the included-slots, then make all-slots be (append merged-slots local-slots)") (setf (ps-all-slots ps) (nconc (merge-slots included-slots super-slots ps) local-slots))) (progn (if included-slots (error "Can't include slots when ~s includes no structure." (ps-name ps))) (il:* il:|;;| "no included slots, so the local-slots are it.") (setf (ps-all-slots ps) local-slots))) (when (and (null (ps-all-slots ps)) (eq (ps-type ps) %default-defstruct-type)) (push (dummy-slot) local-slots) (setf (ps-all-slots ps) local-slots)) (il:* il:|;;| "No longer require local slots to be recorded") (setf (ps-local-slots ps) local-slots) (il:* il:|;;| "now that all slots (included, super, local and filler) have been included, we can create accessor names.") (let ((conc-name (ps-conc-name ps))) (dolist (slot (ps-all-slots ps)) (assign-slot-accessor slot conc-name))) (il:* il:|;;| "we can also record slot-names for the default-structure-printer and inspector.") (setf (ps-all-slot-names ps) (mapcar (function pslot-name) (ps-all-slots ps))) (il:* il:|;;| "make sure that no slot names have been repeated (either from being explicitly listed twice in the defstruct, or using a slot name that is present in the super without using :include for the slot)") (do ((slot-names (ps-all-slot-names ps) (cdr slot-names))) ((null slot-names)) (if (member (car slot-names) (cdr slot-names) :test (function eq)) (error "The slot ~s is repeated in ~s." (car slot-names) (ps-all-slot-names ps))))))(defun insert-included-slot (new-slot super-slots ps) (il:* il:|;;| "Replaces the slot in super-slots that corresponds to new-slot with new-slot") (flet ((same-slot (slot1 slot2) (eq (pslot-name slot1) (pslot-name slot2)))) (let* ((tail (member new-slot super-slots :test (function same-slot))) (old-slot (car tail))) (if (not tail) (error "included slot ~S not present in included structure ~S" (pslot-name new-slot) (ps-include ps))) (il:* il:|;;| " verify the inclusion rules.") (if (and (pslot-read-only old-slot) (not (pslot-read-only new-slot))) (error "included slot ~s must be read-only.  It is in included structure ~S" (pslot-name new-slot) (ps-include ps))) (defstruct-assert-subtypep (pslot-type new-slot) (pslot-type old-slot) ("Included slot ~S's type ~s is not a subtype of original slot type ~s" (pslot-name new-slot) (pslot-type new-slot) (pslot-type old-slot))) (il:* il:|;;| "finally, we can replace the slot") (rplaca tail new-slot))))(defun merge-slots (included-slots super-slots ps) (il:* il:|;;| "Takes the included-slots, and the local slots, then merges them with the slots from the super that aren't shadowed.") (il:* il:|;;| "go through the slots from the super and replace the super's def with the overriding included-slot") (dolist (new-slot included-slots) (insert-included-slot new-slot super-slots ps)) super-slots)(defun name-slot (ps) (il:* il:|;;| "Returns a parsed-slot representing the 'name' field of a structure") (parse-slot (il:bquote (si::--structure-name-slot-- (quote (il:\\\, (ps-name ps))) :read-only t)) nil))(defun dummy-slot nil (parse-slot (il:bquote (si::--structure-dummy-slot-- nil :read-only t :type il:xpointer)) nil))(defun offset-slot nil (parse-slot (il:bquote ((il:\\\, (gensym)) (il:* il:|;;| "to make sure that names are unique, so that when the inspector works on :type list, there will be a unique name.") nil :read-only t)) nil))(il:* il:|;;;| "data layout code")(defun assign-structure-representation (ps) (il:* il:|;;| "Determines the descriptors and returns a form to create the datatype at loadtime.") (il:* il:|;;| "Side effects ps.") (let ((local-slots (ps-local-slots ps))) (il:* il:|;;| "Local slots no longer need be recorded") (setf (ps-local-slots ps) nil) (case (ps-type ps) ((vector list) (il:* il:|;;| "just assign the the field descriptors (offsets).  No run-time declaration is needed since the representation is known (list and vector)") (assign-slot-offset ps) nil) (datatype (let* ((local-field-specs (mapcar (function (lambda (slot) (%structure-type-to-fieldspec (pslot-type slot)))) local-slots)) (super-field-specs (if (ps-include ps) (ps-field-specifiers (parsed-structure (ps-include ps))))) (all-field-specs (append super-field-specs local-field-specs)) (structure-name (ps-name ps))) (setf (ps-field-specifiers ps) all-field-specs) (xcl:destructuring-bind (length &rest field-descriptors) (il:translate.datatype (if (not (ps-template ps)) structure-name) all-field-specs) (il:* il:|;;| "Note that this side-effects ps") (assign-field-descriptors ps field-descriptors) (il:* il:|;;| "save the descriptors? No, even though the ones in the dtd are for the current world, not the crosscompiling world.  They are recomputed each redeclaration by TRANSLATE.DATATYPE") (if (not (ps-template ps)) (il:bquote ((si::%structure-declare-datatype (quote (il:\\\, structure-name)) (quote (il:\\\, all-field-specs)) (quote (il:\\\, field-descriptors)) (il:\\\, length) (quote (il:\\\, (or (ps-include ps) %default-structure-include)))))))))))))(defun coerce-type (element-type) (il:* il:|;;| "As in IL:%canonical-cml-type -- Returns the types (t, string-char, single-float, IL:xpointer, (unsigned-byte n) and (signed-byte n)") (if (consp element-type) (case (car element-type) (unsigned-byte (il:* il:|;;| "Let the bits hang out") (if (> (cadr element-type) 16) t element-type)) (signed-byte (il:%get-enclosing-signed-byte element-type)) (mod (il:* il:|;;| "From cmlarray -- reduces (mod n) to (unsigned-byte m)") (il:%reduce-mod element-type)) (integer (il:* il:|;;| "From cmlarray -- reduces (integer x y) to (signed-byte m)") (il:%reduce-integer element-type)) (member (if (and (eq 2 (length (cdr element-type))) (every (function (lambda (elt) (or (eq elt t) (eq elt nil)))) (cdr element-type))) element-type t)) (t (il:* il:|;;| "Attempt type expansion") (let ((expander (type-expander (car element-type)))) (if expander (coerce-type (type-expand element-type expander)) t)))) (case element-type ((t il:fullpointer il:xpointer il:fullxpointer single-float string-char) element-type) (il:pointer t) ((float short-float long-float double-float) (quote single-float)) (fixnum (il:* il:|;;| "Could be (signed-byte 32) -- but pointer representation is more efficient") t) (character (quote string-char)) (bit (quote (unsigned-byte 1))) (t (let ((expander (type-expander element-type))) (if expander (coerce-type (type-expand element-type expander)) t))))))(defun %structure-type-to-fieldspec (element-type) (il:* il:|;;;| "Returns the most specific InterLisp type descriptor which will hold a given type.") (il:* il:|;;;| "Note: This function accepts only a limited subset of the Common Lisp type specifiers: T FLOAT SINGLE-FLOAT FIXNUM BIT (MOD n) (UNSIGNED-BYTE n) INTEGER (INTEGER low high) IL:XPOINTER DOUBLE-IL:POINTER") (let ((coerced-type (coerce-type element-type))) (if (not (consp coerced-type)) (case coerced-type ((t string-char) (quote il:pointer)) ((il:fullpointer il:xpointer il:fullxpointer) coerced-type) ((single-float) (quote il:floatp)) (otherwise (quote il:pointer))) (case (car coerced-type) (unsigned-byte (il:bquote (il:bits (il:\\\, (cadr coerced-type))))) (signed-byte (case (cadr coerced-type) (16 (quote il:signedword)) (32 (quote il:fixp)) (otherwise (quote il:pointer)))) (member (quote il:flag)) (otherwise (quote il:pointer))))))(defun assign-field-descriptors (ps field-descriptors) (il:* il:|;;| "Assigns the field descriptors for accessing each slot of the structure") (if (not (eq (ps-type ps) (quote datatype))) (error "Not a structure of type datatype")) (do ((f field-descriptors (cdr f)) (slot (ps-all-slots ps) (cdr slot))) ((null f)) (setf (pslot-field-descriptor (car slot)) (car f))) (il:* il:|;;| "DON'T record where the pointer fields are for the circle printer.  it will do this when it needs them.") (il:* il:|;;| "(setf (ps-pointer-descriptors ps) (mapcan #'(lambda (descriptor) (case (caddr descriptor) ((il:pointer il:fullpointer il:xpointer il:fullxpointer) (list descriptor)))) field-descriptors))"))(defun structure-pointer-slots (structure-name) (il:* il:|;;| "record where the pointer fields are for the circle printer.") (let ((ps (parsed-structure structure-name))) (or (ps-pointer-descriptors ps) (setf (ps-pointer-descriptors ps) (mapcan (function (lambda (descriptor) (case (caddr descriptor) ((il:pointer il:fullpointer il:xpointer il:fullxpointer) (list descriptor))))) (mapcar (function pslot-field-descriptor) (ps-all-slots ps)))))))(il:* il:|;;;| "type system hooks")(defun process-type (ps) (il:* il:|;;;| "adds the structure to the common lisp type system and defines the predicate, if any.") (if (not (ps-template ps)) (let* ((name (ps-name ps)) (type (ps-type ps)) (predicate (ps-predicate ps)) (predicate-body (and predicate (predicate-body ps (quote object)))) (exportname (ps-export ps))) (if (and predicate (or (eq exportname t) (member :predicate exportname))) (export predicate)) (il:* il:\; "Edited by TT(13-June-90) Export Option Follow up") (il:bquote ((il:\\\,@ (cond ((eq type (quote datatype)) (il:bquote ((eval-when (eval load compile) (setf (type-expander (quote (il:\\\, name))) (quote type-expand-structure)))))) ((ps-named ps) (il:bquote ((eval-when (eval load compile) (setf (type-expander (quote (il:\\\, name))) (quote type-expand-named-structure)))))))) (il:\\\,@ (when predicate (let* ((inline (ps-inline ps)) (inline-p (and (eq type (quote datatype)) (or (eq inline :only) (and (consp inline) (member :predicate inline :test (function eq)))))) (inline-only-p (eq inline :only))) (if (null inline-p) (il:* il:|;;| "Flush optimizer (a bit extreme, but also gets rid of old definline optimizers from the old defstruct") (setf (compiler:optimizer-list predicate) nil)) (il:bquote ((il:\\\,@ (if (not inline-only-p) (il:bquote ((defun (il:\\\, predicate) (object) (il:\\\, predicate-body)))))) (il:\\\,@ (if inline-p (il:bquote ((eval-when (eval load compile) (establish-predicate (quote (il:\\\, (ps-name ps)))))))))))))))))))(defun predicate-body (ps arg) (let ((predicate (ps-predicate ps)) (type (ps-type ps))) (case type (datatype (il:* il:|;;| "for datatypes, always create a predicate.  Use typep") (il:bquote (typep (il:\\\, arg) (quote (il:\\\, (ps-name ps)))))) (otherwise (il:* il:|;;| "vectors and lists can only have a predicate if they are named") (if (not (ps-named ps)) (error "The predicate ~s may not be specified for ~s because it is not :name'd" predicate (ps-name ps))) (il:bquote (and (typep (il:\\\, arg) (quote (il:\\\, (if (eq type (quote list)) (quote cons) (quote vector))))) (eq (il:\\\, (if (eq type (quote list)) (il:bquote (nth (il:\\\, (ps-name-slot-position ps)) (il:\\\, arg))) (il:bquote (aref (il:\\\, arg) (il:\\\, (ps-name-slot-position ps)))))) (quote (il:\\\, (ps-name ps))))))))))(defun type-expand-structure (type-form) (il:bquote (:datatype (il:\\\, (car type-form)))))(defun type-expand-named-structure (type-form) (il:bquote (satisfies (il:\\\, (ps-predicate (parsed-structure (car type-form)))))))(defun ps-name-slot-position (ps) "returns the offset of the name slot for ps." (let* ((include (ps-include ps)) (super-slots (and include (ps-all-slots (parsed-structure include))))) (+ (ps-initial-offset ps) (length super-slots))))(defun default-predicate-name (structure-name) (values (intern (concatenate (quote string) (string structure-name) "-P"))))(defun defstruct-shared-predicate-optimizer (form &optional environment context) (xcl:destructuring-bind (predicate object) form (let ((name (gethash predicate *defstruct-info-cache*))) (if (null name) (setq name (cache-predicate-info predicate))) (if name (il:bquote (typep (il:\\\, object) (quote (il:\\\, name)))) compiler:pass))))(defun cache-predicate-info (predicate) (il:* il:|;;| "Establishes a shared a shared optimizer for a defstruct predicate") (let ((ps (get-ps-from-predicate predicate t))) (when ps (setf (gethash predicate *defstruct-info-cache*) (ps-name ps)))))(defconstant %function-defining-form-keywords (quote (:accessor :copier :predicate :boa-constructor :constructor)) "all the legal contexts for function-defining-form in defstruct")(il:* il:|;;;| "accessors and setfs")(defun setf-name (accessor-name) "produces the name of the setf function for this accessor" (xcl:pack (list (quote %%setf-) accessor-name)))(defun accessor-body (slot argument structure-type &optional (no-type-check nil)) (il:* il:|;;| "Returns a form which fetches slot from argument") (ecase structure-type (datatype (il:bquote ((il:\\\, (if no-type-check (quote il:ffetchfield) (quote il:fetchfield))) (quote (il:\\\, (pslot-field-descriptor slot))) (il:\\\, argument)))) (list (il:bquote (nth (il:\\\, (pslot-field-descriptor slot)) (il:\\\, argument)))) (vector (il:bquote (aref (il:\\\, argument) (il:\\\, (pslot-field-descriptor slot)))))))(defun process-accessors (ps) (if (not (eq (ps-inline ps) :only)) (if compiler::*new-compiler-is-expanding* (il:bquote ((establish-accessors (quote (il:\\\, (ps-name ps)))))) (il:bquote ((eval-when (eval) (establish-accessors (quote (il:\\\, (ps-name ps))))) (eval-when (load) (il:\\\,@ (define-accessors ps))))))))(defun establish-accessors (ps-name) (il:* il:|;;| "Makes a closure for every accessor ") (let* ((ps (parsed-structure ps-name)) (structure-type (ps-type ps))) (mapcan (function (lambda (slot) (let ((accessor (pslot-accessor slot)) (exportname (ps-export ps))) (when accessor (if (or (eq exportname t) (member :accessor exportname)) (export accessor)) (il:* il:\; "Edited by TT(13-June-90) Export Option Follow up ") (setf (symbol-function accessor) (%make-accessor-closure slot structure-type)))))) (ps-all-slots ps))))(defun define-accessors (ps) (il:* il:|;;| "Returns the forms that when evaluated, define the accessors") (il:* il:|;;| "Only used by the byte compiler") (let ((name (ps-name ps)) (structure-type (ps-type ps))) (il:* il:|;;| "the arg-name must be the structure name, since it is already in the raw-accessors.") (mapcan (function (lambda (slot) (let ((accessor (pslot-accessor slot)) (exportname (ps-export ps))) (when accessor (if (or (eq exportname t) (member :accessor exportname)) (export accessor)) (il:* il:\; "Edited by TT(13-June-90) Export Option follow-up. ") (il:bquote ((defun (il:\\\, accessor) ((il:\\\, name)) (il:\\\, (accessor-body slot name structure-type))))))))) (ps-all-slots ps))))(defun defstruct-shared-accessor-optimizer (form &optional environment context) (xcl:destructuring-bind (accessor object) form (let ((slot-info (gethash accessor *defstruct-info-cache*))) (if (null slot-info) (setq slot-info (cache-slot-info accessor))) (if slot-info (xcl:destructuring-bind (type slot fast-accessors-p) slot-info (accessor-body slot object type fast-accessors-p)) (quote compiler:pass)))))(define-shared-setf-macro defstruct-shared-setf-expander accessor (datum) (new-value) (il:* il:|;;| "Shared setf expander for all defstruct slot accessors ") (let ((slot-info (gethash accessor *defstruct-info-cache*))) (when (null slot-info) (setq slot-info (cache-slot-info accessor))) (xcl:destructuring-bind (type slot fast-accesssor-p) slot-info (let ((descriptor (pslot-field-descriptor slot))) (ecase type (datatype (il:bquote ((il:\\\, (if fast-accesssor-p (quote il:freplacefield) (quote il:replacefield))) (quote (il:\\\, descriptor)) (il:\\\, datum) (il:\\\, new-value)))) (list (il:bquote (setf (nth (il:\\\, descriptor) (il:\\\, datum)) (il:\\\, new-value)))) (vector (macrolet ((simple-p (x) (il:bquote (or (symbolp (il:\\\, x)) (constantp (il:\\\, x)))))) (if (and (simple-p datum) (simple-p new-value)) (il:bquote (xcl:aset (il:\\\, new-value) (il:\\\, datum) (il:\\\, descriptor))) (let ((d (gensym)) (v (gensym))) (il:bquote (let (((il:\\\, d) (il:\\\, datum)) ((il:\\\, v) (il:\\\, new-value))) (xcl:aset (il:\\\, v) (il:\\\, d) (il:\\\, descriptor)))))))))))))(defun cache-slot-info (accessor) (il:* il:|;;;| "saves the internal accessors in a hash table so that setf methods can be generated at interpret/compile time.") (let* ((ps (get-ps-from-accessor accessor)) (fast-accessors (ps-fast-accessors ps))) (setf (gethash accessor *defstruct-info-cache*) (il:* il:\; "Make a copy of the slot to keep refcounts down") (list (ps-type ps) (copy-tree (get-slot-descriptor-from-ps accessor ps)) (and fast-accessors t)))))(defun %make-accessor-closure (slot structure-type) (let ((descriptor (pslot-field-descriptor slot))) (ecase structure-type (datatype (xcl:destructuring-bind (typename offset field-descriptor) descriptor (case field-descriptor ((il:pointer il:fullpointer il:xpointer il:fullxpointer) (%make-pointer-accessor typename offset)) (il:floatp (%make-float-accessor typename offset)) (il:fixp (%make-fixp-accessor typename offset)) (otherwise (il:* il:|;;| "Must be a bit field") (let* ((field-type (car field-descriptor)) (field-arg (cdr field-descriptor)) (size (1+ (logand field-arg 15))) (position (- 16 (+ size (ash field-arg -4))))) (ecase field-type (il:bits (if (eq size 16) (%make-word-accessor typename offset) (%make-bit-accessor typename offset position size))) (il:flagbits (if (eq size 1) (%make-flag-accessor typename offset position) (error "Illegal field descriptor: ~s" descriptor))) (il:signedbits (if (eq size 16) (%make-small-fixp-accessor typename offset) (il:* il:|;;| "Would be better to say here \"Inconvenient field descriptor\"") (error "Illegal field descriptor: ~s" descriptor))))))))) (list (%make-list-accessor descriptor)) (vector (%make-array-accessor descriptor)))))(defun %make-list-accessor (offset) (function (lambda (list) (nth offset list))))(defun %make-array-accessor (offset) (function (lambda (vector) (aref vector offset))))(defun %make-pointer-accessor (type offset) (if type (function (lambda (object) (if (not (il:\\instance-p object type)) (error "Arg not ~s: ~s" type object) (il:\\getbaseptr object offset)))) (function (lambda (object) (il:\\getbaseptr object offset)))))(defun %make-bit-accessor (type word-offset offset size) (if type (function (lambda (object) (if (not (il:\\instance-p object type)) (error "Arg not ~s: ~s" type object) (ldb (byte size offset) (il:\\getbase object word-offset))))) (function (lambda (object) (ldb (byte size offset) (il:\\getbase object word-offset))))))(defun %make-flag-accessor (type word-offset offset) (if type (function (lambda (object) (if (not (il:\\instance-p object type)) (error "Arg not ~s: ~s" type object) (not (eq 0 (ldb (byte 1 offset) (il:\\getbase object word-offset))))))) (function (lambda (object) (not (eq 0 (ldb (byte 1 offset) (il:\\getbase object word-offset))))))))(defun %make-word-accessor (type offset) (if type (function (lambda (object) (if (not (il:\\instance-p object type)) (error "Arg not ~s: ~s" type object) (il:\\getbase object offset)))) (function (lambda (object) (il:\\getbase object offset)))))(defun %make-fixp-accessor (type offset) (if type (function (lambda (object) (if (not (il:\\instance-p object type)) (error "Arg not ~s: ~s" type object) (il:\\getbasefixp object offset)))) (function (lambda (object) (il:\\getbasefixp object offset)))))(defun %make-small-fixp-accessor (type offset) (if type (function (lambda (object) (if (not (il:\\instance-p object type)) (error "Arg not ~s: ~s" type object) (il:\\getbasesmall-fixp object offset)))) (function (lambda (object) (il:\\getbasesmall-fixp object offset)))))(defun %make-float-accessor (type offset) (if type (function (lambda (object) (if (not (il:\\instance-p object type)) (error "Arg not ~s: ~s" type object) (il:\\getbasefloatp object offset)))) (function (lambda (object) (il:\\getbasefloatp object offset)))))(il:* il:|;;;| "constructor definition code")(defun define-constructors (ps) (il:* il:|;;| "Returns the forms that when evaluated, define the constructors") (if (not (ps-template ps)) (let* ((constructors (ps-constructors ps)) (slots (ps-all-slots ps)) (result-arg (ps-name ps)) (all-boas? (every (function boa-constructor-p) constructors)) (exportname (ps-export ps))) (if (or (eq exportname t) (member :constructor exportname)) (export constructors)) (il:* il:\; "Edited by TT(13-June-90) Export Option Follow up") (cond (all-boas? (il:* il:|;;| "don't bother building the arglist etc.") (mapcar (function (lambda (constructor) (define-boa-constructor constructor ps))) constructors)) (t (let* ((argument-list (build-constructor-arglist slots)) (slot-setfs (build-constructor-slot-setfs slots argument-list ps))) (xcl:with-collection (dolist (constructor constructors) (xcl:collect (cond ((boa-constructor-p constructor) (define-boa-constructor constructor ps)) (t (il:* il:|;;| "keep the name of a standard constructor, if any, so that the #s form can work.") (setf (ps-standard-constructor ps) constructor) (il:* il:|;;| "since we just built the object we're setting fields of, we don't need to type check it.") (il:bquote (defun (il:\\\, constructor) (&key (il:\\\,@ argument-list)) (let (((il:\\\, result-arg) (il:\\\, (raw-constructor ps)))) (il:\\\,@ slot-setfs) (il:\\\, result-arg)))))))))))))))(defun define-boa-constructor (name&arglist ps) (let* ((constructor-name (car name&arglist)) (arglist (cadr name&arglist)) (new-argument-list (boa-arg-list-with-initial-values arglist ps)) (result-arg (ps-name ps)) (slot-setfs (boa-slot-setfs result-arg (argument-names new-argument-list) ps))) (il:bquote (defun (il:\\\, constructor-name) (il:\\\, new-argument-list) (let (((il:\\\, result-arg) (il:\\\, (raw-constructor ps)))) (il:\\\,@ slot-setfs) (il:\\\, result-arg))))))(defun argument-names (arg-list) (mapcan (function (lambda (arg) (cond ((consp arg) (list arg)) ((member arg lambda-list-keywords) nil) (t (list (list arg :required-arg)))))) arg-list))(defun boa-arg-list-with-initial-values (arg-list ps) (let ((new-arg-list (copy-tree arg-list)) (slots (ps-all-slots ps))) (il:* il:|;;| "for all the args from &optional up to &rest or &aux get the default value.") (il:for arg-tail il:on (cdr (member (quote &optional) new-arg-list)) il:do (cond ((member (car arg-tail) lambda-list-keywords) (il:* il:|;;| "we have found an ampersand arg, we're done the optionals.") (return)) (t (let ((optional (car arg-tail))) (setf (car arg-tail) (cond ((member optional (quote (&rest &aux))) (il:* il:|;;| "we have hit the end of the optionals, just return.") (return)) ((member optional lambda-list-keywords) (il:* il:|;;| "illegal keyword here") (error "~S cannot appear in a BOA constructor as it does in ~S." optional arg-list)) ((symbolp optional) (let ((intial-value-form (pslot-initial-value (find-slot optional slots)))) (if intial-value-form (il:bquote ((il:\\\, optional) (il:\\\, intial-value-form))) (il:bquote ((il:\\\, optional) nil (il:\\\, (il:gensym))))))) ((and (consp optional) (cdr optional)) (il:* il:|;;| "already a default just leave it alone") optional) ((consp optional) (let ((intial-value-form (pslot-initial-value (find-slot (car optional) slots)))) (if intial-value-form (il:bquote ((il:\\\, (car optional)) (il:\\\, intial-value-form))) (il:bquote ((il:\\\, (car optional)) nil (il:\\\, (il:gensym))))))))))))) new-arg-list))(defun boa-slot-setfs (result-arg slot-names ps) (let ((structure-type (ps-type ps))) (xcl:with-collection (let (slot-place slot-name slot-argument) (dolist (slot (ps-all-slots ps)) (setq slot-name (pslot-name slot)) (setq slot-place (accessor-body slot result-arg structure-type t)) (setq slot-argument (assoc slot-name slot-names :test (function eq))) (xcl:collect (if slot-argument (let ((supplied-p (caddr slot-argument))) (if supplied-p (il:bquote (if (il:\\\, supplied-p) (setf (il:\\\, slot-place) (il:\\\, slot-name)))) (il:bquote (setf (il:\\\, slot-place) (il:\\\, slot-name))))) (il:bquote (setf (il:\\\, slot-place) (il:\\\, (pslot-initial-value slot)))))))))))(defun find-slot (name slots &optional (dont-error nil)) (dolist (slot slots (or dont-error (error "slot ~s not found." name))) (if (eq name (pslot-name slot)) (return slot))))(defun raw-constructor (ps) (il:* il:|;;| "Returns a form which will make an instance of this structure w/o initialisation") (ecase (ps-type ps) (datatype (il:bquote (il:ncreate (quote (il:\\\, (ps-name ps)))))) (list (il:bquote (make-list (il:\\\, (ps-number-of-slots ps))))) (vector (il:bquote (make-array (quote ((il:\\\, (ps-number-of-slots ps)))) :element-type (quote (il:\\\, (ps-vector-type ps))))))))(defun build-constructor-arglist (slots) (il:* il:|;;| "Gathers the keywords and initial-values for (non BOA) constructors") (mapcan (function (lambda (slot) (let* ((init-form (pslot-initial-value slot)) (arg-name (pslot-name slot)) (keyword-pair (il:bquote ((il:\\\, (values (intern (symbol-name arg-name) (quote keyword)))) (il:\\\, (gensym)))))) (cond ((not (pslot-accessor slot)) (il:* il:|;;| "this is an invisible slot (name, initial-offset, etc.) don't generate a keyword arg") nil) (init-form (il:* il:|;;| "specify an initial value for the keyword arg") (il:bquote (((il:\\\, keyword-pair) (il:\\\, init-form))))) (t (il:bquote (((il:\\\, keyword-pair) nil (il:\\\, (gensym)))))))))) slots))(defun build-constructor-slot-setfs (slots argument-list ps) (il:* il:|;;| "Builds the setfs that initialize the slots in a constructor") (let ((structure-type (ps-type ps)) (object-name (ps-name ps)) (argument-list argument-list)) (il:* il:|;;| "The argument list does not have arguments for \"invisible\" slots.") (mapcar (function (lambda (slot) (cond ((not (pslot-accessor slot)) (il:* il:|;;| "invisible slot, so generate a setf to it's initial-value") (il:bquote (setf (il:\\\, (accessor-body slot object-name structure-type t)) (il:\\\, (pslot-initial-value slot))))) (t (let* ((argument (pop argument-list)) (keyword-var-name (cadar argument)) (initial-value-form (cadr argument))) (il:* il:|;;| "since slots can be read-only, we setf the raw accessor, not the slot accessor.") (il:* il:|;;| "Also, since we built the object in which we are setting fields, we use the internal-accessor without typecheck") (if initial-value-form (il:bquote (setf (il:\\\, (accessor-body slot object-name structure-type t)) (il:\\\, keyword-var-name))) (il:bquote (if (il:\\\, (caddr argument)) (setf (il:\\\, (accessor-body slot object-name structure-type t)) (il:\\\, keyword-var-name)))))))))) slots)))(defun boa-constructor-p (constructor) (il:* il:|;;| "Returns t if the constructor is a By Order of Arguments constructor") (consp constructor))(defun default-constructor-name (structure-name) (values (intern (concatenate (quote string) "MAKE-" (string structure-name)))))(il:* il:|;;;| "copiers")(defun define-copiers (ps) (il:* il:|;;| "Returns the form that when evaluated, defines the copier") (if (not (ps-template ps)) (let ((copier (ps-copier ps)) (result-arg (quote new)) (from-arg (ps-name ps))) (if copier (multiple-value-bind (from-arg-type-check type-check-slots?) (build-copier-type-check ps from-arg) (let ((slot-setfs (build-copier-slot-setfs (ps-all-slots ps) (ps-type ps) from-arg result-arg type-check-slots?)) (exportname (ps-export ps))) (if (or (eq exportname t) (member :copier exportname)) (export (ps-copier ps))) (il:* il:\; "Edited by TT(13-June-90) Export Option follow up") (il:* il:|;;| "Since we just built the object we're setting fields of, we don't need to type check it.") (il:bquote ((defun (il:\\\, (ps-copier ps)) ((il:\\\, from-arg)) (il:\\\,@ from-arg-type-check) (let (((il:\\\, result-arg) (il:\\\, (raw-constructor ps)))) (il:\\\,@ slot-setfs) (il:\\\, result-arg)))))))))))(defun build-copier-slot-setfs (slots structure-type from-argument to-argument type-check-slots?) "constructs the forms that copy each individual slot." (il:* il:|;;| "build a series of forms that look like") (il:* il:|;;| "(setf (structure-slot to-arg) (structure-slot from-arg))") (mapcar (function (lambda (slot) (il:bquote (setf (il:\\\, (accessor-body slot to-argument structure-type t)) (il:\\\, (accessor-body slot from-argument structure-type t)))))) slots))(defun build-copier-type-check (ps from-arg) (il:* il:|;;| "Constructs the type checking form at the beginning of the copier and decides whether individual slots need to be type-checked.") (cond ((eq (ps-type ps) (quote datatype)) (il:* il:|;;| "If something is a datatype type check the from-arg once at the beginning.  Don't check the individual accesses.") (values (il:bquote ((check-type (il:\\\, from-arg) (il:\\\, (ps-name ps))))) nil)) ((ps-predicate ps) (il:* il:|;;| "if the structure has a predicate ,then call the predicate.") (values (il:bquote ((or ((il:\\\, (ps-predicate ps)) (il:\\\, from-arg)) (error (il:\\\, (format nil "Arg not ~s: ~~S" (ps-name ps))) (il:\\\, from-arg))))) nil)) (t (il:* il:|;;| "Otherwise, just use the type-checked slot access, so that at least the argument is assured to be a vector/list.") (values nil t))))(il:* il:|;;;| "print functions")(defvar %default-print-function (quote default-structure-printer) "print function used when none is specified in a defstruct")(il:* il:|;;;| "internal stuff.")(defsetf il:ffetchfield il:freplacefield)(il:* il:|;;;| "utilities")(defmacro defstruct-assert-subtypep (type1 type2 (error-string . error-args) &rest cerror-actions) (il:* il:|;;| "Provides an interface for places where the implementor isn't sure that subtypep can be trusted") (let ((error-string (or error-string "~S is not a subtype of ~S")) (error-args (or error-args (list type1 type2)))) (il:bquote (multiple-value-bind (subtype? certain?) (subtypep (il:\\\, type1) (il:\\\, type2)) (cond (subtype? (il:* il:\; "it's ok, continue") t) (certain? (il:* il:\; "subtypep says it sure, so blow up") (error (il:\\\, error-string) (il:\\\,@ error-args))) (t (il:* il:\; "subtypep isn't sure, so raise a continuable error") (cerror "Assume subtypep should return t" (il:\\\, (format nil "Perhaps, ~a" error-string)) (il:\\\,@ error-args)) (il:\\\,@ cerror-actions) t))))))(il:* il:|;;;| "inspecting structures")(defun structure-object-p (object) (typep object (quote structure-object)))(defun inspect-structure-object (structure objecttype where) "calls the system facilities with the appropriate slots and functions." (il:inspectw.create structure (ps-all-slots (parsed-structure (type-of structure))) (quote structure-object-inspect-fetchfn) (quote structure-object-inspect-storefn) (quote structure-object-propcommandfn) nil nil (let ((xcl:*print-structure* nil)) (concatenate (quote string) (princ-to-string structure) " Inspector")) nil where (quote structure-object-inspect-propprintfn)))(defun structure-object-inspect-fetchfn (object property) (if (pslot-accessor property) (funcall (pslot-accessor property) object) (il:fetchfield (pslot-field-descriptor property) object)))(defun structure-object-inspect-propprintfn (property datum) (pslot-name property))(defun structure-object-inspect-storefn (object property newvalue) (il:* il:|;;| "this effectively does (eval `(setf (,(pslot-accessor property) object) newvalue)) ") (if (pslot-accessor property) (eval (il:bquote (setf ((il:\\\, (pslot-accessor property)) (quote (il:\\\, object))) (quote (il:\\\, newvalue))))) (il:replacefield (pslot-field-descriptor property) object newvalue)))(defun structure-object-propcommandfn (property datum inspector-window) (if (and (typep datum (quote structure-object)) (pslot-read-only property)) (il:promptprint "Can't set a read-only slot.") (il:default.inspectw.propcommandfn property datum inspector-window)))(il:* il:|;;| "Defined last so functions required to load a defstruct are loaded first")(defstruct (ps (:type list) :named) (il:* il:|;;;| "Contains the parsed information for a SINGLE structure type") (il:* il:|;;| "most values are not defaulted here, because the defaults depend on other slot values (e.g. predicate depends on type and named.)  These defaults are installed in ensure-consistent-ps.") (name) (il:* il:\; "The name of the structure") (standard-constructor) (il:* il:\; "Contains the constructor to be used by the #s reader.") (all-slot-names) (il:* il:\; "The slot-name list used by the inspector.") (type %default-defstruct-type) (il:* il:\; "Is this structure a datatype, list or vector.") (vector-type) (il:* il:\; "If its a vector, this is the element-type of the vector") (include nil) (il:* il:\; "The included structure, if any.") (conc-name) (constructors %no-constructor) (il:* il:\; "A list of the constructors for this structure.  Boas have the argument list, not just the name.") (predicate %no-predicate) (print-function) (copier %no-copier) (named nil) (initial-offset 0) (local-slots nil) (il:* il:\; "The slot descriptors for slots present locally (not included).") (all-slots) (il:* il:\; "The list of slot descriptors for every slot present in an instance of this slot.") (included-slots) (il:* il:\; "Slots specified in the :include option.") (il:* il:|;;| "Redundant") (documentation-string) (il:* il:|;;| "Unused") (field-specifiers) (il:* il:\; "The position of each slot in the structure.  For vectors and  list structures, it is just an offset.  For datatypes, it is a field-specifier for fetchield.") (il:* il:|;;| "Unused") (pointer-descriptors) (il:* il:\; "the descriptors for all fields which the circle-printer must scan.  It is filled in the first time it is needed.") (inline t) (il:* il:\; "Flag telling whether or not functions built by defstruct are inline or not.") (fast-accessors nil) (il:* il:\; "Flag telling whether or not accessor functions should check the type of the object before slot accesses.") (template nil) (il:* il:\; "As in IL:BLOCKRECORD. Implies type datatype, no copier, predicate or constructors, and fast accessors. No datatype is declared for this option.") (export nil) (il:* il:\; "EXPORT indicates  export of Structure's functions"))(defstruct (parsed-slot (:conc-name pslot-) (:type list)) "describes a single slot in a structure" (name nil :type symbol) (initial-value nil) (type %default-slot-type) (read-only nil) field-descriptor accessor)(il:* il:|;;| "Mapping between names of generated functions and their associated structures")(defun structure-function-p (symbol) (catch (quote found) (maphash (function (lambda (key ps) (if (or (and (consp (ps-constructors ps)) (member symbol (ps-constructors ps) :test (function eq))) (eq symbol (ps-predicate ps)) (eq symbol (ps-copier ps)) (dolist (slot (ps-all-slots ps)) (if (eq symbol (pslot-accessor slot)) (return (ps-name ps))))) (throw (quote found) key)))) *parsed-defstructs*)))(defun structure-functions (structure-name) (let ((ps (parsed-structure structure-name))) (il:bquote ((il:\\\,@ (ps-constructors ps)) (il:\\\,. (let ((predicate (ps-predicate ps))) (if predicate (list predicate)))) (il:\\\,. (let ((copier (ps-copier ps))) (if copier (list copier)))) (il:\\\,. (mapcan (function (lambda (slot) (let ((accessor (pslot-accessor slot))) (and accessor (list accessor))))) (ps-all-slots ps)))))))(il:* il:|;;;| "Editing structures")(defun structures.hasdef (name &optional type source spellflg) (or (structure-function-p name) (il:getdef name (quote il:structures) (quote il:current) (quote (il:nodwim il:nocopy il:noerror il:hasdef)))))(defun structures.editdef (name type source editcoms options) "From accessor function or structure name, edit the structure." (il:* il:\; "Edited by TT (8-June-90 : solution for AR#11127)") (if (parsed-structure name t) (il:default.editdef name (quote il:structures) source editcoms options) (let ((structure-name (structure-function-p name))) (il:* il:\; "Accessor functions are identified as structures, edit the structure instead.") (if structure-name (il:default.editdef structure-name (quote il:structures) source editcoms options) (il:default.editdef name type source editcoms options)))) name)(il:filepkgtype (quote il:structures) (quote il:hasdef) (quote structures.hasdef) (quote il:editdef) (quote structures.editdef))(il:addtovar il:shadow-types (il:structures il:fns))(il:declare\: il:docopy il:donteval@load (il:addtovar il:inspectmacros ((il:function structure-object-p) . inspect-structure-object)))(il:* il:|;;;| "file properties")(il:putprops il:defstruct il:filetype :compile-file)(il:putprops il:defstruct il:makefile-environment (:readtable "XCL" :package "LISP"))(il:putprops il:defstruct il:copyright ("Venue & Xerox Corporation" 1986 1987 1900 1988 1989 1990))(il:declare\: il:dontcopy  (il:filemap (nil)))il:stop