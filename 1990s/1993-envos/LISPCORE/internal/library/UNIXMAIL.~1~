(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "INTERLISP") (FILECREATED"14-Sep-90 12:46:07"|{DSK}<usr>local>lde>lispcore>internal>library>unixmail.;4| 28992        |changes| |to:|  (VARS UNIXMAILCOMS) (FNS UNIXMAILER.OPENMAILBOX UNIXSPOOL.OPENMAILBOX \\UNIXMAIL.SMTP.FLUSH) (FILES LAFITEDECLS)      |previous| |date:| "13-Sep-90 17:16:41"|{DSK}<usr>bane>unixmail.;6|); Copyright (c) 1989, 1990 by ENVOS Corporation.  All rights reserved.(PRETTYCOMPRINT UNIXMAILCOMS)(RPAQQ UNIXMAILCOMS ((DECLARE\: DOEVAL@COMPILE DONTCOPY (FILES (SOURCE)LAFITEDECLS MAILCLIENT NSMAIL) (RECORDS UNIXMAILBOX UNIXMAILFILEINFOUNIXMAILPARSE)) (ALISTS (LAFITEMODELST UNIX)) (* |;;| "These variablescontrol how mail is sent and received.  UNIXMAIL.SEND.MODE controlswhether the SMTP stream is opened via process-stream (PROCESS) or TCPsocket (TCP).  UNIXMAIL.RECEIVE.MODE controls whether mail is receivedthrough the Berkeley mailer (MAILER) or by reading the spool filedirectly (SPOOL).  PROCESS and MAILER can only be done under anemulator; TCP and SPOOL will also work on D-machines (but may needother library packages like TCP or NFS).") (INITVARS(UNIXMAIL.SEND.MODE (QUOTE PROCESS)) (UNIXMAIL.RECEIVE.MODE (QUOTESPOOL))) (* |;;| "List used by \\UNIXMAIL.AUTHENTICATE to construct theMAILSERVEROPS list") (VARS UNIXMAIL.MSOPS.LIST) (* |;;| "Thesevariables control filenames, hostnames, etc. They default to NIL,meaning they are not used or the mailer will try and figure them outitself") (INITVARS UNIXMAIL.SEND.HOST (UNIXMAIL.SEND.PROCESS"/usr/etc/mconnect") (UNIXMAIL.RECEIVE.PROCESS "/usr/ucb/mail -N")UNIXMAIL.SPOOL.FILE (UNIXMAIL.DONT.RECEIVE.STATUS "")) (* |;;|"Functions used to receive mail") (FNS UNIX.POLLNEWMAILUNIX.NEXTMESSAGE UNIXMAILER.OPENMAILBOX UNIXMAILER.RETRIEVEMESSAGEUNIXMAILER.CLOSEMAILBOX UNIXSPOOL.OPENMAILBOX UNIXSPOOL.RETRIEVEMESSAGEUNIXSPOOL.CLOSEMAILBOX) (* |;;| "Functions used to send mail") (FNSUNIX.FLUSH.STREAM UNIX.RETRIEVE.LINE \\UNIXMAIL.SEND\\UNIXMAIL.SEND.PARSE \\UNIXMAIL.SMTP \\UNIXMAIL.SMTP.FLUSH) (* |;;|"This returns multiple-values, so it's a CL:LAMBDA (what the heck).")(FUNCTIONS \\UNIXMAIL.SMTP.TCP.STREAMS) (* |;;| "Other functions Lafiteuses and needs Unix equivalents for") (FNS \\UNIXMAIL.AUTHENTICATE\\UNIXMAIL.LOGIN \\UNIXMAIL.PARSENAMES \\UNIXMAIL.MAKEANSWERFORM\\UNIXMAIL.MESSAGE.FROM.SELF.P \\UNIXMAIL.MESSAGE.P) (* |;;| "This is astub needed by the TEdit-uuencode strategy; if we ever decide on areasonable way to do this and make it part of Lafite, this may goaway") (P (MOVD? (QUOTE NILL) (QUOTE UNIX.UUDECODE.IF.NEEDED)))))(DECLARE\: DOEVAL@COMPILE DONTCOPY (FILESLOAD (SOURCE) LAFITEDECLS MAILCLIENT NSMAIL)(DECLARE\: EVAL@COMPILE(RECORD UNIXMAILBOX (UMSTREAM UMNUMBERS UMNEXT))(RECORD UNIXMAILFILEINFO (UMFNAME UMFTIME))(RECORD UNIXMAILPARSE (UNIXFROM UNIXTO UNIXOTHER FORMATTED?UNIXBODY)) ) )(ADDTOVAR LAFITEMODELST (UNIX 3 \\UNIXMAIL.SEND.PARSE \\UNIXMAIL.SEND\\UNIXMAIL.MAKEANSWERFORM \\UNIXMAIL.AUTHENTICATE \\UNIXMAIL.MESSAGE.P\\UNIXMAIL.MESSAGE.FROM.SELF.P \\UNIXMAIL.LOGIN))(* |;;|  "These variables control how mail is sent and received. UNIXMAIL.SEND.MODE controls whether the SMTP stream is opened viaprocess-stream (PROCESS) or TCP socket (TCP).  UNIXMAIL.RECEIVE.MODEcontrols whether mail is received through the Berkeley mailer (MAILER)or by reading the spool file directly (SPOOL).  PROCESS and MAILER canonly be done under an emulator; TCP and SPOOL will also work onD-machines (but may need other library packages like TCP or NFS)." )(RPAQ? UNIXMAIL.SEND.MODE (QUOTE PROCESS))(RPAQ? UNIXMAIL.RECEIVE.MODE (QUOTE SPOOL))(* |;;| "List used by \\UNIXMAIL.AUTHENTICATE to construct theMAILSERVEROPS list")(RPAQQ UNIXMAIL.MSOPS.LIST ((MAILER UNIX.POLLNEWMAILUNIXMAILER.OPENMAILBOX UNIX.NEXTMESSAGE UNIXMAILER.RETRIEVEMESSAGEUNIXMAILER.CLOSEMAILBOX) (SPOOL UNIX.POLLNEWMAIL UNIXSPOOL.OPENMAILBOXUNIX.NEXTMESSAGE UNIXSPOOL.RETRIEVEMESSAGE UNIXSPOOL.CLOSEMAILBOX)))(* |;;|  "These variables control filenames, hostnames, etc. Theydefault to NIL, meaning they are not used or the mailer will try andfigure them out itself" )(RPAQ? UNIXMAIL.SEND.HOST NIL)(RPAQ? UNIXMAIL.SEND.PROCESS "/usr/etc/mconnect")(RPAQ? UNIXMAIL.RECEIVE.PROCESS "/usr/ucb/mail -N")(RPAQ? UNIXMAIL.SPOOL.FILE NIL)(RPAQ? UNIXMAIL.DONT.RECEIVE.STATUS "")(* |;;| "Functions used to receive mail")(DEFINEQ(UNIX.POLLNEWMAIL (LAMBDA (ADDRESS REGISTEREDNAME CREDENTIALSMAILSERVER) (* \; "Edited  5-Sep-90 14:39 by jrb:") (* |;;| "We havemail iff our mail spool file (either the value of UNIXMAIL.SPOOL.FILEor /usr/spool/mail/<SHORTUSERNAME>) exists and its date is later thanthe last time we got our Unix mail.  In relentlessly hackish use of theexisting MAILSERVER structure, MAILPORT holds a UNIXMAILFILEINFO whichremembers the name of our mail file and when we last looked at it.")(LET ((FILEINFO (OR (|fetch| (MAILSERVER MAILPORT) |of| MAILSERVER)(|replace| (MAILSERVER MAILPORT) |of| MAILSERVER |with| (|create|UNIXMAILFILEINFO UMFNAME _ (OR UNIXMAIL.SPOOL.FILE (CL:CONCATENATE(QUOTE STRING) "{UNIX}/usr/spool/mail/" (|fetch| (LAFITEMODEDATASHORTUSERNAME) |of| *LAFITE-MODE-DATA*))) UMFTIME _ 0))))) (AND(CL:PROBE-FILE (|fetch| (UNIXMAILFILEINFO UMFNAME) |of| FILEINFO))(IGREATERP (GETFILEINFO (|fetch| (UNIXMAILFILEINFO UMFNAME) |of|FILEINFO) (QUOTE IWRITEDATE)) (|fetch| (UNIXMAILFILEINFO UMFTIME) |of|FILEINFO))))) )(UNIX.NEXTMESSAGE (LAMBDA (MAILBOX)                                       (* \; "Edited  5-Jan-89 18:18 by bane")    (CAR (|fetch| UMNEXT |of| MAILBOX))))(UNIXMAILER.OPENMAILBOX (LAMBDA (ADDRESS REGISTEREDNAME CREDENTIALSMAILSERVER) (* \; "Edited 13-Sep-90 23:52 by jrb:") (* |;;| "A Unix\"mailbox\" is a process-stream talking to /usr/ucb/mail ") (|if| (OR(|fetch| (MAILSERVER NEWMAILP) |of| MAILSERVER) (UNIX.POLLNEWMAILADDRESS REGISTEREDNAME CREDENTIALS MAILSERVER)) |then| (LET* ((MSTREAM(CREATE-PROCESS-STREAM UNIXMAIL.RECEIVE.PROCESS)) (UMBOX (|create|UNIXMAILBOX UMSTREAM _ MSTREAM UMNUMBERS _ NIL UMNEXT _ NIL)) NUMBERS)(* |;;| "Get it in condition to be talked to") (CL:FORMAT MSTREAM "setscreen=10000~%set prompt= ~%") (BLOCK 1000) (UNIX.FLUSH.STREAM MSTREAM)(* |;;| "OK, get it to print the headers followed by a line with astrange character on it (char code 254)") (CL:FORMAT MSTREAM "h~%echo") (PRINTCCODE 254 MSTREAM) (PRINTCCODE (CHARCODE NEWLINE) MSTREAM) (*|;;| "Before we really get rolling, scream ifUNIXMAIL.DONT.RECEIVE.STATUS isn't a string") (OR (STRINGPUNIXMAIL.DONT.RECEIVE.STATUS) (ERROR "UNIXMAIL.DONT.RECEIVE.STATUSisn't a string" UNIXMAIL.DONT.RECEIVE.STATUS)) (* |;;| "Headers looklike this:") (* |;;| "<space><status-char> other junk like size,subject...") (|until| (EQ (READCCODE MSTREAM) 254) |do| (|if| (NULL(STRPOS (CL:READ-CHAR MSTREAM) UNIXMAIL.DONT.RECEIVE.STATUS)) |then|(|push| NUMBERS (READ MSTREAM))) (UNIX.FLUSH.STREAM MSTREAM (CHARCODENEWLINE)) |finally| (UNIX.FLUSH.STREAM MSTREAM (CHARCODE NEWLINE)))(|if| NUMBERS |then| (SETQ NUMBERS (DREVERSE NUMBERS)) (|replace|UMNUMBERS |of| UMBOX |with| NUMBERS) (|replace| UMNEXT |of| UMBOX|with| NUMBERS) (|create| OPENEDMAILBOX MAILBOX _ UMBOX PROPERTIES _(LIST (QUOTE \#OFMESSAGES) (LENGTH NUMBERS))) |else| (CL:FORMAT MSTREAM"x~%") (* \; "Empty; close the mail process") (QUOTE EMPTY))) |else|(QUOTE EMPTY))) )(UNIXMAILER.RETRIEVEMESSAGE (LAMBDA (MAILBOX MSGOUTFILE) (* \;"Edited  5-Sep-90 22:58 by jrb:") (LET ((MSTREAM (|fetch| UMSTREAM |of|MAILBOX)) (OUTSTART (GETFILEPTR MSGOUTFILE))) (* |;;| "The UMCOUNT inthe MAILBOX is the number of the message we're about to read in.  Theecho command below makes the message text be followed by a linestarting with the character 254; you'll never see that in a messagethat has gone over an SMTP channel (guaranteed 7-bit chars).")(CL:FORMAT MSTREAM "p ~d~%echo " (|pop| (|fetch| UMNEXT |of| MAILBOX)))(PRINTCCODE 254 MSTREAM) (PRINTCCODE (CHARCODE NEWLINE) MSTREAM)(UNIX.FLUSH.STREAM MSTREAM (CHARCODE NEWLINE)) (* \; "Throw away\"Message 1:\" line") (|while| (UNIX.RETRIEVE.LINE MSTREAM MSGOUTFILE)|do| NIL) (* |;;| "This could use a little error-handling, of course...perhaps a LOT of error handling.") (* |;;| "Check out the tail of themessage and uudecode it if it's an encoded message")(UNIX.UUDECODE.IF.NEEDED MSGOUTFILE OUTSTART))) )(UNIXMAILER.CLOSEMAILBOX (LAMBDA (MAILBOX FLUSH?) (* \; "Edited 5-Sep-90 23:01 by jrb:") (LET ((MSTREAM (|fetch| UMSTREAM |of|MAILBOX))) (* |;;| "If FLUSH?, first clean out the mailbox") (|if|FLUSH? |then| (CL:FORMAT MSTREAM "d~{ ~D~}~%" (|fetch| UMNUMBERS |of|MAILBOX))) (* |;;| "Then close it up") (CL:FORMAT MSTREAM "q~%")(CLOSEF MSTREAM) (* |;;| "Twiddle a second to let the mailer run, thenremember what time we closed the mailbox") (BLOCK 1000) (* |;;| "HACK! Depends on \\LAFITE.RETRIEVEMESSAGES binding of MAILSERVER") (|replace|(UNIXMAILFILEINFO UMFTIME) |of| (|fetch| (MAILSERVER MAILPORT) |of|MAILSERVER) |with| (IDATE)))) )(UNIXSPOOL.OPENMAILBOX (LAMBDA (ADDRESS REGISTEREDNAME CREDENTIALSMAILSERVER) (* \; "Edited 13-Sep-90 20:25 by jrb:") (* |;;| "A Unix\"mailbox\" is a stream open on the mail spool file") (|if| (OR(|fetch| (MAILSERVER NEWMAILP) |of| MAILSERVER) (UNIX.POLLNEWMAILADDRESS REGISTEREDNAME CREDENTIALS MAILSERVER)) |then| (LET* ((MSTREAM(OPENSTREAM (|fetch| (UNIXMAILFILEINFO UMFNAME) |of| (|fetch|(MAILSERVER MAILPORT) |of| MAILSERVER)) (QUOTE INPUT) NIL (QUOTE (EOLLF)))) (UMBOX (|create| UNIXMAILBOX UMSTREAM _ MSTREAM UMNUMBERS _ NILUMNEXT _ NIL)) NUMBERS) (* |;;| "Merrily scan the spool fileremembering where all the messages start; there had better be at leastone.  All messages in Unix spool files start with the charactersequence \"(OR beginning-of-file Newline)From \"; this sequence isguaranteed to occur nowhere else but at the start of messages.") (|if|(ZEROP (FILEPOS "From " MSTREAM)) |then| (|push| NUMBERS 0) (* |;;|"The (CONCAT...) stuff below is to avoid having a string with a LFcharacter in it; the file package/reader/printer have been known toEOL-translate such characters in strings inappropriately.") (|bind| POS|while| (SETQ POS (FILEPOS (CONSTANT (CONCAT (CHARACTER (CHARCODE LF))"From ")) MSTREAM)) |do| (|push| NUMBERS (ADD1 POS)) (READCCODEMSTREAM)) (SETQ NUMBERS (DREVERSE NUMBERS)) (|replace| UMNUMBERS |of|UMBOX |with| NUMBERS) (|replace| UMNEXT |of| UMBOX |with| NUMBERS)(SETFILEPTR MSTREAM 0) (|create| OPENEDMAILBOX MAILBOX _ UMBOXPROPERTIES _ (LIST (QUOTE \#OFMESSAGES) (LENGTH NUMBERS))) |else|(CLOSEF MSTREAM) (ERROR "Mail spool file is not in Unix format:"(|fetch| (UNIXMAILFILEINFO UMFNAME) |of| (|fetch| (MAILSERVER MAILPORT)|of| MAILSERVER))) (QUOTE EMPTY))) |else| (QUOTE EMPTY))) )(UNIXSPOOL.RETRIEVEMESSAGE (LAMBDA (MAILBOX MSGOUTFILE) (* \;"Edited  5-Sep-90 22:59 by jrb:") (LET ((MSTREAM (|fetch| UMSTREAM |of|MAILBOX)) (OUTSTART (GETFILEPTR MSGOUTFILE))) (* |;;| "The numbers inthe UMNEXT of the mailbox are file positions in the spool file of thestart of each message, so to get a message, just COPYCHARS from thestart of the current message to the start of the next one.") (LET((MSTART (|pop| (|fetch| UMNEXT |of| MAILBOX))) (MEND (OR (CAR (|fetch|UMNEXT |of| MAILBOX)) (GETEOFPTR MSTREAM)))) (COPYCHARS MSTREAMMSGOUTFILE MSTART MEND)) (* |;;| "This could use a littleerror-handling, of course... perhaps a LOT of error handling.") (* |;;|"Check out the tail of the message and uudecode it if it's an encodedmessage") (UNIX.UUDECODE.IF.NEEDED MSGOUTFILE OUTSTART))) )(UNIXSPOOL.CLOSEMAILBOX (LAMBDA (MAILBOX FLUSH?) (* \; "Edited 6-Sep-90 11:36 by jrb:") (LET ((MSTREAM (|fetch| UMSTREAM |of|MAILBOX))) (* |;;| "If FLUSH?, nuke the spool file") (|if| FLUSH?|then| (DELFILE (|fetch| (UNIXMAILFILEINFO UMFNAME) |of| (|fetch|(MAILSERVER MAILPORT) |of| MAILSERVER)))) (* |;;| " In any event, closethe mailbox stream") (CLOSEF MSTREAM) (* |;;| "HACK!  Depends on\\LAFITE.RETRIEVEMESSAGES binding of MAILSERVER") (|replace|(UNIXMAILFILEINFO UMFTIME) |of| (|fetch| (MAILSERVER MAILPORT) |of|MAILSERVER) |with| (IDATE)))) ) )(* |;;| "Functions used to send mail")(DEFINEQ(UNIX.FLUSH.STREAM (LAMBDA (STREAM CHAR) (* \; "Edited 13-Sep-9015:58 by jrb:") (* |;;| "Just vacuum out the stream until you see CHAR(if it's NIL, read until EOF)") (* |;;| "If CHAR is supplied, streammust not be at EOF") (|if| CHAR |then| (|until| (OR (NOT (READPSTREAM)) (EQ (READCCODE STREAM) CHAR)) |do| NIL) |else| (|until| (NOT(READP STREAM)) |do| (READCCODE STREAM))) STREAM) )(UNIX.RETRIEVE.LINE (LAMBDA (MSTREAM MSGOUTFILE) (* \; "Edited18-Sep-89 14:39 by jrb:") (* |;;| "Copies a line of text from MSTREAMto MSGOUTFILE except if that line starts with a strange character(charcode 254; see UNIX.RETRIEVEMESSAGE). Returns NIL on seeing such aline") (BLOCK) (* \; "This looks like a good place...") (LET ((CHAR(READCCODE MSTREAM))) (|if| (EQ CHAR 254) |then| (SETQ CHAR NIL)) (*|;;| "When we get here, if CHAR is non-NIL, it needs to be printed toMSGOUTFILE") (|if| CHAR |then| (PRINTCCODE CHAR MSGOUTFILE) (|until|(EQ CHAR (CHARCODE NEWLINE)) |do| (PRINTCCODE (SETQ CHAR (READCCODEMSTREAM)) MSGOUTFILE)) T))) )(\\UNIXMAIL.SEND (LAMBDA (MSG PARSE EDITORWINDOW ABORTWINDOW) (* \;"Edited 13-Sep-90 16:05 by jrb:") (* |;;| "The strategy here is to talkto an SMTP server and throw the message at it.") (|if| (AND(TEDIT.FORMATTEDFILEP MSG) (EQ (|fetch| (UNIXMAILPARSE FORMATTED?) |of|PARSE) (QUOTE TEDIT))) |then| (\\LAFITE.SEND.FAIL EDITORWINDOW "UNIXmode can't send raw TEdit; try TEdit-UUencoded") |else|(CL:MULTIPLE-VALUE-BIND (SMIN SMOUT) (\\UNIXMAIL.SMTP.TCP.STREAMS) (LET((PWINDOW (AND EDITORWINDOW (GETPROMPTWINDOW EDITORWINDOW))) RESULT)(|if| (NULL SMIN) |then| (\\LAFITE.SEND.FAIL EDITORWINDOW (CL:FORMATNIL "Coundn't open SMTP stream because ~s" SMOUT))) (* |;;| "Get theconnection ready to talk to") (|for| I |from| 1 |to| 5 |while| (SETQRESULT (\\UNIXMAIL.SMTP.FLUSH SMIN)) |do| NIL) (|if| RESULT |then|(CL:FORMAT SMOUT "~%.~%QUIT~%") (FORCEOUTPUT SMOUT) (\\LAFITE.SEND.FAILEDITORWINDOW (CL:FORMAT NIL "Coundn't open SMTP stream because ~a"RESULT)) |else| (|if| PWINDOW |then| (CLEARW PWINDOW) (CL:FORMATPWINDOW "Delivering ~:[~;formatted ~]to ~D recipient~:P" (|fetch|(UNIXMAILPARSE FORMATTED?) |of| PARSE) (LENGTH (|fetch| (UNIXMAILPARSEUNIXTO) |of| PARSE)))) (|if| (SETQ RESULT (CL:CATCH (QUOTE SMTP-LOST)(PROGN (* |;;| "First handle who it's from") (\\UNIXMAIL.SMTP SMINSMOUT (CL:FORMAT NIL "MAIL FROM: ~a~%" (|fetch| (LAFITEMODEDATASHORTUSERNAME) |of| *LAFITE-MODE-DATA*))) (* |;;| "Then therecipients") (|for| R |in| (|fetch| (UNIXMAILPARSE UNIXTO) |of| PARSE)|do| (\\UNIXMAIL.SMTP SMIN SMOUT (CL:FORMAT NIL "RCPT TO: ~a~%" R))) (*|;;| "Print a '.' to show we're this far") (AND PWINDOW (|printout|PWINDOW (QUOTE \.))) (* |;;| "Then the message itself; the SMTPresponse here is a 300-range number meaning \"Lay it on me\"")(\\UNIXMAIL.SMTP SMIN SMOUT "DATA~%" 300 399) (* |;;| "First hose outthe other fields") (|for| F |in| (|fetch| (UNIXMAILPARSE UNIXOTHER)|of| PARSE) |do| (CL:FORMAT SMOUT "~a: ~a~%" (CAR F) (CADR F))|finally| (|if| (|fetch| (UNIXMAILPARSE FORMATTED?) |of| PARSE) |then|(CL:FORMAT SMOUT "Format: ~a~%" (|fetch| (UNIXMAILPARSE FORMATTED?)|of| PARSE))) (TERPRI SMOUT)) (* |;;| "Print a '.' to show we're thisfar") (AND PWINDOW (|printout| PWINDOW (QUOTE \.))) (* |;;| "SMTP-DUMPis here to handle the case of lines beginning with '.': the '.' must bedoubled when talking to the SMTP server.") (CL:FLET ((SMTP-DUMP(INSTREAM OUTSTREAM) (BIND NEXTCHAR WHILE (NOT (EOFP INSTREAM)) DO(PRINTCCODE (SETQ NEXTCHAR (READCCODE INSTREAM)) OUTSTREAM) (IF (EQ(CHARCODE NEWLINE) NEXTCHAR) THEN (BLOCK) (* \; "A reasonable place toblock...") (IF (EQ (CHARCODE \.) (PEEKCCODE INSTREAM T)) THEN(PRINTCCODE (CHARCODE \.) OUTSTREAM)))))) (|if| (TEDIT.FORMATTEDFILEPMSG) |then| (SELECTQ (|fetch| (UNIXMAILPARSE FORMATTED?) |of| PARSE)(TEDIT (\\LAFITE.SEND.FAIL EDITORWINDOW "UNIX mode can't send rawTEdit; try TEdit-UUencoded")) (TEDIT-UUENCODE (* |;;| "Nuke the headerin a copy of the msg") (SETQ MSG (COPYTEXTSTREAM MSG)) (TEDIT.DELETEMSG 1 (|fetch| (UNIXMAILPARSE UNIXBODY) |of| PARSE))(UNIX.TEDIT-UUENCODE.MESSAGE MSG SMOUT)) (NIL (* |;;| "Strip TEditformatting") (SMTP-DUMP (LAFITE.MAKE.PLAIN.TEXTSTREAM MSG (|fetch|(UNIXMAILPARSE UNIXBODY) |of| PARSE)) SMOUT)) (\\LAFITE.SEND.FAILEDITORWINDOW (CL:FORMAT NIL "Strange Format: ~A" (|fetch|(UNIXMAILPARSE FORMATTED?) |of| PARSE)))) |else| (SMTP-DUMP MSGSMOUT))) (\\UNIXMAIL.SMTP SMIN SMOUT "~%.~%") (* |;;| "Print a '.' toshow we're this far") (AND PWINDOW (|printout| PWINDOW (QUOTE \.)))(\\UNIXMAIL.SMTP SMIN SMOUT "QUIT~%")))) |then| (* |;;| "Try to closethe mconnection; what we really need is a way to nuke the process associated with the SMTP stream.") (CL:FORMAT SMOUT "~%.~%QUIT~%")(FORCEOUTPUT SMOUT) (\\LAFITE.SEND.FAIL EDITORWINDOW (CL:FORMAT NIL"SMTP error is ~a" RESULT)) |else| (LENGTH (|fetch| (UNIXMAILPARSEUNIXTO) |of| PARSE)))))))) )(\\UNIXMAIL.SEND.PARSE (LAMBDA (MSG EDITORWINDOW)                              (* \; "Edited 13-Jan-89 18:50 by bane")    (* |;;| "Do some obvious checks here and build a \\UNIXMAILPARSEfor UNIXMAIL.SEND to munch on")    (PROG ((MSGFIELDS (\\LAFITE.PREPARE.SEND MSG           EDITORWINDOW)) SENDINGFORMAT HEADEREOF FROMFIELD RECIPIENTS           OTHERSTUFF)          (|if| MSGFIELDS |then| (|if| (EQ              (CAAR MSGFIELDS)                                                                   'EOF) |then| (SETQ HEADEREOF (CADR                             (|pop| MSGFIELDS))))                    (|for| PAIR |in|                       MSGFIELDS |do| (SELECTQ (CAR PAIR)                                                                                                                                        (|Date|                                                   (\\SENDMESSAGEFAIL                                                   EDITORWINDOW                                                    "User-supplied Date                                                   not allowed"))                                                                                                                                            (|Sender|                                                     (\\SENDMESSAGEFAIL                                                     EDITORWINDOW                                                      "User-supplied                                                     Sender not                                                     allowed"))                                                                            ((T\o |cc|)  (SETQ                                         RECIPIENTS (NCONC RECIPIENTS                                         (\\UNIXMAIL.PARSENAMES                                                                                                                                                             (CDR PAIR))))                                         (|push| OTHERSTUFF PAIR))                                                                               (|From| (SETQ                                            FROMFIELD                                            (\\UNIXMAIL.PARSENAMES                                            (CDR PAIR))) (|push|                                            OTHERSTUFF PAIR))                                                                       (|Format| (SETQ SENDINGFORMAT (CADR                                    PAIR))) (|push| OTHERSTUFF                                    PAIR)))                    (|if| (NULL RECIPIENTS)                        |then| (\\SENDMESSAGEFAIL EDITORWINDOW "No                        recipients!")                              (RETURN NIL))                    (|if| (NULL SENDINGFORMAT)                                                                                                                                                                                                                                                                                            |then|                                                                  (SETQ                                                                  SENDINGFORMAT                                                                  (OR                                                                  (\\LAFITE.CHOOSE.MSG.FORMAT                                                                  MSG                                                                  HEADEREOF                                                                  EDITORWINDOW)                                                                              (RETURN)))) (RETURN (|create|                    UNIXMAILPARSE                                                                     UNIXFROM _ FROMFIELD UNIXTO _                                   RECIPIENTS UNIXOTHER _ OTHERSTUFF                                   UNIXBODY _ HEADEREOF FORMATTED? _                                   (SELECTQ SENDINGFORMAT                                                                                                                                                                                                                            ((NIL                                                         TEXT)  NIL)                                                    SENDINGFORMAT)))))))(\\UNIXMAIL.SMTP (LAMBDA (SIN SOUT STRING LO HI) (* \; "Edited13-Sep-90 16:11 by jrb:") (* |;;| "Very dumb protocol handler; showsSTRING to STREAM and reads the response number, returning T or NILdepending on the rangOW6'_≤"MOO  ∞+	  ≤°o   Ao     	  hM  …ºMO@hChlLO≤MO@O  øMO  øM  … çO@KO    øi∏KO  …Oÿÿ[dlÂj¢±˛˙ø  ±˛Ò (321 BLOCK 291 CONDITIONAL-PARSER 288 BCE-PARSER 269 ADD-ERROR-ENTRY 262 CONDITIONAL-PARSER 225 ADD-LINE 222 CONCAT 208 \\FZEROP 203 INLINE-EXPAND 170 \\MVLIST 167 OPERAND-GET 145 ADD-CASE 102 ELT 88 ELT 41 ADD-FN-HEADER-INFO 21 TERPRI 15 PRIN1 8 PRIN1)
(300 BYTE-INFO-REC 276 TRANSLATION-REC 231 TRANSLATION-REC 177 SMALL-CONST 155 TRANSLATION-REC 139 TRANSLATION-REC 133 BYTE-INFO-REC 126 BYTE-INFO-REC 118 BYTE-INFO-REC 93 BYTE-INFO-REC)
( 219 " */ } " 214 "/* exit " 3 "Translation Pass 2: ")
CONDITIONAL-PARSER :D5
(P 3 SI::%$$OBJECT P 2 |next-next-rec| P 1 |next-opcode-rec| P 0 |next-rec| I 3 |operand-string| I 2 FN-NAME I 1 BYTE-REC I 0 TRANS-REC F 4 *INFO-REC* F 5 *ERROR-STACK* F 6 *IGNORE-JUMP*)  A  …!H  …πH  …∫H  …g  ¢± ∑@  …¢± ≠H  …í± £  CK√  ≤4Idg  •dg  íøiÅøhîo   Éo   Co   H  …o     ∞3Idg  •dg  íøiÅøhîo   Éo   hCo   H  …o       ø@  … ≤o   J  … o     i  ÇicøJ  ii@  …ïCT  @  … ¶@  …ì  ø@  …òCUT  co   Co      (275 ADD-OPERAND-LINE 260 ADD-PUSH-OPERAND-LINE 246 PUSH-ALL-OPERANDS 228 OPERAND-PUSH 202 ADD-LINE 198 CONCAT 172 ADD-OPERAND-LINE 169 CONCAT 118 CONCAT 59 PUSH-ALL-OPERANDS)
(251 TRANSLATION-REC 240 TRANSLATION-REC 233 TRANSLATION-REC 220 TRANSLATION-REC 211 BYTE-INFO-REC 189 BYTE-INFO-REC 177 TRANSLATION-REC 160 BYTE-INFO-REC 133 TJUMPX 127 TJUMP 109 BYTE-INFO-REC 83 TJUMPX 77 TJUMP 67 LINE-INFO-REC 50 BYTE-INFO-REC 40 TRANSLATION-REC 31 CJUMP 26 BYTE-INFO-REC 19 BYTE-INFO-REC 12 BYTE-INFO-REC 3 BYTE-INFO-REC)
( 272 ";" 267 "	" 195 ";" 185 "goto pc" 166 "; }" 156 ")) {goto pc" 150 "	if (!(" 145 "	if ((" 115 "; }"
 105 ")) {goto pc" 100 "	if (!(" 95 "	if ((")
INLINE-EXPAND :D5
(P 42 PARM P 38 ERROR-LINE-INFO-REC P 37 TOS-IS-DEFERRED P 36 TOS-1-IS-DEFERRED P 35 SAVE-ERROR-STACK P 34 LINE P 29 PARM P 25 PARM P 21 INLINE-LINE-INFO P 20 INLINE-PARMS P 16 CALL-ACTUALS P 15 PATTERN-LIST P 14 INLINE-LINES P 13 NEW-LINE-INFO-REC P 12 ERROR-RETRY-PARMS P 11 ERROR-RETRY-STRING P 10 TOS-1-CALL-VALUE P 9 TOS-CALL-VALUE P 8 |new-lines| P 7 \n P 6 |argcount| P 5 |error-pc| P 4 |inline-name| P 3 |may-ufn| P 2 |pc| P 1 *TOS-VAL* P 0 *TOS-INFO* I 2 EXPANSION-LIST I 1 BYTE-REC I 0 TRANS-REC F 43 *ERROR-STACK* F 44 *ARG-COUNT* F 45 *INLINE-ERROR-STACK*) ÷+ @A  … ∫@  … ªo   BJ  o   J  qjæA  …_øh___ø@  …_ø@  …_ø`  1@B∞xd_(ø`  O*  O( øO*  O(øO*  0O(∞'dO2@Ahd
  _,øO.µ	OSERNAME _ FULLNAME UNPACKEDUSERNAME _ FULLNAME SHORTUSERNAME _FULLNAME MAILSERVERS _ (LIST (|create| MAILSERVER MAILSERVERNAME _"Unix mail" MAILSERVEROPS _ (OR (CDR (FASSOC UNIXMAIL.RECEIVE.MODEUNIXMAIL.MSOPS.LIST)) (ERROR "Not a known Unix mail receive mode"UNIXMAIL.RECEIVE.MODE))))))) )(\\UNIXMAIL.LOGIN (LAMBDA NIL                                             (* \; "Edited  4-Jan-89 13:29 by bane")    (|if| (EQ (MACHINETYPE) 'MAIKO)        |then| (\\LAFITE.GET.USER.DATA 'UNIX NIL T)              (\\LAFITE.WAKE.WATCHER)      |else| (PROMPTPRINT "No Unix mode; this isn't Maiko"))))(\\UNIXMAIL.PARSENAMES (LAMBDA (FIELD)                                         (* \; "Edited  4-Jan-89 15:41 by bane")    (* |;;| "Just returns a list of the comma-seperated fields inthis string")    (|if| (CL:CONSP FIELD) |then| (MAPCONC FIELD        #'\\UNIXMAIL.PARSENAMES)      |else| (COND (FIELD (|bind| ADDR                    (START _ 1)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       COMMA                                                                      |when|                                                                      (PROGN                                                                      (SETQ                                                                      ADDR                                                                      (SUBSTRING                                                                      FIELD                                                                      START                                                                      (COND                                                                         ((SETQ COMMA (STRPOS '\, FIELD                                                                           START))                                                                                                                                                                                                                                                                                                                                                                       (SUB1                                                          COMMA)))))                                                          (|do|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (*                                                                 \;                                                                 "Strip                                                                 leading                                                                 blanks")                                                                 (SELCHARQ                                                                 (CHCON1                                                                 ADDR)                                                                      ((SPACE TAB)  (GNC                                                                           ADDR))                                                                                                                                                                                                                                                                                                                                                                   (RETURN)))                                                          (|do|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (*                                                                 \;                                                                 "Strip                                                                 trailing                                                                 blanks")                                                                 (SELCHARQ                                                                 (NTHCHARCODE                                                                 ADDR                                                                 -1)                                                                      ((SPACE TAB)  (GLC                                                                           ADDR))                                                                                                                                                                                                                                                                                                                                                                   (RETURN)))                                                          (NEQ (NCHARS                                                          ADDR)                                                                                            0)) |collect|                              ADDR |repeatwhile| (COND                                                   (COMMA (SETQ START(ADD1 COMMA))))))))))(\\UNIXMAIL.MAKEANSWERFORM (LAMBDA (MSGDESCRIPTORS MAILFOLDER) (*\; "Edited 25-Aug-89 21:01 by jrb:") (* |;;| " Code borrowed liberallyfrom GV.MAKEANSWERFORM") (LET ((MSGFIELDS (\\LAFITE.PARSE.MESSAGEMAILFOLDER (OR (CAR (LISTP MSGDESCRIPTORS)) MSGDESCRIPTORS))) SUBJECTFROM DATE SENDER REPLYTO TO CC OLDFROM NEWTO NEWCC) (* \; "get thefields from the file") (|for| PAIR |in| MSGFIELDS |do| (SELECTQ (CARPAIR) (|Subject| (SETQ SUBJECT (CADR PAIR))) (|Sender| (SETQ SENDER(CADR PAIR))) (|From| (SETQ FROM (CADR PAIR))) (|Date| (SETQ DATE (CADRPAIR))) (|Reply-to| (SETQ REPLYTO (CDR PAIR))) (T\o (SETQ TO (CDRPAIR))) (|cc| (SETQ CC (CDR PAIR))) NIL)) (* |;;| "first parse thestrings into recipients.  Need to find the sender's registry in orderto get the registry defaults correct for its recipients.") (COND(SENDER (* \; "Sender is a mail address, and has the officialregistry") (SETQ OLDFROM (\\UNIXMAIL.PARSENAMES SENDER)) (* \;"Elements are of the form (prettyname gvname . registry)") (|if| FROM|then| (* \; "Now that we have a source of official registry (we hope),parse the From field with reference to it.") (SETQ OLDFROM(\\UNIXMAIL.PARSENAMES FROM)))) (FROM (* \; "Have to parse the Fromfield before we can get its registry") (SETQ OLDFROM(\\UNIXMAIL.PARSENAMES FROM)))) (|if| (NULL OLDFROM) |then|(LAB.PROMPTPRINT MAILFOLDER T "Warning: message has no FROM field"))(AND TO (SETQ TO (\\UNIXMAIL.PARSENAMES TO))) (AND CC (SETQ CC(\\UNIXMAIL.PARSENAMES CC))) (SETQ NEWTO (OR (AND REPLYTO (SETQ REPLYTO(\\UNIXMAIL.PARSENAMES REPLYTO))) OLDFROM)) (SETQ NEWCC(LISP:SET-DIFFERENCE (COND (REPLYTO (* \; "Reply goes only to thisaddress, so the only cc is to self") (MKLIST (|fetch| (LAFITEMODEDATASHORTUSERNAME) |of| *LAFITE-MODE-DATA*))) (T (* \; "By default CCeveryone who received the original message and to whom we are notdirectly replying already") (APPEND TO (LISP:SET-DIFFERENCE CC TO :TEST(LISP:FUNCTION STRING-EQUAL))))) NEWTO :TEST (LISP:FUNCTIONSTRING-EQUAL))) (LAFITE.FILL.IN.ANSWER.FORM SUBJECT (|if| (AND (OR(NULL REPLYTO) (EQUAL REPLYTO OLDFROM)) (NULL (CDR NEWCC)) (OR (NULLNEWCC) (STRING-EQUAL (CAR NEWCC) (|fetch| (LAFITEMODEDATASHORTUSERNAME) |of| *LAFITE-MODE-DATA*)))) |then| (* \; "Replying onlyto sender (and maybe self), so just say \"your\" instead of \"Joe BobSmith <JBSmith.pa>'s\"") NIL |else| FROM) DATE NEWTO NEWCC(LISP:FUNCTION LA.PRINT.COMMA.LIST)))) )(\\UNIXMAIL.MESSAGE.FROM.SELF.P (LAMBDA (MSG)                                           (* \; "Edited  6-Dec-88 15:41 by bane")    (* |;;| "For the moment, we send stuff with our SHORTUSERNAMEonly in the FROM field")    (STRING-EQUAL (|fetch| (LAFITEMSG FROM) |of|           MSG) (|fetch| (LAFITEMODEDATA SHORTUSERNAME) |of|           *LAFITE-MODE-DATA*))))(\\UNIXMAIL.MESSAGE.P (LAMBDA (MSG)                                           (* \; "Edited  6-Dec-88 15:39 by bane")    (* |;;| "We're guessing here; basically if it doesn't look likean NS message, say maybe.")    (AND (NOT (STRPOS ":" (|fetch| (LAFITEMSG FROM)         |of| MSG))) '?))))(* |;;|  "This is a stub needed by the TEdit-uuencode strategy; if weever decide on a reasonable way to do this and make it part of Lafite,this may go away" )(MOVD? (QUOTE NILL) (QUOTE UNIX.UUDECODE.IF.NEEDED)) (PUTPROPS UNIXMAILCOPYRIGHT ("ENVOS Corporation" 1989 1990)) (DECLARE\: DONTCOPY  (FILEMAP (NIL (4457 12225 (UNIX.POLLNEWMAIL 4467 . 5502)(UNIX.NEXTMESSAGE 5504 . 5680) ( UNIXMAILER.OPENMAILBOX 5682 . 7458)(UNIXMAILER.RETRIEVEMESSAGE 7460 . 8451) (UNIXMAILER.CLOSEMAILBOX  8453. 9101) (UNIXSPOOL.OPENMAILBOX 9103 . 10852) (UNIXSPOOL.RETRIEVEMESSAGE10854 . 11661) ( UNIXSPOOL.CLOSEMAILBOX 11663 . 12223)) (12273 21054(UNIX.FLUSH.STREAM 12283 . 12677) ( UNIX.RETRIEVE.LINE 12679 . 13326)(\\UNIXMAIL.SEND 13328 . 17194) (\\UNIXMAIL.SEND.PARSE 17196 . 19890 )(\\UNIXMAIL.SMTP 19892 . 20351) (\\UNIXMAIL.SMTP.FLUSH 20353 . 21052))(22109 28684 ( \\UNIXMAIL.AUTHENTICATE 22119 . 22969) (\\UNIXMAIL.LOGIN22971 . 23316) (\\UNIXMAIL.PARSENAMES 23318 . 25548) (\\UNIXMAIL.MAKEANSWERFORM 25550 . 27973)(\\UNIXMAIL.MESSAGE.FROM.SELF.P 27975 . 28361) ( \\UNIXMAIL.MESSAGE.P28363 . 28682))))) STOP