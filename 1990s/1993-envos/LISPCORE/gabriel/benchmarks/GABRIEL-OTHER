(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE (DEFPACKAGE "GABRIEL"))(IL:FILECREATED "28-Jun-88 17:26:33" IL:{ERIS}<LISPCORE>GABRIEL>BENCHMARKS>GABRIEL-OTHER.\;6 64944        IL:|changes| IL:|to:|  (IL:VARIABLES *CONSY-BENCHMARKS*)                             (IL:VARS IL:GABRIEL-OTHERCOMS)      IL:|previous| IL:|date:| "27-Jun-88 10:02:52" IL:{ERIS}<LISPCORE>GABRIEL>BENCHMARKS>GABRIEL-OTHER.\;5); Copyright (c) 1987, 1988 by Xerox Corporation.  All rights reserved.(IL:PRETTYCOMPRINT IL:GABRIEL-OTHERCOMS)(IL:RPAQQ IL:GABRIEL-OTHERCOMS           ((IL:FILES IL:GABRIEL-TIMERS)           (IL:STRUCTURES TNODE)           (IL:VARIABLES TYPEMAX SIZE)           (IL:VARIABLES *A* *ALPHA* *B* *C* *D* *L *P *P* *R* *R2* *R3* *SERIES* *V* *X* *VAR ANSWER                  BOARD CLASS CLASSMAX COUNT FALSE FINAL III IM KOUNT MARKER PIECECOUNT PIECEMAX                   PUZZLE Q* RAND RE ROOT SEQUENCE SN TEMP-TEMP TRUE U* UNIFY-SUBST)           (IL:FUNCTIONS *DDERIV +DDERIV -DDERIV /DDERIV ADD ADD-LEMMA ADD-LEMMA-LST APPLY-SUBST                   APPLY-SUBST-LST BROWSE BROWSE-RANDOM CHAR1 CPLUS CREATE-N CREATE-STRUCTURE CTIMES                   DDERIV DDERIV-AUX DEFINEPIECE DERIV DERIV-AUX DESTRUCTIVE FALSEP FFT FIND-ROOT FIT                  GOGOGO INIT INVESTIGATE ITERATIVE-DIV2 ITERATIVE-DIV2-TEST LAST-POSITION MATCH                   ONE-WAY-UNIFY ONE-WAY-UNIFY1 ONE-WAY-UNIFY1-LST PCOEFADD PCOEFP PCPLUS PCPLUS1                   PCTIMES PCTIMES1 PDIFFER1 PEXPTSQ PLACE POINTERGP PPLUS PPLUS1 PSIMP PTIMES PTIMES1                  PTIMES2 PTIMES3 PUZZLE-REMOVE PZERO PZEROP RANDOMIZE RECURSIVE-DIV2                   RECURSIVE-DIV2-TEST REWRITE REWRITE-ARGS REWRITE-WITH-LEMMAS RUN-DDERIV RUN-DERIV                   RUN-ONE RUN-SERIES RUN-SERIES-TO-FILE SEED SETUP SETUP-DDERIV SETUP-FRPOLY SNB                   START TAUTOLOGYP TAUTP TEST TRANS-OF-IMPLIES TRANS-OF-IMPLIES1 TRAVERS TRAVERSE                   TRAVERSE-RANDOM TRAVERSE-REMOVE TRAVERSE-SELECT TRIAL TRIANG-TEST TRUEP TRY)           (IL:COMS                   (IL:* IL:|;;| "Modified version of browse which doesn't cons so much")                  (IL:FUNCTIONS CHAR1* BROWSE* INVESTIGATE* MATCH*)                  (TIMERS BROWSE*))           (IL:COMS                   (IL:* IL:|;;| "Modified version of traverse-init to break circularities")                  (IL:FUNCTIONS CREATE-STRUCTURE* TRAVERSE-REMOVE* RELEASE-TREE RELEASE-TREE-AUX)                  (TIMERS TRAVERSE* TRAVERSE-INIT*))           (IL:VARIABLES DIV2-L)           (IL:VARIABLES *CONSY-BENCHMARKS* *AREFY-BENCHMARKS* *POLY-BENCHMARKS*)           (TIMERS BOYER BROWSE DDERIV DERIV DESTRU DIV2-1 DIV2-2 FFT FRPOLY10R FRPOLY10R2 FRPOLY10R3                  FRPOLY15R FRPOLY15R2 FRPOLY15R3 FRPOLY2R FRPOLY2R2 FRPOLY2R3 FRPOLY5R FRPOLY5R2                   FRPOLY5R3 PUZZLE TRAVERSE TRAVERSE-INIT TRIANG)           (IL:DECLARE\: IL:DONTCOPY IL:DOEVAL@COMPILE (IL:LOCALVARS . T))           (IL:PROP (IL:FILETYPE IL:MAKEFILE-ENVIRONMENT)                  IL:GABRIEL-OTHER)))(IL:FILESLOAD IL:GABRIEL-TIMERS)(DEFSTRUCT TNODE   (PARENTS NIL)   (SONS NIL)   (SN (SNB))   (ENTRY1 NIL)   (ENTRY2 NIL)   (ENTRY3 NIL)   (ENTRY4 NIL)   (ENTRY5 NIL)   (ENTRY6 NIL)   (MARK NIL))(DEFCONSTANT TYPEMAX 12)(DEFCONSTANT SIZE 511)(DEFVAR *A*                 '           #37(1 2 4 3 5 6 1 3 6 2 5 4 11 12 13 7 8 4 4 7 11 8 12 13 6 10 15 9 14 13 13 14 15 9 10 6))(DEFVAR *ALPHA*)(DEFVAR *B*                 '#37(2 4 7 5 8 9 3 6 10 5 9 8 12 13 14 8 9 5 2 4 7 5 8 9 3 6 10 5 9 8 12 13 14 8 9 5))(DEFVAR *C*                 '           #37(4 7 11 8 12 13 6 10 15 9 14 13 13 14 15 9 10 6 1 2 4 3 5 6 1 3 6 2 5 4 11 12 13 7 8 4))(DEFVAR *D* 8)(DEFVAR *L)(DEFVAR *P)(DEFVAR *P* (MAKE-ARRAY (LIST (1+ TYPEMAX)                                  (1+ SIZE))))(DEFVAR *R*)(DEFVAR *R2*)(DEFVAR *R3*)(DEFPARAMETER *SERIES*   '(PUZZLE TRIANG FRPOLY2R FRPOLY2R2 FRPOLY2R3 FRPOLY5R FRPOLY5R2 FRPOLY5R3 FRPOLY10R FRPOLY10R2            FRPOLY10R3 FRPOLY15R FRPOLY15R2 FRPOLY15R3 BOYER BROWSE DESTRU TRAVERSE-INIT TRAVERSE TAK           STAK CTAK TAKL TAKR DERIV DDERIV DIV2-1 DIV2-2 FFT))(DEFVAR *V*)(DEFVAR *X*)(DEFVAR *VAR)(DEFVAR ANSWER)(DEFVAR BOARD '#16(1 1 1 1 1 0 1))(DEFVAR CLASS (MAKE-ARRAY (1+ TYPEMAX)                         ':INITIAL-ELEMENT 0))(DEFCONSTANT CLASSMAX 3)(DEFVAR COUNT 0)(DEFCONSTANT FALSE NIL)(DEFVAR FINAL)(DEFVAR III 0)(DEFVAR IM (MAKE-ARRAY 1025 :ELEMENT-TYPE 'SINGLE-FLOAT ':INITIAL-ELEMENT 0.0))(DEFVAR KOUNT 0)(DEFVAR MARKER NIL)(DEFVAR PIECECOUNT (MAKE-ARRAY (1+ CLASSMAX)                              ':INITIAL-ELEMENT 0))(DEFVAR PIECEMAX (MAKE-ARRAY (1+ TYPEMAX)                            ':INITIAL-ELEMENT 0))(DEFVAR PUZZLE (MAKE-ARRAY (1+ SIZE)))(DEFVAR Q*)(DEFVAR RAND 21)(DEFVAR RE (MAKE-ARRAY 1025 :ELEMENT-TYPE 'SINGLE-FLOAT ':INITIAL-ELEMENT 0.0))(DEFVAR ROOT)(DEFVAR SEQUENCE (MAKE-ARRAY 14 ':INITIAL-ELEMENT 0))(DEFVAR SN 0)(DEFVAR TEMP-TEMP)(DEFCONSTANT TRUE T)(DEFVAR U*)(DEFVAR UNIFY-SUBST)(DEFUN *DDERIV (A)   (LIST '* (CONS '* A)         (CONS '+ (MAPCAR #'DDERIV-AUX A))))(DEFUN +DDERIV (A)   (CONS '+ (MAPCAR #'DDERIV A)))(DEFUN -DDERIV (A)   (CONS '- (MAPCAR #'DDERIV A)))(DEFUN /DDERIV (A)   (LIST '- (LIST '/ (DDERIV (CAR A))                  (CADR A))         (LIST '/ (CAR A)               (LIST '* (CADR A)                     (CADR A)                     (DDERIV (CADR A))))))(DEFUN ADD (A Q)   (COND      ((NULL Q)       `(,(LET ((X `(,A)))               (RPLACD X X)               X)))      ((NULL (CAR Q))       (LET ((X `(,A)))            (RPLACD X X)            (RPLACA Q X)))      (T (RPLACA Q (RPLACD (CAR Q)                          `(,A . ,(CDR (CAR Q))))))))(DEFUN ADD-LEMMA (TERM)   (COND      ((AND (NOT (ATOM TERM))            (EQ (CAR TERM)                'EQUAL)            (NOT (ATOM (CADR TERM))))       (PUSHNEW TERM (GET (CAR (CADR TERM))                          'LEMMAS)              :TEST              #'EQUAL))      (T (ERROR "Add lemma did not like term"))))(DEFUN ADD-LEMMA-LST (LST)   (COND      ((NULL LST)       T)      (T (ADD-LEMMA (CAR LST))         (ADD-LEMMA-LST (CDR LST)))))(DEFUN APPLY-SUBST (ALIST TERM)   (COND      ((ATOM TERM)       (COND          ((SETQ TEMP-TEMP (ASSOC TERM ALIST))           (CDR TEMP-TEMP))          (T TERM)))      (T (CONS (CAR TERM)               (APPLY-SUBST-LST ALIST (CDR TERM))))))(DEFUN APPLY-SUBST-LST (ALIST LST)   (COND      ((NULL LST)       NIL)      (T (CONS (APPLY-SUBST ALIST (CAR LST))               (APPLY-SUBST-LST ALIST (CDR LST))))))(DEFUN BROWSE ()   (SETF RAND 21)   (INVESTIGATE (RANDOMIZE (INIT 100 10 4                                 '((A A A B B B B A A A A A B B A A A)                                   (A A B B B B A A (A A)                                      (B B))                                   (A A A B (B A)                                      B A B A))))          '((*A ?B *B ?B A *A A *B *A)            (*A *B *B *A (*A)                (*B))            (? ? * (B A)               * ? ?))))(DEFUN BROWSE-RANDOM ()   (SETQ RAND (MOD (* RAND 17)                   251)))(DEFMACRO CHAR1 (X)   `(AREF (SYMBOL-NAME ,X)          0))(DEFMACRO CPLUS (X Y)   `(+ ,X ,Y))(DEFUN CREATE-N (N)   (DO ((N N (1- N))        (A NIL (PUSH NIL A)))       ((= N 0)        A)))(DEFUN CREATE-STRUCTURE (N)   (LET ((A `(,(MAKE-TNODE))))        (DO ((M (1- N)                (1- M))             (P A))            ((= M 0)             (SETQ A `(,(RPLACD P A)))             (DO ((UNUSED A)                  (USED (ADD (TRAVERSE-REMOVE 0 A)                             NIL))                  (X)                  (Y))                 ((NULL (CAR UNUSED))                  (FIND-ROOT (TRAVERSE-SELECT 0 USED)                         N))               (SETQ X (TRAVERSE-REMOVE (REM (TRAVERSE-RANDOM)                                             N)                              UNUSED))               (SETQ Y (TRAVERSE-SELECT (REM (TRAVERSE-RANDOM)                                             N)                              USED))               (ADD X USED)               (SETF (TNODE-SONS Y)                     `(,X . ,(TNODE-SONS Y)))               (SETF (TNODE-PARENTS X)                     `(,Y . ,(TNODE-PARENTS X)))))          (PUSH (MAKE-TNODE)                A))))(DEFMACRO CTIMES (X Y)   `(* ,X ,Y))(DEFUN DDERIV (A)   (COND      ((ATOM A)       (COND          ((EQ A 'X)           1)          (T 0)))      (T (LET ((DDERIV (GET (CAR A)                            'DDERIV)))              (COND                 (DDERIV (FUNCALL DDERIV (CDR A)))                 (T 'ERROR))))))(DEFUN DDERIV-AUX (A)   (LIST '/ (DDERIV A)         A))(DEFUN DEFINEPIECE (ICLASS II JJ KK)   (LET ((INDEX 0))        (DO ((I 0 (1+ I)))            ((> I II))          (DO ((J 0 (1+ J)))              ((> J JJ))            (DO ((K 0 (1+ K)))                ((> K KK))              (SETQ INDEX (+ I (* *D* (+ J (* *D* K)))))              (SETF (AREF *P* III INDEX)                    TRUE))))        (SETF (AREF CLASS III)              ICLASS)        (SETF (AREF PIECEMAX III)              INDEX)        (COND           ((NOT (= III TYPEMAX))            (SETQ III (+ III 1))))))(DEFUN DERIV (A)   (COND      ((ATOM A)       (COND          ((EQ A 'X)           1)          (T 0)))      ((EQ (CAR A)           '+)       (CONS '+ (MAPCAR #'DERIV (CDR A))))      ((EQ (CAR A)           '-)       (CONS '- (MAPCAR #'DERIV (CDR A))))      ((EQ (CAR A)           '*)       (LIST '* A (CONS '+ (MAPCAR 'DERIV-AUX (CDR A)))))      ((EQ (CAR A)           '/)       (LIST '- (LIST '/ (DERIV (CADR A))                      (CADDR A))             (LIST '/ (CADR A)                   (LIST '* (CADDR A)                         (CADDR A)                         (DERIV (CADDR A))))))      (T 'ERROR)))(DEFUN DERIV-AUX (A)   (LIST '/ (DERIV A)         A))(DEFUN DESTRUCTIVE (N M)   (LET ((L (DO ((I 10 (1- I))                 (A NIL (PUSH NIL A)))                ((= I 0)                 A))))        (DO ((I N (1- I)))            ((= I 0))          (COND             ((NULL (CAR L))              (DO ((L L (CDR L)))                  ((NULL L))                (OR (CAR L)                    (RPLACA L (CONS NIL NIL)))                (NCONC (CAR L)                       (DO ((J M (1- J))                            (A NIL (PUSH NIL A)))                           ((= J 0)                            A)))))             (T (DO ((L1 L (CDR L1))                     (L2 (CDR L)                         (CDR L2)))                    ((NULL L2))                  (RPLACD (DO ((J (FLOOR (LENGTH (CAR L2))                                         2)                                  (1- J))                               (A (CAR L2)                                  (CDR A)))                              ((= J 0)                               A)                            (RPLACA A I))                         (LET ((N (FLOOR (LENGTH (CAR L1))                                         2)))                              (COND                                 ((= N 0)                                  (RPLACA L1 NIL)                                  (CAR L1))                                 (T (DO ((J N (1- J))                                         (A (CAR L1)                                            (CDR A)))                                        ((= J 1)                                         (PROG1 (CDR A)                                                (RPLACD A NIL)))                                      (RPLACA A I))))))))))))(DEFUN FALSEP (X LST)   (OR (EQUAL X '(F))       (MEMBER X LST :TEST #'EQUAL)))(DEFUN FFT (AREAL AIMAG)   (PROG (AR AI I J K M N LE LE1 IP NV2 NM1 UR UI WR WI TR TI)         (SETQ AR AREAL AI AIMAG N (ARRAY-DIMENSION AR 0)               N               (1- N)               NV2               (FLOOR N 2)               NM1               (1- N)               M 0 I 1)     L1  (COND            ((< I N)             (SETQ M (1+ M)                   I                   (+ I I))             (GO L1)))         (COND            ((NOT (EQUAL N (EXPT 2 M)))             (PRINC "Error ... array size not a power of two.")             (READ)             (RETURN (TERPRI))))         (SETQ J 1 I 1)     L3  (COND            ((< I J)             (SETQ TR (AREF AR J)                   TI                   (AREF AI J))             (SETF (AREF AR J)                   (AREF AR I))             (SETF (AREF AI J)                   (AREF AI I))             (SETF (AREF AR I)                   TR)             (SETF (AREF AI I)                   TI)))         (SETQ K NV2)     L6  (COND            ((< K J)             (SETQ J (- J K)                   K                   (FLOOR K 2))             (GO L6)))         (SETQ J (+ J K)               I               (1+ I))         (COND            ((< I N)             (GO L3)))         (DO ((L 1 (1+ L)))             ((> L M))           (SETQ LE (EXPT 2 L)                 LE1                 (FLOOR LE 2)                 UR 1.0 UI 0 WR (COS (/ PI (FLOAT LE1)))                 WI                 (SIN (/ PI (FLOAT LE1))))           (DO ((J 1 (1+ J)))               ((> J LE1))             (DO ((I J (+ I LE)))                 ((> I N))               (SETQ IP (+ I LE1)                     TR                     (- (* (AREF AR IP)                           UR)                        (* (AREF AI IP)                           UI))                     TI                     (+ (* (AREF AR IP)                           UI)                        (* (AREF AI IP)                           UR)))               (SETF (AREF AR IP)                     (- (AREF AR I)                        TR))               (SETF (AREF AI IP)                     (- (AREF AI I)                        TI))               (SETF (AREF AR I)                     (+ (AREF AR I)                        TR))               (SETF (AREF AI I)                     (+ (AREF AI I)                        TI))))           (SETQ TR (- (* UR WR)                       (* UI WI))                 TI                 (+ (* UR WI)                    (* UI WR))                 UR TR UI TI))         (RETURN T)))(DEFUN FIND-ROOT (TNODE N)   (DO ((N N (1- N)))       ((= N 0)        TNODE)     (COND        ((NULL (TNODE-PARENTS TNODE))         (RETURN TNODE))        (T (SETQ TNODE (CAR (TNODE-PARENTS TNODE)))))))(DEFUN FIT (I J)   (LET ((END (AREF PIECEMAX I)))        (DO ((K 0 (1+ K)))            ((> K END)             TRUE)          (COND             ((AREF *P* I K)              (COND                 ((AREF PUZZLE (+ J K))                  (RETURN FALSE))))))))(DEFUN GOGOGO (I)   (DOTIMES (J 16)       (SETF (AREF BOARD J)             1))   (SETF (AREF BOARD 5)         0)   (LET ((ANSWER NIL)         (FINAL NIL))        (TRY I 1)))(DEFUN INIT (N M NPATS IPATS)   (LET ((IPATS (COPY-TREE IPATS)))        (DO ((P IPATS (CDR P)))            ((NULL (CDR P))             (RPLACD P IPATS)))        (DO ((N N (1- N))             (I M (COND                     ((= I 0)                      M)                     (T (1- I))))             (NAME (GENSYM)                   (GENSYM))             (A NIL))            ((= N 0)             A)          (PUSH NAME A)          (DO ((I I (1- I)))              ((= I 0))            (SETF (GET NAME (GENSYM))                  NIL))          (SETF (GET NAME 'PATTERN)                (DO ((I NPATS (1- I))                     (IPATS IPATS (CDR IPATS))                     (A NIL))                    ((= I 0)                     A)                  (PUSH (CAR IPATS)                        A)))          (DO ((J (- M I)                  (1- J)))              ((= J 0))            (SETF (GET NAME (GENSYM))                  NIL)))))(DEFUN INVESTIGATE (UNITS PATS)   (DO ((UNITS UNITS (CDR UNITS)))       ((NULL UNITS))     (DO ((PATS PATS (CDR PATS)))         ((NULL PATS))       (DO ((P (GET (CAR UNITS)                    'PATTERN)               (CDR P)))           ((NULL P))         (MATCH (CAR PATS)                (CAR P)                NIL)))))(DEFUN ITERATIVE-DIV2 (L)   (DO ((L L (CDDR L))        (A NIL (PUSH (CAR L)                     A)))       ((NULL L)        A)))(DEFUN ITERATIVE-DIV2-TEST (L)   (DO ((I 300 (1- I)))       ((= I 0))     (ITERATIVE-DIV2 L)     (ITERATIVE-DIV2 L)     (ITERATIVE-DIV2 L)     (ITERATIVE-DIV2 L)))(DEFUN LAST-POSITION ()   (DO ((I 1 (1+ I)))       ((= I 16)        0)     (IF (= 1 (AREF BOARD I))         (RETURN I))))(DEFUN MATCH (PAT DAT ALIST)   (COND      ((NULL PAT)       (NULL DAT))      ((NULL DAT)       NIL)      ((OR (EQ (CAR PAT)               '?)           (EQ (CAR PAT)               (CAR DAT)))       (MATCH (CDR PAT)              (CDR DAT)              ALIST))      ((EQ (CAR PAT)           '*)       (OR (MATCH (CDR PAT)                  DAT ALIST)           (MATCH (CDR PAT)                  (CDR DAT)                  ALIST)           (MATCH PAT (CDR DAT)                  ALIST)))      (T (COND            ((ATOM (CAR PAT))             (COND                ((EQL (CHAR1 (CAR PAT))                      #\?)                 (LET ((VAL (ASSOC (CAR PAT)                                   ALIST)))                      (COND                         (VAL (MATCH (CONS (CDR VAL)                                           (CDR PAT))                                     DAT ALIST))                         (T (MATCH (CDR PAT)                                   (CDR DAT)                                   (CONS (CONS (CAR PAT)                                               (CAR DAT))                                         ALIST))))))                ((EQL (CHAR1 (CAR PAT))                      #\*)                 (LET ((VAL (ASSOC (CAR PAT)                                   ALIST)))                      (COND                         (VAL (MATCH (APPEND (CDR VAL)                                            (CDR PAT))                                     DAT ALIST))                         (T (DO ((L NIL (NCONC L (CONS (CAR D)                                                       NIL)))                                 (E (CONS NIL DAT)                                    (CDR E))                                 (D DAT (CDR D)))                                ((NULL E)                                 NIL)                              (COND                                 ((MATCH (CDR PAT)                                         D                                         (CONS (CONS (CAR PAT)                                                     L)                                               ALIST))                                  (RETURN T))))))))))            (T (AND (NOT (ATOM (CAR DAT)))                    (MATCH (CAR PAT)                           (CAR DAT)                           ALIST)                    (MATCH (CDR PAT)                           (CDR DAT)                           ALIST)))))))(DEFUN ONE-WAY-UNIFY (TERM1 TERM2)   (PROGN (SETQ UNIFY-SUBST NIL)          (ONE-WAY-UNIFY1 TERM1 TERM2)))(DEFUN ONE-WAY-UNIFY1 (TERM1 TERM2)   (COND      ((ATOM TERM2)       (COND          ((SETQ TEMP-TEMP (ASSOC TERM2 UNIFY-SUBST))           (EQUAL TERM1 (CDR TEMP-TEMP)))          (T (SETQ UNIFY-SUBST (CONS (CONS TERM2 TERM1)                                     UNIFY-SUBST))             T)))      ((ATOM TERM1)       NIL)      ((EQ (CAR TERM1)           (CAR TERM2))       (ONE-WAY-UNIFY1-LST (CDR TERM1)              (CDR TERM2)))      (T NIL)))(DEFUN ONE-WAY-UNIFY1-LST (LST1 LST2)   (COND      ((NULL LST1)       T)      ((ONE-WAY-UNIFY1 (CAR LST1)              (CAR LST2))       (ONE-WAY-UNIFY1-LST (CDR LST1)              (CDR LST2)))      (T NIL)))(DEFUN PCOEFADD (E C X)   (IF (PZEROP C)       X       (CONS E (CONS C X))))(DEFMACRO PCOEFP (E)   `(ATOM ,E))(DEFUN PCPLUS (C P)   (IF (PCOEFP P)       (CPLUS P C)       (PSIMP (CAR P)              (PCPLUS1 C (CDR P)))))(DEFUN PCPLUS1 (C X)   (COND      ((NULL X)       (COND          ((PZEROP C)           NIL)          (T (CONS 0 (CONS C NIL)))))      ((PZEROP (CAR X))       (PCOEFADD 0 (PPLUS C (CADR X))              NIL))      (T (CONS (CAR X)               (CONS (CADR X)                     (PCPLUS1 C (CDDR X)))))))(DEFUN PCTIMES (C P)   (COND      ((PCOEFP P)       (CTIMES C P))      (T (PSIMP (CAR P)                (PCTIMES1 C (CDR P))))))(DEFUN PCTIMES1 (C X)   (COND      ((NULL X)       NIL)      (T (PCOEFADD (CAR X)                (PTIMES C (CADR X))                (PCTIMES1 C (CDDR X))))))(DEFUN PDIFFER1 (X Y)   X   Y   (ERROR "pdiffer2 called"))(DEFUN PEXPTSQ (P N)   (DO ((N (FLOOR N 2)           (FLOOR N 2))        (S (COND              ((ODDP N)               P)              (T 1))))       ((ZEROP N)        S)     (SETQ P (PTIMES P P))     (AND (ODDP N)          (SETQ S (PTIMES S P)))))(DEFUN PLACE (I J)   (LET ((END (AREF PIECEMAX I)))        (DO ((K 0 (1+ K)))            ((> K END))          (COND             ((AREF *P* I K)              (SETF (AREF PUZZLE (+ J K))                    TRUE))))        (SETF (AREF PIECECOUNT (AREF CLASS I))              (- (AREF PIECECOUNT (AREF CLASS I))                 1))        (DO ((K J (1+ K)))            ((> K SIZE)             0)          (COND             ((NOT (AREF PUZZLE K))              (RETURN K))))))(DEFMACRO POINTERGP (X Y)   `(> (GET ,X 'ORDER)       (GET ,Y 'ORDER)))(DEFUN PPLUS (X Y)   (COND      ((PCOEFP X)       (PCPLUS X Y))      ((PCOEFP Y)       (PCPLUS Y X))      ((EQ (CAR X)           (CAR Y))       (PSIMP (CAR X)              (PPLUS1 (CDR Y)                     (CDR X))))      ((POINTERGP (CAR X)              (CAR Y))       (PSIMP (CAR X)              (PCPLUS1 Y (CDR X))))      (T (PSIMP (CAR Y)                (PCPLUS1 X (CDR Y))))))(DEFUN PPLUS1 (X Y)   (COND      ((NULL X)       Y)      ((NULL Y)       X)      ((= (CAR X)          (CAR Y))       (PCOEFADD (CAR X)              (PPLUS (CADR X)                     (CADR Y))              (PPLUS1 (CDDR X)                     (CDDR Y))))      ((> (CAR X)          (CAR Y))       (CONS (CAR X)             (CONS (CADR X)                   (PPLUS1 (CDDR X)                          Y))))      (T (CONS (CAR Y)               (CONS (CADR Y)                     (PPLUS1 X (CDDR Y)))))))(DEFUN PSIMP (VAR X)   (COND      ((NULL X)       0)      ((ATOM X)       X)      ((ZEROP (CAR X))       (CADR X))      (T (CONS VAR X))))(DEFUN PTIMES (X Y)   (COND      ((OR (PZEROP X)           (PZEROP Y))       (PZERO))      ((PCOEFP X)       (PCTIMES X Y))      ((PCOEFP Y)       (PCTIMES Y X))      ((EQ (CAR X)           (CAR Y))       (PSIMP (CAR X)              (PTIMES1 (CDR X)                     (CDR Y))))      ((POINTERGP (CAR X)              (CAR Y))       (PSIMP (CAR X)              (PCTIMES1 Y (CDR X))))      (T (PSIMP (CAR Y)                (PCTIMES1 X (CDR Y))))))(DEFUN PTIMES1 (*X* Y)   (PROG (U* *V*)         (SETQ *V* (SETQ U* (PTIMES2 Y)))     A   (SETQ *X* (CDDR *X*))         (COND            ((NULL *X*)             (RETURN U*)))         (PTIMES3 Y)         (GO A)))(DEFUN PTIMES2 (Y)   (COND      ((NULL Y)       NIL)      (T (PCOEFADD (+ (CAR *X*)                      (CAR Y))                (PTIMES (CADR *X*)                       (CADR Y))                (PTIMES2 (CDDR Y))))))(DEFUN PTIMES3 (Y)   (PROG (E U C)     A1  (COND            ((NULL Y)             (RETURN NIL)))         (SETQ E (+ (CAR *X*)                    (CAR Y)))         (SETQ C (PTIMES (CADR Y)                        (CADR *X*)))         (COND            ((PZEROP C)             (SETQ Y (CDDR Y))             (GO A1))            ((OR (NULL *V*)                 (> E (CAR *V*)))             (SETQ U* (SETQ *V* (PPLUS1 U* (LIST E C))))             (SETQ Y (CDDR Y))             (GO A1))            ((= E (CAR *V*))             (SETQ C (PPLUS C (CADR *V*)))             (COND                ((PZEROP C)                 (SETQ U* (SETQ *V* (PDIFFER1 U* (LIST (CAR *V*)                                                       (CADR *V*))))))                (T (RPLACA (CDR *V*)                          C)))             (SETQ Y (CDDR Y))             (GO A1)))     A   (COND            ((AND (CDDR *V*)                  (> (CADDR *V*)                     E))             (SETQ *V* (CDDR *V*))             (GO A)))         (SETQ U (CDR *V*))     B   (COND            ((OR (NULL (CDR U))                 (< (CADR U)                    E))             (RPLACD U (CONS E (CONS C (CDR U))))             (GO E)))         (COND            ((PZEROP (SETQ C (PPLUS (CADDR U)                                    C)))             (RPLACD U (CDDDR U))             (GO D))            (T (RPLACA (CDDR U)                      C)))     E   (SETQ U (CDDR U))     D   (SETQ Y (CDDR Y))         (COND            ((NULL Y)             (RETURN NIL)))         (SETQ E (+ (CAR *X*)                    (CAR Y)))         (SETQ C (PTIMES (CADR Y)                        (CADR *X*)))     C   (COND            ((AND (CDR U)                  (> (CADR U)                     E))             (SETQ U (CDDR U))             (GO C)))         (GO B)))(DEFUN PUZZLE-REMOVE (I J)   (LET ((END (AREF PIECEMAX I)))        (DO ((K 0 (1+ K)))            ((> K END))          (COND             ((AREF *P* I K)              (SETF (AREF PUZZLE (+ J K))                    FALSE))))        (SETF (AREF PIECECOUNT (AREF CLASS I))              (+ (AREF PIECECOUNT (AREF CLASS I))                 1))))(DEFMACRO PZERO ()   0)(DEFMACRO PZEROP (X)   `(AND (NUMBERP ,X)         (ZEROP ,X)))(DEFUN RANDOMIZE (L)   (DO ((A NIL))       ((NULL L)        A)     (LET ((N (MOD (BROWSE-RANDOM)                   (LENGTH L))))          (COND             ((= N 0)              (PUSH (CAR L)                    A)              (SETQ L (CDR L)))             (T (DO ((N N (1- N))                     (X L (CDR X)))                    ((= N 1)                     (PUSH (CADR X)                           A)                     (RPLACD X (CDDR X)))))))))(DEFUN RECURSIVE-DIV2 (L)   (COND      ((NULL L)       NIL)      (T (CONS (CAR L)               (RECURSIVE-DIV2 (CDDR L))))))(DEFUN RECURSIVE-DIV2-TEST (L)   (DO ((I 300 (1- I)))       ((= I 0))     (RECURSIVE-DIV2 L)     (RECURSIVE-DIV2 L)     (RECURSIVE-DIV2 L)     (RECURSIVE-DIV2 L)))(DEFUN REWRITE (TERM)   (COND      ((ATOM TERM)       TERM)      (T (REWRITE-WITH-LEMMAS (CONS (CAR TERM)                                    (REWRITE-ARGS (CDR TERM)))                (GET (CAR TERM)                     'LEMMAS)))))(DEFUN REWRITE-ARGS (LST)   (COND      ((NULL LST)       NIL)      (T (CONS (REWRITE (CAR LST))               (REWRITE-ARGS (CDR LST))))))(DEFUN REWRITE-WITH-LEMMAS (TERM LST)   (COND      ((NULL LST)       TERM)      ((ONE-WAY-UNIFY TERM (CADR (CAR LST)))       (REWRITE (APPLY-SUBST UNIFY-SUBST (CADDR (CAR LST)))))      (T (REWRITE-WITH-LEMMAS TERM (CDR LST)))))(DEFUN RUN-DDERIV ()   (DO ((I 0 (1+ I)))       ((= I 1000))     (DECLARE (TYPE FIXNUM I))     (DDERIV '(+ (* 3 X X)                 (* A X X)                 (* B X)                 5))     (DDERIV '(+ (* 3 X X)                 (* A X X)                 (* B X)                 5))     (DDERIV '(+ (* 3 X X)                 (* A X X)                 (* B X)                 5))     (DDERIV '(+ (* 3 X X)                 (* A X X)                 (* B X)                 5))     (DDERIV '(+ (* 3 X X)                 (* A X X)                 (* B X)                 5))))(DEFUN RUN-DERIV ()   (DO ((I 0 (1+ I)))       ((= I 1000))     (DECLARE (TYPE FIXNUM I))     (DERIV '(+ (* 3 X X)                (* A X X)                (* B X)                5))     (DERIV '(+ (* 3 X X)                (* A X X)                (* B X)                5))     (DERIV '(+ (* 3 X X)                (* A X X)                (* B X)                5))     (DERIV '(+ (* 3 X X)                (* A X X)                (* B X)                5))     (DERIV '(+ (* 3 X X)                (* A X X)                (* B X)                5))))(DEFUN RUN-ONE (NAME &OPTIONAL (STREAM *STANDARD-OUTPUT*))   (FORMAT STREAM "~&~A: " (GET NAME 'TIMING-DOCUMENTATION))   (MULTIPLE-VALUE-BIND (N-RUNS REAL-TIME CPU-TIME)          (MULTIPLE-TIMED-DURATION (GET NAME 'TIMING-FUNCTION))          (FORMAT STREAM "CPU: ~7,3F  Page: ~7,3F  Real: ~7,3F  (based on ~D calls)" CPU-TIME                 (- REAL-TIME CPU-TIME)                 REAL-TIME N-RUNS)))(DEFUN RUN-SERIES (&OPTIONAL (STREAM *STANDARD-OUTPUT*))   (DESCRIBE-IMPLEMENTATION STREAM)   (TERPRI STREAM)   (TERPRI STREAM)   (DOLIST (NAME *SERIES*)       (RUN-ONE NAME STREAM)))(DEFUN RUN-SERIES-TO-FILE (&OPTIONAL (PATHNAME "RPG-CL.TEXT"))   (WITH-OPEN-FILE (STREAM PATHNAME :DIRECTION :OUTPUT)          (RUN-SERIES STREAM)))(DEFUN SEED ()   (SETQ RAND 21))(DEFUN SETUP ()   (ADD-LEMMA-LST '((EQUAL (COMPILE FORM)                           (REVERSE (CODEGEN (OPTIMIZE FORM)                                           (NIL))))                    (EQUAL (EQP X Y)                           (EQUAL (FIX X)                                  (FIX Y)))                    (EQUAL (GREATERP X Y)                           (LESSP Y X))                    (EQUAL (LESSEQP X Y)                           (NOT (LESSP Y X)))                    (EQUAL (GREATEREQP X Y)                           (NOT (LESSP X Y)))                    (EQUAL (BOOLEAN X)                           (OR (EQUAL X (T))                               (EQUAL X (F))))                    (EQUAL (IFF X Y)                           (AND (IMPLIES X Y)                                (IMPLIES Y X)))                    (EQUAL (EVEN1 X)                           (IF (ZEROP X)                               (T)                               (ODD (1- X))))                    (EQUAL (COUNTPS- L PRED)                           (COUNTPS-LOOP L PRED (ZERO)))                    (EQUAL (FACT- I)                           (FACT-LOOP I 1))                    (EQUAL (REVERSE- X)                           (REVERSE-LOOP X (NIL)))                    (EQUAL (DIVIDES X Y)                           (ZEROP (REMAINDER Y X)))                    (EQUAL (ASSUME-TRUE VAR ALIST)                           (CONS (CONS VAR (T))                                 ALIST))                    (EQUAL (ASSUME-FALSE VAR ALIST)                           (CONS (CONS VAR (F))                                 ALIST))                    (EQUAL (TAUTOLOGY-CHECKER X)                           (TAUTOLOGYP (NORMALIZE X)                                  (NIL)))                    (EQUAL (FALSIFY X)                           (FALSIFY1 (NORMALIZE X)                                  (NIL)))                    (EQUAL (PRIME X)                           (AND (NOT (ZEROP X))                                (NOT (EQUAL X (ADD1 (ZERO))))                                (PRIME1 X (1- X))))                    (EQUAL (AND P Q)                           (IF P                               (IF Q                                   (T)                                   (F))                               (F)))                    (EQUAL (OR P Q)                           (IF P                               (T)                               (IF Q                                   (T)                                   (F))                               (F)))                    (EQUAL (NOT P)                           (IF P                               (F)                               (T)))                    (EQUAL (IMPLIES P Q)                           (IF P                               (IF Q                                   (T)                                   (F))                               (T)))                    (EQUAL (FIX X)                           (IF (NUMBERP X)                               X                               (ZERO)))                    (EQUAL (IF (IF A                                   B                                   C)                               D                               E)                           (IF A                               (IF B                                   D                                   E)                               (IF C                                   D                                   E)))                    (EQUAL (ZEROP X)                           (OR (EQUAL X (ZERO))                               (NOT (NUMBERP X))))                    (EQUAL (PLUS (PLUS X Y)                                 Z)                           (PLUS X (PLUS Y Z)))                    (EQUAL (EQUAL (PLUS A B)                                  (ZERO))                           (AND (ZEROP A)                                (ZEROP B)))                    (EQUAL (DIFFERENCE X X)                           (ZERO))                    (EQUAL (EQUAL (PLUS A B)                                  (PLUS A C))                           (EQUAL (FIX B)                                  (FIX C)))                    (EQUAL (EQUAL (ZERO)                                  (DIFFERENCE X Y))                           (NOT (LESSP Y X)))                    (EQUAL (EQUAL X (DIFFERENCE X Y))                           (AND (NUMBERP X)                                (OR (EQUAL X (ZERO))                                    (ZEROP Y))))                    (EQUAL (MEANING (PLUS-TREE (APPEND X Y))                                  A)                           (PLUS (MEANING (PLUS-TREE X)                                        A)                                 (MEANING (PLUS-TREE Y)                                        A)))                    (EQUAL (MEANING (PLUS-TREE (PLUS-FRINGE X))                                  A)                           (FIX (MEANING X A)))                    (EQUAL (APPEND (APPEND X Y)                                  Z)                           (APPEND X (APPEND Y Z)))                    (EQUAL (REVERSE (APPEND A B))                           (APPEND (REVERSE B)                                  (REVERSE A)))                    (EQUAL (TIMES X (PLUS Y Z))                           (PLUS (TIMES X Y)                                 (TIMES X Z)))                    (EQUAL (TIMES (TIMES X Y)                                  Z)                           (TIMES X (TIMES Y Z)))                    (EQUAL (EQUAL (TIMES X Y)                                  (ZERO))                           (OR (ZEROP X)                               (ZEROP Y)))                    (EQUAL (EXEC (APPEND X Y)                                 PDS ENVRN)                           (EXEC Y (EXEC X PDS ENVRN)                                 ENVRN))                    (EQUAL (MC-FLATTEN X Y)                           (APPEND (FLATTEN X)                                  Y))                    (EQUAL (MEMBER X (APPEND A B))                           (OR (MEMBER X A)                               (MEMBER X B)))                    (EQUAL (MEMBER X (REVERSE Y))                           (MEMBER X Y))                    (EQUAL (LENGTH (REVERSE X))                           (LENGTH X))                    (EQUAL (MEMBER A (INTERSECT B C))                           (AND (MEMBER A B)                                (MEMBER A C)))                    (EQUAL (NTH (ZERO)                                I)                           (ZERO))                    (EQUAL (EXP I (PLUS J K))                           (TIMES (EXP I J)                                  (EXP I K)))                    (EQUAL (EXP I (TIMES J K))                           (EXP (EXP I J)                                K))                    (EQUAL (REVERSE-LOOP X Y)                           (APPEND (REVERSE X)                                  Y))                    (EQUAL (REVERSE-LOOP X (NIL))                           (REVERSE X))                    (EQUAL (COUNT-LIST Z (SORT-LP X Y))                           (PLUS (COUNT-LIST Z X)                                 (COUNT-LIST Z Y)))                    (EQUAL (EQUAL (APPEND A B)                                  (APPEND A C))                           (EQUAL B C))                    (EQUAL (PLUS (REMAINDER X Y)                                 (TIMES Y (QUOTIENT X Y)))                           (FIX X))                    (EQUAL (POWER-EVAL (BIG-PLUS1 L I BASE)                                  BASE)                           (PLUS (POWER-EVAL L BASE)                                 I))                    (EQUAL (POWER-EVAL (BIG-PLUS X Y I BASE)                                  BASE)                           (PLUS I (PLUS (POWER-EVAL X BASE)                                         (POWER-EVAL Y BASE))))                    (EQUAL (REMAINDER Y 1)                           (ZERO))                    (EQUAL (LESSP (REMAINDER X Y)                                  Y)                           (NOT (ZEROP Y)))                    (EQUAL (REMAINDER X X)                           (ZERO))                    (EQUAL (LESSP (QUOTIENT I J)                                  I)                           (AND (NOT (ZEROP I))                                (OR (ZEROP J)                                    (NOT (EQUAL J 1)))))                    (EQUAL (LESSP (REMAINDER X Y)                                  X)                           (AND (NOT (ZEROP Y))                                (NOT (ZEROP X))                                (NOT (LESSP X Y))))                    (EQUAL (POWER-EVAL (POWER-REP I BASE)                                  BASE)                           (FIX I))                    (EQUAL (POWER-EVAL (BIG-PLUS (POWER-REP I BASE)                                              (POWER-REP J BASE)                                              (ZERO)                                              BASE)                                  BASE)                           (PLUS I J))                    (EQUAL (GCD X Y)                           (GCD Y X))                    (EQUAL (NTH (APPEND A B)                                I)                           (APPEND (NTH A I)                                  (NTH B (DIFFERENCE I (LENGTH A)))))                    (EQUAL (DIFFERENCE (PLUS X Y)                                  X)                           (FIX Y))                    (EQUAL (DIFFERENCE (PLUS Y X)                                  X)                           (FIX Y))                    (EQUAL (DIFFERENCE (PLUS X Y)                                  (PLUS X Z))                           (DIFFERENCE Y Z))                    (EQUAL (TIMES X (DIFFERENCE C W))                           (DIFFERENCE (TIMES C X)                                  (TIMES W X)))                    (EQUAL (REMAINDER (TIMES X Z)                                  Z)                           (ZERO))                    (EQUAL (DIFFERENCE (PLUS B (PLUS A C))                                  A)                           (PLUS B C))                    (EQUAL (DIFFERENCE (ADD1 (PLUS Y Z))                                  Z)                           (ADD1 Y))                    (EQUAL (LESSP (PLUS X Y)                                  (PLUS X Z))                           (LESSP Y Z))                    (EQUAL (LESSP (TIMES X Z)                                  (TIMES Y Z))                           (AND (NOT (ZEROP Z))                                (LESSP X Y)))                    (EQUAL (LESSP Y (PLUS X Y))                           (NOT (ZEROP X)))                    (EQUAL (GCD (TIMES X Z)                                (TIMES Y Z))                           (TIMES Z (GCD X Y)))                    (EQUAL (VALUE (NORMALIZE X)                                  A)                           (VALUE X A))                    (EQUAL (EQUAL (FLATTEN X)                                  (CONS Y (NIL)))                           (AND (NLISTP X)                                (EQUAL X Y)))                    (EQUAL (LISTP (GOPHER X))                           (LISTP X))                    (EQUAL (SAMEFRINGE X Y)                           (EQUAL (FLATTEN X)                                  (FLATTEN Y)))                    (EQUAL (EQUAL (GREATEST-FACTOR X Y)                                  (ZERO))                           (AND (OR (ZEROP Y)                                    (EQUAL Y 1))                                (EQUAL X (ZERO))))                    (EQUAL (EQUAL (GREATEST-FACTOR X Y)                                  1)                           (EQUAL X 1))                    (EQUAL (NUMBERP (GREATEST-FACTOR X Y))                           (NOT (AND (OR (ZEROP Y)                                         (EQUAL Y 1))                                     (NOT (NUMBERP X)))))                    (EQUAL (TIMES-LIST (APPEND X Y))                           (TIMES (TIMES-LIST X)                                  (TIMES-LIST Y)))                    (EQUAL (PRIME-LIST (APPEND X Y))                           (AND (PRIME-LIST X)                                (PRIME-LIST Y)))                    (EQUAL (EQUAL Z (TIMES W Z))                           (AND (NUMBERP Z)                                (OR (EQUAL Z (ZERO))                                    (EQUAL W 1))))                    (EQUAL (GREATEREQPR X Y)                           (NOT (LESSP X Y)))                    (EQUAL (EQUAL X (TIMES X Y))                           (OR (EQUAL X (ZERO))                               (AND (NUMBERP X)                                    (EQUAL Y 1))))                    (EQUAL (REMAINDER (TIMES Y X)                                  Y)                           (ZERO))                    (EQUAL (EQUAL (TIMES A B)                                  1)                           (AND (NOT (EQUAL A (ZERO)))                                (NOT (EQUAL B (ZERO)))                                (NUMBERP A)                                (NUMBERP B)                                (EQUAL (1- A)                                       (ZERO))                                (EQUAL (1- B)                                       (ZERO))))                    (EQUAL (LESSP (LENGTH (DELETE X L))                                  (LENGTH L))                           (MEMBER X L))                    (EQUAL (SORT2 (DELETE X L))                           (DELETE X (SORT2 L)))                    (EQUAL (DSORT X)                           (SORT2 X))                    (EQUAL (LENGTH (CONS X1 (CONS X2 (CONS X3 (CONS X4 (CONS X5 (CONS X6 X7)))))))                           (PLUS 6 (LENGTH X7)))                    (EQUAL (DIFFERENCE (ADD1 (ADD1 X))                                  2)                           (FIX X))                    (EQUAL (QUOTIENT (PLUS X (PLUS X Y))                                  2)                           (PLUS X (QUOTIENT Y 2)))                    (EQUAL (SIGMA (ZERO)                                  I)                           (QUOTIENT (TIMES I (ADD1 I))                                  2))                    (EQUAL (PLUS X (ADD1 Y))                           (IF (NUMBERP Y)                               (ADD1 (PLUS X Y))                               (ADD1 X)))                    (EQUAL (EQUAL (DIFFERENCE X Y)                                  (DIFFERENCE Z Y))                           (IF (LESSP X Y)                               (NOT (LESSP Y Z))                               (IF (LESSP Z Y)                                   (NOT (LESSP Y X))                                   (EQUAL (FIX X)                                          (FIX Z)))))                    (EQUAL (MEANING (PLUS-TREE (DELETE X Y))                                  A)                           (IF (MEMBER X Y)                               (DIFFERENCE (MEANING (PLUS-TREE Y)                                                  A)                                      (MEANING X A))                               (MEANING (PLUS-TREE Y)                                      A)))                    (EQUAL (TIMES X (ADD1 Y))                           (IF (NUMBERP Y)                               (PLUS X (TIMES X Y))                               (FIX X)))                    (EQUAL (NTH (NIL)                                I)                           (IF (ZEROP I)                               (NIL)                               (ZERO)))                    (EQUAL (LAST (APPEND A B))                           (IF (LISTP B)                               (LAST B)                               (IF (LISTP A)                                   (CONS (CAR (LAST A))                                         B)                                   B)))                    (EQUAL (EQUAL (LESSP X Y)                                  Z)                           (IF (LESSP X Y)                               (EQUAL T Z)                               (EQUAL F Z)))                    (EQUAL (ASSIGNMENT X (APPEND A B))                           (IF (ASSIGNEDP X A)                               (ASSIGNMENT X A)                               (ASSIGNMENT X B)))                    (EQUAL (CAR (GOPHER X))                           (IF (LISTP X)                               (CAR (FLATTEN X))                               (ZERO)))                    (EQUAL (FLATTEN (CDR (GOPHER X)))                           (IF (LISTP X)                               (CDR (FLATTEN X))                               (CONS (ZERO)                                     (NIL))))                    (EQUAL (QUOTIENT (TIMES Y X)                                  Y)                           (IF (ZEROP Y)                               (ZERO)                               (FIX X)))                    (EQUAL (GET J (SET I VAL MEM))                           (IF (EQP J I)                               VAL                               (GET J MEM))))))(DEFUN SETUP-DDERIV ()   (MAPC #'(LAMBDA (OP FUN)                  (SETF (GET OP 'DDERIV)                        (SYMBOL-FUNCTION FUN)))         '(+ - * /)         '(+DDERIV -DDERIV *DDERIV /DDERIV)))(DEFUN SETUP-FRPOLY ()   (SETF (GET 'X 'ORDER)         1)   (SETF (GET 'Y 'ORDER)         2)   (SETF (GET 'Z 'ORDER)         3)   (SETQ *R* (PPLUS '(X 1 1 0 1)                    (PPLUS '(Y 1 1)                           '(Z 1 1))))   (SETQ *R2* (PTIMES *R* 100000))   (SETQ *R3* (PTIMES *R* 1.0)))(DEFUN SNB ()   (SETQ SN (1+ SN)))(DEFUN START ()   (DO ((M 0 (1+ M)))       ((> M SIZE))     (SETF (AREF PUZZLE M)           TRUE))   (DO ((I 1 (1+ I)))       ((> I 5))     (DO ((J 1 (1+ J)))         ((> J 5))       (DO ((K 1 (1+ K)))           ((> K 5))         (SETF (AREF PUZZLE (+ I (* *D* (+ J (* *D* K)))))               FALSE))))   (DO ((I 0 (1+ I)))       ((> I TYPEMAX))     (DO ((M 0 (1+ M)))         ((> M SIZE))       (SETF (AREF *P* I M)             FALSE)))   (SETQ III 0)   (DEFINEPIECE 0 3 1 0)   (DEFINEPIECE 0 1 0 3)   (DEFINEPIECE 0 0 3 1)   (DEFINEPIECE 0 1 3 0)   (DEFINEPIECE 0 3 0 1)   (DEFINEPIECE 0 0 1 3)   (DEFINEPIECE 1 2 0 0)   (DEFINEPIECE 1 0 2 0)   (DEFINEPIECE 1 0 0 2)   (DEFINEPIECE 2 1 1 0)   (DEFINEPIECE 2 1 0 1)   (DEFINEPIECE 2 0 1 1)   (DEFINEPIECE 3 1 1 1)   (SETF (AREF PIECECOUNT 0)         13)   (SETF (AREF PIECECOUNT 1)         3)   (SETF (AREF PIECECOUNT 2)         1)   (SETF (AREF PIECECOUNT 3)         1)   (LET ((M (+ 1 (* *D* (+ 1 *D*))))         (N 0)         (KOUNT 0))        (COND           ((FIT 0 M)            (SETQ N (PLACE 0 M)))           (T (FORMAT T "~%Error.")))        (COND           ((TRIAL N)            (FORMAT T "~%Success in ~4D trials." KOUNT))           (T (FORMAT T "~%Failure.")))))(DEFUN TAUTOLOGYP (X TRUE-LST FALSE-LST)   (COND      ((TRUEP X TRUE-LST)       T)      ((FALSEP X FALSE-LST)       NIL)      ((ATOM X)       NIL)      ((EQ (CAR X)           'IF)       (COND          ((TRUEP (CADR X)                  TRUE-LST)           (TAUTOLOGYP (CADDR X)                  TRUE-LST FALSE-LST))          ((FALSEP (CADR X)                  FALSE-LST)           (TAUTOLOGYP (CADDDR X)                  TRUE-LST FALSE-LST))          (T (AND (TAUTOLOGYP (CADDR X)                         (CONS (CADR X)                               TRUE-LST)                         FALSE-LST)                  (TAUTOLOGYP (CADDDR X)                         TRUE-LST                         (CONS (CADR X)                               FALSE-LST))))))      (T NIL)))(DEFUN TAUTP (X)   (TAUTOLOGYP (REWRITE X)          NIL NIL))(DEFUN TEST ()   (PROG (ANS TERM)         (SETQ TERM (APPLY-SUBST '((X F (PLUS (PLUS A B)                                              (PLUS C (ZERO))))                                   (Y F (TIMES (TIMES A B)                                               (PLUS C D)))                                   (Z F (REVERSE (APPEND (APPEND A B)                                                        (NIL))))                                   (U EQUAL (PLUS A B)                                      (DIFFERENCE X Y))                                   (W LESSP (REMAINDER A B)                                      (MEMBER A (LENGTH B))))                           '(IMPLIES (AND (IMPLIES X Y)                                          (AND (IMPLIES Y Z)                                               (AND (IMPLIES Z U)                                                    (IMPLIES U W))))                                   (IMPLIES X W))))         (SETQ ANS (TAUTP TERM))))(DEFUN TRANS-OF-IMPLIES (N)   (LIST 'IMPLIES (TRANS-OF-IMPLIES1 N)         (LIST 'IMPLIES 0 N)))(DEFUN TRANS-OF-IMPLIES1 (N)   (COND      ((EQUAL N 1)       (LIST 'IMPLIES 0 1))      (T (LIST 'AND (LIST 'IMPLIES (1- N)                          N)               (TRANS-OF-IMPLIES1 (1- N))))))(DEFUN TRAVERS (TNODE MARK)   (COND      ((EQ (TNODE-MARK TNODE)           MARK)       NIL)      (T (SETF (TNODE-MARK TNODE)               MARK)         (SETQ COUNT (1+ COUNT))         (SETF (TNODE-ENTRY1 TNODE)               (NOT (TNODE-ENTRY1 TNODE)))         (SETF (TNODE-ENTRY2 TNODE)               (NOT (TNODE-ENTRY2 TNODE)))         (SETF (TNODE-ENTRY3 TNODE)               (NOT (TNODE-ENTRY3 TNODE)))         (SETF (TNODE-ENTRY4 TNODE)               (NOT (TNODE-ENTRY4 TNODE)))         (SETF (TNODE-ENTRY5 TNODE)               (NOT (TNODE-ENTRY5 TNODE)))         (SETF (TNODE-ENTRY6 TNODE)               (NOT (TNODE-ENTRY6 TNODE)))         (DO ((SONS (TNODE-SONS TNODE)                    (CDR SONS)))             ((NULL SONS)              NIL)           (TRAVERS (CAR SONS)                  MARK)))))(DEFUN TRAVERSE (ROOT)   (LET ((COUNT 0))        (TRAVERS ROOT (SETQ MARKER (NOT MARKER)))        COUNT))(DEFUN TRAVERSE-RANDOM ()   (SETQ RAND (MOD (* RAND 17)                   251)))(DEFUN TRAVERSE-REMOVE (N Q)   (COND      ((EQ (CDR (CAR Q))           (CAR Q))       (PROG2 NIL (CAAR Q)              (RPLACA Q NIL)))      ((= N 0)       (PROG2 NIL (CAAR Q)              (DO ((P (CAR Q)                      (CDR P)))                  ((EQ (CDR P)                       (CAR Q))                   (RPLACA Q (RPLACD P (CDR (CAR Q))))))))      (T (DO ((N N (1- N))              (Q (CAR Q)                 (CDR Q))              (P (CDR (CAR Q))                 (CDR P)))             ((= N 0)              (PROG2 NIL (CAR Q)                     (RPLACD Q P)))))))(DEFUN TRAVERSE-SELECT (N Q)   (DO ((N N (1- N))        (Q (CAR Q)           (CDR Q)))       ((= N 0)        (CAR Q))))(DEFUN TRIAL (J)   (LET ((K 0))        (DO ((I 0 (1+ I)))            ((> I TYPEMAX)             (SETQ KOUNT (1+ KOUNT))             FALSE)          (COND             ((NOT (= (AREF PIECECOUNT (AREF CLASS I))                      0))              (COND                 ((FIT I J)                  (SETQ K (PLACE I J))                  (COND                     ((OR (TRIAL K)                          (= K 0))                      (SETQ KOUNT (+ KOUNT 1))                      (RETURN TRUE))                     (T (PUZZLE-REMOVE I J))))))))))(DEFUN TRIANG-TEST ()   (DOTIMES (J 16)       (SETF (AREF BOARD J)             1))   (SETF (AREF BOARD 5)         0)   (LET ((ANSWER NIL)         (FINAL NIL))        (TRY 22 1)        (= (LENGTH ANSWER)           775)))(DEFUN TRUEP (X LST)   (OR (EQUAL X '(T))       (MEMBER X LST :TEST #'EQUAL)))(DEFUN TRY (I DEPTH)   (COND      ((= DEPTH 14)       (LET ((LP (LAST-POSITION)))            (UNLESS (MEMBER LP FINAL)                   (PUSH LP FINAL)))       (PUSH (CDR (COERCE SEQUENCE 'LIST))             ANSWER)       T)      ((AND (= 1 (AREF BOARD (AREF *A* I)))            (= 1 (AREF BOARD (AREF *B* I)))            (= 0 (AREF BOARD (AREF *C* I))))       (SETF (AREF BOARD (AREF *A* I))             0)       (SETF (AREF BOARD (AREF *B* I))             0)       (SETF (AREF BOARD (AREF *C* I))             1)       (SETF (AREF SEQUENCE DEPTH)             I)       (DO ((J 0 (1+ J))            (DEPTH (1+ DEPTH)))           ((OR (= J 36)                (TRY J DEPTH))            NIL))       (SETF (AREF BOARD (AREF *A* I))             1)       (SETF (AREF BOARD (AREF *B* I))             1)       (SETF (AREF BOARD (AREF *C* I))             0)       NIL)))(IL:* IL:|;;| "Modified version of browse which doesn't cons so much")(DEFMACRO CHAR1* (X)   `(CODE-CHAR (IL:NTHCHARCODE ,X 1)))(DEFUN BROWSE* ()   (SETF RAND 21)   (INVESTIGATE* (RANDOMIZE (INIT 100 10 4                                  '((A A A B B B B A A A A A B B A A A)                                    (A A B B B B A A (A A)                                       (B B))                                    (A A A B (B A)                                       B A B A))))          '((*A ?B *B ?B A *A A *B *A)            (*A *B *B *A (*A)                (*B))            (? ? * (B A)               * ? ?))))(DEFUN INVESTIGATE* (UNITS PATS)   (DO ((UNITS UNITS (CDR UNITS)))       ((NULL UNITS))     (DO ((PATS PATS (CDR PATS)))         ((NULL PATS))       (DO ((P (GET (CAR UNITS)                    'PATTERN)               (CDR P)))           ((NULL P))         (MATCH* (CAR PATS)                (CAR P)                NIL)))))(DEFUN MATCH* (PAT DAT ALIST)   (COND      ((NULL PAT)       (NULL DAT))      ((NULL DAT)       NIL)      ((OR (EQ (CAR PAT)               '?)           (EQ (CAR PAT)               (CAR DAT)))       (MATCH* (CDR PAT)              (CDR DAT)              ALIST))      ((EQ (CAR PAT)           '*)       (OR (MATCH* (CDR PAT)                  DAT ALIST)           (MATCH* (CDR PAT)                  (CDR DAT)                  ALIST)           (MATCH* PAT (CDR DAT)                  ALIST)))      (T (COND            ((ATOM (CAR PAT))             (COND                ((EQL (CHAR1* (CAR PAT))                      #\?)                 (LET ((VAL (ASSOC (CAR PAT)                                   ALIST)))                      (COND                         (VAL (MATCH* (CONS (CDR VAL)                                            (CDR PAT))                                     DAT ALIST))                         (T (MATCH* (CDR PAT)                                   (CDR DAT)                                   (CONS (CONS (CAR PAT)                                               (CAR DAT))                                         ALIST))))))                ((EQL (CHAR1* (CAR PAT))                      #\*)                 (LET ((VAL (ASSOC (CAR PAT)                                   ALIST)))                      (COND                         (VAL (MATCH* (APPEND (CDR VAL)                                             (CDR PAT))                                     DAT ALIST))                         (T (DO ((L NIL (NCONC L (CONS (CAR D)                                                       NIL)))                                 (E (CONS NIL DAT)                                    (CDR E))                                 (D DAT (CDR D)))                                ((NULL E)                                 NIL)                              (COND                                 ((MATCH* (CDR PAT)                                         D                                         (CONS (CONS (CAR PAT)                                                     L)                                               ALIST))                                  (RETURN T))))))))))            (T (AND (NOT (ATOM (CAR DAT)))                    (MATCH* (CAR PAT)                           (CAR DAT)                           ALIST)                    (MATCH* (CDR PAT)                           (CDR DAT)                           ALIST)))))))(DEFINE-TIMER BROWSE* "Browse"   (BROWSE*))(IL:* IL:|;;| "Modified version of traverse-init to break circularities")(DEFUN CREATE-STRUCTURE* (N)   (LET ((A `(,(MAKE-TNODE))))        (DO ((M (1- N)                (1- M))             (P A))            ((= M 0)             (SETQ A `(,(RPLACD P A)))             (DO ((UNUSED A)                  (USED (ADD (TRAVERSE-REMOVE* 0 A)                             NIL))                  (X)                  (Y))                 ((NULL (CAR UNUSED))                  (PROG1 (FIND-ROOT (TRAVERSE-SELECT 0 USED)                                N)                      (IL:* IL:|;;| "Break the circularities")                      (RPLACD (CAR USED)                             NIL)))               (SETQ X (TRAVERSE-REMOVE* (REM (TRAVERSE-RANDOM)                                              N)                              UNUSED))               (SETQ Y (TRAVERSE-SELECT (REM (TRAVERSE-RANDOM)                                             N)                              USED))               (ADD X USED)               (SETF (TNODE-SONS Y)                     `(,X . ,(TNODE-SONS Y)))               (SETF (TNODE-PARENTS X)                     `(,Y . ,(TNODE-PARENTS X)))))          (PUSH (MAKE-TNODE)                A))))(DEFUN TRAVERSE-REMOVE* (N Q)   (COND      ((EQ (CDR (CAR Q))           (CAR Q))       (PROG2 NIL (CAAR Q)              (IL:* IL:|;;| "Break the circularity ")              (RPLACD (CAR Q)                     NIL)              (RPLACA Q NIL)))      ((= N 0)       (PROG2 NIL (CAAR Q)              (DO ((P (CAR Q)                      (CDR P)))                  ((EQ (CDR P)                       (CAR Q))                   (RPLACA Q (RPLACD P (CDR (CAR Q))))))))      (T (DO ((N N (1- N))              (Q (CAR Q)                 (CDR Q))              (P (CDR (CAR Q))                 (CDR P)))             ((= N 0)              (PROG2 NIL (CAR Q)                     (RPLACD Q P)))))))(DEFUN RELEASE-TREE (ROOT)   (LET ((*TREE-SNS* NIL))        (DECLARE (SPECIAL *TREE-SNS*))        (RELEASE-TREE-AUX ROOT)))(DEFUN RELEASE-TREE-AUX (NODE)   (LET ((SONS (TNODE-SONS NODE)))        (DECLARE (SPECIAL *TREE-SNS*))        (PUSHNEW (TNODE-SN NODE)               *TREE-SNS*)        (SETF (TNODE-PARENTS NODE)              NIL)        (DOLIST (N SONS)            (IF (NOT (MEMBER (TNODE-SN N)                            *TREE-SNS* :TEST #'EQ))                (RELEASE-TREE-AUX N)))        (SETF (TNODE-SONS NODE)              NIL)))(DEFINE-TIMER    (TRAVERSE* (:SETUP (PROGN (SETQ SN 0)                             (SETQ RAND 21)                             (SETQ COUNT 0)                             (SETQ MARKER NIL)                             (SETQ ROOT (CREATE-STRUCTURE* 100))                             NIL))          (:AFTER (RELEASE-TREE ROOT))) "Traverse, Traverse"   (DO ((I 50 (1- I)))       ((= I 0))     (TRAVERSE ROOT)     (TRAVERSE ROOT)     (TRAVERSE ROOT)     (TRAVERSE ROOT)     (TRAVERSE ROOT)))(DEFINE-TIMER (TRAVERSE-INIT* (:AFTER-EVERY (RELEASE-TREE ROOT))) "Traverse, Initialize"   (PROGN (SETQ SN 0)          (SETQ RAND 21)          (SETQ COUNT 0)          (SETQ MARKER NIL)          (SETQ ROOT (CREATE-STRUCTURE* 100))          NIL))(DEFVAR DIV2-L (CREATE-N 200))(DEFPARAMETER *CONSY-BENCHMARKS* '(DERIV DDERIV DIV2-1 DIV2-2 DESTRU BOYER BROWSE BROWSE*                                              TRAVERSE-INIT* TRAVERSE*))(DEFPARAMETER *AREFY-BENCHMARKS* '(PUZZLE TRIANG FFT))(DEFPARAMETER *POLY-BENCHMARKS*   '(FRPOLY10R FRPOLY10R2 FRPOLY10R3 FRPOLY15R FRPOLY15R2 FRPOLY15R3 FRPOLY2R FRPOLY2R2 FRPOLY2R3            FRPOLY5R FRPOLY5R2 FRPOLY5R3))(DEFINE-TIMER (BOYER (:SETUP (SETUP))) "Boyer"   (TEST))(DEFINE-TIMER BROWSE "Browse"   (BROWSE))(DEFINE-TIMER (DDERIV (:SETUP (SETUP-DDERIV))) "DDeriv"   (RUN-DDERIV))(DEFINE-TIMER DERIV "Deriv"   (RUN-DERIV))(DEFINE-TIMER DESTRU "Destruct"   (DESTRUCTIVE 600 50))(DEFINE-TIMER DIV2-1 "Div2, Iterative"   (ITERATIVE-DIV2-TEST DIV2-L))(DEFINE-TIMER DIV2-2 "Div2, Recursive"   (RECURSIVE-DIV2-TEST DIV2-L))(DEFINE-TIMER FFT "FFT"   (DO ((NTIMES 0 (1+ NTIMES)))       ((= NTIMES 10))     (FFT RE IM)))(DEFINE-TIMER (FRPOLY10R (:SETUP (SETUP-FRPOLY))) "FRPoly, Power = 10, r = x + y + z + 1"   (PEXPTSQ *R* 10))(DEFINE-TIMER (FRPOLY10R2 (:SETUP (SETUP-FRPOLY))) "FRPoly, Power = 10, r2 = 1000r"   (PEXPTSQ *R2* 10))(DEFINE-TIMER (FRPOLY10R3 (:SETUP (SETUP-FRPOLY))) "FRPoly, Power = 10, r3 = r in flonums"   (PEXPTSQ *R3* 10))(DEFINE-TIMER (FRPOLY15R (:SETUP (SETUP-FRPOLY))) "FRPoly, Power = 15, r = x + y + z + 1"   (PEXPTSQ *R* 15))(DEFINE-TIMER (FRPOLY15R2 (:SETUP (SETUP-FRPOLY))) "FRPoly, Power = 15, r2 = 1000r"   (PEXPTSQ *R2* 15))(DEFINE-TIMER (FRPOLY15R3 (:SETUP (SETUP-FRPOLY))) "FRPoly, Power = 15, r3 = r in flonums"   (PEXPTSQ *R3* 15))(DEFINE-TIMER (FRPOLY2R (:SETUP (SETUP-FRPOLY))) "FRPoly, Power = 2, r = x + y + z + 1"   (PEXPTSQ *R* 2))(DEFINE-TIMER (FRPOLY2R2 (:SETUP (SETUP-FRPOLY))) "FRPoly, Power = 2, r2 = 1000r"   (PEXPTSQ *R2* 2))(DEFINE-TIMER (FRPOLY2R3 (:SETUP (SETUP-FRPOLY))) "FRPoly, Power = 2, r3 = r in flonums"   (PEXPTSQ *R3* 2))(DEFINE-TIMER (FRPOLY5R (:SETUP (SETUP-FRPOLY))) "FRPoly, Power = 5, r = x + y + z + 1"   (PEXPTSQ *R* 5))(DEFINE-TIMER (FRPOLY5R2 (:SETUP (SETUP-FRPOLY))) "FRPoly, Power = 5, r2 = 1000r"   (PEXPTSQ *R2* 5))(DEFINE-TIMER (FRPOLY5R3 (:SETUP (SETUP-FRPOLY))) "FRPoly, Power = 5, r3 = r in flonums"   (PEXPTSQ *R3* 5))(DEFINE-TIMER PUZZLE "Puzzle"   (START))(DEFINE-TIMER TRAVERSE "Traverse, Traverse"   (DO ((I 50 (1- I)))       ((= I 0))     (TRAVERSE ROOT)     (TRAVERSE ROOT)     (TRAVERSE ROOT)     (TRAVERSE ROOT)     (TRAVERSE ROOT)))(DEFINE-TIMER TRAVERSE-INIT "Traverse, Initialize"   (PROGN (SETQ SN 0)          (SETQ RAND 21)          (SETQ COUNT 0)          (SETQ MARKER NIL)          (SETQ ROOT (CREATE-STRUCTURE 100))          NIL))(DEFINE-TIMER TRIANG "Triang"   (GOGOGO 22))(IL:DECLARE\: IL:DONTCOPY IL:DOEVAL@COMPILE (IL:DECLARE\: IL:DOEVAL@COMPILE IL:DONTCOPY(IL:LOCALVARS . T)))(IL:PUTPROPS IL:GABRIEL-OTHER IL:FILETYPE COMPILE-FILE)(IL:PUTPROPS IL:GABRIEL-OTHER IL:MAKEFILE-ENVIRONMENT (:READTABLE "XCL" :PACKAGE (XCL:DEFPACKAGE                                                                                      "GABRIEL")))(IL:PUTPROPS IL:GABRIEL-OTHER IL:COPYRIGHT ("Xerox Corporation" 1987 1988))(IL:DECLARE\: IL:DONTCOPY  (IL:FILEMAP (NIL)))IL:STOP