/******************************************************************************* Intel 386/486 C Code Builder(TM) Kit* Copyright 1991 Intel Corporation.  All Rights Reserved.******************************************************************************** MOUSETST.C** A program to test the mouse interrupt (0x33) functions (that require special* support in the DOS extender environment) including the following functions:*    0x33, 0x09 - Set mouse pointer shape (graphics mode).*    0x33, 0x0C - Set user mouse-event-handler.*    0x33, 0x1F - Disable mouse driver.** This program also demonstrates the use of a user-defined mouse handler.  The* mouse handler resides in high (protected) memory, and is passed the mouse* driver's input on the _XSTACK frame passed to the routine.  (The user's* handler must be defined using a "#pragma interrupt" statement.)  The* contents of this input is given in the include file "mousetst.h".** The first test defines a "block" mouse cursor shape.  This requires changing* the video mode to a graphics mode (4 is used), and requesting function 0x09,* set mouse pointer shape.  A pointer to the table containing the shape data* is passed to the function.  The table is defined in high memory.** The next test installs a user mouse handler, 'Mouse_hndlr()'.  (The handler* is defined using the "#pragma interrupt" statement as previously mentioned.)* 'Mouse_hndlr()' is called by the mouse driver whenever a mouse event* (defined when 'Mouse_hndlr()' is installed) occurs.  The handler saves the* captured mouse event data and notifies the main program by setting a flag* ('mouse_event').  The main program processes the mouse event and continues* to wait for another event (or an <Enter> key which terminates the test).** This test includes an example of spawning a child process which installs* a mouse handler.  Since both parent & child install a mouse handler, the* parent must re-install it's handler after the child has returned.******************************************************************************//******************************************************************************* Include files******************************************************************************/#include <i32.h>                             /* Defines "#pragma interrupt"  */#include <dos.h>                             /* Defines REGS & other structs */#include <stk.h>                             /* _XSTACK struct definition    */#include "mousetst.h"                        /* Mouse defines                *//******************************************************************************* Defines******************************************************************************/#define BYTE      unsigned char#define FALSE     0#define TRUE      1/******************************************************************************* Functions defined in this module******************************************************************************/#pragma interrupt(Mouse_hndlr)void  Mouse_hndlr(void);           /* Fields mouse events from driver        */                                   /*  (during servicing of mouse interrupt) *//******************************************************************************* Global data area******************************************************************************/unsigned       drvr_flags;          /* Event flags passed by 'Mouse_hndlr'   */BYTE           mouse_event = FALSE; /* TRUE when event ready in 'drvr_flags' */main()   {   union REGS regs;   /***************************************************************************   * Reset mouse driver, exit if no mouse driver present   ***************************************************************************/   regs.w.eax = 0;                    /* Function 0 = reset the mouse driver */   int86(0x33, &regs, &regs);   if (regs.w.eax != -1) {    /* Check if mouse driver installed (-1 if not) */      printf("Mouse driver must be installed before running this program.\n");      return(1);      }   /***************************************************************************   * Lock the "user-defined" handler and its data before installing it.   * This prevents the handler from being "swapped out" at a critical time.   ***************************************************************************/   _dpmi_lockregion((void *)&drvr_flags, sizeof(drvr_flags));   _dpmi_lockregion((void *)&mouse_event, sizeof(mouse_event));   _dpmi_lockregion((void *)&Mouse_hndlr, 4096);   /***************************************************************************   * Install "user-defined" handler for events: left, right button pressed   ***************************************************************************/   regs.w.eax = 0x0C;        /* Function 0C = set user-defined mouse handler */   regs.w.ecx = LB_PRESS | RB_PRESS;  /* Call handler on left or right press */   regs.w.edx = FP_OFF(Mouse_hndlr); /* Address of our mouse handler routine */   int86(0x33, &regs, &regs);       /* Install our handler to process events */   if (regs.w.eax == 'MERR') {       /* Check for error return "code" in eax */      printf("Unable to install mouse handler - not enough low memory.\n");      goto mouse_exit;                         /* Uninstall intercept & exit */      }   /***************************************************************************   *  Main loop - Wait for keyboard or mouse event   ***************************************************************************/   while (TRUE) {      if (kbhit()) {                        /* Key "event" - get key pressed */         if (getch() == 0x0d)        /* <Enter> terminates test, else ignore */            break;         }      if (mouse_event){        /* Check if mouse event signaled by our hndler */         mouse_event = FALSE;	 printf("Back in the main loop\n");       }      }   /***************************************************************************   * Program exit - Display message & terminate   ***************************************************************************/mouse_exit:   /***************************************************************************   * unlock the "user-defined" handler and its data.   ***************************************************************************/   _dpmi_unlockregion((void *)&drvr_flags, sizeof(drvr_flags));   _dpmi_unlockregion((void *)&mouse_event, sizeof(mouse_event));   _dpmi_unlockregion((void *)&Mouse_hndlr, 4096);   printf("The test has been terminated.\n");   }/******************************************************************************* Mouse_hndlr** This "user-installed" handler is invoked by the mouse driver whenever an* event occurs which matches one of the events specified when the handler* was installed.** Note: The handler must be declared using "#pragma interrupt()" in order* to retrieve the mouse driver's registers from the _XSTACK frame.  Also* note that the mouse handler should not make any DOS or BIOS interrupt calls,* either directly, or indirectly through a C library call.** As currently written, the mouse handler is blocked from storing the event* information if the previous event has not yet been processed by the main* program.  If new events are added, it may be necessary for the handler to* queue the mouse events to ensure that none are missed.** Input:*    _XSTACK - Stack frame containing driver's registers:*       eax - Mouse event flags, as follows:*             Bit   Meaning if set*             ===   ==============*             0     Mouse movement*             1     Left button pressed*             2     Left button released*             3     Right button pressed*             4     Right button released*             5     Center button pressed*             6     Center button released*       ebx - Button state, as follows:*             Bit   Meaning if set*             ===   ==============*             0     Left button is down*             1     Right button is down*             2     Center button is down*       ecx - Horizontal (X) mouse pointer coordinate.*       edx - Vertical (Y) mouse pointer coordinate.*       esi - Last raw vertical mickey count.*       edi - Last raw horizontal mickey count.*    Although all values are stored in 32-bit locations, only the lower*    16-bits of information contain data from the mouse driver.**  Output:*    drvr_flags     -  Event flag(s) (from ax) representing mouse event(s).*    mouse_event    -  TRUE to indicate a new mouse event has occurred.******************************************************************************/void  Mouse_hndlr(void)   {   _XSTACK  *stk_ptr;   if (!mouse_event) {           /* Only process if previous event completed */      stk_ptr = (_XSTACK *)_get_stk_frame(); /* Get ptr to V86 _XSTACK frame */      drvr_flags = stk_ptr->eax;       /* Save event flags from mouse driver */      mouse_event = TRUE;             /* Indicate new mouse event is waiting */      }   return;   }