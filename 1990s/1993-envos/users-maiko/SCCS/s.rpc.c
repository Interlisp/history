h17976s 00002/00001/00211d D 1.17 92/11/25 21:12:15 sybalsky 17 16c Fixing endif's with extra text => comment. \nes 00005/00005/00207d D 1.16 92/04/21 17:22:57 sybalsky 16 15c shortening file names for DOS \nes 00028/00004/00184d D 1.15 91/09/27 02:51:54 sybalsky 15 14c ISC port changes.es 00004/00001/00184d D 1.14 91/04/09 17:12:27 sybalsky 14 13c Retrofit first round of changes from MIPS porting centeres 00000/00000/00185d D 1.13 90/04/20 01:51:57 sybalsky 13 12c AIX:  shortening file names, bulk change.es 00002/00002/00183d D 1.12 89/12/28 15:27:58 sybalsky 12 11c es 00002/00014/00183d D 1.11 89/12/13 10:58:12 sybalsky 11 10c string-conversion safety addedes 00003/00003/00194d D 1.10 89/03/18 04:02:54 sybalsky 10 9c OneDArrayes 00005/00004/00192d D 1.9 88/07/11 11:54:37 masinter 9 8c bogus register declarations on variables used with &var; fixedes 00001/00001/00195d D 1.8 88/05/26 12:44:29 mullins 8 7c Added cast to convert integer pointet (dest) to char pointer.es 00002/00002/00194d D 1.7 88/05/26 12:01:45 mullins 7 6c es 00003/00002/00193d D 1.6 88/05/23 11:38:37 atty 6 5c Added support for host numberses 00000/00025/00195d D 1.5 88/05/19 13:47:37 atty 5 4c removed subr 122es 00000/00000/00220d D 1.4 88/05/19 13:27:21 atty 4 3c es 00026/00000/00194d D 1.3 88/05/17 15:32:03 atty 3 2c Added subr for fetching a host address from Unixes 00192/00000/00002d D 1.2 88/04/28 22:19:27 atty 2 1c Code for sb_RPC_CALLes 00002/00000/00000d D 1.1 88/04/28 22:17:08 atty 1 0c date and time created 88/04/28 22:17:08 by attyeuUtTI 1D 7/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 7I 7D 9/* This is G-file @(#) rpc.c Version 1.6 (5/23/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) rpc.c	1.6 5/23/88";E 9I 9D 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 12I 12D 15/* This is G-file @(#) rpc.c Version 1.10 (3/18/89). copyright Xerox & Fuji Xerox  */static char *id = "@(#) rpc.c	1.10 3/18/89";E 15I 15/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";/************************************************************************//*									*//*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************//************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 15E 12E 9E 7I 2#include <stdio.h>#include <sys/types.h>#include <sys/socket.h>#include <sys/time.h>#include <netinet/in.h>#include <netdb.h>#include <errno.h>#include <sys/ioctl.h>#include "lispemul.h"#include "lispmap.h"D 16#include "lisptypes.h"#include "lispglobal.h"#include "emulglobal.h"#include "address68k.h"E 16I 16#include "lsptypes.h"#include "lspglob.h"#include "emlglob.h"#include "adr68k.h"E 16#include "arith.h"I 11D 16#include "localfile.h"E 16I 16#include "locfile.h"E 16E 11#define MAX_HOSTNAME_LENGTH 100#define UDP_DATA_BLOCK_SIZE 1000D 11/* A macro to convert a Lisp String to a C string */#define	LispStringToCString(Lisp, C){	\	LispPTR	*naddress;				\	char	*base;					\	int	length;					\	int	offset;					\	naddress = (LispPTR *)(Addr68k_from_LADDR(Lisp));					\D 10	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));	\	offset = (int)(((ONEDARRAAY *)naddress)->offset);	\	length = ((ONEDARRAAY *)naddress)->totalsize;						\E 10I 10	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));	\	offset = (int)(((OneDArray *)naddress)->offset);	\	length = ((OneDArray *)naddress)->totalsize;						\E 10	strncpy(C, base + offset, length);			\	C[length] = '\0';				\	}E 11rpc(args)  LispPTR *args;{  /* Arguments are:     args[0]:Destination Address; hostname or internet address are both supported.     args[1]:Remote port for this program.     args[2]:Argument block pointer.     args[3]:Result Block pointer.     args[4]:Milliseconds before timeout     args[5]:Milliseconds between tries     args[6]:Argument block length     */  char hostname[MAX_HOSTNAME_LENGTH];  struct hostent *hp;  struct servent *sp;  struct sockaddr_in sin, sin1, from;D 6  char *outbuf, *inbuf;E 6I 6  char *outbuf, *inbuf, *destaddr;E 6  register int s, msec_until_timeout, msec_between_tries, out_length;D 9  register int  received,  mask, read_descriptors, dest;  register int port, dontblock, fromlen;E 9I 9  register int  received,  mask;  register int port;  int dontblock, dest, fromlen, read_descriptors;E 9  struct timeval pertry_timeout, total_timeout, time_waited;  /* Set timeout */  /* CONVERT FROM LISP TO C TYPES */  dest = GetTypeNumber(args[0]);  if ((dest == TYPE_FIXP) || (dest == TYPE_SMALLP)) {    N_GETNUMBER(args[0], dest, handle_error);D 6    hp = gethostbyaddr((struct in_addr *)dest, sizeof(struct in_addr), AF_INET);E 6I 6D 8    destaddr = &dest;E 8I 8    destaddr = (char *)&dest;E 8    hp = gethostbyaddr(destaddr, sizeof(struct in_addr), AF_INET);E 6  }  else {    /* Convert Hostname */D 11    LispStringToCString(args[0],hostname);E 11I 11    LispStringToCString(args[0],hostname, MAX_HOSTNAME_LENGTH);E 11    hp = gethostbyname(hostname);  }      N_GETNUMBER(args[1], port, handle_error);  /* Translate the buffer pointer into C pointers */  outbuf = (char *)(Addr68k_from_LADDR(args[2]));  inbuf = (char *)(Addr68k_from_LADDR(args[3]));		     N_GETNUMBER(args[4], msec_until_timeout, handle_error);  N_GETNUMBER(args[5], msec_between_tries, handle_error);    N_GETNUMBER(args[6], out_length, handle_error);  /* Convert to micro seconds */  msec_until_timeout = msec_until_timeout * 1000;  msec_between_tries = msec_between_tries * 1000;  /* Set up the timeouts */  total_timeout.tv_sec = msec_until_timeout / 1000000;  total_timeout.tv_usec = msec_until_timeout % 1000000;  pertry_timeout.tv_sec = msec_between_tries / 1000000;  pertry_timeout.tv_usec = msec_between_tries % 1000000;  /* SET UP THE SOCKET */  /* Open the socket; Might want to make this non-blocking */  if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)    goto handle_error;  dontblock = 1;  /* The sockets that rpc controls don't block */D 14  (void)ioctl(s, FIONBIO, &dontblock);E 14I 14D 15#ifdef RISCOSE 15I 15#ifdef SYSVONLY/* NEED TO FILL THIS IN PROPERLY */E 15#else (void)ioctl(s, FIONBIO, &dontblock);D 15#endif RISCOSE 15I 15D 17#endif SYSVONLYE 17I 17#endif /* SYSVONLY */E 17E 15E 14    bzero((char *)&sin, sizeof(sin));  sin.sin_family = AF_INET;  bind(s, &sin, sizeof(sin));  /* Resolve the host address. */  if (hp) {    sin1.sin_family = hp->h_addrtype;    bcopy(hp->h_addr,(caddr_t) &sin1.sin_addr, hp->h_length);  }  else goto handle_error;  /* Convert to network byte order */  sin1.sin_port = htons((u_short)port);  /* Send buffer out on the socket */  if (sendto(s, outbuf, out_length, 0, (struct sockaddr *)&sin1,	     sizeof(sin1)) != out_length)    goto handle_error;  /* Set the select mask */  mask = 1 << s;    /* Set up the timers */  time_waited.tv_sec = 0;  time_waited.tv_usec = 0;    /* Start the waiting loop */ receive:  read_descriptors = mask;  switch(select(32, &read_descriptors, (int *)NULL, (int *)NULL, 		&pertry_timeout)){        /* Per try timeout expired, Check the total timeout */  case 0:    time_waited.tv_sec += pertry_timeout.tv_sec;    time_waited.tv_usec += pertry_timeout.tv_usec;    while(time_waited.tv_usec >= 1000000) {      time_waited.tv_sec++;      time_waited.tv_usec -= 1000000;    }    /* If the time waited is greater than the total      * timeout then there's an error     */    if ((time_waited.tv_sec > total_timeout.tv_sec) ||	((time_waited.tv_sec == total_timeout.tv_sec) &&	 (time_waited.tv_usec >= total_timeout.tv_usec)))      goto handle_error;    else break;        /* An error was generated, Unless it was a system error stop */  case -1:    if (errno == EINTR)      goto receive;    else goto handle_error;  }  /* Did something arrive for this socket */  if ((read_descriptors & mask) == 0)    goto receive;    /* Something arrived; try to get it */   getbuf:  fromlen = sizeof(struct sockaddr);  received = recvfrom(s, inbuf, UDP_DATA_BLOCK_SIZE, 0, 		      (struct sockaddr *)&from, &fromlen);  if (received < 0)    switch(errno) {    case EINTR:      goto getbuf;    case EWOULDBLOCK:      goto receive;    default:      goto handle_error;    }    /* close the socket */  close(s);    /* Return TRUE */  return(ATOM_T);    /* Return NIL; Eventually we will need to return something more informative, perhaps errno    * would be sufficient.   */ handle_error:  return(NIL_PTR);}I 3D 5/* Returns a 32 bit address */get_ip_host_address(args)     LispPTR *args;{  char hostname[MAX_HOSTNAME_LENGTH];  unsigned int *addr;  struct hostent *hp;  /* Convert host name string to C string format */  LispStringToCString(args[0],hostname);  /* Fetch the host entity */  hp = gethostbyname(hostname);  if (hp)    {      /* Fetch the address */      addr = hp->h_addr;      /* Return the address */      N_ARITH_SWITCH(*addr);    }  else    return(NIL_PTR);}E 5E 3E 2E 1