h48258s 00024/00001/00166d D 1.9 91/09/27 01:54:47 sybalsky 9 8c Prepare for allowing signals on incoming X events; retrofit ISC changeses 00001/00001/00166d D 1.8 91/06/12 11:56:18 sybalsky 8 7c Fix error message if X display-open fails so it shows display name.es 00005/00000/00162d D 1.7 91/05/26 17:23:26 sybalsky 7 6c Misc X Cleanup, trying to fix a bug that's in the X-server code.es 00006/00002/00156d D 1.6 91/04/16 14:53:11 sybalsky 6 5c Retrofit foreign-OS changes from Savoir.es 00000/00000/00158d D 1.5 90/09/21 18:09:52 sybalsky 5 4c Fix for color Xes 00076/00053/00082d D 1.4 90/09/18 23:27:19 sybalsky 4 3c Retrofit changes from AIX, DEC3100, PS/2es 00015/00000/00120d D 1.3 90/06/13 15:25:52 sybalsky 3 2c AIX debugging changes.es 00000/00000/00120d D 1.2 90/04/20 01:09:36 sybalsky 2 1c AIX:  shortening file names, bulk change.es 00120/00000/00000d D 1.1 90/03/01 15:30:43 osamu 1 0c date and time created 90/03/01 15:30:43 by osamueuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";I 3/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 3D 4/*E 4I 4/*  E 4*** Copyright (C) 1988 by Fuji Xerox co.,Ltd. All rights reserved.**		Author: Mitsunori Matsuda*		Date  : June 5, 1988**/#include <stdio.h>#include <X11/Xlib.h>#include <X11/Xutil.h>I 9#include <sys/types.h>#include <sys/file.h>E 9#include "lispemul.h"I 4#include "dbprint.h"E 4#include "XVersion.h"#include "MyWindow.h"I 9#ifdef HPUX#define FASYNC O_NONBLOCK#endif HPUX#include <sys/fcntl.h>#include <sys/ioctl.h>#include <stropts.h>#ifdef ISC#define FASYNC O_NONBLOCK#define SIGIO SIGPOLL#endif ISCE 9#define FALSE 0#define TRUE  !FALSE#define DISPLAY_MAX 65536*16*2		/* same magic number is */					/* in loadsysout.c      */extern char *Display_Name;extern int Auto_Repeat;I 6extern int Def_Auto_Repeat;E 6extern char *Lisp_Screen_Size;Display *Xdisplay;Screen *Xscreen;Bool Backing_Store   , Save_Unders;char *Server_Vendor;int Version  , Revision  , Screen_Number  , Byte_Order  , Bitmap_Bit_Order  , Bitmap_Pad  , Bitmap_Unit  , Default_Depth  , Display_Height  , Display_Width  , LispDisplayWidth  , LispDisplayHeight;unsigned long Black_Pixel            , White_Pixel;Colormap Colors;MyWindow Root_Window;I 9int Xfd;  /* The fd for the socket to the server */extern int LispReadFds;E 9I 4I 9E 9/************************************************************************//*									*//*			O p e n _ D i s p l a y				*//*									*//*	Open the connection to the X client/window manager display,	*//*	gather information from it that we'll need (pixel depth, etc),	*//*	and initialize the lisp display-bank size to fit the screen.	*//*									*//*									*//************************************************************************/E 4Open_Display()D 4{#ifdef TRACE	printf( "TRACE: Open_Display()\n" );#endifE 4I 4  {D 9	TPRINT(( "TRACE: Open_Display()\n" ));E 9E 4I 9    TPRINT(( "TRACE: Open_Display()\n" ));E 9D 4	if( (Xdisplay = XOpenDisplay( Display_Name )) == NULL ) {		fprintf( stderr, "Open_Display: cannot connect to display #s0"E 4I 4    if( (Xdisplay = XOpenDisplay( Display_Name )) == NULL )      {D 8	fprintf( stderr, "Open_Display: cannot connect to display #s0"E 8I 8	fprintf( stderr, "Open_Display: cannot connect to display %s."E 8E 4			,XDisplayName(Display_Name));D 4		exit(-1);	}E 4I 4	exit(-1);      }I 9    Xfd = ConnectionNumber(Xdisplay);    LispReadFds |= (1 << Xfd);#ifndef ISC    fcntl(Xfd, F_SETOWN, getpid());#endif ISCE 9E 4I 3#ifdef DEBUGD 4	XSynchronize(Xdisplay, 1);	/* If debugging, run in sync mode. */E 4I 4    /****************************************************/    /* If debugging, set the X connection so that	*/    /* we run synchronized--so a debugger can		*/    /* 'stop in _XError' and know EXACTLY where		*/    /* an error got caused.				*/    /****************************************************/    XSynchronize(Xdisplay, 1);E 4#endif DEBUGE 3D 4	Version          = ProtocolVersion( Xdisplay );	Revision         = ProtocolRevision( Xdisplay );	Server_Vendor    = ServerVendor( Xdisplay );	Byte_Order       = ImageByteOrder( Xdisplay );	Bitmap_Bit_Order = BitmapBitOrder( Xdisplay );	Bitmap_Pad       = BitmapPad( Xdisplay );	Bitmap_Unit      = BitmapUnit( Xdisplay );E 4I 4    Version          = ProtocolVersion( Xdisplay );    Revision         = ProtocolRevision( Xdisplay );    Server_Vendor    = ServerVendor( Xdisplay );    Byte_Order       = ImageByteOrder( Xdisplay );    Bitmap_Bit_Order = BitmapBitOrder( Xdisplay );    Bitmap_Pad       = BitmapPad( Xdisplay );    Bitmap_Unit      = BitmapUnit( Xdisplay );E 4D 4	Screen_Number    = DefaultScreen( Xdisplay );	Xscreen          = ScreenOfDisplay( Xdisplay, Screen_Number );E 4I 4    Screen_Number    = DefaultScreen( Xdisplay );    Xscreen          = ScreenOfDisplay( Xdisplay, Screen_Number );E 4D 4	Backing_Store    = DoesBackingStore( Xscreen );	Save_Unders      = DoesSaveUnders( Xscreen );	Default_Depth	 = DefaultDepthOfScreen( Xscreen );	Black_Pixel      = BlackPixelOfScreen( Xscreen );	White_Pixel      = WhitePixelOfScreen( Xscreen );	Colors           = DefaultColormapOfScreen( Xscreen );	Root_Window.win  = RootWindowOfScreen( Xscreen );	Display_Width    = WidthOfScreen( Xscreen );	Display_Height   = HeightOfScreen( Xscreen );E 4I 4    Backing_Store    = DoesBackingStore( Xscreen );    Save_Unders      = DoesSaveUnders( Xscreen );    Default_Depth	 = DefaultDepthOfScreen( Xscreen );    Black_Pixel      = BlackPixelOfScreen( Xscreen );    White_Pixel      = WhitePixelOfScreen( Xscreen );    Colors           = DefaultColormapOfScreen( Xscreen );    Root_Window.win  = RootWindowOfScreen( Xscreen );    Display_Width    = WidthOfScreen( Xscreen );    Display_Height   = HeightOfScreen( Xscreen );E 4D 4	/* Size of ScreenBitMap */	LispDisplayWidth  = Display_Width  * PERCENT_OF_SCREEN / 100;	LispDisplayHeight = Display_Height * PERCENT_OF_SCREEN / 100; E 4I 4    /************************************************************/    /* 		Set the size of ScreenBitMap			*/    /* The display's width is rounded to a 32-bit multiple,	*/    /* so that little-Endian machines can display right.	*/    /************************************************************/E 4D 4	if( Lisp_Screen_Size[0] != '\0' ) { /* specified in command line */		int bitmask		  , temp_x		  , temp_y;		bitmask = XParseGeometry( Lisp_Screen_Size						, &temp_x						, &temp_y						, &LispDisplayWidth						, &LispDisplayHeight );	} /* end if */E 4I 4    LispDisplayWidth  = Display_Width  * PERCENT_OF_SCREEN / 100;    LispDisplayWidth = ((LispDisplayWidth+31) >> 5) << 5;    LispDisplayHeight = Display_Height * PERCENT_OF_SCREEN / 100; E 4D 4	/* adjust word boundary */	LispDisplayWidth += (BITSPER_DLWORD -1);	LispDisplayWidth -= (LispDisplayWidth % BITSPER_DLWORD);E 4I 4    if( Lisp_Screen_Size[0] != '\0' )      { /* specified in command line */	int bitmask	  , temp_x	  , temp_y;	bitmask = XParseGeometry( Lisp_Screen_Size					, &temp_x					, &temp_y					, &LispDisplayWidth					, &LispDisplayHeight );      } /* end if */E 4D 4	if( (LispDisplayWidth * LispDisplayHeight ) > DISPLAY_MAX ) {		LispDisplayHeight = DISPLAY_MAX / LispDisplayWidth;	} /* end if */E 4I 4    /* adjust word boundary */I 7#ifdef NEVERE 7    LispDisplayWidth += (BITSPER_DLWORD -1);    LispDisplayWidth -= (LispDisplayWidth % BITSPER_DLWORD);I 7#else    LispDisplayWidth += (Bitmap_Pad -1);    LispDisplayWidth -= (LispDisplayWidth % Bitmap_Pad);#endif NEVERE 7E 4D 4	/* Keyboard Auto Repeat */	if( Auto_Repeat ) {		XAutoRepeatOn( Xdisplay );	} else {		XAutoRepeatOff( Xdisplay );	} /* end if */E 4I 4    if( (LispDisplayWidth * LispDisplayHeight ) > DISPLAY_MAX )      {	LispDisplayHeight = DISPLAY_MAX / LispDisplayWidth;      } /* end if */    /* Keyboard Auto Repeat */D 6    if( Auto_Repeat ) XAutoRepeatOn( Xdisplay );    else XAutoRepeatOff( Xdisplay );E 6I 6    if( Def_Auto_Repeat )      {	if( Auto_Repeat ) XAutoRepeatOn( Xdisplay );	else XAutoRepeatOff( Xdisplay );      }E 6E 4} /* end OpenDisplay */E 1