h12530s 00055/00018/00539d D 2.42 93/02/08 14:51:12 sybalsky 47 46c Big VM (and new CDR coding) changes for 3.0 \nes 00014/00014/00543d D 2.41 92/06/26 13:48:29 sybalsky 46 45c retrofit of 386 unix changes \nes 00005/00005/00552d D 2.40 92/04/21 17:12:02 sybalsky 45 44c shortening file names for DOS \nes 00008/00003/00549d D 2.39 92/01/16 14:56:48 sybalsky 44 43c Fix AR 11464es 00002/00002/00550d D 2.38 91/12/11 04:02:46 sybalsky 43 42c Change MSB bit filed name to xMSB to avoid conflict with HP header file.es 00003/00001/00549d D 2.37 91/07/11 12:11:17 sybalsky 42 41c Dec3100 chage to make byteswapped & big atoms workes 00006/00002/00544d D 2.36 91/04/09 17:28:51 sybalsky 41 40c Retrofit first round of changes from MIPS porting centeres 00004/00001/00542d D 2.35 91/02/26 14:28:11 sybalsky 40 39c Put 3-byte-atom specific code inside IFDEFs, so compiles OK for 2-byte case.es 00005/00002/00538d D 2.34 91/02/12 00:28:06 sybalsky 39 38c Fix STKSCAN to handle 3-byte atomses 00049/00030/00491d D 2.33 91/02/07 19:16:03 sybalsky 38 37c Fix nnewframe, native_newframe to handle 3-byte atomses 00021/00011/00500d D 2.32 91/02/04 12:52:33 sybalsky 37 36c Fixes to free variable lookup -- watch out for 3-byte-atoms.es 00000/00001/00511d D 2.31 91/01/16 13:22:40 sybalsky 36 35c Make new nametable be conditional on BIGATOMS again.es 00002/00000/00510d D 2.30 90/12/10 23:41:08 sybalsky 35 34c Cut out BIG NAMETABLE change while I debug 3-byte atoms elsewhere -- JDSes 00080/00021/00430d D 2.29 90/07/26 15:17:31 osamu 34 33c Change Name-table size 16bit->32bit. This change works when #ifdef BIGATOMSes 00000/00000/00451d D 2.28 90/07/25 18:01:35 sybalsky 33 32c es 00002/00002/00449d D 2.27 90/06/15 16:56:50 mitani 32 31c GCLOOKUPes 00000/00000/00451d D 2.26 90/04/20 01:29:56 sybalsky 31 30c mes, bulk change.es 00011/00004/00440d D 2.25 90/03/19 18:09:34 sybalsky 30 29c N_OP_rplptr calls nnewframe, with a local as one arg.  It wasn't dword-aligned, cuasing stack grbaginges 00019/00007/00425d D 2.24 90/03/02 21:43:59 sybalsky 29 28c 386 checks, commentses 00013/00011/00419d D 2.23 89/03/30 13:15:28 sybalsky 28 27c More word-pointers found & fixed to GETWORD.es 00055/00058/00375d D 2.22 89/03/28 16:17:42 shih 27 26c missing sccs id, cleanupes 00163/00148/00270d D 2.21 89/03/27 17:00:13 sybalsky 26 25c Word pointer refs -> GETWORD.es 00010/00015/00408d D 2.20 88/12/01 13:47:06 krivacic 25 24c Add SUN3_OS4_IL & SUN3_OS3_OR_OS4_IL Flags, and move asm labels to inlines.es 00001/00003/00422d D 2.19 88/10/19 14:59:13 krivacic 24 23c fix N_OP_stkscan problem with the upper bytees 00021/00030/00404d D 2.18 88/10/13 19:27:12 krivacic 23 22c new ifdef varses 00002/00002/00432d D 2.17 88/10/12 14:43:55 krivacic 22 21c new out-of-line interfacees 00039/00033/00395d D 2.16 88/10/10 14:04:25 krivacic 21 20c sun3/4 mergees 00001/00005/00427d D 2.15 88/10/04 13:55:55 krivacic 20 19c use macro GETNAMETABLEes 00009/00007/00423d D 2.14 88/07/26 10:45:30 hayata 19 18c missing close brackets, other things from end of nativenewframees 00027/00024/00403d D 2.13 88/07/26 09:27:55 shih 18 17c performance improvements to nnewframe.ces 00049/00005/00378d D 2.12 88/07/21 15:51:22 krivacic 17 16c native asm loopes 00015/00017/00368d D 2.11 88/07/19 18:21:19 krivacic 16 15c native fvar stuffes 00128/00000/00257d D 2.10 88/07/19 16:46:20 krivacic 15 14c native frame lookupes 00006/00006/00251d D 2.9 88/07/08 03:50:39 shih 14 13c changed order of tests (pvars, then fvars, then ivars)es 00116/00113/00141d D 2.8 88/07/08 03:11:40 shih 13 12c many many optimizations, perhaps 30% faster?es 00001/00001/00253d D 2.7 88/07/05 11:10:26 charnley 12 11c further optimizations to nnewframe inner loop via accurate type declarations.es 00004/00000/00250d D 2.6 88/07/01 17:13:52 charnley 11 10c added profile labels to nnewframees 00002/00004/00248d D 2.5 88/07/01 10:36:45 charnley 10 9c shortened inner loop of fvar lookup, changed fvar found to go to next framees 00008/00013/00244d D 2.4 88/06/15 15:21:22 charnley 9 8c cleaned up some crufty code in fvar.es 00013/00278/00244d D 2.3 88/05/31 19:58:14 masinter 8 7c fvar need never punt; can eliminate duplicate codees 00099/00236/00423d D 2.2 88/05/27 14:57:09 krivacic 7 6c C_ONLY ifdef & remove obsolete newframees 00000/00000/00659d D 2.1 88/05/17 09:24:09 hayata 6 5c Version up to 2.1es 00006/00006/00653d D 1.5 88/05/09 21:24:34 shih 5 4c Use GCLOOKUPes 00302/00000/00357d D 1.4 88/03/31 19:35:05 krivacic 4 3c New Interface for FVar ops & stkscanes 00002/00002/00355d D 1.3 88/03/13 14:47:18 hayata 3 2c Add SCCS key id (%Z%)es 00005/00005/00352d D 1.2 88/03/03 11:35:27 krivacic 2 1c Removed global CurrentFX to use CURRENTFX = PVAR - FRAMESIZEes 00357/00000/00000d D 1.1 88/02/24 16:56:50 hayata 1 0c date and time created 88/02/24 16:56:50 by hayataeuUtTI 1D 3/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 3I 3D 22/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 22I 22D 27/* This is G-file @(#) fvar.c Version 2.16 (10/10/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) fvar.c	2.16 10/10/88";E 22E 3D 8/*** ADOPTED NEW VERSION ***/E 8E 27I 27D 29/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 27/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 8 *	Auther	:	Hiroshi Hayata	E 8I 8D 27 *	Author	:	Hiroshi Hayata	E 27I 27 *	Author	:	Hiroshi HayataE 27E 8 */E 29I 29D 30/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 30I 30D 37/* @(#) fvar.c Version 2.24 (3/2/90). copyright venue & Fuji Xerox  */static char *id = "@(#) fvar.c	2.24 3/2/90	(venue & Fuji Xerox)";E 37I 37/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 37E 30/************************************************************************//*									*/D 37/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 37I 37/*	Copyright 1989, 1990, 1991 Venue				*/E 37/*									*/D 37/*	This file is work-product resulting from the Xerox/Venue	*/E 37I 37/*	This file was work-product resulting from the Xerox/Venue	*/E 37/*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 29#include <stdio.h>#include "lispemul.h"D 45#include "lispglobal.h"#include "address68k.h"E 45I 45#include "lspglob.h"#include "adr68k.h"E 45#include "stack.h"D 45#include "emulglobal.h"E 45I 45#include "emlglob.h"E 45#include "lispmap.h"I 26D 45#include "lisptypes.h"E 45I 45#include "lsptypes.h"E 45E 26#include "gc.h"I 41D 46#ifdef AIXPS2E 46I 46#ifdef GCC386E 46D 45#include "inlinePS2.h"E 45I 45#include "inlnPS2.h"E 45D 46#endif AIXPS2E 46I 46#endif E 46E 41D 26#define	MaskShift(x)	((0xFF & x) << 16)E 26I 26#define	MaskShift(x)	((0xFF & (x)) << 16)E 26I 35D 36#undef BIGATOMS  /* * * * * Until 3-byte fns are in * * * * */E 36E 35I 34#ifdef BIGATOMSD 47#define NT_OFFSET_MASK  0xFFFFFFE 47I 47#define NT_OFFSET_MASK  0xFFFFFFFE 47#define NT_TYPE_MASK    0xFF000000#define GetNTEntry(X)   GetLongWord(X)#define NAMETABLE       LispPTR#else#define NT_OFFSET_MASK  0xFF#define NT_TYPE_MASK    0xFF00#define GetNTEntry(X)   GETWORD(X)#define NAMETABLE       DLword#endifE 34D 13#define FVSTACK		2#define FVGLOBAL	6E 13D 9#define FVUBNBOUND	3E 9D 13#define FVIVAR		0x0#define FVPVAR		0x80#define FVFVAR		0xC0#define ENDSTACKMARK	0xbD 7/************************************************************************* OP_fvarn.c	entry of OPCODE[120b-127b]: FVAR, FVARX	1. save TopOfStack to evaluation stack.	2. set address of searching FVAR slot to chain.	3. call lookfor. (It sets some content to FVAR slot)	4. get some address by caluculation of content of FVAR slot.	5. set the address to TopOfStack.	6. increment PC.**************************************************************************/  OP_fvarn(){register int	n;	/* FVAR slot: word offset from PVar, or scratch */register DLword	*chain;	/* keep FVAR slot2 in CurrentFrameExtension */#ifdef TRACE	printPC();	printf("TRACE:OP_fvarn()\n");#endif	if(*PC == 0127)		n = 0xFF & (*(++PC));	else		n = (*PC & 0x07)<<1;	PushCStack;	chain = PVar + n;#ifdef	DEBUG	printf("DEBUG:newframe[chain (before fvlookup) %x %x]\n",*chain, *(chain+1));#endif/*	if((*chain) & 0x0001){	*/	if(((WBITS *)chain)->LSB){		/* check 15bit of FVAR slot1 in CurrentFrameExtension.			0:	bound			1:	unbound */D 2		fvlookup(CurrentFX, chain, FuncObj);			/* CurrentFX:	pointer to current frame extension */E 2I 2		fvlookup(CURRENTFX, chain, FuncObj);			/* CURRENTFX:	pointer to current frame extension */E 2			/* chain:	pointer to variables to be looked up */			/* FuncObj:	pointer to current function header */	}#ifdef	DEBUG	printf("DEBUG:newframe[chain (after fvlookup) %x %x]\n",*chain, *(chain+1));#endif	n = 0xFFFFFF & (((*(chain+1))<<16) | *chain);	TopOfStack = GetLongWord( Addr68k_from_LADDR(n) );	++PC;	if(StackCheck)		StackOverflow;	return;}/************************************************************************** fvlookup:	This routine is used by only OP_fvarn.	1. get Atom index number of target fvar slot.	2. call fvlookfor.****************************************************************************/fvlookup(apframe1, achain, apfnhead1)struct frameex1 *apframe1;	/* pointer to current frame extension */register DLword	*achain;	/* pointer to 1st word of the searching FVAR slot in CurrentFrameExtension */register struct fnhead	*apfnhead1;	/* pointer to current function heaer */{register DLword *pfh;	/* pointer to current function header */register int	paoffset;	/* 2word offset in PVAR AREA */#ifdef TRACE	printf("TRACE:OP_fvlookup(%x, %x, %x)\n",apframe1, achain, apfnhead1);#endif	pfh = (DLword *)apfnhead1;	paoffset = ((int)achain - (int)PVar)>>2;		/* slot to looked for, 2word offset from PVar */	return( newframe(apframe1, achain, (*(pfh + (apfnhead1->fvaroffset + paoffset - apfnhead1->nlocals)))) );	/* "*(pfh + (apfnhead1->fvaroffset + paoffset - apfnhead1->nlocals))" is Atom index num. of target FVAR slot. */}E 7/******************************************************************************D 7newframeE 7I 7nnewframeE 7	This routine is used by fvlookup and OP_stkscan.	1. scan Name table in new function header.	2. if found, set address of searching variable to chain address.D 7	3. return the type of variable, on stack, global or unbound.E 7I 7D 8	3. return the type of variable, on stack, global or unbound, -1 on error.E 8I 8D 9	3. return the type of variable, on stack, global or unbound.E 9I 9	3. return the type of variable, on stack, or global.E 9E 8E 7******************************************************************************/D 7newframe(apframe1, achain, name)E 7I 7nnewframe(apframe1, achain, name)E 7struct frameex1 *apframe1;	/* pointer to current frame extension */D 8register DLword	*achain;	/* pointer to 1st word of the searching FVAR slot in CurrentFrameExtension */E 8I 8register DLword	*achain;	/* pointer to 1st word of the searching				  FVAR slot in CurrentFrameExtension */E 8register int	name;		/* Atom index num. of target FVAR slot. */{register struct frameex1 *newpfra2;	/* pointer to new frame extension */register struct fnhead *newpfn2;		/* pointer to new function header */int	fvartype;	/* vartype of searching fvar */int	fvaroffset;	/* varoffset of searching fvar */register DLword	*pindex;	/* index to indexs of new name table */D 8DLword	*ppvar;		/* pointer to searching var candidate */E 8I 8DLword	*ppvar;			/* pointer to searching var candidate */E 8register int	i;		/* temp for control */D 8short	nametablesize;	/* NameTable size of current function header. */E 8I 8short	nametablesize;		/* NameTable size of current function header. */E 8D 8#ifdef TRACED 7	printf("TRACE:OP_newframe(%x, %x, name: %x)\n", apframe1, achain, name);E 7I 7	printf("TRACE:N_OP_newframe(%x, %x, name: %x)\n", apframe1, achain, name);E 7#endifE 8newframe:I 11	asm("_newframe_setup:");	asm("	.globl	_newframe_setup");E 11D 8	/* assume that apframe1 can poiints next searching frame */E 8I 8	/* assume that apframe1 points to the next frame to be scanned */E 8	if(apframe1->alink == ENDSTACKMARK){	/* endStack */		if(name & 0x8000){			*(achain+1) = VALS_HI + 1;			*achain = name*2;		}else{			*(achain+1) = VALS_HI;			*achain = name*2;		}		return(FVGLOBAL);	} 	newpfra2 = (struct frameex1 *)(Stackspace + ((apframe1->alink & 0xFFFE) - FRAMESIZE));	if(newpfra2->validnametable)				/* check VALIDNAMETABLE */		newpfn2 = (struct fnhead *)( Addr68k_from_LADDR( ((newpfra2->hi2nametable)<<16 | newpfra2->lonametable) ));	else		newpfn2 = (struct fnhead *)( Addr68k_from_LADDR( ((newpfra2->hi2fnheader)<<16 | newpfra2->lofnheader) ));lookfor:D 8#ifdef	DEBUG	printf("DEBUG:newframe[lookfor:]\n");#endifE 8	pindex = (DLword *)newpfn2 + FNHEADSIZE;		/* now pindex points 1st wor of Nametable. */	nametablesize = newpfn2->ntsize;I 11	asm("_newframe_loop:");	asm("	.globl	_newframe_loop");E 11D 8/*** Change on 27-Oct-87 Hayata	for(i=0; i<nametablesize; ++i){			if(*pindex++ == name){#ifdef	DEBUG	printf("DEBUG:newframe[find same AtomIndexNumber on NameTable: %x]\n", name);#endif			--pindex;			fvaroffset = *(pindex + nametablesize);****/E 8D 10	for(i=0; i<nametablesize; ++i, ++pindex){	/* searching in NewFuncHeader */E 10I 10	for(i=nametablesize; --i >= 0; ++pindex){	/* searching in NewFuncHeader */E 10D 12		if(*pindex == name){E 12I 12		if(*((DLword *)pindex) == (DLword)name){E 12D 8#ifdef	DEBUG	printf("DEBUG:newframe[find same AtomIndexNumber on NameTable: %x]\n", name);#endif                         E 8			fvaroffset = *(pindex + nametablesize);			fvartype = 0xFF &(fvaroffset >> 8);			fvaroffset = 0xFF & fvaroffset;				switch(fvartype){			case FVIVAR: /* 0x0: */	D 8#ifdef	DEBUG	printf("DEBUG:newframe[vartype is FVIVAR, offset %x]\n", fvaroffset);#endifE 8				ppvar = (DLword *)newpfra2 - 1;					/* ppvar points to IVAR field in Basic  frame */				*(achain+1) = STK_HI;				*achain = *ppvar + (fvaroffset << 1);				return(FVSTACK);			case FVPVAR: /* 0x80: */	D 8#ifdef	DEBUG	printf("DEBUG:newframe[vartype if FVPVAR, offset %x]\n", fvaroffset);#endifE 8				ppvar = (DLword *)newpfra2 + (fvaroffset << 1) + FRAMESIZE;					/* ppvar points to argued Pvar */D 8/*				if(*ppvar & 0x8000)	*/E 8				if(((WBITS *)ppvar)->MSB)					/* check UNBOUND (if *ppvar is negative , unbound) */					continue;				*(achain+1) = STK_HI;				*achain = 0xFFFF & LADDR_from_68k( ppvar );					/* save High word of PVAR slot address to FVAR slot */					/* achain points to target FVAR slot */				return(FVSTACK);			case FVFVAR: /* 0xC0: */	D 8#ifdef	DEBUG	printf("DEBUG:newframe[vartype is FVFVAR, offset %x]\n", fvaroffset);#endifE 8				ppvar = (DLword *)newpfra2 + (fvaroffset << 1) + FRAMESIZE;D 10				if(*ppvar & 0x1){E 10I 10				if(*ppvar & 0x1) goto endlookfor;E 10					/* Not Found in new FuncHeader, scan the next one. */D 10					continue;				}E 10				*((int *)achain) = *((int *)ppvar);					/* save address of frame extension to FVAR slot */					/* achain points to target FVAR slot */				if((0xFF & *(ppvar+1)) == STK_HI)					return(FVSTACK);				else					return(FVGLOBAL);D 7			default:				error("fvlookup: Vartype is not good \n");E 7I 7D 8			default:return(-1);E 8I 8			default:error("Stack corrupted: bad value in name table");E 8E 7			}/* end switch */		}/* end if */	}/* end for */endlookfor:D 8#ifdef	DEBUG	printf("DEBUG:newframe[scan next frame]\n");#endifE 8	apframe1 = newpfra2;	/* set next new FuncHeader */	goto newframe;		/* scan the next one */}E 13D 8I 7#ifdef C_ONLYE 8/*************************************************************************D 8 OP_fvarn.c	entry of OPCODE[120b-127b]: FVAR, FVARX	1. save TopOfStack to evaluation stack.	2. set address of searching FVAR slot to chain.	3. call lookfor. (It sets some content to FVAR slot)	4. get some address by caluculation of content of FVAR slot.	5. set the address to TopOfStack.	6. increment PC.**************************************************************************/  OP_fvarn(){register int	n;	/* FVAR slot: word offset from PVar, or scratch */register DLword	*chain;	/* keep FVAR slot2 in CurrentFrameExtension */#ifdef TRACE	printPC();	printf("TRACE:OP_fvarn()\n");#endif	if(*PC == 0127)		n = 0xFF & (*(++PC));	else		n = (*PC & 0x07)<<1;	PushCStack;	chain = PVar + n;#ifdef	DEBUG	printf("DEBUG:newframe[chain (before fvlookup) %x %x]\n",*chain, *(chain+1));#endif/*	if((*chain) & 0x0001){	*/	if(((WBITS *)chain)->LSB){		/* check 15bit of FVAR slot1 in CurrentFrameExtension.			0:	bound			1:	unbound */		if(fvlookup(CURRENTFX, chain, FuncObj) == -1) 			error("fvlookup: Vartype is not good \n");			/* CURRENTFX:	pointer to current frame extension */			/* chain:	pointer to variables to be looked up */			/* FuncObj:	pointer to current function header */	}#ifdef	DEBUG	printf("DEBUG:newframe[chain (after fvlookup) %x %x]\n",*chain, *(chain+1));#endif	n = 0xFFFFFF & (((*(chain+1))<<16) | *chain);	TopOfStack = GetLongWord( Addr68k_from_LADDR(n) );	++PC;	if(StackCheck)		StackOverflow;	return;}/************************************************************************** fvlookup:	This routine is used by only OP_fvarn.	1. get Atom index number of target fvar slot.	2. call fvlookfor.****************************************************************************/fvlookup(apframe1, achain, apfnhead1)struct frameex1 *apframe1;	/* pointer to current frame extension */register DLword	*achain;	/* pointer to 1st word of the searching FVAR slot in CurrentFrameExtension */register struct fnhead	*apfnhead1;	/* pointer to current function heaer */{register DLword *pfh;	/* pointer to current function header */register int	paoffset;	/* 2word offset in PVAR AREA */#ifdef TRACE	printf("TRACE:OP_fvlookup(%x, %x, %x)\n",apframe1, achain, apfnhead1);#endif	pfh = (DLword *)apfnhead1;	paoffset = ((int)achain - (int)PVar)>>2;		/* slot to looked for, 2word offset from PVar */	return( nnewframe(apframe1, achain, (*(pfh + (apfnhead1->fvaroffset + paoffset - apfnhead1->nlocals)))) );}E 7/******************************************************************************OP_stkscan	entry	STKSCAN		OPCODE[057]	<<Enter>>	TopOfStack:	Low word - Atom index number of variable to be saned.	<<Exit>>	TopOfStack:	Address of found value.	1. call fvlookup.	2. Set *chain to TopOfStack.	3. Increment Pc by 1.******************************************************************************/OP_stkscan(){register DLword	*chain;register LispPTR	temp;int	scratch;register int	name;#ifdef TRACE	printPC();	printf("TRACE:OP_stkscan()\n");#endif	scratch = TopOfStack;D 2	newframe(CurrentFX, (DLword *)&scratch, 0xFFFF & scratch );E 2I 2D 7	newframe(CURRENTFX, (DLword *)&scratch, 0xFFFF & scratch );E 7I 7	if (nnewframe(CURRENTFX, (DLword *)&scratch, 0xFFFF & scratch ) == -1)		error("fvlookup: Vartype is not good \n");E 7E 2	temp = 0xFFFF & scratch;	scratch >>= 16;	TopOfStack =  (0xFFFF0000 & (temp<<16)) | (0xFFFF & scratch);	++PC;D 7/****	chain = (DLword *)&TopOfStack;	name = 0xFFFF & TopOfStack;D 2	newframe(CurrentFX, chain, name);E 2I 2	newframe(CURRENTFX, chain, name);E 2	temp = 0xFFFF & TopOfStack;	TopOfStack >>= 16;	TopOfStack =  (0xFFFF0000 & (temp<<16)) | (0xFFFF & TopOfStack);	++PC;****/E 7}/**************************************************OP_fvar_	Entry:	FVAR_		opcode[0143]	***************************************************/OP_fvar_(){register DLword	*ppvar;		/* pointer to argued Fvar slot in pvar area */register DLword	*pfreeval;	/* pointer to argued free value */register int	l1;		/* return value of fvlookup() */#ifdef	TRACE	printPC();	printf("OP_fvar_()\n");#endif	ppvar = PVar + (*(PC+1) & 0xFF);/*	if((*ppvar) & 0x0001){ */	/* check unbound ? */	if(((WBITS *)ppvar)->LSB){	/* check unbound ? */	/* unbound */D 2		l1 = fvlookup(CurrentFX, ppvar, FuncObj);E 2I 2		l1 = fvlookup(CURRENTFX, ppvar, FuncObj);I 7	if (l1 == -1)		error("fvlookup: Vartype is not good \n");E 7E 2		/* scan stack, and set freeval address to the ppvar+1 address */	}else		l1 = 0; /** Hayata::  Changed on 28-Nov-1987 **/	/* bound */	pfreeval =Addr68k_from_LADDR( MaskShift((*(ppvar+1))) | *ppvar );/** Hayata::  Changed on 10-Nov-1987 **/	if((l1 == FVGLOBAL) || ((0xFF & *(ppvar+1)) != STK_HI)){#ifdef	TESTTEMP		printf("fvar:: l1=%x, *(ppvar+1)=%x, *pfreeval=%x\n", l1,(0xFF & *(ppvar+1)),  *((LispPTR *)pfreeval));		if(*((LispPTR *)pfreeval) == 0x3c6e38)			stab();#endifD 5		gclookup(0x8000|DELREF, *((LispPTR *)pfreeval));		gclookup(0x8000|ADDREF, TopOfStack);E 5I 5		GCLOOKUP(0x8000,DELREF, *((LispPTR *)pfreeval));		GCLOOKUP(0x8000,ADDREF, TopOfStack);E 5	}/** Hayata:: Changed on 23-Oct-1987	if(l1 == FVGLOBAL || (0xFF & *(ppvar+1)) != STK_HI){		GcLov = 0;D 5		gclookup(0x8000|DELREF, *((int*)pfreeval));E 5I 5		GCLOOKUP(0x8000,DELREF, *((int*)pfreeval));E 5		if(GcLov == 0xFFFF){#ifdef	DEBUG	printf("DEBUG: OP_fvar_[HashTable overflow or collision]\n");#endif		*((LispPTR *)pfreeval) = TopOfStack;			funcall(ATOMGCSCAN, 1, 2);			return;		}	}D 5	gclookup(0x8000|ADDREF, TopOfStack);E 5I 5	GCLOOKUP(0x8000,ADDREF, TopOfStack);E 5***/	*((LispPTR *)pfreeval) = TopOfStack;	PC+=2;	return;}I 4/* ********************************************************************** */I 7#elseE 7D 7E 7/*************************************************************************E 8D 26 N_OP_fvarn.cE 26I 26 N_OP_fvarnE 26	entry of OPCODE[120b-127b]: FVAR, FVARX	1. save TopOfStack to evaluation stack.	2. set address of searching FVAR slot to chain.	3. call lookfor. (It sets some content to FVAR slot)	4. get some address by caluculation of content of FVAR slot.	5. set the address to TopOfStack.D 27**************************************************************************/  E 27I 27**************************************************************************/E 27D 8LispPTR N_OP_fvarn(n, error_addr)E 8I 8LispPTR N_OP_fvarn(n)E 8	/* n is word offset */D 26	register int n;D 8	int *error_addr;E 8{register DLword	*chain;	/* keep FVAR slot2 in CurrentFrameExtension */E 26I 26 register int n;  {  register DLword *chain;	/* keep FVAR slot2 in CurrentFrameExtension */E 26D 8#ifdef TRACE	printf("TRACE:N_OP_fvarn()\n");#endifE 8D 26	chain = PVar + n;E 26I 26  chain = PVar + n;E 26D 8#ifdef	DEBUG	printf("DEBUG:newframe[chain (before fvlookup) %x %x]\n",*chain, *(chain+1));#endifE 8D 26	if(((WBITS *)chain)->LSB){		/* check 15bit of FVAR slot1 in CurrentFrameExtension.			0:	bound			1:	unbound */D 9		if (nfvlookup(CURRENTFX, chain, FuncObj) < 0) D 8			ERROR_EXIT(error_addr);			/* CURRENTFX:	pointer to current frame extension */			/* chain:	pointer to variables to be looked up */			/* FuncObj:	pointer to current function header */E 8I 8			return(NOBIND_PTR);E 9I 9		nfvlookup(CURRENTFX, chain, FuncObj);E 9E 8	}E 26I 26D 28  if(((WBITS *)chain)->LSB)E 28I 28  if(WBITSPTR(chain)->LSB)E 28    {      /* check 15bit of FVAR slot1 in CurrentFrameExtension.	 0: bound	 1: unbound */      nfvlookup(CURRENTFX, chain, FuncObj);    }E 26D 8#ifdef	DEBUG	printf("DEBUG:newframe[chain (after fvlookup) %x %x]\n",*chain, *(chain+1));#endifE 8D 26	return(	  GetLongWord( 		Addr68k_from_LADDR(0xFFFFFF & (((*(chain+1))<<16) | *chain))));}E 26I 26D 47  return(GetLongWord(Addr68k_from_LADDR(0xFFFFFF &E 47I 47  return(GetLongWord(Addr68k_from_LADDR(POINTERMASK &E 47D 46					(((GETWORD(chain+1))<<16) |					 GETWORD(chain)))));E 46I 46					(((GETBASEWORD(chain,1))<<16) |					 GETBASEWORD(chain,0)))));E 46  }E 26I 42E 42/************************************************************************** nfvlookup:	This routine is used by only OP_fvarn.D 9E 9I 9		( in addition to N_OP_fvar_() )E 9	1. get Atom index number of target fvar slot.	2. call fvlookfor.****************************************************************************/nfvlookup(apframe1, achain, apfnhead1)D 26struct frameex1 *apframe1;	/* pointer to current frame extension */register DLword	*achain;	/* pointer to 1st word of the searching FVAR slot in CurrentFrameExtension */register struct fnhead	*apfnhead1;	/* pointer to current function heaer */{register DLword *pfh;	/* pointer to current function header */register int	paoffset;	/* 2word offset in PVAR AREA */E 26I 26  struct frameex1 *apframe1;	/* pointer to current frame extension */  register DLword *achain;	/* pointer to 1st word of the searching				   FVAR slot in CurrentFrameExtension */  register struct fnhead *apfnhead1;	/* pointer to current function heaer */  {    register DLword *pfh;	/* pointer to current function header */    register int    paoffset;	/* 2word offset in PVAR AREA */E 26D 8#ifdef TRACE	printf("TRACE:OP_fvlookup(%x, %x, %x)\n",apframe1, achain, apfnhead1);#endifE 8D 26	pfh = (DLword *)apfnhead1;	paoffset = ((int)achain - (int)PVar)>>2;E 26I 26    pfh = (DLword *)apfnhead1;    paoffset = ((int)achain - (int)PVar)>>2;E 26		/* slot to looked for, 2word offset from PVar */I 34#ifdef BIGATOMSE 34D 8	return( nnewframe(apframe1, achain, (*(pfh + (apfnhead1->fvaroffset + paoffset - apfnhead1->nlocals)))) );E 8I 8D 26	nnewframe(apframe1, achain, (*(pfh + (apfnhead1->fvaroffset + paoffset - apfnhead1->nlocals))));E 26I 26    nnewframe(apframe1, achain,I 34D 42	      (GETWORD((LispPTR *)E 42I 42	      (*((LispPTR *)E 42		       ((DLword *)pfh + apfnhead1->fvaroffset) + paoffset			- apfnhead1->nlocals)));#else    nnewframe(apframe1, achain,E 34	      (GETWORD(pfh + (apfnhead1->fvaroffset + paoffset -D 27			    apfnhead1->nlocals))));E 27I 27			      apfnhead1->nlocals))));E 27E 26E 8D 34E 34I 34#endifE 34D 26}E 26I 26  }E 26D 7/******************************************************************************nnewframeE 7D 7	This routine is used by fvlookup and OP_stkscan.	1. scan Name table in new function header.	2. if found, set address of searching variable to chain address.	3. return the type of variable, on stack, global or unbound, -1 on error.******************************************************************************/nnewframe(apframe1, achain, name)struct frameex1 *apframe1;	/* pointer to current frame extension */register DLword	*achain;	/* pointer to 1st word of the searching FVAR slot in CurrentFrameExtension */register int	name;		/* Atom index num. of target FVAR slot. */{register struct frameex1 *newpfra2;	/* pointer to new frame extension */register struct fnhead *newpfn2;		/* pointer to new function header */int	fvartype;	/* vartype of searching fvar */int	fvaroffset;	/* varoffset of searching fvar */register DLword	*pindex;	/* index to indexs of new name table */DLword	*ppvar;		/* pointer to searching var candidate */register int	i;		/* temp for control */short	nametablesize;	/* NameTable size of current function header. */#ifdef TRACE	printf("TRACE:N_OP_newframe(%x, %x, name: %x)\n", apframe1, achain, name);#endifnewframe:	/* assume that apframe1 can poiints next searching frame */	if(apframe1->alink == ENDSTACKMARK){	/* endStack */		if(name & 0x8000){			*(achain+1) = VALS_HI + 1;			*achain = name*2;		}else{			*(achain+1) = VALS_HI;			*achain = name*2;		}		return(FVGLOBAL);	} 	newpfra2 = (struct frameex1 *)(Stackspace + ((apframe1->alink & 0xFFFE) - FRAMESIZE));	if(newpfra2->validnametable)				/* check VALIDNAMETABLE */		newpfn2 = (struct fnhead *)( Addr68k_from_LADDR( ((newpfra2->hi2nametable)<<16 | newpfra2->lonametable) ));	else		newpfn2 = (struct fnhead *)( Addr68k_from_LADDR( ((newpfra2->hi2fnheader)<<16 | newpfra2->lofnheader) ));lookfor:#ifdef	DEBUG	printf("DEBUG:newframe[lookfor:]\n");#endif	pindex = (DLword *)newpfn2 + FNHEADSIZE;		/* now pindex points 1st wor of Nametable. */	nametablesize = newpfn2->ntsize;/*** Change on 27-Oct-87 Hayata	for(i=0; i<nametablesize; ++i){			if(*pindex++ == name){#ifdef	DEBUG	printf("DEBUG:newframe[find same AtomIndexNumber on NameTable: %x]\n", name);#endif			--pindex;			fvaroffset = *(pindex + nametablesize);****/	for(i=0; i<nametablesize; ++i, ++pindex){	/* searching in NewFuncHeader */		if(*pindex == name){#ifdef	DEBUG	printf("DEBUG:newframe[find same AtomIndexNumber on NameTable: %x]\n", name);#endif                         			fvaroffset = *(pindex + nametablesize);			fvartype = 0xFF &(fvaroffset >> 8);			fvaroffset = 0xFF & fvaroffset;				switch(fvartype){			case FVIVAR: /* 0x0: */	#ifdef	DEBUG	printf("DEBUG:newframe[vartype is FVIVAR, offset %x]\n", fvaroffset);#endif				ppvar = (DLword *)newpfra2 - 1;					/* ppvar points to IVAR field in Basic  frame */				*(achain+1) = STK_HI;				*achain = *ppvar + (fvaroffset << 1);				return(FVSTACK);			case FVPVAR: /* 0x80: */	#ifdef	DEBUG	printf("DEBUG:newframe[vartype if FVPVAR, offset %x]\n", fvaroffset);#endif				ppvar = (DLword *)newpfra2 + (fvaroffset << 1) + FRAMESIZE;					/* ppvar points to argued Pvar *//*				if(*ppvar & 0x8000)	*/				if(((WBITS *)ppvar)->MSB)					/* check UNBOUND (if *ppvar is negative , unbound) */					continue;				*(achain+1) = STK_HI;				*achain = 0xFFFF & LADDR_from_68k( ppvar );					/* save High word of PVAR slot address to FVAR slot */					/* achain points to target FVAR slot */				return(FVSTACK);			case FVFVAR: /* 0xC0: */	#ifdef	DEBUG	printf("DEBUG:newframe[vartype is FVFVAR, offset %x]\n", fvaroffset);#endif				ppvar = (DLword *)newpfra2 + (fvaroffset << 1) + FRAMESIZE;				if(*ppvar & 0x1){					/* Not Found in new FuncHeader, scan the next one. */					continue;				}				*((int *)achain) = *((int *)ppvar);					/* save address of frame extension to FVAR slot */					/* achain points to target FVAR slot */				if((0xFF & *(ppvar+1)) == STK_HI)					return(FVSTACK);				else					return(FVGLOBAL);			default:return(-1);			}/* end switch */		}/* end if */	}/* end for */endlookfor:#ifdef	DEBUG	printf("DEBUG:newframe[scan next frame]\n");#endif	apframe1 = newpfra2;	/* set next new FuncHeader */	goto newframe;		/* scan the next one */}E 7/******************************************************************************N_OP_stkscan	entry	STKSCAN		OPCODE[057]	<<Enter>>	TopOfStack:	Low word - Atom index number of variable to be saned.	<<Exit>>	TopOfStack:	Address of found value.	1. call fvlookup.	2. Set *chain to TopOfStack.	3. Increment Pc by 1.******************************************************************************/I 30E 30D 8LispPTR N_OP_stkscan(tos, error_addr)E 8I 8LispPTR N_OP_stkscan(tos)E 8D 26	LispPTR tos;D 8	int *error_addr;E 8{register DLword	*chain;register LispPTR	temp;	int	scratch;register int	name;D 8#ifdef TRACE	printf("TRACE:N_OP_stkscan()\n");#endifE 8	scratch = tos;D 8	if (nnewframe(CURRENTFX, (DLword *)&scratch, 0xFFFF & scratch ) < 0)		ERROR_EXIT(error_addr);E 8I 8	nnewframe(CURRENTFX, (DLword *)&scratch, 0xFFFF & scratch );E 8D 24	temp = 0xFFFF & scratch;	scratch >>= 16;	return((0xFFFF0000 & (temp<<16)) | (0xFFFF & scratch));E 24I 24	return(((0xFF & scratch)<<16) | ((unsigned int) scratch >> 16));E 24}E 26I 26  LispPTR tos;  {D 28    register DLword	*chain;E 28D 30    register LispPTR	temp;E 30I 30#ifdef I386    int scratchx[3];    int *scratch = (int *)(0xFFFFFFFC & (3+(int)scratchx));    *scratch = tos;D 39    nnewframe(CURRENTFX, (DLword *)scratch, 0xFFFF & *scratch );E 39I 39D 47    nnewframe(CURRENTFX, (DLword *)scratch, 0xFFFFFF & *scratch );E 47I 47    nnewframe(CURRENTFX, (DLword *)scratch, POINTERMASK & *scratch );E 47E 39D 41    return(((0xFF & *scratch)<<16) | ((unsigned int) *scratch >> 16));E 41I 41    return(swapx(*scratch));E 41#elseE 30    int	scratch;D 30    register int	name;E 30    scratch = tos;D 39    nnewframe(CURRENTFX, (DLword *)&scratch, 0xFFFF & scratch );E 39I 39D 47    nnewframe(CURRENTFX, (DLword *)&scratch, 0xFFFFFF & scratch );E 47I 47    nnewframe(CURRENTFX, (DLword *)&scratch, POINTERMASK & scratch );E 47E 39D 41    return(((0xFF & scratch)<<16) | ((unsigned int) scratch >> 16));E 41I 41    return(swapx(scratch));E 41I 30D 47#endif I386E 47I 47#endif /* I386 */E 47E 30  }I 39E 39E 26/**************************************************N_OP_fvar_	Entry:	FVAR_		opcode[0143]D 27	E 27I 27E 27***************************************************/D 9LispPTR N_OP_fvar_(tos, n, error_addr)E 9I 9LispPTR N_OP_fvar_(tos, n)E 9D 26	register LispPTR tos;	register int n;D 9	int *error_addr;E 9{register DLword	*ppvar;		/* pointer to argued Fvar slot in pvar area */register DLword	*pfreeval;	/* pointer to argued free value */register int	l1;		/* return value of fvlookup() */E 26I 26  register LispPTR tos;  register int n;  {D 27    register DLword *ppvar;		/* pointer to argued Fvar slot in pvar area */E 27I 27    register DLword *ppvar;	/* pointer to argued Fvar slot in pvar area */E 27    register DLword *pfreeval;	/* pointer to argued free value */    register int l1;		/* return value of fvlookup() */E 26D 8#ifdef	TRACE	printf("N_OP_fvar_()\n");#endifE 8D 26	ppvar = PVar + n;E 26I 26    ppvar = PVar + n;E 26D 26	if(((WBITS *)ppvar)->LSB){	/* check unbound ? */E 26I 26D 28    if(((WBITS *)ppvar)->LSB)	/* check unbound ? */E 28I 28    if(WBITSPTR(ppvar)->LSB)	/* check unbound ? */E 28      { /* unbound */	nfvlookup(CURRENTFX, ppvar, FuncObj);      }E 26D 26/* unbound */D 9		l1 = nfvlookup(CURRENTFX, ppvar, FuncObj);		/* scan stack, and set freeval address to the ppvar+1 address */		if (l1 < 0) ERROR_EXIT(error_addr);	}elseD 8/* bound */E 8		l1 = 0;E 9I 9		nfvlookup(CURRENTFX, ppvar, FuncObj);	}E 26I 26    pfreeval =Addr68k_from_LADDR( MaskShift((GETWORD(ppvar+1))) |D 27					    GETWORD(ppvar) );E 27I 27					     GETWORD(ppvar) );E 27E 26E 9D 26	pfreeval =Addr68k_from_LADDR( MaskShift((*(ppvar+1))) | *ppvar );E 26I 26    if( ((0xFF & GETWORD(ppvar+1)) != STK_HI))      {D 32	GCLOOKUP(0x8000,DELREF, *((LispPTR *)pfreeval));	GCLOOKUP(0x8000,ADDREF, tos);E 32I 32	GCLOOKUP(*((LispPTR *)pfreeval), DELREF);	GCLOOKUP(tos, ADDREF);E 32      }E 26D 9	if((l1 == FVGLOBAL) || ((0xFF & *(ppvar+1)) != STK_HI)){E 9I 9D 26	if( ((0xFF & *(ppvar+1)) != STK_HI)){E 9D 8#ifdef	TESTTEMP		printf("fvar:: l1=%x, *(ppvar+1)=%x, *pfreeval=%x\n", l1,(0xFF & *(ppvar+1)),  *((LispPTR *)pfreeval));		if(*((LispPTR *)pfreeval) == 0x3c6e38)			stab();#endifE 8D 5		gclookup(0x8000|DELREF, *((LispPTR *)pfreeval));		gclookup(0x8000|ADDREF, tos);E 5I 5		GCLOOKUP(0x8000,DELREF, *((LispPTR *)pfreeval));		GCLOOKUP(0x8000,ADDREF, tos);E 5	}E 26I 26    *((LispPTR *)pfreeval) = tos;    return(tos);  }E 26D 26	*((LispPTR *)pfreeval) = tos;	return(tos);}E 26I 13#define FVSTACK		2#define FVGLOBAL	6I 34#ifdef BIGATOMSE 34#define FVIVARHI	0x0I 34#define FVPVARHI	(0x80000000)#define FVFVARHI	(0xC0000000)#else#define FVIVARHI	0x0E 34#define FVPVARHI	0x8000#define FVFVARHI	0xC000I 34#endifE 34#define ENDSTACKMARK	0xbI 29E 29/******************************************************************************nnewframe	This routine is used by fvlookup and OP_stkscan.	1. scan Name table in new function header.	2. if found, set address of searching variable to chain address.	3. return the type of var, on stack, or global. (fs: unused, removed)******************************************************************************/I 29E 29D 18nnewframe(apframe1, achain, name)struct frameex1 *apframe1;	/* pointer to current frame extension */E 18I 18nnewframe(newpfra2, achain, name)D 26register struct frameex1 *newpfra2;	/* pointer to new frame extension */E 18register DLword	*achain;	/* pointer to 1st word of the searchingE 26I 26  register struct frameex1 *newpfra2;	/* pointer to new frame extension */D 27  register DLword	*achain;	/* pointer to 1st word of the searchingE 26				  FVAR slot in CurrentFrameExtension */E 27I 27  register DLword	   *achain;	/* pointer to 1st word of the searching					   FVAR slot in CurrentFrameExtension */E 27D 26register int	name;		/* Atom index num. of target FVAR slot. */{E 26I 26  register int	name;		/* Atom index num. of target FVAR slot. */  {E 26D 18register struct frameex1 *newpfra2;	/* pointer to new frame extension */E 18D 26register DLword	*pindex;	/* index to indexs of new name table */register int i;			/* temp for control */register int nametablesize;	/* NameTable size of current function header. */D 18register int alink;E 18I 18register int ph;		/* alink temp, also phase */E 26I 26D 27    register DLword	*pindex;	/* index to indexs of new name table */    register int i;			/* temp for control */E 27I 27D 34    register DLword *pindex;	/* index to indexs of new name table */E 34I 34    register NAMETABLE *pindex;	/* '90/06/06 osamu changed from DLword *				 * index to indexs of new name table */E 34    register int i;		/* temp for control */E 27    register int nametablesize;	/* NameTable size of current function header. */    register int ph;		/* alink temp, also phase */E 26E 18D 26newframe:E 26I 26    newframe:E 26I 21D 23#ifndef NOASME 23I 23D 25#ifdef SUN3_OS3_ILE 23E 21	asm("_newframe_setup:");	asm("	.globl	_newframe_setup");E 25I 25#ifdef SUN3_OS3_OR_OS4_ILD 26	newframe_setup_label();E 26I 26    newframe_setup_label();E 26E 25I 21#endifE 21D 26	/* assume that apframe1 points to the next frame to be scanned */D 18	alink = apframe1->alink;	if(alink == ENDSTACKMARK){E 18I 18	ph = newpfra2->alink;	if(ph == ENDSTACKMARK){E 26I 26    /* assume that apframe1 points to the next frame to be scanned */    ph = newpfra2->alink;    if(ph == ENDSTACKMARK)      {E 26E 18	/* endStack */I 40#ifdef BIGATOMSE 40I 37D 38	/***Missing if NEW_SYMBOL here... */E 37D 26		if(name & 0x8000){			*(achain+1) = VALS_HI + 1;			*achain = name*2;		}else{			*(achain+1) = VALS_HI;			*achain = name*2;		}		return;	}E 26I 26	if(name >= 0x8000)E 38I 38D 47	if ((name&0xFF0000) != 0)	/* New symbol */E 47I 47	if ((name&SEGMASK) != 0)	/* New symbol */E 47E 38	  {I 38	    register int result = name+NEWATOM_VALUE_OFFSET;	/*    printf("NEW-SYMBOL in nnewframe, 0x%x, result = 0x%x\n", name, result); */D 46	    GETWORD(achain+1) = result>>16;	    GETWORD(achain) = result & 0xFFFF;E 46I 46	    GETBASEWORD(achain,1) = result>>16;	    GETBASEWORD(achain,0) = result & 0xFFFF;E 46	  }D 40	else if(name >= 0x8000)E 40I 40	elseD 47#endif BIGATOMSE 47I 47#endif /* BIGATOMS */#ifdef BIGVM    if (name & SEGMASK)      { /* It's a big-atom, so just offset from the base to get value */		register int result = name + NEWATOM_VALUE_OFFSET;		GETBASEWORD(achain,1) = result>>16;		GETBASEWORD(achain,0) = result & 0xFFFF;      }    else      { /* It's an "old" atom, so offset into the table of atoms */		register int result = (PNP_HI << 16) + (10*name) + NEWATOM_VALUE_OFFSET;		GETBASEWORD(achain,1) = result>>16;		GETBASEWORD(achain,0) = result & 0xFFFF;      }#elseE 47	if(name >= 0x8000)E 40	  {E 38D 46	    GETWORD(achain+1) = VALS_HI + 1;	    GETWORD(achain) = name*2;E 46I 46	    GETBASEWORD(achain,1) = VALS_HI + 1;	    GETBASEWORD(achain,0) = name*2;E 46	  }	else	  {D 46	    GETWORD(achain+1) = VALS_HI;	    GETWORD(achain) = name*2;E 46I 46	    GETBASEWORD(achain,1) = VALS_HI;	    GETBASEWORD(achain,0) = name*2;E 46	  }I 47#endif /* BIGVM */E 47	return;      }E 26D 18 	newpfra2 = (struct frameex1 *)(Stackspace + ((alink & 0xFFFE) - FRAMESIZE));E 18I 18D 26	ph &= 0xFFFE;	newpfra2 = (struct frameex1 *)(-FRAMESIZE + Stackspace + ph);E 26I 26    ph &= 0xFFFE; /* to mask off SLOW bit */    newpfra2 = (struct frameex1 *)(-FRAMESIZE + Stackspace + ph);E 26E 18D 26	{ /* open new block to try and conserve address register */	register struct fnhead *newpfn2;	/* ptr to new fn header */E 26I 26    { /* open new block to try and conserve address register */      register struct fnhead *newpfn2;	/* ptr to new fn header */E 26D 26	if(newpfra2->validnametable)		/* check VALIDNAMETABLE */		newpfn2 = (struct fnhead *)			(Addr68k_from_LADDR(((newpfra2->hi2nametable)<<16 |					      newpfra2->lonametable        )));	else	newpfn2 = (struct fnhead *)			(Addr68k_from_LADDR(((newpfra2->hi2fnheader)<<16 |					      newpfra2->lofnheader         )));E 26I 26      if(newpfra2->validnametable)		/* check VALIDNAMETABLE */I 47#ifdef BIGVME 47	newpfn2 = (struct fnhead *)I 47		   (Addr68k_from_LADDR(newpfra2->nametable));      else	newpfn2 = (struct fnhead *)		    (Addr68k_from_LADDR(newpfra2->fnheader));#else	newpfn2 = (struct fnhead *)E 47		   (Addr68k_from_LADDR(((newpfra2->hi2nametable)<<16 |					 newpfra2->lonametable   )));      else	newpfn2 = (struct fnhead *)		    (Addr68k_from_LADDR(((newpfra2->hi2fnheader)<<16 |D 27					      newpfra2->lofnheader  )));E 27I 27					  newpfra2->lofnheader  )));E 27E 26D 47E 47I 47#endif /* BIGVM */E 47D 26	pindex = (DLword *)newpfn2 + FNHEADSIZE;E 26I 26D 34      pindex = ((DLword *)newpfn2) + FNHEADSIZE;E 34I 34      pindex = (NAMETABLE *)((DLword *)newpfn2 + FNHEADSIZE);E 34E 26		/* now pindex points 1st word of Nametable. */I 34#ifdef BIGATOMS      nametablesize = (newpfn2->ntsize >> 1); /* ntsize is # of words in NT 						 not # of element */#elseE 34D 26	nametablesize = newpfn2->ntsize;	}E 26I 26      nametablesize = newpfn2->ntsize;I 34#endifE 34    }E 26I 21D 23#ifndef NOASME 23I 23D 25#ifdef SUN3_OS3_ILE 23E 21	asm("_newframe_loop:");	asm("	.globl	_newframe_loop");E 25I 25#ifdef SUN3_OS3_OR_OS4_ILD 26	newframe_loop_label();E 26I 26    newframe_loop_label();E 26E 25I 21#endifE 21D 18	for(i=nametablesize; --i >= 0; ++pindex){	/* searching in NewFuncHeader */E 18D 18		if(*((DLword *)pindex) == (DLword)name){E 18I 18D 26	i = (int) (pindex + nametablesize);	for(; i > (int) pindex;){	/* searching in NewFuncHeader */		if(*((DLword *)pindex++) == (DLword)name) {ph=1; goto foundit;}cont2:		if(*((DLword *)pindex++) == (DLword)name) {ph=2; goto foundit;}cont3:		if(*((DLword *)pindex++) == (DLword)name) {ph=3; goto foundit;}cont4:		if(*((DLword *)pindex++) == (DLword)name) {ph=0; goto foundit;}E 26I 26    i = (int) (pindex + nametablesize);D 37    for(; i > (int) pindex;)E 37I 37    for(; (unsigned int)i > (unsigned int) pindex;)E 37      {	/* searching in NewFuncHeader */D 34	if(GETWORD((DLword *)pindex++) == (DLword)name) {ph=1; goto foundit;}cont2:	if(GETWORD((DLword *)pindex++) == (DLword)name) {ph=2; goto foundit;}cont3:	if(GETWORD((DLword *)pindex++) == (DLword)name) {ph=3; goto foundit;}cont4:	if(GETWORD((DLword *)pindex++) == (DLword)name) {ph=0; goto foundit;}E 34I 34#ifdef BIGATOMSD 37	if(GETWORD((NAMETABLE *)pindex++) == (int)name) {ph=1; goto foundit;}cont2:	if(GETWORD((NAMETABLE *)pindex++) == (int)name) {ph=2; goto foundit;}cont3:	if(GETWORD((NAMETABLE *)pindex++) == (int)name) {ph=3; goto foundit;}cont4:	if(GETWORD((NAMETABLE *)pindex++) == (int)name) {ph=0; goto foundit;}E 37I 37	/* These used to be GETWORDs, but NAMETABLE is a CELL in 3-byte */D 44	if((int)*((NAMETABLE *)pindex++) == (int)name) {ph=1; goto foundit;}E 44I 44#if 1		if((int)*((NAMETABLE *)pindex++) == (int)name) {ph=1; goto foundit;}cont2:	if((int)*((NAMETABLE *)pindex++) == (int)name) {ph=0; goto foundit;}#else		if((int)*((NAMETABLE *)pindex++) == (int)name) {ph=1; goto foundit;}E 44cont2:	if((int)*((NAMETABLE *)pindex++) == (int)name) {ph=2; goto foundit;}cont3:	if((int)*((NAMETABLE *)pindex++) == (int)name) {ph=3; goto foundit;}cont4:	if((int)*((NAMETABLE *)pindex++) == (int)name) {ph=0; goto foundit;}I 44D 47#endif ISCE 47I 47#endif /* ISC */E 47E 44E 37#else	if(GETWORD((NAMETABLE *)pindex++) == (DLword)name) {ph=1; goto foundit;}cont2:	if(GETWORD((NAMETABLE *)pindex++) == (DLword)name) {ph=2; goto foundit;}cont3:	if(GETWORD((NAMETABLE *)pindex++) == (DLword)name) {ph=3; goto foundit;}cont4:	if(GETWORD((NAMETABLE *)pindex++) == (DLword)name) {ph=0; goto foundit;}#endifE 34E 26	continue;D 26	foundit:	{E 18			register int	fvartype;   /* probing fvar vartype */			register int	fvaroffset; /* probing fvar varoffset */			register DLword	*ppvar;	/* ptr to probing var candidate */D 18				fvartype = *(pindex + nametablesize);E 18I 18			fvartype = *(-1 + pindex + nametablesize);E 18			fvaroffset = 0xFF & fvartype;			fvaroffset <<= 1;			fvartype &= 0xFF00;				switch( fvartype ){D 14			case FVIVARHI: /* 0x000: */					ppvar = (DLword *)newpfra2 - 1;					/* ppvar points to IVAR field in Basic  frame */				*(achain+1) = STK_HI;				*achain = *ppvar + fvaroffset;				return;E 14			case FVPVARHI: /* 0x8000: */	D 18				ppvar = (DLword *)newpfra2 + fvaroffset + FRAMESIZE;E 18I 18				ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;E 18					/* ppvar points to argued Pvar */				if(((WBITS *)ppvar)->MSB)					/* check UNBOUND (if *ppvar is negative , unbound) */D 18					continue;E 18I 18					switch ( ph ) {					    case 0 : continue;					    case 1 : goto cont2;					    case 2 : goto cont3;					    case 3 : goto cont4;					    }E 18				*(achain+1) = STK_HI;				*achain = 0xFFFF & LADDR_from_68k( ppvar );					/* save High word of PVAR slot address to FVAR slot */					/* achain points to target FVAR slot */				return;			case FVFVARHI: /* 0xC000: */	D 18				ppvar = (DLword *)newpfra2 + fvaroffset + FRAMESIZE;E 18I 18				ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;E 18				if( ((WBITS *)ppvar)->LSB ) goto endlookfor;					/* Not Found in new FuncHeader, scan the next one. */				*((int *)achain) = *((int *)ppvar);					/* save address of frame extension to FVAR slot */					/* achain points to target FVAR slot */I 14				return;			case FVIVARHI: /* 0x000: */	D 18				ppvar = (DLword *)newpfra2 - 1;E 18I 18				ppvar = -1 + (DLword *)newpfra2;E 18					/* ppvar points to IVAR field in Basic  frame */				*(achain+1) = STK_HI;				*achain = *ppvar + fvaroffset;E 14				return;			default:error("Stack corrupted: bad value in name table");			}/* end switch */		}/* end if */	}/* end for */E 26I 26foundit:	{	  register int	fvartype;   /* probing fvar vartype */	  register int	fvaroffset; /* probing fvar varoffset */	  register DLword  *ppvar;	/* ptr to probing var candidate */I 37#ifdef BIGATOMS	  fvartype = (int) *(pindex + nametablesize - 1);#elseE 37	  fvartype = GETWORD(pindex + nametablesize - 1);I 37D 47#endif BIGATOMSE 47I 47#endif /* BIGATOMS */E 47E 37D 34	  fvaroffset = 0xFF & fvartype;E 34I 34	  fvaroffset = NT_OFFSET_MASK & fvartype;E 34	  fvaroffset <<= 1;D 27	  fvartype &= 0xFF00;	E 27I 27D 34	  fvartype &= 0xFF00;E 34I 34	  fvartype &= NT_TYPE_MASK;E 34E 27	  switch( fvartype )	    {D 27	      case FVPVARHI: /* 0x8000: */	E 27I 27D 34	      case FVPVARHI: /* 0x8000: */E 34I 34	      case FVPVARHI: /* 0x8000 or 0x80000000(BIGATOMS) */E 34E 27		     ppvar = FRAMESIZE+(DLword *)newpfra2+fvaroffset;				/* ppvar points to argued Pvar */D 28		    if(((WBITS *)ppvar)->MSB)E 28I 28D 43		    if(WBITSPTR(ppvar)->MSB)E 43I 43		    if(WBITSPTR(ppvar)->xMSB)E 43E 28				/* check UNBOUND (if *ppvar is negative , unbound) */			switch ( ph )			 {			    case 0 : continue;			    case 1 : goto cont2;D 44			    case 2 : goto cont3;			    case 3 : goto cont4;E 44I 44			    /* case 2 : goto cont3;			    case 3 : goto cont4; */E 44			 }D 46		      GETWORD(achain+1) = STK_HI;		      GETWORD(achain) = 0xFFFF & LADDR_from_68k(ppvar);E 46I 46		      GETBASEWORD(achain,1) = STK_HI;		      GETBASEWORD(achain,0) = 0xFFFF & LADDR_from_68k(ppvar);E 46			/* save High word of PVAR slot address to FVAR slot */			/* achain points to target FVAR slot */		      return;D 27		case FVFVARHI: /* 0xC000: */	E 27I 27D 34		case FVFVARHI: /* 0xC000: */E 34I 34		case FVFVARHI: /* 0xC000 or 0xC0000000(BIGATOMS) */E 34E 27		       ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;D 28			if( ((WBITS *)ppvar)->LSB ) goto endlookfor;E 28I 28			if( WBITSPTR(ppvar)->LSB ) goto endlookfor;E 28				/* Not Found in new FnHeader, scan next one. */			*((int *)achain) = *((int *)ppvar);				/* save address of FX to FVAR slot */				/* achain points to target FVAR slot */			return;D 27		case FVIVARHI: /* 0x000: */	E 27I 27		case FVIVARHI: /* 0x000: */E 27			ppvar = -1 + (DLword *)newpfra2;				/* ppvar points to IVAR field in Basic  frame */D 46			GETWORD(achain+1) = STK_HI;			GETWORD(achain) = GETWORD(ppvar) + fvaroffset;E 46I 46			GETBASEWORD(achain,1) = STK_HI;			GETBASEWORD(achain,0) = GETWORD(ppvar) + fvaroffset;E 46			return;		default:error("Stack corrupted: bad value in name table");	      }/* end switch */	    }/* end if */	  }/* end for */E 26endlookfor:D 18	apframe1 = newpfra2;	/* set next new FuncHeader */E 18D 26	goto newframe;		/* scan the next one */E 26I 26    goto newframe;		/* scan the next one */E 26D 26}E 26I 26  }I 38#ifndef BIGATOMSE 38E 26I 21D 23#ifdef NOASM#define VALS_HI_RET(x)	\	((int) x << 17) + VALS_HI + ((unsigned short) x >> 15)#define STK_HI_RET(x)	\	((int) x << 16) | 1 | ((unsigned int) x >> 16)#else#ifdef mc68020E 23I 23D 25#ifdef SUN3_OS3_ILE 25I 25#ifdef SUN3_OS3_OR_OS4_ILE 25E 23#define VALS_HI_RET(x)		newframe_vals_hi_ret(x)#define STK_HI_RET(x)		newframe_stk_hi_ret(x)I 23E 23#elseI 23E 23#define VALS_HI_RET(x)	\D 38	((int) x << 17) + VALS_HI + ((unsigned short) x >> 15)E 38I 38	((int) x << 17) + VALS_HI + ((unsigned short) x >> 15)	E 38#define STK_HI_RET(x)	\	((int) x << 16) | 1 | ((unsigned int) x >> 16)I 23E 23D 38#endifE 38I 38D 47#endif SUN3_ILE 47I 47#endif /* SUN3_IL */E 47#elseE 38I 29I 38D 47#define VALS_HI_RET(x)	((((int) x & 0xFF0000) == 0) ?			\E 47I 47#ifdef BIGVM#define VALS_HI_RET(x)	((((int) x & SEGMASK) == 0) ?			\	(swapx((PNP_HI<<16) + (10 * (int) (x)) + NEWATOM_VALUE_OFFSET)) :	\	(swapx((int)x + NEWATOM_VALUE_OFFSET)))#else#define VALS_HI_RET(x)	((((int) x & SEGMASK) == 0) ?			\E 47	(((int) x << 17) + VALS_HI + ((unsigned short) x >> 15)) :	\	(swapx((int)x + NEWATOM_VALUE_OFFSET)))I 47#endif /* BIGVM */E 47E 38I 38#define STK_HI_RET(x)	((int) x << 16) | 1 | ((unsigned int) x >> 16) E 38E 29D 23#endifE 23E 21E 13I 38D 47#endif BIGATOMSE 47I 47#endif /* BIGATOMS */E 47E 38I 21I 38I 47E 47E 38E 21I 15D 18E 18I 18D 19#ifdef NEWSTUFFE 19E 18/******************************************************************************native_newframeD 23	This routine is used by native code.E 23	1. scan Name table in new function header.	2. if found, set address of searching variable to chain address.	3. return the pointer******************************************************************************/native_newframe(slot)D 38int	slot;			/* index of FVAR slot. */{register struct frameex2 *newpfra2;	/* pointer to new frame extension */register DLword	*achain;	/* pointer to 1st word of the searchingD 27				  FVAR slot in CurrentFrameExtension */E 27I 27				   FVAR slot in CurrentFrameExtension */E 27register int	name;		/* Atom index num. of target FVAR slot. */E 38I 38  int	slot;			/* index of FVAR slot. */  {    register struct frameex2 *newpfra2;	/* pointer to new frame extension */    register DLword	*achain;	/* pointer to 1st word of the searching				  	 FVAR slot in CurrentFrameExtension */    register int	name;		/* Atom# of target FVAR slot. */E 38D 38{					/* LOCAL temp regs */E 38I 38      {					/* LOCAL temp regs */E 38	register int rslot = slot;	register struct fnhead *fnobj = FuncObj;	register LispPTR *pvar = (LispPTR *) PVar;I 34#ifdef BIGATOMSD 37	name = GETWORD((LispPTR *)E 37I 37	name = (int) *((LispPTR *)E 37		       ((DLword *)fnobj + fnobj->fvaroffset)			+ rslot - fnobj->nlocals);#elseE 34D 26	name = *((DLword *)fnobj + 	E 26I 26D 27	name = GETWORD((DLword *)fnobj + 	E 26		 (fnobj->fvaroffset + rslot - fnobj->nlocals));	E 27I 27	name = GETWORD((DLword *)fnobj +		 (fnobj->fvaroffset + rslot - fnobj->nlocals));I 34#endifE 34E 27	newpfra2 = (struct frameex2 *) ((DLword *) pvar - FRAMESIZE);	achain = (DLword *) (pvar + rslot);D 38}E 38I 38      }E 38D 38{D 34register DLword	*pindex;	/* index to indexs of new name table */E 34I 34register NAMETABLE *pindex;	/* index to indexs of new name table */E 34register int i;			/* temp for control */register int nametablesize;	/* NameTable size of current function header. */register int alink;E 38I 38      {	register NAMETABLE *pindex;	/* index to indexs of new name table */	register int i;			/* temp for control */	register int nametablesize;	/* NameTable size of current fnhdr */	register int alink;E 38D 19newframe:E 19I 19natnewframe:E 19I 17D 23#ifndef NOASME 23I 23D 25#ifdef SUN3_OS3_ILE 23D 19	asm("newframe:");E 19I 19	asm("natnewframe:");E 25I 25#ifdef SUN3_OS3_OR_OS4_IL	natnewframe_label();E 25E 19#endifE 17	/* assume that apframe1 points to the next frame to be scanned */	alink = newpfra2->alink;D 38	if(alink == ENDSTACKMARK){	/* endStack */D 21		/*****		if(name & 0x8000){			*(achain+1) = VALS_HI + 1;			*achain = name*2;		}else{			*(achain+1) = VALS_HI;			*achain = name*2;		}		******* */		return(*((LispPTR *)achain) = newframe_vals_hi_ret(name));E 21I 21		return(*((LispPTR *)achain) = VALS_HI_RET(name));E 21	}E 38I 38	if(alink == ENDSTACKMARK)	  { /* End of stack, so return top-level-value */D 47/*	    printf("native_newframe returning name 0x%x, result 0x%x.\n",			name, VALS_HI_RET(name)); */E 47I 47/*	    if (name & SEGMASK) printf("native_newframe returning name 0x%x, result 0x%x.\n",			name, VALS_HI_RET(name)); */ E 47	    return(*((LispPTR *)achain) = VALS_HI_RET(name));	  }E 38D 16	alink &= 0xFFFE; 	newpfra2 = (struct frameex2 *)(-FRAMESIZE + Stackspace + alink);E 16I 16	newpfra2 = (struct frameex2 *)(-FRAMESIZE + Stackspace + (alink & 0xFFFE));E 16D 38	{ /* open new block to try and conserve address register */	register struct fnhead *newpfn2;	/* ptr to new fn header */E 38I 38	  { /* open new block to try and conserve address register */	    register struct fnhead *newpfn2;	/* ptr to new fn header */E 38D 16	if(newpfra2->validnametable)		/* check VALIDNAMETABLE */		newpfn2 = (struct fnhead *)			Addr68k_from_LADDR(swapx(newpfra2->nametable));	else	newpfn2 = (struct fnhead *)			Addr68k_from_LADDR(swapx(newpfra2->fnheader));E 16I 16D 20	newpfn2 = (struct fnhead *) Addr68k_from_LADDR(swapx(			((newpfra2->validnametable)			? newpfra2->nametable			: newpfra2->fnheaderD 17			)));E 17I 17			)) & 0x00ffffff);E 20I 20D 38	newpfn2 = GETNAMETABLE(newpfra2);E 38I 38	    newpfn2 = GETNAMETABLE(newpfra2);E 38E 20E 17E 16D 26	pindex = (DLword *)newpfn2 + FNHEADSIZE;E 26I 26D 34	pindex = ((DLword *)newpfn2) + FNHEADSIZE;E 34I 34D 38	pindex = (NAMETABLE *)(((DLword *)newpfn2) + FNHEADSIZE);E 38I 38	    pindex = (NAMETABLE *)(((DLword *)newpfn2) + FNHEADSIZE);E 38E 34E 26		/* now pindex points 1st word of Nametable. */I 34#ifdef BIGATOMSD 38	nametablesize = (newpfn2->ntsize >> 1); /* ntsize is # of words in NTE 38I 38	    nametablesize = (newpfn2->ntsize >> 1); /* ntsize is # of words in NTE 38						   nametablesize is # of items in NT */#elseE 34D 38	nametablesize = newpfn2->ntsize;E 38I 38	    nametablesize = newpfn2->ntsize;E 38I 34D 47#endif						   E 47I 47#endif /* 					    */E 47E 34D 38	}E 38I 38	  }E 38I 21D 23#ifdef sparcE 23I 23#ifdef SUN4_OS4_ILE 23D 27/**/	i =  (int) (pindex + nametablesize);E 27I 27	i =  (int) (pindex + nametablesize);E 27lookup:I 34#ifdef BIGATOMS	pindex = (LispPTR *) name_scan2((int)pindex, i, name);#elseE 34D 27	pindex = (DLword *) name_scan((int)pindex, i, name | (name<<16)); /**/E 27I 27	pindex = (DLword *) name_scan((int)pindex, i, name | (name<<16));E 27D 34	if (!pindex) goto natnewframe;E 34I 34#endif      	if (!pindex) goto natnewframe;E 34D 38{{E 38I 38      {	  {E 38#elseE 21I 17D 23#ifdef NOASME 23I 23D 25#ifdef SUN3_OS3_ILE 25I 25#ifdef SUN3_OS3_OR_OS4_ILE 25E 23E 17D 16	for(i=nametablesize; --i >= 0; ++pindex){	/* searching in NewFuncHeader */E 16I 16D 23	for(i=nametablesize; --i >= 0;){						/* searching in NewFuncHeader */E 16D 16		if(*((DLword *)pindex) == (DLword)name){E 16I 16		if(*((DLword *)pindex++) == (DLword)name){I 17#else#ifdef mc68020E 23	i = nametablesize;I 21	if (--i < 0) goto natnewframe;E 21D 27	/* **** assumes: E 27I 27	/* **** assumes:E 27		d7 = name		d6 = i		a3 = pindexD 27	*** */ E 27I 27	*** */I 34#ifdef BIGATOMSlookup:	fvar_lookup_loop2();#elseE 34E 27D 25lookup:	asm("lookup: 	cmpw a3@+,d7");	asm("		dbeq d6,lookup");D 19	asm("		bne newframe");E 19I 19	asm("		bne natnewframe");E 25I 25lookup:	fvar_lookup_loop();I 34#endifE 34E 25E 19D 27{	E 27{I 27{E 27I 23#elseD 27	for(i=nametablesize; --i >= 0;){	E 27I 27	for(i=nametablesize; --i >= 0;){E 27					/* searching in NewFuncHeader */D 28E 28D 26		if(*((DLword *)pindex++) == (DLword)name){E 26I 26D 34		if(GETWORD((DLword *)pindex++) == (DLword)name){E 26E 34I 34#ifdef BIGATOMSD 37		if(GETWORD((NAMETABLE *)pindex++) == (LispPTR)name){E 37I 37		if((LispPTR) *((NAMETABLE *)pindex++) == (LispPTR)name){E 37#else		if(GETWORD((NAMETABLE *)pindex++) == (DLword)name){D 47#endif BIGATOMS   E 47I 47#endif /* BIGATOMS    */E 47E 34E 23D 21#else#ifdef sparc	for(i=nametablesize; --i >= 0;){						/* searching in NewFuncHeader */		if(*((DLword *)pindex++) == (DLword)name){E 21#endif#endifD 23#endifE 23I 27		    register int     fvartype;   /* probing fvar vartype */		    register int     fvaroffset; /* probing fvar varoffset */		    register DLword *ppvar; /* ptr to probing var candidate */I 37#ifdef BIGATOMS		    fvartype = (int) *(pindex + nametablesize - 1);#elseE 37E 27D 28E 28E 17E 16D 27			register int	fvartype;   /* probing fvar vartype */			register int	fvaroffset; /* probing fvar varoffset */			register DLword	*ppvar;	/* ptr to probing var candidate */	D 16			fvartype = *(pindex + nametablesize);			fvaroffset = 0xFF & fvartype;			fvaroffset <<= 1;			fvartype &= 0xFF00;				switch( fvartype ){			case FVPVARHI: /* 0x8000: */	E 16I 16D 26			fvartype = *(-1 + pindex + nametablesize);E 26I 26			fvartype = GETWORD(pindex + nametablesize - 1);E 26			fvaroffset = (0xFF & fvartype) << 1;D 17			switch( fvartype >> 8 ){			case (FVPVARHI >> 8): /* 0x8000: */	E 17I 17			switch( fvartype >> 14 ){			case (FVPVARHI >> 14): /* 0x8000: */	E 17E 16				ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;E 27I 27		    fvartype = GETWORD(pindex + nametablesize - 1);I 37D 47#endif BIGATOMSE 47I 47#endif /* BIGATOMS */E 47E 37D 34		    fvaroffset = (0xFF & fvartype) << 1;		    switch( fvartype >> 14 ){			case (FVPVARHI >> 14): /* 0x8000: */E 34I 34		    fvaroffset = (NT_OFFSET_MASK & fvartype) << 1;		    fvartype &= NT_TYPE_MASK;		    switch( fvartype ){			case FVPVARHI: /* 0x8000 or 0x80000000(NEWATOM): */E 34			    ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;E 27					/* ppvar points to argued Pvar */D 27				if(((WBITS *)ppvar)->MSB)					/* check UNBOUND (if *ppvar is negative , unbound) */E 27I 27D 28			    if(((WBITS *)ppvar)->MSB)E 28I 28D 43			    if(WBITSPTR(ppvar)->MSB)E 43I 43			    if(WBITSPTR(ppvar)->xMSB)E 43E 28			/* check UNBOUND (if *ppvar is negative , unbound) */E 27I 21D 23#ifdef sparcE 23I 23#ifdef SUN4_OS4_ILE 23D 27					goto lookup;E 27I 27				    goto lookup;E 27#elseE 21I 17D 23#ifdef NOASME 17					continue;I 17#else#ifdef mc68020E 23I 23D 25#ifdef SUN3_OS3_ILE 25I 25#ifdef SUN3_OS3_OR_OS4_ILE 25E 23D 27					goto lookup;E 27I 27				    goto lookup;E 27D 21#else#ifdef sparc					continue;E 21D 23#endifE 23I 23#elseD 27					continue;E 27I 27D 28				    continue;E 28I 28				    {				      continue;				    }E 28E 27E 23#endif#endifE 17D 21/* ******				*(achain+1) = STK_HI;				*achain = 0xFFFF & LADDR_from_68k( ppvar );***** */E 21D 27					/* save High word of PVAR slot address to FVAR slot */					/* achain points to target FVAR slot */				return(*((LispPTR *)achain) = D 21					newframe_stk_hi_ret(E 21I 21					STK_HI_RET(E 21						LADDR_from_68k( ppvar )));D 16			case FVFVARHI: /* 0xC000: */	E 16I 16D 17			case (FVFVARHI >> 8): /* 0xC000: */	E 17I 17			case (FVFVARHI >> 14): /* 0xC000: */	E 17E 16				ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;				if( ((WBITS *)ppvar)->LSB ) goto endlookfor;					/* Not Found in new FuncHeader, scan the next one. */D 21/* **				*((int *)achain) = *((int *)ppvar);*** */E 21					/* save address of frame extension to FVAR slot */					/* achain points to target FVAR slot */				return(*((int *)achain) = *((int *)ppvar));D 16			case FVIVARHI: /* 0x000: */	E 16I 16D 17			case (FVIVARHI >> 8): /* 0x000: */	E 17I 17			case (FVIVARHI >> 14): /* 0x000: */	E 17E 16				ppvar = (DLword *)newpfra2 - 1;					/* ppvar points to IVAR field in Basic  frame */D 21/* ****				*(achain+1) = STK_HI;				*achain = *ppvar + fvaroffset;*** */E 21				return(*((LispPTR *)achain) = D 21					newframe_stk_hi_ret(*ppvar+fvaroffset));;E 21I 21					STK_HI_RET(*ppvar+fvaroffset));;E 27I 27			/* save High word of PVAR slot address to FVAR slot */			/* achain points to target FVAR slot */			     return(*((LispPTR *)achain) =				    STK_HI_RET( LADDR_from_68k( ppvar )));D 34			case (FVFVARHI >> 14): /* 0xC000: */E 34I 34			case FVFVARHI: /* 0xC000 or 0xC0000000(NEWATOM S) */E 34			    ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;D 28			    if( ((WBITS *)ppvar)->LSB ) goto endlookfor;E 28I 28			    if( WBITSPTR(ppvar)->LSB )			      {			        goto endlookfor;			      }E 28			    /* Not Found in new FuncHeader, scan next one. */			    /* save address of frame extension to FVAR slot */			    /* achain points to target FVAR slot */			    return(*((int *)achain) = *((int *)ppvar));D 34			case (FVIVARHI >> 14): /* 0x000: */E 34I 34			case FVIVARHI: /* 0x0000000: */E 34			    ppvar = (DLword *)newpfra2 - 1;			    /* ppvar points to IVAR field in Basic frame */			    return(*((LispPTR *)achain) =D 28				    STK_HI_RET(*ppvar+fvaroffset));;E 28I 28				    STK_HI_RET(GETWORD(ppvar)+fvaroffset));;E 28E 27E 21			default:error("Stack corrupted: bad value in name table");D 18			}/* end switch */		}/* end if */	}/* end for */E 18D 19endlookfor:	goto newframe;		/* scan the next one */E 19I 19			}/* end switch */		}/* end if */	}/* end for */E 19I 19endlookfor:	goto natnewframe;		/* scan the next one */E 19}D 18}E 18I 18D 19#endifE 19I 19}E 19E 18E 15I 7D 8#endifE 8E 7E 4E 1