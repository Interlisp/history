h44281s 00255/00240/00193d D 1.5 93/02/08 14:49:18 sybalsky 5 4c Big VM (and new CDR coding) changes for 3.0 \nes 00013/00001/00420d D 1.4 92/07/24 10:45:41 sybalsky 4 3c retrofit of SGI & DEC OSF1 changes \nes 00005/00000/00416d D 1.3 92/05/29 10:42:55 sybalsky 3 2c Add inline byte swapper for GCC386 machineses 00001/00003/00415d D 1.2 92/04/22 13:50:10 sybalsky 2 1c fix SCCS headeres 00418/00000/00000d D 1.1 92/04/21 15:28:22 sybalsky 1 0c date and time created 92/04/21 15:28:22 by sybalskyeuUf e 0tTI 1D 5/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 5I 5/* @(#) chardev.c Version 1.2 (4/22/92). copyright venue & Fuji Xerox  */static char *id = "@(#) chardev.c       1.2 4/22/92     (venue & Fuji Xerox)";E 5D 2/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 2/************************************************************************/D 5/*									*/D 2/*	Copyright 1989, 1990, 1991 Venue.  All Rights Reserved.		*/E 2I 2D 4/*	Copyright 1989, 1990, 1991, 1992 Venue.  All Rights Reserved.		*/E 4I 4/*	Copyright 1989, 1990, 1991, 1992 Venue.  All Rights Reserved.	*/E 4E 2/*									*//*	This file was work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*/E 5I 5/*                                                                      *//*      Copyright 1989, 1990, 1991, 1992 Venue.  All Rights Reserved.           *//*                                                                      *//*      This file was work-product resulting from the Xerox/Venue       *//*      Agreement dated 18-August-1989 for support of Medley.           *//*      Manufactured in the United States of America.                   *//*                                                                      *//*      The contents of this file are proprietary information           *//*      belonging to Venue, and are provided to you under license.      *//*      They may not be further distributed or disclosed to third       *//*      parties without the specific permission of Venue.               *//*                                                                      */E 5/************************************************************************//************************************************************************/D 5/*									*//*	      C H A R A C T E R - D E V I C E   S U P P O R T		*//*									*//*									*//*									*/E 5I 5/*                                                                      *//*            C H A R A C T E R - D E V I C E   S U P P O R T           *//*                                                                      *//*                                                                      *//*                                                                      */E 5/************************************************************************/D 5#include	<stdio.h>#include	<sys/types.h>I 4#ifndef APOLLOE 4#include	<sys/file.h>I 4#endif /* APOLLO */E 4#include	<sys/stat.h>#include	<sys/param.h>I 4#ifdef APOLLO#include	<sys/times.h>#elif DOS#include	<time.h>#elseE 4#include	<sys/time.h>I 4#endif /* APOLLO ... DOS */E 4#include	<sys/dir.h>I 4#ifdef APOLLO#include	<string.h>#elseE 5I 5#ifndef DOS#include <stdio.h>#include        <sys/types.h>#include        <sys/file.h>#include        <sys/stat.h>#include        <sys/param.h>#include        <sys/time.h>#include        <sys/dir.h>E 5E 4#ifndef HPUXD 5#include	<strings.h>#endif HPUXI 4#endif /* APOLLO */E 4#include 	<setjmp.h>#include	<signal.h>#include	<errno.h>#include	<fcntl.h>#include	<sys/ioctl.h>#include	"lispemul.h"#include	"lispmap.h"#include	"adr68k.h"#include	"lsptypes.h"#include	"arith.h"#include	"timeout.h"#include	"locfile.h"#include	"osmsg.h"#include	"dbprint.h"E 5I 5#include        <strings.h>#endif /* HPUX */#include        <sys/ioctl.h>#else /* DOS */#include <string.h>#endif /* DOS */E 5I 5#include        <setjmp.h>#include        <signal.h>#include        <errno.h>#include        <fcntl.h>E 5I 5#include "lispemul.h"#include        "lispmap.h"#include        "adr68k.h"#include        "lsptypes.h"#include        "arith.h"#include        "timeout.h"#include        "locfile.h"#include        "osmsg.h"#include        "dbprint.h"E 5#ifdef ISCD 5#include	<dirent.h>E 5I 5#include        <dirent.h>E 5#endifI 3D 5#ifdef GCC386#include "inlnPS2.h"#endif	/* GCC386 */E 5I 5extern  int*    Lisp_errno;extern  int     Dummy_errno;E 5E 3D 5extern	int*	Lisp_errno;extern	int	Dummy_errno;E 5D 5E 5/************************************************************************/D 5/*									*//*			  C H A R _ o p e n f i l e			*//*									*//*	Given the arg vector						*//*		args[0] Lisp string full Unix file-name to open		*//*		args[1] Access to open it for (INPUT, OUTPUT, BOTH)	*//*		args[2] a FIXP cell to hold any Unix error number	*//*									*//*	Open the file named, and return the SMALLP descriptor.  If	*//*	the open fails, return NIL, and put the Unix error number	*//*	into the FIXP cell provided, for Lisp to look at.		*//*									*/E 5I 5/*                                                                      *//*                        C H A R _ o p e n f i l e                     *//*                                                                      *//*      Given the arg vector                                            *//*              args[0] Lisp string full Unix file-name to open                 *//*              args[1] Access to open it for (INPUT, OUTPUT, BOTH)     *//*              args[2] a FIXP cell to hold any Unix error number       *//*                                                                      *//*      Open the file named, and return the SMALLP descriptor.  If      *//*      the open fails, return NIL, and put the Unix error number       *//*      into the FIXP cell provided, for Lisp to look at.               *//*                                                                      */E 5/************************************************************************/CHAR_openfile(args)D 5  register LispPTR	*args;  /* args[0]		fullname */  /* args[1]		access */  /* args[2]		errno */E 5I 5  register LispPTR      *args;  /* args[0]            fullname */  /* args[1]            access */  /* args[2]            errno */E 5  {D 5    register int	id;	/* return value  of open system call. */    register int	flags;	/* open system call's argument */    register int	rval;    register int	linkflag =0;    register int	*bufp;    struct stat	statbuf;    char	pathname[MAXPATHLEN];E 5I 5#ifndef DOS    register int id;            /* return value  of open system call. */    register int        flags;  /* open system call's argument */    register int        rval;    register int        linkflag =0;    register int        *bufp;    struct stat statbuf;    char        pathname[MAXPATHLEN];E 5#if (defined(RS6000) || defined(HPUX))D 5    static int one=1;		/* Used in charopenfile, etc. */E 5I 5    static int one=1;           /* Used in charopenfile, etc. */E 5#endifD 5    Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));	E 5I 5    Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));  E 5    LispStringToCString(args[0], pathname, MAXPATHLEN);    flags = O_NDELAY;    ERRSETJMP(NIL);/*    TIMEOUT( rval=stat(pathname, &statbuf) );D 5    if(rval == 0){	} */E 5I 5    if(rval == 0){      } */E 5    switch(args[1])      {D 5	case	ACCESS_INPUT:			flags |= O_RDONLY;			break;	case	ACCESS_OUTPUT:			flags |= (O_WRONLY | O_CREAT);			break;	case	ACCESS_APPEND:			flags |= (O_APPEND | O_RDWR | O_CREAT);			break;	case	ACCESS_BOTH:			flags |= (O_RDWR | O_CREAT);			break;	default:			return(NIL);E 5I 5        case    ACCESS_INPUT:                        flags |= O_RDONLY;                        break;        case    ACCESS_OUTPUT:                        flags |= (O_WRONLY | O_CREAT);                        break;        case    ACCESS_APPEND:                        flags |= (O_APPEND | O_RDWR | O_CREAT);                        break;        case    ACCESS_BOTH:                        flags |= (O_RDWR | O_CREAT);                        break;        default:                        return(NIL);E 5      }    TIMEOUT( id=open(pathname, flags) );    if(id == -1)      {D 5	err_mess("open", errno);	*Lisp_errno = errno;	return(NIL);E 5I 5        err_mess("open", errno);        *Lisp_errno = errno;        return(NIL);E 5      }    /* Prevent I/O requests from blocking -- make them error */    /* if no char is available, or there's no room in pipe.  */#ifdef RS6000    ioctl(id, FIONBIO, &one);    fcntl(id, F_SETOWN, getpid());#else#ifdef HPUX    ioctl(id, FIOSNBIO, &one);#else    rval = fcntl(id, F_GETFL, 0);    rval |= FNDELAY;    rval = fcntl(id, F_SETFL, rval);D 5#endif HPUX#endif RS6000E 5I 5#endif /* HPUX */#endif /* RS6000 */E 5    return(GetSmallp(id));I 5#endif /* DOS */E 5  }/************************************************************************/D 5/*									*//*			C H A R _ c l o s e f i l e			*//*									*//*	Given the arg vector:						*//*		args[0] The SMALLP file descriptor as returned by OPEN	*//*		args[1] a FIXP cell to hold any Unix error number	*//*									*//*	Close the file identified by the descriptor.  If the 		*//*	close succeeds, return T.  Otherwise, return NIL, and put	*//*	the Unix error number in the FIXP cell, for Lisp to see.	*//*									*/E 5I 5/*                                                                      *//*                      C H A R _ c l o s e f i l e                     *//*                                                                      *//*      Given the arg vector:                                           *//*              args[0] The SMALLP file descriptor as returned by OPEN  *//*              args[1] a FIXP cell to hold any Unix error number       *//*                                                                      *//*      Close the file identified by the descriptor.  If the            *//*      close succeeds, return T.  Otherwise, return NIL, and put       *//*      the Unix error number in the FIXP cell, for Lisp to see.        *//*                                                                      */E 5/************************************************************************/CHAR_closefile(args)D 5  register LispPTR	*args;  /* args[0]		id	*/  /* args[1]		errno	*/E 5I 5  register LispPTR      *args;  /* args[0]            id      */  /* args[1]            errno   */E 5  {D 5    register int	id;	/* FileID */    register int	rval;    char	pathname[MAXPATHLEN];    Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));	E 5I 5#ifndef DOS    register int        id;     /* FileID */    register int        rval;    char        pathname[MAXPATHLEN];    Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));  E 5    id = LispNumToCInt(args[0]);    ERRSETJMP(NIL);    TIMEOUT( rval=close(id) );    if( rval == -1)      {D 5	/** This if is a patch for an apparent problem **/	/** in SunOS 4 that causes a close on /dev/ttya **/	/** to error with 'not owner' **/	if (errno == 1)	  {	    DBPRINT(("Got errno 1 on a CLOSE!"));	    return(ATOM_T);	  }	DBPRINT(("Closing char device descriptor #%d.\n", id));	err_mess("close", errno);	*Lisp_errno = errno;	return(NIL);E 5I 5        /** This if is a patch for an apparent problem **/        /** in SunOS 4 that causes a close on /dev/ttya **/        /** to error with 'not owner' **/        if (errno == 1)          {            DBPRINT(("Got errno 1 on a CLOSE!"));            return(ATOM_T);          }        DBPRINT(("Closing char device descriptor #%d.\n", id));        err_mess("close", errno);        *Lisp_errno = errno;        return(NIL);E 5      }    return(ATOM_T);I 5#endif /* DOS */E 5  }/************************************************************************/D 5/*									*//*			    C H A R _ i o c t l				*//*									*//*	Given the arg vector:						*//*		args[0] the file descriptor to be acted on.		*//*		args[1] the IOCTL request code.				*//*		args[2] auxiliary data structure passed to IOCTL	*//*		args[3] a FIXP cell to contain any Unix error number	*//*									*//*	Perform the IOCTL system call on the given file descriptor,	*//*	passing in the request code and auxiliary structure given.	*//*	If the IOCTL succeeds, return T (and the aux structure may	*//*	be side-effected).  Otherwise, return NIL, and put the Unix	*//*	error number in the FIXP cell for Lisp to look at.		*//*									*/E 5I 5/*                                                                      *//*                          C H A R _ i o c t l                                 *//*                                                                      *//*      Given the arg vector:                                           *//*              args[0] the file descriptor to be acted on.             *//*              args[1] the IOCTL request code.                                 *//*              args[2] auxiliary data structure passed to IOCTL        *//*              args[3] a FIXP cell to contain any Unix error number    *//*                                                                      *//*      Perform the IOCTL system call on the given file descriptor,     *//*      passing in the request code and auxiliary structure given.      *//*      If the IOCTL succeeds, return T (and the aux structure may      *//*      be side-effected).  Otherwise, return NIL, and put the Unix     *//*      error number in the FIXP cell for Lisp to look at.              *//*                                                                      */E 5/************************************************************************/CHAR_ioctl(args)  LispPTR *args;  {I 5#ifndef DOSE 5    int id, request, data;D 5    register int	rval;    char	*base;E 5I 5    register int        rval;    char        *base;E 5    struct stat sbuf;D 5    Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	E 5I 5    Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));  E 5    id = LispNumToCInt(args[0]);    request = LispNumToCInt(args[1]);D 5    data = (int)(Addr68k_from_LADDR(args[2]));	E 5I 5    data = (int)(Addr68k_from_LADDR(args[2]));  E 5    ERRSETJMP(NIL);    TIMEOUT(rval=ioctl(id, request, data));    if(rval != 0)      {D 5	err_mess("ioctl", errno);	*Lisp_errno = errno;	return(NIL);E 5I 5        err_mess("ioctl", errno);        *Lisp_errno = errno;        return(NIL);E 5      }    return(ATOM_T);I 5#endif /* DOS */E 5}/************************************************************************/D 5/*									*//*			   C H A R _ b i n				*//*									*//*	Reads one character from the character file descriptor		*//*	id, and returns the value.  If no character is available,	*//*	or an error happens, returns NIL and sets the errno FIXP	*//*	cell to the Unix error number.					*//*									*/E 5I 5/*                                                                      *//*                         C H A R _ b i n                              *//*                                                                      *//*      Reads one character from the character file descriptor          *//*      id, and returns the value.  If no character is available,       *//*      or an error happens, returns NIL and sets the errno FIXP        *//*      cell to the Unix error number.                                  *//*                                                                      */E 5/************************************************************************/CHAR_bin(id, errn)D 5  register int	id;  register LispPTR	errn;E 5I 5  register int  id;  register LispPTR      errn;E 5  {D 5    register int	rval, size;E 5I 5#ifndef DOS    register int rval, size;E 5    unsigned char ch[4];    Lisp_errno = (int *)(Addr68k_from_LADDR(errn));    ERRSETJMP(NIL);    id = LispNumToCInt(id);    /* Read PAGE_SIZE bytes file contents from filepointer. */    TIMEOUT( rval=read(id, ch, 1) );    if ( rval == 0 )      {D 5	*Lisp_errno = EWOULDBLOCK;	return(NIL);E 5I 5        *Lisp_errno = EWOULDBLOCK;        return(NIL);E 5      }    if ( rval == -1 )      {D 5	*Lisp_errno = errno;	return(NIL);E 5I 5        *Lisp_errno = errno;        return(NIL);E 5      }    return(GetSmallp(ch[0]));I 5#endif /* DOS */E 5  }/************************************************************************/D 5/*									*//*			    C H A R _ b o u t				*//*									*//*	Write character ch to the character file descriptor id.  If	*//*	the write works, return T; else return NIL and sets the FIXP	*//*	cell at errno to contain the Unix error number.			*//*									*/E 5I 5/*                                                                      *//*                          C H A R _ b o u t                           *//*                                                                      *//*      Write character ch to the character file descriptor id.  If     *//*      the write works, return T; else return NIL and sets the FIXP    *//*      cell at errno to contain the Unix error number.                         *//*                                                                      */E 5/************************************************************************/CHAR_bout(id, ch, errn)D 5  register int	id;  register LispPTR	ch, errn;E 5I 5  register int  id;  register LispPTR      ch, errn;E 5  {D 5    register int	rval;E 5I 5#ifndef DOS    register int rval;E 5    char buf[4];    Lisp_errno = (int *)(Addr68k_from_LADDR(errn));    ERRSETJMP(NIL);    id = LispNumToCInt(id);    buf[0] = LispNumToCInt(ch);    /* Write PAGE_SIZE bytes file contents from filepointer. */    TIMEOUT( rval=write(id, buf, 1) );    if (rval == -1)      {D 5	*Lisp_errno = errno;	return(NIL);E 5I 5        *Lisp_errno = errno;        return(NIL);E 5      }    if (rval == 0)      {D 5	*Lisp_errno = EWOULDBLOCK;	return(NIL);E 5I 5        *Lisp_errno = EWOULDBLOCK;        return(NIL);E 5      }    return(ATOM_T);I 5#endif /* DOS */E 5  }/************************************************************************/D 5/*									*//*			   C H A R _ b i n s				*//*									*//*	Given the argument vector:					*//*	args[0] the file id to read bytes from				*//*	args[1] the base address of the buffer to read into		*//*	args[2] starting offset within the buffer to put bytes at	*//*	args[3] the number of bytes desired to read, maximum		*//*	args[4] a FIXP cell to hold the errno, if an error occurs	*//*									*//*	Read up to the specified number of bytes into the buffer,	*//*	starting at the offset given.  Return the number of bytes	*//*	actually read; will return if fewer bytes than desired are	*//*	read.  If an error occurs in reading, return NIL, and put	*//*	the Unix errno into the FIXP cell given.  EWOULDBLOCK is an	*//*	error that can occur--and bins returns NIL, so Lisp code has	*//*	to handle that case itself.					*//*									*/E 5I 5/*                                                                      *//*                         C H A R _ b i n s                            *//*                                                                      *//*      Given the argument vector:                                      *//*      args[0] the file id to read bytes from                          *//*      args[1] the base address of the buffer to read into             *//*      args[2] starting offset within the buffer to put bytes at       *//*      args[3] the number of bytes desired to read, maximum            *//*      args[4] a FIXP cell to hold the errno, if an error occurs       *//*                                                                      *//*      Read up to the specified number of bytes into the buffer,       *//*      starting at the offset given.  Return the number of bytes       *//*      actually read; will return if fewer bytes than desired are      *//*      read.  If an error occurs in reading, return NIL, and put       *//*      the Unix errno into the FIXP cell given.  EWOULDBLOCK is an     *//*      error that can occur--and bins returns NIL, so Lisp code has    *//*      to handle that case itself.                                     *//*                                                                      */E 5/************************************************************************/CHAR_bins(args)D 5  register LispPTR	*args;E 5I 5  register LispPTR      *args;E 5  {D 5    register int	id, rval;    char	*buffer;E 5I 5#ifndef DOS    register int id, rval;    char        *buffer;E 5    int offset, nbytes;    Lisp_errno = (int *)(Addr68k_from_LADDR(args[4]));    ERRSETJMP(NIL);    id = LispNumToCInt(args[0]);    buffer = ((char *) (Addr68k_from_LADDR(args[1]))) + LispNumToCInt(args[2]);    nbytes = LispNumToCInt(args[3]);    /* Read PAGE_SIZE bytes file contents from filepointer. */    TIMEOUT( rval=read(id, buffer, nbytes) );    if ( rval == 0 )      {D 5	*Lisp_errno = EWOULDBLOCK;	return(NIL);E 5I 5        *Lisp_errno = EWOULDBLOCK;        return(NIL);E 5      }    if ( rval == -1 )      {D 5	*Lisp_errno = errno;	return(NIL);E 5I 5        *Lisp_errno = errno;        return(NIL);E 5      }#ifdef BYTESWAP    word_swap_page(buffer, (nbytes+3)>>2);D 5#endif BYTESWAPE 5I 5#endif /* BYTESWAP */E 5I 5E 5    return(GetSmallp(rval));I 5#endif /* DOS */E 5  }/************************************************************************/D 5/*									*//*			   C H A R _ b o u t s				*//*									*//*	Given the argument vector:					*//*	args[0] the file id to write bytes to				*//*	args[1] the base address of the buffer to write from		*//*	args[2] starting offset within the buffer to gt bytes from	*//*	args[3] the number of bytes desired to write, maximum		*//*	args[4] a FIXP cell to hold the errno, if an error occurs	*//*									*//*	write up to the specified number of bytes from the buffer,	*//*	starting at the offset given.  Return the number of bytes	*//*	actually written; will return if fewer bytes than desired are	*//*	written.  If an error occurs in writing, return NIL, and put	*//*	the Unix errno into the FIXP cell given.  EWOULDBLOCK is an	*//*	error that can occur--and bins returns NIL, so Lisp code has	*//*	to handle that case itself.					*//*									*/E 5I 5/*                                                                      *//*                         C H A R _ b o u t s                          *//*                                                                      *//*      Given the argument vector:                                      *//*      args[0] the file id to write bytes to                           *//*      args[1] the base address of the buffer to write from            *//*      args[2] starting offset within the buffer to gt bytes from      *//*      args[3] the number of bytes desired to write, maximum           *//*      args[4] a FIXP cell to hold the errno, if an error occurs       *//*                                                                      *//*      write up to the specified number of bytes from the buffer,      *//*      starting at the offset given.  Return the number of bytes       *//*      actually written; will return if fewer bytes than desired are   *//*      written.  If an error occurs in writing, return NIL, and put    *//*      the Unix errno into the FIXP cell given.  EWOULDBLOCK is an     *//*      error that can occur--and bins returns NIL, so Lisp code has    *//*      to handle that case itself.                                     *//*                                                                      */E 5/************************************************************************/CHAR_bouts(args)D 5  register LispPTR	*args;E 5I 5  register LispPTR      *args;E 5  {D 5    register int	id, rval;E 5I 5#ifndef DOS    register int id, rval;E 5    char *buffer;    int nbytes, offset;    Lisp_errno = (int *)(Addr68k_from_LADDR(args[4]));    ERRSETJMP(NIL);    id = LispNumToCInt(args[0]);    buffer = ((char *)(Addr68k_from_LADDR(args[1]))) + LispNumToCInt(args[2]);    nbytes = LispNumToCInt(args[3]);    /* Write PAGE_SIZE bytes file contents from filepointer. */#ifdef BYTESWAP    word_swap_page(buffer, (nbytes+3)>>2);D 5#endif BYTESWAPE 5I 5#endif /* BYTESWAP */E 5    TIMEOUT( rval=write(id, buffer, nbytes) );#ifdef BYTESWAP    word_swap_page(buffer, (nbytes+3)>>2);D 5#endif BYTESWAPE 5I 5#endif /* BYTESWAP */E 5    if (rval == -1)      {D 5	*Lisp_errno = errno;	return(NIL);E 5I 5        *Lisp_errno = errno;        return(NIL);E 5      }    if (rval == 0)      {D 5	*Lisp_errno = EWOULDBLOCK;	return(NIL);E 5I 5        *Lisp_errno = EWOULDBLOCK;        return(NIL);E 5      }    return(GetSmallp(rval));I 5#endif /* DOS */E 5  }E 1