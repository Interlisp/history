h42905s 00044/00023/00057d D 2.6 93/02/08 14:53:48 sybalsky 8 7c Big VM (and new CDR coding) changes for 3.0 \nes 00002/00002/00078d D 2.5 92/04/21 17:14:15 sybalsky 7 6c shortening file names for DOS \nes 00000/00000/00080d D 2.4 90/04/20 01:37:44 sybalsky 6 5c AIX:  shortening file names, bulk change.es 00004/00003/00076d D 2.3 89/03/28 01:43:19 sybalsky 5 4c word-swapped pointer fixes.es 00017/00015/00062d D 2.2 88/10/10 14:06:30 krivacic 4 3c sun3/4 mergees 00000/00000/00077d D 2.1 88/05/17 09:24:58 hayata 3 2c Version up to 2.1es 00002/00002/00075d D 1.2 88/03/13 14:50:38 hayata 2 1c Add SCCS key id (%Z%)es 00077/00000/00000d D 1.1 88/02/24 16:57:26 hayata 1 0c date and time created 88/02/24 16:57:26 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 8/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 8I 8/* This is G-file %Z% %M% Version %I% (%G%). copyright Venue  */E 8static char *id = "%Z% %M%	%I% %G%";E 2I 8/************************************************************************//*									*//*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************/E 8/*************************************************************************/D 8/*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved	 *//*************************************************************************/E 8/*                                                                       */D 8/*                         File Name : gcscans.c                         */E 8I 8/*                         File Name : gcscan.c                         */E 8/*                                                                       *//*************************************************************************//*                                                                       *//*                         Creation Date : July-7-1987                   *//*                         Written by Tomoru Teruuchi                    *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions :                                                 *//*                        gcscan1(probe)                                 *//*                        gcscan2(probe)                                 *//*                                                                       *//*************************************************************************//*           Descreption :                                               *//*                                                                       *//* The functions "gcscan1" and "gcscan2" are the translated functions    *//*  from the Lisp Functions "\GCSCAN1" & "\GCSCAN2".                     *//* These functions' role is to scan the HTmain Table and return the      *//*  existing entry(by "gcscan1") & the entry whose STKBIT field is ON    *//*  (by "gcscan2").These functions are the UFN functions that are called *//*  by OPCODES "GCSCAN1" & "GCSCAN2".                                    *//*                                                                       *//* gcscan1                                                               *//*    INPUT : probe (the startng offset in the HTmain table)             *//*    OUTPUT : the entry's offset or NIL (no more entry existing)        *//*                                                                       *//* gcscan2                                                               *//*    INPUT : probe (the starting offset in the HTmain table)            *//*    OUTPUT : the entry's offset or NIL (no more entry existing)        *//*************************************************************************//*                                                               \Tomtom *//*************************************************************************/#include "lispemul.h"D 7#include "lispglobal.h"E 7I 7#include "lspglob.h"E 7#include "gc.h"I 5D 7#include "lisptypes.h"E 7I 7#include "lsptypes.h"E 7E 5I 8#ifdef BIGVM#define HTSTKBIT 		0x10000		/* = 512 */#define HTENDS 			((struct hashentry *) htlptr)#define GetStkCnt(entry1)	(entry1 >> 16)#elseE 8D 4#define HTSTKBIT 0x200			/* = 512 */#define GetStkCnt(entry1)		 ((entry1 & 0x0fe00) >> 9)E 4I 4#define HTSTKBIT 		0x200		/* = 512 */#define HTENDS 			((struct hashentry *) htlptr)#define GetStkCnt(entry1)	(entry1 >> 9)I 8#endif /* BIGVM */E 8E 4D 8/* extern DLword *HTmain;  -- this is real method */E 8I 4I 8E 8E 4DLword gcscan1 (probe)D 4DLword 	probe;				/* probe is offset */  { register struct hashentry *htents;    register struct htlinkptr *htlptr;		/* overlay access method */     while (probe != 0)			/* End of HTmain Table ? */	{ htents = (struct hashentry *)(HTmain+(--probe));E 4I 4D 8register int 	probe;				/* probe is offset */E 8I 8  register int 	probe;				/* probe is offset */E 8  { register struct htlinkptr *htlptr;		/* overlay access method */     register int contents;    while (--probe >= 0)			/* End of HTmain Table ? */D 8	{ E 4					/* Start addr. of scanning */	D 4   	  htlptr = (struct htlinkptr *)htents;	  if ((htlptr->contents & 0x0ffff) != 0 &&/* entry is Garbage ? */ 	      (htents->collision || GetStkCnt(htlptr->contents) == 0))E 4I 4   	  htlptr = (struct htlinkptr *)(HTmain+probe);D 5	  contents = htlptr->contents;	  if (contents && (HTENDS->collision || (GetStkCnt(contents) == 0)))E 5I 5	  contents = ((struct htlinkptr *)WORDPTR(htlptr))->contents;	  if (contents && (((struct hashentry *)WORDPTR(HTENDS))->collision || (GetStkCnt(contents) == 0)))E 5E 4		 return(probe);	}E 8I 8      { 	/* Start addr. of scanning */		htlptr = (struct htlinkptr *)(HTmain+probe);	contents = ((struct htlinkptr *)GCPTR(htlptr))->contents;	if (contents && (((struct hashentry *)GCPTR(HTENDS))->collision	    || (GetStkCnt(contents) == 0)))	  return(probe);      }E 8    return(NIL);   }I 8E 8DLword gcscan2 (probe)D 4DLword 	probe;				/* probe is offset */E 4I 4D 8register int 	probe;				/* probe is offset */E 4   {register struct htlinkptr *htlptr;		/* overlay access method */ D 4	while (probe != 0)		/* End of HTmain Table ? */	 { htlptr = (struct htlinkptr *)(HTmain+(--probe));					/* Start addr. of scanning */E 4I 4	while (--probe >= 0)			/* End of HTmain Table ? */	 { htlptr = (struct htlinkptr *)(HTmain+probe);E 8I 8  register int 	probe;				/* probe is offset */  {    register struct htlinkptr *htlptr;		/* overlay access method */     while (--probe >= 0)			/* End of HTmain Table ? */      {	htlptr = (struct htlinkptr *)(HTmain+probe);E 8						/* Start addr. of scanning */E 4D 5	   if (((HTSTKBIT | 1) & htlptr->contents) != 0)E 5I 5D 8	   if (((HTSTKBIT | 1) & ((struct htlinkptr *)WORDPTR(htlptr))->contents) != 0)E 5D 4			return(probe);	/* stackref or collision is ON */E 4I 4			return(probe);		/* stackref or collision ON */E 4	 }	return(NIL);   }E 8I 8	if (((HTSTKBIT | 1) & ((struct htlinkptr *)GCPTR(htlptr))->contents) != 0)	    return(probe);		/* stackref or collision ON */      }    return(NIL);  }E 8E 1