h26142s 00003/00003/00201d D 2.7 92/04/21 17:19:30 sybalsky 22 21c shortening file names for DOS \nes 00000/00000/00204d D 2.6 90/04/20 01:47:28 sybalsky 21 20c AIX:  shortening file names, bulk change.es 00003/00003/00201d D 2.5 89/03/18 04:02:26 sybalsky 20 19c OneDArrayes 00000/00035/00204d D 2.4 88/10/18 15:01:12 krivacic 19 18c remove warning messagees 00000/00002/00239d D 2.3 88/10/10 14:07:33 krivacic 18 17c sun3/4 mergees 00016/00000/00225d D 2.2 88/06/30 10:57:32 greep 17 16c put "#ifdef DEBUG" around printfses 00000/00000/00225d D 2.1 88/05/17 09:25:49 hayata 16 15c Version up to 2.1es 00007/00004/00218d D 1.15 88/05/11 18:23:56 krivacic 15 14c es 00018/00000/00204d D 1.14 88/05/11 12:31:21 krivacic 14 13c exec commandes 00007/00003/00197d D 1.13 88/05/10 21:43:52 krivacic 13 12c do jsr to get entry point of new loades 00064/00002/00136d D 1.12 88/05/10 19:43:46 krivacic 12 11c new interfacees 00002/00002/00136d D 1.11 88/05/06 13:44:38 krivacic 11 10c file changes ines 00005/00001/00133d D 1.10 88/05/05 14:10:56 krivacic 10 9c rm line addedes 00002/00002/00132d D 1.9 88/05/04 20:40:08 krivacic 9 8c file changeses 00001/00001/00133d D 1.8 88/04/27 20:45:27 krivacic 8 7c add back -I../inc go cces 00001/00001/00133d D 1.7 88/04/27 13:39:17 krivacic 7 6c assume disp68K.il in ../src/disp68K.il (for loader)es 00004/00001/00130d D 1.6 88/04/25 12:38:30 krivacic 6 5c timer on/offes 00043/00013/00088d D 1.5 88/04/21 18:11:58 krivacic 5 4c loader returns list of (load-addr, entry-addr, length)es 00004/00002/00097d D 1.4 88/04/08 17:18:43 krivacic 4 3c string error fixeses 00002/00002/00097d D 1.3 88/03/13 14:53:39 hayata 3 2c Add SCCS key id (%Z%)es 00001/00001/00098d D 1.2 88/03/03 11:37:28 krivacic 2 1c Use native/disp68K.il file instead of disp68K.iles 00099/00000/00000d D 1.1 88/02/24 16:57:52 hayata 1 0c date and time created 88/02/24 16:57:52 by hayataeuUtTI 1D 3/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 3I 3/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 3#include "sys/exec.h" /* choose one you like */#include <stdio.h>I 5#include "lispemul.h"D 22#include "address68k.h"#include "lisptypes.h"E 22I 22#include "adr68k.h"#include "lsptypes.h"E 22#include "lispmap.h"D 22#include "lispglobal.h"E 22I 22#include "lspglob.h"E 22#include "arith.h"E 5I 5D 18extern int TopOfStack;E 18E 5char *sbrk();unsigned getpagesize(), getpid();char * malloc();#define roundup( a, b) ((((unsigned)(a)+(b)-1)/(b))*(b))I 12/* A macro to convert a Lisp String to a C string */#define	LispStringToCString(Lisp, C){	\	LispPTR	*naddress;				\	char	*base;					\	int	length;					\	int	offset;					\	naddress = (LispPTR *)(Addr68k_from_LADDR(Lisp));					\D 20	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));	\	offset = (int)(((ONEDARRAAY *)naddress)->offset);	\	length = ((ONEDARRAAY *)naddress)->totalsize;						\E 20I 20	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));	\	offset = (int)(((OneDArray *)naddress)->offset);	\	length = ((OneDArray *)naddress)->totalsize;						\E 20	strncpy(C, base + offset, length);			\	C[length] = '\0';				\	}int dynamic_load_code(args) 	LispPTR *args;/*	args[0]:	LispPTR to file name.	args[1]:	native addr of where to load the codeD 13	returns: T 	if load went ok.E 13I 13	returns: List(load_addr, entry_point, length)E 13*/{char	file_name[512];int	load_address;I 13int	entry_point;E 13	LispStringToCString(args[0], file_name);	N_GETNUMBER(args[1], load_address, return_error);	return(load_native_object(load_address, file_name));return_error:I 15	printf("error in dynamic load: 0x%x\n",args[1]);E 15	return(NIL_PTR);}load_native_object(load_address, dynamic_file)	unsigned load_address;	char *dynamic_file;{	int load_length, entry_point;	typedef char *charstrptr;	typedef charstrptr charstrlist[2];	charstrlist p;	int fd, asize, i;	struct exec hdr;	fd = open( dynamic_file, 0 );	if (fd == -1) return(0);	if (read( fd, &hdr, sizeof hdr ) == -1) return(0);		load_length = hdr.a_text+hdr.a_data;I 17#ifdef  DEBUGE 17	printf("Load Size: %x, Header Rec Size %x\n",load_length,sizeof hdr);	printf("Data Size: %x, Text Size %x\n",hdr.a_data, hdr.a_text);I 17#endifE 17	if (read( fd, load_address, load_length ) == -1) return(0);D 13	{register int r0, r2;E 13I 13	entry_point = (int) ( (CFuncPTR)asmcall(load_address) );	{register int r0, r1, r2;E 13	 ARITH_SWITCH((int) load_address, r0);I 13	 ARITH_SWITCH((int) entry_point, r1);E 13	 ARITH_SWITCH(load_length, r2);D 13	 return(N_OP_cons(r0, N_OP_cons(r2, NIL_PTR)));E 13I 13	 return(N_OP_cons(r0, N_OP_cons(r1, N_OP_cons(r2, NIL_PTR))));E 13	}}I 14/* ****  system call subr, living in sb_OLD_COMPILE_LOAD_NATIVE slot *** */D 15int do_system_call(args)	LispPTR *args;E 15I 15int do_system_call(arg)	LispPTR arg;E 15{char	cmd_str[512];register int result;register int lisp_result;D 15	LispStringToCString(args[0], cmd_str);	printf(".."); printf(cmd_str); printf("\n");E 15I 15	LispStringToCString(arg, cmd_str);I 17#ifdef  DEBUGE 17	printf(":: %s \n",cmd_str);I 17#endifE 17	int_timer_off();E 15	result = system(cmd_str);I 15	int_timer_on();E 15	ARITH_SWITCH(result, lisp_result);	return(lisp_result);}/* ****** stuff below is old & should be removed when the subr is *** */E 14E 12int dynamic_load (host_file, dynamic_file, load_address, needs_compile, needs_link, do_load)	char *host_file, *dynamic_file;	unsigned load_address, needs_compile, needs_link, do_load;{I 5	int result = 0;E 5D 4	char fnamec[40], fnameo[40], fnameil[40], cc_str[80], ld_str[80];E 4I 4	char fnamec[80], fnameo[80], fnameil[80], cc_str[255], ld_str[255];E 4	unsigned pagsiz = getpagesize();	I 4	host_file = "lisp";	/* TEMPORARY ********** */I 17D 19#ifdef  DEBUGE 19E 17E 4	printf("loading: %s into %s \n",dynamic_file,host_file);I 17D 19#endifE 19E 17	if (load_address == 0) load_address = roundup(sbrk(0),pagsiz);	sprintf(fnamec, "%s.c", dynamic_file);	sprintf(fnameo, "%s.o", dynamic_file);	sprintf(fnameil, "%s.il", dynamic_file);D 2	sprintf(cc_str,"/bin/cc  -c %s -o %s disp68K.il %s -O",fnamec,fnameo,fnameil);E 2I 2D 7	sprintf(cc_str,"/bin/cc  -c %s -o %s native/disp68K.il %s -O",fnamec,fnameo,fnameil);E 7I 7D 8	sprintf(cc_str,"/bin/cc  -c %s -o %s  %s -O ../src/disp68K.il",fnamec,fnameo,fnameil);E 8I 8D 9	sprintf(cc_str,"/bin/cc  -c %s -o %s  %s -O -I../inc ../src/disp68K.il",fnamec,fnameo,fnameil);E 8E 7E 2	sprintf(ld_str,"/bin/ld -N -Ttext %x -A %s -o %s %s -lc",E 9I 9D 11	sprintf(cc_str,"/bin/cc  -c %s -o %s  %s -O -I/users/krivacic/maiko/inc /users/krivacic/maiko/src/disp68K.il",fnamec,fnameo,fnameil);	sprintf(ld_str,"/bin/ld -N -Ttext %x -A /users/krivacic/maiko/bin/%s -o %s %s -lc",E 11I 11	sprintf(cc_str,"/bin/cc  -pipe -c %s -o %s  %s -O -I/users/krivacic/maiko/inc /users/krivacic/maiko/src/disp68K.il",fnamec,fnameo,fnameil);	sprintf(ld_str,"/bin/ld -N -s -Ttext %x -A /users/krivacic/maiko/bin/%s -o %s %s -lc",E 11E 9			load_address,host_file,dynamic_file,fnameo);D 5	if (needs_compile) exec_command(cc_str);	if (needs_link) exec_command(ld_str);	if (do_load) return(load_object(load_address, dynamic_file));		return(0);E 5I 5I 10E 10	if (needs_compile) 		{result = exec_command(cc_str);		 if (result) return(0);		}	if (needs_link) 		{result = exec_command(ld_str);		 if (result) return(0);		}D 10	if (do_load) E 10I 10	if (do_load) {char rm_str[200];E 10		result = load_object(load_address, dynamic_file);	I 10		sprintf(rm_str,"/bin/rm %s %s %s %s",fnamec, fnameil, fnameo, dynamic_file);D 12		exec_command(rm_str);E 12I 12/* ***		exec_command(rm_str); *** */E 12		}E 10	TopOfStack = result;I 17D 19#ifdef  DEBUGE 17	printf("DL: 0x%x\n",TopOfStack);I 17#endifE 19E 17	return(result);E 5}  /*dynamic_load */exec_command(cmd_str)	char *cmd_str;{	typedef char *charstrptr;	typedef charstrptr charstrlist[21];	charstrlist p;D 4	char ws[21][20];E 4I 4	char ws[21][80];E 4	int i, ii, cmd_length;I 6	int_timer_off();I 17D 19#ifdef  DEBUGE 17E 6I 5	printf(":: %s \n",cmd_str);I 17#endifE 19E 17D 6	return(system(cmd_str));E 6I 6	i = system(cmd_str);	int_timer_on();	return(i);E 6D 19E 5/* unpack the command string */	cmd_length = sscanf(cmd_str,		"%s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s",		ws [0], ws[1], ws[2], ws[3], ws[4], ws[5], 		ws[6], ws[7], ws[8], ws[9], ws[10],		ws[11], ws[12], ws[13], ws[14], ws[15],		ws[16], ws[17], ws[18], ws[19], ws[20]);		for (i = 0; i < (cmd_length); i++) p[i] = ws[i];	p[cmd_length] = NULL;D 5	printf(":: %s \n",cmd_str);E 5/* call the exec */	switch( fork() ){	case 0: /* child */		execv( p[0], p );		exit(0);	case -1: /* failure */		perror("vfork");		exit(1);	default: /*parent */		while ( wait( &ii ) != -1 ) ;	}E 19} /*exec_command */D 5load_object(load_address, dynamic_file, argv)E 5I 5load_object(load_address, dynamic_file)E 5	unsigned load_address;	char *dynamic_file;D 5	char **argv;E 5{I 5	int load_length, entry_point;E 5	typedef char *charstrptr;	typedef charstrptr charstrlist[2];	charstrlist p;	int fd, asize, i;	struct exec hdr;	char *addr2;	unsigned pagsiz = getpagesize();	fd = open( dynamic_file, 0 );D 12	read( fd, &hdr, sizeof hdr );E 12I 12	if (fd == -1) return(0);	if (read( fd, &hdr, sizeof hdr ) == -1) return(0);E 12		asize = roundup(hdr.a_text+hdr.a_data+hdr.a_bss, pagsiz)+pagsiz;I 17#ifdef  DEBUGE 17	printf("Load Size: %x, Header Rec Size %x\n",asize,sizeof hdr);	printf("Data Size: %x, Text Size %x\n",hdr.a_data, hdr.a_text);I 17#endifE 17	addr2 = sbrk(asize);	addr2 = (char *)roundup(addr2,pagsiz);D 5	if ( load_address != (unsigned)addr2 ){		fprintf(stderr,"bad news load_address: %x addr2: %x\n",			load_address,addr2); 		exit(1);E 5I 5	if ( load_address != (unsigned)addr2 ){ return(NIL_PTR); }	load_length = hdr.a_text+hdr.a_data;	read( fd, addr2, load_length );	entry_point = (int) ( (CFuncPTR)asmcall(addr2) );	{register int r0, r1, r2;I 17#ifdef  DEBUGE 17	 printf("Values 0x%x & 0x%x\n",entry_point,load_length);I 17#endifE 17	 ARITH_SWITCH((int) addr2, r0);	 ARITH_SWITCH((int) entry_point, r1);	 ARITH_SWITCH(load_length, r2);I 17#ifdef  DEBUGE 17	 printf("Returning 0x%x & 0x%x\n",r1,r2);I 17#endifE 17	 return(N_OP_cons(r0, N_OP_cons(r1, N_OP_cons(r2))));E 5	}D 5	read( fd, addr2, hdr.a_text+hdr.a_data );	return((int) addr2);E 5}E 1