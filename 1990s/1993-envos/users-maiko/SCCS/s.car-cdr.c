h10536s 00316/00237/00385d D 2.11 93/02/08 14:49:03 sybalsky 15 14c Big VM (and new CDR coding) changes for 3.0 \nes 00004/00004/00618d D 2.10 92/04/21 17:06:32 sybalsky 14 13c shortening file names for DOS \nes 00008/00008/00614d D 2.9 90/06/15 16:56:11 mitani 13 12c GCLOOKUPes 00002/00005/00620d D 2.8 90/05/30 11:06:02 sybalsky 12 11c es 00000/00000/00625d D 2.7 90/04/20 01:23:52 sybalsky 11 10c AIX:  shortening file names, bulk change.es 00157/00146/00468d D 2.6 90/03/15 22:03:00 sybalsky 10 9c code reformatting, commentses 00063/00081/00551d D 2.5 89/01/09 16:10:58 shih 9 8c sccsid restored, minor spellinges 00004/00004/00628d D 2.4 88/11/08 13:10:16 bane 8 7c removed LHS cast to make Apollo compiler happyes 00010/00377/00622d D 2.3 88/10/12 14:41:20 krivacic 7 6c new out-of-line interfacees 00004/00000/00995d D 2.2 88/05/27 14:50:57 krivacic 6 5c C_ONLY ifdefes 00000/00000/00995d D 2.1 88/05/17 09:22:43 hayata 5 4c Version up to 2.1es 00012/00012/00983d D 1.4 88/05/09 21:33:36 shih 4 3c Use GCLOOKUPes 00310/00000/00685d D 1.3 88/03/21 13:57:57 krivacic 3 2c native interfacees 00002/00002/00683d D 1.2 88/03/13 14:34:10 hayata 2 1c Add SCCS key id (%Z%)es 00685/00000/00000d D 1.1 88/02/24 16:55:59 hayata 1 0c date and time created 88/02/24 16:55:59 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 8/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 8I 8D 9/* This is G-file @(#) car-cdr.c Version 2.3 (10/12/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) car-cdr.c	2.3 10/12/88";E 9I 9D 10/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 10I 10D 15/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 10static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 15I 15/* %Z% %M% Version %I% (%G%). copyright Venue  */static char *id = "%Z% %M%	%I% %G%		(Venue)";E 15I 10/************************************************************************//*									*/D 15/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 15I 15/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 15/*									*/D 15/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 15I 15/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 15/*									*//************************************************************************/E 10E 9E 8E 2D 15/*D 9 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther :  Takeshi Shimizu,Naoyuki Mitani *E 9I 9 *	Author :  Takeshi Shimizu, Naoyuki MitaniE 9 */E 15I 15E 15/***********************************************************************//*D 9 		File Name :	car-cdr.cE 9I 9		File Name :	car-cdr.cE 9		Desc	:	car-cdr managementD 9  					Date :		Apr 24, 1987 					Edited by :	Naoyuki Mitani E 9I 9					Date :		Apr 24, 1987					Edited by :	Naoyuki MitaniE 9		Including :	car				cdr				rplaca				rplacd				OP_car				OP_cdr				OP_rplaca				OP_rplacd*//**********************************************************************/#include "lispemul.h"D 14#include "emulglobal.h"#include "lispglobal.h"#include "lisptypes.h"E 14I 14#include "emlglob.h"#include "lspglob.h"#include "lsptypes.h"E 14#include "address.h"D 14#include "address68k.h"E 14I 14#include "adr68k.h"E 14#include "gc.h"D 9#include "cell.h"    E 9I 9#include "cell.h"E 9D 15/**********************************************************************//*		Func name :	carE 15D 9				Called from C program . E 9I 9D 15				Called from C program.E 15E 9D 15					Date :		Apr 15, 1987					Edited by :	Naoyuki MitaniE 15I 15/************************************************************************//*									*//*				c a r					*//*									*//*	Returns CAR of its argument.  Meant to be called from C.	*//*									*//************************************************************************/E 15D 9					Changed : 26-May-87 take						  22-Oct-87 takeE 9D 15*//**********************************************************************/E 15LispPTR car(datum)D 15	register LispPTR datum; /* datum must be LISP pointer(word offset) */D 9{ E 9I 9{E 9  register ConsCell *datum68k;  register ConsCell *temp;E 15I 15  register LispPTR datum; /* datum must be LISP pointer(word offset) */  {    register ConsCell *datum68k;    register ConsCell *temp;E 15D 15#ifdef TRACE2	printf("TRACE: car()\n");#endif datum68k = (ConsCell *)(Addr68k_from_LADDR(datum)); if (Listp(datum)) {E 15I 15    datum68k = (ConsCell *)(Addr68k_from_LADDR(datum));    if (Listp(datum))      {E 15	if (datum68k->cdr_code == CDR_INDIRECT)D 15	{		temp = (ConsCell *)Addr68k_from_LADDR(datum68k->car_field);		return((LispPTR)temp->car_field);	}D 9	else E 9I 9	elseE 9		return((LispPTR)datum68k->car_field);  } else if (datum==NIL_PTR)	return((LispPTR)NIL_PTR);E 15I 15	  {	    temp = (ConsCell *)Addr68k_from_LADDR(datum68k->car_field);	    return((LispPTR)temp->car_field);	  }	else return((LispPTR)datum68k->car_field);      }E 15D 15 else {	if(datum == ATOM_T)	   return(ATOM_T);E 15I 15    else if (datum==NIL_PTR) return((LispPTR)NIL_PTR);E 15I 15    else      {	if(datum == ATOM_T) return(ATOM_T);E 15	/** We assume CAR/CDRERR is CDR ***/D 15	else if ((datum & 0xFF0000)==0) /* LITATOM */E 15I 15	else if ((datum & SEGMASK)==0) /* LITATOM */E 15		return(NIL);D 15	else		error("car : ARG not list");E 15I 15	else error("car : ARG not list");E 15      }D 15} /* end of car */E 15I 15  } /* end of car */E 15D 15/**********************************************************************//*	Func name :	cdrE 15D 9		Called from C program . E 9I 9D 15		Called from C program.E 15E 9D 15			Date :		Apr 15, 1987			Edited by :	Naoyuki MitaniE 15D 9			Changed by:	Naoyuki Mitani(17-Apr)			Changed by:	Naoyuki Mitani(22-Apr)					Take	(26-May-87)					Take (16-Oct-87)					Take(13-Nov-87) DL->intE 9D 15*//**********************************************************************/E 15I 15/************************************************************************//*									*//*				c d r					*//*									*//*	Returns CDR of its argument.  Meant to be called from C.	*//*									*//************************************************************************/E 15LispPTR cdr(datum)D 15	register LispPTR datum; /* datum must be LISP pointer(word offset) */D 9{ E 9I 9{E 9 register ConsCell *datum68k; register DLword cdr_code; register  ConsCell *temp;E 15I 15  register LispPTR datum; /* datum must be LISP pointer(word offset) */  {    register ConsCell *datum68k;    register DLword cdr_code;    register  ConsCell *temp;E 15D 15#ifdef TRACE2	printf("TRACE: cdr()\n");#endifE 15I 15    datum68k = (ConsCell *)(Addr68k_from_LADDR(datum));    cdr_code = datum68k->cdr_code;E 15D 15 datum68k = (ConsCell *)(Addr68k_from_LADDR(datum)); cdr_code = datum68k->cdr_code;E 15I 15    if (Listp(datum))      {	if (cdr_code == CDR_NIL) return(NIL_PTR); /* cdr is nil */E 15D 15 if (Listp(datum)) {	if (cdr_code == CDR_NIL)		/* cdr-nil */D 9	   E 9I 9E 9		return(NIL_PTR);D 9	   E 9I 9E 9	else if ((cdr_code & CDR_ONPAGE) != 0)		/* cdr-samepage */D 9		return(POINTER_PAGEBASE(datum) + E 9I 9		return(POINTER_PAGEBASE(datum) +E 9		((cdr_code & 127) << 1));E 15I 15	else if ((cdr_code & CDR_ONPAGE) != 0) /* cdr-samepage */#ifdef NEWCDRCODING	  return(datum + ((cdr_code & 7) << 1));#else	  return(POINTER_PAGEBASE(datum) + ((cdr_code & 127) << 1));#endif /* NEWCDRCODING */E 15	else if (cdr_code == CDR_INDIRECT)	/* cdr_code > CDR_ONPAGE */		/* cdr-indirect */I 15	  return(cdr ((LispPTR)(datum68k->car_field)));E 15D 15		return(cdr ((LispPTR)(datum68k->car_field)));E 15	elseD 15	{		/* cdr-differentpage */E 15I 15	  {	    /* cdr isn't a CONS, but is stored on this page. */#ifdef NEWCDRCODING	    temp = (ConsCell *)(Addr68k_from_LADDR	      (datum + (cdr_code << 1)));#else	    temp = (ConsCell *)(Addr68k_from_LADDR	      (POINTER_PAGEBASE(datum) + (cdr_code << 1)));#endif /* NEWCDRCODING */	    return((LispPTR)temp->car_field);	  }      }    else if (datum==NIL_PTR) return(NIL_PTR);E 15D 15		temp = (ConsCell *)(Addr68k_from_LADDR		(POINTER_PAGEBASE(datum) + (cdr_code << 1)));		return((LispPTR)temp->car_field);	}  }D 10 else if (datum==NIL_PTR)	  return(NIL_PTR);E 10I 10 else if (datum==NIL_PTR) return(NIL_PTR);E 15E 10 /**** We assume CAR/CDRERR is CDR ****************/D 10 else	error("cdr : ARG not list");E 10I 10D 15 else error("cdr : ARG not list");E 15I 15    else error("cdr : ARG not list");E 15E 10D 10} /* end of cdr */E 10I 10  } /* end of cdr */E 10I 10E 10/**********************************************************************//*		Func name :	rplacaD 9				Called from C program . E 9I 9				Called from C program.E 9					Date :		Apr 15, 1987					Edited by :	Naoyuki MitaniD 9					Changed by:	Naoyuki Mitani(17-Apr)							take	(26-May-87)E 9*//**********************************************************************/LispPTR rplaca(x , y)D 15	register LispPTR x;		/* car of x will be smashed */	register LispPTR y;		/* y is a newly car object */E 15I 15  register LispPTR x;		/* car of x will be smashed */  register LispPTR y;		/* y is a newly car object */E 15D 9{ E 9I 9D 10{E 9 register ConsCell *x_68k; register ConsCell *temp;E 10I 10  {    register ConsCell *x_68k;    register ConsCell *temp;E 10#ifdef TRACE2D 10	printf("TRACE: rplaca()\n");E 10I 10    printf("TRACE: rplaca()\n");E 10#endifD 10 if (Listp(x) == NIL) {E 10I 10    if (Listp(x) == NIL)      { /* arg isn't a CONS cell, might be NIL */E 10	if (x == NIL_PTR)D 10	{		if (y != NIL_PTR)			error("Attempt to RPLACA NIL");D 9E 9		elseD 9			return(NIL_PTR);	E 9I 9			return(NIL_PTR);E 9	}	else		error("ARG not List"); }E 10I 10	  {	    if (y != NIL_PTR) error("Attempt to RPLACA NIL");	    else return(NIL_PTR);	  }	else error("ARG not List");      }E 10D 9 else E 9I 9D 10 elseE 9 {E 10I 10    else      {E 10	x_68k = (ConsCell *)Addr68k_from_LADDR(x);D 4	gclookup(0x8000|DELREF , car(x));	/* set up referense count */	gclookup(0x8000|ADDREF , y);E 4I 4D 9	GCLOOKUP(0x8000,DELREF , car(x));	/* set up reference count */	GCLOOKUP(0x8000,ADDREF , y);E 9I 9D 13	GCLOOKUP(0x8000, DELREF, car(x));	/* set up reference count */	GCLOOKUP(0x8000, ADDREF, y);E 13I 13	GCLOOKUP(car(x), DELREF);	/* set up reference count */	GCLOOKUP(y, ADDREF);E 13E 9E 4	if (x_68k->cdr_code == CDR_INDIRECT)D 10	{		temp = (ConsCell *)Addr68k_from_LADDR					((LispPTR)x_68k->car_field);		temp->car_field = y;	}	else		x_68k->car_field = y;E 10I 10	  {	    temp = (ConsCell *)Addr68k_from_LADDR((LispPTR)x_68k->car_field);	    temp->car_field = y;	  }	else x_68k->car_field = y;E 10D 9 E 9I 9E 9	return(x);D 10 }} /* end of rplaca */E 10I 10      }  } /* end of rplaca */E 10I 10E 10/**********************************************************************//*		Func name :	rplacdD 9				Called from C program . E 9I 9				Called from C program.E 9					Date :		Apr 16, 1987					Edited by :	Naoyuki MitaniD 9					Changed by:	Naoyuki Mitani(23-Apr)					Changed by:	Naoyuki Mitani(24-Apr)							take  (26-MAy-87)E 9*//**********************************************************************/D 15E 15I 15#ifdef NEWCDRCODINGConsCell *find_cdrable_pair();	/* below... */#endifE 15I 12extern struct conspage *next_conspage();  /* conspage.c */E 12LispPTR rplacd(x , y)D 15	LispPTR x;		/* cdr of x will be smashed */	register LispPTR y;		/* y is a newly cdr object */E 15I 15  LispPTR x;		/* cdr of x will be smashed */  register LispPTR y;	/* y is a newly cdr object */E 15D 9{ E 9I 9D 10{E 9 extern struct conspage; extern struct conspage *next_conspage();  /* conspage.c */E 10I 10  {D 12    extern struct conspage;    extern struct conspage *next_conspage();  /* conspage.c */E 10E 12D 10 register ConsCell *x_68k; register ConsCell *temp68k; register ConsCell *cdr_cell68k; LispPTR cdr_cell; LispPTR rp_page; DLword cdr_code; register struct conspage *cons68k;E 10I 10    register ConsCell *x_68k;    register ConsCell *temp68k;    register ConsCell *cdr_cell68k;    LispPTR cdr_cell;    LispPTR rp_page;    DLword cdr_code;    register struct conspage *cons68k;I 15    ConsCell * find_close_cell();E 15E 10D 15#ifdef TRACE2D 10	printf("TRACE: rplacd()\n");E 10I 10    printf("TRACE: rplacd()\n");E 10#endifE 15D 10  if (Listp(x) == NIL) {E 10I 10    if (Listp(x) == NIL)      {E 10	if (x == NIL_PTR)D 10	{		if (y != NIL_PTR)			error("Attempt to RPLACD NIL");E 10I 10	  {	    if (y != NIL_PTR) error("Attempt to RPLACD NIL");	    else return(NIL_PTR);	  }	else error("ARG not List");      }E 10D 10		elseD 9			return(NIL_PTR);	E 9I 9			return(NIL_PTR);E 9	}	else		error("ARG not List"); }D 9 else E 9I 9 elseE 9 {E 10I 10    else      {E 10	x_68k = (ConsCell *)Addr68k_from_LADDR(x);D 4	gclookup(0x8000|DELREF , cdr(x));	/* set up referense count */	gclookup(0x8000|ADDREF , y);E 4I 4D 9	GCLOOKUP(0x8000,DELREF , cdr(x));	/* set up reference count */	GCLOOKUP(0x8000,ADDREF , y);E 9I 9D 13	GCLOOKUP(0x8000, DELREF, cdr(x));	/* set up reference count */	GCLOOKUP(0x8000, ADDREF, y);E 13I 13	GCLOOKUP(cdr(x), DELREF);	/* set up reference count */	GCLOOKUP(y, ADDREF);E 13E 9E 4	cdr_code = x_68k->cdr_code;	if (cdr_code == CDR_INDIRECT)D 10	{		/* cdr-indirect */E 10I 10	  {	    /* cdr-indirect */E 10D 10		rp_page = (LispPTR)x_68k->car_field;		temp68k = (ConsCell *)Addr68k_from_LADDR(rp_page);D 9		cdr_cell = POINTER_PAGEBASE(rp_page) + E 9I 9		cdr_cell = POINTER_PAGEBASE(rp_page) +E 10I 10	    rp_page = (LispPTR)x_68k->car_field;	    temp68k = (ConsCell *)Addr68k_from_LADDR(rp_page);I 15#ifdef NEWCDRCODING	    cdr_cell = (rp_page) + (temp68k->cdr_code << 1);#elseE 15	    cdr_cell = POINTER_PAGEBASE(rp_page) +E 10E 9				(temp68k->cdr_code << 1);D 15#ifdef DEBUG/**** Chechk for DEBUG ***/if(temp68k->cdr_code >= 0200 ||  temp68k->cdr_code == 0){		printf("temp68k->cdr_code: %x\n", temp68k->cdr_code);}D 9/**** End Chechk for DEBUG ***/E 9I 9/**** End Check for DEBUG ***/E 9#endifE 15I 15#endif /* NEWCDRCODING */E 15D 10		cdr_cell68k = (ConsCell *)Addr68k_from_LADDR(cdr_cell);		*(LispPTR *)cdr_cell68k = y & 0xffffff; /* cdr_code is set to 0 */	}E 10I 10	    cdr_cell68k = (ConsCell *)Addr68k_from_LADDR(cdr_cell);D 15	    *(LispPTR *)cdr_cell68k = y & 0xffffff; /* cdr_code is set to 0 */E 15I 15	    *(LispPTR *)cdr_cell68k = y & POINTERMASK; /* cdr_code is set to 0 */E 15	  }E 10	else if (cdr_code <= CDR_MAXINDIRECT)D 10	{		/* cdr-differentpage */E 10I 10	  {	    /* cdr-differentpage */E 10D 15E 15I 15#ifdef NEWCDRCODING	    cdr_cell = x + (cdr_code << 1);#elseE 15D 10		cdr_cell = POINTER_PAGEBASE(x) + (cdr_code << 1);		cdr_cell68k = (ConsCell *)Addr68k_from_LADDR(cdr_cell);		*(LispPTR *)cdr_cell68k = y & 0xffffff; /* cdr_code is set to 0 */E 10I 10	    cdr_cell = POINTER_PAGEBASE(x) + (cdr_code << 1);I 15#endif /* NEWCDRCODING */E 15	    cdr_cell68k = (ConsCell *)Addr68k_from_LADDR(cdr_cell);D 15	    *(LispPTR *)cdr_cell68k = y & 0xffffff; /* cdr_code is set to 0 */E 15I 15	    *(LispPTR *)cdr_cell68k = y & POINTERMASK; /* cdr_code is set to 0 */E 15E 10D 10	}E 10I 10	  }E 10	else if (y == NIL_PTR)		/* cdr-samepage & y is nil */		x_68k->cdr_code = CDR_NIL;D 15E 15I 15#ifdef NEWCDRCODING	else if (((rp_page = POINTER_PAGEBASE(x)) == POINTER_PAGEBASE(y))		 && (y > x) && (y <= (x+14)))		/* cdr-samepage & x and y are on same page */		x_68k->cdr_code = CDR_ONPAGE + ((y-x) >> 1);#elseE 15	else if ((rp_page = POINTER_PAGEBASE(x)) == POINTER_PAGEBASE(y))		/* cdr-samepage & x and y are on same page */		x_68k->cdr_code = CDR_ONPAGE + ((y & 0xff) >> 1);D 15E 15I 15#endif /* NEWCDRCODING */E 15	elseD 10	{		/* cdr-samepage & x and y are on different page */E 10I 10	  {	    /* cdr-samepage & x and y are on different page */E 10D 10		cons68k = (struct conspage *)(Addr68k_from_LADDR(rp_page));		if (cons68k->count > 0)		{			/* at least one free-cell on x's conspage */			cdr_cell68k = GetNewCell_68k(cons68k);			cons68k->count--;			cons68k->next_cell = cdr_cell68k->cdr_code;E 10I 10	    cons68k = (struct conspage *)(Addr68k_from_LADDR(rp_page));I 15#ifdef NEWCDRCODING	    if ((cons68k->count > 0)		 && (cdr_cell68k = find_close_cell(cons68k, x)))	      {		/* at least one free-cell on x's conspage */		/* AND it's within CDR-code range of x. */		*(LispPTR *)cdr_cell68k = y & POINTERMASK; /* cdr_code set to 0 */		x_68k->cdr_code = (LADDR_from_68k(cdr_cell68k) - x) >> 1;	      }#elseE 15	    if (cons68k->count > 0)	      {		/* at least one free-cell on x's conspage */		cdr_cell68k = GetNewCell_68k(cons68k);		cons68k->count--;D 15		cons68k->next_cell = cdr_cell68k->cdr_code;E 15I 15		cons68k->next_cell = ((freecons *)cdr_cell68k)->next_free;E 15E 10D 10			*(LispPTR *)cdr_cell68k = y & 0xffffff; /* cdr_code is set to 0 */E 10I 10D 15		*(LispPTR *)cdr_cell68k = y & 0xffffff; /* cdr_code set to 0 */E 15I 15		*(LispPTR *)cdr_cell68k = y & POINTERMASK; /* cdr_code set to 0 */E 15E 10D 9			x_68k->cdr_code = (LADDR_from_68k(cdr_cell68k) - E 9I 9D 10			x_68k->cdr_code = (LADDR_from_68k(cdr_cell68k) -E 9			rp_page) >> 1;		}		else		{			/* no more free-cell on x's conspage */E 10I 10		x_68k->cdr_code = (LADDR_from_68k(cdr_cell68k) -		rp_page) >> 1;	      }I 15#endif /* NEWCDRCODING */E 15	    else	      {		/* no more free-cell on x's conspage */E 10D 15E 15I 15#ifdef NEWCDRCODING	    temp68k = (ConsCell *)find_cdrable_pair(x, y); 		temp68k->car_field = x_68k->car_field;		x_68k->car_field = LADDR_from_68k(temp68k);		x_68k->cdr_code = CDR_INDIRECT;#elseE 15D 10			cons68k = next_conspage();E 10I 10		cons68k = next_conspage();E 10D 10			cdr_cell68k = GetNewCell_68k(cons68k);			cons68k->next_cell = cdr_cell68k->cdr_code;E 10I 10		cdr_cell68k = GetNewCell_68k(cons68k);D 15		cons68k->next_cell = cdr_cell68k->cdr_code;E 15I 15		cons68k->next_cell = ((freecons *)cdr_cell68k)->next_free;E 15		temp68k = GetNewCell_68k(cons68k);D 15		cons68k->next_cell = temp68k->cdr_code;E 15I 15		cons68k->next_cell = ((freecons *)temp68k)->next_free;E 15E 10D 10			temp68k = GetNewCell_68k(cons68k);			cons68k->next_cell = temp68k->cdr_code;E 10I 10		cons68k->count -= 2;E 10D 10			cons68k->count -= 2;E 10I 10D 15		*(LispPTR *)cdr_cell68k = y & 0xffffff; /* cdr_code set to 0 */E 15I 15		*(LispPTR *)cdr_cell68k = y & POINTERMASK; /* cdr_code set to 0 */E 15E 10D 9			E 9I 9E 9D 10			*(LispPTR *)cdr_cell68k = y & 0xffffff; /* cdr_code is set to 0 */E 10I 10		temp68k->car_field = x_68k->car_field;		x_68k->car_field = LADDR_from_68k(temp68k);E 10D 10			temp68k->car_field = x_68k->car_field;D 8			(LispPTR)x_68k->car_field = LADDR_from_68k(temp68k);E 8I 8			x_68k->car_field = LADDR_from_68k(temp68k);E 10I 10		temp68k->cdr_code = (LADDR_from_68k(cdr_cell68k) & 0xff) >> 1;E 10E 8D 9			temp68k->cdr_code = (LADDR_from_68k(cdr_cell68k) E 9I 9D 10			temp68k->cdr_code = (LADDR_from_68k(cdr_cell68k)E 9			& 0xff) >> 1;E 10I 10		x_68k->cdr_code = CDR_INDIRECT;I 15#endif /* NEWCDRCODING */E 15	      }	  }      }    return(x);E 10D 10			x_68k->cdr_code = CDR_INDIRECT;		}	} } return(x);E 10I 10  }/* end of rplacd */E 10D 10}/* end of rplacd */E 10I 10E 10I 6D 7#ifdef C_ONLYE 6I 3E 7E 3/**********************************************************************//*D 7		Func name :	OP_car				car management 					Date :		Apr 15, 1987					Edited by :	Naoyuki Mitani					Changed : take 26-May-87						  take 22-Oct-87						  Take 23-Oct-87						  Take 17-Nov-87*//**********************************************************************/OP_car(){  register ConsCell *datum68k; register ConsCell *temp;#ifdef TRACE	printPC();	printf("TRACE: OP_car()\n");#endif datum68k = (ConsCell *)(Addr68k_from_LADDR(TopOfStack)); if (Listp(TopOfStack)) {	if (datum68k->cdr_code == CDR_INDIRECT)	{		temp = (ConsCell *)Addr68k_from_LADDR(datum68k->car_field);		TopOfStack = ((LispPTR)temp->car_field);	}	else 		TopOfStack = ((LispPTR)datum68k->car_field);  } else	if (TopOfStack == NIL_PTR)		goto car_ret;	else if ( TopOfStack == ATOM_T)		goto car_ret;	else	  {		ufn(1); /* call CAR.UFN */		return;	  }car_ret: PC++;} /* end of OP_car *//**********************************************************************//*		Func name :	OP_cdr				cdr management 					Date :		Apr 15, 1987					Edited by :	Naoyuki Mitani					Changed by:	Naoyuki Mitani(17-Apr)							take 26-May-87							Take 23-Oct-87*//**********************************************************************/OP_cdr(){  register ConsCell *datum68k; register DLword cdr_code; register ConsCell *temp;#ifdef TRACE	printPC();	printf("TRACE: OP_cdr()\n");#endif datum68k = (ConsCell *)(Addr68k_from_LADDR(TopOfStack)); cdr_code = datum68k->cdr_code; if (Listp(TopOfStack)) {	if (cdr_code == CDR_NIL)		/* cdr-nil */	   		TopOfStack = (NIL_PTR);	   	else if (cdr_code > CDR_ONPAGE)		/* cdr-samepage */		TopOfStack = (POINTER_PAGEBASE(TopOfStack) + 		((cdr_code & 127) << 1));	else if (cdr_code == CDR_INDIRECT)	/* cdr_code < CDR_ONPAGE */		/* cdr-indirect */		TopOfStack = (cdr ((LispPTR)(datum68k->car_field)));	else	{		/* cdr-differentpage */		temp = (ConsCell *)(Addr68k_from_LADDR		(POINTER_PAGEBASE(TopOfStack) + (cdr_code << 1)));		TopOfStack = ((LispPTR)temp->car_field);	}  } else	if (TopOfStack == NIL_PTR)		TopOfStack = NIL_PTR;	else	 {		ufn(2); /* call UFN.CDR */		return;	 }    PC++;} /* end of OP_cdr *//**********************************************************************//*		Func name :	OP_rplaca				rplaca management					Date :		Apr 26, 1987					Edited by :	Naoyuki Mitani					Changed :	take 26-May-87*//**********************************************************************/OP_rplaca(){  register LispPTR x;register  ConsCell *x_68k;register ConsCell *temp;#ifdef TRACE	printPC();	printf("TRACE: OP_rplaca()\n");#endif x = *((LispPTR *)(CurrentStackPTR)); CurrentStackPTR-=2; if (Listp(x) == NIL) {	if (x == NIL_PTR)	{		if (TopOfStack != NIL_PTR)			error("Attempt to RPLACA NIL");		else			TopOfStack = NIL_PTR;				PC++;	}	else		error("ARG not List"); } else  {	x_68k = (ConsCell *)Addr68k_from_LADDR(x);D 4	gclookup(0x8000|DELREF , car(x));	/* set up referense count */	gclookup(0x8000|ADDREF , TopOfStack);E 4I 4	GCLOOKUP(0x8000,DELREF , car(x));	/* set up reference count */	GCLOOKUP(0x8000,ADDREF , TopOfStack);E 4	if (x_68k->cdr_code == CDR_INDIRECT)	{		temp = (ConsCell *)Addr68k_from_LADDR					((LispPTR)x_68k->car_field);		temp->car_field = TopOfStack;	}	else		x_68k->car_field = TopOfStack ; 	PC++;	TopOfStack = x; }} /* end of OP_rplaca *//**********************************************************************//*		Func name :	OP_rplacd				rplacd management 					Date :		Apr 16, 1987					Edited by :	Naoyuki Mitani					Changed by:	Naoyuki Mitani(23-Apr)					Changed by:	Naoyuki Mitani(24-Apr)							take 26-May-87							take 15-Jun-87 *//**********************************************************************/OP_rplacd(){  extern struct conspage *next_conspage(); register LispPTR x; register ConsCell *x_68k;register ConsCell *temp68k; register ConsCell *cdr_cell68k; LispPTR cdr_cell; LispPTR rp_page; DLword cdr_code; register struct conspage *cons68k;#ifdef TRACE	printPC();	printf("TRACE: OP_rplacd()\n");#endif x = *((LispPTR *)(CurrentStackPTR)); CurrentStackPTR-=2; if (Listp(x) == NIL) {	if (x == NIL_PTR)	{		if (TopOfStack != NIL_PTR)			error("Attempt to RPLACD NIL");		else			TopOfStack = NIL_PTR;		}	else		error("ARG not List"); } else  {	x_68k = (ConsCell *)Addr68k_from_LADDR(x);D 4	gclookup(0x8000|DELREF , cdr(x));	/* set up referense count */	gclookup(0x8000|ADDREF , TopOfStack);E 4I 4	GCLOOKUP(0x8000,DELREF , cdr(x));	/* set up reference count */	GCLOOKUP(0x8000,ADDREF , TopOfStack);E 4	cdr_code = x_68k->cdr_code;	if (cdr_code == CDR_INDIRECT)	{		/* cdr-indirect */		rp_page = (LispPTR)x_68k->car_field;		temp68k = (ConsCell *)Addr68k_from_LADDR(rp_page);		cdr_cell = POINTER_PAGEBASE(rp_page) + 				(temp68k->cdr_code << 1);		cdr_cell68k = (ConsCell *)Addr68k_from_LADDR(cdr_cell);#ifdef DEBUG/**** Chechk for DEBUG ***/if(temp68k->cdr_code >= 0200 ||  temp68k->cdr_code == 0){		printf("temp68k->cdr_code: %x\n", temp68k->cdr_code);}/**** End Chechk for DEBUG ***/#endif		*(LispPTR *)cdr_cell68k = TopOfStack & 0xffffff;			/* cdr_code is set to 0 */	}	else if (cdr_code <= CDR_MAXINDIRECT)	{		/* cdr-differentpage */		cdr_cell = POINTER_PAGEBASE(x) + (cdr_code << 1);		cdr_cell68k = (ConsCell *)Addr68k_from_LADDR(cdr_cell);		*(LispPTR *)cdr_cell68k = TopOfStack & 0xffffff;			/* cdr_code is set to 0 */	}	else if (TopOfStack == NIL_PTR)		/* cdr-samepage & TopOfStack is nil */		x_68k->cdr_code = CDR_NIL;	else if ((rp_page = POINTER_PAGEBASE(x)) == 					POINTER_PAGEBASE(TopOfStack))		/* cdr-samepage & x and TopOfStack are on same page */		x_68k->cdr_code = CDR_ONPAGE + ((TopOfStack & 0xff) >> 1);	else	{		/* cdr-samepage & x and TopOfStack are on different page */		cons68k = (struct conspage *)Addr68k_from_LADDR(rp_page);		if (cons68k->count > 0)		{			/* at least one free-cell on x's conspage */			cdr_cell68k = GetNewCell_68k(cons68k);			cons68k->count--;			cons68k->next_cell = cdr_cell68k->cdr_code;			*(LispPTR *)cdr_cell68k = TopOfStack & 0xffffff;				/* cdr_code is set to 0 */			x_68k->cdr_code = (LADDR_from_68k(cdr_cell68k) - 			rp_page) >> 1;		}		else		{			/* no more free-cell on x's conspage */			cons68k = next_conspage();			cdr_cell68k = GetNewCell_68k(cons68k);			cons68k->next_cell = cdr_cell68k->cdr_code;			temp68k = GetNewCell_68k(cons68k);			cons68k->next_cell = temp68k->cdr_code ;			/* 15-jun-87 take*/			/* cons68k->next_cell = cdr_cell68k->cdr_code;*/			cons68k->count -= 2;						*(LispPTR *)cdr_cell68k = TopOfStack & 0xffffff;				/* cdr_code is set to 0 */			temp68k->car_field = x_68k->car_field;			(LispPTR)x_68k->car_field = LADDR_from_68k(temp68k);			temp68k->cdr_code = (LADDR_from_68k(cdr_cell68k) 			& 0xff) >> 1;			x_68k->cdr_code = CDR_INDIRECT;		}	} } PC++; TopOfStack = x;}/* end of OP_rplacd */I 3I 6#elseE 6I 6E 6/**********************************************************************//*E 7		Func name :	N_OP_carD 9				car management E 9I 9				car managementE 9					Date :		March 21, 1988					Edited by :	Robert Krivacic*//**********************************************************************/D 7LispPTR N_OP_car(tos, error_addr)E 7I 7LispPTR N_OP_car(tos)E 7	register LispPTR tos;D 7	int *error_addr;E 7D 9{ E 9I 9D 10{E 9 register ConsCell *datum68k; register ConsCell *temp;D 7#ifdef TRACE	printPC();	printf("TRACE: N_OP_car()\n");#endifE 7 datum68k = (ConsCell *)(Addr68k_from_LADDR(tos)); if (Listp(tos)) {E 10I 10  {    register ConsCell *datum68k;    register ConsCell *temp;     datum68k = (ConsCell *)(Addr68k_from_LADDR(tos));    if (Listp(tos))      {E 10	if (datum68k->cdr_code == CDR_INDIRECT)D 10	{		temp = (ConsCell *)Addr68k_from_LADDR(datum68k->car_field);		return((LispPTR) temp->car_field);	}D 9	else E 9I 9	elseE 9		return((LispPTR) datum68k->car_field);  } else	if (tos == NIL_PTR) return(tos);	else if ( tos == ATOM_T) return(tos);	elseE 10	  {D 7		ERROR_EXIT(error_addr);E 7I 7D 10		ERROR_EXIT(tos);E 10I 10	    temp = (ConsCell *)Addr68k_from_LADDR(datum68k->car_field);	    return((LispPTR) temp->car_field);E 10E 7	  }D 10} /* end of N_OP_car */E 10I 10	else return((LispPTR) datum68k->car_field);       }    else if (tos == NIL_PTR) return(tos);    else if ( tos == ATOM_T) return(tos);    else      {	ERROR_EXIT(tos);      }  } /* end of N_OP_car */E 10I 10E 10/**********************************************************************//*		Func name :	N_OP_cdrD 9				cdr management E 9I 9				cdr managementE 9					Date :		March 21, 1988					Edited by :	Robert Krivacic*//**********************************************************************/D 7LispPTR N_OP_cdr(tos, error_addr)E 7I 7LispPTR N_OP_cdr(tos)E 7D 15	register LispPTR tos;D 7	int *error_addr;E 7D 9{ E 9I 9{E 15I 15  register LispPTR tos;  {E 15E 9D 10 register ConsCell *datum68k; register DLword cdr_code; register ConsCell *temp;E 10I 10    register ConsCell *datum68k;    register DLword cdr_code;    register ConsCell *temp;E 10D 7#ifdef TRACE	printPC();	printf("TRACE: N_OP_cdr()\n");#endifE 7D 10 datum68k = (ConsCell *)(Addr68k_from_LADDR(tos)); cdr_code = datum68k->cdr_code;E 10I 10    datum68k = (ConsCell *)(Addr68k_from_LADDR(tos));    cdr_code = datum68k->cdr_code;E 10D 10 if (Listp(tos)) {D 9	if (cdr_code == CDR_NIL) 		/* cdr-nil */E 9I 9	if (cdr_code == CDR_NIL)		/* cdr-nil */E 10I 10    if (Listp(tos))      {	if (cdr_code == CDR_NIL) return(NIL_PTR);	/* cdr-nil */E 10E 9D 10		return(NIL_PTR);D 9	   E 9I 9E 10E 9	else if (cdr_code > CDR_ONPAGE)		/* cdr-samepage */I 15#ifdef NEWCDRCODING		return(tos + ((cdr_code & 7) << 1));#elseE 15D 10E 10		return(POINTER_PAGEBASE(tos) + ((cdr_code & 127) << 1));D 15E 15I 15#endif /*NEWCDRCODING */E 15	else if (cdr_code == CDR_INDIRECT)	/* cdr_code < CDR_ONPAGE */						/* cdr-indirect */D 10E 10		return(cdr ((LispPTR)(datum68k->car_field)));	elseD 10	{		/* cdr-differentpage */E 10I 10	  {	    /* cdr-differentpage */E 10I 15#ifdef NEWCDRCODINGE 15D 9		return((LispPTR) E 9I 9D 10		return((LispPTR)E 10I 10	    return((LispPTR)E 10E 9			((ConsCell *)D 9  			(Addr68k_from_LADDRE 9I 9			(Addr68k_from_LADDRI 15			(tos+(cdr_code << 1))))->car_field);#else	    return((LispPTR)			((ConsCell *)			(Addr68k_from_LADDRE 15E 9			(POINTER_PAGEBASE(tos)+(cdr_code << 1))))->car_field);I 15#endif /*NEWCDRCODING */E 15D 10	}  } else	if (tos == NIL_PTR) return(tos);	else	 {D 7		ERROR_EXIT(error_addr);E 7I 7		ERROR_EXIT(tos);E 7	 }E 10I 10	  }      }    else if (tos == NIL_PTR) return(tos);    else      {	ERROR_EXIT(tos);      }E 10D 9   E 9I 9E 9D 10} /* end of N_OP_cdr */E 10I 10  } /* end of N_OP_cdr */E 10I 10E 10/**********************************************************************//*		Func name :	N_OP_rplaca				rplaca management					Date :		March 21, 1988					Edited by :	Robert Krivacic*//**********************************************************************/D 7LispPTR N_OP_rplaca(tosm1, tos, error_addr)E 7I 7LispPTR N_OP_rplaca(tosm1, tos)E 7D 15	register LispPTR tosm1;	register LispPTR tos;D 7	int *error_addr;E 7D 9{ E 9I 9{E 9register  ConsCell *x_68k;register ConsCell *temp;E 15I 15  register LispPTR tosm1;  register LispPTR tos;  {    register  ConsCell *x_68k;    register ConsCell *temp;E 15D 7#ifdef TRACE	printPC();	printf("TRACE: OP_rplaca()\n");#endifE 7D 15 if (Listp(tosm1) == NIL) {E 15I 15    if (Listp(tosm1) == NIL)      {E 15	if (tosm1 == NIL_PTR)D 15	{D 7		if (tos != NIL_PTR) ERROR_EXIT(error_addr)E 7I 7		if (tos != NIL_PTR) ERROR_EXIT(tos)E 7		else			return(tosm1);	}	elseD 7		ERROR_EXIT(error_addr);E 7I 7		ERROR_EXIT(tos);E 7 }E 15I 15	  {	    if (tos != NIL_PTR) ERROR_EXIT(tos)	    else return(tosm1);	  }	else ERROR_EXIT(tos);      }E 15D 9 else E 9I 9D 15 elseE 9 {E 15I 15    else      {E 15	x_68k = (ConsCell *)Addr68k_from_LADDR(tosm1);D 4	gclookup(0x8000|DELREF , car(tosm1));	/* set up referense count */	gclookup(0x8000|ADDREF , tos);E 4I 4D 9	GCLOOKUP(0x8000,DELREF , car(tosm1));	/* set up reference count */	GCLOOKUP(0x8000,ADDREF , tos);E 9I 9D 13	GCLOOKUP(0x8000, DELREF, car(tosm1));	/* set up reference count */	GCLOOKUP(0x8000, ADDREF, tos);E 13I 13	GCLOOKUP(car(tosm1), DELREF);	/* set up reference count */	GCLOOKUP(tos, ADDREF);E 13E 9E 4	if (x_68k->cdr_code == CDR_INDIRECT)D 15	{		temp = (ConsCell *)Addr68k_from_LADDRE 15I 15	  {	    temp = (ConsCell *)Addr68k_from_LADDRE 15					((LispPTR)x_68k->car_field);D 15		temp->car_field = tos;	}	else		x_68k->car_field = tos ;E 15I 15	    temp->car_field = tos;	  }	else x_68k->car_field = tos ;E 15D 9 E 9I 9E 9	return(tosm1);D 15 }} /* end of N_OP_rplaca */E 15I 15      }  } /* end of N_OP_rplaca */E 15I 10E 10/**********************************************************************//*		Func name :	N_OP_rplacdD 9				rplacd management E 9I 9				rplacd managementE 9					Date :		March 21, 1988					Edited by :	Robert Krivacic*//**********************************************************************/D 7LispPTR N_OP_rplacd(tosm1, tos, error_addr)E 7I 7LispPTR N_OP_rplacd(tosm1, tos)E 7D 15	register LispPTR tosm1, tos;D 7	int *error_addr;E 7D 9{ E 9I 9{E 9D 12 extern struct conspage *next_conspage();E 12 register ConsCell *x_68k; register ConsCell *temp68k; register ConsCell *cdr_cell68k; LispPTR cdr_cell; LispPTR rp_page; DLword cdr_code; register struct conspage *cons68k;E 15I 15  register LispPTR tosm1, tos;  {E 15D 7#ifdef TRACE	printPC();	printf("TRACE: OP_rplacd()\n");#endifE 7D 15 if (Listp(tosm1) == NIL) {E 15I 15    if (Listp(tosm1) == NIL)      {E 15	if (tosm1 == NIL_PTR)D 15	{D 9		if (tos != NIL_PTR) E 9I 9		if (tos != NIL_PTR)E 9D 7			ERROR_EXIT(error_addr)E 7I 7			ERROR_EXIT(tos)E 7D 9		else 			return(tosm1);	E 9I 9		else			return(tosm1);E 9	}	elseD 7		ERROR_EXIT(error_addr);E 7I 7		ERROR_EXIT(tos);E 7 }E 15I 15	  {	    if (tos != NIL_PTR) ERROR_EXIT(tos)	    else return(tosm1);	  }	else ERROR_EXIT(tos);      }E 15D 9 else E 9I 9D 15 elseE 9 {	x_68k = (ConsCell *)Addr68k_from_LADDR(tosm1);E 15I 15    else rplacd(tosm1, tos);E 15D 4	gclookup(0x8000|DELREF , cdr(tosm1));	/* set up referense count */	gclookup(0x8000|ADDREF , tos);E 4I 4D 9	GCLOOKUP(0x8000,DELREF , cdr(tosm1));	/* set up reference count */	GCLOOKUP(0x8000,ADDREF , tos);E 9I 9D 13	GCLOOKUP(0x8000, DELREF, cdr(tosm1));	/* set up reference count */	GCLOOKUP(0x8000, ADDREF, tos);E 13I 13D 15	GCLOOKUP(cdr(tosm1), DELREF);	/* set up reference count */	GCLOOKUP(tos, ADDREF);E 15I 15    return(tosm1);E 15E 13E 9E 4D 15	cdr_code = x_68k->cdr_code;E 15I 15  }/* end of N_OP_rplacd */E 15D 15	if (cdr_code == CDR_INDIRECT)	{		/* cdr-indirect */E 15D 15		rp_page = (LispPTR)x_68k->car_field;		temp68k = (ConsCell *)Addr68k_from_LADDR(rp_page);D 9		cdr_cell = POINTER_PAGEBASE(rp_page) + E 9I 9		cdr_cell = POINTER_PAGEBASE(rp_page) +E 9				(temp68k->cdr_code << 1);		cdr_cell68k = (ConsCell *)Addr68k_from_LADDR(cdr_cell);#ifdef DEBUG/**** Chechk for DEBUG ***/if(temp68k->cdr_code >= 0200 ||  temp68k->cdr_code == 0){		printf("temp68k->cdr_code: %x\n", temp68k->cdr_code);}/**** End Chechk for DEBUG ***/#endif		*(LispPTR *)cdr_cell68k = tos & 0xffffff;			/* cdr_code is set to 0 */E 15D 15	}	else if (cdr_code <= CDR_MAXINDIRECT)	{		/* cdr-differentpage */E 15I 15/************************************************************************//*									*//*			f i n d _ c l o s e _ c e l l			*//*									*//*	Given the real address of a CONS page and an existing cell	*//*	on that page, return another cell that is close enough to	*//*	be used as the CDR of the existing cell (i.e., within 7		*//*	cells.  If no such cell exists, return 0.			*//*									*//*	If a cell is found, it is taken off the free chain before	*//*	being returned.							*//*									*//************************************************************************/E 15D 15		cdr_cell = POINTER_PAGEBASE(tosm1) + (cdr_code << 1);		cdr_cell68k = (ConsCell *)Addr68k_from_LADDR(cdr_cell);		*(LispPTR *)cdr_cell68k = tos & 0xffffff;			/* cdr_code is set to 0 */E 15I 15ConsCell * find_close_cell(page, oldcell)  struct conspage * page;  LispPTR oldcell;  {    unsigned oldoffset = oldcell & 0xFF;    unsigned offset = page->next_cell;    unsigned prior = 0;E 15D 15	}	else if (tos == NIL_PTR)		/* cdr-samepage & tos is nil */		x_68k->cdr_code = CDR_NIL;E 15I 15    while (offset)      {	if ((offset > oldoffset) && (offset <= (oldoffset+14)))	  {	    if (prior)	      ((freecons *) ((DLword *)page + prior))->next_free		= ((freecons *) ((DLword *)page + offset))->next_free;	    else page->next_cell		   = ((freecons *) ((DLword *)page + offset))->next_free;	    page->count -= 1;	    return(ConsCell *)((DLword *)page + offset);	  }E 15D 9	else if ((rp_page = POINTER_PAGEBASE(tosm1)) == E 9I 9D 15	else if ((rp_page = POINTER_PAGEBASE(tosm1)) ==E 9					POINTER_PAGEBASE(tos))		/* cdr-samepage & tosm1 and tos are on same page */		x_68k->cdr_code = CDR_ONPAGE + ((tos & 0xff) >> 1);E 15I 15	prior = offset;	offset = ((freecons *) ((DLword *)page + offset))->next_free;      }    return((ConsCell *)0);	/* No cell close enough */  }E 15D 15	else	{		/* cdr-samepage & tosm1 and tos are on different page */E 15D 15		cons68k = (struct conspage *)Addr68k_from_LADDR(rp_page);		if (cons68k->count > 0)		{			/* at least one free-cell on tosm1's conspage */			cdr_cell68k = GetNewCell_68k(cons68k);			cons68k->count--;			cons68k->next_cell = cdr_cell68k->cdr_code;E 15D 15			*(LispPTR *)cdr_cell68k = tos & 0xffffff;				/* cdr_code is set to 0 */E 15I 15/************************************************************************//*									*//*	        f i n d _ c l o s e _ p r i o r _ c e l l		*//*									*//*	Given the real address of a CONS page and an existing cell	*//*	on that page, return another cell that is close enough to	*//*	that the existing cell can be its CDR (i.e. up to 7 cells	*//*	earlier.  If no such cell exists, return 0.			*//*									*//*	If a cell is found, it is taken off the free chain before	*//*	being returned.							*//*									*//************************************************************************/E 15D 9			x_68k->cdr_code = (LADDR_from_68k(cdr_cell68k) - E 9I 9D 15			x_68k->cdr_code = (LADDR_from_68k(cdr_cell68k) -E 9			rp_page) >> 1;		}		else		{			/* no more free-cell on x's conspage */E 15I 15ConsCell * find_close_prior_cell(page, oldcell)  struct conspage * page;  LispPTR oldcell;  {    unsigned oldoffset = oldcell & 0xFF;    unsigned offset = page->next_cell;    unsigned prior = 0;    ConsCell *cell;E 15D 15			cons68k = next_conspage();E 15I 15    while (offset)      {	if ((offset < oldoffset) && (offset >= (oldoffset-14)))	  {		cell = (ConsCell *)((DLword *)page + offset);	    if (prior)	      ((freecons *) ((DLword *)page + prior))->next_free		= ((freecons *) cell)->next_free;	    else page->next_cell		   = ((freecons *) cell)->next_free;	    page->count -= 1;		cell->cdr_code = CDR_ONPAGE | ((oldoffset - offset)>>1);		if (254 < (offset + ((cell->cdr_code&7)<<1))) error("in fcpc, page overflow.");	    return(cell);	  }E 15D 15			cdr_cell68k = GetNewCell_68k(cons68k);			cons68k->next_cell = cdr_cell68k->cdr_code;E 15I 15	prior = offset;	offset = ((freecons *) ((DLword *)page + offset))->next_free;      }    return((ConsCell *)0);	/* No cell close enough */  }E 15D 15			temp68k = GetNewCell_68k(cons68k);			cons68k->next_cell = temp68k->cdr_code ;			cons68k->count -= 2;E 15D 9			E 9I 9E 9D 15			*(LispPTR *)cdr_cell68k = tos & 0xffffff;				/* cdr_code is set to 0 */E 15D 15			temp68k->car_field = x_68k->car_field;D 8			(LispPTR)x_68k->car_field = LADDR_from_68k(temp68k);E 8I 8			x_68k->car_field = LADDR_from_68k(temp68k);E 15E 8D 9			temp68k->cdr_code = (LADDR_from_68k(cdr_cell68k) E 9I 9D 15			temp68k->cdr_code = (LADDR_from_68k(cdr_cell68k)E 9			& 0xff) >> 1;E 15I 15/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 15D 15			x_68k->cdr_code = CDR_INDIRECT;		}	} } return(tosm1);E 15I 15ConsCell *find_cdrpair_in_page(pg, carpart, cdrpart)  struct conspage *pg;  LispPTR carpart, cdrpart;  {    ConsCell *cell;	unsigned offset, prior, priorprior;E 15D 15}/* end of N_OP_rplacd */E 15I 15	prior = priorprior = 0;E 15I 15	if (pg->count < 2) return (ConsCell * ) 0;E 15I 15	offset = pg->next_cell;E 15I 15	while (offset)	  {	if (prior && (offset < prior) && (prior <= offset+14))	 { 	   ConsCell *carcell, *cdrcell;	   carcell = (ConsCell *) (((DLword *)pg) + offset);	   cdrcell = (ConsCell *) (((DLword *)pg) + prior);	   if (priorprior)		 FREECONS(pg, priorprior)->next_free = ((freecons *)carcell)->next_free;	   else pg->next_cell = ((freecons *)carcell)->next_free;	   pg->count -= 2;	    *(LispPTR *)carcell = carpart;		*(LispPTR *)cdrcell = cdrpart;		carcell->cdr_code = (cdrcell-carcell);		return(carcell);	  }	priorprior = prior;	prior = offset;	offset = FREECONS(pg, offset)->next_free;      }  }/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/ConsCell *find_cdrable_pair(carpart, cdrpart)  LispPTR carpart, cdrpart;  {    unsigned offset, prior, priorprior, pgno;	struct conspage *pg;    ConsCell *cell;	for ( pg = (struct conspage *)Addr68k_from_LPAGE(pgno = ListpDTD->dtd_nextpage);          pgno; pg = (struct conspage *)Addr68k_from_LPAGE(pgno = pg->next_page))      {	if (cell = find_cdrpair_in_page(pg, carpart, cdrpart)) return (cell);	  }    return (find_cdrpair_in_page(next_conspage(), carpart, cdrpart));  }E 15I 6D 7#endifE 7E 6E 3E 1