h55214s 00000/00000/00168d D 1.6 90/04/20 01:45:24 sybalsky 6 5c AIX:  shortening file names, bulk change.es 00073/00062/00095d D 1.5 89/12/28 15:26:18 sybalsky 5 4c es 00002/00000/00155d D 1.4 88/10/06 16:42:10 krivacic 4 3c add SCCS stringes 00001/00000/00154d D 1.3 88/09/30 17:47:12 sye 3 2c es 00014/00018/00140d D 1.2 88/05/20 18:41:29 sye 2 1c noes 00158/00000/00000d D 1.1 88/05/17 17:43:17 sye 1 0c date and time created 88/05/17 17:43:17 by syeeuUtTI 4/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";I 5/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medlet.		*//*									*//************************************************************************/E 5E 4I 1D 2/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 2/* =========================================================================	The functions defined in this file are used to validate the copyright	protection keys for NewCo's Maiko software. The main function is	'keytester', which takes an input key string and returns a statusD 2	code after processing it.E 2I 2	code after processing the keys.E 2		The external functions called were stored in file 'keylib.o'.	Creation date: May, 1988  ====================================================================== */#include <stdio.h>#include <string.h>#include <ctype.h>#define	GOLDEN_RATIO_HACK			-478700649#define	floadbyte(number,pos)		((number >> pos) & 0xFFFF)#define	hash_unhash(number,hashkey)	(number ^ (GOLDEN_RATIO_HACK * (floadbyte(hashkey,16) + floadbyte(hashkey,0)) ))#define	KEYNUMBERS					3#define	RC0						0D 2/*   meaning of the symbolic constants used:		FAILURE1	invalid hostid 		FAILURE2	invalid date entered from terminal E 2I 2/*   meaning of symbolic constants used: 		FAILURE2	invalid dateE 2		FAILURE3	invalid key 		FAILURE4	key expired           D 2		FAILURE99	invalid date  (* this shouldn't happen unless string format returned by ctime got changed ) */E 2I 2		FAILURE99	invalid date  (this shouldn't happen unless string format returned by ctime got changed) */E 2D 2#define	FAILURE1					-1E 2#define	FAILURE2					-2#define	FAILURE3					-3#define	FAILURE4					-4#define 	FAILURE99					-99unsigned long make_verification();unsigned long date_integer16();unsigned long idate();unsigned long modify();/* =====================================================================	KEYTESTER checks the input key string.  D 2     It returns 0 if the keys are valid, otherwidw it returns non-0.E 2I 2     It returns 0 if the keys are valid, otherwise it returns non-0.E 2  ====================================================================== */int keytester(keystring) char *keystring;D 5 {	unsigned long	keyarray[KEYNUMBERS];	/* array which holds numeric keys */	unsigned long	hostid ;				/* 32-bit unique identifier of the current host  */	unsigned long	hashedword;D 2	int			rc;					/* returned code */E 2I 2	int			rc;					/* return code */E 5I 5  {    unsigned long keyarray[KEYNUMBERS];	/* array which holds numeric keys */    unsigned long	hostid ;	/* 32-bit unique identifier of the current host  */    unsigned long	hashedword;    int			rc;		/* return code */E 5E 2	/* check the keys and convert them from hexdecimal strings to numbers  */I 3D 5      if (keystring == NULL) return FAILURE3;E 3	if ( read_hex(keystring , keyarray) == FAILURE3)  return FAILURE3 ;E 5I 5    if (keystring == NULL) return FAILURE3;    if ( read_hex(keystring , keyarray) == FAILURE3)  return FAILURE3 ;E 5D 5	/*  get machines host id  */	hostid = gethostid();	hostid = modify(hostid);E 5I 5    /*  get machines host id  */    hostid = gethostid();    hostid = modify(hostid);E 5D 5	/*  generate hashword */	hashedword = hash_unhash(keyarray[1] , hostid);E 5I 5    /*  generate hashword */    hashedword = hash_unhash(keyarray[1] , hostid);E 5	D 5	/*  validate keys	*/	if (keyarray[0] != hash_unhash(hostid , hostid))  return FAILURE3; 	if ((rc = ok_date(floadbyte(hashedword , 16))) != RC0) return rc;	if (keyarray[2] != make_verification(keyarray[0] , keyarray[1])) return FAILURE3;E 5I 5    /*  validate keys	*/    if (keyarray[0] != hash_unhash(hostid , hostid))  return FAILURE3;     if ((rc = ok_date(floadbyte(hashedword , 16))) != RC0) return rc;    if (keyarray[2] != make_verification(keyarray[0] , keyarray[1]))      return FAILURE3;E 5	D 5	return 0;   }E 5I 5    return 0;    }E 5/* =====================================================================	READ_HEX reads in keys from the input string , validates them, then  D 2     store the numbers in the input array.E 2I 2     stores them in the input array.E 2  ====================================================================== */int read_hex(s1 , array)D 5	char 			*s1 ;	unsigned long 	*array ; {	char *s2 = {" "};	char *ptr;	char *hexdigits = {"0123456789abcdefABCDEF"};	int i ;E 5I 5  char 			*s1 ;  unsigned long 	*array ;  {    char *s2 = {" "};    char *ptr;    char *hexdigits = {"0123456789abcdefABCDEF"};    int i ;E 5	D 5	for (i = 0 ; (i < KEYNUMBERS) && ((ptr = strtok(s1 , s2)) != NULL) ; ++i)	  {E 5I 5    for (i = 0 ; (i < KEYNUMBERS) && ((ptr = strtok(s1 , s2)) != NULL) ; ++i)      {E 5D 5		/* make sure the key contains only hexadecimal characters */		if ( (strspn (ptr,hexdigits)) != strlen(ptr)) return FAILURE3;E 5I 5	/* make sure the key contains only hexadecimal characters */	if ( (strspn (ptr,hexdigits)) != strlen(ptr)) return FAILURE3;E 5D 5		/* convert key to numeric format*/		*(array + i) = strtol(ptr,NULL,16);E 5I 5	/* convert key to numeric format*/	*(array + i) = strtol(ptr,NULL,16);E 5D 5		/* continue search the next one */		s1 = NULL;	  };E 5I 5	/* continue search the next one */	s1 = NULL;      };E 5D 5	if (i == KEYNUMBERS) return RC0; 	    else return FAILURE3;E 5I 5    if (i == KEYNUMBERS) return RC0;       else return FAILURE3;E 5  }/* ============================================	OK_DATE checks the expiration of the key   ============================================ */int ok_date (date)D 5	unsigned long date ; {	char current_date[30];	char *mptr, *dptr, *yptr, *str;	long realtime , *clock;E 5I 5  unsigned long date ;  {    char current_date[30];    char *mptr, *dptr, *yptr, *str;    long realtime , *clock;E 5D 2	/* if no need to check expiradation date, return right away */E 2I 2D 5	/* first check if the expiration date is set to indefinite */E 5I 5    /* first check if the expiration date is set to indefinite */E 5E 2D 2	/* printf("\narg date: %ld  %x\n", date, date); */	/* printf("\narg date ?????: %ld  %x\n", date_integer16("25-DEC-87"), date_integer16("25-DEC-87")); */E 2I 2D 5		 /* printf("\narg date: %ld  %x\n", date, date); */		 /* printf("\narg date ?????: %ld  %x\n", date_integer16("29-DEC-77"), date_integer16("29-DEC-77")); */E 5I 5     /* printf("\narg date: %ld  %x\n", date, date); */     /* printf("\narg date ?????: %ld  %x\n", date_integer16("29-DEC-77"), date_integer16("29-DEC-77")); */E 5E 2D 5	if  (date == date_integer16("29-DEC-77")) return RC0;E 5I 5    if  (date == date_integer16("29-DEC-77")) return RC0;E 5D 2	/* otherwise check if current date is less than the expiration date */E 2I 2D 5	/* next check if current date is less than or equal to the expiration date */E 2	/* get the current date  string */E 5I 5    /* next check if current date is less than or equal to the expiration date */    /* get the current date  string */E 5	realtime = time(0);	clock = &realtime;	str =  (char *) ctime(clock);D 2	/* delete day and time info and rearray the format to be dd-mmm-yy */E 2I 2	/* delete day and time info and rearrange the string format to be dd-mmm-yy */E 2D 5	mptr = strtok(str," ");	mptr = strtok(NULL," ");	dptr = strtok(NULL," ");	yptr = strtok(NULL," ");	yptr = strtok(NULL," \n");		/* watch out for newline char */	current_date[0] = '\0';	strcat(current_date , dptr);	strcat(current_date , "-");	strcat(current_date , mptr);	strcat(current_date , "-");	strcat(current_date , yptr);E 5I 5    mptr = strtok(str," ");    mptr = strtok(NULL," ");    dptr = strtok(NULL," ");    yptr = strtok(NULL," ");    yptr = strtok(NULL," \n");		/* watch out for newline char */    current_date[0] = '\0';    strcat(current_date , dptr);    strcat(current_date , "-");    strcat(current_date , mptr);    strcat(current_date , "-");    strcat(current_date , yptr);E 5D 5	/* check the date */	if (idate(current_date) == FAILURE2) return FAILURE99;E 5I 5    /* check the date */    if (idate(current_date) == FAILURE2) return FAILURE99;E 5	D 2	/* printf("*current date*: %ld %x\n", date_integer16(current_date), date_integer16(current_date)); */E 2I 2D 5		/* printf("*current date*: %ld %x\n", date_integer16(current_date), date_integer16(current_date)); */E 5I 5    /* printf("*current date*: %ld %x\n", date_integer16(current_date), date_integer16(current_date)); */E 5E 2D 5	return (date_integer16(current_date) <= date ) ? RC0 : FAILURE4;E 5I 5    return (date_integer16(current_date) <= date ) ? RC0 : FAILURE4;E 5 }E 1