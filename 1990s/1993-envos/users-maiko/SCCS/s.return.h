h30817s 00011/00004/00106d D 2.10 93/02/08 15:05:30 sybalsky 11 10c Big VM (and new CDR coding) changes for 3.0 \nes 00005/00002/00105d D 2.9 92/11/25 20:21:32 sybalsky 10 9c Fixing extra text in endifs => comment.\nes 00026/00007/00081d D 2.8 92/05/27 19:15:31 sybalsky 9 8c retrofit of 386 unix changes \nes 00000/00000/00088d D 2.7 92/04/21 16:35:01 sybalsky 8 7c shortening file names for DOSes 00045/00031/00043d D 2.6 90/06/06 13:34:07 sybalsky 7 6c Reformat code, make it work with new S_CHECK macroes 00019/00001/00055d D 2.5 90/06/04 14:46:37 sybalsky 6 5c reformat, copyrightes 00002/00002/00054d D 2.4 89/03/30 11:03:41 sybalsky 5 4c Word pointer fixupses 00007/00007/00049d D 2.3 89/03/23 12:57:01 sybalsky 4 3c Added byte-swapped defses 00001/00003/00055d D 2.2 88/05/31 20:31:47 masinter 3 2c remove obsolete StkLimO referenceses 00000/00000/00058d D 2.1 88/05/17 10:07:05 hayata 2 1c Version up to 2.1es 00058/00000/00000d D 1.1 88/05/11 12:08:55 shimizu 1 0c date and time created 88/05/11 12:08:55 by shimizueuUtTI 1D 5/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 5I 5D 6/* This is G-file @(#) return.h Version 2.3 (3/23/89). copyright Xerox & Fuji Xerox  */E 6I 6D 9/* This is G-file @(#) return.h Version 2.3 (3/23/89). copyright Venue & Fuji Xerox  */E 9I 9D 10/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 10I 10/* %Z% %M% Version %I% (%G%). copyright Venue   */E 10E 9E 6E 5/**************************************************************//*	File Name : 	return.h	Desc. :		Macros for return,contextsw	Written by :	Takeshi Shimizu			11-May-88*//**************************************************************/I 6/************************************************************************//*									*/D 9/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 9I 9/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 9/*									*/D 9/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 9I 9/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 9/*									*//************************************************************************/I 11#ifdef BIGVM#define FX_FNHEADER CURRENTFX->fnheader#else#define FX_FNHEADER (CURRENTFX->hi2fnheader << 16) | CURRENTFX->lofnheader#endif /* BIGVM */E 11D 9E 9E 6/* FAST case return use */I 6D 9E 9I 9#ifndef ISCE 9E 6D 7#define FastRetCALL {							\	/* Get IVar from Retunee's IVAR offset slot(BF) */ 		\D 5	IVar = Addr68k_from_LADDR(STK_OFFSET | *((DLword *)CURRENTFX -1)); \E 5I 5	IVar = Addr68k_from_LADDR(STK_OFFSET | GETWORD((DLword *)CURRENTFX -1)); \E 5	/* Get FuncObj from Retunee's FNHEAD slot in FX */ 		\	FuncObj = (struct fnhead *)Addr68k_from_LADDR((CURRENTFX->hi2fnheader <<16) | CURRENTFX->lofnheader);						\	/* Get PC from Retunee's pc slot in FX */ 			\	PC = (ByteCode *)FuncObj + CURRENTFX->pc ; }E 7I 7#define FastRetCALL							\  {									\    /* Get IVar from Retunee's IVAR offset slot(BF) */ 			\    IVar = Addr68k_from_LADDR(STK_OFFSET | GETWORD((DLword *)CURRENTFX -1)); \    /* Get FuncObj from Retunee's FNHEAD slot in FX */ 			\    FuncObj = (struct fnhead *)						\D 11		Addr68k_from_LADDR((CURRENTFX->hi2fnheader <<16)	\					| CURRENTFX->lofnheader);	\E 11I 11		Addr68k_from_LADDR(FX_FNHEADER);	\E 11    /* Get PC from Retunee's pc slot in FX */ 				\    PC = (ByteCode *)FuncObj + CURRENTFX->pc ; 				\  }E 7D 9E 9I 9#else#define FastRetCALL							\  {									\    /* Get IVar from Retunee's IVAR offset slot(BF) */ 			\    IVar = Addr68k_from_LADDR(STK_OFFSET | GETWORD((DLword *)CURRENTFX -1)); \    /* Get FuncObj from Retunee's FNHEAD slot in FX */ 			\    FuncObj = (struct fnhead *)						\D 11		Addr68k_from_LADDR((CURRENTFX->hi2fnheader <<16)	\					| CURRENTFX->lofnheader);	\E 11I 11		Addr68k_from_LADDR(FX_FNHEADER);	\E 11    /* Get PC from Retunee's pc slot in FX */ 				\    PC = (ByteCode *)FuncObj + CURRENTFX->pc ; 				\    if (!(FuncObj->byteswapped))					\      {								\	byte_swap_code_block(FuncObj);				\	FuncObj->byteswapped = 1;				\      }								\  }D 10#endif ISCE 10I 10#endif /* ISC */E 10E 9I 6E 6/** in CONTEXTSW , for exchanging context **/I 6E 6#define Midpunt(fxnum) 							\D 7	{register DLword midpunt; 					\	midpunt = LOLOC(LADDR_from_68k(CURRENTFX));			\	PVar=(DLword *)							\		Addr68k_from_StkOffset(					\D 4			(*(((DLword *)InterfacePage) +fxnum)))		\E 4I 4			(GETWORD(((DLword *)InterfacePage) +fxnum)))		\E 7I 7  { register DLword midpunt; 					\    midpunt = LOLOC(LADDR_from_68k(CURRENTFX));			\    PVar=(DLword *)							\	    Addr68k_from_StkOffset(					\			(GETWORD(((DLword *)InterfacePage) +fxnum)))	\E 7E 4		+ FRAMESIZE; 						\D 4	*(((DLword *)InterfacePage) +fxnum) = midpunt ;}E 4I 4D 7	GETWORD(((DLword *)InterfacePage) +fxnum) = midpunt ;}E 7I 7    GETWORD(((DLword *)InterfacePage) +fxnum) = midpunt ;		\  }E 7E 4#define CHECKFX							\D 7	if (((int)PVar -(int)CURRENTFX) != 20)			\		{ printf("Invalid FX(0x%x) and PV(0x%x) \n",LADDR_from_68k(CURRENTFX),LADDR_from_68k(PVar));}E 7I 7  if (((int)PVar -(int)CURRENTFX) != 20)			\    { printf("Invalid FX(0x%x) and PV(0x%x) \n",		\	     LADDR_from_68k(CURRENTFX),LADDR_from_68k(PVar));	\    }E 7I 6E 6/**** Calls when invoke the function is assumed	that it is called by CONTEXTSW in orginal LISP code **/I 6E 6D 7#define BEFORE_CONTEXTSW	{ CurrentStackPTR += 2; \ 				CURRENTFX->nextblock=StkOffset_from_68K(CurrentStackPTR); \D 4				 *(CurrentStackPTR)=STK_FSB_WORD; \				 *(CurrentStackPTR+1)= (((int)EndSTKP-(int)(CurrentStackPTR))>>1); }E 4I 4				 GETWORD(CurrentStackPTR)=STK_FSB_WORD; \				 GETWORD(CurrentStackPTR+1)= (((int)EndSTKP-(int)(CurrentStackPTR))>>1); }E 4#define AFTER_CONTEXTSW		{ register DLword *ptr68k,*freeptr; \		ptr68k = (DLword*)Addr68k_from_StkOffset(CURRENTFX->nextblock);\D 4		 if(*ptr68k != STK_FSB_WORD) error("pre_moveframe: MP9316");\E 4I 4		 if(GETWORD(ptr68k) != STK_FSB_WORD) error("pre_moveframe: MP9316");\E 4		 CHECK_FX(CURRENTFX);\ 		freeptr=ptr68k;\D 4  		while(*freeptr == STK_FSB_WORD)  \			EndSTKP=freeptr=freeptr+  *(freeptr+1);\E 4I 4  		while(GETWORD(freeptr) == STK_FSB_WORD)  \			EndSTKP=freeptr=freeptr+  GETWORD(freeptr+1);\E 4D 3		StkLimO = EndSTKP - STKLIMOFFSET ;\		 S_CHECK(ptr68k < StkLimO);\E 3		 S_CHECK(CURRENTFX->incall== NIL);\ 		S_CHECK(CURRENTFX->nopush== NIL);\		CurrentStackPTR = ptr68k- 2 ;\		CHECK_FX(CURRENTFX);\D 3		S_CHECK( EndSTKP>= CurrentStackPTR) ; }E 3I 3		S_CHECK( EndSTKP > CurrentStackPTR) ; }E 7I 7#define BEFORE_CONTEXTSW						\  { CurrentStackPTR += 2; 						\    CURRENTFX->nextblock=StkOffset_from_68K(CurrentStackPTR); 		\    GETWORD(CurrentStackPTR)=STK_FSB_WORD; 				\    GETWORD(CurrentStackPTR+1)= (((int)EndSTKP-(int)(CurrentStackPTR))>>1); \  }#define AFTER_CONTEXTSW							\  { register DLword *ptr68k,*freeptr;					\    ptr68k = (DLword*)Addr68k_from_StkOffset(CURRENTFX->nextblock);	\    if(GETWORD(ptr68k) != STK_FSB_WORD) error("pre_moveframe: MP9316");	\    CHECK_FX(CURRENTFX);						\    freeptr=ptr68k;							\    while(GETWORD(freeptr) == STK_FSB_WORD)  				\      EndSTKP=freeptr=freeptr+  GETWORD(freeptr+1);			\    S_CHECK(CURRENTFX->incall== NIL, "CONTEXTSW during fn call");	\    S_CHECK(CURRENTFX->nopush== NIL, "CONTEXTSW, NOPUSH is set");	\    CurrentStackPTR = ptr68k- 2 ;					\    CHECK_FX(CURRENTFX);						\    S_CHECK( EndSTKP > CurrentStackPTR, 				\		"End of stack isn't beyond current stk pointer."); 	\  }E 7E 3E 1