h16284s 00053/00051/00129d D 1.3 93/02/08 14:53:19 sybalsky 3 2c Big VM (and new CDR coding) changes for 3.0 \nes 00013/00003/00167d D 1.2 92/04/22 14:51:38 sybalsky 2 1c fix sccses 00170/00000/00000d D 1.1 92/04/21 15:28:39 sybalsky 1 0c date and time created 92/04/21 15:28:39 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";D 2/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 2I 2/************************************************************************//*									*//*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************/E 2D 3/*************************************************************************//*************************************************************************/D 2/*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 */E 2/*************************************************************************/E 3I 3/*                                                                      *//*                       File Name : gcr.c				*/E 3/*                                                                       */D 3/*                       File Name : gcr.c                         *//*                                                                       */E 3/*************************************************************************//*                                                                       *//*                      Creation Date : Oct-12-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*           Functions : gcarrangementstack()                            *//*			 doreclaim();                                    *//*                       dogc01();                                       *//*                       disablegc1(noerror);                            *//*                                                                       *//*************************************************************************//*           Description :						 *//* This files' functions is the invocator that may invoke the reclaimer. *//*  gcarrangementstack()						 *//*	This function's role is  narrowing the gap between the		 *//*      contextswitch and the subrcall.					 *//*	In the original Lisp Source, as the contextswitch process may    *//*	clear the remain area to FSB,there is no problem in scannig stack*//*	.But in the subrcall,there isn't such process.			 *//*	Therefore, the function is required to set the remain stack area *//*	 to FSB. And this function does so.				 *//*  dogc01()								 *//*	This function is the mere caller of the reclaimer.		 *//*	The callees are gcscanstack(), gcmapscan() and gcunmapscan().    *//*  doreclaim()								 *//*	This function is the real top level function of the reclaimer.   *//*	But currently this function is not used(may be used in Future.)  *//*	This function may have a problem. It is to manipulate "clock"    *//*	for keeping the GC's time period.				 *//*   disablegc1(noerror)/*      This function is the rescue function,when the HTcoll table is    *//*      overflow and so on.After this function's process is over, the    *//*      keyhandler will sense the interrupt table state and call the     *//*      function \DOGCDISABLEDINTERRUPT for reporting to Users that      *//*      this system status is dangerous and you should save your works.  *//*                                                                       *//*************************************************************************//*                                                               \tomtom *//*************************************************************************/#include "lispemul.h"#include "lispmap.h"#include "emlglob.h"#include "lsptypes.h"#include "address.h"#include "adr68k.h"#include "lspglob.h"#include "stack.h"#include "gc.h"#define MAXSMALLP		65535#define HTBIGENTRYSIZE		4#define WORDSPERPAGE		256#define WORDSPERCELL		2#define MAXTYPENUMBER		INIT_TYPENUM#define STK_HI			1#ifndef BYTESWAP   struct interruptstate {      unsigned nil1             :3;        unsigned gcdisabled       :1;	unsigned vmemfull         :1;	unsigned stackoverflow    :1;	unsigned storagefull      :1;	unsigned waitinginterrupt :1;	unsigned nil2             :8;	DLword   intcharcode;	};#else   struct interruptstate {	DLword   intcharcode;	unsigned nil2             :8;	unsigned waitinginterrupt :1;	unsigned storagefull      :1;	unsigned stackoverflow    :1;	unsigned vmemfull         :1;        unsigned gcdisabled       :1;	unsigned nil1             :3;	};D 3#endif BYTESWAPE 3I 3#endif /* BYTESWAP */E 3I 3E 3gcarrangementstack(){  LispPTR tmpnextblock;	PushCStack;	tmpnextblock = LADDR_from_68k(CurrentStackPTR+=WORDSPERCELL);	CURRENTFX->nextblock = LOLOC(tmpnextblock);  GETWORD(CurrentStackPTR)=STK_FSB_WORD;  GETWORD(CurrentStackPTR+1)=(((int)EndSTKP-(int)CurrentStackPTR)>>1);}/****************************************************************//* The following function is the caller that is the reclaimer.  *//* And, this function is same as \DOGC1 in Lisp because in the  *//* C's implimentation the contextswitch is not required for the *//* remaining the system status.					*//****************************************************************/dogc01()D 3{ gcarrangementstack(); gcscanstack(); gcmapscan(); gcmapunscan(); PopCStack; return(NIL);}E 3I 3  {    gcarrangementstack();    gcscanstack();    gcmapscan();    gcmapunscan();    PopCStack;    return(NIL);  }E 3/*!!!!!! should update clock in Miscstats */doreclaim()D 3{int gctm1; MISCSTATS gcmisc;E 3I 3  {    int gctm1;    MISCSTATS gcmisc;E 3D 3   if (*GcDisabled_word == NIL)	{update_miscstats();	 gcmisc = *((MISCSTATS *)MiscStats);	 *Reclaim_cnt_word = NIL;	 if (*GcMess_word != NIL)		flip_cursor();	 dogc01();	 if (*GcMess_word != NIL)		flip_cursor();	 *Reclaim_cnt_word = *ReclaimMin_word;	 update_miscstats();	 MiscStats->gctime = MiscStats->gctime +			MiscStats->totaltime - gcmisc.totaltime +			MiscStats->swapwaittime - gcmisc.swapwaittime;	};}E 3I 3    if (*GcDisabled_word == NIL)      {	update_miscstats();	gcmisc = *((MISCSTATS *)MiscStats);	*Reclaim_cnt_word = NIL;	if (*GcMess_word != NIL) flip_cursor();	dogc01();	if (*GcMess_word != NIL) flip_cursor();	*Reclaim_cnt_word = *ReclaimMin_word;	update_miscstats();	MiscStats->gctime = MiscStats->gctime +		MiscStats->totaltime - gcmisc.totaltime +		MiscStats->swapwaittime - gcmisc.swapwaittime;      }  }E 3I 3E 3disablegc1(noerror)D 3int       noerror;{ struct interruptstate *gcinterruptstate;  int                   count, i;  DLword                typeword;  gcinterruptstate = (struct interruptstate *)E 3I 3  int noerror;  {    struct interruptstate *gcinterruptstate;    int                   count, i;    DLword                typeword;    gcinterruptstate = (struct interruptstate *)E 3			Addr68k_from_LADDR(*INTERRUPTSTATE_word);D 3  count = (128)*256; /* This is test value. 128 is *MdsTTsize(\MDSTTsize) */  for(i = 0;i < count;i++)    {typeword = GETWORD((DLword *)Addr68k_from_LADDR(LADDR_from_68k(MDStypetbl)+i));     GETWORD((DLword *)Addr68k_from_LADDR(LADDR_from_68k(MDStypetbl)+i) )E 3I 3    count = (128)*256; /* This is test value. 128 is *MdsTTsize(\MDSTTsize) */    for(i = 0;i < count;i++)      {	typeword = GETWORD((DLword *)Addr68k_from_LADDR(LADDR_from_68k(MDStypetbl)+i));	GETWORD((DLword *)Addr68k_from_LADDR(LADDR_from_68k(MDStypetbl)+i) )E 3                 = (typeword | TT_NOREF);D 3   };  *Reclaim_cnt_word = NIL;  *ReclaimMin_word  = NIL;  if ((noerror == NIL) && (*GcDisabled_word == NIL))    { gcinterruptstate->gcdisabled = T;      *PENDINGINTERRUPT_word = ATOM_T;    };  *GcDisabled_word = ATOM_T;  return(NIL);}E 3I 3      }    *Reclaim_cnt_word = NIL;    *ReclaimMin_word  = NIL;    if ((noerror == NIL) && (*GcDisabled_word == NIL))      {	gcinterruptstate->gcdisabled = T;	*PENDINGINTERRUPT_word = ATOM_T;      };    *GcDisabled_word = ATOM_T;    return(NIL);  }E 3E 1