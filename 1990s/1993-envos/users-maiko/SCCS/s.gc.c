h39942s 00022/00013/00026d D 2.8 93/02/08 14:51:28 sybalsky 11 10c Big VM (and new CDR coding) changes for 3.0 \nes 00001/00001/00038d D 2.7 92/06/26 13:48:38 sybalsky 10 9c retrofit of 386 unix changes \nes 00003/00003/00036d D 2.6 92/04/21 17:12:23 sybalsky 9 8c shortening file names for DOS \nes 00004/00005/00035d D 2.5 90/06/15 16:57:59 mitani 8 7c GCLOOKUPVes 00000/00000/00040d D 2.4 90/04/20 01:34:21 sybalsky 7 6c es 00000/00000/00040d D 2.3 89/03/28 01:46:06 sybalsky 6 5c word-pointer fixes for 386es 00000/00030/00040d D 2.2 88/06/02 13:35:09 masinter 5 4c remove unused gclookup functiones 00000/00000/00070d D 2.1 88/05/17 09:24:14 hayata 4 3c Version up to 2.1es 00009/00190/00061d D 1.3 88/03/20 16:46:44 masinter 3 2c Merge new gc code for closure cache; clock temp offes 00002/00002/00249d D 1.2 88/03/13 14:47:36 hayata 2 1c Add SCCS key id (%Z%)es 00251/00000/00000d D 1.1 88/02/24 16:56:53 hayata 1 0c date and time created 88/02/24 16:56:53 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 8/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 8I 8D 11/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 11I 11/* %Z% %M% Version %I% (%G%). copyright venue  */static char *id = "%Z% %M%	%I% %G%		(venue)";E 11E 8E 2D 11/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 3 *	Auther	:	Hiroshi Hayata	E 3I 3 *	Author	:	Hiroshi Hayata	E 3 */E 11I 11/************************************************************************//*									*//*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************/E 11#include <stdio.h>#include "lispemul.h"D 8#include "gc.h"E 8D 9#include "lispglobal.h"#include "lisptypes.h"#include "emulglobal.h"E 9I 9#include "lspglob.h"#include "lsptypes.h"#include "emlglob.h"E 9I 8#include "gc.h"E 8D 3#define	MaskFE00(x)	(0xFE00 & x)E 3D 8E 8D 3#define	HTFIND		025#define	MAX_ADDREF_COUNT	62DLword	GcLov;		/* for GC. if 0xFFFF, HashMainTabel is overflow. */DLword	GcZero;		/* for GC. if 0x7FF, new entry is added to HashMainTable. */LispPTR	gclookup();E 3/************************************************************ 	entry		OP_gcref		OPCODE[025]D 11	1. 	alpha is ADDREF or DELREF, STKREF.		TopOfStack is argued slot address.	2. 	call gclookup with alpha and TopOfStack.	3.	if stk=0 and refcnt=0 of entry of HashMainTable, TopOfStack left alone.		else replace TopOfStack with 0.	4.	increment PC by 2.E 11I 11	1. alpha is ADDREF or DELREF, STKREF.	   TopOfStack is argued slot address.	2. call gclookup with alpha and TopOfStack.	3. if stk=0 and refcnt=0 of entry of HashMainTable,	   TopOfStack left alone.	   else replace TopOfStack with 0.	4. increment PC by 2.E 11D 3	Edited 18-Sep-87E 3***********************************************************/ OP_gcref(){D 3DLword	alpha;	/* 1st argument of OPcode */DLword	gcret;	/* return value of gclookup */E 3#ifdef TRACE	printPC();	printf("TRACE:OP_gcref()\n");#endifD 3	alpha = 0xFF & (*(PC+1));	if( gclookup( (0x8000 | alpha), TopOfStack) == NIL){		/* if MSB of 1st argument is on, gclookup is called by OP_gcref. */#ifdef DEBUG	printf("DEBUG:OP_gcref[HTmain entry - stkref!=0 || refcnt!=0]\n");#endif		/* (stlref != 0) || (refcnt != 0) */		TopOfStack = 0;	}E 3I 3D 8	TopOfStack = htfind(TopOfStack, Get_BYTE(PC+1));E 8I 8D 10	GCLOOKUPV(TopOfStack, Get_BYTE(PC+1), TopOfStack);E 10I 10	GCLOOKUPV(TopOfStack, Get_code_BYTE(PC+1), TopOfStack);E 10E 8E 3	PC+=2;	return;}	D 5/******************************************************gclookup	Common Routine	Used by OP_gcref, OP_gvar_, OP_rplptr	Return	if the new value has stk=0 and refcnt=0, retun 0		if sgmentnumber is 0, or Atom, or overflow, return FFFF		Otherwise, return TT(register) with FE00 mask.	1. 	if segment number of argued address is 0, or MSB of type is ON,		then return.	2.	if 1st bit of type is ON, or collision bit in entry of Hash Main Table		is on, or segment number of Hash Main Table is different from		segment number of difference,		then process collision and retuen.	3. 	if ADDREF, increment count of entry.		if DELREF, increment count of entry.		if STKREF,	 set 1 to stkref.D 3******************************************************/LispPTRgclookup(code, addr)short		code;	/* ADDREF, DELREF or STKREF.			   if MSB of code is on, this routine is called by opcode GCREF. */LispPTR	addr;		/* address of argued slot, Lisp address */{int	type;		/* Data type of argued slot. */char	segnum;	/* segment number in address of argued slot */DLword	*pentry;	/* pointer to hash table entry */struct hashentry	*phentry;	/* pointer to hash table entry */DLword	*povrent;	/* pointer to hash overflow table entry */unsigned int	lowaddr;	/* lower word of addr */#ifdef DEBUGGC	int	checkflag = 0;#endif#ifdef NOGC	return;#endif#ifdef TRACE2	printf("TRACE:gclookup(code:%x, addr:%x)\n", code, addr);#endif/*** For Debug 27-Nov	if (addr == 0x3c6e38)	   {printf("*** In gclookup Encounter {STREAM}0x3c6e38\n");	    pentry = HTmain + (((unsigned short)addr) >> 1);	    phentry = (struct hashentry *)pentry; 	    if (!phentry->collision)		{printf("Ref count is %d\n",((phentry->segnum == 0)&&			(phentry->count == 0))? 1:phentry->count);		 if ((code & 0x7f) == 0)			printf("And now ADDREF\n");		else if ((code & 0x7f) == 1)			printf("And now DELREF\n");		}		else printf("Ah!!!! This is Collision\n");	    stab();	   };***/E 3D 3	if( (0xFF0000 & addr) == 0 ){#ifdef DEBUG	printf("DEBUG:gclookup[No access to HTmain (Seg num is 0)]\n");#endif		/* High address is 0. */		return( NIL );	}E 3I 3This should go away; callers should just call htfind directly E 3D 3	type = GetTypeEntry( addr );	if( type & 0x8000 ){#ifdef DEBUG	printf("DEBUG:gclookup[No access to HTmain (No access type)]\n");#endif		/* MSB of type is on, it's Atom */		return( NIL );	}	pentry = HTmain + (((unsigned short)addr) >> 1);	phentry = (struct hashentry *)pentry; 		segnum = (char)((0xFF0000  & addr) >> 16);	/* get segment number of addr */	if( (type & 0x4000) || (phentry->collision == 1) ||		 (((char)(phentry->segnum) != segnum) && (*pentry != 0)) ){		/* 	(type & 0x4000) : Don't RefCnt						*/		/*	(phentry->collision == 1) : Collision occured			*/		/*	((char)(phentry->segnum) != segnum)					*/		/*		: HashTable Entry has different Segment number 	*/		/*	*pentry != 0				: HashTable Entry is not empty */	/* Collision */	gclcoll:#ifdef DEBUG	printf("DEBUG:gclookup[Overflow or collision in HTmain]\n");#endif		if(code & 0x8000){#ifdef DEBUG	printf("DEBUG:gclookup[Should call htfind()]\n");#endif			/**** call \HTFIND Lisp Func. ****/			return( htfind(addr,code & 0xF));			/***ufn(HTFIND);****/		}		for(povrent=HToverflow; (*povrent)!=0; povrent+=2){			if(povrent == HTbigcount)				error("Error: gclookup [HToverflow is full].\n");			/* search null entry in HashOverflowTable. */		}		*((int *)povrent) = (code << 24) | addr;			/* set code and addr to HashOverflowTable entry. */#ifdef DEBUG	printf("DEBUG:gclookup[Set HToverflow entry: %x]\n",*((int *)povrent) );#endif#ifdef DEBUGGC	--checkflag;	if((((char)(phentry->segnum) != segnum) && (*pentry != 0))){		printf("DEBUGGC:gclookup[Collision!! LispAddr(%x)]\n", addrCD);	}	if(checkflag != 0){		printf("DEBUGGC:gclookup[Wrong setting of HToverflow LispAddr(%x) HToverflow ptr(%x)]\n", addr, povrent);	}#endif		GcLov |= 0xFFFF;			/* set gloval variable to know overflow. */		return( NIL );	/* overflow ! */	}	if( *pentry == 0 ){		/* built a new entry. */		phentry->count = 1;		phentry->segnum = segnum;		GcZero |= 0x7FF;			/* set global variable to know new entry. */#ifdef DEBUG	printf("DEBUG:gclookup[Make new entry on HTmain]\n");#endif	}	switch( code & 0x7F ){		case ADDREF:	/* 0 */				if( (phentry->count) >= MAX_ADDREF_COUNT ){					/* count is full. overflow. */#ifdef DEBUGGC	++checkflag;#endif					goto gclcoll;				}				phentry->count += 1;				break;		case DELREF:	/* 1 */				if( phentry->count == 0 || phentry->count == MAX_GCCOUNT){					/* count is 0. overflow. */#ifdef DEBUGGC	++checkflag;#endif					goto gclcoll;				}				phentry->count -= 1;				break;		case STKREF:	/* 2 */				phentry->stackref = 1;				break;		default:			error("code argumenmt of gclookup is Bad ! \n");	}/* end switch *//***** old	if( (phentry->count == 1) && (phentry->stackref == 0) ){		*pentry = 0;		return( NIL );	}else{		return( NIL );	}******/	if(phentry->stackref==0){		switch(phentry->count){		case	0:	return(addr);		case	1:	*pentry = 0;				return(NIL);		default:	return(NIL);		}	}else{		return(NIL);	} }E 3I 3******************************************************/LispPTR gclookup(code, addr)	short code;	LispPTR addr;{  return htfind(addr, code & 0xff); }E 3E 5E 1