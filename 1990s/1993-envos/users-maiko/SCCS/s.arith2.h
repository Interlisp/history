h18883s 00080/00006/00062d D 1.2 92/05/29 10:17:20 sybalsky 2 1c 386 Unix inline arithmetic cleanupes 00068/00000/00000d D 1.1 92/05/27 19:07:25 sybalsky 1 0c date and time created 92/05/27 19:07:25 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  *//************************************************************************//*									*//*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************/I 2/************************************************************************//*									*//*	Take care of results for inlined arithmetic cases.  *//*	xxx_RESULT does overflow checking and boxing.								*//*									*//*									*//************************************************************************/#ifdef ARITHINLINE#ifdef GCC386E 2/* Inline defines for arith on GCC386 machines */extern inline const int plus32 (int arg1, int arg2){	asm(" addl %2,%0					\n\	jo plus_err": "=r" (arg2): "0" (arg2), "r" (arg1));	return arg2;}D 2#define plus_err_label() asm("plus_err:")E 2I 2#define PLUS_RESULT							\	INLINE_ARITH_SWITCH(result,"plus_ret");	\	asm("plus_err:");		\	INLINE_ERROR_EXIT(tos,"plus_ret")E 2I 2E 2extern inline const int iplus32 (int arg1, int arg2){	asm(" addl %2,%0					\n\	jo iplus_err":  "=r" (arg2): "0" (arg2), "r" (arg1));	return arg2;}D 2#define iplus_err_label() asm("iplus_err:")E 2I 2#define IPLUS_RESULT		\	INLINE_ARITH_SWITCH(result,"iplus_ret");	\	asm("iplus_err:");							\	INLINE_ERROR_EXIT(tos,"iplus_ret")E 2I 2E 2extern inline const int sub32 (int arg1, int arg2){	asm("subl %2,%0						\n\	jo diff_err": "=r" (arg1): "0" (arg1), "r" (arg2));	return arg1;}D 2#define diff_err_label() asm("diff_err:")E 2I 2#define DIFF_RESULT 						\	INLINE_ARITH_SWITCH(result,"diff_ret");		\	asm("diff_err:");							\	INLINE_ERROR_EXIT(tos,"diff_ret")E 2I 2E 2extern inline const int isub32 (int arg1, int arg2){	asm(" subl %2,%0						\n\	jo idiff_err": "=r" (arg1): "0" (arg1), "r" (arg2));	return arg1;}D 2#define idiff_err_label() asm("idiff_err:")E 2I 2#define IDIFF_RESULT 						\	INLINE_ARITH_SWITCH(result,"idiff_ret");		\	asm("idiff_err:");							\	INLINE_ERROR_EXIT(tos,"idiff_ret")E 2I 2E 2extern inline const int iplus32n(int arg1, int arg2){	asm("addl %2,%0						\n\	jo iplusn_err": "=r" (arg2): "0" (arg2), "r" (arg1));	return arg2;}D 2#define iplusn_err_label() asm("iplusn_err:")E 2I 2#define IPLUSN_RESULT						\	INLINE_ARITH_SWITCH(result,"iplusn_ret");	\	asm("iplusn_err:");							\	INLINE_ERROR_EXIT(tos,"iplusn_ret")E 2I 2E 2extern inline const int sub32n (int arg1, int arg2){	asm(" subl %2,%0						\n\	jo idiffn_err": "=r" (arg1): "0" (arg1), "r" (arg2));	return arg1;}D 2#define idiffn_err_label() asm("idiffn_err:")E 2I 2#define IDIFFN_RESULT							\	INLINE_ARITH_SWITCH(result,"idiffn_ret");	\	asm("idiffn_err:");							\	INLINE_ERROR_EXIT(tos,"idiffn_ret")#else	/* Any other ARITHINLINE case */#define PLUS_RESULT							\	N_ARITH_SWITCH(result);					\doufn2:	plus_err_label();					\	ERROR_EXIT(tos);	#define IPLUS_RESULT						\	N_ARITH_SWITCH(result);					\dummy:	iplus_err_label();#define DIFF_RESULT							\	N_ARITH_SWITCH(result);					\doufn2:	diff_err_label();					\	ERROR_EXIT(tos);		#define IDIFF_RESULT						\		N_ARITH_SWITCH(result);					\dummy:	idiff_err_label();#define IPLUSN_RESULT						\	N_ARITH_SWITCH(result);					\dummy:	iplusn_err_label();#define IDIFFN_RESULT						\	N_ARITH_SWITCH(result);					\dummy:	idiffn_err_label();#endif /* GCC386 */#endif /* ARITHINLINE */E 2E 1