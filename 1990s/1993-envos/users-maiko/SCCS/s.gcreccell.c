h45928s 00003/00001/00270d D 1.6 91/01/24 11:08:48 sybalsky 6 5c Add debugging info to reclaimcell fn, reformat codees 00004/00003/00267d D 1.5 91/01/22 16:32:26 sybalsky 5 4c fix typos from last change.es 00178/00158/00092d D 1.4 91/01/22 16:28:10 sybalsky 4 3c Reformat code, add error check for odd pointers being reclaimed.es 00015/00003/00235d D 1.3 90/06/15 16:54:34 mitani 3 2c REC_GCLOOKUPes 00017/00011/00221d D 1.2 90/04/20 01:37:05 sybalsky 2 1c AIX:  shortening file names, bulk change.es 00232/00000/00000d D 1.1 90/04/19 23:19:27 sybalsky 1 0c date and time created 90/04/19 23:19:27 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";D 2/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 2I 2/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 2/*************************************************************************/D 2/*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 *//*************************************************************************/E 2/*                                                                       */D 2/*                       File Name : gcreclaimcell.c                     */E 2I 2D 4/*                       File Name : gcreccell.c                     */E 4I 4/*                       File Name : gcreccell.c                    	 */E 4E 2/*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : July-7-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions :                                                 */D 2/*                       gcreclaimcell(cell);                            */E 2I 2D 4/*                       gcreccell(cell);                            */E 4I 4/*                       gcreccell(cell);				 */E 4E 2/*                       freelistcell(cell);                             *//*                                                                       *//*                                                                       *//*************************************************************************//*           Descreption :                                               *//*                                                                       */D 2/*  The functions "gcreclaimcell" and "freelistcell" are the translated  */E 2I 2D 4/*  The functions "gcreccell" and "freelistcell" are the translated  */E 4I 4/*  The functions "gcreccell" and "freelistcell" are the translated 	 */E 4E 2/*  functions from the Lisp functions "\GCRECLAIMCELL" that is the UFN   *//*  function of the opcode "RECLAIMCELL", and "\FREELISTCELL".           *//*  These functions may have the following characteristics :             *//*                                                                       */D 2/*  	gcreclaimcell(cell)	LispPTR cell				 */E 2I 2D 4/*  	gcreccell(cell)	LispPTR cell				 */E 4I 4/*  	gcreccell(cell)	LispPTR cell					 */E 4E 2/* 		This function may always return NIL(= 0), as the Lisp    *//*           	macro .RECLAIMCELLLP. in more upper level may use this   *//*              return value as the further Garbage's pointer.(The Opcode*//*              "RECLAIMCELL"'s function is specified as this, but its   */D 2/*              UFN function is not. The gcreclaimcell function's	 */E 2I 2D 4/*              UFN function is not. The gcreccell function's	 */E 4I 4/*              UFN function is not. The gcreccell function's		 */E 4E 2/*              behavior is same as the UFN function for speed and 	 *//*		simplicity,this is, this function is closed in this level*//*		)							 */D 4/*		This function may reclaim the date of all types that is  */E 4I 4/*		This function may reclaim the data of all types that is  */E 4/*		Garbage.Especially, the data whose types are ARRAYBLOCK  *//*		(= 0), STACKP(= 8),VMEMPAGEP(= 10) and CODEBLOCK(= 54,55,*//*		56,57,58,59,60,61,62,63) may be reclaimed by each special*//*		processes that are specified and invoked by this function*//*		.The data whose type is LISTP is the main data type	 *//*		processed in this function actually and only then the 	 *//*		function "freelistcell" may be called for making linkage *//*		of free list.						 *//*									 *//*	freelistcell(cell)	LispPTR cell				 *//*		This function may make the linkage of free list of the	 *//*		cons cell.The header of this linkage is DTD->NEXTPAGE of *//*		LISTP and each cons page has its internal linkage of free*//*		cells.This return value is not considered as not used.	 *//*									 *//*************************************************************************//*                                                               \Tomtom *//*************************************************************************/#include <stdio.h>#include "lispemul.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "stack.h"#include "cell.h"#include "ifpage.h"#include "gc.h"#include "dbprint.h"#define CONSPAGE_LAST	0x0ffffI 4/************************************************************************//*									*//*				g c r e c c e l l			*//*									*//*	Reclaim a cell, doing necessary finalization &c.		*//*									*//************************************************************************/E 4D 2gcreclaimcell(cell)E 2I 2gcreccell(cell)E 2D 4LispPTR	cell;	{register ConsCell	*ptr;	 struct dtd		*typdtd; 	 DLword			typ; 	 register LispPTR	tmpptr, donext, tmpcell, val;	 LispPTR		ptrfield,carfield; 	 int	 		index,code;	 LispPTR		*field;	 int freecnt;	 LispPTR freeptr;	 LispPTR *actptr;E 4I 4  LispPTR	cell;  {    register ConsCell *ptr;    struct dtd *typdtd;     DLword typ;     register LispPTR tmpptr, donext, tmpcell, val;D 5    LispPTRptrfield,carfield;     int index,code;    LispPTR*field;E 5I 5    LispPTR ptrfield, carfield;     int index, code;    LispPTR *field;E 5    int freecnt;    LispPTR freeptr;    LispPTR *actptr;E 4D 4	  val = NIL;	  tmpptr = cell;	  index = -1;	  donext = NIL;	lp:	  ptr = (ConsCell *)Addr68k_from_LADDR(tmpptr);E 4I 4    val = NIL;    tmpptr = cell;    index = -1;    donext = NIL;  lp:    ptr = (ConsCell *)Addr68k_from_LADDR(tmpptr);E 4/* # ifdef CHECKD 4	if (refcnt(tmpptr) != 1) error("reclaiming cell w/refcnt not 1");E 4I 4  if (refcnt(tmpptr) != 1) error("reclaiming cell w/refcnt not 1");E 4 # endif*/D 4	typ = GetTypeNumber(tmpptr);	  switch(typ) E 4I 4#ifdef DEBUG    if (tmpptr & 1) error("Reclaiming cell pointer with low bit 1.");I 5#endifE 5    typ = GetTypeNumber(tmpptr);I 6#ifdef DEBUG    if (typ==6) printf("Reclaiming array ptr 0x%x.\n", tmpptr);#endifE 6    switch(typ)       { 	 case TYPE_LISTP: E 4		{ D 4		 case TYPE_LISTP: E 4I 4		  if ((code = ptr->cdr_code) == CDR_INDIRECT) /* indirect */		    { tmpcell = ptr->car_field;  /* Monitor */		      freelistcell(tmpptr);		      ptr = (ConsCell *) Addr68k_from_LADDR(tmpcell);		      tmpptr = tmpcell;		      code = ptr->cdr_code;		    };		  if (index != -1)	/* car part */		    index = -1;/*		  else if ((val = htfind(car(tmpptr), DELREF)) != NIL) */		  else		    {		      REC_GCLOOKUPV(car(tmpptr), DELREF, val);		      if (val != NIL)E 4			{ D 4			  if ((code = ptr->cdr_code) == CDR_INDIRECT)				/* indirect */				  { tmpcell = ptr->car_field;				    		/* Monitor */				    freelistcell(tmpptr);				    ptr = (ConsCell *)						Addr68k_from_LADDR(tmpcell);				    tmpptr = tmpcell;				    code = ptr->cdr_code;				  };			  if (index != -1)	/* car part */			  	index = -1;D 3			  else if ((val = htfind(car(tmpptr), DELREF)) != NIL) E 3I 3/*			  else if ((val = htfind(car(tmpptr), DELREF)) != NIL) */			  else {				  REC_GCLOOKUPV(car(tmpptr), DELREF, val);				  if (val != NIL)E 3					{ 					  ptr->car_field = donext;					  ptr->cdr_code = code;					  donext = tmpptr; 					  goto doval;					};D 3			  val = htfind(cdr(tmpptr),DELREF);E 3I 3			  }/*			  val = htfind(cdr(tmpptr),DELREF); */			  REC_GCLOOKUPV(cdr(tmpptr), DELREF, val);E 3			  if (code <= CDR_MAXINDIRECT)				{tmpcell = POINTER_PAGEBASE(tmpptr)					    + ((code - CDR_INDIRECT) << 1);				  freelistcell(tmpcell);				};			  freelistcell(tmpptr);			  goto doval;    E 4I 4			  ptr->car_field = donext;			  ptr->cdr_code = code;			  donext = tmpptr; 			  goto doval;E 4			};D 4		case TYPE_ARRAYBLOCK:			if ((index == -1) && reclaimarrayblock(tmpptr)) 				goto trynext;			 else break;			case TYPE_STACKP: if ((index == -1) && reclaimstackp(tmpptr))			 { goto trynext;} 			 else break;			case TYPE_VMEMPAGEP:			 DBPRINT(("Trying to reclaim VMEMPAGEP {}%o,%o.\n", HILOC(tmpptr), LOLOC(tmpptr)));			 if ((index == -1) && releasingvmempage(tmpptr))			   {				DBPRINT(("Couldn't release VMEMPAGEP 0x%x.", tmpptr));				 goto trynext;			   }			 else break;		case TYPE_CODEHUNK1:		case TYPE_CODEHUNK2:		case TYPE_CODEHUNK3:		case TYPE_CODEHUNK4:		case TYPE_CODEHUNK5:		case TYPE_CODEHUNK6:		case TYPE_CODEHUNK7:		case TYPE_CODEHUNK8:		case TYPE_CODEHUNK9:		case TYPE_CODEHUNK10:			if ((index == -1) && reclaimcodeblock(tmpptr))				goto trynext;			else break; 		default: 			  ;		}; 	normal: 		typdtd = (struct dtd *)GetDTD(typ); 		ptrfield = typdtd->dtd_ptrs; 		if (index != -1)		   { index = (index << 1);		     ptrfield = cdr(ptrfield);		     while ((car(ptrfield) & 0x0ffff) != index)			{ ptrfield = cdr(ptrfield);}		     index = -1;		   };			while(ptrfield != NIL)		{ carfield = car(ptrfield);		  ptrfield = cdr(ptrfield);		  carfield &= 0x0ffff;E 4I 4		    }/*		  val = htfind(cdr(tmpptr),DELREF); */		  REC_GCLOOKUPV(cdr(tmpptr), DELREF, val);		  if (code <= CDR_MAXINDIRECT)		    {		      tmpcell = POINTER_PAGEBASE(tmpptr)				    + ((code - CDR_INDIRECT) << 1);		      freelistcell(tmpcell);		    };		  freelistcell(tmpptr);		  goto doval;    		};	case TYPE_ARRAYBLOCK:		if ((index == -1) && reclaimarrayblock(tmpptr)) 		  goto trynext;		else break;		case TYPE_STACKP:		if ((index == -1) && reclaimstackp(tmpptr)) goto trynext; 		break;		case TYPE_VMEMPAGEP:		if ((index == -1) && releasingvmempage(tmpptr))		  {D 6		    DBPRINT(("Couldn't release VMEMPAGEP 0x%x.", tmpptr));E 6		    goto trynext;		  }		else break;	case TYPE_CODEHUNK1:	case TYPE_CODEHUNK2:	case TYPE_CODEHUNK3:	case TYPE_CODEHUNK4:	case TYPE_CODEHUNK5:	case TYPE_CODEHUNK6:	case TYPE_CODEHUNK7:	case TYPE_CODEHUNK8:	case TYPE_CODEHUNK9:	case TYPE_CODEHUNK10:		if ((index == -1) && reclaimcodeblock(tmpptr)) goto trynext;		else break; 	default:  ;      };   normal:     typdtd = (struct dtd *)GetDTD(typ);     ptrfield = typdtd->dtd_ptrs;     if (index != -1)      {	index = (index << 1);	ptrfield = cdr(ptrfield);	while ((car(ptrfield) & 0x0ffff) != index) ptrfield = cdr(ptrfield);	index = -1;      };	    while(ptrfield != NIL)      {	carfield = car(ptrfield);	ptrfield = cdr(ptrfield);	carfield &= 0x0ffff;E 4I 3/*E 3D 4		  val = GCLOOKUPV(0x8000,DELREF,(0x0ffffff & *(LispPTR *)				Addr68k_from_LADDR(tmpptr+carfield)));E 4I 4	val = GCLOOKUPV(0x8000,DELREF,(0x0ffffff & *(LispPTR *)		Addr68k_from_LADDR(tmpptr+carfield)));E 4I 3*/D 4		  REC_GCLOOKUPV((0x0ffffff &				 *(LispPTR *)Addr68k_from_LADDR(tmpptr+carfield)),				DELREF, val);E 4I 4	REC_GCLOOKUPV((0x0ffffff &		        *(LispPTR *)Addr68k_from_LADDR(tmpptr+carfield)),		       DELREF, val);E 4E 3D 4		  if (val != NIL)			{if (ptrfield != NIL)				{ ptr = (ConsCell *)Addr68k_from_LADDR(tmpptr);				  ptr->car_field = donext;				  ptr->cdr_code = ((car(ptrfield) & 0x0ffff)								>> 1);				  donext = tmpptr;				  goto doval;				}			 else			   goto addtofreelist;			};		};	addtofreelist:#ifdef DEBUG		if (typ == TYPE_VMEMPAGEP) printf("Adding VMEMPAGEP to free list.\n");#endif		field = (LispPTR *)Addr68k_from_LADDR(tmpptr);		*field	= typdtd->dtd_free;		typdtd->dtd_free = tmpptr;E 4I 4	if (val != NIL)	  {	    if (ptrfield != NIL)	      {		ptr = (ConsCell *)Addr68k_from_LADDR(tmpptr);		ptr->car_field = donext;		ptr->cdr_code = ((car(ptrfield) & 0x0ffff) >> 1);		donext = tmpptr;		goto doval;	      }	    else goto addtofreelist;	  };      };  addtofreelist:    field = (LispPTR *)Addr68k_from_LADDR(tmpptr);    *field = typdtd->dtd_free;    typdtd->dtd_free = tmpptr;E 4D 4	doval:		if (val != NIL)			{ tmpptr = val;D 3			  GCLOOKUP(0x8000, ADDREF,tmpptr); E 3I 3			  REC_GCLOOKUP(tmpptr, ADDREF);/*			  GCLOOKUP(0x8000, ADDREF,tmpptr); */E 3			  val = NIL;			  goto lp;			};	trynext:		if (donext != NIL)			{ tmpptr = donext;			  ptr = (ConsCell *)Addr68k_from_LADDR(tmpptr);			  donext = (LispPTR)ptr->car_field;			  index = ptr->cdr_code;			  goto lp;			};	  return(NIL);	}E 4I 4  doval:    if (val != NIL)      {	tmpptr = val;	REC_GCLOOKUP(tmpptr, ADDREF);/*	GCLOOKUP(0x8000, ADDREF,tmpptr); */	val = NIL;	goto lp;      };  trynext:    if (donext != NIL)      {	tmpptr = donext;	ptr = (ConsCell *)Addr68k_from_LADDR(tmpptr);	donext = (LispPTR)ptr->car_field;	index = ptr->cdr_code;	goto lp;      };    return(NIL);  }E 4I 4/************************************************************************//*									*//*			f r e e l i s t c e l l				*//*									*//*									*//*									*//************************************************************************/E 4freelistcell(cell)LispPTR	cell;D 4	{ struct conspage 	*pbase; 	  register ConsCell		*cell68k;	  cell68k = (ConsCell *)Addr68k_from_LADDR(cell);	  pbase = (struct conspage *)Addr68k_from_LPAGE(POINTER_PAGE(cell));	  cell68k->cdr_code = pbase->next_cell;	  pbase->next_cell = (cell & 0x0ff);	  if ((++pbase->count > 2) && (pbase->next_page == CONSPAGE_LAST)) 		{ pbase->next_page = ListpDTD->dtd_nextpage;  		  ListpDTD->dtd_nextpage = POINTER_PAGE(cell); 		};E 4I 4  {    struct conspage *pbase;     register ConsCell *cell68k;    cell68k = (ConsCell *)Addr68k_from_LADDR(cell);    pbase = (struct conspage *)Addr68k_from_LPAGE(POINTER_PAGE(cell));    cell68k->cdr_code = pbase->next_cell;    pbase->next_cell = (cell & 0x0ff);    if ((++pbase->count > 2) && (pbase->next_page == CONSPAGE_LAST))       {	pbase->next_page = ListpDTD->dtd_nextpage;  	ListpDTD->dtd_nextpage = POINTER_PAGE(cell);       };E 4		 	   D 4	}E 4I 4  }E 4E 1