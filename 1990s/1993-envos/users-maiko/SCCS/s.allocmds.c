h02928s 00019/00012/00171d D 2.7 93/02/08 14:46:03 sybalsky 9 8c Big VM (and new CDR coding) changes for 3.0 \nes 00005/00005/00178d D 2.6 92/04/21 17:00:35 sybalsky 8 7c shortening file names for DOS \nes 00000/00000/00183d D 2.5 90/04/20 01:16:47 sybalsky 7 6c s, bulk change.es 00067/00049/00116d D 2.4 89/12/28 15:22:51 sybalsky 6 5c cleanup code, plus error checkinges 00001/00001/00164d D 2.3 89/03/27 15:43:34 sybalsky 5 4c Word-ptr ref fixup for MDStypetbles 00034/00036/00131d D 2.2 89/01/09 16:34:17 shih 4 3c minor spellinges 00000/00000/00167d D 2.1 88/05/17 09:21:27 hayata 3 2c Version up to 2.1es 00002/00002/00165d D 1.2 88/03/13 14:31:21 hayata 2 1c Add SCCS key id (%Z%)es 00167/00000/00000d D 1.1 88/02/24 16:55:31 hayata 1 0c date and time created 88/02/24 16:55:31 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 4/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 4I 4D 9/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 9I 9/* %Z% %M% Version %I% (%G%). copyright Venue  */E 9E 4static char *id = "%Z% %M%	%I% %G%";I 6I 9E 9/************************************************************************//*									*/D 9/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 9I 9/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 9/*									*/D 9/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 9I 9/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 9/*									*//************************************************************************/E 6E 2D 9/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 4 *	Auther : Takeshi Shimizu * E 4I 4 *	Author : Takeshi Shimizu *E 4 */E 9I 9E 9/**********************************************************************//*D 4 		File Name :	allocmds.cE 4I 4		File Name :	allocmds.cE 4		Allocate Data Type(MDS)D 4  				Date :		August 18, 1987 				Edited by :	Takeshi Shimizu				Aug-20-87 take(for KATANA)				22-Dec-87 Take only for KATANA E 4I 4				Date :		August 18, 1987				Edited by :	Takeshi ShimizuE 4D 6		Including :	initmdapageE 6I 6		Including :	initmdspageE 6				alloc_mdspageD 4					E 4I 4E 4*//**********************************************************************/#include "lispemul.h"#include "address.h"D 8#include "address68k.h"#include "lisptypes.h"E 8I 8#include "adr68k.h"#include "lsptypes.h"E 8#include "cell.h"#include "lispmap.h"D 8#include "initatoms.h"#include "systematoms.h"#include "lispglobal.h"E 8I 8#include "initatms.h"#include "sysatms.h"#include "lspglob.h"E 8/* I consider that there is no case the variable named \GCDISABLED is set to T */D 5#define Make_MDSentry(page,pattern)  *((DLword *)MDStypetbl+(page>>1)) = (DLword)patternE 5I 5#define Make_MDSentry(page,pattern)  GETWORD((DLword *)MDStypetbl+(page>>1)) = (DLword)patternE 5/**********************************************************************//*	Func name :	initmdspageD 4		Write the specified MDSTT entry with specified pattern .E 4I 4		Write the specified MDSTT entry with specified pattern.E 4		returns Top entry for free chain lisp address				Date :		December 24, 1986				Edited by :	Takeshi Shimizu				Changed :	Jun. 5 87 take*//**********************************************************************/LispPTR initmdspage(base , size , prev)D 4register  LispPTR *base ; /* MDS page base */register DLword size ;  /* object cell size you need (WORD) */ register LispPTR prev ; /* keeping top of previous MDS cell */E 4I 4D 6register  LispPTR *base; /* MDS page base */register DLword size;  /* object cell size you need (WORD) */ register LispPTR prev; /* keeping top of previous MDS cell */E 6I 6  register  LispPTR *base; /* MDS page base */  register DLword size;  /* object cell size you need (WORD) */  register LispPTR prev; /* keeping top of previous MDS cell */E 6E 4D 6{D 4  extern DLword *MDStypetbl ;E 4I 4  extern DLword *MDStypetbl;E 6I 6  {    extern DLword *MDStypetbl;E 6E 4D 4  register int remain_size ;  /* (IREMAINDER WORDSPERPAGE SIZE) */  register short num_pages ;  register int limit ;  int used ;   /* used space in MDS page */E 4I 4D 6  register int remain_size;  /* (IREMAINDER WORDSPERPAGE SIZE) */  register short num_pages;  register int limit;  int used;   /* used space in MDS page */E 4   register int i;E 6I 6    register int remain_size;  /* (IREMAINDER WORDSPERPAGE SIZE) */    register short num_pages;    register int limit;    int used;   /* used space in MDS page */     register int i;E 6#ifdef TRACE2	printf("TRACE: initmdspage()\n");#endifD 4  remain_size = DLWORDSPER_PAGE % size ;E 4I 4D 6  remain_size = DLWORDSPER_PAGE % size;E 6I 6    remain_size = DLWORDSPER_PAGE % size;E 6E 4D 6 if((remain_size != 0)&& (remain_size < (size >> 1) && (size < DLWORDSPER_PAGE)))  {E 6I 6   if(  (remain_size != 0)      && (remain_size < (size >> 1)       && (size < DLWORDSPER_PAGE)))      {E 6D 4	num_pages = MDSINCREMENT / DLWORDSPER_PAGE ;  /* on 1121 maybe 2 */	limit = DLWORDSPER_PAGE ;E 4I 4	num_pages = MDSINCREMENT / DLWORDSPER_PAGE;  /* on 1121 maybe 2 */	limit = DLWORDSPER_PAGE;E 4D 6  } else  {E 6I 6      }    else      {E 6D 4	num_pages = 1 ;	limit = MDSINCREMENT ;E 4I 4	num_pages = 1;	limit = MDSINCREMENT;E 4D 6  }E 6I 6      }E 6D 4 for(i=0; i< num_pages ; i++)E 4I 4D 6 for(i=0; i< num_pages; i++)E 4  {E 6I 6    for(i=0; i< num_pages; i++)      {E 6	used=0;D 6	  while((used += size)<= limit){D 4		*base = prev ; /* write prev MDS address to the top of MDS page */E 4I 4		*base = prev; /* write prev MDS address to the top of MDS page */E 4		prev =LADDR_from_68k( base );		/* exchanging pointers */D 4		base = (LispPTR *)((DLword *)base + size) ;  E 4I 4		base = (LispPTR *)((DLword *)base + size);E 6I 6	while((used += size)<= limit)	  {	    *base = prev; /* write prev MDS address to the top of MDS page */	    prev =LADDR_from_68k( base );	/* exchanging pointers */	    base = (LispPTR *)((DLword *)base + size);E 6E 4	  } /* while end */	base = (LispPTR *)((DLword *)base + remain_size );D 6  } /* for end */E 6I 6      } /* for end */E 6D 6 return (prev);} /* initmdspage end */E 6I 6    return (prev);  } /* initmdspage end */E 6/**********************************************************************//*		Func name :	alloc_mdspage			This version works only for KATANA-SUN			Date :		January 13, 1987			Edited by :	Takeshi Shimizu			Changed :	3-Apr-87 (take)					20-Aug-87(take) ifdef					08-Oct-87(take) checkfull					22-Dec-87(Take)*//**********************************************************************//*** For KATANA version ***//** Rev. 12-Oct-87 take *****//** Add. newpage 13-Oct-87 take **/LispPTR *alloc_mdspage(type)D 4 register short type ;E 4I 4D 6 register short type;E 4{  /* It contains Free MDS page number */D 4  extern LispPTR *MDS_free_page_word ; E 4I 4  extern LispPTR *MDS_free_page_word;E 4  /* It contains next vacant(new) MDS page */D 4  extern DLword *Next_MDSpage ;E 4I 4  extern DLword *Next_MDSpage;E 4  extern LispPTR *Next_MDSpage_word;  extern LispPTR *Next_Array_word;E 6I 6  register short type;  {    /* It contains Free MDS page number */    extern LispPTR *MDS_free_page_word;    /* It contains next vacant(new) MDS page */    extern DLword *Next_MDSpage;    extern LispPTR *Next_MDSpage_word;    extern LispPTR *Next_Array_word;E 6D 6  LispPTR newpage();E 6I 6    LispPTR newpage();E 6D 4   register LispPTR *ptr ;  /* points Top 32 bit of the MDS page */E 4I 4D 6  register LispPTR *ptr;  /* points Top 32 bit of the MDS page */E 4  LispPTR next_page;E 6I 6    register LispPTR *ptr;  /* points Top 32 bit of the MDS page */    LispPTR next_page;E 6D 6 /* Next_Array=(DLword *)Addr68k_from_LADDR(((*Next_Array_word)& 0xffff ) << 8); */E 6I 6   /* Next_Array=(DLword *)Addr68k_from_LADDR(((*Next_Array_word)& 0xffff ) << 8); */E 6D 6  if(LOLOC(*MDS_free_page_word )!=NIL)   {E 6I 6    if(LOLOC(*MDS_free_page_word )!=NIL)      {E 6	ptr= (LispPTR *)Addr68k_from_LPAGE(LOLOC(*MDS_free_page_word ));D 6	if( ((next_page= LOLOC(*ptr))!=0 )&& (GetTypeNumber((*ptr))!= TYPE_SMALLP))E 6I 6	if( ((next_page= LOLOC(*ptr))!=0 )	   && (GetTypeNumber((*ptr))!= TYPE_SMALLP))E 6		error("alloc_mdspage: Bad Free Page Link");	else {		*MDS_free_page_word = S_POSITIVE | next_page;	     }D 6   }  else   {E 6I 6      }    else      {E 6	/* I guess Next_MDSpage is redundant */	checkfor_storagefull(NIL);I 9#ifdef BIGVM	Next_MDSpage= (DLword *)Addr68k_from_LADDR(((*Next_MDSpage_word) ) << 8);#elseE 9D 4 	Next_MDSpage= (DLword *)Addr68k_from_LADDR(((*Next_MDSpage_word)& 0xffff ) << 8);E 4I 4	Next_MDSpage= (DLword *)Addr68k_from_LADDR(((*Next_MDSpage_word)& 0xffff ) << 8);E 4D 9E 9I 9#endifE 9	ptr = (LispPTR *)Next_MDSpage; /* Get Pointer to First Page */D 4	Next_MDSpage -= DLWORDSPER_PAGE * 2 ;  /* decrement MDS count */E 4I 4	Next_MDSpage -= DLWORDSPER_PAGE * 2;  /* decrement MDS count */I 9#ifdef BIGVM	*Next_MDSpage_word= LPAGE_from_68k(Next_MDSpage);#elseE 9E 4	*Next_MDSpage_word=S_POSITIVE| LPAGE_from_68k(Next_MDSpage);D 9E 9I 9#endifE 9	newpage(newpage(LADDR_from_68k(ptr)) + DLWORDSPER_PAGE);D 6   }E 6I 6      }E 6D 4  Make_MDSentry(LPAGE_from_68k(ptr),type) ;E 4I 4D 6  Make_MDSentry(LPAGE_from_68k(ptr),type);E 4  return (ptr);} /* alloc_mdspage end */E 6I 6    Make_MDSentry(LPAGE_from_68k(ptr),type);    return (ptr);  } /* alloc_mdspage end */E 6E 1