h28521s 00002/00002/00191d D 2.11 92/04/23 14:10:19 nilsson 12 11c es 00075/00071/00118d D 2.10 92/04/22 13:05:33 sybalsky 11 10c SGI portes 00004/00004/00185d D 2.9 92/04/21 17:11:44 sybalsky 10 9c shortening file names for DOS \nes 00000/00000/00189d D 2.8 90/04/20 01:29:35 sybalsky 9 8c names, bulk change.es 00012/00000/00177d D 2.7 90/03/27 14:29:14 sybalsky 8 7c fp rounding fixes 00067/00009/00110d D 2.6 90/03/02 21:43:44 sybalsky 7 6c 386 checks, coimnmentses 00025/00025/00094d D 2.5 89/03/29 19:38:44 shih 6 5c changed FPTEST usagees 00010/00012/00109d D 2.4 88/10/12 18:43:48 krivacic 5 4c merge sun3/4 floating ptes 00023/00044/00098d D 2.3 88/10/12 14:42:05 krivacic 4 3c new out-of-line interfacees 00011/00001/00131d D 2.2 88/05/20 09:40:29 charnley 3 2c fixed punt caseses 00000/00000/00132d D 2.1 88/05/17 09:23:59 hayata 2 1c Version up to 2.1es 00132/00000/00000d D 1.1 88/05/10 10:41:59 charnley 1 0c date and time created 88/05/10 10:41:59 by charnleyeuUtTI 1D 6/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 6I 6D 7/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 6static char *id = "%Z% %M%	%I% %G%";/*	fp.c */E 7I 7D 12/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 12I 12/* @(#) fp.c Version 2.10 (4/22/92). copyright venue & Fuji Xerox  */static char *id = "@(#) fp.c	2.10 4/22/92	(venue & Fuji Xerox)";E 12I 11E 11/************************************************************************//*									*/D 11/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 11I 11/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 11/*									*/D 11/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 11I 11/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 11/*									*//************************************************************************//************************************************************************//*									*//*				  F P . C  				*//*									*//*	Floating-point arithmetic code.					*//*									*//************************************************************************/E 7#include <stdio.h>#include "lispemul.h"D 10#include "lispglobal.h"#include "address68k.h"E 10I 10#include "lspglob.h"#include "adr68k.h"E 10#include "lispmap.h"D 10#include "lisptypes.h"#include "emulglobal.h"E 10I 10#include "lsptypes.h"#include "emlglob.h"E 10#include "my.h"I 5#include "fp.h"E 5/************************************************************	N_OP_fplus2       -- op 350	N_OP_fdifference  -- op 351	N_OP_ftimes2      -- op 352	N_OP_fquotient    -- op 353	N_OP_fgreaterp    -- op 362***********************************************************/DLword *createcell68k();I 6D 7/*  ========================================================  */E 7I 7/************************************************************************//*									*//*			N _ O P _ f p l u s 2				*//*									*//*	2-argument floating point addition opcode			*//*									*//************************************************************************/E 7E 6I 3D 5static int constant0 = 0;E 3I 3unsigned int fpstatus_();E 3E 5D 4N_OP_fplus2(parg1, parg2, error_addr)E 4I 4N_OP_fplus2(parg1, parg2)E 4D 11LispPTR parg1, parg2;D 4int error_addr;E 4{register float arg1;register float arg2;register float result;register DLword *wordp;E 11I 11  LispPTR parg1, parg2;  {    REGISTER float arg1;    REGISTER float arg2;    REGISTER float result;    register DLword *wordp;E 11D 4#ifdef	TRACE	printPC();	printf("TRACE: N_OP_fplus2()\n");#endif  N_MakeFloat(parg1, arg1, error_addr);  N_MakeFloat(parg2, arg2, error_addr);E 4I 4D 11  N_MakeFloat(parg1, arg1, parg2);  N_MakeFloat(parg2, arg2, parg2);E 4I 3D 5  fpstatus_(&constant0);E 5I 5  FPCLEAR;E 11I 11    N_MakeFloat(parg1, arg1, parg2);    N_MakeFloat(parg2, arg2, parg2);    FPCLEAR;E 11I 8#ifdef I386D 11  I386Round;E 11I 11    I386Round;E 11#endifE 8E 5E 3D 11  result = arg1 + arg2;I 3D 4  if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(error_addr);E 4I 4D 5  if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(parg2);E 5I 5D 6  if (FPTEST) ERROR_EXIT(parg2);E 6I 6  if (FPTEST(result)) ERROR_EXIT(parg2);E 6E 5E 4E 3  wordp = createcell68k(TYPE_FLOATP);  *((float *)wordp) = result;  return(LADDR_from_68k(wordp));}  /* end N_OP_fplus2()  */E 11I 11    result = arg1 + arg2;    if (FPTEST(result)) ERROR_EXIT(parg2);    wordp = createcell68k(TYPE_FLOATP);    *((float *)wordp) = result;    return(LADDR_from_68k(wordp));  }  /* end N_OP_fplus2()  */E 11I 6D 7/*  ========================================================  */E 7I 7/************************************************************************//*									*//*		      N _ O P _ f d i f f e r e n c e			*//*									*//*	2-arugment floating-point subtraction.				*//*									*//************************************************************************/E 7E 6D 4N_OP_fdifference(parg1, parg2, error_addr)E 4I 4N_OP_fdifference(parg1, parg2)E 4D 6LispPTR parg1, parg2;E 6I 6LispPTR          parg1, parg2;E 6D 4int error_addr;E 4D 11{D 6register float arg1;register float arg2;E 6I 6register float arg1, arg2;E 6register float result;register DLword *wordp;E 11I 11  {    REGISTER float arg1, arg2;    REGISTER float result;    register DLword *wordp;E 11D 4#ifdef	TRACE	printPC();	printf("TRACE: N_OP_fdifference()\n");#endif  N_MakeFloat(parg1, arg1, error_addr);  N_MakeFloat(parg2, arg2, error_addr);E 4I 4D 11  N_MakeFloat(parg1, arg1, parg2);  N_MakeFloat(parg2, arg2, parg2);E 4I 3D 5  fpstatus_(&constant0);E 5I 5  FPCLEAR;E 11I 11    N_MakeFloat(parg1, arg1, parg2);    N_MakeFloat(parg2, arg2, parg2);    FPCLEAR;E 11I 8#ifdef I386D 11  I386Round;E 11I 11    I386Round;E 11#endifE 8E 5E 3D 11  result = arg1 - arg2;I 3D 4  if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(error_addr);E 4I 4D 5  if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(parg2);E 5I 5D 6  if (FPTEST) ERROR_EXIT(parg2);E 6I 6  if (FPTEST(result)) ERROR_EXIT(parg2);E 6E 5E 4E 3  wordp = createcell68k(TYPE_FLOATP);  *((float *)wordp) = result;  return(LADDR_from_68k(wordp));}  /* end N_OP_fdifference()  */E 11I 11    result = arg1 - arg2;    if (FPTEST(result)) ERROR_EXIT(parg2);    wordp = createcell68k(TYPE_FLOATP);    *((float *)wordp) = result;    return(LADDR_from_68k(wordp));  }  /* end N_OP_fdifference()  */E 11I 6D 7/*  ========================================================  */E 7I 7/************************************************************************//*									*//*			    N _ O P _ f t i m e s 2			*//*									*//*	Floating-point multiplication					*//*									*//************************************************************************/E 7E 6D 4N_OP_ftimes2(parg1, parg2, error_addr)E 4I 4N_OP_ftimes2(parg1, parg2)E 4D 6LispPTR parg1, parg2;E 6I 6LispPTR      parg1, parg2;E 6D 4int error_addr;E 4D 11{D 6register float arg1;register float arg2;E 6I 6register float arg1, arg2;E 6register float result;register DLword *wordp;E 11I 11  {    REGISTER float arg1, arg2;    REGISTER float result;    register DLword *wordp;E 11D 4#ifdef	TRACE	printPC();	printf("TRACE: N_OP_ftimes2()\n");#endifE 4I 3E 3D 4  N_MakeFloat(parg1, arg1, error_addr);  N_MakeFloat(parg2, arg2, error_addr);E 4I 4D 11  N_MakeFloat(parg1, arg1, parg2);  N_MakeFloat(parg2, arg2, parg2);E 4I 3D 5  fpstatus_(&constant0);E 5I 5  FPCLEAR;E 11I 11    N_MakeFloat(parg1, arg1, parg2);    N_MakeFloat(parg2, arg2, parg2);    FPCLEAR;E 11I 8#ifdef I386D 11  I386Round;E 11I 11    I386Round;E 11#endifE 8E 5E 3D 11  result = arg1 * arg2;I 3D 4  if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(error_addr);E 4I 4D 5  if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(parg2);E 5I 5D 6  if (FPTEST) ERROR_EXIT(parg2);E 6I 6  if (FPTEST(result)) ERROR_EXIT(parg2);E 6E 5E 4E 3  wordp = createcell68k(TYPE_FLOATP);  *((float *)wordp) = result;  return(LADDR_from_68k(wordp));}  /* end N_OP_ftimes2()  */E 11I 11    result = arg1 * arg2;    if (FPTEST(result)) ERROR_EXIT(parg2);    wordp = createcell68k(TYPE_FLOATP);    *((float *)wordp) = result;    return(LADDR_from_68k(wordp));  }  /* end N_OP_ftimes2()  */E 11I 6D 7/*  ========================================================  */E 7I 7/************************************************************************//*									*//*			N _ O P _ f q u o t i e n t			*//*									*//*	floating-point division						*//*									*//************************************************************************/E 7E 6D 4N_OP_fquotient(parg1, parg2, error_addr)E 4I 4N_OP_fquotient(parg1, parg2)E 4D 6LispPTR parg1, parg2;E 6I 6LispPTR        parg1, parg2;E 6D 4int error_addr;E 4D 11{D 6register float arg1;register float arg2;E 6I 6register float arg1, arg2;E 6register float result;register DLword *wordp;E 11I 11  {    REGISTER float arg1, arg2;    REGISTER float result;    register DLword *wordp;E 11D 4#ifdef	TRACE	printPC();	printf("TRACE: N_OP_fquotient()\n");#endif  N_MakeFloat(parg1, arg1, error_addr);  N_MakeFloat(parg2, arg2, error_addr);E 4I 4D 11  N_MakeFloat(parg1, arg1, parg2);  N_MakeFloat(parg2, arg2, parg2);E 4D 3  if (arg2 == 0.0) ERROR_EXIT(error_addr);E 3I 3D 5  fpstatus_(&constant0);E 5I 5  FPCLEAR;E 11I 11    N_MakeFloat(parg1, arg1, parg2);    N_MakeFloat(parg2, arg2, parg2);    FPCLEAR;E 11I 8#ifdef I386D 11  I386Round;E 11I 11    I386Round;E 11#endifE 8E 5E 3D 11  result = arg1 / arg2;E 11I 11    result = arg1 / arg2;E 11I 3D 4  if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(error_addr);E 4I 4D 5  if (fpstatus_(&constant0) & 0xf0) ERROR_EXIT(parg2);E 5I 5D 6  if (FPTEST) ERROR_EXIT(parg2);E 6I 6D 11  if (FPTEST(result)) ERROR_EXIT(parg2);E 6E 5E 4E 3  wordp = createcell68k(TYPE_FLOATP);  *((float *)wordp) = result;  return(LADDR_from_68k(wordp));}  /* end N_OP_fquotient()  */E 11I 11    if (FPTEST(result)) ERROR_EXIT(parg2);    wordp = createcell68k(TYPE_FLOATP);    *((float *)wordp) = result;    return(LADDR_from_68k(wordp));  }  /* end N_OP_fquotient()  */E 11I 6D 7/*  ========================================================  */E 7I 7/************************************************************************//*									*//*			N _ O P _ f g r e a t e r p			*//*									*//*	Floating-point >						*//*									*//************************************************************************/E 7E 6D 4N_OP_fgreaterp(parg1, parg2, error_addr)E 4I 4N_OP_fgreaterp(parg1, parg2)E 4D 6LispPTR parg1, parg2;E 6I 6LispPTR        parg1, parg2;E 6D 4int error_addr;E 4D 11{D 6register float arg1;register float arg2;E 6I 6register float arg1, arg2;E 6register DLword *wordp;register LispPTR lptr;E 11I 11  {    REGISTER float arg1, arg2;    register DLword *wordp;    register LispPTR lptr;E 11D 4#ifdef	TRACE	printPC();	printf("TRACE: N_OP_fgreaterp()\n");#endif  N_MakeFloat(parg1, arg1, error_addr);  N_MakeFloat(parg2, arg2, error_addr);E 4I 4D 11  N_MakeFloat(parg1, arg1, parg2);  N_MakeFloat(parg2, arg2, parg2);E 4  if (arg1 > arg2) return(ATOM_T);  else return(NIL_PTR);}  /* end N_OP_fgreaterp()  */E 11I 11    N_MakeFloat(parg1, arg1, parg2);    N_MakeFloat(parg2, arg2, parg2);    if (arg1 > arg2) return(ATOM_T);    else return(NIL_PTR);  }  /* end N_OP_fgreaterp()  */E 11D 11	/* end module */E 11D 6E 6E 1