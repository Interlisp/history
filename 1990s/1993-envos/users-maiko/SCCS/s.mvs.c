h35618s 00024/00010/00328d D 1.17 93/02/08 14:57:35 sybalsky 17 16c Big VM (and new CDR coding) changes for 3.0 \nes 00049/00010/00289d D 1.16 92/06/26 13:50:15 sybalsky 16 15c retrofit of 386 unix changes \nes 00005/00005/00294d D 1.15 92/04/21 17:21:00 sybalsky 15 14c shortening file names for DOS \nes 00005/00001/00294d D 1.14 91/07/21 12:41:25 sybalsky 14 13c Fix stg smash caused by simulate_unbind doing a MAKEFREEBLOCK.es 00004/00000/00291d D 1.13 91/04/16 17:30:25 sybalsky 13 12c Retrofit foreign-OS changes from Savoir.es 00000/00000/00291d D 1.12 91/02/26 14:27:11 sybalsky 12 11c Make VALUES, VALUES-LIST work with 3-byte atoms. (they didn't skip enough bytes in the FN1 \MVLIST opcode)es 00016/00006/00275d D 1.11 91/02/14 20:14:13 sybalsky 11 10c Make PC increment skip 4 bytes (for FN1 \MVLIST) if it's big atoms, rather than 3.es 00002/00002/00279d D 1.10 90/08/14 17:57:23 sybalsky 10 9c cast pc to unsigned to avoid sign extension problemes 00004/00004/00277d D 1.9 90/07/26 11:31:02 sybalsky 9 8c Make 3-byte atom changes under BIGATOMS, for FN opcode size difference, size of FN opcode's atom number.es 00002/00002/00279d D 1.8 90/07/25 01:00:51 sybalsky 8 7c Fix pointer/interger mismatch warning (pc as ByteCode * vs int)es 00000/00000/00281d D 1.7 90/04/20 01:50:54 sybalsky 7 6c AIX:  shortening file names, bulk change.es 00006/00004/00275d D 1.6 90/03/08 17:59:20 sybalsky 6 5c Fix Bus-error in SEdit / GC bug on EVAL in debugger.  PC wrong - 3 too big.es 00008/00007/00271d D 1.5 90/02/12 14:26:33 sybalsky 5 4c Make VALUES, VALUES-LIST opcodes robust agains compiler inserting UNBIND in the wrong place.es 00037/00004/00241d D 1.4 89/12/28 15:27:28 sybalsky 4 3c es 00003/00003/00242d D 1.3 89/10/19 18:00:54 sybalsky 3 2c comment changeses 00003/00003/00242d D 1.2 89/10/19 14:07:02 sybalsky 2 1c Walking up stack, FNHEAD's addr must be chopped to 24 bits.es 00245/00000/00000d D 1.1 89/05/15 17:28:26 sybalsky 1 0c date and time created 89/05/15 17:28:26 by sybalskyeuUtTI 1D 3/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(envos & Fuji Xerox)";E 3I 3D 11/* @(#) mvs.c Version 1.1 (5/15/89). copyright envos & Fuji Xerox  */static char *id = "@(#) mvs.c	1.1 5/15/89	(envos & Fuji Xerox)";E 11I 11/* @(#) mvs.c Version 1.1 (5/15/89). copyright Venue & Fuji Xerox  */static char *id = "@(#) mvs.c	1.1 5/15/89	(Venue & Fuji Xerox)";E 11E 3I 4E 4/************************************************************************//*									*/I 4D 11/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 11I 11/*	Copyright 1989, 1990 Venue.					*/E 11/*									*/D 11/*	This file is work-product resulting from the Xerox/Venue	*/E 11I 11/*	This file was work-product resulting from the Xerox/Venue	*/E 11/*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************//************************************************************************//*									*/E 4/*		M U L T I P L E - V A L U E   S U P P O R T		*//*			    F U N C T I O N S				*//*									*/D 2/*	Contains: values						*/E 2I 2D 3/*	Contains: values, values_list					*/E 3I 3D 4/*	Contains: values						*/E 4I 4/*	Contains: values, values_list					*/E 4E 3E 2/*									*//************************************************************************/#include <stdio.h>#include "lispemul.h"#include "lispmap.h"D 15#include "lispglobal.h"#include "emulglobal.h"#include "address68k.h"#include "lisptypes.h"E 15I 15#include "lspglob.h"#include "emlglob.h"#include "adr68k.h"#include "lsptypes.h"E 15#include "stack.h"#include "opcodes.h"I 13#ifdef AIXPS2D 15#include "inlinePS2.h"E 15I 15#include "inlnPS2.h"E 15D 17#endif AIXPS2E 17I 17#endif /* AIXPS2 */E 17I 17 /* to optionally swap the fnhead field of a frame */#ifdef BIGVM#define SWA_FNHEAD#else#define SWA_FNHEAD swapx#endif /* BIGVM */E 17E 13I 17E 17LispPTR MVLIST_index;/****************************************************************//*                                                              *//*                            VALUES                            *//*								*/D 4/*         C-coded version of the function CL:VALUES	       */E 4I 4/*         C-coded version of the function CL:VALUES		*/E 4/*								*//****************************************************************/D 4E 4LispPTR values (arg_count, args)  register LispPTR *args;  int arg_count;  {D 5    FX2 *caller, *prevcaller, *immediate_caller=0;E 5I 5    FX2 *caller, *prevcaller=0, *immediate_caller=0;E 5    ByteCode *pc;    int unbind_count=0;    struct fnhead *fnhead;D 16    short opcode;E 16I 16    int byteswapped;  /* T if on 386 & reswapped code block */	short opcode;E 16    caller = (FX2 *) CURRENTFX;    immediate_caller = caller;newframe:    if (caller == immediate_caller)      {	fnhead = (struct fnhead *) FuncObj;D 11	pc = (ByteCode *) PC+3;E 11I 11	pc = (ByteCode *) PC+3; /* to skip the miscn opcode we're in now */E 11      }    else      {	fnhead = (struct fnhead *)D 2		    Addr68k_from_LADDR(swapx((int)caller->fnheader));E 2I 2D 17		    Addr68k_from_LADDR(0xFFFFFF & swapx((int)caller->fnheader));E 17I 17		    Addr68k_from_LADDR(POINTERMASK & SWA_FNHEAD((int)caller->fnheader));E 17E 2	pc = (ByteCode *)fnhead+(caller->pc);      }I 16#ifdef ISC	if(!fnhead->byteswapped)	  {		byte_swap_code_block(fnhead);		fnhead->byteswapped=1;      }D 17#endif ISCE 17I 17#endif /* ISC */E 17I 17E 17	  E 16newpc:D 10    opcode = (short)GETBYTE((char *)pc);E 10I 10D 16    opcode = (short)((unsigned char)GETBYTE((char *)pc));E 10    switch (opcode)E 16I 16#ifdef ISC    opcode = (short)((unsigned char) *((char *)pc));#else	opcode = (short)((unsigned char)GETBYTE((char *)pc));#endif	switch (opcode)E 16      {	case opc_RETURN:	case opc_SLRETURN:  prevcaller = caller;			    caller = (FX2 *) (Stackspace+(int)(GETCLINK(caller)));			    goto newframe;D 9	case opc_FN1:   if (MVLIST_index == Get_DLword(pc+1))E 9I 9D 16	case opc_FN1:   if (MVLIST_index == Get_AtomNo(pc+1))E 16I 16	case opc_FN1:   if (MVLIST_index == Get_code_AtomNo(pc+1))E 16E 9			 {			   if (unbind_count > 0)			     simulate_unbind(caller, unbind_count, prevcaller);I 11#ifndef BIGATOMSE 11D 5			   if (caller == immediate_caller) PC += 3;E 5I 5D 6			   if (caller == immediate_caller) PC = pc+3;E 5			   else caller->pc += 3;E 6I 6			    /* would add 3 to  PC, but miscn return code does.*/			   if (caller == immediate_caller) PC = pc;I 11#elseD 17			   /* BUT 3's not enough for big atoms, so add 1 */			   if (caller == immediate_caller) PC = pc + 1;#endif BIGATOMSE 17I 17			   /* BUT 3's not enough for big atoms, so add diff between FN op size & MISCN op size */			   if (caller == immediate_caller) PC = pc + (FN_OPCODE_SIZE-3);#endif /* BIGATOMS */E 17E 11D 8			   else caller->pc = pc+ 3-(int)fnhead;E 8I 8D 9			   else caller->pc = (int)pc+ 3-(int)fnhead;E 9I 9			   else caller->pc = (int)pc+ FN_OPCODE_SIZE-(int)fnhead;E 9E 8E 6			   return(make_value_list(arg_count, args));			 }			break;	case opc_UNBIND:  pc += 1;			  unbind_count += 1;			  goto newpc;	case opc_JUMPX:  {			   register short displacement;I 16#ifdef ISC			   displacement = (short) (*((char *)pc+1));#elseE 16			   displacement = (short) (GETBYTE((char *)pc+1));I 16#endifE 16			   if (displacement >= 128) displacement -= 256;			   pc += displacement;			   goto newpc;			 }	case opc_JUMPXX:  {			    register int displacement;D 16			    displacement = (int) Get_DLword(pc+1);E 16I 16			    displacement = (int) Get_code_DLword(pc+1);E 16			    if (displacement >= 32768) displacement -= 65536;			    pc += displacement;			    goto newpc;			  }	default:  if ((opcode >= opc_JUMP) && (opcode < opc_FJUMP))		    {		      pc += 2 + opcode - opc_JUMP;		      goto newpc;		    }      }	/*****************************************/	/* Default case:  Return a single value. */	/*****************************************/    if (arg_count>0) return(args[0]);    else return(NIL_PTR);  }I 4E 4/****************************************************************//*                                                              *//*                            VALUES_LIST         		*//*								*//*         C-coded version of the function CL:VALUES-LIST 	*//*								*//****************************************************************/D 4E 4LispPTR values_list (arg_count, args)  register LispPTR *args;  int arg_count;  {D 5    FX2 *caller, *prevcaller, *immediate_caller=0;E 5I 5    FX2 *caller, *prevcaller=0, *immediate_caller=0;E 5    ByteCode *pc;    int unbind_count=0;    struct fnhead *fnhead;    short opcode;    caller = (FX2 *) CURRENTFX;    immediate_caller = caller;newframe:    if (caller == immediate_caller)      {	fnhead = (struct fnhead *) FuncObj;D 11	pc = (ByteCode *) PC+3;E 11I 11	pc = (ByteCode *) PC+3; /* Skip over the miscn opcode we're in now */E 11      }    else      {	fnhead = (struct fnhead *)D 2		    Addr68k_from_LADDR(swapx((int)caller->fnheader));E 2I 2D 17		    Addr68k_from_LADDR(0xFFFFFF & swapx((int)caller->fnheader));E 17I 17		    Addr68k_from_LADDR(POINTERMASK & SWA_FNHEAD((int)caller->fnheader));E 17E 2	pc = (ByteCode *)fnhead+(caller->pc);      }I 16#ifdef ISC	if(!fnhead->byteswapped)	  {		byte_swap_code_block(fnhead);		fnhead->byteswapped=1;      }D 17#endif ISCE 17I 17#endif /* ISC */E 17I 17E 17	  E 16newpc:D 10    opcode = (short)GETBYTE((char *)pc);E 10I 10D 16    opcode = (short)((unsigned char)GETBYTE((char *)pc));E 16I 16#ifdef ISC    opcode = (short)((unsigned char) *((char *)pc));#else	opcode = (short)((unsigned char)GETBYTE((char *)pc));#endifE 16E 10    switch (opcode)      {	case opc_RETURN:	case opc_SLRETURN:  prevcaller = caller;			    caller = (FX2 *) (Stackspace+(int)(GETCLINK(caller)));			    goto newframe;D 9	case opc_FN1:   if (MVLIST_index == Get_DLword(pc+1))E 9I 9D 16	case opc_FN1:   if (MVLIST_index == Get_AtomNo(pc+1))E 16I 16	case opc_FN1:   if (MVLIST_index == Get_code_AtomNo(pc+1))E 16E 9			 {D 5			   if (unbind_count > 0)E 5I 5			   if (unbind_count > 0) E 5			     simulate_unbind(caller, unbind_count, prevcaller);D 5			   if (caller == immediate_caller) PC += 3;E 5I 5D 6			   if (caller == immediate_caller) PC = pc+3;E 5			   else caller->pc += 3;E 6I 6			    /* would add 3 to PC, but miscn ret code does. */I 11#ifndef BIGATOMSE 11			   if (caller == immediate_caller) PC = pc;I 11#else			   /* BUT 3's not enough for big atoms, so add 1 */D 17			   if (caller == immediate_caller) PC = pc + 1;#endif BIGATOMSE 17I 17			   if (caller == immediate_caller) PC = pc + (FN_OPCODE_SIZE-3);#endif /* BIGATOMS */E 17E 11D 8			   else caller->pc = pc+ 3-(int)fnhead;E 8I 8D 9			   else caller->pc = (int)pc+ 3-(int)fnhead;E 9I 9			   else caller->pc = (int)pc+ FN_OPCODE_SIZE-(int)fnhead;E 9E 8E 6			   return(args[0]);			 }			break;	case opc_UNBIND:  pc += 1;			  unbind_count += 1;			  goto newpc;	case opc_JUMPX:  {			   register short displacement;D 16			   displacement = (short) (GETBYTE((char *)pc+1));			   if (displacement >= 128) displacement -= 256;E 16I 16#ifdef ISC			 displacement = (short) (*((char *)pc+1));#else			 displacement = (short) (GETBYTE((char *)pc+1));#endif			 if (displacement >= 128) displacement -= 256;E 16			   pc += displacement;			   goto newpc;			 }	case opc_JUMPXX:  {			    register int displacement;D 16			    displacement = (int) Get_DLword(pc+1);E 16I 16			    displacement = (int) Get_code_DLword(pc+1);E 16			    if (displacement >= 32768) displacement -= 65536;			    pc += displacement;			    goto newpc;			  }	default:  if ((opcode >= opc_JUMP) && (opcode < opc_FJUMP))		    {		      pc += 2 + opcode - opc_JUMP;		      goto newpc;		    }      }	/*****************************************/	/* Default case:  Return a single value. */	/*****************************************/    if (Listp(args[0])) return(car(args[0]));    else return(args[0]);  }I 4/************************************************************************//*									*//*			m a k e _ v a l u e _ l i s t			*//*									*//*	Given a count of values to return, and a pointer to an		*//*	array containing the values, CONS up a list that contains	*//*	the values.  This is because MVs are really returned on		*//*	the stack as a list -- SHOULD BE CHANGED!			*//*									*//************************************************************************/E 4make_value_list(argcount, argarray)  int argcount;  LispPTR *argarray;  {    register LispPTR result = NIL_PTR;    register int i;    if (argcount == 0) return(NIL_PTR);    for (i = argcount-1; i>=0; i--)      {	result = cons(argarray[i], result);      }    return(result);  }I 4/************************************************************************//*									*//*		     s i m u l a t e _ u n b i n d			*//*									*//*	Simulate the effect of UNBIND on a frame, to back us up		*//*	to where we ought to be when we return multiple values.		*//*									*//*									*//*									*//************************************************************************/E 4simulate_unbind(frame, unbind_count, returner)  FX2 *frame, *returner;  int unbind_count;  {    int unbind;    LispPTR *stackptr;    DLword *nextblock;    stackptr = (LispPTR *) (Stackspace+frame->nextblock);    nextblock = (DLword *) stackptr;    for (unbind = 0; unbind<unbind_count; unbind++)      {	register int value;	register LispPTR *lastpvar;	int bindnvalues;	for (;((int)*--stackptr>=0);); /* find the binding mark */	value = (int)*stackptr;	lastpvar = (LispPTR *) ((DLword *)frame + FRAMESIZE + 2 + GetLoWord(value));;	bindnvalues = (~value)>>16;	for(value=bindnvalues; --value >= 0;){*--lastpvar = 0xffffffff;}D 14	MAKEFREEBLOCK(stackptr, (DLword *)stackptr-nextblock);E 14I 14	/* This line caused \NSMAIL.READ.HEADING to smash memory, */	/* so I removed it 21 Jul 91 --JDS.  This was the only	  */	/* difference between this function and the UNWIND code   */	/* in inlineC.h						  *//*	MAKEFREEBLOCK(stackptr, (DLword *)stackptr-nextblock); */E 14      }D 5    returner->fast = 0;	/* since we've destroyed congituity in the stack */E 5I 5    if (returner) returner->fast = 0;	/* since we've destroyed congituity					/* in the stack, but that only					   matters if there's a return. */E 5  }I 17E 17E 1