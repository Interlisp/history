h05167s 00004/00001/00101d D 2.2 88/05/27 14:48:14 krivacic 5 4c C_ONLY ifdefes 00000/00000/00102d D 2.1 88/05/17 09:21:31 hayata 4 3c Version up to 2.1es 00002/00002/00100d D 1.3 88/03/13 14:31:45 hayata 3 2c Add SCCS key id (%Z%)es 00036/00000/00066d D 1.2 88/03/09 18:24:39 krivacic 2 1c Native Vag2 functiones 00066/00000/00000d D 1.1 88/02/24 16:55:33 hayata 1 0c date and time created 88/02/24 16:55:33 by hayataeuUtTI 1D 3/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 3I 3/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 3/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther	:	Hiroshi Hayata	 */#include <stdio.h>#include "lispemul.h"#include "lispglobal.h"#include "emulglobal.h"#include "address68k.h"#include "lispmap.h"#include "lisptypes.h"#include "arith.h"D 5#define	FIXPTYPE	2E 5I 5#ifdef C_ONLYE 5#define	VAG2		0321/************************************************************OP_vag2	entry		VAG2		OPCODE[0321]	1.	<<Entrer>>		*CurrentStackPTR	:	High address (16 bit)		TopOfStack		:	Low address (16 bit)	2.	If size of both address is not proper, call error.	3.	produce address from *CurrentStackPTR and TopOfStack.		4.	increment PC.	5.	decrement CurrentStackPTR by 2.	6.	<<Exit>>		TopOfStack		:	produced address (24 bit)						Lisp Address************************************************************/OP_vag2(){#ifdef	TRACE	printPC();	printf("TRACE: OP_vag2()\n");#endif	if( (0xFFFF0000 & TopOfStack ) != S_POSITIVE ){#ifdef	DEBUG	printf("DEBUG: OP_vag2[Bad argument. Small number only.]\n");#endif		/**** call \VAG2 Lisp Func. ****/		ufn(VAG2);		return;	}/*CSP	if(*(CurrentStackPTR-1) != SPOS_HI){	*/	if(*(CurrentStackPTR) != SPOS_HI){#ifdef	DEBUG	printf("DEBUG: OP_vag2[Bad argument. Small number only.]\n");#endif		/**** call \VAG2 Lisp Func. ****/		ufn(VAG2);		return;	}	TopOfStack = (0xFFFF0000 & ((*(CurrentStackPTR+1)) << 16)) | (0xFFFF & TopOfStack);	CurrentStackPTR -= 2;	++PC;}I 2I 5#elseE 5/************************************************************N_OP_vag2	entry		VAG2		OPCODE[0321]	return ( (a << 16 ) | b)************************************************************/N_OP_vag2(a, b, error_addr)  register int a, b;  int *error_addr;{#ifdef	TRACE	printPC();	printf("TRACE: N_OP_vag2()\n");#endif	if( (0xFFFF0000 & a ) != S_POSITIVE ){#ifdef	DEBUG	printf("DEBUG: OP_vag2[Bad argument. Small number only.]\n");#endif		/**** call \VAG2 Lisp Func. ****/		ERROR_EXIT(error_addr);	}	if(0xFFFF0000 & b != S_POSITIVE){#ifdef	DEBUG	printf("DEBUG: OP_vag2[Bad argument. Small number only.]\n");#endif		/**** call \VAG2 Lisp Func. ****/		ERROR_EXIT(error_addr);	}	return((0xFFFF0000 & (a << 16)) | (0xFFFF & b));}I 5#endifE 5E 2E 1