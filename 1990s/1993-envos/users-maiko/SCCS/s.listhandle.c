h23602s 00000/00000/00136d D 2.16 90/04/20 01:46:54 sybalsky 19 18c AIX:  shortening file names, bulk change.es 00023/00000/00113d D 2.15 90/02/12 11:51:34 takeshi 18 17c program I/F for fmembes 00015/00015/00098d D 2.14 89/01/09 17:18:33 shih 17 16c spellinges 00011/00026/00102d D 2.13 88/10/12 14:44:17 krivacic 16 15c new out-of-line interfacees 00000/00006/00128d D 2.12 88/10/10 14:07:12 krivacic 15 14c sun3/4 mergees 00003/00000/00131d D 2.11 88/10/06 18:40:31 krivacic 14 13c sun3/4 mergees 00032/00032/00099d D 2.10 88/08/11 22:43:24 shih 13 12c listget was punting if prop not found in list.  now fixedes 00014/00004/00117d D 2.9 88/08/01 14:21:56 shimizu 12 11c Add SAVE_ERROR_EXIT2,S_N_CHECKANDCADR2es 00005/00005/00116d D 2.8 88/07/29 17:36:01 shimizu 11 10c Add SAVE_ERROR_EXIT and S_N_CHECKANDCADes 00013/00006/00108d D 2.7 88/07/27 17:35:37 shimizu 10 9c  Enable to continue the execution for timer interruptes 00007/00095/00107d D 2.6 88/07/08 10:59:29 bane 9 8c Fixed N_OP in bad context bug in LISTGETes 00019/00034/00183d D 2.5 88/06/29 15:13:26 bane 8 7c improved fmembes 00003/00001/00214d D 2.4 88/06/21 13:52:06 krivacic 7 6c fix listget ar 10423es 00003/00000/00212d D 2.3 88/06/08 10:04:55 charnley 6 5c added interrupt test to fmembes 00006/00001/00206d D 2.2 88/05/27 14:57:46 krivacic 5 4c C_ONLY ifdef & fix compilation errorses 00000/00000/00207d D 2.1 88/05/17 09:25:39 hayata 4 3c Version up to 2.1es 00084/00000/00123d D 1.3 88/03/29 18:51:02 krivacic 3 2c New Interfaceses 00002/00002/00121d D 1.2 88/03/13 14:53:24 hayata 2 1c Add SCCS key id (%Z%)es 00123/00000/00000d D 1.1 88/02/24 16:57:49 hayata 1 0c date and time created 88/02/24 16:57:49 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 17/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 17I 17/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 17static char *id = "%Z% %M%	%I% %G%";E 2/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 17 *	Auther :  Takeshi ShimizuE 17I 17 *	Author :  Takeshi ShimizuE 17 * *//***********************************************************************//*D 17 		File Name :	listhandle.cD 10		Desc	:	rplconsE 10  				Date :		Jul. 4, 1987 				Edited by :	Takeshi ShimizuE 17I 17		File Name :	listhandle.c				Date :		Jul. 4, 1987				Edited by :	Takeshi ShimizuE 17				Changed :	16-Oct,1987 takeD 17 E 17I 17E 17		Including :	OP_fmemb				OP_listgetD 17								E 17I 17E 17*//**********************************************************************/#include "lispemul.h"#include "emulglobal.h"#include "lispglobal.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"D 17#include "cell.h"    E 17I 17#include "cell.h"E 17I 14D 15#ifndef MVECE 14I 6extern int Irq_Stk_End;I 14#endifE 14I 10extern int Scratch_CSTK;E 10E 15E 6I 5D 9#ifdef C_ONLYE 9E 5D 9/*   (FMEMB item TopOfStack) */OP_fmemb(){  /* OP 34Q */D 8 register LispPTR item; register struct cadr_cell cadrobj; struct cadr_cell cadr();E 8I 8 register LispPTR item = *((LispPTR *)(CurrentStackPTR)); register LispPTR lptr = TopOfStack;E 8D 8 item = *((LispPTR *)(CurrentStackPTR));E 8#ifdef TRACE	printf("TRACE: OP_fmemb \n");	print(item);	print(TopOfStack);#endifD 8  if(TopOfStack != NIL_PTR)    {CheckAndCadr(TopOfStack, cadrobj, 034);	while(cadrobj.car_cell != item)E 8I 8	while(Listp(lptr))E 8	  {D 8		if(cadrobj.cdr_cell == NIL_PTR)		 { /* we can't find item */			TopOfStack = NIL_PTR;			goto deguti ;		 }		TopOfStack=cadrobj.cdr_cell;		CheckAndCadr(cadrobj.cdr_cell,cadrobj,034);E 8I 8	  if(item == car(lptr)) {		TopOfStack = lptr;		goto deguti;	  }	  lptr = cdr(lptr);E 8			  }D 8   }E 8I 8	  if(lptr) ufn(034);	  else TopOfStack = NIL;E 8deguti: CurrentStackPTR -= 2; PC++;} /* OP_fmemb end *//***************************************//***********************************************************************//* 		Func Name :	OP_listget 				Date :		Jul. 4, 1987 				Edited by :	Takeshi Shimizu				Changed :	16-Nov,1987 take *//**********************************************************************/OP_listget(){ /* OP 47Q */ register LispPTR plist ; register struct cadr_cell cadrobj; struct cadr_cell cadr(); /* TOS has PORP item */ plist = *((LispPTR *)(CurrentStackPTR));#ifdef TRACE	printf("TRACE: OP_listget \n");	print(plist);	print(TopOfStack);#endif  if(plist != NIL_PTR)   {	CheckAndCadr(plist,cadrobj,047);	 	while(cadrobj.car_cell != TopOfStack)	 {		if(cadrobj.cdr_cell == NIL_PTR)		 { /* this list ended before we find prop */			goto nilret;		 }				CheckAndCadr(cdr(cadrobj.cdr_cell),cadrobj,047) ;	 }	/* set prop to TOS */	TopOfStack = car( cadrobj.cdr_cell) ;	CurrentStackPTR -=2;	PC++;	return;  } nilret:TopOfStack = NIL_PTR;	CurrentStackPTR -=2;	PC++;	return; }/* OP_listget end */I 3I 5#elseE 5/***********************************************************************/E 9I 9/***********************************************************************/E 9/*	 N_OP_fmemb							*//**********************************************************************/D 16LispPTR N_OP_fmemb(item, tos, error_addr)E 16I 16LispPTR N_OP_fmemb(item, tos)E 16	register LispPTR item, tos;D 16	int *error_addr;E 16{  /* OP 34Q */D 8 register struct cadr_cell cadrobj;I 5 struct cadr_cell cadr();E 8E 5D 16#ifdef TRACE	printf("TRACE: OP_fmemb \n");	print(item);	print(tos);#endifE 16D 8  if(tos != NIL_PTR)    {N_CHECKANDCADR(tos, cadrobj, error_addr);	while(cadrobj.car_cell != item)	  {		if(cadrobj.cdr_cell == NIL_PTR)		 { /* we can't find item */			tos = NIL_PTR;			goto deguti ;		 }		tos=cadrobj.cdr_cell;D 5		CheckAndCadr(cadrobj.cdr_cell,cadrobj,error_addr);E 5I 5		N_CHECKANDCADR(cadrobj.cdr_cell,cadrobj,error_addr);E 5			  }   }deguti: return(tos);E 8I 8	while(Listp(tos)) {D 9		if(item == N_OP_car(tos, error_addr))E 9I 9		if(item == car(tos))E 9			return tos;D 9		tos = N_OP_cdr(tos, error_addr);E 9I 9		tos = cdr(tos);E 9		/* if we get an interrupt, punt so we can handle it safely */D 10		if(!Irq_Stk_End) ERROR_EXIT(error_addr);E 10I 10		if(!Irq_Stk_End) {D 16			TopOfStack = tos; /* for continuation */			TIMER_EXIT(error_addr);E 16I 16			TIMER_EXIT(tos);E 16		}E 10	}D 11	if(tos) ERROR_EXIT(error_addr);E 11I 11D 16	if(tos) SAVE_ERROR_EXIT(tos,error_addr);E 16I 16	if(tos) ERROR_EXIT(tos);E 16E 11	return tos;E 8} /* N_OP_fmemb end */I 18/***********************************************************************//*	 	Func Name :	fmemb(item,list)	>>For User programming<<	NOTE: You should not handle long list, because it doesn't care		about interrupt.*//**********************************************************************/LispPTR fmemb(item, list)	register LispPTR item, list;{  	while(Listp(list)) {		if(item == car(list))			return (list);		list = cdr(list);	}	if(list) return(list);	return (list);} /* fmemb end */E 18I 13E 13/***********************************************************************//*D 17 		Func Name :	N_OP_listgetE 17I 17		Func Name :	N_OP_listgetE 17D 13 				Date :		March. 29, 1988 				Edited by :	Bob KrivacicE 13I 13		Opcode	:	47QE 13 *//**********************************************************************/I 12D 13#define SAVE_ERROR_EXIT2(topcstk , x) { Scratch_CSTK= topcstk; return(fixra(x));}#define S_N_CHECKANDCADR2(sour, dest, ufn_addr, tcstk)             \E 13I 13extern struct cadr_cell cadr();	/** declaration only **/D 16#define SAVE_ERROR_EXIT2(topcstk,x) { Scratch_CSTK= topcstk; return(fixra(x));}E 16I 16#define SAVE_ERROR_EXIT2(topcstk,tos) {Scratch_CSTK=topcstk; ERROR_EXIT(tos);}E 16D 16#define S_N_CHECKANDCADR2(sour,dest,ufn_addr,tcstk)             \E 16I 16#define S_N_CHECKANDCADR2(sour,dest,tos,tcstk)             \E 16E 13                {register LispPTR parm = sour;                  \                 if(GetTypeNumber(parm) != TYPE_LISTP){         \D 16                        SAVE_ERROR_EXIT2(tcstk,ufn_addr);       \E 16I 16                        SAVE_ERROR_EXIT2(tcstk,tos);       \E 16                }else                                           \                        dest = cadr(parm);                      \                }E 12I 12D 13E 13E 12D 16LispPTR N_OP_listget(plist, tos, error_addr)E 16I 16LispPTR N_OP_listget(plist, tos)E 16	register LispPTR plist;	register LispPTR tos;D 16	int *error_addr;E 16D 13{ /* OP 47Q */E 13I 13{E 13 register struct cadr_cell cadrobj;D 13 struct cadr_cell cadr();E 13D 13E 13D 16#ifdef TRACE	printf("TRACE: N_OP_listget \n");	print(plist);	print(tos);#endifE 16D 13  if(plist != NIL_PTR)   {D 11	N_CHECKANDCADR(plist,cadrobj,error_addr);E 11I 11D 12	S_N_CHECKANDCADR(plist,cadrobj,error_addr,tos);E 12I 12	S_N_CHECKANDCADR2(plist,cadrobj,error_addr,plist);E 12E 11D 10	 	while(cadrobj.car_cell != tos)E 10I 10	 while(cadrobj.car_cell != tos)E 10	 {D 9		if(cadrobj.cdr_cell == NIL_PTR)E 9I 9		if(!Listp(cadrobj.cdr_cell))E 9		 { /* this list ended before we find prop */			goto nilret;		 }I 6D 7		if (!Irq_Stk_End) ERROR_EXIT(error_addr);E 7I 7D 10		if ( (GetTypeNumber(cadrobj.cdr_cell) != TYPE_LISTP) ||		     (!Irq_Stk_End) )  ERROR_EXIT(error_addr);E 10I 10		if (GetTypeNumber(cadrobj.cdr_cell) != TYPE_LISTP) E 13I 13 while ( plist != NIL_PTR ) {D 16	S_N_CHECKANDCADR2(plist, cadrobj, error_addr, plist);E 16I 16	S_N_CHECKANDCADR2(plist, cadrobj, tos, plist);E 16	if ( cadrobj.car_cell == tos ) {		if(cadrobj.cdr_cell == NIL_PTR) return NIL_PTR;		if(Listp(cadrobj.cdr_cell))			return(car(cadrobj.cdr_cell));		else    /* must punt in case car/cdrerr */E 13D 11			ERROR_EXIT(error_addr);E 11I 11D 12			SAVE_ERROR_EXIT(tos,error_addr);E 12I 12D 16			SAVE_ERROR_EXIT2(plist,error_addr);E 16I 16			SAVE_ERROR_EXIT2(plist,tos);E 16E 12E 11D 13		if (!Irq_Stk_End) {			/* for continuation,it becomes plist on next time */			Scratch_CSTK = cdr(cadrobj.cdr_cell);			TIMER_EXIT(error_addr);E 13		}E 10E 7E 6D 11		N_CHECKANDCADR(cdr(cadrobj.cdr_cell),cadrobj,error_addr) ;E 11I 11D 12		S_N_CHECKANDCADR(cdr(cadrobj.cdr_cell),cadrobj,error_addr,tos) ;E 12I 12D 13		S_N_CHECKANDCADR2(cdr(cadrobj.cdr_cell),cadrobj,error_addr,plist) ;E 12E 11	 }	/* set prop to TOS */E 13I 13	if( ! Listp(cadrobj.cdr_cell) )		{ /* this list ended before we find prop */		return ( NIL_PTR );		}E 13D 9	return(car( cadrobj.cdr_cell));E 9I 9D 13	if(cadrobj.cdr_cell == NIL_PTR) return NIL_PTR;	else if(Listp(cadrobj.cdr_cell)) return(car(cadrobj.cdr_cell));D 11	else ERROR_EXIT(error_addr);E 11I 11D 12	else SAVE_ERROR_EXIT(tos,error_addr);E 12I 12	else 		SAVE_ERROR_EXIT2(plist,error_addr);E 12E 11E 9  }E 13I 13D 16	S_N_CHECKANDCADR2(cadrobj.cdr_cell, cadrobj, error_addr, plist);E 16I 16	S_N_CHECKANDCADR2(cadrobj.cdr_cell, cadrobj, tos, plist);E 16	plist = cadrobj.cdr_cell;E 13D 13 nilret: return(NIL_PTR);E 13I 13	if (!Irq_Stk_End) {D 17		/* for continuation,it becomes plist on next time */E 17I 17		/* for continuation, it becomes plist on next time */E 17		Scratch_CSTK = plist;D 16		TIMER_EXIT(error_addr);E 16I 16		TIMER_EXIT(tos);E 16		}D 17	}      E 17I 17	}E 17 return(NIL_PTR);E 13D 17 E 17I 17E 17}/* N_OP_listget end */I 13E 13D 9I 5#endifE 9E 5E 3E 1