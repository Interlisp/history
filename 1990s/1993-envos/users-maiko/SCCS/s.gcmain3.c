h42230s 00111/00066/00435d D 2.9 93/02/08 14:52:51 sybalsky 12 11c Big VM (and new CDR coding) changes for 3.0 \nes 00207/00000/00294d D 2.8 92/06/26 13:49:00 sybalsky 11 10c retrofit of 386 unix changes \nes 00004/00004/00290d D 2.7 92/04/21 17:13:56 sybalsky 10 9c shortening file names for DOS \nes 00014/00006/00280d D 2.6 91/01/25 17:58:39 sybalsky 9 8c 3-byte atomses 00085/00092/00201d D 2.5 90/06/15 16:53:50 mitani 8 7c cleanup gcmapscan gcunmapscanes 00001/00001/00292d D 2.4 90/04/20 01:36:45 sybalsky 7 6c AIX:  shortening file names, bulk change.es 00009/00009/00284d D 2.3 89/03/28 01:43:38 sybalsky 6 5c word-swapped pointer fixeses 00187/00158/00106d D 2.2 88/09/27 16:23:30 krivacic 5 4c mergs sun 4 gces 00000/00000/00264d D 2.1 88/05/17 09:24:41 hayata 4 3c Version up to 2.1es 00002/00002/00262d D 1.3 88/05/09 21:13:19 shih 3 2c Use GCLOOKUPes 00002/00002/00262d D 1.2 88/03/13 14:49:35 hayata 2 1c Add SCCS key id (%Z%)es 00264/00000/00000d D 1.1 88/02/24 16:57:14 hayata 1 0c date and time created 88/02/24 16:57:14 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 9/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 9I 9D 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 12I 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Venue  */E 12E 9static char *id = "%Z% %M%	%I% %G%";E 2D 5/*** ADOPTED NEW VERSION ***/E 5I 9I 12E 12/************************************************************************//*									*/D 12/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 12I 12/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 12/*									*/D 12/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 12I 12/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 12/*									*//************************************************************************/E 9/*************************************************************************/D 9/*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 *//*************************************************************************/E 9/*                                                                       *//*                       File Name : gcmain3.c                           *//*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : July-7-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions : gcmapscan();                                    *//*                       gcmapunscan();                                  *//*                       gcscanstack();                                  *//*                                                                       *//*                                                                       *//*************************************************************************//*           Descreption :                                               *//*                                                                       *//*************************************************************************//*                                                               \Tomtom *//*************************************************************************/#include "lispemul.h"I 12#include "lispmap.h"E 12D 10#include "lisptypes.h"E 10I 10#include "lsptypes.h"E 10#include "address.h"D 10#include "address68k.h"#include "lispglobal.h"#include "emulglobal.h"E 10I 10#include "adr68k.h"#include "lspglob.h"#include "emlglob.h"E 10#include "stack.h"#include "cell.h"#include "ifpage.h"#include "gc.h"I 11#ifdef GCC386#include "inlnPS2.h"#endifE 11D 12#define HTMAIN_SIZE	0x8000   /* this will be deleted in including map */#define STK_HI		1	/* This is also. */E 12#define WORDSPERCELL	2#define CONSPAGE_LAST	0x0ffff#define MAXHTCNT	63#define PADDING	4#define FNOVERHEADWORDS	8I 12#define ADD_OFFSET(ptr, dloffset) ((LispPTR *) ((DLword *) (ptr) + (dloffset)))#ifdef BIGVM#define BIND_BITS(value)	((unsigned int) (value) >> 28)#define BF_FLAGS(value)		((unsigned int) (value) >> 29)#define PTR_BITS(entry)		((unsigned int)(entry) & POINTERMASK)#define GetSegnuminColl(entry1) (((entry1) & 0xFFFE) >> 1)#define GetStkCnt(entry1)	((entry1) >> 16)#define StkCntIsZero(entry1)	(!((entry1) & 0xFFFF0000))#define StkrefP(entry1)		((entry1) & 0x10000)#define SinglerefP(entry1)	(((entry1) & 0xFFFE0000) == 0x20000)#define Boundp(frame_field)	((frame_field) == 0)#define Stkref(ptr)		REC_GCLOOKUP(ptr, STKREF)#define GcreclaimLp(ptr) 	while((ptr = gcreccell(ptr)) != NIL)  \				  REC_GCLOOKUP(ptr, ADDREF)#define HTLPTR ((struct htlinkptr *) (entry))#define HENTRY ((struct hashentry *) (entry))#define HTMAIN_ENTRY_COUNT (HTMAIN_SIZE >> 1)#define STKREFBIT 0x10000	/* the bit that says "I'm on the stack" */#elseE 12I 5#define BIND_BITS(value)	((unsigned int) (value) >> 24)#define BF_FLAGS(value)		((unsigned int) (value) >> 29)#define PTR_BITS(entry)		((unsigned int)((unsigned int)((entry) << 8) >> 8))D 12#define ADD_OFFSET(ptr, dloffset) ((LispPTR *) ((DLword *) (ptr) + (dloffset)))E 12E 5D 8#define GetLinkptr(entry)	(entry & 0x0fffe)E 8#define GetSegnuminColl(entry1) 	((entry1 & 0x01fe) >> 1)D 12#define GetCountinColl(entry1) 	((entry1 & 0x0fc00) >> 10)E 12#define GetStkCnt(entry1)	((entry1 & 0x0fe00) >> 9)D 12#define GetStkrefinColl(entry1)	((entry1 & 0x0200) >> 9)I 8#define StkCntIsZero(entry1)	(!(entry1 & 0x0fe00))#define StkrefP(entry1)		(entry1 & 0x0200)#define SinglerefP(entry1)	((entry1 & 0xFC00) == 0x0400)E 12I 12#define StkCntIsZero(entry1)	(!((entry1) & 0x0fe00))#define StkrefP(entry1)		((entry1) & 0x0200)#define SinglerefP(entry1)	(((entry1) & 0xFC00) == 0x0400)E 12E 8D 5#define Boundp(frame_field)	((frame_field == 0)?1:0)E 5I 5#define Boundp(frame_field)	((frame_field) == 0)E 5D 3#define Stkref(ptr)		gclookup((0X8000 | STKREF), ptr)E 3I 3D 8#define Stkref(ptr)		GCLOOKUP(0x8000, STKREF, ptr)E 8I 8#define Stkref(ptr)		REC_GCLOOKUP(ptr, STKREF)E 8E 3D 7#define GcreclaimLp(ptr) 	while((ptr = gcreclaimcell(ptr)) != NIL)  \E 7I 7#define GcreclaimLp(ptr) 	while((ptr = gcreccell(ptr)) != NIL)  \E 7D 3				  gclookup((0x8000 | ADDREF), ptr)E 3I 3D 8				  GCLOOKUP(0x8000, ADDREF, ptr)E 8I 8				  REC_GCLOOKUP(ptr, ADDREF)E 8I 5D 6#define HTLPTR ((struct htlinkptr *) entry)E 6I 6#define HTLPTR ((struct htlinkptr *) WORDPTR(entry))#define HENTRY ((struct hashentry *) WORDPTR(entry))I 12#define HTMAIN_ENTRY_COUNT HTMAIN_SIZE#define STKREFBIT 0x200#endif /* BIGVM */E 12E 6E 5E 3I 8I 11D 12E 12#ifdef GCC386		/* byte-swapped, 386 assembler version */E 11E 8D 6E 6gcmapscan()I 11  {    volatile DLword probe;    volatile DLword *entry;    volatile DLword offset;    volatile LispPTR ptr;    asm volatile(" \n\	movl $32768,%%edi	/ probe = HTSIZE.			\n\	.align 4							\n\nextentry:			/ nextentry:				\n\	decl %%edi							\n\	js returNIL							\n\	leal 0(,%%edi,2),%%esi						\n\	addl HTmain,%%esi	/htlptr = (struct htlinkptr *)(HTmain+probe);	\n\	.align 4							\n\scanloop:								\n\	movl %%esi,%%edx						\n\	xorb $2,%%dl							\n\	movzwl (%%edx),%%eax	/ contents = ((struct htlinkptr *)WORDPTR(htlptr))->contents	\n\	testl %%eax,%%eax	/ if (contents && 			\n\	je scanbot							\n\	testb $1,%%al							\n\	jne scanok							\n\	testb $254,%%ah							\n\	jne scanbot							\n\scanok:									\n\	jmp scandone							\n\	.align 4							\n\scanbot:								\n\	addl $-2,%%esi		/ end of while loop.			\n\	decl %%edi							\n\	jns scanloop							\n\	jmp returNIL							\n\									\n\									\n\scandone:								\n\	movl %%edx,%0	/ entry = (DLword *) HTmain + probe.		\n\retry:	/ retry:							\n\	movl %0,%%ecx							\n\	movzwl (%%ecx),%%eax						\n\	testb $1,%%al		/ if HENTRY->collision,			\n\	je nocollision							\n\	xorl %%esi,%%esi		/ prev = 0			\n\	andl $65534,%%eax						\n\linkloop:		// linkloop:					\n\	leal 0(,%%eax,2),%%ecx						\n\	addl HTcoll,%%ecx						\n\	movw 2(%%ecx),%%ax	/ offset = ((struct htcoll *)link)->free_ptr;	\n\	testb $254,%%ah		/ if StkCountIsZero(offset)		\n\	jne stknz							\n\	sall $15,%%eax		/	, (probe << 1));		\n\	andl $16711680,%%eax						\n\	leal 0(,%%edi,2),%%edx						\n\	orl %%eax,%%edx							\n\	movl %%edx,%2	/ to ptr.					\n\	testl %%esi,%%esi		/ DelLink.  if (prev != 0)	\n\	je prevZ							\n\	leal 2(%%esi),%%edx	/ GETWORD((DLword *)prev + 1) = GETWORD((DLword *)link + 1)	\n\	xorb $2,%%dl							\n\	leal 2(%%ecx),%%eax						\n\	xorb $2,%%al							\n\	movw (%%eax),%%ax						\n\	jmp freelink							\n\	.align 4							\n\prevZ:	\n\	movl %0,%%edx	/ else GETWORD((DLword *)entry) = GETWORD((DLword *)link + 1)	\n\	leal 2(%%ecx),%%eax	\n\	xorb $2,%%al	\n\	movw (%%eax),%%ax	\n\	orb $1,%%al	\n\freelink:	/ FreeLink	\n\	movw %%ax,(%%edx)	\n\	movl %%ecx,%%eax	\n\	xorb $2,%%al	\n\	movw $0,(%%eax)	\n\	leal 2(%%ecx),%%eax	\n\	xorb $2,%%al	\n\	movl HTcoll,%%edx	/ GETWORD(link+1) = GETWORD(HTcoll);	\n\	xorb $2,%%dl	\n\	movw (%%edx),%%dx	\n\	movw %%dx,(%%eax)	\n\	movl HTcoll,%%edx	/ GETWORD(HTcoll) = (link - HTcoll);	\n\	xorb $2,%%dl	\n\	movl %%ecx,%%eax	\n\	subl HTcoll,%%eax	\n\	sarl $1,%%eax	\n\	movw %%ax,(%%edx)	\n\	movl %0,%%esi	/ link = (DLword *)HTcoll + GetLinkptr(GETWORD((DLword *)entry	\n\	movw (%%esi),%%ax	\n\	andl $65534,%%eax	\n\	addl %%eax,%%eax	\n\	movl %%eax,%%ecx	\n\	addl HTcoll,%%ecx	\n\	leal 2(%%ecx),%%edx	/ if (GETWORD((DLword *)link + 1) == 0) {	\n\	xorb $2,%%dl	\n\	cmpw $0,(%%edx)	\n\	jne sgclp1	\n\	movl %%ecx,%%eax	/ GETWORD((DLword *)entry) = GETWORD((DLword *)link)	\n\	xorb $2,%%al	\n\	movw (%%eax),%%bx	\n\	movw %%bx,(%%esi)	\n\	movw $0,(%%eax)		/ FreeLink: GETWORD(link) = 0	\n\	movl HTcoll,%%eax	/ GETWORD(link+1) = GETWORD(HTcoll)	\n\	xorb $2,%%al	\n\	movw (%%eax),%%bx	\n\	movw %%bx,(%%edx)	\n\	movl %%ecx,%%ebx	\n\	subl HTcoll,%%ebx	\n\	sarl $1,%%ebx	\n\	movw %%bx,(%%eax)	\n\	.align 4	\n\sgclp1:	/ start of gcloop 1 - do setup		\n\	movl GcDisabled_word,%%ecx		\n\	movl	MDStypetbl,%%ebx		\n\gclp1:		/ GcreclaimLp:	\n\	pushl %2	\n\	call gcreccell	\n\	addl $4,%%esp	\n\	movl %%eax,%2	\n\	testl %%eax,%%eax	\n\	je eogclp1	\n\	shrl $9,%%eax	\n\	leal 0(%%ebx,%%eax,2),%%eax		\n\	xorb $2,%%al	\n\	cmpw $0,(%%eax)	\n\	jl gclp1	\n\	cmpl $76,(%%ecx)	\n\	je gclp1	\n\	pushl $0	\n\	pushl %2	\n\	call rec_htfind	\n\	addl $8,%%esp	\n\	jmp gclp1	\n\	.align 4	\n\	.align 4	\n\eogclp1:	\n\	movl %0,%%eax	/ if (HTLPTR->contents == 0)	\n\	cmpw $0,(%%eax)	\n\	je nextentry		/ goto nextentry;	\n\	jmp retry	/ else goto retry;	\n\	.align 4	\n\	.align 4	\n\	\n\stknz:	\n\	movw (%%ecx),%%ax	/ if ((offset = ((struct htcoll *)link)->next_free))	\n\	testw %%ax,%%ax	\n\	je nextentry	\n\	movl %%ecx,%%esi	\n\	andl $65535,%%eax	\n\	jmp linkloop	\n\	.align 4	\n\	.align 4	\n\nocollision:	\n\	testw $65024,(%%ecx)	/ if (StkCntIsZero(HTLPTR->contents)) {	\n\	jne nextentry	\n\	movw (%%ecx),%%dx	/ptr = VAG2(HENTRY->segnum, (probe << 1));	\n\	sall $15,%%edx	\n\	andl $16711680,%%edx	\n\	leal (,%%edi,2),%%eax	\n\	orl %%eax,%%edx	\n\	movl %%edx,%2	\n\	movw $0,(%%ecx)	/ HTLPTR->contents = 0	\n\	.align 4	\n\	movl GcDisabled_word,%%ecx	\n\	movl MDStypetbl,%%ebx	\n\gclp2:	/ GcreclaimLp	\n\	pushl %2	\n\	call gcreccell	\n\	addl $4,%%esp	\n\	movl %%eax,%2	\n\	testl %%eax,%%eax	\n\	je nextentry	\n\	shrl $9,%%eax	\n\	leal 0(%%ebx,%%eax,2),%%eax	\n\	xorb $2,%%al	\n\	cmpw $0,(%%eax)	\n\	jl gclp2	\n\	cmpl $76,(%%ecx)	\n\	je gclp2	\n\	pushl $0	\n\	pushl %2	\n\	call rec_htfind	\n\	addl $8,%%esp	\n\	jmp gclp2	\n\	.align 4	\n\returNIL:	\n\    " : "=g" (entry), "=g" (offset), "=g" (ptr) : : "ax", "dx", "cx", "bx", "si", "di");    return NIL;  }#elsegcmapscan()E 11D 5{ struct hashentry	*entry;  LispPTR		ptr, entrylp, linklp, prevlp;  DLword		probe = HTMAIN_SIZE;  struct  htcoll	*link;  struct  htlinkptr	*htlptr; E 5I 5D 8{   LispPTR		prevlp;  register DLword	probe = HTMAIN_SIZE;  register LispPTR	htcoll_LADDR = (LispPTR) LADDR_from_68k(HTcoll);  LispPTR		htmain_LADDR = (LispPTR) LADDR_from_68k(HTmain);E 5nextentry:  while((probe = gcscan1(probe)) != NIL)D 5	{entry = (struct hashentry *)Addr68k_from_LADDR((entrylp =				LADDR_from_68k(HTmain) + probe));	 htlptr = (struct htlinkptr *)entry;E 5I 5	{ register struct hashentry *entry;	  register LispPTR entrylp;	  entrylp = htmain_LADDR + probe;	  entry = (struct hashentry *) ((DLword *) HTmain + probe);E 8I 8D 12{	register DLword			probe;	register DLword			*entry;	DLword				offset;	register LispPTR		ptr;E 12I 12  {    register GCENTRY probe;    register GCENTRY *entry;    GCENTRY  offset, dbgentry, dbgcontents;    register LispPTR ptr;E 12E 8E 5D 8	retry:		D 6	 if (entry->collision)E 6I 6	 if (HENTRY->collision)E 6D 5           { prevlp = NIL; 	/* unbound mark */             link = (struct htcoll *)Addr68k_from_LADDR((linklp =			LADDR_from_68k(HTcoll) + GetLinkptr(htlptr->contents)));	     while(link->next_free != 0)		{if (GetStkCnt(link->free_ptr) == 0)	            {ptr =VAG2(GetSegnuminColl(link->free_ptr),(probe << 1));                     dellink(linklp, prevlp, entrylp);		     GcreclaimLp(ptr);		     if (htlptr->contents == 0)		            goto nextentry;		     else goto retry;	            };		 prevlp = linklp;		 link = (struct htcoll *)Addr68k_from_LADDR((linklp =				LADDR_from_68k(HTcoll) + link->next_free));		};	     if (GetStkCnt(link->free_ptr) == 0)		{ ptr =VAG2(GetSegnuminColl(link->free_ptr),(probe << 1));		  dellink(linklp, prevlp, entrylp);E 5I 5           { register LispPTR next_link;	     prevlp = NIL; 	/* unbound mark */	     next_link = GetLinkptr(HTLPTR->contents); 	     do {		register LispPTR linklp;		register struct htcoll *link;		linklp = htcoll_LADDR + next_link;		link = (struct htcoll *) ((DLword *) HTcoll + next_link);		{register LispPTR ptr = link->free_ptr;		 if (GetStkCnt(ptr) == 0)	         {ptr = VAG2(GetSegnuminColl(ptr),(probe << 1));                  dellink(linklp, prevlp, entrylp);E 5		  GcreclaimLp(ptr);D 5		  if (htlptr->contents == 0)		    goto nextentry;E 5I 5		  if (HTLPTR->contents == 0)		       goto nextentry;E 5		  else goto retry;D 5		};	     prevlp = linklp;E 5I 5	         };		}; /* register */		prevlp = linklp;		next_link = link->next_free;		} while (next_link);E 5	     goto nextentry;D 6	    };  	/* if (entry->collision) */E 6I 6	    };  	/* if (HENTRY->collision) */E 6D 5	 if (GetStkCnt(htlptr->contents) == 0)		{ ptr = VAG2(entry->segnum,(probe << 1));	       	  htlptr->contents = 0;E 5I 5	 if (GetStkCnt(HTLPTR->contents) == 0)D 6		{ register LispPTR ptr = VAG2(entry->segnum,(probe << 1));E 6I 6		{ register LispPTR ptr = VAG2(HENTRY->segnum,(probe << 1));E 6	       	  HTLPTR->contents = 0;E 5	       	  GcreclaimLp(ptr);	        };I 5E 5	}; /* while((probe = gcscan1(probe)) != NIL) */E 8I 8D 12	probe = HTMAIN_SIZE;E 12I 12    probe = HTMAIN_ENTRY_COUNT;E 12      nextentry:D 12	while ((probe = gcscan1(probe)) != NIL) {		entry = (DLword *)HTmain + probe;	      retry:		if (HENTRY->collision) {			register DLword	*prev;			register DLword	*link;E 12I 12    while ((probe = gcscan1(probe)) != NIL)      {	entry = (GCENTRY *)HTmain + probe;	dbgentry = GETGC(entry);      retry:	if (HENTRY->collision)	  {	    register GCENTRY *prev;	    register GCENTRY *link;	    LispPTR content, dbgfree;E 12		D 12			prev = (DLword *)0;			link = (DLword *)HTcoll + GetLinkptr(HTLPTR->contents);		      linkloop:			offset = ((struct htcoll *)link)->free_ptr;			if (StkCntIsZero(offset)) {				/* Reclaimable object */				ptr = VAG2(GetSegnuminColl(offset), (probe << 1));				DelLink(link, prev, entry);				GcreclaimLp(ptr);				if (HTLPTR->contents == 0)				  goto nextentry;				else				  goto retry;			}			if ((offset = ((struct htcoll *)link)->next_free)) {				prev = link;				link = (DLword *)HTcoll + offset;				goto linkloop;			}			goto nextentry;		}		if (StkCntIsZero(HTLPTR->contents)) {			ptr = VAG2(HENTRY->segnum, (probe << 1));			HTLPTR->contents = 0;			GcreclaimLp(ptr);		}	}E 8	return(NIL);D 8   }E 8I 8}E 12I 12	    prev = (GCENTRY *)0;	    link = (GCENTRY *)HTcoll + GetLinkptr((content = HTLPTR->contents));          linkloop:	    offset = ((struct htcoll *)link)->free_ptr;	    dbgfree = ((struct htcoll *)link)->next_free;	    if (StkCntIsZero(offset))	      {		/* Reclaimable object */		ptr = VAG2(GetSegnuminColl(offset), (probe << 1));		DelLink(link, prev, entry);		GcreclaimLp(ptr);		if (HTLPTR->contents == 0)		  goto nextentry;		else		  goto retry;	      }	    if ((offset = ((struct htcoll *)link)->next_free))	      {		prev = link;		link = (GCENTRY *)(HTcoll + offset);		goto linkloop;	      }	    goto nextentry;	  }	if (StkCntIsZero(dbgcontents = HTLPTR->contents)) {		ptr = VAG2(HENTRY->segnum, (probe << 1));		HTLPTR->contents = 0;		GcreclaimLp(ptr);	  }      }    return(NIL);  }E 12I 11#endif /* GCC386 */E 11E 8I 5D 8E 8E 5gcmapunscan()D 5{ DLword		probe = HTMAIN_SIZE;  struct hashentry	*entry;  struct htcoll		*link;  struct htlinkptr	*htlptr;  LispPTR		entrylp, linklp, prevlp; E 5I 5D 8{ register DLword	probe = HTMAIN_SIZE;  register LispPTR	htcoll_LADDR = (LispPTR) LADDR_from_68k(HTcoll);  register LispPTR	htmain_LADDR = (LispPTR) LADDR_from_68k(HTmain);E 8I 8{D 12	register DLword			probe;	register DLword			*entry;	DLword				offset;E 12I 12	register GCENTRY			probe;	register GCENTRY			*entry;	GCENTRY				offset;E 12	register LispPTR		ptr;E 8E 5D 8  while((probe = gcscan2(probe)) != NIL)D 5	{ entry = (struct hashentry *)Addr68k_from_LADDR((entrylp = 				LADDR_from_68k(HTmain) + probe));	  htlptr = (struct htlinkptr *)entry;E 5I 5	{ register struct hashentry *entry;	  register LispPTR entrylp;	  register LispPTR next_link;E 8I 8D 12	probe = HTMAIN_SIZE;E 12I 12	probe = HTMAIN_ENTRY_COUNT;E 12	while ((probe = gcscan2(probe)) != NIL) {D 12		entry = (DLword *)HTmain + probe;E 12I 12		entry = (GCENTRY *)HTmain + probe;E 12	      retry:		if (HENTRY->collision) {D 12			register DLword	*prev;			register DLword *link;E 12I 12			register GCENTRY	*prev;			register GCENTRY *link;E 12E 8D 8	  entrylp = htmain_LADDR + probe;	  entry = (struct hashentry *) ((DLword *) HTmain + probe);E 5	retry:D 6	  if (entry->collision)E 6I 6	  if (HENTRY->collision)E 6D 5	     { link = (struct htcoll *)Addr68k_from_LADDR((linklp = 			LADDR_from_68k(HTcoll) + GetLinkptr(htlptr->contents)));	       	       prevlp = NIL;	    scanlp:	       if (GetStkrefinColl(link->free_ptr) == 1)E 5I 5	     {  LispPTR prevlp;		next_link = GetLinkptr(HTLPTR->contents);	       	prevlp = NIL;	    		do {		register struct htcoll *link;		register LispPTR linklp;		linklp = htcoll_LADDR + next_link;		link = (struct htcoll *) ((DLword *) HTcoll + next_link);		if (GetStkrefinColl(link->free_ptr) == 1)E 5		{if (GetCountinColl(link->free_ptr) == 1)	            {dellink(linklp, prevlp, entrylp);		     goto retry;		    }		 else link->free_ptr = (link->free_ptr & 0x0fdff);		};D 5	       if (link->next_free != 0)		{ 	          prevlp = linklp;		  link = (struct htcoll *)Addr68k_from_LADDR((linklp = 				LADDR_from_68k(HTcoll) + link->next_free));		  goto scanlp;		};E 5I 5		next_link = link->next_free;	        prevlp = linklp;		} while (next_link); /* register link */E 5	      }D 6	  else if (entry->stackref)		{if (entry->count == 1)E 6I 6	  else if (HENTRY->stackref)		{if (HENTRY->count == 1)E 6D 5			htlptr->contents = 0;E 5I 5			HTLPTR->contents = 0;E 5D 6		 else entry->stackref = 0;E 6I 6		 else HENTRY->stackref = 0;E 6		};	}; 	/* while((probe = gcscan2(probe) != NIL) */E 8I 8D 12			prev = (DLword *)0;			link = (DLword *)HTcoll + GetLinkptr(HTLPTR->contents);E 12I 12			prev = (GCENTRY *)0;			link = (GCENTRY *)(HTcoll + GetLinkptr(HTLPTR->contents));E 12		      scnlp:			offset = ((struct htcoll *)link)->free_ptr;			if (StkrefP(offset)) {				if (SinglerefP(offset)) {					DelLink(link, prev, entry);					goto retry;				} else {D 12					GETWORD((DLword *)link) =					  offset & 0x0fdff;E 12I 12					GETGC((GCENTRY *)link) =					  offset & (~ STKREFBIT);E 12				}			}			if ((offset = ((struct htcoll *)link)->next_free)) {				prev = link;D 12				link = (DLword *)HTcoll + offset;E 12I 12				link = (GCENTRY *)(HTcoll + offset);E 12				goto scnlp;			}		} else if (HENTRY->stackref) {			if (HENTRY->count == 1)			  HTLPTR->contents = 0;			else			  HENTRY->stackref = 0;		}	}E 8	return(NIL);}D 8E 8D 5E 5gcscanstack()D 5	{ LispPTR		scanptr,scanend;	  LispPTR		scanbase,next,ntend,qtemp;	  Bframe		*bascframe;	  Bframe		*pvars;	  struct frameex1	*frameex;	  struct fnhead		*fnheader;E 5I 5	{ register  Bframe		*bascframe;	  LispPTR		scanptr,scanend,scanend68K;E 5	  struct fnhead		*nametable;	  int			ftyp;D 5	  int			pcou;E 5	  int			pvcount;D 5	  scanptr = VAG2(STK_HI,InterfacePage->stackbase);	  scanend = VAG2(STK_HI,InterfacePage->endofstack);	  bascframe = (Bframe *)Addr68k_from_LADDR(scanptr);	  while(1)/*This is endless loop until encountering tail of stack */		{		ftyp = (int)bascframe->flags;		switch(ftyp)			{ case STK_FX:				{ scanptr = LADDR_from_68k(				     frameex = (struct frameex1 *)bascframe);				  fnheader = (struct fnhead *)					Addr68k_from_LADDR(					VAG2(frameex->hi2fnheader,					     frameex->lofnheader));				  Stkref(LADDR_from_68k(fnheader));				  pvars =(Bframe *)					  Addr68k_from_LADDR(scanptr+FRAMESIZE);				  for(pcou = fnheader->nlocals;pcou-- != 0;)					{					 if Boundp(pvars->flags+pvars->nil+						pvars->residual+						pvars->padding) 					    Stkref(VAG2(pvars->usecnt,							pvars->ivar));					 ++pvars;					};				  next = qtemp = frameex->nextblock;E 5I 5  scanptr = VAG2(STK_HI,InterfacePage->stackbase);  scanend = VAG2(STK_HI,InterfacePage->endofstack);  scanend68K = (LispPTR) Addr68k_from_LADDR(scanend);  bascframe = (Bframe *)Addr68k_from_LADDR(scanptr);  while(1)/*This is endless loop until encountering tail of stack */ {	ftyp = (int)bascframe->flags;	switch(ftyp) {		case STK_FX: { { 			register struct frameex1 *frameex;			register struct fnhead *fnheader;			frameex = (struct frameex1 *)bascframe;			scanptr = LADDR_from_68k(frameex);			{ register LispPTR fn_head;I 12#ifdef BIGVM			  fn_head = (LispPTR) (frameex->fnheader);#elseE 12			  fn_head = (LispPTR)				VAG2(frameex->hi2fnheader,				     frameex->lofnheader);I 12#endif /* BIGVM */E 12			  Stkref(fn_head);			  fnheader = (struct fnhead *)					Addr68k_from_LADDR(fn_head);			};			{ register int pcou;			  register LispPTR *pvars;			  pvars =(LispPTR *)				  ((DLword *)bascframe + FRAMESIZE);			  for (pcou = fnheader->nlocals;pcou-- != 0;) {				register LispPTR value;				value = *pvars;				if Boundp(BIND_BITS(value)) Stkref(value);				++pvars;			  }; /* for */			}; /* register int pcou */			{  register LispPTR qtemp;			   register LispPTR next;			   register LispPTR ntend;			   next = qtemp = (LispPTR) 				Addr68k_from_StkOffset(frameex->nextblock);E 5					 /* this is offset */D 5				  ntend = 0;	/* init flag */				  if (frameex->validnametable)					{ if (STK_HI == frameex->hi2nametable)					     { Stkref(fnheader->framename);					       qtemp = 						frameex->lonametable;						nametable =(struct fnhead *)						 Addr68k_from_LADDR(						VAG2(frameex->hi2nametable,						     frameex->lonametable));					       ntend = qtemp+FNHEADSIZE						+(nametable->ntsize)*2;					     }					   else					     Stkref(VAG2(frameex->hi2nametable,						 frameex->lonametable));					};				  scanptr +=  FRAMESIZE+PADDING+						(((fnheader->pv)+1)<<2);E 5I 5			   ntend = 0;	/* init flag */			   if (frameex->validnametable) {				register LispPTR nametable;I 12#ifdef BIGVM				nametable = frameex->nametable;				if (STK_HI == (nametable>>16)) {#elseE 12				register unsigned int hi2nametable;				register unsigned int lonametable;				lonametable = frameex->lonametable;				hi2nametable = frameex->hi2nametable;				nametable = VAG2(hi2nametable,lonametable);				if (STK_HI == hi2nametable) {I 12#endif /* BIGVM */E 12	  	  	  		Stkref(fnheader->framename);I 12#ifdef BIGVME 12					qtemp = (LispPTR) I 12						Addr68k_from_StkOffset(nametable&0xFFFF);#else					qtemp = (LispPTR) E 12						Addr68k_from_StkOffset(lonametable);I 12#endifE 12					ntend = (LispPTR) (						((DLword *)qtemp) + 						FNHEADSIZE +						(((struct fnhead *)qtemp)->ntsize)*2);				} else Stkref(nametable);			  }; /* frameex->validnametable */			  bascframe = (Bframe *) 					ADD_OFFSET(bascframe, FRAMESIZE+PADDING+						(((fnheader->pv)+1)<<2));E 5			scantemps:D 5				  scanbase = LOLOC(scanptr);				  while(scanbase < qtemp)					{ pvars = (Bframe *)						    Addr68k_from_LADDR(scanptr);					  if Boundp(pvars->flags+pvars->nil+						pvars->residual+						pvars->padding) 					     Stkref(VAG2(pvars->usecnt,							pvars->ivar));					  scanptr += WORDSPERCELL;					  scanbase = LOLOC(scanptr);					};				  if (ntend != 0)					{ scanptr = VAG2(STK_HI,ntend);					  qtemp = next;					  ntend = 0;					  goto scantemps;					};				   bascframe = (Bframe *)						Addr68k_from_LADDR(scanptr);				   break;E 5I 5D 9			  while((int)bascframe < (int)qtemp) { E 9I 9			  while((unsigned int)bascframe < (unsigned int)qtemp) { E 9				register LispPTR value;				value = *((LispPTR *) bascframe);				if Boundp(BIND_BITS(value))  Stkref(value);				bascframe++;				}; /* while */			  if (ntend != 0) { 				bascframe = (Bframe *)					Addr68k_from_StkOffset(ntend);				qtemp = next;				ntend = 0;				goto scantemps;			  };			  bascframe = (Bframe *) next;			}; /* LOCAL regs qtemp next */			}; /* local regs fnheader frameex */		 	break;			};		case STK_GUARD:/* stack's tail ? */ {D 9			if ((int) bascframe >= (int) scanend68K)E 9I 9			if ((unsigned int) bascframe >= (unsigned int) scanend68K)E 9				return(NIL);		  	else { 				bascframe = (Bframe *)((DLword *) 				bascframe + bascframe->ivar);E 5				};D 5		  	  case STK_GUARD:/* stack's tail ? */				{if ((scanptr = LADDR_from_68k(bascframe))								 >= scanend)					 return(NIL);		  		  else { scanptr += bascframe->ivar;					 bascframe = (Bframe *)					   Addr68k_from_LADDR(scanptr);					};				  break;E 5I 5			break;			};		case STK_FSB: { 			bascframe = (Bframe *)((DLword *) 			bascframe + bascframe->ivar);			break;			};		default:	/* must be basic frame !! */			{			register LispPTR bf_word;			while(STK_BF != BF_FLAGS(bf_word = *((LispPTR *)bascframe)))			{	Stkref(PTR_BITS(bf_word));				bascframe++;E 5				};D 5		  	  case STK_FSB:				{ scanptr = LADDR_from_68k(bascframe);				  scanptr += bascframe->ivar;				  bascframe = (Bframe *)Addr68k_from_LADDR(						scanptr);				  break;				};		  	  default:	/* must be basic frame !! */				{ while(STK_BF != bascframe->flags)					{ Stkref(VAG2(bascframe->usecnt						    ,bascframe->ivar));					  ++bascframe;E 5I 5			bascframe++;			}; /* **** NOTE THIS CODE DOES NOT COMPILE CORRECTLY ON THE SUN 4				{register LispPTR bf_word;				 while(STK_BF != BF_FLAGS(					bf_word = *((LispPTR *)bascframe++)))					{ Stkref(PTR_BITS(bf_word));E 5					};D 5				  ++bascframe;				}; /* default */			};	/* switch */		};	/* while(1) */E 5I 5				}; **** */		};	/* switch */	};	/* while(1) */E 5}I 5E 5E 1