h32416s 00032/00014/00345d D 1.6 91/04/16 15:06:42 sybalsky 6 5c 3-byte-atom changes - find_symbol speedupes 00046/00002/00313d D 1.5 91/03/29 02:49:15 sybalsky 5 4c Add with_symbol, for speeding up symbol search in IL:FIND-SYMBOL* (LLPACKAGE), will be subr 0221.es 00086/00022/00229d D 1.4 91/03/14 20:11:26 sybalsky 4 3c Convert find_symbol to use new package-hashtable list format to match LISP.es 00002/00001/00249d D 1.3 90/07/18 20:18:44 sybalsky 3 2c make find_atom not die on IL pkg (has no internal-symbols hash table)es 00011/00005/00239d D 1.2 90/04/20 01:35:03 sybalsky 2 1c AIX:  shortening file names, bulk change.es 00244/00000/00000d D 1.1 90/04/19 23:19:22 sybalsky 1 0c date and time created 90/04/19 23:19:22 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";D 2/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 2I 2I 5E 5/************************************************************************//*									*/D 4/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 4I 4D 5/*	Copyright 1989, 1990, 1991 Venue.				*/E 5I 5/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*//*	Manufactured in the United States of America.			*/E 5E 4/*									*/I 5/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************/E 5D 4/*	This file is work-product resulting from the Xerox/Venue	*/E 4I 4/*	This file was work-product resulting from the Xerox/Venue	*/E 4/*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 2/*************************************************************************/D 2/*	Copyright (C) 1987 by Fuji Xerox Co.,Ltd. All rights reserved.   *//*************************************************************************/E 2/*                                                                       */D 2/*                      File Name : gcarraymaker.c                       */E 2I 2/*                      File Name : gcarrayops.c                       */E 2/*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions :                                                 *//*                       LispPTR aref1(array, index);                    *//*			 DLword find_symbol(char_base,offset,            *//*						 length,hashtbl);        *//*                       DLword get_package_atom(                        *//*                               char_base,charlen,packname,             *//*                                            packlen,externalp);        */I 5/*									 *//*			LispPTR with_symbol(charbase, charlen, 		 *//*					    hashtable, result_fixp);	 */E 5/*                                                                       *//*************************************************************************//*           Description :                                               *//*                                                                       *//* The function "aref1" is the accessor of oned_array.                   *//* The functions "find_symbol" and "get_package_atom" are implemented    *//*     to access the atom through the package mechanism.                 *//*									 */I 5/*	with_symbol is a C subr implementation of LLPACKAGE's 		 *//*	WITH-SYMBOL macro:  It returns as its result the symbol found,	 *//*	or NIL if none, and in the result_fixp, -1 if not found.	 *//*									 */E 5/*************************************************************************//*                                                               \Tomtom *//*************************************************************************/D 5/* THESE FUNCTIONS ARE NOW USED BY SYSOUT START AND URAID ONLY */E 5#include "lispemul.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "stack.h"#include "cell.h"#include "ifpage.h"#include "gc.h"#include "array.h"#include "debug.h"#include "lispmap.h"/*** not currently used -FS	#define min(a,b)		((a > b)?b:a)	#define Trailer(ldatum,datum68)	(ldatum+2*(datum68->arlen - ARRAYBLOCKTRAILERCELLS))	#define BucketIndex(n)		min(integerlength(n),MAXBUCKETINDEX)	#define FreeBlockChainN(n)	((0xffffff & *FreeBlockBuckets_word)+2*BucketIndex(n)) ***/#define Rehash_factor(hash,tablelen)   \           (((hash) % ((tablelen) - 2)) + 1)#define Symbol_hash_reprobe(hash,rehashfactor,tablelen) \               (((hash) + (rehashfactor)) % (tablelen))#define Entry_hash(strlen,sxhash) \           (((((((strlen)^(sxhash))^((sxhash) >> 8))  \	       ^((sxhash) >> 16))^((sxhash) >> 19)) % 254) + 2)D 4struct hashtable {  LispPTR      table;  LispPTR      hash;  LispPTR      size;  LispPTR      free;  LispPTR      deleted;};E 4I 4/************************************************************************//*									*//*			Package hashtable structure			*//*									*//*	2 per package, for looking up internal and external symbols.	*//*									*//************************************************************************/E 4I 4struct hashtable  {    LispPTR      table;    LispPTR      hash;    LispPTR      size;    LispPTR      free;    LispPTR      deleted;  };E 4/* The end of macros & structure for medley version */D 4/*  ================================================================  */E 4I 4/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 4LispPTR aref1(array, index)  LispPTR array;  int     index;  {    register LispPTR retval;    register LispPTR base;    register short   typenumber;    register ONED_ARRAY  *actarray;    actarray = (ONED_ARRAY *)Addr68k_from_LADDR(array);    if (index >= actarray->TOTAL_SIZE)      {	printf("Invalid index in GC's AREF1:  0x%x\n", index);	printf(" Array size limit:  0x%x\n", actarray->TOTAL_SIZE);	printf(" Array ptr: 0x%x\n", (unsigned int)array);	printf(" Array 68K ptr: 0x%x\n", (unsigned int) actarray);	printf("base:     0x%x\n", actarray->BASE);	printf("offset:   0x%x\n", actarray->OFFSET);	printf("type #:   0x%x\n", actarray->TYPE_NUMBER);	printf("fill ptr: 0x%x\n", actarray->FILL_POINTER);	error("index out of range in GC's AREF1.");      }    index += actarray->OFFSET;    typenumber = actarray->TYPE_NUMBER;    base = actarray->BASE;    switch(typenumber)      {	case  3: /* unsigned 8bits */		/* the following code confuses the Apollo compiler;	*/		/* its equivalent doesn't				*/#ifndef APOLLO		 retval = (GETBYTE(((char *)Addr68k_from_LADDR(base))				 + index)) & 0x0ff;#else		{		  register char *eightbitbase =			(char *)Addr68k_from_LADDR(base);		  retval = GETBYTE(eightbitbase + index) & 0xff;		}#endif	        retval |= S_POSITIVE;	        break;	 case 4: /* unsigned 16bits */		retval = (GETWORD(((DLword *)Addr68k_from_LADDR(base))			 + index)) & 0x0ffff;		retval |= S_POSITIVE;		break;	 case 38:		retval = (*(((LispPTR *)Addr68k_from_LADDR(base))			 + index));		break;	 default:  error("Not Implemented in gc's aref1 (other types)");      };    return(retval);  }D 4/*  ================================================================  */E 4I 4/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 4D 6LispPTR find_symbol(char_base, offset, length, hashtbl)E 6I 6LispPTR find_symbol(char_base, offset, length, hashtbl, fatp, lispp)E 6  char *char_base;  DLword offset;  DLword length;  LispPTR hashtbl;I 6  DLword fatp;		/* T => the "chars" coming in are 16-bit */  DLword lispp;		/* T => the incoming chars are in LISP space */E 6  {    DLword hashval, ehashval, h2, ehash, indexvar;    int arraylen;    struct hashtable *hashtbladdr;I 4#ifdef BIGATOMS    LispPTR vecs, hashes;#endif BIGATOMSE 4    LispPTR vec,hash;    struct arrayheader *vec68k;I 6    int fatpnamep;E 6D 3    hashval = compute_hash(char_base,offset, length);E 3I 3    if (!hashtbl) return(0xffffffff);D 4	hashval = compute_hash(char_base,offset, length);E 4I 4D 6    hashval = compute_hash(char_base,offset, length);E 6I 6    if (lispp) hashval = compute_lisp_hash(char_base, offset, length, fatp);    else hashval = compute_hash(char_base, offset, length);E 6E 4E 3    ehashval = Entry_hash(length, hashval);    hashtbladdr = (struct hashtable *)Addr68k_from_LADDR(hashtbl);I 6    /* Move our string ptr up by offset, allowing for fatness */    if (fatp) char_base += (offset << 1); else char_base += offset;E 6D 4    vec = hashtbladdr->table;E 4I 4#ifdef BIGATOMS    vecs = hashtbladdr->table;    hashes = hashtbladdr->hash;loop_thru_hashtables:    vec = car(vecs);    vecs = cdr(vecs);    hash = car(hashes);    hashes = cdr(hashes);E 4    vec68k = (struct arrayheader *)Addr68k_from_LADDR(vec);I 4    arraylen = vec68k->totalsize;    if(arraylen==0) return(0xffffffff);/*kludge TAKE*/    h2 = Rehash_factor(hashval, arraylen);    indexvar = (hashval % arraylen);#else    vec = hashtbladdr->table;E 4    hash = hashtbladdr->hash;I 4    vec68k = (struct arrayheader *)Addr68k_from_LADDR(vec);E 4    arraylen = vec68k->totalsize;    if(arraylen==0) return(0xffffffff);/*kludge TAKE*/    h2 = Rehash_factor(hashval, arraylen);    indexvar = (hashval % arraylen);I 4#endif BIGATOMSE 4retry:D 6    while (ehashval != (ehash = aref1(hash, indexvar)))E 6I 6    /* the aref1 returns a smallp, which is always <256, so trim it */    while (ehashval != (ehash = 0xFF & aref1(hash, indexvar)))E 6    {D 4      if(ehash==NIL) return(0xffffffff);E 4I 4      if(ehash==NIL) 	{ /* Ran out of entries in this table; try next or fail */#ifdef BIGATOMS	  if (hashes == NIL) return(0xffffffff); /* Last table.  Fail. */	  goto loop_thru_hashtables;#else	  return(0xffffffff);#endif BIGATOMS	}E 4      indexvar = Symbol_hash_reprobe(indexvar, h2, arraylen);    }D 6    if ((indexvar&0xffff) != NIL)E 6I 6 /*   if ((indexvar&0xffff) != NIL) */E 6      {	LispPTR index;	PNCell *pnptr;	char *pname_base;	index = aref1(vec, indexvar);D 6	pnptr = (PNCell *)GetPnameCell(index&0xffff);E 6I 6	if ((index & 0xFF0000) == S_POSITIVE) index &= 0xFFFF;	pnptr = (PNCell *)GetPnameCell(index);	fatpnamep = ((PLCell *)GetPropCell(index))->fatpnamep;E 6	pname_base= (char *)Addr68k_from_LADDR(pnptr->pnamebase);	if((length == GETBYTE(pname_base)) &&D 6	   (T == compare_chars((pname_base+1), char_base, length)))E 6I 6	   (T == ((lispp) ?		 compare_lisp_chars((pname_base+1+fatpnamep), char_base,				    length, fatpnamep, fatp) :		 compare_chars((pname_base+1+fatpnamep), char_base, length))) )E 6	  {D 6	    return(index&0xffff);E 6I 6	    return(index);E 6	  }	else	  {	    indexvar = Symbol_hash_reprobe(indexvar, h2, arraylen);	    goto retry;	  }      }D 6    else return(0xffffffff); /* can't find */E 6I 6 /*   else return(0xffffffff); */ /* can't find */E 6  }D 4/*******************************************************************//*	Func name : get_package_atom			If find symbol, return index.			Else return 0xFFFFFFFF*//*******************************************************************/E 4I 4/************************************************************************//*									*//*			g e t _ p a c k a g e _ a t o m			*//*									*//*	Try to look up the given symbol in the given package.  If 	*//*	you find it, return the atom number.  Otherwise, return -1.	*//*									*//*									*//*									*//************************************************************************/E 4LispPTR get_package_atom(char_base, charlen, packname, packlen, externalp)  char *char_base;  DLword charlen;  char *packname;  DLword packlen;  int    externalp;  {    int packindex;    PACKAGE *packaddr;    LispPTR hashtbladdr;    LispPTR index;    extern LispPTR find_package_from_name();D 4/** for some NICKNAME compatibility */E 4I 4    /* For convenience, recognize the common package nicknames: */E 4    if (0 == strncmp(packname, "XCL", packlen))      packindex = find_package_from_name("XEROX-COMMON-LISP",17);    else if (0 == strncmp(packname, "SI", packlen))      packindex = find_package_from_name("SYSTEM",6);    else if (0 == strncmp(packname, "CL", packlen))      packindex = find_package_from_name("LISP",4);    else if (0 == strncmp(packname, "XCLC", packlen))      packindex = find_package_from_name("COMPILER",8);/**** else if (0 == strncmp(packname, "KEYWORD", packlen))    packindex = 7;***/    else packindex=find_package_from_name(packname, packlen);    if (packindex <0)      {	printf("getting package index is failed \n");	return(0xffffffff);      }/* if (packindex != 7)  Not necessary (Take)*/    packaddr = (PACKAGE *)Addr68k_from_LADDR(			  aref1(*Package_from_Index_word, packindex));/* else packaddr = (PACKAGE *)Addr68k_from_LADDR(			*Keyword_Package_word);	*//* hashtbladdr =	((externalp == T)?(packaddr->EXTERNAL_SYMBOLS):			 (packaddr->INTERNAL_SYMBOLS));D 6 return( find_symbol(char_base, 0, charlen, hashtbladdr) );*/E 6I 6 return( find_symbol(char_base, 0, charlen, hashtbladdr, 0, 0) );*/E 6D 6    if ((index=find_symbol(char_base, 0, charlen,packaddr->EXTERNAL_SYMBOLS)) !=E 6I 6    if ((index=find_symbol(char_base, 0, charlen,packaddr->EXTERNAL_SYMBOLS, 0, 0)) !=E 6				0xffffffff)      return(index);    elseD 6      return(find_symbol(char_base, 0, charlen,packaddr->INTERNAL_SYMBOLS));E 6I 6      return(find_symbol(char_base, 0, charlen,packaddr->INTERNAL_SYMBOLS, 0, 0));E 6}I 5/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/D 6LispPTR with_symbol(char_base, charlen, hashtbl, result)  LispPTR char_base, charlen, hashtbl, result;E 6I 6LispPTR with_symbol(char_base, offset, charlen, fatp, hashtbl, result)  LispPTR char_base, offset, charlen, fatp, hashtbl, result;E 6  {    char * charbase68k = (char *) Addr68k_from_LADDR(char_base);    LispPTR *resultptr = (LispPTR *) Addr68k_from_LADDR(result);    int chars = charlen & 0xFFFF;	/* charlen must be a SMALLP! */I 6    int offst = offset & 0xFFFF;E 6    int symbol;				/* Where the symbol goes pro tem */    D 6    symbol = find_symbol(charbase68k, 0, chars, hashtbl);E 6I 6    symbol = find_symbol(charbase68k, offst, chars, hashtbl, fatp, 1);E 6    if (symbol == -1)      { /* Not found.  Signal that with -1 in result fixp */	*resultptr = -1;	return(NIL);      }    *resultptr = 3;    return(symbol);  } /* End of with_symbol */E 5E 1