h14900s 00390/00302/00198d D 2.14 93/02/08 14:52:37 sybalsky 19 18c Big VM (and new CDR coding) changes for 3.0 \nes 00003/00003/00497d D 2.13 92/04/21 17:13:37 sybalsky 18 17c shortening file names for DOS \nes 00225/00084/00275d D 2.12 90/06/15 16:53:16 mitani 17 16c rec_htfindes 00000/00000/00359d D 2.11 90/04/20 01:36:24 sybalsky 16 15c AIX:  shortening file names, bulk change.es 00028/00024/00331d D 2.10 89/03/31 05:25:14 shih 15 14c added warnings re: \gcdisabled testes 00003/00000/00352d D 2.9 89/03/29 15:56:15 shimizu 14 13c FIX AR11079 \\GCDISABLED affects to systemes 00001/00001/00351d D 2.8 89/03/29 15:21:01 sybalsky 13 12c fixed word pointers to small GC data structures.es 00035/00035/00317d D 2.7 89/03/28 01:48:47 sybalsky 12 11c word-ptr fixeses 00008/00000/00344d D 2.6 88/08/01 23:27:05 masinter 11 10c fix big-refcount of odd pointer by adding back kludgees 00249/00372/00095d D 2.5 88/08/01 10:09:54 masinter 10 9c rewrite htfind for speed, readabilityes 00059/00039/00408d D 2.4 88/07/08 01:42:37 masinter 9 8c clean up code, add checks (under ifdef CHECK) for debugging, indentes 00031/00055/00416d D 2.3 88/07/05 12:41:35 masinter 8 7c call newpage on new overflow table pages so LOGOUT will save them; clean upes 00003/00003/00468d D 2.2 88/07/01 18:28:14 charnley 7 6c used new GCLOOKUPV macro.es 00000/00000/00471d D 2.1 88/05/17 09:24:36 hayata 6 5c Version up to 2.1es 00003/00003/00468d D 1.5 88/05/09 21:13:42 shih 5 4c Use GCLOOKUPes 00006/00001/00465d D 1.4 88/04/26 10:06:58 masinter 4 3c Put recursive GC invocation under getlink into ifdefes 00051/00021/00415d D 1.3 88/03/20 16:47:43 masinter 3 2c merge new gc code for closure cachees 00002/00002/00434d D 1.2 88/03/13 14:49:18 hayata 2 1c Add SCCS key id (%Z%)es 00436/00000/00000d D 1.1 88/02/24 16:57:10 hayata 1 0c date and time created 88/02/24 16:57:10 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 15/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 15I 15D 17/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 15D 8static char *id = "%Z% %M%	%I% %G%";E 8I 8D 9static char *id = "%Z% %M%    %I% %G%";E 9I 9static char *id = "%Z% %M%	%I% %G%";E 17I 17D 19/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 19I 19/* %Z% %M% Version %I% (%G%). copyright venue  */static char *id = "%Z% %M%	%I% %G%		(venue)";E 19E 17E 9E 8E 2I 19/************************************************************************//*									*//*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************/E 19D 10/*************************************************************************//*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.  *//*************************************************************************//*                                                                       *//*                       File Name : gchtfind.c                          *//*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : July-8-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions : htfind(ptr,casep);                              *//*                       gc_enter_bigrefcnt(ptr,entry);                  *//*                       gc_modify_bigrefcnt(entry,casep,ptr);           *//*                       *getlink();                                     *//*                       dellink(link,prev,entry);                       *//*                       freelink(linkcell);                             *//*                       newentry(entry,ptr,casep);                      *//*                       modentry(entry,casep,ptr);                      *//*                                                                       *//*                                                                       *//*************************************************************************/D 3/*           Descreption :                                               */E 3I 3/*           Description :                                               */E 3/*	This file module may have the functions for Reference Counting.	 *//*	The function "htfind" is the main function in this module(for	 *//*	reference counting) and it is based on the UFN function "\HTFIND"*//*	of Opcode "GCREF" that is written in Xerox Lisp.		 *//*	This file's functions can be categolizeed to three groups.	 *//*	First is the main function, that is, "htfind". This isthe agent	 *//*	of manipulating the reference count table, that is, "HTmain",	 *//*	"HTcoll" and "HTbigcount". The process types of the function is  *//*	as following :							 *//*		ADDREF(= 0) : increment reference count			 *//*		DELREF(= 1) : decrement reference count			 *//*		STKREF(= 2) : set stkref field(this indicates that this	 *//*			      object is refered from stack.)		 *//*									 *//*	Second is the amount of functions that may modify the reference	 *//*	count table acually.(These function was implemented by macro in	 *//*	Lisp.)								 *//*	freelink(linkcell)	LispPTR linkcell			 *//*	 This function may arrange the free linkage of collision table	 *//*	 entries.							 *//*	dellink(link, prev, entry) LispPTR link, prev, entry		 *//*	 Thsi function may delete the entry of collision table(that may  *//*	 be indicated by "link". And "prev" may indicate the previous    *//*	 entry of the target entry, "link", on the entries' linkage.	 *//*	 If "prev" is NIL, it may tell that there is no entry between    *//*	 "link" and "entry"."entry" is the header of the linkage and the *//*	 entry in the "HTmain" table.					 *//*	*getlink()							 *//*	 This function may get the new entry template on the collision	 *//*	 table, that is, "HTcoll". And may return its Lisp Address.(But  *//*	 this gotten entry has no information. The function "newentry"	 *//*	 may set information to this new entry.)			 *//*	newentry(entry, ptr, casep)	LispPTR entry,ptr; DLword casep  *//*	 This function may set new entrie's information to new entry.	 *//*	 "entry" is the Lisp Address of new entry. "ptr" is the Lisp	 *//*	 Address of the Lisp Object. "casep" is the code of ref. counting*//*	 process.(0,1 or 2)						 *//*	modentry(entry,casep,ptr)	LispPTR entry,ptr;DLword casep   *//*	 This function may modify the reference count actually. The	 *//*	 parameters are same as the function "newentry".		 *//*	Third is the functions to manipulate the Big Count table.	 *//*	gc_enter_bigrefcnt(ptr,entry)	LispPTR ptr, entry		 *//*	 This function may be called in ADDREF to the object whose ref.	 *//*	 count is 62.Then, this function may make the new entry in the   *//*	 Big Count Table "HTbigcount".The entry of big count may have    *//*	 2 words reference count field and Lisp Address to the Lisp	 *//*	 object.							 *//*	gc_modify_bigrefcnt(entry,casep,ptr)				 *//*	 			LispPTR entry, ptr; DLword casep	 *//*	 This function may modify the reference count of entry on the    *//*	 big count table						 *//*                                                                       *//*************************************************************************//*                                                               \Tomtom *//*************************************************************************/E 10#include "lispemul.h"D 18#include "lisptypes.h"E 18I 18#include "lsptypes.h"E 18#include "address.h"D 18#include "address68k.h"#include "lispglobal.h"E 18I 18#include "adr68k.h"#include "lspglob.h"E 18#include "gc.h"#include "lispmap.h"#include "cell.h"I 19E 19I 9D 10#ifdef CHECK#include "array.h"#endifE 9#define MAXSMALLP		65535#define HTBIGENTRYSIZE		4#define WORDSPERPAGE		256#define MAXTYPENUMBER		INIT_TYPENUME 10D 17#define GetLinkptr(entry)	(entry & 0x0fffe)D 10#define GetSegnuminColl(entry1) ((entry1 & 0x01fe) >> 1)#define GetCountinColl(entry1)  ((entry1 & 0x0fc00) >> 10)#define GetStkCnt(entry1)		 ((entry1 & 0x0fe00) >> 9)#define Oddp(num) (((num % 2) != 0)?1:0)#define Evenp(num,prim) (((num % prim) == 0)?1:0)#define HTCOLLMAX  		HTCOLL_SIZE-2	/* 65534 in Lisp original */D 3#define HTCOLLTHRESHOLD		(HTCOLL_SIZE-8)	/* 65528 in Lisp original */E 3I 3#define HTCOLLTHRESHOLD		(HTCOLL_SIZE/2)	/* 65528 in Lisp original */E 10E 3D 10/* int ReclaimCountDown, ReclaimMin; */ 	  /* The global Variables for triggering the reclaim process *//* int GcDisabled; */	  /* This is the flag that indicates GC status. */I 3int GetLinkRecursion = NIL;I 4#ifdef NEWGC#define RECURSIVEGCOK (GetLinkRecursion == NIL)#else#define RECURSIVEGCOK NIL#endifE 10I 10D 15/* These two functions  (freelink and dellink) are used by the (currently unused) code for  all of reclaim in C */E 15I 15/* These two functions (freelink and dellink) are used by the   (currently unused) code for all of reclaim in C */E 15E 10E 4E 3D 10DLword *getlink()    { struct htcoll *htcollents;	DLword tmpvar;	DLword *retvar;      htcollents = (struct htcoll *)HTcoll;      if ((tmpvar = htcollents->free_ptr) == 0)		{ if ((tmpvar = htcollents->next_free) >= HTCOLLTHRESHOLD)D 3			{/* disablegc1();	currently not impl July-7 */			  error("ERROR : HTcoll overflow\n");			  tmpvar = tmpvar - ((tmpvar == HTCOLLMAX)? 1:0);			};		/*the struct's feature addring -1*/E 3I 3D 4			{if (GetLinkRecursion == NIL)E 4I 4			{if (RECURSIVEGCOK)E 4 				{GetLinkRecursion = T; 				 doreclaim(); 			 	 GetLinkRecursion = NIL; 			 	 return(NIL);} 			 else 			   if (tmpvar >= HTCOLLMAX) 			     disablegc1(NIL); 			 };E 3		   htcollents->next_free = tmpvar+2;		   return((DLword *)Addr68k_from_LADDR(			LADDR_from_68k(HTcoll)+tmpvar));		}	 else	   { retvar = (DLword *)Addr68k_from_LADDR(LADDR_from_68k(HTcoll)						+tmpvar); 				/* offset opera */		htcollents->free_ptr = *(retvar+1);		return(retvar);	   }	}	E 10freelink(linkcell)LispPTR linkcell;   { struct htcoll *htbase;	struct htcoll *cell68k;	htbase = (struct htcoll *)HTcoll;	cell68k = (struct htcoll *)Addr68k_from_LADDR(linkcell);	cell68k->free_ptr = 0;	cell68k->next_free = htbase->free_ptr;	htbase->free_ptr = LOLOC(linkcell); /* "LOLOC" <- "address.h" */   }I 10E 10dellink(link,prev,entry)LispPTR		link;LispPTR		prev;LispPTR		entry;   { struct hashentry *rentry;     struct htlinkptr *htlptr;	struct htcoll *pentry;	struct htcoll *lentry;	rentry = (struct hashentry *)Addr68k_from_LADDR(entry);D 12	htlptr = (struct htlinkptr *)rentry;E 12I 12	htlptr = (struct htlinkptr *)(rentry);E 12D 15 	lentry = (struct htcoll *)Addr68k_from_LADDR(link);E 15I 15	lentry = (struct htcoll *)Addr68k_from_LADDR(link);E 15	if (prev != NIL)		{pentry = (struct htcoll *)Addr68k_from_LADDR(prev);		 pentry->next_free = lentry->next_free;		}	elseD 12	  htlptr->contents = (lentry->next_free | 1);E 12I 12	  ((struct htlinkptr *)WORDPTR(htlptr))->contents = (lentry->next_free | 1);E 12	freelink(link);	lentry = (struct htcoll *)Addr68k_from_LADDR(LADDR_from_68k(HTcoll)D 12			 + GetLinkptr(htlptr->contents));E 12I 12			 + GetLinkptr(((struct htlinkptr *)WORDPTR(htlptr))->contents));E 12D 10	if (lentry->next_free == 0)E 10I 10	if (( lentry->next_free) == 0)E 10D 12		{htlptr->contents = lentry->free_ptr;E 12I 12		{((struct htlinkptr *)WORDPTR(htlptr))->contents = lentry->free_ptr;E 12		 freelink(LADDR_from_68k(lentry));		};   }E 17D 9modentry(entry,casep,ptr)LispPTR 	  entry;DLword 		  casep;LispPTR		  ptr;   { DLword gccnt;E 9I 9D 10modentry(entry, casep, ptr)	LispPTR         entry;	DLword          casep;	LispPTR         ptr;E 10I 10#define Evenp(num,prim) ((num % prim) == 0)I 19#ifdef BIGVM   /* HTCOLLMAX should be in half-entries, not in words */#define HTCOLLMAX		(HTCOLL_SIZE/DLWORDSPER_CELL)-16#elseE 19D 15#define HTCOLLMAX  		HTCOLL_SIZE-16E 15I 15#define HTCOLLMAX		HTCOLL_SIZE-16I 19#endif /* BIGVM */E 19E 15D 17/* getlink gets a new entry from the GC collision table */DLword *getlink()E 10{D 10	register DLword gccnt;E 9	register struct hashentry *rentry;D 9	rentry = (struct hashentry *)Addr68k_from_LADDR(entry);E 9I 9	rentry = (struct hashentry *) Addr68k_from_LADDR(entry);E 9	gccnt = rentry->count;D 9	if (gccnt != MAX_GCCOUNT)		{ switch(casep)			{ case ADDREF: 				{if (gccnt == (MAX_GCCOUNT-1))					gc_enter_bigrefcnt(ptr, entry);				 else ++rentry->count;				 break;}			  case DELREF:				{if (gccnt != 0)					--rentry->count;				 else error("ERROR : DELREF in 0\n");					/* mp_error not implimented here */				 break;}			  case STKREF:				{rentry->stackref = 1;				 break;}			  case UNSTKREF:				{rentry->stackref = 0;				 break;}			  default: 			     {error("ERROR : invalid case on modentry\n"); 			      break;}					/* currently no impli */			};		 if (!(rentry->stackref) && ((rentry->count) == 1))			return(T);		  else return(NIL);		}	else return(gc_modify_bigrefcnt(entry, casep, ptr));   }E 9I 9	if (gccnt == MAX_GCCOUNT)		return gc_modify_bigrefcnt(entry, casep, ptr);	switch (casep) {	case ADDREF:		if (gccnt == (MAX_GCCOUNT - 1))			gc_enter_bigrefcnt(ptr, entry);		else			++(rentry->count);		break;	case DELREF:#ifdef CHECK		if (gccnt == 0)			error("attempt to decrement 0 reference count");#endif		--(rentry->count);		break;	case STKREF:		rentry->stackref = 1;		break;	case UNSTKREF:		rentry->stackref = 0;		break;	};	return ((rentry->count == 1) && (rentry->stackref == 0));E 10I 10	register DLword linkoff;D 12	linkoff = *(HTcoll);E 12I 12	linkoff = GETWORD(HTcoll);E 12	if (linkoff == 0) {D 12		if ((linkoff = *(HTcoll + 1)) >= HTCOLLMAX) {E 12I 12		if ((linkoff = GETWORD(HTcoll + 1)) >= HTCOLLMAX) {E 12			disablegc1(NIL);		};D 12		*(HTcoll + 1) = linkoff + 2;E 12I 12		GETWORD(HTcoll + 1) = linkoff + 2;E 12		return HTcoll + linkoff;	}D 12	*(HTcoll) = *(HTcoll + linkoff + 1);E 12I 12	GETWORD(HTcoll) = GETWORD(HTcoll + linkoff + 1);E 12	return HTcoll + linkoff;E 17I 17/* GetLink gets a new entry from the GC collision table */D 19#define GetLink(var) {							    \									    \	register DLword linkoff;					    \	linkoff = GETWORD(HTcoll);					    \	if (linkoff == 0) {						    \		if ((linkoff = GETWORD((DLword *)HTcoll + 1))		    \		    >= HTCOLLMAX) {					    \			disablegc1(NIL);				    \			return(NIL);  					    \		};							    \		GETWORD(HTcoll + 1) = linkoff + 2;			    \		var = (DLword *)HTcoll + linkoff;			    \	} else {							    \		GETWORD(HTcoll) = GETWORD((DLword *)HTcoll + linkoff + 1);  \		var = (DLword *)HTcoll + linkoff;			    \	}								    \E 19I 19#define GetLink(var)						\  {								\								\    register GCENTRY linkoff;					\    linkoff = GETGC(HTcoll);					\    if (linkoff == 0)						\      {								\	if ((linkoff = GETGC((GCENTRY *)HTcoll + 1))		\	    >= HTCOLLMAX)					\	  {					    		\	    disablegc1(NIL);				    	\	    return(NIL);  					\	  };							\	GETGC((GCENTRY*)HTcoll + 1) = linkoff + 2;		\	var = (GCENTRY *)(HTcoll + linkoff);			\      }								\    else							\      {								\	GETGC(HTcoll) = GETGC((GCENTRY *)(HTcoll + linkoff+1)); \	var = (GCENTRY *)(HTcoll + linkoff);			\      }								\E 19E 17E 10}E 9D 10newentry(entry,ptr,casep) /* !this func. may be applied to HTmain&HTcoll! */LispPTR		  entry;LispPTR		  ptr;DLword		  casep;   { struct hashentry *rentry;	rentry = (struct hashentry *)Addr68k_from_LADDR(entry);I 9#ifdef CHECK	if ((rentry->count != 0) || (rentry->stackref != 0)) error("new non-zero entry");#endifE 9	rentry->segnum = HILOC(ptr);	switch(casep)		{ case ADDREF:			{rentry->count = 2;			 break;}		  case DELREF:			{return(ptr);			 break;}		  case STKREF:			{rentry->count = rentry->stackref = 1;			 break;}		  default: error("ERROR : invalid case on newentry. \n"); 				/* currently no implimented */		};	return(NIL);   }E 10D 19E 19I 19#ifdef BIGVM#define HTCNTSHIFT 17		/* amount to shift to get hash table count */#define HTCNTMASK 0xFFFE0000 	/* mask which masks off hash table count */#define HTCNTSTKMASK 0XFFFF0000 /* mask for hash table count + stack bit */#define HTSTKMASK 0x10000	/* mask for stack bit only */#define HTHIMASK 0x3FE		/* mask of bits which contain high part of				   pointer in hash table  FIXME change this				   to 1FFE when  pointers really go to				   28 bits. JDS */#define HTHISHIFT 1		/* high bits in hash table are shifted left 1 */#elseE 19I 10#define HTCNTSHIFT 10	/* amount to shift to get hash table count */#define HTCNTMASK 0xFC00 /* mask which masks off hash table count */#define HTCNTSTKMASK 0XFE00 /* mask for hash table count + stack bit */#define HTSTKMASK 0x0200 /* mask for stack bit only */D 15#define HTHIMASK 0x1FE	/* mask of bits which contain high part of pointer E 15I 15#define HTHIMASK 0x1FE	/* mask of bits which contain high part of pointerE 15			in hash table */#define HTHISHIFT 1  /* high bits in hash table are shifted left 1 */I 19#endif /* BIGVM */E 19E 10D 8E 8D 10gc_enter_bigrefcnt(ptr,entry)LispPTR			ptr,entry;E 10I 10/*  NewEntry is a macro for adding a new gc hash table entry;	entry is pointer to hash table entryD 15	hiptr is the high point of the ref-cnted entry, shifted 	casep is one of ADDREF, DELREF, etc. E 15I 15	hiptr is the high point of the ref-cnted entry, shifted	casep is one of ADDREF, DELREF, etc.E 15*/I 17/* * NewEntry is never called in the course of the reclaimation. * Thus STKREF case is not needed. */E 17#define NewEntry(entry, hiptr, casep, ptr) {				     \switch (casep) {							     \	case ADDREF:							     \D 12		*(entry) = hiptr | (2 << HTCNTSHIFT);	/* set count = 2 */  \E 12I 12D 15		GETWORD(entry) = hiptr | (2 << HTCNTSHIFT);	/* set count = 2 */  \E 12		return NIL;				/* not new 0 entry */\E 15I 15D 19	    GETWORD(entry) = hiptr | (2 << HTCNTSHIFT);	/* set count = 2 */  \E 19I 19	    GETGC(entry) = hiptr | (2 << HTCNTSHIFT);	/* set count = 2 */  \E 19I 17	    IncAllocCnt(1);\E 17	    return NIL;				/* not new 0 entry */	     \E 15	case DELREF:							     \D 12		*(entry) = hiptr; 			/* set count = 0 */  \E 12I 12D 15		GETWORD(entry) = hiptr; 			/* set count = 0 */  \E 12		return ptr; 				/* new 0 entry */    \E 15I 15D 19	    GETWORD(entry) = hiptr;		/* set count = 0 */	     \E 19I 19	    GETGC(entry) = hiptr;		/* set count = 0 */	     \E 19I 17	    IncAllocCnt(1);\E 17	    return ptr;				/* new 0 entry */	     \I 17	default:							     \	    error("GC error: new entry touches stack bit");	     \	}}/* * RecNewEntry is called in the course of the reclaimation. * Does not maintain the allocation count. */#define RecNewEntry(entry, hiptr, casep, ptr) {				     \switch (casep) {							     \	case ADDREF:							     \D 19	    GETWORD(entry) = hiptr | (2 << HTCNTSHIFT);	/* set count = 2 */  \E 19I 19	    GETGC(entry) = hiptr | (2 << HTCNTSHIFT);	/* set count = 2 */  \E 19	    return NIL;				/* not new 0 entry */	     \	case DELREF:							     \D 19	    GETWORD(entry) = hiptr;		/* set count = 0 */	     \E 19I 19	    GETGC(entry) = hiptr;		/* set count = 0 */	     \E 19	    return ptr;				/* new 0 entry */	     \E 17E 15	case STKREF:  /* set refcnt to 1, stack bit to 1 */		     \D 12		*(entry) = hiptr | (1<<HTCNTSHIFT) | HTSTKMASK;		     \E 12I 12D 15		GETWORD(entry) = hiptr | (1<<HTCNTSHIFT) | HTSTKMASK;		     \E 12		return NIL;						     \E 15I 15D 19	    GETWORD(entry) = hiptr | (1<<HTCNTSHIFT) | HTSTKMASK;	     \E 19I 19	    GETGC(entry) = hiptr | (1<<HTCNTSHIFT) | HTSTKMASK;	     \E 19	    return NIL;							     \E 15	default:							     \D 15		error("GC error: new entry when turning off stack bit");     \E 15I 15	    error("GC error: new entry when turning off stack bit");	     \E 15	}}D 17#define FreeLink(link) {\D 12	*(link) = 0;\	*(link+1) = *HTcoll;\	*HTcoll = (link - HTcoll);\E 12I 12	GETWORD(link) = 0;\D 13	GETWORD(link+1) = *HTcoll;\E 13I 13	GETWORD(link+1) = GETWORD(HTcoll);\E 13	GETWORD(HTcoll) = (link - HTcoll);\E 12}E 17D 15/* ModEntry is a macro to modify an  old  gc hash table entry. E 15I 15D 19/* ModEntry is a macro to modify an old gc hash table entry.E 19I 19   /* ModEntry is a macro to modify an old gc hash table entry.E 19E 15	entry is a pointer to the entry	contents holds the old contents	ptr is the pointer being counted	casep is one of ADDREF, DELREF, etc.D 15	remove is a label to go to if the entry will	go away E 15I 15	remove is a label to go to if the entry will go awayE 15	It always return NIL, since cannot be creating a zero-count,	 no-stack-bit entry */I 17D 19/* * ModEntry is never called in the course of the reclamation. * Thus STKREF and UNSTKREF cases are not needed. */E 17#define ModEntry(entry, contents, ptr, casep, remove) { \	if (contents >= HTCNTMASK) { /* overflow; return non-zero */ \		modify_big_reference_count(entry, casep, ptr);\		return NIL;}\	switch (casep) {\E 19I 19   /*    * ModEntry is never called in the course of the reclamation.    * Thus STKREF and UNSTKREF cases are not needed.    */#define ModEntry(entry, contents, ptr, casep, remove) { 		\    if ((contents & HTCNTMASK) == HTCNTMASK)						\      { /* overflow; return non-zero */ 				\	modify_big_reference_count(entry, casep, ptr);\	return NIL;							\      }\    switch (casep) {\E 19	case ADDREF:\D 19		contents += (1 << HTCNTSHIFT);\		if (contents >= HTCNTMASK ) {\			/* overflow */\D 12			*entry = contents; \E 12I 12			GETWORD(entry) = contents; \E 19I 19	  contents += (1 << HTCNTSHIFT);\    if ((contents & HTCNTMASK) == HTCNTMASK)						\		{	/* overflow */\			GETGC(entry) = contents; \E 19E 12			enter_big_reference_count(ptr);\			return NIL;\			}\I 17D 19         	if ((contents & HTCNTSTKMASK) == (1 << HTCNTSHIFT)) { \E 19I 19           if ((contents & HTCNTSTKMASK) == (1 << HTCNTSHIFT)) { \E 19                	DecAllocCnt(1);\         		goto remove;\         	}\D 19		break;\	case DELREF:\		if ( (contents -= (1 << HTCNTSHIFT)) < 0) \			error("attempt to decrement 0 reference count");\         	if ((contents & HTCNTSTKMASK) == (1 << HTCNTSHIFT)) { \                	DecAllocCnt(1);\         		goto remove;\         	}\		break;\	default:							     \	    error("GC error: mod entry touches stack bit");	     \	}\	GETWORD(entry) = contents;\	return NIL;\}E 19I 19	  break;\	case DELREF:							\	  if ( (contents >> HTCNTSHIFT) == 0)				\	    error("attempt to decrement 0 reference count");		\	  contents -= (1 << HTCNTSHIFT);				\           if ((contents & HTCNTSTKMASK) == (1 << HTCNTSHIFT)) {	\                	DecAllocCnt(1);					\         		goto remove;					\         	}							\	  break;\	default: error("GC error: mod entry touches stack bit");	\      }\    GETGC(entry) = contents;\    return NIL;\  }E 19/* * RecModEntry is called in the course of the reclaimation. * Does not maintain the allocation count. */#define RecModEntry(entry, contents, ptr, casep, remove) { \D 19	if (contents >= HTCNTMASK) { /* overflow; return non-zero */ \E 19I 19    if ((contents & HTCNTMASK) == HTCNTMASK)						\	{ /* overflow; return non-zero */ \E 19		modify_big_reference_count(entry, casep, ptr);\		return NIL;}\	switch (casep) {\	case ADDREF:\		contents += (1 << HTCNTSHIFT);\D 19		if (contents >= HTCNTMASK ) {\E 19I 19        if ((contents & HTCNTMASK) == HTCNTMASK)						\		{\E 19			/* overflow */\D 19			GETWORD(entry) = contents; \E 19I 19			GETGC(entry) = contents; \E 19			enter_big_reference_count(ptr);\			return NIL;\			}\E 17		break; /* check for possibly deleting entry */\	case DELREF:\D 19		if ( (contents -= (1 << HTCNTSHIFT)) < 0) \			error("attempt to decrement 0 reference count");\E 19I 19		if ( (contents >> HTCNTSHIFT) == 0) \		  error("attempt to decrement 0 reference count");\		contents -= (1 << HTCNTSHIFT);				\E 19		break;\	case STKREF:\D 12		*entry = contents | HTSTKMASK;\E 12I 12D 19		GETWORD(entry) = contents | HTSTKMASK;\E 19I 19		GETGC(entry) = contents | HTSTKMASK;\E 19E 12		return NIL;\I 17/*\E 17	case UNSTKREF:\		contents = contents & ~ HTSTKMASK;\D 17		break; /* check for possibly deleting entry */\E 17I 17		break;\*/\E 17	}\	if ((contents & HTCNTSTKMASK) == (1 << HTCNTSHIFT)) goto remove;\D 12	*entry = contents;\E 12I 12D 19	GETWORD(entry) = contents;\E 19I 19	GETGC(entry) = contents;\E 19E 12	return NIL;\}I 19/************************************************************************//*									*//*	     e n t e r _ b i g _ r e f e r e n c e _ c o u n t		*//*									*//*	Add a new overflow entry, for a count that won't fit into	*//*	the field of a main GC table entry.				*//*									*//************************************************************************/E 19I 17E 17D 19/* add a new overflow entry for counts > 62 */E 19void enter_big_reference_count(ptr)D 19LispPTR			ptr;E 10   { struct gc_ovfl	*oventry;D 10     struct hashentry	*entry68;E 10D 8     LispPTR		tmp;     int		BigEntryCnt = 0;#ifdef TRACEE 8I 8     register LispPTR	tmp;E 19I 19  LispPTR ptr;  {    struct gc_ovfl *oventry;    register LispPTR tmp;E 19I 11D 15	/* this kludge is apparently necessary. Odd pointers are E 15I 15D 19	/* this kludge is apparently necessary. Odd pointers areE 15	illegal, but apparently some are reference counted. If you	get an odd pointer, just ignore the low bit */E 19I 19    /* this kludge is apparently necessary. Odd pointers are    illegal, but apparently some are reference counted. If you    get an odd pointer, just ignore the low bit */E 19D 19	if(ptr&1) ptr &= 0xfffffffe;E 11E 8	oventry = (struct gc_ovfl *)HTbigcount;D 8	printf("***BigCountTable's ptr contents is as following :\n");	while(oventry != (struct gc_ovfl *)HTcoll)		{ printf("%d",oventry->ovfl_ptr);		  ++oventry;		};#endif	oventry = (struct gc_ovfl *)HTbigcount;E 8D 10	entry68 = (struct hashentry *)Addr68k_from_LADDR(entry);	if (Oddp(LOLOC(ptr)))I 9#ifdef CHECK		error("odd pointer in refcnt");#elseE 9		--ptr;I 9#endifE 10E 9	while(((tmp = oventry->ovfl_ptr) != ATOM_T) && (tmp != NIL))E 19I 19    ptr &= 0xfffffffe;    oventry = (struct gc_ovfl *)HTbigcount;    while(((tmp = oventry->ovfl_ptr) != ATOM_T) && (tmp != NIL))E 19						/* free area ? */D 19	       {if (tmp == ptr)			{ error(			"ERROR : PTR already in overflow table.\n");D 8			  ++oventry->ovfl_cnthi;E 8I 8			/* "Assure it lives forever" */			  oventry->ovfl_cnt += 0x10000;E 8D 10			  return(NIL);E 10I 10			  return;E 10			}		else ++oventry;D 8	    ++BigEntryCnt;		/*** Monitoring ************/E 8D 15	   	};E 15I 15		};E 15D 8	/* if(Evenp(LOLOC(oventry+4),WORDSPERPAGE))	*/	if ((oventry+4) == (struct gc_ovfl *)HTcoll)	/* another way */					/* by Tomtom Nov-6-1987 */	      error("ERROR : overflow in bigcount table.\n");		/*	newpage(oventry+4); */	oventry->ovfl_cntlo = MAX_GCCOUNT;	oventry->ovfl_cnthi = 0;E 8I 8	if (tmp == NIL) {		if (Evenp(LADDR_from_68k(oventry+1),DLWORDSPER_PAGE)) {			if ((unsigned int)oventry+1 >= (unsigned int)HTcoll)				error("GC big reference count table overflow");			newpage(LADDR_from_68k(oventry+1));			}		}E 19I 19      {	if (tmp == ptr)	  {	    error("ERROR : PTR already in overflow table.\n");	    oventry->ovfl_cnt += 0x10000;	/* "Assure it lives forever" */	    return;	  }	else ++oventry;      };E 19D 19	oventry->ovfl_cnt   = MAX_GCCOUNT;E 8	oventry->ovfl_ptr   = ptr;D 8	entry68->count        = MAX_GCCOUNT;	++BigEntryCnt;#ifdef DEBUG	printf("*** Enter Big Count Table(ptr : %d , entry cnt : %d)\n",							ptr,BigEntryCnt);		/* This is monitoring *************/#endifE 8I 8D 10	entry68->count      = MAX_GCCOUNT;E 8	return(MAX_GCCOUNT);E 10I 10	return;E 10   }E 19I 19    if (tmp == NIL)      {	if (Evenp(LADDR_from_68k(oventry+1),DLWORDSPER_PAGE))	  {	    if ((unsigned int)oventry+1 >= (unsigned int)HTcoll)	      error("GC big reference count table overflow");	    newpage(LADDR_from_68k(oventry+1));	  }      }E 19D 10gc_modify_bigrefcnt(entry,casep,ptr)DLword			casep;LispPTR			entry,ptr;   { struct gc_ovfl 	*oventry;     struct hashentry	*entry68;     LispPTR		tmp;     int		tmpcnt;	oventry = (struct gc_ovfl *)HTbigcount;	entry68 = (struct hashentry *)Addr68k_from_LADDR(entry);	if (Oddp(LOLOC(ptr)))	/* address adjustment */I 9#ifdef CHECK	error("odd pointer in reference count");#elseE 9		--ptr;I 9#endifE 10I 10D 19/* modify an old overflow entry */E 19I 19    oventry->ovfl_cnt = MAX_GCCOUNT;    oventry->ovfl_ptr = ptr;    return;  }E 19E 10I 19/************************************************************************//*									*//*	    m o d i f y _ b i g _ r e f e r e n c e _ c o u n t		*//*									*//*	Modify an existing overflow entry.				*//*									*//************************************************************************/E 19E 9D 10	while((tmp = oventry->ovfl_ptr)!= ptr)	   if (tmp == NIL)		    { /*  gc_bigrefcnt_missing(ptr,entry);  */   			error(	"ERROR : PTR refcnt previously overflowed, but not found in table.\n");			 return(NIL);		     }D 8	    else ++oventry; /* ?1? */E 8I 8	    else ++oventry; /* increment by size of oventry structure */E 8	switch(casep)	   { case ADDREF:D 8		       {if (oventry->ovfl_cntlo < MAXSMALLP)				{++oventry->ovfl_cntlo;}			else { ++oventry->ovfl_cnthi;				  oventry->ovfl_cntlo = 0;				};			break;}		case DELREF:		       {if ((tmpcnt = oventry->ovfl_cntlo-1) >= MAX_GCCOUNT)			    --oventry->ovfl_cntlo;			else if (oventry->ovfl_cnthi == 0)				{ entry68->count = tmpcnt;				  oventry->ovfl_ptr = ATOM_T;			    /* oventry->ovfl_lo = tmp */E 8I 8		       ++(oventry->ovfl_cnt);			return NIL;	     case DELREF:		       if (--(oventry->ovfl_cnt) < MAX_GCCOUNT) {				/* fallen below threshold */#ifdef CHECK				if (oventry->ovfl_cnt != MAX_GCCOUNT-1)					error("overflow table bogus entry");#endif				entry68->count = MAX_GCCOUNT-1;				oventry->ovfl_ptr = ATOM_T;E 8				}D 8			else if (tmpcnt < 0)				{ --oventry->ovfl_cnthi;				  oventry->ovfl_cntlo = MAXSMALLP;				}			else --oventry->ovfl_cntlo;				/* (0<tmp<MAX_GCCOUNT)&&(cnthi>0) */			break;}E 8I 8			return NIL;E 10I 10void modify_big_reference_count(entry, casep, ptr)D 19	DLword          casep;	DLword         *entry;	LispPTR         ptr;{	struct gc_ovfl *oventry;	LispPTR         tmp;	int             tmpcnt;E 19I 19  DLword casep;  GCENTRY *entry;  LispPTR ptr;  {    struct gc_ovfl *oventry;    LispPTR tmp;    int tmpcnt;E 19I 11D 19	/* ditto comment in entry_big_reference_count */	if (ptr & 1) ptr &= 0xfffffffe;E 11	oventry = (struct gc_ovfl *) HTbigcount;	while ((tmp = oventry->ovfl_ptr) != ptr)		if (tmp == NIL) {			error(			      "refcnt previously overflowed, but not found in table.\n");			return;		} else			++oventry;	/* increment by size of oventry					 * structure */	switch (casep) {E 19I 19    /* ditto comment in entry_big_reference_count */    if (ptr & 1) ptr &= 0xfffffffe;    oventry = (struct gc_ovfl *) HTbigcount;    while ((tmp = oventry->ovfl_ptr) != ptr)      if (tmp == NIL)	{	  error("refcnt previously overflowed, but not found in table.\n");	  return;	}      else ++oventry;	/* increment by size of oventry structure */    switch (casep)      {E 19	case ADDREF:D 19		++(oventry->ovfl_cnt);		return;E 19I 19	  ++(oventry->ovfl_cnt);	  return;E 19	case DELREF:D 19		if (--(oventry->ovfl_cnt) < MAX_GCCOUNT) {			/* fallen below threshold */D 12			((struct hashentry *) entry)->count = MAX_GCCOUNT - 1;E 12I 12			((struct hashentry *) WORDPTR(entry))->count = MAX_GCCOUNT - 1;E 12			oventry->ovfl_ptr = ATOM_T;		}		return;E 19I 19	  if (--(oventry->ovfl_cnt) < MAX_GCCOUNT)	    {	      /* fallen below threshold */	      ((struct hashentry *) GCPTR(entry))->count = MAX_GCCOUNT - 1;	      oventry->ovfl_ptr = ATOM_T;	/* mark entry unused */	    }	  return;E 19	case STKREF:D 12		((struct hashentry *) entry)->stackref = 1;E 12I 12D 19		((struct hashentry *) WORDPTR(entry))->stackref = 1;E 12		return;E 19I 19	  ((struct hashentry *) WORDPTR(entry))->stackref = 1;	  return;E 19I 17/*E 17	case UNSTKREF:D 12		((struct hashentry *) entry)->stackref = 0;E 12I 12D 19		((struct hashentry *) WORDPTR(entry))->stackref = 0;E 12		return;E 19I 19	  ((struct hashentry *) WORDPTR(entry))->stackref = 0;	  return;E 19E 10D 17E 17I 17*/E 17E 8D 10		case STKREF:			{entry68->stackref = 1;D 8			 break;}E 8I 8			 return NIL;}E 8		case UNSTKREF:			{entry68->stackref = 0;D 8			 break;}		/* no default case */E 8I 8			 return NIL;}E 8	   }D 8	return(NIL);E 8   }E 10I 10	}}E 10D 8E 8I 19/************************************************************************//*									*//*				h t f i n d				*//*									*//*	Main entry for Ref-count manipulation:  Modify the reference	*//*	count for a lisp pointer.					*//*									*//*	casep is one of ADDREF, DELREF, STKREF				*//*									*//*	ADDREF = add 1							*//*	DELREF = subtract 1						*//*	STKREF = turn on stack bit					*//*	UNSTKREF = turn off stack bit					*//*									*//*	returns NIL if DELREF and the entry became			*//*	refcount = 0, stk bit off (only can happen on a *new* DELREF)	*//*	in which case it returns PTR					*//*									*//************************************************************************/E 19D 10LispPTR htfind(ptr,casep)LispPTR	ptr;DLword	casep;D 3   {  /* not used LispPTR			probe = ptr; */E 3I 3   {	LispPTR				probe;E 3	register struct hashentry 	*entry;	register struct htlinkptr	*htlptr;/* overlay access method */	register struct htcoll		*link,*prev;	DLword			offset;	LispPTR			lpentry,lplink,lpprev;	lpprev = NIL;	if (((int)GetTypeEntry(ptr) & TT_NOREF) != 0)						/* MDS's NOREF checking */		return(NIL);D 9	else if (*GcDisabled_word == ATOM_T)		return(NIL);		/* Above process is forward checking */E 9I 9	else if (*GcDisabled_word == ATOM_T) {#ifdef CHECK		error("\GCDISABLED but htfind reached");#endif		return NIL;}#ifdef CHECK	if((GetTypeNumber(ptr) == 0) && (casep != STKREF) && (casep != UNSTKREF))		 checkarrayblock(ptr-ARRAYBLOCKHEADERWORDS, NIL, NIL);#endifE 9	entry = (struct hashentry *)Addr68k_from_LADDR(		LADDR_from_68k(HTmain) + (LOLOC(ptr) >> 1));							/* hashing entry */	htlptr = (struct htlinkptr *)entry;	/* entry's whole contents */	lpentry = LADDR_from_68k(entry);	if (htlptr->contents == 0)		/* this entry is new entry */		return(newentry(lpentry,ptr,casep));	else if (entry->collision)		{ 		/* scanning and finding the HTCOLL table */		  lplink = LADDR_from_68k(HTcoll)+GetLinkptr(htlptr->contents);						/* offset opera */		  link = (struct htcoll *)Addr68k_from_LADDR(lplink);		  while((offset = link->next_free) != 0)		   {if (HILOC(ptr) == GetSegnuminColl(link->free_ptr))			  if (modentry(lplink, casep, ptr) != NIL)				{ dellink(lplink, lpprev, lpentry);				  return(NIL);				}			  else if (GetStkCnt(link->free_ptr) == 0)				{ return(ptr);}			  else return(NIL);		    prev = link;		    lpprev = lplink;		    lplink = LADDR_from_68k(HTcoll) + offset;		    link = (struct htcoll *)Addr68k_from_LADDR(lplink);		   };		  if (HILOC(ptr) == GetSegnuminColl(link->free_ptr))			  if (modentry(lplink, casep, ptr) != NIL)				{ dellink(lplink, lpprev, lpentry);				  return(NIL);				}			  else if (GetStkCnt(link->free_ptr) == 0)				{ return(ptr);}			  else return(NIL);		  prev = link;		  lpprev = lplink;D 3 		  link = (struct htcoll *)getlink(); 		  lplink = LADDR_from_68k(link);		  link->next_free = 0;		  prev->next_free = LOLOC(lplink);	/* offset opera */		  return(newentry(lplink, ptr, casep));E 3I 3  		  link = (struct htcoll *)getlink();  		  if (link == NIL) 		    {GetLinkRecursion = T;D 5 		     probe = gclookup((0x8000 | casep),ptr);E 5I 5D 7 		     probe = GCLOOKUP(0x8000,casep,ptr);E 7I 7 		     probe = GCLOOKUPV(0x8000,casep,ptr);E 7E 5 		     GetLinkRecursion = NIL; 		     return(probe); 		   }  		  else 		    {lplink = LADDR_from_68k(link); 		     link->next_free = 0; 		     prev->next_free = LOLOC(lplink);	/* offset opera */ 		     return(newentry(lplink, ptr, casep)); 		    };E 3		}	else if (HILOC(ptr) == entry->segnum)				/* already existing */		{if (modentry(lpentry, casep, ptr) != NIL) 			/* case : refcnt is 1 */			{ htlptr->contents = 0; 			  return(NIL);			}		 else if ((entry->count == 0) && 				(entry->stackref == 0))			/* case : garbage is born */				 return(ptr);		      else return(NIL);		 }	else /*	making the new collision entry */	    {	link = (struct htcoll *)getlink(); D 3		lplink = LADDR_from_68k(link);E 3I 3 	    	if (link == NIL) 		  {GetLinkRecursion = T;D 5 		   probe = gclookup((0x8000 | casep),ptr);E 5I 5D 7 		   probe = GCLOOKUP(0x8000,casep,ptr);E 7I 7 		   probe = GCLOOKUPV(0x8000,casep,ptr);E 7E 5 		   GetLinkRecursion = NIL; 	    	   return(probe); 		 } 	    	else 		{lplink = LADDR_from_68k(link);E 3		prev = (struct htcoll *)getlink(); D 3		lpprev = LADDR_from_68k(prev);		prev->next_free = LOLOC(lplink);		prev->free_ptr  = htlptr->contents;		htlptr->contents   =		   (DLword)(LOLOC(lpprev) | 0x01);		link->next_free = 0;		link->free_ptr  = 0;		return(newentry(lplink, ptr, casep));E 3I 3 		 if (prev == NIL) 		   {GetLinkRecursion = T;D 5 		    probe = gclookup((0x8000 | casep),ptr);E 5I 5D 7 		    probe = GCLOOKUP(0x8000,casep,ptr);E 7I 7 		    probe = GCLOOKUPV(0x8000,casep,ptr);E 7E 5 		    GetLinkRecursion = NIL; 		    return(probe); 		  } 		 else			{lpprev = LADDR_from_68k(prev);			prev->next_free = LOLOC(lplink);			prev->free_ptr  = htlptr->contents;			htlptr->contents   =		 	  (DLword)(LOLOC(lpprev) | 0x01);			link->next_free = 0;			link->free_ptr  = 0;			return(newentry(lplink, ptr, casep));E 3		/* !!newentry's first arg must be struct hashentry!! */I 3			};		};E 3	   }   }E 10I 10D 19/* htfind is the main entry for reference manipulation.D 15  It modifies the reference count of the Lisp pointer ptr. E 15I 15  It modifies the reference count of the Lisp pointer ptr.E 15E 10I 10   casep is one of ADDREF, DELREF, STKREFE 10I 10	ADDREF = add 1	DELREF = subtract 1	STKREF = turn on stack bit	UNSTKREF = turn off stack bitE 10I 10   returns NIL if DELREF and the entry became	refcount = 0, stk bit off (only can happen on a *new* DELREF)	in which case it returns PTR */E 19LispPTR htfind(ptr, casep)D 19	LispPTR         ptr;	int             casep;{	register DLword *entry, *link, *prev;	register DLword entry_contents, hiptr;	register struct htlinkptr *htlptr;E 19I 19  LispPTR ptr;  int casep;  {    register GCENTRY *entry, *link, *prev;    register GCENTRY entry_contents, hiptr;    register struct htlinkptr *htlptr;E 19I 14D 15	/* if *GcDisabled_word is T then do nothing */	if(*GcDisabled_word == ATOM_T) return(NIL);E 15E 14D 19	/* if the NOREF bit is on in the type table entry, do	not reference count this pointer. Used for non-reference	counted types like symbols, and also when the GC is	disabled. */E 19I 19    /* if the NOREF bit is on in the type table entry, do    not reference count this pointer. Used for non-reference    counted types like symbols, and also when the GC is    disabled. */E 19I 17D 19	/*	 * Following two tests were moved into GCLOOKUP macro	 * for efficency.	 */E 19I 19    /*     * Following two tests were moved into GCLOOKUP macro     * for efficency.     */E 19/*E 17D 19	if (GetTypeEntry(ptr) & TT_NOREF)		return NIL;E 19I 19    if (GetTypeEntry(ptr) & TT_NOREF) return NIL;E 19D 17E 17I 17*/E 17I 15D 19	/* if *GcDisabled_word is T then do nothing */	/* FS:  this test should not be needed (because type table should		be cleared).  Also, this test seems to cause an infinite		ucode loop in remimplicitkeyhash on the 386i		*/E 19I 19    /* if *GcDisabled_word is T then do nothing */    /* FS:  this test should not be needed (because type table should	    be cleared).  Also, this test seems to cause an infinite	    ucode loop in remimplicitkeyhash on the 386i		*/E 19D 17	if(*GcDisabled_word == ATOM_T) return(NIL);E 17I 17D 19/*	if(*GcDisabled_word == ATOM_T) return(NIL); */E 19I 19/*    if(*GcDisabled_word == ATOM_T) return(NIL); */E 19E 17E 15D 19	/* GC hash table entries have the high 8 bits of the	pointer stored in the middle. Set up hiptr to have	the high bits of the pointer ready to store or test	against */E 19I 19    /* GC hash table entries have the high 8 bits of the    pointer stored in the middle. Set up hiptr to have    the high bits of the pointer ready to store or test    against */E 19D 19	hiptr = (((unsigned int)ptr) >> (16-HTHISHIFT) ) & HTHIMASK;E 19I 19    hiptr = (((unsigned int)ptr) >> (16-HTHISHIFT) ) & HTHIMASK;E 19D 19	/* entry points at the place in the main hash table	where this pointer is stored. The 'hash' isn't one really;	it just uses the low bits of the pointer. */E 19I 19    /* entry points at the place in the main hash table    where this pointer is stored. The 'hash' isn't one really;    it just uses the low bits of the pointer. */E 19D 19	entry = HTmain + (LOLOC(ptr) >> 1);E 19I 19    entry = HTmain + (LOLOC(ptr) >> 1);E 19D 12	entry_contents = *entry;E 12I 12D 19	entry_contents = GETWORD(entry);E 19I 19    entry_contents = GETGC(entry);E 19E 12D 19	if (entry_contents == 0)D 15		NewEntry(entry, hiptr, casep, ptr); E 15I 15		NewEntry(entry, hiptr, casep, ptr);E 19I 19    if (entry_contents == 0) NewEntry(entry, hiptr, casep, ptr);E 19E 15		/* NewEntry returns */D 19	if (entry_contents & 1) {	/* low bit means a collision entry */		/* entry_contents-1 removes low bit */		link = HTcoll + (entry_contents - 1);		prev = 0;		goto newlink;	}E 19I 19    if (entry_contents & 1)      {	/* low bit means a collision entry */	/* entry_contents-1 removes low bit */	link = HTcoll + (entry_contents - 1);	prev = 0;	goto newlink;      }E 19D 19	if (hiptr == (entry_contents & HTHIMASK)) {		ModEntry(entry, entry_contents, ptr, casep, delentry);		/* ModEntry returns or will go to delentry */	}E 19I 19    if (hiptr == (entry_contents & HTHIMASK))      {	ModEntry(entry, entry_contents, ptr, casep, delentry);	/* ModEntry returns or will go to delentry */      }E 19D 19	/* new collision */E 19I 19    /* new collision */E 19D 17	link = getlink();	prev = getlink();D 12	*(prev + 1) = 0;	*(prev) = entry_contents;	*(link + 1) = prev - HTcoll;	*(entry) = link - HTcoll + 1;E 12I 12	GETWORD(prev + 1) = 0;	GETWORD(prev) = entry_contents;	GETWORD(link + 1) = prev - HTcoll;	GETWORD(entry) = link - HTcoll + 1;E 17I 17D 19	GetLink(link);	GetLink(prev);	GETWORD((DLword *)prev + 1) = 0;	GETWORD((DLword *)prev) = entry_contents;	GETWORD((DLword *)link + 1) = prev - HTcoll;	GETWORD((DLword *)entry) = link - HTcoll + 1;E 19I 19    GetLink(link);    GetLink(prev);    GETGC((GCENTRY *)prev + 1) = 0;    GETGC((GCENTRY *)prev) = entry_contents;    GETGC((GCENTRY *)link + 1) = prev - HTcoll;    GETGC((GCENTRY *)entry) = (link - HTcoll) + 1;E 19E 17E 12D 19	NewEntry(link, hiptr, casep, ptr);E 19I 19    NewEntry(link, hiptr, casep, ptr);		/* NewEntry returns */E 19D 12delentry: *(entry) = 0;E 12I 12D 19delentry: GETWORD(entry) = 0;E 12	return NIL;E 19I 19delentry: GETGC(entry) = 0;    return NIL;E 19/* start here when a collision is detected. link is a pointer to  the entry in the collision table, prev is the previous collision  entry or 0 if this is the first one. */D 12newlink:entry_contents = *link;E 12I 12D 19newlink:entry_contents = GETWORD(link);E 12	if (hiptr == (entry_contents & HTHIMASK) ) {		ModEntry(link, entry_contents, ptr, casep, dellink);		/* ModEntry returns or goes to dellink */	}	/* collision didn't match  */D 12	entry_contents = *(link + 1);E 12I 12D 17	entry_contents = GETWORD(link + 1);E 17I 17	entry_contents = GETWORD((DLword *)link + 1);E 17E 12	if (entry_contents == 0) {		goto nolink;	}	/* try the next link in the collision table */	prev = link;	link = HTcoll + entry_contents;	goto newlink;E 19I 19newlink:    entry_contents = GETGC(link);    if (hiptr == (entry_contents & HTHIMASK) )      {	ModEntry(link, entry_contents, ptr, casep, dellink);	/* ModEntry returns or goes to dellink */      }E 19D 19dellink:if (prev)D 12		*(prev + 1) = *(link + 1);E 12I 12D 17		GETWORD(prev + 1) = GETWORD(link + 1);E 17I 17		GETWORD((DLword *)prev + 1) = GETWORD((DLword *)link + 1);E 17E 12	elseD 12		*(entry) = (*(link + 1)) | 1;E 12I 12D 17		GETWORD(entry) = (GETWORD(link + 1)) | 1;E 17I 17		GETWORD((DLword *)entry) = (GETWORD((DLword *)link + 1)) | 1;E 19I 19    /* collision didn't match  */    entry_contents = GETGC((GCENTRY *)link + 1);    if (entry_contents == 0) goto nolink;    /* try the next link in the collision table */    prev = link;    link = HTcoll + entry_contents;    goto newlink;dellink:    if (prev) GETGC((GCENTRY *)prev + 1) = GETGC((GCENTRY *)link + 1);    else GETGC((GCENTRY *)entry) = (GETGC((GCENTRY *)link + 1)) | 1;    FreeLink(link);    link = HTcoll + (GETGC((GCENTRY *)entry)) - 1;    if (GETGC(link + 1) == 0)      {	GETGC((GCENTRY *)entry) = GETGC((GCENTRY *)link);E 19E 17E 12	FreeLink(link);D 12	link = HTcoll + (*entry) - 1;	if (*(link + 1) == 0) {		*(entry) = *(link);E 12I 12D 17	link = HTcoll + (GETWORD(entry)) - 1;E 17I 17D 19	link = HTcoll + (GETWORD((DLword *)entry)) - 1;E 17	if (GETWORD(link + 1) == 0) {D 17		GETWORD(entry) = GETWORD(link);E 17I 17		GETWORD((DLword *)entry) = GETWORD((DLword *)link);E 17E 12		FreeLink(link);	}	return NIL;E 19I 19      }    return NIL;E 19nolink:			/* no match */D 17	link = getlink();D 12	*(link + 1) = *(entry) - 1;	*(entry) = (link - HTcoll) + 1;E 12I 12	GETWORD(link + 1) = GETWORD(entry) - 1;	GETWORD(entry) = (link - HTcoll) + 1;E 17I 17D 19	GetLink(link);	GETWORD((DLword *)link + 1) = GETWORD((DLword *)entry) - 1;	GETWORD((DLword *)entry) = (link - HTcoll) + 1;E 17E 12	NewEntry(link, hiptr, casep, ptr);E 19I 19    GetLink(link);    GETGC((GCENTRY *)link + 1) = GETGC((GCENTRY *)entry) - 1;    GETGC((GCENTRY *)entry) = (link - HTcoll) + 1;    NewEntry(link, hiptr, casep, ptr);  }E 19I 17D 19}E 19I 19/************************************************************************//*									*//*			r e d _ h t f i n d				*//*									*//*	Version of HTFIND used during reclaims (part of GC process)	*//*	Same purpose, but doesn't increment the GC count-down, and	*//*	DELREF can add 0-refcount entries to the table.			*//*									*//************************************************************************/E 19LispPTR rec_htfind(ptr, casep)D 19	LispPTR         ptr;	int             casep;{	register DLword *entry, *link, *prev;	register DLword entry_contents, hiptr;	register struct htlinkptr *htlptr;E 19I 19  LispPTR         ptr;  int             casep;  {    register GCENTRY *entry, *link, *prev;    register GCENTRY entry_contents, hiptr;    register struct htlinkptr *htlptr;E 19D 19	/* if the NOREF bit is on in the type table entry, do	not reference count this pointer. Used for non-reference	counted types like symbols, and also when the GC is	disabled. */	/*	 * Following two tests were moved into GCLOOKUP macro	 * for efficency.	 */E 19I 19    /* if the NOREF bit is on in the type table entry, do    not reference count this pointer. Used for non-reference    counted types like symbols, and also when the GC is    disabled. */    /*     * Following two tests were moved into GCLOOKUP macro     * for efficency.     */E 19/*D 19	if (GetTypeEntry(ptr) & TT_NOREF)E 19I 19    if (GetTypeEntry(ptr) & TT_NOREF)E 19		return NIL;*/D 19	/* if *GcDisabled_word is T then do nothing */	/* FS:  this test should not be needed (because type table should		be cleared).  Also, this test seems to cause an infinite		ucode loop in remimplicitkeyhash on the 386i		*/E 19I 19    /* if *GcDisabled_word is T then do nothing */    /* FS:  this test should not be needed (because type table should    	be cleared).  Also, this test seems to cause an infinite    	ucode loop in remimplicitkeyhash on the 386i		*/E 19D 19/*	if(*GcDisabled_word == ATOM_T) return(NIL); */E 19I 19/*    if(*GcDisabled_word == ATOM_T) return(NIL); */E 19D 19	/* GC hash table entries have the high 8 bits of the	pointer stored in the middle. Set up hiptr to have	the high bits of the pointer ready to store or test	against */E 19I 19    /* GC hash table entries have the high 8 bits of the    pointer stored in the middle. Set up hiptr to have    the high bits of the pointer ready to store or test    against */E 19D 19	hiptr = (((unsigned int)ptr) >> (16-HTHISHIFT) ) & HTHIMASK;E 19I 19    hiptr = (((unsigned int)ptr) >> (16-HTHISHIFT) ) & HTHIMASK;E 19D 19	/* entry points at the place in the main hash table	where this pointer is stored. The 'hash' isn't one really;	it just uses the low bits of the pointer. */E 19I 19    /* entry points at the place in the main hash table    where this pointer is stored. The 'hash' isn't one really;    it just uses the low bits of the pointer. */E 19D 19	entry = HTmain + (LOLOC(ptr) >> 1);E 19I 19    entry = HTmain + (LOLOC(ptr) >> 1);E 19D 19	entry_contents = GETWORD(entry);E 19I 19    entry_contents = GETGC(entry);E 19D 19	if (entry_contents == 0)		RecNewEntry(entry, hiptr, casep, ptr);E 19I 19    if (entry_contents == 0) RecNewEntry(entry, hiptr, casep, ptr);E 19		/* NewEntry returns */D 19	if (entry_contents & 1) {	/* low bit means a collision entry */		/* entry_contents-1 removes low bit */		link = HTcoll + (entry_contents - 1);		prev = 0;		goto newlink;	}E 19I 19    if (entry_contents & 1)      {	/* low bit means a collision entry */	/* entry_contents-1 removes low bit */	link = HTcoll + (entry_contents - 1);	prev = 0;	goto newlink;      }E 19D 19	if (hiptr == (entry_contents & HTHIMASK)) {		RecModEntry(entry, entry_contents, ptr, casep, delentry);		/* ModEntry returns or will go to delentry */	}E 19I 19    if (hiptr == (entry_contents & HTHIMASK))      {	RecModEntry(entry, entry_contents, ptr, casep, delentry);	/* ModEntry returns or will go to delentry */      }E 19D 19	/* new collision */E 19I 19    /* new collision */E 19D 19	GetLink(link);	GetLink(prev);	GETWORD((DLword *)prev + 1) = 0;	GETWORD((DLword *)prev) = entry_contents;	GETWORD((DLword *)link + 1) = prev - HTcoll;	GETWORD((DLword *)entry) = link - HTcoll + 1;E 19I 19    GetLink(link);    GetLink(prev);    GETGC((GCENTRY *)prev + 1) = 0;    GETGC((GCENTRY *)prev) = entry_contents;    GETGC((GCENTRY *)link + 1) = prev - HTcoll;    GETGC((GCENTRY *)entry) = (link - HTcoll) + 1;E 19D 19	RecNewEntry(link, hiptr, casep, ptr);E 19I 19    RecNewEntry(link, hiptr, casep, ptr);E 19D 19delentry: GETWORD(entry) = 0;	return NIL;E 19I 19delentry:    GETGC(entry) = 0;    return NIL;E 19/* start here when a collision is detected. link is a pointer to  the entry in the collision table, prev is the previous collision  entry or 0 if this is the first one. */D 19newlink:entry_contents = GETWORD(link);	if (hiptr == (entry_contents & HTHIMASK) ) {		RecModEntry(link, entry_contents, ptr, casep, dellink);		/* ModEntry returns or goes to dellink */	}	/* collision didn't match  */	entry_contents = GETWORD(link + 1);	if (entry_contents == 0) {		goto nolink;	}	/* try the next link in the collision table */	prev = link;	link = HTcoll + entry_contents;	goto newlink;E 19I 19newlink:    entry_contents = GETGC(link);    if (hiptr == (entry_contents & HTHIMASK) )      {	RecModEntry(link, entry_contents, ptr, casep, dellink);	/* ModEntry returns or goes to dellink */      }    /* collision didn't match  */    entry_contents = GETGC(link + 1);    if (entry_contents == 0)      {	goto nolink;      }    /* try the next link in the collision table */    prev = link;    link = HTcoll + entry_contents;    goto newlink;E 19D 19dellink:if (prev)		GETWORD((DLword *)prev + 1) = GETWORD((DLword *)link + 1);	else		GETWORD((DLword *)entry) = (GETWORD((DLword *)link + 1)) | 1;E 19I 19dellink:    if (prev) GETGC((GCENTRY *)prev + 1) = GETGC((GCENTRY *)link + 1);    else GETGC((GCENTRY *)entry) = (GETGC((GCENTRY *)link + 1)) | 1;    FreeLink(link);    link = HTcoll + ((GETGC((GCENTRY *)entry)) - 1);    if (GETGC((GCENTRY *)link + 1) == 0)      {	GETGC((GCENTRY *)entry) = GETGC((GCENTRY *)link);E 19	FreeLink(link);D 19	link = HTcoll + (GETWORD((DLword *)entry)) - 1;	if (GETWORD((DLword *)link + 1) == 0) {		GETWORD((DLword *)entry) = GETWORD((DLword *)link);		FreeLink(link);	}	return NIL;E 19I 19      }    return NIL;E 19nolink:			/* no match */D 19	GetLink(link);	GETWORD((DLword *)link + 1) = GETWORD((DLword *)entry) - 1;	GETWORD((DLword *)entry) = (link - HTcoll) + 1;	RecNewEntry(link, hiptr, casep, ptr);E 19I 19    GetLink(link);    GETGC((GCENTRY *)link + 1) = GETGC((GCENTRY *)entry) - 1;    GETGC((GCENTRY *)entry) = (link - HTcoll) + 1;    RecNewEntry(link, hiptr, casep, ptr);E 19E 17}E 10E 1