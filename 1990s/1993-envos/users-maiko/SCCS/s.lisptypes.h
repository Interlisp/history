h38563s 00009/00007/00546d D 2.16 91/02/07 20:45:06 sybalsky 18 17c Chante TT_LISPREF to TT_SYMBOLP for symbol type-checking of newatoms and litatoms conveniently.es 00060/00003/00493d D 2.15 90/07/25 20:29:16 osamu 17 16c Add type# for NEWATOM(21) this change works when #ifdef BIGATOMSes 00008/00006/00488d D 2.14 90/07/04 03:50:54 sybalsky 16 15c ls *.ces 00014/00001/00480d D 2.13 90/06/04 13:01:41 sybalsky 15 14c reformat, copyrightes 00015/00000/00466d D 2.12 90/03/22 16:35:33 sybalsky 14 13c Change order of operands to + in some cases, makes better 386i code.es 00035/00001/00431d D 2.11 90/02/22 13:15:10 sybalsky 13 12c Added LispArray for general-array access.es 00023/00001/00409d D 2.10 89/03/28 14:25:56 sybalsky 12 11c bitmapes 00007/00005/00403d D 2.9 89/03/18 04:00:44 sybalsky 11 10c Renamed oned-array to OneDArrayes 00115/00007/00293d D 2.8 89/03/16 12:04:26 sybalsky 10 9c Added byte- and word- accessors, and byte-swapped structure defns.es 00051/00001/00249d D 2.7 89/03/01 11:05:44 sybalsky 9 8c Added type numbers for hunked storage.es 00141/00023/00109d D 2.6 89/02/28 04:00:57 sybalsky 8 7c Added BIGNUM, Comples, Ratio, Pathname built-in-types.es 00001/00001/00131d D 2.5 89/01/09 17:55:35 shih 7 6c spellinges 00015/00025/00117d D 2.4 89/01/09 17:52:11 shih 6 5c spellinges 00003/00003/00139d D 2.3 88/07/31 12:45:37 masinter 5 4c remove extra useless slow mask in getting type entryes 00001/00001/00141d D 2.2 88/06/30 15:52:21 bane 4 3c Improvements to Listp() macro to match the nativeincludes onees 00000/00000/00142d D 2.1 88/05/17 09:18:30 hayata 3 2c Version up to 2.1es 00001/00001/00141d D 1.2 88/03/13 13:23:13 hayata 2 1c Add SCCS key id (%Z%)es 00142/00000/00000d D 1.1 88/02/23 18:36:52 hayata 1 0c date and time created 88/02/23 18:36:52 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 2I 2D 6/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 6I 6D 13/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 13I 13D 17/* @(#) lisptypes.h Version 2.10 (3/28/89). copyright envos & Fuji Xerox  */E 17I 17D 18/*  %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 18I 18/*  %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 18E 17E 13E 6E 2/*D 15 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.E 15 *D 6 *	Auther	:	Takeshi Shimizu *			Hiroshi Hayata	E 6I 6 *	Author	:	Takeshi Shimizu *			Hiroshi HayataE 6 */I 15/************************************************************************//*									*/D 18/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 18I 18/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd.		*/E 18/*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 15/**********************************************************************//*D 6 		File Name :	lisptypes.hE 6I 6		File Name :	lisptypes.hE 6D 6		Define Constants for Datatype	  					Date :		December 16, 1986 					Edited by :	Takeshi Shimizu					Changed : Dec.22.86 (take)					Changed : Dec.24.86 (take)					Changed : Feb.04.87 (take)					Addition : Feb 19.87(take)					Changed : March 27 87 (take						  Jun. 5 87 take					Addition :Aug.14 87 take						: Aug 18 87 take					Changed : Nov 30 87 take E 6I 6		Define Constants for Datatype					Date :		December 16, 1986					Edited by :	Takeshi ShimizuE 6*//**********************************************************************/D 8/* Type Table make */E 8I 8/************************************************************************//*									*//*		T Y P E   T A B L E    M A S K    B I T S		*//*									*//*  These are used for quick type checks, and are ORed into the type	*//*  number in the DTD.							*//*									*/I 18/*  [TT_LISPREF renamed to TT_SYMBOLP 2/7/91 by JDS for 3-byte atoms]	*//*									*/E 18/************************************************************************/E 8D 8#define TT_ATOM			0x0800#define TT_NUMBERP		0x1000#define TT_FIXP			0x2000#define TT_LISPREF		0x4000#define TT_NOREF		0x8000E 8I 8D 18#define TT_ATOM		0x0800	/* ATOM in CL sense		 */#define TT_NUMBERP	0x1000	/* It's a number. 		 */#define TT_FIXP		0x2000	/* It's an integer.		 */#define TT_LISPREF	0x4000	/* Punt of Refcount operations.	 */#define TT_NOREF	0x8000	/* Don't Refcount these objects. */E 18I 18#define TT_ATOM		0x0800	/* ATOM in CL sense			 */#define TT_NUMBERP	0x1000	/* It's a number. 			 */#define TT_FIXP		0x2000	/* It's an integer.			 */#define TT_SYMBOLP	0x4000	/* It's a symbol (LITATOM or NEWATOM.	 */#define TT_NOREF	0x8000	/* Don't Refcount these objects.	 */E 18E 8/* Data type Number */D 6/* Thease definitions may be obsolate in Lyric ?? */E 6I 6D 7/* Thease definitions may be obsolete in Lyric ?? */E 7I 7/* These definitions may be obsolete in Lyric ?? */E 7E 6D 8#define TYPE_SMALLP			1#define TYPE_FIXP			2D 6#define TYPE_FLOATP			3 #define TYPE_LITATOM			4 #define TYPE_LISTP			5 #define TYPE_ARRAYP			6 #define TYPE_STRINGP			7 E 6I 6#define TYPE_FLOATP			3#define TYPE_LITATOM			4#define TYPE_LISTP			5#define TYPE_ARRAYP			6#define TYPE_STRINGP			7E 6#define TYPE_STACKP			8#define TYPE_CHARACTERP			9#define TYPE_VMEMPAGEP			10#define TYPE_STREAM			11E 8I 8/************************************************************************//*									*//*			T Y P E   N U M B E R S				*//*									*//*  These are the type numbers "known to the microcode".  This must     *//*  match the list \BUILT-IN-SYSTEM-TYPES, in LLDATATYPE.  It's the     *//*  list of types that MUST be known to microcode or emulator, and      *//*  which can't rely on the luck of what's loaded when for assignment.  *//*									*//*  Change History:	2/27/89 Sybalsky  Added BIGNUM-PATHNAME, to     *//*					  support SXHASH opcode. 	*/I 9/*			3/1/89	Sybalsky  Added type #s for hunked	*//*					  storage, for use in GC, in	*//*					  place of absolute #s (!!)	*/E 9D 17/*									*/E 17I 17/*			7/25/90 Osamu     Added type# for NEWATOM.						*/E 17/************************************************************************/E 8D 6 E 6I 6I 9#define TYPE_ARRAYBLOCK		0	/* Pseudo type # for array blocks */E 9E 6D 8#define TYPE_BITMAP			12#define TYPE_COMPILED_CLOSURE		13#define TYPE_ONED_ARRAY			14#define TYPE_TWOD_ARRAY			15#define TYPE_GENERAL_ARRAY		16E 8I 8#define TYPE_SMALLP		1#define TYPE_FIXP		2#define TYPE_FLOATP		3#define TYPE_LITATOM		4#define TYPE_LISTP		5#define TYPE_ARRAYP		6#define TYPE_STRINGP		7	/* old IL strings (obs) */#define TYPE_STACKP		8#define TYPE_CHARACTERP		9#define TYPE_VMEMPAGEP		10#define TYPE_STREAM		11E 8I 8#define TYPE_BITMAP		12#define TYPE_COMPILED_CLOSURE	13#define TYPE_ONED_ARRAY		14	/* array, string */#define TYPE_TWOD_ARRAY		15#define TYPE_GENERAL_ARRAY	16E 8D 8#define INIT_TYPENUM			17E 8I 8#define TYPE_BIGNUM		17	/* Bignums */#define TYPE_RATIO		18	/* Commonlisp rationals */#define TYPE_COMPLEX		19	/* Commonlisp complex's */#define TYPE_PATHNAME		20	/* CL path-name structure */E 8I 17#ifdef BIGATOMS#define TYPE_NEWATOM		21	/* New Atom *//* type number 22~30 reserved for future use */#define TYPE_PTRHUNK1		31	/********************************/#define TYPE_PTRHUNK2		32	/*  				*/#define TYPE_PTRHUNK3		33	/*  Type numbers for "hunked"	*/#define TYPE_PTRHUNK4		34	/*  Storage region, used for	*/#define TYPE_PTRHUNK5		35	/*  small arrays.  This range	*/#define TYPE_PTRHUNK6		36	/*  is for arrays of pointers.	*/#define TYPE_PTRHUNK7		37	/*				*/#define TYPE_PTRHUNK8		38	/********************************/#define TYPE_PTRHUNK9		39#define TYPE_PTRHUNK10		40#define TYPE_PTRHUNK11		41#define TYPE_PTRHUNK12		42#define TYPE_PTRHUNK13		43#define TYPE_UNBOXEDHUNK1	44	/********************************/#define TYPE_UNBOXEDHUNK2	45	/*  				*/#define TYPE_UNBOXEDHUNK3	46	/*  This range is for arrays	*/#define TYPE_UNBOXEDHUNK4	47	/*  of unboxed items -- the	*/#define TYPE_UNBOXEDHUNK5	48	/*  contents are not GC'd	*/#define TYPE_UNBOXEDHUNK6	49	/*				*/#define TYPE_UNBOXEDHUNK7	50	/********************************/#define TYPE_UNBOXEDHUNK8	51#define TYPE_UNBOXEDHUNK9	52#define TYPE_UNBOXEDHUNK10	53#define TYPE_UNBOXEDHUNK11	54#define TYPE_UNBOXEDHUNK12	55#define TYPE_UNBOXEDHUNK13	56#define TYPE_UNBOXEDHUNK14	57#define TYPE_UNBOXEDHUNK15	58#define TYPE_UNBOXEDHUNK16	59#define TYPE_UNBOXEDHUNK17	60#define TYPE_UNBOXEDHUNK18	61#define TYPE_UNBOXEDHUNK19	62#define TYPE_UNBOXEDHUNK20	63#define TYPE_CODEHUNK1		64	/********************************/#define TYPE_CODEHUNK2		65	/*  				*/#define TYPE_CODEHUNK3		66	/*  This range is for small	*/#define TYPE_CODEHUNK4		67	/*  CODE blocks -- the code 	*/#define TYPE_CODEHUNK5		68	/*  for small functions.  It	*/#define TYPE_CODEHUNK6		69	/*  gets reclaimed using the	*/#define TYPE_CODEHUNK7		70	/*  function reclaimcodeblock.	*/#define TYPE_CODEHUNK8		71	/*				*/#define TYPE_CODEHUNK9		72	/********************************/#define TYPE_CODEHUNK10		73#define INIT_TYPENUM		74#elseE 17I 9#define TYPE_PTRHUNK1		21	/********************************/#define TYPE_PTRHUNK2		22	/*  				*/#define TYPE_PTRHUNK3		23	/*  Type numbers for "hunked"	*/#define TYPE_PTRHUNK4		24	/*  Storage region, used for	*/#define TYPE_PTRHUNK5		25	/*  small arrays.  This range	*/#define TYPE_PTRHUNK6		26	/*  is for arrays of pointers.	*/#define TYPE_PTRHUNK7		27	/*				*/#define TYPE_PTRHUNK8		28	/********************************/#define TYPE_PTRHUNK9		29#define TYPE_PTRHUNK10		30#define TYPE_PTRHUNK11		31#define TYPE_PTRHUNK12		32#define TYPE_PTRHUNK13		33E 9I 8D 9#define INIT_TYPENUM		21E 9I 9#define TYPE_UNBOXEDHUNK1	34	/********************************/#define TYPE_UNBOXEDHUNK2	35	/*  				*/#define TYPE_UNBOXEDHUNK3	36	/*  This range is for arrays	*/#define TYPE_UNBOXEDHUNK4	37	/*  of unboxed items -- the	*/#define TYPE_UNBOXEDHUNK5	38	/*  contents are not GC'd	*/#define TYPE_UNBOXEDHUNK6	39	/*				*/#define TYPE_UNBOXEDHUNK7	40	/********************************/#define TYPE_UNBOXEDHUNK8	41#define TYPE_UNBOXEDHUNK9	42#define TYPE_UNBOXEDHUNK10	43#define TYPE_UNBOXEDHUNK11	44#define TYPE_UNBOXEDHUNK12	45#define TYPE_UNBOXEDHUNK13	46#define TYPE_UNBOXEDHUNK14	47#define TYPE_UNBOXEDHUNK15	48#define TYPE_UNBOXEDHUNK16	49#define TYPE_UNBOXEDHUNK17	50#define TYPE_UNBOXEDHUNK18	51#define TYPE_UNBOXEDHUNK19	52#define TYPE_UNBOXEDHUNK20	53#define TYPE_CODEHUNK1		54	/********************************/#define TYPE_CODEHUNK2		55	/*  				*/#define TYPE_CODEHUNK3		56	/*  This range is for small	*/#define TYPE_CODEHUNK4		57	/*  CODE blocks -- the code 	*/#define TYPE_CODEHUNK5		58	/*  for small functions.  It	*/#define TYPE_CODEHUNK6		59	/*  gets reclaimed using the	*/#define TYPE_CODEHUNK7		60	/*  function reclaimcodeblock.	*/#define TYPE_CODEHUNK8		61	/*				*/#define TYPE_CODEHUNK9		62	/********************************/#define TYPE_CODEHUNK10		63#define INIT_TYPENUM		64E 9I 17#endif BIGATOMSE 17I 10I 17E 17#ifndef BYTESWAP	/* Normal byte-order versions of declarations */E 10E 8/* Structure for DTD */struct dtd {D 16	DLword dtd_name ;E 16I 16	DLword dtd_namelo ;E 16	DLword dtd_size ;D 16	LispPTR dtd_free ;E 16I 16	LispPTR dtd_free ;		/* really a FULLXPOINTER */E 16	unsigned unuse	:2 ;	unsigned dtd_obsolate :1 ;	unsigned dtd_finalizable :1 ;	unsigned dtd_lockedp : 1 ;	unsigned dtd_hunkp : 1 ;	unsigned dtd_gctype :2 ;	unsigned dtd_descrs : 24;D 16	LispPTR dtd_typespecs ;E 16I 16	unsigned dtd_namehi : 8;	unsigned dtd_typespecs : 24 ;E 16	LispPTR dtd_ptrs ;	int  dtd_oldcnt;	DLword dtd_cnt0 ;	DLword dtd_nextpage ;	DLword dtd_typeentry ;	DLword dtd_supertype ;};typedef  struct stringp {	unsigned origin			: 1 ;	unsigned substringed		: 1 ;	unsigned readonly		: 1 ;	unsigned nil			: 1 ;	unsigned type			: 4 ;	unsigned base			: 24 ;	DLword   length ;	DLword   offset ; } STRINGP ;typedef struct oned_array {		unsigned int nil1 : 8 ;		unsigned int base : 24  ;		unsigned int readonlyp :1 ;		unsigned int indirectp : 1; /* as used arrayheader */		unsigned int bitp :1 ;		unsigned int stringp : 1;		unsigned int ajustablep : 1; /* as used arrayheader */		unsigned int displacedp : 1;		unsigned int fillpointerp :1;		unsigned int extendablep : 1;		unsigned int typenumber : 8 ;		DLword offset;		DLword fillpointer ;D 11		DLword totalsize ; } ONEDARRAAY;E 11I 11		DLword totalsize ; } OneDArray;E 11typedef struct oned_array NEWSTRINGP;I 13typedef struct general_array {		unsigned int nil1 : 8 ;		unsigned int base : 24  ;		unsigned int readonlyp :1 ;		unsigned int indirectp : 1; /* as used arrayheader */		unsigned int bitp :1 ;		unsigned int stringp : 1;		unsigned int ajustablep : 1; /* as used arrayheader */		unsigned int displacedp : 1;		unsigned int fillpointerp :1;		unsigned int extendablep : 1;		unsigned int typenumber : 8 ;		DLword Dim0;		DLword Dim1 ;		DLword Dim2 ; } LispArray;E 13typedef struct compiled_closure {		unsigned int nil1	: 8 ;		unsigned int def_ptr	: 24; /* function */		unsigned int nil2	: 8 ;		unsigned int env_ptr	: 24; /* environment */  } CClosure ;I 12E 12D 10#define ST_POS16	1#define ST_BYTE		0#define THIN_CHAR_TYPENUMBER	67#define FAT_CHAR_TYPENUMBER	68E 10/* Structure for initialdtdcontents */ struct system_dtd_contents {	char   *dtd_name ;  /* type name string >> changed 4-feb-87 */	DLword  name_len ;  /* type name length in BYTE 27-Mar-87 take */	DLword  dtd_size ;};I 12typedef struct{	LispPTR	bmbase;	DLword	bmrasterwidth;	DLword	bmheight;	DLword	bmwidth;	DLword	bmbitperpixel;}BITMAP;E 12I 10	/****************************************************************/	/*		Byte- and Word-array access macros 		*/	/* 								*/	/* Use these macros instead of dereferencing a char pointer	*/	/* so we can encapsulate byte-ordering effects on different	*/	/* hardware!							*/	/* 								*/	/****************************************************************/D 11#define GETBASEBYTE(base,offset) (* ((base)+(offset)))E 11#define GETBYTE(base) (* (base))#define GETBASEWORD(base, offset) (* ((base)+(offset)))#define GETWORD(base) (* (base))I 11#define WORDPTR(base) (base)#define BYTEPTR(base) (base)E 11#else	/********************************************************/	/*							*/D 11	/*  Byte-swapped structure definitions, for 809386 &c	*/E 11I 11	/*  Byte-swapped structure definitions, for 80386 &c	*/E 11	/*							*/	/********************************************************//* Structure for DTD */struct dtd {	DLword dtd_size ;D 16	DLword dtd_name ;	LispPTR dtd_free ;E 16I 16D 17	DLword ded_namelo ;E 17I 17	DLword dtd_namelo ;E 17	LispPTR dtd_free ;		/* really a FULLXPOINTER */E 16	unsigned dtd_descrs : 24;	unsigned dtd_gctype :2 ;	unsigned dtd_hunkp : 1 ;	unsigned dtd_lockedp : 1 ;	unsigned dtd_finalizable :1 ;	unsigned dtd_obsolate :1 ;	unsigned unuse	:2 ;D 16	LispPTR dtd_typespecs ;E 16I 16	unsigned dtd_typespecs : 24 ;	unsigned dtd_namehi : 8;E 16	LispPTR dtd_ptrs ;	int  dtd_oldcnt;	DLword dtd_nextpage ;	DLword dtd_cnt0 ;	DLword dtd_supertype ;	DLword dtd_typeentry ;};typedef  struct stringp  {	unsigned base			: 24 ;	unsigned type			: 4 ;	unsigned nil			: 1 ;	unsigned readonly		: 1 ;	unsigned substringed		: 1 ;	unsigned origin			: 1 ;	DLword   offset ;	DLword   length ;  } STRINGP ;typedef struct oned_array  {	unsigned int base : 24  ;	unsigned int nil1 : 8 ;	DLword offset;	unsigned int typenumber : 8 ;	unsigned int extendablep : 1;	unsigned int fillpointerp :1;	unsigned int displacedp : 1;	unsigned int ajustablep : 1; /* as used arrayheader */	unsigned int stringp : 1;	unsigned int bitp :1 ;	unsigned int indirectp : 1; /* as used arrayheader */	unsigned int readonlyp :1 ;	DLword totalsize ;	DLword fillpointer ;D 11  } ONEDARRAAY;E 11I 11  } OneDArray;E 11typedef struct oned_array NEWSTRINGP;I 13typedef struct general_array  {	unsigned int base : 24  ;	unsigned int nil1 : 8 ;	DLword Dim0;	unsigned int typenumber : 8 ;	unsigned int extendablep : 1;	unsigned int fillpointerp :1;	unsigned int displacedp : 1;	unsigned int ajustablep : 1; /* as used arrayheader */	unsigned int stringp : 1;	unsigned int bitp :1 ;	unsigned int indirectp : 1; /* as used arrayheader */	unsigned int readonlyp :1 ;	DLword Dim2 ;	DLword Dim1 ;  } LispArray;E 13typedef struct compiled_closure  {    unsigned int def_ptr : 24; /* function */    unsigned int nil1 : 8 ;    unsigned int env_ptr: 24; /* environment */    unsigned int nil2 : 8 ;  } CClosure ;/* Structure for initialdtdcontents */I 12E 12 struct system_dtd_contents  {    char   *dtd_name ;  /* type name string >> changed 4-feb-87 */    DLword  dtd_size ;    DLword  name_len ;  /* type name length in BYTE 27-Mar-87 take */  };I 12typedef struct  {    LispPTR	bmbase;    DLword	bmheight;    DLword	bmrasterwidth;    DLword	bmbitperpixel;    DLword	bmwidth;  }BITMAP;E 12	/****************************************************************/	/*		Byte- and Word-array access macros 		*/	/* 								*/	/* Use these macros instead of dereferencing a char pointer	*/	/* so we can encapsulate byte-ordering effects on different	*/	/* hardware!							*/	/* 								*/	/****************************************************************/D 11#define GETBASEBYTE(base,offset) (* (char *) (((offset)+(int)(base))^3))E 11#define GETBYTE(base) (* (char *) (3^(int)(base)))#define GETBASEWORD(base, offset) (* (DLword *) (2^(int)((offset)+(base))))#define GETWORD(base) (* (DLword *) (2^(int)(base)))I 11#define WORDPTR(base) ((DLword *)(2^(int)(base)))#define BYTEPTR(base) ((char *) (3^(int)(base)))E 11#endif BYTESWAP#define ST_POS16	1#define ST_BYTE		0#define THIN_CHAR_TYPENUMBER	67#define FAT_CHAR_TYPENUMBER	68E 10I 8/************************************************************************//*									*//*		T Y P E   E N T R Y   A C C E S S O R S			*//*									*//*	GetDTD		Gets the (C-native) address for the DTD		*//*			(Data Type Descriptor) for the type whose	*//*			number you hand it (LESS the mask bits!).	*//*									*//*	GetTypeEntry	Gets the entire 16-bit "type number" field	*//*			from the DTD, including type-mask bits.		*//*			Use this one when you want the mask bits for	*//*			a quick category check.				*//*									*//*	GetTypeNumber	Gets only the Type Number (without mask bits)	*//*			from the DTD for the object you give it.	*//*			Use this one for doing type checks and 		*//*			dispatching.					*//*									*//*	Listp		If 'address' is the address of a cons cell,	*//*			returns TRUE.  Equivalent to the LISTP pred.	*//*									*//************************************************************************/I 14#ifndef I386E 14E 8/* Get DTD pointer(68k) from typenum */#define GetDTD(typnum)	(DTDspace + ((typnum)<<4))/* Get all type entry */D 5#define GetTypeEntry(address)       *(MDStypetbl + (((address) & 0x0ffff00)>>9))/* This MACRO is similar to NTYPEX 0xff->2047 */#define GetTypeNumber(address)     ((*(MDStypetbl +(((address) & 0x0ffff00)>>9))) & 2047)E 5I 5D 12#define GetTypeEntry(address)      ( *(MDStypetbl+((address)>>9)) )E 12I 12#define GetTypeEntry(address)      ( GETWORD(MDStypetbl+((address)>>9)) )I 14#else	/* Because the 386i's code generator does bettter with them */	/* in this order (does an add, rather than mov-add) */	/* JDS 22-mar-90 *//* Get DTD pointer(68k) from typenum */#define GetDTD(typnum)	(((typnum)<<4) + DTDspace)/* Get all type entry */#define GetTypeEntry(address)      ( GETWORD(((address)>>9) + MDStypetbl) )#endif I386E 14E 12I 8E 8/* the type number is in the low 11 bits */#define GetTypeNumber(address)     (GetTypeEntry(address) & 0x7ff)E 5/* This MACRO is similar to LISTP */D 4#define Listp(address)	( ((GetTypeNumber((address)) ^ TYPE_LISTP )==0) ? 1 : 0 )E 4I 4#define Listp(address)	(GetTypeNumber(address) == TYPE_LISTP)I 8	/******************************************/	/*        Lisp's PATHNAME datatype        */	/*                                        */	/*   This MUST change whenever the Lisp   */	/*   definition of the PATHNAME structure */	/*   changes.                             */	/*                                        */	/******************************************/typedef  struct    {      LispPTR host;      LispPTR device;      LispPTR directory;      LispPTR name;      LispPTR type;      LispPTR version;    } PATHNAME;  	/******************************************/	/*         Lisp's COMPLEX datatype        */	/*                                        */	/*   This MUST change whenever the Lisp   */	/*   definition of the COMPLEX structure  */	/*   changes.                             */	/*                                        */	/******************************************/typedef  struct    {      LispPTR real;      LispPTR imaginary;    } COMPLEX;	/******************************************/	/*          Lisp's RATIO datatype         */	/*                                        */	/*   This MUST change whenever the Lisp   */	/*   definition of the RATIO structure    */	/*   changes.                             */	/*                                        */	/******************************************/typedef  struct    {      LispPTR numerator;      LispPTR denominator;    } RATIO;	/******************************************/	/*         Lisp's BIGNUM datatype         */	/*                                        */	/*   This MUST change whenever the Lisp   */	/*   definition of the BIGNUM structure   */	/*   changes.                             */	/*                                        */	/******************************************/typedef  struct    {      LispPTR contents;	/* a list of 12-bit segments of value, */			/* low-order 12 bits first.            */    } BIGNUM;E 8E 4E 1