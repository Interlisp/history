h04903s 00008/00003/00088d D 2.11 93/02/08 14:54:01 sybalsky 15 14c Big VM (and new CDR coding) changes for 3.0 \nes 00004/00004/00087d D 2.10 92/04/21 17:14:33 sybalsky 14 13c shortening file names for DOS \nes 00068/00046/00023d D 2.9 91/02/20 13:50:19 sybalsky 13 12c Make GVAR_ opcode handle new atoms.  Reformat code and copyright notice.es 00003/00002/00066d D 2.8 90/06/15 16:58:22 mitani 12 11c includes lisptypes.hes 00000/00000/00068d D 2.7 90/04/20 01:38:03 sybalsky 11 10c AIX:  shortening file names, bulk change.es 00003/00000/00065d D 2.6 90/03/21 14:44:15 sybalsky 10 9c add check ofr hi byte left on when setting a GVAR (only if DEBUG set)es 00001/00005/00064d D 2.5 89/03/27 13:20:18 sybalsky 9 8c Moved xpointer def to cell.h, adding byte-swapped version.es 00003/00024/00066d D 2.4 88/10/10 14:06:40 krivacic 8 7c sun3/4 mergees 00001/00001/00089d D 2.3 88/09/27 16:46:32 shih 7 6c sp. correctiones 00000/00102/00090d D 2.2 88/05/25 15:08:22 krivacic 6 5c remove commented out references to funcalles 00000/00000/00192d D 2.1 88/05/17 09:25:02 hayata 5 4c Version up to 2.1es 00008/00008/00184d D 1.4 88/05/09 21:18:38 shih 4 3c Use GCLOOKUPes 00073/00000/00119d D 1.3 88/03/29 18:50:52 krivacic 3 2c New Interfaceses 00002/00002/00117d D 1.2 88/03/13 14:50:53 hayata 2 1c Add SCCS key id (%Z%)es 00119/00000/00000d D 1.1 88/02/24 16:57:28 hayata 1 0c date and time created 88/02/24 16:57:28 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 12I 12/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 12E 2D 13/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 7 *	Auther	:	Hiroshi Hayata	E 7I 7 *	Author	:	Hiroshi Hayata	E 7 */E 13I 13/************************************************************************//*									*//*	Copyright 1989, 1990 Venue.					*//*									*//*	This file was work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 13#include <stdio.h>#include "lispemul.h"I 12D 14#include "lisptypes.h"E 12#include "lispglobal.h"#include "address68k.h"E 14I 14#include "lsptypes.h"#include "lspglob.h"#include "adr68k.h"E 14#include "gc.h"D 14#include "emulglobal.h"E 14I 14#include "emlglob.h"E 14I 9#include "cell.h"I 13#include "dbprint.h"E 13E 9D 9struct xpointer{	unsigned	flags:8;	unsigned	addr:24;};E 9D 6/************************************************************ OP_gvar_	entry		GVAR_		OPCODE[027]E 6D 6	1.	(alpha, beta): offset of argued slot from Valspace.	2.	address of GVAR slot is Valspace+offset.	3.	call gclookup with DELREF and address of GVAR slot.	4.	call gclookup with ADDREF and TopOFStack.	5.	replace GVAR slot with TopOfStack.	6.	If Hash Table is overflow, call fn1ext.	7. 	increment PC by 3.***********************************************************/ OP_gvar_(){register unsigned  int	offset;	/* argued slot: word offset from Valspace */register DLword	*pslot;		/* pointer to argued GVAR slot */register LispPTR	old;		/* old contents of argued GVAR slot */#ifdef	TRACE	printPC();	printf("TRACE: OP_gvar_()\n");#endif/*	alpha = 0xFF & (*(PC+1));	beta = 0xFF & (*(PC+2));	offset = ((alpha << 8) | beta) << 1; */	offset = (((0xFF & (*(PC+1))) << 8) | (0xFF & (*(PC+2)))) << 1; 	pslot = Valspace + offset;	old = 0xFFFFFF & (*((LispPTR *)pslot));/*	GcLov = 0;	*/D 4	gclookup(0x8000| DELREF, old); 	gclookup(0x8000| ADDREF, 0xFFFFFF & TopOfStack );E 4I 4	GCLOOKUP(0x8000, DELREF, old); 	GCLOOKUP(0x8000, ADDREF, 0xFFFFFF & TopOfStack );E 4	((struct xpointer*)pslot)->addr = 0xFFFFFF & TopOfStack;/* ***	if( GcLov == 0xFFFF){#ifdef	DEBUG	printf("DEBUG: OP_gvar_[HashTable overflow or collision]\n");#endif		funcall(ATOMGCSCAN, 1, 3);		return;	} **************************/	PC +=3;	return;}E 6D 13/************************************************************D 6 OP_rplptr	entry		RPLPTR		OPCODE[024]	1.	alpha : offset of argued slot from *CurrentStackPTR.	2.	address of slot is (*CurrentStackPTR)+offset.	3.	call gclookup with DELREF and address of slot.	4.	call gclookup with ADDREF and TopOFStack.	5.	replace slot with TopOfStack.	6.	Pop Current Stack.	7.	If Hash Table is overflow, call fn1ext.	8. 	increment PC by 2.***********************************************************/ OP_rplptr(){register LispPTR	topcstack;	/* Top slot of Current Satck */register DLword	*pslot;		/* pointer to argued slot (68 address) */register LispPTR	old;		/* old contents of argued slot */#ifdef	TRACE	printPC();	printf("TRACE: OP_rplptr()\n");#endif/*CSP	topcstack = 0xFFFFFF & (*((LispPTR *)(CurrentStackPTR-1)));	*/	topcstack = 0xFFFFFF & (*((LispPTR *)(CurrentStackPTR)));	pslot = Addr68k_from_LADDR( topcstack+(0xFF & (*(PC+1))) );	old = 0xFFFFFF & (*((LispPTR *)pslot));/*	GcLov = 0;	*/D 4	gclookup(0x8000|DELREF, old);	gclookup(0x8000|ADDREF, 0xFFFFFF & TopOfStack );E 4I 4	GCLOOKUP(0x8000,DELREF, old);	GCLOOKUP(0x8000,ADDREF, 0xFFFFFF & TopOfStack );E 4	((struct xpointer*)pslot)->addr = TopOfStack;	PopCStack;/******************	if(GcLov == 0xFFFF){#ifdef	DEBUG	printf("DEBUG: OP_rplptr[HashTable overflow or collision]\n");#endif		funcall(ATOMGCSCAN, 1, 2);		return;	} *************/	PC+=2;	return;}I 3/************************************************************E 6 N_OP_gvar_	entry		GVAR_		OPCODE[027]	1.	atom_index: offset of argued slot from Valspace.	2.	address of GVAR slot is Valspace+offset.	3.	call gclookup with DELREF and address of GVAR slot.	4.	call gclookup with ADDREF and TopOFStack.	5.	replace GVAR slot with tos.	6.	If Hash Table is overflow, call fn1ext.***********************************************************/E 13I 13/************************************************************************//*									*//*			    N _ O P _ g v a r _				*//*									*//*	GVAR_ opcode (027).  Assign a value to a global variable.	*//*									*//*	atom_index is the "atom number," either the lo half of the	*//*	old litatom, or the new-atom itself.				*//*									*//*	* call gclookup with DELREF and address of GVAR slot.		*//*	* call gclookup with ADDREF and TopOFStack.			*//*	* replace GVAR slot with tos.					*//*	* If Hash Table is overflow, call fn1ext.			*//*									*//************************************************************************/E 13 LispPTR N_OP_gvar_(tos, atom_index)D 13	register LispPTR tos;	unsigned int atom_index;{register LispPTR *pslot;	/* pointer to argued GVAR slot */E 13I 13  register LispPTR tos;  unsigned int atom_index;  {    register LispPTR *pslot;	/* pointer to argued GVAR slot */E 13D 8register LispPTR old;		/* old contents of argued GVAR slot */E 8D 8#ifdef	TRACE	printPC();	printf("TRACE: N_OP_gvar_()\n");#endifE 8D 13	pslot = (LispPTR *) Valspace + atom_index;I 10#ifdef DEBUG	if (tos&0xFF000000) error("Setting GVAR with high bits on");#endifE 10D 8	old = 0xFFFFFF & *pslot;D 6/*	GcLov = 0;	*/E 6D 4	gclookup(0x8000| DELREF, old); 	gclookup(0x8000| ADDREF, 0xFFFFFF & tos );E 4I 4	GCLOOKUP(0x8000, DELREF, old); 	GCLOOKUP(0x8000, ADDREF, 0xFFFFFF & tos );E 4	((struct xpointer*)pslot)->addr = tos;E 8I 8	FRPLPTR(((struct xpointer*)pslot)->addr, tos);E 8	return(tos);}E 13I 13#ifdef BIGATOMSD 15    if (0 != (atom_index & 0xFF0000))E 15I 15    if (0 != (atom_index & SEGMASK))E 15      pslot = (LispPTR *) Addr68k_from_LADDR(atom_index + NEWATOM_VALUE_OFFSET);    elseD 15#endif BIGATOMSE 15I 15#endif /* BIGATOMS */#ifdef BIGVM    pslot = ((LispPTR *) Pnamespace) + (5 * atom_index) + NEWATOM_VALUE_PTROFF;#elseE 15    pslot = (LispPTR *) Valspace + atom_index;D 15    DEBUGGER(if (tos&0xFF000000) error("Setting GVAR with high bits on"));E 15I 15#endif /* BIGVM */    DEBUGGER(if (tos&0xF0000000) error("Setting GVAR with high bits on"));E 15    FRPLPTR(((struct xpointer*)pslot)->addr, tos);    return(tos);  }E 13D 13/************************************************************ N_OP_rplptr	entry		RPLPTR		OPCODE[024]E 13D 13	1.	alpha : offset of argued slot from tos_m_1.	2.	address of slot is tos_m_1+offset.	3.	call gclookup with DELREF and address of slot.	4.	call gclookup with ADDREF and tos.	5.	replace slot with tos.E 13D 13***********************************************************/ E 13I 13/************************************************************************//*									*//*			    N _ O P _ r p l p t r			*//*									*//*	RPLPTR opcode (024).  Replace a pointer field somewhere,	*//*	updating the reference counts for the old value and the new	*//*	value (DELREF and ADDREF, respectively).			*//*									*//*	tos_m_1 is the base, and alpha is a word-offset for finding	*//*	the cell to replace contents of.				*//*	tos is the new value.						*//*									*//************************************************************************/E 13LispPTR N_OP_rplptr(tos_m_1, tos, alpha)D 13	register LispPTR tos, tos_m_1;	unsigned int alpha;{register DLword	*pslot;		/* pointer to argued slot (68 address) */E 13I 13  register LispPTR tos, tos_m_1;  unsigned int alpha;  {    register DLword *pslot;	/* pointer to argued slot (68 address) */E 13D 8register LispPTR old;		/* old contents of argued slot */E 8D 8#ifdef	TRACE	printPC();	printf("TRACE: N_OP_rplptr()\n");#endif	pslot = Addr68k_from_LADDR( (0xFFFFFF & tos_m_1) + alpha );	old = 0xFFFFFF & (*((LispPTR *)pslot));D 6/*	GcLov = 0;	*/E 6D 4	gclookup(0x8000|DELREF, old);	gclookup(0x8000|ADDREF, old = 0xFFFFFF & tos );E 4I 4	GCLOOKUP(0x8000,DELREF, old);	GCLOOKUP(0x8000,ADDREF, old = 0xFFFFFF & tos );E 4	((struct xpointer*)pslot)->addr = tos;E 8I 8D 13	pslot = Addr68k_from_LADDR(tos_m_1 + alpha );	FRPLPTR( ((struct xpointer*)pslot)->addr,tos);E 8	return(tos_m_1);}E 13I 13    pslot = Addr68k_from_LADDR(tos_m_1 + alpha );    FRPLPTR( ((struct xpointer*)pslot)->addr,tos);    return(tos_m_1);  }E 13E 3E 1