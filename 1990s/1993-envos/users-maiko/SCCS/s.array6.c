h18095s 00004/00004/00057d D 2.10 92/04/21 17:04:00 sybalsky 14 13c shortening file names for DOS \nes 00000/00000/00061d D 2.9 90/04/20 01:20:43 sybalsky 13 12c AIX:  shortening file names, bulk change.es 00018/00008/00043d D 2.8 90/02/19 11:07:20 sybalsky 12 11c 386i changes; add commentses 00008/00009/00043d D 2.7 88/10/12 14:40:20 krivacic 11 10c new out-of-line interfacees 00003/00101/00049d D 2.6 88/07/06 14:40:46 charnley 10 9c uses new select macro with modified select order.es 00017/00033/00133d D 2.5 88/06/07 16:59:42 charnley 9 8c disallow smallp's ino char'ses 00003/00001/00163d D 2.4 88/05/25 17:16:46 charnley 8 7c changed err type.es 00002/00002/00162d D 2.3 88/05/25 16:54:01 charnley 7 6c changed sum name.es 00007/00148/00157d D 2.2 88/05/25 16:04:36 charnley 6 5c removed unused code, fixed bugs in unsigned 16 bit, 32 bit and fl pt.es 00000/00000/00305d D 2.1 88/05/17 09:22:12 hayata 5 4c Version up to 2.1es 00010/00007/00295d D 1.4 88/05/09 21:46:59 shih 4 3c Use GCLOOKUPes 00006/00009/00296d D 1.3 88/04/21 09:39:58 charnley 3 2c changed array-type mask, added refrcounting to pointers, removed unused .h'ses 00002/00000/00303d D 1.2 88/04/20 14:19:49 masinter 2 1c Temporary patch to turn off non-refcounting aset of pointeres 00303/00000/00000d D 1.1 88/04/05 15:29:27 charnley 1 0c date and time created 88/04/05 15:29:27 by charnleyeuUtTI 1/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";D 12/*	array6.c */E 12I 12/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 12#include <stdio.h>#include "lispemul.h"D 14#include "lispglobal.h"#include "address68k.h"E 14I 14#include "lspglob.h"#include "adr68k.h"E 14#include "lispmap.h"D 14#include "lisptypes.h"#include "emulglobal.h"E 14I 14#include "lsptypes.h"#include "emlglob.h"E 14I 3#include "gc.h"E 3#include "arith.h"#include "my.h"D 3#include "tos1defs.h" #include "tosretmacro.h"#include "tosfuncallmacro.h"#include "inlinedefsC.h"#include "inlinedefs68K.h" #include "fastinlinedefs68K.h"E 3D 10/************************************************************ OP_aset2   -- op 357   (new-value array index index)   Array data structure :Word	Content0	Hi word of base pointer1	Low word of base pointer2	Flag (8 bits), Type (4 bits), Size (bits per element, 4 bits)3	Bound 04	Bound 15	Total sizeD 6	typenumber:		type = 7 & (typenumber >> 4)		0  unsigned		1  signed		2  pointer		3  float		4  character		5  xpointer		6  illegal		7  illegal		size = 7 & typenumber		0 1 bit   :		1 2 bits  :		2 4 bits  :		3 8 bits  :		4 16 bits : 		5 24 bits :		6 32 bits :		7 64 bits :	E 6type    size    typenumber  0       0             0      unsigned  :  1 bit  0       3             3      unsigned  :  8 bits  0       4             4      unsigned  : 16 bits  1       4            20      signed    : 16 bits  1       6            22      signed    : 32 bits  2       6            38      pointer   : 32 bits  3       6            54      float     : 32 bits  4       3            67      character :  8 bits  4       4            68      character : 16 bits  5       6            86      Xpointer  : 32 bits***********************************************************/E 10D 6/***	OP_aset2   -- op 357   (new-value array index0 index1)   ***/OP_myaset2(){register LispPTR base;register short typenumber;register short index;register LispPTR data;register DLword *array;register int new;LispPTR temp;register int i, j;      /*  verify array  */      temp = *((LispPTR *)(CurrentStackPTR - 2));      if (GetTypeNumber(temp) != TYPE_TWOD_ARRAY) gotoufn;      array = Addr68k_from_LADDR(temp);      /*  test and setup index  */      temp = *((LispPTR *)CurrentStackPTR);      if ((0xFFFF0000 & temp) != S_POSITIVE) gotoufn;      i = 0xFFFF & temp;      if (i >= *((DLword *)(array + 3))) gotoufn;      if ((0xFFFF0000 & TopOfStack) != S_POSITIVE) gotoufn;      index = 0xFFFF & TopOfStack;      if (index >= (j = (*((DLword *)(array + 4))))) gotoufn;      index += (i * j);      /*  setup typenumber  */      temp = *((DLword *)(array + 2));      if (temp & 0x8000) gotoufn;/* not writeable */      typenumber = 0xFF & temp;      /*  setup base  */      base = *((LispPTR *)array);      /*  fetch data  */      data = *((LispPTR *)(CurrentStackPTR - 4));      /*  disp on type  */    switch (typenumber) {      case 0: /* unsigned : 1 bit per element */        if ((data & 0xFF0000) != S_POSITIVE) gotoufn;         new = data & 0xFFFF;        if (new > 1) gotoufn;        if (new) {          new = (1 << (7 - (index & 7)));          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) |= new;        }        else {          new = 0xFF - (1 << (7 - (index & 7)));          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) &= new;        }        break;      case 3: /* unsigned : 8 bits per element */        if ((data & 0xFF0000) != S_POSITIVE) gotoufn;         new = data & 0xFFFF;        if (new > 0xFF) gotoufn;        *(((char *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 4: /* unsigned : 16 bits per element */        if ((data & 0xFF0000) != S_POSITIVE) gotoufn;         new = data & 0xFFFF;        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 20: /* signed : 16 bits */        if ((((data & 0xFF0000) == S_POSITIVE) && ((data & 0x8000) == 0)) || (((data & 0xFF0000) == S_NEGATIVE) && ((data & 0x8000) != 0)))        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        else gotoufn;        break;      case 22: /* signed : 32 bits */        GetNumber(data, new);        *(((int *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 38: /* pointer : 32 bits */I 2D 3	gotoufn; /* SHOULD REFERENCE COUNT */E 3I 3D 4	gclookup(0x8000|DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));        gclookup(0x8000|ADDREF, data);E 4I 4	GCLOOKUP(0x8000,DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));        GCLOOKUP(0x8000,ADDREF, data);E 4E 3E 2        *(((int *)Addr68k_from_LADDR(base)) + index) = data;        break;      case 54: /* Float : 32 bits */        if (GetTypeNumber(data) != TYPE_FLOATP) gotoufn;        *(((int *)Addr68k_from_LADDR(base)) + index) = *(int *)data;        break;      case 67: /* Character :  8 bits */        if (((data & 0xFF0000) != S_POSITIVE) && ((data & 0xFF0000) != S_CHARACTER)) gotoufn;        new = data & 0xFFFF;        if (new > 0xFF) gotoufn;        *(((char *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 68: /* Character :  16 bits */        if (((data & 0xFF0000) != S_POSITIVE) && ((data & 0xFF0000) != S_CHARACTER)) gotoufn;         new = data & 0xFFFF;        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        break;      case 86: /* XPointer : 32 bits */        *(((int *)Addr68k_from_LADDR(base)) + index) = data;        break;      default: /* Illegal or Unimplemented */        gotoufn;    }/* end switch typenumber */  TopOfStack = data;  CurrentStackPTR -= 6;  PC++;} /*  end OP_aset2()  */E 6/***	N_OP_aset2   -- op 357   (new-value array index0 index1)   ***/D 9N_OP_aset2(data, arrayarg, index0, index1, error_addr)E 9I 9D 11N_OP_aset2(data, arrayarg, inx0, inx1, error_addr)E 9D 6int *error_addr;E 6I 6D 7int error_addr;E 7I 7int *error_addr;E 11I 11N_OP_aset2(data, arrayarg, inx0, inx1)E 11E 7E 6D 9register int index0, index1;LispPTR arrayarg;E 9I 9LispPTR arrayarg, inx0, inx1;E 9register LispPTR data;{D 10register int typenumber;E 10I 10register int type;E 10D 12register DLword *arrayblk;E 12I 12register LispArray *arrayblk;E 12register LispPTR base;register int new;D 9register int i, j;register int index;E 9I 9register int index, temp;int j;E 9      /*  verify array  */D 6      if (GetTypeNumber(arrayarg) != TYPE_ONED_ARRAY) ERROR_EXIT(error_addr);E 6I 6D 11      if (GetTypeNumber(arrayarg) != TYPE_TWOD_ARRAY) ERROR_EXIT(error_addr);E 11I 11      if (GetTypeNumber(arrayarg) != TYPE_TWOD_ARRAY) ERROR_EXIT(inx1);E 11E 6D 12      arrayblk = Addr68k_from_LADDR(arrayarg);      base = *((LispPTR *)(arrayblk));E 12I 12      arrayblk = (LispArray *)Addr68k_from_LADDR(arrayarg);      base = arrayblk->base;E 12      /*  test and setup index  */D 6      if ((0xFFFF0000 & index0) != S_POSITIVE) ERROR_EXIT(error_addr);      index0 = 0xFFFF & index0;E 6I 6D 9      if ((0xFF0000 & index0) != S_POSITIVE) ERROR_EXIT(error_addr);      index0 &= 0xFFFF;E 6      if (index0 >= *((DLword *)(arrayblk + 3))) ERROR_EXIT(error_addr);      if ((0xFFFF0000 & index1) != S_POSITIVE) ERROR_EXIT(error_addr);      index = 0xFFFF & index1;      if (index >= (j = (*((DLword *)(arrayblk + 4))))) ERROR_EXIT(error_addr);      index += (index0 * j);E 9I 9D 11      N_GetPos(inx1, temp, error_addr);      if (temp >= (j = (*((DLword *)(arrayblk + 4))))) ERROR_EXIT(error_addr);      N_GetPos(inx0, index, error_addr);      if (index >= *((DLword *)(arrayblk + 3))) ERROR_EXIT(error_addr);E 11I 11      N_GetPos(inx1, temp, inx1);D 12      if (temp >= (j = (*((DLword *)(arrayblk + 4))))) ERROR_EXIT(inx1);E 12I 12      if (temp >= (j = arrayblk->Dim1)) ERROR_EXIT(inx1);E 12      N_GetPos(inx0, index, inx1);D 12      if (index >= *((DLword *)(arrayblk + 3))) ERROR_EXIT(inx1);E 12I 12      if (index >= arrayblk->Dim0) ERROR_EXIT(inx1);E 12E 11      index *= j;      index += temp;E 9      /*  setup typenumber  */D 3      typenumber = 0xFFFF & *((DLword *)(arrayblk + 2));E 3I 3D 10      typenumber = 0xFF & *((DLword *)(arrayblk + 2));E 10I 10D 12      type = 0xFF & *((DLword *)(arrayblk + 2));E 12I 12      type = 0xFF & arrayblk->typenumber;E 12E 10E 3      /*  disp on type  */D 10    switch (typenumber) {      case 0: /* unsigned : 1 bit per element */D 9        if ((data & 0xFF0000) != S_POSITIVE) ERROR_EXIT(error_addr);         new = data & 0xFFFF;E 9I 9        N_GetPos(data, new, error_addr);E 9        if (new > 1) ERROR_EXIT(error_addr);        if (new) {          new = (1 << (7 - (index & 7)));          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) |= new;        }        else {          new = 0xFF - (1 << (7 - (index & 7)));          *(((char *)Addr68k_from_LADDR(base)) + (index >> 3)) &= new;        }        return(data);E 10I 10D 11      aset_switch(type, error_addr);E 11I 11      aset_switch(type, inx1);E 11E 10D 9        break;E 9D 10      case 3: /* unsigned : 8 bits per element */D 9        if ((data & 0xFF0000) != S_POSITIVE) ERROR_EXIT(error_addr);         new = data & 0xFFFF;E 9I 9        N_GetPos(data, new, error_addr);E 9        if (new > 0xFF) ERROR_EXIT(error_addr);        *(((char *)Addr68k_from_LADDR(base)) + index) = new;        return(data);D 9        break;E 9      case 4: /* unsigned : 16 bits per element */D 9        if ((data & 0xFF0000) != S_POSITIVE) ERROR_EXIT(error_addr);         new = data & 0xFFFF;E 9I 9        N_GetPos(data, new, error_addr);        if (new > 0xFFFF) ERROR_EXIT(error_addr);E 9        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        return(data);D 9        break;E 9      case 20: /* signed : 16 bits */I 6        new = data & 0xFFFF;E 6D 4        if ((((data & 0xFF0000) == S_POSITIVE) && ((data & 0x8000) == 0)) || (((data & 0xFF0000) == S_NEGATIVE) && ((data & 0x8000) != 0)))E 4I 4        if ((((data & 0xFF0000) == S_POSITIVE) && ((data & 0x8000) == 0)) ||D 9	    (((data & 0xFF0000) == S_NEGATIVE) && ((data & 0x8000) != 0)))E 9I 9	    (((data & 0xFF0000) == S_NEGATIVE) && (data & 0x8000)))E 9E 4        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        else ERROR_EXIT(error_addr);        return(data);D 9        break;E 9      case 22: /* signed : 32 bits */D 6        GetNumber(data, new);E 6I 6D 7        N_GetNumber(data, new, error_addr);E 7I 7D 8        N_GETNUMBER(data, new, error_addr);E 8I 8        N_GETNUMBER(data, new, doufn);E 8E 7E 6        *(((int *)Addr68k_from_LADDR(base)) + index) = new;        return(data);D 9        break;E 9      case 38: /* pointer : 32 bits */I 2D 3	ERROR_EXIT(error_addr);E 3I 3D 4	gclookup(0x8000|DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));        gclookup(0x8000|ADDREF, data);E 4I 4	GCLOOKUP(0x8000,DELREF, *(((int *)Addr68k_from_LADDR(base)) + index));        GCLOOKUP(0x8000,ADDREF, data);E 4E 3E 2        *(((int *)Addr68k_from_LADDR(base)) + index) = data;        return(data);D 9        break;E 9      case 54: /* Float : 32 bits */        if (GetTypeNumber(data) != TYPE_FLOATP) ERROR_EXIT(error_addr);D 6        *(((int *)Addr68k_from_LADDR(base)) + index) = *(int *)data;E 6I 6        *(((int *)Addr68k_from_LADDR(base)) + index) = *(int *)Addr68k_from_LADDR(data);E 6        return(data);D 9        break;E 9      case 67: /* Character :  8 bits */D 4        if (((data & 0xFF0000) != S_POSITIVE) && ((data & 0xFF0000) != S_CHARACTER)) ERROR_EXIT(error_addr);E 4I 4D 9        if (((data & 0xFF0000) != S_POSITIVE) &&	    ((data & 0xFF0000) != S_CHARACTER)) ERROR_EXIT(error_addr);E 9I 9        if ((data & 0xFFFF0000) != S_CHARACTER) ERROR_EXIT(error_addr);E 9E 4        new = data & 0xFFFF;        if (new > 0xFF) ERROR_EXIT(error_addr);        *(((char *)Addr68k_from_LADDR(base)) + index) = new;        return(data);D 9        break;E 9      case 68: /* Character :  16 bits */D 4        if (((data & 0xFF0000) != S_POSITIVE) && ((data & 0xFF0000) != S_CHARACTER)) ERROR_EXIT(error_addr); E 4I 4D 9        if (((data & 0xFF0000) != S_POSITIVE) &&	    ((data & 0xFF0000) != S_CHARACTER)) ERROR_EXIT(error_addr); E 9I 9        if ((data & 0xFFFF0000) != S_CHARACTER) ERROR_EXIT(error_addr); E 9E 4        new = data & 0xFFFF;        *(((DLword *)Addr68k_from_LADDR(base)) + index) = new;        return(data);D 9        break;E 9      case 86: /* XPointer : 32 bits */        *(((int *)Addr68k_from_LADDR(base)) + index) = data;        return(data);D 9        break;E 9      default: /* Illegal or Unimplemented */        ERROR_EXIT(error_addr);    }/* end switch typenumber */I 8E 10D 11doufn:		ERROR_EXIT(error_addr);E 11I 11doufn:		ERROR_EXIT(inx1);E 11E 8} /*  end N_OP_aset2()  */D 10        /*  end module  */E 10E 1