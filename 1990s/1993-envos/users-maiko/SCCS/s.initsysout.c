h01454s 00003/00002/00482d D 2.37 91/06/04 12:14:40 sybalsky 49 48c Change from HP port -- dyke out gethostid call.es 00001/00001/00483d D 2.36 91/01/24 22:10:09 sybalsky 48 47c Fix spelling of variable \HUNKING?es 00217/00132/00267d D 2.35 90/08/30 10:29:57 sybalsky 47 46c es 00004/00000/00395d D 2.34 90/07/04 04:00:16 sybalsky 46 45c es 00003/00000/00392d D 2.33 90/06/22 16:39:15 fuji 45 44c New compile flag NOETHERes 00025/00000/00367d D 2.32 90/06/13 23:20:14 fuji 44 43c Initialize pointer to \PUNT.BITBLT.BITMAP,\PUNTBLTSHADE.BITMAPes 00036/00010/00331d D 2.31 90/05/31 14:50:00 fuji 43 42c Takeshi: Add NEW storage futures.(various process size)es 00001/00001/00340d D 2.30 90/04/20 01:39:44 sybalsky 42 41c   shortening file names, bulk change.es 00011/00002/00330d D 2.29 90/02/16 12:00:14 takeshi 41 40c Add initislaizer for COLORes 00001/00000/00331d D 2.28 90/02/12 18:17:18 takeshi 40 39c SLOWBLTCHAR_index initializationes 00014/00003/00317d D 2.27 90/02/12 11:50:31 takeshi 39 38c add SCREENBITMAPS68k for colores 00034/00031/00286d D 2.26 90/02/06 11:47:29 sybalsky 38 37c adding commentses 00003/00001/00314d D 2.25 89/12/29 13:00:35 sybalsky 37 36c Changes from Savoires 00004/00000/00311d D 2.24 89/04/28 16:55:04 sybalsky 36 35c cd ../inces 00016/00016/00295d D 2.23 89/03/31 01:53:21 shih 35 34c removed extraneous casts to LispPTR * from calls to MakeAtom68kes 00004/00004/00307d D 2.22 89/03/20 13:37:27 shih 34 33c cosmetices 00011/00001/00300d D 2.21 89/03/16 12:08:45 sybalsky 33 32c Added byte-swapping code where appropriatees 00001/00000/00300d D 2.20 89/03/08 14:35:47 shih 32 31c devconfig problem (field needs to be cleared first)es 00000/00000/00300d D 2.19 89/03/08 14:02:37 sybalsky 31 30c [no changes]es 00001/00003/00299d D 2.18 89/03/03 04:21:45 shih 30 29c bad declarationes 00086/00160/00216d D 2.17 89/03/03 01:55:08 shih 29 28c major cleanupes 00019/00019/00357d D 2.16 89/02/27 17:24:18 shih 28 27c minor style changees 00001/00001/00375d D 2.15 89/02/14 13:36:44 snow 27 26c moved teditbltchar hack in with bltchar in initsysoutes 00011/00001/00365d D 2.14 89/01/04 18:13:43 shimizu 26 25c Gvars for soft-cursores 00004/00003/00362d D 2.13 88/12/01 14:47:17 shimizu 25 24c Change again:devconfig has proper typees 00012/00008/00353d D 2.12 88/11/01 11:28:37 bane 24 23c Made IL:USERNAME and IL:UNIX-USERNAME determine username in same wayes 00002/00002/00359d D 2.11 88/10/26 16:06:47 shimizu 23 22c IFPAGE->devconfig has proper typees 00004/00000/00357d D 2.10 88/10/17 20:02:45 shimizu 22 21c For color config.(set IFPAGE)es 00048/00047/00309d D 2.9 88/10/13 18:56:45 shih 21 20c minor cleanup (needs lispmap.h)es 00002/00000/00354d D 2.8 88/10/10 14:43:46 shimizu 20 19c  For primary tune of TEDITes 00018/00028/00336d D 2.7 88/10/10 14:07:01 krivacic 19 18c sun3/4 mergees 00005/00003/00359d D 2.6 88/10/04 14:02:46 krivacic 18 17c extra initializationes 00003/00001/00359d D 2.5 88/07/18 11:59:41 root 17 16c Allow (il:serialnumber) to return low bits of gethostid. es 00012/00000/00348d D 2.4 88/06/29 17:26:56 shimizu 16 15c Add vars for maiko.bltchares 00074/00000/00274d D 2.3 88/06/20 21:54:27 shimizu 15 14c For C keyhandleres 00004/00000/00270d D 2.2 88/06/15 10:12:47 shimizu 14 13c For MICROCODEVERSION,initialize IFPAGE->rversiones 00000/00000/00270d D 2.1 88/05/17 09:25:20 hayata 13 12c Version up to 2.1es 00001/00003/00269d D 1.12 88/05/16 15:18:09 masinter 12 11c init IFPage NS number correctlyes 00012/00007/00260d D 1.11 88/05/15 02:37:12 masinter 11 10c fix username calculation to set BCPL style stringes 00018/00000/00249d D 1.10 88/05/11 20:08:30 shimizu 10 9c For merging bitbltes 00003/00002/00246d D 1.9 88/05/04 18:12:39 masinter 9 8c new timeres 00000/00008/00248d D 1.8 88/04/29 05:05:50 masinter 8 7c new gc changeses 00019/00007/00237d D 1.7 88/04/29 00:58:20 masinter 7 6c merge tomtom's changes for Medley closure cachees 00000/00016/00244d D 1.6 88/04/22 19:14:30 krivacic 6 5c inlinedefs re-arrangementes 00017/00000/00243d D 1.5 88/03/20 16:49:11 masinter 5 4c merge new gc code for closure cachees 00002/00000/00241d D 1.4 88/03/31 10:57:52 shimizu 4 3c Add NeedHardreturnCleanup_word initializationes 00012/00000/00229d D 1.3 88/03/23 18:04:20 shimizu 3 2c Add new stuffes 00002/00002/00227d D 1.2 88/03/13 14:51:41 hayata 2 1c Add SCCS key id (%Z%)es 00229/00000/00000d D 1.1 88/02/24 16:57:37 hayata 1 0c date and time created 88/02/24 16:57:37 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 24/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 24I 24D 25/* This is G-file @(#) initsysout.c Version 2.10 (10/17/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) initsysout.c	2.10 10/17/88";E 25I 25D 29/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 29I 29D 38/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 29static char *id = "%Z% %M%	%I% %G%";E 38I 38D 39/* @(#) initsysout.c Version 2.24 (4/28/89). copyright envos & Fuji Xerox  */static char *id = "@(#) initsysout.c	2.24 4/28/89";E 39I 39/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 39E 38E 25E 24E 2D 7E 7D 11/*E 11I 11D 28/*	E 28I 28/*E 28E 11 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. */I 47/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************//************************************************************************//*									*//*		Make connections between lisp and C emulator		*//*									*//*									*//*									*//************************************************************************/E 47D 11/* *	initsysout.c *//**** 28-Aug-87 take ***//** 06 Dec. 87 take STORAGEFULLSTATE's bug **/E 11I 11#include <stdio.h>#include <string.h>I 24#include <pwd.h>E 24E 11D 42#include "machineconfig.h"E 42I 42#include "hdw_config.h"E 42#include "lispemul.h"#include "lispglobal.h"#include "lisptypes.h"#include "lispmap.h"#include "address68k.h"#include "ifpage.h"#include "iopage.h"#include "cell.h"#include "systematoms.h"I 22#include "devconfig.h"I 33#include "dbprint.h"I 44#include "lldisplay.h"E 44E 33E 22I 10D 21/********** definitions for bitblt. add by osamu**********/E 21I 21/********** definitions for bitblt. add by osamu **********/E 21D 28DLword	TEXTURE_atom; DLword	MERGE_atom; DLword	INPUT_atom; DLword	INVERT_atom; DLword	ERASE_atom; DLword	PAINT_atom; DLword	REPLACE_atom; E 28I 28DLword	TEXTURE_atom;DLword	MERGE_atom;DLword	INPUT_atom;DLword	INVERT_atom;DLword	ERASE_atom;DLword	PAINT_atom;DLword	REPLACE_atom;E 28/************ end definitions for bitblt.*****************/E 10I 47/************************************************************************//*									*//*			   i n i t _ i f p a g e			*//*									*//*	Set up the interface page:  Fill in the machine-type, the	*//*	ethernet-ID, the virtual-memory limit (32Mb or less, depending	*//*	on what the -m specified), make space for display type.		*//*									*//*									*//************************************************************************/E 47I 43#define PAGES_IN_MBYTE 2048E 43I 10E 10D 9init_ifpage()E 9I 9init_ifpage(sysout_size)	int sysout_size;E 9D 47{E 47I 47  {E 47I 14    extern long MDate;I 25    extern int DisplayType;E 25E 14D 23E 23I 23D 24    extern int DisplayType;E 24I 24D 43E 43I 43#ifdef NEW_STORAGE    extern int Storage_expanded;    int new_lastvmem ;#endifE 43E 24E 23    /*D 28      Initialize IFPAGE E 28I 28      Initialize IFPAGEE 28     */D 43E 43    InterfacePage->machinetype = KATANA;	/* 3 is katana */I 45#ifdef NOETHER#elseE 45D 12    InterfacePage->nshost0 = NSHOST0_S3;	/* Ethernet Address for sun3ai3 */    InterfacePage->nshost1 = NSHOST1_S3 ;    InterfacePage->nshost2 = NSHOST2_S3;E 12I 12    init_ifpage_ether();	/* store ethernet ID in IF page */I 45#endif NOETHERE 45E 12D 9    InterfacePage->dl24bitaddressable = T;E 9I 9D 43    InterfacePage->dl24bitaddressable = (sysout_size == 32? 0xffff : 0);E 43I 43    /*InterfacePage->dl24bitaddressable = (sysout_size == 32? 0xffff : 0);*/    InterfacePage->dl24bitaddressable = (sysout_size == 8? 0: 0xffff);#ifdef NEW_STORAGE    new_lastvmem = (sysout_size * PAGES_IN_MBYTE)-1;    if((!Storage_expanded) && (InterfacePage->dllastvmempage != new_lastvmem))     {	fprintf(stderr,"You can't expand VMEM\n");	exit(-1);     }    else     { /* Set value which will be set to \\LASTVMEMFILEPAGE in LISP */   	 InterfacePage->dllastvmempage = new_lastvmem;	/* Also you can expand lisp space even if \\STOAGEFULL was T */	*STORAGEFULL_word = NIL;     }   /* Set current process size */    InterfacePage->process_size = sysout_size ;#elseE 43E 9    InterfacePage->dllastvmempage = LASTVMEMPAGE;I 43#endif NEW_STORAGEE 43I 11D 17    E 17I 17    /* unfortunately, Lisp only looks at a 16 bit serial number */D 49    InterfacePage->serialnumber = 0xffff & gethostid();D 28 E 28I 28E 49I 49#ifndef HPUX	InterfacePage->serialnumber = 0xffff & gethostid();#endif HPUXE 49E 28E 17D 34    /* get user name and stuff into vmem; this is the VMEM buffer ;E 34I 34    /* get user name and stuff into vmem; this is the VMEM buffer;E 34    This is a BCPL string -- it starts with a length count. C strings    are null terminated instead */D 24    {char *s;    s = (char*)Addr68k_from_LADDR(0155001);    cuserid(s+1);    *s = (char)strlen(s+1);E 24I 24    {struct passwd *pwd;     char *s = (char*)Addr68k_from_LADDR(0155001);	/* try getpwuid first; use cuserid if it fails */	if((pwd = getpwuid(getuid())) == NULL) cuserid(s+1);	else strcpy(s+1, pwd->pw_name);D 29    	*s = (char)strlen(s+1);E 29I 29	*s = (char)strlen(s+1);E 29E 24    }I 24D 28		E 28I 28E 28E 24I 14     /* sec from Oct-13-87 12:00  It's My birthday(take) */     /* MDate may be set by makefile(by makevdate.c) */    InterfacePage->rversion = (MDate - 561150000)/ (60*60*24);I 22    /* For DisplayType ,I couldn't insert this line into init_display */I 32   InterfacePage->devconfig &= 0xff87;E 32D 23   InterfacePage->devconfig |= SUN2BW;E 23I 23D 24   InterfacePage->devconfig |= DisplayType;E 24I 24D 25   InterfacePage->devconfig |= SUN2BW;E 25I 25   InterfacePage->devconfig |= DisplayType;E 25E 24E 23E 22E 14E 11D 47}E 47I 47  }E 47I 47/************************************************************************//*									*//*			    i n i t _ i o p a g e			*//*									*//*	Clean up the IO page:  Set the keyboard map to "all keys up."	*//*									*//************************************************************************/E 47init_iopage(){    /*D 28     * Initialize IOPAGE E 28I 28     * Initialize IOPAGEE 28     */    IOPage->dlkbdad0 = 65535;	/* ALL UP */    IOPage->dlkbdad1 = 65535;	/* ALL UP */    IOPage->dlkbdad2 = 65535;	/* ALL UP */    IOPage->dlkbdad3 = 65535;	/* ALL UP */    IOPage->dlkbdad4 = 65535;	/* ALL UP */    IOPage->dlkbdad5 = 65535;	/* ALL UP */I 29D 30extern (LispPTR *) MakeAtom68k();E 30E 29    IOPage->dlutilin = 65535;	/* ALL UP */ }I 47/************************************************************************//*									*//*			b u i l d _ l i s p _ m a p			*//*									*//*	Create the atom-pointers used by C to deal with the lisp	*//*	SYSOUT.								*//*									*//************************************************************************/E 47I 19extern int for_makeinit;I 29D 30extern (LispPTR *) MakeAtom68k();E 30I 30extern LispPTR *MakeAtom68k();E 30E 29E 19build_lisp_map()D 47{   DLword index;E 47I 47  {    DLword index;E 47D 19    Atomspace = (DLword *) Addr68k_from_LADDR(ATOMS_OFFSET);E 19    Stackspace = (DLword *) Addr68k_from_LADDR(STK_OFFSET);    Plistspace = (DLword *) Addr68k_from_LADDR(PLIS_OFFSET);D 21    DTDspace = (DLword *) Addr68k_from_LADDR(DTD_OFFSET);E 21I 21    DTDspace   = (DLword *) Addr68k_from_LADDR(DTD_OFFSET);E 21    MDStypetbl = (DLword *) Addr68k_from_LADDR(MDS_OFFSET);D 21    AtomHT = (DLword *) Addr68k_from_LADDR(ATMHT_OFFSET);E 21I 21    AtomHT     = (DLword *) Addr68k_from_LADDR(ATMHT_OFFSET);E 21    Pnamespace = (DLword *) Addr68k_from_LADDR(PNP_OFFSET);D 21    Defspace = (DLword *) Addr68k_from_LADDR(DEFS_OFFSET);    Valspace = (DLword *) Addr68k_from_LADDR(VALS_OFFSET);E 21I 21    Defspace   = (DLword *) Addr68k_from_LADDR(DEFS_OFFSET);    Valspace   = (DLword *) Addr68k_from_LADDR(VALS_OFFSET);E 21D 19    Spospspace = (unsigned short *) Addr68k_from_LADDR(S_POSITIVE);    Snegspace = (DLword *) Addr68k_from_LADDR(S_NEGATIVE);E 19I 33    DBPRINT(("Stackspace = 0x%x.\n", Stackspace));    DBPRINT(("AtomHT = 0x%x.\n", AtomHT));E 33D 33	ListpDTD = (struct dtd *)GetDTD(TYPE_LISTP) ;E 33I 33D 34    ListpDTD = (struct dtd *)GetDTD(TYPE_LISTP) ;E 34I 34    ListpDTD = (struct dtd *)GetDTD(TYPE_LISTP);E 34E 33D 21    FPtoVP = (DLword *) Addr68k_from_LADDR(FPTOVP_OFFSET);D 19    PAGEMap = (DLword *) Addr68k_from_LADDR(PAGEMAP_OFFSET);    PageMapTBL = (DLword *) Addr68k_from_LADDR(PAGEMAPTBL_OFFSET);    LockedPageTable = (DLword *) Addr68k_from_LADDR(LOCKEDPAGETBL_OFFSET);    IOCBPage = (DLword *) Addr68k_from_LADDR(IOCBPAGE_OFFSET);E 19    IOPage = (IOPAGE *) Addr68k_from_LADDR(IOPAGE_OFFSET);E 21I 21    FPtoVP        = (DLword *) Addr68k_from_LADDR(FPTOVP_OFFSET);    IOPage        = (IOPAGE *) Addr68k_from_LADDR(IOPAGE_OFFSET);E 21    InterfacePage = (IFPAGE *) Addr68k_from_LADDR(IFPAGE_OFFSET);D 21    MiscStats = (MISCSTATS *) Addr68k_from_LADDR(MISCSTATS_OFFSET);E 21I 21    MiscStats  = (MISCSTATS *) Addr68k_from_LADDR(MISCSTATS_OFFSET);E 21D 21    UFNTable = (DLword *) Addr68k_from_LADDR(UFNTBL_OFFSET);    DisplayRegion = (DLword *) Addr68k_from_LADDR(DISPALY_OFFSET);E 21I 21    UFNTable      = (DLword *) Addr68k_from_LADDR(UFNTBL_OFFSET);    DisplayRegion = (DLword *) Addr68k_from_LADDR(DISPLAY_OFFSET);E 21D 21    HTmain = (DLword *) Addr68k_from_LADDR(HTMAIN_OFFSET);E 21I 21    HTmain     = (DLword *) Addr68k_from_LADDR(HTMAIN_OFFSET);E 21    HToverflow = (DLword *) Addr68k_from_LADDR(HTOVERFLOW_OFFSET);    HTbigcount = (DLword *) Addr68k_from_LADDR(HTBIG_OFFSET);D 21    HTcoll = (DLword *) Addr68k_from_LADDR(HTCOLL_OFFSET);E 21I 21    HTcoll     = (DLword *) Addr68k_from_LADDR(HTCOLL_OFFSET);E 21D 19    Arrayspace = (DLword *) Addr68k_from_LADDR(ARRAY_OFFSET);    MDS_space_bottom = (DLword *) Addr68k_from_LADDR(MDS_BOTTOM_OFFSET);E 19/**** cache values *****/D 29   index = make_atom("\\NxtMDSPage",0,11,0);   Next_MDSpage_word  =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET+(index<<1));E 29I 29D 47   Next_MDSpage_word         = MakeAtom68k("\\NxtMDSPage");   Next_Array_word           = MakeAtom68k("\\NxtArrayPage");   MDS_free_page_word        = MakeAtom68k("\\MDSFREELISTPAGE");   Reclaim_cnt_word          = MakeAtom68k("\\RECLAIM.COUNTDOWN");E 47I 47    Next_MDSpage_word         = MakeAtom68k("\\NxtMDSPage");    Next_Array_word           = MakeAtom68k("\\NxtArrayPage");    MDS_free_page_word        = MakeAtom68k("\\MDSFREELISTPAGE");    Reclaim_cnt_word          = MakeAtom68k("\\RECLAIM.COUNTDOWN");E 47E 29D 29   index = make_atom("\\NxtArrayPage",0,13,0);   Next_Array_word =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET+(index<<1));   index = make_atom("\\MDSFREELISTPAGE",0,16,0);   MDS_free_page_word =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET+(index <<1));   index = make_atom("\\RECLAIM.COUNTDOWN",0,18,0);   Reclaim_cnt_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index <<1));E 29D 21   /*** cashe values for gcreclaimer : added by T. Teruuchi 30-Sep-1987 ***/E 21I 21   /*** cache values for gcreclaimer : added by T. Teruuchi 30-Sep-1987 ***/E 21D 29   index = make_atom("\\GCDISABLED",0,11,0);   GcDisabled_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 29I 29D 47   GcDisabled_word           = MakeAtom68k("\\GCDISABLED");E 47I 47    GcDisabled_word           = MakeAtom68k("\\GCDISABLED");E 47I 33E 33E 29D 19   index = make_atom("CDRCODING",0,9,0);   CdrCoding_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 19D 21    /*** following cache values are the solution for array reclaimer ***/E 21I 21   /*** following cache values are the solution for array reclaimer ***/E 21D 29   index = make_atom("\\FREEBLOCKBUCKETS",0,17,0);   FreeBlockBuckets_word = (LispPTR *)Addr68k_from_LADDR(					VALS_OFFSET + (index << 1));E 29I 29D 47   FreeBlockBuckets_word     = MakeAtom68k("\\FREEBLOCKBUCKETS");   Array_Block_Checking_word = MakeAtom68k("ARRAYBLOCKCHECKING");   ArrayMerging_word         = MakeAtom68k("\\ARRAYMERGING");   ArraySpace_word           = MakeAtom68k("\\ARRAYSPACE");   ArraySpace2_word          = MakeAtom68k("\\ARRAYSPACE2");   ArrayFrLst_word           = MakeAtom68k("\\ArrayFrLst");   ArrayFrLst2_word          = MakeAtom68k("\\ArrayFrLst2");   Hunk_word                 = MakeAtom68k("\\HUNKING\?");   System_Buffer_List_word   = MakeAtom68k("SYSTEMBUFFERLIST");E 47I 47    FreeBlockBuckets_word     = MakeAtom68k("\\FREEBLOCKBUCKETS");    Array_Block_Checking_word = MakeAtom68k("ARRAYBLOCKCHECKING");    ArrayMerging_word         = MakeAtom68k("\\ARRAYMERGING");    ArraySpace_word           = MakeAtom68k("\\ARRAYSPACE");    ArraySpace2_word          = MakeAtom68k("\\ARRAYSPACE2");    ArrayFrLst_word           = MakeAtom68k("\\ArrayFrLst");    ArrayFrLst2_word          = MakeAtom68k("\\ArrayFrLst2");D 48    Hunk_word                 = MakeAtom68k("\\HUNKING\?");E 48I 48    Hunk_word                 = MakeAtom68k("\\HUNKING?");E 48    System_Buffer_List_word   = MakeAtom68k("SYSTEMBUFFERLIST");E 47E 29D 29   index = make_atom("ARRAYBLOCKCHECKING",0,18,0);   Array_Block_Checking_word = (LispPTR *)Addr68k_from_LADDR(					VALS_OFFSET + (index << 1));   index = make_atom("\\ARRAYMERGING",0,13,0);   ArrayMerging_word = (LispPTR *)Addr68k_from_LADDR(					VALS_OFFSET + (index << 1));   index = make_atom("\\ARRAYSPACE",0,11,0);   ArraySpace_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("\\ARRAYSPACE2",0,12,0);   ArraySpace2_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("\\ArrayFrLst",0,11,0);   ArrayFrLst_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("\\ArrayFrLst2",0,12,0);   ArrayFrLst2_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));D 28   E 28I 28E 28   index = make_atom("\\HUNKING\?",0,9,0);   Hunk_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("SYSTEMBUFFERLIST",0,16,0);   System_Buffer_List_word = (LispPTR *)Addr68k_from_LADDR(					VALS_OFFSET + (index << 1));E 29D 47   /*** The addition of cache values is over. by Tomtom 30-Sep-1987 ***/E 47D 21   /*** The following cashe values are for the top level reclaimer ***/E 21I 21   /*** The following cache values are for the top level reclaimer ***/E 21D 29   index = make_atom("GCMESS",0,6,0);   GcMess_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 29I 29D 47   GcMess_word               = MakeAtom68k("GCMESS");   ReclaimMin_word           = MakeAtom68k("\\RECLAIMMIN");E 47I 47    GcMess_word               = MakeAtom68k("GCMESS");    ReclaimMin_word           = MakeAtom68k("\\RECLAIMMIN");E 47E 29D 29   index = make_atom("\\RECLAIMMIN",0,11,0);   ReclaimMin_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +							(index << 1));E 29D 19   index = make_atom("\\GCTIME1",0,8,0);   GcTime1_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("\\GCTIME2",0,8,0);   GcTime2_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("\\MaxTypeNumber",0,14,0);   MaxTypeNumber_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +							(index << 1));D 6   /*** The addition of cashe values is over. by Tomtom 15-Oct-1987 ***/   /*** The following cashe values are for the code reclaimer ***/   index = make_atom("\\OPCODEARRAY",0,12,0);   OpCode_Array_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET 							+ (index << 1));   index = make_atom("\\OPCODES",0,8,0);   OpCodes_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));      Dopcode_index = (LispPTR)make_atom("DOPCODE",0,7,0);						/*** 23-Oct-1987 added ***/   /*** The addtion of cash values is over. by Tomtom 9-Oct-1987 ***/    /*** The addition of cashe values for GCClock by Tomtom 26-Oct-1987 ***/E 6E 19D 8   index = make_atom("\\RCLKSECOND",0,11,0);   RclkSecond_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +							 (index << 1));   index = make_atom("\\RCLKMILLISECOND",0,16,0);   RclkMilliSecond_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index							<< 1));I 5E 8D 7   /*** The following caches are for medley version 14-April-1988 Tomtom ***/   /*** the following sequences are temporary strategy. 15-April-1988 ** */      index = 1828;E 7I 7D 47   /*** The following caches are for medley version April-28,1988 Tomtom ***/E 47I 47   /*** The following caches are for Symbol lookup April-28,1988 Tomtom ***/E 47D 28 E 28I 28E 28D 29   index = make_atom("*PACKAGE-FROM-INDEX*",0,20,0);   Package_from_Index_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +						(index << 1));E 29I 29D 47   Package_from_Index_word   = MakeAtom68k("*PACKAGE-FROM-INDEX*");   Package_from_Name_word    = MakeAtom68k("*PACKAGE-FROM-NAME*");   Keyword_Package_word      = MakeAtom68k("*KEYWORD-PACKAGE*");E 47I 47    Package_from_Index_word   = MakeAtom68k("*PACKAGE-FROM-INDEX*");    Package_from_Name_word    = MakeAtom68k("*PACKAGE-FROM-NAME*");    Keyword_Package_word      = MakeAtom68k("*KEYWORD-PACKAGE*");E 47I 33    DBPRINT(("Package_from_Index_word = 0x%x.\n", Package_from_Index_word));D 34    DBPRINT(("Package_from_Name_word = 0x%x.\n", Package_from_Name_word));E 34I 34    DBPRINT(("Package_from_Name_word  = 0x%x.\n", Package_from_Name_word));E 34E 33E 29I 36    /*** The following atom-index cache is for CL:VALUES opcode JDS 4/5/89 ***/D 38   MVLIST_index = get_package_atom("\\MVLIST", 7, "INTERLISP", 9, NIL);E 38I 38D 47   MVLIST_index = MAKEATOM("\\MVLIST");E 47I 47    MVLIST_index = MAKEATOM("\\MVLIST");E 47E 38I 47    /* * * Atoms for closure-cache interface * * */E 47E 36I 33E 33D 29   index = make_atom("*PACKAGE-FROM-NAME*",0,19,0);   Package_from_Name_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +						(index << 1));   index = make_atom("*KEYWORD-PACKAGE*",0,17,0);   Keyword_Package_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +						(index << 1));D 28	E 28I 28E 29E 28I 19D 47 if (for_makeinit) {D 21   Closure_Cache_Enabled_word = (LispPTR *)malloc(4);E 21I 21    Closure_Cache_Enabled_word = (LispPTR *)malloc(4);E 21   *Closure_Cache_Enabled_word = NIL;E 47I 47    if (for_makeinit)      {	Closure_Cache_Enabled_word = (LispPTR *)malloc(4);	*Closure_Cache_Enabled_word = NIL;E 47D 21   Closure_Cache_word = (LispPTR *)malloc(4);E 21I 21D 47    Closure_Cache_word = (LispPTR *)malloc(4);E 21   *Closure_Cache_word = NIL;E 47I 47	Closure_Cache_word = (LispPTR *)malloc(4);	*Closure_Cache_word = NIL;E 47D 21   Deleted_Implicit_Hash_Slot_word = (LispPTR *)malloc(4);E 21I 21D 47    Deleted_Implicit_Hash_Slot_word = (LispPTR *)malloc(4);E 21   *Deleted_Implicit_Hash_Slot_word = NIL;}else {I 33    DBPRINT(("%d %d %d %d %d", Stackspace, Plistspace, DTDspace, MDStypetbl, AtomHT));E 47I 47	Deleted_Implicit_Hash_Slot_word = (LispPTR *)malloc(4);	*Deleted_Implicit_Hash_Slot_word = NIL;      }    else       {	DBPRINT(("%d %d %d %d %d", Stackspace, 				   Plistspace, DTDspace, MDStypetbl, AtomHT));E 47E 33E 19D 47   index = get_package_atom("*CLOSURE-CACHE-ENABLED*", 23, "SI", 2, NIL);E 7   Closure_Cache_Enabled_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +E 47I 47	index = get_package_atom("*CLOSURE-CACHE-ENABLED*", 23, "SI", 2, NIL);	Closure_Cache_Enabled_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +E 47						(index << 1));D 7   index = 3604;       /* old index is 3603; */E 7I 7D 47   index = get_package_atom("*CLOSURE-CACHE*", 15, "SI", 2, NIL);E 7   Closure_Cache_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +E 47I 47	index = get_package_atom("*CLOSURE-CACHE*", 15, "SI", 2, NIL);	Closure_Cache_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +E 47						(index << 1));D 7   index = 25924;      /* old index is 25843; */E 7I 7D 47   index = get_package_atom("*DELETED-IMPLICIT-HASH-SLOT*", 28, "XCL", 3,NIL);E 7   Deleted_Implicit_Hash_Slot_word = (LispPTR *)Addr68k_from_LADDR(E 47I 47	index = get_package_atom("*DELETED-IMPLICIT-HASH-SLOT*", 28, "XCL", 3,NIL);	Deleted_Implicit_Hash_Slot_word = (LispPTR *)Addr68k_from_LADDR(E 47		VALS_OFFSET + (index << 1));I 7D 19   index = get_package_atom("FIRST", 5, "KEYWORD", 7, T);   First_index = index;E 19I 19D 47}E 47I 47      }E 47E 19E 7D 19   /*** The above cache values are for closure-caching in Medley ***/E 5 /*** THE following CACHE values are added by Take. ***/E 19I 19D 47/*** The above cache values are for closure-caching in Medley ***/E 47/*** THE following CACHE values are added by Take. ***/E 19D 29    STORAGEFULLSTATE_index = make_atom("\\STORAGEFULLSTATE",0,17,0);D 21    STORAGEFULLSTATE_word= (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + ( STORAGEFULLSTATE_index << 1));E 21I 21    STORAGEFULLSTATE_word= (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +				( STORAGEFULLSTATE_index << 1));E 29I 29D 47   STORAGEFULLSTATE_index = MAKEATOM("\\STORAGEFULLSTATE");E 47I 47    STORAGEFULLSTATE_index = MAKEATOM("\\STORAGEFULLSTATE");E 47E 29E 21D 29   index = make_atom("\\STORAGEFULL",0,12,0);   STORAGEFULL_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 29I 29D 47   STORAGEFULLSTATE_word     = MakeAtom68k("\\STORAGEFULLSTATE");   STORAGEFULL_word          = MakeAtom68k("\\STORAGEFULL");   PENDINGINTERRUPT_word     = MakeAtom68k("\\PENDINGINTERRUPT");   LeastMDSPage_word         = MakeAtom68k("\\LeastMDSPage");   SecondMDSPage_word        = MakeAtom68k("\\SecondMDSPage");   SecondArrayPage_word      = MakeAtom68k("\\SecondArrayPage");   INTERRUPTSTATE_word       = MakeAtom68k("\\INTERRUPTSTATE");   SYSTEMCACHEVARS_word      = MakeAtom68k("\\SYSTEMCACHEVARS");   MACHINETYPE_word          = MakeAtom68k("\\MACHINETYPE");   LASTVMEMFILEPAGE_word     = MakeAtom68k("\\LASTVMEMFILEPAGE");   VMEM_FULL_STATE_word      = MakeAtom68k("\\VMEM.FULL.STATE");E 47I 47    STORAGEFULLSTATE_word     = MakeAtom68k("\\STORAGEFULLSTATE");    STORAGEFULL_word          = MakeAtom68k("\\STORAGEFULL");    PENDINGINTERRUPT_word     = MakeAtom68k("\\PENDINGINTERRUPT");    LeastMDSPage_word         = MakeAtom68k("\\LeastMDSPage");    SecondMDSPage_word        = MakeAtom68k("\\SecondMDSPage");    SecondArrayPage_word      = MakeAtom68k("\\SecondArrayPage");    INTERRUPTSTATE_word       = MakeAtom68k("\\INTERRUPTSTATE");    SYSTEMCACHEVARS_word      = MakeAtom68k("\\SYSTEMCACHEVARS");    MACHINETYPE_word          = MakeAtom68k("\\MACHINETYPE");    LASTVMEMFILEPAGE_word     = MakeAtom68k("\\LASTVMEMFILEPAGE");    VMEM_FULL_STATE_word      = MakeAtom68k("\\VMEM.FULL.STATE");E 47E 29D 29   index = make_atom("\\PENDINGINTERRUPT",0,17,0);   PENDINGINTERRUPT_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 29I 29 /*** The following are STK-OVER-FLOW stuff * Take **/D 47  STACKOVERFLOW_word         = MakeAtom68k("\\STACKOVERFLOW");  GuardStackAddr_word        = MakeAtom68k("\\GuardStackAddr");  LastStackAddr_word         = MakeAtom68k("\\LastStackAddr");  NeedHardreturnCleanup_word = MakeAtom68k("\\NEED.HARDRESET.CLEANUP");E 47I 47    STACKOVERFLOW_word         = MakeAtom68k("\\STACKOVERFLOW");    GuardStackAddr_word        = MakeAtom68k("\\GuardStackAddr");    LastStackAddr_word         = MakeAtom68k("\\LastStackAddr");    NeedHardreturnCleanup_word = MakeAtom68k("\\NEED.HARDRESET.CLEANUP");E 47E 29D 29   index = make_atom("\\LeastMDSPage",0,13,0);   LeastMDSPage_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("\\SecondMDSPage",0,14,0);   SecondMDSPage_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("\\SecondArrayPage",0,16,0);   SecondArrayPage_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("\\INTERRUPTSTATE",0,15,0);   INTERRUPTSTATE_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("\\SYSTEMCACHEVARS",0,16,0);   SYSTEMCACHEVARS_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("\\MACHINETYPE",0,12,0);   MACHINETYPE_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("\\LASTVMEMFILEPAGE",0,17,0);   LASTVMEMFILEPAGE_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("\\VMEM.FULL.STATE",0,16,0);   VMEM_FULL_STATE_word = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));I 3 /*** The followinfs are STK-OVER-FLOW staff * Take **/  index = make_atom("\\STACKOVERFLOW",0,14,0);  STACKOVERFLOW_word=(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));D 21   index = make_atom("\\GuardStackAddr",0,15,0);E 21I 21  index = make_atom("\\GuardStackAddr",0,15,0);E 21  GuardStackAddr_word=(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));D 21    index = make_atom("\\LastStackAddr",0,14,0);E 21I 21  index = make_atom("\\LastStackAddr",0,14,0);E 21  LastStackAddr_word=(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));I 4D 21    index = make_atom("\\NEED.HARDRESET.CLEANUP",0,23,0);E 21I 21  index = make_atom("\\NEED.HARDRESET.CLEANUP",0,23,0);E 21  NeedHardreturnCleanup_word=(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 29I 18D 19E 19E 18I 10D 21  /*** The addition of cashe values for Bitblt by osamu April 13, 1988 ***/E 21I 21  /*** The addition of cache values for Bitblt by osamu April 13, 1988 ***/E 21D 29  TEXTURE_atom = make_atom("TEXTURE",0,7,0);D 21  MERGE_atom = make_atom("MERGE",0,5,0);  INPUT_atom = make_atom("INPUT",0,5,0);  INVERT_atom = make_atom("INVERT",0,6,0);  ERASE_atom = make_atom("ERASE",0,5,0);  PAINT_atom = make_atom("PAINT",0,5,0);E 21I 21  MERGE_atom   = make_atom("MERGE",0,5,0);  INPUT_atom   = make_atom("INPUT",0,5,0);  INVERT_atom  = make_atom("INVERT",0,6,0);  ERASE_atom   = make_atom("ERASE",0,5,0);  PAINT_atom   = make_atom("PAINT",0,5,0);E 21  REPLACE_atom = make_atom("REPLACE",0,7,0);E 29I 29D 47  TEXTURE_atom = MAKEATOM("TEXTURE");  MERGE_atom   = MAKEATOM("MERGE");  INPUT_atom   = MAKEATOM("INPUT");  INVERT_atom  = MAKEATOM("INVERT");  ERASE_atom   = MAKEATOM("ERASE");  PAINT_atom   = MAKEATOM("PAINT");  REPLACE_atom = MAKEATOM("REPLACE");E 47I 47    TEXTURE_atom = MAKEATOM("TEXTURE");    MERGE_atom   = MAKEATOM("MERGE");    INPUT_atom   = MAKEATOM("INPUT");    INVERT_atom  = MAKEATOM("INVERT");    ERASE_atom   = MAKEATOM("ERASE");    PAINT_atom   = MAKEATOM("PAINT");    REPLACE_atom = MAKEATOM("REPLACE");E 47E 29E 10E 4I 15D 47 /*** temp **/ init_for_keyhandle();I 16 init_for_bltchar();I 44 init_for_bitblt();E 47E 44E 16D 47}/****************/E 47I 47    /*** Do initialization for specific devices ***/    init_for_keyhandle();	/* keyboard-interrupt handler */    init_for_bltchar();		/* BLTCHAR speed-up */    init_for_bitblt();		/* BITBLT-to-display speed-up */E 47I 29I 47  }E 47I 47/************************************************************************//*									*//*		    i n i t _ f o r _ k e y h a n d l e			*//*									*//*									*//*									*//************************************************************************/E 47E 29D 38init_for_keyhandle(){D 29 LispPTR index;E 29D 18 extern DLword *CTopKeyevent ; extern LispPTR *KEYBOARDEVENTQUEUE68k; extern LispPTR *KEYBUFFERING68k;E 18I 18D 34extern DLword *CTopKeyevent ;E 34I 34extern DLword *CTopKeyevent;E 34extern LispPTR *KEYBOARDEVENTQUEUE68k;extern LispPTR *KEYBUFFERING68k;E 18extern LispPTR DOBUFFEREDTRANSITION_index;extern LispPTR INTERRUPTFRAME_index;extern LispPTR *TIMER_INTERRUPT_PENDING68k;extern LispPTR *PENDINGINTERRUPT68k;extern LispPTR *MOUSECHORDTICKS68k;D 21extern  LispPTR *LASTUSERACTION68k;E 21I 21extern LispPTR *LASTUSERACTION68k;E 21extern LispPTR ATOM_STARTED;extern LispPTR *CLastUserActionCell68k;E 38I 38init_for_keyhandle()  {    DLword index;    extern DLword *CTopKeyevent;    extern LispPTR *KEYBOARDEVENTQUEUE68k;    extern LispPTR *KEYBUFFERING68k;    extern LispPTR DOBUFFEREDTRANSITION_index;    extern LispPTR INTERRUPTFRAME_index;    extern LispPTR *TIMER_INTERRUPT_PENDING68k;    extern LispPTR *PENDINGINTERRUPT68k;    extern LispPTR *MOUSECHORDTICKS68k;    extern LispPTR *LASTUSERACTION68k;    extern LispPTR ATOM_STARTED;    extern LispPTR *CLastUserActionCell68k;E 38D 38extern LispPTR *CURSORDESTHEIGHT68k;extern LispPTR *CURSORDESTWIDTH68k;E 38I 38    extern LispPTR *CURSORDESTHEIGHT68k;    extern LispPTR *CURSORDESTWIDTH68k;E 38D 38extern LispPTR *CURSORHOTSPOTX68k;extern LispPTR *CURSORHOTSPOTY68k;extern LispPTR *SOFTCURSORUPP68k;I 26D 29extern LispPTR	*SOFTCURSORWIDTH68k;extern LispPTR	*SOFTCURSORHEIGHT68k;extern LispPTR	*CURRENTCURSOR68k;E 29I 29extern LispPTR *SOFTCURSORWIDTH68k;extern LispPTR *SOFTCURSORHEIGHT68k;extern LispPTR *CURRENTCURSOR68k;E 38I 38    extern LispPTR *CURSORHOTSPOTX68k;    extern LispPTR *CURSORHOTSPOTY68k;    extern LispPTR *SOFTCURSORUPP68k;    extern LispPTR *SOFTCURSORWIDTH68k;    extern LispPTR *SOFTCURSORHEIGHT68k;    extern LispPTR *CURRENTCURSOR68k;E 38E 29E 26I 26E 26D 38extern LispPTR *PERIODIC_INTERRUPT68k;extern LispPTR *PERIODIC_INTERRUPT_FREQUENCY68k;extern LispPTR PERIODIC_INTERRUPTFRAME_index;extern LispPTR DORECLAIM_index;I 37extern LispPTR *IOINTERRUPTFLAGS_word;E 38I 38    extern LispPTR *PERIODIC_INTERRUPT68k;    extern LispPTR *PERIODIC_INTERRUPT_FREQUENCY68k;    extern LispPTR PERIODIC_INTERRUPTFRAME_index;    extern LispPTR DORECLAIM_index;    extern LispPTR *IOINTERRUPTFLAGS_word;E 38E 37I 18E 18D 37E 37D 29  index = MAKEATOM("\\CURSORDESTHEIGHT");D 21   CURSORDESTHEIGHT68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 21I 21  CURSORDESTHEIGHT68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 21  index = MAKEATOM("\\CURSORDESTWIDTH");D 21   CURSORDESTWIDTH68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 21I 21  CURSORDESTWIDTH68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 21  index = MAKEATOM("\\CURSORHOTSPOTX");  CURSORHOTSPOTX68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));  index = MAKEATOM("\\CURSORHOTSPOTY");  CURSORHOTSPOTY68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 29I 29D 35  CURSORDESTHEIGHT68k   = (LispPTR *) MakeAtom68k("\\CURSORDESTHEIGHT");  CURSORDESTWIDTH68k    = (LispPTR *) MakeAtom68k("\\CURSORDESTWIDTH");  CURSORHOTSPOTX68k     = (LispPTR *) MakeAtom68k("\\CURSORHOTSPOTX");  CURSORHOTSPOTY68k     = (LispPTR *) MakeAtom68k("\\CURSORHOTSPOTY");E 35I 35D 47  CURSORDESTHEIGHT68k   = MakeAtom68k("\\CURSORDESTHEIGHT");  CURSORDESTWIDTH68k    = MakeAtom68k("\\CURSORDESTWIDTH");  CURSORHOTSPOTX68k     = MakeAtom68k("\\CURSORHOTSPOTX");  CURSORHOTSPOTY68k     = MakeAtom68k("\\CURSORHOTSPOTY");E 47I 47    CURSORDESTHEIGHT68k   = MakeAtom68k("\\CURSORDESTHEIGHT");    CURSORDESTWIDTH68k    = MakeAtom68k("\\CURSORDESTWIDTH");    CURSORHOTSPOTX68k     = MakeAtom68k("\\CURSORHOTSPOTX");    CURSORHOTSPOTY68k     = MakeAtom68k("\\CURSORHOTSPOTY");E 47E 35E 29D 29  index = MAKEATOM("\\SOFTCURSORUPP");  SOFTCURSORUPP68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));I 26  index = MAKEATOM("\\SOFTCURSORWIDTH");  SOFTCURSORWIDTH68k = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));  index = MAKEATOM("\\SOFTCURSORHEIGHT");  SOFTCURSORHEIGHT68k = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));  index = MAKEATOM("\\CURRENTCURSOR");  CURRENTCURSOR68k = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 29I 29D 35  SOFTCURSORUPP68k      = (LispPTR *) MakeAtom68k("\\SOFTCURSORUPP");  SOFTCURSORWIDTH68k    = (LispPTR *) MakeAtom68k("\\SOFTCURSORWIDTH");  SOFTCURSORHEIGHT68k   = (LispPTR *) MakeAtom68k("\\SOFTCURSORHEIGHT");  CURRENTCURSOR68k      = (LispPTR *) MakeAtom68k("\\CURRENTCURSOR");E 35I 35D 47  SOFTCURSORUPP68k      = MakeAtom68k("\\SOFTCURSORUPP");  SOFTCURSORWIDTH68k    = MakeAtom68k("\\SOFTCURSORWIDTH");  SOFTCURSORHEIGHT68k   = MakeAtom68k("\\SOFTCURSORHEIGHT");  CURRENTCURSOR68k      = MakeAtom68k("\\CURRENTCURSOR");E 47I 47    SOFTCURSORUPP68k      = MakeAtom68k("\\SOFTCURSORUPP");    SOFTCURSORWIDTH68k    = MakeAtom68k("\\SOFTCURSORWIDTH");    SOFTCURSORHEIGHT68k   = MakeAtom68k("\\SOFTCURSORHEIGHT");    CURRENTCURSOR68k      = MakeAtom68k("\\CURRENTCURSOR");E 47E 35E 29E 26D 26E 26D 21   ATOM_STARTED= make_atom("STARTED",0,7,0);E 21I 21D 29  ATOM_STARTED= make_atom("STARTED",0,7,0);E 29I 29D 47  ATOM_STARTED= MAKEATOM("STARTED");E 47I 47    ATOM_STARTED= MAKEATOM("STARTED");E 47E 29E 21D 21   index = make_atom("\\KEYBOARDEVENTQUEUE",0,19,0);   KEYBOARDEVENTQUEUE68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   index = make_atom("\\KEYBUFFERING",0,13,0);   KEYBUFFERING68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 21I 21D 29  index = make_atom("\\KEYBOARDEVENTQUEUE",0,19,0);  KEYBOARDEVENTQUEUE68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));  index = make_atom("\\KEYBUFFERING",0,13,0);  KEYBUFFERING68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 29I 29D 35  KEYBOARDEVENTQUEUE68k = (LispPTR *) MakeAtom68k("\\KEYBOARDEVENTQUEUE");  KEYBUFFERING68k       = (LispPTR *) MakeAtom68k("\\KEYBUFFERING");E 35I 35D 47  KEYBOARDEVENTQUEUE68k = MakeAtom68k("\\KEYBOARDEVENTQUEUE");  KEYBUFFERING68k       = MakeAtom68k("\\KEYBUFFERING");E 47I 47    KEYBOARDEVENTQUEUE68k = MakeAtom68k("\\KEYBOARDEVENTQUEUE");    KEYBUFFERING68k       = MakeAtom68k("\\KEYBUFFERING");E 47E 35E 29E 21D 21   index = make_atom("\\PENDINGINTERRUPT",0,17,0);   PENDINGINTERRUPT68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 21I 21D 29  index = make_atom("\\PENDINGINTERRUPT",0,17,0);  PENDINGINTERRUPT68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 29I 29D 35  PENDINGINTERRUPT68k   = (LispPTR *) MakeAtom68k("\\PENDINGINTERRUPT");  MOUSECHORDTICKS68k    = (LispPTR *) MakeAtom68k("\\MOUSECHORDTICKS");  LASTUSERACTION68k     = (LispPTR *) MakeAtom68k("\\LASTUSERACTION");E 35I 35D 47  PENDINGINTERRUPT68k   = MakeAtom68k("\\PENDINGINTERRUPT");  MOUSECHORDTICKS68k    = MakeAtom68k("\\MOUSECHORDTICKS");  LASTUSERACTION68k     = MakeAtom68k("\\LASTUSERACTION");E 47I 47    PENDINGINTERRUPT68k   = MakeAtom68k("\\PENDINGINTERRUPT");    MOUSECHORDTICKS68k    = MakeAtom68k("\\MOUSECHORDTICKS");    LASTUSERACTION68k     = MakeAtom68k("\\LASTUSERACTION");E 47E 35E 29E 21D 21   index = MAKEATOM("\\MOUSECHORDTICKS");   MOUSECHORDTICKS68k=(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 21I 21D 29  index = MAKEATOM("\\MOUSECHORDTICKS");  MOUSECHORDTICKS68k=(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 21D 21   index = make_atom("\\LASTUSERACTION",0,15,0);   LASTUSERACTION68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));   CLastUserActionCell68k= (LispPTR*)Addr68k_from_LADDR(*LASTUSERACTION68k& 0xffffff);E 21I 21  index = make_atom("\\LASTUSERACTION",0,15,0);  LASTUSERACTION68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 29D 47  CLastUserActionCell68k= (LispPTR*)Addr68k_from_LADDR(*LASTUSERACTION68k& 0xffffff);E 47I 47    CLastUserActionCell68k= (LispPTR*)			      Addr68k_from_LADDR(*LASTUSERACTION68k& 0xffffff);E 47E 21D 21   DOBUFFEREDTRANSITION_index = make_atom("\\DOBUFFEREDTRANSITIONS",0,22,0);   INTERRUPTFRAME_index = make_atom("\\INTERRUPTFRAME",0,15,0);E 21I 21D 29  DOBUFFEREDTRANSITION_index = make_atom("\\DOBUFFEREDTRANSITIONS",0,22,0);  INTERRUPTFRAME_index = make_atom("\\INTERRUPTFRAME",0,15,0);E 29I 29D 47  DOBUFFEREDTRANSITION_index = MAKEATOM("\\DOBUFFEREDTRANSITIONS");  INTERRUPTFRAME_index       = MAKEATOM("\\INTERRUPTFRAME");E 47I 47    DOBUFFEREDTRANSITION_index = MAKEATOM("\\DOBUFFEREDTRANSITIONS");    INTERRUPTFRAME_index       = MAKEATOM("\\INTERRUPTFRAME");E 47E 29E 21D 28 E 28I 28E 28D 21   CTopKeyevent= (DLword*)Addr68k_from_LADDR(*KEYBOARDEVENTQUEUE68k);E 21I 21D 47  CTopKeyevent= (DLword*)Addr68k_from_LADDR(*KEYBOARDEVENTQUEUE68k);E 47I 47    CTopKeyevent= (DLword*)Addr68k_from_LADDR(*KEYBOARDEVENTQUEUE68k);E 47E 21D 29  index = MAKEATOM("\\PERIODIC.INTERRUPT");  PERIODIC_INTERRUPT68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 29I 29D 35  PERIODIC_INTERRUPT68k = (LispPTR *) MakeAtom68k("\\PERIODIC.INTERRUPT");E 35I 35D 47  PERIODIC_INTERRUPT68k = MakeAtom68k("\\PERIODIC.INTERRUPT");E 35  PERIODIC_INTERRUPT_FREQUENCY68kE 47I 47    PERIODIC_INTERRUPT68k = MakeAtom68k("\\PERIODIC.INTERRUPT");    PERIODIC_INTERRUPT_FREQUENCY68kE 47D 35			= (LispPTR *) MakeAtom68k("\\PERIODIC.INTERRUPT.FREQUENCY");E 35I 35			= MakeAtom68k("\\PERIODIC.INTERRUPT.FREQUENCY");E 35E 29D 29  index = MAKEATOM("\\PERIODIC.INTERRUPT.FREQUENCY");  PERIODIC_INTERRUPT_FREQUENCY68k =(LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 29D 47  PERIODIC_INTERRUPTFRAME_index = MAKEATOM("\\PERIODIC.INTERRUPTFRAME");D 28  DORECLAIM_index = MAKEATOM("\\DORECLAIM"); E 28I 28D 29  DORECLAIM_index = MAKEATOM("\\DORECLAIM");E 29I 29  DORECLAIM_index               = MAKEATOM("\\DORECLAIM");E 47I 47    PERIODIC_INTERRUPTFRAME_index = MAKEATOM("\\PERIODIC.INTERRUPTFRAME");    DORECLAIM_index               = MAKEATOM("\\DORECLAIM");E 47I 37D 38  IOINTERRUPTFLAGS_word = MakeAtom68k("\\MAIKO.IO-INTERRUPT-FLAGS");E 37E 29E 28E 15E 38I 38#ifndef INITD 47   index = get_package_atom("\\MAIKO.IO-INTERRUPT-FLAGS", 25, "INTERLISP", 9, NIL);D 39   IOINTERRUPTFLAGS_word = Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 39I 39   IOINTERRUPTFLAGS_word =(LispPTR *) Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 47I 47    index = get_package_atom("\\MAIKO.IO-INTERRUPT-FLAGS", 25, "INTERLISP", 9, NIL);    IOINTERRUPTFLAGS_word =(LispPTR *) 				Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 47E 39#endifE 38I 16D 47}E 47I 47  }E 47I 47/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 47D 21 init_for_bltchar()E 21I 21init_for_bltchar()E 21D 47{ LispPTR index;D 29 extern LispPTR        *TOPWDS68k; extern LispPTR         BLTCHAR_index;I 20 extern LispPTR         TEDIT_BLTCHAR_index;E 29I 29  char *IL;E 47I 47  { LispPTR index;    char *IL;E 47E 29E 20I 19D 29if(!for_makeinit) {E 19D 28   BLTCHAR_index = get_package_atom("\\MAIKO.PUNTBLTCHAR", 18, "INTERLISP", 9, NIL);I 27   TEDIT_BLTCHAR_index = get_package_atom("\\TEDIT.BLTCHAR", 14, "INTERLISP", 9, NIL);E 28I 28          BLTCHAR_index = get_package_atom("\\MAIKO.PUNTBLTCHAR", 18, "INTERLISP", 9, NIL);    TEDIT_BLTCHAR_index = get_package_atom("\\TEDIT.BLTCHAR",     14, "INTERLISP", 9, NIL);E 28E 27I 19};I 20D 27  TEDIT_BLTCHAR_index = get_package_atom("\\TEDIT.BLTCHAR", 14, "INTERLISP", 9, NIL);E 27E 20E 19 index = MAKEATOM("\\TOPWDS"); TOPWDS68k = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET + (index << 1));E 29I 29D 47  extern LispPTR        *TOPWDS68k;  extern LispPTR         BLTCHAR_index;  extern LispPTR         TEDIT_BLTCHAR_index;E 47I 47    extern LispPTR        *TOPWDS68k;    extern LispPTR         BLTCHAR_index;    extern LispPTR         TEDIT_BLTCHAR_index;E 47I 39#ifdef COLORD 41  extern LispPTR           *SCREENBITMAPS68k;  extern LispPTR		SLOWBLTCHAR_index;E 41I 41D 47  extern LispPTR        *SCREENBITMAPS68k;  extern LispPTR	SLOWBLTCHAR_index;  extern LispPTR	*COLORSCREEN68k; 	/*  \\COLORSCREEN */  extern LispPTR	COLORSCREEN_index;E 47I 47    extern LispPTR        *SCREENBITMAPS68k;    extern LispPTR	SLOWBLTCHAR_index;    extern LispPTR	*COLORSCREEN68k; 	/*  \\COLORSCREEN */    extern LispPTR	COLORSCREEN_index;E 47E 41#endifE 39D 47  IL = "INTERLISP";E 47I 47    IL = "INTERLISP";E 47I 39E 39D 47  if(!for_makeinit) {          BLTCHAR_index = get_package_atom("\\MAIKO.PUNTBLTCHAR", 18,IL,9,NIL);    TEDIT_BLTCHAR_index = get_package_atom("\\TEDIT.BLTCHAR",     14,IL,9,NIL);    };D 35  TOPWDS68k = (LispPTR *) MakeAtom68k("\\TOPWDS");E 35I 35  TOPWDS68k = MakeAtom68k("\\TOPWDS");E 47I 47    if(!for_makeinit)      {	BLTCHAR_index = get_package_atom("\\MAIKO.PUNTBLTCHAR", 18,IL,9,NIL);	TEDIT_BLTCHAR_index = get_package_atom("\\TEDIT.BLTCHAR", 14,IL,9,NIL);      };    TOPWDS68k = MakeAtom68k("\\TOPWDS");E 47I 39#ifdef COLORI 41D 43 SLOWBLTCHAR_index= get_package_atom("\\PUNT.SLOWBLTCHAR", E 43I 43D 47  if(!for_makeinit) { 	SLOWBLTCHAR_index= get_package_atom("\\PUNT.SLOWBLTCHAR", E 47I 47    if(!for_makeinit)       {	SLOWBLTCHAR_index= get_package_atom("\\PUNT.SLOWBLTCHAR", E 47E 43	17, "INTERLISP", 9, NIL);E 41D 43 index = MAKEATOM("\\SCREENBITMAPS"); SCREENBITMAPS68k = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +	 (index << 1));I 41 COLORSCREEN_index = MAKEATOM("\\COLORSCREEN"); COLORSCREEN68k = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +	 (COLORSCREEN_index << 1));E 43I 43 	index = MAKEATOM("\\SCREENBITMAPS");	 SCREENBITMAPS68k = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +		 (index << 1));	 COLORSCREEN_index = MAKEATOM("\\COLORSCREEN");	 COLORSCREEN68k = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +		 (COLORSCREEN_index << 1));D 47   }E 47I 47      }E 47E 43E 41#endif COLORE 39E 35E 29E 16E 3D 47}E 47I 47  }E 47I 26I 40I 47/************************************************************************//*									*//*			i n i t _ f o r _ b i t b l t			*//*									*//*									*//*									*//************************************************************************/E 47I 44init_for_bitblt()D 47{  LispPTR index;  char *IL;E 47I 47  {    LispPTR index;    char *IL;E 47D 47  extern LispPTR BITBLTBITMAP_index;  extern LispPTR BLTSHADEBITMAP_index;E 47I 47    extern LispPTR BITBLTBITMAP_index;    extern LispPTR BLTSHADEBITMAP_index;E 47I 46#ifndef XWINDOWE 46D 47  extern LispPTR *COLORSCREEN68k;  extern LispPTR COLORSCREEN_index;E 47I 47    extern LispPTR *COLORSCREEN68k;    extern LispPTR COLORSCREEN_index;E 47I 46#endif XWINDOWE 46D 47 if(!for_makeinit){   BITBLTBITMAP_index=get_package_atom("\\PUNT.BITBLT.BITMAP",19,E 47I 47    if(!for_makeinit)      {	BITBLTBITMAP_index=get_package_atom("\\PUNT.BITBLT.BITMAP",19,E 47						"INTERLISP",9, NIL); D 47   BLTSHADEBITMAP_index=get_package_atom("\\PUNT.BLTSHADE.BITMAP",21,E 47I 47	BLTSHADEBITMAP_index=get_package_atom("\\PUNT.BLTSHADE.BITMAP",21,E 47						"INTERLISP",9, NIL); I 46#ifndef XWINDOWE 46D 47   COLORSCREEN_index = MAKEATOM("\\COLORSCREEN");   COLORSCREEN68k = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +E 47I 47	COLORSCREEN_index = MAKEATOM("\\COLORSCREEN");	COLORSCREEN68k = (LispPTR *)Addr68k_from_LADDR(VALS_OFFSET +E 47	 	(COLORSCREEN_index << 1));I 46#endif XWINDOWE 46D 47 }E 47I 47      }E 47D 47}E 47I 47  }E 47E 44E 40E 26E 1