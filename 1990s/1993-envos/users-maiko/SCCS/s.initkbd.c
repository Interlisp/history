h19982s 00038/00019/00619d D 1.20 92/11/25 21:05:45 sybalsky 20 19c Fixing endif's with extra text => comment. \nes 00006/00006/00632d D 1.19 92/07/24 10:46:04 sybalsky 19 18c retrofit of SGI & DEC OSF1 changes \nes 00032/00005/00606d D 1.18 92/06/26 13:49:15 sybalsky 18 17c retrofit of 386 unix changes \nes 00003/00003/00608d D 1.17 92/04/21 17:16:01 sybalsky 17 16c shortening file names for DOS \nes 00002/00002/00609d D 1.16 92/03/04 18:55:35 sybalsky 16 15c 386es 00011/00014/00600d D 1.15 91/12/11 03:58:31 sybalsky 15 14c Fix missing keys in DEC3100 keyboard config.es 00003/00000/00611d D 1.14 91/09/27 02:34:03 sybalsky 14 13c ISC port changeses 00000/00000/00611d D 1.13 91/06/10 12:57:03 sybalsky 13 12c Make X generic flag case-independentes 00017/00003/00594d D 1.12 91/06/07 14:02:17 sybalsky 12 11c Fix generic-X keyboard inites 00002/00002/00595d D 1.11 91/06/04 11:50:43 sybalsky 11 10c Changes from HP port center.  Use key # 255 for unused keys.es 00000/00000/00597d D 1.10 91/06/02 15:35:31 sybalsky 10 9c Retrofit changes from Savoir to make generic-X code work on DECstation.es 00025/00013/00572d D 1.9 91/06/02 15:20:21 sybalsky 9 8c Retrofit changes to generic-X from Savoir, make it work on DECstation.es 00107/00029/00478d D 1.8 91/05/26 16:03:14 sybalsky 8 7c Add generic-X keyboard map building, if LDEKBDTYPE = xes 00003/00003/00504d D 1.7 91/02/07 11:37:44 sybalsky 7 6c Fix HP9000 ] key (had been 59, should be 29), make all non-Sun machines look like type-3 kbd to the emulator for now.es 00049/00017/00458d D 1.6 91/01/25 17:59:11 sybalsky 6 5c Retrofit HP9000/RS6000 changeses 00068/00003/00407d D 1.5 90/09/18 23:44:25 sybalsky 5 4c Retrofit changes from AIX, DEC3100, PS/2es 00002/00002/00408d D 1.4 90/07/04 03:59:58 sybalsky 4 3c Fix X ifdefs so they workes 00044/00001/00366d D 1.3 90/06/13 18:35:13 sybalsky 3 2c AIX portability changeses 00000/00002/00367d D 1.2 90/04/20 01:39:21 sybalsky 2 1c X:  shortening file names, bulk change.es 00369/00000/00000d D 1.1 90/04/19 23:19:30 sybalsky 1 0c date and time created 90/04/19 23:19:30 by sybalskyeuUf e 0tTI 1D 19/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 19I 19/* %Z% %M% Version %I% (%G%). copyright venue  */static char *id = "%Z% %M%	%I% %G%	(venue)";E 19D 2/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 2D 15/* *	Copyright (C) 1987, 1989 by Fuji Xerox Co., Ltd., *				    Venue, and Envos Corporation. *		  All rights reserved. * *	Author	:	Osamu Nakamura */E 15/************************************************************************//*									*/D 15/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 15I 15D 19/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*/E 19I 19/*	(C) Copyright 1989-1992 Venue. All Rights Reserved.		*/E 19/*	Manufactured in the United States of America.			*/E 15/*									*/D 15/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 15I 15/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 15/*									*//************************************************************************/I 15E 15#include <stdio.h>#include <sys/types.h>#include <sys/file.h>I 3#ifdef SUNDISPLAYE 3#include <sundev/kbd.h>#include <sundev/kbio.h>I 3D 20#endif SUNDISPLAYE 20I 20#endif /* SUNDISPLAY */E 20E 3#include <fcntl.h>I 3#ifdef SUNDISPLAYE 3#include <sunwindow/window_hs.h>#include <sunwindow/cms.h>#include <sys/ioctl.h>#include <sunwindow/win_ioctl.h>#include <pixrect/pixrect_hs.h>I 3D 20#endif SUNDISPLAYE 20I 20#endif /* SUNDISPLAY */E 20E 3I 20E 20I 8#ifdef XWINDOW#include <X11/Xlib.h>#include <X11/Xutil.h>#include <X11/keysym.h>#include <X11/keysymdef.h>#include "XKeymap.h"extern Display *Xdisplay;D 20#endif XWINDOWE 20I 20#endif /* XWINDOW */E 20I 20E 20I 14#ifdef ISC#include <sys/bsdtypes.h>D 20#endif ISCE 20I 20#endif /* ISC */E 20E 14I 20E 20E 8#include "lispemul.h"#include "lispmap.h"D 17#include "lispglobal.h"#include "address68k.h"E 17I 17#include "lspglob.h"#include "adr68k.h"E 17#include "address.h"D 17#include "devconfig.h"E 17I 17#include "devconf.h"E 17#include "iopage.h"#include "ifpage.h"I 3#ifdef SUNDISPLAYE 3extern struct screen LispScreen;I 3D 20#endif SUNDISPLAYE 20I 20#endif /* SUNDISPLAY */E 20I 20E 20E 3extern int LispWindowFd;int LispKbdFd;extern int errno;/*   for debug    */int	DebugKBD = NIL;FILE	*KBlog;u_int LispReadFds = 0;I 3#ifdef SUNDISPLAYE 3struct inputmask LispEventMask;I 3D 20#endif SUNDISPLAYE 20I 20#endif /* SUNDISPLAY */E 20E 3I 20E 20D 3E 3IOPAGE	*IOPage68K;DLword	*EmMouseX68K;DLword	*EmMouseY68K;DLword	*EmCursorX68K;DLword	*EmCursorY68K;DLword	*EmRealUtilin68K;DLword	*EmUtilin68K;DLword	*EmKbdAd068K;DLword	*EmKbdAd168K;DLword	*EmKbdAd268K;DLword	*EmKbdAd368K;DLword	*EmKbdAd468K;DLword	*EmKbdAd568K;DLword	*EmDispInterrupt68K;DLword	*EmCursorBitMap68K;/*u_char SUNLispKeyMap[128];*/u_char *SUNLispKeyMap;/* keymap for type3 */u_char SUNLispKeyMap_for3[128] = {/* 0 */	  -1,  61,  -1,  91,  -1,  97,  99,  -1,/* 8 */  100,  -1,  67,  -1,  68,  -1, 101,  -1,/* 16*/   66, 104,  80,  47,  -1,  73,  74,  75,/* 24*/   -1,  92,  63,  -1,  -1,  33,  32,  17,/* 32*/   16,   1,   0,   2,   4,  53,  22,   8,/* 40*/	  10,  59,  45,  13,  -1,  81,  82,  83,/* 48*/   -1,  14,  -1,  62,  -1,  34,  19,  18,/* 56*/    3,  48,  49,  51,   6,  23,  25,  11,/* 64*/   58,  29,  15,  -1,  84,  85,  87,  -1,/* 72*/  111,  89,  -1,  -1,  36,  21,  20,   5,/* 80*/	  35,  50,  52,  38,   9,  26,  43,  28,/* 88*/  105,  44,  -1,  94,  69,  70,  -1,  90,/* 96*/   -1,  46,  -1,  41,  40,  24,  37,   7,/*104*/   39,  54,  55,  27,  42,  12,  60,  71,/*112*/   98,  76,  72,  -1,  -1,  -1,  -1,  56,/*120*/	  31,  57,  93,  -1,  -1,  -1,  -1,  -1, };/* for type4 */u_char SUNLispKeyMap_for4[128] = {/* 0 */   -1,  61,  -1,  91,  -1,  97,  99, 106,D 16/* 8 */  100, 107,  67, 108,  68,  47, 101,  -1,E 16I 16/* 8 */  100, 107,  67, 108,  68,  47, 101,  30,E 16/* 16*/   66, 104,  80,  31,  -1,  75, 110,  74,/* 24*/   -1, 109,  63,  -1,  -1,  33,  32,  17,/* 32*/   16,   1,   0,   2,   4,  53,  22,   8,/* 40*/   10,  59,  45,  15,  -1,  64,  65,  95,/* 48*/   -1,  14,  13,  89,  -1,  34,  19,  18,/* 56*/    3,  48,  49,  51,   6,  23,  25,  11,/* 64*/   58,  29,  13,  93,  81,  82,  83,  96,/* 72*/  111,  62,  -1,  -1,  36,  21,  20,   5,/* 80*/   35,  50,  52,  38,   9,  26,  43,  28,/* 88*/  105,  44,  76,  84,  85,  87,  98,  90,/* 96*/   -1,  46,  73,  41,  40,  24,  37,   7,/*104*/   39,  54,  55,  27,  42,  12,  60,  71,/*112*/   94,  69,  70,  -1,  -1,  -1,  92,  56,D 16/*120*/   86,  57,  88,  -1,  -1, 102,  -1,  -1,E 16I 16/*120*/   86,  57,  88,  -1, 103, 102,  -1,  -1,E 16 };/* for jle */u_char SUNLispKeyMap_jle[128] = {/* 0 */   -1,  61,  -1,  91,  -1,  97,  99, 106,/* 8 */  100, 107,  67, 108,  68,  47, 101,  71,/* 16*/   66, 104,  80,  31,  -1,  75, 110,  74,/* 24*/   -1, 109,  63,  -1,  -1,  33,  32,  17,/* 32*/   16,   1,   0,   2,   4,  53,  22,   8,/* 40*/   59,  45,  30,  15,  -1,  64,  65,  95,/* 48*/   -1,  14,  13,  89,  -1,  34,  19,  18,/* 56*/    3,  48,  49,  51,   6,  23,  25,  11,/* 64*/   58,  29,  13,  93,  81,  82,  83,  96,/* 72*/  111,  62,  -1,  -1,  36,  21,  20,   5,/* 80*/   35,  50,  52,  38,   9,  26,  43,  28,/* 88*/  105,  44,  76,  84,  85,  87,  98,  90,/* 96*/   -1,  46,  73,  41,  40,  24,  37,   7,/*104*/   39,  54,  55,  27,  42,  12,  60,  10,/*112*/   94,  69,  70,  72, 103, 109,  92,  56,/*120*/   86,  57,  88,  -1,  -1, 102,  -1,  -1, };/* [40] 10->59  *//* [41] 59->45  *//* [42] 45->30  *//* [111] 71->10 *//* [115] -1 -> 72  Kakutei *//* [116] -1 -> 103 Henkan *//* [117] -1 -> 109 Nihongo On-Off */I 3I 5/* For IBM Risc System 6000 */E 5u_char SUNLispKeyMap_RS6000[128] = {D 6/* 0 */   -1, -1,   45,  32,  17,  16,   1,   0,/* 8 */    2,   4,  53,  22,   8,  10,  59,  -1,/* 16*/   15,  34,  19,  18,   3,  48,  49,  51,/* 24*/    6,  23,  25,  11,  58,  29, 105,  56,/* 32*/   21,  20,   5,  35,  50,  52,  38,   9,/* 40*/   26,  43,  28,  -1,  44,  41,  -1,  40,/* 48*/   24,  37,   7,  39,  54,  55,  27,  42,/* 56*/   12,  -1,  60,  36,  -1,  31,  57,  -1,/* 64*/   -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/* 72*/   -1,  -1,  -1,  -1,  -1,  46,  -1,  -1,/* 80*/   -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/* 88*/   -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/* 96*/   -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/*104*/   -1,  -1,  -1,  -1,  -1,  -1,  -1,  33,/*112*/   -1,  97,  99, 100,  67,  68, 101,  66,/*120*/  104,  80, 106, 107, 108,  -1,  -1,  -1,E 6I 6/* 7 */   -1, -1,   45,  32,  17,  16,   1,   0,/* 15*/    2,   4,  53,  22,   8,  10,  59,  -1,/* 23*/   15,  34,  19,  18,   3,  48,  49,  51,/* 31*/    6,  23,  25,  11,  58,  29, 105,  56,/* 39*/   21,  20,   5,  35,  50,  52,  38,   9,/* 47*/   26,  43,  28,  -1,  44,  41,  -1,  40,/* 55*/   24,  37,   7,  39,  54,  55,  27,  42,/* 63*/   12,  -1,  60,  36,  -1,  31,  57,  93,/* 71*/   -1,  47,  -1,  -1,  -1,  -1,  -1,  -1,/* 79*/   -1,  -1,  -1,  -1,  89,  46,  -1,  -1,/* 87*/  129,  62,  90,  -1, 130, 131,  63,  91,/* 95*/   -1,  -1, 132,  73,  81,  84,  94,  -1,/*103*/   65,  82,  85,  69,  98,  95,  83,  87,/*111*/   70,  13,  96, 102,  -1, 128,  -1,  33,/*119*/   -1,  97,  99, 100,  67,  68, 101,  66,/*127*/  104,  80, 106, 107,  92,  76,  14,  61,/*136*/ E 6 };E 3D 5/*  ----------------------------------------------------------------*/E 5I 5/* For DECStation 3100 */E 5I 5u_char SUNLispKeyMap_DEC3100[256] = {/*  7*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/* 15*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/* 23*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/* 31*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/* 39*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/* 47*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/* 55*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/* 63*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/* 71*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/* 79*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  97,/* 87*/  99, 100,  67,  68,  -1,  -1,  -1,  -1,/* 95*/  -1,  -1,  -1,  -1,  -1, 101,  66, 104,/*103*/  80, 106,  -1,  -1,  -1,  -1,  -1,  -1,/*111*/  -1,  -1, 107, 108,  -1,  -1,  -1,  -1,D 15/*119*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,E 15I 15/*119*/  -1,  -1,  -1,  -1,  -1,  92,  76,  -1,E 15/*127*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,D 15/*135*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,/*143*/  -1,  -1,  -1,  98,  -1,  13,  76,  94,E 15I 15/*135*/  -1,  -1,  -1,  90,  91,  46,  93,  89,/*143*/  47,  -1,  -1,  98,  -1,  13,  76,  94,E 15/*151*/  69,  70,  84,  85,  87, 102,  81,  82,/*159*/  83,  -1,  -1,  -1,  -1,  -1,  -1,  -1,D 15/*167*/  -1,  -1,  -1,  -1,  -1,  -1,  -1,  41,E 15I 15/*167*/ 129, 132, 131, 130,  -1,  -1,  -1,  41,E 15/*175*/  36,  56,  31,  -1,  -1,  -1,  -1,  -1,/*183*/  -1,  -1,  -1,  -1,  -1,  15,  44,  34,/*191*/  33,  32,  19,  21,  40,  -1,  17,  18,/*199*/  20,  24,  45,  -1,  16,   3,   5,  37,/*207*/  -1,   1,  48,  35,   7,  57,  -1,   0,/*215*/  49,  50,  39,  -1,   2,  51,  52,  54,/*223*/  -1,   4,   6,  38,  55,  -1,  53,  23,/*231*/   9,  27,  -1,  22,  25,  26,  42,  -1,/*239*/   8,  11,  -1,  43,  12,  -1,  59,  29,/*247*/ 105,  -1,  10,  58,  28,  -1,  -1,  -1   };I 6u_char SUNLispKeyMap_HP9000[135] =   {/*   7*/  -1, -1, -1, 93, 31, 60, 41, 36,/*  15*/  -1, -1, -1, -1, -1, -1, -1, -1,/*  23*/  -1, -1, -1, -1, -1, -1, -1, -1,/*  31*/  -1, 39,  7, 37, 24, 40, -1, -1,/*  39*/  -1, -1, -1, -1, -1, -1, -1, -1,/*  47*/  -1, 52, 50, 35,  5, 20, 21, -1,/*  55*/  56,  6, 51, 49, 48,  3, 18, 19,/*  63*/  34,  4,  2,  0,  1, 16, 17, 32,/*  71*/  45, -1, -1, -1, -1, -1, -1, -1,/*  79*/  -1, 68, 67,100, 99, 97, -1, -1,/*  87*/  -1, 68,101, 66,104, 80, 13, -1,/*  95*/  -1, 53, 22,  8, 10, 59, 15, -1,D 7/* 103*/  -1, 23, 25, 11, 58, 59,105, -1,E 7I 7/* 103*/  -1, 23, 25, 11, 58, 29,105, -1,E 7/* 111*/  -1, 38,  9, 26, 43, 28, 44, -1,/* 119*/  -1, 55, 27, 42, 12, -1, -1, -1,/* 127*/  47, 54, 57, -1, -1, -1, -1, -1};E 6I 8u_char *XGenericKeyMap;	/* filled in with malloc if needed */E 8I 6E 6E 5init_keyboard(flg)  int flg ; /* if 0 init else re-init */  {    int keytrans;    set_kbd_iopointers();#ifdef SUNDISPLAY    if( (LispKbdFd = open( LispScreen.scr_kbdname , O_RDWR)) == -1)      {	fprintf( stderr, "can't open %s\n", LispScreen.scr_kbdname);	exit( -1 );      }D 20#endif SUNDISPLAYE 20I 20#endif /* SUNDISPLAY */E 20I 20E 20    if(flg==0)      {	keyboardtype(LispKbdFd);      }#ifdef SUNDISPLAY    keytrans = TR_UNTRANS_EVENT;	/* keyboard does not encode key */    if(ioctl( LispKbdFd, KIOCTRANS, &keytrans)== -1)      {	fprintf( stderr, "Error at ioctl errnoo =%d\n", errno);	exit( -1 );      }    close( LispKbdFd );    seteventmask( &LispEventMask );D 20#endif SUNDISPLAYE 20I 20#endif /* SUNDISPLAY */E 20I 20E 20#ifdef XWINDOW    init_Xevent();D 20#endif XWINDOWE 20I 20#endif /* XWINDOW */E 20}I 5E 5/*  ----------------------------------------------------------------*/device_before_exit(){#ifdef SUNDISPLAY	int keytrans;	if( (LispKbdFd = open( LispScreen.scr_kbdname , O_RDWR)) == -1){		fprintf( stderr, "can't open %s\n", LispScreen.scr_kbdname);		exit( -1 );	}	keytrans = TR_EVENT;	/* keyboard encodes key */	if(ioctl( LispKbdFd, KIOCTRANS, &keytrans)== -1){		fprintf( stderr, "Error at ioctl errnoo =%d\n", errno);			exit( -1 );	}	close( LispKbdFd );D 20#endif SUNDISPLAYE 20I 20#endif /* SUNDISPLAY */E 20	display_before_exit();}I 5E 5/*  ----------------------------------------------------------------*/set_kbd_iopointers(){	IOPage68K       = (IOPAGE *)IOPage;	EmMouseX68K     = (DLword *) &(IOPage68K->dlmousex);	EmMouseY68K     = (DLword *) &(IOPage68K->dlmousey);	EmCursorX68K    = (DLword *) &(IOPage68K->dlcursorx);	EmCursorY68K    = (DLword *) &(IOPage68K->dlcursory);	EmRealUtilin68K = (DLword *) &(IOPage68K->dlutilin);	/* EmUtilin68K is for KEYDOWNP1 macro or etc. */	EmUtilin68K = (DLword *) &(InterfacePage->fakemousebits);	EmKbdAd068K = (DLword *) &(IOPage68K->dlkbdad0);	EmKbdAd168K = (DLword *) &(IOPage68K->dlkbdad1);	EmKbdAd268K = (DLword *) &(IOPage68K->dlkbdad2);	EmKbdAd368K = (DLword *) &(IOPage68K->dlkbdad3);	EmKbdAd468K = (DLword *) &(IOPage68K->dlkbdad4);	EmKbdAd568K = (DLword *) &(IOPage68K->dlkbdad5);	EmDispInterrupt68K = (DLword *) &(IOPage68K->dldispinterrupt);	EmCursorBitMap68K  = (DLword *)  (IOPage68K->dlcursorbitmap);}I 5E 5/*  ----------------------------------------------------------------*/#ifdef SUNDISPLAYseteventmask( eventmask )struct inputmask *eventmask;{	input_imnull( eventmask );	eventmask->im_flags  |=  IM_ASCII | IM_NEGASCII | IM_NEGEVENT;	win_setinputcodebit  ( eventmask, MS_LEFT );	win_setinputcodebit  ( eventmask, MS_MIDDLE );	win_setinputcodebit  ( eventmask, MS_RIGHT );	win_setinputcodebit  ( eventmask, LOC_MOVE );	win_unsetinputcodebit( eventmask, LOC_STILL );	win_unsetinputcodebit( eventmask, LOC_MOVEWHILEBUTDOWN );	win_unsetinputcodebit( eventmask, LOC_WINENTER );	win_unsetinputcodebit( eventmask, LOC_WINEXIT );	win_setinputmask( LispWindowFd, eventmask, eventmask, WIN_NULLLINK);}D 20#endif SUNDISPLAYE 20I 20#endif /* SUNDISPLAY */E 20I 20E 20char* getenv();		/*  ---- external entry points --------*/#define MIN_KEYTYPE 3#define KB_AS3000J (7 + MIN_KEYTYPE)I 3#define KB_RS6000  (8 + MIN_KEYTYPE)I 5#define KB_DEC3100 (9 + MIN_KEYTYPE)I 6#define KB_HP9000  (10+ MIN_KEYTYPE)I 8#define KB_X	   (11+ MIN_KEYTYPE)E 8E 6E 5E 3I 6E 6/* KB_SUN4 not defined in older OS versions */#ifndef KB_SUN4#define KB_SUN4 4#endifI 3D 4#ifdef AIXE 4I 4#ifdef XWINDOWE 4	/* These KB types nog defined outside Sun world,so define them here */#define KB_SUN2 2#define KB_SUN3 3D 4#endif AIXE 4I 4D 20#endif XWINDOWE 20I 20#endif /* XWINDOW */E 20E 4I 20E 20E 3/* For the JLE keyboard */#define KB_JLE 5D 8/*  ----------------------------------------------------------------*//*********************************************************//*	keyboardtype(fd)E 8D 8	Determine the keyboard type	by checking LDEKBDTYPE	If it is not set,then print the message	and exit to SHELL (for Fuji).	If LDEKBDTYPE's value doesn't match then	it is treated as type3*//*********************************************************/E 8I 8/************************************************************************//*									*/I 9/*			m a k e _ X _ k e y m a p			*/E 9/*									*/I 9/*	Starting from the generic-X-keyboard mapping in XKeymap.h,	*//*	construct a keyboard map for this machine, using the rules	*//*	shown in the header file.					*/E 9/*									*//*									*/D 9/*									*/E 9/************************************************************************/I 12E 12#ifdef XWINDOWu_char * make_X_keymap()  {D 9    u_char *table = (u_char *)malloc(256);    int lisp_codes_used[256];E 9I 9    u_char *table = (u_char *)malloc(256);	/* the final result table */    int lisp_codes_used[256];	/* Keep track of the Lisk key #s we've used */E 9    int last_KEYSYM = -1;    int sym_used = 0;D 9    int *map = generic_X_keymap;E 9I 9    int *key_sym_pairs = generic_X_keymap;    int i = 0;I 18    KeySym * mapping;    KeyCode first;    int codecount, symspercode, minkey, maxkey;E 18E 9D 9    for (; *map != -1; )E 9I 9    for (; i<256; i++)      { /* clear the tables we just allocated */	lisp_codes_used[i] = 0;D 11	table[i]=0;E 11I 11D 12	table[i]=255;E 12I 12	table[i]=255;		/* The "no key assigned" code */E 12E 11      }I 18    XDisplayKeycodes(Xdisplay, &minkey, &maxkey);    codecount = maxkey + 1 - minkey;    mapping = XGetKeyboardMapping(Xdisplay, minkey, codecount, &symspercode);E 18    for (; *key_sym_pairs != -1; )E 9      {D 9	int code = *map++,	    sym  = *map++,E 9I 9D 18	int code = *key_sym_pairs++,E 18I 18	int reusable = *key_sym_pairs++,	    code = *key_sym_pairs++,E 18	    sym  = *key_sym_pairs++,E 9	    xcode;	if (sym_used && (sym == last_KEYSYM)) continue;	sym_used = 0;	last_KEYSYM = sym;D 9	if (table[code-7] != 0) continue;E 9D 18	xcode = XKeysymToKeycode(Xdisplay, sym);E 18I 18	xcode = find_unused_key(mapping, minkey, codecount,				symspercode, sym, table);E 18D 9	if ((xcode==0) | table[xcode-7] != 0) continue;	if (lisp_codes_used[code] != 0) continue;E 9I 9D 12	if ((xcode==0) || (table[xcode-7] != 0)) continue;D 11	if (lisp_codes_used[code] != 0) continue;E 11I 11	if (lisp_codes_used[code] != 255) continue;E 12I 12D 18	if ((xcode==0) || (table[xcode-7] != 255)) continue;	if (lisp_codes_used[code] != 0) continue;E 18I 18	if (xcode==0) continue;	if ((!reusable) && (lisp_codes_used[code] != 0)) continue;E 18E 12E 11	E 9	sym_used = 1;	last_KEYSYM = sym;	lisp_codes_used[code] = 1;	table[xcode-7] = code;	      }I 12#ifdef DEBUG    for (i=0; i < 256; i += 8)      {	printf("\n\n\tKeyboard mapping table\n\n");	printf("%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",		table[i], table[i+1], table[i+2], table[i+3],		table[i+4], table[i+5], table[i+6], table[i+7]);      }D 20#endif DEBUGE 20I 20#endif /* DEBUG */E 20I 20E 20E 12I 9    return(table);E 9  }D 18#endif XWINDOWE 18I 18int find_unused_key(map, minkey, len, syms, sym, table)  KeySym *map;  int minkey, len, syms, sym;  u_char *table;  {    int i;E 18I 18    for (i=0; i<(len*syms); i++)      {	if (sym == map[i])	  {	    int code = minkey + (i/syms);	    if (table[code-7] != 255) continue;	    return(code);	  }       }    return(0);  }#endif /* XWINDOW */E 18/************************************************************************//*									*//*			  k e y b o a r d t y p e			*//*									*//*	Determine what kind of keyboard we're dealing with, by		*//*	checking the LDEKBDTYPE shell variable.  It it's not set,	*//*	either default it (for DEC, IBM), or complain and exit.		*//*	Valid LDEKBDTYPE values:					*//*		type3	Sun type-3 keyboard				*//*		type4	Sun type-4 keyboard				*//*		rs6000	IBM RS/6000					*//*		hp9000	HP 9000 series 800 or 700			*//*		dec3100	DECstation 3100 or 5000				*//*		x	generic X keyboard map				*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/I 12E 12E 8keyboardtype(fd)D 8int fd;{ int type; int i; char *key;E 8I 8  int fd;  {    int type;    int i;    char *key;E 8D 8 for(i=0;i<5000;i++){/* IDLE LOOP */}E 8I 8    for(i=0;i<5000;i++){/* IDLE LOOP */} /* because of a SunOS bug */E 8D 8 /* clear the keyboard field in devconfig */ InterfacePage->devconfig &= 0xfff8;E 8I 8    /* clear the keyboard field in devconfig */    InterfacePage->devconfig &= 0xfff8;E 8D 8/************************************************************ Due to the problems of SunOS 4.0 & 4.0.1 calling ioctl never return the correct keyboard type. So,these 2 lines are commented out ...(Take)->AR11100*************************************************************/E 8I 8   /************************************************************    Due to the problems of SunOS 4.0 & 4.0.1    calling ioctl never return the correct keyboard type.    So,these 2 lines are commented out ...(Take)->AR11100   *************************************************************/E 8D 8/* Get keytype from LDEKBDTYPE  */ if ((key = getenv("LDEKBDTYPE")) == 0) {E 8I 8    /* Get keytype from LDEKBDTYPE  */    if ((key = getenv("LDEKBDTYPE")) == 0) {E 8D 5#ifdef XWINDOWE 5I 5D 6#if (defined(XWINDOW) && (!defined(RS6000)) && (!defined(DEC3100)))E 6I 6D 9#if (defined(XWINDOW) && (!defined(RS6000)) && (!defined(DEC3100)) && (!defined(HP9000)))E 6E 5#define FUJI#endif XWINDOWE 9#ifdef FUJI	/* obnoxious behavior */	mess_reset();	printf("!!CAUTION: LDEKBDTYPE is not set.\n");	printf("Please retry after setting LDEKBDTYPE correctly.\n");	printf("Usage: setenv LDEKBDTYPE <kbdtype>\n");	printf("       (one of type2, type3, type4, jle, or as3000j)");	exit(0); /* exit to shell */#elseI 5D 19#ifdef DEC3100E 19I 19#ifdef DECSTNE 19	type = KB_DEC3100;#else#ifdef RS6000	type = KB_RS6000;#elseI 6#ifdef HP9000	type = KB_HP9000;#elseI 9#ifdef XWINDOW	type = KB_X;#elseE 9E 6E 5  	if(ioctl(fd,KIOCTYPE,&type) !=0) {		error("keyboardtype:IOCTL(KIOCTYPE) fails (cont. w. type-3");		type = KB_SUN3;		}	/* otherwise, type is set */I 9D 19#endif XWINDOWE 19I 19#endif /* XWINDOW */E 19E 9I 6D 20#endif HP9000E 6D 5#endifE 5I 5#endif RS6000D 19#endif DEC3100E 19I 19#endif DECSTNE 19#endif FUJIE 20I 20#endif /* HP9000 */#endif /* RS6000 */#endif /* DECSTN */#endif /* FUJI */E 20E 5#ifdef XWINDOW#undef FUJID 20#endif XWINDOWE 20I 20#endif /* XWINDOW */E 20 }/* if end */ else {	if      (strcmp("as3000j", key)==0) type = KB_AS3000J;	else if (strcmp("type4",   key)==0) type = KB_SUN4;	else if (strcmp("type2",   key)==0) type = KB_SUN2;        else if (strcmp("jle",     key)==0) type = KB_JLE;I 3	else if (strcmp("rs6000",  key)==0) type = KB_RS6000;I 5	else if (strcmp("dec3100", key)==0) type = KB_DEC3100;I 6D 8	else if (strcmp("hp9000", key)==0) type = KB_HP9000;E 8I 8	else if (strcmp("hp9000",  key)==0) type = KB_HP9000;	else if (strcmp("X",       key)==0) type = KB_X;I 12	else if (strcmp("x",       key)==0) type = KB_X;E 12E 8E 6E 5E 3	else     type = KB_SUN3;           /* default */       } switch(type) {	case KB_SUN2 : /* type2, we still use keymap for type3 */		SUNLispKeyMap = SUNLispKeyMap_for3;		/* MIN_KEYTYPE is 3,so we can't set devconfig correctly */		/* Therefore type2 may treat as type3 */		InterfacePage->devconfig |= 0;		break;	case KB_SUN3 : /* type3 */		SUNLispKeyMap = SUNLispKeyMap_for3;		InterfacePage->devconfig |= type-MIN_KEYTYPE;		break;	case KB_SUN4 : /* type4 */		SUNLispKeyMap = SUNLispKeyMap_for4;		InterfacePage->devconfig |= type-MIN_KEYTYPE;		break;	case KB_JLE : /* JLE */		/*printf("jle\n"); */		SUNLispKeyMap=SUNLispKeyMap_jle;		InterfacePage->devconfig |= type-MIN_KEYTYPE;		/* InterfacePage->devconfig |= 4-MIN_KEYTYPE; */		break;	case KB_AS3000J : /* for AS, use type4 map */		SUNLispKeyMap = SUNLispKeyMap_for4;		InterfacePage->devconfig |= type-MIN_KEYTYPE;/* 7 */I 3		break;	case KB_RS6000:		SUNLispKeyMap = SUNLispKeyMap_RS6000;D 7		InterfacePage->devconfig |= type - MIN_KEYTYPE; /* 8 */E 7I 7		InterfacePage->devconfig |= KB_SUN3 - MIN_KEYTYPE; /* 8 */E 7I 5		break;	case KB_DEC3100:		SUNLispKeyMap = SUNLispKeyMap_DEC3100;D 7		InterfacePage->devconfig |= type - MIN_KEYTYPE; /* 9 */E 7I 7		InterfacePage->devconfig |= KB_SUN3 - MIN_KEYTYPE; /* 9 */E 7I 6		break;	case KB_HP9000:		SUNLispKeyMap = SUNLispKeyMap_HP9000;		InterfacePage->devconfig |= KB_SUN3 - MIN_KEYTYPE; /* 10 */E 6E 5E 3		break;I 8#ifdef XWINDOW	case KB_X:		XGenericKeyMap = (u_char *)make_X_keymap();		SUNLispKeyMap = XGenericKeyMap;		InterfacePage->devconfig |= KB_SUN3 - MIN_KEYTYPE; /* 10 */		break;D 20#endif XWINDOWE 20I 20#endif /* XWINDOW */E 20E 8	default: { char errmsg [ 200 ];		sprintf ( errmsg, "Unsupported keyboard type: %d", type);                printf ( "%s\n", errmsg);                printf ( "Configuring keyboard for type-3\n", errmsg);                SUNLispKeyMap = SUNLispKeyMap_for3;                InterfacePage->devconfig |= KB_SUN3-MIN_KEYTYPE;		break;		}	}}/* end keyboardtype*/D 8E 8E 1