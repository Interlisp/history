h14501s 00001/00001/00083d D 2.10 92/04/21 17:04:22 sybalsky 14 13c shortening file names for DOS \nes 00004/00010/00080d D 2.9 91/01/16 13:21:06 sybalsky 13 12c Make atomcell use new offset names for fields in a new-symbol.es 00037/00000/00053d D 2.8 90/07/26 15:18:38 osamu 12 11c Change for ATOM > 64K. This change works when #ifdef BIGATOMSes 00000/00000/00053d D 2.7 90/04/20 01:21:06 sybalsky 11 10c AIX:  shortening file names, bulk change.es 00023/00015/00030d D 2.6 90/02/19 11:10:35 sybalsky 10 9c check for 386i, add commentses 00011/00011/00034d D 2.5 89/01/09 17:18:44 shih 9 8c spellinges 00004/00009/00041d D 2.4 88/10/12 14:40:30 krivacic 8 7c new out-of-line interfacees 00000/00057/00050d D 2.3 88/10/10 14:04:03 krivacic 7 6c sun3/4 mergees 00006/00000/00101d D 2.2 88/05/27 14:49:27 krivacic 6 5c C_ONLY ifdefes 00000/00000/00101d D 2.1 88/05/17 09:22:17 hayata 5 4c Version up to 2.1es 00000/00000/00101d D 1.4 88/04/22 11:45:00 masinter 4 3c make working consistent with sccses 00023/00000/00078d D 1.3 88/03/18 17:56:44 krivacic 3 2c Added N_OP_atomcelles 00002/00002/00076d D 1.2 88/03/13 14:32:49 hayata 2 1c Add SCCS key id (%Z%)es 00078/00000/00000d D 1.1 88/02/24 16:55:45 hayata 1 0c date and time created 88/02/24 16:55:45 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 9/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 9I 9D 10/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 9static char *id = "%Z% %M%	%I% %G%";E 2/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 9 *	Auther :  Takeshi ShimizuE 9I 9 *	Author :  Takeshi ShimizuE 9 * */E 10I 10/* @(#) atom.c Version 2.5 (1/9/89). copyright envos & Fuji Xerox  */static char *id = "@(#) atom.c	2.5 1/9/89";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 10/**********************************************************************//*D 9 		File Name :	atom.cE 9I 9		File Name :	atom.cE 9		Desc	:	implement opcode ATOMCELL.ND 9  					Date :		Apr 13, 1987 					Edited by :	Naoyuki Mitani E 9I 9					Date :		Apr 13, 1987					Edited by :	Naoyuki MitaniE 9		Including :	OP_atomcellND 9								E 9I 9E 9*//**********************************************************************/#include "lispemul.h"#include "lispmap.h"D 14#include "emulglobal.h"E 14I 14#include "emlglob.h"E 14I 12D 13#ifdef BIGATOMS#define NEWATOM_PNP_OFFSET    0#define NEWATOM_VALS_OFFSET   2#define NEWATOM_DEFS_OFFSET   4#define NEWATOM_PLIS_OFFSET   6#endifE 13E 12I 12#ifndef BIGATOMSE 12D 7/**********************************************************************//*		Func name :	OP_atomcellN				Set the LISP pointer to the property cell 				specified with the contents of TOS .					Date :		Apr 13, 1987					Edited by :	Naoyuki Mitani					Changed by:	Naoyuki Mitani(28-Apr)							take(15-may-87)				****NOTE see lispmap.h****	** ADOPTED NEW VERSION*//**********************************************************************/I 6#ifdef C_ONLYE 6OP_atomcellN(){#ifdef TRACE	printPC();	printf("TRACE: OP_atomcellN()\n");#endif/****	ufn(0301); ***/ if ((TopOfStack & 0xffff0000) != 0){	/* error("OP_aromcellN: Not Atom Pointer"); */	ufn(0301);	return; } switch((Get_BYTE(PC+1))) {	case D_DEFSHI :	TopOfStack = DEFS_OFFSET +((TopOfStack & 0x0ffff) << 1) ;			break;	case D_VALSHI :	TopOfStack = VALS_OFFSET + ((TopOfStack & 0x0ffff) << 1) ;			break ;	case D_PLISHI :	TopOfStack = PLIS_OFFSET + ((TopOfStack & 0x0ffff) << 1) ;			break;	case D_PNHI :	TopOfStack = PNP_OFFSET + ((TopOfStack & 0x0ffff) << 1) ;			break ;	default : 	/* error("OP_aromcellN: Not Atom Property"); */ 			ufn(0301);			return ;  }  PC += 2;}I 6#elseE 6E 7I 3D 8N_OP_atomcellN(tos, n, error_addr)E 8I 8N_OP_atomcellN(tos, n)E 8D 10	register int tos;D 8	int n, *error_addr;E 8I 8	int n;E 8{E 10I 10  register int tos;  int n;  {E 10D 8#ifdef TRACE	printPC();	printf("TRACE: N_OP_atomcellN()\n");#endif if ((tos & 0xffff0000) != 0) ERROR_EXIT(error_addr);E 8I 8D 10 if ((tos & 0xffff0000) != 0) ERROR_EXIT(tos);E 10I 10    if ((tos & 0xffff0000) != 0) ERROR_EXIT(tos);E 10E 8D 9 E 9I 9E 9D 10 tos = (tos << 1);E 10I 10   tos = (tos << 1);E 10D 10 switch(n) {E 10I 10    switch(n)      {E 10	case D_DEFSHI :	return(DEFS_OFFSET + tos);	case D_VALSHI :	return(VALS_OFFSET + tos);	case D_PLISHI :	return(PLIS_OFFSET + tos);	case D_PNHI :	return(PNP_OFFSET + tos);D 8	default : 	ERROR_EXIT(error_addr);E 8I 8D 9	default : 	ERROR_EXIT(tos);E 8  } E 9I 9	default :	ERROR_EXIT(tos);D 10  }E 10I 10      }E 10E 9}I 12#elseN_OP_atomcellN(tos, n)  register int tos;  int n;  {   if ((tos & 0xffff0000) == 0){ /* XeroxLisp traditional symbol */     tos = (tos << 1);     switch(n)      {        case D_DEFSHI :	return(DEFS_OFFSET + tos);	case D_VALSHI :	return(VALS_OFFSET + tos);	case D_PLISHI :	return(PLIS_OFFSET + tos);	case D_PNHI :	return(PNP_OFFSET + tos);	default :	ERROR_EXIT(tos);      }   }   else{			/* New Symbol */     switch(n)      {D 13        case D_DEFSHI :	return(NEWATOM_DEFS_OFFSET + tos);	case D_VALSHI :	return(NEWATOM_VALS_OFFSET + tos);	case D_PLISHI :	return(NEWATOM_PLIS_OFFSET + tos);	case D_PNHI :	return(NEWATOM_PNP_OFFSET + tos);E 13I 13        case D_DEFSHI :	return(NEWATOM_DEFN_OFFSET + tos);	case D_VALSHI :	return(NEWATOM_VALUE_OFFSET + tos);	case D_PLISHI :	return(NEWATOM_PLIST_OFFSET + tos);	case D_PNHI :	return(NEWATOM_PNAME_OFFSET + tos);E 13	default :	ERROR_EXIT(tos);      }   } }   #endifE 12I 6D 7#endifE 7E 6E 3E 1