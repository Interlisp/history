h34910s 00003/00000/00196d D 2.2 88/05/27 14:56:25 krivacic 7 6c C_ONLY ifdefes 00000/00000/00196d D 2.1 88/05/17 09:23:37 hayata 6 5c Version up to 2.1es 00000/00000/00196d D 1.5 88/04/20 15:09:22 atty 5 4c MADE no changes, just looked at how the eql opcode was structured.es 00003/00003/00193d D 1.4 88/04/14 11:59:30 krivacic 4 3c fix bug in eqles 00065/00000/00131d D 1.3 88/03/29 18:50:31 krivacic 3 2c New Interfaceses 00002/00002/00129d D 1.2 88/03/13 14:45:02 hayata 2 1c Add SCCS key id (%Z%)es 00131/00000/00000d D 1.1 88/02/24 16:56:26 hayata 1 0c date and time created 88/02/24 16:56:26 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 2/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther :  Takeshi Shimizu * *//**********************************************************************//* 		File Name :	equal.c		Desc	:	implement opcode EQ  					Date :		Apr 13, 1987 					Edited by :	Naoyuki Mitani 		Including :	OP_eq				OP_eqlop							*//**********************************************************************/#include "lispemul.h"#include "lispmap.h"#include "lisptypes.h"#include "lispglobal.h"#include "emulglobal.h"#include "address68k.h"#include "arith.h"I 7#ifdef C_ONLYE 7/**********************************************************************//*		Func name :	OP_eq				Pop the contents of the current evaluation				stack and compare it with previous contents				of TOS . Returns atomT or atomNIL .					Date :		Apr 13, 1987					Edited by :	Naoyuki Mitani*//**********************************************************************/OP_eq(){ register LispPTR temp;#ifdef TRACE	printPC();	printf("TRACE: OP_eq()\n");#endif temp = TopOfStack; PopCStack; if (temp == TopOfStack)	TopOfStack = ATOM_T; else	TopOfStack = NIL_PTR; PC++;} /* OP-eq end *//**********************************************************************//*		Func name :	OP_eqlop			This OPCODE used by both EQL(72Q) and EQUAL(364Q)			Pop the contents of the current evaluation			stack and compare it with previous contents			of TOS . Returns atomT or atomNIL .					Date :		JUL 21, 1987					Edited by :	take*//**********************************************************************/OP_eqlop(){  register LispPTR stkarg ;  register int num1,num2;  register int type1,type2;  LispPTR *fobjptr1,*fobjptr2;  stkarg= *((LispPTR *)(CurrentStackPTR )); /* get arg1 on cstk */  if(stkarg == TopOfStack) goto TRET;  else if(((TopOfStack & 0xFF0000) == S_POSITIVE) ||	((TopOfStack & 0xFF0000) == S_NEGATIVE) ||	((TopOfStack & 0xFF0000) == ATOMS_OFFSET) ||	((TopOfStack & 0xFF0000) == ATOMS_OFFSET) ) 	  goto NILRET;  type1=GetTypeNumber(TopOfStack);  type2=GetTypeNumber(stkarg);  if((type1==TYPE_FIXP) && (type2==TYPE_FIXP))   {	GetNumber(TopOfStack , num1);	GetNumber(stkarg , num2); /* if it calls UFN,return*/   	if(num1==num2)		goto TRET;	else goto NILRET ;   } else if ((type1==TYPE_FLOATP)&&(type2==TYPE_FLOATP))	{		fobjptr1=(LispPTR *)Addr68k_from_LADDR(TopOfStack);		fobjptr2=(LispPTR *)Addr68k_from_LADDR(stkarg);		if(*fobjptr1== *fobjptr2)			goto TRET;		else  goto NILRET;	}	else 	{		ufn(Get_BYTE(PC));		return;	} TRET:	TopOfStack = ATOM_T;	CurrentStackPTR -= 2;	PC++;	return; NILRET: TopOfStack = NIL;	CurrentStackPTR -= 2;	PC++;	return;} /* OP_eqlop end */I 3I 7#elseE 7/**********************************************************************//*		Func name :	N_OP_eqlop			This OPCODE used by both EQL(72Q) and EQUAL(364Q)			Pop the contents of the current evaluation			stack and compare it with previous contents			of TOS . Returns atomT or atomNIL .					Date :		March 21, 198					Edited by :	bk*//**********************************************************************/int N_OP_eqlop(tos_m_1, tos, error_addr)	register LispPTR tos_m_1, tos;	int * error_addr;{  register int num1,num2;  register int type1,type2;  LispPTR *fobjptr1,*fobjptr2;  if(tos_m_1 == tos) goto TRET;  else {register LispPTR tos_type = (tos & 0xff0000);	if((tos_type == S_POSITIVE) ||	(tos_type == S_NEGATIVE) ||	(tos_type == ATOMS_OFFSET) ) 	  goto NILRET;	}  type1=GetTypeNumber(tos);  type2=GetTypeNumber(tos_m_1);  if((type1==TYPE_FIXP) && (type2==TYPE_FIXP))   {D 4	GetNumber(tos , num1);	GetNumber(tos_m_1 , num2); /* if it calls UFN,return*/E 4I 4	N_GETNUMBER(tos , num1, doerror);	N_GETNUMBER(tos_m_1 , num2, doerror); /* if it calls UFN,return*/E 4   	if(num1==num2)		goto TRET;	else goto NILRET ;   } else if ((type1==TYPE_FLOATP)&&(type2==TYPE_FLOATP))	{		fobjptr1=(LispPTR *)Addr68k_from_LADDR(tos);		fobjptr2=(LispPTR *)Addr68k_from_LADDR(tos_m_1);		if(*fobjptr1== *fobjptr2)			goto TRET;		else  goto NILRET;	}	else 	{D 4		ERROR_EXIT(error_addr);E 4I 4doerror:	ERROR_EXIT(error_addr);E 4	} TRET:	return(ATOM_T); NILRET: return(NIL_PTR);} /* N_OP_eqlop end */I 7#endifE 7E 3E 1