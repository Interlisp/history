h02854s 00098/00056/00960d D 2.44 92/11/25 21:13:36 sybalsky 55 54c Fixing endif's with extra text => comment. \nes 00015/00015/01001d D 2.43 92/11/18 17:37:38 sybalsky 54 53c Change "signal" to "sigset" in SYSV signal code, so it's all using 1 set of functions consistently (vs sighold, sigrelse)es 00081/00028/00935d D 2.42 92/06/26 13:50:46 sybalsky 53 52c retrofit of 386 unix changes \nes 00012/00012/00951d D 2.41 92/04/23 10:56:05 sybalsky 52 51c fixing SCCS headers \nes 00004/00004/00959d D 2.40 92/04/21 17:25:39 sybalsky 51 50c shortening file names for DOS \nes 00043/00007/00920d D 2.39 91/10/15 18:27:36 sybalsky 50 49c ISC changeses 00050/00031/00877d D 2.38 91/06/10 12:57:31 sybalsky 49 48c Change RISCOS specifics to SYSVSIGNALS for those that require it, add workaround for HPTIMERBUG.es 00005/00002/00903d D 2.37 91/05/03 14:51:02 sybalsky 48 47c MIPS changeses 00011/00002/00894d D 2.36 91/05/01 18:16:10 sybalsky 47 46c Retrofit changes from MIPS porting center.es 00058/00002/00838d D 2.35 91/04/09 17:12:53 sybalsky 46 45c Retrofit first round of changes from MIPS porting centeres 00012/00006/00828d D 2.34 91/02/04 12:55:28 sybalsky 45 44c Fix errors in teh Savoir retrofit (placement of ifdefs &c)es 00012/00008/00822d D 2.33 91/01/27 12:08:26 sybalsky 44 43c Retrofit HP9000/RS6000 changeses 00004/00002/00826d D 2.32 90/11/20 09:36:14 fuji 43 42c Fix for AR 11300es 00021/00001/00807d D 2.31 90/09/18 23:49:37 sybalsky 42 41c Retrofit changes from AIX, DEC3100, PS/2es 00002/00000/00806d D 2.30 90/07/25 01:01:20 sybalsky 41 40c REmove SIGABRT if compiling for OS3 (not known in that version)es 00042/00011/00764d D 2.29 90/07/18 20:20:37 sybalsky 40 39c Change signal handler to not catch, e.g., SIGINT and SIGPROF, that aren't really errors.es 00126/00050/00649d D 2.28 90/07/04 04:04:44 sybalsky 39 38c Bane change -- handle fatal signals & go to URAID.es 00005/00001/00694d D 2.27 90/06/20 12:39:05 mitani 38 37c remove printf from timeout_errores 00000/00000/00695d D 2.26 90/04/20 01:58:40 sybalsky 37 36c AIX:  shortening file names, bulk change.es 00000/00004/00695d D 2.25 90/04/19 22:48:57 sybalsky 36 35c AIX:  remove SIGPOLL (redundant anyhow)es 00011/00002/00688d D 2.24 90/03/01 13:56:23 osamu 35 34c Mitsunori Matsuda adds XWindow functionality.es 00004/00004/00686d D 2.23 89/12/28 15:29:10 sybalsky 34 33c es 00393/00154/00297d D 2.22 89/12/13 10:58:55 sybalsky 33 32c interrupt-driven etheres 00007/00006/00444d D 2.21 89/03/29 19:46:11 shih 32 31c minor cleanup, also to force recompile (changed FLTINT)es 00048/00060/00402d D 2.20 89/03/23 18:58:13 shih 31 30c cosmetic changeses 00017/00000/00445d D 2.19 89/01/05 14:47:25 hayata 30 29c initilization of gloval var TIMEOUT_TIME is added. It can be settable by LDEFILETIMEOUTes 00002/00002/00443d D 2.18 88/11/30 14:10:21 hayata 29 28c update SCCS headeres 00001/00001/00444d D 2.17 88/11/30 14:08:42 hayata 28 27c To avoid signal of file system full, mask SIGXFSZ before fork_UNIXes 00040/00003/00405d D 2.16 88/11/15 17:27:01 hayata 27 26c To fix "connection timeout" problem, sigvec is used to initilize SIGALRM.es 00005/00000/00403d D 2.15 88/11/09 13:24:58 bane 26 25c Added APOLLO ifdefes 00011/00002/00392d D 2.14 88/10/18 15:01:20 krivacic 25 24c remove warning messagees 00001/00005/00393d D 2.13 88/10/18 10:17:02 krivacic 24 23c remove spar ifdef in N_OP_rclkes 00007/00002/00391d D 2.12 88/10/12 18:50:00 krivacic 23 22c ifdef on TIMER_INTERFALes 00049/00017/00344d D 2.11 88/10/10 14:10:15 krivacic 22 21c sun3/4 mergees 00023/00032/00338d D 2.10 88/07/05 21:09:23 bane 21 20c removed warnings about signal handler function type mismatches 00023/00040/00333d D 2.9 88/07/05 20:57:42 bane 20 19c Merged Sun4 changes, ifdef'ed error messagees 00019/00041/00332d D 2.8 88/07/05 20:20:42 masinter 19 18c JRB - checking in so I can merge changeses 00006/00000/00367d D 2.7 88/06/30 11:03:04 greep 18 17c put "#ifdef DEBUG" around printfses 00008/00003/00359d D 2.6 88/06/24 23:06:16 bane 17 16c Added KB interrupt code and KBINT ifdefses 00004/00002/00358d D 2.5 88/06/24 13:33:06 bane 16 15c Added KBINT ifdef for keyboard signal handlinges 00001/00001/00359d D 2.4 88/06/21 14:05:45 masinter 15 14c update MiscStats->secondstmp too since LLKEY handler did it and it is used by trackcursores 00013/00018/00347d D 2.3 88/06/20 22:01:15 shimizu 14 13c getsignaldata makes INTIO driven ,But halfwayes 00012/00011/00353d D 2.2 88/05/31 20:14:07 masinter 13 12c part of turning off I/O interrupts. update_timer doesn't call getsignaldata, its called inlinees 00000/00000/00364d D 2.1 88/05/17 09:27:06 hayata 12 11c Version up to 2.1es 00012/00007/00352d D 1.11 88/05/10 19:42:38 krivacic 11 10c new Irq_Stk_Check, Irq_Stk_Endes 00140/00049/00219d D 1.10 88/05/04 18:13:18 masinter 10 9c new timeres 00021/00002/00247d D 1.9 88/04/28 14:52:27 krivacic 9 8c hack to get timer on/off working againes 00078/00016/00171d D 1.8 88/04/27 09:17:26 bane 8 7c Added I/O interrupt handling codees 00019/00001/00168d D 1.7 88/04/25 12:34:12 bane 7 6c Added int_timer_off() and int_timer_on()es 00007/00009/00162d D 1.6 88/04/24 23:29:32 bane 6 5c REALLY using alarm timer for interrupts now...es 00002/00002/00169d D 1.5 88/04/15 11:47:16 bane 5 4c Changed type of signal handling function to shut compiler up.es 00052/00000/00119d D 1.4 88/03/15 17:17:23 bane 4 3c Added timer interrupt code; running at 40 Hz virtual time.es 00028/00000/00091d D 1.3 88/03/31 12:47:40 krivacic 3 2c new interfacees 00002/00002/00089d D 1.2 88/03/13 15:08:08 hayata 2 1c Add SCCS key id (%Z%)es 00091/00000/00000d D 1.1 88/02/24 16:58:43 hayata 1 0c date and time created 88/02/24 16:58:43 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 6/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 6I 6D 10/* This is G-file @(#) timer.c Version 1.5 (4/15/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) timer.c	1.5 4/15/88";E 10I 10D 19D 20/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 20I 20D 29/* This is G-file @(#) timer.c Version 2.7 (6/30/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) timer.c	2.7 6/30/88";E 29I 29D 31/* This is G-file %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 31I 31D 34/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 31static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 34I 34D 35/* @(#) timer.c Version 2.21 (3/29/89). copyright envos & Fuji Xerox  */static char *id = "@(#) timer.c	2.21 3/29/89		(envos & Fuji Xerox)";E 35I 35D 39/* @(#) timer.c Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 39I 39D 43/* @(#) timer.c Version %I% (%G%). copyright Venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(Venue & Fuji Xerox)";E 43I 43D 44/* @(#) timer.c Version 2.31 (9/18/90). copyright Venue & Fuji Xerox  */static char *id = "@(#) timer.c	2.31 9/18/90		(Venue & Fuji Xerox)";E 44I 44/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 44E 43E 39E 35E 34E 29E 20E 19I 19D 21/* This is G-file @(#) timer.c Version 2.7 (6/30/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) timer.c	2.7 6/30/88";E 21E 19E 10E 6E 2D 33/********************************************************************** *	timer.c *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. **********************************************************************/E 33I 33/************************************************************************//*									*//*				t i m e r . c				*//*									*//*	Timer handling routines, plus set-up for the other interrupts	*//*	Medley uses on Unix.						*//*									*/I 52/************************************************************************//************************************************************************/E 52/*									*/I 39D 52/*	Copyright 1987-1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 52I 52/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 52E 39/*									*/I 39D 52/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 52I 52/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 52E 39/*									*/D 34/*	COPYRIGHT (C) 1987, 1989 by Fuji Xerox Co., Ltd.		*//*				    and John Sybalsky.			*/E 34I 34D 39/*	COPYRIGHT (C) 1987, 1989 by Fuji Xerox Co., Ltd.,		*//*				    Venue, and Xerox Corp.		*/E 34/*		  All Rights Reserved.					*//*									*//*									*//*									*/E 39/************************************************************************/E 33I 33I 39E 39E 33#include	<sys/time.h>I 8#include	<sys/types.h>E 8#include	<stdio.h>I 4#include	<signal.h>I 8#include	<fcntl.h>I 53E 53I 50#ifdef ISC#include	<sys/bsdtypes.h>#include	<stropts.h>#include	<sys/ioctl.h>I 53#include	<sys/times.h>E 53#define SIGIO SIGPOLLI 53extern long timezone;	/* seconds difference GMT to local */E 53#elseE 50I 10#include	<sys/resource.h>I 50D 55#endif ISCE 55I 55#endif /* ISC */E 55E 50E 10E 8E 4D 27E 27I 27#include	<setjmp.h>I 42#ifdef AIXPS2#include	<sys/fpcontrol.h>D 55#endif AIXPS2E 55I 55#endif /* AIXPS2 */E 55I 55E 55E 42E 27I 26/* Apollo and Sun have different ideas about the name of this field */#ifdef APOLLO#define sv_flags sv_onstack#endifE 26#include	"lispemul.h"D 51#include	"emulglobal.h"#include	"lispglobal.h"#include	"address68k.h"I 10#include	"lisptypes.h"E 51I 51#include	"emlglob.h"#include	"lspglob.h"#include	"adr68k.h"#include	"lsptypes.h"E 51#include	"arith.h"#include	"lispmap.h"I 11#include	"stack.h"I 31#include	"dbprint.h"E 31E 11E 10#define	LISP_UNIX_TIME_DIFF	29969152#define	LISP_ALTO_TIME_MASK	0x80000000D 10/* *	Interlisp begins at	"19-Jan-69 12:14:08 JST"E 10I 10#define UNIX_ALTO_TIME_DIFF	2177452800/*	Interlisp time is signed; MIN.FIXP = "01-JAN-01 00:00:00 GMT" *	Interlisp 0 is at	"19-Jan-69 12:14:08 PST"E 10 *	Unix begins at		" 1-Jan-70  0:00:00 GMT" *	(CL:- (IL:IDATE	" 1-Jan-70  0:00:00 GMT")D 10 *			"19-Jan-69 12:14:08 JST")) *	=> 29969152E 10I 10 *	      (IL:IDATE "19-Jan-69 12:14:08 PST")) *	=> 29969152, amount to add to Lisp time to get Unix time *	Alto time is unsigned; 0 = "01-JAN-01 00:00:00 GMT" *      UNIX_ALTO_TIME_DIFF is amount to add to Unix time *	to get Alto time.E 10 */I 30int	TIMEOUT_TIME;	/* For file system timeout */char	*getenv();I 35#ifdef XWINDOW#define FALSE 0#define TRUE  !FALSEint Event_Req = FALSE;I 50extern int Xfd;E 50D 55#endif XWINDOWE 55I 55#endif /* XWINDOW */E 55E 35I 55#define ERRCHK(expr, str) if (expr == -1) perror(str)#define SIGERRCHK(set, str) if (set == SIG_ERR) perror(str)E 55E 30D 33/**********************************************************************D 10 *	OP_rclk *	entry	RCLK	OPCODE[167] *	Get unix time and set microseconds timeE 10I 10	init_miscstats()E 33I 33/************************************************************************//*									*//*			i n i t _ m i s c s t a t s			*//*									*//*	Called at initialization time to set miscstats words.		*//*	?? and to periodically update them ?? [JDS 11/22/89]		*//*									*//*									*//************************************************************************/E 33E 10D 10	** ADOPTED NEW VERSIONE 10I 10D 31	called at initialization time to set E 31I 31D 33	called at initialization time to setE 31	miscstats words and periodically to update them**********************************************************************/E 33init_miscstats()D 33{E 33I 33  {    MiscStats->starttime = gettime(0);    MiscStats->gctime = 0;    update_miscstats();  }E 33E 10D 10 **********************************************************************/#ifdef DEBUG LispPTR D_time=0;OP_rclk() { *((int*)Addr68k_from_LADDR(TopOfStack)) =D_time += 10000;  PC++; }#else/*******	changed : Code form Larry's mail dated Dec 31 1987.*********/OP_rclk()E 10I 10D 33	MiscStats->starttime = gettime(0);	MiscStats->gctime = 0;	update_miscstats();E 33D 33}E 33D 33/* update_miscstats()E 33I 33/************************************************************************//*									*//*		    u p d a t e _ m i s c s t a t s			*//*									*//*	Updates counters and timers in the MISCSTATS "page".		*//*									*//*									*//*									*//************************************************************************/E 33D 31	updates counters and timers in the miscstats page E 31I 31D 33	updates counters and timers in the miscstats pageE 31*/E 33update_miscstats()E 10D 33{I 10	struct rusage ru;	struct timeval time;E 33I 33  {I 53    struct timeval timev;E 53I 50#ifndef ISCE 50    struct rusage ru;D 53    struct timeval time;E 53E 33D 33	getrusage(RUSAGE_SELF, &ru);E 33I 33    getrusage(RUSAGE_SELF, &ru);E 33D 31	E 31I 31E 31D 32	MiscStats->totaltime	=  ru.ru_utime.tv_sec * 1000D 31				   + ru.ru_utime.tv_usec/1000 ;	MiscStats->swapwaittime = ru.ru_stime.tv_sec * 1000 E 31I 31				   + ru.ru_utime.tv_usec/1000;E 32I 32D 33	MiscStats->totaltime	= ru.ru_utime.tv_sec * 1000				+ ru.ru_utime.tv_usec /1000;E 32	MiscStats->swapwaittime = ru.ru_stime.tv_sec * 1000E 31D 32				   + ru.ru_stime.tv_usec/1000;E 32I 32				+ ru.ru_stime.tv_usec /1000;E 32	MiscStats->pagefaults	= ru.ru_minflt + ru.ru_majflt;	MiscStats->swapwrites	= ru.ru_majflt;	MiscStats->diskiotime	= 0; /* ?? not available ?? */D 31	MiscStats->diskops	= ru.ru_inblock E 31I 31	MiscStats->diskops	= ru.ru_inblockE 31				 /* ?? this doesn't work ???				+ ru.ru_outblock   */E 33I 33    MiscStats->totaltime = ru.ru_utime.tv_sec * 1000			 + ru.ru_utime.tv_usec /1000;    MiscStats->swapwaittime = ru.ru_stime.tv_sec * 1000			    + ru.ru_stime.tv_usec /1000;    MiscStats->pagefaults = ru.ru_minflt + ru.ru_majflt;    MiscStats->swapwrites = ru.ru_majflt;    MiscStats->diskiotime = 0; /* ?? not available ?? */    MiscStats->diskops	= ru.ru_inblock    			 /* ?? this doesn't work ???    			+ ru.ru_outblock   */E 33				;D 33	gettimeofday(&time, NULL);	MiscStats->secondstmp =D 31	MiscStats->secondsclock =    	   (time.tv_sec + UNIX_ALTO_TIME_DIFF);	E 31I 31	MiscStats->secondsclock =	   (time.tv_sec + UNIX_ALTO_TIME_DIFF);E 33I 33D 53    gettimeofday(&time, NULL);E 53I 53    gettimeofday(&timev, NULL);E 53    MiscStats->secondstmp =D 53    MiscStats->secondsclock = (time.tv_sec + UNIX_ALTO_TIME_DIFF);E 53I 53    MiscStats->secondsclock = (timev.tv_sec + UNIX_ALTO_TIME_DIFF);#else    struct tms ru;    times(&ru);	/* Get system time used */    MiscStats->totaltime = ru.tms_utime*10 + ru.tms_stime*10			 + ru.tms_cutime*10 + ru.tms_cstime*10;  MiscStats->swapwaittime = ru.tms_stime*10	    + ru.tms_cstime*10;    MiscStats->pagefaults = 0;  /* can't tell this on ISC */    MiscStats->swapwrites = 0;    MiscStats->diskiotime = 0; /* ?? not available ?? */    MiscStats->diskops	= 0;    MiscStats->secondstmp =    	MiscStats->secondsclock = (time(0) + UNIX_ALTO_TIME_DIFF);  E 53E 33D 50E 50I 50D 55#endif ISCE 55I 55#endif /* ISC */E 55E 50I 33  }/************************************************************************//*									*//*			s u b r _ g e t t i m e				*//*									*//*	Handler for Lisps GETTIME subr call, dispatched thru		*//*	subr.c/miscn.c sub-dispatch.					*//*									*//*	Calls gettime, and returns the result to Lisp as a SMALLP	*//*	or FIXP, as appropriate.					*//*									*//************************************************************************/DLword	*createcell68k();LispPTR subr_gettime(args)  LispPTR	args[];  {    int result;    result = gettime(args[0] & 0xffff);    if (args[1])      {	*((int*)Addr68k_from_LADDR(args[1]) ) = result;	return (args[1]);      }    else N_ARITH_SWITCH(result);E 33E 31}I 33/************************************************************************//*									*//*		    		g e t t i m e				*//*									*//*	Get the value of one of the various time counters, as		*//*	specified by the argument casep.  casep's values & meanings:	*//*									*//*	0 elapsed time, in milliseconds.				*//*	1 start of elapsed-time period, in milliseconds			*//*	2 this process's run time, in milliseconds			*//*	3 total GC time, in milliseconds				*//*	4 current time-of-day, in ALTO format				*//*	5 current time-of-day, in Interlisp format			*//*	6 start of daylight-savings, as day-in-year			*//*	7 end of daylight-savings, as day-in-year			*//*	8 time zone, as hours of offset from GMT (whole hours only)	*//*									*//************************************************************************/E 33int gettime(casep)D 33int casep;{E 10struct	timeval	time;D 10unsigned int	usec;E 10I 10struct	timezone tz;	switch (casep) {E 33I 33    int casep;  {D 53    struct	timeval	time;E 53I 53    struct	timeval	timev;E 53    struct	timezone tz;    switch (casep)      {E 33E 10I 10D 33case 0: /* elapsed time in alto milliseconds */E 10	gettimeofday(&time, NULL);D 10	usec = (time.tv_sec * 1000000) + time.tv_usec;#ifdef	SPARC	*(short *)Addr68k_from_LADDR(TopOfStack) = usec >> 16;	*((short *)Addr68k_from_LADDR(TopOfStack)+2) = usec & 0xFFFF;#else	*((unsigned int *)(Addr68k_from_LADDR(TopOfStack))) = usec;#endif	++PC;} /* end OP_rclk */#endifE 10I 10	return((time.tv_sec + UNIX_ALTO_TIME_DIFF)*1000 + time.tv_usec/1000);E 33I 33	case 0: /* elapsed time in alto milliseconds */D 53		gettimeofday(&time, NULL);		return((time.tv_sec + UNIX_ALTO_TIME_DIFF)*1000				    + time.tv_usec/1000);E 53I 53		gettimeofday(&timev, NULL);		return((timev.tv_sec + UNIX_ALTO_TIME_DIFF)*1000				    + timev.tv_usec/1000);E 53E 33D 33case 1: /* starting elapsed time in milliseconds */	return(MiscStats->starttime);E 33I 33	case 1: /* starting elapsed time in milliseconds */		return(MiscStats->starttime);E 33D 33case 2: /* run time, this process, in milliseconds */	update_miscstats();D 31	return(MiscStats->totaltime); E 31I 31	return(MiscStats->totaltime);E 33I 33	case 2: /* run time, this process, in milliseconds */		update_miscstats();		return(MiscStats->totaltime);E 33E 31D 33case 3: /* total GC time in milliseconds */	return(MiscStats->gctime);E 33I 33	case 3: /* total GC time in milliseconds */		return(MiscStats->gctime);E 33D 33case 4: /* current time of day in Alto format */	gettimeofday(&time, NULL);	return (time.tv_sec + UNIX_ALTO_TIME_DIFF);E 33I 33	case 4: /* current time of day in Alto format */D 53		gettimeofday(&time, NULL);		return (time.tv_sec + UNIX_ALTO_TIME_DIFF);E 53I 53#ifdef ISC	    return(time(0) + UNIX_ALTO_TIME_DIFF);#else		gettimeofday(&timev, NULL);		return (timev.tv_sec + UNIX_ALTO_TIME_DIFF);#endifE 53E 33D 33case 5:	/* current time of day in Interlisp format */	gettimeofday(&time, NULL);	return(time.tv_sec + LISP_UNIX_TIME_DIFF);E 33I 33	case 5:	/* current time of day in Interlisp format */D 53		gettimeofday(&time, NULL);		return(time.tv_sec + LISP_UNIX_TIME_DIFF);E 53I 53#ifdef ISC	    return(time(0) + LISP_UNIX_TIME_DIFF);#else		gettimeofday(&timev, NULL);		return(timev.tv_sec + LISP_UNIX_TIME_DIFF);#endifE 53E 33D 33case 6: gettimeofday(&time, &tz);	return (98); /* this is wrong, only works in PST */E 33I 33D 53	case 6: gettimeofday(&time, &tz);E 53I 53	case 6: gettimeofday(&timev, &tz);E 53		return (98); /* this is wrong, only works in PST */E 33D 33case 7: gettimeofday(&time, &tz);	return (305); /* this is wrong, only works in PST */E 33I 33D 53	case 7: gettimeofday(&time, &tz);E 53I 53	case 7: gettimeofday(&timev, &tz);E 53		return (305); /* this is wrong, only works in PST */E 33D 33case 8: gettimeofday(&time, &tz);	return (tz.tz_minuteswest/60); /* only integral timezones supported */E 33I 33D 53	case 8: gettimeofday(&time, &tz);E 53I 53	case 8: gettimeofday(&timev, &tz);#ifndef ISCE 53		return (tz.tz_minuteswest/60); /* only integral timezones work */I 53#else		return (timezone/3600);	/* timezone, extern, is #secs diff GMT to local. */#endifE 53E 33D 33default:	return (0);}}E 33I 33	default: return (0);      }  }E 33E 10D 33/**********************************************************************D 10 *	subr_gettime(args) *	Get unix time and set alto seconds timeE 10I 10*	subr_gettime(args)E 10 **********************************************************************/D 10subr_gettime(args)E 10I 10DLword	*createcell68k();E 33D 33LispPTR subr_gettime(args)E 10LispPTR	args[];{D 10	struct	timeval	time;#ifdef DEBUG	D_time += 100000;	*((int*)Addr68k_from_LADDR(args[0])) = LISP_ALTO_TIME_MASK ^ (D_time + LISP_UNIX_TIME_DIFF);#else	gettimeofday(&time, NULL);	*((int*)Addr68k_from_LADDR(args[0])) = LISP_ALTO_TIME_MASK ^ (time.tv_sec + LISP_UNIX_TIME_DIFF);#endifE 10I 10int result;	result = gettime(args[0] & 0xffff);	if (args[1])	 {D 31	 *((int*)Addr68k_from_LADDR(args[1]) ) = result; E 31I 31	 *((int*)Addr68k_from_LADDR(args[1]) ) = result;E 31	  return (args[1]); }	else	  N_ARITH_SWITCH(result);D 31} E 31I 31}E 33E 31E 10D 10} /* end subr_gettime */E 10D 33/********************************************************************** *	subr_settime() *	Get alto seconds time and set unix time *	You must be superuser **********************************************************************/E 33I 33/************************************************************************//*									*//*			s u b r _ s e t t i m e				*//*									*//*	Converts its argument, a time in ALTO seconds, to the		*//*	UNIX time format, and sets the UNIX clock.  You must be		*//*	the super-user for this to work.				*//*									*//*	Implements the SETTIME subr call, sub-dispatched from subr.c	*//*									*//************************************************************************/E 33subr_settime(args)D 33LispPTR	args[];{	struct timeval time;D 10	time.tv_sec = (LISP_ALTO_TIME_MASK ^ *((int*)Addr68k_from_LADDR(args[0]))) - LISP_UNIX_TIME_DIFF;E 10I 10D 31	time.tv_sec = *((int*)Addr68k_from_LADDR(args[0])) E 31I 31	time.tv_sec = *((int*)Addr68k_from_LADDR(args[0]))E 31			- UNIX_ALTO_TIME_DIFF;E 10	settimeofday(&time, NULL);} /* end subr_settime */E 33I 33  LispPTR	args[];  {I 46D 50#ifdef RISCOSE 50I 50#ifdef SYSVONLYE 50    stime(*((int*)Addr68k_from_LADDR(args[0]))                - UNIX_ALTO_TIME_DIFF);#elseE 46D 53    struct timeval time;    time.tv_sec = *((int*)Addr68k_from_LADDR(args[0]))E 53I 53    struct timeval timev;    timev.tv_sec = *((int*)Addr68k_from_LADDR(args[0]))E 53    		- UNIX_ALTO_TIME_DIFF;D 53    settimeofday(&time, NULL);E 53I 53    settimeofday(&timev, NULL);E 53I 46D 50#endif RISCOSE 50I 50D 55#endif SYSVONLYE 55I 55#endif /* SYSVONLY */E 55E 50E 46  } /* end subr_settime */E 33I 3I 33/************************************************************************//*									*//*		    s u b r _ c o p y t i m e s t a t s			*//*									*//*	Given source and destination MISCSTATS structure pointers,	*//*	copy the contents of the source structure into the dest.	*//*									*//*	Also calls update_miscstats, to keep stats current.		*//*									*//************************************************************************/E 33I 10subr_copytimestats(args)D 33LispPTR args[];{   MISCSTATS *source;E 33I 33  LispPTR args[]; {    MISCSTATS *source;E 33    MISCSTATS *dest;D 33	source = (MISCSTATS*) Addr68k_from_LADDR(args[0]);D 32	dest = (MISCSTATS*) Addr68k_from_LADDR(args[1]);E 32I 32	dest   = (MISCSTATS*) Addr68k_from_LADDR(args[1]);E 33I 33    source = (MISCSTATS*) Addr68k_from_LADDR(args[0]);    dest   = (MISCSTATS*) Addr68k_from_LADDR(args[1]);E 33E 32    update_miscstats();D 22    dest->starttime = source->starttime;    dest->totaltime = source->totaltime;    dest->swapwaittime = source->swapwaittime;    dest->pagefaults = source->pagefaults;    dest->swapwrites = source->swapwrites;    dest->diskiotime = source->diskiotime;    dest->diskops = source->diskops;    dest->gctime = source->gctime;    dest->netiotime = source->netiotime;E 22I 22    *dest = *source;I 33  }E 33E 22E 10I 10D 33}E 33E 10D 33/********************************************************************** *	N_OP_rclk *	entry	RCLK	OPCODE[167] *	Get unix time and set microseconds timeD 22	** ADOPTED NEW VERSIONE 22 **********************************************************************/E 33I 33/************************************************************************//*									*//*			     N _ O P _ r c l k				*//*									*//*	Get the current time in UNIX format, convert it to micro-	*//*	seconds in ALTO format, and store the low 32 bits into		*//*	the FIXP cell passed in to us on the top of stack.		*//*									*//************************************************************************/E 33LispPTR N_OP_rclk(tos)D 33	register LispPTR tos;{struct	timeval	time;unsigned int	usec;E 33I 33  register LispPTR tos;  {D 53    struct	timeval	time;E 53I 53    struct	timeval	timev;E 53    unsigned int	usec;E 33D 33	gettimeofday(&time, NULL);	usec = (time.tv_sec * 1000000) + time.tv_usec;D 19D 20#ifdef	sparcE 20I 20D 21#ifdef sparcE 20	*(short *)Addr68k_from_LADDR(tos) = usec >> 16;	*((short *)Addr68k_from_LADDR(tos)+2) = usec & 0xFFFF;#elseE 19I 19	if (tos & 1) {error("rclk not aligned");}E 21I 21D 24#ifdef	sparc	*(short *)Addr68k_from_LADDR(tos) = usec >> 16;	*((short *)Addr68k_from_LADDR(tos)+2) = usec & 0xFFFF;#elseE 24E 21E 19	*((unsigned int *)(Addr68k_from_LADDR(tos))) = usec;I 21D 24#endifE 24E 21D 19#endifE 19	return(tos);} /* end N_OP_rclk */E 33I 33D 53    gettimeofday(&time, NULL);    usec = (time.tv_sec * 1000000) + time.tv_usec;E 53I 53    gettimeofday(&timev, NULL);    usec = (timev.tv_sec * 1000000) + timev.tv_usec;E 53    *((unsigned int *)(Addr68k_from_LADDR(tos))) = usec;    return(tos);  } /* end N_OP_rclk */E 33I 24I 33E 33E 24I 10/**********************************************************************/ /* update_timer called periodically */I 33/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 33update_timer()D 31 {  	struct  timeval time;E 31I 31D 33 {	struct  timeval time;E 31D 13	getsignaldata();E 13        gettimeofday(&time, NIL);D 15	MiscStats->secondsclock = E 15I 15D 31	MiscStats->secondstmp = MiscStats->secondsclock = E 15   	   (time.tv_sec + UNIX_ALTO_TIME_DIFF);E 31I 31	MiscStats->secondstmp = MiscStats->secondsclock =	   (time.tv_sec + UNIX_ALTO_TIME_DIFF);E 33I 33  {D 53    struct  timeval time;    gettimeofday(&time, NIL);E 53I 53    struct  timeval timev;    gettimeofday(&timev, NIL);E 53    MiscStats->secondstmp = MiscStats->secondsclockD 53			  = (time.tv_sec + UNIX_ALTO_TIME_DIFF);E 53I 53			  = (timev.tv_sec + UNIX_ALTO_TIME_DIFF);E 53E 33E 31  }E 10D 10 E 10I 10I 33/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 33E 10I 4/**********************************************************************//* timer interrupt handling systemD 8	int_timer_init() should be called before first entering dispatch loop.	int_timer_service() catches the signal and sets LoopCounter to 0E 8I 8	int_init() should be called before first entering dispatch loop.	int_timer_init() is called by int_init() and arms the timer interrupt.	int_io_init() is called by int_init() and arms the I/O interrupt.D 11	int_timer_service() catches the timer signal and sets LoopCounter to 0E 11I 11D 31	int_timer_service() catches the timer signal and sets E 31I 31	int_timer_service() catches the timer signal and setsE 31		Irq_Stk_Check & Irq_Stk_End to 0E 11E 8		so the rest of the system will see it and respond.D 8	This will eventuallu get replaced with a slick assembler hack to getE 8I 8D 11	int_io_service() catches the I/O signal and sets LoopCounter to 0E 11I 11D 20	int_io_service() catches the I/O signal and sets 		Irq_Stk_Check & Irq_Stk_End to 0E 11		so the rest of the system will see it and respond, and sets		FileIOFlags so getsignaldata() will see it.E 20	int_block() and int_unblock() block timer interrupts  and release them.	int_io_open(fd) should be called whenever a file that should interrupt		us is opened; it enables the interrupt on that fd.	int_io_close(fd) should be called whenever a file that should interrupt		us is closed; it disables the interrupt on that fd.D 19D 20	This shoild get replaced with a slick assembler hack to getE 8		rid of CHECK_INTERRUPT altogether.E 20E 19*/D 22/* 25000 usec ~ 40 per second.  This should live in some machine-configurationE 22I 22D 23/* 50000 usec ~ 20  per second.  This should live in some machine-configurationE 23I 23D 31/* TIMER_INTERVAL usec ~ 20  per second.  This should live in some E 31I 31/* TIMER_INTERVAL usec ~ 20  per second.  This should live in someE 31	machine-configurationE 23E 22D 6	file somewhere */E 6I 6D 21	file somewhere - it can be changed as the third parameter to lisp*/E 21I 21	file somewhere - it can be changed as the -t parameter to lisp*/E 21E 6D 5#define TIMER_INTERVAL 25000E 5I 5D 22int TIMER_INTERVAL =  25000;E 5	D 11extern int LoopCounter;E 11I 11extern int Irq_Stk_Check, Irq_Stk_End;E 22I 22D 23int TIMER_INTERVAL =  50000;E 23I 23#ifdef sparcint TIMER_INTERVAL =  100000;#elseint TIMER_INTERVAL =  25000;#endifE 23E 22E 11I 8int FileIOFlag = 0;I 13int TimerFlag = 0;E 13D 22extern int TTY_Fd, RS232C_Fd, ether_fd;E 22extern u_int LispWindowFd;E 8I 33/************************************************************************//*									*/I 49/*		    i n t _ t i m e r _ s e r v i c e			*/E 49/*									*/I 49/*	Handle the virtual-time alarm signal VTALRM.  If running in	*//*	HPUX, re-set the alarm ourselves, because the OS walks on	*//*	your timer if you let IT do the resetting.			*/E 49/*									*//*									*/D 49/*									*//*									*//*									*//*									*/E 49/************************************************************************/I 49#ifndef SYSVSIGNALSstatic struct sigvec timerv;D 55#endif SYSVSIGNALSE 55I 55#endif /* SYSVSIGNALS */E 55E 49I 55E 55E 33D 5void int_timer_service(sig, code, scp)E 5I 5D 19D 20int_timer_service(sig, code, scp)E 20I 20D 21void int_timer_service(sig, code, scp)E 20E 19I 19void int_timer_service(sig, code, scp)E 21I 21D 25int_timer_service(sig, code, scp)E 25I 25D 47#ifdef OS4E 47I 47D 50#if (defined(OS4) || defined(RISCOS))E 50I 50#if (defined(OS4) || defined(SYSVONLY))E 50E 47void int_timer_service(sig, code, scp)#elseint int_timer_service(sig, code, scp)D 47#endifE 47I 47D 50#endif OS4 | RISCOSE 50I 50D 55#endif OS4 | SYSVONLYE 55I 55#endif /* OS4 | SYSVONLY */E 55E 50E 47I 55E 55E 25E 21E 19E 5int sig, code;struct sigcontext *scp;{/* this may have to do more in the future, like check for nested interrupts,D 8	set a non-zero=>interrupt flag to code for which interrupt wants service,E 8	etc... */D 11	LoopCounter = 0;E 11I 11	Irq_Stk_Check = 0;	Irq_Stk_End = 0;I 13	TimerFlag = 1;I 35#ifdef XWINDOW	Event_Req = TRUE;#endifI 48D 49#ifdef RISCOSE 49I 49#ifdef HPTIMERBUG      {struct itimerval timert, tmpt;	timert.it_interval.tv_sec  = timert.it_value.tv_sec = 0;	timert.it_interval.tv_usec = 0;	timert.it_value.tv_usec = TIMER_INTERVAL;	setitimer(ITIMER_VIRTUAL, &timert, 0);      }D 55#endif HPTIMERBUGE 55I 55#endif /* HPTIMERBUG */E 55I 55E 55#ifdef SYSVSIGNALSI 50#ifndef ISCE 50E 49D 54    signal(SIGVTALRM, int_timer_service);E 54I 54/*    sigset(SIGVTALRM, int_timer_service); */E 54I 50D 55#endif ISCE 50D 49#endif RISCOSE 49I 49#endif SYSVSIGNALSE 55I 55#endif /* ISC */#endif /* SYSVSIGNALS */E 55E 49E 48E 35E 13E 11}D 14I 7D 8struct sigvec timerv, timeroffv;E 8I 8int_io_service(sig, code, scp)E 14I 14D 19D 20/*OBSOLATE -> getsignaldata *//**int_io_service(sig, code, scp)E 14int sig, code;struct sigcontext *scp;{D 13/* FileIOFlag counts I/O interrupts; next hack is to change sense ofD 11	LoopCounter and use it as interrupt flag */E 11I 11	Irq_Stk_Check, Irq_Stk_End and use it as interrupt flag */E 13I 13D 14/*  signal that there's some input to handle */E 14I 14##  signal that there's some input to handle *##E 20E 19E 14E 13E 11E 8I 33I 50E 50/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/D 46E 46I 46D 49#ifndef RISCOSE 46E 33I 8D 11	LoopCounter = 0;E 11I 11D 19D 20	Irq_Stk_Check = 0;	Irq_Stk_End = 0;E 11	FileIOFlag++;D 14}E 14I 14}***/E 14E 20E 19I 9static struct sigvec timerv;I 46#endif RISCOSE 49E 46E 9E 8E 7void int_timer_init(){I 50D 55#ifndef ISCE 55I 55#ifdef SIGVTALRME 55E 50D 7static struct sigvec timerv, tmpv;E 7I 7D 8static struct sigvec tmpv;E 7static struct itimerval timert, tmpt;E 8I 8struct itimerval timert, tmpt;D 9static struct sigvec timerv;E 9E 8D 19D 20E 20I 20D 21   if (TIMER_INTERVAL != 0) {E 20E 19I 19   if (TIMER_INTERVAL != 0) {E 21I 21I 46D 49#ifdef RISCOSE 49I 49#ifdef SYSVSIGNALSE 49D 54	signal(SIGVTALRM, int_timer_service);E 54I 54D 55	sigset(SIGVTALRM, int_timer_service);E 55I 55	SIGERRCHK(sigset(SIGVTALRM, int_timer_service), "sigset vtalrm");E 55E 54#elseE 46E 21E 19D 6/* warn of what's coming... */	printf("Starting timer interrupt...\n");E 6/* first set up the signal handler */	timerv.sv_handler = int_timer_service;	timerv.sv_mask = timerv.sv_flags = 0;D 8	sigvec(SIGVTALRM, &timerv, &tmpv);E 8I 8	sigvec(SIGVTALRM, &timerv, 0);I 46D 49#endif RISCOSE 49I 49D 55#endif SYSVSIGNALSE 55I 55#endif /* SYSVSIGNALS */E 55E 49E 46E 8I 55E 55/* then attach a timer to it and turn it loose */I 49#ifdef HPTIMERBUG	/* HPUX on the series 700 trashes the timer if you use */	/* the auto-reset feature (interval != 0), so have to  */	/* move the reset into the timer handler (above).      */E 49D 6	timert.it_interval.tv_sec = 0;	timert.it_interval.tv_usec = TIMER_INTERVAL;	timerclear(&timert.it_value);E 6I 6D 31	timert.it_interval.tv_sec = timert.it_value.tv_sec = 0;E 31I 31	timert.it_interval.tv_sec  = timert.it_value.tv_sec = 0;I 49	timert.it_interval.tv_usec = 0;	timert.it_value.tv_usec = TIMER_INTERVAL;#else	timert.it_interval.tv_sec  = timert.it_value.tv_sec = 0;E 49E 31	timert.it_interval.tv_usec = timert.it_value.tv_usec = TIMER_INTERVAL;I 49D 55#endif HPTIMERBUGE 55I 55#endif /* HPTIMERBUG */E 55E 49E 6	timerclear(&tmpt.it_value);	timerclear(&tmpt.it_interval);D 11	LoopCounter = 1;	/* as long as it's not zero... */E 11I 11D 13	CLR_IRQ;E 13E 11	setitimer(ITIMER_VIRTUAL, &timert, &tmpt);I 6	getitimer(ITIMER_VIRTUAL, &tmpt);I 18D 31#ifdef  DEBUGE 18	printf("Timer interval set to %d usec\n", timert.it_value.tv_usec);I 18#endifE 31I 31	DBPRINT(("Timer interval set to %d usec\n", timert.it_value.tv_usec));I 50D 55#endif ISCE 55I 55#endif /* SIGVTALRM */E 55E 50E 31E 18I 7D 19D 20}E 20I 20D 21} }E 20E 19I 19} }E 21I 21}E 21E 19I 50E 50I 33/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 33D 8void int_timer_off()E 8I 8void int_io_open(fd)int fd;E 8{I 13D 14/*	no io interrupts nowE 13D 8struct sigvec tmpv;E 8I 8	fcntl(fd, F_SETOWN, getpid());	fcntl(fd, F_SETFL, fcntl (fd, F_GETFL, 0) | FASYNC);I 13*/E 14I 14D 17/**	if(fcntl(fd, F_SETOWN, getpid()) == -1 )E 17I 17#ifdef KBINTI 18D 31#ifdef  DEBUGE 18	printf("int_io_opening %d\n", fd);I 18#endifE 18	if(fcntl(fd, F_SETOWN, getpid()) == -1 )E 31I 31	DBPRINT(("int_io_opening %d\n", fd));	if(fcntl(fd, F_SETOWN, getpid()) == -1 ) {E 31I 20#ifdef DEBUGE 20E 17		perror("fcntl F_SETOWN ERROR");I 20D 31#else	{};E 31#endifI 31		};E 31E 20	if(fcntl(fd, F_SETFL, fcntl (fd, F_GETFL, 0) | FASYNC) == -1)D 17		perror("fcntl F_SETFL error");**/E 17I 17		perror("fcntl F_SETFL error");#endifE 17E 14E 13}E 8D 8timeroffv.sv_handler = SIG_IGN;timeroffv.sv_mask = timeroffv.sv_flags = 0;sigvec(SIGVTALRM, &timeroffv, &tmpv);E 8I 8void int_io_close(fd)int fd;{I 13D 14/* no io interruptsE 13	fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~FASYNC);I 13*/E 14I 14D 17/*	fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~FASYNC);*/E 17I 17#ifdef KBINT	fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~FASYNC);#endifE 17E 14E 13E 8}I 8D 33void int_io_init()E 33E 8D 8void int_timer_on()E 8D 33{D 8struct sigvec tmpv;E 8I 8static struct sigvec timerv;E 33I 33/************************************************************************//*									*//*			i n t _ i o _ i n i t				*//*									*//*	Set up handling for the SIGIO and SIGPOLL signals, in		*//*	support of keyboard event handling and ethernet incoming-	*//*	packet handling.						*//*									*//*									*//************************************************************************/void int_io_init()  {I 46D 49#ifndef RISCOSE 49I 49#ifndef SYSVSIGNALSE 49E 46    static struct sigvec timerv;    static struct sigvec poll_timerv;I 46D 49#endif RISCOSE 49I 49D 55#endif SYSVSIGNALSE 55I 55#endif /* SYSVSIGNALS */E 55E 49E 46E 33I 14D 19D 20extern getsignaldata();E 20I 20D 21extern void getsignaldata();E 20E 19I 19extern void getsignaldata();E 21I 21D 25extern getsignaldata();E 25I 25D 52#ifdef OS4E 52D 33extern void getsignaldata();E 33I 33    extern void getsignaldata();E 33D 52#elseD 33extern int getsignaldata();E 33I 33    extern int getsignaldata();E 33#endifE 52E 25E 21E 19E 14E 8D 8sigvec(SIGVTALRM, &timerv, &tmpv);E 8I 8D 33/* first set up the signal handler */E 33I 33    /* first set up the signal handler */E 33I 13I 46D 49#ifndef RISCOSE 49I 49#ifndef SYSVSIGNALSE 49E 46D 14/* don't bother, it polls now E 13	timerv.sv_handler = int_io_service;E 14I 14D 16/**	timerv.sv_handler = getsignaldata;E 16I 16#ifdef KBINTD 33	timerv.sv_handler = getsignaldata;E 16E 14	timerv.sv_mask = timerv.sv_flags = 0;	sigvec(SIGIO, &timerv, 0);E 33I 33    timerv.sv_handler = getsignaldata;    timerv.sv_mask = timerv.sv_flags = 0;    sigvec(SIGIO, &timerv, 0); D 36    poll_timerv.sv_handler = getsignaldata;    poll_timerv.sv_mask = poll_timerv.sv_flags = 0;    sigvec(SIGPOLL, &poll_timerv, 0);E 33I 21E 36E 21D 19D 20E 20E 19I 18D 31#ifdef  DEBUGE 18D 13/* then hang the signal on all the open file descriptors that need it *//* this is all done with int_io_open() calls near the actual open() calls...	if(LispWindowFd >= 0) int_io_open(LispWindowFd);	if(ether_fd >= 0) int_io_open(ether_fd);	if(RS232C_Fd >= 0) int_io_open(RS232C_Fd);	if(TTY_Fd >= 0) int_io_open(TTY_Fd);*/E 13D 14	printf("I/O interrupts enabled\n");I 13*/E 14I 14D 16	printf("I/O interrupts enabled\n");**/E 16I 16	printf("I/O interrupts enabled\n");E 31I 31D 33	DBPRINT(("I/O interrupts enabled\n"));E 33I 33    DBPRINT(("I/O interrupts enabled\n"));E 33E 31I 18D 48#endifE 48I 48D 55#endif KBINTE 55I 55#endif /* KBINT */E 55I 53#else /* SYSVSIGNALS in effect... */#ifdef ISC	{	  int res = sigset(SIGIO, getsignaldata);	  if (res==SIG_ERR) perror("sigset for I/O polling");	  if (ioctl(Xfd, I_SETSIG, S_INPUT) < 0) perror("ioctl on X fd - SETSIG");	}E 53E 48I 46#elseD 54    signal(SIGIO, getsignaldata);E 54I 54D 55    sigset(SIGIO, getsignaldata);E 54I 50D 53#ifdef ISC    ioctl(Xfd, I_SETSIG, S_INPUT);E 53#endif ISCE 50D 49#endif RISCOSE 49I 49#endif SYSVSIGNALSE 55I 55    SIGERRCHK(sigset(SIGIO, getsignaldata), "sigset io");#endif /* ISC */E 55E 49I 55#endif /* SYSVSIGNALS */E 55E 46E 18D 31#endifE 31E 16E 14E 13}D 27int oldmask;E 27I 27int oldmask = 0;E 27I 33/************************************************************************//*									*/I 39/*			   i n t _ b l o c k				*/E 39/*									*/I 39/*	Temporarily turn off interrupts.				*/E 39/*									*/I 39/*	NOTE that these interrupts must also be turned off in ldeboot's	*//*	forking code; if you change these, go fix that one too		*/E 39/*									*/D 39/*									*//*									*//*									*//*									*/E 39/************************************************************************/E 33D 19D 20void int_block(){	oldmask = sigblock(SIGVTALRM | SIGIO);}void int_unblock(){D 14	sigsetmask(oldmask);E 14I 14/*	sigsetmask(oldmask);*/E 14}D 9E 9I 9/* **** THESE DIDN't WORK **** E 9int_timer_on() {int_unblock();}int_timer_off() {int_block();}I 9**************************** */E 20E 19D 21void int_timer_off(){struct sigvec tmpv, timeroffv;timeroffv.sv_handler = SIG_IGN;timeroffv.sv_mask = timeroffv.sv_flags = 0;sigvec(SIGVTALRM, &timeroffv, &tmpv);I 20}int oldmask = 0;E 21void int_block(){D 21	oldmask = sigblock(sigmask(SIGVTALRM) | sigmask(SIGIO) | sigmask(SIGALRM));E 21I 21/* temporarily turn off interrupts */I 46D 49#ifdef RISCOSE 49I 49#ifdef SYSVSIGNALSI 50D 55#ifndef ISCE 55I 55#ifdef SIGVTALRME 55E 50E 49    sighold(SIGVTALRM);I 50D 55#endif ISCE 55I 55#endif /* SIGVTALRM */E 55E 50    sighold(SIGIO);    sighold(SIGALRM);I 50D 55#ifndef ISCE 55I 55#ifdef SIGXFSZE 55E 50    sighold(SIGXFSZ);I 50D 55#endif ISCE 55I 55#endif /* SIGXFSZ */E 55E 50#elseE 46D 27	oldmask= sigsetmask(sigmask(SIGVTALRM) | sigmask(SIGIO) | sigmask(SIGALRM));E 27I 27D 28	oldmask= sigblock(sigmask(SIGVTALRM) | sigmask(SIGIO) | sigmask(SIGALRM)E 28I 28D 32	oldmask= sigblock(sigmask(SIGVTALRM) | sigmask(SIGIO) | sigmask(SIGALRM) | sigmask(SIGXFSZ)E 32I 32D 44	oldmask= sigblock(sigmask(SIGVTALRM) | sigmask(SIGIO)  |			  sigmask(SIGALRM)   | sigmask(SIGXFSZ)E 44I 44	oldmask= sigblock(sigmask(SIGVTALRM) | sigmask(SIGIO)			  | sigmask(SIGALRM) #ifndef HPUX			  | sigmask(SIGXFSZ)D 55#endif HPUXE 55I 55#endif /* HPUX */E 55E 44E 32E 28#ifdef FLTINTD 32 | sigmask(SIGFPE)E 32I 32D 44 			| sigmask(SIGFPE)E 44I 44 			  | sigmask(SIGFPE)E 44E 32#endif);I 46D 49#endif RISCOSE 49I 49D 55#endif SYSVSIGNALSE 55I 55#endif /* SYSVSIGNALS */E 55E 49E 46E 27E 21}I 33/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 33void int_unblock(){I 46D 49#ifdef RISCOSE 49I 49#ifdef SYSVSIGNALSI 50D 55#ifndef ISCE 50E 49    sigrelse(SIGVTALRM);I 50#endif ISCE 50    sigrelse(SIGIO);    sigrelse(SIGALRM);I 50#ifndef ISCE 50    sigrelse(SIGXFSZ);I 50#endif ISCE 55I 55#ifdef SIGVTALRM    ERRCHK(sigrelse(SIGVTALRM), "sigrelse vtalrm");#endif /* SIGVTALRM */    ERRCHK(sigrelse(SIGIO), "sigrelse io");    ERRCHK(sigrelse(SIGALRM), "sigrelse alrm");#ifdef SIGXFSZ    ERRCHK(sigrelse(SIGXFSZ), "sigrelse XFSZ");#endif  /* SIGXFSZ */E 55E 50#elseE 46	sigsetmask(oldmask);I 46D 49#endif RISCOSE 49I 49D 55#endif SYSVSIGNALSE 55I 55#endif /* SYSVSIGNALS */E 55E 49I 55E 55E 46E 20}I 21D 31int_timer_on() {int_unblock();}int_timer_off() {int_block();}E 31E 21I 31int_timer_on () {int_unblock();}int_timer_off() {int_block  ();}E 31I 19D 21int oldmask;E 21I 31I 33/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 33E 31D 21void int_block()E 21I 21D 55/*E 55I 55#ifdef NEVERE 55void int_timer_off()E 21{I 46D 49#ifdef RISCOSE 49I 49#ifdef SYSVSIGNALSI 50#ifndef ISCE 50E 49sigignore(SIGVTALRM);I 50D 55#endif ISCE 55I 55#endif /* ISC */E 55E 50#elseE 46D 21	oldmask = sigblock(sigmask(SIGVTALRM) | sigmask(SIGIO) | sigmask(SIGALRM));}E 21I 21struct sigvec tmpv, timeroffv;E 21D 21void int_unblock(){	sigsetmask(oldmask);E 21I 21timeroffv.sv_handler = SIG_IGN;timeroffv.sv_mask = timeroffv.sv_flags = 0;sigvec(SIGVTALRM, &timeroffv, &tmpv);I 46D 49#endif RISCOSE 49I 49D 55#endif SYSVSIGNALSE 55I 55#endif /* SYSVSIGNALS */E 55E 49E 46E 21}E 19void int_timer_on(){I 46D 49#ifdef RISCOSE 49I 49#ifdef SYSVSIGNALSI 50D 55#ifndef ISCE 50E 49D 48    signal(SIGVTALRM, int_timer_handle);E 48I 48D 54    signal(SIGVTALRM, int_timer_service);E 54I 54    sigset(SIGVTALRM, int_timer_service);E 54I 50#endif ISCE 55I 55#ifdef SIGVTALRM    SIGERRCHK(sigset(SIGVTALRM, int_timer_service), "sigset vtalrm");#endif /* SIGVTALRM */E 55E 50E 48#elseE 46struct sigvec tmpv;sigvec(SIGVTALRM, &timerv, &tmpv);I 46D 49#endif RISCOSE 49I 49D 55#endif SYSVSIGNALSE 55I 55#endif /* SYSVSIGNALS */E 55E 49I 55E 55E 46}I 21D 55*/E 55E 21I 55#endif /* NEVER */E 55I 22#ifdef FLTINTI 33/************************************************************************//*									*//*  F L O A T I N G - P O I N T   I N T E R R U P T   H A N D L I N G	*//*									*//*	This is the handler for the SIGFPE signal, to catch floating-	*//*	point exceptions.  Sets the global 'FP_error' to the error	*//*	code passed in by the signal; FP_error is checked by the	*//*	Lisp emulator FP code to make sure everything is OK.		*//*									*//************************************************************************/E 33E 22E 9I 22/* The global used to signal floating-point errors */int FP_error = 0;I 33E 33void int_fp_service(sig, code, scp)D 33int sig, code;struct sigcontext *scp;{D 31	switch(code) {		case FPE_FLTDIV_TRAP:		case FPE_FLTUND_TRAP:		case FPE_FLTOPERR_TRAP:		case FPE_FLTOVF_TRAP:			FP_error = code;			break;		default: {E 31I 31    switch(code) {E 33I 33  int sig, code;  struct sigcontext *scp;  {    switch(code)      {I 42#ifdef AIXPS2	case FPM_DENORM:	case FPM_DIVIDE_0:	case FPM_UNDERFLOW:	case FPM_OVERFLOW:	case FPM_PRECISION:#elseI 50#ifndef ISCE 50E 42E 33	case FPE_FLTDIV_TRAP:	case FPE_FLTUND_TRAP:	case FPE_FLTOVF_TRAP:D 33	case FPE_FLTOPERR_TRAP:		FP_error = code;		break;	default: {E 33I 33D 42	case FPE_FLTOPERR_TRAP: FP_error = code;E 42I 42	case FPE_FLTOPERR_TRAP:I 50D 55#endif ISCE 50#endif AIXPS2 E 55I 55#endif /* ISC */#endif /* AIXPS2  */E 55				FP_error = code;E 42				break;	default:	  {E 33E 31#ifdef DEBUGD 31				char stuff[100];				sprintf(stuff,"Unexpected FP error signal code: %d", code);				perror(stuff);E 31I 31D 33		char stuff[100];		sprintf(stuff, "Unexpected FP error signal code: %d", code);		perror(stuff);E 33I 33	    char stuff[100];	    sprintf(stuff, "Unexpected FP error signal code: %d", code);	    perror(stuff);E 33E 31#endifD 31				}E 31I 31D 33		}E 31	}}E 33I 33	  }      }  }E 33I 33E 33int_fp_init()D 31{/* first set up the signal handler */E 31I 31D 33    {	/* first set up the signal handler */E 31	if(ieee_handler("set", "all", int_fp_service))		perror("Sigvec for FPE failed");I 31	DBPRINT(("FP interrupts enabled\n"));    }E 33I 33  {	/* first set up the signal handler */I 50#ifndef ISCE 50I 42#ifndef AIXPS2E 42    if(ieee_handler("set", "all", int_fp_service))I 42#elseD 54    if(signal(SIGFPE, int_fp_service))E 54I 54    if(sigset(SIGFPE, int_fp_service))E 54D 55#endif AIXPS2E 55I 55#endif /* AIXPS2 */E 55E 42      perror("Sigvec for FPE failed");    DBPRINT(("FP interrupts enabled\n"));I 50D 55#endif ISCE 55I 55#endif /* ISC */E 55E 50  }E 33E 31D 31#ifdef  DEBUG	printf("FP interrupts enabled\n");#endif}E 31D 55#endif FLTINTE 55I 55#endif /* FLTINT */E 55I 33I 55E 55/************************************************************************//*									*/I 39/*			t i m e o u t _ e r r o r			*/E 39/*									*/I 39/*	Error handling routine for SIGALRM.  Called when any		*//*	TIMEOUT(...) forms spend more than TIMEOUT_TIME (normally	*//*	10 sec.) trying to do an I/O operation.				*/E 39/*									*//*									*/D 39/*									*//*									*//*									*//*									*/E 39/************************************************************************/E 33I 27D 39/*****************************************************************timeout_error	Error handling routine for SIGALRM.	When TIMEOUT spend TIMEOUT_TIME (10 sec), this rouitne is called.*****************************************************************/E 27E 39I 27jmp_buf	jmpbuf;D 52#ifdef OS4void#endiftimeout_error()E 52I 52void timeout_error()E 52D 39{D 38	printf("File access timed out.\n");E 38I 38	/*	 * Following printf changes the contents of jmpbuf!	 * This would lead to horibble segmentation violation.	 *//*	printf("File access timed out.\n"); */E 38	longjmp(jmpbuf, 1);}E 39I 39  {    /*     * Following printf changes the contents of jmpbuf!     * This would lead to horrible segmentation violation.     *//*  printf("File access timed out.\n"); */I 47D 49#ifdef RISCOSE 49I 49#ifdef SYSVSIGNALSE 49D 53    signal(SIGALRM, timeout_error);E 53I 53#ifndef ISCD 54	signal(SIGALRM, timeout_error);E 54I 54	sigset(SIGALRM, timeout_error);E 54#endifE 53D 49#endif RISCOSE 49I 49D 55#endif SYSVSIGNALSE 55I 55#endif /* SYSVSIGNALS */E 55E 49E 47    longjmp(jmpbuf, 1);  }E 39I 39/************************************************************************//*									*//*			i n t _ f i l e _ i n i t			*//*									*//*	Set up the signal handler for SIGALRM, to catch TIMEOUTs:	*//*	TIMEOUT(...) forms spend more than TIMEOUT_TIME (normally	*//*	10 sec.) trying to do an I/O operation.				*//*									*//*									*//************************************************************************/E 39void int_file_init()I 39  {I 46D 49#ifndef RISCOSE 49I 49#ifndef SYSVSIGNALSE 49E 46    static struct sigvec timerv;I 46D 49#endif RISCOSE 49I 49D 55#endif SYSVSIGNALSE 55I 55#endif /* SYSVSIGNALS */E 55E 49E 46    char	*envtime;    int	timeout_time;E 39D 39{static struct sigvec timerv;I 30char	*envtime;int	timeout_time;E 39I 39    /* first set up the signal handler */E 39E 30D 46E 46I 46D 49#ifndef RISCOSE 49I 49#ifndef SYSVSIGNALSE 49E 46D 39/* first set up the signal handler */E 39I 39    timerv.sv_handler = timeout_error;    timerv.sv_mask = timerv.sv_flags = 0;    sigvec(SIGALRM, &timerv, 0);I 46#elseD 53    signal(SIGALRM, timeout_error);E 53I 53#ifdef ISC	sigset(SIGALRM, timeout_error);#elseD 54	signal(SIGALRM, timeout_error);E 54I 54	sigset(SIGALRM, timeout_error);E 54D 55#endif ISCE 53D 49#endif RISCOSE 49I 49#endif SYSVSIGNALSE 55I 55#endif /* ISC */E 55E 49E 46E 39I 55#endif /* SYSVSIGNALS */E 55D 39	timerv.sv_handler = timeout_error;	timerv.sv_mask = timerv.sv_flags = 0;	sigvec(SIGALRM, &timerv, 0);E 39I 39    /* Set Timeout period */    if((envtime = getenv("LDEFILETIMEOUT")) == NULL)      {	TIMEOUT_TIME = 10;      }    else      {	if( (timeout_time = atoi(envtime)) > 0) TIMEOUT_TIME = timeout_time;	else TIMEOUT_TIME = 10;      }    DBPRINT(("File timeout interrupts enabled\n"));  }E 39I 30D 39/* Set Timeout period */	if((envtime = getenv("LDEFILETIMEOUT")) == NULL){		TIMEOUT_TIME = 10;	}else{		if( (timeout_time = atoi(envtime)) > 0){D 31			TIMEOUT_TIME = timeout_time ;E 31I 31			TIMEOUT_TIME = timeout_time;E 31		}else{			TIMEOUT_TIME = 10;		}	}E 30D 31#ifdef  DEBUG	printf("File timeout interrupts enabled\n");#endifE 31I 31	DBPRINT(("File timeout interrupts enabled\n"));E 31}E 39I 33I 39/************************************************************************//*                                                                      *//*                         p a n i c u r a i d                          *//*                                                                      *//*   Most of the unused process-killing interrupts end up here; you     *//*      can't do a whole lot safely here but dump your sysout for       *//*      post-mortem analysis, but you MIGHT be able to get a clue       *//*      about what killed you.                                          *//*                                                                      *//************************************************************************/E 39I 39D 40void panicuraid(sig, code, scp)E 40I 40void panicuraid(sig, code, scp, addr)E 40  int sig, code;  struct sigcontext *scp;  {D 40    static char *errormsg =	"PANIC interrupt: Unix signal .... code ....\n\Please record the signal and code information and do a 'v' before trying\n\anything else if you want us to diagnose this system bug. - The Authors";E 40I 40    static char errormsg[200];    static char *stdmsg ="Please record the signal and code information\n\and do a 'v' before trying anything else.";    int i;E 40D 40    sprintf(errormsg+29, "%4d", sig);    sprintf(errormsg+39, "%4d", code);    errormsg[33] = errormsg[43] = ' ';E 40I 40    for (i=0; i<200; i++) errormsg[i]=0;    switch (sig)      {	case SIGBUS:	sprintf(errormsg,				"BUS error (code %d) at address 0x%x.\n%s",				code, addr, stdmsg);			break;	case SIGSEGV:	sprintf(errormsg,				"SEGV error (code %d) at address 0x%x.\n%s",				code, addr, stdmsg);			break;	case SIGILL:	sprintf(errormsg,				"Illegal instruction (code %d) at address 0x%x.\n%s",				code, addr, stdmsg);			break;	case SIGPIPE:	sprintf(errormsg,D 44				"Borken PIPE (code %d) at address 0x%x.\n%s",E 44I 44				"Broken PIPE (code %d) at address 0x%x.\n%s",E 44				code, addr, stdmsg);			break;	case SIGHUP:	sprintf(errormsg,				"HANGUP signalled (code %d) at address 0x%x.\n%s",				code, addr, stdmsg);I 43D 44			/* Assume that a user try to exit UNIX shell */E 44I 44			/* Assume that a user tried to exit UNIX shell */I 46D 50#ifdef RISCOSE 50I 50#ifdef SYSVONLYE 50			kill(0, SIGKILL); exit(0);#elseE 46E 44			killpg(getpgrp(0), SIGKILL);exit(0);I 46D 50#endif RISCOSE 50I 50D 55#endif SYSVONLYE 55I 55#endif /* SYSVONLY */E 55E 50E 46E 43			break;	case SIGFPE:	sprintf(errormsg,				"FP error (code %d) at address 0x%x.\n%s",				code, addr, stdmsg);			break;D 52	default:	sprintf("Uncaught SIGNAL %d (code %d).\n%s",E 52I 52	default:	sprintf(errormsg, "Uncaught SIGNAL %d (code %d).\n%s",E 52				sig, code, stdmsg);      }E 40    error(errormsg);I 40E 40  }E 39/************************************************************************/I 39/*                                                                      *//*                     i n t _ p a n i c _ i n i t                      *//*                                                                      *//*  A catch for all the deadly interupts (but KILL, of course)          *//*  Dumps you into uraid; you probably can't get back from it,          *//*     but there is hope that you will be able to poke around with      *//*     uraid and get a clue about why you're dying.                     *//*                                                                      *//************************************************************************/void int_panic_init()  {I 46D 49#ifdef RISCOSE 49I 49#ifdef SYSVSIGNALSE 49D 53    signal(SIGHUP, panicuraid);E 53I 53#ifdef ISC	sigset(SIGHUP, panicuraid);	sigset(SIGQUIT, panicuraid);	sigset(SIGILL, panicuraid);	sigset(SIGEMT, panicuraid);	sigset(SIGBUS, panicuraid);	sigset(SIGSEGV, panicuraid);	sigset(SIGSYS, panicuraid);	sigset(SIGTERM, panicuraid);#else	D 54	signal(SIGHUP, panicuraid);E 53    signal(SIGQUIT, panicuraid);I 47    signal(SIGILL, panicuraid);    signal(SIGEMT, panicuraid);    signal(SIGBUS, panicuraid);    signal(SIGSEGV, panicuraid);    signal(SIGSYS, panicuraid);    signal(SIGTERM, panicuraid);E 54I 54	sigset(SIGHUP, panicuraid);    sigset(SIGQUIT, panicuraid);    sigset(SIGILL, panicuraid);    sigset(SIGEMT, panicuraid);    sigset(SIGBUS, panicuraid);    sigset(SIGSEGV, panicuraid);    sigset(SIGSYS, panicuraid);    sigset(SIGTERM, panicuraid);E 54I 53#endifE 53E 47#elseE 46    static struct sigvec panicv;D 45    /* first set up the signal handler */E 45I 45    static struct sigvec ignorev;E 45I 45    /* first set up the signal handlers: */E 45    panicv.sv_handler = panicuraid;    panicv.sv_mask = panicv.sv_flags = 0;I 45    ignorev.sv_handler = SIG_IGN;    ignorev.sv_mask = ignorev.sv_flags = 0;    /* Now arrange for signals to be handled properly: */E 45    sigvec(SIGHUP,  &panicv, 0);D 40    sigvec(SIGINT,  &panicv, 0);E 40I 40D 45/*    sigvec(SIGINT,  &panicv, 0); */E 45I 45/*  sigvec(SIGINT,  &panicv, 0); */E 45E 40    sigvec(SIGQUIT, &panicv, 0);    sigvec(SIGILL,  &panicv, 0);D 40    sigvec(SIGTRAP, &panicv, 0);E 40I 40D 45/*    sigvec(SIGTRAP, &panicv, 0); */E 45I 45/*  sigvec(SIGTRAP, &panicv, 0); */E 45I 41#ifdef OS4E 41E 40    sigvec(SIGABRT, &panicv, 0);I 41D 55#endif OS4E 55I 55#endif /* OS4 */E 55E 41    sigvec(SIGEMT,  &panicv, 0);    sigvec(SIGBUS,  &panicv, 0);    sigvec(SIGSEGV, &panicv, 0);    sigvec(SIGSYS,  &panicv, 0);D 45    sigvec(SIGPIPE, &panicv, 0);E 45I 45/*  sigvec(SIGPIPE, &panicv, 0);  Caused trouble with TCP; now ignored: */    sigvec(SIGPIPE, &ignorev, 0);E 45    sigvec(SIGTERM, &panicv, 0);I 44#ifdef OS4E 44    sigvec(SIGXCPU, &panicv, 0);D 40    sigvec(SIGPROF, &panicv, 0);E 40I 40D 44/*    sigvec(SIGPROF, &panicv, 0); */E 44I 44D 45#endif OS4E 44I 42#ifdef OS4E 45E 42E 40    sigvec(SIGLOST, &panicv, 0);I 42D 55#endif OS4E 55I 55#endif /* OS4 */E 55E 42    sigvec(SIGUSR1, &panicv, 0);    sigvec(SIGUSR2, &panicv, 0);#ifndef FLTINT    sigvec(SIGFPE, &panicv, 0);#endifI 46D 49#endif RISCOSE 49I 49D 55#endif SYSVSIGNALSE 55I 55#endif /* SYSVSIGNALS */E 55E 49E 46    DBPRINT(("Panic interrupts enabled\n"));  }/************************************************************************/E 39/*									*//*			    i n t _ i n i t				*//*									*//*	Initialize all the interrupts for Lisp & the emulator.		*//*									*//************************************************************************/E 33E 27E 22void int_init()D 33{	int_timer_init();	int_io_init();I 27	int_file_init();E 33I 33  {   int_timer_init();	/* periodic interrupt timer */   int_io_init();	/* SIGIO and SIGPOLL async I/O handlers */   int_file_init();	/* file-io TIMEOUT support */I 39   int_panic_init();    /* catch for all other dangerous interrupts */E 39E 33E 27I 22#ifdef FLTINTD 33	int_fp_init();E 33I 33   int_fp_init();	/* Floating-point exception handler */E 33#endifE 22I 21D 33	int_unblock();E 33I 33   int_unblock();	/* Turn on interrupts */E 33E 21D 19	int_unblock();E 19E 8E 7E 6}E 4E 3E 1