h27558s 00004/00004/00093d D 1.3 92/04/21 17:18:37 sybalsky 3 2c shortening file names for DOS \nes 00009/00011/00088d D 1.2 92/04/17 15:00:51 nilsson 2 1c es 00099/00000/00000d D 1.1 92/03/04 19:53:11 nilsson 1 0c date and time created 92/03/04 19:53:11 by nilssoneuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";/* File containing the conversion functions between lisp and C *//* -jarl */#include "lispemul.h"D 3#include "lispglobal.h"#include "emulglobal.h"#include "address68k.h"E 3I 3#include "lspglob.h"#include "emlglob.h"#include "adr68k.h"E 3#include "lispmap.h"D 3#include "lisptypes.h"E 3I 3#include "lsptypes.h"E 3#include "fp.h"#include "arith.h"int LispStringLenght (lispstring)     LispPTR *lispstring;{  OneDArray	*arrayp;  arrayp = (OneDArray *)(Addr68k_from_LADDR((unsigned int)lispstring));  return(arrayp->fillpointer);}LispStringToCStr (lispstring, cstring)     LispPTR lispstring;     char cstring[];{  OneDArray *arrayp;  char	*base;  short	*sbase;  int	i, Len;  arrayp = (OneDArray *)(Addr68k_from_LADDR((unsigned int)lispstring));  Len = arrayp->fillpointer;  switch(arrayp->typenumber)    {    case THIN_CHAR_TYPENUMBER:      base = ((char *)	      (Addr68k_from_LADDR((unsigned int)arrayp->base)))	+ ((int)(arrayp->offset));      for(i=0;i<Len;i++)	cstring[i] = base[i];      cstring[Len] = '\0';      break;    case FAT_CHAR_TYPENUMBER:      sbase = ((short *)	       (Addr68k_from_LADDR((unsigned int)arrayp->base)))	+ ((int)(arrayp->offset));      base = (char *)sbase;      for(i=0;i<Len*2;i++)	cstring[i] = base[i];      cstring[Len*2] = '\0';      break;    default:      error("LStringToCString can not handle\n");    }}int LispIntToCInt (lispint)     LispPTR lispint;{  switch( (0xFFFF0000 & lispint) ){  case S_POSITIVE:    return(lispint & 0xFFFF);    break;  case S_NEGATIVE:    return(lispint | 0xFFFF0000);    break;  default:    if( GetTypeNumber(lispint) == TYPE_FIXP ) {      return( *((int *)Addr68k_from_LADDR(lispint)));    } else {      printf("LispIntToCInt: Arg not Lispint.\n");    }    break;  }}LispPTR CIntToLispInt(cint)     int cint;{D 2  switch(cint & 0xFFFF0000){					  case 0:							    return(S_POSITIVE | cint);			  case 0xFFFF0000:					    return(S_NEGATIVE | (0xFFFF & cint));		  default:{register LispPTR *wordp;				   /* cint is FIXP, call createcell */			   wordp = (LispPTR *) createcell68k(TYPE_FIXP);		   *((int *)wordp) = cint;					   return(LADDR_from_68k(wordp));				 }						E 2I 2  if (abs(cint) > 0xFFFF) {	/* its a fixp! */    register LispPTR *wordp;    wordp = (LispPTR *) createcell68k(TYPE_FIXP);    *((int *)wordp) = cint;    return(LADDR_from_68k(wordp));  } else if (cint >= 0) {	/* its a positive smallp! */    return(S_POSITIVE | cint);  } else {			/* its a negative smallp! */    return(S_NEGATIVE | (0xFFFF & cint));E 2  }}E 1