h54388s 00154/00028/00913d D 1.18 93/02/08 15:04:27 sybalsky 18 17c Big VM (and new CDR coding) changes for 3.0 \nes 00030/00028/00911d D 1.17 92/05/27 19:14:42 sybalsky 17 16c retrofit of 386 unix changes \nes 00000/00000/00939d D 1.16 92/04/21 16:28:51 sybalsky 16 15c shortening file names for DOSes 00014/00007/00925d D 1.15 92/03/04 18:49:52 sybalsky 15 14c 386es 00001/00001/00931d D 1.14 91/08/21 12:39:57 sybalsky 14 13c Make DTEST use 24 bits of name, rather than low 16.es 00008/00000/00924d D 1.13 91/02/07 19:15:40 sybalsky 13 12c Make FVAR, ATOMCELL work with 3-byte atomses 00012/00010/00912d D 1.12 91/02/04 12:57:14 sybalsky 12 11c more 3-byte-atomses 00037/00000/00885d D 1.11 91/01/14 15:10:49 sybalsky 11 10c Add 3-byte-atom cases to GVAR, GVAR_ ATOMCELL.N (unfinished)es 00001/00001/00884d D 1.10 90/09/12 16:16:19 sybalsky 10 9c fix a CSTKPTR on lhs of == to CSTKPTRLes 00038/00037/00847d D 1.9 90/08/30 10:33:29 sybalsky 9 8c AIX changes for += codees 00002/00006/00882d D 1.8 90/07/26 11:34:09 sybalsky 8 7c Move bit-atom atomNo macros to lispemules 00005/00000/00883d D 1.7 90/07/22 11:37:46 sybalsky 7 6c Change FNx opcodes to respect FNTRACEes 00017/00004/00866d D 1.6 90/07/09 16:00:53 sybalsky 6 5c Add 3-byte atom number fetching, under control of -DBIGATOMSes 00001/00001/00869d D 1.5 90/07/04 03:50:05 sybalsky 5 4c Fix dtd_name use to use dtdnamelo, to match DTD change for 24-bit type nameses 00003/00005/00867d D 1.4 90/06/15 17:00:46 mitani 4 3c GCLOOKUPVes 00011/00001/00861d D 1.3 90/06/04 13:00:12 sybalsky 3 2c reformat, copyrightes 00001/00001/00861d D 1.2 90/05/09 12:19:24 fuji 2 1c Takeshi: fix N_OP_CALL_9 c old: op_name( ... TOPOFSTACK, fix_tos_ufn) c new: op_name( ... TOPOFSTACK /*, fix_tos_ufn*/)es 00862/00000/00000d D 1.1 90/04/19 21:29:01 sybalsky 1 0c date and time created 90/04/19 21:29:01 by sybalskyeuUf e 0tTI 1D 4/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 4I 4D 18/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */E 18I 18/* %Z% %M% Version %I% (%G%). copyright venue   */E 18E 4D 3/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 3I 3I 15D 17E 17E 15D 4E 4/************************************************************************//*									*/D 15/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 15I 15D 17/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*/E 17I 17/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*/E 17/*	Manufactured in the United States of America.			*/E 15/*									*/D 15/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 15I 15/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 15/*									*//************************************************************************/E 3D 17I 15E 17E 15/* 		These are the Macros Used to generate inline c code.	These are the goto ni definitions of the opcodes.*//************************************************************************//*									*//*	    Macros for fetching bytes & words PC-relative		*//*									*//*	These are this way so that they can be redefined for the 386i,	*//*	where it makes a difference in speed if you know in advance.	*//*									*//************************************************************************/#define Get_BYTE_PCMAC0 Get_BYTE(PCMAC)#define Get_BYTE_PCMAC1 Get_BYTE(PCMAC+1)#define Get_BYTE_PCMAC2 Get_BYTE(PCMAC+2)#define Get_BYTE_PCMAC3 Get_BYTE(PCMAC+3)#define Get_DLword_PCMAC0 Get_DLword(PCMAC)#define Get_DLword_PCMAC1 Get_DLword(PCMAC+1)#define Get_DLword_PCMAC2 Get_DLword(PCMAC+2)#define Get_DLword_PCMAC3 Get_DLword(PCMAC+3)I 6#define Get_Pointer_PCMAC0D 8#define Get_Pointer_PCMAC1 ((Get_BYTE(PCMAC + 1) << 16) | 	\			    (Get_BYTE(PCMAC + 2) << 8) | 	\			    Get_BYTE(PCMAC +  3))I 7#define Get_Pointer_PCMAC2 ((Get_BYTE(PCMAC + 2) << 16) | 	\			    (Get_BYTE(PCMAC + 3) << 8) | 	\			    Get_BYTE(PCMAC +  4))E 8I 8#define Get_Pointer_PCMAC1 Get_Pointer(PCMAC + 1)#define Get_Pointer_PCMAC2 Get_Pointer(PCMAC + 2)E 8E 7E 6I 17	/* For getting a signed byte */#define Get_SBYTE_PCMAC0 GETBYTE((s_char *)PCMAC)#define Get_SBYTE_PCMAC1 GETBYTE((s_char *)PCMAC+1)E 17I 6	/* for getting an atom number, e.g., for FNx or DTEST */#ifdef BIGATOMS#define Get_AtomNo_PCMAC1 Get_Pointer_PCMAC1I 7#define Get_AtomNo_PCMAC2 Get_Pointer_PCMAC2I 18#ifdef BIGVM#define nextop_atom nextop5#define nextop_ptr nextop5#elseE 18E 7#define nextop_atom nextop4I 18#define nextop_ptr nextop4#endif /* BIGVM */E 18#else#define Get_AtomNo_PCMAC1 Get_DLword_PCMAC1I 7#define Get_AtomNo_PCMAC2 Get_DLword_PCMAC2E 7#define nextop_atom nextop3D 18#endif BIGATOMSE 18I 18#define nextop_ptr nextop4#endif /* BIGATOMS */E 18E 6I 6I 18E 18E 6#define CHECK_INTERRUPT {if((int)CSTKPTR > Irq_Stk_Check) goto check_interrupt;} #define SWAP_WORDS(x) (((unsigned int)x << 16) | (((unsigned int)x >> 16) & 0xFFFF))#define NATIVECHECK							\	{if (BCE_CURRENTFX->native) {goto gonative ;} nextop0; }#define nextop0 {goto nextopcode; }#define nextop1 {PCMACL += 1; nextop0; }#define nextop2 {PCMACL += 2; nextop0; }#define nextop3 {PCMACL += 3; nextop0; }#define nextop4 {PCMACL += 4; nextop0; }I 18#define nextop5 {PCMACL += 5; nextop0; }E 18#define OPCAR \ if (Listp(TOPOFSTACK))\ {\ register ConsCell *DATUM68K = (ConsCell *)(Addr68k_from_LADDR(TOPOFSTACK));\	if (DATUM68K->cdr_code == CDR_INDIRECT)\	{\		TOPOFSTACK = ((LispPTR)((ConsCell *)Addr68k_from_LADDR(DATUM68K->car_field))->car_field);\		nextop1; \	}\	else \	{ \		TOPOFSTACK = ((LispPTR)DATUM68K->car_field);\		nextop1; \  } \  }\ else	if (TOPOFSTACK == NIL_PTR)\		{ nextop1; } \	else if ( TOPOFSTACK == ATOM_T)\		{ nextop1; } \	else \	  {\		goto op_ufn; \	  } /* end of OPCAR */I 18#ifdef NEWCDRCODINGE 18#define OPCDR  \ if (Listp(TOPOFSTACK))\ {\register ConsCell *DATUM68K = (ConsCell *)(Addr68k_from_LADDR(TOPOFSTACK));\register int CDRCODEX = DATUM68K->cdr_code;\	if (CDRCODEX == CDR_NIL) {\		/* cdr-nil */\		TOPOFSTACK = (NIL_PTR);\		nextop1; \		} \	else if (CDRCODEX> CDR_ONPAGE) {\		/* cdr-samepage */\I 18		TOPOFSTACK = ((TOPOFSTACK) + ((CDRCODEX & 7) << 1));\		nextop1; \		} \	else if (CDRCODEX == CDR_INDIRECT) {	/* CDRCODEX < CDR_ONPAGE */\		/* cdr-indirect */\		TOPOFSTACK = (cdr ((LispPTR)(DATUM68K->car_field)));\		nextop1; \		} \	else\	{\		/* cdr-differentpage */\		TOPOFSTACK = ((ConsCell *)(Addr68k_from_LADDR \		((TOPOFSTACK) + (CDRCODEX << 1)))\											)->car_field;\		nextop1; \	}\  }\ else	if (TOPOFSTACK == NIL_PTR)\		{ nextop1; } \	else\	 {\		goto op_ufn; \	 } /* end of OPCDR */#else#define OPCDR  \ if (Listp(TOPOFSTACK))\ {\register ConsCell *DATUM68K = (ConsCell *)(Addr68k_from_LADDR(TOPOFSTACK));\register int CDRCODEX = DATUM68K->cdr_code;\	if (CDRCODEX == CDR_NIL) {\		/* cdr-nil */\		TOPOFSTACK = (NIL_PTR);\		nextop1; \		} \	else if (CDRCODEX> CDR_ONPAGE) {\		/* cdr-samepage */\E 18		TOPOFSTACK = (POINTER_PAGEBASE(TOPOFSTACK) + \		((CDRCODEX & 127) << 1));\		nextop1; \		} \	else if (CDRCODEX == CDR_INDIRECT) {	/* CDRCODEX < CDR_ONPAGE */\		/* cdr-indirect */\		TOPOFSTACK = (cdr ((LispPTR)(DATUM68K->car_field)));\		nextop1; \		} \	else\	{\		/* cdr-differentpage */\		TOPOFSTACK = ((ConsCell *)(Addr68k_from_LADDR \		(POINTER_PAGEBASE(TOPOFSTACK) + (CDRCODEX << 1)))\											)->car_field;\		nextop1; \	}\  }\ else	if (TOPOFSTACK == NIL_PTR)\		{ nextop1; } \	else\	 {\		goto op_ufn; \	 } /* end of OPCDR */I 18#endif /* NEWCDRCODING */E 18#define	IVARMACRO(x)	{PUSH(IVAR[x]); nextop1;}#define	PVARMACRO(x)	{PUSH(PVAR[x]); nextop1;}#define	PVARSETMACRO(x)	{PVAR[x] = TOPOFSTACK; nextop1;}#define	PVARSETPOPMACRO(x) {PVAR[x] = TOPOFSTACK; POP; nextop1;}#define	PUSHATOM(x)	{PUSH(x); nextop1;}#define	JUMPMACRO(x)	{CHECK_INTERRUPT; PCMACL += x; nextop0;}#define	FJUMPMACRO(x)	{if(TOPOFSTACK != 0) {goto PopNextop1 ; }	\			{CHECK_INTERRUPT; POP; PCMACL += x; nextop0;}	\			}#define	TJUMPMACRO(x)	{if(TOPOFSTACK == 0) {goto PopNextop1 ; }	\			{CHECK_INTERRUPT; POP; PCMACL += x; nextop0;}	\			}#define GETBASE_N(N)	{ 						\		TOPOFSTACK = 						\			(S_POSITIVE | GETWORD((DLword *)			\D 18			Addr68k_from_LADDR((0xFFFFFF & TOPOFSTACK) + N)));\E 18I 18			Addr68k_from_LADDR((POINTERMASK & TOPOFSTACK) + N)));\E 18		nextop2;						\		}#define GETBASEPTR_N(N) {						\		TOPOFSTACK = 						\D 18			(0xFFFFFF & *((LispPTR *)			\			Addr68k_from_LADDR((0xFFFFFF & TOPOFSTACK) + N)));\E 18I 18			(POINTERMASK & *((LispPTR *)			\			Addr68k_from_LADDR((POINTERMASK & TOPOFSTACK) + N)));\E 18		nextop2;						\		}#define PUTBASEBYTE							\	{ register int byteoffset;					\	  register char	*p_data;					\D 18	 if(((0xFFFF0000 & TOPOFSTACK) != S_POSITIVE) ||		\E 18I 18	 if(((SEGMASK & TOPOFSTACK) != S_POSITIVE) ||		\E 18	    ((unsigned short)TOPOFSTACK >= 256))			\		goto op_ufn;						\	 byteoffset = GET_TOS_1;					\D 18	 switch( (0xFFFF0000 & byteoffset) ){				\E 18I 18	 switch( (SEGMASK & byteoffset) ){				\E 18	 case S_POSITIVE:						\	 	byteoffset &=  0x0000FFFF;				\	 	break;							\	 case S_NEGATIVE:						\		byteoffset |=  0xFFFF0000;				\		break;							\	 default:							\		goto op_ufn;						\	/***	if( GetTypeNumber(byteoffset) == TYPE_FIXP )		\			byteoffset = *((int *)Addr68k_from_LADDR(byteoffset));	\		else							\			goto op_ufn; ***/				\	 }								\D 9	 --CSTKPTR;							\E 9I 9	 --CSTKPTRL;							\E 9D 18	 p_data = (char*)Addr68k_from_LADDR(0xFFFFFF & (POP_TOS_1)) + byteoffset;	\E 18I 18	 p_data = (char*)Addr68k_from_LADDR(POINTERMASK & (POP_TOS_1)) + byteoffset;	\E 18	 GETBYTE(p_data) = 0xFF & TOPOFSTACK;				\	 nextop1;							\	}#define GETBASEBYTE							\D 18	{switch( (0xFFFF0000 & TOPOFSTACK) ){				\E 18I 18	{switch( (SEGMASK & TOPOFSTACK) ){				\E 18	 case S_POSITIVE:						\		TOPOFSTACK &=  0x0000FFFF;				\		break;							\	 case S_NEGATIVE:						\		TOPOFSTACK |=  0xFFFF0000;				\		break;							\	 default:							\		if( GetTypeNumber(TOPOFSTACK) == TYPE_FIXP )		\		 TOPOFSTACK = *((int *)Addr68k_from_LADDR(TOPOFSTACK));	\		else							\			goto op_ufn;					\	 }								\D 18	 TOPOFSTACK = (0xFF & (GETBYTE((char*)Addr68k_from_LADDR((0xFFFFFF & (POP_TOS_1))) + TOPOFSTACK))) | S_POSITIVE;	\E 18I 18	 TOPOFSTACK = (0xFF & (GETBYTE((char*)Addr68k_from_LADDR((POINTERMASK & (POP_TOS_1))) + TOPOFSTACK))) | S_POSITIVE;	\E 18	 nextop1;							\	}D 18E 18#define PUTBASEPTR_N(n)							\	{ register int base;						\D 18	  base = 0xffffff & POP_TOS_1;					\E 18I 18	  base = POINTERMASK & POP_TOS_1;					\E 18	  *((LispPTR *)Addr68k_from_LADDR(base + n)) = TOPOFSTACK;      \	  TOPOFSTACK = base;						\	  nextop2;							\	}#define PUTBASE_N(n)							\	{ register int base;						\	  if (GetHiWord(TOPOFSTACK) != (S_POSITIVE >> 16))		\		goto op_ufn;						\D 18	  base = 0xffffff & POP_TOS_1;					\E 18I 18	  base = POINTERMASK & POP_TOS_1;					\E 18	  GETWORD((DLword *)Addr68k_from_LADDR(base + n)) = GetLoWord(TOPOFSTACK);\	  TOPOFSTACK = base;						\	  nextop2;							\	}I 18E 18#define PVARX(x)	{ PUSH(GetLongWord((DLword *)PVAR + x)); nextop2; }#define PVARX_(x)	{ *((LispPTR *)((DLword *)PVAR+x))=TOPOFSTACK; nextop2;}#define IVARX(x)	{ PUSH(GetLongWord((DLword *)IVAR + x)); nextop2; }#define IVARX_(x)	{ *((LispPTR *)((DLword *)IVAR+x))=TOPOFSTACK; nextop2;}I 11#ifndef BIGATOMSE 11D 6#define GVAR(x)		{ PUSH(GetLongWord(Valspace + (x<<1))); nextop3; }E 6I 6D 12#define GVAR(x)		{ PUSH(GetLongWord(Valspace + (x<<1))); nextop_atom; }E 12I 12#define GVAR(x)		{ PUSH(GetLongWord(Valspace + ((x)<<1))); nextop_atom; }I 18#elif BIGVM#define GVAR(x)								\  { register int tx = x;									\    if (tx & SEGMASK)							\      {									\	PUSH(GetLongWord(						\	      Addr68k_from_LADDR((tx)+NEWATOM_VALUE_OFFSET)));		\      }									\    else PUSH(GetLongWord((LispPTR *)Pnamespace + (tx*5) + NEWATOM_VALUE_PTROFF));			\									\    nextop_atom;							\  }E 18E 12I 11#elseD 12#define GVAR(x)  {    if (x && 0xFFFF00000)      {	PUSH(GetLongWord(Addr68k_from_LADDR(x)));      }    else PUSH(GetLongWord(Valspace + (x<<1)));E 11E 6I 11    nextop_atom;E 12I 12#define GVAR(x)								\D 17  {									\    if (x & 0xFFFF0000)							\E 17I 17  { register int tx = x;									\D 18    if (tx & 0xFFFF0000)							\E 18I 18    if (tx & SEGMASK)							\E 18E 17      {									\	PUSH(GetLongWord(						\D 17	      Addr68k_from_LADDR((x)+NEWATOM_VALUE_OFFSET)));		\E 17I 17	      Addr68k_from_LADDR((tx)+NEWATOM_VALUE_OFFSET)));		\E 17      }									\D 17    else PUSH(GetLongWord(Valspace + ((x)<<1)));			\E 17I 17    else PUSH(GetLongWord(Valspace + ((tx)<<1)));			\E 17									\    nextop_atom;							\E 12  }D 18#endif BIGATOMSE 18I 18#endif /* BIGATOMS */E 18I 12E 12I 18E 18E 11#define COPY		{ HARD_PUSH(TOPOFSTACK); nextop1; }#define SWAP		{ register LispPTR temp;			\			 temp = GET_TOS_1;				\			 GET_TOS_1 = TOPOFSTACK;			\		 	 TOPOFSTACK = temp;				\			 nextop1;					\			}D 9#define	N_OP_VAG2		{ TOPOFSTACK = (GET_TOS_1 << 16) | (0xFFFF & TOPOFSTACK); CSTKPTR--; nextop1; }E 9I 9#define	N_OP_VAG2	{ TOPOFSTACK = (GET_TOS_1 << 16)		\			  | (0xFFFF & TOPOFSTACK); CSTKPTRL--; nextop1; }E 9#define FN0		{ OPFN(0, fn0_args, fn0_xna, fn0_native); }#define FN1		{ OPFN(1, fn1_args, fn1_xna, fn1_native); }#define FN2		{ OPFN(2, fn2_args, fn2_xna, fn2_native); }#define FN3		{ OPFN(3, fn3_args, fn3_xna, fn3_native); }#define FN4		{ OPFN(4, fn4_args, fn4_xna, fn4_native); }#define FNX		{ OPFNX; nextop0; }#define ENVCALL		{ OP_ENVCALL; nextop0; }#define RETURN		{ OPRETURN; nextop0; }#define APPLY		{ OPAPPLY;}#define CHECKAPPLY	{ OPCHECKAPPLY; nextop1; }#define BIN								\{									\register Stream *stream68k; /* stream instance on TOS */		\register  char *buff68k;     /* pointer to BUFF */			\									\  if ( GetTypeNumber(TOPOFSTACK) == TYPE_STREAM ) {			\	stream68k=(Stream *) Addr68k_from_LADDR(TOPOFSTACK);		\	if( ( !stream68k->BINABLE ) ||					\	    (  stream68k->COFFSET >=					\	       stream68k->CBUFSIZE   ) ) goto op_ufn;			\									\	/* get BUFFER instance */					\	buff68k =(char *)Addr68k_from_LADDR(stream68k->CBUFPTR);	\									\	/* get BYTE data and set it to TOS */				\	TOPOFSTACK = (S_POSITIVE |					\		      (Get_BYTE(buff68k + (stream68k->COFFSET)++)) );	\	nextop1;							\	}								\  else	goto op_ufn;							\}#ifdef RECLAIMINC#define RECLAIMCELL	{ TOPOFSTACK = gcreclaimcell(TOPOFSTACK); nextop1; }#else#define RECLAIMCELL	{ goto op_ufn; }#endif#define GCSCAN1		{ TOPOFSTACK=gcscan1(TOPOFSTACK & 0xffff);	\			 if (TOPOFSTACK) {TOPOFSTACK |= S_POSITIVE; };nextop1;}#define GCSCAN2		{ TOPOFSTACK=gcscan2(TOPOFSTACK & 0xffff);	\			  if (TOPOFSTACK) {TOPOFSTACK |=S_POSITIVE; };nextop1;}#define CONTEXTSWITCH	{ EXT; OP_contextsw(); RET; 			\			  /*CHECK_INTERRUPT;*/ CLR_IRQ;			\			  NATIVE_NEXTOP0; }#define	NOP		{ nextop1; }#define RESLIST(n)	{ goto op_ufn; }#define FINDKEY(x)							\		{							\		 TOPOFSTACK = N_OP_findkey(TOPOFSTACK, x);		\		 nextop2;						\		}#define RPLPTR(n)							\		{							\		 TOPOFSTACK = N_OP_rplptr(POP_TOS_1, TOPOFSTACK, n);	\		 nextop2;						\		}#define GVAR_(atom_index)						\		{							\		 N_OP_gvar_(TOPOFSTACK, atom_index);			\D 6		 nextop3;						\E 6I 6		 nextop_atom;						\E 6		}D 15#define BIND	{register int n1;					\E 15I 15D 17#define BIND	{register byte = Get_BYTE_PCMAC1;			\		register int n1;					\E 17I 17#define BIND	{register int n1;					\E 17E 15		register int n2;					\		register LispPTR *ppvar;				\		register int i;						\D 15		n1 = Get_BYTE_PCMAC1 >> 4;				\		n2 = Get_BYTE_PCMAC1 & 0xf;				\		ppvar = (LispPTR *)PVAR + 1 + Get_BYTE_PCMAC2;	\E 15I 15D 17		n1 = byte >> 4;						\		n2 = byte & 0xf;					\		ppvar = (LispPTR *)PVAR + 1 + Get_BYTE_PCMAC2;		\E 17I 17		n1 = Get_BYTE_PCMAC1 >> 4;				\		n2 = Get_BYTE_PCMAC1 & 0xf;				\		ppvar = (LispPTR *)PVAR + 1 + Get_BYTE_PCMAC2;	\E 17E 15		for(i=n1; --i >= 0;){ *--ppvar = NIL_PTR; }		\		if(n2 == 0){						\D 10			*CSTKPTR++ = TOPOFSTACK;			\E 10I 10			*CSTKPTRL++ = TOPOFSTACK;			\E 10		}else{							\			*--ppvar = TOPOFSTACK;				\D 9			for(i=1; i<n2; i++) { *--ppvar = *(--CSTKPTR); }	\E 9I 9			for(i=1; i<n2; i++) { *--ppvar = *(--CSTKPTRL); }	\E 9		}							\		i = ~(n1 + n2);						\		TOPOFSTACK = (i<<16) | (Get_BYTE_PCMAC2<<1);		\		nextop3;						\		}#define UNBIND	{register int num;					\		register LispPTR *ppvar;				\		register int	i;					\		register LispPTR value;					\D 9		for(; ( ((int)*--CSTKPTR) >= 0 ););			\E 9I 9		for(; ( ((int)*--CSTKPTRL) >= 0 ););			\E 9		value = *CSTKPTR;					\		num = (~value)>>16;					\		ppvar = (LispPTR *)((DLword *)PVAR + 2 + GetLoWord(value));\		for(i=num; --i >= 0;){*--ppvar = 0xffffffff;}		\		nextop1;						\		}#define DUNBIND	{register int num;					\		register LispPTR *ppvar;				\		register int	i;					\		register LispPTR value;					\		if((int)TOPOFSTACK < 0){ 				\		  num =(~TOPOFSTACK)>>16;				\		  if(num != 0){						\		    ppvar = (LispPTR *)((DLword *)PVAR + 2 + GetLoWord(TOPOFSTACK)); \		    for(i=num; --i >= 0;) {  \					    *--ppvar = 0xffffffff; }	\		  }							\		}else{							\D 9		for(; ( ((int)*--CSTKPTR) >= 0 ););			\E 9I 9		for(; ( ((int)*--CSTKPTRL) >= 0 ););			\E 9		  value = *CSTKPTR;					\		  num = (~value)>>16;					\		  ppvar = (LispPTR *)((DLword *)PVAR + 2 + GetLoWord(value));\		  for(i=num; --i >= 0;) {  \					  *--ppvar = 0xffffffff; }	\		}							\		POP;							\		nextop1;						\		}#define N_OP_HILOC							\		{							\		 TOPOFSTACK = GetHiWord(TOPOFSTACK) | S_POSITIVE;	\		 nextop1;						\		}#define N_OP_LOLOC							\		{							\		 TOPOFSTACK = GetLoWord(TOPOFSTACK) | S_POSITIVE;	\		 nextop1;						\		}#define GETBITS_N_M(a, b)						\D 17		{register int temp;					\		temp = 0xF & b;						\E 17I 17		{register int temp, bb = b;					\		temp = 0xF & bb;						\E 17		TOPOFSTACK = S_POSITIVE | 				\D 18		 (( (GETWORD(Addr68k_from_LADDR(0xFFFFFF & (TOPOFSTACK+a))))	\E 18I 18		 (( (GETWORD(Addr68k_from_LADDR(POINTERMASK & (TOPOFSTACK+a))))	\E 18D 17			>> (16 - ( (0xF & (b >> 4)) + temp + 1)) )	\E 17I 17			>> (16 - ( (0xF & (bb >> 4)) + temp + 1)) )	\E 17			& n_mask_array[temp] );				\		 nextop3;						\		}#define PUTBITS_N_M(a, b)						\	{ int	base;							\I 17	  register int bb = b;					\E 17	  register DLword	*pword;					\	  register int shift_size, field_size, fmask;			\D 18	 if( (0xFFFF0000 & TOPOFSTACK) != S_POSITIVE ){ goto op_ufn; };	\	 base = 0xFFFFFF & POP_TOS_1;					\E 18I 18	 if( (SEGMASK & TOPOFSTACK) != S_POSITIVE ){ goto op_ufn; };	\	 base = POINTERMASK & POP_TOS_1;					\E 18	 pword = (DLword*)Addr68k_from_LADDR( base + a );		\D 17	 field_size = 0xF & b;						\	 shift_size = 15 - (0xF & (b >> 4)) - field_size;		\E 17I 17	 field_size = 0xF & bb;						\	 shift_size = 15 - (0xF & (bb >> 4)) - field_size;		\E 17	 fmask = n_mask_array[field_size] << shift_size;		\	 GETWORD(pword) = ( (TOPOFSTACK << shift_size) & fmask) |	\			    (GETWORD(pword) & (~fmask));		\	 TOPOFSTACK = base;						\	 nextop3;							\	}#define CONS								\	{ TOPOFSTACK = N_OP_cons(POP_TOS_1, TOPOFSTACK);		\	  nextop1;							\	}#define MYALINK								\	{								\	 PUSH(((( CURRENTFX->alink) & 0xfffe)-FRAMESIZE) | S_POSITIVE);	\	 nextop1;							\	}#define MYARGCOUNT							\	{ register int arg_num;						\	  if (( CURRENTFX->alink & 1) == 0)				\	    arg_num = (int)((LispPTR *)(CURRENTFX) - 1);				\ 	  else								\	    arg_num = (int)(Stackspace + CURRENTFX->blink);		\	 PUSH( (DLword)((arg_num - (int)IVar) >> 2) | S_POSITIVE);	\	 nextop1;							\	}#define RCLK								\	{								\	 TOPOFSTACK = N_OP_rclk(TOPOFSTACK);				\	 nextop1;							\	}#define LISTP	{							\		 if((DLword)GetTypeNumber(TOPOFSTACK) != TYPE_LISTP)\    			TOPOFSTACK = NIL_PTR;				\		 nextop1;						\		}#define NTYPEX								\		{							\		 TOPOFSTACK = S_POSITIVE | (DLword)(GetTypeNumber(TOPOFSTACK));\		nextop1;						\		}#define TYPEP(n) 							\		{							\		  if((DLword)GetTypeNumber(TOPOFSTACK) != n)		\    			TOPOFSTACK = NIL_PTR;				\		 nextop2;						\		}#define TYPEMASK(n) 							\		{							\  		 if( ( ((DLword)GetTypeEntry(TOPOFSTACK))  & 		\		     ( (DLword)n << 8)) == 0)				\    			TOPOFSTACK = NIL_PTR;				\		 nextop2;						\		}#define INSTANCEP(atom_index)						\		{							\		 TOPOFSTACK = N_OP_instancep(TOPOFSTACK,atom_index);	\D 6		 nextop3;						\E 6I 6		 nextop_atom;						\E 6		}#define STOREN(n)							\		{ *(CSTKPTR  - ((n+2) >> 1)) = TOPOFSTACK;		\		 nextop2;						\		}#define COPYN(n)							\		{ PUSH(*(CSTKPTR  - ((n+2) >> 1)));			\		 nextop2;						\		}#define POPN(n)								\D 9		{TOPOFSTACK = *(CSTKPTR -= ((n)+1));			\E 9I 9		{TOPOFSTACK = *(CSTKPTRL -= ((n)+1));			\E 9		 nextop2;						\		}#define CLARITHEQUAL	{						\register int arg2;							\  SV; arg2 = POP_TOS_1;							\D 18  if ((TOPOFSTACK & 0xff0000) == S_POSITIVE)				\E 18I 18  if ((TOPOFSTACK & SEGMASK) == S_POSITIVE)				\E 18  {									\  if (arg2 == TOPOFSTACK) {TOPOFSTACK = ATOM_T; nextop1;}		\D 18  if ((arg2 & 0xff0000) == S_POSITIVE) {TOPOFSTACK = NIL; nextop1;}	\E 18I 18  if ((arg2 & SEGMASK) == S_POSITIVE) {TOPOFSTACK = NIL; nextop1;}	\E 18  }									\  N_OP_POPPED_CALL_2(N_OP_eqq, arg2);					\}#define S_CHARACTER 0x70000#define AREF1	{							\LispPTR arrayarg;							\register LispPTR baseL;							\register int index;							\register OneDArray *arrayblk;						\DLword	*createcell68k();						\    SV; arrayarg = POP_TOS_1;						\    if (GetTypeNumber(arrayarg) != TYPE_ONED_ARRAY) goto aref_ufn;	\    arrayblk = (OneDArray *)Addr68k_from_LADDR(arrayarg);		\D 18    if ((TOPOFSTACK & 0xFFFF0000) != S_POSITIVE) goto aref_ufn;		\E 18I 18    if ((TOPOFSTACK & SEGMASK) != S_POSITIVE) goto aref_ufn;		\E 18    index = TOPOFSTACK & 0xFFFF;					\    if (index >= arrayblk->totalsize) goto aref_ufn;		\    index += arrayblk->offset;				\    baseL = arrayblk->base;					\    switch (arrayblk->typenumber) {			\      case 38: /* pointer : 32 bits */					\         TOPOFSTACK = *(((int *)Addr68k_from_LADDR(baseL)) + index);	\         nextop1;							\      case 20: /* signed : 16 bits */					\         TOPOFSTACK = (GETWORD(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;									\         if (TOPOFSTACK & 0x8000) TOPOFSTACK |= S_NEGATIVE;		\         else TOPOFSTACK |= S_POSITIVE;					\         nextop1;							\      case 67: /* Character :  8 bits */				\         TOPOFSTACK = S_CHARACTER | ((GETBYTE(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF);								\         nextop1;							\      case 22: /* signed : 32 bits */					\         TOPOFSTACK = *(((int *)Addr68k_from_LADDR(baseL)) + index);	\         switch(TOPOFSTACK & 0xFFFF0000){				\           case 0:							\             TOPOFSTACK |= S_POSITIVE;					\             break;							\           case (unsigned)0xFFFF0000:					\             TOPOFSTACK &= S_NEGATIVE;					\             break;							\           default:{register DLword *wordp;				\             wordp = createcell68k(TYPE_FIXP);				\             *((int *)wordp) = TOPOFSTACK;				\D 9             (LispPTR)TOPOFSTACK = LADDR_from_68k(wordp);		\E 9I 9             TOPOFSTACK = (LispPTR)LADDR_from_68k(wordp);		\E 9             }								\         }								\         nextop1;							\      case 0: /* unsigned : 1 bit per element */			\         TOPOFSTACK = S_POSITIVE | (((GETBYTE(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1);				\         nextop1;							\      case 3: /* unsigned : 8 bits per element */			\         TOPOFSTACK = S_POSITIVE | ((GETBYTE(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF);								\         nextop1;							\      case 4: /* unsigned : 16 bits per element */			\         TOPOFSTACK = S_POSITIVE | ((GETWORD(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF);							\         nextop1;							\      case 54: /* Float : 32 bits */{register DLword *wordp;		\         wordp = createcell68k(TYPE_FLOATP);				\         *((int *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);\D 9         (LispPTR)TOPOFSTACK = LADDR_from_68k(wordp);			\E 9I 9         TOPOFSTACK = (LispPTR)LADDR_from_68k(wordp);			\E 9         }								\         nextop1;							\      case 68: /* Character :  16 bits */				\         TOPOFSTACK = S_CHARACTER | ((GETWORD(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF);							\         nextop1;							\      case 86: /* XPointer : 32 bits */					\         TOPOFSTACK = *(((int *)Addr68k_from_LADDR(baseL)) + index);	\         nextop1;							\      default: /* Illegal or Unimplemented */				\        goto aref_ufn;							\    }/* end switch typenumber */					\aref_ufn:								\	N_OP_POPPED_CALL_2(N_OP_aref1, arrayarg); 			\}I 18#ifdef BIGVME 18#define DTEST(n)							\{									\	register int atom_index;					\	register struct dtd *dtd68k ;					\	atom_index = n;							\ for(dtd68k=(struct dtd *) GetDTD(GetTypeNumber(TOPOFSTACK));		\I 18	atom_index != dtd68k->dtd_name ;	\	    dtd68k=(struct dtd *) GetDTD(dtd68k->dtd_supertype))	\	{								\		if( dtd68k->dtd_supertype == 0)				\		{							\		 goto op_ufn;						\		}							\	}								\nextop_atom;								\}#else /* BIGVM */#define DTEST(n)							\{									\	register int atom_index;					\	register struct dtd *dtd68k ;					\	atom_index = n;							\ for(dtd68k=(struct dtd *) GetDTD(GetTypeNumber(TOPOFSTACK));		\E 18D 5	atom_index != dtd68k->dtd_name ;				\E 5I 5D 14	atom_index != dtd68k->dtd_namelo/* +(dtd68k->dtd_name_hi<<16)*/ ;	\E 14I 14D 17	atom_index != dtd68k->dtd_namelo +(dtd68k->dtd_namehi<<16) ;	\E 17I 17	atom_index != dtd68k->dtd_namelo +((int)(dtd68k->dtd_namehi)<<16) ;	\E 17E 14E 5	    dtd68k=(struct dtd *) GetDTD(dtd68k->dtd_supertype))	\	{								\		if( dtd68k->dtd_supertype == 0)				\		{							\		 goto op_ufn;						\		}							\	}								\D 6nextop3;								\E 6I 6nextop_atom;								\E 6}I 18#endif /* BIGVM */E 18#define FVAR(n)	{							\register LispPTR *chain;						\chain = (LispPTR *) (PVar + n);						\if(WBITSPTR(chain)->LSB){						\	PUSH(GetLongWord(Addr68k_from_LADDR(				\D 18		0xFFFFFF & SWAP_WORDS(native_newframe(n >> 1)))));	\E 18I 18		POINTERMASK & SWAP_WORDS(native_newframe(n >> 1)))));	\E 18	nextop1;							\    }/* if(((WBITS */							\D 18PUSH(GetLongWord(Addr68k_from_LADDR(0xFFFFFF & SWAP_WORDS(*chain))));	\E 18I 18PUSH(GetLongWord(Addr68k_from_LADDR(POINTERMASK & SWAP_WORDS(*chain))));	\E 18nextop1;								\}#define FVARX(n)	{						\I 17register int nn = n;							\E 17register LispPTR *chain;						\D 17chain = (LispPTR *) (PVar + n);						\E 17I 17chain = (LispPTR *) (PVar + nn);						\E 17if(WBITSPTR(chain)->LSB){						\	PUSH(GetLongWord(Addr68k_from_LADDR(				\D 17		0xFFFFFF & SWAP_WORDS(native_newframe(n >> 1)))));	\E 17I 17D 18		0xFFFFFF & SWAP_WORDS(native_newframe(nn >> 1)))));	\E 18I 18		POINTERMASK & SWAP_WORDS(native_newframe(nn >> 1)))));	\E 18E 17	nextop2;							\    }/* if(((WBITS */							\D 18PUSH(GetLongWord(Addr68k_from_LADDR(0xFFFFFF & SWAP_WORDS(*chain))));	\E 18I 18PUSH(GetLongWord(Addr68k_from_LADDR(POINTERMASK & SWAP_WORDS(*chain))));	\E 18nextop2;								\}/* ********************************************************************	*//* THE FOLLOWING WAS IN n_op_inlinedefsC.h *//* ********************************************************************	*/D 4#define GCREF(n)							\	{TOPOFSTACK = htfind(TOPOFSTACK, n);				\E 4I 4#define GCREF(n) {							\	GCLOOKUPV(TOPOFSTACK, n, TOPOFSTACK);				\E 4	nextop2;}D 4E 4I 11#ifndef BIGATOMSE 11#define ATOMCELL_N(n)							\	{if ((unsigned int)TOPOFSTACK >> 16) {goto op_ufn;}		\	TOPOFSTACK = (n << 16) + (TOPOFSTACK << 1) ;			\	nextop2;							\	}I 11D 18#else		E 18I 18#elif BIGVME 18#define ATOMCELL_N(n)							\D 17      {	if (0==((unsigned int)TOPOFSTACK >> 16))			\	  { /* old-symbol case; just add cell-number arg */		\	    TOPOFSTACK = (n << 16) + (TOPOFSTACK << 1) ;		\E 17I 17      { register int nn = n;					\D 18		if (0==((unsigned int)TOPOFSTACK & 0xFFFF0000))			\E 18I 18		if (0==((unsigned int)TOPOFSTACK & SEGMASK))			\E 18	    { /* old-symbol case; just add cell-number arg */		\I 18	    switch (nn)							\	      {								\		case PLIS_HI:	/* PLIST entry for symbol */		\		  TOPOFSTACK = (PNP_HI << 16) + (10*(unsigned int)TOPOFSTACK) + NEWATOM_PLIST_OFFSET;	\		  break;						\		case PNP_HI:	/* PNAME entry for symbol */		\		  TOPOFSTACK = (PNP_HI << 16) + (10*(unsigned int)TOPOFSTACK) + NEWATOM_PNAME_OFFSET;	\		  break;						\		case VALS_HI:	/* VALUE cell for symbol */		\		  TOPOFSTACK = (PNP_HI << 16) + (10*(unsigned int)TOPOFSTACK) + NEWATOM_VALUE_OFFSET;	\		  break;						\		case DEFS_HI:	/* DEFINITION for symbol */		\		  TOPOFSTACK = (PNP_HI << 16) + (10*(unsigned int)TOPOFSTACK) + NEWATOM_DEFN_OFFSET;	\		  break;						\		default:  goto op_ufn;					\	      }								\	    nextop2;							\	    }								\	else if (TYPE_NEWATOM == GetTypeNumber(TOPOFSTACK))		\	  { /* NEW-symbol case; it's an offset from the main ptr */	\	    switch (nn)							\	      {								\		case PLIS_HI:	/* PLIST entry for symbol */		\		  TOPOFSTACK = TOPOFSTACK + NEWATOM_PLIST_OFFSET;	\		  break;						\		case PNP_HI:	/* PNAME entry for symbol */		\		  TOPOFSTACK = TOPOFSTACK + NEWATOM_PNAME_OFFSET;	\		  break;						\		case VALS_HI:	/* VALUE cell for symbol */		\		  TOPOFSTACK = TOPOFSTACK + NEWATOM_VALUE_OFFSET;	\		  break;						\		case DEFS_HI:	/* DEFINITION for symbol */		\		  TOPOFSTACK = TOPOFSTACK + NEWATOM_DEFN_OFFSET;	\		  break;						\		default:  goto op_ufn;					\	      }								\	    nextop2;							\	  }								\	else goto op_ufn;						\	}#else /* 	 */#define ATOMCELL_N(n)							\      { register int nn = n;					\		if (0==((unsigned int)TOPOFSTACK & SEGMASK))			\	    { /* old-symbol case; just add cell-number arg */		\E 18	    TOPOFSTACK = (nn << 16) + (TOPOFSTACK << 1) ;		\E 17	    nextop2;							\D 17	  }								\E 17I 17	    }								\E 17	else if (TYPE_NEWATOM == GetTypeNumber(TOPOFSTACK))		\	  { /* NEW-symbol case; it's an offset from the main ptr */	\D 17	    switch (n)							\E 17I 17	    switch (nn)							\E 17	      {								\		case PLIS_HI:	/* PLIST entry for symbol */		\I 13		  TOPOFSTACK = TOPOFSTACK + NEWATOM_PLIST_OFFSET;	\		  break;						\E 13		case PNP_HI:	/* PNAME entry for symbol */		\I 13		  TOPOFSTACK = TOPOFSTACK + NEWATOM_PNAME_OFFSET;	\		  break;						\E 13		case VALS_HI:	/* VALUE cell for symbol */		\I 13		  TOPOFSTACK = TOPOFSTACK + NEWATOM_VALUE_OFFSET;	\		  break;						\E 13		case DEFS_HI:	/* DEFINITION for symbol */		\I 13		  TOPOFSTACK = TOPOFSTACK + NEWATOM_DEFN_OFFSET;	\		  break;						\E 13		default:  goto op_ufn;					\	      }								\	    nextop2;							\	  }								\	else goto op_ufn;						\	}D 18#endif BIGATOMSE 18I 18#endif /* BIGATOMS */E 18E 11#define DIFFERENCE	{N_OP_CALL_2(N_OP_difference);}#define LOGOR		{N_OP_CALL_2(N_OP_logor);}#define LOGAND 		{N_OP_CALL_2(N_OP_logand);}#define LOGXOR 		{N_OP_CALL_2(N_OP_logxor);}#define PLUS2		{N_OP_CALL_2(N_OP_plus2);}#define QUOTIENT	{N_OP_CALL_2(N_OP_quot);}#define TIMES2		{N_OP_CALL_2(N_OP_times2);}#define	GREATERP	{N_OP_CALL_2(N_OP_greaterp);}#define IDIFFERENCE	{N_OP_CALL_2(N_OP_idifference);}#define IPLUS2		{N_OP_CALL_2(N_OP_iplus2);}#define IQUOTIENT	{N_OP_CALL_2(N_OP_iquot);}#define ITIMES2		{N_OP_CALL_2(N_OP_itimes2);}#define	IGREATERP	{N_OP_CALL_2(N_OP_igreaterp);}#define IREMAINDER	{N_OP_CALL_2(N_OP_iremainder);}#define IPLUS_N(n)	{N_OP_CALL_1d(N_OP_iplusn, n)}#define IDIFFERENCE_N(n)	{N_OP_CALL_1d(N_OP_idifferencen, n);}#define BOXIPLUS	{N_OP_CALL_2(N_OP_boxiplus);}#define BOXIDIFFERENCE	{N_OP_CALL_2(N_OP_boxidiff);}#define FPLUS2		{N_OP_CALL_2(N_OP_fplus2);}#define FDIFFERENCE	{N_OP_CALL_2(N_OP_fdifference);}#define FTIMES2		{N_OP_CALL_2(N_OP_ftimes2);}#define FQUOTIENT	{N_OP_CALL_2(N_OP_fquotient);}#define FGREATERP	{N_OP_CALL_2(N_OP_fgreaterp);}#define UBFLOAT1(n)	{N_OP_UNBOXED_CALL_1d(N_OP_ubfloat1, n);}#define UBFLOAT2(n)	{N_OP_UNBOXED_CALL_2d(N_OP_ubfloat2, n);}#define UBFLOAT3(n)	{N_OP_UNBOXED_CALL_3d(N_OP_ubfloat3, n);}#define LRSH1		{N_OP_CALL_1(N_OP_lrsh1);}#define LRSH8		{N_OP_CALL_1(N_OP_lrsh8);}#define LLSH1		{N_OP_CALL_1(N_OP_llsh1);}#define LLSH8		{N_OP_CALL_1(N_OP_llsh8);}#define LSH		{N_OP_CALL_2(N_OP_lsh);}#define RPLACA		{N_OP_CALL_2(N_OP_rplaca);}#define RPLACD		{N_OP_CALL_2(N_OP_rplacd);}#define RPLCONS		{N_OP_CALL_2(N_OP_rplcons);}#define MAKENUMBER 	{N_OP_CALL_2(N_OP_makenumber);}#define EQLOP		{N_OP_CALL_2(N_OP_eqlop);}#define CLEQUAL		{N_OP_CALL_2(N_OP_clequal);}#define ILEQUAL		{N_OP_CALL_2(N_OP_equal);}#define CLFMEMB		{N_OP_CALL_exception_2(N_OP_clfmemb);}#define CLASSOC		{N_OP_CALL_exception_2(N_OP_classoc);}#define FMEMB		{N_OP_CALL_exception_2(N_OP_fmemb);}#define ASSOC		{N_OP_CALL_exception_2(N_OP_assoc);}#define ARG0		{N_OP_CALL_1(N_OP_arg0);}#define LISTGET		{N_OP_CALL_exception_2C(N_OP_listget);}#define DRAWLINE	{N_OP_CALL_9(N_OP_drawline);}#define N_OP_ADDBASE	{N_OP_CALL_2(N_OP_addbase);}#define UNWIND(n, m)							\		{	 						\D 9		 if ((int)(CSTKPTR = (LispPTR *)			\E 9I 9		 if ((int)(CSTKPTRL = (LispPTR *)			\E 9		      N_OP_unwind(CSTKPTR, TOPOFSTACK, n, m)) < 0) 	\			goto unwind_err;				\		 POP;							\		 nextop3;						\		}#define STKSCAN								\		{TOPOFSTACK = N_OP_stkscan(TOPOFSTACK);			\		 nextop1;						\		}#define FVARX_(n)							\		{TOPOFSTACK = N_OP_fvar_(TOPOFSTACK, n);		\		 nextop2;						\		}#define BLT		{N_OP_CALL_3(N_OP_blt);}#define PILOTBITBLT							\		{TOPOFSTACK = N_OP_pilotbitblt(POP_TOS_1, TOPOFSTACK);	\		 nextop1;						\		}#define CREATECELL	{N_OP_CALL_1(N_OP_createcell);}#define RESTLIST(n)	{TOPOFSTACK = N_OP_restlist(POP_TOS_1, TOPOFSTACK, n);\			nextop2;}#define ASET1		{N_OP_CALL_3(N_OP_aset1);}#define ASET2		{N_OP_CALL_4(N_OP_aset2);}#define MISC3(n)	{N_OP_CALL_3d(N_OP_misc3, n);}#define MISC4(n)	{N_OP_CALL_4d(N_OP_misc4, n);}#define MISC7(n)	{N_OP_CALL_7d(N_OP_misc7, n);}#define AREF2		{N_OP_CALL_3(N_OP_aref2);}#define MISCN(index, args)						\{	EXT;								\D 17	if (OP_miscn())  {						\E 17I 17	if (OP_miscn(index,args))  {					\E 17		RET;							\	/*	PUSH(S_POSITIVE | (index << 8) | args);		*/	\		goto op_ufn;						\		}							\	RET;								\	nextop0;							\}/* ******************************************************************** *//*	Call Interface where -1 indicates an error return		*//* ******************************************************************** *//* SV need do no work */#define SV/* UFN_CALLS are inserted in xc.c. Note that only ufn_2 calls have decremented the stack at the time the UFN is called *//* ufn_x	there are x args from the Lisp stack   ufn_xd	there are x args from the Lisp stack & 		some from the code stream.*/#define	UFN_CALLS							\									\unwind_err:	 							\D 9	CSTKPTR = (LispPTR *) CurrentStackPTR;				\E 9I 9	CSTKPTRL = (LispPTR *) CurrentStackPTR;				\E 9	Error_Exit = 0;							\	goto op_ufn;							\D 9ufn_2d:	CSTKPTR += 1;							\E 9I 9ufn_2d:	CSTKPTRL += 1;							\E 9	goto fix_tos_ufn;						\D 9ufn_2d2:CSTKPTR += 1;							\E 9I 9ufn_2d2:CSTKPTRL += 1;							\E 9	goto fix_tos_ufn;						\D 9ufn_2:	CSTKPTR += 1;							\E 9I 9ufn_2:	CSTKPTRL += 1;							\E 9	goto fix_tos_ufn;						\exception_2 : 								\	Error_Exit = 0;							\D 9	CSTKPTR += 1;							\E 9I 9	CSTKPTRL += 1;							\E 9	TOPOFSTACK = TopOfStack;					\	if(!Irq_Stk_End){						\		 goto check_interrupt;					\	}								\	else goto op_ufn;						\exception_2C : 								\	Error_Exit = 0;							\	TOPOFSTACK = TopOfStack;					\D 9	*CSTKPTR = Scratch_CSTK;					\	CSTKPTR += 1;							\E 9I 9	*CSTKPTRL = Scratch_CSTK;					\	CSTKPTRL += 1;							\E 9	if(!Irq_Stk_End){						\		 goto check_interrupt;					\	}								\	else {								\		goto op_ufn;						\	}								\fix_tos_ufn:								\	TOPOFSTACK = TopOfStack;					\	Error_Exit = 0;							\	goto op_ufn;#define N_OP_CALL_1(op_name)						\D 9if ((int)((int)TOPOFSTACK = op_name(TOPOFSTACK)) < 0) goto fix_tos_ufn;	\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(TOPOFSTACK)) < 0) goto fix_tos_ufn;\E 9nextop1;#define N_OP_CALL_1d(op_name, n)					\D 9if ((int)((int)TOPOFSTACK = op_name(TOPOFSTACK, n)) < 0) goto fix_tos_ufn;\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(TOPOFSTACK, n)) < 0) goto fix_tos_ufn;\E 9nextop2;#define N_OP_UNBOXED_CALL_1d(op_name, n)				\TOPOFSTACK = op_name(TOPOFSTACK, n);					\if (Error_Exit) goto fix_tos_ufn;					\nextop2;#define N_OP_CALL_2(op_name)						\D 9if ((int)((int)TOPOFSTACK = op_name(POP_TOS_1, TOPOFSTACK)) < 0)	\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(POP_TOS_1, TOPOFSTACK)) < 0)	\E 9	goto ufn_2;							\nextop1;#define N_OP_POPPED_CALL_2(op_name, popped_arg)				\D 9if ((int)((int)TOPOFSTACK = op_name(popped_arg, TOPOFSTACK)) < 0)	\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(popped_arg, TOPOFSTACK)) < 0)	\E 9	goto ufn_2;							\nextop1;#define N_OP_CALL_2d(op_name, n)					\D 9if ((int)((int)TOPOFSTACK = op_name(POP_TOS_1, TOPOFSTACK, n)) < 0)	\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(POP_TOS_1, TOPOFSTACK, n)) < 0)	\E 9	goto ufn_2d;							\nextop2;#define N_OP_UNBOXED_CALL_2d(op_name, n)				\TOPOFSTACK = op_name(POP_TOS_1, TOPOFSTACK, n);				\if (Error_Exit) goto ufn_2d;						\nextop2;#define N_OP_CALL_2d2(op_name, a, b)					\D 9if ((int)((int)TOPOFSTACK = op_name(POP_TOS_1, TOPOFSTACK, a, b)) < 0)	\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(POP_TOS_1, TOPOFSTACK, a, b)) < 0) \E 9	goto ufn_2d2;							\nextop3;#define N_OP_CALL_exception_2(op_name)					\D 9if ((int)((int)TOPOFSTACK = op_name(POP_TOS_1, TOPOFSTACK)) < 0)	\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(POP_TOS_1, TOPOFSTACK)) < 0)	\E 9	goto exception_2;						\nextop1;#define N_OP_CALL_exception_2C(op_name)					\D 9if ((int)((int)TOPOFSTACK = op_name(POP_TOS_1, TOPOFSTACK)) < 0)	\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(POP_TOS_1, TOPOFSTACK)) < 0)	\E 9	goto exception_2C;						\nextop1;#define N_OP_CALL_3(op_name)						\D 9if ((int)((int)TOPOFSTACK = op_name(					\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(					\E 9		 *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK)) < 0)		\	goto fix_tos_ufn;						\D 9CSTKPTR -= 2;								\E 9I 9CSTKPTRL -= 2;								\E 9nextop1;#define N_OP_CALL_3d(op_name, n)					\D 9if ((int)((int)TOPOFSTACK = op_name(					\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(				\E 9		 *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n)) < 0)	\	goto fix_tos_ufn;						\D 9CSTKPTR -= 2;								\E 9I 9CSTKPTRL -= 2;								\E 9nextop2;#define N_OP_UNBOXED_CALL_3d(op_name, n)				\TOPOFSTACK = op_name(*(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n);	\if (Error_Exit) goto fix_tos_ufn;					\D 9CSTKPTR -= 2;								\E 9I 9CSTKPTRL -= 2;								\E 9nextop2;#define N_OP_CALL_4(op_name)						\D 9if ((int)((int)TOPOFSTACK = op_name(					\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(				\E 9	*(CSTKPTR-3), *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK)) < 0)	\	goto fix_tos_ufn;						\D 9CSTKPTR -= 3;								\E 9I 9CSTKPTRL -= 3;								\E 9nextop1;#define N_OP_CALL_4d(op_name, n)					\D 9if ((int)((int)TOPOFSTACK = op_name(					\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(					\E 9	*(CSTKPTR-3), *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n)) < 0)	\	goto fix_tos_ufn;						\D 9CSTKPTR -= 3;								\E 9I 9CSTKPTRL -= 3;								\E 9nextop2;#define N_OP_CALL_7d(op_name, n)					\D 9if ((int)((int)TOPOFSTACK = op_name(					\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(					\E 9	*(CSTKPTR-6), *(CSTKPTR-5), *(CSTKPTR-4),			\	*(CSTKPTR-3), *(CSTKPTR-2), *(CSTKPTR-1), TOPOFSTACK, n)) < 0)	\	goto fix_tos_ufn;						\D 9CSTKPTR -= 6;								\E 9I 9CSTKPTRL -= 6;								\E 9nextop2;#define N_OP_CALL_9(op_name)						\D 9if ((int)((int)TOPOFSTACK = op_name(					\E 9I 9if ((int)(TOPOFSTACK = (LispPTR)op_name(				\E 9		 *(CSTKPTR-8), *(CSTKPTR-7), *(CSTKPTR-6),		\		 *(CSTKPTR-5), *(CSTKPTR-4), *(CSTKPTR-3), *(CSTKPTR-2),\D 2		 *(CSTKPTR-1), TOPOFSTACK, fix_tos_ufn)) < 0)		\E 2I 2		 *(CSTKPTR-1), TOPOFSTACK /*, fix_tos_ufn*/)) < 0)	\E 2	goto fix_tos_ufn;						\D 9CSTKPTR -= 8;								\E 9I 9CSTKPTRL -= 8;								\E 9nextop1;#ifdef SUN3_OS3_OR_OS4_IL/* need jump point for inline asm code, e.g., for IPLUS */#define OPCODEFAIL							\									\fixtos1:								\	fixtos1_label();						\	FIXTOS1;							\	goto op_ufn;#else/* no opcode fail point necessary */#define OPCODEFAIL#endifE 1