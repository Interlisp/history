h64198s 00001/00001/00195d D 1.4 93/02/08 14:55:20 sybalsky 4 3c Big VM (and new CDR coding) changes for 3.0 \nes 00024/00003/00172d D 1.3 92/07/24 10:46:29 sybalsky 3 2c retrofit of SGI & DEC OSF1 changes \nes 00010/00005/00165d D 1.2 92/04/22 14:35:11 sybalsky 2 1c fix SCCS headeres 00170/00000/00000d D 1.1 92/04/21 15:28:55 sybalsky 1 0c date and time created 92/04/21 15:28:55 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";D 2/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 2I 2E 2/************************************************************************//*									*/D 2/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 2I 2/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 2/*									*/D 2/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medlet.		*/E 2I 2/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 2/*									*//************************************************************************/I 2E 2/* =========================================================================	The functions defined in this file are used to validate the copyright	protection keys for NewCo's Maiko software. The main function is	'keytester', which takes an input key string and returns a status	code after processing the keys.		The external functions called were stored in file 'keylib.o'.	Creation date: May, 1988  ====================================================================== */#include <stdio.h>#include <string.h>#include <ctype.h>I 3#ifdef HPUX	/* On HPUX, use the UNAME syscall to get hostid */#include	<sys/utsname.h>#endifE 3I 3E 3#define	GOLDEN_RATIO_HACK			-478700649#define	floadbyte(number,pos)		((number >> pos) & 0xFFFF)#define	hash_unhash(number,hashkey)	(number ^ (GOLDEN_RATIO_HACK * (floadbyte(hashkey,16) + floadbyte(hashkey,0)) ))#define	KEYNUMBERS					3#define	RC0						0/*   meaning of symbolic constants used: 		FAILURE2	invalid date		FAILURE3	invalid key 		FAILURE4	key expired           		FAILURE99	invalid date  (this shouldn't happen unless string format returned by ctime got changed) */#define	FAILURE2					-2#define	FAILURE3					-3#define	FAILURE4					-4#define 	FAILURE99					-99unsigned long make_verification();unsigned long date_integer16();unsigned long idate();unsigned long modify();/* =====================================================================	KEYTESTER checks the input key string.       It returns 0 if the keys are valid, otherwise it returns non-0.  ====================================================================== */int keytester(keystring) char *keystring;D 3  {    unsigned long keyarray[KEYNUMBERS];	/* array which holds numeric keys */E 3I 3  {    unsigned long keyarray[KEYNUMBERS];	/* array which holds numeric keys */E 3    unsigned long	hostid ;	/* 32-bit unique identifier of the current host  */    unsigned long	hashedword;    int			rc;		/* return code */I 3#ifdef HPUX    struct utsname unameinfo;#endifE 3	/* check the keys and convert them from hexdecimal strings to numbers  */    if (keystring == NULL) return FAILURE3;    if ( read_hex(keystring , keyarray) == FAILURE3)  return FAILURE3 ;    /*  get machines host id  */I 3#ifdef HPUX    uname(&unameinfo);    hostid = atol(unameinfo.idnumber);#elseE 3    hostid = gethostid();I 3#endifE 3    hostid = modify(hostid);    /*  generate hashword */    hashedword = hash_unhash(keyarray[1] , hostid);	    /*  validate keys	*/    if (keyarray[0] != hash_unhash(hostid , hostid))  return FAILURE3;     if ((rc = ok_date(floadbyte(hashedword , 16))) != RC0) return rc;    if (keyarray[2] != make_verification(keyarray[0] , keyarray[1]))      return FAILURE3;	    return 0;    }/* =====================================================================	READ_HEX reads in keys from the input string , validates them, then       stores them in the input array.  ====================================================================== */int read_hex(s1 , array)  char 			*s1 ;  unsigned long 	*array ;  {    char *s2 = {" "};    char *ptr;    char *hexdigits = {"0123456789abcdefABCDEF"};    int i ;	    for (i = 0 ; (i < KEYNUMBERS) && ((ptr = strtok(s1 , s2)) != NULL) ; ++i)      {	/* make sure the key contains only hexadecimal characters */	if ( (strspn (ptr,hexdigits)) != strlen(ptr)) return FAILURE3;	/* convert key to numeric format*/D 3	*(array + i) = strtol(ptr,NULL,16);E 3I 3#ifdef HPUX	*(array + i) = strtoul(ptr,NULL,16);	/* On HP, must convert to unsigned */#elif defined(APOLLO)	*(array + i) = strtoul(ptr,NULL,16);	/* On APOLLO, must convert to unsigned */#elif defined(INDIGO)	*(array + i) = strtoul(ptr,NULL,16);	/* On Indigo, must convert to unsigned */#else	*(array + i) = strtol(ptr,NULL,16);	/* On suns, this works OK */#endifE 3D 4E 4I 4printf("0x%x ", *(array+i)); fflush(stdout);E 4	/* continue search the next one */	s1 = NULL;      };    if (i == KEYNUMBERS) return RC0;       else return FAILURE3;  }/* ============================================	OK_DATE checks the expiration of the key   ============================================ */int ok_date (date)  unsigned long date ;  {    char current_date[30];    char *mptr, *dptr, *yptr, *str;    long realtime , *clock;    /* first check if the expiration date is set to indefinite */     /* printf("\narg date: %ld  %x\n", date, date); */     /* printf("\narg date ?????: %ld  %x\n", date_integer16("29-DEC-77"), date_integer16("29-DEC-77")); */    if  (date == date_integer16("29-DEC-77")) return RC0;    /* next check if current date is less than or equal to the expiration date */    /* get the current date  string */	realtime = time(0);	clock = &realtime;	str =  (char *) ctime(clock);	/* delete day and time info and rearrange the string format to be dd-mmm-yy */    mptr = strtok(str," ");    mptr = strtok(NULL," ");    dptr = strtok(NULL," ");    yptr = strtok(NULL," ");    yptr = strtok(NULL," \n");		/* watch out for newline char */    current_date[0] = '\0';    strcat(current_date , dptr);    strcat(current_date , "-");    strcat(current_date , mptr);    strcat(current_date , "-");    strcat(current_date , yptr);    /* check the date */    if (idate(current_date) == FAILURE2) return FAILURE99;	    /* printf("*current date*: %ld %x\n", date_integer16(current_date), date_integer16(current_date)); */    return (date_integer16(current_date) <= date ) ? RC0 : FAILURE4; }E 1