h07439s 00054/00027/00407d D 1.21 92/11/25 21:04:57 sybalsky 21 20c Fixing endif's with extra text => comment. \nes 00014/00004/00420d D 1.20 92/06/26 13:49:08 sybalsky 20 19c retrofit of 386 unix changes \nes 00005/00005/00419d D 1.19 92/04/21 17:15:43 sybalsky 19 18c shortening file names for DOS \nes 00001/00000/00423d D 1.18 92/01/16 12:34:42 sybalsky 18 17c HP changes from savoires 00024/00008/00399d D 1.17 91/09/27 02:30:33 sybalsky 17 16c ISC port changeses 00012/00000/00395d D 1.16 91/04/09 17:10:56 sybalsky 16 15c Retrofit first round of changes from MIPS porting centeres 00048/00021/00347d D 1.15 91/03/14 20:23:16 sybalsky 15 14c AIX/HPUX change:  Use ioctl(--,FIONBIO/FIOSNBIO,..) for non-blocking I/O.es 00011/00002/00357d D 1.14 91/02/04 12:53:02 sybalsky 14 13c Fix errors in teh Savoir retrofit (placement of ifdefs &c)es 00016/00002/00343d D 1.13 91/01/24 19:48:51 sybalsky 13 12c Take in Savoir's version of the code.es 00036/00002/00309d D 1.12 90/09/18 23:44:01 sybalsky 12 11c Retrofit changes from AIX, DEC3100, PS/2es 00016/00004/00295d D 1.11 90/08/21 17:15:34 sybalsky 11 10c Retrofit AIX changes from IBMes 00000/00000/00299d D 1.10 90/07/04 03:59:23 sybalsky 10 9c Small fixes to decls.es 00001/00001/00298d D 1.9 90/05/30 11:08:20 sybalsky 9 8c ANSI C fixeses 00000/00000/00299d D 1.8 90/04/20 01:38:41 sybalsky 8 7c AIX:  shortening file names, bulk change.es 00005/00001/00294d D 1.7 90/04/19 22:48:19 sybalsky 7 6c AIX:  fix LispPTR int foo decles 00039/00019/00256d D 1.6 90/04/05 18:55:04 sybalsky 6 5c UDP listen/send/recv changes from Savoires 00069/00011/00206d D 1.5 90/02/12 14:26:53 sybalsky 5 4c Add more UDP code.es 00002/00001/00215d D 1.4 90/02/06 11:46:24 sybalsky 4 3c More TCP supportes 00099/00020/00117d D 1.3 89/12/29 13:00:07 sybalsky 3 2c Savoir code -- TCP support, add UDP listen, connectes 00002/00004/00135d D 1.2 89/12/28 15:25:22 sybalsky 2 1c es 00139/00000/00000d D 1.1 89/12/08 17:21:54 sybalsky 1 0c date and time created 89/12/08 17:21:54 by sybalskyeuUtTI 11/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";I 20E 20/************************************************************************//*									*/D 14/*	Copyright 1989, 1990 Venue					*/E 14I 14D 20/*	Copyright 1989, 1990, 1991 Venue				*/E 20I 20/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 20E 14/*									*/D 20/*	This file is NOT work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 20I 20/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 20/*									*//************************************************************************/D 20E 20E 11I 1D 2/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 2#include <stdio.h>#include <ctype.h>D 17#include <sys/file.h>E 17#include <sys/types.h>I 17#include <sys/file.h>E 17I 6#include <signal.h>I 17#ifdef ISC#include <sys/fcntl.h>I 18#include <sys/bsdtypes.h>E 18D 21#endif ISCE 21I 21#endif /* ISC */E 21E 17E 6#include <sys/time.h>D 17#include <sys/types.h>E 17#include <sys/socket.h>#include <netinet/in.h>#include <netdb.h>I 14#include <sys/ioctl.h>E 14I 3#include <errno.h>E 3#include "lispemul.h"#include "lispmap.h"D 19#include "lisptypes.h"E 19I 19#include "lsptypes.h"E 19#include "arith.h"D 19#include "emulglobal.h"#include "lispglobal.h"#include "address68k.h"E 19I 19#include "emlglob.h"#include "lspglob.h"#include "adr68k.h"E 19#include "ether.h"#include "dbprint.h"D 19#include "localfile.h"E 19I 19#include "locfile.h"E 19I 13#ifdef HPUX#define FASYNC O_NONBLOCKD 21#endif NPUXE 21I 21#endif /* NPUX */E 21I 17#ifdef ISC#define FASYNC O_NONBLOCK#define SIGIO SIGPOLLD 21#endif ISCE 21I 21#endif /* ISC */E 21I 20I 21E 21#ifdef GCC386#include "inlnPS2.h"#endifE 20E 17E 13#define TCPhostlookup 0#define TCPservicelookup 1#define TCPsocket	2#define TCPclose	3#define	TCPconnect	4#define TCPsend		5#define TCPrecv		6I 3#define TCPListen	7#define TCPAccept	8E 3I 5#define INETpeername	64	/* (socket buf) => buf has name, returns len */#define INETpeeraddr	65#define INETgetname	66	/* Address to name translation */E 5D 3extern u_int LispIOFds;E 3I 3#define UDPListen	128#define UDPConnect	129I 5#define UDPSendto	130#define UDPRecvfrom	131E 5E 3I 7D 11#ifdef AIX#define FNDELAY O_NONDELAY#endifE 11E 7I 3extern u_int LispIOFds, LispReadFds;extern int *Lisp_errno;E 3D 2subr_TCP_ops (op, nameConn, proto, length)  int op;E 2I 2D 5subr_TCP_ops (op, nameConn, proto, length, null1, null2)  int op, null1, null2;E 2  LispPTR  int nameConn, proto, length; E 5I 5subr_TCP_ops (op, nameConn, proto, length, bufaddr, maxlen)  int op;D 7  LispPTR  int nameConn, proto, length, bufaddr, maxlen; E 7I 7  LispPTR nameConn, proto, length, bufaddr, maxlen; E 7E 5  {D 3    int sock, len, buflen;E 3I 3    int sock, len, buflen, res;E 3    char namestring[100];    char servstring[50];    struct sockaddr_in addr;    struct hostent *host;    struct servent *service;    struct sockaddr_in farend;    int addr_class, protocol;    char *buffer;D 3    LispPTR result;E 3I 3    int result;I 14#ifdef RS6000    static int one=1;		/* Used in TCPconnect */#endifE 14E 3    switch (op & 0xFFFF)      {	case TCPhostlookup:	LispStringToCString(nameConn, namestring, 100);				host = gethostbyname(namestring);				if (!host) return(NIL);D 3				printf("haddr len = %d, addr = 0x%x.\n",host->h_length, host->h_addr);E 3D 5				N_ARITH_SWITCH((int)host->h_addr);E 5I 5				N_ARITH_SWITCH(*(int *)host->h_addr);E 5				break;	case TCPservicelookup:	LispStringToCString(nameConn, namestring, 100);				LispStringToCString(proto, servstring, 50);				service = getservbyname(namestring, servstring);				if (!service) return(NIL);D 3				printf("srvr port = %d.\n",service->s_port);E 3				return(GetSmallp(service->s_port));				break;	case TCPsocket:		addr_class = LispNumToCInt(nameConn);				protocol = LispNumToCInt(proto);				result = socket(addr_class, protocol, 0);I 15#ifdef RS6000				ioctl(result, FIONBIO, &one);				fcntl(result, F_SETOWN, getpid());#else#ifdef HPUX				ioctl(result, FIOSNBIO, &one);#elseE 15D 3				fcntl(result,  fcntl(result, F_GETFL, 0)E 3I 3				fcntl(result, F_SETFL,  fcntl(result, F_GETFL, 0)E 3					      | FNDELAY | FASYNC);I 17#ifndef ISCE 17I 13D 15#ifndef HPUXE 15E 13				fcntl(result, F_SETOWN, getpid());I 17D 21#endif ISCE 17I 13#endif HPUXI 15#endif RS6000E 21I 21#endif /* ISC */#endif /* HPUX */#endif /* RS6000 */E 21E 15E 13				return(GetSmallp(result));				break;	case TCPconnect:	/* args: hostname, socket# */I 4	  			bzero(&farend, sizeof farend);I 12				N_GETNUMBER(nameConn, res, string_host);				farend.sin_addr.s_addr = htons(res);				goto host_ok;			      string_host:E 12E 4				LispStringToCString(nameConn, namestring, 100);D 12				sock = LispNumToCInt(proto);				result = socket(AF_INET, SOCK_STREAM, 0);E 12D 3				fcntl(result,  fcntl(result, F_GETFL, 0)					      | FNDELAY/* | FASYNC */);				fcntl(result, F_SETOWN, getpid());E 3				host = gethostbyname(namestring);				if (!host) return(NIL);I 12				bcopy( (char *)host->h_addr,				       (char *)&farend.sin_addr,				       host->h_length);			      host_ok:				sock = LispNumToCInt(proto);				result = socket(AF_INET, SOCK_STREAM, 0);E 12				farend.sin_family = AF_INET;				bcopy( (char *)host->h_addr,				       (char *)&farend.sin_addr,				       host->h_length);				farend.sin_port = sock;D 4				if (connect(result, farend, sizeof farend)<0)E 4I 4				if (connect(result, &farend, sizeof farend)<0)E 4				  {				    perror("TCP connect");				    return(NIL);				  }I 3D 15				fcntl(result, F_SETFL,				      fcntl(result, F_GETFL, 0)	 | FNDELAY);E 15I 14#ifdef RS6000				/* FNDELAY alone isn't enough on aix */				/* (don't know if FIONBIO alone is enough) */				ioctl(result, FIONBIO, &one);D 15#endif RS6000E 14I 13#ifndef HPUXE 15E 13				fcntl(result, F_SETOWN, getpid());I 15#else#ifdef HPUX				ioctl(result, FIOSNBIO, &one);#else				fcntl(result, F_SETFL,  fcntl(result, F_GETFL, 0)					      | FNDELAY);I 17#ifndef ISCE 17				fcntl(result, F_SETOWN, getpid());I 17D 21#endif ISCE 17E 15I 13#endif HPUXI 15#endif RS6000E 21I 21#endif /* ISC */#endif /* HPUX */#endif /* RS6000 */E 21E 15E 13E 3				return(GetSmallp(result));				break;	case TCPsend:		/* args: conn, buffer, len */				sock = LispNumToCInt(nameConn);				buffer = (char *)Addr68k_from_LADDR(proto);				len = LispNumToCInt(length);D 3				printf("sock: %d, len %d.\n", sock, len);E 3I 3				DBPRINT(("sock: %d, len %d.\n", sock, len));I 12#ifdef BYTESWAP				word_swap_page(buffer, (len + 3) >> 2);D 21#endif BYTESWAPE 21I 21#endif /* BYTESWAP */E 21I 21E 21E 12E 3				result = send(sock, buffer, len, 0);I 12#ifdef BYTESWAP				word_swap_page(buffer, (len + 3) >> 2);D 21#endif BYTESWAPE 21I 21#endif /* BYTESWAP */E 21I 21E 21E 12				if (result < 0)				  {				    perror("TCP send"); return(NIL);				  }				return(GetSmallp(result));				break;	case TCPrecv:		/* args: conn, buffer, maxlen */				sock = LispNumToCInt(nameConn);D 3				buffer = Addr68k_from_LADDR(proto);E 3I 3				buffer = (char *)Addr68k_from_LADDR(proto);E 3				len = LispNumToCInt(length);D 6				result = recv(sock, buffer, len, 0);E 6I 6D 14				result = read(sock, buffer, len, 0);E 14I 14				result = read(sock, buffer, len);E 14E 6				if (result < 0)				  {D 3				    perror("TCP recv"); return(NIL);E 3I 3				    if (errno == EWOULDBLOCK)				      return(ATOM_T);D 6				    perror("TCP recv");E 6I 6				    perror("TCP read");E 6				    *Lisp_errno = errno;				    return(NIL);E 3				  }I 12#ifdef BYTESWAP				word_swap_page(buffer, (result + 3) >> 2);D 21#endif BYTESWAPE 21I 21#endif /* BYTESWAP */E 21E 12				return(GetSmallp(result));				break;	case TCPclose:		sock = LispNumToCInt(nameConn);D 3				LispIOFds &= !(1<<sock);E 3I 3				LispIOFds &= ~(1<<sock);				LispReadFds &= ~(1<<sock);E 3				shutdown(sock, 2);				close(sock);				return(ATOM_T);I 3	case TCPListen:		/* socket# to listen on */				sock = LispNumToCInt(nameConn);				result = socket(AF_INET, SOCK_STREAM, 0);				farend.sin_family = AF_INET;				farend.sin_port = sock;				farend.sin_addr.s_addr = INADDR_ANY;				if (bind(result, &farend, sizeof(farend))<0)				  {				    perror("TCP bind");				    close(result);				    return(NIL);				  }D 6				if (fcntl(result, F_SETFL,				      fcntl(result, F_GETFL, 0)	 | FNDELAY								 | FASYNC)<0)				  perror("TCP Listen ASYNC");;				if (fcntl(result, F_SETOWN, getpid()) < 0)				  perror("TCP Listen SETOWN");				if (listen(result, 5) == -1)				  {				    perror("TCP Listen");				    close(result);				    return(NIL);				  }E 6I 6				{ /* Do this without taking IO interrupts */I 16D 17#ifdef RISCOSE 17I 17#ifdef SYSVSIGNALSE 17				sighold(SIGIO);#elseE 16				  int oldmask = sigblock(sigmask(SIGIO));I 16D 17#endif RISCOSE 17I 17D 21#endif SYSVSIGNALSE 21I 21#endif /* SYSVSIGNALS */E 21E 17E 16D 15				  if (fcntl(result, F_SETFL,E 15I 15#ifdef RS6000				ioctl(result, FIONBIO, &one);				fcntl(result, F_SETOWN, getpid());#else#ifdef HPUX				ioctl(result, FIOSNBIO, &one);#else				fcntl(result, F_SETFL,E 15				        fcntl(result, F_GETFL, 0) | FNDELAYD 15								  | FASYNC)<0)D 13				    perror("TCP Listen ASYNC");;E 13I 13				    perror("TCP Listen ASYNC");#ifndef HPUXE 13				  if (fcntl(result, F_SETOWN, getpid()) < 0)				    perror("TCP Listen SETOWN");E 15I 15								  | FASYNC);I 17#ifndef ISCE 17				fcntl(result, F_SETOWN, getpid());I 17D 21#endif ISCE 17E 15I 13#endif HPUXI 15#endif RS6000E 21I 21#endif /* ISC */#endif /* HPUX */#endif /* RS6000 */E 21E 15E 13								  if (listen(result, 5) == -1)				    {				      perror("TCP Listen");				      close(result);I 16D 17#ifdef RISCOSE 17I 17#ifdef SYSVSIGNALSE 17				      sigrelse(SIGIO);#elseE 16				      sigsetmask(oldmask);I 16D 17#endif RISCOSE 17I 17D 21#endif SYSVSIGNALSE 21I 21#endif /* SYSVSIGNALS */E 21E 17E 16				      return(NIL);				    }I 16D 17#ifdef RISCOSE 17I 17#ifdef SYSVSIGNALSE 17				sigrelse(SIGIO);#elseE 16				  sigsetmask(oldmask);I 16D 17#endif RISCOSE 17I 17D 21#endif SYSVSIGNALSE 21I 21#endif /* SYSVSIGNALS */E 21E 17E 16				}E 6				LispIOFds |= (1 << result); /* so we get interrupts */				LispReadFds |= LispIOFds;				DBPRINT(("LispIOFds = 0x%x.\n", LispIOFds));				return(GetSmallp(result));				break;	case TCPAccept:		/* Socket we're listening on */				sock = LispNumToCInt(nameConn);				result = accept(sock, NULL, 0);				if (result < 0)				  {				    if (errno != EWOULDBLOCK)				      perror("TCP Accept");				    return(NIL);				  }D 15				fcntl(result, F_SETFL,				      fcntl(result, F_GETFL, 0)	 | FNDELAY);I 13#ifndef HPUXE 15I 15#ifdef RS6000				ioctl(result, FIONBIO, &one);E 15E 13				fcntl(result, F_SETOWN, getpid());I 15#else#ifdef HPUX				ioctl(result, FIOSNBIO, &one);#else				fcntl(result, F_SETFL,  fcntl(result, F_GETFL, 0)					      | FNDELAY);I 17#ifndef ISCE 17				fcntl(result, F_SETOWN, getpid());I 17D 21#endif ISCE 17E 15I 13#endif HPUXI 15#endif RS6000E 21I 21#endif /* ISC */#endif /* HPUX */#endif /* RS6000 */E 21E 15E 13				return(GetSmallp(result));				break;I 5	case INETpeername:	/* socket#, buffer for name string */				sock = LispNumToCInt(nameConn);				buffer = (char *)Addr68k_from_LADDR(proto);				res = sizeof(addr);				getpeername(sock, &addr, &res);				host = gethostbyaddr(&addr, res, AF_INET);				strcpy(buffer, host->h_name);				return(GetSmallp(strlen(host->h_name)));				break;	case INETgetname:	/* host addr, buffer for name string */				sock = LispNumToCInt(nameConn);				buffer = (char *)Addr68k_from_LADDR(proto);				res = sizeof(addr);D 9				addr.s_addr = sock;E 9I 9				addr.sin_addr.s_addr = sock;E 9				host = gethostbyaddr(&addr, res, 0);				if (!host) return(GetSmallp(0));				strcpy(buffer, host->h_name);				return(GetSmallp(strlen(host->h_name)));				break;E 5	case UDPListen:		/* socket# to listen on */				sock = LispNumToCInt(nameConn);				result = socket(AF_INET, SOCK_DGRAM, 0);				farend.sin_family = AF_INET;				farend.sin_port = sock;				farend.sin_addr.s_addr = INADDR_ANY;				if (bind(result, &farend, sizeof(farend))<0)				  {D 5				    perror("TCP bind");E 5I 5				    perror("UDP bind");E 5				    close(result);				    return(NIL);				  }D 15				if (fcntl(result, F_SETFL,				      fcntl(result, F_GETFL, 0)	 | FNDELAY								 | FASYNC)<0)D 13				  perror("UDP Listen ASYNC");;E 13I 13				  perror("UDP Listen ASYNC");#ifndef HPUXE 13				if (fcntl(result, F_SETOWN, getpid()) < 0)				  perror("UDP Listen SETOWN");E 15I 15#ifdef RS6000				ioctl(result, FIONBIO, &one);				fcntl(result, F_SETOWN, getpid());#else#ifdef HPUX				ioctl(result, FIOSNBIO, &one);#else				fcntl(result, F_SETFL,  fcntl(result, F_GETFL, 0)					      | FNDELAY | FASYNC);I 17#ifndef ISCE 17				fcntl(result, F_SETOWN, getpid());I 17D 21#endif ISCE 17E 15I 13#endif HPUXI 15#endif RS6000E 21I 21#endif /* ISC */#endif /* HPUX */#endif /* RS6000 */E 21E 15E 13D 5				if (listen(result, 5) == -1)				  {				    perror("UDP Listen");				    close(result);				    return(NIL);				  }E 5				LispIOFds |= (1 << result); /* so we get interrupts */				LispReadFds |= LispIOFds;				DBPRINT(("LispIOFds = 0x%x.\n", LispIOFds));				return(GetSmallp(result));				break;I 5	case UDPSendto:		/* fd-socket# addr remote-socket buffer len*/				sock = LispNumToCInt(nameConn);				farend.sin_family = AF_INET;				farend.sin_port = LispNumToCInt(length);				farend.sin_addr.s_addr = LispNumToCInt(proto);D 11				buffer = Addr68k_from_LADDR(bufaddr);E 11I 11				buffer = (char *) Addr68k_from_LADDR(bufaddr);E 11				buflen = LispNumToCInt(maxlen);I 6				DBPRINT(("UDP send:  socket = %d, remote-port = %d.\n",					  sock, farend.sin_port));				DBPRINT(("           remote-addr = 0x%x, buflen = %d.\n",					  farend.sin_addr.s_addr, buflen));I 12#ifdef BYTESWAP				word_swap_page(buffer, (buflen + 3) >> 2);D 21#endif BYTESWAPE 21I 21#endif /* BYTESWAP */E 21I 21E 21E 12E 6				if (result = sendto(sock, buffer, buflen, 0,						    &farend, sizeof farend)  <0)I 12#ifdef BYTESWAP				word_swap_page(buffer, (buflen + 3) >> 2);D 21#endif BYTESWAPE 21I 21#endif /* BYTESWAP */E 21I 21E 21E 12				  {				    perror("UDP Send");				    printf(" fd = %d, addr = 0x%x.\n", sock,						farend.sin_addr.s_addr);				    return(NIL);				  }				return(GetSmallp(result));				break;	case UDPRecvfrom:	/* fd-socket# buffer len addr-cell port-cell*/				sock = LispNumToCInt(nameConn);D 6				buffer = Addr68k_from_LADDR(proto);E 6I 6				buffer = (char *)Addr68k_from_LADDR(proto);E 6				buflen = LispNumToCInt(length);				res = sizeof farend;D 6				if (result = recvfrom(sock, buffer, buflen, 0,						    &farend, &res)  <0)E 6I 6				if ((result = recvfrom(sock, buffer, buflen, 0,						    &farend, &res))  <0)E 6				  {				    perror("UDP Recv");				    return(NIL);				  }D 6				*Addr68k_from_LADDR(bufaddr) = farend.sin_addr.s_addr;				*Addr68k_from_LADDR(maxlen) = farend.sin_port;E 6I 6				DBPRINT(("UDP recv:  socket = %d, len = %d.\n",					 sock, result));				DBPRINT(("           remote-addr = 0x%x, remote-port = %d.\n",					 farend.sin_addr.s_addr, farend.sin_port));				DBPRINT(("           bufsize = %d, addrcell = 0x%x, portcell = 0x%x.\n",					 buflen, bufaddr, maxlen));				*((int *)Addr68k_from_LADDR(bufaddr)) = (int)farend.sin_addr.s_addr;				*((int *)Addr68k_from_LADDR(maxlen))  = (int)farend.sin_port;E 6I 12#ifdef BYTESWAP				word_swap_page(buffer, (result + 3) >> 2);D 21#endif BYTESWAPE 21I 21#endif /* BYTESWAP */E 21E 12				return(GetSmallp(result));				break;E 5E 3	default: return(NIL);		 break;      }  }D 3hprin(buf,count)  char *buf; int count;  {    int i;    for (i=0; i<count; i++) printf("%x%x ", (buf[i]>>4), buf[i]&0xF);  }E 3E 1