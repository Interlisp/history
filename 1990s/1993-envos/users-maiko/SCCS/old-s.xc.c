h15806s 00005/00025/01022d D 2.30 88/10/13 19:26:51 krivacic 68 67c new ifdef varses 00006/00000/01041d D 2.29 88/10/12 17:54:50 krivacic 67 66c fix ifdef on asm_label_check_interruptes 00001/00001/01040d D 2.28 88/10/12 17:20:32 krivacic 66 65c fix NATIVETRAN ifndefes 00004/00015/01037d D 2.27 88/10/12 14:46:18 krivacic 65 64c new out-of-line interfacees 00100/00039/00952d D 2.26 88/10/10 14:11:22 krivacic 64 63c sun3/4 mergees 00006/00004/00985d D 2.25 88/10/05 17:04:22 krivacic 63 62c stack overflow fixeses 00031/00036/00958d D 2.24 88/10/04 14:03:17 krivacic 62 61c stack overflow stuff & interruptes 00010/00006/00984d D 2.23 88/09/28 18:19:44 krivacic 61 60c Call URAID on Stack Overflow, also checks ABSOLUTE stack overflow (THIS MAY BE A PERFORMANCE HIT)es 00024/00022/00966d D 2.22 88/09/16 14:40:35 bane 60 59c Adjusted PC changeses 00007/00001/00981d D 2.21 88/08/15 14:31:45 krivacic 59 58c label for asm fn call & return, unnecessary stack check outes 00004/00000/00978d D 2.20 88/07/27 17:36:31 shimizu 58 57c Add Scratch_CSTK for exception2C:es 00005/00000/00973d D 2.19 88/07/21 09:53:53 shimizu 57 56c Add URaid_req for Shift-Cnt-DEL(SAFE-WAY)es 00018/00035/00955d D 2.18 88/07/19 16:46:47 krivacic 56 55c native interfaceses 00001/00000/00989d D 2.17 88/07/01 19:57:43 shih 55 54c Added stream.h to include fileses 00006/00000/00983d D 2.16 88/07/01 19:10:35 hayata 54 53c n_mask_array is added.es 00003/00002/00980d D 2.15 88/07/01 10:37:06 charnley 53 52c put FVARX inline.es 00010/00006/00972d D 2.14 88/06/28 19:12:42 charnley 52 51c part of fvar inline.es 00451/00450/00527d D 2.13 88/06/28 18:28:40 shih 51 50c Added profile.h hooks (renamed casexx to CASEXX)es 00002/00000/00975d D 2.12 88/06/24 13:32:27 bane 50 49c Added KBINT ifdef for keyboard signal handlinges 00014/00016/00961d D 2.11 88/06/21 16:02:07 masinter 49 48c change order of checks at interrupt (wasn't doing GC if PERIODIC.INTERRUPT)es 00045/00001/00932d D 2.10 88/06/20 22:00:05 shimizu 48 47c For C KeyHandleres 00001/00001/00932d D 2.9 88/06/15 10:06:53 charnley 47 46c changed to call unwind with 2 byte argses 00001/00001/00932d D 2.8 88/06/15 09:55:28 bane 46 45c removed CHECK_INTERRUPTS from forward brancheses 00010/00001/00923d D 2.7 88/06/02 15:17:03 krivacic 45 44c c_ret_to_dispatches 00022/00014/00902d D 2.6 88/05/31 20:18:52 masinter 44 43c allow ufns to be native translated, check overflow correctly. eliminate StkLimO.es 00019/00015/00897d D 2.5 88/05/27 15:05:26 krivacic 43 42c timer interrupt fixes (for native code)es 00029/00054/00883d D 2.4 88/05/24 18:21:19 krivacic 42 41c fix #ifdef mc68020 & UNSAFE, remove obsolete ctak, re-arrange timer interrupt & stack overflow stuffes 00009/00012/00928d D 2.3 88/05/23 15:55:21 krivacic 41 40c ret_to_ufnes 00023/00013/00917d D 2.2 88/05/20 10:36:30 krivacic 40 39c irq & stk check changeses 00000/00000/00930d D 2.1 88/05/17 09:27:58 hayata 39 38c Version up to 2.1es 00053/00007/00877d D 1.38 88/05/10 19:44:43 krivacic 38 37c new timer stuff with Irq_Stk_Check, Irq_Stk_Endes 00001/00001/00883d D 1.37 88/05/05 14:09:08 krivacic 37 36c add ENVCALLes 00000/00020/00884d D 1.36 88/05/04 18:13:33 masinter 36 35c new timeres 00001/00001/00903d D 1.35 88/05/04 15:12:10 krivacic 35 34c fix shift bugs & pop.nes 00001/00001/00903d D 1.34 88/05/03 11:20:24 krivacic 34 33c fix .globl _ret_to_fn4es 00001/00001/00903d D 1.33 88/05/02 11:55:37 krivacic 33 32c fix _ret_to_fnx labeles 00000/00002/00904d D 1.32 88/05/01 23:48:50 masinter 32 31c remove reference to donsops.h; no longer usedes 00000/00001/00906d D 1.31 88/04/29 05:05:11 masinter 31 30c remove mention of unnecessary include filees 00044/00016/00863d D 1.30 88/04/27 13:40:18 krivacic 30 29c native entry points for fn callses 00001/00001/00878d D 1.29 88/04/25 11:40:46 krivacic 29 28c LSH macroes 00090/00094/00789d D 1.28 88/04/22 19:13:46 krivacic 28 27c inlinedefs re-arrangementes 00002/00002/00881d D 1.27 88/04/21 18:09:57 krivacic 27 26c inces 00001/00002/00882d D 1.26 88/04/14 15:48:06 krivacic 26 25c POP_N back ines 00004/00002/00880d D 1.25 88/04/14 14:42:02 krivacic 25 24c apply fix & pop.n outes 00001/00001/00881d D 1.24 88/04/13 15:45:05 krivacic 24 23c POP.N error fixed (300)es 00002/00002/00880d D 1.23 88/04/08 17:19:01 krivacic 23 22c native interface changeses 00007/00007/00875d D 1.22 88/03/31 19:35:18 krivacic 22 21c New Interface for FVar ops & stkscanes 00014/00010/00868d D 1.21 88/03/31 15:11:48 krivacic 21 20c storen, copyn, arg0, assoces 00004/00002/00874d D 1.20 88/03/31 11:08:45 krivacic 20 19c rplcons, myargcount, myalinkes 00007/00004/00869d D 1.19 88/03/31 10:06:53 krivacic 19 18c N interfaces for get&put bytes etces 00001/00003/00872d D 1.18 88/03/30 10:19:16 charnley 18 17c included donsops.hes 00002/00002/00873d D 1.17 88/03/29 18:51:25 krivacic 17 16c New Interfaceses 00082/00066/00793d D 1.16 88/03/28 12:00:18 krivacic 16 15c new native code interfacees 00001/00001/00858d D 1.15 88/03/23 10:56:32 krivacic 15 14c longer loopcountes 00023/00005/00836d D 1.14 88/03/23 10:14:54 krivacic 14 13c SPARC ifdef'ses 00001/00000/00840d D 1.13 88/03/21 17:12:33 charnley 13 12c added include of donsops.h for drawline C codees 00001/00001/00839d D 1.12 88/03/16 17:33:20 krivacic 12 11c larger loop countes 00013/00000/00827d D 1.11 88/03/15 18:24:13 krivacic 11 10c Closure Call, Apply, & CheckApply to dispatch loopes 00067/00032/00760d D 1.10 88/03/14 17:41:18 krivacic 10 9c nces 00043/00024/00749d D 1.9 88/03/14 12:15:13 krivacic 9 8c Don's opcodeses 00002/00000/00771d D 1.8 88/03/13 15:11:50 hayata 8 7c Add SCCS key ides 00046/00037/00725d D 1.7 88/03/11 18:07:38 krivacic 7 6c nces 00000/00001/00762d D 1.6 88/03/09 16:07:10 krivacic 6 5c removed MachineState externes 00000/00000/00763d D 1.5 88/03/09 15:50:32 krivacic 5 4c es 00032/00009/00731d D 1.4 88/03/09 15:46:11 krivacic 4 3c MachineState changeses 00013/00008/00727d D 1.3 88/03/04 11:20:42 krivacic 3 2c Fixed Native Interface FuncObjes 00239/00511/00496d D 1.2 88/03/03 11:40:14 krivacic 2 1c MACRO  driven opcode inlines  defined in external files:inlinedefsC.h & redefined assembly calls in inlinedefs68K.h; Removed global CurrentFX to use CURRENTFX = PVAR - FRAMESIZEes 01007/00000/00000d D 1.1 88/02/24 16:59:11 hayata 1 0c date and time created 88/02/24 16:59:11 by hayataeuUtTI 8D 16/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 16I 16D 28/* This is G-file @(#) xc.c Version 1.15 (3/23/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) xc.c	1.15 3/23/88";E 16E 8I 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2/* File: xc.c - created by Fuji Xerox. Last edit: *//* masinter:parc:Xerox  5-Jan-88 16:50:48 */E 28I 28D 60/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 60I 60/* This is G-file @(#) xc.c Version 2.21 (8/15/88). copyright Xerox & Fuji Xerox  */E 60D 44/* File: xc.c */E 44E 28D 28/* Copyright (C) 1988 by Xerox Corporation. All rights reserved. */E 28#include <sys/types.h>#include <sys/time.h>#include <stdio.h>I 60E 60#include "lispemul.h"#include "emulglobal.h"#include "address.h"#include "address68k.h"#include "stack.h"#include "lispglobal.h"#include "lisptypes.h"#include "lispmap.h"#include "cell.h"#include "initatoms.h"#include "gc.h"D 2E 2#include "arith.h"I 55#include "stream.h"E 55D 2E 2D 31#include "opcodefunc.h"E 31D 2typedef struct conspage ConsPage;#define CGETNUMBER(sour,dest)	\{	\		switch(0xFFFF0000 & sour){\		case S_POSITIVE:		\			dest = 0xFFFF & sour;	\			break;			\		case S_NEGATIVE:		\			dest = 0xFFFF0000 | sour;	\			break;			\		default:			\			if(GetTypeNumber( sour ) != TYPE_FIXP){	\				UFN(Get_BYTE(PCMAC));	\			}			\			dest = *((int *)Addr68k_from_LADDR(sour));	\		}	\}#undef PopCStack#undef PopStackTo#undef PushCStack#undef PushStack#undef StackOverflowCheck#undef StackCheck#undef SmashStack#define PCMAC 		pccache#define CSTKPTR  	cspcache#define NEXTOPCODE 	goto nextopcode#ifdef NOTOSCACHE/* No TOS Cache at All */#define CPushStack(x)	{CSTKPTR += 2; *((LispPTR *)CSTKPTR) = x;}#define CPopCStack	{CSTKPTR -= 2;}#define CPushCStack	{}#define TOPOFSTACK	*((LispPTR *)CSTKPTR)#define PREVTOS		*((LispPTR *)(CSTKPTR-2))#define CPush(x)	{CPushStack(x);}#define CPopStore(x)	{*((LispPTR *)--CSTKPTR) = x;}#define CCopyTos	{CPushStack(PREVTOS);}#define StackPtrSave	{CurrentStackPTR = CSTKPTR-2;}#define StackPtrRestore	{CSTKPTR = CurrentStackPTR+2;}#endif#ifdef TOS1/** cached TOPOFSTACK, with CSTKPTR pointing to where cache should be   **/ #define CPushStack(x)	{*((LispPTR *)CSTKPTR++)=x;}#define CPopCStack	{TOPOFSTACK = *((LispPTR *)--CSTKPTR);}#define CPushCStack	{*((LispPTR *)CSTKPTR++) = TOPOFSTACK;}#define TOPOFSTACK 	tscache#define PREVTOS		*((LispPTR *)(CSTKPTR-2))#define POPPREVTOS	*((LispPTR *)--CSTKPTR)#define TOS		*((LispPTR *)(CSTKPTR))#define CPush(x)	{CPushCStack; TOPOFSTACK = x;}#define CPopStore(x)	{CSTKPTR -= 2; TOPOFSTACK = x;}#define CCopyTos	{CPushCStack;}#define StackPtrSave	{CurrentStackPTR = CSTKPTR-2;}#define StackPtrRestore	{CSTKPTR = CurrentStackPTR+2;}E 2I 2#include "tos1defs.h" E 2#include "tosretmacro.h"#include "tosfuncallmacro.h"I 2D 14#include "inlinedefsC.h"D 9#include "inlinedefs68K.h"E 9I 9#include "inlinedefs68K.h" E 14I 14D 28#include "ni_inlinedefsC.h"#include "op_inlinedefsC.h"E 28I 28#include "inlinedefsC.h"E 28D 28#ifdef MC68KE 28I 28D 43#ifdef mc68020E 43I 43D 64#ifndef C_ONLYE 64E 43E 28D 65#include "n_op_inlinedefsC.h"I 43E 65I 64D 68#ifndef NOASME 64#ifdef mc68020E 68I 68#ifdef SUN3_OS3_ILE 68E 43#include "inlinedefs68K.h"I 43#ifdef UNSAFE#include "fastinlinedefs68K.h"E 43#endifI 43#endifI 64D 68#endifE 68E 64E 43D 16#ifdef SPARCE 16I 16#ifdef sparcE 16D 64#include "dummy_entries.h"E 64#include "inlinedefsSPARC.h"#endifI 43D 64E 43#ifdef OPDISPE 64#include "fast_dispatch.h"D 64#endifD 28#ifdef MC68K & UNSAFEE 28I 28D 42#ifdef mc68020 & UNSAFEE 42I 42D 43#ifdef mc68020#ifdef UNSAFEE 42E 28E 14E 9I 7#include "fastinlinedefs68K.h"E 43I 43D 51E 51E 43I 13D 14#include "donsops.h"E 14I 14D 44#endifE 44I 44#endif /* C_ONLY */E 44I 42D 43#endifE 43E 42E 14E 13E 7E 2E 64I 51#include "profile.h"E 51I 43I 51D 60E 51E 43I 14D 18/*#include "inlinedefsC.h"E 18D 32#include "donsops.h"D 18*/E 18I 18E 32E 18E 14D 2#endifE 2I 2#define PCMAC 		pccacheE 60I 60/* trick now is that pccache points one ahead... */#define PCMAC 		(pccache-1)#define PCMACL		pccacheE 60#define CSTKPTR  	((LispPTR *) cspcache)I 4D 16/* These defs should be used if MState is in a reg *//*E 4#define	PVAR		((LispPTR *) MState->pvar)#define IVAR		((LispPTR *) MState->ivar)I 4*/E 4E 2I 4/* These defs are better than using MState if MState is not in a reg */E 16D 6extern struct state MachineState;E 6D 64#define	PVAR		((LispPTR *) MachineState.pvar)#define IVAR		((LispPTR *) MachineState.ivar)E 64I 64#define	PVAR		((LispPTR *) PVar)#define IVAR		((LispPTR *) IVar)E 64D 16E 16#define BCE_CURRENTFX	((struct  frameex2 *)((DLword *) PVAR - FRAMESIZE))I 16D 28#define OPtbl_base 	((CFuncPTR *) OPCODE_entries)E 28E 16E 4D 2#ifdef TOS0E 2I 2typedef struct conspage ConsPage;typedef ByteCode *InstPtr;E 2I 52D 53static DLword	*fvar_chain;E 53E 52D 2/** cached TOPOFSTACK, CSTKPTR points at last item in stack   **/ #define CPushStack(x)	{CSTKPTR += 2; *((LispPTR *)CSTKPTR)=x;}#define CPopCStack	{TOPOFSTACK = *((LispPTR *)CSTKPTR); CSTKPTR -= 2;}#define CPushCStack	{CSTKPTR += 2; *((LispPTR *)CSTKPTR) = TOPOFSTACK;}#define TOPOFSTACK 	tscache#define PREVTOS		*((LispPTR *)(CSTKPTR))#define POPPREVTOS	*((LispPTR *)CSTKPTR--)#define TOS		*((LispPTR *)(CSTKPTR-2))#define CPush(x)	{CPushCStack; TOPOFSTACK = x;}#define CPopStore(x)	{CSTKPTR -= 2; TOPOFSTACK = x;}#define CCopyTos	{CPushCStack;}#define StackPtrSave	{CurrentStackPTR = CSTKPTR;}#define StackPtrRestore	{CSTKPTR = CurrentStackPTR;}#include "retmacro.h"#include "funcallmacro.h"#endif#define NativeCheck	{if (FuncObj->native) {goto gonative ;} nextop0; }E 2D 64extern ByteCode *PC;extern CFuncPTR OPCODE_entries[];extern int Intrdisable;E 64I 2extern DLword *createcell68k();E 2I 64#ifdef OPDISPE 64I 16InstPtr optable[512];D 56ByteCode call_pc;E 56D 38int LoopCounter=400;E 38I 38D 64int Irq_Stk_Check = 0;		/* Usually contains safe StkLim */int Irq_Stk_End = 0;		/* = real stk lim */E 64I 64#endifE 64E 38I 58D 64int Scratch_CSTK;		/* for N_OP_xx,keeps scratch value				 for exceptions */I 62int		extended_frame;E 64I 64int	extended_frame;		/*indicates if soft stack overflow */E 64E 62E 58I 54int n_mask_array[16] = {	1, 3, 7, 0xf, 			0x1f, 0x3f, 0x7f, 0xff,			0x1ff, 0x3ff, 0x7ff, 0xfff,			0x1fff, 0x3fff, 0x7fff, 0xffff};I 64D 65extern int ufn_restart_case;E 65extern int TIMER_INTERVAL;E 64E 54E 16D 2#ifdef	IVARINREG#define EXT	{ PC = pccache;\		  TopOfStack = TOPOFSTACK;\		  StackPtrSave;\		  IVar = IVAR;}#define RET	{ pccache = PC;\		  StackPtrRestore;\		  TOPOFSTACK = TopOfStack;\		  IVAR = IVar; }#else#define	IVAR	MState->ivar#define EXT	{ PC=pccache;\		  TopOfStack=TOPOFSTACK;\		  StackPtrSave; }#define RET	{ pccache=PC;\		  StackPtrRestore;\		  TOPOFSTACK = TopOfStack; } #endif#define NRET	{ RET; nextop0; }#define UFN(x)  { EXT; ufn((x)); NRET; }#define CURRENTFX CurrentFX#define	PVAR	MState->pvar#define  CFnStkOvr(argnum,bytenum) { \				CPushStack(S_POSITIVE | argnum); \				EXT;\				contextsw(SubovFXP,bytenum,1); \				RET; nextop0; }typedef ByteCode *InstPtr;E 2D 42int ctak(x, y, z) { if (x > y)  	{return(ctak( 		 ctak(x-1, y, z),		 ctak(y-1, z, x),		 ctak(z-1, x, y)		)	   );	}  else    return(z);};E 42D 2E 2dispatch()D 16{	InstPtr optable[256];E 16I 16{E 16D 42 	int timevalue;	int takval;	struct timeval time;	unsigned int usec;	printf("timing ctak...\n");	update_timer();	gettimeofday(&time, NULL);	usec = (time.tv_sec * 1000000) + time.tv_usec;	takval = ctak(18, 12, 6);	update_timer();	gettimeofday(&time, NULL);	timevalue = ((time.tv_sec * 1000000) + time.tv_usec) - usec;	printf("ctak(18, 12, 6) = %d, in %f  sec \n",takval,timevalue / 1000000.0);D 2#ifdef OPDISPE 2D 16	doDispatch(0, optable);E 16I 16	doDispatch();E 42I 42D 64 	doDispatch();E 42E 16}D 16doDispatch(pccache, table)	register InstPtr pccache;	register InstPtr *table;E 16I 16doDispatch()E 16{E 64D 2#else    register InstPtr pccache;#endif    register DLword *cspcache;E 2I 2D 16    register LispPTR *cspcache;E 2    register LispPTR tscache;    register int SaveD6;I 7    register int Save_D5_shift_amount;E 7    register int LoopCounter=400;E 16I 16	register InstPtr pccache;I 64#if defined(OPDISP) || defined(SPARCDISP)E 64  	register InstPtr *table;I 64#endifE 64	register LispPTR *cspcache;	register LispPTR tscache;I 64#ifdef sparc	register struct state *stateptrcache = MState;#undef MState#define MState stateptrcache#endif#ifdef OPDISPD 68#ifdef mc68020#ifndef NOASME 68E 64	register int SaveD6;I 64#endifD 68#endif#endifE 68#ifdef UNSAFEE 64	register int Save_D5_shift_amount;I 64#endifE 64E 16I 11/* OP_FN_COMMON arguments */    DefCell *fn_defcell;    LispPTR fn_atom_index;    int fn_opcode_size;    int fn_num_args;    int fn_apply;    LispPTR fn_loc_defcell;I 53D 64    DLword *fvar_chain;E 64E 53E 11D 2#ifdef IVARINREG     register DLword *IVAR;E 2I 2D 16/* # ifdef IVARINREG     register LispPTR *IVAR;E 2#endifD 2    register  struct state	*mstate;E 2I 2*/ E 2    CFuncPTR *OPtbl_base ;D 2    int save_atom_index;E 2/* changed to --LoopCounter so can subtract then test */D 2#define CHECK_INTERRUPT {if(--LoopCounter<0) goto check_interrupt;} E 2D 2#define registers  register int arg1,arg2, arg3, result; register DLword *wordp; \	register LispPTR *cellp;    extern DLword *createcell68k();#ifdef OPDISPextern void jumpLabel();void LispPTR difference();#define nextop0 {jumpLabel();}#define nextop1 {PCMAC += 1; jumpLabel();}#define nextop2 {PCMAC += 2; jumpLabel();}#define nextop3 {PCMAC += 3; jumpLabel();}#else#define nextop0 {goto nextopcode; }#define nextop1 {PCMAC += 1; goto nextopcode; }#define nextop2 {PCMAC += 2; goto nextopcode; }#define nextop3 {PCMAC += 3; goto nextopcode; }#endif#define	IVARMACRO(x)	{CPush(GetLongWord(IVAR + x )); nextop1;}#define	PVARMACRO(x)	{CPush(GetLongWord(PVAR + x )); nextop1;}#define	PVARSETMACRO(x)	{*((LispPTR *)PVAR + x) = TOPOFSTACK; nextop1;}#define	PUSHATOM(x)	{CPush(x); nextop1;}#define	FJUMPMACRO(x)	{if(TOPOFSTACK != 0) {goto PopNextop1 ; }\			{CPopCStack; PCMAC += x; nextop0;}\			}#define	TJUMPMACRO(x)	{if(TOPOFSTACK == 0) {goto PopNextop1 ; }\			{CPopCStack; PCMAC += x; nextop0;}\			}E 2    OPtbl_base = OPCODE_entries;E 16D 7E 7D 4#ifdef OPDISPE 4	RET; I 38	CLR_IRQ;I 64#ifdef OPDISPE 64E 38I 16	table = optable;I 64#endif#ifdef SPARCDISP	table = (InstPtr *) compute_dispatch_table();#endif#ifdef UNSAFEE 64E 16I 7	Save_D5_shift_amount = 15;I 64#endif#ifdef OPDISPD 68#ifdef mc68020#ifndef NOASME 68E 64I 16	SaveD6 = 0;I 64D 68#endif#endif#endifE 64E 16E 7I 4I 64D 65	switch (ufn_restart_case) {	case -2: goto check_interrupt;	case -3: /* restart from FX */	case -1: /* restart */E 65E 64#ifdef OPDISPE 68E 4	goto setup_table;I 4#else	goto nextopcode;E 4#endifI 64I 68E 68D 65	case 0: goto op_ufn;	default: error("bad ufn restart case");	}E 64I 4	E 65/* INLINE OPCODE FAIL ENTRY POINTS, CALL EXTERNAL ROUTINES HERE */E 4D 43E 43I 43D 64#ifndef C_ONLYE 64E 43I 4	OPCODEFAIL;E 4D 43E 43I 43D 64#endifE 64E 43D 4nextopret:    RET;    E 4I 4/* OPCODE FAIL ENTRY POINTS, CALL UFNS HERE */	UFN_CALLS;I 11I 44op_ufn:	{ register UFN *entry68k;						   entry68k = (UFN *)GetUFNEntry(Get_BYTE(PCMAC));			   fn_num_args = entry68k->arg_num;					   fn_opcode_size = entry68k->byte_num+1;				   fn_atom_index = entry68k->atom_name;					   fn_defcell = (DefCell *) GetDEFCELL68k(fn_atom_index);		   fn_apply = 2 + entry68k->byte_num; /* code for UFN entry */   goto op_fn_common;							};E 44/* FUNCTION CALL TAIL ROUTINE */	OP_FN_COMMON;E 11/* DISPATCH "LOOP" */E 4nextopcode :switch (Get_BYTE(PCMAC)) { D 7 case 000 : case000: { jmpni(); }E 7I 7D 28 case 000 : case000: { goto ni; }E 28I 28D 51 case 000 : case000: { goto op_ufn; } /* unused */E 28E 7D 2 case 001 : case001: { EXT; OP_car(); NRET; } case 002 : case002: { EXT; OP_cdr(); NRET; } case 003 : case003: { EXT; OP_listp(); NRET; } case 004 : case004: { EXT; OP_ntypex(); NRET; } case 005 : case005: { EXT; OP_typep(); NRET; } case 006 : case006: { EXT; OP_dtest(); NRET; } case 007 : case007: {goto ni; }E 2I 2 case 001 : case001: OPCAR; case 002 : case002: OPCDR; case 003 : case003: LISTP; case 004 : case004: NTYPEX;D 21 case 005 : case005: TYPEP; case 006 : case006: DTEST; case 007 : case007: { goto ni; }E 21I 21 case 005 : case005: TYPEP(Get_BYTE(PCMAC+1)); case 056 : case056:  case 006 : case006: DTEST(Get_DLword(PCMAC+1));D 47 case 007 : case007: UNWIND(Get_BYTE(PCMAC+1));E 47I 47 case 007 : case007: UNWIND(Get_BYTE(PCMAC+1), Get_BYTE(PCMAC+2));E 51I 51 case 000 : CASE000: { goto op_ufn; } /* unused */ case 001 : CASE001: OPCAR; case 002 : CASE002: OPCDR; case 003 : CASE003: LISTP; case 004 : CASE004: NTYPEX; case 005 : CASE005: TYPEP(Get_BYTE(PCMAC+1)); case 056 : CASE056:  case 006 : CASE006: DTEST(Get_DLword(PCMAC+1)); case 007 : CASE007: UNWIND(Get_BYTE(PCMAC+1), Get_BYTE(PCMAC+2));E 51E 47E 21E 2D 64 I 30	    ret_to_fn0: asm("_ret_to_fn0:"); E 64I 64#ifdef NATIVETRAN 	    ret_to_fn0: asm("_ret_to_fn0:"); E 64			asm("	.globl _ret_to_fn0"); D 56			RET_FROM_NATIVE(0);E 56I 56			RET_FROM_NATIVE;I 64#endifE 64E 56E 30I 2D 51 case 010 : case010: FN0;E 51I 51 case 010 : CASE010: FN0;I 64#ifdef NATIVETRANE 64E 51I 30	    ret_to_fn1: asm("_ret_to_fn1:"); 			asm("	.globl _ret_to_fn1"); D 56			RET_FROM_NATIVE(0);E 56I 56			RET_FROM_NATIVE;I 64#endifE 64E 56E 30D 51 case 011 : case011: FN1;E 51I 51 case 011 : CASE011: FN1;I 64#ifdef NATIVETRANE 64E 51I 30	    ret_to_fn2: asm("_ret_to_fn2:"); 			asm("	.globl _ret_to_fn2"); D 56			RET_FROM_NATIVE(0);E 56I 56			RET_FROM_NATIVE;I 64#endifE 64E 56E 30D 51 case 012 : case012: FN2;E 51I 51 case 012 : CASE012: FN2;I 64#ifdef NATIVETRANE 64E 51I 30	    ret_to_fn3: asm("_ret_to_fn3:"); 			asm("	.globl _ret_to_fn3"); D 56			RET_FROM_NATIVE(0);E 56I 56			RET_FROM_NATIVE;I 64#endifE 64E 56E 30D 51 case 013 : case013: FN3;E 51I 51 case 013 : CASE013: FN3;I 64#ifdef NATIVETRANE 64E 51I 30	    ret_to_fn4: asm("_ret_to_fn4:"); D 34			asm("	.globl _ret_to_fn3"); E 34I 34			asm("	.globl _ret_to_fn4"); E 34D 56			RET_FROM_NATIVE(0);E 56I 56			RET_FROM_NATIVE;I 64#endifE 64E 56E 30D 51 case 014 : case014: FN4;E 51I 51 case 014 : CASE014: FN4;I 64#ifdef NATIVETRANE 64E 51I 30	    ret_to_fnx: asm("_ret_to_fnx:"); D 33			asm("	.globl _ret_to_fn3"); E 33I 33			asm("	.globl _ret_to_fnx"); E 33D 56			RET_FROM_NATIVE(0);E 56I 56			RET_FROM_NATIVE;I 64#endifE 64E 56E 30D 51 case 015 : case015: FNX;E 51I 51 case 015 : CASE015: FNX;I 64#ifdef NATIVETRANE 64E 51I 30	    ret_to_apply: asm("_ret_to_apply:"); 			asm("	.globl _ret_to_apply"); D 56			RET_FROM_NATIVE(0);E 56I 56			RET_FROM_NATIVE;I 64#endifE 64E 56E 30D 51 case 016 : case016: APPLY;E 51I 51 case 016 : CASE016: APPLY;E 51I 30E 30D 51 case 017 : case017: CHECKAPPLY; case 020 : case020: RETURN;E 51I 51 case 017 : CASE017: CHECKAPPLY; case 020 : CASE020: RETURN;E 51E 2D 2 /*  case 010 : case010: { goto ni; } case 011 : case011: {goto ni; } case 012 : case012: {goto ni; } case 013 : case013: {goto ni; }  case 014 : case014: {goto ni; }*/ case 010 : case010: {registers; CHECK_INTERRUPT; OPFN(0); nextop0; } case 011 : case011: {registers; CHECK_INTERRUPT; OPFN(1); nextop0; } case 012 : case012: {registers; CHECK_INTERRUPT; OPFN(2); nextop0; }/* case 013 : case013: {registers; CHECK_INTERRUPT; fn3(); NativeCheck; }*/ case 013 : case013: {registers; CHECK_INTERRUPT; OPFN(3); NativeCheck; } case 014 : case014: {registers; CHECK_INTERRUPT; OPFN(4); nextop0; } case 015 : case015: {CHECK_INTERRUPT; EXT; OP_fnx(); RET; nextop0; } case 016 : case016: {CHECK_INTERRUPT; EXT; OP_apply(); RET; nextop0;  } case 017 : case017: { EXT; OP_checkapply(); RET; NativeCheck;} case 020 : case020: {OPRETURN; nextop0; }/* case 020 : case020: {opreturn(); NativeCheck; }*//* case 021 : case021: { goto ni; } case 022 : case022: { goto ni; } case 023 : case023: { goto ni; } case 024 : case024: { goto ni; } case 025 : case025: { goto ni; } case 026 : case026: { goto ni; } case 027 : case027: { goto ni; } case 030 : case030: { goto ni; } case 031 : case031: { goto ni; } case 032 : case032: { goto ni; } case 033 : case033: { goto ni; } case 034 : case034: { goto ni; }E 2I 2D 51 case 021 : case021: BIND; case 022 : case022: UNBIND; case 023 : case023: DUNBIND;D 17 case 024 : case024: RPLPTR;E 17I 17 case 024 : case024: RPLPTR(Get_BYTE(PCMAC+1));E 17 case 025 : case025: GCREF; case 026 : case026: ASSOC; case 027 : case027: GVAR_(Get_DLword(1+PCMAC)); case 030 : case030: RPLACA; case 031 : case031: RPLACD; case 032 : case032: CONS;D 9 case 033 : case033: DBX;E 9I 9 case 033 : case033: CLASSOC;E 9 case 034 : case034: FMEMB;E 2D 9 case 035 : case035: { goto ni; }E 9I 9 case 035 : case035: CLFMEMB;E 9D 2 case 036 : case036: { goto ni; } case 037 : case037: { goto ni; } case 040 : case040: { goto ni; }E 2I 2D 17 case 036 : case036: FINDKEY;E 17I 17 case 036 : case036: FINDKEY(Get_BYTE(PCMAC+1));E 17 case 037 : case037: CREATECELL; case 040 : case040: BIN;E 2D 28 case 041 : case041: { goto ni; } case 042 : case042: { goto ni; }D 9 case 043 : case043: { goto ni; }E 9I 9 case 043 : case043: RESTLIST;E 9 case 044 : case044: { goto ni; } case 045 : case045: { goto ni; }E 28I 28 case 041 : case041: { goto op_ufn; } /* BOUT */ case 042 : case042: { goto op_ufn; } /* POPDISP - prolog only */D 38 case 043 : case043: { goto op_ufn; }  /* RESTLIST */E 38I 38 case 043 : case043: RESTLIST(Get_BYTE(PCMAC+1));E 38 case 044 : case044: { goto op_ufn; }  /* unused */ case 045 : case045: { goto op_ufn; }  /* unused */E 28D 2 case 046 : case046: { goto ni; } case 047 : case047: { goto ni; }E 2I 2 case 046 : case046: RPLCONS; case 047 : case047: LISTGET;E 2D 28 case 050 : case050: { goto ni; } case 051 : case051: { goto ni; } case 052 : case052: { goto ni; } case 053 : case053: { goto ni; }E 28I 28 case 050 : case050: { goto op_ufn; }  /* unused */ case 051 : case051: { goto op_ufn; }  /* unused */ case 052 : case052: { goto op_ufn; }  /* unused */ case 053 : case053: { goto op_ufn; }  /* unused */E 28D 2 case 054 : case054: { goto ni; }E 2I 2 case 054 : case054: EVAL;E 51I 51 case 021 : CASE021: BIND; case 022 : CASE022: UNBIND; case 023 : CASE023: DUNBIND; case 024 : CASE024: RPLPTR(Get_BYTE(PCMAC+1));D 63 case 025 : CASE025: GCREF;E 63I 63 case 025 : CASE025: GCREF(Get_BYTE(PCMAC+1));E 63 case 026 : CASE026: ASSOC;D 60 case 027 : CASE027: GVAR_(Get_DLword(1+PCMAC));E 60I 60 case 027 : CASE027: GVAR_(Get_DLword(PCMAC+1));E 60 case 030 : CASE030: RPLACA; case 031 : CASE031: RPLACD; case 032 : CASE032: CONS; case 033 : CASE033: CLASSOC; case 034 : CASE034: FMEMB; case 035 : CASE035: CLFMEMB; case 036 : CASE036: FINDKEY(Get_BYTE(PCMAC+1)); case 037 : CASE037: CREATECELL; case 040 : CASE040: BIN; case 041 : CASE041: { goto op_ufn; } /* BOUT */ case 042 : CASE042: { goto op_ufn; } /* POPDISP - prolog only */ case 043 : CASE043: RESTLIST(Get_BYTE(PCMAC+1)); case 044 : CASE044: { goto op_ufn; }  /* unused */ case 045 : CASE045: { goto op_ufn; }  /* unused */ case 046 : CASE046: RPLCONS; case 047 : CASE047: LISTGET; case 050 : CASE050: { goto op_ufn; }  /* unused */ case 051 : CASE051: { goto op_ufn; }  /* unused */ case 052 : CASE052: { goto op_ufn; }  /* unused */ case 053 : CASE053: { goto op_ufn; }  /* unused */ case 054 : CASE054: EVAL;E 51I 38D 64E 64I 64#ifdef NATIVETRANE 64	    ret_to_envcall: asm("_ret_to_envcall:"); 			asm("	.globl _ret_to_envcall"); D 56			RET_FROM_NATIVE(0);E 56I 56			RET_FROM_NATIVE;E 56D 64E 64I 64#endifE 64E 38E 2D 28 case 055 : case055: { goto ni; }E 28I 28D 37 case 055 : case055: { goto op_ufn; }  /* unused WILL BE USED */E 37I 37D 51 case 055 : case055: ENVCALL;E 51I 51 case 055 : CASE055: ENVCALL;E 51I 38E 38E 37E 28D 2 case 056 : case056: { goto ni; } case 057 : case057: { goto ni; }E 2I 2D 21 case 056 : case056: DTEST;E 21I 21D 51/*  case 056 : case056: @ 006 */E 21 case 057 : case057: STKSCAN;E 2D 28 case 060 : case060: { goto ni; } case 061 : case061: { goto ni; }E 28I 28 case 060 : case060: { goto op_ufn; } /* BUSBLT - DLion only */ case 061 : case061: { goto op_ufn; } /* MISC8 - no longer used */E 28D 2 case 062 : case062: { goto ni; } case 063 : case063: { goto ni; }E 2I 2D 9 case 062 : case062: UBFLOAT3;E 9I 9 case 062 : case062: UBFLOAT3(Get_BYTE(1+PCMAC));E 9D 21 case 063 : case063: TYPEMASKE 21I 21 case 063 : case063: TYPEMASK(Get_BYTE(1+PCMAC));E 21E 2D 28 case 064 : case064: { goto ni; } case 065 : case065: { goto ni; } case 066 : case066: { goto ni; } case 067 : case067: { goto ni; } case 070 : case070: { goto ni; } case 071 : case071: { goto ni; }E 28I 28 case 064 : case064: { goto op_ufn; } /* rdprologptr */ case 065 : case065: { goto op_ufn; } /* rdprologtag */ case 066 : case066: { goto op_ufn; } /* writeptr&tag */ case 067 : case067: { goto op_ufn; } /* writeptr&0tag */ case 070 : case070: { goto op_ufn; }  /* misc7 (pseudocolor) */ case 071 : case071: { goto op_ufn; } /* dovemisc - dove only */E 28D 2 case 072 : case072: { goto ni; }  case 073 : case073: { goto ni; }  case 074 : case074: { goto ni; } case 075 : case075: { goto ni; }E 2I 2 case 072 : case072: EQLOP; case 073 : case073: DRAWLINE;D 21 case 074 : case074: STOREN; case 075 : case075: COPYN;E 21I 21 case 074 : case074: STOREN(Get_BYTE(1+PCMAC)); case 075 : case075: COPYN(Get_BYTE(1+PCMAC));E 21E 2D 28 case 076 : case076: { goto ni; } case 077 : case077: { goto ni; }E 28I 28 case 076 : case076: { goto op_ufn; } /* RAID */ case 077 : case077: { goto op_ufn; } /* \RETURN */E 51I 51/*  case 056 : CASE056: @ 006 */ case 057 : CASE057: STKSCAN; case 060 : CASE060: { goto op_ufn; } /* BUSBLT - DLion only */ case 061 : CASE061: { goto op_ufn; } /* MISC8 - no longer used */D 60 case 062 : CASE062: UBFLOAT3(Get_BYTE(1+PCMAC)); case 063 : CASE063: TYPEMASK(Get_BYTE(1+PCMAC));E 60I 60 case 062 : CASE062: UBFLOAT3(Get_BYTE(PCMAC+1)); case 063 : CASE063: TYPEMASK(Get_BYTE(PCMAC+1));E 60 case 064 : CASE064: { goto op_ufn; } /* rdprologptr */ case 065 : CASE065: { goto op_ufn; } /* rdprologtag */ case 066 : CASE066: { goto op_ufn; } /* writeptr&tag */ case 067 : CASE067: { goto op_ufn; } /* writeptr&0tag */ case 070 : CASE070: { goto op_ufn; }  /* misc7 (pseudocolor) */ case 071 : CASE071: { goto op_ufn; } /* dovemisc - dove only */ case 072 : CASE072: EQLOP; case 073 : CASE073: DRAWLINE;D 60 case 074 : CASE074: STOREN(Get_BYTE(1+PCMAC)); case 075 : CASE075: COPYN(Get_BYTE(1+PCMAC));E 60I 60 case 074 : CASE074: STOREN(Get_BYTE(PCMAC+1)); case 075 : CASE075: COPYN(Get_BYTE(PCMAC+1));E 60 case 076 : CASE076: { goto op_ufn; } /* RAID */ case 077 : CASE077: { goto op_ufn; } /* \RETURN */E 51E 28D 2*/E 2D 2 case 021 : case021: { EXT; OP_bind(); NRET; } case 022 : case022: { EXT; OP_unbind(); NRET; } case 023 : case023: { EXT; OP_dunbind(); NRET; } case 024 : case024: { EXT; OP_rplptr(); NRET; } case 025 : case025: { EXT; OP_gcref(); NRET; } case 026 : case026: { EXT; OP_assoc(); NRET; } case 027 : case027: { EXT; OP_gvar_(); NRET; } case 030 : case030: { EXT; OP_rplaca(); NRET; } case 031 : case031: { EXT; OP_rplacd(); NRET; } case 032 : case032: { EXT; OP_cons(); NRET; } case 033 : case033: { EXT; OP_dbx(); NRET; } case 034 : case034: { EXT; OP_fmemb(); NRET; } case 035 : case035: { goto ni; } case 036 : case036: { EXT; OP_findkey(); NRET; } case 037 : case037: { EXT; OP_createcell(); NRET; } case 040 : case040: { EXT; OP_bin(); NRET; } case 041 : case041: { goto ni; } case 042 : case042: { goto ni; } case 043 : case043: { goto ni; } case 044 : case044: { goto ni; } case 045 : case045: { goto ni; } case 046 : case046: { EXT; OP_rplcons(); NRET; } case 047 : case047: { EXT; OP_listget(); NRET; } case 050 : case050: { goto ni; } case 051 : case051: { goto ni; } case 052 : case052: { goto ni; } case 053 : case053: { goto ni; } case 054 : case054: { EXT; OP_eval(); NRET; } case 055 : case055: { goto ni; } case 056 : case056: { EXT; OP_dtest(); NRET; } case 057 : case057: { EXT; OP_stkscan(); NRET; } case 060 : case060: { goto ni; } case 061 : case061: { goto ni; } case 062 : case062: { EXT; OP_ubfloat3(); NRET; } case 063 : case063: { EXT; OP_typemask(); NRET; } case 064 : case064: { goto ni; } case 065 : case065: { goto ni; } case 066 : case066: { goto ni; } case 067 : case067: { goto ni; } case 070 : case070: { goto ni; } case 071 : case071: { goto ni; } case 072 : case072: { EXT; OP_eqlop(); NRET; } case 073 : case073: { EXT; OP_drawline(); NRET; } case 074 : case074: { EXT; OP_storen(); NRET; } case 075 : case075: { EXT; OP_copyn(); NRET; } case 076 : case076: { goto ni; } case 077 : case077: { goto ni; }E 2I 2D 7 case 0100 : case0100:  IVARMACRO ( 0 );   case 0101 : case0101:  IVARMACRO ( 1 );   case 0102 : case0102:  IVARMACRO ( 2 );   case 0103 : case0103:  IVARMACRO ( 3 );   case 0104 : case0104:  IVARMACRO ( 4 );   case 0105 : case0105:  IVARMACRO ( 5 );   case 0106 : case0106:  IVARMACRO ( 6 );    case 0107 : case0107:  IVARX ( Get_BYTE(1+PCMAC) );   E 7I 7D 51 case 0100 : case0100:  IVARMACRO (0);   case 0101 : case0101:  IVARMACRO (1);   case 0102 : case0102:  IVARMACRO (2);   case 0103 : case0103:  IVARMACRO (3);   case 0104 : case0104:  IVARMACRO (4);   case 0105 : case0105:  IVARMACRO (5);   case 0106 : case0106:  IVARMACRO (6);    case 0107 : case0107:  IVARX (Get_BYTE(1+PCMAC));   E 51I 51 case 0100 : CASE100:  IVARMACRO (0);   case 0101 : CASE101:  IVARMACRO (1);   case 0102 : CASE102:  IVARMACRO (2);   case 0103 : CASE103:  IVARMACRO (3);   case 0104 : CASE104:  IVARMACRO (4);   case 0105 : CASE105:  IVARMACRO (5);   case 0106 : CASE106:  IVARMACRO (6);   D 60 case 0107 : CASE107:  IVARX (Get_BYTE(1+PCMAC));   E 60I 60 case 0107 : CASE107:  IVARX (Get_BYTE(PCMAC+1));   E 60E 51E 7E 2I 2D 7 case 0110 : case0110:  PVARMACRO ( 0 );   case 0111 : case0111:  PVARMACRO ( 1 );  case 0112 : case0112:  PVARMACRO ( 2 );   case 0113 : case0113:  PVARMACRO ( 3 );   case 0114 : case0114:  PVARMACRO ( 4 );   case 0115 : case0115:  PVARMACRO ( 5 );   case 0116 : case0116:  PVARMACRO ( 6 );    E 7I 7D 51 case 0110 : case0110:  PVARMACRO (0);   case 0111 : case0111:  PVARMACRO (1);  case 0112 : case0112:  PVARMACRO (2);   case 0113 : case0113:  PVARMACRO (3);   case 0114 : case0114:  PVARMACRO (4);   case 0115 : case0115:  PVARMACRO (5);   case 0116 : case0116:  PVARMACRO (6);    E 51I 51 case 0110 : CASE110:  PVARMACRO (0);   case 0111 : CASE111:  PVARMACRO (1);  case 0112 : CASE112:  PVARMACRO (2);   case 0113 : CASE113:  PVARMACRO (3);   case 0114 : CASE114:  PVARMACRO (4);   case 0115 : CASE115:  PVARMACRO (5);   case 0116 : CASE116:  PVARMACRO (6);    E 51E 7E 2D 2 case 0100 : case0100: { IVARMACRO ( 0 );  } case 0101 : case0101: { IVARMACRO ( 2 );  } case 0102 : case0102: { IVARMACRO ( 4 );  } case 0103 : case0103: { IVARMACRO ( 6 );  } case 0104 : case0104: { IVARMACRO ( 8 );  } case 0105 : case0105: { IVARMACRO ( 10 );  } case 0106 : case0106: { IVARMACRO ( 12 );  } E 2I 2D 7 case 0117 : case0117: PVARX( Get_BYTE(1+PCMAC) );E 7I 7D 51 case 0117 : case0117: PVARX(Get_BYTE(1+PCMAC));E 51I 51D 60 case 0117 : CASE117: PVARX(Get_BYTE(1+PCMAC));E 60I 60 case 0117 : CASE117: PVARX(Get_BYTE(PCMAC+1));E 60E 51E 7E 2D 2 case 0110 : case0110: { PVARMACRO (  0 );  } case 0111 : case0111: { PVARMACRO (  2 );  } case 0112 : case0112: { PVARMACRO (  4 );  } case 0113 : case0113: { PVARMACRO (  6 );  } case 0114 : case0114: { PVARMACRO (  8 );  } case 0115 : case0115: { PVARMACRO ( 10 );  } case 0116 : case0116: { PVARMACRO ( 12 );  }  /******** PVarX		********/ case 0117 : case0117: {		CPush(GetLongWord( PVAR + Get_BYTE(1+PCMAC) ));		nextop2;		}E 2I 2D 7 case 0120 : case0120: FVARMACRO ( 0 ); case 0121 : case0121: FVARMACRO ( 1 ); case 0122 : case0122: FVARMACRO ( 2 ); case 0123 : case0123: FVARMACRO ( 3 ); case 0124 : case0124: FVARMACRO ( 4 ); case 0125 : case0125: FVARMACRO ( 5 ); case 0126 : case0126: FVARMACRO ( 6 ); case 0127 : case0127: FVARX( Get_BYTE(1+PCMAC) );E 7I 7D 22 case 0120 : case0120: FVARMACRO (0); case 0121 : case0121: FVARMACRO (1); case 0122 : case0122: FVARMACRO (2); case 0123 : case0123: FVARMACRO (3); case 0124 : case0124: FVARMACRO (4); case 0125 : case0125: FVARMACRO (5); case 0126 : case0126: FVARMACRO (6);E 22I 22D 51 case 0120 : case0120: FVAR(0); case 0121 : case0121: FVAR(1); case 0122 : case0122: FVAR(2); case 0123 : case0123: FVAR(3); case 0124 : case0124: FVAR(4); case 0125 : case0125: FVAR(5); case 0126 : case0126: FVAR(6);E 22 case 0127 : case0127: FVARX(Get_BYTE(1+PCMAC));E 51I 51 case 0120 : CASE120: FVAR(0);D 52 case 0121 : CASE121: FVAR(1); case 0122 : CASE122: FVAR(2); case 0123 : CASE123: FVAR(3); case 0124 : CASE124: FVAR(4); case 0125 : CASE125: FVAR(5); case 0126 : CASE126: FVAR(6);E 52I 52 case 0121 : CASE121: FVAR(2); case 0122 : CASE122: FVAR(4); case 0123 : CASE123: FVAR(6); case 0124 : CASE124: FVAR(8); case 0125 : CASE125: FVAR(10); case 0126 : CASE126: FVAR(12);E 52D 60 case 0127 : CASE127: FVARX(Get_BYTE(1+PCMAC));E 60I 60 case 0127 : CASE127: FVARX(Get_BYTE(PCMAC+1));E 60E 51E 7E 2		D 2 case 0130 : case0130: { PVARSETMACRO (0); } case 0131 : case0131: { PVARSETMACRO (1); } case 0132 : case0132: { PVARSETMACRO (2); } case 0133 : case0133: { PVARSETMACRO (3); } case 0134 : case0134: { PVARSETMACRO (4); } case 0135 : case0135: { PVARSETMACRO (5); } case 0136 : case0136: { PVARSETMACRO (6); }E 2I 2D 51 case 0130 : case0130: PVARSETMACRO (0);  case 0131 : case0131: PVARSETMACRO (1);  case 0132 : case0132: PVARSETMACRO (2); case 0133 : case0133: PVARSETMACRO (3);  case 0134 : case0134: PVARSETMACRO (4);  case 0135 : case0135: PVARSETMACRO (5);  case 0136 : case0136: PVARSETMACRO (6); E 51I 51 case 0130 : CASE130: PVARSETMACRO (0);  case 0131 : CASE131: PVARSETMACRO (1);  case 0132 : CASE132: PVARSETMACRO (2); case 0133 : CASE133: PVARSETMACRO (3);  case 0134 : CASE134: PVARSETMACRO (4);  case 0135 : CASE135: PVARSETMACRO (5);  case 0136 : CASE136: PVARSETMACRO (6); E 51E 2D 2/******** PvarX_	********/E 2I 2D 51 case 0137 : case0137: PVARX_(Get_BYTE(1+PCMAC));E 51I 51D 60 case 0137 : CASE137: PVARX_(Get_BYTE(1+PCMAC));E 60I 60 case 0137 : CASE137: PVARX_(Get_BYTE(PCMAC+1));E 60E 51 D 51 case 0140 : case0140: GVAR(Get_DLword(1+PCMAC));I 21 case 0141 : case0141: ARG0;E 21 case 0142 : case0142: IVARX_(Get_BYTE(1+PCMAC));I 10 case 0143 : case0143: FVARX_(Get_BYTE(1+PCMAC));I 16 case 0144 : case0144: COPY;I 20 case 0145 : case0145: MYARGCOUNT; case 0146 : case0146: MYALINK;E 51I 51D 60 case 0140 : CASE140: GVAR(Get_DLword(1+PCMAC));E 60I 60 case 0140 : CASE140: GVAR(Get_DLword(PCMAC+1));E 60 case 0141 : CASE141: ARG0;D 60 case 0142 : CASE142: IVARX_(Get_BYTE(1+PCMAC)); case 0143 : CASE143: FVARX_(Get_BYTE(1+PCMAC));E 60I 60 case 0142 : CASE142: IVARX_(Get_BYTE(PCMAC+1)); case 0143 : CASE143: FVARX_(Get_BYTE(PCMAC+1));E 60 case 0144 : CASE144: COPY; case 0145 : CASE145: MYARGCOUNT; case 0146 : CASE146: MYALINK;E 51E 20E 16E 10E 2D 2 case 0137 : case0137: {				*((LispPTR *)(PVAR + Get_BYTE(1+PCMAC))) = TOPOFSTACK;		nextop2;		} /******** GVar		********/ case 0140 : case0140: {		CPush(GetLongWord(Valspace + ((Get_DLword(1+PCMAC))<<1)));		nextop3;		}/******** IvarX_	********/ case 0142 : case0142: {		*((LispPTR *)(IVAR + Get_BYTE(1+PCMAC))) = TOPOFSTACK;		nextop2;		}E 2D 16/******** Copy		********/D 2case 0144 : case0144: {	CCopyTos(TOPOFSTACK); nextop1; }E 2I 2case 0144 : case0144: COPY;E 2E 16D 2E 2/******** Aconst	********/D 2 case 0147 : case0147: { CPush(Get_DLword(PCMAC+1)); nextop3;}E 2I 2D 51 case 0147 : case0147: { PUSH(Get_DLword(PCMAC+1)); nextop3;}E 2 case 0150 : case0150: { PUSHATOM(NIL_PTR     ); } case 0151 : case0151: { PUSHATOM(ATOM_T      ); }D 16 case 0152 : case0152: { PUSHATOM(S_POSITIVE  ); } case 0153 : case0153: { PUSHATOM(0xE0001     ); }E 16I 16 case 0152 : case0152: { PUSHATOM(S_POSITIVE  ); } /* '0 */ case 0153 : case0153: { PUSHATOM(0xE0001     ); } /* '1 */E 51I 51 case 0147 : CASE147: { PUSH(Get_DLword(PCMAC+1)); nextop3;} case 0150 : CASE150: { PUSHATOM(NIL_PTR     ); } case 0151 : CASE151: { PUSHATOM(ATOM_T      ); } case 0152 : CASE152: { PUSHATOM(S_POSITIVE  ); } /* '0 */ case 0153 : CASE153: { PUSHATOM(0xE0001     ); } /* '1 */E 51E 16/********* SIC		********/D 51 case 0154 : case0154: {	E 51I 51 case 0154 : CASE154: {	E 51D 2 		CPush(S_POSITIVE | Get_BYTE(PCMAC+1));E 2I 2 		PUSH(S_POSITIVE | Get_BYTE(PCMAC+1));E 2 		nextop2;		}/********* SNIC		********/D 51 case 0155 : case0155: { 	E 51I 51 case 0155 : CASE155: { 	E 51D 2		CPush(S_NEGATIVE | 0xff00 | Get_BYTE(PCMAC+1));E 2I 2		PUSH(S_NEGATIVE | 0xff00 | Get_BYTE(PCMAC+1));E 2 		nextop2;		}/********* SICX		********/D 2 case 0156 : case0156: { 	 		CPush(S_POSITIVE | Get_DLword(PCMAC+1));E 2I 2D 51 case 0156 : case0156:{ 	E 51I 51 case 0156 : CASE156:{ 	E 51 		PUSH(S_POSITIVE | Get_DLword(PCMAC+1));E 2 		nextop3;		}I 2/********* GCONST	********/D 51 case 0157 : case0157: {E 51I 51 case 0157 : CASE157: {E 51		PUSH(	(Get_BYTE(PCMAC + 1) << 16) | 			(Get_BYTE(PCMAC + 2) << 8) | 			Get_BYTE(PCMAC +  3));		nextop4;		} I 28D 51 case 0160 : case0160: { goto op_ufn; } /* unused */ case 0161 : case0161: { goto op_ufn; } /* readflags */ case 0162 : case0162: { goto op_ufn; } /* readrp */ case 0163 : case0163: { goto op_ufn; } /* writemap */ case 0164 : case0164: { goto op_ufn; } /* readprinterport */ case 0165 : case0165: { goto op_ufn; } /* writeprinterport */E 51I 51 case 0160 : CASE160: { goto op_ufn; } /* unused */ case 0161 : CASE161: { goto op_ufn; } /* readflags */ case 0162 : CASE162: { goto op_ufn; } /* readrp */ case 0163 : CASE163: { goto op_ufn; } /* writemap */ case 0164 : CASE164: { goto op_ufn; } /* readprinterport */ case 0165 : CASE165: { goto op_ufn; } /* writeprinterport */E 51E 28I 25D 51 case 0166 : case0166: PILOTBITBLT;E 25I 21 case 0167 : case0167: RCLK;D 28E 28I 28 case 0170 : case0170: { goto op_ufn; } /* MISC1, dorado only */ case 0171 : case0171: { goto op_ufn; } /* MISC2, dorado only */E 28E 21 case 0172 : case0172: RECLAIMCELL;I 10 case 0173 : case0173: GCSCAN1; case 0174 : case0174: GCSCAN2;I 28D 30 case 0175 : case0175: { EXT; OP_subrcall(); NRET};E 28 case 0176 : case0176: CONTEXTSWITCH;E 30I 30 case 0175 : case0175: { EXT; OP_subrcall(); RET; NATIVE_NEXTOP0; }; case 0176 : case0176: { CONTEXTSWITCH; }E 30I 28 case 0177 : case0177: { goto op_ufn; } /* RETCALL */E 51I 51 case 0166 : CASE166: PILOTBITBLT; case 0167 : CASE167: RCLK; case 0170 : CASE170: { goto op_ufn; } /* MISC1, dorado only */ case 0171 : CASE171: { goto op_ufn; } /* MISC2, dorado only */ case 0172 : CASE172: RECLAIMCELL; case 0173 : CASE173: GCSCAN1; case 0174 : CASE174: GCSCAN2; case 0175 : CASE175: { EXT; OP_subrcall(); RET; NATIVE_NEXTOP0; }; case 0176 : CASE176: { CONTEXTSWITCH; } case 0177 : CASE177: { goto op_ufn; } /* RETCALL */E 51E 28E 10E 2I 9D 28E 28I 10/* JUMP */E 10I 10D 51 case 0200 : case0200: { JUMPMACRO(2); } case 0201 : case0201: { JUMPMACRO(3); } case 0202 : case0202: { JUMPMACRO(4); } case 0203 : case0203: { JUMPMACRO(5); } case 0204 : case0204: { JUMPMACRO(6); } case 0205 : case0205: { JUMPMACRO(7); } case 0206 : case0206: { JUMPMACRO(8); } case 0207 : case0207: { JUMPMACRO(9); } case 0210 : case0210: { JUMPMACRO(10); } case 0211 : case0211: { JUMPMACRO(11); } case 0212 : case0212: { JUMPMACRO(12); } case 0213 : case0213: { JUMPMACRO(13); } case 0214 : case0214: { JUMPMACRO(14); } case 0215 : case0215: { JUMPMACRO(15); } case 0216 : case0216: { JUMPMACRO(16); } case 0217 : case0217: { JUMPMACRO(17); }E 51I 51 case 0200 : CASE200: { JUMPMACRO(2); } case 0201 : CASE201: { JUMPMACRO(3); } case 0202 : CASE202: { JUMPMACRO(4); } case 0203 : CASE203: { JUMPMACRO(5); } case 0204 : CASE204: { JUMPMACRO(6); } case 0205 : CASE205: { JUMPMACRO(7); } case 0206 : CASE206: { JUMPMACRO(8); } case 0207 : CASE207: { JUMPMACRO(9); } case 0210 : CASE210: { JUMPMACRO(10); } case 0211 : CASE211: { JUMPMACRO(11); } case 0212 : CASE212: { JUMPMACRO(12); } case 0213 : CASE213: { JUMPMACRO(13); } case 0214 : CASE214: { JUMPMACRO(14); } case 0215 : CASE215: { JUMPMACRO(15); } case 0216 : CASE216: { JUMPMACRO(16); } case 0217 : CASE217: { JUMPMACRO(17); }E 51E 10E 9/* FJUMP */D 51 case 0220 : case0220: { FJUMPMACRO(2); } case 0221 : case0221: { FJUMPMACRO(3); } case 0222 : case0222: { FJUMPMACRO(4); } case 0223 : case0223: { FJUMPMACRO(5); } case 0224 : case0224: { FJUMPMACRO(6); } case 0225 : case0225: { FJUMPMACRO(7); } case 0226 : case0226: { FJUMPMACRO(8); } case 0227 : case0227: { FJUMPMACRO(9); } case 0230 : case0230: { FJUMPMACRO(10); } case 0231 : case0231: { FJUMPMACRO(11); } case 0232 : case0232: { FJUMPMACRO(12); } case 0233 : case0233: { FJUMPMACRO(13); } case 0234 : case0234: { FJUMPMACRO(14); } case 0235 : case0235: { FJUMPMACRO(15); } case 0236 : case0236: { FJUMPMACRO(16); } case 0237 : case0237: { FJUMPMACRO(17); }E 51I 51 case 0220 : CASE220: { FJUMPMACRO(2); } case 0221 : CASE221: { FJUMPMACRO(3); } case 0222 : CASE222: { FJUMPMACRO(4); } case 0223 : CASE223: { FJUMPMACRO(5); } case 0224 : CASE224: { FJUMPMACRO(6); } case 0225 : CASE225: { FJUMPMACRO(7); } case 0226 : CASE226: { FJUMPMACRO(8); } case 0227 : CASE227: { FJUMPMACRO(9); } case 0230 : CASE230: { FJUMPMACRO(10); } case 0231 : CASE231: { FJUMPMACRO(11); } case 0232 : CASE232: { FJUMPMACRO(12); } case 0233 : CASE233: { FJUMPMACRO(13); } case 0234 : CASE234: { FJUMPMACRO(14); } case 0235 : CASE235: { FJUMPMACRO(15); } case 0236 : CASE236: { FJUMPMACRO(16); } case 0237 : CASE237: { FJUMPMACRO(17); }E 51/* TJUMP */I 2E 2D 51 case 0240 : case0240: { TJUMPMACRO(2); } case 0241 : case0241: { TJUMPMACRO(3); } case 0242 : case0242: { TJUMPMACRO(4); } case 0243 : case0243: { TJUMPMACRO(5); } case 0244 : case0244: { TJUMPMACRO(6); } case 0245 : case0245: { TJUMPMACRO(7); } case 0246 : case0246: { TJUMPMACRO(8); } case 0247 : case0247: { TJUMPMACRO(9); } case 0250 : case0250: { TJUMPMACRO(10); } case 0251 : case0251: { TJUMPMACRO(11); } case 0252 : case0252: { TJUMPMACRO(12); } case 0253 : case0253: { TJUMPMACRO(13); } case 0254 : case0254: { TJUMPMACRO(14); } case 0255 : case0255: { TJUMPMACRO(15); } case 0256 : case0256: { TJUMPMACRO(16); } case 0257 : case0257: { TJUMPMACRO(17); }E 51I 51 case 0240 : CASE240: { TJUMPMACRO(2); } case 0241 : CASE241: { TJUMPMACRO(3); } case 0242 : CASE242: { TJUMPMACRO(4); } case 0243 : CASE243: { TJUMPMACRO(5); } case 0244 : CASE244: { TJUMPMACRO(6); } case 0245 : CASE245: { TJUMPMACRO(7); } case 0246 : CASE246: { TJUMPMACRO(8); } case 0247 : CASE247: { TJUMPMACRO(9); } case 0250 : CASE250: { TJUMPMACRO(10); } case 0251 : CASE251: { TJUMPMACRO(11); } case 0252 : CASE252: { TJUMPMACRO(12); } case 0253 : CASE253: { TJUMPMACRO(13); } case 0254 : CASE254: { TJUMPMACRO(14); } case 0255 : CASE255: { TJUMPMACRO(15); } case 0256 : CASE256: { TJUMPMACRO(16); } case 0257 : CASE257: { TJUMPMACRO(17); }E 51/******* JUMPX ********/D 51 case 0260 : case0260: {E 51I 51 case 0260 : CASE260: {E 51D 28/*	if ((*(PCMAC+1)) < 0) {CHECK_INTERRUPT;};*//*	It's easier to check interrupt than the branch direction */E 28		CHECK_INTERRUPT;D 60		PCMAC += *(PCMAC+1); nextop0; E 60I 60		PCMACL += *(PCMAC+1); nextop0; E 60		}I 28/******* JUMPXX ********/D 51 case 0261 : case0261: {E 51I 51 case 0261 : CASE261: {E 51		CHECK_INTERRUPT;D 60		PCMAC += (*(PCMAC+1)<<8) | Get_BYTE(PCMAC+2); nextop0; E 60I 60		PCMACL += (*(PCMAC+1)<<8) | Get_BYTE(PCMAC+2); nextop0; E 60		}E 28/******* FJumpx *******/D 51 case 0262 : case0262: {E 51I 51 case 0262 : CASE262: {E 51D 46	if(TOPOFSTACK != 0) {goto PopNextop2;}E 46I 46    if(TOPOFSTACK != 0) {goto PopNextop2;}E 46D 2/*	if ((*(PCMAC+1)) < 0) {CHECK_INTERRUPT;};*//*	It's easier to check interrupt than the branch direction */E 2	CHECK_INTERRUPT;D 2	CPopCStack;E 2I 2	POP;E 2D 60	PCMAC += *(PCMAC+1);E 60I 60	PCMACL += *(PCMAC+1);E 60	nextop0; 	}I 2/******* TJumpx *******/E 2D 2/******** Pop		********/ case 0277 : case0277: { CPopCStack; nextop1; }E 2I 2D 51 case 0263 : case0263: {E 51I 51 case 0263 : CASE263: {E 51	if(TOPOFSTACK == 0) {goto PopNextop2;}	CHECK_INTERRUPT;	POP;D 60	PCMAC += *(PCMAC+1);E 60I 60	PCMACL += *(PCMAC+1);E 60	nextop0; 	}E 2D 2case 0303 : case0303: { goto ni; }E 2I 2/******* NFJumpx *******/E 2D 2/********  Plus2	********//******** IPlus2	********/	E 2I 2D 51 case 0264 : case0264: {E 51I 51 case 0264 : CASE264: {E 51	if(TOPOFSTACK != 0) {goto PopNextop2;}	CHECK_INTERRUPT;D 60	PCMAC += *(PCMAC+1);E 60I 60	PCMACL += *(PCMAC+1);E 60	nextop0; 	}E 2D 2 case 0324 : case0324: 	 case 0330 : case0330:#ifdef TOS1	{CPopStore(plus(TOS, TOPOFSTACK)); nextop1;}#endif#ifdef TOS0	{TOPOFSTACK=plus(PREVTOS, TOPOFSTACK); CSTKPTR-=2; nextop1;}#endifE 2I 2/******* NTJumpx *******/E 2D 2/*	{ register int arg1, arg2; 	CGETNUMBER(PREVTOS, arg1 );	CGETNUMBER(TOPOFSTACK, arg2 );	arg1 = arg1 + arg2;	 	if(0 <= arg1)	  {     if(arg1 <= MAX_SMALL)			{ CPopStore(S_POSITIVE | arg1); }		else{	register DLword *wordp;			wordp = createcell68k(TYPE_FIXP);			*((unsigned int *)wordp) = arg1;			CPopStore(LADDR_from_68k(wordp)); }	  }else{		if(MIN_SMALL <= arg1)			{ CPopStore(S_NEGATIVE | (0xFFFF & arg1)); }		else{	register DLword *wordp;			wordp = createcell68k(TYPE_FIXP);			*((unsigned int *)wordp) = arg1;			CPopStore(LADDR_from_68k(wordp));}		};	nextop1;E 2I 2D 51 case 0265 : case0265: {E 51I 51 case 0265 : CASE265: {E 51	if(TOPOFSTACK == 0) {goto PopNextop2;}	CHECK_INTERRUPT;D 60	PCMAC += *(PCMAC+1);E 60I 60	PCMACL += *(PCMAC+1);E 60	nextop0; E 2	}I 9D 51 case 0266 : case0266:	AREF1; case 0267 : case0267:	ASET1;E 51I 51 case 0266 : CASE266:	AREF1; case 0267 : CASE267:	ASET1;E 51E 9D 2*/	/********  Difference	********//******** IDifference	********/E 2I 2D 7 case 0270 : case0270:	PVARSETPOPMACRO( 0 ); case 0271 : case0271:	PVARSETPOPMACRO( 1 ); case 0272 : case0272:	PVARSETPOPMACRO( 2 ); case 0273 : case0273:	PVARSETPOPMACRO( 3 ); case 0274 : case0274:	PVARSETPOPMACRO( 4 ); case 0275 : case0275:	PVARSETPOPMACRO( 5 ); case 0276 : case0276:	PVARSETPOPMACRO( 6 );E 7I 7D 51 case 0270 : case0270:	PVARSETPOPMACRO(0); case 0271 : case0271:	PVARSETPOPMACRO(1); case 0272 : case0272:	PVARSETPOPMACRO(2); case 0273 : case0273:	PVARSETPOPMACRO(3); case 0274 : case0274:	PVARSETPOPMACRO(4); case 0275 : case0275:	PVARSETPOPMACRO(5); case 0276 : case0276:	PVARSETPOPMACRO(6);E 51I 51 case 0270 : CASE270:	PVARSETPOPMACRO(0); case 0271 : CASE271:	PVARSETPOPMACRO(1); case 0272 : CASE272:	PVARSETPOPMACRO(2); case 0273 : CASE273:	PVARSETPOPMACRO(3); case 0274 : CASE274:	PVARSETPOPMACRO(4); case 0275 : CASE275:	PVARSETPOPMACRO(5); case 0276 : CASE276:	PVARSETPOPMACRO(6);E 51E 7E 2D 2 case 0325 : case0325:  		 case 0331 : case0331: E 2I 2D 51 case 0277 : case0277: 	{ POP; nextop1; }E 51I 51 case 0277 : CASE277: 	{ POP; nextop1; }E 51E 2D 2#ifdef TOS1	{CPopStore(difference(TOS, TOPOFSTACK)); nextop1;}#endif#ifdef TOS0	{TOPOFSTACK=difference(PREVTOS, TOPOFSTACK); CSTKPTR-=2; nextop1;}#endifE 2I 2D 10 case 0300 : case0300: 	{CSTKPTR -= (Get_BYTE(PCMAC+1) = 1); nextop1; }E 10I 10D 24 case 0300 : case0300:  {CSTKPTR -= (Get_BYTE(PCMAC+1) = 1); nextop1;}E 24I 24D 25 case 0300 : case0300:  {CSTKPTR -= (Get_BYTE(PCMAC+1) + 1); nextop1;}E 25I 25D 26 case 0300 : case0300: /* {CSTKPTR -= (Get_BYTE(PCMAC+1) + 1); nextop1;}				*/ goto ni;E 26I 26D 35 case 0300 : case0300:  { CSTKPTR -= Get_BYTE(PCMAC+1); POP; nextop1; }E 35I 35D 51 case 0300 : case0300:  POPN(Get_BYTE(PCMAC+1));E 35E 26E 25E 24 case 0301 : case0301: 	ATOMCELL_N(Get_BYTE(PCMAC+1));E 10D 19 case 0303 : case0303:  {goto ni;}E 19I 19 case 0302 : case0302: 	GETBASEBYTE;D 21 case 0303 : case0303:  INSTANCEP;E 21I 21 case 0303 : case0303:  INSTANCEP(Get_DLword(PCMAC+1));E 21E 19 case 0304 : case0304:  BLT;I 28 case 0305 : case0305:  {goto op_ufn; } /* MISC10 */ case 0306 : case0306:  {goto op_ufn; } /* P-MISC2 ??? */E 28 case 0307 : case0307:	PUTBASEBYTE; case 0310 : case0310:	GETBASE_N(Get_BYTE(PCMAC+1)); case 0311 : case0311:	GETBASEPTR_N(Get_BYTE(PCMAC+1));I 19 case 0312 : case0312:	GETBITS_N_M(Get_BYTE(PCMAC+1), Get_BYTE(PCMAC+2));I 28 case 0313 : case0313:  {goto op_ufn; } /* unused */E 28E 19I 9 case 0314 : case0314:	CLEQUAL;E 9 case 0315 : case0315:	PUTBASE_N(Get_BYTE(PCMAC+1)); case 0316 : case0316:	PUTBASEPTR_N(Get_BYTE(PCMAC+1));I 19 case 0317 : case0317:	PUTBITS_N_M(Get_BYTE(PCMAC+1), Get_BYTE(PCMAC+2));E 51I 51 case 0300 : CASE300:  POPN(Get_BYTE(PCMAC+1)); case 0301 : CASE301: 	ATOMCELL_N(Get_BYTE(PCMAC+1)); case 0302 : CASE302: 	GETBASEBYTE; case 0303 : CASE303:  INSTANCEP(Get_DLword(PCMAC+1)); case 0304 : CASE304:  BLT; case 0305 : CASE305:  {goto op_ufn; } /* MISC10 */ case 0306 : CASE306:  {goto op_ufn; } /* P-MISC2 ??? */ case 0307 : CASE307:	PUTBASEBYTE; case 0310 : CASE310:	GETBASE_N(Get_BYTE(PCMAC+1)); case 0311 : CASE311:	GETBASEPTR_N(Get_BYTE(PCMAC+1)); case 0312 : CASE312:	GETBITS_N_M(Get_BYTE(PCMAC+1), Get_BYTE(PCMAC+2)); case 0313 : CASE313:  {goto op_ufn; } /* unused */ case 0314 : CASE314:	CLEQUAL; case 0315 : CASE315:	PUTBASE_N(Get_BYTE(PCMAC+1)); case 0316 : CASE316:	PUTBASEPTR_N(Get_BYTE(PCMAC+1)); case 0317 : CASE317:	PUTBITS_N_M(Get_BYTE(PCMAC+1), Get_BYTE(PCMAC+2));E 51E 19E 2I 2D 51 case 0320 : case0320:	ADDBASE; case 0321 : case0321:	VAG2; case 0322 : case0322:	HILOC; case 0323 : case0323:	LOLOC;E 2D 28I 10 case 0327 : case0327: case 0333 : case0333:	QUOTIENT;E 10D 2/*	{  register int arg1, arg2; 	CGETNUMBER(PREVTOS , arg1 );	CGETNUMBER(TOPOFSTACK, arg2 );	arg1 = arg1 - arg2;	 	if(0 <= arg1)	  {     if(arg1 <= MAX_SMALL)			{ CPopStore(S_POSITIVE | arg1); }		else{	register DLword *wordp;			wordp = createcell68k(TYPE_FIXP);			*((unsigned int *)wordp) = arg1;			CPopStore(LADDR_from_68k(wordp)); }	  }else{		if(MIN_SMALL <= arg1)			{ CPopStore(S_NEGATIVE | (0xFFFF & arg1)); }		else{	register DLword *wordp;			wordp = createcell68k(TYPE_FIXP);			*((unsigned int *)wordp) = arg1;			CPopStore(LADDR_from_68k(Cordp));}		}!	nextop1;	}*/E 2I 2 case 0324 : case0324: 	 case 0330 : case0330: 	PLUS;D 10	E 10I 10E 10 case 0325 : case0325:  		 case 0331 : case0331:	DIFFERENCE;E 2I 10 case 0326 : case0326: case 0332 : case0332:	TIMES2;E 28I 28 case 0324 : case0324: 	PLUS2; /* PLUS */ case 0325 : case0325:  DIFFERENCE;	/* DIFFERENCE */	se0231: { FJUMPMACRO(11); } case 0232 : case0232: { FJUMPMACRO(12); } case 0233 : case0233: { FJUMPMACRO(13); } case 0234 : case0234: { FJUMPMACRO(14); } case 0235 : case0235: { FJUMPMACRO(15); } case 0236 : case0236: { FJUMPMACRO(16); } case 0237 : case0237: { FJUMPMACRO(17); }E 51I 51 case 0220 : CASE220: { FJUMPMACRO(2); } case 0221 : CASE221: { FJUMPMACRO(3); } case 0222 : CASE222: { FJUMPMACRO(4); } case 0223 : CASE223: { FJUMPMACRO(5); } case 0224 : CASE224: { FJUMPMACRO(6); } case 0225 : CASE225: { FJUMPMACRO(7); } case 0226 : CASE226: { FJUMPMACRO(8); } case 0227 : CASE227: { FJUMPMACRO(9); } case 0230 : CASE230: { FJUMPMACRO(10); } case 0231 : CASE231: { FJUMPMACRO(11); } case 0232 : CASE232: { FJUMPMACRO(12); } case 0233 : CASE233: { FJUMPMACRO(13); } case 0234 : CASE234: { FJUMPMACRO(14); } case 0235 : CASE235: { FJUMPMACRO(15); } case 0236 : CASE236: { FJUMPMACRO(16); } case 0237 : CASE237: { FJUMPMACRO(17); }E 51/* TJUMP */I 2E 2D 51 case 0240 : case0240: { T50 : case0350:  FPLUS2; case 0351 : case0351:  FDIFFERENCE; case 0352 : case0352:  FTIMES2; case 0353 : case0353:  FQUOTIENT; case 0354 : case0354:  UBFLOAT2(Get_BYTE(PCMAC+1)); case 0355 : case0355:  UBFLOAT1(Get_BYTE(PCMAC+1)); case 0356 : case0356:  AREF2; case 0357 : case0357:  ASET2;E 51I 51D 65 case 0320 : CASE320:	ADDBASE; case 0321 : CASE321:	VAG2; case 0322 : CASE322:	HILOC; case 0323 : CASE323:	LOLOC;E 65I 65 case 0320 : CASE320:	N_OP_ADDBASE; case 0321 : CASE321:	N_OP_VAG2; case 0322 : CASE322:	N_OP_HILOC; case 0323 : CASE323:	N_OP_LOLOC;E 65 case 0324 : CASE324: 	PLUS2; /* PLUS */ case 0325 : CASE325:  DIFFERENCE;	/* DIFFERENCE */	 case 0326 : CASE326:	TIMES2; /* TIMES2 */ case 0327 : CASE327:  QUOTIENT /* QUOTIENT */ case 0330 : CASE330:  IPLUS2; /* IPLUS2 only while PLUS has no float */ case 0331 : CASE331:  IDIFFERENCE; /* IDIFFERENCE only while no float */ case 0332 : CASE332:	ITIMES2; /* ITIMES2 only while no float */ case 0333 : CASE333:	IQUOTIENT; /* IQUOTIENT */ case 0334 : CASE334:	IREMAINDER; case 0335 : CASE335:	IPLUS_N(Get_BYTE(PCMAC+1)); case 0336 : CASE336:	IDIFFERENCE_N(Get_BYTE(PCMAC+1)); case 0337 : CASE337:  { goto op_ufn; } /* BASE-< */ case 0340 : CASE340:  LLSH1; case 0341 : CASE341:  LLSH8; case 0342 : CASE342:  LRSH1; case 0343 : CASE343:  LRSH8; case 0344 : CASE344:  LOGOR; case 0345 : CASE345:  LOGAND; case 0346 : CASE346:  LOGXOR; case 0347 : CASE347:  LSH; case 0350 : CASE350:  FPLUS2; case 0351 : CASE351:  FDIFFERENCE; case 0352 : CASE352:  FTIMES2; case 0353 : CASE353:  FQUOTIENT; case 0354 : CASE354:  UBFLOAT2(Get_BYTE(PCMAC+1)); case 0355 : CASE355:  UBFLOAT1(Get_BYTE(PCMAC+1)); case 0356 : CASE356:  AREF2; case 0357 : CASE357:  ASET2;E 51E 9D 2		if(TOPOFSTACK == PREVTOS)			CPopStore(ATOM_T)		else	CPopStore(NIL_PTR);E 2I 2D 51 case 0360 : case0360: {E 51I 51 case 0360 : CASE360: {E 51		if(TOPOFSTACK == POP_TOS_1)			TOPOFSTACK = ATOM_T;		else	TOPOFSTACK = NIL_PTR;E 2		nextop1;		}I 28D 51 case 0361 : case0361:  IGREATERP; /* IGREATERP if no float */	E 28I 9 case 0362 : case0362:  FGREATERP;E 9D 2/******** IGreaterP	********//********  GreaterP	********/E 2D 28 case 0361 : case0361:  		E 28D 2 case 0363 : case0363: #ifdef TOS1	{CPopStore(greaterp(TOS, TOPOFSTACK)); nextop1;}#endif#ifdef TOS0	{TOPOFSTACK=greaterp(PREVTOS, TOPOFSTACK); CSTKPTR-=2; nextop1;}#endifE 2I 2 case 0363 : case0363:	GREATERP;I 9 case 0364 : case0364:  ILEQUAL;E 9I 7 case 0365 : case0365:	MAKENUMBER; case 0366 : case0366:	BOXIPLUS; case 0367 : case0367:	BOXIDIFFERENCE;I 28 case 0370 : case0370:  { goto op_ufn; } /* FLOATBLT */ case 0371 : case0371:  { goto op_ufn; } /* FFTSTEP */E 28I 9 case 0372 : case0372: 	MISC3(Get_BYTE(PCMAC+1)); case 0373 : case0373: 	MISC4(Get_BYTE(PCMAC+1));I 28 case 0374 : case0374:  { goto op_ufn; } /* upctrace */E 28E 9E 7 case 0375 : case0375: 	SWAP;E 2D 10E 10I 10D 38 case 0376 : case0376: 	nextop1;E 38I 38 case 0376 : case0376: 	NOP;E 38E 10D 2/*{ register int arg1, arg2; E 2I 2D 9 case 0377 : case0377: 	{goto ni; }E 9I 9 case 0377 : case0377: 	CLARITHEQUAL;E 51I 51 case 0361 : CASE361:  IGREATERP; /* IGREATERP if no float */	 case 0362 : CASE362:  FGREATERP; case 0363 : CASE363:	GREATERP; case 0364 : CASE364:  ILEQUAL; case 0365 : CASE365:	MAKENUMBER; case 0366 : CASE366:	BOXIPLUS; case 0367 : CASE367:	BOXIDIFFERENCE; case 0370 : CASE370:  { goto op_ufn; } /* FLOATBLT */ case 0371 : CASE371:  { goto op_ufn; } /* FFTSTEP */ case 0372 : CASE372: 	MISC3(Get_BYTE(PCMAC+1)); case 0373 : CASE373: 	MISC4(Get_BYTE(PCMAC+1)); case 0374 : CASE374:  { goto op_ufn; } /* upctrace */ case 0375 : CASE375: 	SWAP; case 0376 : CASE376: 	NOP; case 0377 : CASE377: 	CLARITHEQUAL;E 51E 9 	D 28 default: 	DEFAULT;E 28I 28 default: 	error("should not default");I 52D 64	FVAR_CODE_HERE;I 53	FVARX_CODE_HERE;E 53E 52E 28E 2E 64D 2		CGETNUMBER(PREVTOS,arg1);		CGETNUMBER(TOPOFSTACK ,arg2);		if(arg1 > arg2)			CPopStore(ATOM_T)		else	CPopStore(NIL_PTR);		nextop1;		}*/E 2I 2	 }	/* switch */E 2D 14D 2/******* SWAP *******/ case 0375 : case0375: { register int temp; 		 	temp = PREVTOS;			PREVTOS = TOPOFSTACK;		 	TOPOFSTACK = (LispPTR)temp;			nextop1;			} case 0377 : case0377: {goto ni; } default: ni: {     		EXT;		(*(OPtbl_base + Get_BYTE(PCMAC)))(); 		RET; nextop0; 		}	    }	/* switch */E 2 nextop0;E 14I 64#ifdef NATIVETRANE 64D 2{  setfixtosaddr();#ifdef TOS1   CSTKPTR += 2; #endif    setniaddr();   EXT;   (*(OPtbl_base + Get_BYTE(PCMAC)))();   RET;    nextop0; }E 2I 2D 4	OPCODEFAIL;E 4E 2D 44E 44I 4D 16/* NATIVE CODE INTERFACE */E 16I 16/************************************************************************//*	 	NATIVE CODE INTERFACE 					*//************************************************************************/E 16E 4I 2D 16callnative:	TopOfStack = TOPOFSTACK;	StackPtrSave;D 3/*	printf("call native: 0x%x, at %d\n",FuncObj->framename,PC); */E 3I 3/*	printf("Call Native: %d, RA: %d, FuncObj 0x%x\n",		PC,(unsigned int)PCMAC,(unsigned int)FuncObj);*/ E 3	PC = (InstPtr)D 3		(  Native_Hash[FuncObj->framename] )			(PC, (unsigned int)PCMAC - (unsigned int)FuncObj) E 3I 3		(  Native_Hash[FuncObj->framename] )(PC, PCMAC) E 3D 4		+ (unsigned int)FuncObj;E 4I 4		;E 4	goto native2;E 16I 16D 56/*		DISPATCH -> NATIVE					*//*		Global PC is already set				*//*		Entry Point is set					*/E 56E 16E 2D 16gonative:	EXT;D 2/*	printf("Frame name: %x, atomindex: %x \n",FuncObj->framename,save_atom_index);*/E 2I 2native1:E 16I 16D 56call_native:		HARD_PUSH(TOPOFSTACK);	CurrentStackPTR = (DLword *) CSTKPTR;D 41/*	printf("Call Native: %d,  FuncObj 0x%x\n",		PC,(unsigned int)FuncObj);*/E 41D 23	asmgoto((Native_Hash[FuncObj->framename])());E 23I 23D 27	asmgoto(Native_Hash[FuncObj->framename]);E 27I 27	asmgoto(GET_NATIVE_ADDR(FuncObj));E 27E 23/*		DISPATCH -> NATIVE					*//*		Must set global PC 					*//*		Entry point is PC indexed				*/ret_native:E 16D 3/*	printf("ret native: 0x%x, at 0x%x\n",FuncObj->framename,PCMAC); */E 3I 3D 41/*	printf("To native: %d, 0x%x, FuncObj 0x%x, opcode: %oQ\n",		PC - (unsigned int)FuncObj,PC,FuncObj,Get_BYTE(PC));*/ E 41E 3E 2D 16	PC = (InstPtr)		(  Native_Hash[FuncObj->framename] )D 3			((unsigned int)PCMAC - (unsigned int)FuncObj) E 3I 3			((unsigned int)PC - (unsigned int)FuncObj) E 3D 4		+ (unsigned int)FuncObj;E 4I 4		;E 16I 16	HARD_PUSH(TOPOFSTACK);	CurrentStackPTR = (DLword *) CSTKPTR;	PC = PCMAC - (unsigned int) FuncObj;E 16E 4D 41D 2  	(*(OPtbl_base + Get_BYTE(PC))) ();E 2I 2D 16native2:D 3/*	printf("Ret PC: %d\n",PC- (unsigned int)FuncObj);	printf(" Real PC: 0x%x\n",PC);	printf(" opcode: 0x%x\n",Get_BYTE(PC));E 3I 3D 4/*	printf("From Native: %d, 0x%x, FuncObj 0x%x, opcode: %oQ\n",		PC - (unsigned int)FuncObj,PC,FuncObj,Get_BYTE(PC));E 4I 4/*	printf("From Native: %d, 0x%x, FuncObj 0x%x",		PC - (unsigned int)FuncObj,PC,FuncObj);	printf(", opcode: %oQ\n",Get_BYTE(PC));E 16I 16/*	printf("Ret Native: %d,  FuncObj 0x%x\n",		PC,(unsigned int)FuncObj);E 16E 4E 3*/E 41D 16 	(*(OPtbl_base + Get_BYTE(PC))) ();	if (CURRENTFX->native) goto native1;I 3/*	printf("Back to BCE: %d, 0x%x, FuncObj 0x%x, opcode: %oQ\n",		PC - (unsigned int)FuncObj,PC,FuncObj,Get_BYTE(PC));*/E 3E 2  	RET;E 16I 16D 23	asmgoto((Native_Hash[FuncObj->framename])());E 23I 23D 27	asmgoto(Native_Hash[FuncObj->framename]);E 27I 27	asmgoto(GET_NATIVE_ADDR(FuncObj));E 27E 23E 56I 45/*		FORIEGN -> DISPATCH 					*//*		Return to current frame ext				*/c_ret_to_dispatch:	asm("	.globl	_c_ret_to_dispatch");	asm("_c_ret_to_dispatch:");D 56	PC = (ByteCode *) FuncObj + BCE_CURRENTFX->pc;E 56I 56D 60	PCMAC = (ByteCode *) FuncObj + BCE_CURRENTFX->pc;E 60I 60	PCMACL = (ByteCode *) FuncObj + BCE_CURRENTFX->pc;E 60E 56	goto ret_to_dispatch;		/* assume optimizer will remove */E 45/*		NATIVE -> DISPATCH 					*//*		Return to current frame ext				*/ret_to_dispatch:	asm("	.globl	_ret_to_dispatch");	asm("_ret_to_dispatch:");D 56	RET_FROM_NATIVE(0);E 56I 56	RET_FROM_NATIVE;E 56E 16D 2	NativeCheck;E 2I 2	nextop0;I 4I 16/*		NATIVE -> DISPATCH 					*//*		Execute opcode in current frame ext			*/E 16E 4E 2I 16ret_to_unimpl:	asm("	.globl	_ret_to_unimpl");	asm("_ret_to_unimpl:");D 56	RET_FROM_NATIVE(0x100);E 56I 56	SaveD6 = 0x100;E 56I 30			/* HACK.  Reg. d6 is set to dispatch to native_check */			/* so need to do switch instead of dispatch! */I 56	RET_FROM_NATIVE;E 56E 30	goto nextopcode;I 41/*		NATIVE -> UFN(PC) 					*/ret_to_ufn:	asm("	.globl	_ret_to_ufn");	asm("_ret_to_ufn:");D 56	RET_FROM_NATIVE(0);E 56I 56	RET_FROM_NATIVE;E 56	goto op_ufn;E 41/*		DISPATCH -> NATIVE? 					*//*		Return to current frame ext?				*/	native_check:D 56	if (BCE_CURRENTFX->native)  { goto ret_native; }E 56	SaveD6 = 0;D 56	nextop0;E 56I 56	NATIVE_NEXTOP0;E 56D 30/************************************************************************//*	 	 COMMON TAILS		 				*//************************************************************************/	E 30I 30/*		NATIVE -> TIMER						*//*		Return to Execute timer interrupt			*/E 30I 30ret_to_timer:	asm("_ret_to_timer:");	asm("	.globl	_ret_to_timer");D 41	RET_FROM_NATIVE(0);E 41I 41D 56	RET_FROM_NATIVE(0x100);E 56I 56	SaveD6 = 0x100;	RET_FROM_NATIVE;E 56E 41D 44E 44D 45	/* Fall into Timer Check Routine */E 45I 45D 64	goto check_interrupt;	/* assume optimizer will remove *.E 64I 64	goto check_interrupt;	/* assume optimizer will remove */E 64E 45I 64#elseE 64I 64native_check: #ifdef OPDISP		SaveD6 = 0x000;#endif		goto nextopcode;#endifE 64I 38/************************************************************************/E 38/*		TIMER INTERRUPT CHECK ROUTINE				*/D 38E 38I 38/************************************************************************/E 38check_interrupt:I 67D 68#ifndef NOASME 68E 67D 38	LoopCounter=1600;	if (!Intrdisable) {EXT; update_timer(); RET;};E 38I 38D 44D 40		 if ( (int)CSTKPTR > (int)StkLimO )			{printf("REAL STK OVERFLOW\n Irq_Stk_Check: 0x%x\n Irq_Stk_End: 0x%x\n StkLimO: 0x%x\n",			Irq_Stk_Check,Irq_Stk_End,StkLimO);			printf("PC: 0x%x, OPCODE: 0x%x\n",PCMAC,Get_BYTE(PCMAC));			error("REAL STK OVERFLOW");			}E 40I 40	 if ( (int)CSTKPTR > (int)StkLimO )		{printf("REAL STK OVERFLOW\n Irq_Stk_Check: 0x%x\n Irq_Stk_End: 0x%x\n StkLimO: 0x%x\n",		Irq_Stk_Check,Irq_Stk_End,StkLimO);		printf("PC: 0x%x, OPCODE: 0x%x\n",PCMAC,Get_BYTE(PCMAC));			error("REAL STK OVERFLOW");E 44I 44D 59	 if ( (int)CSTKPTR > (int)EndSTKP )E 59I 59D 64#ifndef	NOASME 64I 64D 66#ifndef	NATIVETRANE 66I 66#ifdef	NATIVETRANE 66E 64	asm_label_check_interrupt();I 67#elseD 68#ifdef	mc68020E 68I 68#ifdef	SUN3_OS3_ILE 68	asm_label_check_interrupt();#endif#endifE 67D 68#endifE 68D 61/* ************* I TOOK THIS CHECK OUT, IT SHOULD NOT BE NEEDED (BK)E 61	if ( (int)CSTKPTR > (int)EndSTKP )E 59D 61		{printf("REAL STK OVERFLOW\n Current = 0x%x\n EndSTKP = 0x\n Irq_Stk_Check: 0x%x\n Irq_Stk_End: 0x%x\n",		CSTKPTR,EndSTKP,Irq_Stk_Check,Irq_Stk_End);		printf("PC: 0x%x, OPCODE: 0x%x\n",PCMAC,Get_BYTE(PCMAC));			error("Unrecoverable stack overflow not detected");E 61I 61		{EXT;		 error("Unrecoverable Stack Overflow");	         RET;E 61E 44		}I 59D 61************** */E 61E 59E 40I 40	/* Check for an IRQ request */D 42{int stkend, fromirq = 0;E 42I 42D 62{register int need_irq = 0;E 62I 62{register int need_irq;E 62I 48 static int period_cnt=60;extern int	KBDEventFlg;extern LispPTR DOBUFFEREDTRANSITION_index;extern LispPTR INTERRUPTFRAME_index;extern LispPTR *KEYBUFFERING68k;extern LispPTR *PENDINGINTERRUPT68k;extern LispPTR ATOM_STARTED;extern LispPTR *PERIODIC_INTERRUPT68k;extern LispPTR *PERIODIC_INTERRUPT_FREQUENCY68k;extern LispPTR PERIODIC_INTERRUPTFRAME_index;extern LispPTR *Reclaim_cnt_word;extern LispPTR DORECLAIM_index;I 57extern int URaid_req;E 57E 48E 42E 40D 42	if (Irq_Stk_End == 0) {		/* Really an IRQ request */		if (!Intrdisable) {	/* Interrupts not Disabled */			EXT; 			update_timer(); 			RET;			}			/* Clear out IRQ (looses pending interrupt request 			   if interrupts are disabled) */		CLR_IRQ;I 40		fromirq = 1;E 42I 42D 43/*	if ((STK_END_COMPUTE(StkLimO, FuncObj) != Irq_Stk_Check) && Irq_Stk_Check) 		{	printf("bad Irq_Stk_Check: 0x%x, should be: 0x%x\n",			Irq_Stk_Check, STK_END_COMPUTE(StkLimO, FuncObj));E 42E 40		}D 42E 42I 42*/E 43E 42I 40	/* Check for an Stack Overflow */E 40D 42	if ((int)CSTKPTR > Irq_Stk_Check) E 42I 42D 43	if ( 	((int)CSTKPTR > Irq_Stk_Check) && E 43I 43re_check_stack:I 62	need_irq = 0;E 62	if ( 	((int)(CSTKPTR+1) > Irq_Stk_Check) && E 43		(Irq_Stk_End > 0) && 		(Irq_Stk_Check > 0) )E 42		{D 40		 if ( (int)CSTKPTR > (int)StkLimO )			{printf("REAL STK OVERFLOW\n Irq_Stk_Check: 0x%x\n Irq_Stk_End: 0x%x\n StkLimO: 0x%x\n",			Irq_Stk_Check,Irq_Stk_End,StkLimO);			printf("PC: 0x%x, OPCODE: 0x%x\n",PCMAC,Get_BYTE(PCMAC));			error("REAL STK OVERFLOW");E 40I 40D 42		stkend = (int) STK_END_COMPUTE(StkLimO, FuncObj);/* ***		if ((int)CSTKPTR < stkend) 			{printf("usf CHK: 0x%x, END: 0x%x, LIM: 0x%x, stkend: 0x%x, from IRQ %d\n",					Irq_Stk_Check,Irq_Stk_End,StkLimO,stkend,fromirq);		 	 printf("CSTKPTR: 0x%x, stkmin: 0x%x\n",CSTKPTR,FuncObj->stkmin);			 printf("opcode: 0x%x\n",Get_BYTE(PCMAC));			 retfun();E 40			}I 40****** */E 40E 42D 40	/* HACK DO-STACK OVERFLOW HERE ******* */E 40	 	 HARD_PUSH(TOPOFSTACK);D 40		 BCE_CURRENTFX->pc = (unsigned int)PCMAC-(unsigned int)FuncObj;E 40		 EXT;D 61		 if (do_stackoverflow(NIL)) {RET; CLR_IRQ; nextop0; }E 61I 61D 62		 if (do_stackoverflow(NIL))  {			error("Stack Overflow");			TopOfStack = NIL;			RET;			CLR_IRQ; 			nextop0; 			}E 62I 62		 extended_frame = NIL;D 63		 if (do_stackoverflow(NIL))  { error("Stack Overflow"); }E 62E 61		 RET;		 POP;E 63I 63		 if (do_stackoverflow(NIL)) { 			error("Stack Overflow, MUST HARDRESET!"); 			RET; TOPOFSTACK = NIL_PTR; 			}		 else { RET; POP; }E 63D 42		 CLR_IRQ;E 42I 42D 44		 Irq_Stk_Check = STK_END_COMPUTE(StkLimO, FuncObj);E 44I 44		 Irq_Stk_Check = (int)EndSTKP-STK_MIN(FuncObj);E 44D 62		 need_irq = (Irq_Stk_End == 0);E 62I 62		 need_irq = (Irq_Stk_End == 0)  || extended_frame;		 *PENDINGINTERRUPT68k |= extended_frame; E 62D 44		 Irq_Stk_End = (int) StkLimO;E 44I 44		 Irq_Stk_End = (int) EndSTKP;E 44E 42		}I 42	/* Check for an IRQ request */	if ((Irq_Stk_End <= 0) || (Irq_Stk_Check <= 0) || need_irq) {D 49		if (!Intrdisable) {	/* Interrupts not Disabled */E 49I 49D 62		if (StkOffset_from_68K(CSTKPTR) > InterfacePage->stackbase) {	/* Interrupts not Disabled */E 49D 44			EXT; E 44I 44			EXT; CLR_IRQ;E 62I 62		if (StkOffset_from_68K(CSTKPTR) > InterfacePage->stackbase) {			/* Interrupts not Disabled */E 62I 50#ifndef KBINTE 50			getsignaldata();I 50#endifI 62			EXT; E 62E 50E 44			update_timer(); I 62E 62I 57			if(URaid_req ==T){				URaid_req=NIL;				error("Call URaid by User Interrupt");			}E 57I 44D 48			contextsw( KbdFXP, 0, 0);E 48I 48D 49			/*contextsw( KbdFXP, 0, 0);*/			if(StkOffset_from_68K(CSTKPTR) < InterfacePage->stackbase)			{ RET;nextop0;}/* We are the inside of SYSTEM context */E 49I 49D 62E 49			if((KBDEventFlg>0)&&(*KEYBUFFERING68k==ATOM_T)){E 62I 62			else if((KBDEventFlg>0)&&(*KEYBUFFERING68k==ATOM_T)) {E 62				*KEYBUFFERING68k= ATOM_STARTED;				cause_interruptcall(DOBUFFEREDTRANSITION_index);				KBDEventFlg --;D 62			}I 49			else if(*Reclaim_cnt_word == S_POSITIVE)				{  					*Reclaim_cnt_word=NIL;					cause_interruptcall(DORECLAIM_index);E 62				}D 62			else if(*PENDINGINTERRUPT68k!=NIL)				{ 					cause_interruptcall(INTERRUPTFRAME_index);					*PENDINGINTERRUPT68k=NIL;E 62I 62			else if(*Reclaim_cnt_word == S_POSITIVE) {  				*Reclaim_cnt_word=NIL;				cause_interruptcall(DORECLAIM_index);E 62				}E 49D 62			else if(*PERIODIC_INTERRUPT68k!=NIL)				{					if(period_cnt>0)  period_cnt--;					else 					{						cause_interruptcall(PERIODIC_INTERRUPTFRAME_index);D 49						if(PERIODIC_INTERRUPT_FREQUENCY68k==NIL)E 49I 49						if(*PERIODIC_INTERRUPT_FREQUENCY68k==NIL)E 49							period_cnt=0;						else							period_cnt=(*PERIODIC_INTERRUPT_FREQUENCY68k & 0xffff) -1;E 62I 62			else if(*PENDINGINTERRUPT68k!=NIL) { 				*PENDINGINTERRUPT68k=NIL;				cause_interruptcall(INTERRUPTFRAME_index);				}			else if(*PERIODIC_INTERRUPT68k!=NIL) {				if(period_cnt>0)  period_cnt--;				else {					cause_interruptcall(PERIODIC_INTERRUPTFRAME_index);					if(*PERIODIC_INTERRUPT_FREQUENCY68k==NIL)						period_cnt=0;					elseD 64						period_cnt=(*PERIODIC_INTERRUPT_FREQUENCY68k & 0xffff) -1;E 64I 64						period_cnt=(*PERIODIC_INTERRUPT_FREQUENCY68k & 0xffff) *(1000000/60) /TIMER_INTERVAL;	/* number of 1/60 second periods between interrupts.	  TIMER_INTERVAL is the number of microseconds between	  timer interrupts. The calculation here avoids some	  overflow errors although there is some roundoff	  if the interrupt frequency number is too low,	 it will bottom out and just set period_cnt to 0 */E 64E 62					}D 49				}			else if(*PENDINGINTERRUPT68k!=NIL)				{ 					cause_interruptcall(INTERRUPTFRAME_index);					*PENDINGINTERRUPT68k=NIL;				}			else if(((*Reclaim_cnt_word) & 0xffff) == 0)				{  					*Reclaim_cnt_word=NIL;					cause_interruptcall(DORECLAIM_index);E 49				}D 62E 62E 48E 44			RET;D 43			}E 43I 43D 44			CLR_IRQ;E 44D 62		} else {E 62I 62			CLR_IRQ;			} /* Interrupts not Disabled */		else {E 62E 43D 44			/* Clear out IRQ (looses pending interrupt request E 44I 44			/* Clear out IRQ (loses pending interrupt request E 44			   if interrupts are disabled) */D 43		CLR_IRQ;E 43I 43			CLR_IRQ;			goto re_check_stack;			}E 43		}E 42I 40}E 40D 40E 40E 38	nextop0;I 38/************************************************************************/E 38E 30E 16/* Common Jump Tails (they have to jump anyway, so use common Tail) */D 38E 38I 38/************************************************************************/E 38PopNextop1:D 2	CPopCStack; E 2I 2	POP; E 2	nextop1;PopNextop2:D 2	CPopCStack; E 2I 2	POP; E 2	nextop2;D 30check_stack:D 2	if (CSTKPTR >= StkLimO) {EXT; contextsw(SubovFXP,0,0); RET;};E 2I 2	if ((DLword * ) CSTKPTR >= StkLimO)		{EXT; contextsw(SubovFXP,0,0); RET;};I 7	CHECK_INTERRUPT;	nextop0;E 7E 2check_interrupt:D 12	LoopCounter=400;E 12I 12D 15	LoopCounter=800;E 15I 15	LoopCounter=1600;E 15E 12	if (!Intrdisable) {EXT; update_timer(); RET;};	nextop0;E 30#ifdef OPDISP setup_table:I 68	SaveD6 = 0;E 68D 64	SaveD6 = 0;E 64I 64#ifdef UNSAFEE 64I 7	Save_D5_shift_amount = 15;I 64#endifD 68#ifdef OPDISP#ifdef mc68020#ifndef NOASM	SaveD6 = 0;#endif#endif#endifE 68E 64E 7I 2D 28	{int i; for (i = 0; i < 256; i++) { table[i] = (InstPtr) ni; };}E 28I 28	{int i; for (i = 0; i < 256; i++) { table[i] = (InstPtr) op_ufn; };}E 28I 16	{int i; for (i = 256; i < 512; i++) 		{ table[i] = (InstPtr) native_check; };	}E 16E 2D 28	table[000] = (InstPtr) ni;E 28	table[001] = (InstPtr) case001;	table[002] = (InstPtr) case002;	table[003] = (InstPtr) case003;	table[004] = (InstPtr) case004;	table[005] = (InstPtr) case005;	table[006] = (InstPtr) case006;	table[007] = (InstPtr) case007;	table[010] = (InstPtr) case010;	table[011] = (InstPtr) case011;	table[012] = (InstPtr) case012;	table[013] = (InstPtr) case013;	table[014] = (InstPtr) case014;	table[015] = (InstPtr) case015;	table[016] = (InstPtr) case016;	table[017] = (InstPtr) case017;	table[020] = (InstPtr) case020;	table[021] = (InstPtr) case021;	table[022] = (InstPtr) case022;	table[023] = (InstPtr) case023;	table[024] = (InstPtr) case024;	table[025] = (InstPtr) case025;	table[026] = (InstPtr) case026;	table[027] = (InstPtr) case027;	table[030] = (InstPtr) case030;	table[031] = (InstPtr) case031;	table[032] = (InstPtr) case032;	table[033] = (InstPtr) case033;	table[034] = (InstPtr) case034;D 9	table[035] = (InstPtr) ni;E 9I 9	table[035] = (InstPtr) case035;E 9	table[036] = (InstPtr) case036;	table[037] = (InstPtr) case037;	table[040] = (InstPtr) case040;D 28	table[041] = (InstPtr) ni;	table[042] = (InstPtr) ni;E 28I 28	table[041] = (InstPtr) case041;	table[042] = (InstPtr) case042;E 28D 9	table[043] = (InstPtr) ni;E 9I 9	table[043] = (InstPtr) case043;E 9D 28	table[044] = (InstPtr) ni;	table[045] = (InstPtr) ni;E 28I 28	table[044] = (InstPtr) case044;	table[045] = (InstPtr) case045;E 28	table[046] = (InstPtr) case046;	table[047] = (InstPtr) case047;D 28	table[050] = (InstPtr) ni;	table[051] = (InstPtr) ni;	table[052] = (InstPtr) ni;	table[053] = (InstPtr) ni;E 28I 28E 28	table[054] = (InstPtr) case054;D 28	table[055] = (InstPtr) ni;E 28I 28	table[055] = (InstPtr) case055;E 28	table[056] = (InstPtr) case056;	table[057] = (InstPtr) case057;D 28	table[060] = (InstPtr) ni;	table[061] = (InstPtr) ni;E 28I 28E 28	table[062] = (InstPtr) case062;	table[063] = (InstPtr) case063;D 28	table[064] = (InstPtr) ni;	table[065] = (InstPtr) ni;	table[066] = (InstPtr) ni;	table[067] = (InstPtr) ni;	table[070] = (InstPtr) ni;	table[071] = (InstPtr) ni;E 28I 28E 28	table[072] = (InstPtr) case072;	table[073] = (InstPtr) case073;	table[074] = (InstPtr) case074;	table[075] = (InstPtr) case075;D 28	table[076] = (InstPtr) ni;	table[077] = (InstPtr) ni;E 28I 28E 28D 51	table[0100] = (InstPtr) case0100;	table[0101] = (InstPtr) case0101;	table[0102] = (InstPtr) case0102;	table[0103] = (InstPtr) case0103;	table[0104] = (InstPtr) case0104;	table[0105] = (InstPtr) case0105;	table[0106] = (InstPtr) case0106;D 2	table[0107] = (InstPtr) ni;E 2I 2	table[0107] = (InstPtr) case0107;E 2	table[0110] = (InstPtr) case0110;	table[0111] = (InstPtr) case0111;	table[0112] = (InstPtr) case0112;	table[0113] = (InstPtr) case0113;	table[0114] = (InstPtr) case0114;	table[0115] = (InstPtr) case0115;	table[0116] = (InstPtr) case0116;	table[0117] = (InstPtr) case0117;D 2	table[0120] = (InstPtr) ni;	table[0121] = (InstPtr) ni;	table[0122] = (InstPtr) ni;	table[0123] = (InstPtr) ni;	table[0124] = (InstPtr) ni;	table[0125] = (InstPtr) ni;	table[0126] = (InstPtr) ni;	table[0127] = (InstPtr) ni;E 2I 2	table[0120] = (InstPtr) case0120;	table[0121] = (InstPtr) case0121;	table[0122] = (InstPtr) case0122;	table[0123] = (InstPtr) case0123;	table[0124] = (InstPtr) case0124;	table[0125] = (InstPtr) case0125;	table[0126] = (InstPtr) case0126;	table[0127] = (InstPtr) case0127;E 2	table[0130] = (InstPtr) case0130;	table[0131] = (InstPtr) case0131;	table[0132] = (InstPtr) case0132;	table[0133] = (InstPtr) case0133;	table[0134] = (InstPtr) case0134;	table[0135] = (InstPtr) case0135;	table[0136] = (InstPtr) case0136;	table[0137] = (InstPtr) case0137;	table[0140] = (InstPtr) case0140;D 21	table[0141] = (InstPtr) ni;E 21I 21	table[0141] = (InstPtr) case0141;E 21	table[0142] = (InstPtr) case0142;D 10	table[0143] = (InstPtr) ni;E 10I 10	table[0143] = (InstPtr) case0143;E 10	table[0144] = (InstPtr) case0144;D 20	table[0145] = (InstPtr) ni;	table[0146] = (InstPtr) ni;E 20I 20	table[0145] = (InstPtr) case0145;	table[0146] = (InstPtr) case0146;E 20	table[0147] = (InstPtr) case0147;	table[0150] = (InstPtr) case0150;	table[0151] = (InstPtr) case0151;	table[0152] = (InstPtr) case0152;	table[0153] = (InstPtr) case0153;D 2	table[0154] = (InstPtr) ni;E 2I 2	table[0154] = (InstPtr) case0154;E 2	table[0155] = (InstPtr) case0155;	table[0156] = (InstPtr) case0156;D 2	table[0157] = (InstPtr) ni;E 2I 2	table[0157] = (InstPtr) case0157;E 2D 28	table[0160] = (InstPtr) ni;	table[0161] = (InstPtr) ni;	table[0162] = (InstPtr) ni;	table[0163] = (InstPtr) ni;	table[0164] = (InstPtr) ni;	table[0165] = (InstPtr) ni;E 28I 28	table[0160] = (InstPtr) case0160;	table[0161] = (InstPtr) case0161;	table[0162] = (InstPtr) case0162;	table[0163] = (InstPtr) case0163;	table[0164] = (InstPtr) case0164;	table[0165] = (InstPtr) case0165;E 28D 25	table[0166] = (InstPtr) ni;E 25I 25	table[0166] = (InstPtr) case0166;E 25D 21	table[0167] = (InstPtr) ni;E 21I 21	table[0167] = (InstPtr) case0167;E 21D 28	table[0170] = (InstPtr) ni;	table[0171] = (InstPtr) ni;E 28I 28	table[0170] = (InstPtr) case0170;	table[0171] = (InstPtr) case0171;E 28D 2	table[0172] = (InstPtr) ni;E 2I 2	table[0172] = (InstPtr) case0172;E 2D 10	table[0173] = (InstPtr) ni;	table[0174] = (InstPtr) ni;E 10I 10	table[0173] = (InstPtr) case0173;	table[0174] = (InstPtr) case0174;E 10D 28	table[0175] = (InstPtr) ni;E 28I 28	table[0175] = (InstPtr) case0175;E 28D 10	table[0176] = (InstPtr) ni;E 10I 10	table[0176] = (InstPtr) case0176;E 10D 28	table[0177] = (InstPtr) ni;E 28I 28	table[0177] = (InstPtr) case0177;E 28D 10	table[0200] = (InstPtr) ni;	table[0201] = (InstPtr) ni;	table[0202] = (InstPtr) ni;	table[0203] = (InstPtr) ni;	table[0204] = (InstPtr) ni;	table[0205] = (InstPtr) ni;	table[0206] = (InstPtr) ni;	table[0207] = (InstPtr) ni;	table[0210] = (InstPtr) ni;	table[0211] = (InstPtr) ni;	table[0212] = (InstPtr) ni;	table[0213] = (InstPtr) ni;	table[0214] = (InstPtr) ni;	table[0215] = (InstPtr) ni;	table[0216] = (InstPtr) ni;	table[0217] = (InstPtr) ni;E 10I 10	table[0200] = (InstPtr) case0200;	table[0201] = (InstPtr) case0201;	table[0202] = (InstPtr) case0202;	table[0203] = (InstPtr) case0203;	table[0204] = (InstPtr) case0204;	table[0205] = (InstPtr) case0205;	table[0206] = (InstPtr) case0206;	table[0207] = (InstPtr) case0207;	table[0210] = (InstPtr) case0210;	table[0211] = (InstPtr) case0211;	table[0212] = (InstPtr) case0212;	table[0213] = (InstPtr) case0213;	table[0214] = (InstPtr) case0214;	table[0215] = (InstPtr) case0215;	table[0216] = (InstPtr) case0216;	table[0217] = (InstPtr) case0217;E 10	table[0220] = (InstPtr) case0220;	table[0221] = (InstPtr) case0221;	table[0222] = (InstPtr) case0222;	table[0223] = (InstPtr) case0223;	table[0224] = (InstPtr) case0224;	table[0225] = (InstPtr) case0225;	table[0226] = (InstPtr) case0226;	table[0227] = (InstPtr) case0227;	table[0230] = (InstPtr) case0230;	table[0231] = (InstPtr) case0231;	table[0232] = (InstPtr) case0232;	table[0233] = (InstPtr) case0233;	table[0234] = (InstPtr) case0234;	table[0235] = (InstPtr) case0235;	table[0236] = (InstPtr) case0236;	table[0237] = (InstPtr) case0237;	table[0240] = (InstPtr) case0240;	table[0241] = (InstPtr) case0241;	table[0242] = (InstPtr) case0242;	table[0243] = (InstPtr) case0243;	table[0244] = (InstPtr) case0244;	table[0245] = (InstPtr) case0245;	table[0246] = (InstPtr) case0246;	table[0247] = (InstPtr) case0247;	table[0250] = (InstPtr) case0250;	table[0251] = (InstPtr) case0251;	table[0252] = (InstPtr) case0252;	table[0253] = (InstPtr) case0253;	table[0254] = (InstPtr) case0254;	table[0255] = (InstPtr) case0255;	table[0256] = (InstPtr) case0256;	table[0257] = (InstPtr) case0257;	table[0260] = (InstPtr) case0260;D 28	table[0261] = (InstPtr) ni;E 28I 28	table[0261] = (InstPtr) case0261;E 28	table[0262] = (InstPtr) case0262;D 2	table[0263] = (InstPtr) ni;	table[0264] = (InstPtr) ni;	table[0265] = (InstPtr) ni;E 2I 2	table[0263] = (InstPtr) case0263;	table[0264] = (InstPtr) case0264;	table[0265] = (InstPtr) case0265;E 2D 9	table[0266] = (InstPtr) ni;	table[0267] = (InstPtr) ni;E 9I 9	table[0266] = (InstPtr) case0266;	table[0267] = (InstPtr) case0267;E 9D 2	table[0270] = (InstPtr) ni;	table[0271] = (InstPtr) ni;	table[0272] = (InstPtr) ni;	table[0273] = (InstPtr) ni;	table[0274] = (InstPtr) ni;	table[0275] = (InstPtr) ni;	table[0276] = (InstPtr) ni;E 2I 2	table[0270] = (InstPtr) case0270;	table[0271] = (InstPtr) case0271;	table[0272] = (InstPtr) case0272;	table[0273] = (InstPtr) case0273;	table[0274] = (InstPtr) case0274;	table[0275] = (InstPtr) case0275;	table[0276] = (InstPtr) case0276;E 2	table[0277] = (InstPtr) case0277;D 2	table[0300] = (InstPtr) ni;E 2I 2	table[0300] = (InstPtr) case0300;E 2D 10	table[0301] = (InstPtr) ni;E 10I 10	table[0301] = (InstPtr) case0301;E 10D 19	table[0302] = (InstPtr) ni;E 19I 19	table[0302] = (InstPtr) case0302;E 19	table[0303] = (InstPtr) case0303;D 2	table[0304] = (InstPtr) ni;E 2I 2	table[0304] = (InstPtr) case0304;E 2D 28	table[0305] = (InstPtr) ni;	table[0306] = (InstPtr) ni;E 28I 28	table[0305] = (InstPtr) case0305;	table[0306] = (InstPtr) case0306;E 28D 2	table[0307] = (InstPtr) ni;	table[0310] = (InstPtr) ni;	table[0311] = (InstPtr) ni;E 2I 2	table[0307] = (InstPtr) case0307;	table[0310] = (InstPtr) case0310;	table[0311] = (InstPtr) case0311;E 2D 19	table[0312] = (InstPtr) ni;E 19I 19	table[0312] = (InstPtr) case0312;E 19D 28	table[0313] = (InstPtr) ni;E 28I 28	table[0313] = (InstPtr) case0313;E 28D 9	table[0314] = (InstPtr) ni;E 9I 9	table[0314] = (InstPtr) case0314;E 9D 2	table[0315] = (InstPtr) ni;	table[0316] = (InstPtr) ni;E 2I 2	table[0315] = (InstPtr) case0315;	table[0316] = (InstPtr) case0316;E 2D 19	table[0317] = (InstPtr) ni;E 19I 19	table[0317] = (InstPtr) case0317;E 19D 2	table[0320] = (InstPtr) ni;	table[0321] = (InstPtr) ni;	table[0322] = (InstPtr) ni;	table[0323] = (InstPtr) ni;E 2I 2	table[0320] = (InstPtr) case0320;	table[0321] = (InstPtr) case0321;	table[0322] = (InstPtr) case0322;	table[0323] = (InstPtr) case0323;E 2	table[0324] = (InstPtr) case0324;	table[0325] = (InstPtr) case0325;D 10	table[0326] = (InstPtr) ni;	table[0327] = (InstPtr) ni;E 10I 10	table[0326] = (InstPtr) case0326;	table[0327] = (InstPtr) case0327;E 10	table[0330] = (InstPtr) case0330;	table[0331] = (InstPtr) case0331;D 10	table[0332] = (InstPtr) ni;	table[0333] = (InstPtr) ni;	table[0334] = (InstPtr) ni;	table[0335] = (InstPtr) ni;	table[0336] = (InstPtr) ni;E 10I 10	table[0332] = (InstPtr) case0332;	table[0333] = (InstPtr) case0333;	table[0334] = (InstPtr) case0334;	table[0335] = (InstPtr) case0335;	table[0336] = (InstPtr) case0336;E 10D 28	table[0337] = (InstPtr) ni;E 28I 28	table[0337] = (InstPtr) case0337;E 28D 2	table[0340] = (InstPtr) ni;	table[0341] = (InstPtr) ni;	table[0342] = (InstPtr) ni;	table[0343] = (InstPtr) ni;	table[0344] = (InstPtr) ni;	table[0345] = (InstPtr) ni;E 2I 2	table[0340] = (InstPtr) case0340;	table[0341] = (InstPtr) case0341;	table[0342] = (InstPtr) case0342;	table[0343] = (InstPtr) case0343;	table[0344] = (InstPtr) case0344;	table[0345] = (InstPtr) case0345;E 2D 7	table[0346] = (InstPtr) ni;E 7I 7	table[0346] = (InstPtr) case0346;E 7D 28	table[0347] = (InstPtr) ni;E 28I 28	table[0347] = (InstPtr) case0347;E 28D 9	table[0350] = (InstPtr) ni;	table[0351] = (InstPtr) ni;	table[0352] = (InstPtr) ni;	table[0353] = (InstPtr) ni;	table[0354] = (InstPtr) ni;	table[0355] = (InstPtr) ni;	table[0356] = (InstPtr) ni;	table[0357] = (InstPtr) ni;E 9I 9	table[0350] = (InstPtr) case0350;	table[0351] = (InstPtr) case0351;	table[0352] = (InstPtr) case0352;	table[0353] = (InstPtr) case0353;	table[0354] = (InstPtr) case0354;	table[0355] = (InstPtr) case0355;	table[0356] = (InstPtr) case0356;	table[0357] = (InstPtr) case0357;E 9	table[0360] = (InstPtr) case0360;	table[0361] = (InstPtr) case0361;D 9	table[0362] = (InstPtr) ni;E 9I 9	table[0362] = (InstPtr) case0362;E 9	table[0363] = (InstPtr) case0363;D 9	table[0364] = (InstPtr) ni;E 9I 9	table[0364] = (InstPtr) case0364;E 9D 7	table[0365] = (InstPtr) ni;	table[0366] = (InstPtr) ni;	table[0367] = (InstPtr) ni;E 7I 7	table[0365] = (InstPtr) case0365;	table[0366] = (InstPtr) case0366;	table[0367] = (InstPtr) case0367;E 7D 28	table[0370] = (InstPtr) ni;	table[0371] = (InstPtr) ni;E 28I 28	table[0370] = (InstPtr) case0370;	table[0371] = (InstPtr) case0371;E 28D 9	table[0372] = (InstPtr) ni;	table[0373] = (InstPtr) ni;E 9I 9	table[0372] = (InstPtr) case0372;	table[0373] = (InstPtr) case0373;E 9D 28	table[0374] = (InstPtr) ni;E 28I 28	table[0374] = (InstPtr) case0374;E 28	table[0375] = (InstPtr) case0375;D 10	table[0376] = (InstPtr) ni;E 10I 10	table[0376] = (InstPtr) case0376;E 10D 9	table[0377] = (InstPtr) ni;E 9I 9	table[0377] = (InstPtr) case0377;E 51I 51	table[0100] = (InstPtr) case100;	table[0101] = (InstPtr) case101;	table[0102] = (InstPtr) case102;	table[0103] = (InstPtr) case103;	table[0104] = (InstPtr) case104;	table[0105] = (InstPtr) case105;	table[0106] = (InstPtr) case106;	table[0107] = (InstPtr) case107;	table[0110] = (InstPtr) case110;	table[0111] = (InstPtr) case111;	table[0112] = (InstPtr) case112;	table[0113] = (InstPtr) case113;	table[0114] = (InstPtr) case114;	table[0115] = (InstPtr) case115;	table[0116] = (InstPtr) case116;	table[0117] = (InstPtr) case117;	table[0120] = (InstPtr) case120;	table[0121] = (InstPtr) case121;	table[0122] = (InstPtr) case122;	table[0123] = (InstPtr) case123;	table[0124] = (InstPtr) case124;	table[0125] = (InstPtr) case125;	table[0126] = (InstPtr) case126;	table[0127] = (InstPtr) case127;	table[0130] = (InstPtr) case130;	table[0131] = (InstPtr) case131;	table[0132] = (InstPtr) case132;	table[0133] = (InstPtr) case133;	table[0134] = (InstPtr) case134;	table[0135] = (InstPtr) case135;	table[0136] = (InstPtr) case136;	table[0137] = (InstPtr) case137;	table[0140] = (InstPtr) case140;	table[0141] = (InstPtr) case141;	table[0142] = (InstPtr) case142;	table[0143] = (InstPtr) case143;	table[0144] = (InstPtr) case144;	table[0145] = (InstPtr) case145;	table[0146] = (InstPtr) case146;	table[0147] = (InstPtr) case147;	table[0150] = (InstPtr) case150;	table[0151] = (InstPtr) case151;	table[0152] = (InstPtr) case152;	table[0153] = (InstPtr) case153;	table[0154] = (InstPtr) case154;	table[0155] = (InstPtr) case155;	table[0156] = (InstPtr) case156;	table[0157] = (InstPtr) case157;	table[0160] = (InstPtr) case160;	table[0161] = (InstPtr) case161;	table[0162] = (InstPtr) case162;	table[0163] = (InstPtr) case163;	table[0164] = (InstPtr) case164;	table[0165] = (InstPtr) case165;	table[0166] = (InstPtr) case166;	table[0167] = (InstPtr) case167;	table[0170] = (InstPtr) case170;	table[0171] = (InstPtr) case171;	table[0172] = (InstPtr) case172;	table[0173] = (InstPtr) case173;	table[0174] = (InstPtr) case174;	table[0175] = (InstPtr) case175;	table[0176] = (InstPtr) case176;	table[0177] = (InstPtr) case177;	table[0200] = (InstPtr) case200;	table[0201] = (InstPtr) case201;	table[0202] = (InstPtr) case202;	table[0203] = (InstPtr) case203;	table[0204] = (InstPtr) case204;	table[0205] = (InstPtr) case205;	table[0206] = (InstPtr) case206;	table[0207] = (InstPtr) case207;	table[0210] = (InstPtr) case210;	table[0211] = (InstPtr) case211;	table[0212] = (InstPtr) case212;	table[0213] = (InstPtr) case213;	table[0214] = (InstPtr) case214;	table[0215] = (InstPtr) case215;	table[0216] = (InstPtr) case216;	table[0217] = (InstPtr) case217;	table[0220] = (InstPtr) case220;	table[0221] = (InstPtr) case221;	table[0222] = (InstPtr) case222;	table[0223] = (InstPtr) case223;	table[0224] = (InstPtr) case224;	table[0225] = (InstPtr) case225;	table[0226] = (InstPtr) case226;	table[0227] = (InstPtr) case227;	table[0230] = (InstPtr) case230;	table[0231] = (InstPtr) case231;	table[0232] = (InstPtr) case232;	table[0233] = (InstPtr) case233;	table[0234] = (InstPtr) case234;	table[0235] = (InstPtr) case235;	table[0236] = (InstPtr) case236;	table[0237] = (InstPtr) case237;	table[0240] = (InstPtr) case240;	table[0241] = (InstPtr) case241;	table[0242] = (InstPtr) case242;	table[0243] = (InstPtr) case243;	table[0244] = (InstPtr) case244;	table[0245] = (InstPtr) case245;	table[0246] = (InstPtr) case246;	table[0247] = (InstPtr) case247;	table[0250] = (InstPtr) case250;	table[0251] = (InstPtr) case251;	table[0252] = (InstPtr) case252;	table[0253] = (InstPtr) case253;	table[0254] = (InstPtr) case254;	table[0255] = (InstPtr) case255;	table[0256] = (InstPtr) case256;	table[0257] = (InstPtr) case257;	table[0260] = (InstPtr) case260;	table[0261] = (InstPtr) case261;	table[0262] = (InstPtr) case262;	table[0263] = (InstPtr) case263;	table[0264] = (InstPtr) case264;	table[0265] = (InstPtr) case265;	table[0266] = (InstPtr) case266;	table[0267] = (InstPtr) case267;	table[0270] = (InstPtr) case270;	table[0271] = (InstPtr) case271;	table[0272] = (InstPtr) case272;	table[0273] = (InstPtr) case273;	table[0274] = (InstPtr) case274;	table[0275] = (InstPtr) case275;	table[0276] = (InstPtr) case276;	table[0277] = (InstPtr) case277;	table[0300] = (InstPtr) case300;	table[0301] = (InstPtr) case301;	table[0302] = (InstPtr) case302;	table[0303] = (InstPtr) case303;	table[0304] = (InstPtr) case304;	table[0305] = (InstPtr) case305;	table[0306] = (InstPtr) case306;	table[0307] = (InstPtr) case307;	table[0310] = (InstPtr) case310;	table[0311] = (InstPtr) case311;	table[0312] = (InstPtr) case312;	table[0313] = (InstPtr) case313;	table[0314] = (InstPtr) case314;	table[0315] = (InstPtr) case315;	table[0316] = (InstPtr) case316;	table[0317] = (InstPtr) case317;	table[0320] = (InstPtr) case320;	table[0321] = (InstPtr) case321;	table[0322] = (InstPtr) case322;	table[0323] = (InstPtr) case323;	table[0324] = (InstPtr) case324;	table[0325] = (InstPtr) case325;	table[0326] = (InstPtr) case326;	table[0327] = (InstPtr) case327;	table[0330] = (InstPtr) case330;	table[0331] = (InstPtr) case331;	table[0332] = (InstPtr) case332;	table[0333] = (InstPtr) case333;	table[0334] = (InstPtr) case334;	table[0335] = (InstPtr) case335;	table[0336] = (InstPtr) case336;	table[0337] = (InstPtr) case337;	table[0340] = (InstPtr) case340;	table[0341] = (InstPtr) case341;	table[0342] = (InstPtr) case342;	table[0343] = (InstPtr) case343;	table[0344] = (InstPtr) case344;	table[0345] = (InstPtr) case345;	table[0346] = (InstPtr) case346;	table[0347] = (InstPtr) case347;	table[0350] = (InstPtr) case350;	table[0351] = (InstPtr) case351;	table[0352] = (InstPtr) case352;	table[0353] = (InstPtr) case353;	table[0354] = (InstPtr) case354;	table[0355] = (InstPtr) case355;	table[0356] = (InstPtr) case356;	table[0357] = (InstPtr) case357;	table[0360] = (InstPtr) case360;	table[0361] = (InstPtr) case361;	table[0362] = (InstPtr) case362;	table[0363] = (InstPtr) case363;	table[0364] = (InstPtr) case364;	table[0365] = (InstPtr) case365;	table[0366] = (InstPtr) case366;	table[0367] = (InstPtr) case367;	table[0370] = (InstPtr) case370;	table[0371] = (InstPtr) case371;	table[0372] = (InstPtr) case372;	table[0373] = (InstPtr) case373;	table[0374] = (InstPtr) case374;	table[0375] = (InstPtr) case375;	table[0376] = (InstPtr) case376;	table[0377] = (InstPtr) case377;E 51E 9     goto nextopcode;#endif     }I 40int retfun() {return(0);}I 56do_brk() {}E 56E 40I 2D 36E 2#define KATANARCLKSECOND 1000000D 2update_timer ()E 2I 2update_timer()E 2 {  	int     excess;	unsigned int	usec;        struct  timeval time;	getsignaldata();        gettimeofday(&time, NIL);	usec = time.tv_sec * KATANARCLKSECOND;        MiscStats->rclktemp0 = usec + time.tv_usec;        excess = MiscStats->rclktemp0 - MiscStats->baseclock;        if(excess >= KATANARCLKSECOND | (excess <= 0))                {                MiscStats->baseclock = MiscStats->rclktemp0;                MiscStats->millisecondsclock += 1000;                MiscStats->secondsclock += 1;                }  }E 36E 1