h27416s 00006/00002/00240d D 2.27 92/06/26 13:48:04 sybalsky 32 31c retrofit of 386 unix changes \nes 00003/00003/00239d D 2.26 92/04/21 17:05:27 sybalsky 31 30c shortening file names for DOS \nes 00007/00010/00235d D 2.25 90/05/14 12:02:48 fuji 30 29c Matsuda: support color funcs on CG6es 00000/00000/00245d D 2.24 90/04/20 01:22:15 sybalsky 29 28c AIX:  shortening file names, bulk change.es 00083/00065/00162d D 2.23 90/03/16 21:08:34 sybalsky 28 27c ci disp386i.iles 00017/00001/00210d D 2.22 90/03/01 12:56:09 osamu 27 26c Mitsunori Matsuda adds XWindow functionality.es 00002/00002/00209d D 2.21 90/02/12 11:42:58 takeshi 26 25c Add SCCS headeres 00004/00004/00207d D 2.20 89/12/13 10:53:11 sybalsky 25 24c color ss1es 00005/00001/00206d D 2.19 89/10/19 17:57:46 sybalsky 24 23c display buffering for SSes 00000/00000/00207d D 2.18 89/03/30 20:30:00 sybalsky 23 22c TUrn off pixrects on 386es 00019/00000/00188d D 2.17 89/02/14 13:26:59 snow 22 21c Added an IFDEF to pilotbitblt for making loadups on the sunes 00059/00000/00129d D 2.16 89/01/17 10:02:02 shimizu 21 20c Add Color cursores 00007/00007/00122d D 2.15 89/01/11 16:08:44 shimizu 20 19c Back to previopus version(-1)es 00007/00007/00122d D 2.14 89/01/10 20:37:05 shimizu 19 18c Try to use the argument's x rather than culuculating it(cursorin)es 00003/00002/00126d D 2.13 89/01/04 16:55:02 shimizu 18 17c For C-Cursor trackinges 00008/00010/00120d D 2.12 88/10/13 18:56:16 shih 17 16c minor cleanup (needs lispmap.h)es 00001/00002/00129d D 2.11 88/10/12 14:40:55 krivacic 16 15c new out-of-line interfacees 00034/00089/00097d D 2.10 88/09/23 13:52:56 charnley 15 14c using new bb.hes 00049/00256/00137d D 2.9 88/08/18 16:56:24 charnley 14 13c rewrote for performance.es 00001/00001/00392d D 2.8 88/08/10 14:17:51 charnley 13 12c all backwards cases now go thru bitblt_bpl1().es 00099/00073/00294d D 2.7 88/07/25 13:13:13 shimizu 12 11c AR:10447 fixedes 00016/00279/00351d D 2.6 88/07/15 12:44:01 masinter 11 10c add ifdef sparc to avoid bug in %fast-array-copy use of bitblt. remove C_onlyes 00002/00008/00628d D 2.5 88/06/29 17:26:17 shimizu 10 9c Add register decl. and remove commentses 00029/00017/00607d D 2.4 88/06/20 13:03:48 shimizu 9 8c Fix AR10239,10383(BITOP & LARGE ARRAY INIT)es 00171/00154/00453d D 2.3 88/06/10 01:16:53 sybalsky 8 7c Made the old opcode routines conditional on C_ONLY; reformatted code.es 00080/00008/00527d D 2.2 88/06/02 14:26:05 shimizu 7 6c Can treat bpl=1 casees 00000/00000/00535d D 2.1 88/05/17 09:22:29 hayata 6 5c Version up to 2.1es 00126/00027/00409d D 1.5 88/05/11 20:09:15 shimizu 5 4c For merging bitbltes 00158/00000/00278d D 1.4 88/04/14 11:04:05 krivacic 4 3c native interfacees 00007/00004/00271d D 1.3 88/04/11 17:56:27 masinter 3 2c Fix bitblt to know that display can have 2 segmentses 00002/00002/00273d D 1.2 88/03/13 14:33:37 hayata 2 1c Add SCCS key id (%Z%)es 00275/00000/00000d D 1.1 88/02/24 16:55:54 hayata 1 0c date and time created 88/02/24 16:55:54 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 25/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */D 11static char *id = "%Z% %M%	%I% %G%";E 11I 11static char *id = "%Z% %M%      %I% %G%";E 25I 25D 26/* This is G-file @(#) bitblt.c Version 2.18 (3/30/89). copyright Xerox & Fuji Xerox  */static char *id = "@(#) bitblt.c      2.18 3/30/89";E 26I 26D 28/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 28I 28/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 28static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 26E 25E 11E 2I 28D 30E 30/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 28/*D 28 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.E 28 *D 3 *	Auther :  Osamu NakamuraE 3I 3 *	Author :  Osamu NakamuraE 3D 17D 3	***** ADOPTED NEW VERSIONE 3E 17 * */#include <stdio.h>#include <sys/ioctl.h>D 11E 11I 11D 12#include <memory.h>E 12I 12I 24#ifndef NOPIXRECTE 24E 12E 11D 14#include <pixrect/pixrect_hs.h>E 14#include <sunwindow/window_hs.h>#include <sunwindow/win_ioctl.h>I 5D 24#ifdef WINDOWE 24#include <suntool/sunview.h>#include <signal.h>#include <sunwindow/cms_mono.h>#include <suntool/canvas.h>#endifE 5I 27#ifdef XWINDOW I 32	/* ldeXdefs is normally in MyWindow, but we don't need the rest of it. */#include "ldeXdefs.h"E 32#define DISPLAYBUFFER#endif XWINDOWE 27#include "lispemul.h"D 31#include "lispglobal.h"E 31I 31#include "lspglob.h"E 31#include "lispmap.h"D 31#include "emulglobal.h"#include "address68k.h"E 31I 31#include "emlglob.h"#include "adr68k.h"E 31#include "address.h"#include "pilotbbt.h"#include "display.h"I 5#include "bitblt.h"I 14#include "bb.h"E 14E 5I 7D 15E 15E 7D 5E 5extern int LispWindowFd;I 18extern int ScreenLocked;I 22extern int kbd_for_makeinit;E 22E 18D 15extern int DisplayWidth, DisplayHeight;E 15I 30#ifdef COLORextern int MonoOrColor;#endif COLORE 30D 15extern struct pixrect *SrcPixRect, *DestPixRect, *TexturePixRect;extern struct cursor	CurrentCursor;E 15D 18E 18D 15/* DisplayLockArea specifies win_lock area when bitblt is operated * It specifies whole screen area. */extern struct winlock DisplayLockArea;I 5#ifdef WINDOWextern Pixwin *Lisp_pw;extern struct pixrect *ScreenBitMap;#endifE 5D 5unsigned short pix_operation();E 5D 8I 5/* unsigned short pix_operation(); */E 5OP_pilotbitblt(){E 8I 8D 11/***************************************************************************** * *			OP_pilotbitblt * *	The C-only version of the BITBLT opcode * *****************************************************************************/#ifdef C_ONLY   OP_pilotbitblt()     {E 8	PILOTBBT  *pbt;D 8#ifdef TRACE        printPC();        printf("TRACE: OP_pilotbitblt()\n");E 8I 8#ifdef TRACE   /* Trace the op, if called for. */           printPC();           printf("TRACE: OP_pilotbitblt()\n");E 8#endifD 8	pbt = (PILOTBBT *)Addr68k_from_LADDR(*(LispPTR *)( CurrentStackPTR ));E 8I 8	pbt = (PILOTBBT *)Addr68k_from_LADDR(*(LispPTR *)( CurrentStackPTR ));E 8	CurrentStackPTR-=2;D 8E 8	pilotbitblt( pbt );I 5#ifdef WINDOWD 8	pw_rop( Lisp_pw, 0, 0, DisplayWidth, DisplayHeight, PIX_SRC,		ScreenBitMap, 0, 0);E 8I 8	   pw_rop( Lisp_pw, 0, 0, DisplayWidth, DisplayHeight, PIX_SRC,		   ScreenBitMap, 0, 0);E 8#endifE 5	PC++;D 8} /* end of OP_pilotbitblt */E 8I 8     } /* end of OP_pilotbitblt */E 8I 4D 8E 4pilotbitblt( pbt )PILOTBBT *pbt;{E 8I 8   pilotbitblt( pbt )     PILOTBBT *pbt;     {E 8	short 	*srcaddr, *destaddr;	int 	x, h, displayflg, destbpl, sourcebpl, distance;I 5	int	dx, sx, w, y;E 5	u_short pix_op;D 8	if( pbt->pbtusegray )		return( bitblt_texture( pbt ) );	/* texture bitblt */E 8I 8	if( pbt->pbtusegray ) return( bitblt_texture( pbt ) );	/* texture */E 8			srcaddr = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,						     pbt->pbtsourcelo));	destaddr = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, 						      pbt->pbtdestlo ));	if( pbt->pbtbackward ){		x = ( pbt->pbtdestbpl/BITSPER_DLWORD ) * (pbt->pbtheight -1);		srcaddr += x;		destaddr += x;	}		h = pbt->pbtheight;	SrcPixRect->pr_width = sourcebpl = abs( pbt->pbtsourcebpl ); 	SrcPixRect->pr_height = h;	(mpr_d(SrcPixRect))->md_image = srcaddr;D 5	mpr_mdlinebytes(SrcPixRect)	/* Takeshi 30-Dec-87 	 = abs( (pbt->pbtsourcebpl + 7) >> 3 ) ;*/	= ( SrcPixRect->pr_width +7) >>3;E 5I 5	mpr_mdlinebytes(SrcPixRect) = ( SrcPixRect->pr_width +7) >>3;E 5	 	DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );	DestPixRect->pr_height = h;	        mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;D 9	if(destbpl <= pbt->pbtdestbit){	/* Special case */E 9I 9	if((destbpl <= pbt->pbtdestbit) && 	   (pbt->pbtwidth * pbt->pbtheight < 32768)){	/* Special case */E 9		if( destbpl % 8 == 0 ){			 (char *)(mpr_d(DestPixRect))->md_image = 				 (char *)destaddr + ( destbpl >> 3 );			 pbt->pbtdestbit = 0;		}		else{			(mpr_d(DestPixRect))->md_image = destaddr;		}	}	else{	/* Normal Case */		(mpr_d(DestPixRect))->md_image = destaddr;	}	D 9	if(sourcebpl <= pbt->pbtsourcebit){	/* Special case */E 9I 9	if((sourcebpl <= pbt->pbtsourcebit) && 	   (pbt->pbtwidth * pbt->pbtheight < 32768)){	/* Special case */E 9		if( sourcebpl % 8 == 0 ){			 (char *)(mpr_d(SrcPixRect))->md_image = 				 (char *)srcaddr + ( sourcebpl >> 3 );			 pbt->pbtsourcebit = 0;		}		else{			(mpr_d(SrcPixRect))->md_image = srcaddr;		}	}	else{	/* Normal Case */		(mpr_d(SrcPixRect))->md_image = srcaddr;	}	/* if displayflg != 0 then source or destination is DisplayBitMap */I 5/*E 5	displayflg = (pbt->pbtsourcehi == DISPALY_HI) ||D 3		     (pbt->pbtdesthi == DISPALY_HI);E 3I 3		     (pbt->pbtdesthi == DISPALY_HI) || 		     (pbt->pbtdesthi == DISPALY_HI+1) || 		     (pbt->pbtsourcehi == DISPALY_HI+1);E 3D 5	pix_op = pix_operation( (unsigned short)pbt->pbtsourcetype,E 5I 5*/ 	displayflg = cursorin(pbt->pbtdesthi, pbt->pbtdestlo, 			      (dx=pbt->pbtdestbit), (w=pbt->pbtwidth), h, y,			      pbt->pbtbackward)  || 		     cursorin(pbt->pbtsourcehi, pbt->pbtsourcelo,  		     	      (sx=pbt->pbtsourcebit), w, h, y, pbt->pbtbackward); 	/*	 *pix_op = pix_operation( (unsigned short)pbt->pbtsourcetype,	 *			(unsigned short)pbt->pbtoperation );	 */	 pix_op = PixOperation( (unsigned short)pbt->pbtsourcetype,E 5				(unsigned short)pbt->pbtoperation );	if( displayflg )D 5		hidecursor();E 5I 5		HideCursor;E 5		D 7	if( pbt->pbtdisjointitems && pbt->pbtbackward ){E 7I 7D 9	if((pbt->pbtdestbpl % 8 == 0) && (pbt->pbtsourcebpl % 8 == 0)){E 9I 9	if((pbt->pbtdestbpl % 8 == 0) && (pbt->pbtsourcebpl % 8 == 0) &&	   (pbt->pbtwidth * pbt->pbtheight < 32768)){E 9	    if( pbt->pbtdisjointitems && pbt->pbtbackward ){E 7		distance = abs(srcaddr - destaddr) / ((destbpl + 15) >> 4);		SrcPixRect->pr_height += distance;		if(pr_rop( SrcPixRect, pbt->pbtdestbit, distance,			   pbt->pbtwidth, h, pix_op, 			   SrcPixRect, pbt->pbtsourcebit, 0) != 0)			error("pilotbitblt: pr_rop failed\n");D 7	}	else{	E 7I 7	    }	    else{	E 7		if(pr_rop( DestPixRect, pbt->pbtdestbit, 0, 			   pbt->pbtwidth, h, pix_op, 			   SrcPixRect, pbt->pbtsourcebit, 0) != 0)			error("pilotbitblt: pr_rop failed\n");I 7	    }E 7	}I 7	else	    bitblt_bpl1(srcaddr, pbt->pbtsourcebit, 0, sourcebpl,				destaddr, pbt->pbtdestbit, 0, destbpl,				pbt->pbtwidth, h, pix_op);E 7			if( displayflg )D 5		showcursor();E 5I 5		ShowCursor;E 5D 8}E 8I 8     }E 8#define TEXTURE_WIDTH	16bitblt_texture( pbt )D 10TEXTUREBBT *pbt;E 10I 10register TEXTUREBBT *pbt;E 10{	short *srcaddr, *destaddr;D 5	short  x, h, textureheight, w, xoffset, yoffset, destright, displayflg;E 5I 5	short  x, h, y, textureheight, w, xoffset, yoffset, destright, displayflg;	int	dx, sx;E 5	u_short pix_op;	srcaddr = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,						     pbt->pbtsourcelo));	destaddr = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, 						      pbt->pbtdestlo ));		SrcPixRect->pr_width = TEXTURE_WIDTH;	SrcPixRect->pr_height = textureheight = pbt->pbtgrayheightlessone + 1;	((mpr_d(SrcPixRect))->md_image) = srcaddr - pbt->pbtgrayoffset;	mpr_mdlinebytes(SrcPixRect) = TEXTURE_WIDTH >> 3;		/* texture rasterwidth is always 2bytes */	DestPixRect->pr_width = destright = pbt->pbtdestbit + pbt->pbtwidth;	DestPixRect->pr_height = h = pbt->pbtheight;	(mpr_d(DestPixRect))->md_image = destaddr;		mpr_mdlinebytes(DestPixRect)	 = abs( (pbt->pbtdestbpl + 7 ) >> 3 );	/* copy bitmap from SRCPixRect to TexturePixRect */	TexturePixRect->pr_height = textureheight;	pr_rop( TexturePixRect, 0, 0, TEXTURE_WIDTH, 		textureheight - pbt->pbtgrayoffset, PIX_SRC, 	 	SrcPixRect, 0, pbt->pbtgrayoffset);	pr_rop( TexturePixRect, 0, textureheight - pbt->pbtgrayoffset,		TEXTURE_WIDTH, pbt->pbtgrayoffset,		PIX_SRC, SrcPixRect, 0, 0);D 5	pix_op = pix_operation( (unsigned short)pbt->pbtsourcetype,E 5I 5	/*	 * pix_op = pix_operation( (unsigned short)pbt->pbtsourcetype,	 * 			(unsigned short)pbt->pbtoperation );	 */	pix_op = PixOperation( (unsigned short)pbt->pbtsourcetype,E 5				(unsigned short)pbt->pbtoperation );	/* if displayflg != 0 then source or destination is DisplayBitMap */D 5	displayflg = (pbt->pbtsourcehi == DISPALY_HI) ||E 5I 5/*	displayflg = (pbt->pbtsourcehi == DISPALY_HI) ||E 5D 3		     (pbt->pbtdesthi == DISPALY_HI);E 3I 3		     (pbt->pbtdesthi == DISPALY_HI) || 		     (pbt->pbtdesthi == DISPALY_HI+1) || 		     (pbt->pbtsourcehi == DISPALY_HI+1);I 5*/		      	displayflg = cursorin(pbt->pbtdesthi, pbt->pbtdestlo, 			      (dx=pbt->pbtdestbit), (w=pbt->pbtwidth), h, y,				pbt->pbtbackward)  || 		     cursorin(pbt->pbtsourcehi, pbt->pbtsourcelo,  		     	      (sx=pbt->pbtsourcebit), w, h, y, pbt->pbtbackward); E 5E 3	if( displayflg )D 5		hidecursor();E 5I 5		HideCursor;E 5	 D 5	 pr_replrop( DestPixRect, pbt->pbtdestbit, 0, 	 	     pbt->pbtwidth, pbt->pbtheight, pix_op,	 	     TexturePixRect, pbt->pbtsourcebit, 0); /* Dec 28 */E 5I 5/****	 pr_replrop( DestPixRect, dx, 0, w, h, pix_op,	 	     TexturePixRect, pbt->pbtsourcebit, 0); **************************************************************//* Dec 28 */E 5I 5	 pr_replrop( DestPixRect, dx, 0, w, h, pix_op,	 	     SrcPixRect, pbt->pbtsourcebit, pbt->pbtgrayoffset); /* Dec 28 */E 5	if( displayflg )D 5		  showcursor();E 5I 5		  ShowCursor;E 5	 }D 5E 5I 5/*------------------------------------------------------------------- *	this function translate to macro PixOperation *	comment out	by osamuE 5#define PBT_REPLACE 	0#define PBT_ERASE   	1#define PBT_PAINT	2#define PBT_INVERT  	3unsigned short pix_operation( sourcetype, operation )unsigned short sourcetype;unsigned short operation;{unsigned short pixsource, pixop;	if( sourcetype == PBT_ERASE )		pixsource = PIX_NOT( PIX_SRC );	else		pixsource =  PIX_SRC;			switch( operation ){		case PBT_PAINT:			pixop = pixsource | PIX_DST;			break;		case PBT_REPLACE:			pixop = pixsource;			break;		case PBT_ERASE:			pixop = pixsource & PIX_DST ;			break;		case PBT_INVERT:			pixop = pixsource ^ PIX_DST ; 			break;		default: 			break;		}		return( pixop );}I 5--------comment out---------------------------------------------*/I 8#endif C_ONLY/*****************************************************************************//**		End of OP_pilotbitblt and its subfunctions                  **//*****************************************************************************/E 8E 11E 5hidecursor(){I 5D 10/*	DisplayLockArea.wl_rect.r_left = min( MOUSEXL, 0);	DisplayLockArea.wl_rect.r_top = min( MOUSEYH, 0);	DisplayLockArea.wl_rect.r_width = 2 * XDELTA;	DisplayLockArea.wl_rect.r_height = 2 * YDELTA;*/E 10E 5	ioctl( LispWindowFd, WINLOCKSCREEN, &DisplayLockArea);}showcursor(){	ioctl( LispWindowFd, WINUNLOCKSCREEN, &DisplayLockArea);}D 11/*cursor_pos( x, y )short x, y;{	win_setmouseposition(LispWindowFd, x, y);}*/E 11I 4E 15D 11E 11I 8/*****************************************************************************/D 28/*****************************************************************************/E 28/**									    **//**				N_OP_pilotbitblt			    **//**									    **//**	  The Native-code compatible version of the opcode for bitblt.	    **//**									    **//**									    **//*****************************************************************************/D 28/*****************************************************************************/E 28E 8D 8/* **************************************************************** */E 8D 16LispPTR N_OP_pilotbitblt(pilot_bt_tbl, tos, error_addr)E 16I 16LispPTR N_OP_pilotbitblt(pilot_bt_tbl, tos)E 16D 8	LispPTR pilot_bt_tbl;	int tos;	int *error_addr;{E 8I 8D 28     LispPTR pilot_bt_tbl;     int tos;D 16     int *error_addr;E 16     {E 8D 25	register PILOTBBT  *pbt;D 14#define tpbt ((TEXTUREBBT *) pbt)	register short 	*srcaddr, *destaddr;E 14I 14	register DLword 	*srcbase, *dstbase;E 25I 25	PILOTBBT  *pbt;	DLword 	*srcbase, *dstbase;E 25E 14D 15	int displayflg;D 14	u_short pix_op;D 5E 5I 5	int	sx, dx, w, h, y;E 14I 14	int	sx, dx, w, h, y, srcbpl, dstbpl, backwardflg;E 14	E 15I 15	int	displayflg;	int	sx, dx, w, h, srcbpl, dstbpl, backwardflg;	int	src_comp, op, gray, num_gray, curr_gray_line;E 28I 28  LispPTR pilot_bt_tbl;  int tos;  {    PILOTBBT  *pbt;    DLword 	*srcbase, *dstbase;    int	displayflg;    int	sx, dx, w, h, srcbpl, dstbpl, backwardflg;    int	src_comp, op, gray, num_gray, curr_gray_line;E 28I 22#ifdef INIT	/* for init, we have to initialize the pointers at the	   first call to pilotbitblt or we die.  If we do it 	   earlier we die also.  We set a new flag so we don't	   do it more than once which is a lose also. 	   I put this in an ifdef so there won't be any extra	   code when making a regular LDE.  */	D 28	if (!kbd_for_makeinit){		init_keyboard(0);		kbd_for_makeinit = 1;	};E 28I 28    if (!kbd_for_makeinit)      {	init_keyboard(0);	kbd_for_makeinit = 1;      };E 28#endifE 22E 15E 5D 11#ifdef TRACED 8        printPC();        printf("TRACE: N_OP_pilotbitblt()\n");E 8I 8	   printPC();	   printf("TRACE: N_OP_pilotbitblt()\n");E 8#endifE 11D 28	pbt = (PILOTBBT *)Addr68k_from_LADDR(pilot_bt_tbl);E 28I 28    pbt = (PILOTBBT *)Addr68k_from_LADDR(pilot_bt_tbl);E 28I 15D 28	w  = pbt->pbtwidth;	h  = pbt->pbtheight;	  if ((h <= 0) || (w <= 0)) return(pilot_bt_tbl);		dx = pbt->pbtdestbit;	sx = pbt->pbtsourcebit;	backwardflg = pbt->pbtbackward;E 15	/* if displayflg != 0 then source or destination is DisplayBitMap */D 18E 18I 18	ScreenLocked=T;E 28I 28    w  = pbt->pbtwidth;    h  = pbt->pbtheight;    if ((h <= 0) || (w <= 0)) return(pilot_bt_tbl);	    dx = pbt->pbtdestbit;    sx = pbt->pbtsourcebit;    backwardflg = pbt->pbtbackward;    /* if displayflg != 0 then source or destination is DisplayBitMap */    ScreenLocked=T;E 28I 27#ifdef SUNDISPLAYE 27E 18D 5	displayflg = (pbt->pbtsourcehi == DISPALY_HI) ||E 5I 5D 8/*	displayflg = (pbt->pbtsourcehi == DISPALY_HI) ||E 5		     (pbt->pbtdesthi == DISPALY_HI) || 		     (pbt->pbtdesthi == DISPALY_HI+1) || 		     (pbt->pbtsourcehi == DISPALY_HI+1);I 5*/E 8I 8D 12	/*	displayflg = (pbt->pbtsourcehi == DISPALY_HI) ||	*		     (pbt->pbtdesthi == DISPALY_HI) || 	*		     (pbt->pbtdesthi == DISPALY_HI+1) || 	*		     (pbt->pbtsourcehi == DISPALY_HI+1);	*/E 12E 8D 15 	displayflg = cursorin(pbt->pbtdesthi, pbt->pbtdestlo, 			      (dx=pbt->pbtdestbit),  			      (w=pbt->pbtwidth), (h=pbt->pbtheight), y,			      pbt->pbtbackward)  || 		     cursorin(pbt->pbtsourcehi, pbt->pbtsourcelo,  		     	      (sx=pbt->pbtsourcebit), w, h, y, 			      pbt->pbtbackward); 		     E 15I 15D 28	displayflg = cursorin(pbt->pbtdesthi, (pbt->pbtdestlo + (dx >> 4)),E 28I 28    displayflg = cursorin(pbt->pbtdesthi, (pbt->pbtdestlo + (dx >> 4)),E 28D 19 			      w, h, backwardflg)  ||E 19I 19D 20 			     dx, w, h, backwardflg)  ||E 20I 20 			      w, h, backwardflg)  ||E 20E 19D 28 		     cursorin(pbt->pbtsourcehi, (pbt->pbtsourcelo + (sx >> 4)), E 28I 28 	         cursorin(pbt->pbtsourcehi, (pbt->pbtsourcelo + (sx >> 4)), E 28D 19 		     	      w, h, backwardflg); E 19I 19D 20 		     	     sx, w, h, backwardflg); E 20I 20 		     	      w, h, backwardflg); I 27#endif SUNDISPLAYE 27E 20E 19E 15E 5D 14	srcaddr = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,E 14I 14D 28	srcbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,E 28I 28    srcbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,E 28E 14D 15						     pbt->pbtsourcelo));E 15I 15					     pbt->pbtsourcelo));E 15D 14	destaddr = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, E 14I 14D 28	dstbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, E 28I 28    dstbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, E 28E 14D 15						      pbt->pbtdestlo ));E 15I 15					      pbt->pbtdestlo ));E 15D 5	if( displayflg ) hidecursor();E 5I 5D 15	if( displayflg ) HideCursor;E 5E 15D 14	/* ********************* TEXTURE BLT ************************** */E 14I 14D 17	srcbpl = pbt->pbtsourcebpl;	dstbpl = pbt->pbtdestbpl;E 17I 17D 28	srcbpl   = pbt->pbtsourcebpl;	dstbpl   = pbt->pbtdestbpl;E 17D 15	backwardflg = pbt->pbtbackward;E 15I 15	src_comp = pbt->pbtsourcetype;D 17	op = pbt->pbtoperation;	gray = pbt->pbtusegray;	num_gray = ((TEXTUREBBT *)pbt)->pbtgrayheightlessone + 1;E 17I 17	op       = pbt->pbtoperation;	gray     = pbt->pbtusegray;	num_gray       = ((TEXTUREBBT *)pbt)->pbtgrayheightlessone + 1;E 17	curr_gray_line = ((TEXTUREBBT *)pbt)->pbtgrayoffset;E 28I 28    srcbpl   = pbt->pbtsourcebpl;    dstbpl   = pbt->pbtdestbpl;    src_comp = pbt->pbtsourcetype;    op       = pbt->pbtoperation;    gray     = pbt->pbtusegray;    num_gray       = ((TEXTUREBBT *)pbt)->pbtgrayheightlessone + 1;    curr_gray_line = ((TEXTUREBBT *)pbt)->pbtgrayoffset;E 28E 15E 14I 27#ifdef SUNDISPLAYE 27D 14	if( pbt->pbtusegray )D 8{	register int textureheight, destright, h;E 8I 8	   {	register int textureheight, destright, h;#define TEXTURE_WIDTH	16I 12		if((pbt->pbtdestbpl & 7) || (pbt->pbtdestbpl <= 0) ||		   (pbt->pbtwidth * pbt->pbtheight > 32767)){			bitblt_bpl1(pbt, srcaddr, pbt->pbtsourcebit, pbt->pbtsourcebpl,				    destaddr, pbt->pbtdestbit, pbt->pbtdestbpl,				    pbt->pbtwidth, pbt->pbtheight,				    PixOperation( (unsigned short)pbt->pbtsourcetype,						  (unsigned short)pbt->pbtoperation ),				    pbt->pbtbackward);			return;		}E 12		SrcPixRect->pr_width = TEXTURE_WIDTH;		SrcPixRect->pr_height = textureheight				      = tpbt->pbtgrayheightlessone + 1;		((mpr_d(SrcPixRect))->md_image) = srcaddr - tpbt->pbtgrayoffset;		mpr_mdlinebytes(SrcPixRect) = TEXTURE_WIDTH >> 3;	E 14I 14D 15{	/* NEW BITBLT CODE */variablessome_initwhile (num_lines_remaining-- > 0){ /* begin line loop */  if (gray)  {    do_src_gray_setup    do_gray_transfer  }  if (fwd)  {    F_do_src_setup    F_do_transfer  }  {    B_do_src_setup    B_do_transfer  }do_fpt:  {    do_partial_transfer    goto next_line;  }next_line:  if (gray)  {    do_gray_advance    continue;  }  if (fwd)  {    F_do_advance    continue;  }  {    B_do_advance    continue;  }} /* end line loop */E 15I 15D 28	if( displayflg ) HideCursor;E 28I 28    if( displayflg ) HideCursor;E 28I 27#endif SUNDISPLAYE 27E 15E 14E 8D 8	SrcPixRect->pr_width = TEXTURE_WIDTH;	SrcPixRect->pr_height = textureheight = tpbt->pbtgrayheightlessone + 1;	((mpr_d(SrcPixRect))->md_image) = srcaddr - tpbt->pbtgrayoffset;	mpr_mdlinebytes(SrcPixRect) = TEXTURE_WIDTH >> 3;	E 8I 8D 14		/* texture rasterwidth is always 2bytes */E 14I 14D 15}E 15I 15D 28	new_bitblt_codeE 28I 28    new_bitblt_codeE 28I 27#ifdef SUNDISPLAYE 27I 24#ifdef DISPLAYBUFFERI 30#ifdef COLOR    if( MonoOrColor == MONO_SCREEN )#endif COLORE 30D 28	if (in_display_segment(dstbase))	  flush_display_lineregion(dx, dstbase, w, h);E 28I 28    if (in_display_segment(dstbase))	flush_display_lineregion(dx, dstbase, w, h);E 28#endifE 24E 15E 14E 8D 27E 27D 8	/* texture rasterwidth is always 2bytes */	DestPixRect->pr_width = destright = tpbt->pbtdestbit + tpbt->pbtwidth;	DestPixRect->pr_height = h = tpbt->pbtheight;	(mpr_d(DestPixRect))->md_image = destaddr;E 8I 8D 14		DestPixRect->pr_width = destright				      = tpbt->pbtdestbit + tpbt->pbtwidth;		DestPixRect->pr_height = h = tpbt->pbtheight;		(mpr_d(DestPixRect))->md_image = destaddr;E 8	D 8	mpr_mdlinebytes(DestPixRect) = abs( (pbt->pbtdestbpl + 7 ) >> 3 );E 8I 8		mpr_mdlinebytes(DestPixRect) = abs((pbt->pbtdestbpl+7) >> 3);E 8D 8	/* copy bitmap from SRCPixRect to TexturePixRect */E 8I 8		/* copy bitmap from SRCPixRect to TexturePixRect */E 8D 8	TexturePixRect->pr_height = textureheight;	pr_rop( TexturePixRect, 0, 0, TEXTURE_WIDTH, 		textureheight - tpbt->pbtgrayoffset, PIX_SRC, 	 	SrcPixRect, 0, tpbt->pbtgrayoffset);	pr_rop( TexturePixRect, 0, textureheight - tpbt->pbtgrayoffset,		TEXTURE_WIDTH, tpbt->pbtgrayoffset,		PIX_SRC, SrcPixRect, 0, 0);E 8I 8		TexturePixRect->pr_height = textureheight;		pr_rop( TexturePixRect, 0, 0, TEXTURE_WIDTH, 			textureheight - tpbt->pbtgrayoffset, PIX_SRC, 	 		SrcPixRect, 0, tpbt->pbtgrayoffset);		pr_rop( TexturePixRect, 0, textureheight - tpbt->pbtgrayoffset,			TEXTURE_WIDTH, tpbt->pbtgrayoffset,			PIX_SRC, SrcPixRect, 0, 0);E 8I 8D 12		/*		 * pix_op = pix_operation( (unsigned short)tpbt->pbtsourcetype,		 *			(unsigned short)tpbt->pbtoperation );		 */E 12I 12E 12		pix_op = PixOperation( (unsigned short)pbt->pbtsourcetype,				       (unsigned short)pbt->pbtoperation );E 8D 5	pix_op = pix_operation( (unsigned short)tpbt->pbtsourcetype,				(unsigned short)tpbt->pbtoperation );E 5I 5D 8	/*	 * pix_op = pix_operation( (unsigned short)tpbt->pbtsourcetype,	 *			(unsigned short)tpbt->pbtoperation );	 */	pix_op = PixOperation( (unsigned short)pbt->pbtsourcetype,				(unsigned short)pbt->pbtoperation );E 5I 5/**********E 5	pr_replrop( DestPixRect, tpbt->pbtdestbit, 0, 	 	     tpbt->pbtwidth, tpbt->pbtheight, pix_op,D 5	 	     TexturePixRect, tpbt->pbtsourcebit, 0); /* Dec 28 */E 5I 5	 	     TexturePixRect, tpbt->pbtsourcebit, 0);**********************************************************/ /* Dec 28 */	 pr_replrop( DestPixRect, dx, 0, w, h, pix_op,	 	     SrcPixRect, tpbt->pbtsourcebit, tpbt->pbtgrayoffset); /* Dec 28 */E 5}	 E 8I 8D 12		/**********		* pr_replrop( DestPixRect, tpbt->pbtdestbit, 0, 	 	*	     tpbt->pbtwidth, tpbt->pbtheight, pix_op,	 	*	     TexturePixRect, tpbt->pbtsourcebit, 0);		***********/ /* Dec 28 */E 12I 12E 12		 pr_replrop( DestPixRect, dx, 0, w, h, pix_op,	 	  	   SrcPixRect, tpbt->pbtsourcebit,			   tpbt->pbtgrayoffset); /* Dec 28 */	     }	 I 11#ifdef sparc        else if ((pbt->pbtdisjoint != 0)                && (pbt->pbtsourcebpl==w)                 && (pbt->pbtdestbpl==w) 		&& (pbt->pbtsourcetype==0)		&& (pbt->pbtoperation==REPLACE)                && (((w*(pbt->pbtheight))&7) == 0)                && ((dx&7)==0)                && ((sx&7)==0))  {        memcpy( ((char *)destaddr)+(dx>>3),                 ((char *)srcaddr )+(sx>>3),                (w>>3)*(pbt->pbtheight));        }#endifE 11E 8	else	/* ********************* NORMAL BLT ************************** */D 8{	register int sourcebpl, destbpl, h;E 8I 8	     {	register int sourcebpl, destbpl, h;E 8D 8	if( pbt->pbtbackward ){		register int x;		x = ( pbt->pbtdestbpl/BITSPER_DLWORD ) * (pbt->pbtheight -1);		srcaddr += x;		destaddr += x;	}E 8I 8D 12		if( pbt->pbtbackward )E 12I 12	     if((pbt->pbtdestbpl & 7) || (pbt->pbtsourcebpl & 7) ||	        (pbt->pbtdestbpl == 0) || (pbt->pbtsourcebpl == 0) ||D 13	        (pbt->pbtwidth * pbt->pbtheight > 32767)){E 13I 13	        (pbt->pbtwidth * pbt->pbtheight > 32767) || (pbt->pbtbackward)){E 13		     bitblt_bpl1(pbt,srcaddr, pbt->pbtsourcebit, pbt->pbtsourcebpl,			    destaddr, pbt->pbtdestbit, pbt->pbtdestbpl,			    pbt->pbtwidth, pbt->pbtheight,			    PixOperation( (unsigned short)pbt->pbtsourcetype,					  (unsigned short)pbt->pbtoperation ),			    pbt->pbtbackward);		     return;	     }	     if( pbt->pbtbackward )E 12		  {		    register int x;		    x = (pbt->pbtdestbpl/BITSPER_DLWORD) * (pbt->pbtheight-1);		    srcaddr += x;		    destaddr += x;		  }E 8	D 8	h = pbt->pbtheight;	SrcPixRect->pr_width = sourcebpl = abs( pbt->pbtsourcebpl ); 	SrcPixRect->pr_height = h;	(mpr_d(SrcPixRect))->md_image = srcaddr;	mpr_mdlinebytes(SrcPixRect) = ( SrcPixRect->pr_width +7) >>3;E 8I 8		h = pbt->pbtheight;		SrcPixRect->pr_width = sourcebpl = abs( pbt->pbtsourcebpl ); 		SrcPixRect->pr_height = h;		(mpr_d(SrcPixRect))->md_image = srcaddr;		mpr_mdlinebytes(SrcPixRect) = ( SrcPixRect->pr_width +7) >>3;E 8	 D 8	DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );	DestPixRect->pr_height = h;E 8I 8		DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );		DestPixRect->pr_height = h;E 8	        mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;D 8	if(destbpl <= pbt->pbtdestbit){	/* Special case */		if( destbpl % 8 == 0 ){			 (char *)(mpr_d(DestPixRect))->md_image = E 8I 8D 9		if(destbpl <= pbt->pbtdestbit)E 9I 9		if((destbpl <= pbt->pbtdestbit) && 		   (pbt->pbtwidth * pbt->pbtheight < 32768))E 9		  {	/* Special case */		    if( destbpl % 8 == 0 )		      {			(char *)(mpr_d(DestPixRect))->md_image = E 8				 (char *)destaddr + ( destbpl >> 3 );			 pbt->pbtdestbit = 0;D 8		}		else{E 8I 8		      }		    else		      {E 8			(mpr_d(DestPixRect))->md_image = destaddr;D 8		}	}	else{	/* Normal Case */		(mpr_d(DestPixRect))->md_image = destaddr;	}E 8I 8		      }		  }		else		  {	/* Normal Case */		    (mpr_d(DestPixRect))->md_image = destaddr;		  }E 8	D 8	if(sourcebpl <= pbt->pbtsourcebit){	/* Special case */		if( sourcebpl % 8 == 0 ){			 (char *)(mpr_d(SrcPixRect))->md_image = 				 (char *)srcaddr + ( sourcebpl >> 3 );			 pbt->pbtsourcebit = 0;		}		else{E 8I 8D 9		if(sourcebpl <= pbt->pbtsourcebit){	/* Special case */E 9I 9		if((sourcebpl <= pbt->pbtsourcebit) &&		   (pbt->pbtwidth * pbt->pbtheight < 32768)){ /* Special case */E 9			if( sourcebpl % 8 == 0 ){				 (char *)(mpr_d(SrcPixRect))->md_image = 					 (char *)srcaddr + ( sourcebpl >> 3 );				 pbt->pbtsourcebit = 0;			}			else{				(mpr_d(SrcPixRect))->md_image = srcaddr;			}D 12	}E 12I 12		}E 12		else{	/* Normal Case */E 8			(mpr_d(SrcPixRect))->md_image = srcaddr;		}D 8	}	else{	/* Normal Case */		(mpr_d(SrcPixRect))->md_image = srcaddr;	}E 8D 5	pix_op = pix_operation( (unsigned short)pbt->pbtsourcetype,E 5I 5D 8	/*	 * pix_op = pix_operation( (unsigned short)pbt->pbtsourcetype,	 *			(unsigned short)pbt->pbtoperation );	 */	pix_op = PixOperation( (unsigned short)pbt->pbtsourcetype,E 5				(unsigned short)pbt->pbtoperation );E 8I 8D 12		/*		 * pix_op = pix_operation( (unsigned short)pbt->pbtsourcetype,		 *			(unsigned short)pbt->pbtoperation );		 */E 12		pix_op = PixOperation( (unsigned short)pbt->pbtsourcetype,					(unsigned short)pbt->pbtoperation );E 8D 7	if( pbt->pbtdisjointitems && pbt->pbtbackward ){E 7I 7D 8	if((pbt->pbtdestbpl % 8 == 0) && (pbt->pbtsourcebpl % 8 == 0)){	    if( pbt->pbtdisjointitems && pbt->pbtbackward ){E 7		register int distance;		distance = abs(srcaddr - destaddr) / ((destbpl + 15) >> 4);		SrcPixRect->pr_height += distance;		if(pr_rop( SrcPixRect, pbt->pbtdestbit, distance,			   pbt->pbtwidth, h, pix_op, 			   SrcPixRect, pbt->pbtsourcebit, 0) != 0)			/* error("pilotbitblt: pr_rop failed\n"); */			ERROR_EXIT(error_addr);D 7	}	else{			if(pr_rop( DestPixRect, pbt->pbtdestbit, 0, E 7I 7	    }	    else{		    if(pr_rop( DestPixRect, pbt->pbtdestbit, 0, E 7			   pbt->pbtwidth, h, pix_op, 			   SrcPixRect, pbt->pbtsourcebit, 0) != 0)			/* error("pilotbitblt: pr_rop failed\n"); */			ERROR_EXIT(error_addr);D 7E 7I 7	    }E 7	}I 7	else	    bitblt_bpl1(srcaddr, pbt->pbtsourcebit, 0, sourcebpl,				destaddr, pbt->pbtdestbit, 0, destbpl,				pbt->pbtwidth, h, pix_op);E 8I 8D 9		if((pbt->pbtdestbpl % 8 == 0) && (pbt->pbtsourcebpl % 8 == 0))E 9I 9D 12		if((pbt->pbtdestbpl % 8 == 0) && (pbt->pbtsourcebpl % 8 == 0) &&	  	   (pbt->pbtwidth * pbt->pbtheight < 32768))E 9		  { /* Source & Dest are both multiples of a byte wide. */E 12		    if( pbt->pbtdisjointitems && pbt->pbtbackward )		      {			register int distance;			distance = abs(srcaddr-destaddr)/((destbpl+15) >> 4);			SrcPixRect->pr_height += distance;			if(pr_rop( SrcPixRect, pbt->pbtdestbit, distance,				   pbt->pbtwidth, h, pix_op, 				   SrcPixRect, pbt->pbtsourcebit, 0) != 0)				/* error("pilotbitblt: pr_rop failed\n"); */				ERROR_EXIT(error_addr);		      }		    else		      {			if(pr_rop( DestPixRect, pbt->pbtdestbit, 0, 				   pbt->pbtwidth, h, pix_op, 				   SrcPixRect, pbt->pbtsourcebit, 0) != 0)				/* error("pilotbitblt: pr_rop failed\n"); */				ERROR_EXIT(error_addr);		      }D 12		  }		else bitblt_bpl1(srcaddr, pbt->pbtsourcebit, 0, sourcebpl,				 destaddr, pbt->pbtdestbit, 0, destbpl,				 pbt->pbtwidth, h, pix_op);E 8	E 12E 7		D 8}					/* normal BLT */E 8I 8	    }					/* normal BLT */E 8E 14D 5	if( displayflg) showcursor();E 5I 5D 28	if( displayflg) ShowCursor;E 28I 28    if( displayflg) ShowCursor;E 28I 27#endif SUNDISPLAY#ifdef XWINDOWD 28	flush_display_lineregion(dx, dstbase, w, h);E 28I 28D 32    flush_display_lineregion(dx, dstbase, w, h);E 32I 32    XLOCK;	flush_display_lineregion(dx, dstbase, w, h);	XUNLOCK;E 32E 28#endif XWINDOWE 27I 18D 28	ScreenLocked=NIL;E 28I 28    ScreenLocked=NIL;E 28E 18E 5I 5D 14#ifdef WINDOWD 8	pw_rop( Lisp_pw, 0, 0, DisplayWidth, DisplayHeight, PIX_SRC,		ScreenBitMap, 0, 0);E 8I 8	   pw_rop( Lisp_pw, 0, 0, DisplayWidth, DisplayHeight, PIX_SRC,		   ScreenBitMap, 0, 0);E 8#endifE 14E 5D 28	return(pilot_bt_tbl);E 28I 28    return(pilot_bt_tbl);E 28D 8} /* end of N_OP_pilotbitblt */E 8I 8D 28     } /* end of N_OP_pilotbitblt */E 28I 28  } /* end of N_OP_pilotbitblt */E 28E 8I 5I 28/************************************************************************//*									*//*				c u r s o r i n				*//*									*/D 32/*									*/E 32I 32/*	Return T if cursor is over the screen we just painted.				*/E 32/*									*//************************************************************************/E 28I 21#ifndef COLOR/* for MONO only */E 21D 8int cursorin( addrhi, addrlo, x, w, h, y, backward)DLword	addrhi;		/* Lisp addr hi-word	*/DLword	addrlo;		/* Lisp addr lo-word	*/register int	x, w, h, y;{		if(addrhi == DISPALY_HI)		y = addrlo / DisplayRasterWidth;	else if(addrhi == DISPALY_HI+1)		y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth;	else 		return( NIL );E 8I 8D 15int cursorin  ( addrhi, addrlo, x, w, h, y, backward)E 15I 15D 17int cursorin  ( addrhi, addrlo, w, h, backward)E 17I 17D 19int cursorin (addrhi, addrlo, w, h, backward)E 19I 19D 20int cursorin (addrhi, addrlo,x, w, h, backward)E 20I 20int cursorin (addrhi, addrlo, w, h, backward)E 20E 19E 17E 15D 28     DLword	addrhi;		/* Lisp addr hi-word	*/     DLword	addrlo;		/* Lisp addr lo-word	*/D 15     register int	x, w, h, y;E 15I 15D 19     register int	w, h;E 19I 19D 20     register int	x, w, h;E 20I 20     register int	w, h;E 20E 19E 15     {E 28I 28  DLword	addrhi;		/* Lisp addr hi-word	*/  DLword	addrlo;		/* Lisp addr lo-word	*/  register int	w, h;  {E 28D 15	if (addrhi == DISPALY_HI)  y = addrlo / DisplayRasterWidth;E 15I 15D 19     register int	x, y;E 19I 19D 20     register int	 y;E 20I 20     register int	x, y;E 20E 19D 17	if (addrhi == DISPALY_HI)E 17I 17D 28	if (addrhi == DISPLAY_HI)E 17	{	  y = addrlo / DisplayRasterWidth;D 19	  x = (addrlo - y * DisplayRasterWidth) << 4;E 19I 19D 20	 /* x = (addrlo - y * DisplayRasterWidth) << 4;*/E 20I 20	  x = (addrlo - y * DisplayRasterWidth) << 4;E 20E 19	}E 15D 17	else if (addrhi == DISPALY_HI+1)E 17I 17	else if (addrhi == DISPLAY_HI+1)E 17I 15	{E 15	   y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth;I 15D 19	   x = ((addrlo + DLWORDSPER_SEGMENT) - y * DisplayRasterWidth) << 4;E 19I 19D 20	   /*x = ((addrlo + DLWORDSPER_SEGMENT) - y * DisplayRasterWidth) << 4;*/E 20I 20	   x = ((addrlo + DLWORDSPER_SEGMENT) - y * DisplayRasterWidth) << 4;E 20E 19	}E 15	else return( NIL );E 28I 28    if (addrhi == DISPLAY_HI)      {	y = addrlo / DisplayRasterWidth;	x = (addrlo - y * DisplayRasterWidth) << 4;      }    else if (addrhi == DISPLAY_HI+1)      {	y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth;	x = ((addrlo + DLWORDSPER_SEGMENT) - y * DisplayRasterWidth) << 4;      }    else return( NIL );E 28E 8D 8	if(backward)		y -= h;E 8I 8D 28	if(backward) y -= h;E 28I 28    if(backward) y -= h;E 28E 8		D 28	if((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))E 28I 28    if((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))E 28D 8		return( T );E 8I 8	   return( T );E 8D 28	else D 8		return( NIL );}E 8I 8	   return( NIL );     }E 28I 28    else return( NIL );  }E 28I 21#elseE 21E 8I 7D 30I 21#define DLWORD_PERLINE	(DisplayWidth/16)#define HARD_CURSORWIDTH 16#define HARD_CURSORHEIGHT 16#define COLOR_BITSPER_PIXEL 8#define MONO_SCREEN 0#define COLOR_SCREEN 1#define COLOR_MAX_Address (ColorDisplayRegion68k + 1152 * 900)E 30E 21D 12#define	BitAddr(x,y,bpl) \	((BITSPER_DLWORD-1) - (((x)+(y)*(bpl)) % BITSPER_DLWORD))E 12I 12D 14#define WAddr(WORD, OFFSET, INCR) \	((WORD) + (((OFFSET)+(INCR))>>4))#define BAddr( OFFSET, INCR) \	((((OFFSET)+(INCR))%16) < 0 ? (16 + (((OFFSET)+(INCR))%16)) \				: (((OFFSET)+(INCR))%16))E 12D 12#define	GetPixValue( base, x, y, bpl ) \D 9	(((*((base) + (((u_short)((x)+(y)*(bpl)))>>4))&(1<<BitAddr(x,y,bpl))) \E 9I 9	(((*(u_short *)((base) + (((x)+(y)*(bpl))>>4))&(1<<BitAddr(x,y,bpl))) \E 9		 >> BitAddr(x,y,bpl)) & 1)#define	PutPixValue(base, x, y, bpl, bitvalue ) \	((bitvalue) ? \D 9		(*((base) + (((u_short)((x)+(y)*(bpl)))>>4 )) |= \E 9I 9		(*(u_short *)((base) + (((x)+(y)*(bpl))>>4 )) |= \E 9				 (1 << BitAddr(x,y,bpl))) \D 9		: (*((base) + (((u_short)((x)+(y)*(bpl)))>>4 )) &= \E 9I 9		: (*(u_short *)((base) + (((x)+(y)*(bpl))>>4 )) &= \E 9				 ~(1 << BitAddr(x,y,bpl))))E 12I 12#define	GetPixValue( BASE, OFFSET, INCR ) \	!!((*WAddr(BASE, OFFSET, INCR))&(1<<(15-BAddr( OFFSET, INCR))))E 12D 12bitblt_bpl1(srcbase, sx, sy, srcbpl, dstbase, dx, dy, dstbpl, w, h, pixop ) E 12I 12#define	PutPixValue( BASE, OFFSET, INCR, VAL ) \	{ if(VAL) \	     (*WAddr(BASE,OFFSET,INCR) |=(1<<(15-BAddr( OFFSET, INCR)))); \	   else \	     (*WAddr(BASE,OFFSET,INCR) &= ~(1<<(15-BAddr( OFFSET, INCR)))); \	}bitblt_bpl1(pbt, srcbase, sx, srcbpl, dstbase, dx, dstbpl, w, h, pixop,backwordflg) register PILOTBBT  *pbt;E 12D 10DLword	*srcbase, *dstbase;E 10I 10register DLword	*srcbase, *dstbase;E 10D 12int	sx, sy, srcbpl, dx, dy, dstbpl, w, h, pixop;E 12I 12int	sx, srcbpl, dx, dstbpl, w, h, pixop, backwordflg;E 12{D 12	register int	sbit, dbit, x, y;E 12I 12	register int	srcbit, dstbit, sbit, dbit, x, y, i, j, line, delta,			grayflg, graywidth, graheight, graybump, lastgray;E 12D 9	for( x= 0; x < w; x++){	    for( y=0; y < h; y++){E 9I 9D 12	for( y=0; y < h; y++){/*				getchar();*/	    for( x= 0; x < w; x++){E 9		sbit = GetPixValue(srcbase, x+sx, y+sy, srcbpl);		dbit = GetPixValue(dstbase, x+dx, y+dy, dstbpl);D 9		switch(pixop){E 9I 9	/*		printf("sb: %x db: %x x: %d  y: %d  %t sbit: %d dbit:%d\n",				x,y,sbit,dbit); 	*/		switch(pixop){E 9		case (PIX_SRC):			PutPixValue(dstbase, x+dx, y+dy, dstbpl, (sbit));E 12I 12	delta = backwordflg ? -1 : 1;	line = backwordflg ? (h - 1) : 0;	if(grayflg = pbt->pbtusegray){		graywidth = ((((TEXTUREBBT *)pbt)->pbtgraywidthlessone + 1 )*16);		graheight = ((TEXTUREBBT *)pbt)->pbtgrayheightlessone + 1;		graybump  = -(graywidth * (graheight-1));		lastgray = backwordflg ? ((TEXTUREBBT *)pbt)->pbtgrayoffset :					(graheight - 1 - ((TEXTUREBBT *)pbt)->pbtgrayoffset);	}	srcbit = dstbit = 0;	for( j=0; j < h; j++, line += delta){	    for( i= 0,x = backwordflg ? (w - 1) : 0; i < w; i++, x += delta){		if(grayflg)		    sbit=GetPixValue( srcbase, srcbit, (x+sx)%abs(graywidth) );		else		    sbit = GetPixValue( srcbase, srcbit, sx+x );		dbit = GetPixValue( dstbase, dstbit, dx+x );	        switch(pixop){		    case (PIX_SRC):			dbit = sbit;E 12			break;D 12		case (PIX_SRC | PIX_DST):			PutPixValue(dstbase, x+dx, y+dy, dstbpl, (sbit | dbit));E 12I 12		    case (PIX_SRC | PIX_DST):			dbit = sbit | dbit;E 12			break;D 12		case (PIX_SRC & PIX_DST):			PutPixValue(dstbase, x+dx, y+dy, dstbpl, (sbit & dbit));E 12I 12		    case (PIX_SRC & PIX_DST):			dbit = sbit & dbit;E 12			break;D 12		case (PIX_SRC ^ PIX_DST):			PutPixValue(dstbase, x+dx, y+dy, dstbpl, (sbit ^ dbit));E 12I 12	     	    case (PIX_SRC ^ PIX_DST):			dbit = sbit ^ dbit;E 12			break;D 12		case (PIX_NOT(PIX_SRC)):D 9			PutPixValue(dstbase, x+dx, y+dy, dstbpl, (~sbit));E 9I 9			PutPixValue(dstbase, x+dx, y+dy, dstbpl, (!sbit));E 12I 12		    case (PIX_NOT(PIX_SRC)):			dbit = !sbit;E 12E 9			break;D 12		case (PIX_NOT(PIX_SRC) | PIX_DST):D 9			PutPixValue(dstbase, x+dx, y+dy, dstbpl, ((~sbit) | dbit));E 9I 9			PutPixValue(dstbase, x+dx, y+dy, dstbpl, ((!sbit) | dbit));E 12I 12		    case (PIX_NOT(PIX_SRC) | PIX_DST):			dbit = (!sbit) | dbit;E 12E 9			break;D 12		case (PIX_NOT(PIX_SRC) & PIX_DST):D 9			PutPixValue(dstbase, x+dx, y+dy, dstbpl, ((~sbit) & dbit));E 9I 9			PutPixValue(dstbase, x+dx, y+dy, dstbpl, ((!sbit) & dbit));E 12I 12		    case (PIX_NOT(PIX_SRC) & PIX_DST):			dbit = (!sbit) & dbit;E 12E 9			break;D 12		case (PIX_NOT(PIX_SRC) ^ PIX_DST):D 9			PutPixValue(dstbase, x+dx, y+dy, dstbpl, ((~sbit) ^ dbit));E 9I 9			PutPixValue(dstbase, x+dx, y+dy, dstbpl, ((!sbit) ^ dbit));E 12I 12		    case (PIX_NOT(PIX_SRC) ^ PIX_DST):			dbit = (!sbit) ^ dbit;E 12E 9			break;D 12		default:E 12I 12		    default:E 12I 9			error("bitbltbpl1: missing op");E 9D 12			PutPixValue(dstbase, x+dx, y+dy, dstbpl, (sbit));E 12I 12			dbit = sbit;E 12			break;D 12			}E 12I 12		    }		    PutPixValue(dstbase, dstbit, (dx+x), (dbit));E 12		}I 12	    if(grayflg)		srcbase = WAddr(srcbase, srcbit, (((line%graheight)==lastgray) ? 							graybump : graywidth) );	    else		srcbase = WAddr(srcbase, srcbit, srcbpl);	    if(grayflg)		srcbit = BAddr(srcbit, (((line%graheight)==lastgray) ? 							graybump : graywidth) );    	    else		srcbit  = BAddr(srcbit, srcbpl);	    dstbase = WAddr(dstbase, dstbit, dstbpl);	    dstbit  = BAddr(dstbit, dstbpl);E 12	}}E 14D 9E 9E 7I 21/* for COLOR & MONO */int cursorin (addrhi, addrlo, w, h, backward)     DLword	addrhi;		/* Lisp addr hi-word	*/     DLword	addrlo;		/* Lisp addr lo-word	*/     register int	w, h;     {     register int	x, y;     register DLword *base68k;    extern int MonoOrColor;    extern int DisplayWidth;    extern DLword *ColorDisplayRegion68k;E 21I 21 if(MonoOrColor == MONO_SCREEN) { /* On MONO screen */	if (addrhi == DISPLAY_HI)	{	  y = addrlo / DisplayRasterWidth;	  x = (addrlo - y * DisplayRasterWidth) << 4;	}	else if (addrhi == DISPLAY_HI+1)	{	   y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth;	   x = ((addrlo + DLWORDSPER_SEGMENT) - y * DisplayRasterWidth) << 4;	}	else return( NIL );E 21E 5I 21	if(backward) y -= h;			if((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))	   return( T );	else 	   return( NIL ); } else {        base68k=(DLword*)Addr68k_from_LADDR(addrhi << 16 | addrlo);        if ((ColorDisplayRegion68k<=base68k) &&		 (base68k <= COLOR_MAX_Address)){	     y =(base68k - ColorDisplayRegion68k) /DisplayWidth ;	     x = (int)(base68k - ColorDisplayRegion68k) -(y * DisplayWidth );	 	/* printf("cursorin: IN COLOR mx=%d my=%d x=%d y%d w=%d h=%d\n"		,*EmMouseX68K,*EmMouseY68K,x,y,w,h); */	}        else return( NIL );E 21I 21       if(backward) y -= h;E 21I 21       if((x < MOUSEXR)&&((x + (w >> 3)) > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))	      { /* printf("cursorin T\n"); */ return( T );}       else	      return( NIL ); } /* on COLOR screen */     }#endif COLORE 21E 4E 1