h08682s 00038/00006/00202d D 1.16 92/03/04 18:55:22 sybalsky 16 15c 386es 00001/00001/00207d D 1.15 91/09/27 04:32:38 sybalsky 15 14c ISC port change fixes 00005/00004/00203d D 1.14 91/05/02 19:10:30 sybalsky 14 13c Fix an ANSI prototype to work on Sun's compiler.es 00014/00006/00193d D 1.13 91/04/16 14:54:08 sybalsky 13 12c Retrofit foreign-OS changes from Savoir.es 00001/00001/00198d D 1.12 90/04/20 01:23:29 sybalsky 12 11c AIX:  shortening file names, bulk change.es 00013/00002/00186d D 1.11 90/03/15 22:02:23 sybalsky 11 10c es 00001/00001/00187d D 1.10 90/03/15 15:12:20 sybalsky 10 9c Set it up to use more 386i inline codees 00005/00002/00183d D 1.9 90/03/13 18:57:21 sybalsky 9 8c Some inline-code speedups made, so returned some things to functions from macros.es 00013/00010/00172d D 1.8 90/03/09 14:40:38 takeshi 8 7c light tunedes 00087/00000/00095d D 1.7 90/02/06 11:45:10 sybalsky 7 6c es 00005/00005/00090d D 1.6 89/03/30 20:30:40 sybalsky 6 5c fixed swapx, which swapped bytes instead of words.es 00001/00001/00094d D 1.5 89/03/23 12:54:41 sybalsky 5 4c more fixes to word-swapperes 00005/00007/00090d D 1.4 89/02/27 12:01:09 shih 4 3c lost sccs ides 00052/00000/00045d D 1.3 89/01/17 11:59:37 sybalsky 3 2c Added swapx defn, and word-swapping fns.es 00002/00002/00043d D 1.2 89/01/17 11:43:29 sybalsky 2 1c Adding 4-byte-wide swappinges 00045/00000/00000d D 1.1 88/12/09 21:46:55 sybalsky 1 0c date and time created 88/12/09 21:46:55 by sybalskyeuUf e 0tTI 1D 2/* This is G-file %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 2I 2D 4/* This is G-file @(#) byteswapfns.c Version 1.1 (12/9/88). copyright envos & Fuji Xerox  */static char *id = "@(#) byteswapfns.c	1.1 12/9/88		(envos & Fuji Xerox)";E 2/* This is G-file @(#) loadsysout.c Version 2.9 (11/8/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) byteswapfns..c	2.9 11/8/88";E 4I 4D 6/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 6I 6D 11/* @(#) byteswapfns.c Version 1.5 (3/23/89). copyright envos & Fuji Xerox  */static char *id = "@(#) byteswapfns.c	1.5 3/23/89		(envos & Fuji Xerox)";E 11I 11/* @(#) byteswapfns.c Version 1.5 (3/23/89). copyright Venue & Fuji Xerox  */static char *id = "@(#) byteswapfns.c	1.5 3/23/89		(Venue & Fuji Xerox)";I 16E 16/************************************************************************//*									*/D 16/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 16I 16/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 16/*									*/D 16/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 16I 16/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 16/*									*//************************************************************************/E 11E 6E 4/***************************************************************************//*                                                                         *//*                               byteswapfns.c                             *//*                                                                         *//*         Support functions for byte-swapped architecture machines        *//*                             (e.g., 80386's)                             *//*                                                                         *//***************************************************************************/#include <stdio.h>D 15#include <sys/file.h>E 15#include <sys/types.h>I 15#include <sys/file.h>E 15#include <sys/stat.h>#include <errno.h>D 12#include "machineconfig.h"E 12I 12#include "hdw_config.h"E 12#include "lispemul.h"#include "lispmap.h"I 7#include "lisptypes.h"I 16#include "stack.h"E 16E 7I 13D 16#ifdef AIXPS2E 16I 16#ifdef ISCE 16#include "inlinePS2.h"#elseE 13I 3/****************************************************************//*                                                              *//*                 Byte-swap a single 2-byte word               *//*       (Name used for general-purpose byte swaps, rather      *//*           than for fixing up byte-swapped machines)          *//*                                                              *//****************************************************************/D 6unsigned short swapx(word)   unsigned short word;E 6I 6unsigned int swapx(word)   unsigned int word;E 6D 13   {D 4      return( ((word>>8)&0xff)+((word&0xff)<<8) ); }; E 4I 4D 6      return( ((word>>8)&0xff)+((word&0xff)<<8) ); };E 6I 6      return( ((word>>16)&0xffff)+((word&0xffff)<<16) ); };E 13I 13 {      return( ((word>>16)&0xffff)+((word&0xffff)<<16) );  };E 13E 6E 4/****************************************************************//*                                                              *//*                 Byte-swap a single 2-byte word               *//*                                                              *//****************************************************************/E 3unsigned short byte_swap_word(word)D 13   unsigned short word;   {D 4      return( ((word>>8)&0xff)+((word&0xff)<<8) ); }; E 4I 4      return( ((word>>8)&0xff)+((word&0xff)<<8) ); };E 13I 13  unsigned short word;  {      return( ((word>>8)&0xff)+((word&0xff)<<8) );  };E 13E 4/****************************************************************//*                                                              */I 3/*                   Word-swap a 2-word integer                 *//*           Does NOT byte-swap the words themselves.           *//*                                                              *//****************************************************************/D 5unsigned short word_swap_longword(word)E 5I 5D 8unsigned int word_swap_longword(word)E 8I 8D 9/**unsigned int word_swap_longword(word)E 9I 9/***unsigned int word_swap_longword(word)E 9E 8E 5   unsigned int word;   {D 4      return( ((word>>16)&0xffff)+((word&0xffff)<<16) ); }; E 4I 4D 8      return( ((word>>16)&0xffff)+((word&0xffff)<<16) ); };E 8I 8D 9      return( ((word>>16)&0xffff)+((word&0xffff)<<16) ); };**/E 9I 9      return( ((word>>16)&0xffff)+((word&0xffff)<<16) ); }; ***/#ifndef I386E 9#define word_swap_longword(word) ( ((word>>16)&0xffff)+((word&0xffff)<<16) )I 9#endifE 9E 8E 4D 13E 13I 13#endif AIXPS2E 13/****************************************************************//*                                                              */E 3/*            Byte-swap a region wordcount words long           */I 3/*            This does NOT swap words in a long-word!          */E 3/*                                                              *//****************************************************************/byte_swap_page(page, wordcount)   unsigned short	*page;   {    int i;    for (i = 0; i < wordcount; i++)      {        *(page+i) = byte_swap_word(*(page+i));I 3      };    };I 14D 16#ifndef AIXPS2E 16I 16#ifndef GCC386E 16E 14/****************************************************************//*                                                              *//*     Byte- & word-swap a region wordcount long-words long     *//*                                                              *//****************************************************************/D 14word_swap_page(page, longwordcount)   unsigned short	*page;I 7D 8   int longwordcount;E 8I 8   register int longwordcount;E 14I 14void word_swap_page(page, longwordcount)  unsigned short *page;  int longwordcount;E 14E 8E 7   {D 8    int i;    unsigned int  *longpage;E 8I 8    register int i;    register unsigned int  *longpage;E 8    longpage = page;    for (i = 0; i < (longwordcount+longwordcount); i++)      {        *(page+i) = byte_swap_word(*(page+i));      };    for (i = 0; i < longwordcount; i++)      {        *(longpage+i) = word_swap_longword(*(longpage+i));E 3      };    };I 7D 14E 14I 14D 16#endif AIXPS2E 16I 16#endif GCC386E 16E 14/****************************************************************//*                                                              *//*    		 Bit-reverse all the words in a region	  	*//*                                                              *//****************************************************************/D 8    static unsigned char reversedbits[256] = E 8I 8     unsigned char reversedbits[256] = E 8      { /* table of bytes with their bits reversed */	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,	0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,	0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,	0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,	0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,	0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,	0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,	0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,	0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,	0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,	0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,	0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,	0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,	0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,	0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,	0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,	0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,      };D 8unsigned short reverse_bits(word)E 8I 8/*unsigned short reverse_bits(word)E 8  unsigned short word;  {    return ((reversedbits[(word>>8) & 0xFF] <<8) | reversedbits[word & 0xff]);  }I 8******/#define reverse_bits(word) ((reversedbits[((word)>>8) & 0xFF] <<8) | reversedbits[(word) & 0xff])E 8bit_reverse_region(top, width, height, rasterwidth)D 8  unsigned short *top;E 8I 8  register unsigned short *top;E 8  int width, height, rasterwidth;  {D 8    int i, j, wordwid = ((width+15)>>4);    unsigned short *word;E 8I 8D 10    register int i, j, wordwid = ((width+15)>>4);E 10I 10    register int i, j, wordwid = ((width+31)>>5)<<1;E 10    register unsigned short *word;E 8    for (i = 0; i < height; i++)      {	word = top;	for (j = 0; j < wordwid; j++)	  {	    GETWORD(word+j) = reverse_bits(GETWORD(word+j));	  }	word_swap_page((int)word&0xFFFFFFFE, (wordwid+1)>>1);	top += rasterwidth;      }  }E 7I 16/************************************************************************//*									*//*		b y t e _ s w a p _ c o d e _ b l o c k			*//*									*//*	Byte-swap the opcodes in a piece of compiled code.  This 	*//*	can be used to make the compiled bytes be in machine-natural	*//*	order, so we can avoid pointer arithmetic on the PC in the	*//*	inner loop.  The performance effect isn't yet known (2/92)	*//*									*//************************************************************************/unsigned int byte_swap_code_block (base)   unsigned int *base;  {    int startpc, len;    startpc = ((int)base) + ((struct fnhead *)base)->startpc;    len = code_block_size(base);    word_swap_page(startpc, (len+3)>>2);    return base;   } /* end of byte_swap_code_block */E 16E 1