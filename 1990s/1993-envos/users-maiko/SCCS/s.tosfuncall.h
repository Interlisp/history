h49391s 00011/00007/00728d D 1.15 92/03/04 18:52:53 sybalsky 15 14c 386es 00002/00002/00733d D 1.14 91/07/05 13:59:03 sybalsky 14 13c Fix 2 cases in OPFNX where symbol was fetched as DLword rather than AtomNo.es 00001/00001/00734d D 1.13 91/04/16 17:50:53 sybalsky 13 12c 3-byte-atom changes - find_symbol speedupes 00007/00006/00728d D 1.12 91/02/12 00:28:31 sybalsky 12 11c Fix EVAL to handle 3-byte atoms.es 00032/00007/00702d D 1.11 91/02/07 19:14:27 sybalsky 11 10c Make applyfn and eval deal with New-Atoms right.es 00136/00044/00573d D 1.10 91/01/24 11:13:07 sybalsky 10 9c 3-byte-atom changes (fix EVAL to handle new symbols)es 00006/00001/00611d D 1.9 90/12/07 20:35:27 sybalsky 9 8c Add OPTRACEing to ENVCALL, add optional stack-check at each fncall/returnes 00009/00009/00603d D 1.8 90/09/18 23:51:28 sybalsky 8 7c Retrofit changes from AIX, DEC3100, PS/2es 00020/00020/00592d D 1.7 90/08/30 10:33:57 sybalsky 7 6c AIX changeses 00000/00013/00612d D 1.6 90/07/26 11:34:52 sybalsky 6 5c Move big-atom opcode-size macros to lispemules 00050/00021/00575d D 1.5 90/07/22 11:37:59 sybalsky 5 4c change fnX opcodes to respect FNTRACEes 00005/00005/00591d D 1.4 90/07/09 16:01:04 sybalsky 4 3c Add 3-byte atom number fetching, under control of -DBIGATOMSes 00000/00001/00596d D 1.3 90/06/04 14:48:04 sybalsky 3 2c reformat, copyrightes 00013/00009/00584d D 1.2 90/04/19 21:52:16 sybalsky 2 1c AIX:  Shortened from tosfuncallmacro.hes 00593/00000/00000d D 1.1 90/04/17 17:33:01 sybalsky 1 0c date and time created 90/04/17 17:33:01 by sybalskyeuUf e 0tTI 1D 2/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 2I 2D 5/* @(#) tosfuncall.h Version 1.1 (4/17/90). copyright Venue & Fuji Xerox  */E 5I 5/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 5E 2D 3/* @(#) tosfuncall.h Version 2.21 (3/22/90). copyright Venue & Fuji Xerox  */E 3/***	tosfuncall.h	By Takeshi	3-Dec-87	name shortened 4/17/90 by jds, for posix/AIX compatibility.***/I 15E 15/************************************************************************//*									*/D 11/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 11I 11D 15/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd,		*/E 15I 15/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*//*	Manufactured in the United States of America.			*/E 15E 11/*									*/D 15/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 15I 15/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 15/*									*//************************************************************************/I 5D 6/************************************************************************//*	Define sizes of FN and FNX opcodes; depends on atom size	*//************************************************************************/E 5I 5#ifdef BIGATOMS#define FN_OPCODE_SIZE 4#define FNX_OPCODE_SIZE 5#else#define FN_OPCODE_SIZE 3#define FNX_OPCODE_SIZE 4#endif BIGATOMSE 6D 15E 15E 5/****************************************************************//******		 CURRENT Stack Overflow checks		 ********//****************************************************************/#define  FN_STACK_CHECK			\  if ((int)CSTKPTR > (Irq_Stk_Check=(Irq_Stk_End-STK_MIN(LOCFNCELL))))	\     goto check_interrupt;I 5E 5/****************************************************************//******			 LOCAL MACROS			 ********//****************************************************************/#ifdef NATIVETRAN#define	FN_CALL_NATIVE_CHECK(fncell, args, extra_code)			\{									\  if (fncell->native)							\	{								\	 extra_code;							\	 FuncObj = fncell;						\	 HARD_PUSH(TOPOFSTACK);						\	 CALL_NATIVE(fncell, args);					\	}								\}#define	FN_CALL_NATIVE_CHECK2(fncell, args, extra_code)			\{									\  if (fncell->native)							\	{								\	 extra_code;							\	 (int) PC = args;						\	 FuncObj = fncell;						\	 HARD_PUSH(TOPOFSTACK);						\	 CALL_NATIVE2(fncell, args);					\	}								\}#define ASM_LABEL_OF_FN_COMMON asm_label_op_fn_common()#elseI 2#ifdef I386#define ASM_LABEL_OF_FN_COMMON asm("fn_common:");#else#define ASM_LABEL_OF_FN_COMMON#endifE 2#define FN_CALL_NATIVE_CHECK(fncell, args, extra_code)#define	FN_CALL_NATIVE_CHECK2(fncell, args, extra_code)D 2#define ASM_LABEL_OF_FN_COMMONE 2#endifD 10#define APPLY_POP_PUSH_TEST {						\	 switch (fn_apply) {						\		case 0:	break; /* do nothing */				\		case 1: POP; POP;  break; /* from apply */		\		case 2: break; /* ufn 0 args */				\		case 3: PUSH(S_POSITIVE | Get_BYTE_PCMAC1); break;	\		case 4: PUSH(S_POSITIVE | Get_DLword_PCMAC1); break;	\		default: error("Storage error: invalid UFN entry");	\		}							\	 if (needpush) PUSH(fn_atom_index);				\	}E 10I 10/************************************************************************//*									*//*		   A P P L Y _ P O P _ P U S H _ T E S T		*//*									*//*	Part of op_fn_common; decide what to do to the stack, depending	*//*	on whether we're FNcalling, APPLYing, or calling a UFN.  What	*//*	happens depends on the value of fn_apply, which is set by	*//*	the various opcode macros, as follows:				*//*									*//*	0 Normal function calls; do nothing additional.			*//*	1 APPLY:  POP the #ARGS and FN-NAME arguments.			*//*	2 UFN with 0 args from the opcode byte stream.  Do nothing.	*//*	3 UFN with 1 byte of arg from the code stream as a SMALLP	*//*	4 UFN with 2 bytes of arg from the code stream as a SMALLP	*//*	5 UFN with 3 bytes of arg from the code stream as a SMALLP	*//*									*//*	The latter 3 cases push the additional argument; THE 3-BYTE	*//*	CASE IS INCOMPLETE:  IT SHOULD BOX ANY NON-SMALLP VALUES!	*//*									*//************************************************************************/#define APPLY_POP_PUSH_TEST						\  {									\    switch (fn_apply)							\      {									\	case 0:	break; /* do nothing */					\	case 1: POP; POP;  break; /* from apply */			\	case 2: break; /* ufn 0 args */					\	case 3: PUSH(S_POSITIVE | Get_BYTE_PCMAC1); break;		\	case 4: PUSH(S_POSITIVE | Get_DLword_PCMAC1); break;		\	case 5: PUSH(S_POSITIVE | Get_AtomNo_PCMAC1); break;		\	default: error("Storage error: invalid UFN entry");		\      }									\    if (needpush) PUSH(fn_atom_index);					\  }E 10#define N_APPLY_POP_PUSH_TEST {						\	APPLY_POP_PUSH_TEST;						\	native_closure_env=closure_env;					\	}#define N_ENVCALL_POP_TEST {						\D 5	CSTKPTR -=2;							\E 5I 5	CSTKPTRL -=2;							\E 5	native_closure_env=closure_env;					\	}/****************************************************************//******			 OPAPPLY			 ********//****************************************************************/D 11E 11I 11#ifndef BIGATOMSE 11#define OPAPPLY	{							\  if ( GET_TOS_1_HI  == SPOS_HI ) {					\	fn_num_args = GET_TOS_1_LO;					\	fn_opcode_size = 1;						\	fn_apply = 1;							\	fn_atom_index = TOPOFSTACK;					\I 5	FNTRACER(Trace_APPLY(fn_atom_index));				\I 9	FNCHECKER(if (quick_stack_check()) Trace_APPLY(fn_atom_index));	\E 9E 5	if ( (0xffff0000 & TOPOFSTACK) == 0)				\	     {	fn_defcell = (DefCell *) GetDEFCELL68k(TOPOFSTACK);	\		goto op_fn_common;					\	     }								\	else								\	if (GetTypeNumber(TOPOFSTACK)==TYPE_COMPILED_CLOSURE)		\	     {	TopOfStack=TOPOFSTACK;					\		fn_defcell = (DefCell *) &TopOfStack;			\		goto op_fn_common;					\	     }								\	else {	fn_defcell = (DefCell *) GetDEFCELL68k(NIL_PTR);	\		goto op_fn_common;					\	     }								\	}								\  goto op_ufn;								\} /* OPAPPLY */I 11#else#define OPAPPLY	{							\  if ( GET_TOS_1_HI  == SPOS_HI ) {					\	fn_num_args = GET_TOS_1_LO;					\	fn_opcode_size = 1;						\	fn_apply = 1;							\	fn_atom_index = TOPOFSTACK;					\	FNTRACER(Trace_APPLY(fn_atom_index));				\	FNCHECKER(if (quick_stack_check()) Trace_APPLY(fn_atom_index));	\	if ( (0xffff0000 & TOPOFSTACK) == 0)				\	     {	fn_defcell = (DefCell *) GetDEFCELLlitatom(TOPOFSTACK);	\		goto op_fn_common;					\	     }								\	else switch (GetTypeNumber(TOPOFSTACK))				\	  {								\	    case TYPE_NEWATOM:						\		fn_defcell = (DefCell *) GetDEFCELLnew(TOPOFSTACK);	\		goto op_fn_common;					\	    case TYPE_COMPILED_CLOSURE:					\		TopOfStack=TOPOFSTACK;					\		fn_defcell = (DefCell *) &TopOfStack; 			\		goto op_fn_common;					\	    default: fn_defcell = (DefCell *) GetDEFCELL68k(NIL_PTR);	\		     goto op_fn_common;					\	  } /* end of switch */						\	}								\  goto op_ufn;								\} /* OPAPPLY */#endif BIGATOMSE 11D 11E 11/****************************************************************//******			 OPFN(x)			 ********//****************************************************************/#if (defined(SUN3_OS3_OR_OS4_IL) &&  !(defined(NOASMFNCALL)) )#ifdef NATIVETRAN#define OPFN(x, num_args_fn, fn_xna_args, fn_native)			\{    /* asm inlines for fn call (much care put into keeping optimizer	\	from moving things around). */					\	fn_section1();							\	fn_section2();							\	num_args_fn();							\	fn_native_test();						\	fn_section3();							\	fn_xna_args();							\	fn_section4();							\	fast1_dispatcher();		/* nextop0 don't work here */	\	fn_native();							\	fn_section5();							\			/* asm code jumps here when not ccodep */	\D 4	{ fn_atom_index = Get_DLword_PCMAC1;				\E 4I 4	{ fn_atom_index = Get_AtomNo_PCMAC1;				\E 4	  fn_defcell = (DefCell *) GetDEFCELL68k(fn_atom_index);	\	  fn_num_args = x;						\D 7	  fn_opcode_size = 3;						\E 7I 7	  fn_opcode_size = FN_OPCODE_SIZE;						\E 7	  fn_apply = 0;							\	  goto op_fn_common;						\	}								\}#define OPFNX								\{    /* asm inlines for fn call (much care put into keeping optimizer	\	from moving things around.	*/				\	fnx_section1();							\	fn_section2();							\	fnx_args();							\	fn_native_test();						\	fn_section3();							\	fnx_xna();							\	fn_section4();							\	fast1_dispatcher();		/* nextop0 don't work here */	\	fnx_native();							\	fn_section5();							\D 2	fn_atom_index = Get_DLword(PCMAC+2);				\E 2I 2D 14	fn_atom_index = Get_DLword_PCMAC2;				\E 14I 14	fn_atom_index = Get_AtomNo_PCMAC2;				\E 14E 2	fn_defcell = (DefCell *) GetDEFCELL68k(fn_atom_index);		\	fn_num_args = Get_BYTE_PCMAC1;				\D 7	fn_opcode_size = 4;						\E 7I 7D 8	fn_opcode_size = FNX_OPCODE_SIOZE;						\E 8I 8	fn_opcode_size = FNX_OPCODE_SIZE;						\E 8E 7	fn_apply = 0;							\	goto op_fn_common;						\		/* *** these carefully arranged to satisfy optimizer */ \label1:	fast1_dispatcher();						\label2:	to_native_label();						\									\}#else#define OPFN(x, num_args_fn, fn_xna_args, fn_native)			\{    /* asm inlines for fn call (much care put into keeping optimizer	\	from moving things around). */					\	fn_section1();							\	fn_section2();							\	num_args_fn();							\	fn_section3();							\	fn_xna_args();							\	fn_section4();							\	fast1_dispatcher();		/* nextop0 don't work here */	\	fn_section5();							\			/* asm code jumps here when not ccodep */	\D 4	{ fn_atom_index = Get_DLword_PCMAC1;				\E 4I 4	{ fn_atom_index = Get_AtomNo_PCMAC1;				\E 4	  fn_defcell = (DefCell *) GetDEFCELL68k(fn_atom_index);	\	  fn_num_args = x;						\D 7	  fn_opcode_size = 3;						\E 7I 7	  fn_opcode_size = FN_OPCODE_SIZE;				\E 7	  fn_apply = 0;							\	  goto op_fn_common;						\	}								\}#define OPFNX								\{    /* asm inlines for fn call (much care put into keeping optimizer	\	from moving things around.	*/				\	fnx_section1();							\	fn_section2();							\	fnx_args();							\	fn_section3();							\	fnx_xna();							\	fn_section4();							\	fast1_dispatcher();		/* nextop0 don't work here */	\	fn_section5();							\D 2	fn_atom_index = Get_DLword(PCMAC+2);				\E 2I 2D 14	fn_atom_index = Get_DLword_PCMAC2;				\E 14I 14	fn_atom_index = Get_AtomNo_PCMAC2;				\E 14E 2	fn_defcell = (DefCell *) GetDEFCELL68k(fn_atom_index);		\	fn_num_args = Get_BYTE_PCMAC1;				\D 7	fn_opcode_size = 4;						\E 7I 7	fn_opcode_size = FNX_OPCODE_SIZE;				\E 7	fn_apply = 0;							\	goto op_fn_common;						\		/* *** these carefully arranged to satisfy optimizer */ \label1:	fast1_dispatcher();						\									\}D 5#endifE 5I 5#endif NATIVETRANE 5#elseD 5#define OPFN(x, num_args_fn, fn_xna_args, fn_native)			\{	 /* x is a number of the arguments on stack */			\E 5I 5#define OPFN(argcount, num_args_fn, fn_xna_args, fn_native)		\{	 /* argcount is a number of the arguments on stack */		\E 5  register struct fnhead *LOCFNCELL;					\  register int defcell_word;						\  register int NEXTBLOCK;						\I 5  FNTRACER(Trace_FNCall(argcount, Get_AtomNo_PCMAC1));			\E 5D 2  if((defcell_word = *((int *) GetDEFCELL68k(Get_DLword(PCMAC+1)))) >= 0)\E 2I 2D 4  if((defcell_word = *((int *) GetDEFCELL68k(Get_DLword_PCMAC1))) >= 0)\E 4I 4D 9  if((defcell_word = *((int *) GetDEFCELL68k(Get_AtomNo_PCMAC1))) >= 0)\E 9I 9  FNCHECKER(if (quick_stack_check()) Trace_FNCall(argcount, Get_AtomNo_PCMAC1));	\D 15  if((defcell_word = *((int *) GetDEFCELL68k(Get_AtomNo_PCMAC1))) >= 0)	\E 15I 15  if((defcell_word = *((int *) fn_defcell = (DefCell *)GetDEFCELL68k(fn_atom_index = Get_AtomNo_PCMAC1))) >= 0)	\E 15E 9E 4E 2	{ /* it's not a CCODEP (what a test^!! */			\D 2	  fn_defcell = (DefCell *) GetDEFCELL68k(Get_DLword(PCMAC+1));	\E 2I 2D 4	  fn_defcell = (DefCell *) GetDEFCELL68k(Get_DLword_PCMAC1);	\E 4I 4D 15	  fn_defcell = (DefCell *) GetDEFCELL68k(Get_AtomNo_PCMAC1);	\E 15I 15	/* fn_defcell = (DefCell *) GetDEFCELL68k(Get_AtomNo_PCMAC1);*/	\E 15E 4E 2D 5	  fn_num_args = x;						\	  fn_opcode_size = 3;						\E 5I 5	  fn_num_args = argcount;					\	  fn_opcode_size = FN_OPCODE_SIZE;				\E 5D 2	  fn_atom_index = Get_DLword(PCMAC+1);				\E 2I 2D 4	  fn_atom_index = Get_DLword_PCMAC1;				\E 4I 4D 15	  fn_atom_index = Get_AtomNo_PCMAC1;				\E 15I 15	/*  fn_atom_index = Get_AtomNo_PCMAC1;*/			\E 15E 4E 2	  fn_apply = 0;							\	  goto op_fn_common;						\	}								\  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR((defcell_word &= 0xffffff));\D 5  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 3;\  FN_CALL_NATIVE_CHECK(LOCFNCELL,-x,{});				\E 5I 5  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + FN_OPCODE_SIZE;\  FN_CALL_NATIVE_CHECK(LOCFNCELL,-argcount,{});				\E 5  FN_STACK_CHECK;							\  {register int newivar;						\D 5	(LispPTR *) newivar = IVAR = CSTKPTR-x+1;			\E 5I 5	newivar = (int) (IVARL = (DLword *)(CSTKPTR-argcount+1));	\E 5	BCE_CURRENTFX->nextblock =					\	NEXTBLOCK =							\		StkOffset_from_68K(newivar);				\  }									\  HARD_PUSH(TOPOFSTACK);  /* save TOS */				\  if( LOCFNCELL->na >= 0 )						\  {register int RESTARGS;						\D 5	RESTARGS = x - LOCFNCELL->na;					\E 5I 5	RESTARGS = argcount - LOCFNCELL->na;				\E 5	while(RESTARGS <0) {						\	  HARD_PUSH(NIL_PTR);						\	  RESTARGS++;							\	}								\D 5	CSTKPTR -= (RESTARGS);						\E 5I 5	CSTKPTRL -= (RESTARGS);						\E 5  } /* if end */							\ /* Set up BF */							\ HARD_PUSH(BF_MARK32 | NEXTBLOCK);					\ *((LispPTR *)CSTKPTR) = (FX_MARK << 16) | (StkOffset_from_68K(PVAR));	\D 5 ((struct frameex2 *)CSTKPTR)->fnheader = SWAP_WORDS(defcell_word);\  ((DLword *) CSTKPTR) += FRAMESIZE;					\  PVAR = (LispPTR *) CSTKPTR;						\E 5I 5 ((struct frameex2 *)CSTKPTR)->fnheader = SWAP_WORDS(defcell_word);	\  CSTKPTRL = (LispPTR *)(((DLword *)CSTKPTR) + FRAMESIZE);		\D 8  PVARL = (LispPTR *) CSTKPTR;						\E 8I 8  PVARL = (DLword *) CSTKPTR;						\E 8E 5  {register int result;							\	result = LOCFNCELL->pv;						\	if (result >= 0)						\	  {register LispPTR unboundval;					\	   unboundval = (LispPTR) 0xffffffff;				\	   HARD_PUSH(unboundval);					\	   HARD_PUSH(unboundval);					\	   if (result > 0)						\	    {HARD_PUSH(unboundval);					\	     HARD_PUSH(unboundval);					\	     result-=1;							\	     for (; --result >= 0;) {					\	       HARD_PUSH(unboundval);					\	       HARD_PUSH(unboundval);					\	     }								\	   }								\	 }								\ }									\D 5 CSTKPTR += 1;								\E 5I 5 CSTKPTRL += 1;								\E 5 PCMACL = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1;		\ FuncObj = LOCFNCELL;							\ nextop0;								\} /* end OPFN *//*************** OPFNX *************/#define OPFNX	{							\  register struct fnhead *LOCFNCELL;					\  register DefCell *defcell;	/* this reg is not allocated */		\  register int NEXTBLOCK;						\  int num_args = Get_BYTE_PCMAC1;					\D 2  defcell = (DefCell *) GetDEFCELL68k(Get_DLword(PCMAC+2));		\E 2I 2D 5  defcell = (DefCell *) GetDEFCELL68k(Get_DLword_PCMAC2);		\E 5I 5  defcell = (DefCell *) GetDEFCELL68k(Get_AtomNo_PCMAC2);		\  FNTRACER(Trace_FNCall(num_args, Get_AtomNo_PCMAC2));			\I 9  FNCHECKER(if (quick_stack_check()) Trace_FNCall(num_args, Get_AtomNo_PCMAC2));	\E 9E 5E 2  if( defcell->ccodep == 0 )						\	{ fn_defcell = defcell;						\	  fn_num_args = num_args;					\D 5	  fn_opcode_size = 4;						\E 5I 5	  fn_opcode_size = FNX_OPCODE_SIZE;				\E 5D 2	  fn_atom_index = Get_DLword(PCMAC+2);				\E 2I 2D 13	  fn_atom_index = Get_DLword_PCMAC2;				\E 13I 13	  fn_atom_index = Get_AtomNo_PCMAC2;				\E 13E 2	  fn_apply = 0;							\	  goto op_fn_common;						\	}								\  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(defcell->defpointer);	\D 5  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 4;\E 5I 5  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + FNX_OPCODE_SIZE;\E 5  FN_CALL_NATIVE_CHECK2(LOCFNCELL, - num_args, {});			\  FN_STACK_CHECK;							\  {register int newivar;						\D 7	(LispPTR *) newivar = IVAR = CSTKPTR-num_args+1;		\E 7I 7D 8	newivar = (int)(IVAR = CSTKPTR-num_args+1);		\E 8I 8	newivar = (int)(IVARL = (DLword *)(CSTKPTR-num_args+1));	\E 8E 7	BCE_CURRENTFX->nextblock =					\	NEXTBLOCK =							\		StkOffset_from_68K(newivar);				\  }									\  HARD_PUSH(TOPOFSTACK);  /* save TOS */				\  if( LOCFNCELL->na >= 0 )						\  {register int RESTARGS;						\	RESTARGS = num_args - LOCFNCELL->na;				\	while(RESTARGS <0) {						\	  HARD_PUSH(NIL_PTR);						\	  RESTARGS++;							\	}								\D 7	CSTKPTR -= (RESTARGS);						\E 7I 7	CSTKPTRL -= (RESTARGS);						\E 7  } /* if end */							\ /* Set up BF */							\ HARD_PUSH(BF_MARK32 | NEXTBLOCK);					\ *((LispPTR *)CSTKPTR) = (FX_MARK << 16) | (StkOffset_from_68K(PVAR));	\ ((struct frameex2 *)CSTKPTR)->fnheader = SWAP_WORDS(defcell->defpointer);\D 7  ((DLword *) CSTKPTR) += FRAMESIZE;					\  PVAR = (LispPTR *) CSTKPTR;						\E 7I 7  CSTKPTRL = (LispPTR *) (((DLword *)CSTKPTR) + FRAMESIZE);		\D 8  PVARL = (LispPTR *) CSTKPTR;						\E 8I 8  PVARL = (DLword *) CSTKPTR;						\E 8E 7  {register int result;							\	result = LOCFNCELL->pv;						\	if (result >= 0)						\	  {register LispPTR unboundval;					\	   unboundval = (LispPTR) 0xffffffff;				\	   HARD_PUSH(unboundval);					\	   HARD_PUSH(unboundval);					\	   if (result > 0)						\	    {HARD_PUSH(unboundval);					\	     HARD_PUSH(unboundval);					\	     result-=1;							\	     for (; --result >= 0;) {					\	       HARD_PUSH(unboundval);					\	       HARD_PUSH(unboundval);					\	     }								\	   }								\	 }								\ }									\D 7 CSTKPTR += 1;								\E 7I 7 CSTKPTRL += 1;								\E 7 PCMACL = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1;		\ FuncObj = LOCFNCELL;							\} /* end OPFN */D 5#endifE 5I 5#endif NOASMFNCALLE 5I 5E 5/****************************************************************//******			 OPCHECKAPPLY			 ********//****************************************************************/#define OPCHECKAPPLY {							\  register DefCell *defcell;						\  defcell = (DefCell *) GetDEFCELL68k(TOPOFSTACK & 0xffff);		\  if  (!(  defcell->ccodep  && ((TOPOFSTACK & 0xffff0000) == 0)	&&	\	( ( defcell->argtype == 0 ) || ( defcell->argtype == 2 ) ) ) )	\	goto op_ufn;							\}I 5E 5/****************************************************************//*		UFN_COMMON at op_ufn				 //****************************************************************/#define GetUFNEntry(num)	(((UFN *)UFNTable) + (num))#define	UFN_COMMON							\op_ufn:		 use code in XC.c					\{ register UFN *entry68k;						\   entry68k = (UFN *)GetUFNEntry(Get_BYTE_PCMAC0);			\   fn_num_args = entry68k->arg_num;					\   fn_opcode_size = entry68k->byte_num+1;				\   fn_atom_index = entry68k->atom_name;					\   fn_defcell = (DefCell *) GetDEFCELL68k(fn_atom_index);		\   fn_apply = 0;							\   goto op_fn_common;							\  };/****************************************************************//******			 OP_FN_COMMON			 ********//* vars:							*//*	fn_atom_index						*//*	fn_num_args						*//*	fn_opcode_size						*//*	fn_defcell						*//*	fn_apply						*//*								*//* All Closure Calls go through here				*//****************************************************************/#define needpush NEXTBLOCK#define OP_FN_COMMON							\op_fn_common:								\	ASM_LABEL_OF_FN_COMMON;						\{ register struct fnhead *LOCFNCELL;					\  register DefCell *defcell;	/* this reg is not allocated */		\  CClosure *closure;							\  LispPTR closure_env = (LispPTR) 0xffffffff;				\ {register int NEXTBLOCK = NIL;						\  defcell = fn_defcell;							\  if( (defcell->ccodep == 0)  )						\    if(GetTypeNumber(defcell->defpointer)==TYPE_COMPILED_CLOSURE)	\	 { /* setup closure */						\		closure=(CClosure *)Addr68k_from_LADDR(defcell->defpointer);\		defcell=(DefCell *)closure;				\		/* not  a closure if closure's env is NIL */		\		if(closure->env_ptr )					\			{closure_env =  (LispPTR) (closure->env_ptr);	\			}						\	 } /* if end */							\	else {								\	/* NOT compiled object . We must use Interpreter*/		\	defcell = (DefCell *)GetDEFCELL68k(ATOM_INTERPRETER);		\	needpush = 1;							\	 } /*else end */						\  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(defcell->defpointer);	\D 5  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + fn_opcode_size;\E 5I 5  BCE_CURRENTFX->pc = ((unsigned int)PCMAC 				\			- (unsigned int)FuncObj) + fn_opcode_size;	\  FNTPRINT(("Saving PC = 0%o (0x%x).\n", 				\	    BCE_CURRENTFX->pc, PCMAC+fn_opcode_size)); 			\E 5  FN_CALL_NATIVE_CHECK2(LOCFNCELL, -fn_num_args, N_APPLY_POP_PUSH_TEST)	\  FN_STACK_CHECK;							\  APPLY_POP_PUSH_TEST;							\ {register int newivar;							\D 7	(LispPTR *) newivar = IVAR = CSTKPTR+(1-fn_num_args-needpush);	\E 7I 7D 8	newivar = (int)(IVAR = CSTKPTR+(1-fn_num_args-needpush));	\E 8I 8	newivar = (int)(IVARL = (DLword *) (CSTKPTR+(1-fn_num_args-needpush)));	\E 8E 7	BCE_CURRENTFX->nextblock =					\	NEXTBLOCK =							\		StkOffset_from_68K(newivar);				\  }									\  HARD_PUSH(TOPOFSTACK);  /* save TOS */				\  if( LOCFNCELL->na >= 0 )						\  {register int RESTARGS;						\	RESTARGS = fn_num_args - LOCFNCELL->na;				\	while(RESTARGS <0) {						\	  HARD_PUSH(NIL_PTR);						\	  RESTARGS++;							\	}								\D 7	CSTKPTR -= (RESTARGS);						\E 7I 7	CSTKPTRL -= (RESTARGS);						\E 7  } /* if end */							\ /* Set up BF */							\ HARD_PUSH(BF_MARK32 | NEXTBLOCK);					\ } /* NEXTBLOCK BLOCK */						\ *((LispPTR *)CSTKPTR) = (FX_MARK << 16) | (StkOffset_from_68K(PVAR));	\ ((struct frameex2 *)CSTKPTR)->fnheader = SWAP_WORDS(defcell->defpointer);\D 7  ((DLword *) CSTKPTR) += FRAMESIZE;					\  PVAR = (LispPTR *) CSTKPTR;						\E 7I 7D 8  CSTKPTR = (LispPTR *) (((DLword *)CSTKPTR) + FRAMESIZE);		\  PVARL = (LispPTR *) CSTKPTR;						\E 8I 8  CSTKPTRL = (LispPTR *) (((DLword *)CSTKPTR) + FRAMESIZE);		\  PVARL = (DLword *) CSTKPTR;						\E 8E 7  {register int result;							\   register LispPTR unboundval;						\   unboundval = (LispPTR) 0xffffffff;					\   result = LOCFNCELL->pv;						\   HARD_PUSH(closure_env);						\   HARD_PUSH(unboundval);						\   for (; --result >= 0;) {						\       HARD_PUSH(unboundval);						\       HARD_PUSH(unboundval);						\       }								\ }	/* result, unboundval block */					\D 7 CSTKPTR += 1;								\E 7I 7 CSTKPTRL += 1;								\E 7 PCMACL = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1;		\ FuncObj = LOCFNCELL;							\ CHECK_INTERRUPT;							\ nextop0;								\} /* end OP_FN_COMMON */I 5E 5/************************************************************************//*									*//*			O P _ E N V C A L L				*//*									*//*	Environment call on a code object.  Takes an arg count on	*//*	the stack, along with a pointer to an environment.  If non-	*//*	NIL, the environment is stuffed into the PVAR0 slot of the	*//*	frame. [This NIL check is in the UFN, and seems to be meant	*//*	to allow closures to be called without an environment, without	*//*	the compiler having to emit special code.]			*//*									*//************************************************************************/#define OP_ENVCALL	{						\  register struct fnhead *LOCFNCELL;					\  register int NEXTBLOCK;						\  register LispPTR closure_env = TOPOFSTACK;				\  register int num_args;						\  register LispPTR Fn_DefCell=  GET_TOS_1;				\  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(Fn_DefCell);		\I 9  FNTPRINT(("ENVCall.\n"));						\  FNCHECKER(if (quick_stack_check()) printf("In ENVCALL.\n"));	\E 9  N_GETNUMBER(GET_TOS_2, num_args, op_ufn);				\  BCE_CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 1;\  FN_CALL_NATIVE_CHECK2(LOCFNCELL, -num_args, N_ENVCALL_POP_TEST);	\  FN_STACK_CHECK;							\D 7  CSTKPTR -= 2;								\E 7I 7  CSTKPTRL -= 2;							\E 7  {register int newivar;						\D 7	(LispPTR *) newivar = IVAR = CSTKPTR-num_args;			\E 7I 7D 8	newivar = (int) (IVAR = CSTKPTR-num_args);			\E 8I 8	newivar = (int) (IVARL = (DLword *) (CSTKPTR-num_args));			\E 8E 7	BCE_CURRENTFX->nextblock =					\	NEXTBLOCK =							\		StkOffset_from_68K(newivar);				\  }									\  if( LOCFNCELL->na >= 0 )						\  {register int RESTARGS;						\	RESTARGS = num_args - LOCFNCELL->na;				\	while(RESTARGS <0) {						\	  HARD_PUSH(NIL_PTR);						\	  RESTARGS++;							\	}								\D 7	CSTKPTR -= (RESTARGS);						\E 7I 7	CSTKPTRL -= (RESTARGS);						\E 7  } /* if end */							\ /* Set up BF */							\ HARD_PUSH(BF_MARK32 | NEXTBLOCK);					\ *((LispPTR *)CSTKPTR) = (FX_MARK << 16) | (StkOffset_from_68K(PVAR));	\ ((struct frameex2 *)CSTKPTR)->fnheader = SWAP_WORDS(Fn_DefCell);	\D 7  ((DLword *) CSTKPTR) += FRAMESIZE;					\  PVAR = (LispPTR *) CSTKPTR;						\E 7I 7  CSTKPTRL = (LispPTR *)(((DLword *)CSTKPTR) + FRAMESIZE);		\D 8  PVARL = (LispPTR *) CSTKPTR;						\E 8I 8  PVARL = (DLword *) CSTKPTR;						\E 8E 7  {register int result;							\	result = LOCFNCELL->pv;						\	if (result >= 0)						\	  {register LispPTR unboundval;					\	   unboundval = (LispPTR) 0xffffffff;				\	   if (closure_env == NIL_PTR) HARD_PUSH(unboundval);		\	     else HARD_PUSH(closure_env);				\	   HARD_PUSH(unboundval);					\	   if (result > 0)						\	    {HARD_PUSH(unboundval);					\	     HARD_PUSH(unboundval);					\	     result-=1;							\	     for (; --result >= 0;) {					\	       HARD_PUSH(unboundval);					\	       HARD_PUSH(unboundval);					\	     }								\	   }								\	 }								\ }									\D 7 CSTKPTR += 1;								\E 7I 7 CSTKPTRL += 1;								\E 7 PCMACL = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc + 1;		\ FuncObj = LOCFNCELL;							\} /* end OP_ENVCALL */I 5E 5/****************************************************************//******			 EVAL				 ********//****************************************************************/D 10E 10I 10#ifndef BIGATOMSE 10#define EVAL								\D 10{									\ LispPTR scratch;							\ register LispPTR work;							\ register LispPTR lookuped; /* keep looked up value */			\E 10I 10  {									\    LispPTR scratch;							\    register LispPTR work;						\    register LispPTR lookuped; /* keep looked up value */		\E 10									\D 10  switch(TOPOFSTACK & 0x0ff0000) {					\   case S_POSITIVE :							\   case S_NEGATIVE :	nextop1;					\E 10I 10    switch(TOPOFSTACK & 0x0ff0000)					\      {									\	case S_POSITIVE:						\	case S_NEGATIVE:  nextop1;					\E 10									\D 10   case ATOMS_OFFSET : if((TOPOFSTACK==NIL_PTR)||(TOPOFSTACK==ATOM_T))	\			goto Hack_Label;				\			nnewframe(CURRENTFX,&scratch,TOPOFSTACK & 0xffff);\			work =	((scratch & 0xffff0000)>> 16) |		\				((scratch & 0x00ff) <<16);		\			lookuped =					\			  *((LispPTR *)(Addr68k_from_LADDR(work)));	\			if(lookuped==NOBIND_PTR) goto op_ufn;		\			TOPOFSTACK = lookuped;				\Hack_Label:		nextop1;					\E 10I 10	case ATOMS_OFFSET: if( (TOPOFSTACK==NIL_PTR)			\			     ||(TOPOFSTACK==ATOM_T))			\				goto Hack_Label;			\			    nnewframe(CURRENTFX,&scratch,		\				      TOPOFSTACK & 0xffff);		\			    work = ((scratch & 0xffff0000)>> 16) |	\				   ((scratch & 0x00ff) <<16);		\			    lookuped = *((LispPTR *)			\					(Addr68k_from_LADDR(work)));	\			    if(lookuped==NOBIND_PTR) goto op_ufn;	\			    TOPOFSTACK = lookuped;			\		Hack_Label: nextop1;					\E 10									\D 10   default :		switch(GetTypeNumber(TOPOFSTACK)){		\			  case TYPE_FIXP :				\			  case TYPE_FLOATP :				\			  case TYPE_STRINGP :				\			  case TYPE_ONED_ARRAY :			\			  case TYPE_GENERAL_ARRAY :	nextop1;	\E 10I 10	default:  switch(GetTypeNumber(TOPOFSTACK))			\		    {							\		      case TYPE_FIXP :					\		      case TYPE_FLOATP :				\		      case TYPE_STRINGP :				\		      case TYPE_ONED_ARRAY :				\		      case TYPE_GENERAL_ARRAY :	nextop1;		\E 10									\D 10			  case TYPE_LISTP :				\				fn_atom_index = ATOM_EVALFORM;		\				fn_num_args = 1;			\				fn_opcode_size = 1;			\				fn_defcell = (DefCell *)		\					GetDEFCELL68k(ATOM_EVALFORM);	\				fn_apply = 0;				\				goto op_fn_common;			\E 10I 10		      case TYPE_LISTP :					\			fn_atom_index = ATOM_EVALFORM;			\			fn_num_args = 1;				\			fn_opcode_size = 1;				\			fn_defcell = (DefCell *)			\				GetDEFCELL68k(ATOM_EVALFORM);		\			fn_apply = 0;					\			goto op_fn_common;				\E 10									\D 10			  default :	 goto op_ufn;			\E 10I 10		      default :	 goto op_ufn;				\E 10				}					\									\  } /* end switch */							\									\}/* EVAL end */I 10#else#define EVAL								\  {									\    LispPTR scratch;							\    register LispPTR work;						\    register LispPTR lookuped; /* keep looked up value */		\									\    switch(TOPOFSTACK & 0x0ff0000)					\      {									\	case S_POSITIVE:						\	case S_NEGATIVE:  nextop1;					\									\	case ATOMS_OFFSET: if( (TOPOFSTACK==NIL_PTR)			\			     ||(TOPOFSTACK==ATOM_T))			\				goto Hack_Label;			\			    nnewframe(CURRENTFX,&scratch,		\				      TOPOFSTACK & 0xffff);		\			    work = ((scratch & 0xffff0000)>> 16) |	\				   ((scratch & 0x00ff) <<16);		\			    lookuped = *((LispPTR *)			\					(Addr68k_from_LADDR(work)));	\			    if(lookuped==NOBIND_PTR) goto op_ufn;	\			    TOPOFSTACK = lookuped;			\		Hack_Label: nextop1;					\									\	default:  switch(GetTypeNumber(TOPOFSTACK))			\		    {							\		      case TYPE_FIXP :					\		      case TYPE_FLOATP :				\		      case TYPE_STRINGP :				\		      case TYPE_ONED_ARRAY :				\		      case TYPE_GENERAL_ARRAY :	nextop1;		\									\		      case TYPE_LISTP :					\			fn_atom_index = ATOM_EVALFORM;			\			fn_num_args = 1;				\			fn_opcode_size = 1;				\			fn_defcell = (DefCell *)			\				GetDEFCELL68k(ATOM_EVALFORM);		\			fn_apply = 0;					\			goto op_fn_common;				\									\		      case TYPE_NEWATOM:				\D 11				nnewframe(CURRENTFX,&scratch,		\					  TOPOFSTACK & 0xffffff);	\				work =	((scratch & 0xffff0000)>> 16)	\				       | ((scratch & 0x00ff) <<16);	\E 11I 11D 12				work =	0xFFFFFF & SWAP_WORDS(scratch);	\E 11				lookuped = *((LispPTR *)		\					   (Addr68k_from_LADDR(work)));	\				if(lookuped==NOBIND_PTR) goto op_ufn;	\				TOPOFSTACK = lookuped;			\				nextop1;				\E 12I 12			nnewframe(CURRENTFX, &scratch, TOPOFSTACK);	\			work =	0xFFFFFF & SWAP_WORDS(scratch);		\			lookuped = *((LispPTR *)			\				   (Addr68k_from_LADDR(work)));		\			if(lookuped==NOBIND_PTR) goto op_ufn;		\			TOPOFSTACK = lookuped;				\			nextop1;					\E 12		      default :	 goto op_ufn;				\				}					\									\  } /* end switch */							\									\}/* EVAL end */#endif BIGATOMSE 10E 1