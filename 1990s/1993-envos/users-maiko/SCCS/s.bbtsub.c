h61319s 01300/01127/01104d D 1.4 93/02/08 14:48:00 sybalsky 4 3c Big VM (and new CDR coding) changes for 3.0 \nes 00014/00018/02217d D 1.3 92/06/26 13:47:53 sybalsky 3 2c retrofit of 386 unix changes \nes 00001/00003/02234d D 1.2 92/04/22 13:47:08 sybalsky 2 1c fix SCCS headeres 02237/00000/00000d D 1.1 92/04/21 15:28:15 sybalsky 1 0c date and time created 92/04/21 15:28:15 by sybalskyeuUf e 0tTI 1D 2/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 2D 4/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(Venue & Fuji Xerox)";E 4I 4/* @(#) bbtsub.c Version 1.2 (4/22/92). copyright Venue & Fuji Xerox  */static char *id = "@(#) bbtsub.c        1.2 4/22/92             (Venue & Fuji Xerox)";E 4/************************************************************************/D 4/*									*//*			File:	bbtsub.c				*//*									*//*	Subroutines to support BITBLT, \BLTCHAR, and \TEDIT.BLTCHAR	*//*	lisp functions, providing performance improvement.		*//*									*//*									*//*									*//*									*//*									*//*									*/E 4I 4/*                                                                      *//*                      File:   bbtsub.c                                *//*                                                                      *//*      Subroutines to support BITBLT, \BLTCHAR, and \TEDIT.BLTCHAR     *//*      lisp functions, providing performance improvement.              *//*                                                                      *//*                                                                      *//*                                                                      *//*                                                                      *//*                                                                      *//*                                                                      */E 4/************************************************************************//************************************************************************/D 4/*									*/D 2/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*/E 2I 2/*	(C) Copyright 1989, 1990, 1991, 1992 Venue. All Rights Reserved.	*/E 2/*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*/E 4I 4/*                                                                      *//*      (C) Copyright 1989, 1990, 1991, 1992 Venue. All Rights Reserved.        *//*      Manufactured in the United States of America.                   *//*                                                                      *//*      The contents of this file are proprietary information           *//*      belonging to Venue, and are provided to you under license.      *//*      They may not be further distributed or disclosed to third       *//*      parties without the specific permission of Venue.               *//*                                                                      */E 4/************************************************************************/#include <stdio.h>D 4#include <sys/ioctl.h>#include <sys/types.h>E 4#ifdef XWINDOWI 4#ifndef DOS#include <sys/ioctl.h>#endif /* DOS */#include <sys/types.h>E 4#include <X11/Xlib.h>#include <X11/Xutil.h>I 3D 4#include "ldeXdefs.h"E 4E 3extern Display *Xdisplay;I 4#ifdef ISC  /* for ISC, need to turn off SIGIO while flushing changes to X server */#define SIGoff sighold(SIGPOLL);#define SIGon  sigrelse(SIGPOLL);#include <signal.h>#else#define SIGoff#define SIGon#endif /* ISC */#endif /* XWINDOW */E 4/* from pixrect's rect.h: */#ifndef max#define max(a,b) (((a) > (b)) ? (a) : (b))#endif#ifndef minD 4#define min(a,b)	(((a) < (b)) ? (a) : (b))E 4I 4#define min(a,b)        (((a) < (b)) ? (a) : (b))E 4#endifD 3#ifdef ISC  /* for ISC, need to turn off SIGIO while flushing changes to X server */#define SIGoff sighold(SIGPOLL);#define SIGon  sigrelse(SIGPOLL);#include <signal.h>#else#define SIGoff#define SIGon#endif /* ISC */E 3D 4#endif XWINDOWE 4#ifndef XWINDOW#ifndef NOPIXRECTI 4#ifndef DOSE 4#include <sunwindow/window_hs.h>#include <sunwindow/win_ioctl.h>D 4#endif NOPIXRECT#endif XWINDOWE 4I 4#endif /* DOS */#endif /* NOPIXRECT */E 4I 4#endif /* XWINDOW */E 4#include "lispemul.h"#include "lspglob.h"#include "lispmap.h"#include "lsptypes.h"#include "emlglob.h"#include "adr68k.h"#include "address.h"#include "arith.h"#include "stack.h"#include "cell.h"#include "gc.h"I 3D 4#include "tosfns.h"E 4E 3#ifdef AIX#include <sys/types.h>#include <macros.h>D 4#endif AIXE 4I 4#endif /* AIX */E 4I 4E 4#include "bb.h"#include "bitblt.h"#include "pilotbbt.h"#include "dspdata.h"#include "display.h"#include "dbprint.h"#ifdef COLORextern int MonoOrColor;D 4#endif COLORE 4I 4#endif /* COLOR */E 4I 4    /*******************************************/    /*  REALCURSOR is defined iff we need to   */    /*  take care of cursor movement & hiding  */    /*  (during bitblts to screen) ourselves.  */    /*******************************************/#if defined(SUNDISPLAY) || defined(DOS)#define REALCURSOR#else#undef REALCURSOR#endifE 4/* same definition is in my.h */I 4#ifdef BIGVM#define IsNumber(address)  ((GETWORD(MDStypetbl +(((address) & 0x0fffff00)>>9))) & 0x1000)#elseE 4#define IsNumber(address)  ((GETWORD(MDStypetbl +(((address) & 0x0ffff00)>>9))) & 0x1000)I 4#endifE 4D 4#define BITSPERWORD	(16)	/* temp definition	*/E 4I 4#define BITSPERWORD     (16)    /* temp definition      */E 4D 4	/***** Don't use PixRect code on 386i for now *****/	/***** -or on any machine that doesn't support it (HP, e.g.) *****/E 4I 4        /***** Don't use PixRect code on 386i for now *****/        /***** -or on any machine that doesn't support it (HP, e.g.) *****/E 4D 4	/********************************************************/	/*							*/	/*	prropstyle is DEFINED when we want to use	*/	/*	pixrect versions of the operations in this	*/	/*	file, and UNDEFINED, when we want to use	*/	/*	Don Charnley's bitblt code to do them.		*/	/*							*/	/********************************************************/E 4I 4        /********************************************************/        /*                                                      */        /*      prropstyle is DEFINED when we want to use       */        /*      pixrect versions of the operations in this      */        /*      file, and UNDEFINED, when we want to use        */        /*      Don Charnley's bitblt code to do them.          */        /*                                                      */        /********************************************************/E 4#if ( !(defined(NOPIXRECT)) && !(defined(NEWBITBLT)) && !(defined(I386)) )#define prropstyle 1D 4#endif NOPIXRECTE 4I 4#endif /* NOPIXRECT */E 4I 4E 4extern int LispWindowFd;extern int ScreenLocked; /* for mouse tracking *//*****************************************************************(PUTPROPS \SETPBTFUNCTION MACROD 4	(OPENLAMBDA (BBT SourceType Operation)		(PROGN (replace (PILOTBBT PBTOPERATION) of BBT with				(SELECTQ Operation					(ERASE 1)					(PAINT 2)					(INVERT 3)					0))		       (replace (PILOTBBT PBTSOURCETYPE) of BBT with			    (COND ((EQ (EQ SourceType (QUOTE INVERT))				       (EQ Operation (QUOTE ERASE))) 0)				  (T 1))))))E 4I 4        (OPENLAMBDA (BBT SourceType Operation)                (PROGN (replace (PILOTBBT PBTOPERATION) of BBT with                                (SELECTQ Operation                                        (ERASE 1)                                        (PAINT 2)                                        (INVERT 3)                                        0))                       (replace (PILOTBBT PBTSOURCETYPE) of BBT with                            (COND ((EQ (EQ SourceType (QUOTE INVERT))                                       (EQ Operation (QUOTE ERASE))) 0)                                  (T 1))))))E 4*****************************************************************/D 4#define PixOperationLisp( SRCTYPE, OPERATION )				\	( SRCTYPE == INVERT_atom ?					\		(OPERATION == REPLACE_atom ? PIX_NOT(PIX_SRC) :		\		(OPERATION == PAINT_atom   ? PIX_NOT(PIX_SRC) | PIX_DST : \		(OPERATION == ERASE_atom   ? PIX_SRC & PIX_DST :	\		(OPERATION == INVERT_atom  ? PIX_NOT(PIX_SRC) ^ PIX_DST : ERROR)))) :	\	/*  SRCTYPE == INPUT, TEXTURE */				\		(OPERATION == REPLACE_atom ? PIX_SRC :			\		(OPERATION == PAINT_atom   ? PIX_SRC | PIX_DST :	\		(OPERATION == ERASE_atom   ? PIX_NOT(PIX_SRC) & PIX_DST : \		(OPERATION == INVERT_atom  ? PIX_SRC ^ PIX_DST : ERROR)))))E 4I 4#define PixOperationLisp( SRCTYPE, OPERATION )                          \        ( SRCTYPE == INVERT_atom ?                                      \                (OPERATION == REPLACE_atom ? PIX_NOT(PIX_SRC) :                 \                (OPERATION == PAINT_atom   ? PIX_NOT(PIX_SRC) | PIX_DST : \                (OPERATION == ERASE_atom   ? PIX_SRC & PIX_DST :        \                (OPERATION == INVERT_atom  ? PIX_NOT(PIX_SRC) ^ PIX_DST : ERROR)))) :   \        /*  SRCTYPE == INPUT, TEXTURE */                                \                (OPERATION == REPLACE_atom ? PIX_SRC :                  \                (OPERATION == PAINT_atom   ? PIX_SRC | PIX_DST :        \                (OPERATION == ERASE_atom   ? PIX_NOT(PIX_SRC) & PIX_DST : \                (OPERATION == INVERT_atom  ? PIX_SRC ^ PIX_DST : ERROR)))))E 4D 4#define bbop( SRCTYPE, OPERATION )					\		(OPERATION == PAINT_atom ? op_fn_or :			\		(OPERATION == ERASE_atom ? op_fn_and :			\		(OPERATION == INVERT_atom ? op_fn_xor : op_repl_src)))E 4I 4#define bbop( SRCTYPE, OPERATION )                                      \                (OPERATION == PAINT_atom ? op_fn_or :                   \                (OPERATION == ERASE_atom ? op_fn_and :                  \                (OPERATION == INVERT_atom ? op_fn_xor : op_repl_src)))E 4D 4	/********************************************************/	/*							*/	/*		    b b s r c _ t y p e			*/	/*							*/	/*	Returns 1 if the source bits must be inverted	*/	/*	as part of the BITBLT.  This is true if the	*/	/*	OPERATION argument to BITBLT is 'ERASE, or	*/	/*	if the SOURCETYPE argument is 'INVERT.		*/	/*							*/	/********************************************************/E 4I 4        /********************************************************/        /*                                                      */        /*                  b b s r c _ t y p e                         */        /*                                                      */        /*      Returns 1 if the source bits must be inverted   */        /*      as part of the BITBLT.  This is true if the     */        /*      OPERATION argument to BITBLT is 'ERASE, or      */        /*      if the SOURCETYPE argument is 'INVERT.          */        /*                                                      */        /********************************************************/E 4D 4#define bbsrc_type( SRCTYPE, OPERATION )				\	( SRCTYPE == INVERT_atom ?					\		(OPERATION == ERASE_atom ? 0 : 1 )			\	/*  SRCTYPE == INPUT, TEXTURE */				\		: (OPERATION == ERASE_atom ? 1 : 0))E 4I 4#define bbsrc_type( SRCTYPE, OPERATION )                                \        ( SRCTYPE == INVERT_atom ?                                      \                (OPERATION == ERASE_atom ? 0 : 1 )                      \        /*  SRCTYPE == INPUT, TEXTURE */                                \                : (OPERATION == ERASE_atom ? 1 : 0))E 4D 4#define init_kbd_startup	\	if (!kbd_for_makeinit){ \		init_keyboard(0); \		kbd_for_makeinit = 1; \	};E 4I 4#define init_kbd_startup        \        if (!kbd_for_makeinit){ \                init_keyboard(0); \                kbd_for_makeinit = 1; \        };E 4extern struct pixrect *SrcePixRect, *DestPixRect, *TexturePixRect;extern struct pixrect *BlackTexturePixRect, *WhiteTexturePixRect;D 4extern DLword	TEXTURE_atom;extern DLword	MERGE_atom;extern DLword	INPUT_atom;extern DLword	INVERT_atom;extern DLword	ERASE_atom;extern DLword	PAINT_atom;extern DLword	REPLACE_atom;E 4I 4extern DLword   TEXTURE_atom;extern DLword   MERGE_atom;extern DLword   INPUT_atom;extern DLword   INVERT_atom;extern DLword   ERASE_atom;extern DLword   PAINT_atom;extern DLword   REPLACE_atom;E 4D 4extern int kbd_for_makeinit;	/*** FOR INIT ***/E 4I 4extern int kbd_for_makeinit;    /*** FOR INIT ***/E 4/************************************************************************/D 4/*									*//*			   b i t b l t s u b				*//*									*//*	Implements the lisp function \BITBLTSUB, which is where		*//*	all BITBLT & BLTSHADE calls bottom out.  This is distinct	*//*	from the PILOTBITBLT opcode, which is implemented in bitblt.c.	*//*									*//*									*//*	args[0] :	PILOTBBT					*//*	args[1] :	SOURCEBITMAP					*//*	args[2] :	SLX (SourceLeftX)		sx		*//*	args[3] :	STY (SourceTopY)		sty		*//*	args[4] :	DESTINATIONBITMAP				*//*	args[5] :	DLX (DestinationLeftX)		dx		*//*	args[6] :	DTY (DestinationTopY)		dty		*//*	args[7] :	HEIGHT						*//*	args[8] :	SourceType					*//*	args[9] :	Operation					*//*	args[10] :	Texture						*//*	args[11] :	WindowXOffset					*//*	args[12] :	WindowYOffset					*//*									*//*									*//*									*//*									*//*									*//*									*/E 4I 4/*                                                                      *//*                         b i t b l t s u b                            *//*                                                                      *//*      Implements the lisp function \BITBLTSUB, which is where                 *//*      all BITBLT & BLTSHADE calls bottom out.  This is distinct       *//*      from the PILOTBITBLT opcode, which is implemented in bitblt.c.  *//*                                                                      *//*                                                                      *//*      args[0] :       PILOTBBT                                        *//*      args[1] :       SOURCEBITMAP                                    *//*      args[2] :       SLX (SourceLeftX)               sx              *//*      args[3] :       STY (SourceTopY)                sty             *//*      args[4] :       DESTINATIONBITMAP                               *//*      args[5] :       DLX (DestinationLeftX)          dx              *//*      args[6] :       DTY (DestinationTopY)           dty             *//*      args[7] :       HEIGHT                                          *//*      args[8] :       SourceType                                      *//*      args[9] :       Operation                                       *//*      args[10] :      Texture                                                 *//*      args[11] :      WindowXOffset                                   *//*      args[12] :      WindowYOffset                                   *//*                                                                      *//*                                                                      *//*                                                                      *//*                                                                      *//*                                                                      *//*                                                                      */E 4/************************************************************************/bitbltsub( argv )D 4 LispPTR	*argv;E 4I 4 LispPTR        *argv;E 4  {D 4    int	sourcetype, operation;    int	sty, dty, texture, wxoffset, wyoffset;E 4I 4    int sourcetype, operation;    int sty, dty, texture, wxoffset, wyoffset;E 4    int h, w;    int displayflg = 0, desthi;    int backwardflg = 0, sx, dx, srcbpl, dstbpl, src_comp, op;    register DLword *srcbase, *dstbase;    int gray = 0, num_gray = 0, curr_gray_line = 0;    DLword grayword[4];    { /* Initialization code, in a block so it optimizes independently */      register LispPTR *args = argv;      register PILOTBBT *pbt;      register BITMAP *srcebm, *destbm;      BITMAP *texture68k;      register DLword *base;#ifdef INIT      init_kbd_startup;#endif      pbt        = (PILOTBBT *)Addr68k_from_LADDR( args[0] );D 4      srcebm	   = (BITMAP *)Addr68k_from_LADDR( args[1] );      sx	   = (args[2] & 0xFFFF);      sty	   = (args[3] & 0xFFFF);      destbm	   = (BITMAP *)Addr68k_from_LADDR( args[4] );      dx	   = (args[5] & 0xFFFF);      dty	   = (args[6] & 0xFFFF);E 4I 4      srcebm       = (BITMAP *)Addr68k_from_LADDR( args[1] );      sx           = (args[2] & 0xFFFF);      sty          = (args[3] & 0xFFFF);      destbm       = (BITMAP *)Addr68k_from_LADDR( args[4] );      dx           = (args[5] & 0xFFFF);      dty          = (args[6] & 0xFFFF);E 4      sourcetype = ( args[8] == NIL_PTR ? INPUT_atom : args[8] );      operation  = ( args[9] == NIL_PTR ? REPLACE_atom : args[9] );      w = pbt->pbtwidth;      h = pbt->pbtheight;      if ((h <= 0) || (w <= 0)) return(0);      src_comp = bbsrc_type(sourcetype, operation);      op = bbop(sourcetype, operation);      dstbpl = destbm->bmrasterwidth << 4;      if( sourcetype == TEXTURE_atom )D 4	{	  texture = args[10];	  wxoffset = ( args[11] == NIL_PTR ? 0 : args[11] & 0xFFFF );	  wyoffset = ( args[12] == NIL_PTR ? 0 : args[12] & 0xFFFF );	  sx = ((wxoffset) ? (dx - wxoffset) : dx) % BITSPERWORD;	  dstbase = (DLword *)	      Addr68k_from_LADDR( ADDBASE( destbm->bmbase,	       destbm->bmrasterwidth * dty));	  gray = 1;	  if (texture == NIL_PTR)	    { /* White Shade */	      grayword[0] = 0;	      srcbase = &grayword[0];	      num_gray = 1;	      curr_gray_line = 0;	      goto do_it_now;	    }	  else if(IsNumber(texture))	    {	      if( (texture &= 0xffff) == 0)		{ /* White Shade */		  grayword[0] = 0;		  srcbase = &grayword[0];		  num_gray = 1;		  curr_gray_line = 0;		  goto do_it_now;		}	      else if(texture == 0xffff)		{ /* Black Shade */		  grayword[0] = 0xFFFF;		  srcbase = &grayword[0];		  num_gray = 1;		  curr_gray_line = 0;		  goto do_it_now;		}	      else		{ /* 4x4 */		  srcbase = base = (DLword *)(&grayword[0]);		  GETWORD(base++) = Expand4Bit(((texture >> 12) & 0xf));		  GETWORD(base++) = Expand4Bit(((texture >>  8) & 0xf));		  GETWORD(base++) = Expand4Bit(((texture >>  4) & 0xf));		  GETWORD(base++) = Expand4Bit((texture & 0xf));		  num_gray = 4;		  curr_gray_line = (dty + wyoffset) & 3;		  srcbase += curr_gray_line;		  goto do_it_now;		}	    }	  else	    { /* A bitmap that is 16 bits wide. */	      texture68k = (BITMAP *)Addr68k_from_LADDR(texture);	      srcbase = (DLword *)Addr68k_from_LADDR(texture68k->bmbase);	      num_gray = min( texture68k->bmheight, 16);	      curr_gray_line = (dty + wyoffset) % num_gray;	      srcbase += curr_gray_line;	      goto do_it_now;	    }	}      /* ; INPUT or INVERT	*/E 4I 4        {          texture = args[10];          wxoffset = ( args[11] == NIL_PTR ? 0 : args[11] & 0xFFFF );          wyoffset = ( args[12] == NIL_PTR ? 0 : args[12] & 0xFFFF );          sx = ((wxoffset) ? (dx - wxoffset) : dx) % BITSPERWORD;          dstbase = (DLword *)              Addr68k_from_LADDR( ADDBASE( destbm->bmbase,               destbm->bmrasterwidth * dty));          gray = 1;          if (texture == NIL_PTR)            { /* White Shade */              grayword[0] = 0;              srcbase = &grayword[0];              num_gray = 1;              curr_gray_line = 0;              goto do_it_now;            }          else if(IsNumber(texture))            {              if( (texture &= 0xffff) == 0)                { /* White Shade */                  grayword[0] = 0;                  srcbase = &grayword[0];                  num_gray = 1;                  curr_gray_line = 0;                  goto do_it_now;                }              else if(texture == 0xffff)                { /* Black Shade */                  grayword[0] = 0xFFFF;                  srcbase = &grayword[0];                  num_gray = 1;                  curr_gray_line = 0;                  goto do_it_now;                }              else                { /* 4x4 */                  srcbase = base = (DLword *)(&grayword[0]);                  GETWORD(base++) = Expand4Bit(((texture >> 12) & 0xf));                  GETWORD(base++) = Expand4Bit(((texture >>  8) & 0xf));                  GETWORD(base++) = Expand4Bit(((texture >>  4) & 0xf));                  GETWORD(base++) = Expand4Bit((texture & 0xf));                  num_gray = 4;                  curr_gray_line = (dty + wyoffset) & 3;                  srcbase += curr_gray_line;                  goto do_it_now;                }            }          else            { /* A bitmap that is 16 bits wide. */              texture68k = (BITMAP *)Addr68k_from_LADDR(texture);              srcbase = (DLword *)Addr68k_from_LADDR(texture68k->bmbase);              num_gray = min( texture68k->bmheight, 16);              curr_gray_line = (dty + wyoffset) % num_gray;              srcbase += curr_gray_line;              goto do_it_now;            }        }      /* ; INPUT or INVERT      */E 4      srcbpl = srcebm->bmrasterwidth << 4;      /* compute flags */      /* out for now      if(srcebm == destbm)      if(sty <= dty)      if(dty <= (sty + h))      if((sty != dty) || ((sx < dx) && (dx < (sx + w))))D 4			backwardflg = T;E 4I 4                        backwardflg = T;E 4      out for now */      /* compute flags */      if(srcebm != destbm);      else if(sty > dty);      else if(dty > (sty + h));      else if((sty != dty) ||D 4	      ((sx < dx) && (dx < (sx + w))))			backwardflg = T;E 4I 4              ((sx < dx) && (dx < (sx + w))))                        backwardflg = T;E 4      if (backwardflg)D 4	{		srcbase = ( DLword *)			Addr68k_from_LADDR( ADDBASE( srcebm->bmbase,			   srcebm->bmrasterwidth * (sty + h - 1)));		dstbase = (DLword *)			Addr68k_from_LADDR( ADDBASE( destbm->bmbase,			   destbm->bmrasterwidth * (dty + h - 1)));		srcbpl = 0 - srcbpl;		dstbpl = 0 - dstbpl;	}E 4I 4        {                srcbase = ( DLword *)                        Addr68k_from_LADDR( ADDBASE( srcebm->bmbase,                           srcebm->bmrasterwidth * (sty + h - 1)));                dstbase = (DLword *)                        Addr68k_from_LADDR( ADDBASE( destbm->bmbase,                           destbm->bmrasterwidth * (dty + h - 1)));                srcbpl = 0 - srcbpl;                dstbpl = 0 - dstbpl;        }E 4      elseD 4	{		srcbase = (DLword  *)			Addr68k_from_LADDR( ADDBASE( srcebm->bmbase,			   srcebm->bmrasterwidth * sty));		dstbase = (DLword *)			Addr68k_from_LADDR( ADDBASE( destbm->bmbase,			   destbm->bmrasterwidth * dty));	}#ifdef SUNDISPLAY	displayflg=n_new_cursorin(srcbase,sx,sty,w,h);#endif SUNDISPLAYE 4I 4        {                srcbase = (DLword  *)                        Addr68k_from_LADDR( ADDBASE( srcebm->bmbase,                           srcebm->bmrasterwidth * sty));                dstbase = (DLword *)                        Addr68k_from_LADDR( ADDBASE( destbm->bmbase,                           destbm->bmrasterwidth * dty));        }#ifdef REALCURSOR        displayflg=n_new_cursorin(srcbase,sx,sty,w,h);#endif /* REALCURSOR */E 4    }do_it_now:D 4	ScreenLocked=T;E 4I 4        ScreenLocked=T;E 4D 4#ifdef SUNDISPLAY	displayflg |= n_new_cursorin(dstbase,dx,dty,w,h);	if( displayflg ) HideCursor;#endif SUNDISPLAYE 4I 4#ifdef REALCURSOR        displayflg |= n_new_cursorin(dstbase,dx,dty,w,h);        if( displayflg ) HideCursor;#endif /* REALCURSOR */E 4I 4E 4#ifdef NEWBITBLTD 4	bitblt(srcbase, dstbase, sx, dx, w, h, srcbpl, dstbpl,		  backwardflg, src_comp, op, gray, num_gray, curr_gray_line);E 4I 4        bitblt(srcbase, dstbase, sx, dx, w, h, srcbpl, dstbpl,                  backwardflg, src_comp, op, gray, num_gray, curr_gray_line);E 4#elseD 4	new_bitblt_code;E 4I 4        new_bitblt_code;E 4#endifD 4#ifdef SUNDISPLAYE 4#ifdef DISPLAYBUFFER#ifdef COLORD 4	if( MonoOrColor == MONO_SCREEN )#endif COLOR	/* Copy the changed section of display bank to the frame buffer */	if (in_display_segment(dstbase))	  {/*	DBPRINT(("bltsub: x %d, y %d, w %d, h %d.\n",dx, dty, w,h)); */	    flush_display_region(dx, dty, w, h); 	  }E 4I 4        if( MonoOrColor == MONO_SCREEN )#endif /* COLOR */        /* Copy the changed section of display bank to the frame buffer */        if (in_display_segment(dstbase))          {/*      DBPRINT(("bltsub: x %d, y %d, w %d, h %d.\n",dx, dty, w,h)); */            flush_display_region(dx, dty, w, h);           }E 4#endifD 4	if( displayflg) ShowCursor;#endif SUNDISPLAYE 4I 4E 4#ifdef XWINDOWD 3	SIGoff;E 3I 3D 4	XLOCK;E 3	if (in_display_segment(dstbase))	    flush_display_region(dx, dty, w, h);	XFlush(Xdisplay);D 3	SIGon;E 3I 3	XUNLOCK;E 3#endif XWINDOWE 4I 4        SIGoff;        if (in_display_segment(dstbase))            flush_display_region(dx, dty, w, h);        XFlush(Xdisplay);        SIGon;#endif /* XWINDOW */E 4D 4	ScreenLocked=NIL;E 4I 4#ifdef DOS        /* Copy the changed section of display bank to the frame buffer */        if (in_display_segment(dstbase))          {/*      DBPRINT(("bltsub: x %d, y %d, w %d, h %d.\n",dx, dty, w,h)); */            flush_display_region(dx, dty, w, h);           }#endif /* DOS */E 4I 4#ifdef REALCURSOR        if( displayflg) ShowCursor;#endif /* REALCURSOR */        ScreenLocked=NIL;E 4} /* end of bitbltsub *//************************************************************************/D 4/*									*//*			n _ n e w _ c u r s o r i n			*//*									*//*	Is the cursor over the spot we're about to change on the	*//*	screen?								*//*									*//*	This version takes a native address for the bitmap base,	*//*	plus x, y, width, and height for the intended change area.	*//*	Returns T if the cursor overlaps the intended change, NIL	*//*	otherwise.							*//*									*/E 4I 4/*                                                                      *//*                      n _ n e w _ c u r s o r i n                     *//*                                                                      *//*      Is the cursor over the spot we're about to change on the        *//*      screen?                                                                 *//*                                                                      *//*      This version takes a native address for the bitmap base,        *//*      plus x, y, width, and height for the intended change area.      *//*      Returns T if the cursor overlaps the intended change, NIL       *//*      otherwise.                                                      *//*                                                                      */E 4/************************************************************************/#ifndef COLORD 4	/********************************************************/	/*							*/	/*		Monochrome-only version			*/	/*							*/	/********************************************************/E 4I 4        /********************************************************/        /*                                                      */        /*              Monochrome-only version                         */        /*                                                      */        /********************************************************/E 4n_new_cursorin(baseaddr,dx,dy,w,h)  register DLword *baseaddr;  register int dx,dy,w,h;  {    extern DLword *DisplayRegion68k;#ifdef INIT      init_kbd_startup; /* MUST START KBD FOR INIT BEFORE FIRST BITBLT */#endif    if((DisplayRegion68k <= baseaddr) && (baseaddr <=DISP_MAX_Address))      {D 4	if((dx < MOUSEXR)&&(dx + w > MOUSEXL) &&	   (dy < MOUSEYH)&&(dy + h > MOUSEYL)    ) return(T);	else return(NIL);E 4I 4        if((dx < MOUSEXR)&&(dx + w > MOUSEXL) &&           (dy < MOUSEYH)&&(dy + h > MOUSEYL)    ) return(T);        else return(NIL);E 4      }    else return(NIL);  }#elseD 4	/********************************************************/	/*							*/	/*		   Mono / color version			*/	/*							*/	/********************************************************/E 4I 4        /********************************************************/        /*                                                      */        /*                 Mono / color version                         */        /*                                                      */        /********************************************************/E 4n_new_cursorin(baseaddr,dx,dy,w,h)register DLword *baseaddr;register int dx,dy,w,h;{extern DLword *DisplayRegion68k,*ColorDisplayRegion68k;extern int MonoOrColor;#ifdef INIT      init_kbd_startup; /* MUST START KBD FOR INIT BEFORE FIRST BITBLT */#endifif(MonoOrColor == MONO_SCREEN){ /* in MONO screen */    if((DisplayRegion68k <= baseaddr) && (baseaddr <=DISP_MAX_Address)){        if((dx < MOUSEXR)&&(dx + w > MOUSEXL) &&D 4	   (dy < MOUSEYH)&&(dy + h > MOUSEYL)    )	 {   return(T);}E 4I 4           (dy < MOUSEYH)&&(dy + h > MOUSEYL)    )         {   return(T);}E 4        elseD 4	 {   return(NIL);}E 4I 4         {   return(NIL);}E 4     }     elseD 4	return(NIL);E 4I 4        return(NIL);E 4 } /* if for MONO end */else {/* in COLOR screen */    if((ColorDisplayRegion68k <= baseaddr) && (baseaddr <=COLOR_MAX_Address)){D 4	dx = dx >> 3;	/*printf("new_c in COLOR mx=%d my=%d x=%d y=%d\n"	,*EmMouseX68K,*EmMouseY68K,dx,dy);*/E 4I 4        dx = dx >> 3;        /*printf("new_c in COLOR mx=%d my=%d x=%d y=%d\n"        ,*EmMouseX68K,*EmMouseY68K,dx,dy);*/E 4        if((dx < MOUSEXR)&&(dx + w > MOUSEXL)&&(dy < MOUSEYH)D 4		&&(dy + h > MOUSEYL))	 { /*  printf("new_c T\n");*/  return(T);}E 4I 4                &&(dy + h > MOUSEYL))         { /*  printf("new_c T\n");*/  return(T);}E 4        elseD 4	 {   return(NIL);}E 4I 4         {   return(NIL);}E 4     }     elseD 4	return(NIL);E 4I 4        return(NIL);E 4 }}D 4#endif COLORE 4I 4#endif /* COLOR */E 4I 4E 4#define BITBLTBITMAP_argnum 14#define PUNT_TO_BITBLTBITMAP {\D 4	if(BITBLTBITMAP_index==0xffffffff){				\	   BITBLTBITMAP_index=get_package_atom("\\PUNT.BITBLT.BITMAP",	\						19,"INTERLISP",9, NIL); \	   if(BITBLTBITMAP_index==0xffffffff)				\		{error("BITBLTBITMAP install failed");			\		return;}  }						\	CurrentStackPTR +=(BITBLTBITMAP_argnum-1)*DLWORDSPER_CELL;	\	ccfuncall(BITBLTBITMAP_index,BITBLTBITMAP_argnum,3);return;}E 4I 4        if(BITBLTBITMAP_index==0xffffffff){                             \           BITBLTBITMAP_index=get_package_atom("\\PUNT.BITBLT.BITMAP",  \                                                19,"INTERLISP",9, NIL); \           if(BITBLTBITMAP_index==0xffffffff)                           \                {error("BITBLTBITMAP install failed");                  \                return;}  }                                             \        CurrentStackPTR +=(BITBLTBITMAP_argnum-1)*DLWORDSPER_CELL;      \        ccfuncall(BITBLTBITMAP_index,BITBLTBITMAP_argnum,3);return;}E 4 LispPTR BITBLTBITMAP_index;/************************************************************************/D 4/*									*//*			b i t b l t _ b i t m a p			*//*									*//*	C implementation of the Lisp function \BITBLT.BITMAP,		*//*	which does bitmap-to-bitmap cases of BITBLT, after BITBLT	*//*	does some setup and massaging first.				*//*									*//*	args[xx]: SourceBitmap						*//*	args[xx]: SourceLeft		Must be a SMALLPOSP		*//*	args[xx]: SourceBottom		Must be a SMALLPOSP		*//*	args[xx]: DestBitmap						*//*	args[xx]: DestLeft		Must be a SMALLPOSP		*//*	args[xx]: DestBottom		Must be a SMALLPOSP		*//*	args[xx]: Width			Must be a SMALLPOSP		*//*	args[xx]: height		Must be a SMALLPOSP		*//*	args[xx]: SourceType						*//*	args[xx]: Operation						*//*	args[xx]: Texture						*//*	args[xx]: ClippingRegion					*//*	args[xx]: ClippedSrcLeft	Must be a SMALLPOSP		*//*	args[xx]: ClippedSrcBottom	Must be a SMALLPOSP		*//*									*//*									*//*	SourceType must not be MERGE, which should be handled by	*//*	the lisp code in \BITBLT.BITMAP.				*//*	This func. can't handle COLOR & souecetype == MERGE case.	*//* 	It causes punting to \\PUNT.BITBLT.BITMAP.			*//*	Therefore SYSOUT must contain \\PUNT.BITBLT.BITMAP.		*//*									*/E 4I 4/*                                                                      *//*                      b i t b l t _ b i t m a p                       *//*                                                                      *//*      C implementation of the Lisp function \BITBLT.BITMAP,           *//*      which does bitmap-to-bitmap cases of BITBLT, after BITBLT       *//*      does some setup and massaging first.                            *//*                                                                      *//*      args[xx]: SourceBitmap                                          *//*      args[xx]: SourceLeft            Must be a SMALLPOSP             *//*      args[xx]: SourceBottom          Must be a SMALLPOSP             *//*      args[xx]: DestBitmap                                            *//*      args[xx]: DestLeft              Must be a SMALLPOSP             *//*      args[xx]: DestBottom            Must be a SMALLPOSP             *//*      args[xx]: Width                         Must be a SMALLPOSP             *//*      args[xx]: height                Must be a SMALLPOSP             *//*      args[xx]: SourceType                                            *//*      args[xx]: Operation                                             *//*      args[xx]: Texture                                               *//*      args[xx]: ClippingRegion                                        *//*      args[xx]: ClippedSrcLeft        Must be a SMALLPOSP             *//*      args[xx]: ClippedSrcBottom      Must be a SMALLPOSP             *//*                                                                      *//*                                                                      *//*      SourceType must not be MERGE, which should be handled by        *//*      the lisp code in \BITBLT.BITMAP.                                *//*      This func. can't handle COLOR & souecetype == MERGE case.       *//*      It causes punting to \\PUNT.BITBLT.BITMAP.                      *//*      Therefore SYSOUT must contain \\PUNT.BITBLT.BITMAP.             *//*                                                                      */E 4/************************************************************************/bitblt_bitmap(args)  LispPTR *args;  {    BITMAP *SourceBitmap, *DestBitmap;    int sleft, sbottom, dleft, dbottom, width, height, clipleft, clipbottom;    LispPTR clipreg, clipvalue;    int stodx, stody, right, top, destbits, sourcebits, left, bottom;    LispPTR sourcetype, operation, texture;    DLword *srcbase, *dstbase;    int dlx, dty, slx, sty, srcbpl, dstbpl, op, src_comp, backwardflg = 0,         displayflg = 0;    extern DLword MERGE_atom;/* Get arguments  and check the possibilities of PUNT */    SourceBitmap = (BITMAP *) Addr68k_from_LADDR(args[0]);    DestBitmap = (BITMAP *) Addr68k_from_LADDR(args[3]);/* It does not handle COLOR ..... maybe later */    if(((destbits = DestBitmap->bmbitperpixel) != 1) ||       ((sourcebits = SourceBitmap->bmbitperpixel) != 1))    { PUNT_TO_BITBLTBITMAP; }    sourcetype = args[8];    /* sourcetype == MERGE_atom case must be handled inD 4	Lisp func \\BITMAP.BITBLT */E 4I 4        Lisp func \\BITMAP.BITBLT */E 4    if( sourcetype == MERGE_atom)    {  PUNT_TO_BITBLTBITMAP; }    N_GETNUMBER(args[1], sleft, bad_arg);    N_GETNUMBER(args[2], sbottom, bad_arg);    N_GETNUMBER(args[4], dleft, bad_arg);    N_GETNUMBER(args[5], dbottom, bad_arg);    operation = args[9];    texture = args[10];    clipreg = args[11];    N_GETNUMBER(args[12], clipleft, bad_arg);    N_GETNUMBER(args[13], clipbottom, bad_arg);    top = DestBitmap->bmheight;    left = bottom = 0;    right = DestBitmap->bmwidth;    if (clipreg != NIL_PTR)      { /* clip the BITBLT using the clipping region supplied */D 4	register LispPTR clipvalue;	register int temp, cr_left, cr_bot;E 4I 4        register LispPTR clipvalue;        register int temp, cr_left, cr_bot;E 4D 4	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, cr_left, bad_arg);	left = max(left, cr_left);E 4I 4        clipvalue = car(clipreg);        N_GETNUMBER(clipvalue, cr_left, bad_arg);        left = max(left, cr_left);E 4D 4	clipreg = cdr(clipreg);	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, cr_bot, bad_arg);	bottom = max(bottom, cr_bot);E 4I 4        clipreg = cdr(clipreg);        clipvalue = car(clipreg);        N_GETNUMBER(clipvalue, cr_bot, bad_arg);        bottom = max(bottom, cr_bot);E 4D 4	clipreg = cdr(clipreg);	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, temp, bad_arg);	right = min(right, cr_left+temp);E 4I 4        clipreg = cdr(clipreg);        clipvalue = car(clipreg);        N_GETNUMBER(clipvalue, temp, bad_arg);        right = min(right, cr_left+temp);E 4D 4	clipreg = cdr(clipreg);	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, temp, bad_arg);	top = min(top, cr_bot+temp);E 4I 4        clipreg = cdr(clipreg);        clipvalue = car(clipreg);        N_GETNUMBER(clipvalue, temp, bad_arg);        top = min(top, cr_bot+temp);E 4      }    left = max(left, dleft);    bottom = max(bottom, dbottom);    if (args[6] != NIL_PTR)      {D 4	N_GETNUMBER(args[6], width, bad_arg);	right = min(right, dleft+width);E 4I 4        N_GETNUMBER(args[6], width, bad_arg);        right = min(right, dleft+width);E 4      }    if (args[7] != NIL_PTR)      {D 4	N_GETNUMBER(args[7], height, bad_arg);	top = min(top, dbottom+height);E 4I 4        N_GETNUMBER(args[7], height, bad_arg);        top = min(top, dbottom+height);E 4      }    stodx = dleft - sleft;    stody = dbottom - sbottom;    {      register int temp;      left = max(clipleft, max(0, left - stodx));      bottom = max(clipbottom, max(0, bottom - stody));      temp = SourceBitmap->bmwidth;      right = min(temp, min(right-stodx, clipleft+width));      temp = SourceBitmap->bmheight;      top = min(temp, min(top-stody, clipbottom+height));    }    if ( (right <= left) || (top <= bottom) ) return(NIL);    /*** PUT SOURCETYPE MERGE special code HERE ***/D 4	/**** See avobe, earler in this code check 		souecetype and punting. *****/E 4I 4        /**** See avobe, earler in this code check                 souecetype and punting. *****/E 4    if (sourcebits == destbits)      { /* not 1-bit-per-pixel, so adjust limits by pixel size */D 4	switch (sourcebits)	  {	    case 4:  left = left*4;		     right = right*4;		     stodx = stodx*4;		     /* Put color texture merge case here */		     break;E 4I 4        switch (sourcebits)          {            case 4:  left = left*4;                     right = right*4;                     stodx = stodx*4;                     /* Put color texture merge case here */                     break;E 4D 4	    case 8:  left = left*8;		     right = right*8;		     stodx = stodx*8;		     /* Put color texture merge case here */		     break;E 4I 4            case 8:  left = left*8;                     right = right*8;                     stodx = stodx*8;                     /* Put color texture merge case here */                     break;E 4D 4	    case 24: left = left*24;		     right = right*24;		     stodx = stodx*24;		     /* Put color texture merge case here */		     break;E 4I 4            case 24: left = left*24;                     right = right*24;                     stodx = stodx*24;                     /* Put color texture merge case here */                     break;E 4D 4	  }E 4I 4          }E 4      }    else      {D 4/*	DBPRINT(("BITBLT between bitmaps of different sizes, unimplemented.")); */	return(NIL); E 4I 4/*      DBPRINT(("BITBLT between bitmaps of different sizes, unimplemented.")); */        return(NIL); E 4      }    height = top - bottom;    width = right - left;    dty = DestBitmap->bmheight - (top + stody);    dlx = left + stodx;    sty = SourceBitmap->bmheight - top;    slx = left;    /*** Stolen from bitbltsub, to avoid the call overhead: ***/    src_comp = bbsrc_type(sourcetype, operation);    op = bbop(sourcetype, operation);    dstbpl = DestBitmap->bmrasterwidth << 4;D 4	E 4I 4        E 4      /* Sourcetype guaragneed not to be TEXTURE by BITBLT fn */    srcbpl = SourceBitmap->bmrasterwidth << 4;      /* compute flags */    if(SourceBitmap != DestBitmap);    else if(sty > dty);    else if(dty > (sty + height));    else if((sty != dty) || ((slx < dlx) && (dlx < (slx + width))))D 4	    backwardflg = T;E 4I 4            backwardflg = T;E 4    if (backwardflg)      {D 4	srcbase = ( DLword *)		Addr68k_from_LADDR( ADDBASE( SourceBitmap->bmbase,		   SourceBitmap->bmrasterwidth * (sty + height - 1)));	dstbase = (DLword *)		Addr68k_from_LADDR( ADDBASE( DestBitmap->bmbase,		   DestBitmap->bmrasterwidth * (dty + height - 1)));	srcbpl = 0 - srcbpl;	dstbpl = 0 - dstbpl;E 4I 4        srcbase = ( DLword *)                Addr68k_from_LADDR( ADDBASE( SourceBitmap->bmbase,                   SourceBitmap->bmrasterwidth * (sty + height - 1)));        dstbase = (DLword *)                Addr68k_from_LADDR( ADDBASE( DestBitmap->bmbase,                   DestBitmap->bmrasterwidth * (dty + height - 1)));        srcbpl = 0 - srcbpl;        dstbpl = 0 - dstbpl;E 4      }    else      {D 4	srcbase = (DLword  *)		Addr68k_from_LADDR( ADDBASE( SourceBitmap->bmbase,		   SourceBitmap->bmrasterwidth * sty));	dstbase = (DLword *)		Addr68k_from_LADDR( ADDBASE( DestBitmap->bmbase,		   DestBitmap->bmrasterwidth * dty));E 4I 4        srcbase = (DLword  *)                Addr68k_from_LADDR( ADDBASE( SourceBitmap->bmbase,                   SourceBitmap->bmrasterwidth * sty));        dstbase = (DLword *)                Addr68k_from_LADDR( ADDBASE( DestBitmap->bmbase,                   DestBitmap->bmrasterwidth * dty));E 4      }    displayflg=n_new_cursorin(srcbase,slx,sty,width,height);do_it_now:    ScreenLocked=T;D 4#ifdef SUNDISPLAYE 4I 4#ifdef REALCURSORE 4    displayflg |= n_new_cursorin(dstbase,dlx,dty,width,height);    if( displayflg ) HideCursor;D 4#endif  SUNDISPLAYE 4I 4#endif /*  REALCURSOR */E 4I 4E 4#ifdef NEWBITBLT    bitblt(srcbase, dstbase, slx, dlx, width, height, srcbpl, dstbpl,D 4	      backwardflg, src_comp, op, 0, 0, 0);E 4I 4              backwardflg, src_comp, op, 0, 0, 0);E 4#else#define gray 0#define dx dlx#define sx slx#define w width#define h height#define curr_gray_line dx#define num_gray 0    new_bitblt_code;#undef gray#undef dx#undef sx#undef w#undef h#undef curr_gray_line#undef num_gray#endifD 4#ifdef SUNDISPLAYE 4#ifdef DISPLAYBUFFER#ifdef COLOR    if( MonoOrColor == MONO_SCREEN )D 4#endif COLOR	/* Copy the changed section of display bank to the frame buffer */	if (in_display_segment(dstbase))E 4I 4#endif /* COLOR */        /* Copy the changed section of display bank to the frame buffer */        if (in_display_segment(dstbase))E 4      {D 4/*	DBPRINT(("bltsub: x %d, y %d, w %d, h %d.\n",dlx, dty, width,height));*/	    flush_display_region(dlx, dty, width, height);E 4I 4/*      DBPRINT(("bltsub: x %d, y %d, w %d, h %d.\n",dlx, dty, width,height));*/            flush_display_region(dlx, dty, width, height);E 4      }#endifD 4    if( displayflg) ShowCursor;#endif SUNDISPLAYE 4I 4E 4#ifdef XWINDOWD 3    SIGoff;E 3I 3D 4    XLOCK;E 4I 4    SIGoff;E 4E 3    if (in_display_segment(dstbase))D 4	    flush_display_region(dlx, dty, width, height);E 4I 4            flush_display_region(dlx, dty, width, height);E 4    XFlush(Xdisplay);D 3    SIGon;E 3I 3D 4    XUNLOCK;E 3#endif XWINDOWE 4I 4    SIGon;#endif /* XWINDOW */E 4I 4#ifdef DOS        /* Copy the changed section of display bank to the frame buffer */        if (in_display_segment(dstbase))          {/*      DBPRINT(("bltsub: x %d, y %d, w %d, h %d.\n",dx, dty, w,h)); */             flush_display_region(dlx, dty, width, height);           }#endif /* DOS */#ifdef REALCURSOR    if( displayflg) ShowCursor;#endif /* REALCURSOR */E 4    ScreenLocked=NIL;    return(ATOM_T); bad_arg:  return(NIL);  } /* end of bitblt_bitmap */#define BLTSHADEBITMAP_argnum 8#define PUNT_TO_BLTSHADEBITMAP {\D 4	if(BLTSHADEBITMAP_index==0xffffffff){				\	   BLTSHADEBITMAP_index=get_package_atom("\\PUNT.BLTSHADE.BITMAP"\				,21,"INTERLISP",9, NIL);		\	   if(BLTSHADEBITMAP_index==0xffffffff)				\		{error("BLTSHADEBITMAP install failed");		\		return;}  }						\	CurrentStackPTR +=(BLTSHADEBITMAP_argnum-1)*DLWORDSPER_CELL;	\	ccfuncall(BLTSHADEBITMAP_index,BLTSHADEBITMAP_argnum,3);return;}E 4I 4        if(BLTSHADEBITMAP_index==0xffffffff){                           \           BLTSHADEBITMAP_index=get_package_atom("\\PUNT.BLTSHADE.BITMAP"\                                ,21,"INTERLISP",9, NIL);                \           if(BLTSHADEBITMAP_index==0xffffffff)                                 \                {error("BLTSHADEBITMAP install failed");                \                return;}  }                                             \        CurrentStackPTR +=(BLTSHADEBITMAP_argnum-1)*DLWORDSPER_CELL;    \        ccfuncall(BLTSHADEBITMAP_index,BLTSHADEBITMAP_argnum,3);return;}E 4 LispPTR BLTSHADEBITMAP_index;/************************************************************************/D 4/*									*//*		    b i t s h a d e _ b i t m a p			*//*									*//*	C implementation of the Lisp function \BITSHADE.BITMAP,		*//*	which does bitmap-to-bitmap cases of BITSHADE, after BITSHADE	*//*	does some setup and massaging first.				*//*	This func. can't handle TEXTURE == LISTP or LITATOM case.	*//* 	It causes punting to \\PUNT.BLTSHADE.BITMAP.			*//*	Therefore SYSOUT must contain \\PUNT.BLTSHADE.BITMAP.		*//*									*//*	args[0]: Texture						*//*	args[1]: DestBitmap						*//*	args[2]: DestLeft		Must be a SMALLPOSP		*//*	args[3]: DestBottom		Must be a SMALLPOSP		*//*	args[4]: Width			Must be a SMALLPOSP		*//*	args[5]: height			Must be a SMALLPOSP		*//*	args[6]: Operation						*//*	args[7]: ClippingRegion						*//*									*//*	The numeric arguments are assumed to be SMALLPOSPs;		*//*	the result with anything else isn't guaranteed correct.		*//*	 This Func should punt if TEXTURE==LITATOM(NOT NIL) or LISTP	*//*		or DestBitmap's BPP !=1					*//*									*//*									*/E 4I 4/*                                                                      *//*                  b i t s h a d e _ b i t m a p                       *//*                                                                      *//*      C implementation of the Lisp function \BITSHADE.BITMAP,                 *//*      which does bitmap-to-bitmap cases of BITSHADE, after BITSHADE   *//*      does some setup and massaging first.                            *//*      This func. can't handle TEXTURE == LISTP or LITATOM case.       *//*      It causes punting to \\PUNT.BLTSHADE.BITMAP.                    *//*      Therefore SYSOUT must contain \\PUNT.BLTSHADE.BITMAP.           *//*                                                                      *//*      args[0]: Texture                                                *//*      args[1]: DestBitmap                                             *//*      args[2]: DestLeft               Must be a SMALLPOSP             *//*      args[3]: DestBottom             Must be a SMALLPOSP             *//*      args[4]: Width                  Must be a SMALLPOSP             *//*      args[5]: height                         Must be a SMALLPOSP             *//*      args[6]: Operation                                              *//*      args[7]: ClippingRegion                                                 *//*                                                                      *//*      The numeric arguments are assumed to be SMALLPOSPs;             *//*      the result with anything else isn't guaranteed correct.                 *//*       This Func should punt if TEXTURE==LITATOM(NOT NIL) or LISTP    *//*              or DestBitmap's BPP !=1                                         *//*                                                                      *//*                                                                      */E 4/************************************************************************/bitshade_bitmap(args)  LispPTR *args;  {    BITMAP *DestBitmap, *texture68k;    int dleft, dbottom, width, height, clipleft, clipbottom;    LispPTR clipreg;    int right, top, destbits, left, bottom, textureword;    LispPTR sourcetype, operation, texture;    DLword *srcbase, *dstbase, *base;    int dlx, dty, slx, sty, dstbpl, op, src_comp,          displayflg = 0;    int rasterwidth;    int num_gray, curr_gray_line;    DLword grayword[4];    texture = args[0];    {register temp;D 4	temp = GetTypeNumber(texture);	if (((temp== TYPE_LITATOM)&&(texture != NIL_PTR))||	     (temp == TYPE_LISTP))	{ PUNT_TO_BLTSHADEBITMAP;}E 4I 4        temp = GetTypeNumber(texture);        if (((temp== TYPE_LITATOM)&&(texture != NIL_PTR))||             (temp == TYPE_LISTP))        { PUNT_TO_BLTSHADEBITMAP;}E 4    }    DestBitmap = (BITMAP *) Addr68k_from_LADDR(args[1]);    if((destbits = DestBitmap->bmbitperpixel) != 1)D 4	{ PUNT_TO_BLTSHADEBITMAP;}E 4I 4        { PUNT_TO_BLTSHADEBITMAP;}E 4    N_GETNUMBER(args[2], dleft, bad_arg);    N_GETNUMBER(args[3], dbottom, bad_arg);    operation = args[6];    clipreg = args[7];    rasterwidth = DestBitmap->bmrasterwidth;    top = DestBitmap->bmheight;    left = bottom = 0;    right = DestBitmap->bmwidth;    if (clipreg != NIL_PTR)      { /* clip the BITBLT using the clipping region supplied */D 4	register LispPTR clipvalue;	register int temp, cr_left, cr_bot;E 4I 4        register LispPTR clipvalue;        register int temp, cr_left, cr_bot;E 4D 4	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, cr_left, bad_arg);	left = max(left, cr_left);E 4I 4        clipvalue = car(clipreg);        N_GETNUMBER(clipvalue, cr_left, bad_arg);        left = max(left, cr_left);E 4D 4	clipreg = cdr(clipreg);	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, cr_bot, bad_arg);	bottom = max(bottom, cr_bot);E 4I 4        clipreg = cdr(clipreg);        clipvalue = car(clipreg);        N_GETNUMBER(clipvalue, cr_bot, bad_arg);        bottom = max(bottom, cr_bot);E 4D 4	clipreg = cdr(clipreg);	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, temp, bad_arg);	right = min(right, cr_left+temp);E 4I 4        clipreg = cdr(clipreg);        clipvalue = car(clipreg);        N_GETNUMBER(clipvalue, temp, bad_arg);        right = min(right, cr_left+temp);E 4D 4	clipreg = cdr(clipreg);	clipvalue = car(clipreg);	N_GETNUMBER(clipvalue, temp, bad_arg);	top = min(top, cr_bot+temp);E 4I 4        clipreg = cdr(clipreg);        clipvalue = car(clipreg);        N_GETNUMBER(clipvalue, temp, bad_arg);        top = min(top, cr_bot+temp);E 4      }    left = max(left, dleft);    bottom = max(bottom, dbottom);    if (args[4] != NIL_PTR)      {D 4	N_GETNUMBER(args[4], width, bad_arg);	right = min(right, dleft+width);E 4I 4        N_GETNUMBER(args[4], width, bad_arg);        right = min(right, dleft+width);E 4      }    if (args[5] != NIL_PTR)      {D 4	N_GETNUMBER(args[5], height, bad_arg);	top = min(top, dbottom+height);E 4I 4        N_GETNUMBER(args[5], height, bad_arg);        top = min(top, dbottom+height);E 4      }    if ( (right <= left) || (top <= bottom) ) return(NIL);    height = top - bottom;    width = right - left;    dty = DestBitmap->bmheight - top;    if ( (dty < 0) || ((dty+height) > DestBitmap->bmheight)) error("dty bad.");    if ( (bottom < 0) ) error("bottom bad.");    if ((bottom > 2048)) error ("bottom suspicious");        /*** Stolen from bitbltsub, to avoid the call overhead: ***/      src_comp = bbsrc_type(0, operation);      op = bbop(0, operation);      dstbpl = rasterwidth << 4;    if ( (left < 0) || (right > dstbpl) ) error ("left/right bad.");D 4	E 4I 4        E 4      slx = left % BITSPERWORD;      dstbase = (DLword *)D 4	      Addr68k_from_LADDR( ADDBASE( DestBitmap->bmbase,	       (rasterwidth * dty)));E 4I 4              Addr68k_from_LADDR( ADDBASE( DestBitmap->bmbase,               (rasterwidth * dty)));E 4D 4	  if (GetTypeNumber(texture) == TYPE_LITATOM){		if(texture == NIL_PTR)	    	{ /* White Shade */	      	grayword[0] = 0;	      	srcbase = &grayword[0];	      	num_gray = 1;	      	curr_gray_line = 0;	      	goto do_it_now;	    	}		/* temp DEBUFG stuff */		else { print(texture); error("Should not!");}	}E 4I 4          if (GetTypeNumber(texture) == TYPE_LITATOM){                if(texture == NIL_PTR)                { /* White Shade */                grayword[0] = 0;                srcbase = &grayword[0];                num_gray = 1;                curr_gray_line = 0;                goto do_it_now;                }                /* temp DEBUFG stuff */                else { print(texture); error("Should not!");}        }E 4      else if(IsNumber(texture))D 4	{	  if( (texture &= 0xffff) == 0)	    { /* White Shade */	      grayword[0] = 0;	      srcbase = &grayword[0];	      num_gray = 1;	      curr_gray_line = 0;	    }	      else if(texture == 0xffff)	    { /* Black Shade */	      grayword[0] = 0xFFFF;	      srcbase = &grayword[0];	      num_gray = 1;	      curr_gray_line = 0;	    }	      else	    { /* 4x4 */	      srcbase = base = (DLword *)(&grayword[0]);	      GETWORD(base++) = Expand4Bit(((texture >> 12) & 0xf));	      GETWORD(base++) = Expand4Bit(((texture >>  8) & 0xf));	      GETWORD(base++) = Expand4Bit(((texture >>  4) & 0xf));	      GETWORD(base++) = Expand4Bit((texture & 0xf));	      num_gray = 4;	      curr_gray_line = (dty) & 3;	      srcbase += curr_gray_line;	    }	}      else	/**** Need to handle texture = listp case, too ***/	/* Listp case alway punt to LISP */	{ /* A bitmap that is 16 bits wide. */	  texture68k = (BITMAP *)Addr68k_from_LADDR(texture);	  srcbase = (DLword *)Addr68k_from_LADDR(texture68k->bmbase);	  num_gray = min( texture68k->bmheight, 16);	  curr_gray_line = (dty) % num_gray;	  srcbase += curr_gray_line;	}E 4I 4        {          if( (texture &= 0xffff) == 0)            { /* White Shade */              grayword[0] = 0;              srcbase = &grayword[0];              num_gray = 1;              curr_gray_line = 0;            }              else if(texture == 0xffff)            { /* Black Shade */              grayword[0] = 0xFFFF;              srcbase = &grayword[0];              num_gray = 1;              curr_gray_line = 0;            }              else            { /* 4x4 */              srcbase = base = (DLword *)(&grayword[0]);              GETWORD(base++) = Expand4Bit(((texture >> 12) & 0xf));              GETWORD(base++) = Expand4Bit(((texture >>  8) & 0xf));              GETWORD(base++) = Expand4Bit(((texture >>  4) & 0xf));              GETWORD(base++) = Expand4Bit((texture & 0xf));              num_gray = 4;              curr_gray_line = (dty) & 3;              srcbase += curr_gray_line;            }        }      else      /**** Need to handle texture = listp case, too ***/        /* Listp case alway punt to LISP */        { /* A bitmap that is 16 bits wide. */          texture68k = (BITMAP *)Addr68k_from_LADDR(texture);          srcbase = (DLword *)Addr68k_from_LADDR(texture68k->bmbase);          num_gray = min( texture68k->bmheight, 16);          curr_gray_line = (dty) % num_gray;          srcbase += curr_gray_line;        }E 4do_it_now:D 4	ScreenLocked=T;E 4I 4        ScreenLocked=T;E 4D 4#ifdef SUNDISPLAY	displayflg |= n_new_cursorin(dstbase,left,dty,width,height);	if( displayflg ) HideCursor;#endif SUNDISPLAYE 4I 4#ifdef REALCURSOR        displayflg |= n_new_cursorin(dstbase,left,dty,width,height);        if( displayflg ) HideCursor;#endif /* REALCURSOR */E 4I 4E 4#ifdef NEWBITBLTD 4	bitblt(srcbase, dstbase, slx, left, width, height, 0, dstbpl,		  0, src_comp, op, 1, num_gray, curr_gray_line);E 4I 4        bitblt(srcbase, dstbase, slx, left, width, height, 0, dstbpl,                  0, src_comp, op, 1, num_gray, curr_gray_line);E 4#else#define gray 1#define backwardflg 0#define srcbpl 0#define w width#define h height#define dx left#define sx slxD 4	new_bitblt_code;E 4I 4        new_bitblt_code;E 4#undef gray#undef backwardflg#undef srcbpl#undef w#undef h#undef dx#undef sx#endifD 4#ifdef SUNDISPLAYE 4#ifdef DISPLAYBUFFER#ifdef COLORD 4	if( MonoOrColor == MONO_SCREEN )#endif COLOR	/* Copy the changed section of display bank to the frame buffer */	if (in_display_segment(dstbase))	  {/*	DBPRINT(("bltsub: x %d, y %d, w %d, h %d.\n",left, dty, width,height));*/	    flush_display_region(left, dty, width, height);	  }E 4I 4        if( MonoOrColor == MONO_SCREEN )#endif /* COLOR */        /* Copy the changed section of display bank to the frame buffer */        if (in_display_segment(dstbase))          {/*      DBPRINT(("bltsub: x %d, y %d, w %d, h %d.\n",left, dty, width,height));*/            flush_display_region(left, dty, width, height);          }E 4#endifD 4	if( displayflg) ShowCursor;#endif  SUNDISPLAYE 4I 4E 4#ifdef XWINDOWD 3    SIGoff;E 3I 3D 4    XLOCK;E 4I 4    SIGoff;E 4E 3    if (in_display_segment(dstbase))      flush_display_region(left, dty, width, height);    XFlush(Xdisplay);D 3    SIGon;E 3I 3D 4    XUNLOCK;E 3#endif XWINDOWE 4I 4    SIGon;#endif /* XWINDOW */E 4D 4	ScreenLocked=NIL;E 4I 4#ifdef DOS        /* Copy the changed section of display bank to the frame buffer */        if (in_display_segment(dstbase))          {/*      DBPRINT(("bltsub: x %d, y %d, w %d, h %d.\n",dx, dty, w,h)); */            flush_display_region(left, dty, width, height);           }#endif /* DOS */E 4I 4#ifdef REALCURSOR        if( displayflg) ShowCursor;#endif /*  REALCURSOR */        ScreenLocked=NIL;E 4    return(ATOM_T); bad_arg:  return(NIL);  } /* end of bitshade_bitmap *//* * *D 4 ********	BLTCHAR	BLTCHAR	BLTCHAR	BLTCHAR	*********E 4I 4 ********       BLTCHAR         BLTCHAR         BLTCHAR         BLTCHAR         *********E 4 * *//** \BLTCHAR ****(freplace (PILOTBBT PBTDESTBIT) of LOCAL1 with LEFT)(freplace (PILOTBBT PBTWIDTH) of LOCAL1 with (IDIFFERENCE RIGHT LEFT))(freplace (PILOTBBT PBTSOURCEBIT) of LOCAL1 with    (IDIFFERENCED 4	(IPLUS (\GETBASE		    (ffetch (\DISPLAYDATA DDOFFSETSCACHE) of DISPLAYDATA)		    CHAR8CODE)	        LEFT)	CURX))E 4I 4        (IPLUS (\GETBASE                    (ffetch (\DISPLAYDATA DDOFFSETSCACHE) of DISPLAYDATA)                    CHAR8CODE)                LEFT)        CURX))E 4(\PILOTBITBLT LOCAL1 0)*********/#ifndef BYTESWAPI 4#ifdef BIGVME 4typedef  struct  {D 4	unsigned nil1		: 8;	unsigned pilotbbt	: 24;	unsigned nil2		: 8;	unsigned displaydata	: 24;	unsigned nil3		: 16;	unsigned char8code	: 16;	unsigned nil4		: 16;	unsigned curx		: 16;	unsigned nil5		: 16;	unsigned left		: 16;	unsigned nil6		: 16;	unsigned right		: 16;E 4I 4        unsigned nil1           : 4;        unsigned pilotbbt       : 28;        unsigned nil2           : 4;        unsigned displaydata    : 28;        unsigned nil3           : 16;        unsigned char8code      : 16;        unsigned nil4           : 16;        unsigned curx           : 16;        unsigned nil5           : 16;        unsigned left           : 16;        unsigned nil6           : 16;        unsigned right          : 16;E 4  } BLTC;#elsetypedef  struct  {D 4	unsigned pilotbbt	: 24;	unsigned nil1		: 8;	unsigned displaydata	: 24;	unsigned nil2		: 8;	unsigned char8code	: 16;	unsigned nil3		: 16;	unsigned curx		: 16;	unsigned nil4		: 16;	unsigned left		: 16;	unsigned nil5		: 16;	unsigned right		: 16;	unsigned nil6		: 16;E 4I 4        unsigned nil1           : 8;        unsigned pilotbbt       : 24;        unsigned nil2           : 8;        unsigned displaydata    : 24;        unsigned nil3           : 16;        unsigned char8code      : 16;        unsigned nil4           : 16;        unsigned curx           : 16;        unsigned nil5           : 16;        unsigned left           : 16;        unsigned nil6           : 16;        unsigned right          : 16;E 4  } BLTC;I 4#endif /* BIGVM */#else#ifdef BIGVMtypedef  struct  {        unsigned pilotbbt       : 28;        unsigned nil1           : 4;        unsigned displaydata    : 28;        unsigned nil2           : 4;        unsigned char8code      : 16;        unsigned nil3           : 16;        unsigned curx           : 16;        unsigned nil4           : 16;        unsigned left           : 16;        unsigned nil5           : 16;        unsigned right          : 16;        unsigned nil6           : 16;  } BLTC;#elsetypedef  struct  {        unsigned pilotbbt       : 24;        unsigned nil1           : 8;        unsigned displaydata    : 24;        unsigned nil2           : 8;        unsigned char8code      : 16;        unsigned nil3           : 16;        unsigned curx           : 16;        unsigned nil4           : 16;        unsigned left           : 16;        unsigned nil5           : 16;        unsigned right          : 16;        unsigned nil6           : 16;  } BLTC;#endif /* BIGVM */#endif /* BYTESWAP */E 4D 4#endif BYTESWAPE 4/************************************************************************/D 4/*									*//*				b l t c h a r				*//*									*//*	BITBLT character images onto a display stream.			*//*									*//*									*/E 4I 4/*                                                                      *//*                              b l t c h a r                           *//*                                                                      *//*      BITBLT character images onto a display stream.                  *//*                                                                      *//*                                                                      */E 4/************************************************************************/#ifndef prropstyleD 4	/********************************************************/	/*	       Non-PIXRECT version of the code		*/	/********************************************************/	E 4I 4        /********************************************************/        /*             Non-PIXRECT version of the code          */        /********************************************************/        E 4bltchar( args )D 4register BLTC	*args;		/*	args[0] :	PILOTBBT		 *	args[1] :	DISPLAYDATA		 *	args[2] :	CHAR8CODE		 *	args[3] :	CURX		 *	args[4] :	LEFT		 *	args[5] :	RIGHT		 */E 4I 4register BLTC   *args;                /*      args[0] :       PILOTBBT                 *      args[1] :       DISPLAYDATA                 *      args[2] :       CHAR8CODE                 *      args[3] :       CURX                 *      args[4] :       LEFT                 *      args[5] :       RIGHT                 */E 4{D 4	register PILOTBBT  *pbt;	register DISPLAYDATA	*dspdata;	int	base;	register int displayflg;E 4I 4        register PILOTBBT  *pbt;        register DISPLAYDATA    *dspdata;        int     base;        register int displayflg;E 4D 4	int w, h;	int backwardflg = 0, sx, dx, srcbpl, dstbpl, src_comp, op;	DLword *srcbase, *dstbase;	int gray = 0, num_gray = 0, curr_gray_line = 0;E 4I 4        int w, h;        int backwardflg = 0, sx, dx, srcbpl, dstbpl, src_comp, op;        DLword *srcbase, *dstbase;        int gray = 0, num_gray = 0, curr_gray_line = 0;E 4D 4	pbt	  = (PILOTBBT *)   Addr68k_from_LADDR( args->pilotbbt );	dspdata	  = (DISPLAYDATA *)Addr68k_from_LADDR( args->displaydata );E 4I 4        pbt       = (PILOTBBT *)   Addr68k_from_LADDR( args->pilotbbt );        dspdata           = (DISPLAYDATA *)Addr68k_from_LADDR( args->displaydata );E 4D 4	srcbase =(DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,						     pbt->pbtsourcelo));E 4I 4        srcbase =(DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,                                                     pbt->pbtsourcelo));E 4D 4	dstbase =(DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,						     pbt->pbtdestlo ));E 4I 4        dstbase =(DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,                                                     pbt->pbtdestlo ));E 4D 4	srcbpl = abs( pbt->pbtsourcebpl );	dstbpl = abs( pbt->pbtdestbpl );	h = pbt->pbtheight;	w = args->right - args->left;	if ((h <= 0) || (w <= 0)) return(0);E 4I 4        srcbpl = abs( pbt->pbtsourcebpl );        dstbpl = abs( pbt->pbtdestbpl );        h = pbt->pbtheight;        w = args->right - args->left;        if ((h <= 0) || (w <= 0)) return(0);E 4D 4	base = GETWORD( Addr68k_from_LADDR			(dspdata->ddoffsetscache + args->char8code));	sx = base + args->left - args->curx;	dx = args->left;E 4I 4        base = GETWORD( Addr68k_from_LADDR                        (dspdata->ddoffsetscache + args->char8code));        sx = base + args->left - args->curx;        dx = args->left;E 4D 4#ifdef SUNDISPLAY	/* if displayflg != 0 then source or destination is DisplayBitMap	 * Now we consider about only destination	 */	displayflg = cursorin(pbt->pbtdesthi,			     (pbt->pbtdestlo + (args->left >> 4)),			     (args->right - args->left),			      pbt->pbtheight,			      pbt->pbtbackward);#endif SUNDISPLAYE 4I 4#ifdef REALCURSOR        /* if displayflg != 0 then source or destination is DisplayBitMap         * Now we consider about only destination         */        displayflg = cursorin(pbt->pbtdesthi,                             (pbt->pbtdestlo + (args->left >> 4)),                             (args->right - args->left),                              pbt->pbtheight,                              pbt->pbtbackward);#endif /* REALCURSOR */E 4D 4	op = pbt->pbtoperation;	src_comp = pbt->pbtsourcetype;E 4D 4	ScreenLocked=T;E 4I 4        op = pbt->pbtoperation;        src_comp = pbt->pbtsourcetype;E 4D 4#ifdef SUNDISPLAY	if( displayflg )		HideCursor;#endif SUNDISPLAYE 4I 4        ScreenLocked=T;E 4I 4#ifdef REALCURSOR        if( displayflg )                HideCursor;#endif /* REALCURSOR */E 4#ifdef NEWBITBLTD 4	bitblt(srcbase, dstbase, sx, dx, w, h, srcbpl, dstbpl,		  backwardflg, src_comp, op, gray, num_gray, curr_gray_line);E 4I 4        bitblt(srcbase, dstbase, sx, dx, w, h, srcbpl, dstbpl,                  backwardflg, src_comp, op, gray, num_gray, curr_gray_line);E 4#elseD 4	new_char_bitblt_codeE 4I 4        new_char_bitblt_codeE 4#endifD 4#ifdef SUNDISPLAYE 4#ifdef DISPLAYBUFFER#ifdef COLOR    if( MonoOrColor == MONO_SCREEN )D 4#endif COLORE 4I 4#endif /* COLOR */E 4    if (in_display_segment(dstbase))      {D 4	flush_display_lineregion(dx,			     dstbase,			     w, h);E 4I 4        flush_display_lineregion(dx,                             dstbase,                             w, h);E 4      }#endifD 4	if( displayflg )		ShowCursor;#endif SUNDISPLAYE 4I 4E 4#ifdef XWINDOWD 3    SIGoff;E 3I 3D 4    XLOCK;E 4I 4    SIGoff;E 4E 3    if (in_display_segment(dstbase))D 4	flush_display_lineregion(dx, dstbase, w, h);D 3    SIGon;E 3I 3    XUNLOCK;E 3#endif XWINDOWE 4I 4        flush_display_lineregion(dx, dstbase, w, h);    SIGon;#endif /* XWINDOW */E 4D 4	ScreenLocked=NIL;E 4I 4#ifdef DOS    if (in_display_segment(dstbase))        flush_display_lineregion(dx, dstbase, w, h);#endif /* DOS */#ifdef REALCURSOR        if( displayflg )                ShowCursor;#endif /* REALCURSOR */        ScreenLocked=NIL;E 4}#else/* prropstyle */bltchar( args )D 4register BLTC	*args;		/*	args[0] :	PILOTBBT		 *	args[1] :	DISPLAYDATA		 *	args[2] :	CHAR8CODE		 *	args[3] :	CURX		 *	args[4] :	LEFT		 *	args[5] :	RIGHT		 */E 4I 4register BLTC   *args;                /*      args[0] :       PILOTBBT                 *      args[1] :       DISPLAYDATA                 *      args[2] :       CHAR8CODE                 *      args[3] :       CURX                 *      args[4] :       LEFT                 *      args[5] :       RIGHT                 */E 4{D 4	register PILOTBBT  *pbt;	register DISPLAYDATA	*dspdata;	int	x, y,  destbpl, srcebpl, srcebit, distance;	int	base;	register int displayflg;	unsigned int pix_op;	DLword *dstbase;E 4I 4        register PILOTBBT  *pbt;        register DISPLAYDATA    *dspdata;        int     x, y,  destbpl, srcebpl, srcebit, distance;        int     base;        register int displayflg;        unsigned int pix_op;        DLword *dstbase;E 4D 4	pbt	  = (PILOTBBT *)   Addr68k_from_LADDR( args->pilotbbt );	dspdata	  = (DISPLAYDATA *)Addr68k_from_LADDR( args->displaydata );E 4I 4        pbt       = (PILOTBBT *)   Addr68k_from_LADDR( args->pilotbbt );        dspdata           = (DISPLAYDATA *)Addr68k_from_LADDR( args->displaydata );E 4D 4	(mpr_d(SrcePixRect))->md_image =	 (short *)Addr68k_from_LADDR(VAG2( pbt->pbtsourcehi, pbt->pbtsourcelo));E 4I 4        (mpr_d(SrcePixRect))->md_image =         (short *)Addr68k_from_LADDR(VAG2( pbt->pbtsourcehi, pbt->pbtsourcelo));E 4D 4	dstbase = (mpr_d(DestPixRect))->md_image =	 (short *)Addr68k_from_LADDR(VAG2( pbt->pbtdesthi,   pbt->pbtdestlo ));E 4I 4        dstbase = (mpr_d(DestPixRect))->md_image =         (short *)Addr68k_from_LADDR(VAG2( pbt->pbtdesthi,   pbt->pbtdestlo ));E 4D 4	SrcePixRect->pr_width  = srcebpl = abs( pbt->pbtsourcebpl );	DestPixRect->pr_width  = destbpl = abs( pbt->pbtdestbpl );	SrcePixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 4I 4        SrcePixRect->pr_width  = srcebpl = abs( pbt->pbtsourcebpl );        DestPixRect->pr_width  = destbpl = abs( pbt->pbtdestbpl );        SrcePixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 4#ifdef I386D 4	/* Need to take care of byte order, because display bank */	/* on the 386 is NOT bit reversed.... */	if (IN_DISPLAY_BANK(pbt->pbtsourcehi))	  mpr_d(SrcePixRect)->md_flags |= MP_I386;	 else mpr_d(SrcePixRect)->md_flags &= (~MP_I386);	if (IN_DISPLAY_BANK(pbt->pbtdesthi))	  mpr_d(DestPixRect)->md_flags |= MP_I386;	 else mpr_d(DestPixRect)->md_flags &= (~MP_I386);#endif I386E 4I 4        /* Need to take care of byte order, because display bank */        /* on the 386 is NOT bit reversed.... */        if (IN_DISPLAY_BANK(pbt->pbtsourcehi))          mpr_d(SrcePixRect)->md_flags |= MP_I386;         else mpr_d(SrcePixRect)->md_flags &= (~MP_I386);        if (IN_DISPLAY_BANK(pbt->pbtdesthi))          mpr_d(DestPixRect)->md_flags |= MP_I386;         else mpr_d(DestPixRect)->md_flags &= (~MP_I386);#endif /* I386 */E 4D 4	mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;	mpr_mdlinebytes(SrcePixRect) = (srcebpl + 7) >> 3;E 4D 4	base = GETWORD( Addr68k_from_LADDR			(dspdata->ddoffsetscache + args->char8code));	srcebit = base + args->left - args->curx;E 4I 4        mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;        mpr_mdlinebytes(SrcePixRect) = (srcebpl + 7) >> 3;E 4D 4#ifdef SUNDISPLAY	/* if displayflg != 0 then source or destination is DisplayBitMap	 * Now we consider about only destination	 */	displayflg = old_cursorin(pbt->pbtdesthi, pbt->pbtdestlo,			args->left,			(args->right - args->left),			pbt->pbtheight, y, pbt->pbtbackward);#endif SUNDISPLAYE 4I 4        base = GETWORD( Addr68k_from_LADDR                        (dspdata->ddoffsetscache + args->char8code));        srcebit = base + args->left - args->curx;E 4I 4#ifdef REALCURSOR        /* if displayflg != 0 then source or destination is DisplayBitMap         * Now we consider about only destination         */        displayflg = old_cursorin(pbt->pbtdesthi, pbt->pbtdestlo,                        args->left,                        (args->right - args->left),                        pbt->pbtheight, y, pbt->pbtbackward);#endif /* REALCURSOR */E 4/**** for DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG *****/D 4/*	displayflg = T;					*/E 4I 4/*      displayflg = T;                                         */E 4/**** for DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG *****/D 4	pix_op = PixOperation( pbt->pbtsourcetype, pbt->pbtoperation );E 4I 4        pix_op = PixOperation( pbt->pbtsourcetype, pbt->pbtoperation );E 4D 4	ScreenLocked=T;E 4I 4        ScreenLocked=T;E 4D 4#ifdef SUNDISPLAY	if( displayflg )		HideCursor;#endif SUNDISPLAYE 4I 4#ifdef REALCURSOR        if( displayflg )                HideCursor;#endif /* REALCURSOR */E 4D 4	if(pr_rop( DestPixRect, args->left, 0,			   (args->right - args->left),pbt->pbtheight, pix_op,			   SrcePixRect, srcebit, 0) != 0)		error("pilotbitblt: pr_rop failed\n");E 4D 4#ifdef SUNDISPLAYE 4I 4        if(pr_rop( DestPixRect, args->left, 0,                           (args->right - args->left),pbt->pbtheight, pix_op,                           SrcePixRect, srcebit, 0) != 0)                error("pilotbitblt: pr_rop failed\n");E 4#ifdef DISPLAYBUFFER#ifdef COLORD 4	if( MonoOrColor == MONO_SCREEN )#endif COLOR	if (in_display_segment(dstbase))	  {/*	    DBPRINT(("bltchar pix:  x %x, y %d, w %d, h %d.\n", args->left, dstbase, (args->right - args->left),pbt->pbtheight)); */	    flush_display_lineregion(args->left, dstbase, (args->right - args->left),pbt->pbtheight);	  }E 4I 4        if( MonoOrColor == MONO_SCREEN )#endif /* COLOR */        if (in_display_segment(dstbase))          {/*          DBPRINT(("bltchar pix:  x %x, y %d, w %d, h %d.\n", args->left, dstbase, (args->right - args->left),pbt->pbtheight)); */            flush_display_lineregion(args->left, dstbase, (args->right - args->left),pbt->pbtheight);          }E 4#endifD 4	if( displayflg )		ShowCursor;#endif SUNDISPLAYE 4I 4E 4#ifdef XWINDOWD 4	if (in_display_segment(dstbase))	    flush_display_lineregion(args->left, dstbase, (args->right - args->left),pbt->pbtheight);#endif XWINDOWE 4I 4        if (in_display_segment(dstbase))            flush_display_lineregion(args->left, dstbase, (args->right - args->left),pbt->pbtheight);#endif /* XWINDOW */#ifdef DOS    if (in_display_segment(dstbase))        flush_display_lineregion(dx, dstbase, w, h);#endif /* DOS */E 4D 4	ScreenLocked=NIL;E 4I 4#ifdef REALCURSOR        if( displayflg )                ShowCursor;#endif /* REALCURSOR */        ScreenLocked=NIL;E 4}#endif/************************************************************************/D 4/*									*//*			    n e w b l t c h a r				*//*									*//*	BITBLT character images onto a display stream.  This version	*//*	handles clipping in the C code, and checks for changes of	*//*	character set and hitting the right margin.  In either of	*//*	those cases, it punts to the old LISP code for BLTCHAR.	It	*//*	also punts if the display stream we're writing to isn't for	*//*	the top window on the screen's window stack.			*//*									*/E 4I 4/*                                                                      *//*                          n e w b l t c h a r                                 *//*                                                                      *//*      BITBLT character images onto a display stream.  This version    *//*      handles clipping in the C code, and checks for changes of       *//*      character set and hitting the right margin.  In either of       *//*      those cases, it punts to the old LISP code for BLTCHAR.         It      *//*      also punts if the display stream we're writing to isn't for     *//*      the top window on the screen's window stack.                    *//*                                                                      */E 4/************************************************************************/#define BLTCHAR_argnum 3#ifndef INITD 4#define PUNT_TO_BLTCHAR 						\  {									\    if ((BLTCHAR_index==0))						\      {									\	BLTCHAR_index = get_package_atom("\\MAIKO.PUNTBLTCHAR",18, 	\					 "INTERLISP",9, NIL);		\	if (BLTCHAR_index == 0xffffffff) 				\	  { 								\	    error("\\MAIKO.PUNTBLTCHAR install failed");		\	    return;							\	  }  								\      } 								\    CurrentStackPTR +=(BLTCHAR_argnum-1)*DLWORDSPER_CELL;	 	\    ccfuncall(BLTCHAR_index,BLTCHAR_argnum,3); 				\    return; 								\E 4I 4#define PUNT_TO_BLTCHAR                                                 \  {                                                                     \    if ((BLTCHAR_index==0))                                             \      {                                                                 \        BLTCHAR_index = get_package_atom("\\MAIKO.PUNTBLTCHAR",18,      \                                         "INTERLISP",9, NIL);           \        if (BLTCHAR_index == 0xffffffff)                                \          {                                                             \            error("\\MAIKO.PUNTBLTCHAR install failed");                \            return;                                                     \          }                                                             \      }                                                                 \    CurrentStackPTR +=(BLTCHAR_argnum-1)*DLWORDSPER_CELL;               \    ccfuncall(BLTCHAR_index,BLTCHAR_argnum,3);                          \    return;                                                             \E 4  }#elseD 4#define PUNT_TO_BLTCHAR 						\  { /* Version that is silent instead of erroring for init */		\    if ((BLTCHAR_index==0))						\      {									\	BLTCHAR_index = get_package_atom("\\MAIKO.PUNTBLTCHAR",18, 	\					 "INTERLISP",9, NIL);		\	if (BLTCHAR_index == 0xffffffff) 				\	  { 								\	 /*   error("\\MAIKO.PUNTBLTCHAR install failed");	*/	\	    return;							\	  }  								\      } 								\    CurrentStackPTR +=(BLTCHAR_argnum-1)*DLWORDSPER_CELL;	 	\    ccfuncall(BLTCHAR_index,BLTCHAR_argnum,3); 				\    return; 								\E 4I 4#define PUNT_TO_BLTCHAR                                                 \  { /* Version that is silent instead of erroring for init */           \    if ((BLTCHAR_index==0))                                             \      {                                                                 \        BLTCHAR_index = get_package_atom("\\MAIKO.PUNTBLTCHAR",18,      \                                         "INTERLISP",9, NIL);           \        if (BLTCHAR_index == 0xffffffff)                                \          {                                                             \         /*   error("\\MAIKO.PUNTBLTCHAR install failed");      */      \            return;                                                     \          }                                                             \      }                                                                 \    CurrentStackPTR +=(BLTCHAR_argnum-1)*DLWORDSPER_CELL;               \    ccfuncall(BLTCHAR_index,BLTCHAR_argnum,3);                          \    return;                                                             \E 4  }D 4#endif INITE 4I 4#endif /* INIT */E 4I 4E 4#define TEDIT_BLTCHAR_argnum 6#define PUNT_TO_TEDIT_BLTCHAR {\D 4	if(TEDIT_BLTCHAR_index==0xffffffff){				\	   TEDIT_BLTCHAR_index=get_package_atom("\\TEDIT.BLTCHAR",14,"INTERLISP",9, NIL); \	   if(TEDIT_BLTCHAR_index==0xffffffff)				\		{error("TEDIT install failed");				\		return;}  }						\	CurrentStackPTR +=(TEDIT_BLTCHAR_argnum-1)*DLWORDSPER_CELL;	\	ccfuncall(TEDIT_BLTCHAR_index,TEDIT_BLTCHAR_argnum,3);return;}E 4I 4        if(TEDIT_BLTCHAR_index==0xffffffff){                            \           TEDIT_BLTCHAR_index=get_package_atom("\\TEDIT.BLTCHAR",14,"INTERLISP",9, NIL); \           if(TEDIT_BLTCHAR_index==0xffffffff)                          \                {error("TEDIT install failed");                                 \                return;}  }                                             \        CurrentStackPTR +=(TEDIT_BLTCHAR_argnum-1)*DLWORDSPER_CELL;     \        ccfuncall(TEDIT_BLTCHAR_index,TEDIT_BLTCHAR_argnum,3);return;}E 4#define FGetNum(ptr, place) { \D 4	     if(((ptr) & 0xff0000)== S_POSITIVE) {(place) = ((ptr) & 0xffff);}\	else if(((ptr) & 0xff0000)== S_NEGATIVE) {(place) = (int)((ptr)| 0xffff0000);}\	else {PUNT_TO_BLTCHAR;}}E 4I 4             if(((ptr) & SEGMASK)== S_POSITIVE) {(place) = ((ptr) & 0xffff);}\        else if(((ptr) & SEGMASK)== S_NEGATIVE) {(place) = (int)((ptr)| 0xffff0000);}\        else {PUNT_TO_BLTCHAR;}}E 4#define FGetNum2(ptr, place) { \D 4	     if(((ptr) & 0xff0000)== S_POSITIVE) {(place) = ((ptr) & 0xffff);}\	else if(((ptr) & 0xff0000)== S_NEGATIVE) {(place) = (int)((ptr)| 0xffff0000);}\	else {return(-1);}}E 4I 4             if(((ptr) & SEGMASK)== S_POSITIVE) {(place) = ((ptr) & 0xffff);}\        else if(((ptr) & SEGMASK)== S_NEGATIVE) {(place) = (int)((ptr)| 0xffff0000);}\        else {return(-1);}}E 4D 4LispPTR *TOPWDS68k;		/* Top of window stack's DS */LispPTR BLTCHAR_index;		/* Atom # for \PUNTBLTCHAR punt fn */LispPTR TEDIT_BLTCHAR_index;	/* if NIL ,TEDIT is not yet loaded */E 4I 4LispPTR *TOPWDS68k;             /* Top of window stack's DS */LispPTR BLTCHAR_index;          /* Atom # for \PUNTBLTCHAR punt fn */LispPTR TEDIT_BLTCHAR_index;    /* if NIL ,TEDIT is not yet loaded */E 4D 4	/****************************************/	/*					*/	/*	Arguments to NEWBLTCHAR		*/	/*					*/	/****************************************/E 4I 4        /****************************************/        /*                                      */        /*      Arguments to NEWBLTCHAR                 */        /*                                      */        /****************************************/E 4#ifndef BYTESWAPtypedef struct {D 4	DLword	 nil;			/* Unused word */	unsigned charset	: 8;	/* High 8 bits of character code */	unsigned char8code	: 8;	/* Low 8 bits of character code  */	LispPTR displaystream;		/* The display stream to print on */	LispPTR displaydata;		/* The image data (margins, etc)  */E 4I 4        DLword   nil;                   /* Unused word */        unsigned charset        : 8;    /* High 8 bits of character code */        unsigned char8code      : 8;    /* Low 8 bits of character code  */        LispPTR displaystream;          /* The display stream to print on */        LispPTR displaydata;            /* The image data (margins, etc)  */E 4} BLTARG;#elsetypedef struct {D 4	unsigned char8code	: 8;	/* Low 8 bits of character code  */	unsigned charset	: 8;	/* High 8 bits of character code */	DLword	 nil;			/* Unused word */	LispPTR displaystream;		/* The display stream to print on */	LispPTR displaydata;		/* The image data (margins, etc)  */E 4I 4        unsigned char8code      : 8;    /* Low 8 bits of character code  */        unsigned charset        : 8;    /* High 8 bits of character code */        DLword   nil;                   /* Unused word */        LispPTR displaystream;          /* The display stream to print on */        LispPTR displaydata;            /* The image data (margins, etc)  */E 4} BLTARG;D 4#endif BYTESWAPE 4I 4#endif /* BYTESWAP */E 4I 4E 4#ifndef prropstyle/************************************************************************/D 4/*									*//*			    n e w b l t c h a r				*//*			   (non-PIXRECT version)			*//*									*/E 4I 4/*                                                                      *//*                          n e w b l t c h a r                                 *//*                         (non-PIXRECT version)                        *//*                                                                      */E 4/************************************************************************/newbltchar(args)  register BLTARG *args;  {    register DISPLAYDATA *displaydata68k;    int right, left, curx;    PILOTBBT *pbt;    int lmargin, rmargin, xoff;    int base;    int h, w;    int displayflg;    int backwardflg = 0, sx, dx, srcbpl, dstbpl, src_comp, op;    DLword *srcbase, *dstbase;    int gray = 0, num_gray = 0, curr_gray_line = 0;    displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);    if((displaydata68k->ddcharset & 0xFFFF) != args->charset)      {D 4	/*if(changecharset_display(displaydata68k, args->charset) ==-1)*/	PUNT_TO_BLTCHAR;E 4I 4        /*if(changecharset_display(displaydata68k, args->charset) ==-1)*/        PUNT_TO_BLTCHAR;E 4      }    if(displaydata68k->ddslowprintingcase)      {D 4	PUNT_TO_BLTCHAR; /** \SLOWBLTCHAR--return;**/E 4I 4        PUNT_TO_BLTCHAR; /** \SLOWBLTCHAR--return;**/E 4      }    FGetNum(displaydata68k->ddxposition,curx);    FGetNum(displaydata68k->ddrightmargin,rmargin);    FGetNum(displaydata68k->ddleftmargin,lmargin);    FGetNum(displaydata68k->ddxoffset,xoff);    right = curx + GETWORD((DLword*)Addr68k_from_LADDRD 4		(displaydata68k->ddcharimagewidths + args->char8code));E 4I 4                (displaydata68k->ddcharimagewidths + args->char8code));E 4    if((right> rmargin )&&(curx >lmargin)) PUNT_TO_BLTCHAR;    if(args->displaystream != *TOPWDS68k) PUNT_TO_BLTCHAR;    {      register int  newpos;      newpos = curx + GETWORD((DLword*)Addr68k_from_LADDRD 4	(displaydata68k->ddwidthscache + args->char8code ));E 4I 4        (displaydata68k->ddwidthscache + args->char8code ));E 4      if ((0 <= newpos) && (newpos < 65536))D 4	(displaydata68k->ddxposition) = (LispPTR)(S_POSITIVE | newpos);E 4I 4        (displaydata68k->ddxposition) = (LispPTR)(S_POSITIVE | newpos);E 4      else if(-65537 < newpos)D 4	(displaydata68k->ddxposition) = (LispPTR)(S_NEGATIVE | (0xffff & newpos));E 4I 4        (displaydata68k->ddxposition) = (LispPTR)(S_NEGATIVE | (0xffff & newpos));E 4      else {PUNT_TO_BLTCHAR;}    }    curx  += xoff;    right += xoff;    if(right > (int)(displaydata68k->ddclippingright))D 4		right =  displaydata68k->ddclippingright;E 4I 4                right =  displaydata68k->ddclippingright;E 4    if(curx >  (int)(displaydata68k->ddclippingleft))D 4		left = curx;E 4I 4                left = curx;E 4    else    left   = displaydata68k->ddclippingleft;    pbt= (PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);    h = pbt->pbtheight;    w = right - left;    if ((h <= 0) || (w <= 0)) return(0);    srcbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,D 4						      pbt->pbtsourcelo));E 4I 4                                                      pbt->pbtsourcelo));E 4    dstbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,D 4						      pbt->pbtdestlo ));E 4I 4                                                      pbt->pbtdestlo ));E 4    op       = pbt->pbtoperation;    src_comp = pbt->pbtsourcetype;    srcbpl = abs( pbt->pbtsourcebpl );    dstbpl = abs( pbt->pbtdestbpl );    base = GETWORD( Addr68k_from_LADDRD 4			(displaydata68k->ddoffsetscache + args->char8code));E 4I 4                        (displaydata68k->ddoffsetscache + args->char8code));E 4    sx = base + left - curx;    dx = left;    ScreenLocked=T;D 4#ifdef SUNDISPLAYE 4I 4#ifdef REALCURSORE 4    displayflg = ( cursorin(pbt->pbtdesthi, (pbt->pbtdestlo + (left >> 4)),D 4	      (right - left), pbt->pbtheight, pbt->pbtbackward) );E 4I 4              (right - left), pbt->pbtheight, pbt->pbtbackward) );E 4    if (displayflg) HideCursor;D 4#endif SUNDISPLAYE 4I 4#endif /* REALCURSOR */E 4I 4E 4#ifdef NEWBITBLT    bitblt(srcbase, dstbase, sx, dx, w, h, srcbpl, dstbpl,D 4	      backwardflg, src_comp, op, gray, num_gray, curr_gray_line);E 4I 4              backwardflg, src_comp, op, gray, num_gray, curr_gray_line);E 4#else    new_char_bitblt_code#endifD 4#ifdef SUNDISPLAYE 4#ifdef DISPLAYBUFFER#ifdef COLOR    if( MonoOrColor == MONO_SCREEN )D 4#endif COLORE 4I 4#endif /* COLOR */E 4    if (in_display_segment(dstbase))      {D 4/*	DBPRINT(("newbltchar:  x %d, y 0x%x, w %d, h %d.\n", dx, dstbase, w, h));*/	flush_display_lineregion(dx, dstbase, w, h);E 4I 4/*      DBPRINT(("newbltchar:  x %d, y 0x%x, w %d, h %d.\n", dx, dstbase, w, h));*/        flush_display_lineregion(dx, dstbase, w, h);E 4      }#endifD 4    if (displayflg) ShowCursor;#endif SUNDISPLAYE 4I 4E 4#ifdef XWINDOW    if (in_display_segment(dstbase))D 4	flush_display_lineregion(dx, dstbase, w, h);	#endif XWINDOWE 4I 4        flush_display_lineregion(dx, dstbase, w, h);    #endif /* XWINDOW */#ifdef DOS    if (in_display_segment(dstbase))        flush_display_lineregion(dx, dstbase, w, h);#endif /* DOS */#ifdef REALCURSOR    if (displayflg) ShowCursor;#endif /* REALCURSOR */E 4    ScreenLocked=NIL;  } /* end of newbltchar */#else  /* prropstyle *//************************************************************************/D 4/*									*//*			    n e w b l t c h a r				*//*			     (PIXRECT version)				*//*									*/E 4I 4/*                                                                      *//*                          n e w b l t c h a r                                 *//*                           (PIXRECT version)                          *//*                                                                      */E 4/************************************************************************/newbltchar(args)  register BLTARG *args;  {    register DISPLAYDATA *displaydata68k;    register int right,left,curx;    register PILOTBBT *pbt;    register int lmargin,rmargin,xoff;D 4    int displayflg;	/* T if cursor needs to be taken down */E 4I 4    int displayflg;     /* T if cursor needs to be taken down */E 4    displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);    if((displaydata68k->ddcharset & 0xFFFF) != args->charset)      {D 4	/* Currently, this has BUG, so I can't call it */	/*if(changecharset_display(displaydata68k,args->charset) ==-1)*/	{PUNT_TO_BLTCHAR;}E 4I 4        /* Currently, this has BUG, so I can't call it */        /*if(changecharset_display(displaydata68k,args->charset) ==-1)*/        {PUNT_TO_BLTCHAR;}E 4      }    if(displaydata68k->ddslowprintingcase)      {D 4	PUNT_TO_BLTCHAR; /** \SLOWBLTCHAR--return;**/E 4I 4        PUNT_TO_BLTCHAR; /** \SLOWBLTCHAR--return;**/E 4      }    FGetNum(displaydata68k->ddxposition, curx);    FGetNum(displaydata68k->ddrightmargin, rmargin);    FGetNum(displaydata68k->ddleftmargin, lmargin);    FGetNum(displaydata68k->ddxoffset, xoff);    right = curx + GETWORD((DLword*)Addr68k_from_LADDRD 4		(displaydata68k->ddcharimagewidths+ args->char8code));E 4I 4                (displaydata68k->ddcharimagewidths+ args->char8code));E 4    if((right> rmargin )&&(curx >lmargin)) PUNT_TO_BLTCHAR;    if(args->displaystream != *TOPWDS68k) PUNT_TO_BLTCHAR;    {      register int  newpos;      newpos = curx + GETWORD((DLword*)Addr68k_from_LADDRD 4		(displaydata68k->ddwidthscache + args->char8code ));E 4I 4                (displaydata68k->ddwidthscache + args->char8code ));E 4      if ((0 <= newpos) && (newpos < 65536))D 4	(displaydata68k->ddxposition) = (LispPTR)(S_POSITIVE | newpos);E 4I 4        (displaydata68k->ddxposition) = (LispPTR)(S_POSITIVE | newpos);E 4      else if(-65537 < newpos)D 4	(displaydata68k->ddxposition) = (LispPTR)(S_NEGATIVE | (0xffff & newpos));E 4I 4        (displaydata68k->ddxposition) = (LispPTR)(S_NEGATIVE | (0xffff & newpos));E 4      else {PUNT_TO_BLTCHAR;}    }    curx  += xoff;    right += xoff;    if(right > (int)(displaydata68k->ddclippingright))D 4		right =  displaydata68k->ddclippingright;E 4I 4                right =  displaydata68k->ddclippingright;E 4    if(curx >  (int)(displaydata68k->ddclippingleft))D 4		left = curx;E 4I 4                left = curx;E 4    else    left =   displaydata68k->ddclippingleft;    if(left <right)      {D 4	pbt= (PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);	if(pbt->pbtheight !=0)	  {	    /****** OLD bltchar *****/	    register int	destbpl, srcebpl, sourcebit;	    DLword * dstbase;	    int	base,y;E 4I 4        pbt= (PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);        if(pbt->pbtheight !=0)          {            /****** OLD bltchar *****/            register int        destbpl, srcebpl, sourcebit;            DLword * dstbase;            int         base,y;E 4D 4	    (mpr_d(SrcePixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,					     pbt->pbtsourcelo));E 4I 4            (mpr_d(SrcePixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,                                             pbt->pbtsourcelo));E 4D 4	    dstbase = (mpr_d(DestPixRect))->md_image = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,					      pbt->pbtdestlo ));E 4I 4            dstbase = (mpr_d(DestPixRect))->md_image = (short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,                                              pbt->pbtdestlo ));E 4D 4	    SrcePixRect->pr_width  = srcebpl = abs( pbt->pbtsourcebpl );	    DestPixRect->pr_width  = destbpl = abs( pbt->pbtdestbpl );	    SrcePixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 4I 4            SrcePixRect->pr_width  = srcebpl = abs( pbt->pbtsourcebpl );            DestPixRect->pr_width  = destbpl = abs( pbt->pbtdestbpl );            SrcePixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 4D 4#ifdef I386	    /* Need to take care of byte order, because display bank */	    /* on the 386 is NOT bit reversed.... */	    if (IN_DISPLAY_BANK(pbt->pbtsourcehi))	      mpr_d(SrcePixRect)->md_flags |= MP_I386;	     else mpr_d(SrcePixRect)->md_flags &= (~MP_I386);	    if (IN_DISPLAY_BANK(pbt->pbtdesthi))	      mpr_d(DestPixRect)->md_flags |= MP_I386;	     else mpr_d(DestPixRect)->md_flags &= (~MP_I386);#endif I386E 4D 4	    mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;	    mpr_mdlinebytes(SrcePixRect) = (srcebpl + 7) >> 3;E 4D 4	    base = GETBASE(Addr68k_from_LADDR(displaydata68k->ddoffsetscache), args->char8code);	    sourcebit = base + left - curx;E 4I 4            mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;            mpr_mdlinebytes(SrcePixRect) = (srcebpl + 7) >> 3;E 4D 4	   ScreenLocked=T;E 4I 4            base = GETBASE(Addr68k_from_LADDR(displaydata68k->ddoffsetscache), args->char8code);            sourcebit = base + left - curx;E 4I 4           ScreenLocked=T;E 4#ifdef SUNDISPLAYD 4	   if ( displayflg = old_cursorin(pbt->pbtdesthi, pbt->pbtdestlo,	      left, (right - left), pbt->pbtheight, y, pbt->pbtbackward) )	     {		HideCursor;		if(pr_rop( DestPixRect, left, 0,			   (right - left),pbt->pbtheight,			PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ),			   SrcePixRect, sourcebit, 0) != 0)			error("pilotbitblt: pr_rop failed\n");		/* Save SHOWCURSOR 'til after paint to screen */E 4I 4           if ( displayflg = old_cursorin(pbt->pbtdesthi, pbt->pbtdestlo,              left, (right - left), pbt->pbtheight, y, pbt->pbtbackward) )             {                HideCursor;                if(pr_rop( DestPixRect, left, 0,                           (right - left),pbt->pbtheight,                        PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ),                           SrcePixRect, sourcebit, 0) != 0)                        error("pilotbitblt: pr_rop failed\n");                /* Save SHOWCURSOR 'til after paint to screen */E 4#ifndef DISPLAYBUFFERD 4		ShowCursor;E 4I 4                ShowCursor;E 4#endifD 4	      } /* display case */	    else 	      {		if(pr_rop( DestPixRect, left, 0,			   (right - left),pbt->pbtheight,			PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ),			   SrcePixRect, sourcebit, 0) != 0)			error("pilotbitblt: pr_rop failed\n");E 4I 4              } /* display case */            else               {                if(pr_rop( DestPixRect, left, 0,                           (right - left),pbt->pbtheight,                        PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ),                           SrcePixRect, sourcebit, 0) != 0)                        error("pilotbitblt: pr_rop failed\n");E 4D 4	       } /* else */E 4I 4               } /* else */E 4#ifdef DISPLAYBUFFER#ifdef COLORD 4	if( MonoOrColor == MONO_SCREEN )#endif COLOR	if (in_display_segment(dstbase))E 4I 4        if( MonoOrColor == MONO_SCREEN )#endif /* COLOR */        if (in_display_segment(dstbase))E 4      {D 4/*		 DBPRINT(("newbltchar:  x %d, y 0x%x, w %d, h %d.\n", left, dstbase, (right - left), pbt->pbtheight)); */E 4I 4/*               DBPRINT(("newbltchar:  x %d, y 0x%x, w %d, h %d.\n", left, dstbase, (right - left), pbt->pbtheight)); */E 4D 4	flush_display_lineregion(left, dstbase, (right - left), pbt->pbtheight);	if (displayflg) ShowCursor; /* because hide is done earlier */E 4I 4        flush_display_lineregion(left, dstbase, (right - left), pbt->pbtheight);        if (displayflg) ShowCursor; /* because hide is done earlier */E 4      }#endifD 4#endif SUNDISPLAYE 4I 4#endif /* SUNDISPLAY */E 4I 4E 4#ifdef XWINDOW        if(pr_rop( DestPixRect, left, 0,D 4		   (right - left),pbt->pbtheight,		PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ),		   SrcePixRect, sourcebit, 0) != 0)		error("pilotbitblt: pr_rop failed\n");E 4I 4                   (right - left),pbt->pbtheight,                PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ),                   SrcePixRect, sourcebit, 0) != 0)                error("pilotbitblt: pr_rop failed\n");E 4D 4	if (in_display_segment(dstbase))	flush_display_lineregion(left, dstbase, (right - left), pbt->pbtheight);	#endif XWINDOWE 4I 4        if (in_display_segment(dstbase))        flush_display_lineregion(left, dstbase, (right - left), pbt->pbtheight);        #endif /* XWINDOW */E 4D 4	ScreenLocked=NIL;E 4I 4#ifdef DOS    if (in_display_segment(dstbase))        flush_display_lineregion(dx, dstbase, w, h);    if (displayflg) ShowCursor;#endif /* DOS */E 4D 4		/****** OLD bltchar *****/E 4I 4        ScreenLocked=NIL;E 4D 4		}E 4I 4                /****** OLD bltchar *****/E 4D 4	}E 4I 4                }        }E 4} /* newbltchar */#endif/******************************************************************/#ifndef BYTESWAPI 4#ifdef BIGVME 4typedef struct {D 4		LispPTR		FONTDEVICE;		LispPTR		SFObsolete1;		LispPTR		FONTFAMILY;		LispPTR		FONTSIZE;		LispPTR		FONTFACE;		LispPTR		SFObsolete2;		LispPTR		SFObsolete3;		LispPTR		SFObsolete4;		DLword		SFObsolete5;		DLword		SFObsolete6;		DLword		SFAscent;		DLword		SFDescent;		DLword		SFHeight;		DLword		ROTATION;		short		FBBOX;		short		FBBOY;		short		FBBDX;		short		FBBDY;		unsigned	SFFACECODE		: 8;		unsigned	SFLKerns		:24;		LispPTR		SFRWidths;		LispPTR		FONTDEVICESPEC;		LispPTR		OTHERDEVICEFONTPROPS;		LispPTR		FONTSCALE;		DLword		FONTAVGCHARWIDTH;		DLword		dum;		LispPTR		FONTIMAGEWIDTHS;		LispPTR		FONTCHARSETVECTOR;		LispPTR		FONTEXTRAFIELD2;E 4I 4                LispPTR                 FONTDEVICE;                LispPTR                 FONTFAMILY;                LispPTR                 FONTSIZE;                LispPTR                 FONTFACE;                DLword          SFAscent;                DLword          SFDescent;                DLword          SFHeight;                DLword          ROTATION;                short           FBBOX;                short           FBBOY;                short           FBBDX;                short           FBBDY;                LispPTR        SFLKerns;                LispPTR                 SFRWidths;                LispPTR                 FONTDEVICESPEC;                LispPTR                 OTHERDEVICEFONTPROPS;                LispPTR                 FONTSCALE;                unsigned        SFFACECODE              : 8;                unsigned        nil                :8;                DLword          FONTAVGCHARWIDTH;                LispPTR                 FONTIMAGEWIDTHS;                LispPTR                 FONTCHARSETVECTOR;                LispPTR                 FONTEXTRAFIELD2;E 4} FONTDESC;I 4#elsetypedef struct {                LispPTR                 FONTDEVICE;                LispPTR                 SFObsolete1;                LispPTR                 FONTFAMILY;                LispPTR                 FONTSIZE;                LispPTR                 FONTFACE;                LispPTR                 SFObsolete2;                LispPTR                 SFObsolete3;                LispPTR                 SFObsolete4;                DLword          SFObsolete5;                DLword          SFObsolete6;                DLword          SFAscent;                DLword          SFDescent;                DLword          SFHeight;                DLword          ROTATION;                short           FBBOX;                short           FBBOY;                short           FBBDX;                short           FBBDY;                unsigned        SFFACECODE              : 8;                unsigned        SFLKerns                :24;                LispPTR                 SFRWidths;                LispPTR                 FONTDEVICESPEC;                LispPTR                 OTHERDEVICEFONTPROPS;                LispPTR                 FONTSCALE;                DLword          FONTAVGCHARWIDTH;                DLword          dum;                LispPTR                 FONTIMAGEWIDTHS;                LispPTR                 FONTCHARSETVECTOR;                LispPTR                 FONTEXTRAFIELD2;} FONTDESC;#endif /* BIGVM */E 4typedef struct {D 4		LispPTR	WIDTHS;		LispPTR	OFFSETS;		LispPTR	IMAGEWIDTHS;		LispPTR	CHARSETBITMAP;		LispPTR	YWIDTHS;		DLword	CHARSETASCENT;		DLword	CHARSETDESCENT;		LispPTR	LEFTKERN;E 4I 4                LispPTR         WIDTHS;                LispPTR         OFFSETS;                LispPTR         IMAGEWIDTHS;                LispPTR         CHARSETBITMAP;                LispPTR         YWIDTHS;                DLword  CHARSETASCENT;                DLword  CHARSETDESCENT;                LispPTR         LEFTKERN;E 4 } CHARSETINFO;#elsetypedef struct {D 4		LispPTR		FONTDEVICE;		LispPTR		SFObsolete1;		LispPTR		FONTFAMILY;		LispPTR		FONTSIZE;		LispPTR		FONTFACE;		LispPTR		SFObsolete2;		LispPTR		SFObsolete3;		LispPTR		SFObsolete4;		DLword		SFObsolete6;		DLword		SFObsolete5;		DLword		SFDescent;		DLword		SFAscent;		DLword		ROTATION;		DLword		SFHeight;		short		FBBOY;		short		FBBOX;		short		FBBDY;		short		FBBDX;		unsigned	SFLKerns		:24;		unsigned	SFFACECODE		: 8;		LispPTR		SFRWidths;		LispPTR		FONTDEVICESPEC;		LispPTR		OTHERDEVICEFONTPROPS;		LispPTR		FONTSCALE;		DLword		dum;		DLword		FONTAVGCHARWIDTH;		LispPTR		FONTIMAGEWIDTHS;		LispPTR		FONTCHARSETVECTOR;		LispPTR		FONTEXTRAFIELD2;E 4I 4                LispPTR                 FONTDEVICE;                LispPTR                 SFObsolete1;                LispPTR                 FONTFAMILY;                LispPTR                 FONTSIZE;                LispPTR                 FONTFACE;                LispPTR                 SFObsolete2;                LispPTR                 SFObsolete3;                LispPTR                 SFObsolete4;                DLword          SFObsolete6;                DLword          SFObsolete5;                DLword          SFDescent;                DLword          SFAscent;                DLword          ROTATION;                DLword          SFHeight;                short           FBBOY;                short           FBBOX;                short           FBBDY;                short           FBBDX;                unsigned        SFLKerns                :24;                unsigned        SFFACECODE              : 8;                LispPTR                 SFRWidths;                LispPTR                 FONTDEVICESPEC;                LispPTR                 OTHERDEVICEFONTPROPS;                LispPTR                 FONTSCALE;                DLword          dum;                DLword          FONTAVGCHARWIDTH;                LispPTR                 FONTIMAGEWIDTHS;                LispPTR                 FONTCHARSETVECTOR;                LispPTR                 FONTEXTRAFIELD2;E 4} FONTDESC;typedef struct {D 4		LispPTR	WIDTHS;		LispPTR	OFFSETS;		LispPTR	IMAGEWIDTHS;		LispPTR	CHARSETBITMAP;		LispPTR	YWIDTHS;		DLword	CHARSETDESCENT;		DLword	CHARSETASCENT;		LispPTR	LEFTKERN;E 4I 4                LispPTR         WIDTHS;                LispPTR         OFFSETS;                LispPTR         IMAGEWIDTHS;                LispPTR         CHARSETBITMAP;                LispPTR         YWIDTHS;                DLword  CHARSETDESCENT;                DLword  CHARSETASCENT;                LispPTR         LEFTKERN;E 4 } CHARSETINFO;D 4#endif BYTESWAPE 4I 4#endif /* BYTESWAP */E 4I 4E 4#define IMIN(x,y)  (((x) > (y)) ? (y) : (x))#define IMAX(x,y)  (((x) > (y)) ? (x) : (y))/** changecharset_display,sfffixy are not tested *****I don't use TAKE **/changecharset_display(displaydata68k,charset)register DISPLAYDATA *displaydata68k;DLword charset;{ register PILOTBBT *pbt68k; register FONTDESC *fontd68k; LispPTR csinfo; register CHARSETINFO *csinfo68k; BITMAP *bm68k; LispPTR *base68k; pbt68k  =(PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt); fontd68k=(FONTDESC*)Addr68k_from_LADDR(displaydata68k->ddfont); base68k = (LispPTR*)Addr68k_from_LADDR(fontd68k->FONTCHARSETVECTOR); if((csinfo= *(base68k + charset)) == NIL ){D 4	return(-1); /* punt case */E 4I 4        return(-1); /* punt case */E 4 } csinfo68k =  (CHARSETINFO*)Addr68k_from_LADDR(csinfo);/* REF CNT */FRPLPTR(displaydata68k->ddwidthscache,     csinfo68k->WIDTHS);FRPLPTR(displaydata68k->ddoffsetscache,    csinfo68k->OFFSETS);FRPLPTR(displaydata68k->ddcharimagewidths, csinfo68k->IMAGEWIDTHS); displaydata68k->ddcharset = charset; bm68k =(BITMAP*)Addr68k_from_LADDR( csinfo68k->CHARSETBITMAP); pbt68k->pbtsourcebpl = (bm68k->bmrasterwidth) << 4; if((displaydata68k->ddcharsetascent  != csinfo68k->CHARSETASCENT) ||    (displaydata68k->ddcharsetdescent != csinfo68k->CHARSETDESCENT)) { printf("CCD1\n");     return(sfffixy(displaydata68k, csinfo68k,pbt68k )); } else {   register LispPTR addr;   register int num;   FGetNum2(displaydata68k->ddcharheightdelta,num);/* if not number, return -1 */   addr = bm68k->bmbase + (bm68k->bmrasterwidth * num);   printf("CCD2 num=%d\n",num);   pbt68k->pbtsourcehi= addr >> 16;   pbt68k->pbtsourcelo = addr;  /* don't care REFCNT */   return(T); }} /* changecharset_display */sfffixy(displaydata68k,csinfo68k,pbt68k)    DISPLAYDATA *displaydata68k;    CHARSETINFO *csinfo68k;    PILOTBBT *pbt68k;    {    int y;    int chartop,top;    BITMAP *bm68k;    register LispPTR base,ypos,yoff;    FGetNum2(displaydata68k->ddyoffset, yoff);    FGetNum2(displaydata68k->ddyposition, ypos);    y = ypos + yoff;    displaydata68k->ddcharsetascent=csinfo68k->CHARSETASCENT;    chartop = y + displaydata68k->ddcharsetascent;    bm68k=(BITMAP*)Addr68k_from_LADDR(displaydata68k->dddestination);    base = bm68k->bmbase;    top = IMAX( IMIN(displaydata68k->ddclippingtop, chartop), 0 );    base= base + (bm68k->bmrasterwidth * (bm68k->bmheight - top));    pbt68k->pbtdesthi= base >> 16;    pbt68k->pbtdestlo= base;    bm68k=(BITMAP*)Addr68k_from_LADDR(csinfo68k->CHARSETBITMAP);    base = bm68k->bmbase;    displaydata68k->ddcharheightdelta=D 4	IMIN( IMAX(chartop - top, 0), 65535 );/* always positive */E 4I 4        IMIN( IMAX(chartop - top, 0), 65535 );/* always positive */E 4    base = base + bm68k->bmrasterwidth * displaydata68k->ddcharheightdelta;    pbt68k->pbtsourcehi = base >> 16;    pbt68k->pbtsourcelo = base;    displaydata68k->ddcharsetdescent= csinfo68k->CHARSETDESCENT;    pbt68k->pbtheight = IMAX(0,     top-(IMAX( y- displaydata68k->ddcharsetdescent,displaydata68k->ddclippingbottom)));    return(T);   } /* sfffixy *//******************************************************************/ccfuncall(atom_index,argnum,bytenum)  register unsigned int atom_index;   /* Atomindex for Function you want to invoke */  register int argnum;   /* Number of ARGS on TOS and STK */  register int bytenum;  /* Number of bytes of Caller'sD 4			OPCODE(including multi-byte) */E 4I 4                        OPCODE(including multi-byte) */E 4{  register struct definition_cell *defcell68k;  /* Definition Cell PTR */  register short pv_num; /* scratch for pv */  register struct fnhead *tmp_fn;  int rest;  /* use for arignments */  int closurep=NIL;  register CClosure *closure68k;  /* Get Next Block offset from argnum */  CURRENTFX->nextblock = (LADDR_from_68k(CurrentStackPTR) & 0x0ffff)D 4					- (argnum<<1)+4 /* +3  */;E 4I 4                                        - (argnum<<1)+4 /* +3  */;E 4  /* Setup IVar */  IVar = Addr68k_from_LADDR((((LispPTR)(CURRENTFX->nextblock)) | STK_OFFSET));  /* Set PC to the Next Instruction and save into FX */  CURRENTFX->pc = ((unsigned int)PC - (unsigned int)FuncObj) + bytenum;  PushCStack;  /* save TOS */  /* Get DEFCELL 68k address */  defcell68k =(struct definition_cell *) GetDEFCELL68k(atom_index);  tmp_fn = (struct fnhead *)Addr68k_from_LADDR( defcell68k->defpointer );if((unsigned int)(CurrentStackPTR + tmp_fn->stkmin +STK_SAFE) >=  (unsigned int)EndSTKP )D 4	{E 4I 4        {E 4 LispPTR test;D 4		test= *((LispPTR*)CurrentStackPTR);		DOSTACKOVERFLOW(argnum,bytenum-1);		S_CHECK(test == *((LispPTR*)CurrentStackPTR),			"stack overflow in ccfuncall");	}E 4I 4                test= *((LispPTR*)CurrentStackPTR);                DOSTACKOVERFLOW(argnum,bytenum-1);                S_CHECK(test == *((LispPTR*)CurrentStackPTR),                        "stack overflow in ccfuncall");        }E 4  FuncObj = tmp_fn;I 3D 4  SWAPPED_FN_CHECK;E 3E 4 if( FuncObj->na >= 0 )  {D 4	/* This Function is Spread Type */	/* Arguments on Stack Adjustment  */	rest = argnum - FuncObj->na;E 4I 4        /* This Function is Spread Type */        /* Arguments on Stack Adjustment  */        rest = argnum - FuncObj->na;E 4D 4	while(rest <0) {	  PushStack(NIL_PTR);	  rest++;	}	CurrentStackPTR -= (rest<<1);E 4I 4        while(rest <0) {          PushStack(NIL_PTR);          rest++;        }        CurrentStackPTR -= (rest<<1);E 4  } /* if end */ /* Set up BF */CurrentStackPTR+=2; GETWORD(CurrentStackPTR) = BF_MARK; GETWORD(CurrentStackPTR+1) = CURRENTFX->nextblock;CurrentStackPTR+=2; /* Set up FX */ GETWORD(CurrentStackPTR) = FX_MARK; /* Now SET new FX */ ((struct frameex1 *)CurrentStackPTR)->alink = LADDR_from_68k(PVar); PVar = (DLword *)CurrentStackPTR + FRAMESIZE;I 4#ifdef BIGVM ((struct frameex1 *)CurrentStackPTR)->fnheader =        (defcell68k->defpointer);#elseE 4 ((struct frameex1 *)CurrentStackPTR)->lofnheader =D 4	(defcell68k->defpointer) & 0x0ffff;E 4I 4        (defcell68k->defpointer) & 0x0ffff;E 4 ((struct frameex1 *)CurrentStackPTR)->hi2fnheader =D 4	((defcell68k->defpointer) & 0x0ff0000) >> 16;E 4I 4        ((defcell68k->defpointer) & SEGMASK) >> 16;#endif /* BIGVM */E 4 CurrentStackPTR = PVar; /* Set up PVar area */ pv_num = FuncObj->pv+1; /* Changed Apr.27 */ while(pv_num > 0) {D 4	*((LispPTR *)CurrentStackPTR) = 0x0ffff0000;	CurrentStackPTR += DLWORDSPER_CELL;	*((LispPTR *)CurrentStackPTR) = 0x0ffff0000;	CurrentStackPTR += DLWORDSPER_CELL;	pv_num--;E 4I 4        *((LispPTR *)CurrentStackPTR) = 0x0ffff0000;        CurrentStackPTR += DLWORDSPER_CELL;        *((LispPTR *)CurrentStackPTR) = 0x0ffff0000;        CurrentStackPTR += DLWORDSPER_CELL;        pv_num--;E 4  } /* Set PC points New Function's first OPCODE */ PC = (ByteCode *)FuncObj + FuncObj->startpc; /* It assume that ccfuncall is called  for PUNTing from SUBRCALL */ PC -= 3 ; /* Ajust PC */} /* end ccfuncall *//****************************************************************//*                                                              *//*                        tedit_bltchar                         */D 4/*								*/E 4I 4/*                                                              */E 4/*     C-coded version of TEdit's character-painting function   */D 4/*		\\TEDIT.BLTCHAR					*//*								*/E 4I 4/*              \\TEDIT.BLTCHAR                                         *//*                                                              */E 4/****************************************************************/#ifndef BYTESWAPtypedef   struct tbta    {D 4	DLword       nil;	unsigned     charset	: 8;	unsigned     char8code	: 8;	LispPTR      displaystream;	unsigned int nil2 : 16;	unsigned int current_x : 16; /* this is allways positive */	LispPTR      displaydata;	LispPTR      ddpilotbitblt;	unsigned int nil3 : 16;	unsigned int clipright : 16;/* this is allways positive */E 4I 4        DLword       nil;        unsigned     charset    : 8;        unsigned     char8code  : 8;        LispPTR      displaystream;        unsigned int nil2 : 16;        unsigned int current_x : 16; /* this is allways positive */        LispPTR      displaydata;        LispPTR      ddpilotbitblt;        unsigned int nil3 : 16;        unsigned int clipright : 16;/* this is allways positive */E 4     } TBLTARG;#elsetypedef   struct tbta    {D 4	unsigned     char8code	: 8;	unsigned     charset	: 8;	DLword       nil;	LispPTR      displaystream;	unsigned int current_x : 16; /* this is allways positive */	unsigned int nil2 : 16;	LispPTR      displaydata;	LispPTR      ddpilotbitblt;	unsigned int clipright : 16;/* this is allways positive */	unsigned int nil3 : 16;E 4I 4        unsigned     char8code  : 8;        unsigned     charset    : 8;        DLword       nil;        LispPTR      displaystream;        unsigned int current_x : 16; /* this is allways positive */        unsigned int nil2 : 16;        LispPTR      displaydata;        LispPTR      ddpilotbitblt;        unsigned int clipright : 16;/* this is allways positive */        unsigned int nil3 : 16;E 4     } TBLTARG;D 4#endif BYTESWAPE 4I 4#endif /* BYTESWAP */E 4I 4E 4#ifndef prropstyleD 4	/***************************/	/*   Non-PIXRECT version   */	/***************************/E 4I 4        /***************************/        /*   Non-PIXRECT version   */        /***************************/E 4tedit_bltchar(args)  register TBLTARG *args;  {#define backwardflg 0#define displayflg 0    register DISPLAYDATA *displaydata68k;    int right;    register PILOTBBT *pbt;    int imagewidth, newx;    /* for new_char_bitblt_code */    int h, w;    int sx, dx, srcbpl, dstbpl, src_comp, op;    DLword *srcbase, *dstbase;    int gray = 0, num_gray = 0, curr_gray_line = 0;    displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);    if(displaydata68k->ddcharset != args->charset)      {D 4	/**if(changecharset_display(displaydata68k, args->charset)== -1)**/	{	   PUNT_TO_TEDIT_BLTCHAR;	}E 4I 4        /**if(changecharset_display(displaydata68k, args->charset)== -1)**/        {           PUNT_TO_TEDIT_BLTCHAR;        }E 4      }    imagewidth = *((DLword*)Addr68k_from_LADDRD 4		(displaydata68k->ddcharimagewidths+ args->char8code));E 4I 4                (displaydata68k->ddcharimagewidths+ args->char8code));E 4     newx =  args->current_x + imagewidth;     dx = IMAX(0,args->current_x );     right = IMIN(newx, args->clipright);     if(dx < right)      {D 4	pbt= (PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);	h = pbt->pbtheight;	srcbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,						      pbt->pbtsourcelo));E 4I 4        pbt= (PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);        h = pbt->pbtheight;        srcbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,                                                      pbt->pbtsourcelo));E 4D 4	dstbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,						      pbt->pbtdestlo ));	srcbpl = abs( pbt->pbtsourcebpl );	dstbpl = abs( pbt->pbtdestbpl );E 4I 4        dstbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi,                                                      pbt->pbtdestlo ));        srcbpl = abs( pbt->pbtsourcebpl );        dstbpl = abs( pbt->pbtdestbpl );E 4D 4	op = pbt->pbtoperation;	src_comp = pbt->pbtsourcetype;E 4I 4        op = pbt->pbtoperation;        src_comp = pbt->pbtsourcetype;E 4D 4	/*dx=left;  I'll optimize  later*/	sx = GETBASE(Addr68k_from_LADDR(displaydata68k->ddoffsetscache),		     args->char8code);	w= IMIN(imagewidth, (right-dx));E 4I 4        /*dx=left;  I'll optimize  later*/        sx = GETBASE(Addr68k_from_LADDR(displaydata68k->ddoffsetscache),                     args->char8code);        w= IMIN(imagewidth, (right-dx));E 4#ifdef NEWBITBLTD 4	bitblt(srcbase, dstbase, sx, dx, w, h, srcbpl, dstbpl,		  backwardflg, src_comp, op, gray, num_gray, curr_gray_line);E 4I 4        bitblt(srcbase, dstbase, sx, dx, w, h, srcbpl, dstbpl,                  backwardflg, src_comp, op, gray, num_gray, curr_gray_line);E 4#elseD 4	new_char_bitblt_code;E 4I 4        new_char_bitblt_code;E 4#endif      }#undef displayflg#undef backwardflg  } /* end tedit_bltchar */#else/* pr_op style */D 4	/**********************/	/*   PIXRECT version  */	/**********************/E 4I 4        /**********************/        /*   PIXRECT version  */        /**********************/E 4tedit_bltchar(args)  register TBLTARG *args;  {    register DISPLAYDATA *displaydata68k;    register int left,right;    register PILOTBBT *pbt;    register int imagewidth, newx;    register displayflg;    displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);    if(displaydata68k->ddcharset != args->charset)      {D 4	/**if(changecharset_display(displaydata68k, args->charset)== -1)**/	 {	   PUNT_TO_TEDIT_BLTCHAR;	 }E 4I 4        /**if(changecharset_display(displaydata68k, args->charset)== -1)**/         {           PUNT_TO_TEDIT_BLTCHAR;         }E 4      }    imagewidth = *((DLword*)Addr68k_from_LADDRD 4		   (displaydata68k->ddcharimagewidths+ args->char8code));E 4I 4                   (displaydata68k->ddcharimagewidths+ args->char8code));E 4     newx =  args->current_x + imagewidth;     left = IMAX(0,args->current_x );     right = IMIN(newx, args->clipright);     ScreenLocked=T;     if(left < right)      {        pbt= (PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);D 4	if( pbt->pbtheight)	  {	    (mpr_d(SrcePixRect))->md_image =		 (short *)Addr68k_from_LADDR(VAG2(pbt->pbtsourcehi,						  pbt->pbtsourcelo));E 4I 4        if( pbt->pbtheight)          {            (mpr_d(SrcePixRect))->md_image =                 (short *)Addr68k_from_LADDR(VAG2(pbt->pbtsourcehi,                                                  pbt->pbtsourcelo));E 4D 4	    (mpr_d(DestPixRect))->md_image =		(short *)Addr68k_from_LADDR(VAG2(pbt->pbtdesthi,						 pbt->pbtdestlo ));	      {		register int srcebpl,destbpl;		SrcePixRect->pr_width = srcebpl = abs( pbt->pbtsourcebpl );		DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );		SrcePixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 4I 4            (mpr_d(DestPixRect))->md_image =                (short *)Addr68k_from_LADDR(VAG2(pbt->pbtdesthi,                                                 pbt->pbtdestlo ));              {                register int srcebpl,destbpl;                SrcePixRect->pr_width = srcebpl = abs( pbt->pbtsourcebpl );                DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );                SrcePixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;E 4#ifdef I386D 4	/* Need to take care of byte order, because display bank */	/* on the 386 is NOT bit reversed.... */	if (IN_DISPLAY_BANK(pbt->pbtsourcehi))	  mpr_d(SrcePixRect)->md_flags |= MP_I386;	 else mpr_d(SrcePixRect)->md_flags &= (~MP_I386);	if (IN_DISPLAY_BANK(pbt->pbtdesthi))	  mpr_d(DestPixRect)->md_flags |= MP_I386;	 else mpr_d(DestPixRect)->md_flags &= (~MP_I386);#endif I386E 4I 4        /* Need to take care of byte order, because display bank */        /* on the 386 is NOT bit reversed.... */        if (IN_DISPLAY_BANK(pbt->pbtsourcehi))          mpr_d(SrcePixRect)->md_flags |= MP_I386;         else mpr_d(SrcePixRect)->md_flags &= (~MP_I386);        if (IN_DISPLAY_BANK(pbt->pbtdesthi))          mpr_d(DestPixRect)->md_flags |= MP_I386;         else mpr_d(DestPixRect)->md_flags &= (~MP_I386);#endif /* I386 */E 4D 4		mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;		mpr_mdlinebytes(SrcePixRect) = (srcebpl + 7) >> 3;	      }E 4D 4	    pbt->pbtwidth= IMIN(imagewidth, (right-left));	    pbt->pbtsourcebit=GETBASE(Addr68k_from_LADDR			(displaydata68k->ddoffsetscache), args->char8code);E 4I 4                mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;                mpr_mdlinebytes(SrcePixRect) = (srcebpl + 7) >> 3;              }E 4D 4	    if(pr_rop( DestPixRect, left, 0,		   pbt->pbtwidth,pbt->pbtheight,		PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ),		   SrcePixRect, pbt->pbtsourcebit, 0) != 0)		error("pilotbitblt: pr_rop failed\n");E 4I 4            pbt->pbtwidth= IMIN(imagewidth, (right-left));            pbt->pbtsourcebit=GETBASE(Addr68k_from_LADDR                        (displaydata68k->ddoffsetscache), args->char8code);E 4I 4            if(pr_rop( DestPixRect, left, 0,                   pbt->pbtwidth,pbt->pbtheight,                PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ),                   SrcePixRect, pbt->pbtsourcebit, 0) != 0)                error("pilotbitblt: pr_rop failed\n");E 4I 4E 4           } /* if pbt->pbtheight */D 4	} /* if left<right */E 4I 4        } /* if left<right */E 4    ScreenLocked=NIL;  } /* end tedit_bltchar */#endif#ifndef COLORint old_cursorin  ( addrhi, addrlo, x, w, h, y, backward)D 4     DLword	addrhi;		/* Lisp addr hi-word	*/     DLword	addrlo;		/* Lisp addr lo-word	*/     register int	x, w, h, y;E 4I 4     DLword     addrhi;                 /* Lisp addr hi-word    */     DLword     addrlo;                 /* Lisp addr lo-word    */     register int       x, w, h, y;E 4     {#ifdef INIT      init_kbd_startup;#endifD 4	if (addrhi == DISPLAY_HI)  y = addrlo / DisplayRasterWidth;	else if (addrhi == DISPLAY_HI+1)	   y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth;	else return( NIL );E 4I 4        if (addrhi == DISPLAY_HI)  y = addrlo / DisplayRasterWidth;        else if (addrhi == DISPLAY_HI+1)           y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth;        else return( NIL );E 4D 4	if(backward) y -= h;E 4I 4        if(backward) y -= h;E 4D 4	if((x < MOUSEXR)&&(x + w > MOUSEXL)&&	   (y < MOUSEYH)&&(y + h > MOUSEYL)   )	   return( T );	else	   return( NIL );E 4I 4        if((x < MOUSEXR)&&(x + w > MOUSEXL)&&           (y < MOUSEYH)&&(y + h > MOUSEYL)   )           return( T );        else           return( NIL );E 4     }#else/* For MONO and COLOR */old_cursorin  ( addrhi, addrlo, x, w, h, y, backward)D 4     DLword	addrhi;		/* Lisp addr hi-word	*/     DLword	addrlo;		/* Lisp addr lo-word	*/     register int	x, w, h, y;E 4I 4     DLword     addrhi;                 /* Lisp addr hi-word    */     DLword     addrlo;                 /* Lisp addr lo-word    */     register int       x, w, h, y;E 4     {D 4	register DLword *base68k;	extern int MonoOrColor;	extern int DisplayWidth;E 4I 4        register DLword *base68k;        extern int MonoOrColor;        extern int DisplayWidth;E 4#ifdef INIT      init_kbd_startup;#endifD 4	if(MonoOrColor == MONO_SCREEN) {	  if (addrhi == DISPLAY_HI)  y = addrlo / DisplayRasterWidth;	  else if (addrhi == DISPLAY_HI+1)	     y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth;	  else return( NIL );E 4I 4        if(MonoOrColor == MONO_SCREEN) {          if (addrhi == DISPLAY_HI)  y = addrlo / DisplayRasterWidth;          else if (addrhi == DISPLAY_HI+1)             y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth;          else return( NIL );E 4D 4	  if(backward) y -= h;E 4I 4          if(backward) y -= h;E 4D 4	  if((x < MOUSEXR)&&(x + w > MOUSEXL)&&	     (y < MOUSEYH)&&(y + h > MOUSEYL)   )	     return( T );	  else	     return( NIL );	} /* MONO case end */	else {	  base68k=(DLword*)Addr68k_from_LADDR(addrhi << 16 | addrlo);	  if ((ColorDisplayRegion68k<=base68k) &&		 (base68k <= COLOR_MAX_Address)){	     y =(base68k - ColorDisplayRegion68k) /DisplayWidth ;	  }	  else return( NIL );E 4I 4          if((x < MOUSEXR)&&(x + w > MOUSEXL)&&             (y < MOUSEYH)&&(y + h > MOUSEYL)   )             return( T );          else             return( NIL );        } /* MONO case end */        else {          base68k=(DLword*)Addr68k_from_LADDR(addrhi << 16 | addrlo);          if ((ColorDisplayRegion68k<=base68k) &&                 (base68k <= COLOR_MAX_Address)){             y =(base68k - ColorDisplayRegion68k) /DisplayWidth ;          }          else return( NIL );E 4D 4	  if(backward) y -= h;	 /*  printf("old_c:x=%d,y=%d,w=%d,h=%d\n",x,y,w,h);*/	  if((x < MOUSEXR)&&((x + (w >>3)) > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))	     { /* printf("old_c T\n");*/ return( T );}	  else	      return( NIL );	} /* COLOR case end */E 4I 4          if(backward) y -= h;         /*  printf("old_c:x=%d,y=%d,w=%d,h=%d\n",x,y,w,h);*/          if((x < MOUSEXR)&&((x + (w >>3)) > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))             { /* printf("old_c T\n");*/ return( T );}          else              return( NIL );        } /* COLOR case end */E 4     }D 4#endif COLORE 4I 4#endif /* COLOR */E 4E 1