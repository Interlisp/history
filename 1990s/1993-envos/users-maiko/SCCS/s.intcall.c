h43320s 00006/00001/00119d D 1.7 93/02/08 14:54:41 sybalsky 7 6c Big VM (and new CDR coding) changes for 3.0 \nes 00005/00001/00115d D 1.6 92/06/26 13:49:23 sybalsky 6 5c retrofit of 386 unix changes \nes 00009/00004/00107d D 1.5 92/04/22 14:36:16 sybalsky 5 4c fix copyrightes 00005/00005/00106d D 1.4 92/04/21 17:16:19 sybalsky 4 3c shortening file names for DOS \nes 00000/00000/00111d D 1.3 90/04/20 01:40:04 sybalsky 3 2c shortening file names, bulk change.es 00000/00002/00111d D 1.2 90/04/19 21:58:14 sybalsky 2 1c Fix check-in mistake in headeres 00113/00000/00000d D 1.1 90/04/19 20:54:19 sybalsky 1 0c date and time created 90/04/19 20:54:19 by sybalskyeuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";D 2/* This is G-file %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 2I 5E 5/************************************************************************//*									*/D 5/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 5I 5/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 5/*									*/D 5/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 5I 5/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 5/*									*//************************************************************************/D 5E 5D 2static char *id = "%Z% %M%	%I% %G%";E 2#include "lispemul.h"#include "address.h"D 4#include "address68k.h"#include "lisptypes.h"E 4I 4#include "adr68k.h"#include "lsptypes.h"E 4#include "lispmap.h"#include "stack.h"#include "return.h"D 4#include "emulglobal.h"#include "lispglobal.h"#include "initatoms.h"E 4I 4#include "emlglob.h"#include "lspglob.h"#include "initatms.h"E 4#include "cell.h"I 6#include "tosfns.h"E 6I 6E 6cause_interruptcall(atom_index)  register unsigned int atom_index;   /* Atomindex for Function you want to invoke */{  register struct definition_cell *defcell68k ;  /* Definition Cell PTR */  register short pv_num ; /* scratch for pv */  register struct fnhead *tmp_fn;  int rest ;  /* use for arignments */  CURRENTFX->nopush = T;  CURRENTFX->nextblock=StkOffset_from_68K(CurrentStackPTR)+4;   PushCStack ;  /* save TOS */  /* Setup IVar */  IVar = Addr68k_from_StkOffset(CURRENTFX->nextblock) ;  /* Set PC to the Next Instruction and save into pre-FX */  CURRENTFX->pc = ((unsigned int)PC - (unsigned int)FuncObj) ;   /* Get DEFCELL 68k address */  defcell68k =(struct definition_cell *) GetDEFCELL68k(atom_index) ; /* Interrupt FN should be compiled code */  tmp_fn = (struct fnhead *)Addr68k_from_LADDR( defcell68k->defpointer ) ;if((unsigned int)(CurrentStackPTR + tmp_fn->stkmin +STK_SAFE) >=  (unsigned int)EndSTKP )	{		/*printf("Intrrupt:$$ STKOVER when ");		print(atom_index);		printf(" was called  *****\n");*/		DOSTACKOVERFLOW(0,-1);	}  FuncObj = tmp_fn  ; D 6 if( FuncObj->na >= 0 )E 6I 6  SWAPPED_FN_CHECK; /* Check for need to re-swap code stream */  if( FuncObj->na >= 0 )E 6  {	/* This Function is Spread Type */	/* Arguments on Stack Adjustment  */	rest = 0 - (FuncObj->na) ;		while(rest <0) { 	  PushStack(NIL_PTR) ;	  rest++;	}	CurrentStackPTR -= (rest<<1) ;  } /* if end */ /* Set up BF */CurrentStackPTR+=2; GETWORD(CurrentStackPTR) = BF_MARK ; GETWORD(CurrentStackPTR+1) = CURRENTFX->nextblock ;CurrentStackPTR+=2; /* Set up FX */ GETWORD(CurrentStackPTR) = FX_MARK; /* Now SET new FX */ /* Make it SLOWP */ ((FX*)CurrentStackPTR)->alink = StkOffset_from_68K(PVar) + 1; ((FX*)CurrentStackPTR)->blink = StkOffset_from_68K(DUMMYBF(CurrentStackPTR)); ((FX*)CurrentStackPTR)->clink = StkOffset_from_68K(PVar) ; PVar = (DLword *)CurrentStackPTR + FRAMESIZE;I 7#ifdef BIGVM ((FX*)CurrentStackPTR)->fnheader = 	(defcell68k->defpointer);#elseE 7 ((FX*)CurrentStackPTR)->lofnheader = 	(defcell68k->defpointer) & 0x0ffff ; ((FX*)CurrentStackPTR)->hi2fnheader = D 7	((defcell68k->defpointer) & 0x0ff0000) >> 16 ;E 7I 7	((defcell68k->defpointer) & SEGMASK) >> 16 ;#endif /* BIGVM */E 7 CurrentStackPTR = PVar ; /* Set up PVar area */ pv_num = FuncObj->pv+1 ; while(pv_num > 0) {	*((LispPTR *)CurrentStackPTR) = 0x0ffffffff ;	CurrentStackPTR += DLWORDSPER_CELL ;	*((LispPTR *)CurrentStackPTR) = 0x0ffffffff ;	CurrentStackPTR += DLWORDSPER_CELL ;	pv_num--;  } /* Set PC points New Function's first OPCODE */ PC = (ByteCode *)FuncObj + FuncObj->startpc ; CURRENTFX->nextblock = StkOffset_from_68K(CurrentStackPTR); MAKEFREEBLOCK(CurrentStackPTR , ((int)EndSTKP - (int)CurrentStackPTR) >> 1);} /* end */E 1