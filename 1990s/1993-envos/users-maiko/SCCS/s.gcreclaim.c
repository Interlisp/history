h29117s 00000/00000/00168d D 2.9 90/06/15 16:55:18 mitani 13 12c new GCes 00000/00000/00168d D 2.8 90/04/20 01:37:25 sybalsky 12 11c AIX:  shortening file names, bulk change.es 00029/00029/00139d D 2.7 89/04/07 13:38:03 shih 11 10c lost sccs stempes 00018/00005/00150d D 2.6 89/03/28 01:44:53 sybalsky 10 9c word-pointer fixes for 386es 00003/00002/00152d D 2.5 88/10/10 14:04:35 krivacic 9 8c sun3/4 mergees 00009/00005/00145d D 2.4 88/09/27 16:25:07 krivacic 8 7c merge sun 4 gces 00001/00005/00149d D 2.3 88/07/31 12:41:45 masinter 7 6c remove extraneous unused GetLinkRecursion variablees 00001/00001/00153d D 2.2 88/05/31 16:46:54 masinter 6 5c remove reference to (obsolete) StkLimOes 00000/00000/00154d D 2.1 88/05/17 09:24:45 hayata 5 4c Version up to 2.1es 00050/00006/00104d D 1.4 88/03/20 16:48:02 masinter 4 3c merge new gc code for closure cachees 00002/00002/00108d D 1.3 88/03/13 14:49:51 hayata 3 2c Add SCCS key id (%Z%)es 00001/00001/00109d D 1.2 88/03/03 11:36:00 krivacic 2 1c es 00110/00000/00000d D 1.1 88/02/24 16:57:17 hayata 1 0c date and time created 88/02/24 16:57:17 by hayataeuUtTI 1D 3/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 3I 3D 9/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 9I 9D 11/* This is G-file @(#) gcreclaim.c Version 2.4 (9/27/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) gcreclaim.c	2.4 9/27/88";E 11I 11/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 11E 9E 3D 4/*** ADOPTED NEW VERSION ***/E 4/*************************************************************************//*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 *//*************************************************************************//*                                                                       *//*                       File Name : gcreclaim.c                         *//*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : Oct-12-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*           Functions : gcarrangementstack()                            */D 11/*           		 doreclaim();                                    */E 11I 11/*			 doreclaim();                                    */E 11/*                       dogc01();                                       */I 4/*                       disablegc1(noerror);                            */E 4/*                                                                       *//*************************************************************************/D 11/*           Descreption : 						 */E 11I 11/*           Description :						 */E 11/* This files' functions is the invocator that may invoke the reclaimer. *//*  gcarrangementstack()						 */D 11/*	This function's role is  narrowing the gap between the 		 */E 11I 11/*	This function's role is  narrowing the gap between the		 */E 11/*      contextswitch and the subrcall.					 *//*	In the original Lisp Source, as the contextswitch process may    *//*	clear the remain area to FSB,there is no problem in scannig stack*//*	.But in the subrcall,there isn't such process.			 *//*	Therefore, the function is required to set the remain stack area *//*	 to FSB. And this function does so.				 *//*  dogc01()								 *//*	This function is the mere caller of the reclaimer.		 *//*	The callees are gcscanstack(), gcmapscan() and gcunmapscan().    *//*  doreclaim()								 *//*	This function is the real top level function of the reclaimer.   *//*	But currently this function is not used(may be used in Future.)  *//*	This function may have a problem. It is to manipulate "clock"    *//*	for keeping the GC's time period.				 */I 4/*   disablegc1(noerror)/*      This function is the rescue function,when the HTcoll table is    *//*      overflow and so on.After this function's process is over, the    *//*      keyhandler will sense the interrupt table state and call the     *//*      function \DOGCDISABLEDINTERRUPT for reporting to Users that      *//*      this system status is dangerous and you should save your works.  */E 4/*                                                                       *//*************************************************************************/D 4/*                                                               \Tomtom */E 4I 4/*                                                               \tomtom */E 4/*************************************************************************/#include "lispemul.h"I 4#include "lispmap.h"E 4#include "emulglobal.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "stack.h"#include "gc.h"#define MAXSMALLP		65535#define HTBIGENTRYSIZE		4#define WORDSPERPAGE		256#define WORDSPERCELL		2#define MAXTYPENUMBER		INIT_TYPENUM#define STK_HI			1I 10#ifndef BYTESWAPE 10I 4D 7 extern int GetLinkRecursion;   struct interruptstateE 7I 7   struct interruptstateE 7D 11 {       unsigned nil1             :3;         unsigned gcdisabled       :1; 	unsigned vmemfull         :1; 	unsigned stackoverflow    :1; 	unsigned storagefull      :1; 	unsigned waitinginterrupt :1; 	unsigned nil2             :8; 	DLword   intcharcode; 	};E 11I 11 {      unsigned nil1             :3;        unsigned gcdisabled       :1;	unsigned vmemfull         :1;	unsigned stackoverflow    :1;	unsigned storagefull      :1;	unsigned waitinginterrupt :1;	unsigned nil2             :8;	DLword   intcharcode;	};E 11D 10 E 10I 10#else   struct interruptstate {D 11 	DLword   intcharcode; 	unsigned nil2             :8; 	unsigned waitinginterrupt :1; 	unsigned storagefull      :1; 	unsigned stackoverflow    :1; 	unsigned vmemfull         :1;E 11I 11	DLword   intcharcode;	unsigned nil2             :8;	unsigned waitinginterrupt :1;	unsigned storagefull      :1;	unsigned stackoverflow    :1;	unsigned vmemfull         :1;E 11        unsigned gcdisabled       :1;	unsigned nil1             :3;D 11 	};E 11I 11	};E 11#endif BYTESWAPE 10E 4gcarrangementstack(){  LispPTR tmpnextblock;I 4D 11 	PushCStack;E 11I 11	PushCStack;E 11E 4	tmpnextblock = LADDR_from_68k(CurrentStackPTR+=WORDSPERCELL);D 2	CurrentFX->nextblock = LOLOC(tmpnextblock);E 2I 2	CURRENTFX->nextblock = LOLOC(tmpnextblock);E 2D 10  *(CurrentStackPTR)=STK_FSB_WORD;D 6  *(CurrentStackPTR+1)=(((int)StkLimO-(int)CurrentStackPTR)>>1) + STKLIMOFFSET;E 6I 6  *(CurrentStackPTR+1)=(((int)EndSTKP-(int)CurrentStackPTR)>>1);E 10I 10  GETWORD(CurrentStackPTR)=STK_FSB_WORD;  GETWORD(CurrentStackPTR+1)=(((int)EndSTKP-(int)CurrentStackPTR)>>1);E 10E 6D 4E 4}/****************************************************************//* The following function is the caller that is the reclaimer.  *//* And, this function is same as \DOGC1 in Lisp because in the  *//* C's implimentation the contextswitch is not required for the *//* remaining the system status.					*//****************************************************************/D 11dogc01() E 11I 11dogc01()E 11{ gcarrangementstack(); gcscanstack(); gcmapscan(); gcmapunscan();I 9 PopCStack;E 9 return(NIL);}I 8/*!!!!!! should update clock in Miscstats */E 8doreclaim(){int gctm1;D 8 MISCSTATS	*gcmisc;E 8I 8 MISCSTATS gcmisc;E 8   if (*GcDisabled_word == NIL)D 8	{gcmisc = (MISCSTATS *)MiscStats;E 8I 8	{update_miscstats();	 gcmisc = *((MISCSTATS *)MiscStats);E 8	 *Reclaim_cnt_word = NIL;D 4	 gctm1 = clock(2, *GcTime1_word);E 4I 4D 8/* 	 gctm1 = clock(2, *GcTime1_word); temp no clock */E 8E 4	 if (*GcMess_word != NIL)		flip_cursor();I 4D 7 	 GetLinkRecursion = T;E 7E 4	 dogc01();I 4D 7 	 GetLinkRecursion = NIL;E 7E 4	 if (*GcMess_word != NIL)		flip_cursor();D 4	 gcmisc->gctime +=		clock(2, *GcTime2_word) - gctm1;E 4I 4D 8/*	 gcmisc->gctime +=		clock(2, *GcTime2_word) - gctm1; temp no clock */E 8E 4	 *Reclaim_cnt_word = *ReclaimMin_word;I 8	 update_miscstats();D 11	 MiscStats->gctime = MiscStats->gctime + E 11I 11	 MiscStats->gctime = MiscStats->gctime +E 11			MiscStats->totaltime - gcmisc.totaltime +			MiscStats->swapwaittime - gcmisc.swapwaittime;E 8	};}I 4disablegc1(noerror)D 11int       noerror; E 11I 11int       noerror;E 11{ struct interruptstate *gcinterruptstate;  int                   count, i;  DLword                typeword;  gcinterruptstate = (struct interruptstate *)			Addr68k_from_LADDR(*INTERRUPTSTATE_word);D 11  count = (128)*256; /* This is test value. 128 is *MdsTTsize(\MDSTTsize) */ E 11I 11  count = (128)*256; /* This is test value. 128 is *MdsTTsize(\MDSTTsize) */E 11  for(i = 0;i < count;i++)D 10    {typeword = *(DLword *)Addr68k_from_LADDR(LADDR_from_68k(MDStypetbl)+i);     *(DLword *)Addr68k_from_LADDR(LADDR_from_68k(MDStypetbl)+i) E 10I 10    {typeword = GETWORD((DLword *)Addr68k_from_LADDR(LADDR_from_68k(MDStypetbl)+i));     GETWORD((DLword *)Addr68k_from_LADDR(LADDR_from_68k(MDStypetbl)+i) )E 10                 = (typeword | TT_NOREF);D 11   };   *Reclaim_cnt_word = NIL; E 11I 11   };  *Reclaim_cnt_word = NIL;E 11  *ReclaimMin_word  = NIL;D 11  if ((noerror == NIL) && (*GcDisabled_word == NIL)) E 11I 11  if ((noerror == NIL) && (*GcDisabled_word == NIL))E 11    { gcinterruptstate->gcdisabled = T;      *PENDINGINTERRUPT_word = ATOM_T;    };  *GcDisabled_word = ATOM_T;  return(NIL);}E 4E 1