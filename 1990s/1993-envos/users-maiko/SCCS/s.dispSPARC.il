h05138s 00027/00008/00695d D 2.7 90/07/25 20:33:29 osamu 9 8c Add name_scan2 (expanding name-table varsion of name_scan).es 00012/00012/00691d D 2.6 89/12/29 13:02:22 sybalsky 8 7c Add min, maxes 00001/00001/00702d D 2.5 89/12/28 15:30:21 sybalsky 7 6c es 00015/00000/00688d D 2.4 89/12/13 11:01:36 sybalsky 6 5c add min and max speed-upses 00059/00000/00629d D 2.3 88/10/06 17:10:30 krivacic 5 4c take maiko1.1 version on mergees 00569/00071/00060d D 2.2 88/09/27 16:09:43 krivacic 4 3c make the same as the sun4 versiones 00000/00000/00131d D 2.1 88/05/17 09:23:19 hayata 3 2c Version up to 2.1es 00086/00000/00045d D 1.2 88/03/28 11:59:54 krivacic 2 1c dispatches 00045/00000/00000d D 1.1 88/03/23 10:14:10 krivacic 1 0c date and time created 88/03/23 10:14:10 by krivaciceuUtTI 1D 7/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 7I 7D 9/* This is G-file @(#) dispSPARC.il Version 2.3 (10/6/88). copyright Xerox & Fuji Xerox  */E 7I 5/*E 9I 9/*  %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 9I 9/*  change _name_scan for name table expanding '90/07/13 by osamu *//*  Name table Expanded version *//* _name_scan2(entry, limit, names)	inner loop of FVAR	%o0	entry		even pointer to name table entry	%o1	limit		oct_byte pointer beyond last name	%o2	names		32 bit (actually 24bit) atom number	%o4	low		contents of entry /**/ .inline _name_scan2,12		!(entry, limit, names) returns first+4 or 0loop:	cmp	%o0,%o1		!loop:	if(entry<limit)loop1:	blu	ph0		!		then continue{	ld	[%o0],%o4	!	     low = *(entry);}		 ba	done		!		else entry=0; goto done;	 sub	%o0,%o0,%o0	!  ph0:	inc	4,%o0		!ph0:	entry += 4	xorcc	%o4,%o2,%o4	!	if(cc = low ^ names) then continue;	bne	loop1		!	if(cc=(last==first)) then loop	cmp	%o0,%o1		!	 ba	done		!		else done;	 nop			!		done:				!.end/* Old Nametable(entry size 16bit) version */E 9/* _name_scan(entry, limit, names)	inner loop of FVAR	%o0	entry		even pointer to name table entry	%o1	limit		oct_byte pointer beyond last name	%o2	names		2 copies of 16 bit atom number	%o3	mask		0xFFFF0000	%o4	low or temp	low half of double word fetch	%o5	high		high half of double word fetch/**/ .inline _name_scan,12		!(entry, limit, names) returns first+2 or 0	andcc	%o0,7,%o4	! switch (temp=entry & 7)	be	loop		!	case0: goto loop;	sethi	%hi(0xFFFF0000),%o3	andn	%o0,0x7,%o0	!	entry &= ~7;	cmp	%o4,0x4		! if (temp=entry&7 < 4)	ldd	[%o0],%o4	!	low = *(entry); high = *(entry+4);	inc	8,%o0		!	entry += 8	xor	%o4,%o2,%o4	!	  {temp = low ^ names}	bl,a	ph2		!	case2:	andncc	%o4,%o3,%g0	!		cc=temp & ^0xFFFF0000; goto ph1;	be	ph4		!	  {temp = high^ names}	xor	%o5,%o2,%o4	!	case4:	 goto ph2;	ba	ph6		!	case6:		andncc	%o4,%o3,%g0	!		cc=temp & ^0xFFFF0000; goto ph3;loop:	cmp	%o0,%o1		!loop:	if(entry<limit)loop1:	blu	ph0		!		then continue{	ldd	[%o0],%o4	!	     low = *(entry); high = *(entry+4)}		 ba	done		!		else entry=0; goto done;	 sub	%o0,%o0,%o0	!  ph0:	inc	8,%o0		!ph0:	entry += 8	xor	%o4,%o2,%o4	!	temp = low ^ names	andcc	%o4,%o3,%g0	!	if (temp & 0xFFFF0000)	bne	ph2		!		then continue{	andncc	%o4,%o3,%g0	!			cc=temp &^ 0xFFFF0000}	 ba	done		!		else {entry -= 6; goto done;}	 dec	6,%o0		!		ph2:	bne	ph4		!ph1: if (cc=temp &^ 0xFFFF0000) then continue{	xor	%o5,%o2,%o4	!			temp = high ^ names}	 ba	done		!		else {entry -=4; goto done;}	 dec	4,%o0		!		ph4:	andcc	%o4,%o3,%g0	!ph2:	if (temp & 0xFFFF0000)	bne	ph6		!		then continue{	andncc	%o4,%o3,%g0	!			cc=temp &^ 0xFFFF0000}	 ba	done		!		else {entry -= 2; goto done;}	 dec	2,%o0		!		ph6:	bne	loop1		!ph3:	if (cc=temp &^ 0xFFFF0000) then loop{	cmp	%o0,%o1		! 			cc=(last==first)}done:				!		else done;.endD 9E 9E 5D 4/* dispatch.il */E 4/* inline dispatching support */D 4/* Russ Atkinson, December 29, 1987 */E 4I 4/* Thanks to Russ Atkinson, December 29, 1987 */E 4/* To use in compiling XXX, cc -O2 XXX.c dispatch.il */D 4/* The qdisp* routines depend on pc being in %i0 and table being in %i1 */E 4I 4/* The qdisp* routines depend on pc being in %o0 and table being in %o1 */E 4I 2D 4/* The qdisp* routines depend on pc being in %i0 and table being in %i1 */E 2.inline	_qdisp0,0	! qdisp0 - %i0: pc, %i1: table	ldub	[%i0+0],%i2	! temp = *pc	sll	%i2,2,%i2	! temp = temp * 4	ld	[%i2+%i1],%i2	! temp = table[temp]	jmp	%i2		! dispatchE 4I 4.inline	_qdisp0,8	! qdisp0 - %o0: pc, %o1: table	ldub	[%o0+0],%o2	! temp = *pc	sll	%o2,2,%o2	! temp = temp * 4	ld	[%o2+%o1],%o2	! temp = table[temp]	jmp	%o2		! dispatchE 4	nop.endD 4.inline	_qdisp1,0	! qdisp1 - %i0: pc, %i1: table	ldub	[%i0+1],%i2	! temp = *pc	sll	%i2,2,%i2	! temp = temp * 4	ld	[%i2+%i1],%i2	! temp = table[temp]	jmp	%i2		! dispatch	add	%i0,1,%i0	! update the pcE 4I 4.inline	_qdisp1,8	! qdisp1 - %o0: pc, %o1: table	ldub	[%o0+1],%o2	! temp = *pc	sll	%o2,2,%o2	! temp = temp * 4	ld	[%o2+%o1],%o2	! temp = table[temp]	jmp	%o2		! dispatch	add	%o0,1,%o0	! update the pcE 4.endD 4.inline	_qdisp2,0	! qdisp2 - %i0: pc, %i1: table	ldub	[%i0+2],%i2	! temp = *pc	sll	%i2,2,%i2	! temp = temp * 4	ld	[%i2+%i1],%i2	! temp = table[temp]	jmp	%i2		! dispatch	add	%i0,2,%i0	! update the pcE 4I 4.inline	_qdisp2,8	! qdisp2 - %o0: pc, %o1: table	ldub	[%o0+2],%o2	! temp = *pc	sll	%o2,2,%o2	! temp = temp * 4	ld	[%o2+%o1],%o2	! temp = table[temp]	jmp	%o2		! dispatch	add	%o0,2,%o0	! update the pcE 4.endD 4.inline	_qdisp3,0	! qdisp3 - %i0: pc, %i1: table	ldub	[%i0+3],%i2	! temp = *pc	sll	%i2,2,%i2	! temp = temp * 4	ld	[%i2+%i1],%i2	! temp = table[temp]	jmp	%i2		! dispatch	add	%i0,3,%i0	! update the pcE 4I 4.inline	_qdisp3,8	! qdisp3 - %o0: pc, %o1: table	ldub	[%o0+3],%o2	! temp = *pc	sll	%o2,2,%o2	! temp = temp * 4	ld	[%o2+%o1],%o2	! temp = table[temp]	jmp	%o2		! dispatch	add	%o0,3,%o0	! update the pcE 4I 2.end.inline	_fast_dispatcher,8D 4	!  - %o0: table, %o1: instE 4I 4	!  - %o0: table, %o1: pc	ldub	[%o1+0],%o1	! fetch inst byteE 4	sll	%o1,2,%o1	ld	[%o1+%o0],%o1	jmp	%o1		! dispatch	nop.endI 4/*	***************************************************************	Special Native Code Jump Routine.	****************************************************************/E 4I 4.inline _asmgoto,4	jmp	%o0	nopE 4I 4.end/* THIS IS WRONG! asmcall(label) is supposed to do a direct call there... this is just a jump. Used by emulator<->native interface */.inline _asmcall,4	jmp 	%o0	nop.endE 4/*	***************************************************************I 4	Arithmetic Opcode Helpers	****************************************************************/.inline	_sub32,8	subcc	%o0,%o1,%o0	! result = arg0 - arg1	bvs	diff_err	nop.end.inline	_isub32,8	subcc	%o0,%o1,%o0	! result = arg0 - arg1	bvs	idiff_err	nop.end.inline	_sub32n,8	subcc	%o0,%o1,%o0	! result = arg0 - arg1	bvs	diff_err2	nop.end.inline	_mpy32,8	ba	mpy_err	nop.end.inline	_impy32,8	ba	impy_err	nop.end.inline	_quot32,8	ba	quot_err	nop.end.inline	_iquot32,8	ba	iquot_err	nop.end.inline	_rem32,8	ba	rem_err	nop.end.inline	_irem32,8	ba	irem_err	nop.end.inline	_plus32,8	addcc	%o0,%o1,%o0	! result = arg0 + arg1	bvs	plus_err	nop.end.inline	_iplus32,8	addcc	%o0,%o1,%o0	! result = arg0 + arg1	bvs	iplus_err	nop.end.inline	_iplus32n,8	addcc	%o0,%o1,%o0	! result = arg0 + arg1	bvs	iplusn_err	nop.end/*	***************************************************************E 4	Inline Assembly help for dispatcher.	****************************************************************//* Note: that the error exit of these routines may or may not need to	fix the tos pointer.  The C code should decide when tos must	be fixed through the ifdef flats.*/I 4/* SWAP halves of a register */E 4D 4/* inline DIFFERENCE *//* 	%o0 - %o1E 4I 4.inline	_swapx,4	sll	%o0,16,%o1	srl	%o0,16,%o0	or	%o0,%o1,%o0.end/*	***************************************************************	DIFFERENCE VERSIONS sp@ - sp@(4)  i.e. (tos-1)  -  (tos)	***************************************************************E 4*/D 4.inline	_op_difference,8	sethi	%hi(0xffff0000),%o2		#15,d2	roll	d2,d1	subqb	#7,d1E 4I 4.inline	_op_difference,8	! working	srl	%o1,17,%o2	! r2 = type(arg1)	cmp	%o2,7		!   ==smallp ?	bne	diff_err	!   else diff_err	srl	%o0,17,%o2	! r2 = type(arg0)	cmp	%o2,7E 4	bne	diff_errD 4	roll	d2,d0	subqb	#7,d0	bne	diff_err	subl	d1,d0E 4I 4	sll	%o0,15,%o2	! preserve arg0 	sll	%o1,15,%o1	subcc	%o2,%o1,%o0E 4	bvs	diff_errD 4	lsrl	d2,d0	orl	#0x000E0000,d0E 4I 4	srl	%o0,15,%o0	sethi	%hi(0x000E0000),%o2	or	%o2, %o0,%o0E 4.endD 4/* inline DIFFERENCE *//* 	d7 - sp@E 4I 4/*	***************************************************************	PLUS VERSIONS sp@ + sp@(4)  i.e. (tos-1)  +  (tos)	***************************************************************E 4*/D 4.inline	_fast_op_difference,4E 4D 4	movl	a7@+,d1	roll	d5,d7	subqb	#7,d7	bne	diff_err	roll	d5,d1	subqb	#7,d1	bne	diff_err	subl	d7,d1	bvs	diff_err	lsrl	d5,d1	orl	#0x000E0000,d1	movl	d1,d7E 4I 4.inline	_op_plus,8	srl	%o1,17,%o2	! r2 = type(arg1)	cmp	%o2,7		!   ==smallp ?	bne	plus_err	!   else diff_err	srl	%o0,17,%o2	! r2 = type(arg0)	cmp	%o2,7	bne	plus_err	sll	%o0,15,%o2	! preserve arg0 	sll	%o1,15,%o1	addcc	%o2,%o1,%o0	bvs	plus_err	srl	%o0,15,%o0	sethi	%hi(0x000E0000),%o2	or	%o2, %o0,%o0E 4.endD 4/* inline DIFFERENCE 32 *//* 	sp@ - sp@(4)E 4I 4/*	***************************************************************	LOGAND VERSIONS sp@ & sp@(4)  i.e. (tos-1)  &  (tos)	***************************************************************E 4*/D 4.inline	_sub32,8E 4I 4.inline	_op_logand,8	srl	%o1,17,%o2	! r2 = type(arg1)	cmp	%o2,7		!   ==smallp ?	bne	logand_err	!   else diff_err	srl	%o0,17,%o2	! r2 = type(arg0)	cmp	%o2,7	bne	logand_err	and	%o0,%o1,%o0.end/*	***************************************************************	LOGOR VERSIONS sp@ | sp@(4)  i.e. (tos-1)  |  (tos)	****************************************************************/.inline	_op_logor,8	srl	%o1,17,%o2	! r2 = type(arg1)	cmp	%o2,7		!   ==smallp ?	bne	logor_err	!   else diff_err	srl	%o0,17,%o2	! r2 = type(arg0)	cmp	%o2,7	bne	logor_err	or	%o0,%o1,%o0.end/*	***************************************************************	LOGXOR VERSIONS sp@ | sp@(4)  i.e. (tos-1)  |  (tos)	****************************************************************/.inline	_op_logxor,8	srl	%o1,17,%o2	! r2 = type(arg1)	cmp	%o2,7		!   ==smallp ?	bne	logxor_err	!   else diff_err	srl	%o0,17,%o2	! r2 = type(arg0)	cmp	%o2,7	bne	logxor_err	xor	%o0,%o1,%o0	sethi	%hi(0x000E0000),%o1	or	%o0,%o1,%o0.end/*	***************************************************************	SHIFT OPCODE VERSIONS	****************************************************************/.inline	_op_lrsh8,4	srl	%o0,16,%o2	! r2 = type(arg0)	cmp	%o2,0xE	bne	lrsh8_err	sethi	%hi(0xE0E0000),%o1	!E0000 xor E000000	xor	%o0,%o1,%o0	srl	%o0,8,%o0.end/* inline LRSH1 *//* 	sp@ >> 1*/.inline	_op_lrsh1,4	srl	%o0,16,%o2	cmp	%o2,0xE	bne	lrsh1_err	srl	%o0,11,%o0	sethi	%hi(0x00090000),%o1	!E0000 xor 70000	or	%o0,%o1,%o0.end.inline	_op_llsh8,4	srl	%o0,8,%o2	! (arg0>>8)==0xE00?	cmp	%o2,0xE00	bne	llsh8_err	sll	%o0,8,%o0	sethi	%hi(0xE0E0000),%o1	!E0000 xor E000000	xor	%o0,%o1,%o0.end.inline	_op_llsh1,4	srl	%o0,15,%o2	! (arg0>>15)==0x1C	cmp	%o2,0x1C	bne	llsh1_err	sll	%o0,1,%o0	sethi	%hi(0x00120000),%o1	!E0000 xor 1C0000	xor	%o0,%o1,%o0.end/*	***************************************************************	GREATERP OPCODE VERSIONS	****************************************************************/.inline	_op_greaterp,8	srl	%o1,17,%o2	! \	cmp	%o2,7		!  > smallp(arg1) ?	bne	greaterp_err	! /	sll	%o0,15,%o2	! preserve arg0 	srl	%o0,17,%o0	! return NIL	cmp	%o2,7		!  > smallp(arg0) ?	bne	greaterp_err	! /	cmp	%o2,%o1		! arg0 - arg1  ??	bg,a	9f		! if greater, return T	or	%o0,76,%o09:.end/*	***************************************************************	POINTER OPCODE VERSIONS	****************************************************************/.inline _addbase,8	srl	%o1,17,%o2	! \	cmp	%o2,7		!  > smallp(arg1) ?	bne	addbase_err	! /	sll	%o1,15,%o1	sra	%o1,15,%o1	add	%o1,%o0,%o0	sethi	%hi(0xFFFFFF),%o1	!is this necessary ??	and	%o0,%o1,%o0.end.inline _loloc,4	sll	%o0,16,%o0	srl	%o0,16,%o0	sethi	%hi(0xE0000),%o1	or	%o0,%o1,%o0.end.inline	_hiloc,4	srl	%o0,16,%o0	sethi	%hi(0xE0000),%o1	or	%o0,%o1,%o0.end/* this really doesn't need to check */.inline	_vag2,8	sll	%o0,16,%o0	sll	%o1,16,%o1	srl	%o1,16,%o1	or	%o0,%o1,%o0.end	/*	***************************************************************	TYPE OPCODE VERSIONS	****************************************************************//* TYPE INLINE OPCODES */.inline	_listp,4E 4	movl	a7@+,d0I 4	movl	d0,d1	lsrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movw	a0@(0,d1:l:1),d1	andw	#0x7FF,d1	cmpw	#5,d1	jeq	_xwzq5	clrl	d0_xwzq5:.end.inline	_fast_op_listp,0	movl	d7,d1	lsrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movw	a0@(0,d1:l:1),d1	andw	#0x7FF,d1	cmpw	#5,d1	jeq	_xwzq6	clrl	d7_xwzq6:.end.inline	_ntypex,4E 4	movl	a7@+,d1D 4	subl	d1,d0	bvs	diff_errE 4I 4	lsrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movl	#0x000E0000,d0	movw	a0@(0,d1:l:1),d0	andw	#0x7FF,d0E 4.endD 4.inline	_sub32n,8E 4I 4.inline	_fast_op_ntypex,0	lsrl	#8,d7	andl	#0xFFFE,d7	movl	_MDStypetbl,a0	movw	a0@(0,d7:l:1),d7	andw	#0x7FF,d0	orl	#0x000E0000,d7.endE 4D 4	movl	a7@+,d0E 4I 4.inline _typep,8E 4	movl	a7@+,d1D 4	subl	d1,d0	bvs	diff_err2E 4I 4	movl	a7@+,d2	movl	d1,d0	lsrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movw	a0@(0,d1:l:1),d1	andw	#0x7FF,d1	cmpl	d2,d1	beq	115$	moveq	#0,d0115$:E 4E 2.endI 4.inline _fast_op_typep,0	movl	d7,d0	lsrl	#8,d0	andl	#0xFFFE,d0	movl	_MDStypetbl,a0	movw	a0@(0,d0:l:1),d0	andw	#0x7FF,d0	moveq	#0,d1	movb	a5@(1),d1	cmpw	d1,d0	beq	115$	moveq	#0,d7115$:.end/* TYPE INLINE FUNCTIONS */.inline _GetTypeNumber,4	movl	a7@+,d1	asrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	moveq	#00,d0	movw	a0@(0,d1:l:1),d0	andw	#0x7FF,d0.end.inline _GetTypeEntry,4	movl	a7@+,d1	asrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movw	a0@(0,d1:l:1),d0.end	.inline	_opreturn,0	movl	_CurrentFX,a1		|returnFX = a1	movl	#65536,d0	movw	a1@(2),d0		|returnFX->alink	lsrl	#1,d0			|low bit to carry	jcs	ni			|jump if slow return	movl	a2,a3			|CSTKPTR = IVAR	movl	_Lisp_world,a0		|PVar=	lea	a0@(0,d0:l:4),a0	movl	a0,_PVar	moveq	#20,d1	subl	d1,a0			|returnFX = a0	movl	a0,_CurrentFX		|CURRENTFX = returnFX	movl	#65536,d0	movw	a0@(-2),d0		|returnFX -1	movl	_Lisp_world,a1	lea	a1@(0,d0:l:2),a2	|IVAR = a2	moveq	#0,d0	movb	a0@(7),d0		|returnFX->hi2fnheader	swap	d0	movw	a0@(4),d0		|returnFX->lofnheader	movl	_Lisp_world,a1	lea	a1@(0,d0:l:2),a1	movl	a1,_FuncObj		|FuncObj = a1	subl	a5,a5	movw	a0@(10),a5		|returnFX->pc a5	lea	a1@(0,a5:l:1),a5	| a5 + FuncObj	movb	a5@,d6	movl	a4@(0,d6:l:4),a0	jmp	a0@.end.inline _fn3,0	moveq	#0,d0	movw	a5@(1),d0	movl	_Defspace,a0	lea	a0@(0,d0:l:4),a1		|defcell = a1	movl	a1,d4				|save defcell in d4|	movl	a1,a6@(-20)	btst	#7,a1@	jeq	ni	movl	a1@,d0				|defcell->defpointer	andl	#16777215,d0	movl	_Lisp_world,a0	lea	a0@(0,d0:l:2),a1		|LOCFNCELL	movl	a1,d2				|save LOCFNCELL in a1, d2|	movl	a1,a6@(-12)	moveq	#0,d0	movw	a1@,d0				|LOCFNCELL->stkmin	lea	a3@(4,d0:l:2),a0|	addql	#4,a0	cmpl	_StkLimO,a0	jcc	ni				|stack overflow	lea	a3@(-8),a1			|CSTKPTR-(x<<1)+2	subl	_Lisp_world,a1	movl	a1,d3	lsrl	#1,d3|	movl	d3,a1	andl	#65535,d3			|NEXTBLOCK = d3|	movl	d0,d3	movl	_CurrentFX,a1			|a1 = _CurrentFX	movw	d3,a1@(8)			|CURRENTFX->nextblock =	movl	d3,d0	orl	#65536,d0	movl	_Lisp_world,a0	lea	a0@(0,d0:l:2),a2		|IVAR =|	movl	_CurrentFX,a0	movl	a5,d0	subl	_FuncObj,d0	addql	#3,d0	movw	d0,a1@(10)			|CURRENTFX->pc	movl	d7,a3@+				|CPushCStack	movl	d2,a1				|get LOCFNCELL = a1	movw	a1@(2),d0	tstw	d0	jlt	fn3noargs			|no function arguments|	movw	a0@(2),d0	extl	d0	moveq	#2,d1	subl	d0,d1|	movl	d1,d4	jra	fn3ly16fn3ly17:	clrl	a3@+	addql	#1,d1fn3ly16:	tstl	d1	jlt	fn3ly17|	movl	d4,d0	asll	#2,d1	subl	d1,a3fn3noargs:	movl	d3,d0				|CPush(BF_MARK32 | NEXTBLOCK)	orl	#-2147483648,d0	movl	d0,a3@+	movl	a3,_CurrentFX			|CURRENTFX =	movl	_PVar,d0|	subl	_Lisp_world,d0	subl	a0,d0	lsrl	#1,d0	andl	#65535,d0	orl	#-1073741824,d0	movl	d0,a3@				|*CSTKPTR=FX_MARK etc	movl	d4,a0				|defcell = a0	movw	a0@(2),a3@(4)			|->lofnheader = ->defpointer|	movl	a6@(-20),a0|	movl	a0@,d0|	andl	#16777215,d0|	movw	d0,a3@(4)|	movl	d4,a0|	movl	a6@(-20),a0	movb	a0@(1),a3@(7)			|hi2fnheader = *((defcell)+1)	lea	a3@(20),a3	movl	a3,_PVar			|PVar = CSTKPTR|	movl	d2,a0	movw	a1@(4),d0			||LOCFNCELL->pv	extl	d0	addql	#1,d0|	movl	d0,a6@(-8)	moveq	#-1,d1	jra	fn3ly18fn3ly19:	movl	d1,a3@+	movl	d1,a3@+	subql	#1,d0fn3ly18:	tstl	d0	jgt	fn3ly19	addqw	#4,a3				| CSTKPTR += 2|	movl	d2,a0|	moveq	#0,d0	subl	a5,a5	movw	a1@(6),a5			|LOCFNCELL->startpc	addl	a1,a5|	movl	d0,a5	movl	a1,_FuncObj.endI 6D 8.inline _min,8	cmp	%o0,%o1	ble,a	$10	mov	%o1,%o0$10.endE 8I 8|.inline _min,8|	cmp	%o0,%o1|	ble,a	$10|	mov	%o1,%o0|$10|.endE 8D 8.inline _max,8	cmp	%o0,%o1	bge,a	$10	mov	%o1,%o0$10.endE 8I 8|.inline _max,8|	cmp	%o0,%o1|	bge,a	$10|	mov	%o1,%o0|$10|.endE 8E 6E 4E 1