h15244s 00001/00001/00302d D 2.32 91/09/27 03:45:20 sybalsky 42 41c ISC port changeses 00010/00003/00293d D 2.31 91/09/27 02:40:52 sybalsky 41 40c ISC port changeses 00061/00036/00235d D 2.30 91/05/01 18:15:00 sybalsky 40 39c Retrofit changes from MIPS porting center.es 00002/00002/00269d D 2.29 91/04/16 17:01:15 sybalsky 39 38c Back out valloc -> malloc changees 00020/00005/00251d D 2.28 91/04/09 17:11:25 sybalsky 38 37c Retrofit first round of changes from MIPS porting centeres 00002/00003/00254d D 2.27 90/06/11 11:50:24 fuji 37 36c Takeshi: add sys_size != DEFAULT_MAX_SYSOUTSIZE in if-expr at line#110es 00077/00018/00180d D 2.26 90/05/31 14:50:54 fuji 36 35c Takeshi: Add NEW storage futures.(various process size)es 00000/00000/00198d D 2.25 90/04/20 01:47:45 sybalsky 35 34c AIX:  shortening file names, bulk change.es 00004/00000/00194d D 2.24 90/03/01 13:58:15 osamu 34 33c Mitsunori Matsuda adds XWindow functionality.es 00002/00002/00192d D 2.23 89/12/28 15:26:29 sybalsky 33 32c es 00004/00000/00190d D 2.22 89/10/19 18:00:27 sybalsky 32 31c display bufferinges 00016/00012/00174d D 2.21 89/03/30 13:14:39 sybalsky 31 30c fix up ranges for byte swapping.es 00008/00006/00178d D 2.20 89/03/16 12:09:06 sybalsky 30 29c Changed word-ptr refs to use GETWORD.es 00001/00001/00183d D 2.19 89/03/08 14:04:37 sybalsky 29 28c cd ../inces 00004/00004/00180d D 2.18 89/03/08 14:02:21 sybalsky 28 27c Changed 386 part to word swap, too.es 00001/00001/00183d D 2.17 89/03/03 04:21:04 shih 27 26c added address68k.h (because of change to initdisplay)es 00004/00020/00180d D 2.16 89/03/03 02:01:40 shih 26 25c changed init_display to initdisplay2, takes 68k address insteades 00010/00017/00190d D 2.15 89/03/02 20:31:10 shih 25 24c added dbprint.hes 00008/00008/00199d D 2.14 89/01/10 15:49:33 shih 24 23c removed nls from perror stringses 00015/00013/00192d D 2.13 89/01/04 15:22:58 shih 23 22c minor cleanupes 00011/00007/00194d D 2.12 89/01/04 15:19:31 shih 22 21c if can't open sysout file, echo file namees 00000/00002/00201d D 2.11 89/01/03 13:28:07 hayata 21 20c delete obsolete mess_reset() call in sysout_loader().es 00010/00000/00193d D 2.10 88/11/22 15:39:42 hayata 20 19c jobses 00008/00007/00185d D 2.9 88/11/08 17:33:38 bane 19 18c Added many perrors so failures are more informativees 00019/00018/00173d D 2.8 88/10/13 18:57:33 shih 18 17c minor cleanup (needs lispmap.h)es 00026/00017/00165d D 2.7 88/10/10 14:09:17 krivacic 17 16c  vars3.c vmemsave.c xc.c z2.ces 00000/00007/00182d D 2.6 88/07/27 10:57:40 hayata 16 15c mess_reset() is removed from sysout_loader.es 00002/00000/00187d D 2.5 88/07/12 12:30:44 bane 15 14c AR 10485 - Some error messages needed mess_reset before themes 00008/00000/00179d D 2.4 88/06/30 10:59:15 greep 14 13c put "#ifdef DEBUG" around printfses 00014/00004/00165d D 2.3 88/06/21 21:50:03 bane 13 12c Added mess_resets to make sysout die cleanlyes 00007/00000/00162d D 2.2 88/06/21 09:05:10 bane 12 11c Added ifpage key checkes 00000/00000/00162d D 2.1 88/05/17 09:25:53 hayata 11 10c Version up to 2.1es 00006/00080/00156d D 1.10 88/05/13 14:15:33 krivacic 10 9c remove native code referenceses 00002/00003/00234d D 1.9 88/05/13 10:10:59 hayata 9 8c Add SCCS keyides 00054/00063/00183d D 1.8 88/05/10 17:36:23 krivacic 8 7c load sysout now workinges 00029/00015/00217d D 1.7 88/05/06 11:44:23 krivacic 7 6c native ioes 00053/00005/00179d D 1.6 88/04/22 19:14:43 krivacic 6 5c inlinedefs re-arrangementes 00005/00002/00179d D 1.5 88/04/08 17:19:48 krivacic 5 4c print of sysout size infoes 00017/00020/00164d D 1.4 88/04/01 17:42:18 masinter 4 3c Allow sysout size as variable; for medley increase max displayes 00001/00001/00183d D 1.3 88/03/17 18:09:34 krivacic 3 2c Hi Res Display Hacks es 00002/00002/00182d D 1.2 88/03/13 14:53:53 hayata 2 1c Add SCCS key id (%Z%)es 00184/00000/00000d D 1.1 88/02/24 16:57:54 hayata 1 0c date and time created 88/02/24 16:57:54 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 6/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 6I 6D 9/* This is G-file @(#) loadsysout.c Version 1.5 (4/8/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) loadsysout.c	1.5 4/8/88";E 6E 2E 9I 9D 22/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 22I 22D 25/* %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 25I 25D 33/* %Z% %M% Version %I% (%G%). copyright Envos & Fuji Xerox  */E 25E 22static char *id = "%Z% %M%	%I% %G%";E 33I 33D 36/* @(#) loadsysout.c Version 2.21 (3/30/89). copyright Envos & Fuji Xerox  */static char *id = "@(#) loadsysout.c	2.21 3/30/89";E 36I 36/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 36E 33E 9D 38/*D 4 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	AutherE 4I 4 *	loadsysout.cE 4 */E 38I 38/************************************************************************//*									*//*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************/E 38D 4/* *	sysoutloader.c */E 4#include <stdio.h>D 41#include <sys/file.h>E 41#include <sys/types.h>I 41#include <sys/file.h>E 41#include <sys/stat.h>#include <errno.h>I 41#ifdef ISCD 42#inlcude <sys/fcntl.h>E 42I 42#include <sys/fcntl.h>E 42#endif ISCE 41I 6D 27#include "machineconfig.h"E 27I 27#include "address68k.h"E 27E 6#include "lispemul.h"I 30#include "lisptypes.h"E 30#include "lispmap.h"#include "lispglobal.h"#include "ifpage.h"I 25#include "dbprint.h"E 25I 38#ifdef AIXPS2#include "inlinePS2.h"#endif AIXPS2I 41#ifdef ISC#include "inlinePS2.h"#endif ISCE 41E 38#define	IFPAGE_ADDRESS	512I 36#define DEFAULT_MAX_SYSOUTSIZE		32  /* in Mbyte */#define DEFAULT_PRIME_SYSOUTSIZE	8E 36D 4#define	LISP_SIZE4M	4194304	  /*  4 Mb */#define LISP_SIZE16M	0x1000000 /* 16 M */#define LISP_SIZE24M	0x1800000 /* 24 Mb */#define LISP_SIZE32M	0x2000000 /* 32 Mb */E 4I 4#define MBYTE	0x100000 /* 1 Mbyte */I 7D 10#define roundup( a, b) ((((unsigned)(a)+(b)-1)/(b))*(b))E 7E 4E 10extern int	errno;I 36/* Flag for indication whether process space   is going to expand or not */int Storage_expanded;  /*  T or NIL */I 40  /* RISCOS doesn't have valloc, and malloc works OK there. */D 41#ifdef RISCOSE 41I 41#ifdef SYSVONLYE 41#define valloc mallocD 41#endif RISCOSE 41I 41#endif SYSVONLYE 41E 40E 36I 26D 38char *valloc();E 38I 38D 39char *malloc();E 39I 39char *valloc();E 39E 38I 40/************************************************************************//*									*//*			s y s o u t _ l o a d e r			*//*									*//*	Load the sysout file into memory.				*//*									*//************************************************************************/E 40E 26D 4sysout_loader(sysout_file_name)E 4I 4sysout_loader(sysout_file_name, sys_size)E 4D 40char	*sysout_file_name;I 4int	sys_size;   /* sysout size in megabytes */E 4{E 40I 40  char	*sysout_file_name;  int	sys_size;   /* sysout size in megabytes */  {E 40    int             sysout;	/* SysoutFile descriptor */D 26    char           *malloc();	/* malloc() */    char           *valloc();	/* valloc() */E 26D 8    char           *ifpage_scratch;	/* scratch area for IFPAGE */D 4    IFPAGE         *ifpage;	/* IFAPGE */E 4I 4    IFPAGE         *ifpage;	/* IFPAGE */E 8I 8    IFPAGE         ifpage;	/* IFPAGE */E 8E 4    char           *fptovp_scratch;	/* scratch area for FPTOVP */D 10    DLword         *fptovp;	/* FPTOVP */    long            fptovp_offset;	/* FPTOVP start offset */E 10I 10    DLword         fptovp[0x10000];	/* FPTOVP */    long           fptovp_offset;	/* FPTOVP start offset */E 10    char           *lispworld_scratch;	/* scratch area for lispworld */    long            lispworld_offset;	/* lispworld offset */    unsigned        sysout_size;/* sysout size in page */    struct stat     stat_buf;	/* file stat buf */    int             i, vp;I 6D 7    int             native_start_addr, native_length;E 7I 7D 10    int             native_start_addr_mem_page;    int             native_length_page;    int             native_page_offset;    unsigned        pagsiz;E 10    int             machinetype;I 22    char            errmsg [ 255 ];E 22E 7D 7    native_start_addr = 0;    native_length = 0;E 7I 7D 10    native_start_addr_mem_page = 0;    native_length_page = 0;    native_page_offset = 0;E 10    machinetype = 0;E 7D 36I 7D 10    pagsiz = getpagesize();E 10I 8    /* allocate Virtual Memory Space */I 17D 26#ifdef USEMAP	/* still being debugged */   {    int ptr;	int dummyfd=open(".myvmem", O_RDWR | O_CREAT, 0666 );D 23    	unlink(".myvmem");E 23I 23	unlink(".myvmem");E 23	write(dummyfd, "stuff at the beginning",10);	ptr = lseek(dummyfd, 0, L_XTND);	ptr = lseek(dummyfd, (32*MBYTE)- ptr, L_XTND);	write(dummyfd, "make a hole",1);D 23	lispworld_scratch = mmap(0x100000, 32*MBYTE, PROT_READ|PROT_WRITE, 			 MAP_SHARED,  dummyfd, 0); E 23I 23	lispworld_scratch = mmap(0x100000, 32*MBYTE, PROT_READ|PROT_WRITE,			 MAP_SHARED,  dummyfd, 0);E 23}E 26E 17I 17D 26#elseE 26E 17    lispworld_scratch = valloc(sys_size * MBYTE);D 17    if (lispworld_scratch == NULL) {E 17I 17D 23 E 23I 23E 23D 26#endifE 26   if (lispworld_scratch == NULL) {E 17D 13	printf("sysout_loader: can't allocate Lisp %dMBytes VM \n",sys_size);	exit(-1);E 13I 13D 16		mess_reset();E 16D 18		fprintf(stderr,"sysout_loader: can't allocate Lisp %dMBytes VM \n",									   sys_size);		exit(-1);E 13    }E 18I 18	fprintf(stderr,"sysout_loader: can't allocate Lisp %dMBytes VM \n",								   sys_size);E 36I 36D 40/** CHANGES FOR NEW STORAGE **/E 40I 40E 40    /* Checks for specifying the process size (phase I) */    /* If sys_size == 0 figure out the proper size later */D 40    if((sys_size != 0) && (sys_size < DEFAULT_PRIME_SYSOUTSIZE)) {E 40I 40    if((sys_size != 0) && (sys_size < DEFAULT_PRIME_SYSOUTSIZE))      {E 40	perror("You have to specify more than 8MB for process size");E 36	exit(-1);D 36   }E 36I 36D 40    }    else if ( sys_size > DEFAULT_MAX_SYSOUTSIZE) {E 40I 40      }    else if ( sys_size > DEFAULT_MAX_SYSOUTSIZE)      {E 40	perror("You have to specify less than 32MB for process size");	exit(-1);D 40    }/** CHANGES FOR NEW STORAGE  END**/E 40I 40      }E 40E 36E 18D 10    /* Allocate Start of Native Code Area */         native_load_address = roundup(sbrk(0),pagsiz);E 10D 36    /* now you can access lispworld */    Lisp_world = (DLword *) lispworld_scratch;I 14D 25#ifdef  DEBUGE 14    printf("VM allocated = 0x%x at 0x%x\n",sys_size * MBYTE,lispworld_scratch);    printf("Native Load Address = 0x%x\n",native_load_address);I 14#endifE 25I 25    DBPRINT(("VM allocated = 0x%x at 0x%x\n", sys_size * MBYTE, Lisp_world));    DBPRINT(("Native Load Address = 0x%x\n", native_load_address));E 25E 14E 36D 25E 25E 8E 7E 6    /*D 23     * first read the IFPAGE(InterfacePage) E 23I 23     * first read the IFPAGE(InterfacePage)E 23     */    /* open SysoutFile */    sysout = open(sysout_file_name, O_RDONLY, NULL);D 40    if (sysout == -1) {E 40I 40    if (sysout == -1)      {E 40I 13D 16		mess_reset();E 16E 13D 17	printf("sysout_loader: can't open SysoutFile");E 17I 17D 19	printf("sysout_loader: can't open SysoutFile\n");E 19I 19D 22	perror("sysout_loader: can't open SysoutFile\n");E 22I 22	sprintf( errmsg,D 24                 "sysout_loader: can't open sysout file: %s\n",E 24I 24                 "sysout_loader: can't open sysout file: %s",E 24		 sysout_file_name);	perror( errmsg );E 22E 19E 17	exit(-1);D 40    }E 40I 40      }E 40    /* seek to IFPAGE */D 40    if (lseek(sysout, IFPAGE_ADDRESS, 0) == -1) {E 40I 40    if (lseek(sysout, IFPAGE_ADDRESS, 0) == -1)      {E 40I 13D 16		mess_reset();E 16E 13D 17	printf("sysout_loader: can't seek to IFPAGE");E 17I 17D 19	printf("sysout_loader: can't seek to IFPAGE\n");E 19I 19D 24	perror("sysout_loader: can't seek to IFPAGE\n");E 24I 24	perror("sysout_loader: can't seek to IFPAGE");E 24E 19E 17	exit(-1);D 40    }E 40I 40      }E 40D 8    /* allocate ScratchPage for IFPAGE */    ifpage_scratch = malloc(BYTESPER_PAGE);    if (ifpage_scratch == NULL) {	printf("sysout_loader: can't allocate scratch page");	exit(-1);    }E 8    /* reads IFPAGE into scratch_page */D 8    if (read(sysout, ifpage_scratch, BYTESPER_PAGE) == -1) {E 8I 8D 40    if (read(sysout, &ifpage, sizeof(IFPAGE)) == -1) {E 40I 40    if (read(sysout, &ifpage, sizeof(IFPAGE)) == -1)      {E 40I 13D 16		mess_reset();E 16E 13E 8D 17	printf("sysout_loader: can't read IFPAGE");E 17I 17D 19	printf("sysout_loader: can't read IFPAGE\n");E 19I 19D 24	perror("sysout_loader: can't read IFPAGE\n");E 24I 24	perror("sysout_loader: can't read IFPAGE");E 24E 19E 17	exit(-1);D 40    }E 40I 40      }E 40D 8    /* now you can access IFPAGE */    ifpage = (IFPAGE *) ifpage_scratch;E 8I 20#ifdef BYTESWAPD 28    byte_swap_page(&ifpage, sizeof(IFPAGE)/2);E 28I 28D 30    word_swap_page(&ifpage, sizeof(IFPAGE)/2);E 30I 30D 31    word_swap_page(&ifpage, sizeof(IFPAGE)/4);E 31I 31    word_swap_page(&ifpage, (3+sizeof(IFPAGE))/4);E 31E 30E 28#endifI 36D 40/** CHANGES FOR NEW STORAGE **/E 40I 40E 40#ifdef NEW_STORAGE    if(sys_size == 0)  /* use default or the previous one */D 40    {E 40I 40      {E 40	if(ifpage.process_size == 0) /* Pure LISP.SYSOUT */	  sys_size = DEFAULT_MAX_SYSOUTSIZE;  /* default for pure SYSOUT */	else	  sys_size = ifpage.process_size; /* use previous one */D 40    }E 40I 40      }E 40E 36I 36    /* Checks for specifying the process size (phase II) */D 37    if(((ifpage.storagefullstate == SFS_ARRAYSWITCHED) ||	(ifpage.storagefullstate == SFS_FULLYSWITCHED)) 		&& (sys_size != DEFAULT_MAX_SYSOUTSIZE))E 37I 37    if((ifpage.storagefullstate == SFS_ARRAYSWITCHED) ||       (ifpage.storagefullstate == SFS_FULLYSWITCHED)) E 37     {	/* Storage may be allocated from Secondary space */	/* Therefore you can not change \\DefaultSecondMDSPage */	if(ifpage.process_size != sys_size)	{	fprintf(stderr,"sysout_loader: You can't specify the process size.\n");	fprintf(stderr,"Because, secondary space is already used.\n");	exit(-1);	}	/*Can use this sys_size as the process size */	/* The sys_size should be same as the previous one */	Storage_expanded=NIL;     }    else     {  /* assumes that we can expand the process space */	Storage_expanded=T;	/* You can use secondary space , though it was STORAGEFULL	   So, STORAGEFULL may be set to NIL later  */     }D 40/** CHANGES FOR NEW STORAGE END **/E 40#elseD 40	if(sys_size == 0) {		sys_size = DEFAULT_MAX_SYSOUTSIZE ;	}E 40I 40	if(sys_size == 0) sys_size = DEFAULT_MAX_SYSOUTSIZE;E 40#endif NEW_STORAGEI 40E 40    /* allocate Virtual Memory Space */D 38    lispworld_scratch = valloc(sys_size * MBYTE);E 38I 38D 39    lispworld_scratch = malloc(sys_size * MBYTE);E 39I 39    lispworld_scratch = valloc(sys_size * MBYTE);E 39E 38D 40   if (lispworld_scratch == NULL) {E 40I 40    if (lispworld_scratch == NULL)      {E 40	fprintf(stderr,"sysout_loader: can't allocate Lisp %dMBytes VM \n",								   sys_size);	exit(-1);D 40   }E 40I 40     }E 40    /* now you can access lispworld */    Lisp_world = (DLword *) lispworld_scratch;    DBPRINT(("VM allocated = 0x%x at 0x%x\n", sys_size * MBYTE, Lisp_world));    DBPRINT(("Native Load Address = 0x%x\n", native_load_address));E 36E 20D 8E 8    /*D 23     * get FPTOVP location and SysoutFile size E 23I 23     * get FPTOVP location and SysoutFile sizeE 23     */    /* get FPTOVP location from IFPAGE */D 8    fptovp_offset = ifpage->fptovpstart;E 8I 8    fptovp_offset = ifpage.fptovpstart;I 14D 25#ifdef  DEBUGE 14E 8    printf("FPTOVP Location %d \n", fptovp_offset);I 14#endifE 25E 14I 25    DBPRINT(("FPTOVP Location %d \n", fptovp_offset));E 25    /* get sysout file size in halfpage(256) */D 40    if (fstat(sysout, &stat_buf) == -1) {E 40I 40    if (fstat(sysout, &stat_buf) == -1)      {E 40I 13D 16		mess_reset();E 16E 13D 17	printf("sysout_loader: can't get SysoutFile size");E 17I 17D 19	printf("sysout_loader: can't get SysoutFile size\n");E 19I 19D 22	perror("sysout_loader: can't get SysoutFile size\n");E 22I 22D 24	perror("sysout_loader: can't get sysout file size\n");E 24I 24	perror("sysout_loader: can't get sysout file size");E 24E 22E 19E 17	exit(-1);D 40    }E 40I 40      }E 40    sysout_size = stat_buf.st_size / BYTESPER_PAGE * 2;I 14D 25#ifdef  DEBUGE 14D 5    printf("sysout size = %d\n", sysout_size / 2);E 5I 5D 7    printf("sysout size = 0x%x\n", sysout_size / 2);E 7I 7    printf("sysout size / 2 = 0x%x\n", sysout_size / 2);D 8    printf("vmem size = 0x%x\n", ifpage->nactivepages);E 8I 8    printf("vmem size = 0x%x\n", ifpage.nactivepages);I 14#endifE 25E 14E 8E 7E 5I 25    DBPRINT(("sysout size / 2 = 0x%x\n", sysout_size / 2));    DBPRINT(("vmem size = 0x%x\n", ifpage.nactivepages));E 25I 12D 18	/* do some simple checks to see if this is really a sysout */	if(ifpage.key != IFPAGE_KEYVAL) {I 13D 16		mess_reset();E 16E 13		printf("sysout_loader: %s isn't a sysout:\nkey is %x, should be %x\n",						sysout_file_name, ifpage.key, IFPAGE_KEYVAL);D 13		error("BYE");E 13I 13		exit(1);E 13	}E 18I 18    /* do some simple checks to see if this is really a sysout */D 40    if(ifpage.key != IFPAGE_KEYVAL) {E 40I 40    if(ifpage.key != IFPAGE_KEYVAL)      {E 40	printf("sysout_loader: %s isn't a sysout:\nkey is %x, should be %x\n",			sysout_file_name, ifpage.key, IFPAGE_KEYVAL);	exit(1);D 40    }E 40I 40      }E 40E 18E 12I 7D 8    machinetype = ifpage->machinetype;E 8I 8    machinetype = ifpage.machinetype;E 8E 7D 8	/*****  take ***/	if(( stat_buf.st_size & 0x1ff) != 0)E 8I 8    if(( stat_buf.st_size & 0x1ff) != 0)E 8D 18		printf("CAUTION::sysout & 0x1ff = 0x%x \n", stat_buf.st_size & BYTESPER_PAGE);E 18I 18D 23	printf("CAUTION::sysout & 0x1ff = 0x%x \n", stat_buf.st_size & BYTESPER_PAGE);E 23I 23	printf("CAUTION::sysout & 0x1ff = 0x%x\n",D 40	stat_buf.st_size & BYTESPER_PAGE);E 40I 40		stat_buf.st_size & BYTESPER_PAGE);E 40E 23E 18D 8	if(ifpage->nactivepages !=( sysout_size /2) ) {D 6		printf("sysout_loader:IFPAGE says sysout size is %d \n",ifpage->nactivepages);		printf("But,sysout size from UNIX is %d \n",sysout_size /2);		 error("BYE"); E 6I 6D 7		printf("Machine Type: %d\n",ifpage->machinetype);E 7I 7		printf("Machine Type: %d\n",machinetype);E 7		printf("KATANA: %d\n",KATANA);E 8I 8D 18	if(ifpage.nactivepages != ( sysout_size /2) ) {I 15D 16		mess_reset();E 16E 15E 8D 7		if (ifpage->machinetype == KATANA) {			native_start_addr = ifpage->native_start_addr;			native_length = ifpage->native_length;E 7I 7D 10		if (machinetype == KATANA) {D 8			native_start_addr_mem_page = ifpage->native_start_addr_mem_page;			native_length_page = ifpage->native_length_page;			native_page_offset = ifpage->native_page_offset;E 7			sysout_size = ifpage->nactivepages * 2;E 8I 8			native_start_addr_mem_page = ifpage.native_start_addr_mem_page;			native_length_page = ifpage.native_length_page;			native_page_offset = ifpage.native_page_offset;			sysout_size = ifpage.nactivepages * 2;			printf("Native Info: \n");			printf(" Start_addr: 0x%x\n",native_start_addr_mem_page);			printf(" Length: 0x%x\n",native_length_page);			printf(" Offset: 0x%x\n",native_page_offset);			printf(" Sysout size / 2 = 0x%x\n", sysout_size / 2);E 8		} else {D 8			printf("sysout_loader:IFPAGE says sysout size is %d \n",ifpage->nactivepages);E 8I 8			printf("sysout_loader:IFPAGE says sysout size is %d \n",ifpage.nactivepages);E 8			printf("But,sysout size from UNIX is %d \n",sysout_size /2);			error("BYE"); 		}E 10I 10		printf("sysout_loader:IFPAGE says sysout size is %d \n",ifpage.nactivepages);		printf("But,sysout size from UNIX is %d \n",sysout_size /2);D 13		error("BYE"); E 13I 13		exit(-1); E 13E 10E 6	 }E 18I 18D 40    if(ifpage.nactivepages != ( sysout_size /2) ) {E 40I 40    if(ifpage.nactivepages != ( sysout_size /2) )      {E 40D 23	printf("sysout_loader:IFPAGE says sysout size is %d \n",ifpage.nactivepages);	printf("But,sysout size from UNIX is %d \n",sysout_size /2);	exit(-1); E 23I 23	printf("sysout_loader:IFPAGE says sysout size is %d\n",               ifpage.nactivepages);	printf("But, sysout size from UNIX is %d\n",sysout_size /2);	exit(-1);E 23D 40    }E 40I 40      }E 40E 18D 8    /* free ifpage scratch */    if (free(ifpage_scratch) == -1) {	printf("sysout_loader: can't free scratch_page");	exit(-1);    }E 8    /*D 23     * Now get FPTOVP E 23I 23     * Now get FPTOVPE 23     */D 10    /* allocate fptovp area */D 8    fptovp_scratch = malloc(sysout_size);E 8I 8    fptovp_scratch = (char *) sbrk(sysout_size);E 8    if (fptovp_scratch == NULL) {	printf("sysout_loader: can't allocate FPTOVP");	exit(-1);    }E 10    /* seek to FPTOVP */    fptovp_offset = (fptovp_offset - 1) * BYTESPER_PAGE + 2;D 40    if (lseek(sysout, fptovp_offset, 0) == -1) {E 40I 40    if (lseek(sysout, fptovp_offset, 0) == -1)      {E 40I 13D 21		mess_reset();E 21E 13D 17	printf("sysout_loader: can't seek to FPTOVP");E 17I 17D 19	printf("sysout_loader: can't seek to FPTOVP\n");E 19I 19D 24	perror("sysout_loader: can't seek to FPTOVP\n");E 24I 24	perror("sysout_loader: can't seek to FPTOVP");E 24E 19E 17	exit(-1);D 40    }E 40I 40      }E 40    /* read FPTOVP */D 10    if (read(sysout, fptovp_scratch, sysout_size) == -1) {E 10I 10D 40    if (read(sysout, fptovp, sysout_size) == -1) {E 40I 40    if (read(sysout, fptovp, sysout_size) == -1)      {E 40I 13D 21		mess_reset();E 21E 13E 10D 17	printf("sysout_loader: can't read FPTOVP");	printf("%d\n", errno);E 17I 17D 19	printf("sysout_loader: can't read FPTOVP %d\n", errno);E 19I 19D 24	perror("sysout_loader: can't read FPTOVP\n");E 24I 24	perror("sysout_loader: can't read FPTOVP");E 24E 19E 17	exit(-1);D 40    }E 40I 40      }E 40I 20#ifdef BYTESWAPD 28    byte_swap_page(fptovp, sysout_size/2);E 28I 28D 30    word_swap_page(fptovp, sysout_size/2);E 30I 30D 31    word_swap_page(fptovp, sysout_size/4);E 31I 31    word_swap_page(fptovp, (sysout_size/4)+1);E 31E 30E 28#endifE 20D 10    /* now you can access FPTOVP */    fptovp = (DLword *) fptovp_scratch;E 10D 10E 10    /*D 23     * Last Build the Lisp VM E 23I 23D 26     * Last Build the Lisp VME 26I 26     * Initialize the display (note now passing 68k address!!!)E 26E 23     */D 4    /* allocate 8MBytes Virtual Memory Space (take)*/    lispworld_scratch = valloc(LISP_SIZE24M);E 4I 4D 5    printf("brk = %10d" , sbrk(0));E 5I 5D 10    printf("brk = 0x%x" , sbrk(0));E 5 E 10D 8    /* allocate Virtual Memory Space (take)*/    lispworld_scratch = valloc(sys_size * MBYTE);E 4    if (lispworld_scratch == NULL) {D 4	printf("sysout_loader: can't allocate Lisp %dMBytes VM \n",LISP_SIZE24M>>20);E 4I 4	printf("sysout_loader: can't allocate Lisp %dMBytes VM \n",sys_size);E 4	exit(-1);    }I 5    printf("VM allocated = 0x%x at 0x%x\n",sys_size * MBYTE,lispworld_scratch);    printf("Last Addr = 0x%x, sbrk = 0x%x\n",lispworld_scratch+sys_size*MBYTE,sbrk(0));E 5    /* now you can access lispworld */    Lisp_world = (DLword *) lispworld_scratch;D 4    D 3    init_display();			/* modified by osamu Sep. 3 */E 3I 3    init_display(DISPALY_OFFSET, 65566 * 16);E 4E 3E 8D 4    /* read SysoutFile to 4MB lispworld */E 4I 4D 17#ifdef MEDLEYE 17D 18    init_display(DISPALY_OFFSET, 65536 * 16 * 2);E 18I 18D 26    init_display(DISPLAY_OFFSET, 65536 * 16 * 2);E 26I 26D 28    init_display2(Addr68k_from_LADDR(DISPLAY_OFFSET), 65536 * 16 * 2);E 28I 28D 29    init_display(Addr68k_from_LADDR(DISPLAY_OFFSET), 65536 * 16 * 2);E 29I 29    init_display2(Addr68k_from_LADDR(DISPLAY_OFFSET), 65536 * 16 * 2);E 29E 28E 26E 18D 17#else    init_display(DISPALY_OFFSET, 65536 * 16);#endifE 17I 8D 10#define SKIPPAGES 300E 10D 17E 17D 10E 10E 8D 22    /* read SysoutFile to lispworld */E 22I 22    /* read sysout file to lispworld */E 22I 8E 8E 4D 31    for (i = 0; i < (sysout_size / 2); i++) {D 8 /*	printf("%4d %6o", i, *fptovp); */	if (*fptovp != 0177777) {E 8I 8D 30	if (fptovp[i] != 0177777) {E 30I 30	if (GETBASEWORD(fptovp,i) != 0177777) {E 30E 8	    if (lseek(sysout, i * BYTESPER_PAGE, 0) == -1) {E 31I 31    for (i = 0; i < (sysout_size / 2); i++)      {	if (GETBASEWORD(fptovp,i) != 0177777)	  {	    if (lseek(sysout, i * BYTESPER_PAGE, 0) == -1)	      {E 31I 15D 17		mess_reset();E 15		printf("sysout_loader: can't seek SysoutFile");E 17I 17D 19		printf("sysout_loader: can't seek SysoutFile\n");E 19I 19D 22		perror("sysout_loader: can't seek SysoutFile\n");E 22I 22D 24		perror("sysout_loader: can't seek sysout file\n");E 24I 24		perror("sysout_loader: can't seek sysout file");E 24E 22E 19E 17		exit(-1);D 31	    };E 31I 31	      };E 31D 8	    lispworld_offset = *fptovp * BYTESPER_PAGE;E 8I 8D 30	    lispworld_offset = fptovp[i] * BYTESPER_PAGE;E 30I 30	    lispworld_offset = GETBASEWORD(fptovp,i) * BYTESPER_PAGE;E 30E 8D 18	    if (read(sysout, lispworld_scratch + lispworld_offset, BYTESPER_PAGE) == -1) {E 18I 18	    if (read(sysout, lispworld_scratch +D 30			     lispworld_offset, BYTESPER_PAGE) == -1) {E 30I 30D 31			     lispworld_offset , BYTESPER_PAGE) == -1) {E 31I 31			     lispworld_offset , BYTESPER_PAGE) == -1)	      {E 31E 30E 18I 13D 17		mess_reset();E 13		printf("sysout_loader: can't read SysoutFile at %d", i);E 17I 17D 22		printf("sysout_loader: can't read SysoutFile at %d\n", i);E 22I 22		printf("sysout_loader: can't read sysout file at %d\n", i);I 30D 31		printf("               offset was 0x%x (0x%x pages).\n", lispworld_offset, GETBASEWORD(fptovp,i));E 31I 31		printf("               offset was 0x%x (0x%x pages).\n",		       lispworld_offset, GETBASEWORD(fptovp,i));E 31E 30E 22I 19D 24		perror("read() error was:");E 24I 24		perror("read() error was");E 24E 19E 17		exit(-1);D 31	    };E 31I 31	      };E 31I 20#ifdef BYTESWAPD 28            byte_swap_page(lispworld_scratch+lispworld_offset, 256);E 28I 28D 30            word_swap_page(lispworld_scratch+lispworld_offset, 256);E 30I 30            word_swap_page(lispworld_scratch+lispworld_offset, 128);E 30E 28#endifE 20I 8E 8D 31	};D 8/*	printf("\b\b\b\b\b\b\b\b\b\b\b"); */	fptovp++;E 8    }E 31I 31	  };      }E 31I 14D 25#ifdef  DEBUGE 14D 8    /* free FPTOVP and Scratch Area */    if (free(fptovp_scratch) == -1) {	printf("sysout_loader: can't free fptovp");	exit(-1);    }E 8I 6D 10    printf("Lisp is read completely.\n");I 8    brk(native_load_address);    printf("native_load_address: 0x%x\n",native_load_address);    printf("native_start_addr_mem_page * pagsiz: 0x%x\n",native_start_addr_mem_page * pagsiz);E 8D 7    native_load_address = sbrk(0);E 7I 7D 8    native_load_address = roundup(sbrk(0),pagsiz);E 7I 7E 8E 7	/* Read in NATIVE Code */D 7    if ( (ifpage->machinetype == KATANA) & (native_start_addr) ){E 7I 7D 8    if ( (machinetype == KATANA) & (native_start_addr_mem_page) ){E 8I 8    if ( (machinetype == KATANA) && (native_start_addr_mem_page) ){E 8E 7I 8	sbrk(native_length_page*pagsiz);E 8D 7	if (lseek(sysout, native_start_addr, 0) == -1) {E 7I 7	if (lseek(sysout, native_page_offset*BYTESPER_PAGE, 0) == -1) {E 7		printf("sysout_loader: can't seek to NATIVE CODE");		exit(-1);   		}D 7	if (sbrk(0) != native_start_addr) {E 7I 7	if (native_load_address != (native_start_addr_mem_page * pagsiz)) {E 7		printf("sysout_loader: Memory Size Problem with NATIVE CODE");D 8		exit(-1);E 8I 8		goto skip_native;E 8		}D 7	sbrk(native_length);E 7D 7	printf("Reading Native Code/n");	if (read(sysout, native_start_addr, native_length) == -1) {E 7I 7D 8	printf("Reading Native Code to: 0x%x, from Lisp Page: 0x%x, for 0x%x pages/n",native_load_address,native_page_offset,native_length_page);E 8I 8	printf("Reading Native Code into: 0x%x, from Lisp Page: 0x%x, for 0x%x pages\n",native_load_address,native_page_offset,native_length_page);E 8	if (read(sysout,native_load_address,(native_length_page*pagsiz))==-1) {E 7		printf("sysout_loader: can't read NATIVE CODE");		printf("%d\n", errno);		exit(-1);		}I 8E 8	printf("Native Code read completely./n");    } else { printf("No Native Code to Read\n"); }D 8E 8I 8skip_native:E 10E 8E 6D 22    printf("SysoutFile is read completely.\n");E 22I 22    printf("sysout file is read completely.\n");E 22I 14#endifE 25I 25    DBPRINT(("sysout file is read completely.\n"));E 25E 14I 32#ifdef DISPLAYBUFFER    flush_display_buffer();#endifI 34#ifdef XWINDOW    flush_display_buffer();#endif XWINDOWE 34E 32    close(sysout);I 36    return(sys_size);E 36I 6D 23	E 23I 23D 25E 25E 23E 6D 40}E 40I 40  }E 40E 1