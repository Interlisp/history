h45581s 00062/00049/00399d D 2.11 92/01/16 12:36:13 sybalsky 14 13c DEC/386 changes for byte orderes 00019/00001/00429d D 2.10 91/07/11 12:11:59 sybalsky 13 12c Put in code to fix a potential bug (under ifdef NEVER for now) in atom reading on byteswapped machines.)es 00124/00010/00306d D 2.9 91/04/16 17:29:42 sybalsky 12 11c 3-byte-atom changes - find_symbol speedupes 00000/00000/00316d D 2.8 90/04/20 01:51:10 sybalsky 11 10c AIX:  shortening file names, bulk change.es 00006/00005/00310d D 2.7 90/03/05 17:04:20 takeshi 10 9c Not use GETBYTE in parse_numberes 00107/00077/00208d D 2.6 89/03/17 13:33:41 sybalsky 9 8c Fixed byte-order dependencieses 00001/00001/00284d D 2.5 89/03/03 04:21:16 shih 8 7c typoes 00064/00077/00221d D 2.4 89/03/03 01:56:12 shih 7 6c cleanupes 00000/00079/00298d D 2.3 88/12/12 18:40:37 hayata 6 5c To fix AR10945, obsole code is removed. (create_symbol()). And obsolete extern declaration is removed. (AtomSpace, OneCharAtomBase)es 00020/00020/00357d D 2.2 88/10/17 22:39:38 shih 5 4c minor cleanupes 00000/00000/00377d D 2.1 88/05/17 09:26:07 hayata 4 3c Version up to 2.1es 00002/00018/00375d D 1.3 88/05/08 10:34:44 shimizu 3 2c for URaid modifyes 00002/00002/00391d D 1.2 88/03/13 14:54:58 hayata 2 1c Add SCCS key id (%Z%)es 00393/00000/00000d D 1.1 88/02/24 16:58:06 hayata 1 0c date and time created 88/02/24 16:58:06 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 7/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 7I 7D 14/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 7static char *id = "%Z% %M%	%I% %G%";E 14I 14/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 14E 2D 14/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. */E 14I 14/************************************************************************//*									*//*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************/E 14/**********************************************************************//*D 5 		File Name :	makeatom.cE 5I 5D 7		File Name :	makeatom.cE 7I 7	File Name :	makeatom.cE 7E 5D 7		Desc. :		Create atomE 7I 7	Desc. :		Create atomE 7D 5  				Date :		January 29, 1987 				Edited by :	Takeshi ShimizuE 5I 5D 7				Date :		January 29, 1987				Edited by :	Takeshi ShimizuE 5				Change : create_symbol					  take,30-Jun					  1 May 1987 take					  28 Aug. 1987 takeE 7I 7	Date :		January 29, 1987	Edited by :	Takeshi Shimizu	Change : create_symbol			  take,30-Jun			  1 May 1987 take			  28 Aug. 1987 takeE 7D 7		222 linesD 5 E 5I 5E 5		Including :	make_atom				compute_hash				create_symbol				compare_chars				parse_numberE 7I 7	Including :	make_atom			compute_hash			create_symbol			compare_chars			parse_numberE 7*//**********************************************************************/#include "lispemul.h"#include "address68k.h"#include "lisptypes.h"#include "lispmap.h"#include "cell.h"I 9#include "dbprint.h"E 9#define ATOMoffset	2   /* NIL NOBIND  */D 7#define MAX_ATOMINDEX	0xffff  /* man  number of atom */E 7I 7#define MAX_ATOMINDEX	0xffff  /* max number of atoms */E 7D 9#define Atom_reprobe( hash , char )	(((char ^ hash)| 1) & 63 )E 9I 9#define Atom_reprobe( hash , char )	((((char) ^ (hash))| 1) & 63 )E 9extern DLword *Lisp_world ;/**********************************************************************//*D 7		Func name :	make_atomE 7I 7	Func name :	make_atomE 7D 7				If the atom already existed then return				else create new atom .E 7I 7	If the atom already existed then returnD 9	else create new atom .E 9I 9	else create new atom .  Returns the Atom's index.E 9E 7I 9	This function does not handle FAT pname's.E 9D 7					Date :		January 29, 1987					Edited by :	Takeshi Shimizu					Changed : take 20-Jan					Changed : March 27 '87  take					Changed : May 1 '87 take					Changed : May 9 '87 take					Changed : May 13 '87 take						May 15 '87 takeE 7I 7	Date :		January 29, 1987	Edited by :	Takeshi Shimizu	Changed : take 20-Jan	Changed : March 27 '87  take	Changed : May 1 '87 take	Changed : May 9 '87 take	Changed : May 13 '87 take		May 15 '87 takeE 7*//**********************************************************************/D 9LispPTR make_atom(char_base,offset, length , non_numericp) /* return atomindex */char *char_base;DLword offset;DLword length;D 7short non_numericp; /* if it is NIL then this charas. are treated as NUMBER */E 7I 7short non_numericp; /* if it is NIL then these chars are treated as NUMBER */E 7  /* This Prog. doesn't treat FAT code */{D 6  extern DLword *OneCharAtomBase ; /* may  be AtomSpace +2 */E 6  extern DLword *Spospspace ;D 6  extern DLword *AtomSpace ;E 6  extern DLword *AtomHT ;  extern DLword *Pnamespace  ;  LispPTR parse_number();E 9I 9LispPTR make_atom(char_base,offset, length , non_numericp)    char *char_base;  DLword offset;  DLword length;  short non_numericp; /* if it is NIL then these chars are treated as NUMBER */  {    extern DLword *Spospspace ;    extern DLword *AtomHT ;    extern DLword *Pnamespace  ;    LispPTR parse_number();E 9D 5  E 5I 5E 5D 9  DLword hash;  LispPTR hash_entry ;  /* hash entry contents */  DLword atom_index ;  DLword reprobe ;E 9I 9    DLword hash;    LispPTR hash_entry ;  /* hash entry contents */    DLword atom_index ;    DLword reprobe ;E 9D 9  PNCell *pnptr ;  char *pname_base ;  unsigned short first_char ;E 9I 9    PNCell *pnptr ;    char *pname_base ;    unsigned short first_char ;E 9#ifdef TRACE2D 9	printf("TRACE: make_atom( %s , len= %d, non_numericp = %d)\n",char_base, length , non_numericp);E 9I 9    printf("TRACE: make_atom( %s , offset= %d, len= %d, non_numericp = %d)\n",	   char_base, offset, length , non_numericp);E 9#endifD 9  first_char = (*(char_base + offset) & 0xff) ;  if (length!=0)   {E 9I 9    first_char = (*(char_base+offset)) & 0xff ;    if (length!=0)     {E 9	if(length==1) /* one char. atoms */D 9	{E 9I 9	 {E 9		if (first_char > 57 ) /* greater than '9 */		  return((LispPTR)(ATOMoffset + (first_char -10)) );		else if (first_char > 47) /* between '0 to '9 */			 return((LispPTR)(S_POSITIVE + (first_char - 48)) );				/* fixed S_... mar-27-87 take */			else	/* other one char. atoms */			  return ((LispPTR)(ATOMoffset +first_char));D 9	}  /* if(length==1.. end */E 9I 9	  }  /* if(length==1.. end */E 9D 5	else if ((non_numericp ==NIL) &&(first_char <= '9'))  E 5I 5	else if ((non_numericp ==NIL) &&(first_char <= '9'))E 5	/* more than 10 arithmetic  aon + - mixed atom process */		{			if((hash_entry = parse_number(char_base+offset,length))!=0)				return((LispPTR)hash_entry);						/* if NIL that means THE ATOM is +- mixed litatom */			/* 15 may 87 take */		}D 12	hash = compute_hash(char_base, offset,length) ;E 12I 12	hash = compute_hash(char_base, offset,length, 0) ;E 12   } /* if(lengt.. end */  else  {	hash = 0;	first_char = 255 ;D 5	  } E 5D 7E 7I 5  }E 5D 7/* This point correspond with LP in Lisp source */E 7I 7/* This point corresponds with LP in Lisp source */E 7D 7/* following for loop never exit untill it finds new hash enty or same atom */E 7I 7/* following for loop never exits until it finds new hash enty or same atom */E 7D 5 for(  reprobe=Atom_reprobe(hash ,first_char) ; E 5I 5D 9 for(  reprobe=Atom_reprobe(hash ,first_char) ;E 5	(hash_entry= *(AtomHT+hash)) != 0 ; hash = ((hash + reprobe) & 0xffff)  )  {	atom_index = hash_entry -1 ;E 9I 9    for ( reprobe=Atom_reprobe(hash ,first_char) ;	  (hash_entry= GETWORD(AtomHT+hash)) != 0 ;          hash = ((hash + reprobe) & 0xffff) )      {        atom_index = hash_entry -1 ;E 9	 /* get pname pointer */D 3/**** #ifdef KATANA *****/E 3D 9	pnptr = (PNCell *)GetPnameCell( atom_index);	pname_base= (char *)Addr68k_from_LADDR(pnptr->pnamebase) ;E 9I 9        pnptr = (PNCell *)GetPnameCell( atom_index);        pname_base= (char *)Addr68k_from_LADDR(pnptr->pnamebase) ;E 9D 3/*****#else****//****	pname_base= (char *)Addr68k_from_LADDR(*((int *)Pnamespace + atom_index)) ;****//****#endif****/E 3D 9	if((length == *pname_base ) && (compare_chars(++pname_base,char_base+offset,length) ==T))	 {#ifdef DEBUG		printf("The ATOM has already existed. \n");#endif		  return ( atom_index ); /* find already existed atom */E 9I 9        if ((length == GETBYTE(pname_base) ) &&            (compare_chars(++pname_base,char_base+offset,length) ==T))	  {	    DBPRINT(("FOUND the atom. \n"));	    return ( atom_index ); /* find already existed atom */E 9	  }D 9#ifdef DEBUG	printf("HASH doesn't HIT. reprobe!\n");#endifE 9I 9        DBPRINT(("HASH doesn't hit. reprobe!\n"));E 9D 9  } /* for end */E 9I 9      } /* for end */E 9D 7/* we can't find such that atom , then we should make new atom */E 7I 7/* we can't find that atom, then we should make new atom */E 7D 3/****#ifdef KATANA****/	printf("Can't find such ATOM .\n");	return(NIL);/****#else***//*** atom_index = create_symbol(char_base,length);***//* update hash entry */  /* Added take 30 -Jan *//****  *(AtomHT + hash) = atom_index +1 ; return((LispPTR)atom_index);*****//***#endif***/E 3I 3D 9	return(0xffffffff);E 9I 9    DBPRINT(("HASH NEVER HIT.  Returning -1.\n"));    return(0xffffffff);E 9/** Don't create newatom now **/E 3D 9} /* make_atom end */E 9I 9  } /* make_atom end */E 9/**********************************************************************//*D 7		Func name :	compute_hashE 7I 7	Func name :	compute_hashE 7D 7				Compute hash value from cahrs.E 7I 7	Compute hash value from chars.I 9	THIS ONLY WORKS CORRECTLY ON EMULATOR STRINGS.	Don't use it with strings in lisp-space.E 9E 7D 7					Date :		January 29, 1987					Chan.		Aug. 27 87 take					Edited by :	Takeshi ShimizuE 7I 7	Date :		January 29, 1987	Chan.		Aug. 27 87 take	Edited by :	Takeshi ShimizuE 7*//**********************************************************************/D 7compute_hash(char_base,offset , length )E 7I 7compute_hash ( char_base, offset, length )E 7D 9 char *char_base; DLword offset;D 7 DLword length ;E 7I 7 DLword length;E 7{D 7  DLword hash ;  DLword number ;  DLword temp1,temp2 ;E 7I 7  DLword hash;  DLword number;  DLword temp1,temp2;E 9I 9  char *char_base;  DLword offset;  DLword length;  {    DLword hash;    DLword number;    DLword temp1,temp2;E 9E 7D 12#ifdef TRACE2	printf("TRACE: compute_hash()\n");#endifE 12I 12    DLword *word_base;E 12D 9  char_base +=offset;  hash = (int)(*char_base ) << 8 ; /* get first byte */  char_base++ ; /* skip length area */E 9I 9    char_base +=offset;    hash = (int)(*(char_base)) << 8 ; /* get first byte */    char_base++ ;  /* skip length area */E 9D 7  for (number= 1 ; number <= length -1 ;char_base++,number++)E 7I 7D 9  for (number= 1; number <= length -1; char_base++, number++)E 7	{E 9I 9    for (number= 1; number <= length -1; char_base++, number++)      {E 9D 7		hash = (hash + ((hash & 4095)<< 2 )) & 0x0ffff ;		temp1 = (hash + ((hash & 255) << 8) & 0x0ffff ) ;		hash = (int)(temp1 + *char_base) & 0x0ffff ;E 7I 7	hash  = (hash + ((hash & 4095) << 2)) & 0x0ffff;	temp1 = (hash + ((hash &  255) << 8)) & 0x0ffff;D 9	hash  = (int)(temp1 + *char_base) & 0x0ffff ;E 7	}E 9I 9D 12	hash  = (int)(temp1 + (*char_base)) & 0x0ffff ;E 12I 12	hash  = (int)(temp1 + (*(char_base))) & 0x0ffff ;E 12      }I 12E 12E 9  return (hash);} /* end compute_hash *//**********************************************************************//*I 12	Func name :	compute_lisp_hash	Compute hash value from chars. WORKS ONLY ON LISP CHARS.	Date :		January 29, 1987	Chan.		Aug. 27 87 take	Edited by :	Takeshi Shimizu*//**********************************************************************/compute_lisp_hash ( char_base, offset, length, fatp )  char *char_base;  DLword offset;  DLword length;  DLword fatp;  {    DLword hash;    DLword number;    DLword temp1,temp2;    DLword *word_base;    if (length == 0) return(0);    if (fatp)      { /* fat characters in the string to be searched. */	word_base = (DLword *)char_base;	word_base +=offset;	hash = (DLword)(0xFF & GETWORD(word_base)) << 8 ; /* get first byte */	word_base++ ;  /* skip length area */	for (number= 1; number <= length -1; word_base++, number++)	  {	    hash  = (hash + ((hash & 4095) << 2)) & 0x0ffff;	    temp1 = (hash + ((hash &  255) << 8)) & 0x0ffff;	    hash  = (int)(temp1 + (0xFF & GETWORD(word_base))) & 0x0ffff ;	  }      }    else      {	char_base +=offset;	hash = (int)(0xFF & GETBYTE(char_base)) << 8 ; /* get first byte */	char_base++ ;  /* skip length area */	for (number= 1; number <= length -1; char_base++, number++)	  {	    hash  = (hash + ((hash & 4095) << 2)) & 0x0ffff;	    temp1 = (hash + ((hash &  255) << 8)) & 0x0ffff;	    hash  = (int)(temp1 + (0xFF & GETBYTE(char_base))) & 0x0ffff ;	  }      }  return (hash);} /* end compute_lisp_hash *//**********************************************************************//*E 12D 7		Func name :	compare_charsE 7I 7	Func name :	compare_charsE 7D 7				Compare two stringsE 7I 7D 9	Compare two stringsE 9I 9	Compare two strings, char1, char2		char1 -- in the LISP address space (& potentially			 byte swapped!)		char2 -- in emulator space, and obeying the "natural"			 ordering of bytes in a string.E 9E 7D 7					Date :		January 29, 1987					Edited by :	Takeshi ShimizuD 5E 5I 5			(why not use strncmp??)E 7I 7	Date :		January 29, 1987	Edited by :	Takeshi Shimizu	(why not call strncmp directly??)I 9	Because we need to account for byte ordering!! --JDSE 9E 7E 5*//**********************************************************************/D 12compare_chars( char1 , char2 , length )E 12I 12compare_chars( char1 , char2 , length)E 12D 5char  *char1;char  *char2;DLword length ;E 5I 5D 9register char  *char1;register char  *char2;D 7register DLword length ;E 7I 7register DLword length;E 7E 5{E 9I 9  register char  *char1;  register char  *char2;  register DLword length;  {E 9D 5 short i;E 5I 5D 7 register short i;E 5E 7D 12#ifdef TRACE2D 9	printf("TRACE: compare_chars()\n");E 9I 9    printf("TRACE: compare_chars()\n");E 9#endifE 12I 9#ifndef BYTESWAP    if (strncmp ( char1, char2, length ) == 0)#else    if (bytecmp ( char1, char2, length ))#endif BYTESWAP      {        return(T);      }    else      {	return(NIL);      }E 9D 7  for(i = 0 ; i < length ; i++,*char1++,*char2++)  {	if(*char1 != *char2) return(NIL);  } return (T);E 7I 7D 9if (strncmp ( char1, char2, length ) == 0)D 8	return(T)E 8I 8	return(T);E 8 else   return(NIL);E 7} /* end compare_chars */E 9I 9  } /* end compare_chars */#ifdef BYTESWAPbytecmp (char1, char2, len)  char *char1;  char *char2;  int   len;  {    int index;    for (index=0; index<len; index++)      {	if (GETBYTE(char1++) != *(char2++)) return(0);      }    return(1);  }#endif BYTESWAPI 12/**********************************************************************//*	Func name :	compare_lisp_chars	Compare two strings, char1, char2		in the LISP address space (& potentially		 byte swapped!)	Date :		January 29, 1987	Edited by :	Takeshi Shimizu	(why not call strncmp directly??)	Because we need to account for byte ordering!! --JDS	And for fat/thin differences.	OFFSETs must be accounted for in the pointers already.*//**********************************************************************/compare_lisp_chars( char1 , char2 , length, fat1, fat2)  register char  *char1;  register char  *char2;  register DLword length;  DLword fat1, fat2;  {    if ((!fat1) == (!fat2))D 14      { /* both fat, just double # of chars */I 13#ifdef NEVER 	/* In case the strncmp fails for fat strings sometime....*/E 14I 14      { /* both fat or both non-fat. */#ifdef BYTESWAPE 14     if (fat1)D 14       {E 14I 14       { /* both fat, so compare 'em a word at a time */E 14         int i;         for (i = 0; i < length; i++)           if (GETWORD(char1++) != GETWORD(char2++)) return(NIL);         return(T);               }     elseD 14       {E 14I 14       { /* both thin, so compare 'em a byte at a time */	 /* (it's this way in case we're byte-swapped.)*/E 14         int i;        for (i=0; i< length; i++)           if (GETBYTE(char1++) != GETBYTE(char2++)) return(NIL);         return(T);       }#elseI 14	/* This one fails for byte-swapped machines */E 14E 13	if (fat1) length = length + length;	if (strncmp ( char1, char2, length ) == 0) return(T);D 14	else return(NIL);D 13      }E 13I 13#endif NEVERE 14I 14	else{  return(NIL);}#endif BYTESWAPE 14     }E 13    else if (fat1)      { /* char1 is fat, char2 isn't */	if (lispcmp(char1, char2, length)) return(T);	else return(NIL);      }    else      { /* char2 is fat, char1 isn't */	if (lispcmp(char2, char1, length)) return(T);	else return(NIL);      }D 14  } /* end compar_lispe_chars */E 14I 14  } /* end compare_lisp_chars */E 14lispcmp (char1, char2, len)  DLword *char1;  char *char2;  int   len;  {    int index;    for (index=0; index<len; index++)      {	if (GETWORD(char1++) != GETBYTE(char2++)) return(0);      }    return(1);  }E 12E 9D 7D 6/**#ifndef KATANA**/D 5#ifdef OBSOLATEE 5I 5#ifdef OBSOLETEE 5/**********************************************************************//*		Func name :	create_symbol				Actualy create atom symbol					Date :		January 29, 1987					Edited by :	Takeshi Shimizu					Changed :		take(January 30, 1987)*//**********************************************************************/create_symbol(char_base , length )  char *char_base ;  DLword length ;{ extern DLword AtomFrLst ; /* Num of Atoms ever registed */ DLword *alloc_pname_chars(); DLword nword; /* number of word this ATOM needs */ DLword atom_index ; /* this ATOM's index */ char *pname_base ; /* points area keeps raw ASCII code */ LispPTR *pname_slot ; /* keep address that was translated from LADDR */ short i;#ifdef TRACE2	printf("TRACE: create_symbols()\n");#endif /* check limit */ if((atom_index = AtomFrLst) >= MAX_ATOMINDEX)   error ("ATOM exceeded ");/*******************************************************//*  COMMENT OUT January 30, 1987 *//* if((length+1)%4 == 0 )*/ /* Cell(4 byte) align ? *//*	ncell = (length+1) >>2; else	ncell = ((length+1) >>2)+1 ;*//*******************************************************/ if((length+1)%2 == 0) /*WORD allign */	nword = (length+1) >>1 ; else	nword = ((length+1) >>1)+1 ; /* get area */ pname_base= (char *)alloc_pname_chars(nword); /* Get selected PNPSPACE 68addr */ pname_slot = (LispPTR *)Pnamespace + atom_index ; /* replace selected PNPSPACE contents */ *pname_slot =(LispPTR) LADDR_from_68k(pname_base); /* write out length */ *pname_base++ = length ; /* copy char. code */ for(i=0; i<length ; i++,char_base++,pname_base++)  {	*pname_base = *char_base ;  } AtomFrLst++ ; /* add num of atoms */ return(atom_index);} /* create_symbol end */#endifE 6E 7/*********************************************************************//*D 7		Func name :	parse_numberE 7I 7	Func name :	parse_numberE 7D 7		Desc	:	It can treat -65534 to 65535 interger				Returns SMALLP PTRD 5		Date : 		1,May 1987 TakeE 5I 5		Date :		1,May 1987 TakeE 5				15 May 87 takeE 7I 7	Desc	:	It can treat -65534 to 65535 integer			Returns SMALLP PTR	Date :		1,May 1987 Take			15 May 87 takeE 7*//*********************************************************************/I 7I 10/* Assume this func. should be called with C string in "char_base" */E 10E 7LispPTR parse_number(char_base,length)D 14char *char_base;short length ;{  register LispPTR sign_mask ;  register LispPTR val ;  register int radix ;  register int *cell68k;E 14I 14  char *char_base;  short length ;  {    register LispPTR sign_mask ;    register LispPTR val ;    register int radix ;    register int *cell68k;E 14D 14  LispPTR *createcell68k();E 14I 14    LispPTR *createcell68k();E 14#ifdef TRACE2D 14	printf("TRACE: parse_number()\n");E 14I 14    printf("TRACE: parse_number()\n");E 14#endifD 14/* Check for Radix 8(Q) postfixed ?? */D 9 if( (*(char_base +(length -1))) == 'Q')E 9I 9D 10 if( (GETBYTE(char_base +(length -1))) == 'Q')E 10I 10 if( (*(char_base +(length -1))) == 'Q')E 10E 9  {D 9  radix= 8;  length--;E 9I 9    radix= 8;    length--;E 9  }D 5 else E 5I 5 elseE 5  radix = 10 ;E 14I 14    /* Check for Radix 8(Q) postfixed ?? */    if( (*(char_base +(length -1))) == 'Q')      {	radix= 8;	length--;      }    else radix = 10 ;E 14D 14/* Check for Sign */ sign_mask =S_POSITIVE ;E 14I 14    /* Check for Sign */    sign_mask =S_POSITIVE ;E 14D 9  if((*char_base == '+') || (*char_base == '-'))E 9I 9D 10  if((GETBYTE(char_base) == '+') || (GETBYTE(char_base) == '-'))E 10I 10D 14  if((*(char_base) == '+') || (*(char_base) == '-'))E 10E 9  {E 14I 14    if((*(char_base) == '+') || (*(char_base) == '-'))      {E 14D 9	sign_mask = (*char_base++ =='+') ? S_POSITIVE : S_NEGATIVE ;E 9I 9D 10	sign_mask = (GETBYTE(char_base++) =='+') ? S_POSITIVE : S_NEGATIVE ;E 10I 10	sign_mask = ((*char_base++) =='+') ? S_POSITIVE : S_NEGATIVE ;E 10E 9	length--;D 7E 7D 14  }E 14I 14      }E 14D 14  for(val=0;length>0;length--)  {E 14I 14    for(val=0;length>0;length--)      {E 14D 9	if ( ((*char_base) < '0' ) || ( '9' < (*char_base)) )E 9I 9D 10	if ( ((GETBYTE(char_base)) < '0' ) || ( '9' < (GETBYTE(char_base))) )E 10I 10	if ( (((*char_base)) < '0' ) || ( '9' < ((*char_base))) )E 10E 9		return(NIL);D 9	val = radix * val + (*char_base++) - '0' ;E 9I 9D 10	val = radix * val + GETBYTE(char_base++) - '0' ;E 10I 10	val = radix * val + (*char_base++) - '0' ;E 10E 9D 14  }E 14I 14      }E 14D 7  if(val > 0xffffffff)  error("parse_number : Overflow ...exceeded range of FIXP");E 7I 7D 14  if(val > 0xffffffff)E 14I 14    if(val > 0xffffffff)E 14	error("parse_number : Overflow ...exceeded range of FIXP");E 7D 5 E 5I 5E 5D 7  if((sign_mask ==S_POSITIVE)&&(val >0xffff))E 7I 7D 14  if((sign_mask == S_POSITIVE)&&(val > 0xffff))E 7  {E 14I 14    if((sign_mask == S_POSITIVE)&&(val > 0xffff))      {E 14	cell68k = (int *)createcell68k(TYPE_FIXP);	*cell68k = val ;	return(LADDR_from_68k(cell68k));D 14  }D 7  else if((sign_mask == S_NEGATIVE) && (val >0xffff))E 7I 7  else if((sign_mask == S_NEGATIVE) && (val > 0xffff))E 7  {E 14I 14      }    else if((sign_mask == S_NEGATIVE) && (val > 0xffff))      {E 14	cell68k =(int *) createcell68k(TYPE_FIXP);D 5 	*cell68k = ~val +1 ;E 5I 5	*cell68k = ~val +1 ;E 5	return(LADDR_from_68k(cell68k));D 7E 7D 14  }E 14I 14      }E 14D 14  else if(sign_mask == S_NEGATIVE)E 14I 14    else if(sign_mask == S_NEGATIVE)E 14	return(sign_mask | (~((DLword)val) + 1));D 14  else {E 14I 14    else      {E 14	return(sign_mask | val);D 7	 }E 7I 7D 14	}E 7}E 14I 14      }  }E 14 /* end parse_number */E 1