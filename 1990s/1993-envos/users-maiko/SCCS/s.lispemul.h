h20903s 00080/00011/00581d D 2.31 93/02/08 15:04:37 sybalsky 42 41c Big VM (and new CDR coding) changes for 3.0 \nes 00035/00032/00557d D 2.30 92/10/22 09:46:29 sybalsky 41 40c misc changes and restore other files sans change \nes 00007/00003/00582d D 2.29 92/06/26 14:27:26 sybalsky 40 39c retrofit of Apollo poort changes \nes 00027/00000/00558d D 2.28 92/05/27 19:15:11 sybalsky 39 38c retrofit of 386 unix changes \nes 00012/00002/00546d D 2.27 92/04/23 10:58:10 sybalsky 38 37c sfixing SCCS header \nes 00001/00001/00547d D 2.26 92/04/21 16:30:16 sybalsky 37 36c shortening file names for DOSes 00010/00022/00538d D 2.25 91/12/11 04:01:25 sybalsky 36 35c Change MSB to xMSB, to avoid conflict with HPUX header file.es 00008/00000/00552d D 2.24 91/09/27 04:07:50 sybalsky 35 34c Fix LispString ToCString.es 00001/00000/00551d D 2.23 91/05/01 16:08:09 sybalsky 34 33c Retrofit changes from MIPS porting center.es 00004/00000/00547d D 2.22 91/04/09 17:53:22 sybalsky 33 32c Retrofit first round of changes from MIPS porting centeres 00012/00013/00535d D 2.21 91/02/04 12:57:36 sybalsky 32 31c 3-byte atomses 00023/00000/00525d D 2.20 91/01/16 13:19:26 sybalsky 31 30c Add NEWATOM typedef, offsets for value cell &c for new atoms.es 00061/00003/00464d D 2.19 90/09/18 23:51:18 sybalsky 30 29c Retrofit changes from AIX, DEC3100, PS/2es 00034/00000/00433d D 2.18 90/07/26 11:34:32 sybalsky 29 28c Move big-atom AtomNo macros from inlineC & tosfuncalles 00024/00009/00409d D 2.17 90/07/04 03:50:39 sybalsky 28 27c Change DTD so type-name field is 24 bits, rather than 16.es 00012/00001/00406d D 2.16 90/06/04 13:01:04 sybalsky 27 26c reformat, copyrightes 00093/00067/00314d D 2.15 89/12/13 11:02:47 sybalsky 26 25c string-conversion safety addedes 00042/00043/00339d D 2.14 89/04/07 20:19:45 shih 25 24c bad sccsides 00006/00000/00376d D 2.13 89/03/30 11:02:43 sybalsky 24 23c Added WBITSPTRes 00000/00000/00376d D 2.12 89/03/28 01:44:28 sybalsky 23 22c more 386 workes 00131/00038/00245d D 2.11 89/03/23 12:56:32 sybalsky 22 21c Added byte-swapped defs for 386es 00008/00000/00275d D 2.10 88/12/01 13:49:28 krivacic 21 20c Add SUN3_OS4_IL & SUN3_OS3_OR_OS4_IL Flags, and move asm labels to inlines.es 00001/00000/00274d D 2.9 88/10/18 12:29:55 krivacic 20 19c add PROFILE to NOASM ifdefes 00013/00000/00261d D 2.8 88/10/13 19:29:40 krivacic 19 18c ifdef cleanuupes 00008/00011/00253d D 2.7 88/10/12 14:48:14 krivacic 18 17c new out-of-line interfacees 00011/00013/00253d D 2.6 88/10/10 14:13:07 krivacic 17 16c sun3/4 mergees 00037/00006/00229d D 2.5 88/10/05 17:02:21 krivacic 16 15c sun 3 / 4 mergees 00001/00000/00234d D 2.4 88/07/29 17:37:45 shimizu 15 14c Add SAVE_ERROR_EXITes 00001/00000/00233d D 2.3 88/07/27 14:52:48 shimizu 14 13c Add TIMER_EXITes 00001/00026/00232d D 2.2 88/05/31 20:28:39 masinter 13 12c remove obsolete macroses 00000/00000/00258d D 2.1 88/05/17 09:18:17 hayata 12 11c Version up to 2.1es 00001/00002/00257d D 1.10 88/05/13 10:02:32 hayata 11 10c Add SCCS keyides 00001/00001/00258d D 1.9 88/05/10 17:34:44 krivacic 10 9c change do_stackoverflow(T) calles 00000/00001/00259d D 1.8 88/04/25 12:26:21 krivacic 9 8c removeNative_Hash_Sizees 00003/00000/00257d D 1.7 88/04/21 16:36:12 krivacic 8 7c GET_NATIVE_ADDR macro to get Native entry address from fn objectes 00007/00002/00250d D 1.6 88/04/11 12:21:01 shimizu 7 6c Add new option,TRADSTACKOVER.es 00002/00001/00250d D 1.5 88/04/07 14:50:19 shimizu 6 5c Add WARN macroes 00012/00000/00239d D 1.4 88/03/31 11:00:39 shimizu 5 4c Add DOSTACKOVERFLOWes 00001/00001/00238d D 1.3 88/03/13 13:22:29 hayata 4 3c Add SCCS key id (%Z%)es 00005/00000/00234d D 1.2 88/03/09 13:40:44 krivacic 3 1c Added ERROR_EXIT macroes 00001/00001/00233d R 1.2 88/03/07 18:20:16 krivacic 2 1c Added ERROR_EXIT macroes 00234/00000/00000d D 1.1 88/02/23 18:36:44 hayata 1 0c date and time created 88/02/23 18:36:44 by hayataeuUtTI 1D 4/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 4I 4D 7/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 7I 7D 11/* This is G-file @(#) lispemul.h Version 1.5 (4/7/88). copyright Xerox & Fuji Xerox  */E 7E 4E 11I 11D 18/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 18I 18D 25/* This is G-file @(#) lispemul.h Version 2.6 (10/10/88). copyright Xerox & Fuji Xerox  */E 25I 25D 26/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 26I 26D 27/* @(#) lispemul.h Version 2.14 (4/7/89). copyright envos & Fuji Xerox  */E 27I 27D 30/* @(#) lispemul.h Version 2.14 (4/7/89). copyright Venue & Fuji Xerox  */E 30I 30D 42/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 42I 42/* %Z% %M% Version %I% (%G%). copyright Venue   */E 42E 30E 27E 26I 30E 30E 25E 18E 11/*D 25 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *E 25D 13 *	Auther	:	Takeshi ShimizuE 13I 13 *	Author	:	Takeshi ShimizuE 13 *			Hiroshi Hayata	D 13 * MERGED AT AISE 13 */D 36/**********************************************************************//*D 25 		File Name :	lispemul.h(newv)E 25I 25 		File Name :	lispemul.hE 36E 25D 25		Definitions for LispEmulater E 25I 25D 36		Definitions for LispEmulatorE 36E 25D 36 			Date :		December 07, 1987 			Edited by :	Takeshi Shimizu				04-Jan-88 Take(Get_DLword)			05-Jan-88 Take(INTSTAT)*//**********************************************************************/I 27E 36/************************************************************************//*									*/D 36/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 36I 36D 38/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*/E 38I 38/*	(C) Copyright 1989-1992 Venue. All Rights Reserved.		*/E 38/*	Manufactured in the United States of America.			*/E 36/*									*/D 36/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 36I 36/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 36/*									*//************************************************************************/E 27I 19D 36E 36#ifdef NOASM#undef SUN3_OS3_ILI 21#undef SUN3_OS4_ILE 21#undef SUN4_OS4_IL#undef OPDISP#undef NATIVETRAN#undef UNSAFEI 20#undef PROFILEE 20#define NOASMFNCALL	1#endifI 21#ifdef SUN3_OS3_IL#define SUN3_OS3_OR_OS4_IL	1#endif#ifdef SUN3_OS4_IL#define SUN3_OS3_OR_OS4_IL	1#endifE 21I 30	/****************************************************************/	/*								*/	/*  Architecture-specific flags:  Set flags			*/	/*  based on thing we know about the architecture		*/	/*  or idiosyncracies of the machine we're compiling for.	*/	/*								*/	/*  Defaults:	Unaligned fetches OK	UNALIGNED_FETCH_OK	*/	/*		type char is signed	SIGNED_CHARS		*/I 38	/*		fp values used with				*/	/*		FPTEST can be in regs.	REGISTER		*/E 38	/*								*/	/****************************************************************/	/* Set up defaults */#define UNALIGNED_FETCH_OKI 38#define REGISTER registerE 38D 32#define SIGNED_CHARSE 32#ifdef suntypedef char s_char;D 42#endif sunE 42I 42#endif /* sun */E 42I 42E 42	/* SPARCs and MIPSs can't do unaligned word-loads */#ifdef sparc#undef UNALIGNED_FETCH_OKD 32#define SIGNED_CHARSE 32D 42#endif SPARCE 42I 42#endif /* SPARC */E 42I 42E 42#ifdef DEC3100#undef UNALIGNED_FETCH_OKI 41#ifdef OSF1typedef signed char s_char;#endif /* OSF1 */E 41D 32#define SIGNED_CHARSE 32D 42#endif DEC3100E 42I 42#endif /* DEC3100 */E 42I 42E 42D 32#ifdef PS2E 32I 32#ifdef AIXPS2typedef signed char s_char;I 39#define GCC386E 39E 32#endifI 32#ifdef HPUXtypedef char s_char;#define valloc malloc#define seteuid(x) setresuid(-1, (x), -1)#define getwd(x) getcwd((x), MAXPATHLEN)#define getrusage(x, y) #define getpagesize() 4096#undef UNALIGNED_FETCH_OK#endifE 32#ifdef RS6000D 32#undef SIGNED_CHARSE 32typedef signed char s_char;D 40#endif RS6000E 40I 40#endif /* RS6000 */E 40D 32#if (defined(sparc)) || (defined(DEC3100))#undef UNALIGNED_FETCH_OK#else#define UNALIGNED_FETCH_OK 1#endif sparc | DEC3100E 32I 33#ifdef RISCOStypedef signed char s_char;I 34#undef UNALIGNED_FETCH_OKE 34#endifI 35#ifdef ISCtypedef signed char s_char;#undef UNALIGNED_FETCH_OK#define MAXPATHLEN MAXNAMLEN#define EWOULDBLOCK EAGAIN#define getwd(x) getcwd((x), MAXPATHLEN)I 39 /* we compile on a 386 with GCC, so can use optimizations. */#define GCC386#define RESWAPPEDCODESTREAME 39D 40#endif ISCE 40I 40#endif /* ISC */E 40I 38#ifdef INDIGOtypedef signed char s_char;#undef UNALIGNED_FETCH_OK#undef REGISTER#define REGISTER#endif /* INDIGO */E 38E 35E 33I 40#ifdef APOLLOtypedef signed char s_char;#endif /* APOLLO */E 40I 38I 40E 40E 38	/****************************************************************/	/* 	    End of architecture-specific flag settings		*/	/****************************************************************/E 30D 22E 19/** typedef struct {unsigned int code : 8;} BYTECODE; **/E 22I 22#ifndef BYTESWAP	/*** Normal byte-order type decls */E 22D 38typedef struct {unsigned code : 8;} BYTECODE;E 38I 38D 40typedef struct {unsigned char code : 8;} BYTECODE;E 40I 40typedef struct {unsigned char code;} BYTECODE;E 40E 38typedef char ByteCode;typedef unsigned short  DLword;typedef char  DLbyte;typedef unsigned int  LispPTR;D 22typedef struct  consstr { 		  unsigned cdr_code : 8 ;		  unsigned car_field : 24 ;	} ConsCell;E 22/* 32 bit Cell Chang. 14 Jan 87 take */D 25typedef DLword mds_page ;  /* Top word of the MDS */typedef (*CFuncPTR)() ;E 25I 25typedef DLword mds_page;  /* Top word of the MDS */typedef (*CFuncPTR)();E 25I 42#ifdef BIGVME 42I 22D 25typedef struct  consstr { 		  unsigned cdr_code : 8 ;		  unsigned car_field : 24 ;E 25I 25D 26typedef struct  consstr {		  unsigned cdr_code  : 8;		  unsigned car_field : 24;E 25	} ConsCell;E 22typedef struct ufn_entry {D 25		DLword atom_name ;   /* UFN's atomindex */D 16		unsigned unknown : 6 ;		unsigned byte_num : 2 ; /* num of byte code */E 16I 16		unsigned byte_num : 8 ; /* num of byte code */E 16		unsigned arg_num : 8 ;  /* num of argments */	} UFN ;E 25I 25		DLword atom_name;   /* UFN's atomindex */		unsigned byte_num : 8; /* num of byte code */		unsigned arg_num  : 8; /* num of argments */	} UFN;E 25typedef struct closure_type {D 25		unsigned nil1 : 8 ;		unsigned def_ptr : 24 ; /* LispPTR to definition cell */		unsigned nil2 : 8 ;		unsigned env_ptr : 24 ; /* LispPTR to environment */	} Closure ;E 25I 25		unsigned nil1    :  8;		unsigned def_ptr : 24; /* LispPTR to definition cell */		unsigned nil2    :  8;		unsigned env_ptr : 24; /* LispPTR to environment */	} Closure;E 26I 26typedef struct  consstr  {I 42    unsigned cdr_code  : 4;    unsigned car_field : 28;  } ConsCell;typedef struct ufn_entry  {    DLword atom_name;   /* UFN's atomindex */    unsigned byte_num : 8; /* num of byte code */    unsigned arg_num  : 8; /* num of argments */  } UFN;typedef struct closure_type  {    unsigned nil1    :  4;    unsigned def_ptr : 28; /* LispPTR to definition cell */    unsigned nil2    :  4;    unsigned env_ptr : 28; /* LispPTR to environment */  } Closure;#else /* not BIGVM */typedef struct  consstr  {E 42    unsigned cdr_code  : 8;    unsigned car_field : 24;  } ConsCell;E 26E 25D 26typedef struct interrupt_state {		unsigned nil1			:3;		unsigned gcdisabled		:1;		unsigned vmemfull		:1;		unsigned stackoverflow		:1;		unsigned storagefull		:1;		unsigned waitinginterrupt	:1;D 25		DLword   intcharcode ;	} INTSTAT ;E 25I 25		DLword   intcharcode;	} INTSTAT;E 26I 26typedef struct ufn_entry  {    DLword atom_name;   /* UFN's atomindex */    unsigned byte_num : 8; /* num of byte code */    unsigned arg_num  : 8; /* num of argments */  } UFN;E 26E 25D 26struct state{D 17	DLword	*ivar;	DLword	*pvar;I 16#ifdef MVEC	DLword		*csp;	LispPTR	 	tosvalue;	ByteCode 	*currentpc;	struct fnhead 	*currentfunc;	DLword 		*endofstack;	int 		irqcheck;	int 		irqend;#endifE 17I 17	DLword		*ivar;		/* + 0 */	DLword		*pvar;		/* + 4 */	DLword		*csp;		/* + 8 */	LispPTR	 	tosvalue;	/* + 12 */	ByteCode 	*currentpc;	/* + 16 */	struct fnhead 	*currentfunc;	/* + 20*/	DLword 		*endofstack;	/* + 24*/	int 		irqcheck;	/* + 28 */	int 		irqend;		/* + 32 */	LispPTR		scratch_cstk;	/* + 34 */I 18	int		errorexit;	/* + 38 */E 18E 17E 16};E 26I 26typedef struct closure_type  {    unsigned nil1    :  8;    unsigned def_ptr : 24; /* LispPTR to definition cell */    unsigned nil2    :  8;    unsigned env_ptr : 24; /* LispPTR to environment */  } Closure;I 42#endif /* BIGVM */E 42E 26I 26typedef struct interrupt_state  { /* Interrupt-request mask to communicate with INTERRUPTED */D 28    unsigned LogFileIO		:1;	/* console msg arrived to print */    unsigned ETHERInterrupt	:1;	/* 10MB activity happened */    unsigned IOInterrupt	:1;	/* I/O happened (not used yet) */E 28I 28    unsigned LogFileIO		:1; /* console msg arrived to print */    unsigned ETHERInterrupt	:1; /* 10MB activity happened */    unsigned IOInterrupt	:1; /* I/O happened (not used yet) */E 28    unsigned gcdisabled		:1;    unsigned vmemfull		:1;    unsigned stackoverflow	:1;    unsigned storagefull	:1;    unsigned waitinginterrupt	:1;D 28    unsigned nil2		:8;E 28I 28    unsigned nil	:8;	    /* mask of ints being processes */E 28    DLword   intcharcode;  } INTSTAT;I 28typedef struct interrupt_state_2  { /* alternate view of the interrupt state */    unsigned pendingmask	:8;    unsigned handledmask	:8;    DLword   nil;  } INTSTAT2;E 28struct state  {    DLword		*ivar;		/* + 0 */    DLword		*pvar;		/* + 4 */    DLword		*csp;		/* + 8 */    LispPTR	 	tosvalue;	/* + 12 */    ByteCode 		*currentpc;	/* + 16 */    struct fnhead 	*currentfunc;	/* + 20*/    DLword 		*endofstack;	/* + 24*/    int 		irqcheck;	/* + 28 */    int 		irqend;		/* + 32 */    LispPTR		scratch_cstk;	/* + 34 */    int			errorexit;	/* + 38 */  };E 26I 22/***** Get_DLword(ptr) ptr is char* ***/D 30#ifdef sparcE 30I 30#ifndef UNALIGNED_FETCH_OKE 30D 25#define Get_DLword(ptr)		((Get_BYTE(ptr) <<8) | Get_BYTE(ptr+1)) E 25I 25#define Get_DLword(ptr)		((Get_BYTE(ptr) <<8) | Get_BYTE(ptr+1))E 25#else#define Get_DLword(ptr)		*(((DLword *)WORDPTR(ptr)))#endifI 26I 42#ifdef BIGVM#define Get_Pointer(ptr)   ((Get_BYTE(ptr) << 24) | 	\			    (Get_BYTE(ptr+1) << 16) | 	\			    (Get_BYTE(ptr+2) << 8) | Get_BYTE(ptr+3))#elseE 42I 29#define Get_Pointer(ptr)   ((Get_BYTE(ptr) << 16) | 	\D 42			    (Get_BYTE(ptr+1) << 8) | 	\E 42I 42			    (Get_BYTE(ptr+1) << 8) | \E 42			    Get_BYTE(ptr+2))I 42#endif /* BIGVM */E 42I 39#define Get_code_BYTE Get_BYTE#define Get_code_DLword Get_DLword#define Get_code_AtomNo Get_AtomNo#define Get_code_Pointer Get_PointerE 39#ifdef BIGATOMS#define Get_AtomNo(ptr)	Get_Pointer(ptr)#else#define Get_AtomNo(ptr) Get_DLword(ptr)D 42#endif BIGATOMSE 42I 42#endif /* BIGATOMS */E 42I 42E 42E 29E 26/* For bit test */D 26typedef	struct wbits{	unsigned MSB	:1;	unsigned B1	:1;	unsigned B2	:1;	unsigned B3	:1;	unsigned B4	:1;	unsigned B5	:1;	unsigned B6	:1;	unsigned B7	:1;	unsigned B8	:1;	unsigned B9	:1;	unsigned B10	:1;	unsigned B11	:1;	unsigned B12	:1;	unsigned B13	:1;	unsigned B14	:1;	unsigned LSB	:1;}WBITS;E 26I 26typedef	struct wbits  {D 36    unsigned MSB :1;E 36I 36D 41    unsigned xMSB :1;E 36    unsigned B1  :1;    unsigned B2	 :1;    unsigned B3	 :1;    unsigned B4	 :1;    unsigned B5  :1;    unsigned B6	 :1;    unsigned B7	 :1;    unsigned B8	 :1;    unsigned B9	 :1;    unsigned B10 :1;    unsigned B11 :1;    unsigned B12 :1;    unsigned B13 :1;    unsigned B14 :1;    unsigned LSB :1;E 41I 41    unsigned short xMSB :1;    unsigned short B1  :1;    unsigned short B2	 :1;    unsigned short B3	 :1;    unsigned short B4	 :1;    unsigned short B5  :1;    unsigned short B6	 :1;    unsigned short B7	 :1;    unsigned short B8	 :1;    unsigned short B9	 :1;    unsigned short B10 :1;    unsigned short B11 :1;    unsigned short B12 :1;    unsigned short B13 :1;    unsigned short B14 :1;    unsigned short LSB :1;E 41  }WBITS;E 26D 26typedef	struct lbits{	unsigned MSB	:1;	unsigned MIDDLE	:30;	unsigned LSB	:1;}LBITS;E 26I 26typedef	struct lbits  {D 36    unsigned MSB	:1;E 36I 36    unsigned xMSB	:1;E 36    unsigned MIDDLE	:30;    unsigned LSB	:1;  }LBITS;E 26#else	/*** Byte-swapped structure declarations, for 80386 ***/D 30typedef struct {unsigned code : 8;} BYTECODE;E 30I 30typedef struct {unsigned char code;} BYTECODE;E 30typedef char ByteCode;typedef unsigned short  DLword;typedef char  DLbyte;typedef unsigned int  LispPTR;/* 32 bit Cell Chang. 14 Jan 87 take */D 25typedef DLword mds_page ;  /* Top word of the MDS */typedef (*CFuncPTR)() ;E 25I 25typedef DLword mds_page;  /* Top word of the MDS */typedef (*CFuncPTR)();E 25typedef struct consstrD 25  {     unsigned car_field : 24 ;    unsigned cdr_code : 8 ;E 25I 25  {    unsigned car_field : 24;    unsigned cdr_code  :  8;E 25  } ConsCell;typedef struct ufn_entry  {D 25    unsigned arg_num : 8 ;  /* num of argments */    unsigned byte_num : 8 ; /* num of byte code */    DLword atom_name ;   /* UFN's atomindex */  } UFN ;E 25I 25    unsigned arg_num  : 8; /* num of argments */    unsigned byte_num : 8; /* num of byte code */    DLword atom_name;   /* UFN's atomindex */  } UFN;E 25typedef struct closure_type  {D 25    unsigned def_ptr : 24 ; /* LispPTR to definition cell */    unsigned nil1 : 8 ;    unsigned env_ptr : 24 ; /* LispPTR to environment */    unsigned nil2 : 8 ;  } Closure ;E 25I 25    unsigned def_ptr : 24; /* LispPTR to definition cell */    unsigned nil1    :  8;    unsigned env_ptr : 24; /* LispPTR to environment */    unsigned nil2    :  8;  } Closure;E 25typedef struct interrupt_stateD 26  {E 26I 26  { /* Interrupt-request mask to communicate with INTERRUPTED */E 26D 25    DLword   intcharcode ;E 25I 25    DLword   intcharcode;I 26D 28    unsigned nil2		:8;E 28I 28    unsigned nil		:8;E 28E 26E 25    unsigned waitinginterrupt	:1;    unsigned storagefull	:1;    unsigned stackoverflow	:1;D 26    unsigned vmemfull	:1;    unsigned gcdisabled	:1;    unsigned nil1	:3;E 26I 26    unsigned vmemfull		:1;D 28    unsigned gcdisabled		:1;    unsigned IOInterrupt	:1;	/* I/O happened (not used yet) */    unsigned ETHERInterrupt	:1;	/* 10MB activity happened */    unsigned LogFileIO		:1;	/* console msg arrived to print */E 28I 28    unsigned gcdisabled	:1;    unsigned IOInterrupt	:1; /* I/O happened (not used yet) */    unsigned ETHERInterrupt	:1; /* 10MB activity happened */    unsigned LogFileIO		:1; /* console msg arrived to print */E 28E 26D 25  } INTSTAT ;E 25I 25  } INTSTAT;I 28typedef struct interrupt_state_2  { /* alternate view of the interrupt state */    DLword   nil;    unsigned handledmask	:8;    unsigned pendingmask	:8;  } INTSTAT2;E 28E 25struct state  {    DLword		*ivar;		/* + 0 */    DLword		*pvar;		/* + 4 */    DLword		*csp;		/* + 8 */    LispPTR	 	tosvalue;	/* + 12 */D 25    ByteCode 	*currentpc;	/* + 16 */E 25I 25    ByteCode 		*currentpc;	/* + 16 */E 25    struct fnhead 	*currentfunc;	/* + 20*/    DLword 		*endofstack;	/* + 24*/    int 		irqcheck;	/* + 28 */    int 		irqend;		/* + 32 */    LispPTR		scratch_cstk;	/* + 34 */D 25    int		errorexit;	/* + 38 */E 25I 25    int			errorexit;	/* + 38 */E 25  };/* Fetching 2 bytes to make a word -- always do it the hard way *//* if we're byte-swapped:  You can't rely on byte ordering!!    */D 25#define Get_DLword(ptr)		((Get_BYTE(ptr) <<8) | Get_BYTE(ptr+1)) E 25I 25#define Get_DLword(ptr)		((Get_BYTE(ptr) <<8) | Get_BYTE(ptr+1))I 29#define Get_Pointer(ptr)   ((Get_BYTE(ptr) << 16) | 	\			    (Get_BYTE(ptr+1) << 8) | 	\			    Get_BYTE(ptr+2))I 39#ifndef RESWAPPEDCODESTREAM#define Get_code_BYTE(ptr) Get_BYTE(ptr)#define Get_code_AtomNo Get_AtomNo#define Get_code_DLword Get_DLword#else#define Get_code_BYTE(ptr) (((BYTECODE *)(ptr))->code)#define Get_code_Pointer(ptr) ((Get_code_BYTE(ptr) << 16) | \							   (Get_code_BYTE(ptr+1) << 8) | \							   Get_code_BYTE(ptr+2))#define Get_code_DLword(ptr) ((Get_code_BYTE(ptr) << 8) | Get_code_BYTE(ptr+1))#define Get_code_AtomNo Get_code_PointerD 42#endif RESWAPPEDCODESTREAME 42I 42#endif /* RESWAPPEDCODESTREAM */E 42I 42E 42E 39#ifdef BIGATOMS#define Get_AtomNo(ptr)	Get_Pointer(ptr)#else#define Get_AtomNo(ptr) Get_DLword(ptr)D 42#endif BIGATOMSE 42I 42#endif /* BIGATOMS */E 42I 42E 42E 29E 25/* For bit test */typedef	struct wbits  {D 41	unsigned LSB	:1;	unsigned B14	:1;	unsigned B13	:1;	unsigned B12	:1;	unsigned B11	:1;	unsigned B10	:1;	unsigned B9	:1;	unsigned B8	:1;	unsigned B7	:1;	unsigned B6	:1;	unsigned B5	:1;	unsigned B4	:1;	unsigned B3	:1;	unsigned B2	:1;	unsigned B1	:1;D 36	unsigned MSB	:1;E 36I 36	unsigned xMSB	:1;E 41I 41	unsigned short LSB	:1;	unsigned short B14	:1;	unsigned short B13	:1;	unsigned short B12	:1;	unsigned short B11	:1;	unsigned short B10	:1;	unsigned short B9	:1;	unsigned short B8	:1;	unsigned short B7	:1;	unsigned short B6	:1;	unsigned short B5	:1;	unsigned short B4	:1;	unsigned short B3	:1;	unsigned short B2	:1;	unsigned short B1	:1;	unsigned short xMSB	:1;E 41E 36  } WBITS;typedef	struct lbits  {    unsigned LSB	:1;    unsigned MIDDLE	:30;D 36    unsigned MSB	:1;E 36I 36    unsigned xMSB	:1;	/* xMSB b/c HPUX defined MSB in a header */E 36  } LBITS;D 42#endif BYTESWAPE 42I 42#endif /* BYTESWAP */E 42I 42E 42I 24	/* Because a WBITS is only 1 word long, need byte-swapped */	/* access to it.  Use WBITSPTR(x) instead of ((WBITS *) x) */#define WBITSPTR(ptr) ((WBITS *) WORDPTR(ptr))E 24E 22I 16D 17#ifdef MVECE 17extern struct state MachineState;#define MState (&MachineState)#define CURRENTFX 	((struct  frameex1 *)(((DLword *) PVar) - FRAMESIZE))#define	IVar		MState->ivar#define PVar		MState->pvar#define CurrentStackPTR MState->csp#define TopOfStack  	MState->tosvalue#define PC 		MState->currentpc#define FuncObj 	MState->currentfunc#define EndSTKP 	MState->endofstack#define Irq_Stk_Check   MState->irqcheck#define Irq_Stk_End	MState->irqendD 17#endifE 17I 17#define Scratch_CSTK	MState->scratch_cstkI 18#define Error_Exit	MState->errorexitE 18E 17E 16/* Typedef for IFPAGE */#include "ifpage.h"/* Typedef for IOPAGE */#include "iopage.h"/* Typedef for MISCSTAT */D 37#include "miscstats.h"E 37I 37#include "miscstat.h"E 37/**************************************************** MakeAddr:	base:	DLword*		offset:	word offset from base	return:	DLword*	****************************************************/#define MakeAddr(base, offset)		((DLword *)(base + (int)offset))/****************************************************GetHiWord:*****************************************************/#define GetHiWord(x)		((DLword)((x)>>16))/****************************************************GetLoWord:*****************************************************/#define GetLoWord(x)		((DLword)(x))/****************************************************GetLongWord:	address:	DLword*		retrun:		int*****************************************************/#define GetLongWord(address)		(*((int *) (address)))/****************************************************PopCStack:#define PopCStack	{TopOfStack = *((int *)(--CurrentStackPTR)); --CurrentStackPTR;}*****************************************************/#define PopCStack	{TopOfStack = *((LispPTR *)(CurrentStackPTR)); CurrentStackPTR -= 2;}/****************************************************PopStackTo:  CSTK -> Place#define PopStackTo(Place)	{Place= *((LispPTR *)(--CurrentStackPTR)); CurrentStackPTR--; }*****************************************************/#define PopStackTo(Place)	{Place= *((LispPTR *)(CurrentStackPTR)); CurrentStackPTR -= 2; }/****************************************************PushCStack:#define PushCStack	{*((int *)(++CurrentStackPTR)) = TopOfStack; ++CurrentStackPTR;}*****************************************************/#define PushCStack	{CurrentStackPTR += 2;*((LispPTR *)(CurrentStackPTR)) = TopOfStack; }/****************************************************PushStack:#define PushStack(x)	{*((LispPTR *)(++CurrentStackPTR))=x;CurrentStackPTR++;}*****************************************************/#define PushStack(x)	{CurrentStackPTR += 2;*((LispPTR *)(CurrentStackPTR))=x;}/****************************************************D 25SmashStack:  E 25I 25SmashStack:E 25#define SmashStack(x)	(*((LispPTR *)(CurrentStackPTR-1))=x)*****************************************************/#define SmashStack(x)	(*((LispPTR *)(CurrentStackPTR))=x)/*********************************************************Get_BYTE(byteptr)	byteptr: pointer to  8 bit data**********************************************************//***** OLD definition ************* 13 Nov 1987 takeshi ***#define Get_BYTE(byteptr)	(((unsigned)(*(byteptr))) & 0xff)**********************************************/D 22#define Get_BYTE(byteptr)	(((BYTECODE *)(byteptr))->code)E 22I 22#define Get_BYTE(byteptr)	(((BYTECODE *)BYTEPTR(byteptr))->code)E 22D 13/****************************************************StackCheck  This macro can be used only at the end of opcode.*****************************************************/#define StackCheck	(CurrentStackPTR >= StkLimO)/****************************************************StackOverflow  This macro can be used only at the end of opcode.*****************************************************/#define StackOverflow	{contextsw(SubovFXP, 0,0);}E 13/**********************************************************D 13FnStkOvr(argnum,bytenum) call as InCall**********************************************************/#define FnStkOvr(argnum,bytenum) { \				PushStack(S_POSITIVE | argnum); \				contextsw(SubovFXP,bytenum,1); }I 7#ifdef TRADSTACKOVER#define DOSTACKOVERFLOW(argnum,bytenum) { \		FnStkOvr(argnum,bytenum) ; \		return; }#elseE 7I 5/**********************************************************E 13DOSTACKOVERFLOW(argnum,bytenum) if it needs hardreturn-cleanupD 26	then upnt to contextsw and immidiatery returnE 26I 26	then upnt to contextsw and immediately returnE 26**********************************************************/#define DOSTACKOVERFLOW(argnum,bytenum) { \D 10			if(do_stackoverflow())  \E 10I 10			if(do_stackoverflow(T))  \E 10			{	PushStack(S_POSITIVE | argnum); \				contextsw(SubovFXP,bytenum,1); \				return;\			} \		}D 13E 5D 7E 7I 7#endifE 7I 3E 13E 3D 22/***** Get_DLword(ptr) ptr is char* ***/D 16#ifdef SPARCE 16I 16#ifdef sparcE 16#define Get_DLword(ptr)		((Get_BYTE(ptr) <<8) | Get_BYTE(ptr+1)) #else#define Get_DLword(ptr)		*(((DLword *)(ptr)))#endifE 22I 3D 26E 26I 26/************************************************************************//*									*//*		E R R O R   &   T I M E R   P U N T   C A S E S		*//*									*//*	Set up the top-of-stack so we can continue gracefully after	*//*	handling the timer interrupt (e.g., FMEMB, which walks down	*//*	the list being searched, pushes its current state on TOS	*//*	so that it picks up where it left off after the interrupt.	*//*									*/E 26D 16E 16I 16D 18#define SAVE_ERROR_EXIT(tos, x) {TopOfStack=tos; ERROR_EXIT(x);}#ifdef NOASM/* use longjmp interface for ufn calls */#define ERROR_EXIT(x)	{return(error_exit(0));}#define TIMER_EXIT(x) 	{return(error_exit(-2));}#else/* use assembly language for ufn calls */E 16#define	ERROR_EXIT(x) 	{return(fixra(x));}I 15D 16#define SAVE_ERROR_EXIT(tos , x) {TopOfStack = tos; return(fixra(x));}E 15I 14#define TIMER_EXIT(x)	{return(fixra(x));}E 16I 16#define TIMER_EXIT(x) 	{return(fixra(x));}#endifE 18I 18/*	Call Interface where neg number indicates an error return	*/I 26/*									*//************************************************************************/E 26#define ERROR_EXIT(tos)		{TopOfStack=tos; Error_Exit = 1; return(-1);}I 39#ifdef ISC#define INLINE_ERROR_EXIT(tos,retlbl) {TopOfStack=tos; Error_Exit=1 asm("movl $-1,%0\n" retlbl ":" : "=g" (result) : "0" (result)); return(result); }#endifE 39#define TIMER_EXIT(tos)		{TopOfStack=tos; Error_Exit = 1; return(-2);}E 18E 16E 14E 3D 6E 6I 6#define WARN(message,operation)	{warn(message);operation;return;}#define NO_WOP	{}E 6#define NIL	0	/* added 29-jan */#define T	1#define ATOM_T	0114	/* T's AtomIndex Number 114Q */#define NIL_PTR		0   /* from cell.h 24-mar-87 take */#define NOBIND_PTR	1		#define STKLIM		0x1FFFF#define FRAMESIZE	10		/* size of frameex1: 10 words */#define FNHEADSIZE	8		/* size of fnhead: 8 words */#define BFSIZE	2		/* size of basci frame pointer: 2 words */#define BITSPER_DLWORD		16#define BITSPER_CELL		32#define BYTESPER_DLWORD		2	#define BYTESPER_CELL		4#define BYTESPER_QUAD		8#define BYTESPER_PAGE		512#define CELLSPER_QUAD		2#define CELLSPER_PAGE		128#define CELLSPER_SEGMENT	32768#define DLWORDSPER_CELL		2#define DLWORDSPER_QUAD		4#define DLWORDSPER_PAGE		256#define DLWORDSPER_SEGMENT	65536#define PAGESPER_SEGMENT	256#define PAGESPER_MDSUNIT	2#define MDSINCREMENT		512#define GUARDSTORAGEFULL	128#define GUARD1STORAGEFULL	64#define SFS_NOTSWITCHABLE	1#define SFS_SWITCHABLE		2#define SFS_ARRAYSWITCHED	3#define SFS_FULLYSWITCHED	4#define AtomHTSIZE		256 * DLWORDSPER_PAGE#define MAXPNCHARS		255    /* Maximam length of PnChars */D 9#define Native_Hash_Size      0xFFFFE 9I 8#define GET_NATIVE_ADDR(fnobject)					\		*((int *) ((int)fnobject + fnobject->startpc - 4))I 29/************************************************************************//*	Define sizes of FN and FNX opcodes; depends on atom size	*//************************************************************************/D 42#ifdef BIGATOMSE 42I 42#ifdef BIGVM#define FN_OPCODE_SIZE 5#define FNX_OPCODE_SIZE 6#elif defined(BIGATOMS)E 42#define FN_OPCODE_SIZE 4#define FNX_OPCODE_SIZE 5#else#define FN_OPCODE_SIZE 3#define FNX_OPCODE_SIZE 4D 42#endif BIGATOMSE 42I 42#endif /* BIGATOMS */E 42E 29I 31I 42E 42/************************************************************************//*									*//*			Definitions for "NEW" Symbols			*//*									*//*	Offsets within the "New	 symbols that go with 3-byte atoms.	*//*									*//************************************************************************/#ifdef BIGATOMStypedef struct newatom  {    LispPTR na_pname;	/* Pointer to the print name */    LispPTR na_value;	/* The value cell */    LispPTR na_defn;	/* The definition cell */    LispPTR na_plist;	/* The property list */I 42	LispPTR na_flags;	/* flags from other cells, to make BIGVM work ok */E 42  } NEWATOM;I 42  /* Offsets, in WORDS, from the start of the NEWATOM structure */E 42#define NEWATOM_PNAME_OFFSET    0#define NEWATOM_VALUE_OFFSET    2#define NEWATOM_DEFN_OFFSET     4#define NEWATOM_PLIST_OFFSET    6I 42  /* Offsets, in cells from start of the NEWATOM structure */#define NEWATOM_PNAME_PTROFF    0#define NEWATOM_VALUE_PTROFF    1#define NEWATOM_DEFN_PTROFF     2#define NEWATOM_PLIST_PTROFF    3E 42#endifI 42/************************************************************************//*									*//*	Mask to mask off relevant bits in a pointer.			*//*									*//************************************************************************/#ifdef BIGVM#define POINTERMASK 0xfffffff#define SEGMASK     0xfff0000#define PAGEMASK    0xfffff00#else#define POINTERMASK 0xffffff#define SEGMASK     0xff0000#define PAGEMASK    0xffff00#endif /* BIGVM */E 42E 31E 8D 22/* For bit test */typedef	struct wbits{	unsigned MSB	:1;	unsigned B1	:1;	unsigned B2	:1;	unsigned B3	:1;	unsigned B4	:1;	unsigned B5	:1;	unsigned B6	:1;	unsigned B7	:1;	unsigned B8	:1;	unsigned B9	:1;	unsigned B10	:1;	unsigned B11	:1;	unsigned B12	:1;	unsigned B13	:1;	unsigned B14	:1;	unsigned LSB	:1;}WBITS;typedef	struct lbits{	unsigned MSB	:1;	unsigned MIDDLE	:30;	unsigned LSB	:1;}LBITS;E 22E 1