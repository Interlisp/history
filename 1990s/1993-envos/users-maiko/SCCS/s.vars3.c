h59684s 00023/00016/00170d D 2.15 93/02/08 15:01:08 sybalsky 20 19c Big VM (and new CDR coding) changes for 3.0 \nes 00004/00004/00182d D 2.14 92/04/21 17:28:56 sybalsky 19 18c shortening file names for DOS \nes 00013/00001/00173d D 2.13 90/06/04 18:10:42 sybalsky 18 17c reformat, copyrightes 00000/00000/00174d D 2.12 90/04/20 02:08:41 sybalsky 17 16c AIX:  shortening file names, bulk change.es 00003/00003/00171d D 2.11 90/02/06 11:48:17 sybalsky 16 15c Comments, plus timer-interrupt fixes to FMEMB, ASSCOes 00000/00000/00174d D 2.10 89/03/27 23:27:42 sybalsky 15 14c no changeses 00006/00008/00168d D 2.9 88/10/12 14:46:11 krivacic 14 13c new out-of-line interfacees 00001/00129/00175d D 2.8 88/10/10 14:11:05 krivacic 13 12c sun3/4 mergees 00001/00001/00303d D 2.7 88/07/29 17:34:47 shimizu 12 11c Add SAVE_ERROR_EXIT and S_N_CHECKANDCADRes 00004/00001/00300d D 2.6 88/07/27 14:50:41 shimizu 11 10c N_OP_assoc punt by TIMER_EXIT and be able to continue the ececution.es 00006/00009/00295d D 2.5 88/07/08 11:01:00 bane 10 9c Fixed N_OP in bad context bug in {CL}ASSOCes 00013/00069/00291d D 2.4 88/06/28 20:51:55 bane 9 8c Made ASSOC opcode punt much less...es 00003/00000/00357d D 2.3 88/06/08 09:55:02 charnley 8 7c added interrupt test to assoces 00007/00003/00350d D 2.2 88/05/31 20:16:41 masinter 7 6c put obsolete code into c_only ifdefes 00000/00000/00353d D 2.1 88/05/17 09:27:48 hayata 6 5c Version up to 2.1es 00104/00000/00249d D 1.4 88/03/31 15:11:37 krivacic 5 4c storen, copyn, arg0, assoces 00002/00002/00247d D 1.3 88/03/13 15:10:17 hayata 4 2c Add SCCS key id (%Z%)es 00000/00000/00249d R 1.3 88/03/04 14:57:38 hayata 3 2c For Testes 00003/00003/00246d D 1.2 88/03/03 11:39:54 krivacic 2 1c Removed global CurrentFX to use CURRENTFX = PVAR - FRAMESIZEes 00249/00000/00000d D 1.1 88/02/24 16:59:06 hayata 1 0c date and time created 88/02/24 16:59:06 by hayataeuUtTI 1D 4/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 4I 4D 16/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 16I 16D 18/* This is G-file @(#) vars3.c Version 2.10 (3/27/89). copyright Xerox & Fuji Xerox  */E 18I 18D 20/* This is G-file @(#) vars3.c Version 2.10 (3/27/89). copyright Venue & Fuji Xerox  */E 18static char *id = "@(#) vars3.c	2.10 3/27/89";E 20I 20/* %Z% %M% Version %I% (%G%). copyright venue  */static char *id = "%Z% %M%	%I% %G%	(venue)";E 20E 16E 4D 7/*** ADOPTED NEW VERSION ***/E 7D 20/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 7 *	Auther	:	Hiroshi Hayata	E 7I 7 *	Author	:	Hiroshi Hayata	E 7 */E 20I 18/************************************************************************//*									*/D 20/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 20I 20/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 20/*									*/D 20/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 20I 20/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 20/*									*//************************************************************************/D 20E 20E 18#include	<stdio.h>#include	"lispemul.h"D 19#include	"lispglobal.h"E 19I 19#include	"lspglob.h"E 19#include	"lispmap.h"D 19#include	"address68k.h"#include	"emulglobal.h"E 19I 19#include	"adr68k.h"#include	"emlglob.h"E 19#include	"cell.h"D 19#include	"lisptypes.h"E 19I 19#include	"lsptypes.h"E 19#include	"stack.h"/* def. of car_cell moved to cell.h */I 8D 13extern int Irq_Stk_End;E 13E 8struct cadr_cell cadr();I 7D 13#ifdef C_ONLYE 7/***********************************************************OP_arg0	Entry:	ARG0	opcode[0141]	<Entry>	TopOfStack : slot number of IVAR area	<Exit>	TopOfStack : the contents of the slot.	No effect to CurrentStack.************************************************************/OP_arg0(){int	num;DLword	*bf;	/* index of Basic frame */int	nargs;#ifdef	TRACE	printPC();	printf("TRACE: OP_arg0()\n");#endif 	if( (0xFFFF0000 & TopOfStack ) != S_POSITIVE){		/* error("OP_arg0: Bad TopOfStack\n"); */		ufn(0141);		return;	}else		num = 0xFFFF & TopOfStack;D 2	if(CurrentFX->alink & 0x1){E 2I 2	if(CURRENTFX->alink & 0x1){E 2		/* slow */#ifdef	DEBUG	printf("DEBUG:OP_arg0[access BasicFrame by slow]\n");#endifD 2		bf = Stackspace + CurrentFX->blink;E 2I 2		bf = Stackspace + CURRENTFX->blink;E 2	}else{		/* fast */#ifdef	DEBUG	printf("DEBUG:OP_arg0[access BasicFrame by fast]\n");#endifD 2		bf = ((DLword *)CurrentFX) - BFSIZE;E 2I 2		bf = ((DLword *)CURRENTFX) - BFSIZE;E 2	/* bf : pointer to 1st word of BasicFramePointer */	}	nargs = ((int)bf - (int)IVar)>>2;		/* nargs : number of IVAR slots */	if((num ==0) || (num > nargs)){#ifdef	DEBUG		printf("DEBUG:OP_arg0[argument number is %d, target argument is %d]\n", nargs, num);#endif		/* error("OP_arg0: Bad argument number\n"); */		ufn(0141);		return;	}	TopOfStack = *((int *)IVar + num - 1);		++PC;}/*******************************************OP_assoc	Entry:	ASSOC	opcode[026]	TopOfStack -- A-list (cons cell of Lisp address)	*(int *)(CurrentStackPTR) -- Key (cons cell of Lisp address) *******************************************/OP_assoc(){D 9LispPTR	key;	/* address of cons cell; Lisp address */E 9I 9register LispPTR	key;	/* address of cons cell; Lisp address */E 9struct cadr_cell cadr1;D 9struct cadr_cell cadr2;LispPTR	cdr;	/* address of (cdr A-list); Lisp address */LispPTR	caar;	/* address of (caar A-list); Lisp address */E 9I 9register LispPTR	cdr;	/* address of (cdr A-list); Lisp address */E 9D 9#ifdef	TRACE	printPC();	printf("TRACE: OP_assoc()\n");#endifE 9	if(TopOfStack == NIL_PTR){		/* if A-list is NIL, return NIL. */ D 9#ifdef	DEBUG	printf("DEBUG:OP_assoc[A-list is NIL]\n");#endifE 9		CurrentStackPTR -= 2;		++PC;		return;	}	D 10	if(GetTypeNumber( TopOfStack ) != TYPE_LISTP){E 10I 10	if(!Listp( TopOfStack )){E 10D 9#ifdef	DEBUG	printf("DEBUG:OP_assoc[A-list is not LISTP]\n");#endifE 9		TopOfStack = NIL_PTR;		CurrentStackPTR -= 2;		++PC;		return;	}	/*CSP	key = *( (LispPTR *)(CurrentStackPTR-1) );	*/	key = *( (LispPTR *)(CurrentStackPTR) );D 9#ifdef	DEBUG	printf("DEBUG:OP_assoc[key:%x]\n",key);#endifE 9	CheckAndCadr(TopOfStack, cadr1, 026);D 9	/* cadr1 = cadr(TopOfStack); */E 9	do{		cdr = cadr1.cdr_cell;	/* the rest of A-list */D 9		CheckAndCadr(cadr1.car_cell, cadr2, 026);		/* cadr2 = cadr(cadr1.car_cell); */		if(key == cadr2.car_cell){E 9I 9D 10		if(GetTypeNumber(cadr1.car_cell) == TYPE_LISTP		&& key == N_OP_car(cadr1.car_cell, 026)){E 10I 10		if(Listp(cadr1.car_cell) && key == car(cadr1.car_cell)){E 10E 9		/* cons data found */D 9#ifdef	DEBUG	printf("DEBUG:OP_assoc[find dotted pair!]\n");#endifE 9			TopOfStack = cadr1.car_cell;			CurrentStackPTR -= 2;			++PC;			return;		}		/* search the rest of A-list */D 9#ifdef	DEBUG	printf("DEBUG:OP_assoc[search the rest of A-list]\n");#endif		CheckAndCadr(cadr1.cdr_cell, cadr1, 026);		/* cadr1 = cadr(cadr1.cdr_cell); */E 9I 9D 10		if(GetTypeNumber(cdr) == TYPE_LISTP)E 10I 10		if(Listp(cdr))E 10			cadr1 = cadr(cdr);		else cdr = NIL;E 9	}while(cdr != NIL_PTR);	TopOfStack = NIL_PTR;	CurrentStackPTR -= 2;	++PC;	return;}I 7#endifE 7/*******************************************E 13I 13/*******************************************E 13cadrD 7	common rourtime.E 7I 7	common routine.E 7	used by OP_assoc, OP_fmemb*******************************************/struct cadr_cellcadr(cell_adr)LispPTR	cell_adr;	/* address of cell */			/* Lisp address (word addressing) */{ConsCell	*pcons;struct cadr_cell	cadr1;	/* return value */short	offset;D 9#ifdef	TRACE	printf("cadr(%x)\n", cell_adr);#endifE 9	if( Listp(cell_adr) == NIL)		if(cell_adr == NIL){D 9#ifdef	DEBUG	printf("DEBUG:cadr[cell_adr is NIL]\n");#endifE 9			cadr1.car_cell = 0;			cadr1.cdr_cell = 0;			return(cadr1);		} else {			cadr1.car_cell = car(cell_adr);			cadr1.cdr_cell = cdr(cell_adr);			return(cadr1);		}	pcons = (ConsCell *)Addr68k_from_LADDR(cell_adr);	while( pcons->cdr_code == CDR_INDIRECT ){D 9#ifdef	DEBUG	printf("DEBUG:cadr[cdr_code is CDR_INDIRECT]\n");#endifE 9		/* CDR indirect */		cell_adr = pcons->car_field;		pcons = (ConsCell *)Addr68k_from_LADDR(pcons->car_field);	}/* skip CDR_INDIRECT cell */		cadr1.car_cell = pcons->car_field;D 9#ifdef	DEBUG	printf("DEBUG:cadr[car_cell: %x]\n",pcons->car_field);#endif	E 9	if( pcons->cdr_code == CDR_NIL ){		/* CDR nil */D 9#ifdef	DEBUG	printf("DEBUG:cadr[cdr_code is CDR_NIL]\n");#endifE 9		cadr1.cdr_cell = NIL_PTR;		return(cadr1);	}D 20	E 20I 20#ifdef NEWCDRCODING	offset = (0x7 & pcons->cdr_code) << 1;	if(pcons->cdr_code > CDR_NIL){		/* CDR on page */		cadr1.cdr_cell = cell_adr + offset;	}else{		/* CDR different page */		pcons = (ConsCell *)Addr68k_from_LADDR( (cell_adr) + offset) ;		cadr1.cdr_cell = pcons->car_field;	}#elseE 20	offset = (0x7F & pcons->cdr_code) << 1;	if(pcons->cdr_code > CDR_NIL){		/* CDR on page */D 9#ifdef	DEBUG	printf("DEBUG:cadr[cdr_code is CDRonPage]\n");#endifE 9D 20		cadr1.cdr_cell = (0xFFFF00 & cell_adr) | offset;E 20I 20		cadr1.cdr_cell = (PAGEMASK & cell_adr) | offset;E 20	}else{		/* CDR different page */D 9#ifdef	DEBUG	printf("DEBUG:cadr[cdr_code is CDRdifferentPage]\n");#endifE 9D 20		pcons = (ConsCell *)Addr68k_from_LADDR( ((0xFFFF00 & cell_adr) | offset) );E 20I 20		pcons = (ConsCell *)Addr68k_from_LADDR( ((PAGEMASK & cell_adr) | offset) );E 20		cadr1.cdr_cell = pcons->car_field;	}I 20#endif /* NEWCDRCODING */E 20D 9#ifdef	DEBUG	printf("DEBUG:cadr[return val. car_cell(%x) cdr_cell(%x)]\n",cadr1.car_cell, cadr1.cdr_cell);#endif	E 9	return(cadr1);}I 5I 7D 13#ifndef C_ONLYE 7E 13/***********************************************************N_OP_arg0	Entry:	ARG0	opcode[0141]	<Entry>	TopOfStack : slot number of IVAR area	<Exit>	return : the contents of the slot.	No effect to CurrentStack.************************************************************/D 14LispPTR N_OP_arg0(tos, error_addr)E 14I 14LispPTR N_OP_arg0(tos)E 14	register LispPTR tos;D 14	int *error_addr;E 14{register int	num;register DLword	*bf;	/* index of Basic frame */register int	nargs;D 9#ifdef	TRACE	printf("TRACE: N_OP_arg0()\n");#endifE 9 D 20	if( (0xFFFF0000 & tos ) != S_POSITIVE){E 20I 20	if( (SEGMASK & tos ) != S_POSITIVE){E 20		/* error("OP_arg0: Bad TopOfStack\n"); */D 14		ERROR_EXIT(error_addr);E 14I 14		ERROR_EXIT(tos);E 14	}else		num = 0xFFFF & tos;	if(CURRENTFX->alink & 0x1){		/* slow */		bf = Stackspace + CURRENTFX->blink;	}else{		/* fast */		bf = ((DLword *)CURRENTFX) - BFSIZE;	/* bf : pointer to 1st word of BasicFramePointer */	}	nargs = ((int)bf - (int)IVar)>>2;		/* nargs : number of IVAR slots */	if((num ==0) || (num > nargs)){		/* error("OP_arg0: Bad argument number\n"); */D 14		ERROR_EXIT(error_addr);E 14I 14		ERROR_EXIT(tos);E 14	}	return(*((int *)IVar + num - 1));	}/*******************************************N_OP_assoc	Entry:	ASSOC	opcode[026]	TopOfStack -- A-list (cons cell of Lisp address)	*(int *)(CurrentStackPTR) -- Key (cons cell of Lisp address) *******************************************/D 14LispPTR N_OP_assoc(key, list, error_addr)E 14I 14LispPTR N_OP_assoc(key, list)E 14	register LispPTR key;	register LispPTR list;D 14	int *error_addr;E 14{register struct cadr_cell cadr1;D 9register struct cadr_cell cadr2;E 9register LispPTR	cdr;	/* address of (cdr A-list); Lisp address */D 9register LispPTR	caar;	/* address of (caar A-list); Lisp address */E 9D 9#ifdef	TRACE	printf("TRACE: N_OP_assoc()\n");#endifE 9	if (list == NIL_PTR) { return(NIL_PTR); }	D 10	if (GetTypeNumber( list ) != TYPE_LISTP) { return(NIL_PTR); }E 10I 10	if (!Listp( list )) { return(NIL_PTR); }E 10	D 12	N_CHECKANDCADR(list, cadr1, error_addr);E 12I 12D 14	S_N_CHECKANDCADR(list, cadr1, error_addr, list);E 14I 14	S_N_CHECKANDCADR(list, cadr1, list);E 14E 12D 9	/* cadr1 = cadr(list); */E 9	do{		cdr = cadr1.cdr_cell;	/* the rest of A-list */D 9		N_CHECKANDCADR(cadr1.car_cell, cadr2, error_addr);		/* cadr2 = cadr(cadr1.car_cell); */		if(key == cadr2.car_cell){E 9I 9D 10		if(GetTypeNumber(cadr1.car_cell) == TYPE_LISTP		&& key == N_OP_car(cadr1.car_cell, error_addr)){E 10I 10		if(Listp(cadr1.car_cell) && key == car(cadr1.car_cell)){E 10E 9		/* cons data found */			return(cadr1.car_cell);		}		/* search the rest of A-list */I 9D 10		if(GetTypeNumber(cdr) == TYPE_LISTP)E 10I 10		if(Listp(cdr))E 10			cadr1 = cadr(cdr);		else cdr = NIL;		/* check for interrupts and punt to handle one safely */E 9I 8D 11		if (!Irq_Stk_End) ERROR_EXIT(error_addr);E 11I 11		if (!Irq_Stk_End) {			TopOfStack = cdr; /* for next execution */D 14			TIMER_EXIT(error_addr);E 14I 14D 16			TIMER_EXIT(list);E 16I 16			TIMER_EXIT(cdr);E 16E 14		}E 11E 8D 9		N_CHECKANDCADR(cadr1.cdr_cell, cadr1, error_addr);		/* cadr1 = cadr(cadr1.cdr_cell); */E 9	}while(cdr != NIL_PTR);	return(NIL_PTR);}I 7D 13#endifE 13E 7D 10E 10E 5E 1