h26768s 00013/00002/01386d D 2.17 90/07/25 20:34:58 osamu 33 32c Add fvar_lookup2 (expanding name-table varsion of fvar_lookup).es 00016/00016/01372d D 2.16 89/12/29 13:02:06 sybalsky 32 31c Add min, maxes 00037/00001/01351d D 2.15 89/12/13 11:01:15 sybalsky 31 30c add min and max speed-upses 00001/00001/01351d D 2.14 89/02/27 12:06:37 shih 30 29c wrong sccsides 00007/00000/01345d D 2.13 89/02/24 13:41:30 sybalsky 29 28c inline code for SXHASH-ROT, taking it from 12 instrs to 1 rorw.es 00074/00001/01271d D 2.12 88/12/01 13:47:27 krivacic 28 27c Add asm labels to inlines.es 00003/00001/01269d D 2.11 88/10/13 19:31:30 krivacic 27 26c def to take out native checkes 00016/00095/01254d D 2.10 88/10/10 14:04:12 krivacic 26 25c sun3/4 mergees 00001/00045/01348d D 2.9 88/09/21 11:44:01 krivacic 25 24c remove error prone asm code for slow returnes 00147/00026/01246d D 2.8 88/09/16 14:37:04 krivacic 24 23c Adjusted PC changeses 00001/00000/01271d D 2.7 88/08/19 15:49:21 bane 23 22c fix stack check (clr of d0)es 00007/00009/01264d D 2.6 88/08/16 18:28:23 krivacic 22 21c fix native fn call & returnes 00265/00123/01008d D 2.5 88/08/15 14:29:15 krivacic 21 20c asm code for fncall & returnes 00031/00000/01100d D 2.4 88/08/11 09:48:07 krivacic 20 19c native box & unbox fnses 00008/00006/01092d D 2.3 88/07/25 15:21:28 krivacic 19 18c fix native unwind loopses 00185/00001/00913d D 2.2 88/07/19 16:45:48 krivacic 18 17c native asm routineses 00000/00000/00914d D 2.1 88/05/17 09:23:14 hayata 17 16c Version up to 2.1es 00089/00004/00825d D 1.16 88/05/16 11:42:31 krivacic 16 15c fast_plus & fast_iplus fixes 00011/00009/00818d D 1.15 88/05/04 15:11:34 krivacic 15 14c fix shift bugses 00149/00015/00678d D 1.14 88/04/27 13:34:08 krivacic 14 13c more fast inlines: LOLOC HILOC VAG2...es 00085/00075/00608d D 1.13 88/04/25 21:19:11 krivacic 13 12c fast plus, idifferencenes 00002/00093/00681d D 1.12 88/04/22 19:15:24 krivacic 12 11c inlinedefs re-arrangement & remove excess inlineses 00012/00000/00762d D 1.11 88/04/08 17:18:14 krivacic 11 10c es 00011/00000/00751d D 1.10 88/03/28 11:59:34 krivacic 10 9c asm gotoes 00026/00010/00725d D 1.9 88/03/23 10:14:38 krivacic 9 8c dispatch editses 00061/00029/00674d D 1.8 88/03/14 17:40:55 krivacic 8 7c fast shift fixes, mpy, quotient, remainderes 00041/00000/00662d D 1.7 88/03/14 12:14:59 krivacic 7 6c op_shifts fixedes 00001/00000/00661d D 1.6 88/03/13 14:37:28 hayata 6 5c Add SCCS key ides 00107/00022/00554d D 1.5 88/03/11 18:06:58 krivacic 5 4c 32 bit aritmetic for add & -es 00000/00000/00576d D 1.4 88/03/09 15:51:50 krivacic 4 3c SCCS mixupes 00111/00001/00465d D 1.3 88/03/09 15:46:30 krivacic 3 2c swapx & some native fnses 00171/00020/00295d D 1.2 88/03/03 11:34:02 krivacic 2 1c Removed global CurrentFX to use CURRENTFX = PVAR - FRAMESIZE, New Inlineses 00315/00000/00000d D 1.1 88/02/24 16:56:20 hayata 1 0c date and time created 88/02/24 16:56:20 by hayataeuUtTI 6D 18/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 18I 18D 30/* This is G-file @(#) disp68K.il Version 1.16 (5/16/88). copyright Xerox & Fuji Xerox  */E 30I 30D 31/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 31I 31D 33/* @(#) disp68K.il Version 2.14 (2/27/89). copyright envos & Fuji Xerox  */E 33I 33/*  %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 33E 31E 30E 18E 6I 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 2D 9/* dispatch.il */E 9I 9D 24/* disp68K.il */E 24I 24/* disp68K.il */ E 24E 9/* inline dispatching support *//* Bob Krivacic, Jan 6, 1988 */D 9/* To use in compiling XXX, cc -O2 XXX.c dispatch.il *//*	This routine is UNSAFE, since it assumes:	a5 = PC	d6 = 000000xx	a4 = @TableE 9I 9D 33/*E 33I 33/* ************************************************************** * Changes:	'90/07/20 osamu: change _fvar_lookup_loop for Name table expand*****************************************************************/E 33	***************************************************************	Fast inline dispatcher.	This routine is UNSAFE, since it assumes:		a5 = PC		d6 = 000000xx		a4 = @Table	***************************************************************E 9*/D 9.inline	_jumpLabel,0E 9I 9D 24.inline	_fast_dispatcher,0E 9	movb	a5@,d6E 24I 24.inline	_fast0_dispatcher,0	movb	a5@(-1),d6E 24	movl	a4@(0,d6:l:4),a0D 9	jmp	a0@E 9I 9	.word	0x4ed0		|jmp	a0@	to clear up optimizer error	|.word	0x4ef4, 0x6d11	|jmp	[a4@(0,d6:l:4)] compiler will re-use d6	|jmp     a4@(0,d6:l:4)@ E 9.endI 24.inline	_fast1_dispatcher,0movb	a5@+,d6	movl	a4@(0,d6:l:4),a0	.word	0x4ed0		|jmp	a0@	to clear up optimizer error	|.word	0x4ef4, 0x6d11	|jmp	[a4@(0,d6:l:4)] compiler will re-use d6	|jmp     a4@(0,d6:l:4)@ .end.inline	_fast1_dispatcher2,0| The labels are to keep the optimizer from doing 2 a5@+'s| instead of the right thing on nextop2112$:	addql	#1,a5	movb	a5@+,d6	movl	a4@(0,d6:l:4),a0	.word	0x4ed0		|jmp	a0@	to clear up optimizer error	|.word	0x4ef4, 0x6d11	|jmp	[a4@(0,d6:l:4)] compiler will re-use d6	|jmp     a4@(0,d6:l:4)@ 	bcs	112$.endI 28/*	***************************************************************	Inlines to produce ASM labels only, replaces asm("label:") in C	****************************************************************/E 28I 28.inline	_fixtos1_label,0fixtos1:.end.inline	_plus_err_label,0plus_err:.end.inline	_iplus_err_label,0iplus_err:.end.inline	_diff_err_label,0diff_err:.end.inline	_idiff_err_label,0idiff_err:.end.inline	_iplusn_err_label,0iplusn_err:.end.inline	_idiffn_err_label,0idiffn_err:.end.inline	_mpy_err_label,0mpy_err:.end.inline	_impy_err_label,0impy_err:.end.inline	_quot_err_label,0quot_err:.end.inline	_iquot_err_label,0iquot_err:.end.inline	_irem_err_label,0irem_err:.end.inline	_newframe_setup_label,0newframe_setup:	.globl	newframe_setup.end.inline	_newframe_loop_label,0newframe_loop:	.globl	newframe_loop.end.inline	_natnewframe_label,0natnewframe:.endE 28E 24I 9/*	***************************************************************I 28	Special Helper for Free Var Lookup.	****************************************************************/	/* **** assumes: 		d7 = name		d6 = i		a3 = pindex	*** */ I 33/* NT expand version */.inline	_fvar_lookup_loop2,0lookup: 	cmpl a3@+,d7		dbeq d6,lookup		bne natnewframe.endE 33I 33/* Old NT(entry size 16bit) version */E 33.inline	_fvar_lookup_loop,0lookup: 	cmpw a3@+,d7		dbeq d6,lookup		bne natnewframe.end/*	***************************************************************E 28I 10	Special Native Code Jump Routine.	****************************************************************/.inline	_asmgoto,4	movl	a7@+,a0I 11	.word	0x4ed0		|jmp	a0@	to clear up optimizer error	movl	a0@,d0.end.inline	_asmgoto2,4	movl	a7@+,a0	.word	0x4ed0		|jmp	a0@	to clear up optimizer error.end.inline	_asmcall,4	movl	a7@+,a0E 11	jsr	a0@.endI 18.inline _setivar_pvar_jmp,12	movl	a7@+,a5		|set native IVAR	movl	a7@+,a4		|set native PVAR	movl	a7@+,a0		|get jump address	.word	0x4ed0		|jmp	a0@	to clear up optimizer error	movl	a0@,d0		|*** KEEP OPTIMIZER FROM REMOVING ABOVE CODE ***	movl	a4@,d1	movl	a5@,d2.end.inline _setpc_jmp,8	movl	a7@+,a5		|set the PCMAC	movl	a7@+,a0		|get the address	.word	0x4ed0		|jmp	a0@	to clear up optimizer error	movl	a0@,d0		|*** KEEP OPTIMIZER FROM REMOVING ABOVE CODE ***	movl	a5@,d1.endE 18/*	***************************************************************E 10	Routines to Fixup the C stack after an error return	from an Opcode Execution Routine.	****************************************************************/E 9D 5.inline	_jmpni,0D 2jmpni:		bra	nifixtosx:	bra	fixtosE 2I 2jumpni:		bra	niE 2.endE 5D 5.inline	_setniaddr,0ni:.end.inline	_setfixtosaddr,0D 2fixtos:E 2I 2fixtos1:E 2.endI 2.inline	_setfixtosaddr2,0fixtos2:.endE 5E 2D 3	E 3I 3.inline	_fixra,4	movl	a7@+,a6@(4).endE 3I 3.inline	_fixsp1,0	addql	#4,a7.end.inline	_fixsp2,0	lea	a7@(8),a7.end.inline	_fixsp3,0	lea	a7@(12),a7.end.inline	_fixspn,4D 8	addl	@a7+,a7E 8I 8	movl	a7@+,d0	lea	a7@(0,d0:l:4),a7E 8.end	I 21/*	***************************************************************	Inlines to Decalare Labels	****************************************************************/E 21I 9I 21.inline	_asm_label_op_fn_common,0op_fn_common:.end.inline	_asm_label_check_interrupt,0check_interrupt:.endE 21/*	***************************************************************I 13	Arithmetic Opcode Helpers	****************************************************************/.inline	_sub32,8	movl	a7@+,d0	movl	a7@+,d1	subl	d1,d0	bvs	diff_err.endI 16.inline	_isub32,8	movl	a7@+,d0	movl	a7@+,d1	subl	d1,d0	bvs	idiff_err.endE 16.inline	_sub32n,8	movl	a7@+,d0	movl	a7@+,d1	subl	d1,d0D 28	bvs	diff_err2E 28I 28	bvs	idiffn_errE 28.end.inline	_mpy32,8	movl	a7@+,d0	movl	a7@+,d1	mulsl	d1,d0	bvs	mpy_err.endI 16.inline	_impy32,8	movl	a7@+,d0	movl	a7@+,d1	mulsl	d1,d0	bvs	impy_err.endE 16.inline	_quot32,8	movl	a7@+,d0	movl	a7@+,d1	divsl	d1,d0	bvs	quot_err.endI 16.inline	_iquot32,8	movl	a7@+,d0	movl	a7@+,d1	divsl	d1,d0	bvs	iquot_err.endE 16.inline	_rem32,8	movl	a7@+,d2	movl	a7@+,d1	divsll	d1,d0:d2	bvs	rem_err.endI 16.inline	_irem32,8	movl	a7@+,d2	movl	a7@+,d1	divsll	d1,d0:d2	bvs	irem_err.endE 16.inline	_plus32,8	movl	a7@+,d0	movl	a7@+,d1	addl	d1,d0	bvs	plus_err.endD 16.inline	_plus32n,8E 16I 16.inline	_iplus32,8E 16	movl	a7@+,d0	movl	a7@+,d1	addl	d1,d0D 16	bvs	plus_err2E 16I 16	bvs	iplus_errE 16.endI 16.inline	_iplus32n,8	movl	a7@+,d0	movl	a7@+,d1	addl	d1,d0	bvs	iplusn_err.endE 16I 16E 16/*	***************************************************************E 13	Inline Assembly help for dispatcher.	****************************************************************/E 9E 3/* Note: that the error exit of these routines may or may not need to	fix the tos pointer.  The C code should decide when tos must	be fixed through the ifdef flats.*//* SWAP halves of a register */.inline	_swapx,4	movl	a7@+,d0	swap	d0.endD 13/* inline DIFFERENCE *//* 	sp@ - sp@(4)E 13I 13/*	***************************************************************	DIFFERENCE VERSIONS sp@ - sp@(4)  i.e. (tos-1)  -  (tos)	***************************************************************E 13*/D 12.inline	_difference,8	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	roll	d2,d1	subqb	#7,d1D 2	bne	fixtosxE 2I 2	bne	fixtos1E 2	roll	d2,d0	subqb	#7,d0D 2	bne	fixtosxE 2I 2	bne	fixtos1E 2	subl	d1,d0D 2	bvs	fixtosxE 2I 2	bvs	fixtos1E 2	lsrl	d2,d0	orl	#0x000E0000,d0.endI 3/* inline DIFFERENCE *//* 	sp@ - sp@(4)*/E 3E 12I 3.inline	_op_difference,8E 3I 2I 3	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	roll	d2,d1	subqb	#7,d1	bne	diff_err	roll	d2,d0	subqb	#7,d0	bne	diff_err	subl	d1,d0	bvs	diff_err	lsrl	d2,d0	orl	#0x000E0000,d0.endI 5D 13/* inline DIFFERENCE *//* 	d7 - sp@*/E 5E 13I 5.inline	_fast_op_difference,4E 5I 5	movl	a7@+,d1	roll	d5,d7	subqb	#7,d7	bne	diff_err	roll	d5,d1	subqb	#7,d1	bne	diff_err	subl	d7,d1	bvs	diff_err	lsrl	d5,d1	orl	#0x000E0000,d1	movl	d1,d7.endE 5I 16.inline	_fast_op_idifference,4	movl	a7@+,d1	roll	d5,d7	subqb	#7,d7	bne	idiff_err	roll	d5,d1	subqb	#7,d1	bne	idiff_err	subl	d7,d1	bvs	idiff_err	lsrl	d5,d1	orl	#0x000E0000,d1	movl	d1,d7.endE 16I 5D 13/* inline DIFFERENCE 32 *//* 	sp@ - sp@(4)*/E 13I 13.inline	_fast_op_idifferencen,4E 13D 13.inline	_sub32,8E 13	movl	a7@+,d0D 13	movl	a7@+,d1	subl	d1,d0	bvs	diff_errE 13I 13	roll	d5,d0	roll	d5,d7	subqb	#7,d7	bne	idiffn_err	subl	d0,d7	bvs	idiffn_err	lsrl	d5,d7	orl	#0x000E0000,d7E 13.endD 13.inline	_sub32n,8E 13D 13	movl	a7@+,d0	movl	a7@+,d1	subl	d1,d0	bvs	diff_err2.endI 8/* inline mpy 32 *//* 	sp@ * sp@(4)E 13I 13/*	***************************************************************	PLUS VERSIONS sp@ + sp@(4)  i.e. (tos-1)  +  (tos)	***************************************************************E 13*/E 8I 8D 13.inline	_mpy32,8	movl	a7@+,d0	movl	a7@+,d1	mulsl	d1,d0	bvs	mpy_err.endE 13E 8I 8D 13/* inline quot 32 *//* 	sp@ / sp@(4)*/E 8I 8.inline	_quot32,8	movl	a7@+,d0	movl	a7@+,d1	divsl	d1,d0	bvs	quot_err.endE 8I 8/* inline remainder 32 *//* 	sp@ / sp@(4)*/E 8I 8.inline	_rem32,8	movl	a7@+,d2	movl	a7@+,d1	divsll	d1,d0:d2	bvs	rem_err.endD 12E 12E 8E 5E 3E 2/* inline PLUS *//* 	sp@ + sp@(4)*/E 13D 12.inline	_plus,8D 2E 2	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	roll	d2,d1	subqb	#7,d1D 2	bne	fixtosxE 2I 2	bne	fixtos1E 2	roll	d2,d0	subqb	#7,d0D 2	bne	fixtosxE 2I 2	bne	fixtos1E 2	addl	d1,d0D 2	bvs	fixtosxE 2I 2	bvs	fixtos1E 2	lsrl	d2,d0	orl	#0x000E0000,d0.endI 3/* inline PLUS *//* 	sp@ + sp@(4)*/E 3E 12I 3.inline	_op_plus,8	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	roll	d2,d1	subqb	#7,d1	bne	plus_err	roll	d2,d0	subqb	#7,d0	bne	plus_err	addl	d1,d0	bvs	plus_err	lsrl	d2,d0	orl	#0x000E0000,d0.endE 3I 5D 13/* inline PLUS 32 *//* 	sp@ + sp@(4)*/E 5I 3I 5.inline	_plus32,8E 13I 13.inline	_fast_op_plus,4E 13	movl	a7@+,d0D 13	movl	a7@+,d1	addl	d1,d0E 13I 13	roll	d5,d7	subqb	#7,d7	bne	plus_err	roll	d5,d0	subqb	#7,d0	bne	plus_errD 16	addl	d0,d7E 16I 16	addl	d7,d0E 16E 13	bvs	plus_errI 13D 16	lsrl	d5,d7E 16I 16	lsrl	d5,d0	movl	d0,d7E 16	orl	#0x000E0000,d7E 13.endE 5D 13I 5.inline	_plus32n,8	movl	a7@+,d0	movl	a7@+,d1	addl	d1,d0	bvs	plus_err2.endE 13I 16.inline	_fast_op_iplus,4	movl	a7@+,d0	roll	d5,d7	subqb	#7,d7	bne	iplus_err	roll	d5,d0	subqb	#7,d0	bne	iplus_err	addl	d7,d0	bvs	iplus_err	lsrl	d5,d0	movl	d0,d7	orl	#0x000E0000,d7.endE 16I 14.inline	_fast_op_iplusn,4E 14I 14	movl	a7@+,d0	roll	d5,d0	roll	d5,d7	subqb	#7,d7	bne	iplusn_err	addl	d0,d7	bvs	iplusn_err	lsrl	d5,d7	orl	#0x000E0000,d7.endE 14E 5E 3D 14/* inline LOGAND *//* 	sp@ AND sp@(4)E 14I 14/*	***************************************************************	LOGAND VERSIONS sp@ & sp@(4)  i.e. (tos-1)  &  (tos)	***************************************************************E 14*/I 14E 14D 12.inline	_logand,8	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	moveq	#7,d3	roll	d2,d1	cmpb	d3,d1D 2	bne	fixtosxE 2I 2	bne	fixtos1E 2	roll	d2,d0	cmpb	d3,d0D 2	bne	fixtosxE 2I 2	bne	fixtos1E 2	andl	d1,d0	rorl	d2,d0.endE 12I 3.inline	_op_logand,8	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	moveq	#7,d3	roll	d2,d1	cmpb	d3,d1	bne	logand_err	roll	d2,d0	cmpb	d3,d0	bne	logand_err	andl	d1,d0	rorl	d2,d0.endI 14.inline	_fast_op_logand,4	movl	a7@+,d0	roll	d5,d7	cmpb	#7,d7	bne	logand_err	roll	d5,d0	cmpb	#7,d0	bne	logand_err	andl	d0,d7	rorl	d5,d7.endE 14E 3D 14/* inline LOGOR *//* 	sp@ OR sp@(4)E 14I 14/*	***************************************************************	LOGOR VERSIONS sp@ | sp@(4)  i.e. (tos-1)  |  (tos)	***************************************************************E 14*/D 12.inline	_logor,8E 12I 12.inline	_op_logor,8E 12	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	moveq	#7,d3	roll	d2,d1	cmpb	d3,d1I 3	bne	logor_err	roll	d2,d0	cmpb	d3,d0	bne	logor_err	orl	d1,d0	rorl	d2,d0.endD 12.inline	_op_logor,8	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	moveq	#7,d3	roll	d2,d1	cmpb	d3,d1E 3D 2	bne	fixtosxE 2I 2	bne	fixtos1E 2	roll	d2,d0	cmpb	d3,d0D 2	bne	fixtosxE 2I 2	bne	fixtos1E 2	orl	d1,d0	rorl	d2,d0.endE 12I 5D 14/* inline LOGXOR *//* 	sp@ OR sp@(4)E 14I 14.inline	_fast_op_logor,4	movl	a7@+,d0	roll	d5,d7	cmpb	#7,d7	bne	logor_err	roll	d5,d0	cmpb	#7,d0	bne	logor_err	orl	d0,d7	rorl	d5,d7.end/*	***************************************************************	LOGXOR VERSIONS sp@ | sp@(4)  i.e. (tos-1)  |  (tos)	***************************************************************E 14*/.inline	_op_logxor,8	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	moveq	#7,d3	roll	d2,d1	subb	d3,d1	bne	logxor_err	roll	d2,d0	cmpb	d3,d0	bne	logxor_err	eorl	d1,d0	rorl	d2,d0.endI 14.inline	_fast_op_logxor,4	movl	a7@+,d0	roll	d5,d7	cmpb	#7,d7	bne	logxor_err	roll	d5,d0	subqb	#7,d0	bne	logxor_err	eorl	d0,d7	rorl	d5,d7.endE 14E 5D 14/* inline LRSH8 *//* 	sp@ >> 8E 14I 14/*	***************************************************************	SHIFT OPCODE VERSIONS	***************************************************************E 14*/I 14E 14D 8.inline	_lrsh8,4E 8I 8.inline	_op_lrsh8,4E 8D 2E 2	movl	a7@+,d0I 15	moveq	#15,d2E 15	movl	d0,d1	swap	d1D 15	cmpw	#0xE,d1E 15I 15	cmpw	#0xe,d1E 15D 2	bne	fixtosxE 2I 2D 5	bne	jumpniE 5I 5D 8	bne	niE 8I 8	bne	lrsh8_errE 8E 5E 2	lsrw	#8,d0.endI 7D 8.inline	_op_lrsh8,4	movl	a7@+,d0	movl	d0,d1E 8I 8.inline	_fast_op_lrsh8,0	movl	d7,d1E 8	swap	d1D 15	cmpw	#0xE,d1E 15I 15	cmpw	#0xe,d1E 15	bne	lrsh8_errD 8	lsrw	#8,d0E 8I 8	lsrw	#8,d7E 8.endE 7I 2/* inline LRSH1 *//* 	sp@ >> 1*/E 2I 2D 8.inline	_lrsh1,4E 8I 8.inline	_op_lrsh1,4E 8	movl	a7@+,d0I 15	moveq	#15,d2E 15	movl	d0,d1	swap	d1D 15	cmpw	#0xE,d1E 15I 15	cmpw	#0xe,d1E 15D 5	bne	jumpniE 5I 5D 8	bne	niE 8I 8	bne	lrsh1_errE 8E 5	lsrw	#1,d0.endI 7D 8.inline	_op_lrsh1,4	movl	a7@+,d0	movl	d0,d1E 8I 8.inline	_fast_op_lrsh1,0	movl	d7,d1E 8	swap	d1D 15	cmpw	#0xE,d1E 15I 15	cmpw	#0xe,d1E 15	bne	lrsh1_errD 8	lsrw	#1,d0E 8I 8D 15 	lsrw	#1,d7E 15I 15	lsrw	#1,d7E 15E 8.endE 7I 7E 7D 8.inline	_llsh8,4E 8I 8.inline	_op_llsh8,4E 8	movl	a7@+,d0	cmpw	#0x0FF,d0D 5	bhi	jumpniE 5I 5D 8	bhi	niE 8I 8	bhi	llsh8_errE 8E 5	movl	d0,d1	swap	d1D 15	cmpw	#0xE,d1E 15I 15	cmpw	#0xe,d1E 15D 5	bne	jumpniE 5I 5D 8	bne	niE 8I 8	bne	llsh8_errE 8E 5	lslw	#8,d0.endI 7D 8.inline	_op_llsh8,4	movl	a7@+,d0	cmpw	#0x0FF,d0E 8I 8.inline	_fast_op_llsh8,0	cmpw	#0x0FF,d7E 8	bhi	llsh8_errD 8	movl	d0,d1E 8I 8	movl	d7,d1E 8	swap	d1D 15	cmpw	#0xE,d1E 15I 15	cmpw	#0xe,d1E 15	bne	llsh8_errD 8	lslw	#8,d0E 8I 8	lslw	#8,d7E 8.endE 7D 8.inline	_llsh1,4E 8I 8.inline	_op_llsh1,4E 8	movl	a7@+,d0	cmpw	#0x07FFF,d0D 5	bhi	jumpniE 5I 5D 8	bhi	niE 8I 8	bhi	llsh1_errE 8E 5	movl	d0,d1	swap	d1D 15	cmpw	#0xE,d1E 15I 15	cmpw	#0xe,d1E 15D 5	bne	jumpniE 5I 5D 8	bne	niE 8I 8	bne	llsh1_errE 8I 7	lslw	#1,d0.endD 8.inline	_op_llsh1,4	movl	a7@+,d0	cmpw	#0x07FFF,d0E 8I 8.inline	_fast_op_llsh1,0	cmpw	#0x07FFF,d7E 8	bhi	llsh1_errD 8	movl	d0,d1E 8I 8	movl	d7,d1E 8	swap	d1D 15	cmpw	#0xE,d1E 15I 15	cmpw	#0xe,d1E 15	bne	llsh1_errE 7E 5D 8	lslw	#1,d0E 8I 8	lslw	#1,d7E 8.endD 14E 2/* inline GREATERP *//* 	sp@ > sp@(4)E 14I 14/*	***************************************************************	GREATERP OPCODE VERSIONS	***************************************************************E 14*/D 12.inline	_greaterp,8E 12D 12	movl	a7@+,d3	movl	a7@+,d1	moveq	#15,d2	roll	d2,d1	subqb	#7,d1D 2	bne	fixtosxE 2I 2	bne	fixtos1E 2	roll	d2,d3	subqb	#7,d3D 2	bne	fixtosxE 2I 2	bne	fixtos1E 2	clrl	d0	cmpl	d1,d3	ble	100$	moveq	#76,d0100$:.endE 12I 3.inline	_op_greaterp,8	movl	a7@+,d3	movl	a7@+,d1	moveq	#15,d2	roll	d2,d1	subqb	#7,d1	bne	greaterp_err	roll	d2,d3	subqb	#7,d3	bne	greaterp_err	clrl	d0	cmpl	d1,d3	ble	100$	moveq	#76,d0100$:.endE 3I 5.inline	_fast_op_greaterp,4	movl	a7@+,d1	movl	d7,d3	roll	d5,d3	subqb	#7,d3	bne	greaterp_err	roll	d5,d1	subqb	#7,d1	bne	greaterp_err	clrl	d7	cmpl	d3,d1	ble	100$	moveq	#76,d7100$:I 16.end.inline	_fast_op_igreaterp,4	movl	a7@+,d1	movl	d7,d3	roll	d5,d3	subqb	#7,d3	bne	igreaterp_err	roll	d5,d1	subqb	#7,d1	bne	igreaterp_err	clrl	d7	cmpl	d3,d1	ble	101$	moveq	#76,d7101$:E 16.endI 14/*	***************************************************************	POINTER OPCODE VERSIONS	****************************************************************/E 14E 5I 2D 14/* POINTER OPERANTION */E 14.inline _addbase,8	movl	a7@+,d0	movl	a7@+,d1	moveq	#15,d2	roll	d2,d1	subqb	#7,d1	bne	fixtos1	asrl	d2,d1	andl	#0xFFFFFF,d0	addl	d1,d0.endI 14.inline _fast_op_addbase,4	movl	a7@+,d0	roll	d5,d7	subqb	#7,d7	bne	addbase_err	asrl	d5,d7	andl	#0xFFFFFF,d0	addl	d0,d7.endE 14.inline _loloc,4	movl	a7@+,d0|	commented code is messed up by the optimizer (movw -> moveq)|	swap	d0|	movw	#0x000E,d0|	swap	d0	andl	#0x0000FFFF,d0	orl	#0x000E0000,d0.endI 14.inline _fast_op_loloc,0	andl	#0x0000FFFF,d7	orl	#0x000E0000,d7.endE 14.inline	_hiloc,4	movl	a7@+,d0|	commented code is messed up by the optimizer (movw -> moveq)|	movw	#0x000E,d0|	swap	d0|	andw	#0x00FF,d0	swap	d0	andl	#0x0000FFFF,d0	orl	#0x000E0000,d0.endI 14.inline	_fast_op_hiloc,0	swap	d7	andl	#0x0000FFFF,d7	orl	#0x000E0000,d7.endE 14I 12/* this really doesn't need to check */E 12.inline	_vag2,8	movl	a7@+,d0	movl	a7@+,d1	swap	d0	swap	d1	cmpb	#0x0E,d0	bne	fixtos1	cmpb	#0x0E,d1	bne	fixtos1	swap	d1	movw	d1,d0D 14.end	E 14I 14.endE 14I 14.inline	_fast_op_vag2,4	movl	a7@+,d0	swap	d7	movw	d0,d7	swap	d7.end	/*	***************************************************************	TYPE OPCODE VERSIONS	****************************************************************/E 14/* TYPE INLINE OPCODES */.inline	_listp,4	movl	a7@+,d0	movl	d0,d1	lsrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movw	a0@(0,d1:l:1),d1	andw	#0x7FF,d1	cmpw	#5,d1	jeq	110$	clrl	d0110$:.endI 14.inline	_fast_op_listp,0	movl	d7,d1	lsrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movw	a0@(0,d1:l:1),d1	andw	#0x7FF,d1	cmpw	#5,d1	jeq	110$	clrl	d7110$:.endE 14.inline	_ntypex,4	movl	a7@+,d1	lsrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movl	#0x000E0000,d0	movw	a0@(0,d1:l:1),d0	andw	#0x7FF,d0.endI 14.inline	_fast_op_ntypex,0	lsrl	#8,d7	andl	#0xFFFE,d7	movl	_MDStypetbl,a0	movw	a0@(0,d7:l:1),d7	andw	#0x7FF,d0	orl	#0x000E0000,d7.endE 14.inline _typep,8	movl	a7@+,d1	movl	a7@+,d2	movl	d1,d0	lsrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movw	a0@(0,d1:l:1),d1	andw	#0x7FF,d1	cmpl	d2,d1	beq	115$	moveq	#0,d0115$:.endI 14.inline _fast_op_typep,0	movl	d7,d0	lsrl	#8,d0	andl	#0xFFFE,d0	movl	_MDStypetbl,a0	movw	a0@(0,d0:l:1),d0	andw	#0x7FF,d0	moveq	#0,d1D 24	movb	a5@(1),d1E 24I 24	movb	a5@,d1E 24	cmpw	d1,d0	beq	115$	moveq	#0,d7115$:.endE 14/* TYPE INLINE FUNCTIONS */.inline _GetTypeNumber,4	movl	a7@+,d1	asrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	moveq	#00,d0	movw	a0@(0,d1:l:1),d0	andw	#0x7FF,d0.end.inline _GetTypeEntry,4	movl	a7@+,d1	asrl	#8,d1	andl	#0xFFFE,d1	movl	_MDStypetbl,a0	movw	a0@(0,d1:l:1),d0.end	I 21/*	***************************************************************	Code for RETURN opcode	****************************************************************/E 21D 21E 21E 2.inline	_opreturn,0D 21	movl	_CurrentFX,a1		|returnFX = a1	movl	#65536,d0	movw	a1@(2),d0		|returnFX->alink	lsrl	#1,d0			|low bit to carryD 2	jcs	jmpni			|jump if slow returnE 2I 2D 5	jcs	jumpni			|jump if slow returnE 5I 5	jcs	ni			|jump if slow returnE 5E 2	movl	a2,a3			|CSTKPTR = IVAR	movl	_Lisp_world,a0		|PVar=	lea	a0@(0,d0:l:4),a0	movl	a0,_PVar	moveq	#20,d1	subl	d1,a0			|returnFX = a0	movl	a0,_CurrentFX		|CURRENTFX = returnFX	movl	#65536,d0	movw	a0@(-2),d0		|returnFX -1	movl	_Lisp_world,a1	lea	a1@(0,d0:l:2),a2	|IVAR = a2E 21I 21	movl	_MachineState+4,a2		|a2 = PVARD 24	movl	a2@(-20),d3			|d3 = FX >> 1E 24I 24	moveq	#0,d3	movw	a2@(-18),d3			|d3 = FX >> 1E 24	lsrl	#1,d3	jcs	do_slow_return			|jump if must do slow return	movl	_MachineState,a3	movl	_Stackspace,a1			|a1 = StackspaceD 24	andw	#0x7ffff,d3E 24	lea	a1@(0,d3:w:4),a2		|a2 = new PVAR	movl	a2,_MachineState+4E 21	moveq	#0,d0D 21	movb	a0@(7),d0		|returnFX->hi2fnheaderE 21I 21	movw	a2@(-22),d0			|*(returnFX -1)	lea	a1@(0,d0:l:2),a0	movl	a0,_MachineState		|IVAR = 	movl	a2@(-16),d0			|returnFX->fnheaderE 21	swap	d0D 21	movw	a0@(4),d0		|returnFX->lofnheader	movl	_Lisp_world,a1	lea	a1@(0,d0:l:2),a1	movl	a1,_FuncObj		|FuncObj = a1	subl	a5,a5	movw	a0@(10),a5		|returnFX->pc a5	lea	a1@(0,a5:l:1),a5	| a5 + FuncObj	movb	a5@,d6E 21I 21	andl	#16777215,d0				movl	_Lisp_world,a5	lea	a5@(0,d0:l:2),a0		|Addr68k_from_LADDRD 26	movl	a0,_FuncObj			|FuncObj = E 26I 26	movl	a0,_MachineState+20		|FuncObj = E 26D 22	moveq	#0,d0				|returnFX->pc	movw	a2@(-10),d0	lea	a0@(0,d0:l:1),a5		|PCMAC = E 22I 22	moveq	#0,d4				|returnFX->pc	movw	a2@(-10),d4	lea	a0@(0,d4:l:1),a5		|PCMAC = I 23D 24	moveq	#0,d0				|d0 = stkminE 24I 24	moveq	#0,d0E 24E 23E 22	movw	a0@,d0				|stkmin	lsll	#1,d0D 26	movl	_EndSTKP,d1E 26I 26	movl	_MachineState+24,d1		|_EndSTKPE 26	movl	d1,d2				|d2 = save _EndSTKP	subl	d0,d1D 26	movl	d1,_Irq_Stk_CheckE 26I 26	movl	d1,_MachineState+28 		|_Irq_Stk_CheckE 26	cmpl	d1,a3	jgt	do_a_timer_checkD 26	tstl	_Irq_Stk_EndE 26I 26	tstl	_MachineState+32 		|_Irq_Stk_EndE 26	jle	do_a_timer_checkD 26	movl	d2,_Irq_Stk_End			|_Irq_Stk_End = _EndSTKP  E 26I 26	movl	d2,_MachineState+32		|_Irq_Stk_End = _EndSTKP  E 26D 24	btst	#26,d3				|test native bitE 24I 24	btst	#3,a2@(-20)			|test native bitE 24	jne	is_native_return		|jump if a native returndo_a_dispatch:D 24	movb	a5@,d6				|dispatchE 24I 24	movb	a5@+,d6				|dispatchE 24E 21	movl	a4@(0,d6:l:4),a0D 21	jmp	a0@E 21I 21	.word	20176I 24E 24is_native_return:D 22	movl	a0,a6@(-32)			|a0 is still _FuncObj	movl	a6@(-32),a0E 22I 22						|a0 is still _FuncObj						|d4 = returnFX->pcE 22	moveq	#0,d0	movw	a0@(6),d0			|startpcD 22	movl	a0@(-4,d0:l),a1			|fnobj + startpc - 4	movl	a5,d0				|d0 = PCMAC	subl	a0,d0	lea	a1@(0,d0:l:4),a0E 22I 22	movl	a0@(-4,d0:l:1),a1		|*(fnobj + startpc - 40)D 24	lea	a1@(0,d4:l:1),a0E 22	movl	a0@(28),d3			|get entry addrE 24I 24D 25	movl	a1@(28,d4:l:4),a0		|get entry addrE 25I 25	movl	a1@(32,d4:l:4),a0		|get entry addrE 25	movl	a0,d3				|test itE 24	jeq	do_a_dispatch			|no entry point	movl	d7,a3@+				|push TOPOFSTACK	movl	_MachineState+4,a4		|setup PVAR	movl	_MachineState,a5		|setup IVARD 24	movl	d3,a0E 24	.word	20176	movl	a0@,d0	movl	a4@,d1	movl	a5@,d2E 21I 21do_a_timer_check:	movl	#256,d6I 24	addql	#1,a5			|bump PCMAC past current positionE 24	jmp	check_interruptE 21D 21.endE 21I 21do_slow_return:E 21D 25I 24	subql	#1,a5E 24I 21	movl	a5,_PC	movl	d7,_TopOfStack	lea	a3@(-4),a0	movl	a0,_CurrentStackPTR	jbsr	_slowreturn	movl	_PC,a5	movl	_CurrentStackPTR,a3	addql	#4,a3	movl	_TopOfStack,d7	movl	_FuncObj,a0	moveq	#0,d0	movw	a0@,d0	lsll	#1,d0	movl	_EndSTKP,d1	subl	d0,d1	movl	d1,_Irq_Stk_Check	cmpl	_Irq_Stk_Check,a3	jgt	do_a_timer_check	tstl	_Irq_Stk_End	jle	do_a_timer_check	movl	_EndSTKP,_Irq_Stk_End	movl	_MachineState+4,a0	btst	#3,a0@(-20)	jeq	do_a_dispatchD 24	movl	_FuncObj,a6@(-32)E 24I 24	movl	_FuncObj,a6@(-32)		|native bit is setE 24	movl	a6@(-32),a0	moveq	#0,d0	movw	a0@(6),d0	movl	a0@(-4,d0:l),a0	movl	a5,d0	subl	a6@(-32),d0	lea	a0@(0,d0:l:4),a0	movl	a0@(28),d3D 24	jeq	do_a_dispatch	movl	d7,a3@+E 24I 24	jeq	do_a_dispatch			|no entry address	movl	d7,a3@+				|dispatch to nativeE 24	movl	_MachineState+4,a4	movl	_MachineState,a5	movl	d3,a0	.word	20176	movl	a0@,d0	movl	a4@,d1	movl	a5@,d2E 25E 21I 21.endE 21D 21.inline _fn3,0E 21I 21/*	***************************************************************	COMPONENTS OF FN CALL	****************************************************************//*	Head Section of code	*/E 21D 21	moveq	#0,d0E 21I 21.inline _fnx_section1,0	moveq	#0,d1			|# argsD 24	movb	a5@(1),d1		|carefull this gets zapped!E 24I 24	movb	a5@,d1			|carefull this gets zapped!E 24	moveq	#0,d0			|Get Atom IndexD 24	movw	a5@(2),d0E 24I 24	movw	a5@(1),d0E 24	movl	_Defspace,a0		|Turn into Addr of Def Cell	movl	a0@(0,d0:l:4),d4	|d4 = defcell word	jge	400$			|Jump if not CCodeP	andl	#16777215,d4		movl	_Lisp_world,a2	lea	a2@(0,d4:l:2),a2	|a2 = LOCFNCELL	movl	_MachineState+4,a1	|a1 = PVARD 24	lea	a5@(4),a0		|BCE_CURRENTFX->pc	E 24I 24	lea	a5@(3),a0		|BCE_CURRENTFX->pc	E 24.end.inline _fn_section1,0	moveq	#0,d0			|Get Atom IndexE 21D 24	movw	a5@(1),d0E 24I 24	movw	a5@,d0E 24D 21	movl	_Defspace,a0	lea	a0@(0,d0:l:4),a1		|defcell = a1	movl	a1,d4				|save defcell in d4|	movl	a1,a6@(-20)	btst	#7,a1@	jeq	ni	movl	a1@,d0				|defcell->defpointer	andl	#16777215,d0	movl	_Lisp_world,a0	lea	a0@(0,d0:l:2),a1		|LOCFNCELL	movl	a1,d2				|save LOCFNCELL in a1, d2|	movl	a1,a6@(-12)	moveq	#0,d0	movw	a1@,d0				|LOCFNCELL->stkmin	lea	a3@(4,d0:l:2),a0|	addql	#4,a0	cmpl	_StkLimO,a0	jcc	ni				|stack overflow	lea	a3@(-8),a1			|CSTKPTR-(x<<1)+2	subl	_Lisp_world,a1	movl	a1,d3E 21I 21	movl	_Defspace,a0		|Turn into Addr of Def Cell	movl	a0@(0,d0:l:4),d4	|d4 = defcell word	jge	400$			|Jump if not CCodeP	andl	#16777215,d4		movl	_Lisp_world,a2	lea	a2@(0,d4:l:2),a2	|a2 = LOCFNCELL	movl	_MachineState+4,a1	|a1 = PVARD 24	lea	a5@(3),a0		|BCE_CURRENTFX->pc	E 24I 24	lea	a5@(2),a0		|BCE_CURRENTFX->pc	E 24.end.inline _fn_section2,0D 26	subl	_FuncObj,a0		|PCMAC - FuncObjE 26I 26	subl	_MachineState+20,a0	|PCMAC - FuncObjE 26	movw	a0,a1@(-10).end.inline _fn0_args,0	lea	a3@(4),a0		|a0 = newivar = CSTKPTR - x + 1.end.inline _fn1_args,0	lea	a3@(0),a0		|a0 = newivar = CSTKPTR - x + 1.end.inline _fn2_args,0	lea	a3@(-4),a0		|a0 = newivar = CSTKPTR - x + 1.end.inline _fn3_args,0	lea	a3@(-8),a0		|a0 = newivar = CSTKPTR - x + 1.end.inline _fn4_args,0	lea	a3@(-12),a0		|a0 = newivar = CSTKPTR - x + 1.end.inline _fnx_args,0	negl	d1	lea	a3@(4,d1:l:4),a0	|a0 = newivar = CSTKPTR - x + 1.endD 27.inline _fn_section3,0E 27I 27.inline _fn_native_test,0E 27	movl	a2@(8),d0		|get flags from FN headerD 24	jmi	is_native_call		|jump if a native callE 24I 24	jmi	450$			|jump if a native callI 27.end.inline _fn_section3,0E 27E 24	moveq	#0,d0			|d0 = stkmin	movw	a2@,d0	lsll	#1,d0D 26	movl	_Irq_Stk_End,d2E 26I 26	movl	_MachineState+32,d2	|_Irq_Stk_EndE 26	subl	d0,d2			|end - minD 26	movl	d2,_Irq_Stk_Check	|Irq_Stk_Check = end - minE 26I 26	movl	d2,_MachineState+28	|Irq_Stk_Check = end - minE 26	cmpl	d2,a3			|CSTKPTR > Irq_Stk_Check	jgt	check_interrupt		|jump if stack overflow	movl	a0,_MachineState	movl	_Stackspace,d2		|d2 = Stackspace	subl	d2,a0	movl	a0,d3			|d3 = NEXTBLOCKE 21	lsrl	#1,d3D 21|	movl	d3,a1	andl	#65535,d3			|NEXTBLOCK = d3|	movl	d0,d3	movl	_CurrentFX,a1			|a1 = _CurrentFX	movw	d3,a1@(8)			|CURRENTFX->nextblock =	movl	d3,d0	orl	#65536,d0	movl	_Lisp_world,a0	lea	a0@(0,d0:l:2),a2		|IVAR =|	movl	_CurrentFX,a0	movl	a5,d0	subl	_FuncObj,d0	addql	#3,d0	movw	d0,a1@(10)			|CURRENTFX->pc	movl	d7,a3@+				|CPushCStack	movl	d2,a1				|get LOCFNCELL = a1	movw	a1@(2),d0	tstw	d0	jlt	fn3noargs			|no function arguments|	movw	a0@(2),d0E 21I 21	movw	d3,a1@(-12)		|BCE_CURRENTFX->nextblock =	movl	d7,a3@+	movw	a2@(2),d0		|LOCFNCELL->na	jlt	275$			|jump if no need to loopE 21	extl	d0D 21	moveq	#2,d1E 21I 21.end.inline _fn0_xna,0	moveq	#0,d1			|x - na.end.inline _fn1_xna,0	moveq	#1,d1			|x - na.end.inline _fn2_xna,0	moveq	#2,d1			|x - na.end.inline _fn3_xna,0	moveq	#3,d1			|x - na.end.inline _fn4_xna,0	moveq	#4,d1			|x - na.end.inline _fnx_xna,0	negl	d1			|x - na.end.inline _fn_section4,0E 21	subl	d0,d1D 21|	movl	d1,d4	jra	fn3ly16fn3ly17:E 21I 21	jpl	250$200$:E 21	clrl	a3@+	addql	#1,d1D 21fn3ly16:	tstl	d1	jlt	fn3ly17|	movl	d4,d0E 21I 21	jmi	200$250$:E 21	asll	#2,d1	subl	d1,a3D 21fn3noargs:	movl	d3,d0				|CPush(BF_MARK32 | NEXTBLOCK)	orl	#-2147483648,d0	movl	d0,a3@+	movl	a3,_CurrentFX			|CURRENTFX =	movl	_PVar,d0|	subl	_Lisp_world,d0	subl	a0,d0E 21I 21275$:	orl	#-2147483648,d3	movl	d3,a3@+	movl	a1,d0			|(StkOffset_from_68K(PVAR)	subl	d2,d0E 21	lsrl	#1,d0D 21	andl	#65535,d0	orl	#-1073741824,d0	movl	d0,a3@				|*CSTKPTR=FX_MARK etc	movl	d4,a0				|defcell = a0	movw	a0@(2),a3@(4)			|->lofnheader = ->defpointer|	movl	a6@(-20),a0|	movl	a0@,d0|	andl	#16777215,d0|	movw	d0,a3@(4)|	movl	d4,a0|	movl	a6@(-20),a0	movb	a0@(1),a3@(7)			|hi2fnheader = *((defcell)+1)	lea	a3@(20),a3	movl	a3,_PVar			|PVar = CSTKPTR|	movl	d2,a0	movw	a1@(4),d0			||LOCFNCELL->pv	extl	d0	addql	#1,d0|	movl	d0,a6@(-8)	moveq	#-1,d1	jra	fn3ly18fn3ly19:	movl	d1,a3@+	movl	d1,a3@+	subql	#1,d0fn3ly18:	tstl	d0	jgt	fn3ly19	addqw	#4,a3				| CSTKPTR += 2|	movl	d2,a0|	moveq	#0,d0	subl	a5,a5	movw	a1@(6),a5			|LOCFNCELL->startpc	addl	a1,a5|	movl	d0,a5	movl	a1,_FuncObjE 21I 21	orl	#-1073741824,d0		|(FX_MARK << 16)	movl	d0,a3@	swap	d4			|SWAP_WORDS(defcell_word)	movl	d4,a3@(4)	lea	a3@(20),a3		|CSTKPTR += FRAMESIZE	movl	a3,_MachineState+4	|PVAR = (LispPTR *) CSTKPTR	movw	a2@(4),d2		|result = LOCFNCELL->pv	extl	d2	jlt	350$	moveq	#-1,d4325$:	movl	d4,a3@+	movl	d4,a3@+	dbra	d2,325$350$:	addqw	#4,a3	moveq	#0,d0	movw	a2@(6),d0	lea	a2@(0,d0:l),a5D 26	movl	a2,_FuncObjE 26I 26	movl	a2,_MachineState+20	|_FuncObjE 26.endE 21I 21D 24.inline _fn_section5,0400$:			|following "C" code does setup to opfn common			|E 24I 24.inline _fn0_native,0450$:	movl	a0,a5			|Set the IVAR (NEED x)D 26	movl	a2,_FuncObjE 26I 26	movl	a2,_MachineState+20	|_FuncObjE 26	movl	d7,a3@+	moveq	#0,d0	movw	a2@(6),d0	movl	d0,a0	movl	a0@(-4,a2:l),a0	movl	a0@(32),a0		|Set entry address	movl	a1,a4			|Set native PVAR	.word	20176			|Jump to native code	movl	a0@,d0	movl	a4@,d1	movl	a5@,d2E 24.endE 21I 21D 24.inline	_to_native_label,0is_native_call:E 24I 24.inline _fn1_native,0450$:E 24	movl	a0,a5			|Set the IVAR (NEED x)D 26	movl	a2,_FuncObjE 26I 26	movl	a2,_MachineState+20	|_FuncObjE 26	movl	d7,a3@+	moveq	#0,d0	movw	a2@(6),d0	movl	d0,a0	movl	a0@(-4,a2:l),a0I 24	movl	a0@(28),a0		|Set entry address	movl	a1,a4			|Set native PVAR	.word	20176			|Jump to native code	movl	a0@,d0	movl	a4@,d1	movl	a5@,d2.end.inline _fn2_native,0450$:	movl	a0,a5			|Set the IVAR (NEED x)D 26	movl	a2,_FuncObjE 26I 26	movl	a2,_MachineState+20	|_FuncObjE 26	movl	d7,a3@+	moveq	#0,d0	movw	a2@(6),d0	movl	d0,a0	movl	a0@(-4,a2:l),a0	movl	a0@(24),a0		|Set entry address	movl	a1,a4			|Set native PVAR	.word	20176			|Jump to native code	movl	a0@,d0	movl	a4@,d1	movl	a5@,d2.end.inline _fn3_native,0450$:	movl	a0,a5			|Set the IVAR (NEED x)D 26	movl	a2,_FuncObjE 26I 26	movl	a2,_MachineState+20 	|_FuncObjE 26	movl	d7,a3@+	moveq	#0,d0	movw	a2@(6),d0	movl	d0,a0	movl	a0@(-4,a2:l),a0	movl	a0@(20),a0		|Set entry address	movl	a1,a4			|Set native PVAR	.word	20176			|Jump to native code	movl	a0@,d0	movl	a4@,d1	movl	a5@,d2.end.inline _fn4_native,0450$:	movl	a0,a5			|Set the IVAR (NEED x)D 26	movl	a2,_FuncObjE 26I 26	movl	a2,_MachineState+20 	|_FuncObjE 26	movl	d7,a3@+	moveq	#0,d0	movw	a2@(6),d0	movl	d0,a0	movl	a0@(-4,a2:l),a0E 24	movl	a0@(16),a0		|Set entry address	movl	a1,a4			|Set native PVAR	.word	20176			|Jump to native code	movl	a0@,d0	movl	a4@,d1	movl	a5@,d2E 21.endI 24.inline _fnx_native,0450$:	movl	a0,a5			|Set the IVAR (NEED x)D 26	movl	a2,_FuncObjE 26I 26	movl	a2,_MachineState+20 	|_FuncObjE 26	movl	d7,a3@+	moveq	#0,d0	movw	a2@(6),d0	movl	d0,a0	movl	a0@(-4,a2:l),a0	movl	a1,a4			|Set native PVARD 26	movl	d1,_PC			|set the PC for the entry loopE 26I 26	movl	d1,_MachineState+16	|set the PC for the entry loopE 26	addql	#5,d1			|see if less than 6 args	bpl	455$			|go do indexed jump if so	movl	a0@(8),a0		|fnx(6) call	.word	20176			|Jump to native code	movl	a5@,d2	movl	a0@,d0	movl	a4@,d1455$:	movl	a0@(12,d1:l:4),a0	|Set entry address	.word	20176			|Jump to native code	movl	a4@,d1	movl	a0@,d0	movl	a5@,d2.end.inline _fn_section5,0400$:			|following "C" code does setup to opfn common			|.endE 24I 21E 21I 18/*	***************************************************************	CODE TO HELP FREE VARIABLE LOOKUP	****************************************************************/.inline	_newframe_stk_hi_ret,4|	STK_HI is 1|	result returned in d0	movl	a7@+,d0	swap	d0	moveq	#1,d1	orl	d1,d0		|or in the STK_HI to lower word.end.inline	_newframe_vals_hi_ret,4|	VALS_HI is 12|	result returned in d0	movl	a7@+,d0	moveq	#17,d1		|need to get shift amount	roll	d1,d0		|shift the 1st bit of name to lsb	orw	#12,d0		|or in the VALS_HI to lower word.end/*	***************************************************************	NATIVE CODE INLINE ASSEMBLY CODE	***************************************************************I 20		Assume:		d5 = 15		Shift AmountE 20*/I 20/*	****************************************************************//*	Boxing & Unboxing					       *//*	****************************************************************/.inline _nop_nsmallp_range,4	movl	a7@,d0	movl	d0,d1		|save value	lsll	d5,d0		|x = value << 15	asrl	d5,d0		|x = x >> 15	eorl	d1,d0		|x = x EOR value.end.inline _nop_smallp_unbox,4	movl	a7@,d0	lsll	d5,d0		|x = value << 15	asrl	d5,d0		|x = x >> 15.end	.inline _nop_smallp_box,4	movl	a7@,d0	lsll	d5,d0		|x = value << 15	lsrl	d5,d0		|x = x >> 15	orl	#0x000e0000,d0.end	E 20/*	****************************************************************//*	UNBIND & DUNBIND					       *//*	****************************************************************/.inline _nop_unbind,4|| Assumes: 	a3 = CURRSTKP|		a4 = PVAR|D 19	movl	a7@+,a1		|save TOSE 19I 19	movl	a7@+,a1		|save TOS valueE 1910$:	tstl	a3@-		|look for bind mark	bpls	10$	movl	a3@,d0		|get the bind mark	movl	d0,d1		|get num of pvars to unbind	movl	#0xffff,d2	andl	d2,d0		|get pvar index	lea	a4@(4,d0:l:2),a0	swap	d1		|compute num of pvars to unbind	notw	d1	andl	d2,d1		|clear top of num	beqs	30$		|jump if none to clearD 19	movl	#0xffffffff,d0	|set loop value20$:	movl	d0,a0@-		|Store the unbind mark	dbne	d1,20$		|loop till pvars clearedE 19I 19	subql	#1,d1		|adjust counter for loop	moveq	#-1,d0		|set loop store value20$:	movl	d0,a0@-		|Store the unbind mark in pvars	dbra	d1,20$		|loop till pvars clearedE 1930$:	movl	a1,a3@+		|push the old TOS.end.inline _nop_dunbind,0|| Assumes: 	a3 = CURRSTKP|		a4 = PVAR|10$:	tstl	a3@-		|look for bind mark	bpls	10$	movl	a3@,d0		|get the bind mark	movl	d0,d1		|get num of pvars to unbind	movl	#0xffff,d2	andl	d2,d0		|get pvar index	lea	a4@(4,d0:l:2),a0	swap	d1		|compute num of pvars to unbind	notw	d1	andl	d2,d1		|clear top of num	beqs	30$		|jump if none to clearD 19	movl	#0xffffffff,d0	|set loop valueE 19I 19	subql	#1,d1		|adjust counter for loop	moveq	#-1,d0		|set loop store valueE 1920$:	movl	d0,a0@-		|Store the unbind markD 19	dbne	d1,20$		|loop till pvars clearedE 19I 19	dbra	d1,20$		|loop till pvars clearedE 1930$:	D 26.end/*	***************************************************************	FN RETURN	***************************************************************NOW OBSOLETE !!!!*/.inline _nop_return,8	movl 	a7@+,d2		|return pc	movl	a7@+,d3		|current swapped fn obj	moveq	#0,d0			movw	a3@(-18),d0		|get Alink	btst	#0,d0		jne	200$		lea	a4@(4),a5		|Set CSTKPTR to IVAR	movl	_Stackspace,a0		|Compute new PVAR	lea	a0@(0, d0:l:2),a3	movw	a3@(-22),d0	|compute new IVAR	lea	a0@(0,d0:l:2),a4	movl	a4,_MachineState	movl	a3,_MachineState+4	movw	a3@(-10),d0		|get the return PC	btst	#3,a3@(-20)		|native ?	jeq	201$	| NATIVE FN RETURN	movl	d0,_PC	movl 	a3@(-16),d1		|get fn obj	cmpl	d3,d1	jeq	switchlabel	andw	#0xff,d1	swap	d1	movl	_Lisp_world,a0	lea	a0@(0,d1:l:2),a0	movl	a0,_FuncObj	movl	a5,_CurrentStackPTR	movw	a0@(6),d0	movl	a0@(-4,d0:l),a0	jmp	a0@	| NORMAL FN RETURN201$:	movl 	a3@(-16),d1		|get fn obj	andw	#0xff,d1	swap	d1	movl	_Lisp_world,a0	lea	a0@(0,d1:l:2),a1	movl	a1,_FuncObj	addl	a1,d0			|add return pc	movl	d0,_PC	movl	a5,_CurrentStackPTR	moveq	#0,d0			|compute new stack end	movw	a1@,d0	moveq	#32,d7	addl	d7,d0	lsll	#1,d0	movl	_EndSTKP,d1	subl	d0,d1	 	movl	d1,_Irq_Stk_Check	cmpl	_Irq_Stk_Check,a5	jgt	202$	tstl	_Irq_Stk_End	jle	202$	movl	_EndSTKP,_Irq_Stk_End	jmp	_ret_to_dispatch202$:	jmp	_ret_to_timer200$:	movl	a4@,a5@+	movl	d2,_PC	movl	a5,_CurrentStackPTR	jmp	_ret_to_unimplE 26.endE 18I 31/************************************************************************//*									*//*		    _ s x h a s h _ r o t a t e				*//*									*//*	Rotate the low word of its argument to the right by 7 bits	*//*	This is equivalent to the SXHASH-ROTATE macro in CMLHASH.	*//*									*//************************************************************************/E 31I 29.inline _sxhash_rotate,4| Rotates the low word to the right by 7 bits.| This is the equivalent of the SXHASH-ROTATE macro in CMLHASH.|	movl	a7@+,d0	rolw	#7,d0I 31.end/************************************************************************//*									*//*									*//*									*//*									*//************************************************************************/D 32.inline _min,8	movl	a7@+,d0	movl	a7@+,d1	cmpl	d1,d0	jge	$30	movl	d1,d0$30.endE 32I 32|.inline _min,8|	movl	a7@+,d0|	movl	a7@+,d1|	cmpl	d1,d0|	jge	$30|	movl	d1,d0|$30|.endE 32D 32.inline _max,8	movl	a7@+,d0	movl	a7@+,d1	cmpl	d1,d0	jle	$30	movl	d1,d0$30E 31.endE 32I 32|.inline _max,8|	movl	a7@+,d0|	movl	a7@+,d1|	cmpl	d1,d0|	jle	$30|	movl	d1,d0|$30|.endE 32E 29E 1