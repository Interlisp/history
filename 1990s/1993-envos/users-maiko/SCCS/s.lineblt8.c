h11107s 00002/00001/00222d D 1.7 92/11/25 21:07:54 sybalsky 7 6c Fixing endif's with extra text => comment. \nes 00000/00000/00223d D 1.6 92/04/21 17:18:21 sybalsky 6 5c shortening file names for DOS \nes 00005/00000/00218d D 1.5 91/09/27 02:37:30 sybalsky 5 4c ISC port changeses 00119/00066/00099d D 1.4 90/09/18 23:45:26 sybalsky 4 3c Retrofit changes from AIX, DEC3100, PS/2es 00001/00001/00164d D 1.3 90/06/12 17:55:09 fuji 3 2c Matsuda: bug fixes 00000/00000/00165d D 1.2 90/04/20 01:46:38 sybalsky 2 1c AIX:  shortening file names, bulk change.es 00165/00000/00000d D 1.1 90/02/12 11:54:52 takeshi 1 0c date and time created 90/02/12 11:54:52 by takeshieuUf e 0tTI 1/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";I 4/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 4#include <sys/types.h>#include "lispemul.h"I 5#ifdef ISC#include <sys/bsdtypes.h>D 7#endif ISCE 7I 7#endif /* ISC */E 7E 5#define COLOR8ARRAYSIZE	16#define BITSPERNIBBLE	4#define BITSPERDLWORD 16DLword BitMaskArray[]={32768,16384,8192,4096,2048,1024,				512,256,128,64,32,16,8,4,2,1};unsigned int ConvBM_tbl[] = { 	         0 ,       0xff ,     0xff00 ,     0xffff , 	  0xff0000 ,   0xff00ff ,   0xffff00 ,   0xffffff , 	0xff000000 , 0xff0000ff , 0xff00ff00 , 0xff00ffff ,	0xffff0000 , 0xffff00ff , 0xffffff00 , 0xffffffff };unsigned int BMask_tbl[] = { 0xf , 7 , 3 , 1 };I 4#define noop 1E 4/*************************************************************** 	Macro:WriteLongW**************************************************************/#define WriteLongW(srcpattern,destptr,op1,op2) {\	register cnt;\	register u_char *des,*src;\	for(cnt=0,des=(u_char*)destptr,src=(u_char*)(&(srcpattern));\	 cnt <4 ; cnt++,des++,src++)\D 4		(*des) op1 op2(*src);}E 4I 4		(*des) op1 (*src);}E 4/*************************************************************** 	Macro:LineBLT8	srcWptr :		DLword ptr	offset  :		Bits offset	width	   :		Bits width to copy	dstLptr :		Destination's LispPTR ptr	op1,op2 :		operations in C(=,|=,^=,&=,^)				ERASE only uses op2**************************************************************/ /* srcw points DLword which contains the nibble processed now */ /* offset indicates MSB in the nibble */ /* width:before copy,make sure the nibble is inside source bitmap */ /* width:after copy,decremented by BITSPERNIBBLE.	therefore,width indictes the rest bits in source bitmap */#define LineBLT8(srcWptr,offset,width,dstLptr,op1,op2){  					\  register DLword *srcw;										\  register u_int temp1;										\D 4 for(srcw= (srcWptr) + (offset)/BITSPERDLWORD;((width) -BITSPERNIBBLE)>= 0;\		(width) -=BITSPERNIBBLE,((u_int*)(dstLptr))++,(offset)+=BITSPERNIBBLE){\E 4I 4 for(srcw= (srcWptr) + (offset)/BITSPERDLWORD ;		\      ((width) -BITSPERNIBBLE)>= 0;			\      (width) -=BITSPERNIBBLE,				\      (dstLptr) = (u_char *) ((u_int *)(dstLptr) + 1),	\       (offset)+=BITSPERNIBBLE)				\   {\E 4 switch((offset) % 16) {\D 4 case 0 : 	  WriteLongW(color_array[(*srcw )>> 12],dstLptr,op1,op2); break;\ case 1 : 	  WriteLongW(color_array[(*srcw & 0x7800) >> 11],dstLptr,op1,op2);	break;\ case 2 : 	  WriteLongW(color_array[(*srcw & 0x3c00) >> 10],dstLptr,op1,op2);	break;\ case 3 : 	  WriteLongW(color_array[(*srcw & 0x1e00) >> 9],dstLptr,op1,op2);	break;\ case 4 : 	  WriteLongW(color_array[(*srcw & 0x0f00) >> 8],dstLptr,op1,op2);	break;\ case 5 : 	  WriteLongW(color_array[(*srcw & 0x0780) >> 7],dstLptr,op1,op2);	break;\ case 6 : 	  WriteLongW(color_array[(*srcw & 0x03c0) >> 6],dstLptr,op1,op2);	break;\ case 7 : 	  WriteLongW(color_array[(*srcw & 0x01e0) >> 5],dstLptr,op1,op2);	break;\ case 8 : 	  WriteLongW(color_array[(*srcw & 0x00f0) >> 4],dstLptr,op1,op2);	break;\ case 9 : 	  WriteLongW(color_array[(*srcw & 0x0078) >> 3],dstLptr,op1,op2);  break;\ case 10 :  WriteLongW(color_array[(*srcw & 0x003c) >> 2],dstLptr,op1,op2);	break;\ case 11 :  WriteLongW(color_array[(*srcw & 0x001e) >> 1],dstLptr,op1,op2);	break;\E 4I 4 case 0 :   WriteLongW(color_array[(*srcw )>> 12],dstLptr,op1,op2);\	    break;\ case 1 :   WriteLongW(color_array[(*srcw & 0x7800) >> 11],dstLptr,op1,op2);	\	   break;\ case 2 :   WriteLongW(color_array[(*srcw & 0x3c00) >> 10],dstLptr,op1,op2);	\	   break;\ case 3 :   WriteLongW(color_array[(*srcw & 0x1e00) >> 9],dstLptr,op1,op2);\	   	break;\ case 4 :   WriteLongW(color_array[(*srcw & 0x0f00) >> 8],dstLptr,op1,op2);\	   	break;\ case 5 :   WriteLongW(color_array[(*srcw & 0x0780) >> 7],dstLptr,op1,op2);\	   	break;\ case 6 :   WriteLongW(color_array[(*srcw & 0x03c0) >> 6],dstLptr,op1,op2);\	   	break;\ case 7 :   WriteLongW(color_array[(*srcw & 0x01e0) >> 5],dstLptr,op1,op2);\	   	break;\ case 8 :   WriteLongW(color_array[(*srcw & 0x00f0) >> 4],dstLptr,op1,op2);\	   	break;\ case 9 :   WriteLongW(color_array[(*srcw & 0x0078) >> 3],dstLptr,op1,op2);\	     break;\ case 10 :  WriteLongW(color_array[(*srcw & 0x003c) >> 2],dstLptr,op1,op2);\	   	break;\ case 11 :  WriteLongW(color_array[(*srcw & 0x001e) >> 1],dstLptr,op1,op2);\	   	break;\E 4 case 12 :  WriteLongW(color_array[*srcw & 0xf],dstLptr,op1,op2);\		 srcw++; /* move srcw pointer */\		 break;\ case 13 : temp1= (*srcw & 7) << 1 ;\	   temp1 |= ((*(++srcw)) & 0x8000)>> 15 ;/** Compiler's BUG?*/\		 WriteLongW(color_array[temp1],dstLptr,op1,op2);\		 break;\ case 14 : temp1= ((*srcw & 3) << 2) ;\	   temp1 |= ((*(++srcw) & 0xc000)>> 14) ;\		 WriteLongW(color_array[temp1],dstLptr,op1,op2);\		 break;\ case 15 : temp1= ((*srcw & 1) << 3);\	   temp1 |= ((*(++srcw) & 0xe000)>> 13) ;\		 WriteLongW(color_array[temp1],dstLptr,op1,op2);\		 break;\ } /* switch end */\ } /* for end */\/* process for the rest bits (0~3)*/\switch(width)\{ register u_char *destc;\  register int mod;\ case 0: /* already finished */\		break;\ case 1: \ case 2:\ case 3:	destc=(u_char *)dstLptr;\		while(width--){\			if(BitMaskArray[mod =(offset %16)] & *srcw) \D 4				(*destc++) op1 op2(color1);\			else    (*destc++) op1 op2(color0);\E 4I 4				(*destc++) op1 (color1);\			else    (*destc++) op1 (color0);\E 4			if(mod == 15) srcw++;\			offset++;\		} /* WHILE END */\		break;\ default: ;/* error */\}/* switch end */\} /* MACRO END */I 4/************************************************************************//*									*//*			l i n e b l t 8					*//*									*//*									*//*									*//************************************************************************/E 4/* destination is always ColorFontCache's line *//* I don't care sourcetype & operation NOW */I 4E 4lineBlt8(srcbase,offset,destl,width,color0,color1,sourcetype,operation)D 4DLword *srcbase;register int offset;/* register u_int *destl;*/register u_char *destl; /* for SPARC */register int width;u_char color0; /* Background color */u_char color1; /* foreground color */LispPTR sourcetype;LispPTR operation; /*operation type PAINT,REPLACE or INVERT */E 4I 4  DLword *srcbase;  register int offset;  /* register u_int *destl;*/  register u_char *destl; /* for SPARC */  register int width;  u_char color0; /* Background color */  u_char color1; /* foreground color */  LispPTR sourcetype;  LispPTR operation; /*operation type PAINT,REPLACE or INVERT */E 4D 4{ static unsigned char beforecolor0=0; static unsigned char beforecolor1=0; static color_array[COLOR8ARRAYSIZE];E 4I 4  {    static unsigned char beforecolor0=0;    static unsigned char beforecolor1=0;    static color_array[COLOR8ARRAYSIZE];E 4D 4 extern DLword  REPLACE_atom; extern DLword  INPUT_atom; extern DLword  INVERT_atom; extern DLword  PAINT_atom; extern DLword  ERASE_atom;E 4I 4    extern DLword  REPLACE_atom;    extern DLword  INPUT_atom;    extern DLword  INVERT_atom;    extern DLword  PAINT_atom;    extern DLword  ERASE_atom;E 4D 4DLword *baseword; /* Assume dest word always quad aligned */E 4I 4    DLword *baseword; /* Assume dest word always quad aligned */E 4D 4if(sourcetype == INVERT_atom){  register tempcol;  tempcol = color0;  color0 = color1;  color1 = tempcol;}if((beforecolor0 != color0) || (beforecolor1 != color1)) {  /* making color-mapped array */  register i;  register u_int longcol0,longcol1;E 4I 4    if(sourcetype == INVERT_atom)      {	register tempcol;	tempcol = color0;	color0 = color1;	color1 = tempcol;      }    if((beforecolor0 != color0) || (beforecolor1 != color1))      {	/* making color-mapped array */	register i;	register u_int longcol0,longcol1;E 4D 4  beforecolor0 = color0;  beforecolor1 = color1;  longcol0 = (color0 << 24) | (color0 << 16) | (color0 << 8) | color0;  longcol1 = (color1 << 24) | (color1 << 16) | (color1 << 8) | color1;E 4I 4	beforecolor0 = color0;	beforecolor1 = color1;	longcol0 = (color0 << 24) | (color0 << 16) | (color0 << 8) | color0;	longcol1 = (color1 << 24) | (color1 << 16) | (color1 << 8) | color1;E 4 D 3  for(i=1;i < COLOR8ARRAYSIZE;i++) {/* array[0] always 0 */E 3I 3D 4  for(i=0;i < COLOR8ARRAYSIZE;i++) {E 3	color_array[i] = ConvBM_tbl[i] & longcol1;	color_array[i] |= (~(ConvBM_tbl[i])) & longcol0;  } } /* otherwise previous colors are same as current one. use cached one */E 4I 4	for(i=0;i < COLOR8ARRAYSIZE;i++)	  {	    color_array[i] = ConvBM_tbl[i] & longcol1;	    color_array[i] |= (~(ConvBM_tbl[i])) & longcol0;	  }      } /* otherwise previous colors are same as current one. use cached one */E 4D 4 if(operation == REPLACE_atom){		LineBLT8(srcbase,offset,width,destl,=,); } else if (operation ==  INVERT_atom){		LineBLT8(srcbase,offset,width,destl,^=,); } else if (operation ==  PAINT_atom){		LineBLT8(srcbase,offset,width,destl,|=,); } else if (operation ==  ERASE_atom){/*erase */	LineBLT8(srcbase,offset,width,destl,&=,~); } else	error("lineBlt8:Illegal operation specified");E 4I 4    if(operation == REPLACE_atom)      {		LineBLT8(srcbase,offset,width,destl,=,noop);      }    else if (operation ==  INVERT_atom)      {		LineBLT8(srcbase,offset,width,destl,^=,noop);      }    else if (operation ==  PAINT_atom)      {		LineBLT8(srcbase,offset,width,destl,|=,noop);      }    else if (operation ==  ERASE_atom)      { /*erase */	LineBLT8(srcbase,offset,width,destl,&=~,noop);      }    else error("lineBlt8:Illegal operation specified");E 4 D 4}E 4I 4  }E 4/* lineBlt8 end */E 1