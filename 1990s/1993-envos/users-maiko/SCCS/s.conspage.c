h56105s 00212/00066/00238d D 2.12 93/02/08 14:49:58 sybalsky 17 16c Big VM (and new CDR coding) changes for 3.0 \nes 00003/00003/00301d D 2.11 92/04/21 17:08:56 sybalsky 16 15c shortening file names for DOS \nes 00016/00011/00288d D 2.10 90/09/18 23:42:48 sybalsky 15 14c Retrofit changes from AIX, DEC3100, PS/2es 00007/00008/00292d D 2.9 90/06/15 16:52:04 mitani 14 13c GCLOOKUPes 00000/00000/00300d D 2.8 90/04/20 01:25:47 sybalsky 13 12c X:  shortening file names, bulk change.es 00145/00131/00155d D 2.7 90/02/21 18:44:08 sybalsky 12 11c check for 386i (OK), reformat code, add comments.es 00000/00000/00286d D 2.6 89/03/29 14:14:08 sybalsky 11 10c New-page checks under DEBUG are bogus:  car field needn't be NIL.es 00000/00005/00286d D 2.5 88/09/27 16:43:29 krivacic 10 9c sun 4 mergees 00000/00004/00291d D 2.4 88/09/27 16:14:06 krivacic 9 8c remove unused externs for mergees 00000/00001/00295d D 2.3 88/05/31 19:52:47 masinter 8 7c remove bogus artifact from diff run (sorry)es 00007/00337/00289d D 2.2 88/05/31 16:25:01 masinter 7 6c remove obsolete duplicate code; need only one instance of CONS codees 00000/00000/00626d D 2.1 88/05/17 09:22:55 hayata 6 5c Version up to 2.1es 00002/00002/00624d D 1.5 88/05/13 10:08:05 hayata 5 4c Add SCCS key ides 00010/00010/00616d D 1.4 88/05/09 21:29:14 shih 4 3c Use GCLOOKUPes 00164/00002/00462d D 1.3 88/03/29 18:50:16 krivacic 3 2c New Interfacees 00002/00002/00462d D 1.2 88/03/13 14:34:59 hayata 2 1c Add SCCS key id (%Z%)es 00464/00000/00000d D 1.1 88/02/24 16:56:08 hayata 1 0c date and time created 88/02/24 16:56:08 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 3/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 3I 3D 5/* This is G-file @(#) conspage.c Version 1.2 (3/13/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) conspage.c	1.2 3/13/88";E 5I 5D 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 5E 3E 2/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 7 *	Auther :  Takeshi ShimizuE 7I 7 *	Author :  Takeshi ShimizuE 7 * */E 12I 12D 14/* This is G-file @(#) conspage.c Version 2.6 (3/29/89). copyright Xerox & Fuji Xerox  */static char *id = "@(#) conspage.c	2.6 3/29/89";E 14I 14D 17/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(venue & Fuji Xerox)";E 17I 17/* %Z% %M% Version %I% (%G%). copyright venue  */static char *id = "%Z% %M%	%I% %G%		(venue)";E 17E 14I 17E 17D 14E 14/************************************************************************//*									*/D 17/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 17I 17/*	(C) Copyright 1989-92 Venue. All Rights Reserved.		*//*	Manufactured in the United States of America.			*/E 17/*									*/D 17/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 17I 17/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 17/*									*//************************************************************************/E 12/***********************************************************************//*		File Name :conspage.c*//************************************************************************/#include "lispemul.h"#include "address.h"D 16#include "address68k.h"#include "lisptypes.h"E 16I 16#include "adr68k.h"#include "lsptypes.h"E 16#include "cell.h"#include "lispmap.h"D 14#include "gc.h"E 14D 16#include "lispglobal.h"E 16I 16#include "lspglob.h"E 16I 14#include "gc.h"E 14D 9extern DLword *Atomspace ;extern DLbyte *PC ;extern DLword *Lisp_world;E 9/**********************************************************************//*		Func name :	next_conspageD 15				GET NEXT CONS PAGE .E 15I 15		GET NEXT CONS PAGE .E 15D 15					Date :		January 13, 1987					Edited by :	Takeshi Shimizu					Changed	:	January 20, 1987 (take)					Changed :	Feb-12-87 take					Changed :	Feb-13-87 takeE 15I 15		Date :		January 13, 1987		Edited by :	Takeshi Shimizu		Changed	:	January 20, 1987 (take)		Changed :	Feb-12-87 take		Changed :	Feb-13-87 takeE 15*//**********************************************************************/struct conspage *next_conspage()D 12{  extern struct dtd *ListpDTD ;E 12I 12  {    extern struct dtd *ListpDTD ;E 12D 12  register struct  conspage  *page1 ; 	 /* Pointer points allocated 1st MDS page */  register struct  conspage  *page2 ; 	 /* Pointer points allocated 2nd MDS page */E 12I 12    register struct  conspage  *page1 ;  /* Allocated 1st MDS page */    register struct  conspage  *page2 ;  /* Allocated 2nd MDS page */I 17    struct conspage *pg, *priorpg;    register int next, prior;E 17E 12D 12  register int next;E 12I 12D 17    register int next;E 17I 17#ifdef NEWCDRCODING    /* Alloc 2 Conspages and get 1st page base */    page1 = (struct conspage *)alloc_mdspage(TYPE_LISTP) ;E 17E 12D 17#ifdef TRACE2D 12	printf("TRACE: next_conspage()\n");E 12I 12    printf("TRACE: next_conspage()\n");E 12#endifE 17I 17    /* Culc. next Conspage's Base address */    page2 = (struct conspage *)((DLword *)page1 + DLWORDSPER_PAGE) ;E 17I 17    init_conspage(page2 , 0); /* Doesn't exst next page */    init_conspage(page1 , LPAGE_from_68k(page2) ) ;    prior = 0;	for (pg = (struct conspage *)Addr68k_from_LPAGE(next=ListpDTD->dtd_nextpage);         next && (next != 65535);		 pg = (struct conspage *)Addr68k_from_LPAGE(next = pg->next_page))	  { priorpg = pg; prior = next; }    if (prior) priorpg->next_page = LPAGE_from_68k(page1);	else ListpDTD->dtd_nextpage = LPAGE_from_68k(page1) ;    	if (page2->next_page) error("page2 has a next page??");	if (page2 == priorpg) error("loop in conspage next_pages");#elseE 17D 12  for(next =(int) ListpDTD->dtd_nextpage ; /* getnext free conspage */     ; ListpDTD -> dtd_nextpage = next = page1 -> next_page ,      page1->next_page = 0xffff )  {  if(next ==0)   {	/* Alloc 2 Conspages and get 1st page base */	page1 = (struct conspage *)alloc_mdspage(TYPE_LISTP) ;E 12I 12    for(next =(int) ListpDTD->dtd_nextpage ; /* getnext free conspage */         ; ListpDTD -> dtd_nextpage = next = page1 -> next_page ,          page1->next_page = 0xffff )      {	if(next ==0)	  {	    /* Alloc 2 Conspages and get 1st page base */	    page1 = (struct conspage *)alloc_mdspage(TYPE_LISTP) ;E 12D 12	/* Culc. next Conspage's Base address */	page2 = (struct conspage *)((DLword *)page1 + DLWORDSPER_PAGE) ;E 12I 12	    /* Culc. next Conspage's Base address */	    page2 = (struct conspage *)((DLword *)page1 + DLWORDSPER_PAGE) ;E 12D 17#ifdef TRACE2D 12	printf("DEB: nextcons : new cons page %x and %x \n",LADDR_from_68k(page1),LADDR_from_68k(page2));E 12I 12	    printf("DEB: nextcons : new cons page %x and %x \n",			LADDR_from_68k(page1),LADDR_from_68k(page2));E 12#endifE 17D 12	init_conspage(page2 , NIL_PTR); /* Doesn't exst next page */D 4	init_conspage( page1 , LPAGE_from_68k(page2) ) ;E 4I 4	init_conspage(page1 , LPAGE_from_68k(page2) ) ;E 12I 12D 17	    init_conspage(page2 , NIL_PTR); /* Doesn't exst next page */E 17I 17	    init_conspage(page2 , ListpDTD->dtd_nextpage); /* Doesn't exst next page */E 17	    init_conspage(page1 , LPAGE_from_68k(page2) ) ;E 12E 4D 7	ListpDTD->dtd_nextpage = LPAGE_from_68k(page1) ;/*Jan-21 page2 -> page 1*/E 7I 7D 12	ListpDTD->dtd_nextpage = LPAGE_from_68k(page1) ;E 7	goto ex ; /* replaced break */   }  else   {	page1 =(struct conspage *) Addr68k_from_LPAGE(next) ; /*Jan-21*/   }E 12I 12	    ListpDTD->dtd_nextpage = LPAGE_from_68k(page1) ;	    goto ex ; /* replaced break */	  }	else	  {	    page1 =(struct conspage *) Addr68k_from_LPAGE(next) ; /*Jan-21*/	  }E 12D 12  if (page1->count > 1)	break ;E 12I 12	if (page1->count > 1) break ;E 12D 12 } /* for loop end */E 12I 12      } /* for loop end */I 17#endif /* NEWCDRCODING */E 17E 12ex :D 12 return(page1) ;}  /* next_conspage end */E 12I 12    return(page1) ;  }  /* next_conspage end */E 12I 12E 12D 17/**********************************************************************//*	Func name :	init_conspageE 17I 17/************************************************************************//*									*//*			i n i t _ c o n s p a g e			*//*									*//*	Initialize a fresh page of CONS cells.  Sets the count field	*//*	and chains the cells together for ease of searching.		*//*									*//*	A fresh CONS page looks like this:				*//*									*//*	+--------+--------+----------------+				*//*    0 | count  | nxtcell|   (padding)    |	nxtcell = 254.		*//*	+--------+--------+----------------+				*//*    2 |      next_page                   |				*//*	+--------+-------------------------+				*//*    4 |     0  |         N I L           |				*//*	+--------+-------------------------+				*//*    6 |     4  |         N I L           |				*//*	+--------+-------------------------+				*//*  ... |   ...  |         N I L           |				*//*	+--------+-------------------------+				*//*  254 |   252  |         N I L           |				*//*	+--------+-------------------------+				*//*									*//*	The cells are chained together thru their high 8 bits,		*//*	using the word offset within page as the chain.  Cells		*//*	are chained from the top of the page down.			*//*									*//*									*//*									*//*									*//************************************************************************/E 17D 17		GET NEXT CONS PAGE .			Date :		January 13, 1987			Edited by :	Takeshi Shimizu			Changed :	Feb-13-87 take					Nov-13-87 take(DLword ->int)*//**********************************************************************/E 17init_conspage( base , link )  register struct conspage *base;  /* Page Base */  DLword link ; /* Prev Link page number DL->int*/D 12{  register ConsCell *cell ;  register int j ; /* DL-> int */E 12I 12  {    register ConsCell *cell ;    register int j ; /* DL-> int */E 12#ifdef TRACE2D 12	printf("TRACE: init_conspage()\n");E 12I 12    printf("TRACE: init_conspage()\n");E 12#endifD 12  base -> next_cell= j = 254 ;E 12I 12    base -> next_cell= j = 254 ;E 12D 17  E 17I 17#ifdef NEWCDRCODING    while (j > 4)#elseE 17D 12  while(j != 0)   {E 12I 12    while(j != 0)I 17#endif /* NEWCDRCODING */E 17     {E 12	cell = (ConsCell *)((DLword *)base + j );	cell->car_field = NIL_PTR ;D 17	cell->cdr_code = j = j-2 ;E 17I 17	((freecons *)cell)->next_free = j = j-2 ;E 17D 12   }  base -> count = 127 ;  base -> next_page = link ;E 12I 12     }I 17#ifdef NEWCDRCODING    base -> count = 126;#elseE 17    base -> count = 127 ;I 17#endif /* NEWCDRCODING */E 17    base -> next_page = link ;E 12D 12} /* init_conspage end */E 12I 12  } /* init_conspage end */E 12I 12I 17/************************************************************************//*									*//*			f i n d _ c d r c o d a b l e _ p a i r			*//*									*//*	Find a pair of CONS cells that are close enough (within 7)			*//*	that the second can be cdr-coded as the cdr of the first.			*//*	Set up the cdr code in the first cell, and return it.								*//*									*//*	First searches the CONS page given, then the free-page chain			*//*	finally, calls conspage to get a fresh (and guaranteed useful) page.			*//*									*//************************************************************************/E 17I 17ConsCell * find_pair_in_page(pg, cdrval)  struct conspage *pg;  LispPTR cdrval;  {    ConsCell *carcell, *cdrcell;	unsigned int offset, prior, priorprior;	if (pg->count < 2) return((ConsCell *)0);	priorprior = prior = 0;	for (offset = pg->next_cell; offset; offset = FREECONS(pg, offset)->next_free)	  {	if (prior)	  {		if (prior <= offset) error("free list in CONS page corrupt.");		if (prior <= offset+14)		  {						carcell = (ConsCell *) ((DLword *)pg + offset);			cdrcell = (ConsCell *) ((DLword *)pg + prior);		if (priorprior)		  FREECONS(pg,priorprior)->next_free = ((freecons *)carcell) ->next_free;		else pg->next_cell = ((freecons *)carcell) ->next_free;			carcell -> cdr_code = cdrcell - carcell;			if ((cdrcell-carcell) > 7) error("in find_pair_in_page, cdr code too big.");			if (254 < (offset + (carcell->cdr_code << 1))) error ("in fpip, page overflow.");			pg->count -= 2;			*((LispPTR *)cdrcell) = cdrval;			return(carcell);		  }	  }	    priorprior = prior;	    prior = offset;      }    return((ConsCell *)0);  }ConsCell * find_cdrcodable_pair(cdrval)  LispPTR cdrval;  {    ConsCell * cell;    struct conspage *pg;	unsigned pgno = ListpDTD->dtd_nextpage;	for (pg = (struct conspage *)Addr68k_from_LPAGE(pgno); pgno;			pg = (struct conspage *)Addr68k_from_LPAGE(pgno = pg->next_page))	  if (cell = find_pair_in_page(pg, cdrval)) return(cell);    pg = next_conspage();	return(find_pair_in_page(pg, cdrval));  }  /* end of find_cdrcodable_pair */ConsCell * find_free_cons_cell()  {    ConsCell * cell;    struct conspage *pg, *priorpg;	unsigned pgno = ListpDTD->dtd_nextpage;	for (pg = (struct conspage *)Addr68k_from_LPAGE(pgno); pgno;			pg = (struct conspage *)Addr68k_from_LPAGE(pgno))	  if (pg->count)		{		  pg->count--;		  cell =(ConsCell *) (((DLword *)pg)+(pg->next_cell));		  pg->next_cell = ((freecons *)cell)->next_free;		  return(cell);	    }      else		{ /* remove the empty page from the free chain */		  pgno = ListpDTD->dtd_nextpage = pg->next_page;	  		  pg->next_page = 0xffffffff;        }	return((ConsCell *)0);  }  /* end of find_free_cons_cell */E 17E 12/**********************************************************************/D 7/*	Func name :OP_cons			Execute OPCODE Cons .			Date :		January 22 1987			Edited by :	Takeshi Shimizu			Changed :	Feb-12 take			Changed :	22-Apr-87 take					27-Apr-87 take					22-Sep-87 take(add IncAllocCnt)					13-Nov-87 take(Dl->int)*/E 7I 7/* function cons same as N_OP_cons				      */E 7/**********************************************************************/D 7OP_cons(){  extern int TopOfStack ;  extern DLword *CurrentStackPTR ;  extern struct dtd *ListpDTD ;  register int cons_x ; /* cache argument x(on Current STK) */  register struct conspage *new_conspage ;  register ConsCell *new_cell ;  register ConsCell *temp_cell ;  register int new_page ;  /* hold the return  val of nextconspage ,DL->int */#ifdef TRACE  printPC();  printf("TRACE:OP_cons() \n TOS= 0x%x ; CSTK = 0x%x ; \n",TopOfStack,GetLongWord(CurrentStackPTR) );#endif  cons_x = GetLongWord(CurrentStackPTR) ;  CurrentStackPTR -= 2;D 4  gclookup(0x8000|ADDREF, TopOfStack);  gclookup(0x8000|ADDREF, cons_x);E 4I 4  GCLOOKUP(0x8000,ADDREF, TopOfStack);  GCLOOKUP(0x8000,ADDREF, cons_x);E 4  IncAllocCnt(1);  if(TopOfStack == NIL_PTR)   {	if ((ListpDTD->dtd_nextpage != 0)&&(GetCONSCount(ListpDTD->dtd_nextpage) > 0))	{	/* nextpage has 1 or more free cells  in that page */	  	/* uCode  CDR_NIL case */		new_page = ListpDTD->dtd_nextpage;		/* Get New Cell */		new_conspage = (struct conspage *)Addr68k_from_LPAGE(new_page);		new_cell = GetNewCell_68k(new_conspage); /* get new cell */#ifdef DEBUG	if(new_cell->car_field != NIL) {		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));		error("QUIT from OP_cons");	}#endif		new_conspage->count --;  /* decrement free cnt. */		new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */		/* filling new cell with the data */		new_cell->car_field = cons_x ;		new_cell->cdr_code = CDR_NIL ;		ListpDTD->dtd_cnt0++;	} /* if (ListpDTD.. end */	else /* 1   UFN case : CDR_NIL */	{		new_conspage=next_conspage();		new_cell = GetNewCell_68k( new_conspage ) ;#ifdef DEBUG	if(new_cell->car_field != NIL) {		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));		error("QUIT from OP_cons");	}#endif		new_conspage->count --;  /* decrement free cnt. */		new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */		/* filling new cell with the data */		new_cell->car_field = cons_x ;		new_cell->cdr_code = CDR_NIL ;		ListpDTD->dtd_oldcnt++;	} /* else 1 end */   } /* if(TopOfStack.. end */  else /* TopOfStack != NIL */   {	new_page = POINTER_PAGE(TopOfStack); /* Y's page num */	if(Listp(TopOfStack) && (GetCONSCount(new_page ) > 0 ))	{		/* uCode case : CDR_ONPAGE */		new_conspage= (struct conspage *)Addr68k_from_LPAGE(new_page);		new_cell = GetNewCell_68k( new_conspage ) ;#ifdef DEBUG	if(new_cell->car_field != NIL) {		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));		error("QUIT from OP_cons");	}#endif		new_conspage->count --;  /* decrement free cnt. */		new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */		new_cell->car_field = cons_x ;		/* cdr_onpage + cell offset in this conspage */		new_cell->cdr_code = CDR_ONPAGE | ((TopOfStack&0xff)>>1) ;		ListpDTD->dtd_cnt0++;			} /* if (listp.. end */	else	{		/* UFN case : CDR_INDIRECT */		new_conspage = next_conspage();		/* get 2 cells from conspage */		temp_cell = GetNewCell_68k( new_conspage ) ;#ifdef DEBUG	if(temp_cell->car_field != NIL) {		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));		error("QUIT from OP_cons");	}#endif		new_conspage->next_cell = temp_cell->cdr_code ; /* update free cell chain */		new_cell = GetNewCell_68k( new_conspage ) ;#ifdef DEBUG	if(new_cell->car_field != NIL) {		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));		error("QUIT from OP_cons");	}#endif		new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */		new_conspage->count -= 2;  /* decrement free cnt. */		/* filling cell */		*((LispPTR *)temp_cell) = TopOfStack ; /* Indirect CDR ptr */		 /*** temp_cell->car_field = TopOfStack ; */		 /*** temp_cell->cdr_code = 0 ; */		new_cell->car_field = cons_x ;		/* culc. cdr code */		new_cell->cdr_code = (((LispPTR)LADDR_from_68k(temp_cell)) & 0xff) >> 1;		ListpDTD->dtd_oldcnt++ ;  /* added feb-12 take */	} /* else end */   } /* else (TOS==NIL end) */ /* return val set */  TopOfStack = LADDR_from_68k(new_cell) ;D 4  gclookup(0x8000|DELREF , TopOfStack);E 4I 4  GCLOOKUP(0x8000,DELREF , TopOfStack);E 4  PC++; /* PC mainte. */} /* OP_cons() end *//******************************************************************//*		Func name :	cons		Desc :		C Interface for CONSing		Created :	17-Apr-87 T.Shimizu		Changed :	27-Apr-87 take				22-Sep-87 take(add IncAllocCnt)				13-Nov-87 take(DL->int)*//******************************************************************/E 7cons(cons_car , cons_cdr)D 7  LispPTR  cons_car ;  register LispPTR  cons_cdr ;{E 7I 7D 8#ifndef FROBE 8  LispPTR  cons_car, cons_cdr ;D 12{ return(N_OP_cons(cons_car, cons_cdr));}E 12I 12  {    return(N_OP_cons(cons_car, cons_cdr));  }E 12E 7  I 12E 12D 7  extern struct dtd *ListpDTD ;  register struct conspage *new_conspage ;  register ConsCell *new_cell ;  register ConsCell *temp_cell ;  LispPTR  ret_Laddr ;  register int new_page ;  /* hold the return  val of nextconspage */#ifdef TRACE2 printf("TRACE: cons (cons_car: 0x%x , cons_cdr: 0x%x ) \n",cons_car,cons_cdr);#endif/* Don't care RECLAIMCOUNTDOWN,yet */D 4  gclookup(0x8000|ADDREF, cons_car);  gclookup(0x8000|ADDREF, cons_cdr);E 4I 4  GCLOOKUP(0x8000,ADDREF, cons_car);  GCLOOKUP(0x8000,ADDREF, cons_cdr);E 4  IncAllocCnt(1);  if(cons_cdr == NIL_PTR)   {	if ((ListpDTD->dtd_nextpage != 0)&&(GetCONSCount(ListpDTD->dtd_nextpage) > 0))	{	/* nextpage has 1 or more free cells  in that page */	  	/* uCode  CDR_NIL case */		new_page = ListpDTD->dtd_nextpage;		/* Get New Cell */		new_conspage = (struct conspage *)Addr68k_from_LPAGE(new_page);		new_cell = GetNewCell_68k(new_conspage); /* get new cell */#ifdef DEBUG	if(new_cell->car_field != NIL) {		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));		error("QUIT from cons");	}#endif		new_conspage->count --;  /* decrement free cnt. */		new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */		/* filling new cell with the data */		new_cell->car_field = cons_car ;		new_cell->cdr_code = CDR_NIL ;		ListpDTD->dtd_cnt0++;	} /* if (ListpDTD.. end */	else /* 1   UFN case : CDR_NIL */	{		new_conspage=next_conspage();		new_cell = GetNewCell_68k( new_conspage ) ;#ifdef DEBUG	if(new_cell->car_field != NIL) {		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));		error("QUIT from cons");	}#endif		new_conspage->count --;  /* decrement free cnt. */		new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */		/* filling new cell with the data */		new_cell->car_field = cons_car ;		new_cell->cdr_code = CDR_NIL ;		ListpDTD->dtd_oldcnt++;	} /* else 1 end */   } /* if(TopOfStack.. end */  else /* TopOfStack != NIL */   {	new_page = POINTER_PAGE(cons_cdr); /* Y's page num */	if(Listp(cons_cdr) && (GetCONSCount(new_page ) > 0 ))	{		/* uCode case : CDR_ONPAGE */		new_conspage= (struct conspage *)Addr68k_from_LPAGE(new_page);		new_cell = GetNewCell_68k( new_conspage ) ;#ifdef DEBUG	if(new_cell->car_field != NIL) {		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));		error("QUIT from cons");	}#endif		new_conspage->count --;  /* decrement free cnt. */		new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */		new_cell->car_field = cons_car ;		/* cdr_onpage + cell offset in this conspage */		new_cell->cdr_code = CDR_ONPAGE | (((cons_cdr) & 0xff)>>1) ;		ListpDTD->dtd_cnt0++;			} /* if (listp.. end */	else	{		/* UFN case : CDR_INDIRECT */		new_conspage = next_conspage();		/* get 2 cells from conspage */		temp_cell = GetNewCell_68k( new_conspage ) ;#ifdef DEBUG	if(temp_cell->car_field != NIL) {		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));		error("QUIT from cons");	}#endif		new_conspage->next_cell = temp_cell->cdr_code ; /* update free cell chain */		new_cell = GetNewCell_68k( new_conspage ) ;#ifdef DEBUG	if(new_cell->car_field != NIL) {		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));		error("QUIT from cons");	}#endif		new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */		new_conspage->count -= 2;  /* decrement free cnt. */		/* filling cell */		/* Indirect CDR ptr */		*((LispPTR *)temp_cell) = cons_cdr ;		/*** temp_cell->car_field = cons_cdr ;		temp_cell->cdr_code = 0 ; */		new_cell->car_field = cons_car ; /* CAR cell */		/* culc. cdr code */		new_cell->cdr_code =((LispPTR)(LADDR_from_68k(temp_cell)) & 0x0ff) >> 1 ;		ListpDTD->dtd_oldcnt++ ;  /* added feb-12 take */	} /* else end */   } /* else ( end) */ /* return val set */  ret_Laddr = LADDR_from_68k(new_cell) ;D 4  gclookup(0x8000|DELREF , ret_Laddr);E 4I 4  GCLOOKUP(0x8000,DELREF , ret_Laddr);E 4  return(ret_Laddr);} /* cons() end */I 3E 7/**********************************************************************//*	Func name :N_OP_cons	D 7		Execute OPCODE Cons .E 7I 7		Execute CONS OPCODEE 7			Date :		March 29 1988			Edited by :	Bob Krivacic*//**********************************************************************/N_OP_cons(cons_car, cons_cdr)D 12	register int cons_car, cons_cdr;{  extern struct dtd *ListpDTD ;E 12I 12  register int cons_car, cons_cdr;  {    extern struct dtd *ListpDTD ;E 12D 12  register struct conspage *new_conspage ;  register ConsCell *new_cell ;  register ConsCell *temp_cell ;  register int new_page ;  /* hold the return  val of nextconspage ,DL->int */E 12I 12    register struct conspage *new_conspage ;    register ConsCell *new_cell ;    register ConsCell *temp_cell ;    register int new_page ;  /* hold the return  val of nextconspage ,DL->int */E 12I 17	extern ConsCell * find_close_prior_cell();E 17D 10#ifdef TRACE  printPC();  printf("TRACE:N_OP_cons() \n TOS= 0x%x ; tos-1 = 0x%x ; \n",cons_cdr,cons_car );#endifE 10D 4  gclookup(0x8000|ADDREF, cons_cdr);  gclookup(0x8000|ADDREF, cons_car);E 4I 4D 12  GCLOOKUP(0x8000,ADDREF, cons_cdr);  GCLOOKUP(0x8000,ADDREF, cons_car);E 12I 12D 14    GCLOOKUP(0x8000,ADDREF, cons_cdr);    GCLOOKUP(0x8000,ADDREF, cons_car);E 14I 14    GCLOOKUP(cons_cdr, ADDREF);    GCLOOKUP(cons_car, ADDREF);E 14E 12E 4D 12  IncAllocCnt(1);E 12I 12D 14    IncAllocCnt(1);E 14I 14D 17/*    IncAllocCnt(1); */E 17E 14E 12D 12  if(cons_cdr == NIL_PTR)   {E 12I 12    if(cons_cdr == NIL_PTR)      {E 12D 17	if ((ListpDTD->dtd_nextpage != 0)&&(GetCONSCount(ListpDTD->dtd_nextpage) > 0))D 12	{	/* nextpage has 1 or more free cells  in that page */	  	/* uCode  CDR_NIL case */		new_page = ListpDTD->dtd_nextpage;		/* Get New Cell */		new_conspage = (struct conspage *)Addr68k_from_LPAGE(new_page);		new_cell = GetNewCell_68k(new_conspage); /* get new cell */E 12I 12	  {	/* nextpage has 1 or more free cells  in that page */	    /* uCode  CDR_NIL case */E 17I 17#ifdef NEWCDRCODING	if (new_cell = find_free_cons_cell())	  {	/* next page has 1 or more free cells */#else	if ((ListpDTD->dtd_nextpage != 0)	    && (GetCONSCount(ListpDTD->dtd_nextpage) > 0))	  {	/* next page has 1 or more free cells */E 17	    new_page = ListpDTD->dtd_nextpage;D 17	    /* Get New Cell */E 17	    new_conspage = (struct conspage *)Addr68k_from_LPAGE(new_page);I 17		if (new_conspage->next_cell == 0) error("count ne 0, but nothing on free chain.");E 17	    new_cell = GetNewCell_68k(new_conspage); /* get new cell */E 12D 17#ifdef DEBUGD 12	if(new_cell->car_field != NIL) {E 12I 12	    if(new_cell->car_field != NIL)	      {E 12D 15		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));E 15I 15		printf("CELL 0x%x has non-NIL car = 0x%x \n",		       LADDR_from_68k(new_cell), new_cell->car_field);E 15		error("QUIT from N_OP_cons");D 12	}E 12I 12	      }E 12#endifE 17D 12		new_conspage->count --;  /* decrement free cnt. */		new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */E 12I 12	    new_conspage->count --;  /* decrement free cnt. */D 17	    new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */E 17I 17	    new_conspage->next_cell	       = ((freecons *)new_cell)->next_free ; /* update free cell chain */#endif /* NEWCDRCODING */E 17E 12D 12		/* filling new cell with the data */		new_cell->car_field = cons_car ;		new_cell->cdr_code = CDR_NIL ;E 12I 12	    /* filling new cell with the data */	    new_cell->car_field = cons_car ;	    new_cell->cdr_code = CDR_NIL ;E 12D 12		ListpDTD->dtd_cnt0++;E 12I 12	    ListpDTD->dtd_cnt0++;E 12D 12	} /* if (ListpDTD.. end */E 12I 12	  } /* if (ListpDTD.. end */E 12D 17	else /* 1   UFN case : CDR_NIL */D 12	{		new_conspage=next_conspage();E 12I 12	  {E 17I 17	else 	  { /* Need to get a new CONS page */E 17	    new_conspage=next_conspage();E 12D 12		new_cell = GetNewCell_68k( new_conspage ) ;E 12I 12	    new_cell = GetNewCell_68k( new_conspage ) ;E 12D 17#ifdef DEBUGD 12	if(new_cell->car_field != NIL) {E 12I 12	    if(new_cell->car_field != NIL)	      {E 12D 15		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));E 15I 15		printf("CELL 0x%x has non-NIL car = 0x%x \n",		       LADDR_from_68k(new_cell), new_cell->car_field);E 15		error("QUIT from N_OP_cons");D 12	}E 12I 12	      }E 12#endifE 17D 12		new_conspage->count --;  /* decrement free cnt. */		new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */E 12I 12	    new_conspage->count --;  /* decrement free cnt. */D 17	    new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */E 17I 17	    new_conspage->next_cell	      = ((freecons *)new_cell)->next_free ; /* update free cell chain */E 17E 12D 12		/* filling new cell with the data */		new_cell->car_field = cons_car ;		new_cell->cdr_code = CDR_NIL ;E 12I 12	    /* filling new cell with the data */	    new_cell->car_field = cons_car ;	    new_cell->cdr_code = CDR_NIL ;E 12D 12		ListpDTD->dtd_oldcnt++;E 12I 12	    ListpDTD->dtd_oldcnt++;E 12D 12	} /* else 1 end */   } /* if(cons_cdr.. end */  else /* cons_cdr != NIL */   {E 12I 12	  } /* else 1 end */      } /* if(cons_cdr.. end */    else /* cons_cdr != NIL */      {E 12	new_page = POINTER_PAGE(cons_cdr); /* Y's page num */D 17	if(Listp(cons_cdr) && (GetCONSCount(new_page ) > 0 ))D 12	{		/* uCode case : CDR_ONPAGE */		new_conspage= (struct conspage *)Addr68k_from_LPAGE(new_page);E 12I 12	  {	    /* uCode case : CDR_ONPAGE */	    new_conspage= (struct conspage *)Addr68k_from_LPAGE(new_page);E 17I 17	new_conspage= (struct conspage *)Addr68k_from_LPAGE(new_page);#ifdef NEWCDRCODING	if (Listp(cons_cdr) && (new_conspage->count > 0 )	   && (new_cell = find_close_prior_cell(new_conspage, cons_cdr)))#else	if(Listp(cons_cdr) && (new_conspage->count > 0 ))#endif /* NEWCDRCODING */	  { /* The cdr is itself a CONS cell, and can be */	    /* represented using CDR_ONPAGE representation */E 17E 12I 17#ifndef NEWCDRCODINGE 17D 12		new_cell = GetNewCell_68k( new_conspage ) ;E 12I 12	    new_cell = GetNewCell_68k( new_conspage ) ;E 12#ifdef DEBUGD 12	if(new_cell->car_field != NIL) {E 12I 12	    if(new_cell->car_field != NIL)	      {E 12D 15		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));E 15I 15		printf("CELL 0x%x has non-NIL car = 0x%x \n",		       LADDR_from_68k(new_cell), new_cell->car_field);E 15		error("QUIT from N_OP_cons");D 12	}E 12I 12	      }E 12#endifD 12		new_conspage->count --;  /* decrement free cnt. */		new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */E 12I 12	    new_conspage->count --;  /* decrement free cnt. */D 17	    new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */E 17I 17	    new_conspage->next_cell	      = ((freecons *)new_cell)->next_free ; /* update free cell chain */#endif /*NEWCDRCODING */E 17E 12D 12		new_cell->car_field = cons_car ;		/* cdr_onpage + cell offset in this conspage */		new_cell->cdr_code = CDR_ONPAGE | ((cons_cdr&0xff)>>1) ;E 12I 12	    new_cell->car_field = cons_car ;	    /* cdr_onpage + cell offset in this conspage */I 17#ifdef NEWCDRCODING#elseE 17	    new_cell->cdr_code = CDR_ONPAGE | ((cons_cdr&0xff)>>1) ;E 12D 17E 17I 17#endif /* NEWCDRCODING */E 17D 12		ListpDTD->dtd_cnt0++;E 12I 12	    ListpDTD->dtd_cnt0++;E 12		D 12	} /* if (listp.. end */E 12I 12	  } /* if (listp.. end */E 12	elseD 12	{		/* UFN case : CDR_INDIRECT */		new_conspage = next_conspage();E 12I 12	  {	    /* UFN case : CDR_INDIRECT */I 17#ifdef NEWCDRCODING	new_cell = find_cdrcodable_pair(cons_cdr);#elseE 17	    new_conspage = next_conspage();E 12D 12		/* get 2 cells from conspage */		temp_cell = GetNewCell_68k( new_conspage ) ;E 12I 12	    /* get 2 cells from conspage */	    temp_cell = GetNewCell_68k( new_conspage ) ;E 12#ifdef DEBUG	if(temp_cell->car_field != NIL) {D 15		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));E 15I 15		printf("CDR indirect CELL 0x%x has non-NIL car 0x%x \n",		       LADDR_from_68k(new_cell), temp_cell->car_field);E 15		error("QUIT from N_OP_cons");	}#endifD 12		new_conspage->next_cell = temp_cell->cdr_code ; /* update free cell chain */		new_cell = GetNewCell_68k( new_conspage ) ;E 12I 12D 17	    new_conspage->next_cell = temp_cell->cdr_code ; /* update free cell chain */E 17I 17	    new_conspage->next_cell	      = ((freecons *)temp_cell)->next_free ; /* update free cell chain */E 17	    new_cell = GetNewCell_68k( new_conspage ) ;E 12#ifdef DEBUG	if(new_cell->car_field != NIL) {D 15		printf("BAD CELL: %d \n",LADDR_from_68k(new_cell));E 15I 15		printf("CDR ind-2 CELL 0x%x has non-NIL car = 0x%x \n",		       LADDR_from_68k(new_cell), new_cell->car_field);E 15		error("QUIT from N_OP_cons");	}#endifD 12		new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */		new_conspage->count -= 2;  /* decrement free cnt. */E 12I 12D 17	    new_conspage->next_cell = new_cell->cdr_code ; /* update free cell chain */E 17I 17	    new_conspage->next_cell	      = ((freecons *)new_cell)->next_free ; /* update free cell chain */E 17	    new_conspage->count -= 2;  /* decrement free cnt. */E 12D 12		/* filling cell */		*((LispPTR *)temp_cell) = cons_cdr ; /* Indirect CDR ptr */E 12I 12	    /* filling cell */	    *((LispPTR *)temp_cell) = cons_cdr ; /* Indirect CDR ptr */E 12D 17E 17I 17#endif /* NEWCDRCODING */E 17D 12		new_cell->car_field = cons_car ;		/* culc. cdr code */		new_cell->cdr_code = (((LispPTR)LADDR_from_68k(temp_cell)) & 0xff) >> 1;E 12I 12	    new_cell->car_field = cons_car ;I 17#ifndef NEWCDRCODINGE 17	    /* culc. cdr code */	    new_cell->cdr_code = (((LispPTR)LADDR_from_68k(temp_cell)) & 0xff) >> 1;I 17#endif /* NEWCDRCODING */E 17E 12D 12		ListpDTD->dtd_oldcnt++ ;  /* added feb-12 take */E 12I 12	    ListpDTD->dtd_oldcnt++ ;  /* added feb-12 take */E 12D 12	} /* else end */E 12I 12	  } /* else end */E 12D 12   } /* else (cons_cdr==NIL end) */E 12I 12      } /* else (cons_cdr==NIL end) */E 12D 12 /* return val set */E 12I 12D 17    /* return val set */E 17E 12 D 12  new_page = LADDR_from_68k(new_cell) ;E 12I 12    new_page = LADDR_from_68k(new_cell) ;E 12D 17E 17D 4  gclookup(0x8000|DELREF , new_page);E 4I 4D 12  GCLOOKUP(0x8000,DELREF , new_page);E 12I 12D 14    GCLOOKUP(0x8000,DELREF , new_page);E 14I 14    GCLOOKUP(new_page, DELREF);E 14E 12E 4D 17E 17I 17	if (254 < ((new_page & 0xff) + ((new_cell->cdr_code & 7)<<1))) error("in CONS, cdr code too big.");E 17D 12  return(new_page);E 12I 12    return(new_page);E 12D 12} /* N_OP_cons() end */E 12I 12  } /* N_OP_cons() end */E 12E 3E 1