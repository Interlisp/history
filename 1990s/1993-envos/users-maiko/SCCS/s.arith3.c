h46837s 00004/00004/00112d D 2.9 92/04/21 17:01:21 sybalsky 12 11c shortening file names for DOS \nes 00000/00000/00116d D 2.8 90/04/20 01:17:38 sybalsky 11 10c ulk change.es 00049/00031/00067d D 2.7 90/02/19 09:27:07 sybalsky 10 9c Check for 386 dependencies, add comments.es 00013/00026/00085d D 2.6 88/11/30 19:56:27 shih 9 8c minor cleanupes 00015/00014/00096d D 2.5 88/10/12 14:39:06 krivacic 8 7c new out-of-line interfacees 00000/00115/00110d D 2.4 88/09/27 15:48:42 krivacic 7 6c mergees 00008/00014/00217d D 2.3 88/05/31 16:00:52 masinter 6 5c boxiplus, idifference were ufning wronges 00005/00000/00226d D 2.2 88/05/27 14:48:43 krivacic 5 4c es 00000/00000/00226d D 2.1 88/05/17 09:21:41 hayata 4 3c Version up to 2.1es 00002/00002/00224d D 1.3 88/03/13 14:32:17 hayata 3 2c Add SCCS key id (%Z%)es 00080/00000/00146d D 1.2 88/03/11 18:06:29 krivacic 2 1c Native Interfaceses 00146/00000/00000d D 1.1 88/02/24 16:55:40 hayata 1 0c date and time created 88/02/24 16:55:40 by hayataeuUtTI 1D 3/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 3I 3D 9/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 9I 9D 10/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(envos & Fuji Xerox)";E 10I 10/* @(#) arith3.c Version 2.6 (11/30/88). copyright envos & Fuji Xerox  */static char *id = "@(#) arith3.c	2.6 11/30/88	(envos & Fuji Xerox)";E 10E 9E 3D 10/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 9 *	Auther :  Takeshi ShimizuE 9I 9 *	Author :  Takeshi ShimizuE 9 * */E 10D 10/***********************************************************************//*D 9 		File Name :	arith3.cE 9I 9		File Name :	arith3.cE 10E 9D 9		Desc	:	  				Date :		Jun. 29, 1987 				Edited by :	Takeshi Shimizu				Changed :	09-Nov, 1987 Hayata(OP_boxiplus) E 9D 10		Including :	OP_makenumber				OP_boxiplus				OP_boxidiffD 9								E 9*//**********************************************************************/E 10I 10/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 10I 10/************************************************************************//*									*//*			    A R I T H 3 . C				*//*									*//*	Including :	OP_makenumber					*//*			OP_boxiplus					*//*			OP_boxidiff					*//*									*//*									*//************************************************************************/E 10#include "lispemul.h"#include "lispmap.h"D 12#include "emulglobal.h"#include "lispglobal.h"#include "lisptypes.h"E 12I 12#include "emlglob.h"#include "lspglob.h"#include "lsptypes.h"E 12#include "address.h"D 12#include "address68k.h"E 12I 12#include "adr68k.h"E 12D 9#include "cell.h" #include "arith.h"  E 9I 9#include "cell.h"#include "arith.h"E 9I 5D 7#ifdef C_ONLYE 7E 5D 7/**********************************************************************//*E 7I 9E 9D 7		Func name :	OP_makenumber			Date :		Jun. 29, 1987			Edited by :	Take*/E 7D 10/**********************************************************************/D 7OP_makenumber(){  LispPTR arg1 ; 	/* Keep val of CSTK */  int  *cell68k ; 	/* Pointer to FIXP cell */  DLword *createcell68k();  PopStackTo(arg1);  /* Pop CSTK to arg1 */  if(((TopOfStack & 0xFF0000) != S_POSITIVE) || ((arg1 & 0xFF0000) !=  S_POSITIVE))	error("OP_makenumber : Illegal Arg");  switch(arg1=(arg1 & 0xFFFF))   {	case 0:		TopOfStack |=S_POSITIVE ;			break;	case 0xFFFF :	TopOfStack |=S_NEGATIVE;			break;	default :	cell68k=(int *)createcell68k(TYPE_FIXP);			*cell68k=arg1<<16;			*cell68k |=TopOfStack & 0xFFFF ;			TopOfStack = LADDR_from_68k(cell68k);			break;    } PC++; /* Increment PC */} /* end OP_makenumber *//**********************************************************************/E 7/*E 10D 7		Func name :	OP_boxiplus			Date :		Jun. 29, 1987			Edited by :	Take			Changed :	09-Nov, 1987 Hayata*//**********************************************************************/OP_boxiplus(){  LispPTR  cstk ;	/* keep CSTK value */  int    arg1 ;		/* Immidiate value converted from the OBJECT pointed by CSTK */  int    arg2 ;		/* Immidiate value converted from the OBJECT pointed by TOS */  LispPTR *cell68k ;	/* cache pointer for cstk *//* Type of cell68k was chnaged from DLword* to LispPTR*. */  if( GetTypeNumber(cstk= *((LispPTR *)(CurrentStackPTR))) == TYPE_FIXP )   {	/* Get Immidiate values */	GetNumber(cstk, arg1);	GetNumber(TopOfStack, arg2);	cell68k=(LispPTR *)Addr68k_from_LADDR(cstk);	*cell68k = arg1 + arg2 ; /* No care about overflow */	PopCStack;	PC++;   }  else	ufn(0366); /* UFN call */} /* OP_boxiplus *//**********************************************************************//*		Func name :	OP_boxidiff			Date :		Jun. 29, 1987			Edited by :	Take(31-aug-87)*//**********************************************************************/OP_boxidiff(){  LispPTR  cstk ;	/* keep CSTK value */  int    arg1 ;		/* Immidiate value converted from the OBJECT pointed by CSTK */  int    arg2 ;		/* Immidiate value converted from the OBJECT pointed by TOS */  int *cell68k ;	/* cache pointer for cstk */  if( GetTypeNumber(cstk= *((LispPTR *)(CurrentStackPTR))) == TYPE_FIXP )   {	/* Get Immidiate values */	GetNumber(cstk, arg1);	GetNumber(TopOfStack, arg2);	cell68k=(int *)Addr68k_from_LADDR(cstk);	*cell68k = arg1 - arg2 ; /* No care about underflow */	PopCStack;	PC++;   }  else	ufn(0367); /* UFN call */} /* end OP_boxidiff */I 2I 5#elseE 5I 5E 5/**********************************************************************//*E 7D 10		Func name :	N_OP_makenumberE 10I 10/************************************************************************//*									*//*			N _ O P _ m a k e n u m b e r			*//*									*//*	Given the 2 halves of a FIXP as SMALLP's, create a number	*//*	box for the number, and fill it in.				*//*									*//************************************************************************/E 10D 9			Date :		March 9, 1988			Edited by :	KrivacicE 9D 10*//**********************************************************************/E 10D 8N_OP_makenumber(a, b, error_addr)  int a, b, *error_addr;{ register int result;E 8I 8D 9N_OP_makenumber(tosm1, tos) 	int tosm1, tos; { E 9I 9N_OP_makenumber(tosm1, tos)	int tosm1, tos;{E 9  register int result;E 8D 8  if(((a & 0xFFFF0000) != S_POSITIVE) || ((b & 0xFFFF0000) !=  S_POSITIVE))	ERROR_EXIT(error_addr);  result = ((a & 0xffff) << 16) | (b & 0xffff);E 8I 8  if(((tosm1 & 0xFFFF0000) != S_POSITIVE) || ((tos & 0xFFFF0000) !=  S_POSITIVE))	ERROR_EXIT(tos);  result = ((tosm1 & 0xffff) << 16) | (tos & 0xffff);E 8  N_ARITH_SWITCH(result);} /* end OP_makenumber */D 10/**********************************************************************//*E 10D 10		Func name :	N_OP_boxiplusE 10I 10/************************************************************************//*									*//*			N _ O P _ b o x i p l u s			*//*									*//*	Given a FIXP box and a number to add to it, add the number,	*//*	leaving the result in the box given.  Used to avoid garbaging.	*//*									*//************************************************************************/E 10D 9			Date :		March 9, 1988			Edited by :	KrivacicE 9D 10*//**********************************************************************/E 10D 8N_OP_boxiplus(a, b, error_addr)E 8I 8N_OP_boxiplus(a, tos)E 8  register int a;D 8  int b, *error_addr;E 8I 8  int tos;E 8{D 6  register int    arg1, arg2 ; E 6I 6D 9  register int    arg2 ; E 9I 9  register int    arg2;E 9E 6  if( GetTypeNumber(a) == TYPE_FIXP )   {D 6	/* Get Immidiate values */	GetNumber(a, arg1);	GetNumber(b, arg2);	*((LispPTR *)Addr68k_from_LADDR(a)) = arg1 + arg2;E 6I 6D 8	N_GETNUMBER(b, arg2, bad);E 8I 8	N_GETNUMBER(tos, arg2, bad);E 8	*((LispPTR *)Addr68k_from_LADDR(a)) += arg2;E 6	return(a);   }D 6  else	ERROR_EXIT(error_addr);E 6I 6D 8bad:	ERROR_EXIT(error_addr);E 8I 8bad:	ERROR_EXIT(tos);E 8E 6} /* OP_boxiplus */D 10/**********************************************************************//*E 10D 10		Func name :	OP_boxidiffE 10D 10*//**********************************************************************/E 10I 10/************************************************************************//*									*//*			O P _ b o x i d i f f				*//*									*//*	Given a FIXP box and a number to subtract from it, do the	*//*	subtraction, and leave the result in the box given.		*//*	Used to avoid allocating storage in low-level routines.		*//*									*//************************************************************************/E 10D 8N_OP_boxidiff(a, b, error_addr)E 8I 8N_OP_boxidiff(a, tos)E 8  register int a;D 8  int b, *error_addr;E 8I 8  int tos;E 8{D 6  register int    arg1, arg2 ; E 6I 6D 9  register int    arg2 ; E 9I 9  register int    arg2;E 9E 6  if( GetTypeNumber(a) == TYPE_FIXP )   {D 6	/* Get Immidiate values */	GetNumber(a, arg1);	GetNumber(b, arg2);	*((LispPTR *)Addr68k_from_LADDR(a)) = arg1 - arg2;E 6I 6D 8	N_GETNUMBER(b, arg2, bad);E 8I 8	N_GETNUMBER(tos, arg2, bad);E 8	*((LispPTR *)Addr68k_from_LADDR(a)) -=  arg2;E 6	return(a);   }D 6  else	ERROR_EXIT(error_addr);E 6I 6D 8  bad: ERROR_EXIT(error_addr);E 8I 8  bad: ERROR_EXIT(tos);E 8E 6} /* end OP_boxidiff */I 5D 7#endifE 7E 5E 2E 1