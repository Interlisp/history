h17749s 00001/00001/00415d D 1.12 91/09/27 03:18:33 sybalsky 12 11c ISC changes (fix)es 00003/00000/00413d D 1.11 91/09/27 02:11:38 sybalsky 11 10c ISC port changeses 00017/00002/00396d D 1.10 91/05/03 14:50:37 sybalsky 10 9c MIPS changeses 00016/00002/00382d D 1.9 91/04/16 14:54:38 sybalsky 9 8c Retrofit foreign-OS changes from Savoir.es 00002/00000/00382d D 1.8 91/02/04 12:48:39 sybalsky 8 7c Fix errors in teh Savoir retrofit (placement of ifdefs &c)es 00016/00002/00366d D 1.7 90/09/18 23:42:33 sybalsky 7 6c Retrofit changes from AIX, DEC3100, PS/2es 00000/00003/00368d D 1.6 90/06/13 15:40:06 sybalsky 6 5c #ifdef AIXes 00000/00000/00371d D 1.5 90/04/20 01:24:14 sybalsky 5 4c AIX:  shortening file names, bulk change.es 00004/00000/00367d D 1.4 90/04/19 22:10:42 sybalsky 4 3c AIX:  define FNDELAY = O_NONDELAY if we're compiling for AIX.es 00013/00002/00354d D 1.3 90/03/15 22:03:21 sybalsky 3 2c add copyright noticees 00004/00014/00352d D 1.2 89/12/13 10:54:01 sybalsky 2 1c cleanup string conversiones 00366/00000/00000d D 1.1 89/10/19 16:33:30 sybalsky 1 0c date and time created 89/10/19 16:33:30 by sybalskyeuUtTI 1D 2/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(envos & Fuji Xerox)";/************************************************************************//*									*//*				CHARDEVICE.C				*//*									*//*	Support for non-block UNIX devices, e.g. RS232 & pipes.		*//*									*//*									*//*									*//*									*//************************************************************************/E 2I 2D 3/* This is G-file @(#) dsk.c Version 2.40 (4/4/89). copyright envos & Fuji Xerox  */static char *id = "@(#) dsk.c	2.40 4/4/89		(envos & Fuji Xerox)";E 3I 3/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";/************************************************************************//*									*/D 9/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 9I 9/*	Copyright 1989, 1990, 1991 Venue.  All Rights Reserved.		*/E 9/*									*/D 9/*	This file is work-product resulting from the Xerox/Venue	*/E 9I 9/*	This file was work-product resulting from the Xerox/Venue	*/E 9/*	Agreement dated 18-August-1989 for support of Medley.		*/I 9/*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************//************************************************************************//*									*//*	      C H A R A C T E R - D E V I C E   S U P P O R T		*//*									*//*									*/E 9/*									*//************************************************************************/E 3E 2#include	<stdio.h>#include	<sys/types.h>#include	<sys/file.h>#include	<sys/stat.h>#include	<sys/param.h>#include	<sys/time.h>#include	<sys/dir.h>I 8#ifndef HPUXE 8#include	<strings.h>I 8#endif HPUXE 8#include 	<setjmp.h>I 7#include	<signal.h>E 7#include	<errno.h>#include	<fcntl.h>I 10#include	<sys/ioctl.h>E 10#include	"lispemul.h"#include	"lispmap.h"#include	"address68k.h"#include	"lisptypes.h"#include	"arith.h"D 10#include	"stream.h"E 10#include	"timeout.h"#include	"localfile.h"#include	"osmessage.h"#include	"dbprint.h"I 4D 6#ifdef AIX#define FNDELAY O_NONDELAY#endifE 6I 11#ifdef ISCD 12#inlcude	<dirent.h>E 12I 12#include	<dirent.h>E 12#endifE 11E 4extern	int*	Lisp_errno;extern	int	Dummy_errno;/************************************************************************//*									*//*			  C H A R _ o p e n f i l e			*//*									*//*	Given the arg vector						*//*		args[0] Lisp string full Unix file-name to open		*//*		args[1] Access to open it for (INPUT, OUTPUT, BOTH)	*//*		args[2] a FIXP cell to hold any Unix error number	*//*									*//*	Open the file named, and return the SMALLP descriptor.  If	*//*	the open fails, return NIL, and put the Unix error number	*//*	into the FIXP cell provided, for Lisp to look at.		*//*									*//************************************************************************/CHAR_openfile(args)  register LispPTR	*args;  /* args[0]		fullname */  /* args[1]		access */  /* args[2]		errno */  {    register int	id;	/* return value  of open system call. */    register int	flags;	/* open system call's argument */    register int	rval;    register int	linkflag =0;    register int	*bufp;    struct stat	statbuf;    char	pathname[MAXPATHLEN];D 10	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));	E 10I 10#if (defined(RS6000) || defined(HPUX))    static int one=1;		/* Used in charopenfile, etc. */#endif    Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));	E 10D 2    LispStringToCString(args[0], pathname);E 2I 2    LispStringToCString(args[0], pathname, MAXPATHLEN);E 2    flags = O_NDELAY;    ERRSETJMP(NIL);/*    TIMEOUT( rval=stat(pathname, &statbuf) );    if(rval == 0){	} */    switch(args[1])      {	case	ACCESS_INPUT:			flags |= O_RDONLY;			break;	case	ACCESS_OUTPUT:			flags |= (O_WRONLY | O_CREAT);			break;	case	ACCESS_APPEND:			flags |= (O_APPEND | O_RDWR | O_CREAT);			break;	case	ACCESS_BOTH:			flags |= (O_RDWR | O_CREAT);			break;	default:			return(NIL);      }    TIMEOUT( id=open(pathname, flags) );    if(id == -1)      {	err_mess("open", errno);	*Lisp_errno = errno;	return(NIL);      }    /* Prevent I/O requests from blocking -- make them error */    /* if no char is available, or there's no room in pipe.  */I 10#ifdef RS6000    ioctl(id, FIONBIO, &one);    fcntl(id, F_SETOWN, getpid());#else#ifdef HPUX    ioctl(id, FIOSNBIO, &one);#elseE 10D 2    rval = fcntl(id, F_GETFL);E 2I 2    rval = fcntl(id, F_GETFL, 0);E 2    rval |= FNDELAY;    rval = fcntl(id, F_SETFL, rval);I 10#endif HPUX#endif RS6000E 10    return(GetSmallp(id));  }/************************************************************************//*									*//*			C H A R _ c l o s e f i l e			*//*									*//*	Given the arg vector:						*//*		args[0] The SMALLP file descriptor as returned by OPEN	*//*		args[1] a FIXP cell to hold any Unix error number	*//*									*//*	Close the file identified by the descriptor.  If the 		*//*	close succeeds, return T.  Otherwise, return NIL, and put	*//*	the Unix error number in the FIXP cell, for Lisp to see.	*//*									*//************************************************************************/CHAR_closefile(args)  register LispPTR	*args;  /* args[0]		id	*/  /* args[1]		errno	*/  {    register int	id;	/* FileID */    register int	rval;    char	pathname[MAXPATHLEN];    Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));	    id = LispNumToCInt(args[0]);    ERRSETJMP(NIL);    TIMEOUT( rval=close(id) );    if( rval == -1)      {	/** This if is a patch for an apparent problem **/	/** in SunOS 4 that causes a close on /dev/ttya **/	/** to error with 'not owner' **/	if (errno == 1)	  {	    DBPRINT(("Got errno 1 on a CLOSE!"));	    return(ATOM_T);	  }	DBPRINT(("Closing char device descriptor #%d.\n", id));	err_mess("close", errno);	*Lisp_errno = errno;	return(NIL);      }    return(ATOM_T);  }/************************************************************************//*									*//*			    C H A R _ i o c t l				*//*									*//*	Given the arg vector:						*//*		args[0] the file descriptor to be acted on.		*//*		args[1] the IOCTL request code.				*//*		args[2] auxiliary data structure passed to IOCTL	*//*		args[3] a FIXP cell to contain any Unix error number	*//*									*//*	Perform the IOCTL system call on the given file descriptor,	*//*	passing in the request code and auxiliary structure given.	*//*	If the IOCTL succeeds, return T (and the aux structure may	*//*	be side-effected).  Otherwise, return NIL, and put the Unix	*//*	error number in the FIXP cell for Lisp to look at.		*//*									*//************************************************************************/CHAR_ioctl(args)  LispPTR *args;  {    int id, request, data;    register int	rval;    char	*base;    struct stat sbuf;    Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	    id = LispNumToCInt(args[0]);    request = LispNumToCInt(args[1]);    data = (int)(Addr68k_from_LADDR(args[2]));	    ERRSETJMP(NIL);    TIMEOUT(rval=ioctl(id, request, data));    if(rval != 0)      {	err_mess("ioctl", errno);	*Lisp_errno = errno;	return(NIL);      }    return(ATOM_T);}/************************************************************************//*									*//*			   C H A R _ b i n				*//*									*//*	Reads one character from the character file descriptor		*//*	id, and returns the value.  If no character is available,	*//*	or an error happens, returns NIL and sets the errno FIXP	*//*	cell to the Unix error number.					*//*									*//************************************************************************/CHAR_bin(id, errn)  register int	id;  register LispPTR	errn;  {    register int	rval, size;    unsigned char ch[4];    Lisp_errno = (int *)(Addr68k_from_LADDR(errn));    ERRSETJMP(NIL);    id = LispNumToCInt(id);    /* Read PAGE_SIZE bytes file contents from filepointer. */    TIMEOUT( rval=read(id, ch, 1) );    if ( rval == 0 )      {	*Lisp_errno = EWOULDBLOCK;	return(NIL);      }    if ( rval == -1 )      {	*Lisp_errno = errno;	return(NIL);      }    return(GetSmallp(ch[0]));  }/************************************************************************//*									*//*			    C H A R _ b o u t				*//*									*//*	Write character ch to the character file descriptor id.  If	*//*	the write works, return T; else return NIL and sets the FIXP	*//*	cell at errno to contain the Unix error number.			*//*									*//************************************************************************/CHAR_bout(id, ch, errn)  register int	id;  register LispPTR	ch, errn;  {    register int	rval;    char buf[4];    Lisp_errno = (int *)(Addr68k_from_LADDR(errn));    ERRSETJMP(NIL);    id = LispNumToCInt(id);    buf[0] = LispNumToCInt(ch);D 7    /* Read PAGE_SIZE bytes file contents from filepointer. */E 7I 7    /* Write PAGE_SIZE bytes file contents from filepointer. */E 7    TIMEOUT( rval=write(id, buf, 1) );I 7E 7    if (rval == -1)      {	*Lisp_errno = errno;	return(NIL);      }    if (rval == 0)      {	*Lisp_errno = EWOULDBLOCK;	return(NIL);      }    return(ATOM_T);  }/************************************************************************//*									*//*			   C H A R _ b i n s				*//*									*//*	Given the argument vector:					*//*	args[0] the file id to read bytes from				*//*	args[1] the base address of the buffer to read into		*//*	args[2] starting offset within the buffer to put bytes at	*//*	args[3] the number of bytes desired to read, maximum		*//*	args[4] a FIXP cell to hold the errno, if an error occurs	*//*									*//*	Read up to the specified number of bytes into the buffer,	*//*	starting at the offset given.  Return the number of bytes	*//*	actually read; will return if fewer bytes than desired are	*//*	read.  If an error occurs in reading, return NIL, and put	*//*	the Unix errno into the FIXP cell given.  EWOULDBLOCK is an	*//*	error that can occur--and bins returns NIL, so Lisp code has	*//*	to handle that case itself.					*//*									*//************************************************************************/CHAR_bins(args)  register LispPTR	*args;  {    register int	id, rval;    char	*buffer;    int offset, nbytes;    Lisp_errno = (int *)(Addr68k_from_LADDR(args[4]));    ERRSETJMP(NIL);    id = LispNumToCInt(args[0]);    buffer = ((char *) (Addr68k_from_LADDR(args[1]))) + LispNumToCInt(args[2]);    nbytes = LispNumToCInt(args[3]);    /* Read PAGE_SIZE bytes file contents from filepointer. */    TIMEOUT( rval=read(id, buffer, nbytes) );    if ( rval == 0 )      {	*Lisp_errno = EWOULDBLOCK;	return(NIL);      }    if ( rval == -1 )      {	*Lisp_errno = errno;	return(NIL);      }I 7#ifdef BYTESWAP    word_swap_page(buffer, (nbytes+3)>>2);#endif BYTESWAPE 7    return(GetSmallp(rval));  }/************************************************************************//*									*//*			   C H A R _ b o u t s				*//*									*//*	Given the argument vector:					*//*	args[0] the file id to write bytes to				*//*	args[1] the base address of the buffer to write from		*//*	args[2] starting offset within the buffer to gt bytes from	*//*	args[3] the number of bytes desired to write, maximum		*//*	args[4] a FIXP cell to hold the errno, if an error occurs	*//*									*//*	write up to the specified number of bytes from the buffer,	*//*	starting at the offset given.  Return the number of bytes	*//*	actually written; will return if fewer bytes than desired are	*//*	written.  If an error occurs in writing, return NIL, and put	*//*	the Unix errno into the FIXP cell given.  EWOULDBLOCK is an	*//*	error that can occur--and bins returns NIL, so Lisp code has	*//*	to handle that case itself.					*//*									*//************************************************************************/CHAR_bouts(args)  register LispPTR	*args;  {    register int	id, rval;    char *buffer;    int nbytes, offset;    Lisp_errno = (int *)(Addr68k_from_LADDR(args[4]));    ERRSETJMP(NIL);    id = LispNumToCInt(args[0]);    buffer = ((char *)(Addr68k_from_LADDR(args[1]))) + LispNumToCInt(args[2]);    nbytes = LispNumToCInt(args[3]);D 7    /* Read PAGE_SIZE bytes file contents from filepointer. */E 7I 7    /* Write PAGE_SIZE bytes file contents from filepointer. */#ifdef BYTESWAP    word_swap_page(buffer, (nbytes+3)>>2);#endif BYTESWAPE 7    TIMEOUT( rval=write(id, buffer, nbytes) );I 7#ifdef BYTESWAP    word_swap_page(buffer, (nbytes+3)>>2);#endif BYTESWAPE 7    if (rval == -1)      {	*Lisp_errno = errno;	return(NIL);      }    if (rval == 0)      {	*Lisp_errno = EWOULDBLOCK;	return(NIL);      }    return(GetSmallp(rval));  }E 1