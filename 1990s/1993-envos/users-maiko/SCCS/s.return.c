h58114s 00005/00005/00168d D 2.8 92/04/21 17:22:41 sybalsky 16 15c shortening file names for DOS \nes 00000/00000/00173d D 2.7 90/04/20 01:51:42 sybalsky 15 14c AIX:  shortening file names, bulk change.es 00000/00000/00173d D 2.6 89/03/30 11:03:57 sybalsky 14 13c STKWORD.es 00004/00004/00169d D 2.5 89/03/23 12:55:23 sybalsky 13 12c Fixed word-pointer refs to use GETWORD, for 386es 00001/00002/00172d D 2.4 88/10/10 14:09:40 krivacic 12 11c sun3/4 mergees 00006/00230/00168d D 2.3 88/05/31 20:11:44 masinter 11 10c eliminate unused OP_return, incall bit code es 00009/00012/00389d D 2.2 88/05/24 14:18:10 shimizu 10 9c Change Intrdisable settinges 00000/00000/00401d D 2.1 88/05/17 09:26:20 hayata 9 8c Version up to 2.1es 00002/00002/00399d D 1.8 88/05/13 10:11:52 hayata 8 7c Add SCCS keyides 00001/00026/00400d D 1.7 88/05/11 12:11:43 shimizu 7 6c refinement for return.hes 00016/00025/00410d D 1.6 88/05/11 10:51:15 shimizu 6 5c Direct Call I/F for slowreturn-casees 00013/00027/00422d D 1.5 88/04/13 12:34:01 shimizu 5 4c remove commentses 00006/00006/00443d D 1.4 88/04/01 14:43:34 shimizu 4 3c Don't set incall flg for FAULTFXPes 00002/00002/00447d D 1.3 88/03/13 14:55:31 hayata 3 2c Add SCCS key id (%Z%)es 00060/00047/00389d D 1.2 88/03/03 11:38:03 krivacic 2 1c Removed global CurrentFX to use CURRENTFX = PVAR - FRAMESIZEes 00436/00000/00000d D 1.1 88/02/24 16:58:12 hayata 1 0c date and time created 88/02/24 16:58:12 by hayataeuUtTI 1D 3/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 3I 3D 4/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 4I 4D 8/* This is G-file @(#) return.c Version 1.3 (3/13/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) return.c	1.3 3/13/88";E 8I 8/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 8E 4E 3/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 11 *	Auther :  Takeshi ShimizuE 11I 11 *	Author :  Takeshi ShimizuE 11 * *//***********************************************************//*		File Name :	return.cD 11		Including	:	OP_return					OP_contextswE 11I 11		Including	:	OP_contextswE 11					contextsw		Created	:	May 1, 1987 Takeshi Shimizu		Changed :	May 19 1987 take				Aug 27 1987 NMitani				Sep.02 1987 take				Sep.09 1987 take				Oct.23 1987 Take*//***********************************************************/#include "lispemul.h"#include "address.h"D 16#include "address68k.h"#include "lisptypes.h"E 16I 16#include "adr68k.h"#include "lsptypes.h"E 16#include "lispmap.h"#include "stack.h"D 16#include "emulglobal.h"#include "lispglobal.h"#include "initatoms.h"E 16I 16#include "emlglob.h"#include "lspglob.h"#include "initatms.h"E 16#include "cell.h"I 7#include "return.h"E 7D 2#define FastRetCALL {	/* Get IVar from Retunee's IVAR offset slot(BF) */ \	IVar = Addr68k_from_LADDR(STK_OFFSET | *((DLword *)CurrentFX -1)) ; \	/* Get FuncObj from Retunee's FNHEAD slot in FX */ \	FuncObj = (struct fnhead *)Addr68k_from_LADDR((CurrentFX->hi2fnheader <<16) | CurrentFX->lofnheader) ; \	/* Get PC from Retunee's pc slot in FX */ \	PC = (ByteCode *)FuncObj + CurrentFX->pc ; }E 2D 11D 2#define Midpunt(fxnum) { DLword midpunt; \midpunt = LOLOC(LADDR_from_68k(CurrentFX));\CurrentFX=(struct frameex1 *)Addr68k_from_LADDR(STK_OFFSET | (*(((DLword *)InterfacePage) +fxnum))) ; \*(((DLword *)InterfacePage) +fxnum) = midpunt ;}E 2I 2D 7#define FastRetCALL {							\	/* Get IVar from Retunee's IVAR offset slot(BF) */ 		\	IVar = Addr68k_from_LADDR(STK_OFFSET | *((DLword *)CURRENTFX -1)); \	/* Get FuncObj from Retunee's FNHEAD slot in FX */ 		\	FuncObj = (struct fnhead *)Addr68k_from_LADDR((CURRENTFX->hi2fnheader <<16) | CURRENTFX->lofnheader);						\	/* Get PC from Retunee's pc slot in FX */ 			\	PC = (ByteCode *)FuncObj + CURRENTFX->pc ; }E 2D 2#define CHECKFX	if (((int)PVar -(int)CurrentFX) != 20) \		{ printf("Invalid FX(0x%x) and PV(0x%x) \n",LADDR_from_68k(CurrentFX),LADDR_from_68k(PVar));}E 2I 2#define Midpunt(fxnum) 							\	{register DLword midpunt; 					\	midpunt = LOLOC(LADDR_from_68k(CURRENTFX));			\	PVar=(DLword *)							\		Addr68k_from_LADDR(					\			STK_OFFSET | 					\			(*(((DLword *)InterfacePage) +fxnum)))		\		+ FRAMESIZE; 						\	*(((DLword *)InterfacePage) +fxnum) = midpunt ;}#define CHECKFX							\	if (((int)PVar -(int)CURRENTFX) != 20)			\		{ printf("Invalid FX(0x%x) and PV(0x%x) \n",LADDR_from_68k(CURRENTFX),LADDR_from_68k(PVar));}E 2#define LOOPCNT 4000E 7E 11/***********************************************************************//*D 11		Func Name :	OP_return		Created	:	May 1, 1987 Takeshi Shimizu		changed 	3 Jul 87  take				23 Oct 87 Take		Desc	:	Execute return operations on Lisp Stack .*//***********************************************************************/OP_return(){ register struct frameex1 *returnFX ; /* retunee's FX got from returner's ALINK */ register DLword *next68k ; /* Keep Cache address of returnFX->nextblock */ register Bframe *dummyBF ; /* BF address got from returner's FX */D 2 register Bframe *currentBF ; /* BF address got from CurrentFX->blink */E 2I 2 register Bframe *currentBF ; /* BF address got from CURRENTFX->blink */E 2 register DLword *freeptr ; /* point to STK to be FSB */#ifdef LISPTRACE struct fnhead *fnobj; /* trace aid */	fnobj = FuncObj;	printPC();#endifD 2 if( CurrentFX->alink & 1)E 2I 2D 6 if( CURRENTFX->alink & 1)E 6I 6#ifdef NO_C_HARDRET/* ORIGINAL SLOWCASE */ if( SLOWP(CURRENTFX))E 6E 2  {D 6#ifdef TRACE	printf("SLOW case\n");#endifE 6D 2	/* Get retunee's FX from CurrentFX->alink , It's SLOWP case */	returnFX= (struct frameex1 *)Addr68k_from_LADDR(STK_OFFSET|CurrentFX->alink-11);E 2I 2	/* Get retunee's FX from CURRENTFX->alink , It's SLOWP case */	returnFX= (struct frameex1 *)		Addr68k_from_LADDR(STK_OFFSET|CURRENTFX->alink-11);E 2D 2	if (((CurrentFX->alink & 0xFFFE) != CurrentFX->clink)||(returnFX->usecount !=0))E 2I 2	if (((CURRENTFX->alink & 0xFFFE) != CURRENTFX->clink)||(returnFX->usecount !=0))E 2	 {D 6#ifdef DEBUG		printf("OP_return:UFN case 1 \n");#endifE 6		ufn(020) ;#ifdef LISPTRACE		printf("TRACE: return from ");		print_atomname(fnobj->framename);		printf(":<= ");		print(TopOfStack);		printf("\n");#endif		return ; /* exit OPreturn */	 }	next68k = Addr68k_from_LADDR(STK_OFFSET| returnFX->nextblock) ;D 2	currentBF = (Bframe *)Addr68k_from_LADDR(STK_OFFSET|CurrentFX->blink);E 2I 2	currentBF = (Bframe *)Addr68k_from_LADDR(STK_OFFSET|CURRENTFX->blink);E 2	if((*next68k != STK_FSB_WORD) && ((next68k != IVar) || (currentBF->usecnt != 0)))	 {D 6#ifdef DEBUG		printf("OP_return:UFN case 2 \n");#endifE 6		ufn(020);#ifdef LISPTRACE		printf("TRACE: return from ");		print_atomname(fnobj->framename);		printf(": <= "); print(TopOfStack); printf("\n");#endif		return;	 }D 2	freeptr = ((DLword *)CurrentFX)-2 ;E 2I 2	freeptr = ((DLword *)CURRENTFX)-2 ;E 2	if( ((Bframe *)freeptr)->residual)	 {D 6#ifdef DEBUG		printf("OP_return:Residual case 2 \n");#endifE 6		if(currentBF->usecnt == 0)		 {			/* make FREEBLOCK for real BF */			*IVar = STK_FSB_WORD;			*(IVar +1) =(((int)currentBF - (int)IVar)>>1 )+2 ;		 }		else			currentBF->usecnt --;	 }	 else		freeptr = IVar ; /* reset free ptr: not residual case */	/* free FX + BF(dummy or real) */	*freeptr = STK_FSB_WORD;	*(freeptr +1)= ((int)EndSTKP - (int)freeptr)>>1 ;D 5#ifdef DEBUGE 5I 5#ifdef STACKCHECKE 5	if(EndSTKP < freeptr) error("return:Illegal ESP");#endifD 2	CurrentFX=returnFX;  /* Now right CurrentFX is set */E 2I 2	PVar=((DLword *)returnFX) + FRAMESIZE ;	/* CURRENTFX=returnFX;   Now right CURRENTFX is set */E 2 RTN2:	if (*next68k != STK_FSB_WORD)		error("OP_return: MP9316");	freeptr = next68k ;	while(*freeptr==STK_FSB_WORD)	 EndSTKP = freeptr = freeptr + *(freeptr+1);	StkLimO = EndSTKP- STKLIMOFFSET ;	if(next68k >= StkLimO)	 {#ifdef DEBUG		printf("OP_return: MIDPUNT case!!!!\n");#endif		Midpunt(SubovFXP) ; /* cause contextsw to stack overflow process */D 2		next68k = Addr68k_from_LADDR(STK_OFFSET| CurrentFX->nextblock) ;E 2I 2		next68k = Addr68k_from_LADDR(STK_OFFSET| CURRENTFX->nextblock);E 2		goto RTN2 ;	}D 2	PVar=((DLword *)CurrentFX) + FRAMESIZE ;	if(CurrentFX->incall)E 2I 2	if(CURRENTFX->incall)E 2	 {  /* this frame is  Interrupted */D 5#ifdef DEBUG		printf("OP_return: INCALL case !!!\n");E 5I 5#ifdef STACKCHECK		/*printf("OP_return: INCALL case !!!\n");*/E 5		CHECKFX;#endifD 2		CurrentFX->incall=NIL;E 2I 2		CURRENTFX->incall=NIL;E 2		CurrentStackPTR = next68k -2 ;		TopOfStack = *((LispPTR *)CurrentStackPTR) ;		CurrentStackPTR-=2;D 2		FuncObj = (struct fnhead *)(Addr68k_from_LADDR		((CurrentFX->hi2fnheader << 16)| CurrentFX->lofnheader));E 2I 2		FuncObj = (struct fnhead *)			Addr68k_from_LADDR(				(CURRENTFX->hi2fnheader << 16) | 				CURRENTFX->lofnheader);E 2D 2		PC = (ByteCode *)(((DLword *)FuncObj) + CurrentFX->pc );E 2I 2		PC = (ByteCode *)(((DLword *)FuncObj) + CURRENTFX->pc );E 2		OP_apply();  /* CALL Func again */#ifdef LISPTRACE		printf("TRACE: return from ");		print_atomname(fnobj->framename);		printf(" :<= ");print(TopOfStack);printf("\n");#endif		return;	 }	else 	 	 {D 2		if (CurrentFX->nopush)E 2I 2		if (CURRENTFX->nopush)E 2		 {D 2			CurrentFX->nopush =NIL;E 2I 2			CURRENTFX->nopush =NIL;E 2			CurrentStackPTR = next68k-2 ;			TopOfStack = *((LispPTR *)CurrentStackPTR) ;			CurrentStackPTR-=2;		 }		elseD 6		 	CurrentStackPTR = next68k-2 /*-1*/ ; /* Changed by Hayata */E 6I 6		 	CurrentStackPTR = next68k-2 ; E 6D 5#ifdef DEBUGE 5I 5#ifdef STACKCHECKE 5		CHECKFX;		if(EndSTKP < freeptr) error("return:Illegal ESP");#endif		FastRetCALL#ifdef LISPTRACE		printf("TRACE: return from ");		print(fnobj->framename);		printf(" :<= ");		print(TopOfStack);printf("\n");#endif		return;	 }I 6  } /* SlowRet case end */#else/* else for NO_C_HARDRET */ if( SLOWP(CURRENTFX))  {E 6I 6	/* call c-hardreturn */	slowreturn();	return;  }E 6D 6  } /* SlowRet case end */  else  { /* FastRet CASE #ifdef TRACE	printf("FAST case\n");E 6#endifD 6***************************/E 6I 6/* ENDIF for NO_C_HARDRET */  else  { /* FastRet CASE */E 6	/* Returnee's Stack(PV area) exists just before Retuner's BF */	CurrentStackPTR = IVar-2 /*-1*/ ;	/* Get PVar from ALINK */D 2	PVar= Addr68k_from_LADDR((STK_OFFSET | CurrentFX->alink));	/* Move CurrentFX ptr */ 	CurrentFX=(struct  frameex1 *)(PVar - FRAMESIZE) ; E 2I 2	PVar= Addr68k_from_LADDR(STK_OFFSET | CURRENTFX->alink);E 2D 6#ifdef DEBUG		CHECKFX;#endifE 6	FastRetCALL ;#ifdef LISPTRACE		printf("Freturn from ");		print_atomname(fnobj->framename);		printf(":<= ");		print(TopOfStack);		printf("\n");#endif	return;  } /* FastRet Case end */} /* OP_return() end *//***********************************************************************//*E 11		Func Name :	OP_contextsw		Created	:	Jul 3, 1987 Takeshi Shimizu		changed 	AUG 25 1987 TAKE				aug 31 take				Aug 4  1987 NMitani				Oct 23 1987 Take				Nov 05 1987 Take(modify flags,del. whocalls					and incall args)		Desc	:	Execute ContextSW to FX specified as 				offset from IFPGE by TOS .*//***********************************************************************/OP_contextsw(){#ifdef TRACE	printf("OP_contextsw:\n");#endif  contextsw(TopOfStack & 0xffff,1,2);  /* TOS will be smashed ?? I'm not sure .	PC will be incremented 1. */} /* OP_contextsw */contextsw(fxnum,bytenum,flags) register DLword fxnum; register DLword bytenum; /* BYTEnum that you want increment PC 				after CONTEXTSW */ register DLword flags;  /* 0bit(MSB) ON: incall mode */			 /* 1bit ON : call from OP_contextsw */			 /* I don't know that it is the possible case that 				flags is 3 . */ { register DLword *next68k; register DLword *freeptr ; /* point to STK to be FSB */D 5#ifndef EXPextern int Intrdisable;#endifE 5I 5D 12 extern int Intrdisable;E 12E 5#ifdef TRACE 	printf("contextsw : %d \n",fxnum);#endifI 12E 12I 10 if(!(fxnum==SubovFXP)) {D 12 	Intrdisable = ! Intrdisable; 	E 12			/* interrupt disable during execting [special] function			  invoked by contextsw(\KEYHANDLER,\RESETSTACK,FAULT)			 */ }E 10D 4#ifndef EXPE 4D 10 Intrdisable = ! Intrdisable; 	/* interrupt disable during execting function				 * invoked by contextsw				 */E 10D 4#endifE 4D 5  if(fxnum == FAULTFXP)D 2	CurrentFX->incall = T;E 2I 2D 4	CURRENTFX->incall = T;E 4I 4   {/*CURRENTFX->incall = T;*/	printf("FAULTFXP \n");	CURRENTFX->incall = NIL;   }E 4E 2  else if(flags & 1) /* INCALL? */E 5I 5 if(flags & 1) /* INCALL? */E 5D 2	CurrentFX->incall = T;E 2I 2D 11	CURRENTFX->incall = T;E 11I 11	error("contextswitch sets Incall");E 11E 2D 5	elseE 5I 5 elseE 5D 2	CurrentFX->nopush = T;E 2I 2	CURRENTFX->nopush = T;E 2  /* store PC */D 2  CurrentFX->pc = (int)PC - (int)FuncObj + bytenum;E 2I 2  CURRENTFX->pc = (int)PC - (int)FuncObj + bytenum;E 2 /* TOS save */ if(flags & 2){D 10  	/** *(++CurrentStackPTR)=0;  	*(++CurrentStackPTR)=fxnum; **/	PushStack(fxnum);E 10I 10  	PushStack(fxnum);E 10 	CurrentStackPTR += 2;  }  else{D 10  	/** *(LispPTR *)(++CurrentStackPTR) = TopOfStack; **/E 10	PushCStack; 	CurrentStackPTR += 2;  }D 2  CurrentFX->nextblock=LOLOC(LADDR_from_68k(CurrentStackPTR));E 2I 2  CURRENTFX->nextblock=LOLOC(LADDR_from_68k(CurrentStackPTR));E 2  /* FSB set */D 13  *(CurrentStackPTR)=STK_FSB_WORD;D 11  *(CurrentStackPTR+1)= (((int)StkLimO-(int)CurrentStackPTR)>>1) + STKLIMOFFSET ;E 11I 11  *(CurrentStackPTR+1)= (((int)EndSTKP-(int)CurrentStackPTR)>>1);E 13I 13  GETWORD(CurrentStackPTR)=STK_FSB_WORD;  GETWORD(CurrentStackPTR+1)= (((int)EndSTKP-(int)CurrentStackPTR)>>1);E 13E 11D 5#ifdef DEBUGE 5I 5#ifdef STACKCHECKE 5	if(EndSTKP < CurrentStackPTR) error("contextsw:Illegal ESP");D 5	if(fxnum==2) printf("contextsw: FSB size 0x%x \n",*(CurrentStackPTR+1));E 5#endif  Midpunt(fxnum); /* exchanging FX */RTNX :D 2  next68k = (DLword *)Addr68k_from_LADDR(STK_OFFSET | CurrentFX->nextblock);E 2I 2  next68k = (DLword *)Addr68k_from_LADDR(STK_OFFSET | CURRENTFX->nextblock);E 2D 13  if(*next68k != STK_FSB_WORD) error("contextsw(): MP9316");E 13I 13  if(GETWORD(next68k) != STK_FSB_WORD) error("contextsw(): MP9316");E 13   freeptr=next68k;/* Merging FSB area */D 13  while(*freeptr == STK_FSB_WORD)  EndSTKP=freeptr=freeptr+  *(freeptr+1);E 13I 13  while(GETWORD(freeptr) == STK_FSB_WORD)  EndSTKP=freeptr=freeptr+  GETWORD(freeptr+1);E 13D 11/* Set current Stack Limit */  StkLimO = EndSTKP - STKLIMOFFSET ;E 11#ifdef DEBUG  printf("contextsw:ESTKP set ");  laddr(EndSTKP);#endifD 11  if( next68k >= StkLimO )    {	error("STK overflow in contextsw\n");D 10	Midpunt(SubovFXP); /* contextsw */ 	goto RTNX ;E 10I 10	/* Midpunt(SubovFXP);  contextsw */ 	/* goto RTNX ; */E 10   }D 2  PVar = ((DLword *)CurrentFX) + FRAMESIZE ;E 2E 11D 2	if(CurrentFX->incall)E 2I 2	if(CURRENTFX->incall)E 2D 11	 {  /* this frame is  Interrupted */D 2		CurrentFX->incall=NIL;E 2I 2		CURRENTFX->incall=NIL;E 2		CurrentStackPTR =(DLword *)next68k -2 ;		TopOfStack = *((LispPTR *)CurrentStackPTR) ;		CurrentStackPTR-=2;D 2		FuncObj = (struct fnhead *)(Addr68k_from_LADDR		((CurrentFX->hi2fnheader << 16)| CurrentFX->lofnheader));E 2I 2		FuncObj = (struct fnhead *)			Addr68k_from_LADDR(				(CURRENTFX->hi2fnheader << 16) | 				CURRENTFX->lofnheader);E 2D 2		 PC = (ByteCode *)(((ByteCode *)FuncObj) + CurrentFX->pc );E 2I 2		 PC = (ByteCode *)(((ByteCode *)FuncObj) + CURRENTFX->pc );E 2D 5#ifdef DEBUGE 5I 5#ifdef STACKCHECKE 5		CHECKFX;D 5		if(TopOfStack==2) error("STOP in context");		else printf("context:INCALL apply :");print(TopOfStack);E 5I 5D 10		/*if(TopOfStack==2) error("STOP in context");		else printf("context:INCALL apply :");print(TopOfStack);*/E 10E 5#endifD 5		/* modified kludge by NMitani */		if(fxnum != FAULTFXP){			OP_apply();		}		/* OP_apply(); */E 5I 5		OP_apply();E 5		return;E 11I 11	 {    error("return to frame with incall bit ");E 11	 }	else 	 	 {D 2		if (CurrentFX->nopush)E 2I 2		if (CURRENTFX->nopush)E 2		 {#ifdef DEBUG			printf("context:after:nopush \n");#endifD 2			CurrentFX->nopush =NIL;E 2I 2			CURRENTFX->nopush =NIL;E 2			CurrentStackPTR = next68k-2 ;			TopOfStack = *((LispPTR *)CurrentStackPTR) ;			CurrentStackPTR-=2;		 }		else		 {#ifdef DEBUG			printf("context:after:3 \n");#endif		 	CurrentStackPTR = next68k-2 /*-1*/ ; /* CHanged by Hayata */		 }D 5#ifdef DEBUGE 5I 5#ifdef STACKCHECKE 5		CHECKFX;		if( EndSTKP< CurrentStackPTR) 			error("contextsw:Illegal ESP");#endif		FastRetCALL		return;	 }} /* end contextsw */I 11E 11E 1