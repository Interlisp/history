h59283s 00004/00004/00100d D 2.10 92/04/21 17:23:45 sybalsky 17 16c shortening file names for DOS \nes 00000/00000/00104d D 2.9 90/04/20 01:52:58 sybalsky 16 15c AIX:  shortening file names, bulk change.es 00001/00001/00103d D 2.8 90/03/05 14:58:19 takeshi 15 14c commented out obsoleted vares 00000/00000/00104d D 2.7 89/02/14 13:42:29 snow 14 13c no changeses 00004/00001/00100d D 2.6 89/01/27 17:37:13 snow 13 12c Took out bogus punt case on RSH when you shifted 1 bits out the edge.es 00005/00005/00096d D 2.5 89/01/09 17:18:21 shih 12 11c spellinges 00014/00272/00087d D 2.4 88/10/12 14:44:56 krivacic 11 10c new out-of-line interfacees 00005/00003/00354d D 2.3 88/06/17 12:13:53 krivacic 10 9c fix ASH error (didn't punt right)es 00005/00000/00352d D 2.2 88/05/27 14:58:47 krivacic 9 8c C_ONLY ifdefes 00000/00000/00352d D 2.1 88/05/17 09:26:36 hayata 8 7c Version up to 2.1es 00000/00000/00352d D 1.7 88/05/05 20:01:06 shih 7 6c no changeses 00012/00004/00340d D 1.6 88/05/05 14:06:33 krivacic 6 5c lsh fixes 00004/00004/00340d D 1.5 88/05/04 15:11:50 krivacic 5 4c fix shift bugses 00002/00002/00342d D 1.4 88/03/13 15:06:30 hayata 4 3c Add SCCS key id (%Z%)es 00000/00000/00344d D 1.3 88/03/11 18:07:17 krivacic 3 2c Native Interfaceses 00095/00000/00249d D 1.2 88/03/09 15:45:46 krivacic 2 1c Native Fn interface rtnses 00249/00000/00000d D 1.1 88/02/24 16:58:22 hayata 1 0c date and time created 88/02/24 16:58:22 by hayataeuUtTI 1D 4/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 4I 4D 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 12I 12/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 12static char *id = "%Z% %M%	%I% %G%";E 4/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *D 12 *	Auther :  Hiroshi HayataE 12I 12 *	Author :  Hiroshi HayataE 12 * */#include <stdio.h>#include "lispemul.h"D 17#include "lispglobal.h"#include "emulglobal.h"#include "address68k.h"E 17I 17#include "lspglob.h"#include "emlglob.h"#include "adr68k.h"E 17#include "lispmap.h"D 17#include "lisptypes.h"E 17I 17#include "lsptypes.h"E 17#include "arith.h"#define	LSH	0347DLword	*createcell68k();I 9D 11#ifdef C_ONLYE 11E 9/************************************************************D 11OP_llsh1	entry		LLSH1		OPCODE[0340]	1.	<<Entrer>>		TopOfStack			: argument of LLSH		They are SMALLPL or SMALLNEG, Lisp address.	2.	shift argument.	3.	<<Exit>>		TopOfStack			: shifted value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_llsh1(){register int	arg;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_llsh1()\n");#endif	GetNumber( TopOfStack, arg );	arg <<= 1;	switch(arg & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg);			break;		default:			/* arg is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg;			TopOfStack = LADDR_from_68k(wordp);			break;	}	++PC;}/************************************************************OP_llsh8	entry		LLSH8		OPCODE[0341]	1.	<<Entrer>>		TopOfStack			: argument of LLSH		They are SMALLPL or SMALLNEG, Lisp address.	2.	shift argument.	3.	<<Exit>>		TopOfStack			: shifted value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_llsh8(){register int	arg;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_llsh8()\n");#endif	GetNumber( TopOfStack, arg );	arg <<= 8;	switch(arg & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg);			break;		default:			/* arg is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg;			TopOfStack = LADDR_from_68k(wordp);			break;	}	++PC;}/************************************************************OP_lrsh1	entry		LRSH1		OPCODE[0342]	1.	<<Entrer>>		TopOfStack			: argument of LRSH		They are SMALLPL or SMALLNEG, Lisp address.	2.	shift argument.	3.	<<Exit>>		TopOfStack			: shifted value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_lrsh1(){register int	arg;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_lrsh1()\n");#endif	GetNumber( TopOfStack, arg );	arg >>= 1;	switch(arg & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg);			break;		default:			/* arg is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg;			TopOfStack = LADDR_from_68k(wordp);			break;	}	++PC;}/************************************************************OP_lrsh8	entry		LRSH8		OPCODE[0343]	1.	<<Entrer>>		TopOfStack			: argument of LRSH		They are SMALLPL or SMALLNEG, Lisp address.	2.	shift argument.	3.	<<Exit>>		TopOfStack			: shifted value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_lrsh8(){register int	arg;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_lrsh8()\n");#endif	GetNumber( TopOfStack, arg );	arg >>= 8;	switch(arg & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg);			break;		default:			/* arg is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg;			TopOfStack = LADDR_from_68k(wordp);			break;	}	++PC;}/************************************************************OP_lsh	entry		LSH		OPCODE[0347]	1.	<<Entrer>>		TopOfStack		: shift size		Top of CurrentStack	: argument of LSH		They are SMALLPL or SMALLNEG, Lisp address.	2.	left shift argument.	3.	<<Exit>>		TopOfStack		: shifted value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_lsh(){register int	arg;register int	size;DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_lsh()\n");#endif	GetNumber( TopOfStack, size );/*CSP	GetNumber(*((int *)(CurrentStackPTR-1)), arg);	*/	GetNumber(*((int *)(CurrentStackPTR)), arg);	if((size < 0) || (size > 15)){		/**** call Lisp Func. ****/		ufn(LSH);		return;	}	arg <<= size;	switch(arg & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg);			break;		default:			/* arg is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg;			TopOfStack = LADDR_from_68k(wordp);			break;		break;	}	CurrentStackPTR -= 2;	++PC;}I 9#elseE 9I 2/************************************************************E 11N_OP_llsh1	entry		LLSH1		OPCODE[0340]	return(a << 1)************************************************************/D 11N_OP_llsh1(a, error_addr)	int a, *error_addr;E 11I 11N_OP_llsh1(a)	int a;E 11{D 11#ifdef	TRACE	printPC();	printf("TRACE: OP_llsh1()\n");#endifD 5	N_ARITH_BODY_1(a, 1, error_addr, <<);E 5I 5	N_ARITH_BODY_1_UNSIGNED(a, 1, error_addr, <<);E 11I 11	N_ARITH_BODY_1_UNSIGNED(a, 1, <<);E 11E 5}/************************************************************N_OP_llsh8	entry		LLSH8		OPCODE[0341]	return(a << 8)************************************************************/D 11N_OP_llsh8(a, error_addr)	int a, *error_addr;E 11I 11N_OP_llsh8(a)	int a;E 11{D 11#ifdef	TRACE	printPC();	printf("TRACE: OP_llsh8()\n");#endifD 5	N_ARITH_BODY_1(a, 8, error_addr, <<);E 5I 5	N_ARITH_BODY_1_UNSIGNED(a, 8, error_addr, <<);E 11I 11	N_ARITH_BODY_1_UNSIGNED(a, 8, <<);E 11E 5}/************************************************************N_OP_lrsh1	entry		LRSH1		OPCODE[0342]	return(a >> 1)************************************************************/D 11N_OP_lrsh1(a, error_addr)	int a, *error_addr;E 11I 11N_OP_lrsh1(a)E 11{D 11#ifdef	TRACE	printPC();	printf("TRACE: OP_lrsh1()\n");#endifD 5	N_ARITH_BODY_1(a, 1, error_addr, >>);E 5I 5	N_ARITH_BODY_1_UNSIGNED(a, 1, error_addr, >>);E 11I 11	N_ARITH_BODY_1_UNSIGNED(a, 1, >>);E 11E 5}/************************************************************N_OP_lrsh8	entry		LRSH8		OPCODE[0343]	return(a >> 8)************************************************************/D 11N_OP_lrsh8(a, error_addr)	int a, *error_addr;E 11I 11N_OP_lrsh8(a)	int a;E 11{D 11#ifdef	TRACE	printPC();	printf("TRACE: OP_lrsh8()\n");#endifD 5	N_ARITH_BODY_1(a, 8, error_addr, >> );E 5I 5	N_ARITH_BODY_1_UNSIGNED(a, 8, error_addr, >>);E 11I 11	N_ARITH_BODY_1_UNSIGNED(a, 8, >>);E 11E 5}/************************************************************N_OP_lsh	entry		LSH		OPCODE[0347]	return(a <?> b)************************************************************/D 11N_OP_lsh(a, b, error_addr)	int a, b, *error_addr;E 11I 11N_OP_lsh(a, b)	int a, b;E 11{D 6register int	arg;E 6I 6register int	arg,arg2;E 6register int	size;D 15DLword	*wordp;E 15I 15/*DLword	*wordp;*/E 15D 11#ifdef	TRACE	printPC();	printf("TRACE: OP_lsh()\n");#endifE 11	N_GETNUMBER(b, size, do_ufn);D 6	N_GETNUMBER(a, arg, do_ufn);E 6I 6	N_GETNUMBER(a, arg2, do_ufn);E 6D 6	if((size < 0) || (size > 15)) goto do_ufn;E 6D 10	E 10I 10E 10D 6	arg <<= size;E 6I 6	if (size > 0) {I 10		if (size > 31) goto do_ufn;E 10		arg = arg2 << size;		if ((arg >> size) != arg2) goto do_ufn;D 12	} else E 12I 12	} elseE 12	if (size < 0) {D 10		arg = arg2 >> size;		if ((arg << size) != arg2) goto do_ufn;E 10I 10		if (size < -31) goto do_ufn;		arg = arg2 >> -size;D 13		if ((arg << -size) != arg2) goto do_ufn;E 13I 13/*** Commented out JDS 1/27/89:  This punts if you shifted ***//*** ANY 1 bits off the right edge.  You CAN'T overflow    ***//*** in this direction!!                                   ***//*		if ((arg << -size) != arg2) goto do_ufn; */E 13E 10	} else return(a);D 12		E 12I 12E 12E 6	N_ARITH_SWITCH(arg);D 11do_ufn:	ERROR_EXIT(error_addr);E 11I 11do_ufn:	ERROR_EXIT(b);E 11}I 9D 11#endifE 11E 9E 2E 1