h01008s 00000/00000/01062d D 1.13 90/04/19 22:46:02 sybalsky 13 12c AIX:  OBSOLETED.  REplaced by testtool.ces 00271/00227/00791d D 1.12 90/02/21 18:32:20 sybalsky 12 11c 386i changes: uses Bframe 1-word struct, STKH 1-word struct.es 00010/00001/01008d D 1.11 90/02/06 11:44:26 sybalsky 11 10c Stack display changeses 00099/00044/00910d D 1.10 89/12/29 12:56:59 sybalsky 10 9c Changes from Savoires 00150/00094/00804d D 1.9 89/03/30 13:04:04 sybalsky 9 8c Added Trace_FNCall & Trace_APPLY functions for tracing aid.es 00029/00023/00869d D 1.8 89/03/23 12:53:59 sybalsky 8 7c Byte-orcer changes for find_atom &ces 00002/00002/00890d D 1.7 89/03/03 05:25:50 shih 7 6c declaration errores 00176/00160/00716d D 1.6 89/03/03 01:10:07 shih 6 5c added MakeAtom68k, much cleanupes 00001/00001/00875d D 1.5 88/10/18 15:00:59 krivacic 5 4c remove warning messagees 00000/00002/00876d D 1.4 88/09/27 15:42:04 krivacic 4 3c merginges 00015/00035/00863d D 1.3 88/07/11 10:45:36 masinter 3 2c check in fixed check_dtd_chain (used only when compiled with -DCHECK)es 00045/00017/00853d D 1.2 88/05/23 11:37:40 shimizu 2 1c modify all_stack_dumpes 00870/00000/00000d D 1.1 88/04/18 20:11:07 shimizu 1 0c date and time created 88/04/18 20:11:07 by shimizueuUtTI 1D 6/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 6I 6D 9/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 6D 3static char *id = "%Z% %M%	%I% %G%";E 3I 3static char *id = "%Z% %M%      %I% %G%";E 9I 9/* @(#) Ktesttool.c Version 1.8 (3/23/89). copyright envos & Fuji Xerox  */static char *id = "@(#) Ktesttool.c      1.8 3/23/89";I 10/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 10E 9E 3/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. */D 3/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. */E 3/***************************************************************//*	file name :	 Ktesttools.c	For Debugging Aids	Including :		dump_check_atoms()		print_atomname(index)		dump_dtd()		check_type_68k(type,ptr)		type_num(LISPPTR)		dump_conspage(base , linking )		trace_listpDTD()		a68k( lispptr)		laddr(addr68k)		dump_fnobj(index)		doko()		dumpl(laddr)		ptintPC()D 6		all_stack_dump(start,end)  E 6I 6		all_stack_dump(start,end)E 6		date :   14 May 1987   takeshi			 15 May 1987 take			 1  June 1987 take			 21  June 1987 NMitani			  9  Sep. 1987 take*/D 2E 2I 2#include <stdio.h>E 2#include "lispemul.h"#include "lispmap.h"#include "address68k.h"#include "lisptypes.h"#include "lispglobal.h"#include "emulglobal.h"#include "cell.h"#include "stack.h"#include "ifpage.h"#include "debug.h"I 8#include "dbprint.h"E 8D 4extern DLword *Lisp_world ;/* extern DLword AtomFrLst; */E 4#define URMAXFXNUM		100#define URSCAN_ALINK		0#define URSCAN_CLINK		1extern int URaid_scanlink;extern int URaid_currentFX;extern FX *URaid_FXarray[];extern int URaid_ArrMAXIndex;D 9/*************************************************************//*		Func :	print_atomnameE 9I 9/************************************************************************//*									*//*			P R I N T _ A T O M N A M E			*//*									*//*	Given the Atom # for an atom, print the atom's name.		*//*									*//************************************************************************/E 9D 9*//************************************************************/E 9print_atomname(index)D 6 DLword index ; /* atomindex */E 6I 6 DLword index; /* atomindex */E 6{D 6 char *pname ; DLword length ; PNCell *pnptr ;E 6I 6 char *pname; DLword length; PNCell *pnptr;E 6 pnptr =(PNCell *)GetPnameCell( index); print_package_name(pnptr->pkg_index); pname=(char *) Addr68k_from_LADDR(pnptr->pnamebase);D 6 length =(DLword)( *pname++ ); E 6I 6D 8 length =(DLword)( *pname++ );E 8I 8 length = (DLword) GETBYTE(pname++);E 8E 6 while(length >0){D 8			 putchar(*pname++);E 8I 8			 putchar(GETBYTE(pname++));E 8D 6			 length-- ;E 6I 6			 length--;E 6		}} /* end print_atomname */D 8/*********FOR PACKAGE**********/E 8I 8/************************************************************************//*									*//*		F I N D _ P A C K A G E _ F R O M _ N A M E		*//*									*//************************************************************************/E 8#define PACKAGES_LIMIT 255/** GET PACKAGE INDEX from PACKAGE FULL NAME */D 6find_package_from_name(packname,len) E 6I 6find_package_from_name(packname,len)E 6D 8char *packname;int len;{ int index; PACKAGE *package; NEWSTRINGP *namestring; DLword len2; char *pname;E 8I 8  char *packname;  int len;  {    int index;    PACKAGE *package;    NEWSTRINGP *namestring;    DLword len2;    char *pname;E 8D 6 for(index =1 ; index <= PACKAGES_LIMIT ; index++)E 6I 6D 8 for(index =1; index <= PACKAGES_LIMIT; index++)E 6 {E 8I 8    for(index =1; index <= PACKAGES_LIMIT; index++)      {E 8	package = (PACKAGE *)Addr68k_from_LADDR(			  aref1(*Package_from_Index_word, index));	namestring = (NEWSTRINGP*)Addr68k_from_LADDR(package->NAME);	pname = (char*)Addr68k_from_LADDR(namestring->base);	if(namestring->offset != 0)D 8	{		pname += namestring->offset;	}E 8I 8	  {	    pname += namestring->offset;	  }E 8	len2 = (DLword)(namestring->totalsize);	if(len == len2)D 8	{		if(compare_chars(packname,pname,len)==T)D 6		 {	E 6I 6		 {E 6			return(index);D 6	 	 }E 6I 6		 }E 6	}E 8I 8	  {	    if(compare_chars(pname, packname, len)==T)	      {		return(index);	      }	  }E 8 } /* for end */ return(-1);}I 9/************************************************************************//*									*//*		    P R I N T _ P A C K A G E _ N A M E			*//*									*//************************************************************************/E 9print_package_name(index)D 9int index;{   PACKAGE *package;   NEWSTRINGP *namestring;   DLword len;   char *pname;E 9I 9  int index;  {    PACKAGE *package;    NEWSTRINGP *namestring;    DLword len;    char *pname;E 9D 9	if(index == 0)	{		printf("#:");		return;	}	package = (PACKAGE *)Addr68k_from_LADDR(E 9I 9    if(index == 0)      {	printf("#:");	return;      }    package = (PACKAGE *)Addr68k_from_LADDR(E 9			  aref1(*Package_from_Index_word, index));D 9	namestring = (NEWSTRINGP*)Addr68k_from_LADDR(package->NAME);	pname = (char*)Addr68k_from_LADDR(namestring->base);	if(namestring->offset != 0) {		pname += namestring->offset;		printf("OFFSET:\n");	}	len = (DLword)(namestring->totalsize);E 9I 9    namestring = (NEWSTRINGP*)Addr68k_from_LADDR(package->NAME);    pname = (char*)Addr68k_from_LADDR(namestring->base);    if(namestring->offset != 0)      {	pname += namestring->offset;	printf("OFFSET:\n");      }    len = (DLword)(namestring->totalsize);E 9D 9	if(compare_chars(pname , "INTERLISP", len) == T)	{		printf("IL:");		return;	}	else if(compare_chars(pname , "LISP", len) == T)	{		printf("CL:");		return;	}	else if(compare_chars(pname , "XEROX-COMMON-LISP", len) == T)	{		printf("XCL:");		return;	}	else if(compare_chars(pname , "SYSTEM", len) == T)	{		printf("SI:");		return;	}	else if(compare_chars(pname , "KEYWORD", len) == T)	{		printf(":");		return;	}	else if(compare_chars(pname , "COMPILER", len) == T)	{		printf("XCLC:");		return;	}	else	{		while(len >0){D 8			 putchar(*pname++);E 8I 8			 putchar(GETBYTE(pname++));E 8D 6			 len-- ;E 6I 6			 len--;E 6		}		putchar(':');E 9I 9    if(compare_chars(pname , "INTERLISP", len) == T)      {	printf("IL:");	return;      }    else if(compare_chars(pname , "LISP", len) == T)     {	printf("CL:");	return;      }    else if(compare_chars(pname , "XEROX-COMMON-LISP", len) == T)      {	printf("XCL:");	return;      }    else if(compare_chars(pname , "SYSTEM", len) == T)      {	printf("SI:");	return;      }    else if(compare_chars(pname , "KEYWORD", len) == T)     {	printf(":");	return;      }    else if(compare_chars(pname , "COMPILER", len) == T)      {	printf("XCLC:");	return;      }    else      {	while(len >0)	  {	     putchar(GETBYTE(pname++));	     len--;	  }	putchar(':');	return;      }E 9D 9		return;	}E 9I 9  }  /*print_package_name */E 9D 9}/***print_package_name end */E 9D 10/*************************************************************//*		Func :	dump_dtdE 10D 10*//************************************************************/E 10I 10/************************************************************************//*									*//*				d u m p _ d t d				*//*									*//*									*//*									*//************************************************************************/E 10dump_dtd()D 10{D 6 extern DLword *DTDspace ;  struct dtd *dtdp ; DLword cnt ;E 6I 6 extern DLword *DTDspace;  struct dtd *dtdp; DLword cnt;E 10I 10  {    extern DLword *DTDspace;    struct dtd *dtdp;    DLword cnt;E 10E 6D 6 dtdp = (struct dtd *)DTDspace ;E 6I 6D 10 dtdp = (struct dtd *)DTDspace;E 6dtdp++;E 10I 10    dtdp = (struct dtd *)DTDspace;    dtdp++;E 10D 6for (cnt = 0 ; cnt < INIT_TYPENUM ; cnt ++)E 6I 6D 10for (cnt = 0; cnt < INIT_TYPENUM; cnt ++)E 6 {E 10I 10    for (cnt = 0; cnt < INIT_TYPENUM; cnt ++)       {E 10	printf("DTD[ %d ] for ",cnt+1);	print_atomname(dtdp->dtd_name);	putchar('\n');D 6	printf("    dtd_name = %d \n",dtdp->dtd_name);	printf("    dtd_size = %d \n",dtdp->dtd_size);	printf("    dtd_free = %d \n",dtdp->dtd_free);	printf("    dtd_obsolate = %d \n",dtdp->dtd_obsolate);	printf("    dtd_finalizable = %d \n",dtdp->dtd_finalizable);	printf("    dtd_lockedp = %d \n",dtdp->dtd_lockedp);	printf("    dtd_hunkp = %d \n",dtdp->dtd_hunkp);	printf("    dtd_gctype = %d \n",dtdp->dtd_gctype);	printf("    dtd_descrs = %d \n",dtdp->dtd_descrs);	printf("    dtd_typespecs = %d \n",dtdp->dtd_typespecs);	printf("    dtd_ptrs = %d \n",dtdp->dtd_ptrs);	printf("    dtd_oldcnt = %d \n",dtdp->dtd_oldcnt);	printf("    dtd_cnt0 = %d \n",dtdp->dtd_cnt0);	printf("    dtd_nextpage = %d \n",dtdp->dtd_nextpage);	printf("    dtd_typeentry = %x \n",dtdp->dtd_typeentry);	printf("    dtd_supertype = %d \n",dtdp->dtd_supertype);E 6I 6	printf("    dtd_name = %d\n",dtdp->dtd_name);	printf("    dtd_size = %d\n",dtdp->dtd_size);	printf("    dtd_free = %d\n",dtdp->dtd_free);	printf("    dtd_obsolate = %d\n",dtdp->dtd_obsolate);	printf("    dtd_finalizable = %d\n",dtdp->dtd_finalizable);	printf("    dtd_lockedp = %d\n",dtdp->dtd_lockedp);	printf("    dtd_hunkp = %d\n",dtdp->dtd_hunkp);	printf("    dtd_gctype = %d\n",dtdp->dtd_gctype);	printf("    dtd_descrs = %d\n",dtdp->dtd_descrs);	printf("    dtd_typespecs = %d\n",dtdp->dtd_typespecs);	printf("    dtd_ptrs = %d\n",dtdp->dtd_ptrs);	printf("    dtd_oldcnt = %d\n",dtdp->dtd_oldcnt);	printf("    dtd_cnt0 = %d\n",dtdp->dtd_cnt0);	printf("    dtd_nextpage = %d\n",dtdp->dtd_nextpage);	printf("    dtd_typeentry = 0x%x\n",dtdp->dtd_typeentry);	printf("    dtd_supertype = %d\n",dtdp->dtd_supertype);E 6	dtdp++;D 10  }E 10I 10      }E 10D 10} /* end dump dtd */E 10I 10  } /* end dump dtd */E 10D 10/********************************/D 6/* E 6I 6/*E 6   It prints the type number which associated by 68kptr*/E 10I 10/************************************************************************//*									*//*			c h e c k _ t y p e _ 6 8 k			*//*									*//*	Check that the lisp pointer ptr is of type type, then		*//*	print a message showing the type number.			*//*									*//************************************************************************/E 10check_type_68k(type,ptr)D 6 LispPTR *ptr ;E 6I 6 LispPTR *ptr;E 6{ if (type != (GetTypeNumber(LADDR_from_68k(ptr)) ) )  {D 6  printf("Mismatching occur !!! LispAddr 0x%x  type %d  \n",LADDR_from_68k(ptr)E 6I 6  printf("Mismatching occur !!! LispAddr 0x%x  type %d\n",LADDR_from_68k(ptr)E 6	  ,type);  exit(-1);  }D 6  printf("LispPTR 0x%x is the datatype %d \n", LADDR_from_68k(ptr)E 6I 6  printf("LispPTR 0x%x is the datatype %d\n", LADDR_from_68k(ptr)E 6      ,GetTypeNumber(LADDR_from_68k(ptr)) );}D 10/****************************************//** return type num ******/E 10I 10/************************************************************************//*									*//*				t y p e _ n u m				*//*									*//*	Given a lisp pointer, return its type number.			*//*									*//************************************************************************/E 10type_num(lispptr) LispPTR lispptr;{  int type;  type = GetTypeNumber(lispptr);D 6  printf("LispPTR 0x%x is datatype %dth \n",lispptr,type);E 6I 6  printf("LispPTR 0x%x is datatype %dth\n",lispptr,type);E 6  return(type);}D 10/******************************//* DUMP conspage prog.*//*****************************/E 10I 10/************************************************************************//*									*//*			d u m p _ c o n s p a g e			*//*									*//*	Print information about a CONS page, and the cells in it.	*//*									*//************************************************************************/E 10dump_conspage(base , linking )D 10 struct conspage *base; /* target conspage address */D 6 int linking ;  /* look for chaiing conspage ? T/NIL */E 6I 6 int linking;  /* look for chaiing conspage ? T/NIL */E 6{E 10I 10   struct conspage *base; /* target conspage address */   int linking;  /* look for chaiing conspage ? T/NIL */  {E 10D 6 ConsCell *cell ;E 6I 6D 10 ConsCell *cell;E 6 int  i;E 10I 10   ConsCell *cell;   int  i;E 10lp:D 6	printf("conspage at 0x%x(lisp) has %d free cells , next available cell offset is %d ,and next page is 0x%x(lisp) \n",LADDR_from_68k(base),(0xff & base->count),(0xff & base->next_cell), base->next_page );E 6I 6D 10	printf("conspage at 0x%x(lisp) has %d free cells , next available cell offset is %d ,and next page is 0x%x(lisp)\n",LADDR_from_68k(base),(0xff & base->count),(0xff & base->next_cell), base->next_page );E 10I 10    printf("conspage at 0x%x(lisp) has %d free cells , next available cell offset is %d ,and next page is 0x%x(lisp)\n",	   LADDR_from_68k(base), (0xff & base->count), 	   (0xff & base->next_cell), base->next_page );E 10E 6D 6		for( i = 0 , cell = (ConsCell *)base+1; i <127 ; i++,cell++)E 6I 6D 10	for( i = 0 , cell = (ConsCell *)base+1; i <127; i++,cell++)E 6	 {D 6		printf(" LADDR : %d = Cell[ %d ]## cdr_code= %d ,car = %d \n"E 6I 6		printf(" LADDR : %d = Cell[ %d ]## cdr_code= %d ,car = %d\n"E 6		,LADDR_from_68k(cell),i+1,cell->cdr_code,cell->car_field);E 10I 10    for( i = 0 , cell = (ConsCell *)base+1; i <127; i++,cell++)      {	printf(" LADDR : %d = Cell[ %d ]## cdr_code= %d ,car = %d\n",	       LADDR_from_68k(cell),i+1,cell->cdr_code,cell->car_field);E 10D 10	 }E 10I 10      }E 10D 10	if ((linking==T) && (base->next_page != NIL_PTR))	{D 6		base =(struct conspage *) Addr68k_from_LPAGE(base->next_page) ;		goto lp ;E 6I 6		base =(struct conspage *) Addr68k_from_LPAGE(base->next_page);		goto lp;E 6	}E 10I 10    if ((linking==T) && (base->next_page != NIL_PTR))      {	base =(struct conspage *) Addr68k_from_LPAGE(base->next_page);	goto lp;      }E 10D 10} /* end dump_conspage */E 10I 10  } /* end dump_conspage */E 10/*********************************//* trace the link in ListpDTD->dtd_nextpage */trace_listpDTD(){D 6extern struct dtd *ListpDTD ; printf("Dump conspages from ListpDTD chain \n");E 6I 6extern struct dtd *ListpDTD; printf("Dump conspages from ListpDTD chain\n");E 6 dump_conspage(Addr68k_from_LPAGE(ListpDTD->dtd_nextpage) , T);}D 10/*************************************/E 10I 10/************************************************************************//*									*//*				a 6 8 k					*//*									*//*	Given a lisp pointer, print the corresponding native address.	*//*									*//************************************************************************/E 10D 6a68k( lispptr)LispPTR lispptr;{  printf("68k: 0x%x (%d) \n",Addr68k_from_LADDR(lispptr),Addr68k_from_LADDR(lispptr));}E 6I 6a68k(lispptr)D 12    LispPTR lispptr;    {E 12I 12  LispPTR lispptr;  {E 12D 7    int val;E 7I 7    DLword *val;E 7    val = Addr68k_from_LADDR(lispptr);    printf("68k: 0x%x (%d)\n", val, val);D 12    }E 12I 12  }E 12I 10/************************************************************************//*									*//*			   l a d d r					*//*									*//*	Given a native address, print the corresponding lisp ptr.	*//*									*//************************************************************************/E 10E 6laddr(addr68k)D 6DLword *addr68k ;{ printf("LADDR : 0x%x (%d)\n",LADDR_from_68k(addr68k),LADDR_from_68k(addr68k));}E 6I 6D 12    DLword *addr68k;    {E 12I 12  DLword *addr68k;  {E 12    int val;    val = LADDR_from_68k(addr68k);    printf("LADDR : 0x%x (%d)\n", val, val);D 12    }E 12I 12  }E 12E 6/*************************************************************//* dump_fnobj(index) */#define DUMPSIZE 40dump_fnobj(index)D 6LispPTR index ; /* atom index */E 6I 6D 12LispPTR index; /* atom index */E 6{  struct fnhead *fnobj;  DefCell *defcell68k;  LispPTR cell;  DLbyte *scratch; int i;E 12I 12  LispPTR index; /* atom index */  {    struct fnhead *fnobj;    DefCell *defcell68k;    LispPTR cell;    DLbyte *scratch;    int i;E 12D 12  defcell68k = (DefCell *)GetDEFCELL68k(index); fnobj = (struct fnhead *)Addr68k_from_LADDR(defcell68k->defpointer);E 12I 12    defcell68k = (DefCell *)GetDEFCELL68k(index);    fnobj = (struct fnhead *)Addr68k_from_LADDR(defcell68k->defpointer);E 12D 12 /* check if it's the same index ??*/ if (index != (fnobj->framename)) {E 12I 12    /* check if it's the same index ??*/    if (index != (fnobj->framename))      {E 12	printf("DEFCELL says it is ");	print_atomname(index);	printf("\n But Func OBJ says ");	print_atomname(fnobj->framename);	putchar('\n');	return;D 12   }E 12I 12      }E 12D 12 printf("***DUMP Func Obj << ");D 6 printf("start at 0x%x lisp address(0x%x 68k) \n",LADDR_from_68k(fnobj),fnobj);E 6I 6 printf("start at 0x%x lisp address(0x%x 68k)\n",LADDR_from_68k(fnobj),fnobj);E 12I 12    printf("***DUMP Func Obj << ");    printf("start at 0x%x lisp address(0x%x 68k)\n",		LADDR_from_68k(fnobj),fnobj);E 12E 6D 12 print_atomname(index); putchar('\n');E 12I 12    print_atomname(index);    putchar('\n');E 12D 6 printf("stkmin    : %d \n",fnobj->stkmin); printf("na        : %d \n",fnobj->na); printf("pv        : %d \n",fnobj->pv); printf("startpc   : %d \n",fnobj->startpc); printf("argtype   : %d \n",fnobj->argtype); printf("framename : %d \n",fnobj->framename); printf("ntsize    : %d \n",fnobj->ntsize); printf("nlocals   : %d \n",fnobj->nlocals); printf("fvaroffset: %d \n",fnobj->fvaroffset);E 6I 6D 12 printf("stkmin    : %d\n",fnobj->stkmin); printf("na        : %d\n",fnobj->na); printf("pv        : %d\n",fnobj->pv); printf("startpc   : %d\n",fnobj->startpc); printf("argtype   : %d\n",fnobj->argtype); printf("framename : %d\n",fnobj->framename); printf("ntsize    : %d\n",fnobj->ntsize); printf("nlocals   : %d\n",fnobj->nlocals); printf("fvaroffset: %d\n",fnobj->fvaroffset);E 12I 12    printf("stkmin    : %d\n",fnobj->stkmin);    printf("na        : %d\n",fnobj->na);    printf("pv        : %d\n",fnobj->pv);    printf("startpc   : %d\n",fnobj->startpc);    printf("argtype   : %d\n",fnobj->argtype);    printf("framename : %d\n",fnobj->framename);    printf("ntsize    : %d\n",fnobj->ntsize);    printf("nlocals   : %d\n",fnobj->nlocals);    printf("fvaroffset: %d\n",fnobj->fvaroffset);E 12E 6D 12scratch= (DLbyte *)fnobj;for (i= 20; i<(fnobj->startpc); i+=2){D 6printf(" 0x%x(0x%x 68k): 0%o \n",LADDR_from_68k(scratch),scratch,(int)(0xffff & (*((DLword *)(scratch+i)))) );E 6I 6D 9printf(" 0x%x(0x%x 68k): 0%o\n",LADDR_from_68k(scratch),scratch,(int)(0xffff & (*((DLword *)(scratch+i)))) );E 9I 9printf(" 0x%x(0x%x 68k): 0%o\n",LADDR_from_68k(scratch),scratch,(int)(0xffff & (GETWORD((DLword *)(scratch+i)))) );E 9E 6}E 12I 12   scratch= (DLbyte *)fnobj;   for (i= 20; i<(fnobj->startpc); i+=2)      {	printf(" 0x%x(0x%x 68k): 0%o\n",		LADDR_from_68k(scratch), scratch,		(int)(0xffff & (GETWORD((DLword *)(scratch+i)))) );      }E 12D 12scratch= (DLbyte *)fnobj + (fnobj->startpc);D 6for (i= 0 ; i< DUMPSIZE; i++,scratch++)E 6I 6for (i= 0; i< DUMPSIZE; i++,scratch++)E 6{D 6printf(" 0x%x(0x%x 68k): 0%o \n",LADDR_from_68k(scratch),scratch,(int)(0xff & (*scratch)) );E 6I 6printf(" 0x%x(0x%x 68k): 0%o\n",LADDR_from_68k(scratch),scratch,(int)(0xff & (*scratch)) );E 6}E 12I 12    scratch= (DLbyte *)fnobj + (fnobj->startpc);    for (i= 0; i< DUMPSIZE; i++, scratch++)      {	printf(" 0x%x(0x%x 68k): 0%o\n", LADDR_from_68k(scratch), 		scratch, (int)(0xff & GETBYTE(scratch)) );      }E 12} /*dump_fnobj end *//*********************************************************************/D 6 struct doko {  	LispPTR func ;	int     pc ;};E 6I 6D 12 struct doko {	LispPTR func;	int     pc;};E 12I 12 struct doko   {    LispPTR func;    int     pc;  };E 12E 6struct doko doko()D 12{  struct doko tmp;E 12I 12  {    struct doko tmp;E 12D 12   printf(" At ");   print_atomname(FuncObj->framename);   putchar('\n');D 6   printf("   PC cnt = 0%o \n" ,tmp.pc=((int)(PC)- (int)FuncObj) );E 6I 6   printf("   PC cnt = 0%o\n" ,tmp.pc=((int)(PC)- (int)FuncObj) );E 6   tmp.func= FuncObj->framename;   return(tmp);}E 12I 12     printf(" At ");     print_atomname(FuncObj->framename);     putchar('\n');     printf("   PC cnt = 0%o\n" ,tmp.pc=((int)(PC)- (int)FuncObj) );     tmp.func= FuncObj->framename;     return(tmp);  }E 12I 12E 12/**** dump specified area (in 32 bit width) ***/dumpl(laddr)D 6 LispPTR laddr ;E 6I 6D 12 LispPTR laddr;E 6{D 6  int i ;  LispPTR *ptr ;E 6I 6  int i;  LispPTR *ptr;E 12I 12  LispPTR laddr;  {    int i;    LispPTR *ptr;E 12E 6D 12  ptr = (LispPTR *)Addr68k_from_LADDR(laddr);E 12I 12    ptr = (LispPTR *)Addr68k_from_LADDR(laddr);E 12D 6  E 6D 6 for(i=0 ; i< 40 ; i++,ptr++)	printf("LADDR 0x%x : %d \n",LADDR_from_68k(ptr),*ptr);E 6I 6D 12 for(i=0; i< 40; i++,ptr++)	printf("LADDR 0x%x : %d\n",LADDR_from_68k(ptr),*ptr);E 12I 12   for(i=0; i< 40; i++,ptr++)      printf("LADDR 0x%x : %d\n", LADDR_from_68k(ptr), *ptr);E 12E 6D 12}E 12I 12  }E 12/**** dump specified area (in 16 bit width) ***/dumps(laddr)D 6 LispPTR laddr ;E 6I 6D 12 LispPTR laddr;E 6{D 6  int i ;  DLword *ptr ;E 6I 6  int i;  DLword *ptr;E 12I 12  LispPTR laddr;  {    int i;    DLword *ptr;E 12E 6D 12  ptr = (DLword *)Addr68k_from_LADDR(laddr);E 12I 12    ptr = (DLword *)Addr68k_from_LADDR(laddr);E 12D 6  E 6D 6 for(i=0 ; i< 40 ; i++,ptr++)	printf("LADDR 0x%x : %d \n",LADDR_from_68k(ptr),((*ptr)& 0xffff));E 6I 6D 12 for(i=0; i< 40; i++,ptr++)D 9	printf("LADDR 0x%x : %d\n",LADDR_from_68k(ptr),((*ptr)& 0xffff));E 9I 9	printf("LADDR 0x%x : %d\n",LADDR_from_68k(ptr),(GETWORD(ptr)& 0xffff));E 12I 12   for(i=0; i< 40; i++,ptr++)      printf("LADDR 0x%x : %d\n", LADDR_from_68k(ptr), (GETWORD(ptr)& 0xffff));E 12E 9E 6D 12}E 12I 12  }E 12I 12E 12/***********************/printPC()D 12{ unsigned short pc;E 12I 12  {    unsigned short pc;E 12D 6 pc =(int)PC - (int)FuncObj ;E 6I 6D 12 pc =(int)PC - (int)FuncObj;E 12I 12    pc =(int)PC - (int)FuncObj;E 12E 6D 12printf("PC: O%o ",pc);}E 12I 12    printf("PC: O%o ",pc);  }E 12/***************************/countchar(string)D 12char *string;{ int cnt=0;E 12I 12  char *string;  {    int cnt=0;E 12D 12while(*string != '\0')D 6{ string++;cnt++;} E 6I 6{ string++;cnt++;}E 12I 12    while(*string != '\0') { string++; cnt++;}E 12E 6D 12 return(cnt);}/****************/E 12I 12    return(cnt);  }E 12D 12/****************************************************************/E 12I 12E 12/***************************************************************//*	Func Name :	dump_stackframe	Desc :		For Debugging AidsD 6	Changed 	8 JUN 1987 TAKEE 6I 6	Changed		8 JUN 1987 TAKEE 6*//***************************************************************/dump_stackframe( fx_addr68k )D 6  struct frameex1 *fx_addr68k ;E 6I 6  struct frameex1 *fx_addr68k;E 6D 12{  Bframe *bf; if((fx_addr68k->alink & 1)==0)  {   /* FAST */E 12I 12  {    Bframe *bf;    if((fx_addr68k->alink & 1)==0)      {   /* FAST */E 12D 6 	bf = (Bframe *)(((DLword *)fx_addr68k)  - 2 );  E 6I 6	bf = (Bframe *)(((DLword *)fx_addr68k)  - 2 );E 6D 12  }  else  {   /* SLOW */E 12I 12      }    else      {   /* SLOW */E 12D 6	bf =(Bframe *) Addr68k_from_LADDR((fx_addr68k->blink+ STK_OFFSET)) ;E 6I 6	bf =(Bframe *) Addr68k_from_LADDR((fx_addr68k->blink+ STK_OFFSET));I 12      }    dump_bf(bf);    dump_fx(fx_addr68k);E 12E 6  }D 12  dump_bf(bf);  dump_fx(fx_addr68k);}E 12I 12E 12dump_bf(bf)  Bframe *bf;D 12{D 6  DLword *ptr ;E 6I 6  DLword *ptr;E 6  printf("\n*** Basic Frame");  if (bf->flags != 4)    {printf("\nInvalid basic frame"); return(0);};E 12I 12  {    DLword *ptr;    printf("\n*** Basic Frame");    if (BFRAMEPTR(bf)->flags != 4)      {	printf("\nInvalid basic frame"); 	return(0);      };E 12D 12  if (bf->residual) {goto printflags;}E 12I 12    if (BFRAMEPTR(bf)->residual) {goto printflags;}E 12D 12  ptr = Addr68k_from_LADDR( STK_OFFSET + bf->ivar);  if ( (((DLword*)bf - ptr) > 512) || (( (int)ptr & 1) != 0) )    {printf("\nInvalid basic frame"); return(0);};  while(ptr < (DLword *)bf)  {    printf("\n %x : %x %x",LADDR_from_68k(ptr),*ptr, *(ptr+1));    print(*ptr);    ptr+=2;  }E 12I 12    ptr = Addr68k_from_LADDR( STK_OFFSET + bf->ivar);    if ( (((DLword*)bf - ptr) > 512) || (( (int)ptr & 1) != 0) )      {	printf("\nInvalid basic frame");	return(0);      }    while(ptr < (DLword *)bf)      {	printf("\n %x : %x %x", LADDR_from_68k(ptr),		GETWORD(ptr), GETWORD(ptr+1));	print(*ptr);	ptr+=2;      }E 12printflags:    printf("\n %x : %x %x ",LADDR_from_68k(bf),*bf, *(bf+1));    putchar('[');D 12    if (bf->residual)	printf("Residual, ");    if (bf->padding)	printf("Padded, ");    printf("usecnt=%d ] ",bf->usecnt);    printf("ivar : 0x%x",bf->ivar);E 12I 12    if (BFRAMEPTR(bf)->residual)	printf("Residual, ");    if (BFRAMEPTR(bf)->padding)	printf("Padded, ");    printf("usecnt=%d ] ",BFRAMEPTR(bf)->usecnt);    printf("ivar : 0x%x",BFRAMEPTR(bf)->ivar);E 12}dump_fx( fx_addr68k)D 6  struct frameex1 *fx_addr68k ;E 6I 6  struct frameex1 *fx_addr68k;E 6D 12{D 6  DLword *next68k ;  DLword *ptr ;  LispPTR atomindex ; E 6I 6  DLword *next68k;  DLword *ptr;  LispPTR atomindex;E 12I 12  {    DLword *next68k;    DLword *ptr;    LispPTR atomindex;E 12E 6D 12 ptr = (DLword *)fx_addr68k;E 12I 12    ptr = (DLword *)fx_addr68k;E 12D 12  if(fx_addr68k->flags != 6)   {printf("\nInvalid frame,NOT FX"); return(0);};E 12I 12    if(fx_addr68k->flags != 6)      {	printf("\nInvalid frame,NOT FX"); 	return(0);      };E 12D 12  atomindex = get_framename(fx_addr68k);  printf("\n*** Frame Extension for ");  print(atomindex);D 9  printf("\n %x : %x %x ",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 9I 9  printf("\n %x : %x %x ",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));E 12I 12    atomindex = get_framename(fx_addr68k);    printf("\n*** Frame Extension for ");    print(atomindex);    printf("\n %x : %x %x ",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));E 12E 9D 12 putchar('[');  if(fx_addr68k->fast)		printf("F,");  if(fx_addr68k->incall)	printf("incall, ");  if(fx_addr68k->validnametable)	printf("V, ");  printf("usecnt = %d]; alink",fx_addr68k->usecount);  if(fx_addr68k->alink & 1)  printf("[SLOWP]");E 12I 12    putchar('[');    if(fx_addr68k->fast) printf("F,");    if(fx_addr68k->incall) printf("incall, ");    if(fx_addr68k->validnametable) printf("V, ");    printf("usecnt = %d]; alink",fx_addr68k->usecount);    if(fx_addr68k->alink & 1)    printf("[SLOWP]");E 12D 12  ptr+=2;D 9  printf("\n %x : %x %x fnheadlo, fnheadhi\n",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 9I 9  printf("\n %x : %x %x fnheadlo, fnheadhi\n",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));E 12I 12    ptr+=2;    printf("\n %x : %x %x fnheadlo, fnheadhi\n", 		LADDR_from_68k(ptr), GETWORD(ptr), GETWORD(ptr+1));E 12E 9D 12  ptr+=2;D 9  printf("\n %x : %x %x next,     pc\n",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 9I 9  printf("\n %x : %x %x next,     pc\n",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));E 12I 12    ptr+=2;    printf("\n %x : %x %x next,     pc\n",		LADDR_from_68k(ptr), GETWORD(ptr), GETWORD(ptr+1));E 12E 9D 12  ptr+=2;D 9  printf("\n %x : %x %x LoNmTbl,  HiNmTbl\n",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 9I 9  printf("\n %x : %x %x LoNmTbl,  HiNmTbl\n",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));E 12I 12    ptr+=2;    printf("\n %x : %x %x LoNmTbl,  HiNmTbl\n",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));E 12E 9D 12  ptr+=2;D 9  printf("\n %x : %x %x #blink,   #clink\n",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 9I 9  printf("\n %x : %x %x #blink,   #clink\n",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));E 12I 12    ptr+=2;    printf("\n %x : %x %x #blink,   #clink\n",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));E 12E 9D 12/* should pay attention to the name table like RAID does */E 12I 12    /* should pay attention to the name table like RAID does */E 12D 6 next68k = (DLword *)Addr68k_from_LADDR((fx_addr68k->nextblock+STK_OFFSET)) ;E 6I 6D 12 next68k = (DLword *)Addr68k_from_LADDR((fx_addr68k->nextblock+STK_OFFSET));E 6 if (fx_addr68k == CURRENTFX) {next68k = CurrentStackPTR + 2;}E 12I 12    next68k = (DLword *)Addr68k_from_LADDR((fx_addr68k->nextblock+STK_OFFSET));    if (fx_addr68k == CURRENTFX) {next68k = CurrentStackPTR + 2;}E 12D 12 if ((next68k < ptr) || (((int)next68k & 1) != 0) )E 12I 12    if ((next68k < ptr) || (((int)next68k & 1) != 0) )E 12D 6    {printf ("\nNext block invalid") ; return(0);}E 6I 6    {printf ("\nNext block invalid"); return(0);}E 6D 6 E 6I 6E 6D 12 while(next68k > ptr)  {  ptr+=2;D 9  printf("\n %x : %x %x",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 9I 9  printf("\n %x : %x %x",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));E 9  }return (0);E 12I 12    while(next68k > ptr)      {	ptr+=2;	printf("\n %x : %x %x",		LADDR_from_68k(ptr), GETWORD(ptr), GETWORD(ptr+1));      }    return (0);E 12D 12} /* end dump_fx */E 12I 12  } /* end dump_fx */E 12dump_CSTK(before)D 12int before;{D 6  DLword *ptr ; ptr= CurrentStackPTR - before ;E 6I 6  DLword *ptr; ptr= CurrentStackPTR - before;E 6while(ptr != CurrentStackPTR){E 12I 12  int before;  {    DLword *ptr;    ptr= CurrentStackPTR - before;    while(ptr != CurrentStackPTR)      {E 12D 9	printf("\n%x : %x ",LADDR_from_68k(ptr),*ptr);E 9I 9	printf("\n%x : %x ",LADDR_from_68k(ptr),GETWORD(ptr));E 9	ptr++;D 12}printf("\nCurrentSTKP : %x  ",LADDR_from_68k(CurrentStackPTR));printf("\ncontents :  %x ",*((LispPTR *)(CurrentStackPTR-1)));}/* dump_CSTK end */E 12I 12      }    printf("\nCurrentSTKP : %x  ",LADDR_from_68k(CurrentStackPTR));    printf("\ncontents :  %x ",*((LispPTR *)(CurrentStackPTR-1)));  }/* dump_CSTK end */E 12/******************************************//* BTV */btv()D 6{  E 6I 6D 12{E 6  struct frameex1 *fx_addr68k;D 6  LispPTR atomindex ;E 6I 6  LispPTR atomindex;E 6 struct frameex1 *get_nextFX();E 12I 12  {    struct frameex1 *fx_addr68k;    LispPTR atomindex;    struct frameex1 *get_nextFX();E 12D 6  fx_addr68k = CURRENTFX ;E 6I 6D 12  fx_addr68k = CURRENTFX;E 12I 12    fx_addr68k = CURRENTFX;E 12E 6loop:D 12  dump_stackframe(fx_addr68k);D 6  if( fx_addr68k->alink == 0 ) E 6I 6  if( fx_addr68k->alink == 0 )E 12I 12    dump_stackframe(fx_addr68k);    if( fx_addr68k->alink == 0 )E 12E 6     {printf ("\n BTV end"); return(0);};D 12   fx_addr68k= get_nextFX(fx_addr68k);   goto loop;} /*end btv*/E 12I 12    fx_addr68k= get_nextFX(fx_addr68k);    goto loop;  } /*end btv*/E 12D 6  E 6I 6E 6get_framename(fx_addr68k)D 6  struct frameex1 *fx_addr68k ;E 6I 6  struct frameex1 *fx_addr68k;E 6D 12{  struct fnhead *fnheader;D 6  LispPTR scratch ;E 6I 6  LispPTR scratch;E 12I 12  {    struct fnhead *fnheader;    LispPTR scratch;E 12E 6D 12/* Get FNHEAD */  if(fx_addr68k->validnametable==0) {E 12I 12    /* Get FNHEAD */    if(fx_addr68k->validnametable==0)      {E 12D 6	scratch = (unsigned int)fx_addr68k->hi2fnheader << 16 ;	scratch |= (unsigned int)(fx_addr68k->lofnheader) ;	fnheader = (struct fnhead *)Addr68k_from_LADDR(scratch ) ;E 6I 6	scratch  = (unsigned int)(fx_addr68k->hi2fnheader << 16);	scratch |= (unsigned int)(fx_addr68k->lofnheader);E 6D 12    }  else {E 12I 12      }  else      {E 12D 6	scratch = (unsigned int)(fx_addr68k->hi2nametable << 16);	scratch |= (unsigned int) (fx_addr68k->lonametable);	fnheader = (struct fnhead *)Addr68k_from_LADDR( scratch );E 6I 6	scratch  = (unsigned int)(fx_addr68k->hi2nametable << 16);	scratch |= (unsigned int)(fx_addr68k->lonametable);E 6D 12    }D 6   return(fnheader->framename);E 6I 6  fnheader = (struct fnhead *)Addr68k_from_LADDR( scratch );  return(fnheader->framename);E 6}/* get_framename end */E 12I 12      }    fnheader = (struct fnhead *)Addr68k_from_LADDR( scratch );    return(fnheader->framename);  }/* get_framename end */E 12D 6 E 6I 6E 6D 12/**********************************************************************/E 12D 12 FX *get_nextFX(fx)E 12I 12FX *get_nextFX(fx)E 12  FX *fx;D 12{D 6 DLword *pv ;E 6I 6 DLword *pv;E 12I 12  {    DLword *pv;E 12E 6D 12 if(URaid_scanlink==URSCAN_ALINK)E 12I 12    if(URaid_scanlink==URSCAN_ALINK)E 12D 6 	return((FX *)Addr68k_from_StkOffset(GETALINK(fx))); else E 6I 6	return((FX *)Addr68k_from_StkOffset(GETALINK(fx)));D 12 elseE 12I 12    elseE 12E 6	return((FX *)Addr68k_from_StkOffset(GETCLINK(fx)));D 6 E 6I 6E 6D 12} /* get_nextFX end */E 12I 12  } /* get_nextFX end */E 12D 12/*************************************************************/E 12D 12/***************************/E 12MAKEATOM(string)D 12char *string;{ int length; length = countchar(string);  return(make_atom(string,0,length,0));}/****************/E 12I 12  char *string;  {    int length;    length = countchar(string);    return(make_atom(string,0,length,0));  }E 12I 6D 11/* called from initsysout */E 11I 11/************************************************************************//*									*//*			M a k e A t o m 6 8 k				*//*									*//*	Given a LITATOM that exists before the package system was	*//*	turned on, return a pointer to that atom's value cell.		*//*									*//************************************************************************/E 11D 7MakeAtom68k(string)E 7I 7DLword *MakeAtom68k(string)E 7    char   *string;    {    int index;    index = make_atom(string, 0, countchar(string), 0);    index = VALS_OFFSET + (index << 1);    return ( Addr68k_from_LADDR( index ) );    }/****************/E 6GETTOPVAL(string) char *string;{  int index;  LispPTR *cell68k; index=MAKEATOM(string); cell68k= (LispPTR *)GetVALCELL68k(index);  print(*cell68k);}I 9/************************************************************************//*									*//*				S _ T O P V A L				*//*									*//*	Given a string that's an atom name minus the initial \,		*//*	print the atom's top-level value.  This is here because		*//*	DBX won't put \'s in strings you type.				*//*									*//************************************************************************/E 9S_TOPVAL(string)D 9 char *string;{  int index;  LispPTR *cell68k; int length; char dummy[256];E 9I 9  char *string;  {    int index;    LispPTR *cell68k;    int length;    char dummy[256];E 9D 6 dummy[0]='\\'; E 6I 6D 9 dummy[0]='\\';E 6 for(length=1; *string != '\0'; length++,string++)  { dummy[length] = *string;}E 9I 9    dummy[0]='\\';    for(length=1; *string != '\0'; length++,string++)      { 	dummy[length] = *string;      }E 9I 9    index=make_atom(dummy,0,length,0);    cell68k= (LispPTR *)GetVALCELL68k(index);    print(*cell68k);  }E 9D 9 index=make_atom(dummy,0,length,0); cell68k= (LispPTR *)GetVALCELL68k(index);  print(*cell68k);}E 9I 9E 9/***************/S_MAKEATOM(string) char *string;{  int index=0; int length; char dummy[256];D 6 dummy[0]='\\'; E 6I 6 dummy[0]='\\';E 6 for(length=1; *string != '\0'; length++,string++)  { dummy[length] = *string;} index=make_atom(dummy,0,length,0);D 6  printf("#Atomindex : %d \n",index);E 6I 6  printf("#Atomindex : %d\n",index);E 6 return(index);}/****************************************************************************/D 6/*     all_stack_dump(start,end)  E 6I 6/*     all_stack_dump(start,end)E 6*/I 2#define SDMAXLINE 40#define SD_morep	if(++sdlines>SDMAXLINE){\			 printf("\nPress Return:"); getchar();fflush(stdin);sdlines=0;}E 2D 12typedef struct stack_header {	unsigned	flags1 : 3;D 6	unsigned	flags2  : 5;		unsigned	usecount : 8 ; } STKH ;E 6I 6	unsigned	flags2  : 5;	unsigned	usecount : 8; } STKH;E 12E 6I 12#ifndef BYTESWAPtypedef struct stack_header  {    unsigned	flags1 : 3;    unsigned	flags2  : 5;    unsigned	usecount : 8;  } STKH;#define STKHPTR(ptr) (ptr)#elsetypedef struct stack_header  {    unsigned	usecount : 8;    unsigned	flags2  : 5;    unsigned	flags1 : 3;  } STKH;#define STKHPTR(ptr) ((STKH *) (2^(int)(ptr)))#endif BYTESWAPE 12all_stack_dump(start,end,silent) DLword start,end ,silent; /* Stack offset in DLword */{  STKH *stkptr;D 2  DLword *start68k,*end68k;E 2I 2  DLword *start68k,*end68k,*orig68k;E 2  DLword size,dummy;I 2  int sdlines=0;E 2 extern IFPAGE *InterfacePage; if(start==0) start68k= Stackspace + InterfacePage->stackbase;D 6 else start68k = Addr68k_from_LADDR(STK_OFFSET | start) ;E 6I 6 else start68k = Addr68k_from_LADDR(STK_OFFSET | start);E 6 if(end==0) end68k= Stackspace+ InterfacePage->endofstack;D 6 else end68k = Addr68k_from_LADDR(STK_OFFSET | end) ;E 6I 6 else end68k = Addr68k_from_LADDR(STK_OFFSET | end);E 6 stkptr= (STKH *)start68k;  while(((DLword*)stkptr) < end68k )  {	dummy = LADDR_from_68k(stkptr);D 12	switch (stkptr->flags1 ) {E 12I 12	switch (STKHPTR(stkptr)->flags1 ) {E 12	case STK_GUARD :	case STK_FSB :D 12			if( (stkptr->flags2 !=0) || (stkptr->usecount!=0) )E 12I 12			if( (STKHPTR(stkptr)->flags2 !=0) || (STKHPTR(stkptr)->usecount!=0) )E 12				{goto badblock;};D 6			size = *(((DLword *)stkptr) +1) ;E 6I 6D 9			size = *(((DLword *)stkptr) +1);E 9I 9			size = GETWORD(((DLword *)stkptr) +1);E 9E 6			if(size <=0 || size > ((DLword*)end68k-(DLword*)stkptr))			 {goto badblock;};D 12			if(stkptr->flags1 == STK_GUARD)E 12I 12			if(STKHPTR(stkptr)->flags1 == STK_GUARD)E 12			printf("\n<<  0x%x GUARD size : 0x%x >>",LADDR_from_68k(stkptr),size );			else printf("\n<<  0x%x FSB size : 0x%x >>",LADDR_from_68k(stkptr),size);I 2			SD_morep;E 2D 6			size = *(((DLword *)stkptr) +1) ;E 6I 6D 9			size = *(((DLword *)stkptr) +1);E 9I 9			size = GETWORD(((DLword *)stkptr) +1);E 9E 6	checksize:			if(size <=0 || size > ((DLword*)end68k-(DLword*)stkptr))			 {goto badblock;};			((DLword *)stkptr) += size;D 6			break ;E 6I 6			break;E 6D 6	case STK_FX :	D 2			if((((FX *)stkptr)->pc < 24) || E 2I 2			/*if((((FX *)stkptr)->pc < 24) || E 2				(((FX *)stkptr)->alink==0)  ||					 (stkptr->usecount > 31))	E 6I 6	case STK_FX :			/*if((((FX *)stkptr)->pc < 24) ||				(((FX *)stkptr)->alink==0)  ||D 12				 (stkptr->usecount > 31))E 12I 12				 (STKHPTR(stkptr)->usecount > 31))E 12E 6D 2			 {goto badblock;};E 2I 2			 {goto badblock;};*/E 2			if (silent)D 2			{E 2I 2			{SD_morep;E 2			 printf("\n<<  0x%x: FX for ",LADDR_from_68k(stkptr));			 print(get_framename(stkptr));			 printf(" [");D 2 			 if(((FX *)stkptr)->incall)	printf("incall,");E 2I 2D 6 			 if(((FX *)stkptr)->fast)	printf("fast,");E 2 			 if(((FX *)stkptr)->native)	printf("native,");I 2 			 if(((FX *)stkptr)->incall)	printf("incall,"); 			 if(((FX *)stkptr)->validnametable)	printf("V,"); 			 if(((FX *)stkptr)->nopush)	printf("nopush,");E 2 			 printf("]"); }E 6I 6			 if(((FX *)stkptr)->fast)	printf("fast,");			 if(((FX *)stkptr)->native)	printf("native,");			 if(((FX *)stkptr)->incall)	printf("incall,");			 if(((FX *)stkptr)->validnametable)	printf("V,");			 if(((FX *)stkptr)->nopush)	printf("nopush,");			 printf("]"); }E 6			else {dump_fx(stkptr);}			if((FX *)stkptr == CURRENTFX) {D 2				printf("***current***");E 2I 2				printf(" <-***current***");E 2D 6				size= EndSTKP - (DLword*)stkptr ;E 6I 6				size= EndSTKP - (DLword*)stkptr;E 6			}			else {			size = (Addr68k_from_LADDR(STK_OFFSET| ((FX *)stkptr)->nextblock) - (DLword*)stkptr);			};			goto checksize;I 2	default :D 6       		       orig68k =(DLword*) stkptr;E 6I 6		       orig68k =(DLword*) stkptr;E 6E 2D 2	case 0:	case STK_BF :			while (stkptr->flags1 == 0) {(DLword *)stkptr +=2;};			if (stkptr->flags1 != STK_BF) {goto badblock;};	E 2I 2D 12                        while(stkptr->flags1 != STK_BF) {                                if(stkptr->flags1!=STK_NOTFLG){goto badblock;};E 12I 12                        while(STKHPTR(stkptr)->flags1 != STK_BF) {                                if(STKHPTR(stkptr)->flags1!=STK_NOTFLG){goto badblock;};E 12D 6                                ((DLword *)stkptr) += DLWORDSPER_CELL ; E 6I 6                                ((DLword *)stkptr) += DLWORDSPER_CELL;E 6                         };D 6 			if(((Bframe*)stkptr)->residual)D 5                          { if(stkptr !=(DLword*) orig68k) E 5I 5                          { if((DLword*) stkptr != orig68k) E 6I 6D 12			if(((Bframe*)stkptr)->residual)E 12I 12			if((BFRAMEPTR(stkptr))->residual)E 12                          { if((DLword*) stkptr != orig68k)E 6E 5                             {				printf("\n$$$Bad BF(res):0x%x",LADDR_from_68k(stkptr));				goto incptr;			     }			  }			 else			  {D 6				 if(((Bframe*)stkptr)->ivar 					 	!= StkOffset_from_68K(orig68k))E 6I 6D 12				 if(((Bframe*)stkptr)->ivarE 12I 12				 if(BFRAMEPTR(stkptr)->ivarE 12						!= StkOffset_from_68K(orig68k))E 6				 {					printf("\n$$$BF doesn't point TopIVAR:0x%x\n",LADDR_from_68k(stkptr));					goto incptr;				 }			  }E 2			if(silent)D 2			{E 2I 2D 12			{SD_morep;E 2			printf("\n<<  0x%x: BF ",LADDR_from_68k(stkptr));			putchar('[');D 6 			if (((Bframe *)stkptr)->residual)	printf("Res,"); 			if (((Bframe *)stkptr)->padding)	printf("Pad,");E 6I 6			if (((Bframe *)stkptr)->residual)	printf("Res,");			if (((Bframe *)stkptr)->padding)	printf("Pad,");E 6			printf("ivar : 0x%x]",((Bframe *)stkptr)->ivar);E 12I 12			  { SD_morep;			    printf("\n<<  0x%x: BF ",LADDR_from_68k(stkptr));			    putchar('[');			if (BFRAMEPTR(stkptr)->residual) printf("Res,");			if (BFRAMEPTR(stkptr)->padding) printf("Pad,");			printf("ivar : 0x%x]", BFRAMEPTR(stkptr)->ivar);E 12			} else  dump_bf(stkptr);			((DLword *)stkptr) += 2;			break;D 2	default :	badblock:       printf("\n<< 0x%x: Invalid, %x %x>>",LADDR_from_68k(stkptr), *stkptr, *(stkptr+1));			((DLword *)stkptr)+=2;E 2I 2	badblock:       SD_morep;D 9			printf("\n!!!<< 0x%x: Invalid, %x %x>>!!!",LADDR_from_68k(stkptr), *stkptr, *(stkptr+1));E 9I 9			printf("\n!!!<< 0x%x: Invalid, %x %x>>!!!",LADDR_from_68k(stkptr), GETWORD(stkptr), GETWORD(stkptr+1));E 9	incptr:		((DLword *)stkptr)+=2;E 2			break;D 6	E 6I 6E 6	} /* case end */  } /* while end */D 2printf("<< That's All , last stack :0x%x >> \n",InterfacePage->endofstack);E 2I 2D 6printf("\n<< That's All , last stack :0x%x >> \n",InterfacePage->endofstack);E 6I 6printf("\n<< That's All , last stack :0x%x >>\n",InterfacePage->endofstack);E 6E 2}/************************************************************/dtd_chain(type) DLword type;D 12{  struct dtd *dtdp;  LispPTR next;  LispPTR *next68k;E 12I 12  {    struct dtd *dtdp;    LispPTR next;    LispPTR *next68k;E 12D 12 dtdp=(struct dtd *)GetDTD(type);E 12I 12    dtdp=(struct dtd *)GetDTD(type);E 12D 12 next=dtdp->dtd_free; next68k=(LispPTR *) Addr68k_from_LADDR(next);E 12I 12    next=dtdp->dtd_free;    next68k=(LispPTR *) Addr68k_from_LADDR(next);E 12D 12 while((*next68k) != 0) {E 12I 12    while((*next68k) != 0)      {E 12D 6  	if(type != GetTypeNumber(next)) {	printf("BAD cell in next dtdfree \n");E 6I 6	if(type != GetTypeNumber(next)) {	printf("BAD cell in next dtdfree\n");E 6	  return; }	print(next);	putchar('\n');	next= *next68k;	next68k=(LispPTR *) Addr68k_from_LADDR(next);D 12 } printf("That's All !\n");E 12I 12      }    printf("That's All !\n");E 12D 12}/*  dtd_chain end **/E 12I 12  }/*  dtd_chain end **/E 12I 3#ifdef CHECKE 3check_dtd_chain(type)D 3 DLword type;{  struct dtd *dtdp;  LispPTR next;  LispPTR *next68k;E 3I 3	DLword          type;{	register LispPTR next;	LispPTR         before;E 3D 3 LispPTR before;E 3I 3	next = ((struct dtd *)GetDTD(type))->dtd_free;E 3D 3 dtdp=(struct dtd *)GetDTD(type); if(dtdp->dtd_free==0) {		printf(" Type %d is exhausted.\n",type); 		return;E 3I 3	while (next != NIL) {		if (type != GetTypeNumber(next)) {			error("BAD cell in next dtdfree ");			return;		}		next = *((LispPTR *)Addr68k_from_LADDR(next));	}E 3}D 3 if(GetTypeNumber(dtdp->dtd_free) != type)   error("BAD cell in dtdfree "); next=dtdp->dtd_free; next68k=(LispPTR *) Addr68k_from_LADDR(next); while((*next68k) != 0) {  	if(type != GetTypeNumber(next)) {	error("BAD cell in next dtdfree ");	  return; }	before = next;	next= *next68k;	next68k=(LispPTR *) Addr68k_from_LADDR(next);	if(*next68k == before) error("CIRCULER founded"); }putchar('.');}/*  cehck_dtd_chain end **/E 3I 3#endifI 9/************************************************************************//*									*//*			T R A C E _ F N C A L L				*//*			T R A C E _ A P P L Y				*//*									*//*	Functions for tracing function call and apply.  Trace_FNCall	*//*	takes 2 arguments:  The # of args the fn is bing called with	*//*	and the atom index of the function's name.			*//*									*//*	Trace_APPLY takes one argument:  The atom number of the		*//*	atom being applied.						*//*									*//************************************************************************/Trace_FNCall(numargs, atomindex)  int numargs;  int atomindex;  {    printf("Calling a %d-arg FN:  ", numargs);    print_atomname(atomindex);    printf(".\n");  }Trace_APPLY(atomindex)  int atomindex;  {    printf("APPLYing an atom:  ");    print_atomname(atomindex);    printf(".\n");  }E 9E 3E 1