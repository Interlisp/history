h52916s 00280/00156/00619d D 2.3 88/04/18 19:13:24 shimizu 11 10c Add line-limit for all_stack_dumpes 00028/00011/00855d D 2.2 88/05/18 19:11:53 shimizu 10 9c change all_stack_dumpes 00000/00000/00866d D 2.1 88/05/17 09:21:22 hayata 9 8c Version up to 2.1es 00001/00000/00865d D 1.8 88/05/08 10:33:27 shimizu 8 7c for URaid modifyes 00121/00011/00744d D 1.7 88/05/05 10:52:49 shimizu 7 6c First modify for URAIDes 00120/00140/00635d D 1.6 88/05/01 23:49:43 masinter 6 5c add more error checking so stack dump won't loopes 00002/00002/00773d D 1.5 88/03/13 14:39:14 hayata 5 4c Add SCCS key ides 00000/00000/00775d D 1.4 88/03/13 14:30:53 hayata 4 3c Add SCCS key id (%Z%)es 00000/00002/00775d D 1.3 88/03/03 14:00:04 krivacic 3 2c CurrentFX to CURRENTF\es 00000/00000/00777d D 1.2 88/03/03 12:05:28 krivacic 2 1c Removed global CurrentFX to use CURRENTFX = PVAR - FRAMESIZEes 00777/00000/00000d D 1.1 88/03/03 11:55:24 krivacic 1 0c datee and time created 88/02/24 16:56:37 by hayataeuUtTI 1D 3/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 3I 3D 5/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 5I 5D 8/* This is G-file @(#) eval.c Version 1.4 (3/31/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) eval.c	1.4 3/31/88";E 8I 8/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 8E 5E 3/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther :  Takeshi Shimizu	** ADOPTED NEW VERSION * *//******************************************************************//*		File Name :	eval.c		Including :	OP_eval		Created :	May 9, 1987 take		Changed :	May 11, 1987 take				MAY 18, 1987 TAKE				May 22, 1987 take				May 25, 1987 take				Aug 12, 1987 take				Aug 28, 1987 take				Sep 18, 1987 take				NOV 13, 1987 TAKE(simpleSTKCHK)				Nov 17, 1987 Take(macro Call_EVALFORM)				Nov 25, 1987 Take(EVALFORM_STKMIN)					Takeshi Shimizu*//******************************************************************/#include "lispemul.h"#include "lispmap.h"#include "initatoms.h"#include "lisptypes.h"#include "address68k.h"#include "address.h"#include "stack.h"#include "emulglobal.h"#include "lispglobal.h"#include "cell.h"struct frame_evalform {		DLword bf_flags ;		DLword ivar;		struct frameex1 fx;		LispPTR pvar[6];	} Frame_evalform ;D 11struct frame_evalform *ScratchPTR;E 11I 11/**struct frame_evalform *ScratchPTR;**/E 11struct fnhead *EVALFORM_obj;D 5#define EVALFORM_STKMIN 66  /* 64 + STK_SAFE */E 5I 5#define EVALFORM_STKMIN 66  /* 64 + STK_SAFE for Lyric */E 5I 5#ifdef TRADSTACKOVERE 5D 11#define Call_EVALFORM { \E 11I 11#define Call_EVALFORM { register struct frame_evalform *ScratchPTR;\E 11D 2 CurrentFX->nextblock = LADDR_from_68k(CurrentStackPTR) + 2 /* +1 */; \ IVar =(DLword *) Addr68k_from_LADDR((CurrentFX->nextblock|STK_OFFSET)) ; \E 2I 2 CURRENTFX->nextblock = LADDR_from_68k(CurrentStackPTR) + 2 /* +1 */; \ IVar =(DLword *) Addr68k_from_LADDR((CURRENTFX->nextblock|STK_OFFSET)) ; \E 2 PushCStack ; \ PushStack(NIL_PTR); \ /** ScratchPTR = (struct frame_evalform *)(CurrentStackPTR +1); **/\  ScratchPTR = (struct frame_evalform *)(CurrentStackPTR +2); \ *ScratchPTR =  Frame_evalform ; /* copy cached contents */ \D 2 CurrentFX->pc = ((unsigned int)PC - (unsigned int)FuncObj)+1 ; \E 2I 2 CURRENTFX->pc = ((unsigned int)PC - (unsigned int)FuncObj)+1 ; \E 2 if ( (unsigned int)(CurrentStackPTR + EVALFORM_STKMIN) >=  (unsigned int)StkLimO  ) \ { \   /** printf(" STKOVER in \EVALFORM call \n"); **/ \   TopOfStack = ATOM_EVALFORM ;\D 4   FnStkOvr(2,0);\   return ;\E 4I 4   DOSTACKOVERFLOW(2,0);\E 4 } \ FuncObj=EVALFORM_obj ; \ ScratchPTR->fx.alink = LOLOC(LADDR_from_68k(PVar)); \D 2 ScratchPTR->ivar = CurrentFX->nextblock; \E 2I 2 ScratchPTR->ivar = CURRENTFX->nextblock; \E 2 PVar = (DLword *)(&(ScratchPTR->pvar[0])) ; \/** CurrentStackPTR=(DLword *)( PVar + 13 ); **/\ CurrentStackPTR=(DLword *)( PVar + 12 ); \D 2 CurrentFX =(struct frameex1 *) (PVar - FRAMESIZE) ; \E 2 /* Set PC points \EVALFORM Function's first OPCODE */ \ PC = (ByteCode *)FuncObj + FuncObj->startpc ; }D 5 E 5/*** This macro updated on 7-OCT-87 by take */I 5#elseD 11#define Call_EVALFORM { \E 11I 11#define Call_EVALFORM { register struct frame_evalform *ScratchPTR;\E 11 CURRENTFX->nextblock = LADDR_from_68k(CurrentStackPTR) + 2 /* +1 */; \ IVar =(DLword *) Addr68k_from_LADDR((CURRENTFX->nextblock|STK_OFFSET)) ; \ PushCStack ; \ PushStack(NIL_PTR); \D 6 /** ScratchPTR = (struct frame_evalform *)(CurrentStackPTR +1); **/\  ScratchPTR = (struct frame_evalform *)(CurrentStackPTR +2); \ *ScratchPTR =  Frame_evalform ; /* copy cached contents */ \ CURRENTFX->pc = ((unsigned int)PC - (unsigned int)FuncObj)+1 ; \E 6 if ( (unsigned int)(CurrentStackPTR + EVALFORM_STKMIN) >=  (unsigned int)StkLimO  ) \ { \   DOSTACKOVERFLOW(2,0);\ } \I 6  ScratchPTR = (struct frame_evalform *)(CurrentStackPTR +2); \ *ScratchPTR =  Frame_evalform ; /* copy cached contents */ \ CURRENTFX->pc = ((unsigned int)PC - (unsigned int)FuncObj)+1 ; \E 6 FuncObj=EVALFORM_obj ; \ ScratchPTR->fx.alink = LOLOC(LADDR_from_68k(PVar)); \ ScratchPTR->ivar = CURRENTFX->nextblock; \ PVar = (DLword *)(&(ScratchPTR->pvar[0])) ; \D 6/** CurrentStackPTR=(DLword *)( PVar + 13 ); **/\E 6 CurrentStackPTR=(DLword *)( PVar + 12 ); \ /* Set PC points \EVALFORM Function's first OPCODE */ \ PC = (ByteCode *)FuncObj + FuncObj->startpc ; }D 6/*** This macro added on 12-APR-88 by take */E 6#endifE 5/******************************************************************//*	Func Name  :	OP_eval	Created :		May 7, 1987 take	Changed :	May 25 1987 take			Aug 12 1987 take(Don't depend on PROT)*//******************************************************************/OP_eval(){ LispPTR scratch; register LispPTR work ;I 7 register LispPTR lookuped; /* keep looked up value */E 7#ifdef DEBUG	struct frameex1 *tmpFX;D 2	extern struct frameex1 *CurrentFX ;E 2D 2	tmpFX = CurrentFX ;E 2I 2	tmpFX = CURRENTFX ;E 2#endif#ifdef TRACE	printPC();	printf("TRACE: OP_eval() \n");	print(TopOfStack);#endif  switch(TopOfStack & 0x0ff0000) {   case S_POSITIVE :   case S_NEGATIVE :	PC++;			return; 			break;   case ATOMS_OFFSET :	if((TopOfStack==NIL_PTR)||(TopOfStack==ATOM_T))			{				PC++;				return ;			}D 2			newframe(CurrentFX,&scratch,LOLOC(TopOfStack)) ;E 2I 2			newframe(CURRENTFX,&scratch,LOLOC(TopOfStack)) ;E 2			work = ((scratch & 0xffff0000)>> 16) | ((scratch & 0x00ff) <<16) ;D 7			TopOfStack =E 7I 7			lookuped =E 7			  *((LispPTR *)(Addr68k_from_LADDR(work)));D 7			if(TopOfStack==NOBIND_PTR)E 7I 7			if(lookuped==NOBIND_PTR)E 7			 {			   ufn(054);			   return;			 }I return;	}	else if(compare_chars(pname , "KEYWORD", len) == T)	{		printf(":");		return;	}	else if(compare_chars(pname , "COMPILER", len) == T)	{		printf("XCLC:");		return;	}	else	{		while(len >0){			 putchar(*pname++);			 len-- ;		}I 8		putchar(':');E 8		return;	}}/***print_package_name end */E 7/*************************************************************//*		Func :	dump_dtd*//************************************************************/dump_dtd(){ extern DLword *DTDspace ;  struct dtd *dtdp ; DLword cnt ; dtdp = (struct dtd *)DTDspace ;dtdp++;for (cnt = 0 ; cnt < INIT_TYPENUM ; cnt ++) {	printf("DTD[ %d ] for ",cnt+1);	print_atomname(dtdp->dtd_name);	putchar('\n');	printf("    dtd_name = %d \n",dtdp->dtd_name);	printf("    dtd_size = %d \n",dtdp->dtd_size);	printf("    dtd_free = %d \n",dtdp->dtd_free);	printf("    dtd_obsolate = %d \n",dtdp->dtd_obsolate);	printf("    dtd_finalizable = %d \n",dtdp->dtd_finalizable);	printf("    dtd_lockedp = %d \n",dtdp->dtd_lockedp);	printf("    dtd_hunkp = %d \n",dtdp->dtd_hunkp);	printf("    dtd_gctype = %d \n",dtdp->dtd_gctype);	printf("    dtd_descrs = %d \n",dtdp->dtd_descrs);	printf("    dtd_typespecs = %d \n",dtdp->dtd_typespecs);	printf("    dtd_ptrs = %d \n",dtdp->dtd_ptrs);	printf("    dtd_oldcnt = %d \n",dtdp->dtd_oldcnt);	printf("    dtd_cnt0 = %d \n",dtdp->dtd_cnt0);	printf("    dtd_nextpage = %d \n",dtdp->dtd_nextpage);	printf("    dtd_typeentry = %x \n",dtdp->dtd_typeentry);	printf("    dtd_supertype = %d \n",dtdp->dtd_supertype);	dtdp++;  }} /* end dump dtd *//********************************//*    It prints the type number which associated by 68kptr*/check_type_68k(type,ptr) LispPTR *ptr ;{ if (type != (GetTypeNumber(LADDR_from_68k(ptr)) ) )  {  printf("Mismatching occur !!! LispAddr 0x%x  type %d  \n",LADDR_from_68k(ptr)	  ,type);  exit(-1);  }  printf("LispPTR 0x%x is the datatype %d \n", LADDR_from_68k(ptr)      ,GetTypeNumber(LADDR_from_68k(ptr)) );}/****************************************//** return type num ******/type_num(lispptr) LispPTR lispptr;{  int type;  type = GetTypeNumber(lispptr);  printf("LispPTR 0x%x is datatype %dth \n",lispptr,type);  return(type);}/******************************//* DUMP conspage prog.*//*****************************/dump_conspage(base , linking ) struct conspage *base; /* target conspage address */ int linking ;  /* look for chaiing conspage ? T/NIL */{ ConsCell *cell ; int  i;lp:	printf("conspage at 0x%x(lisp) has %d free cells , next available cell offset is %d ,and next page is 0x%x(lisp) \n",LADDR_from_68k(base),(0xff & base->count),(0xff & base->next_cell), base->next_page );		for( i = 0 , cell = (ConsCell *)base+1; i <127 ; i++,cell++)	 {		printf(" LADDR : %d = Cell[ %d ]## cdr_code= %d ,car = %d \n"		,LADDR_from_68k(cell),i+1,cell->cdr_code,cell->car_field);	 }	if ((linking==T) && (base->next_page != NIL_PTR))	{		base =(struct conspage *) Addr68k_from_LPAGE(base->next_page) ;		goto lp ;	}} /* end dump_conspage *//*********************************//* trace the link in ListpDTD->dtd_nextpage */trace_listpDTD(){extern struct dtd *ListpDTD ; printf("Dump conspages from ListpDTD chain \n"); dump_conspage(Addr68k_from_LPAGE(ListpDTD->dtd_nextpage) , T);}/*************************************/a68k( lispptr)LispPTR lispptr;{  printf("68k: 0x%x (%d) \n",Addr68k_from_LADDR(lispptr),Addr68k_from_LADDR(lispptr));}laddr(addr68k)DLword *addr68k ;{ printf("LADDR : 0x%x (%d)\n",LADDR_from_68k(addr68k),LADDR_from_68k(addr68k));}/*************************************************************//* dump_fnobj(index) */#define DUMPSIZE 40dump_fnobj(index)LispPTR index ; /* atom index */{  struct fnhead *fnobj;  DefCell *defcell68k;  LispPTR cell;  DLbyte *scratch; int i;  defcell68k = (DefCell *)GetDEFCELL68k(index); fnobj = (struct fnhead *)Addr68k_from_LADDR(defcell68k->defpointer); /* check if it's the same index ??*/ if (index != (fnobj->framename)) {	printf("DEFCELL says it is ");	print_atomname(index);	printf("\n But Func OBJ says ");	print_atomname(fnobj->framename);	putchar('\n');	return;   } printf("***DUMP Func Obj << "); printf("start at 0x%x lisp address(0x%x 68k) \n",LADDR_from_68k(fnobj),fnobj); print_atomname(index); putchar('\n'); printf("stkmin    : %d \n",fnobj->stkmin); printf("na        : %d \n",fnobj->na); printf("pv        : %d \n",fnobj->pv); printf("startpc   : %d \n",fnobj->startpc); printf("argtype   : %d \n",fnobj->argtype); printf("framename : %d \n",fnobj->framename); printf("ntsize    : %d \n",fnobj->ntsize); printf("nlocals   : %d \n",fnobj->nlocals); printf("fvaroffset: %d \n",fnobj->fvaroffset);scratch= (DLbyte *)fnobj;for (i= 20; i<(fnobj->startpc); i+=2){printf(" 0x%x(0x%x 68k): 0%o \n",LADDR_from_68k(scratch),scratch,(int)(0xffff & (*((DLword *)(scratch+i)))) );}scratch= (DLbyte *)fnobj + (fnobj->startpc);for (i= 0 ; i< DUMPSIZE; i++,scratch++){printf(" 0x%x(0x%x 68k): 0%o \n",LADDR_from_68k(scratch),scratch,(int)(0xff & (*scratch)) );}} /*dump_fnobj end *//*********************************************************************/ struct doko {  	LispPTR func ;	int     pc ;};struct doko doko(){  struct doko tmp;   printf(" At ");   print_atomname(FuncObj->framename);   putchar('\n');   printf("   PC cnt = 0%o \n" ,tmp.pc=((int)(PC)- (int)FuncObj) );   tmp.func= FuncObj->framename;   return(tmp);}/**** dump specified area (in 32 bit width) ***/dumpl(laddr) LispPTR laddr ;{  int i ;  LispPTR *ptr ;  ptr = (LispPTR *)Addr68k_from_LADDR(laddr);   for(i=0 ; i< 40 ; i++,ptr++)	printf("LADDR 0x%x : %d \n",LADDR_from_68k(ptr),*ptr);}/**** dump specified area (in 16 bit width) ***/dumps(laddr) LispPTR laddr ;{  int i ;  DLword *ptr ;  ptr = (DLword *)Addr68k_from_LADDR(laddr);   for(i=0 ; i< 40 ; i++,ptr++)	printf("LADDR 0x%x : %d \n",LADDR_from_68k(ptr),((*ptr)& 0xffff));}/***********************/printPC(){ unsigned short pc; pc =(int)PC - (int)FuncObj ;printf("PC: O%o ",pc);}/***************************/countchar(string)char *string;{ int cnt=0;while(*string != '\0'){ string++;cnt++;}  return(cnt);}/****************//****************************************************************//***************************************************************//*	Func Name :	dump_stackframe	Desc :		For Debugging AidsD 6D 11E 11E 6	Changed 	8 JUN 1987 TAKE*//***************************************************************/dump_stackframe( fx_addr68k )  struct frameex1 *fx_addr68k ;{  Bframe *bf;D 6D 11  DLword *next68k ;  DLword *ptr ; LispPTR atomindex ;E 11E 6 if((fx_addr68k->alink & 1)==0)  {   /* FAST */ 	bf = (Bframe *)(((DLword *)fx_addr68k)  - 2 );    }  else  {   /* SLOW */	bf =(Bframe *) Addr68k_from_LADDR((fx_addr68k->blink+ STK_OFFSET)) ;  }I 11  dump_bf(bf);  dump_fx(fx_addr68k);}E 11I 6  dump_bf(bf);  dump_fx(fx_addr68k);}E 6D 6D 11/* Print IVARs */  printf("IVAR -------\n");E 11E 6D 6D 11  ptr = Addr68k_from_LADDR( STK_OFFSET + bf->ivar); while(ptr!=(DLword *)bf)E 11I 11dump_bf(bf)  Bframe *bf;E 11E 6I 6dump_bf(bf)  Bframe *bf;E 6{D 6D 11  printf(" %x : %x \n",LADDR_from_68k(ptr),*ptr);  ptr++;} printf("## STACK BF at 0x%x ## \n",(LispPTR)LADDR_from_68k(bf));/* print BF  */ if(bf->flags != 4)	printf("Invalid frame,NOT BX \n"); putchar('[');  if (bf->residual)	printf("Res, ");  if (bf->padding)	printf("Pad, ");  printf("cnt=%d ]\n",bf->usecnt);  printf("ivar : 0x%x \n",bf->ivar);E 11I 11  DLword *ptr ;  printf("\n*** Basic Frame");  if (bf->flags != 4)    {printf("\nInvalid basic frame"); return(0);};E 11E 6I 6  DLword *ptr ;  printf("\n*** Basic Frame");  if (bf->flags != 4)    {printf("\nInvalid basic frame"); return(0);};E 6D 6D 11    printf(">> Bf's ivar says 0x%x vs. IVar says 0x%x \n",bf->ivar+STK_OFFSET,LADDR_from_68k(IVar));E 11I 11  if (bf->residual) {goto printflags;}E 11E 6I 6  if (bf->residual) {goto printflags;}E 6I 11  ptr = Addr68k_from_LADDR( STK_OFFSET + bf->ivar);  if ( (((DLword*)bf - ptr) > 512) || (( (int)ptr & 1) != 0) )    {printf("\nInvalid basic frame"); return(0);};  while(ptr < (DLword *)bf)  {    printf("\n %x : %x %x",LADDR_from_68k(ptr),*ptr, *(ptr+1));    print(*ptr);    ptr+=2;  }E 11I 6  ptr = Addr68k_from_LADDR( STK_OFFSET + bf->ivar);  if ( (((DLword*)bf - ptr) > 512) || (( (int)ptr & 1) != 0) )    {printf("\nInvalid basic frame"); return(0);};  while(ptr < (DLword *)bf)  {    printf("\n %x : %x %x",LADDR_from_68k(ptr),*ptr, *(ptr+1));    print(*ptr);    ptr+=2;  }E 6D 6D 11  atomindex = get_framename(fx_addr68k);  printf("Fname is ");  print_atomname(atomindex);  printf("\n");E 11I 11printflags:    printf("\n %x : %x %x ",LADDR_from_68k(bf),*bf, *(bf+1));    putchar('[');    if (bf->residual)	printf("Residual, ");    if (bf->padding)	printf("Padded, ");    printf("usecnt=%d ] ",bf->usecnt);    printf("ivar : 0x%x",bf->ivar);E 11E 6I 6printflags:    printf("\n %x : %x %x ",LADDR_from_68k(bf),*bf, *(bf+1));    putchar('[');    if (bf->residual)	printf("Residual, ");    if (bf->padding)	printf("Padded, ");    printf("usecnt=%d ] ",bf->usecnt);    printf("ivar : 0x%x",bf->ivar);E 6D 6D 11/***** printout FX ****/  printf("## STACK FX at 0x%x ## \n",LADDR_from_68k(fx_addr68k));E 11I 11}E 11E 6I 6}E 6I 11dump_fx( fx_addr68k)  struct frameex1 *fx_addr68k ;{  DLword *next68k ;  DLword *ptr ;  LispPTR atomindex ;  ptr = (DLword *)fx_addr68k;E 11I 6dump_fx( fx_addr68k)  struct frameex1 *fx_addr68k ;{  DLword *next68k ;  DLword *ptr ;  LispPTR atomindex ;  ptr = (DLword *)fx_addr68k;E 6  if(fx_addr68k->flags != 6)D 6D 11    printf("Invalid frame,NOT FX \n");E 11I 11   {printf("\nInvalid frame,NOT FX"); return(0);};E 11E 6I 6   {printf("\nInvalid frame,NOT FX"); return(0);};E 6I 11  atomindex = get_framename(fx_addr68k);  printf("\n*** Frame Extension for ");  print(atomindex);  printf("\n %x : %x %x ",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 11I 6  atomindex = get_framename(fx_addr68k);  printf("\n*** Frame Extension for ");  print(atomindex);D 7E 7  printf("\n %x : %x %x ",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 6 putchar('[');  if(fx_addr68k->fast)		printf("F,");  if(fx_addr68k->incall)	printf("incall, ");  if(fx_addr68k->validnametable)	printf("V, ");D 6D 11  printf("cnt = %d ]\n",fx_addr68k->usecount);  printf(" #alink           0x%x ",fx_addr68k->alink);E 11I 11  printf("usecnt = %d]; alink",fx_addr68k->usecount);E 11E 6I 6  printf("usecnt = %d]; alink",fx_addr68k->usecount);E 6  if(fx_addr68k->alink & 1)D 6D 11  printf("[SLOWP] \n");  else printf("\n");E 11I 11  printf("[SLOWP]");E 11E 6I 6  printf("[SLOWP]");E 6D 6D 11  printf(" fnheadlo        0x%x \n",fx_addr68k->lofnheader);  printf(" hi1,hi2 fnhead  0x%x , 0x%x \n",fx_addr68k->hi1fnheader,fx_addr68k->hi2fnheader);  printf(" nextblock       0x%x \n",fx_addr68k->nextblock);  printf(" pc              0x%x \n",fx_addr68k->pc);  printf(" lonametbl       0x%x \n",fx_addr68k->lonametable);  printf(" hi1,hi2 nametbl 0x%x , 0x%x  \n",fx_addr68k->hi1nametable,fx_addr68k->hi2nametable);  printf(" #blink           0x%x \n",fx_addr68k->blink);  printf(" #clink           0x%x \n",fx_addr68k->clink);E 11E 6I 11  ptr+=2;  printf("\n %x : %x %x fnheadlo, fnheadhi\n",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 11I 6  ptr+=2;  printf("\n %x : %x %x fnheadlo, fnheadhi\n",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 6D 6D 11 if (fx_addr68k ==CURRENTFX) { 	ptr=PVar;	while(ptr <(CurrentStackPTR+2))	{		printf(" %x : %x \n",LADDR_from_68k(ptr),*ptr);		ptr++;	}  printf("this frame is last !! \n");  return(-1); }E 11I 11  ptr+=2;  printf("\n %x : %x %x next,     pc\n",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 11E 6I 6  ptr+=2;  printf("\n %x : %x %x next,     pc\n",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 6I 11  ptr+=2;  printf("\n %x : %x %x LoNmTbl,  HiNmTbl\n",LADDR_from_68k(ptr),*ptr, *(ptr+1));  ptr+=2;  printf("\n %x : %x %x #blink,   #clink\n",LADDR_from_68k(ptr),*ptr, *(ptr+1));/* should pay attention to the name table like RAID does */E 11I 6  ptr+=2;  printf("\n %x : %x %x LoNmTbl,  HiNmTbl\n",LADDR_from_68k(ptr),*ptr, *(ptr+1));  ptr+=2;  printf("\n %x : %x %x #blink,   #clink\n",LADDR_from_68k(ptr),*ptr, *(ptr+1));/* should pay attention to the name table like RAID does */E 6 next68k = (DLword *)Addr68k_from_LADDR((fx_addr68k->nextblock+STK_OFFSET)) ;D 6D 11 ptr =(DLword *)(fx_addr68k+1) ;E 11I 11 if (fx_addr68k == CURRENTFX) {next68k = CurrentStackPTR + 2;}E 11E 6I 6 if (fx_addr68k == CURRENTFX) {next68k = CurrentStackPTR + 2;}E 6I 11 if ((next68k < ptr) || (((int)next68k & 1) != 0) )    {printf ("\nNext block invalid") ; return(0);}E 11I 6 if ((next68k < ptr) || (((int)next68k & 1) != 0) )    {printf ("\nNext block invalid") ; return(0);}E 6  while(next68k > ptr)  {D 6D 11    printf(" %x : %x \n",LADDR_from_68k(ptr),*ptr);    ptr++;E 11I 11  ptr+=2;  printf("\n %x : %x %x",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 11E 6I 6  ptr+=2;  printf("\n %x : %x %x",LADDR_from_68k(ptr),*ptr, *(ptr+1));E 6  }return (0);D 6D 11} /* end dump_stackframe */E 11I 11} /* end dump_fx */E 11E 6I 6} /* end dump_fx */E 6dump_CSTK(before)int before;{  DLword *ptr ; ptr= CurrentStackPTR - before ;while(ptr != CurrentStackPTR){D 6D 11	printf(" 0x%x : 0x%x \n",LADDR_from_68k(ptr),*ptr);E 11I 11	printf("\n%x : %x ",LADDR_from_68k(ptr),*ptr);E 11E 6I 6	printf("\n%x : %x ",LADDR_from_68k(ptr),*ptr);E 6	ptr++;}D 6D 11printf("CurrentSTKP : 0x%x  \n",LADDR_from_68k(CurrentStackPTR));printf("contents :  0x%x \n",*((LispPTR *)(CurrentStackPTR-1)));E 11I 11printf("\nCurrentSTKP : %x  ",LADDR_from_68k(CurrentStackPTR));printf("\ncontents :  %x ",*((LispPTR *)(CurrentStackPTR-1)));E 11E 6I 6printf("\nCurrentSTKP : %x  ",LADDR_from_68k(CurrentStackPTR));printf("\ncontents :  %x ",*((LispPTR *)(CurrentStackPTR-1)));E 6}/* dump_CSTK end *//******************************************//* BTV */btv(){    struct frameex1 *fx_addr68k;  LispPTR atomindex ; struct frameex1 *get_nextFX();  fx_addr68k = CURRENTFX ;D 6D 11  atomindex = get_framename(fx_addr68k);E 11I 11loop:  dump_stackframe(fx_addr68k);  if( fx_addr68k->alink == 0 )      {printf ("\n BTV end"); return(0);};E 11E 6I 6loop:  dump_stackframe(fx_addr68k);  if( fx_addr68k->alink == 0 )      {printf ("\n BTV end"); return(0);};E 6D 6D 11 while(atomindex != ATOM_T)  {	dump_stackframe(fx_addr68k);	fx_addr68k= get_nextFX(fx_addr68k);	atomindex = get_framename(fx_addr68k);  } /* dump T frame */ dump_stackframe(fx_addr68k); printf("\n BTV end ********\n");E 11I 11   fx_addr68k= get_nextFX(fx_addr68k);   goto loop;E 11E 6I 6   fx_addr68k= get_nextFX(fx_addr68k);   goto loop;E 6} /*end btv*/  get_framename(fx_addr68k)  struct frameex1 *fx_addr68k ;{  struct fnhead *fnheader;  LispPTR scratch ;/* Get FNHEAD */  if(fx_addr68k->validnametable==0) {	scratch = (unsigned int)fx_addr68k->hi2fnheader << 16 ;	scratch |= (unsigned int)(fx_addr68k->lofnheader) ;	fnheader = (struct fnhead *)Addr68k_from_LADDR(scratch ) ;    }  else {	scratch = (unsigned int)(fx_addr68k->hi2nametable << 16);	scratch |= (unsigned int) (fx_addr68k->lonametable);	fnheader = (struct fnhead *)Addr68k_from_LADDR( scratch );    }   return(fnheader->framename);}/* get_framename end */ /**********************************************************************/D 7D 11 struct frameex1 *get_nextFX(fx_addr68k)  struct frameex1 *fx_addr68k;E 11I 11 FX *get_nextFX(fx)  FX *fx;E 11E 7I 7 FX *get_nextFX(fx)  FX *fx;E 7{ DLword *pv ;D 7D 11 if(fx_addr68k->alink & 1)   pv = (DLword *)Addr68k_from_LADDR((STK_OFFSET | (fx_addr68k->alink -1))); else pv = (DLword *)Addr68k_from_LADDR((STK_OFFSET | fx_addr68k->alink)); return((struct  frameex1 *)(pv - FRAMESIZE));E 11I 11 if(URaid_scanlink==URSCAN_ALINK) 	return((FX *)Addr68k_from_StkOffset(GETALINK(fx))); else 	return((FX *)Addr68k_from_StkOffset(GETCLINK(fx)));E 11E 7I 7 if(URaid_scanlink==URSCAN_ALINK) 	return((FX *)Addr68k_from_StkOffset(GETALINK(fx))); else 	return((FX *)Addr68k_from_StkOffset(GETCLINK(fx)));E 7 } /* get_nextFX end *//*************************************************************//***************************/MAKEATOM(string)char *string;{ int length; length = countchar(string);  return(make_atom(string,0,length,0));}/****************/GETTOPVAL(string) char *string;{  int index;  LispPTR *cell68k; index=MAKEATOM(string); cell68k= (LispPTR *)GetVALCELL68k(index);  print(*cell68k);}S_TOPVAL(string) char *string;{  int index;  LispPTR *cell68k; int length; char dummy[256]; dummy[0]='\\';  for(length=1; *string != '\0'; length++,string++)  { dummy[length] = *string;} index=make_atom(dummy,0,length,0); cell68k= (LispPTR *)GetVALCELL68k(index);  print(*cell68k);}/***************/S_MAKEATOM(string) char *string;{  int index=0; int length; char dummy[256]; dummy[0]='\\';  for(length=1; *string != '\0'; length++,string++)  { dummy[length] = *string;} index=make_atom(dummy,0,length,0);  printf("#Atomindex : %d \n",index); return(index);}/****************************************************************************/D 11/*     all_stack_dump(start,end)  E 11I 11/*     	Func Name : all_stack_dump(start,end)  	All Stack Walker(sequentialy)	By TAKESHIE 11*/I 11/****************************************************************************/E 11typedef struct stack_header {	unsigned	flags1 : 3;	unsigned	flags2  : 5;		unsigned	usecount : 8 ; } STKH ;I 11#define SDMAXLINE 40#define SD_morep	if(++SD_lines>SDMAXLINE){\			 printf("Press Return:"); getchar();fflush(stdin);SD_lines=0;}E 11I 11E 11all_stack_dump(start,end,silent) DLword start,end ,silent; /* Stack offset in DLword */{  STKH *stkptr;D 10D 11  DLword *start68k,*end68k;E 11I 11  DLword *start68k,*end68k,*org68k;E 11E 10I 10  DLword *start68k,*end68k,*org68k;E 10  DLword size,dummy;D 11 extern IFPAGE *InterfacePage;E 11I 11  int SD_lines=0;  extern IFPAGE *InterfacePage;E 11 if(start==0) start68k= Stackspace + InterfacePage->stackbase; else start68k = Addr68k_from_LADDR(STK_OFFSET | start) ; if(end==0) end68k= Stackspace+ InterfacePage->endofstack; else end68k = Addr68k_from_LADDR(STK_OFFSET | end) ; stkptr= (STKH *)start68k;  while(((DLword*)stkptr) < end68k )  {	dummy = LADDR_from_68k(stkptr);	switch (stkptr->flags1 ) {D 6D 11E 11I 11	case STK_GUARD :E 11E 6I 6	case STK_GUARD :E 6	case STK_FSB :D 6D 11			if(((stkptr->flags2 !=0) || (stkptr->usecount!=0))			 ||((dummy %2)!=0) || (*((DLword *)stkptr) == 0xffff))			{if(!silent)putchar('-');((DLword *)stkptr)++; break;}E 11I 11			size = FSB_size(stkptr);			if(size <=0 || size > ((DLword*)end68k-(DLword*)stkptr))			 {goto badblock;};			if(stkptr->flags1 == STK_GUARD)			printf("\n<<  0x%x GUARD size : 0x%x >>",LADDR_from_68k(stkptr),size );			else printf("\n<<  0x%x FSB size : 0x%x >>",LADDR_from_68k(stkptr),size);			SD_morep;E 11E 6I 6D 10			if( (stkptr->flags2 !=0) || (stkptr->usecount!=0) )				{goto badblock;};E 6			size = *(((DLword *)stkptr) +1) ;E 10I 10			size = FSB_size(stkptr);E 10D 6D 11			if(size==0)			 {	if(!silent)putchar('+');				stkptr++; break;}			printf("\n<<  0x%x FSB size : 0x%x >>\n",LADDR_from_68k(stkptr),size);E 11I 11	checksize:			if(size <=0 || size > ((DLword*)end68k-(DLword*)stkptr))			 {goto badblock;};E 11			((DLword *)stkptr) += size;D 11E 11			break ;D 11	case STK_GUARD :			if(((stkptr->flags2 !=0) ||(stkptr->usecount!=0))			||((dummy %2)!=0) || (*((DLword *)stkptr)== 0xffff))			 {	if(!silent)putchar('>');				((DLword *)stkptr)++; break;}E 6I 6			if(size <=0 || size > ((DLword*)end68k-(DLword*)stkptr))			 {goto badblock;};			if(stkptr->flags1 == STK_GUARD)			printf("\n<<  0x%x GUARD size : 0x%x >>",LADDR_from_68k(stkptr),size );			else printf("\n<<  0x%x FSB size : 0x%x >>",LADDR_from_68k(stkptr),size);E 6			size = *(((DLword *)stkptr) +1) ;D 6			if(size==0)			 {	if(!silent)putchar('?');				((DLword *)stkptr)++; break;}			printf("\n<<  0x%x GUARD size : 0x%x >>\n",LADDR_from_68k(stkptr),size );E 6I 6	checksize:			if(size <=0 || size > ((DLword*)end68k-(DLword*)stkptr))			 {goto badblock;};E 6			((DLword *)stkptr) += size;D 6E 6			break ;D 6E 11E 6	case STK_FX :	D 6D 11			if((((FX *)stkptr)->pc ==0)|| (((FX *)stkptr)->pc < 24) || (((FX *)stkptr)->alink==0)  || (stkptr->usecount > 31)) {if(!silent) putchar('~');((DLword *)stkptr)++; break;}			 /******			if(((dummy+FRAMESIZE) % 4) != 0) {if(!silent) putchar('!');((DLword *)stkptr)++; break;} ** 18 Nov*/			if(!silent)putchar('\n');			printf("<<  0x%x: FX for ",LADDR_from_68k(stkptr));			print_atomname(get_framename(stkptr));			printf(" >> \n");E 11I 11			/**if((((FX *)stkptr)->pc < 24) || 				(((FX *)stkptr)->alink==0)  ||					 (stkptr->usecount > 31))				 {goto badblock;};**/			if (silent)			{SD_morep;			 printf("\n<<  0x%x: FX for ",LADDR_from_68k(stkptr));			 print(get_framename(stkptr));			 printf(" ["); 			 if(((FX *)stkptr)->fast)	printf("fast,"); 			 if(((FX *)stkptr)->incall)	printf("incall,"); 			 if(((FX *)stkptr)->native)	printf("native,"); 			 if(((FX *)stkptr)->validnametable)	printf("valid,"); 			 if(((FX *)stkptr)->nopush)	printf("nopush,"); 			 printf("]");			 printf(" cnt=%d",stkptr->usecount);			 }			else {dump_fx(stkptr);}E 11E 6I 6			if((((FX *)stkptr)->pc < 24) || 				(((FX *)stkptr)->alink==0)  ||					 (stkptr->usecount > 31))				 {goto badblock;};			if (silent)			{			 printf("\n<<  0x%x: FX for ",LADDR_from_68k(stkptr));			 print(get_framename(stkptr));			 printf(" ["); 			 if(((FX *)stkptr)->incall)	printf("incall,"); 			 if(((FX *)stkptr)->native)	printf("native,");D 10 			 printf("]"); }E 10I 10 			 printf("]");			 printf(" cnt=%d",stkptr->usecount);			 }E 10			else {dump_fx(stkptr);}E 6D 6D 11			if(!silent){			printf("  [");			if(((FX *)stkptr)->fast)		printf("F,"); 			if(((FX *)stkptr)->incall)	printf("incall,");  			if(((FX *)stkptr)->validnametable)	printf("V,"); 			printf("cnt = %d ]\n",((FX *)stkptr)->usecount);			printf("  #alink   0x%x ",((FX *)stkptr)->alink); 			if(((FX *)stkptr)->alink & 1) 			 printf("[SLOWP] \n");  			else printf("\n");			printf(" nextblock 0x%x \n",((FX *)stkptr)->nextblock);			printf("  #blink   0x%x \n",((FX *)stkptr)->blink);				printf("  #clink   0x%x \n",((FX *)stkptr)->clink);			} E 11E 6			if((FX *)stkptr == CURRENTFX) {D 6D 11			((DLword *)stkptr) += FRAMESIZE ;			break; }E 11I 11				printf("***current***");				size= EndSTKP - (DLword*)stkptr ;			}E 11E 6I 6				printf("***current***");				size= EndSTKP - (DLword*)stkptr ;			}E 6			else {D 6D 11			stkptr=Addr68k_from_LADDR(STK_OFFSET| ((FX *)stkptr)->nextblock) ;			break;}E 11I 11			size = (Addr68k_from_LADDR(STK_OFFSET| ((FX *)stkptr)->nextblock) - (DLword*)stkptr);E 11E 6I 6			size = (Addr68k_from_LADDR(STK_OFFSET| ((FX *)stkptr)->nextblock) - (DLword*)stkptr);E 6D 6D 11	case STK_BF :			if(((Bframe *)stkptr)->ivar == 0)			{ if(!silent)putchar('*');((DLword *)stkptr)++; break;}			if(!silent)putchar('\n');E 11I 11			};			goto checksize;E 11E 6I 6			};			goto checksize;E 6D 6D 11			printf("<<  0x%x: BF ",LADDR_from_68k(stkptr));			if(!silent){			 putchar('[');E 11I 11 	default:	org68k = (DLword*)stkptr;			while (stkptr->flags1 !=STK_BF )			 {				if(stkptr->flags1 != 0) 				{  SD_morep;					printf("\n***Bad DATA on stack :0x%x ",LADDR_from_68k(stkptr));				}				(DLword *)stkptr += DLWORDSPER_CELL;			};			if(((Bframe*)stkptr)->residual)			 {				if((DLword*)stkptr != org68k)					printf("\nResidual has real IVAR 0x%x",LADDR_from_68k(stkptr));			 }			else			 {			   if(((Bframe*)stkptr)->ivar 					!= StkOffset_from_68K(org68k))						printf("\nBF doesn't point TopIVAR 0x%x",LADDR_from_68k(stkptr));			 }			SD_morep;			if(silent)			{			printf("\n<<  0x%x: BF ",LADDR_from_68k(stkptr));			putchar('[');E 11E 6I 6D 10	case 0:	case STK_BF :			while (stkptr->flags1 == 0) {(DLword *)stkptr +=2;};			if (stkptr->flags1 != STK_BF) {goto badblock;};	E 10I 10 	default:	org68k = (DLword*)stkptr;			while (stkptr->flags1 !=STK_BF )			 {				if(stkptr->flags1 != 0) 				{					printf("***Bad DATA on stack :0x%x \n",LADDR_from_68k(stkptr));				}				(DLword *)stkptr += DLWORDSPER_CELL;			};			if(((Bframe*)stkptr)->residual)			 {				if((DLword*)stkptr != org68k)					printf("Residual has real IVAR 0x%x\n",LADDR_from_68k(stkptr));			 }			else			 {			   if(((Bframe*)stkptr)->ivar 					!= StkOffset_from_68K(org68k))						printf("BF doesn't point TopIVAR 0x%x\n",LADDR_from_68k(stkptr));			 }E 10			if(silent)			{			printf("\n<<  0x%x: BF ",LADDR_from_68k(stkptr));			putchar('[');E 6 			if (((Bframe *)stkptr)->residual)	printf("Res,"); 			if (((Bframe *)stkptr)->padding)	printf("Pad,");I 10			printf("cnt=%d",stkptr->usecount);E 10D 6D 11 			printf("cnt=%d ]\n",((Bframe *)stkptr)->usecnt);			printf("ivar : 0x%x \n",((Bframe *)stkptr)->ivar);			} else  putchar('\n');E 11I 11			printf("cnt=%d",stkptr->usecount);			printf("ivar : 0x%x]",((Bframe *)stkptr)->ivar);			} else  dump_bf(stkptr);E 11E 6I 6			printf("ivar : 0x%x]",((Bframe *)stkptr)->ivar);			} else  dump_bf(stkptr);E 6			((DLword *)stkptr) += 2;			break;D 10D 11	default :E 10I 10	E 10D 6			if(!silent) putchar('.');			((DLword *)stkptr)++;E 11I 11		badblock:       SD_morep;			printf("\n<< 0x%x: Invalid, %x %x>>",LADDR_from_68k(stkptr), *stkptr, *(stkptr+1));			((DLword *)stkptr)+=2;E 11E 6I 6	badblock:       printf("\n<< 0x%x: Invalid, %x %x>>",LADDR_from_68k(stkptr), *stkptr, *(stkptr+1));			((DLword *)stkptr)+=2;E 6			break;D 6D 11E 11I 11	E 11E 6I 6	E 6	} /* case end */D 6D 11	E 11I 11E 11E 6I 6E 6  } /* while end */D 11printf("<< That's All , last stack :0x%x >> \n",InterfacePage->endofstack);E 11I 11printf("\n<< That's All , last stack :0x%x >> \n",InterfacePage->endofstack);E 11}/************************************************************/dtd_chain(type) DLword type;{  struct dtd *dtdp;  LispPTR next;  LispPTR *next68k; dtdp=(struct dtd *)GetDTD(type); next=dtdp->dtd_free; next68k=(LispPTR *) Addr68k_from_LADDR(next); while((*next68k) != 0) {  	if(type != GetTypeNumber(next)) {	printf("BAD cell in next dtdfree \n");	  return; }	print(next);	putchar('\n');	next= *next68k;	next68k=(LispPTR *) Addr68k_from_LADDR(next); } printf("That's All !\n");}/*  dtd_chain end **/check_dtd_chain(type) DLword type;{  struct dtd *dtdp;  LispPTR next;  LispPTR *next68k; LispPTR before; dtdp=(struct dtd *)GetDTD(type); if(dtdp->dtd_free==0) {		printf(" Type %d is exhausted.\n",type); 		return;} if(GetTypeNumber(dtdp->dtd_free) != type)   error("BAD cell in dtdfree "); next=dtdp->dtd_free; next68k=(LispPTR *) Addr68k_from_LADDR(next); while((*next68k) != 0) {  	if(type != GetTypeNumber(next)) {	error("BAD cell in next dtdfree ");	  return; }	before = next;	next= *next68k;	next68k=(LispPTR *) Addr68k_from_LADDR(next);	if(*next68k == before) error("CIRCULER founded"); }putchar('.');}/*  cehck_dtd_chain end **/E 1