h42452s 00001/00001/00458d D 2.12 90/03/19 18:29:27 takeshi 16 15c change error msges 00024/00005/00435d D 2.11 90/03/02 21:44:16 sybalsky 15 14c 386 checks, commentses 00000/00000/00440d D 2.10 90/02/06 11:45:59 sybalsky 14 13c GC fixes for VMEMPAGEPses 00059/00008/00381d D 2.9 89/12/29 12:59:20 sybalsky 13 12c Fix VMEMPAGEP reclaimable predicate to allow reclamationes 00015/00002/00374d D 2.8 89/03/30 20:31:35 sybalsky 12 11c byte swapping.es 00000/00070/00376d D 2.7 88/07/31 12:40:30 masinter 11 10c remove extraneous (unused) and buggy code, calls functions not usedes 00009/00000/00437d D 2.6 88/07/08 01:39:55 masinter 10 9c add checks (undef ifdef CHECK) useful for looking for GC bugses 00001/00001/00436d D 2.5 88/07/05 12:40:57 masinter 9 8c make overflow table references by 32 bit arithmetices 00002/00001/00435d D 2.4 88/06/22 19:07:27 masinter 8 7c Fix buffer record to really match Lisp's recordes 00011/00095/00425d D 2.3 88/06/02 13:37:31 masinter 7 6c remove obsolete code, spurious * printout, and -- most important -- extra DELREFes 00014/00009/00505d D 2.2 88/04/18 19:14:25 shimizu 6 5c Fix bug reclaimstackp and commont out decusecount etc.es 00000/00000/00514d D 2.1 88/05/17 09:24:27 hayata 5 4c Version up to 2.1es 00001/00001/00513d D 1.4 88/05/09 21:12:31 shih 4 3c Use GCLOOKUPes 00009/00002/00505d D 1.3 88/03/20 16:47:24 masinter 3 2c merge new gc code for closure cachees 00002/00002/00505d D 1.2 88/03/13 14:48:44 hayata 2 1c Add SCCS key id (%Z%)es 00507/00000/00000d D 1.1 88/02/24 16:57:04 hayata 1 0c date and time created 88/02/24 16:57:04 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 13/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 13I 13D 15/* This is G-file @(#) gcfinalfuncs.c Version 2.8 (3/30/89). copyright Xerox & Fuji Xerox  */static char *id = "@(#) gcfinalfuncs.c	2.8 3/30/89";E 15I 15/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 15E 13E 2D 7/*** ADOPTED NEW VERSION ***/E 7I 13/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 13/*************************************************************************//*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 *//*************************************************************************//*                                                                       *//*                       File Name : gcfinalfuncs.c                      *//*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : Sep-25-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions :                                                 *//*                       reclaimstackp();                                *//*                       reclaimarrayblock(ptr);                         *//*                       reclaimcodeblock() is in another file           *//*                       releasingvmempage();                            *//*			 deleteblock();					 *//*			 linkblock();					 *//*			 mergeforward();				 *//*			 mergebackward();				 *//*			 arrayblockmerger();				 *//*			 checkarrayblock();				 */D 11/*			 refcnt();					 *//*			 gc_lookup_bigrefcnt0();			 */E 11/*			 findptrsbuffer();				 *//*                                                                       *//*                                                                       *//*                                                                       *//*************************************************************************/D 7/*           Descreption :                                               */E 7I 7/*           Description :                                               */E 7/*                                                                       */D 7/*    *//*  */E 7I 7/*  									 */E 7/*                                                                       */D 7/*                                                                       *//*                                                                       *//*                                                                       *//*                                                                       *//*                                                                       *//*                                                                       *//*                                                                       */ /*                                                                       */ /*                                                                       */E 7/*************************************************************************//*                                                               \Tomtom *//*************************************************************************/#include "lispemul.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "stack.h"#include "cell.h"#include "ifpage.h"#include "gc.h"#include "array.h"D 7E 7#define GetSegnuminColl(entry1) ((entry1 & 0x01fe) >> 1)#define GetLinkptr(entry)	(entry & 0x0fffe)#define GetCountinColl(entry1)  ((entry1 & 0x0fc00) >> 10)#define Oddp(num) (((num % 2) != 0)?1:0)#define Evenp(num) 		(((num % 2) != 0)?0:1)#define STK_HI		1	/* This value also */#define WORDSPERCELL	2#define PADDING	4#define Boundp(frame_field)	((frame_field == 0)?1:0)#define min(a,b)		((a > b)?b:a)#define Trailer(ldatum,datum68)	(ldatum+2*(datum68->arlen - \					ARRAYBLOCKTRAILERCELLS))#define BucketIndex(n)		min(integerlength(n),MAXBUCKETINDEX)#define FreeBlockChainN(n)	((0xffffff & *FreeBlockBuckets_word)+ \					2*BucketIndex(n))I 6D 7/**E 6#define GetAlink(frameex)	(Evenp(frameex->alink)?(frameex->alink-10): \					(frameex->alink-11))#define GetBlink(frameex)	(Evenp(frameex->alink)?(( \				   LADDR_from_68k(frameex)-WORDSPERCELL) \			  	 & 0x0ffff) :frameex->blink)#define GetClink(frameex)	(Evenp(frameex->alink)?(frameex->alink-10): \					(frameex->clink-10))I 6**/E 7E 6I 12#ifndef BYTESWAPE 12D 7E 7D 6E 6struct buf {	LispPTR		filepage;	LispPTR		vmempage;	LispPTR		buffernext;D 8	LispPTR		sysnext;E 8	unsigned	noreference :1;	unsigned	usermapped :1;	unsigned	iodirty :1;I 8	unsigned	unused :5;	unsigned	sysnext :24;E 8};I 12#elsestruct buf {	LispPTR		filepage;	LispPTR		vmempage;	LispPTR		buffernext;	unsigned	sysnext :24;	unsigned	unused :5;	unsigned	iodirty :1;	unsigned	usermapped :1;	unsigned	noreference :1;};#endif BYTESWAPE 12/************* The following procedure is common !! **************************/integerlength(n)unsigned int	n;{int	cnt;   if (n <= 2)	return(n);   else     {cnt = 1;      do    	{cnt++;	 n = (n >> 1);	}while(n != 1);      return(cnt);     };}/************* The above procedure is common !! **************************/I 13/************************************************************************//*									*//*			f i n d p t r s b u f f e r			*//*									*//*	Given a pointer to a VMEMPAGEP, see if it is pointed to by	*//*	any BUFFER.  If so, return the BUFFER's pointer. Otherwise,	*//*	return NIL.							*//*									*//************************************************************************/E 13D 7LispPTR findptrsbuffer(ptr,noerror)E 7I 7LispPTR findptrsbuffer(ptr)E 7LispPTR		ptr;D 7DLword		noerror;E 7{ struct buf *bptr;	bptr = (struct buf *)Addr68k_from_LADDR(*System_Buffer_List_word);	while(LADDR_from_68k(bptr) != NIL)	  {if (ptr == bptr->vmempage)		return(LADDR_from_68k(bptr));	   else bptr = (struct buf *)Addr68k_from_LADDR(bptr->sysnext);};D 7	if (noerror == T)	   return(NIL);	else error("not a MAPPAGE pointer.\n");E 7I 7	return(NIL);E 7}I 13/************************************************************************//*									*//*		    r e l e a s i n g v m e m p a g e			*//*									*//*	Called when ptr, a VMEMPAGEP, is about to be reclaimed by the	*//*	GC.  Returns T if it is NOT OK TO RECLAIM THE VMEMPAGEP.	*//*	Otherwise, returns NIL.  It won't be OK to reclaim when		*//*	the VMEMPAGEP is being used as a buffer.			*//*									*//************************************************************************/E 13LispPTR releasingvmempage(ptr)D 13LispPTR ptr;{ struct buf *bptr;D 7  bptr = (struct buf *)Addr68k_from_LADDR(findptrsbuffer(ptr,T));E 7I 7  bptr = (struct buf *)Addr68k_from_LADDR(findptrsbuffer(ptr));E 7  bptr->noreference = T;  return(ATOM_T);}E 13I 13  LispPTR ptr;  {     register struct buf *bptr;    register LispPTR bufferptr = findptrsbuffer(ptr);    if (bufferptr == NIL) return(NIL); /* Not in use, OK to reclaim it */    bptr = (struct buf *)Addr68k_from_LADDR(bufferptr);    bptr->noreference = T; /* Mark the buffer free to use ?? */    return(ATOM_T);  }/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 13D 11unsigned int gc_lookup_bigrefcnt0(ptr)LispPTR			ptr;   { struct gc_ovfl 	*oventry;     LispPTR		tmp;	oventry = (struct gc_ovfl *)HTbigcount;	if (Oddp(LOLOC(ptr)))			/*address adjustment */	   --ptr;	while((tmp = oventry->ovfl_ptr) != ptr)	   { if (tmp == NIL)		   { error(D 7	"ERROR : PTR refcnt previously overflowed,but not found in table.\n");E 7I 7	"GC ERROR: refcnt previously overflowed, but not found in table.\n");E 7			return(MAX_GCCOUNT);		   };		++oventry; /* next entry */	   };D 9	return((unsigned int)VAG2(oventry->ovfl_cnthi,oventry->ovfl_cntlo));E 9I 9	return(oventry->ovfl_cnt);E 9   }unsigned int refcnt(ptr)LispPTR	ptr;   { struct hashentry 	*entry;     struct htlinkptr	*htlptr;     struct htcoll	*link;     unsigned int	cnt;	if ((GetTypeEntry(ptr) & TT_NOREF) != 0) /* MDSTT's NOREF checking */		return(1);	entry = (struct hashentry *)Addr68k_from_LADDR(			LADDR_from_68k(HTmain)+(LOLOC(ptr) >> 1));	htlptr = (struct htlinkptr *)entry;	if (htlptr->contents == 0)			/* no entry */		return(1);	else if (entry->collision) 			/* scan the linkage */		{ link=(struct htcoll *)Addr68k_from_LADDR(			LADDR_from_68k(HTcoll)+GetLinkptr(htlptr->contents));		  while(link->next_free != 0)		/* cont linkage ? */			{ if (GetSegnuminColl(link->free_ptr) == HILOC(ptr))				if (cnt = GetCountinColl(link->free_ptr) < 				    MAX_GCCOUNT)	/*normal in linkage*/					return(cnt);				else			/* big in linkage */				   { cnt = gc_lookup_bigrefcnt0(ptr);					return(cnt);				   };			  link = (struct htcoll *)Addr68k_from_LADDR(				LADDR_from_68k(HTcoll)+link->next_free);			}		  if (GetSegnuminColl(link->free_ptr) == HILOC(ptr))			if (cnt = GetCountinColl(link->free_ptr) < 			    MAX_GCCOUNT)		/*normal in linkage*/				return(cnt);			else				/* big in linkage */			   { cnt = gc_lookup_bigrefcnt0(ptr);				return(cnt);			   };		  return(1);					/* no entry */		}	else if (HILOC(ptr) != entry->segnum)	/* other object's */		return(1);	else if ((cnt = entry->count) < MAX_GCCOUNT)	/* normal case */		return(cnt);	else						/* bigcount case */	   {cnt = gc_lookup_bigrefcnt0(ptr);	    return(cnt);	   };   }E 11LispPTR checkarrayblock(base,free,onfreelist)LispPTR		base;LispPTR		free;LispPTR		onfreelist;{struct arrayblock 	*bbase, *btrailer; struct arrayblock	*bfwd, *bbwd, *rbase; LispPTR		fbl; LispPTR		*rover, *tmprover;I 10#ifdef CHECK   if (T)#elseE 10   if (*Array_Block_Checking_word != NIL)I 10#endifE 10	{bbase = (struct arrayblock *)Addr68k_from_LADDR(base);	 btrailer=(struct arrayblock *)Addr68k_from_LADDR(Trailer(base,bbase));	 bfwd = (struct arrayblock *)Addr68k_from_LADDR(bbase->fwd);	 bbwd = (struct arrayblock *)Addr68k_from_LADDR(bbase->bkwd);	 if (bbase->password != ARRAYBLOCKPASSWORD)		error("ARRAYBLOCK password wrong\n");	 else if (bbase->inuse == free)		error("ARRAYBLOCK INUSE bit set wrong\n");D 11	 else if (free && (refcnt(base) != 1))		error("Free ARRAYBLOCK with RefCnt not 1\n");E 11	 else if (btrailer->password != ARRAYBLOCKPASSWORD)		error("ARRAYBLOCK trailer password wrong\n");	 else if (bbase->arlen != btrailer->arlen)		error("ARRAYBLOCK Header and Trailer length don't match\n");	 else if (btrailer->inuse == free)			/* This is not original source.(in original, 			   btrailer -> bbase) maybe, this is correction. */		error("ARRAYBLOCK Trailer INUSE bit set wrong\n");	 else if (!onfreelist || (bbase->arlen < MINARRAYBLOCKSIZE))			/* Remaining tests only for free list. */		return(NIL);	 else if ((bbwd->fwd != base) || (bfwd->bkwd != base))		error("ARRAYBLOCK links fouled\n");	 else	   {fbl = FreeBlockChainN(bbase->arlen);	    rover = tmprover = (LispPTR *)Addr68k_from_LADDR(fbl);			/* GETBASEPTR */	    if ((*rover & 0x0ffffff) == NIL)		error("Free Block's bucket empty\n");	    do		{if ((*rover & 0x0ffffff) == base)			return(NIL);		 checkarrayblock((*rover & 0x0ffffff), T, NIL);		 rbase = (struct arrayblock *)Addr68k_from_LADDR(						*rover & 0x0ffffff);		}while(((*rover = rbase->fwd)& 0x0ffffff) != 						(*tmprover & 0x0ffffff));	    return(NIL);	   }; 	};   return(NIL);}LispPTR deleteblock(base)LispPTR		base;{  struct arrayblock 	*bbase, *fbbase, *bbbase;   LispPTR		fwd,bkwd,fbl,freeblocklsp;   LispPTR		*freeblock;   bbase = (struct arrayblock *)Addr68k_from_LADDR(base);   if ((bbase->arlen >= MINARRAYBLOCKSIZE) && (bbase->fwd != NIL))	{fwd = bbase->fwd;	 fbbase = (struct arrayblock *)Addr68k_from_LADDR(fwd);	 bkwd = bbase->bkwd;	 bbbase = (struct arrayblock *)Addr68k_from_LADDR(bkwd);	 fbl = FreeBlockChainN(bbase->arlen);	 freeblock = (LispPTR *)Addr68k_from_LADDR(fbl);	 freeblocklsp = 0xffffff & *freeblock;	 if (base == fwd)	   {if (base == freeblocklsp)		*freeblock = NIL;	D 7	    else error("deleting last list # FREEBLOCKLIST\n");E 7I 7	    else error("GC error:deleting last list # FREEBLOCKLIST\n");E 7	    return(NIL);	   }         else	   if (base == freeblocklsp)		*freeblock = fwd;	fbbase->bkwd = bkwd;	bbbase->fwd  = fwd;	}   return(NIL);}LispPTR linkblock(base)LispPTR		base;{  struct arrayblock 	*bbase,*fbbase,*tmpbase;   LispPTR 		fbl,freeblocklsp;   LispPTR		*freeblock;   if (*FreeBlockBuckets_word != NIL) 	{ bbase = (struct arrayblock *)Addr68k_from_LADDR(base);	  if (bbase->arlen < MINARRAYBLOCKSIZE)		checkarrayblock(base, T, NIL);	  else	    {fbl = FreeBlockChainN(bbase->arlen);	     freeblock = (LispPTR *)Addr68k_from_LADDR(0x0ffffff & fbl);	     freeblocklsp = 0x0ffffff & (*freeblock);	     if (freeblocklsp == NIL)		{bbase->fwd = base;		 bbase->bkwd = base;		}	     else		{fbbase = (struct arrayblock *)Addr68k_from_LADDR(freeblocklsp);		 bbase->fwd = freeblocklsp;		 bbase->bkwd = fbbase->bkwd;		 tmpbase = (struct arrayblock *)				Addr68k_from_LADDR(fbbase->bkwd);		 tmpbase->fwd = base;		 fbbase->bkwd = base;		};	     *freeblock = base;	     checkarrayblock(base, T, T);	    };	};	return(base);}I 15E 15LispPTR makefreearrayblock(block, length)LispPTR		block;DLword		length;{ LispPTR		trailer;  struct arrayblock 	*bbase;  struct abdum		*dbase;   bbase = (struct arrayblock *)Addr68k_from_LADDR(block);D 12   dbase = (struct abdum *)bbase;E 12I 12   dbase = (struct abdum *)WORDPTR(bbase);E 12   dbase->abflags = FREEARRAYFLAGWORD;   bbase->arlen   = length;   trailer = Trailer(block,bbase);    bbase = (struct arrayblock *)Addr68k_from_LADDR(trailer);D 12   dbase = (struct abdum *)bbase;E 12I 12   dbase = (struct abdum *)WORDPTR(bbase);E 12   dbase->abflags = FREEARRAYFLAGWORD;   bbase->arlen   = length;   return(block);}I 15E 15LispPTR arrayblockmerger(base, nbase)LispPTR		base, nbase;D 15{   DLword		arlens, narlens, secondbite, minblocksize, shaveback;E 15I 15{   DLword arlens, narlens, secondbite, minblocksize, shaveback;E 15    struct arrayblock 	*bbase, *bnbase;    bbase = (struct arrayblock *)Addr68k_from_LADDR(base);    bnbase = (struct arrayblock *)Addr68k_from_LADDR(nbase);    arlens = bbase->arlen;    narlens = bnbase->arlen;    secondbite = MAXARRAYBLOCKSIZE - arlens;    if (narlens > secondbite)	{arlens = MAXARRAYBLOCKSIZE;	 narlens = narlens - secondbite;D 15	 minblocksize = ((*Hunk_word         ==ATOM_T)?(ARRAYBLOCKOVERHEADCELLS+MAXCELLSPERHUNK):MINARRAYBLOCKSIZE);E 15I 15	 minblocksize = ((*Hunk_word == ATOM_T) ? 			   (ARRAYBLOCKOVERHEADCELLS+MAXCELLSPERHUNK) : 			   MINARRAYBLOCKSIZE);E 15	 if (narlens < minblocksize)	    {shaveback = narlens - minblocksize;	     narlens = minblocksize;	     arlens += shaveback;	     secondbite += shaveback;	    };	linkblock(makefreearrayblock(nbase+2*secondbite, narlens));	narlens = 0;	};    return(linkblock(makefreearrayblock(base, arlens+narlens)));}I 15E 15LispPTR mergebackward(base)LispPTR 	base;{  LispPTR 		pbase;   struct arrayblock 	*ptrailer;    ptrailer = (struct arrayblock *)Addr68k_from_LADDR(base -					ARRAYBLOCKTRAILERWORDS);   if (base == NIL)	return(NIL);   else if ((*ArrayMerging_word == NIL) || ((base == *ArraySpace_word) || 	     ((base == *ArraySpace2_word) || (ptrailer->inuse == T))))	    return(linkblock(base));   pbase = base - 2*ptrailer->arlen;   checkarrayblock(pbase, T,NIL);   deleteblock(pbase);   return(arrayblockmerger(pbase, base));}I 15E 15LispPTR mergeforward(base)LispPTR 	base;{   LispPTR	nbase, nbinuse;    struct arrayblock 	*bbase, *bnbase;    bbase = (struct arrayblock *)Addr68k_from_LADDR(base);    nbase = base + 2*(bbase->arlen);    bnbase = (struct arrayblock *)Addr68k_from_LADDR(nbase);    if ((*ArrayMerging_word == NIL) || ((base == NIL)	 || (checkarrayblock(base, T, T) || ((nbase == *ArrayFrLst_word) ||	 ((nbase == *ArrayFrLst2_word) || 	 (checkarrayblock(nbase, (! (nbinuse = bnbase->inuse)),NIL) || 	 nbinuse))))))	return(NIL);    deleteblock(nbase);    deleteblock(base);    return(arrayblockmerger(base, nbase));}I 15E 15LispPTR reclaimarrayblock(ptr)LispPTR ptr;{ LispPTR		tmpptr, btrailer;  struct arrayblock 	*base;  LispPTR		*tmpp;I 3  int			reclaim_p;D 7/* upgrade to Medley version. */E 7     reclaim_p = T;I 10#ifdef CHECK     checkarrayblock(ptr-ARRAYBLOCKHEADERWORDS, NIL, NIL);#endifE 10E 3     base = (struct arrayblock *)Addr68k_from_LADDR(ptr-ARRAYBLOCKHEADERWORDS);I 10E 10     if ((HILOC(ptr) < FIRSTARRAYSEGMENT) ||	   ((ARRAYBLOCKPASSWORD != base->password) ||	    (base->inuse == NIL)))	   {error(D 16          "Bad array block reclaimed--continue with N but save state ASAP. \n");E 16I 16          "Bad array block reclaimed--continue with 'Q' but save state ASAP. \n");E 16	    return(T);	   }; I 10E 10     switch(base->gctype)	  {	   case PTRBLOCK_GCT:		{btrailer = (ptr-2)+2*(base->arlen - ARRAYBLOCKTRAILERCELLS);		 tmpptr = ptr;		 do		   {		    tmpp = (LispPTR *)Addr68k_from_LADDR(tmpptr);D 4D 6		    gclookup((DELREF | 0x8000), *tmpp); /* added 8-Oct-87 TT */E 6I 6		    GCLOOKUP(0x8000,DELREF, *tmpp); /* added 8-Oct-87 TT */E 6E 4I 4D 7		    GCLOOKUP(0x8000,DELREF, *tmpp); /* added 8-Oct-87 TT */E 7E 4		    *tmpp = NIL;		    tmpptr += 2;		   } while (tmpptr != btrailer);		 break;			};	   case CODEBLOCK_GCT:D 3		reclaimcodeblock(ptr); E 3I 3		reclaim_p = ((reclaimcodeblock(ptr) == NIL)?T:NIL); E 3       /* default:   No Action */	  };D 3     mergeforward(mergebackward(makefreearrayblock(ptr-ARRAYBLOCKHEADERWORDSE 3I 3     if (reclaim_p == T)	mergeforward(mergebackward(makefreearrayblock(						ptr-ARRAYBLOCKHEADERWORDSE 3							,base->arlen)));     return(T);}I 15E 15I 6D 7/******* OBSOLATE ********E 6makefreeblock(stk,size)LispPTR		stk;DLword		size;{Bframe		*dumbframe68;   dumbframe68 = (Bframe *)Addr68k_from_LADDR(stk);   dumbframe68->ivar = size;   dumbframe68->flags = (STK_FSB_WORD & 0x0e000) >> 13;}D 6E 6LispPTR decusecount(frameexlp)LispPTR		frameexlp;{struct frameex1 	*frameex68; Bframe			*dumbframe68; DLword			alinknow, blinknow, clinknow, nextblk, size; LispPTR		alinklp,clinklp, startivars;   frameex68 = (struct frameex1 *)Addr68k_from_LADDR(frameexlp);   while(1){   if ((frameex68->flags == 0) || (LADDR_from_68k(frameex68) == VAG2(STK_HI,0)))	return(NIL);   if (frameex68->usecount != 0)	{--frameex68->usecount;	 return(LADDR_from_68k(frameex68));	};   alinknow = GetAlink(frameex68);   alinklp  = VAG2(STK_HI,alinknow);   blinknow = GetBlink(frameex68);   clinknow = GetClink(frameex68);   clinklp  = VAG2(STK_HI,clinknow);   nextblk  = frameex68->nextblock;   size     = VAG2(STK_HI,nextblk) - LADDR_from_68k(frameex68);   dumbframe68 = (Bframe *)Addr68k_from_LADDR(				LADDR_from_68k(frameex68) - 2);D 6						/* the above Basic Frame */ E 6   if (dumbframe68->residual)	makefreeblock(LADDR_from_68k(dumbframe68), size+2);   else	makefreeblock(LADDR_from_68k(frameex68), size);   dumbframe68 = (Bframe *)Addr68k_from_LADDR(VAG2(STK_HI,blinknow));   if (dumbframe68->usecnt == 0)	{startivars = VAG2(STK_HI, dumbframe68->ivar);	 makefreeblock(startivars,	   		(LADDR_from_68k(dumbframe68) - startivars+2));}   else	--(dumbframe68->usecnt);   if (alinklp != clinklp)	decusecount(alinklp);   frameex68 = (struct frameex1 *)Addr68k_from_LADDR(clinklp);   };}I 6*******************************/E 6E 7D 6E 6LispPTR reclaimstackp (ptr)		/* This is the entry function */D 7LispPTR		ptr;		/*  in stack reclaiming */E 7I 7LispPTR		ptr;			/*  in stack reclaiming */E 7D 6{Bframe		*stktp; stktp = (Bframe *)Addr68k_from_LADDR(ptr);   if (stktp->flags != 0)	decusecount(LADDR_from_68k(VAG2(STK_HI, stktp->ivar)));E 6I 6{ register STACKP *stkp; register FX	*fxp; stkp = (STACKP*)Addr68k_from_LADDR(ptr); fxp = (FX*)Addr68k_from_StkOffset( stkp->edfxp );D 7 /* this check will be done in decusecount68k   if (!FX_INVALIDP(fxp)) *************/  decusecount68k(fxp); putchar('*'); /* debug */E 6   return(NIL);E 7I 7 decusecount68k(fxp); return(NIL);E 7}D 7   E 7I 7E 7E 1