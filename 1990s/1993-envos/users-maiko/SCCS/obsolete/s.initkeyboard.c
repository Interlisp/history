h44652s 00000/00000/00367d D 2.28 90/03/05 15:23:08 sybalsky 35 34c [no change]es 00020/00002/00347d D 2.27 90/03/01 13:57:03 osamu 34 33c Mitsunori Matsuda adds XWindow functionality.es 00012/00001/00337d D 2.26 90/02/12 14:25:23 sybalsky 33 32c Fix grammar in the "Please set LDEKBDTYPE" msges 00000/00000/00338d D 2.25 90/02/08 14:32:27 osamu 32 31c There is no change. This co/ci is for change SCCS comment on previous version. c correct comment: NEXT-key(AltGraph-Key) is abailable. c 	change value of SUNLispKeyMap_for4[13] -1 => 47.es 00002/00002/00336d D 2.24 90/02/08 14:28:57 osamu 31 30c NEXT-key(AltGraph-Key) is abailable. c 	change value of multies 00001/00001/00337d D 2.23 90/02/07 12:10:47 mitani 30 29c close comment list for KB_JLE definitiones 00039/00000/00299d D 2.22 90/02/06 20:53:22 gadener 29 28c yes 00002/00002/00297d D 2.21 89/12/28 15:25:43 sybalsky 28 27c es 00023/00018/00276d D 2.20 89/12/13 10:55:51 sybalsky 27 26c color ss1es 00018/00014/00276d D 2.19 89/03/31 13:36:23 shih 26 25c put LDEKBDTYPE in ifdef FUJIes 00000/00000/00290d D 2.18 89/03/30 20:31:48 sybalsky 25 24c byte swappinges 00036/00014/00254d D 2.17 89/03/30 15:21:06 shimizu 24 23c If LDEKBDTYPE is not set,then exit.es 00000/00000/00268d D 2.16 89/03/29 14:02:03 shih 23 22c added minor check for type3 LDEKBDTYPEes 00002/00002/00266d D 2.15 89/03/23 15:21:13 shih 22 21c changed LDEKBDTYPE to LDEKBDTYPEes 00064/00032/00204d D 2.14 89/03/08 14:36:25 shih 21 20c merged type4 ioctl bug workaround, devconfig problemes 00004/00000/00232d D 2.13 89/01/05 14:59:38 shimizu 20 19c Accept TYPE2 kbdes 00027/00027/00205d D 2.12 88/11/29 16:00:33 shih 19 18c minor cleanupes 00008/00002/00224d D 2.11 88/10/27 18:10:16 shimizu 18 17c change I/F for init_keyboardes 00003/00001/00223d D 2.10 88/10/26 16:21:53 shimizu 17 16c Temp solution for AR10908es 00007/00005/00217d D 2.9 88/10/19 15:00:07 shimizu 16 15c try to continue after ioctl fails (looks hopeless though)es 00059/00001/00163d D 2.8 88/10/17 20:03:37 shimizu 15 14c For type4 kbd changeses 00000/00001/00164d D 2.7 88/10/10 14:06:48 krivacic 14 13c sun3/4 mergees 00001/00001/00164d D 2.6 88/09/14 11:51:37 shimizu 13 12c Change keymap for LineFeed to 71(also needs change SYSOUT)es 00003/00000/00162d D 2.5 88/07/06 18:17:12 shimizu 12 11c EmUtilin68K points to IFPAGE->fakemousebites 00004/00000/00158d D 2.4 88/06/20 21:57:19 shimizu 11 10c For C keyhandleres 00002/00002/00156d D 2.3 88/06/15 12:27:05 shimizu 10 9c Physical No.43 <- keynum 13(SAME) PhyNo.49 <- 14(BackWD)es 00002/00002/00156d D 2.2 88/06/09 20:16:46 shimizu 9 8c Add O_RDWR arg to open calles 00000/00000/00158d D 2.1 88/05/17 09:25:15 hayata 8 7c Version up to 2.1es 00008/00007/00150d D 1.7 88/05/10 17:52:31 masinter 7 6c Change keyboard mapping to match diagrames 00002/00002/00155d D 1.6 88/04/11 18:17:34 hayata 6 5c Add SCCS key ides 00002/00003/00155d D 1.5 88/04/11 18:15:42 hayata 5 4c Remove LispReadFds initialization from init_keyboard to fix ether bug.es 00003/00001/00155d D 1.4 88/03/17 18:09:16 krivacic 4 3c Hi Res Display Hacks es 00002/00002/00154d D 1.3 88/03/13 14:51:24 hayata 3 2c Add SCCS key id (%Z%)es 00001/00042/00155d D 1.2 88/03/01 15:55:13 takeshi 2 1c Doesn't inquire MAIKO or KATANA.(takeshi)es 00197/00000/00000d D 1.1 88/02/24 16:57:34 hayata 1 0c date and time created 88/02/24 16:57:34 by hayataeuUtTI 1D 3/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 3I 3D 5/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 5I 5D 6/* This is G-file @(#) initkeyboard.c Version 1.4 (3/17/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) initkeyboard.c	1.4 3/17/88";E 6I 6D 19/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 19I 19D 28/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 19static char *id = "%Z% %M%	%I% %G%";E 28I 28D 34/* @(#) initkeyboard.c Version 2.19 (3/31/89). copyright envos & Fuji Xerox  */static char *id = "@(#) initkeyboard.c	2.19 3/31/89";E 34I 34/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 34E 28E 6E 5E 3D 21/*** ADOPTED NEW VERSION ***/E 21D 21E 21/*D 27 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.E 27I 27 *	Copyright (C) 1987, 1989 by Fuji Xerox Co., Ltd., *				    Venue, and Envos Corporation. *		  All rights reserved.E 27 *D 19 *	Auther	:	Osamu Nakamura	E 19I 19 *	Author	:	Osamu NakamuraE 19 */I 33/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/E 33#include <stdio.h>#include <sys/types.h>#include <sys/file.h>#include <sundev/kbd.h>#include <sundev/kbio.h>#include <fcntl.h>#include <sunwindow/window_hs.h>#include <sunwindow/cms.h>#include <sys/ioctl.h>#include <sunwindow/win_ioctl.h>#include <pixrect/pixrect_hs.h>#include "lispemul.h"#include "lispmap.h"#include "lispglobal.h"#include "address68k.h"#include "address.h"I 15#include "devconfig.h"E 15#include "iopage.h"#include "ifpage.h"extern struct screen LispScreen;extern int LispWindowFd;int LispKbdFd;extern int errno;/*   for debug    */D 19int 	DebugKBD = NIL;E 19I 19int	DebugKBD = NIL;E 19FILE	*KBlog;u_int LispReadFds = 0;struct inputmask LispEventMask;D 14int	Intrdisable = NIL;E 14IOPAGE	*IOPage68K;DLword	*EmMouseX68K;DLword	*EmMouseY68K;I 11DLword	*EmCursorX68K;DLword	*EmCursorY68K;E 11DLword	*EmRealUtilin68K;I 12DLword	*EmUtilin68K;E 12DLword	*EmKbdAd068K;DLword	*EmKbdAd168K;DLword	*EmKbdAd268K;DLword	*EmKbdAd368K;DLword	*EmKbdAd468K;DLword	*EmKbdAd568K;DLword	*EmDispInterrupt68K;DLword	*EmCursorBitMap68K;D 2u_char SUNLispKeyMap[128];static u_char MAIKOKeyMap[] = {E 2I 2D 15u_char SUNLispKeyMap[128] = {E 15I 15/*u_char SUNLispKeyMap[128];*/u_char *SUNLispKeyMap;E 15E 2D 7/* 0 */	  -1,  61,  -1,  46,  -1,  97,  99,  -1,E 7I 7I 15/* keymap for type3 */u_char SUNLispKeyMap_for3[128] = {E 15/* 0 */	  -1,  61,  -1,  91,  -1,  97,  99,  -1,E 7D 19/* 8 */  100,  -1,  67,  -1,  68,  -1,  101, -1,E 19I 19/* 8 */  100,  -1,  67,  -1,  68,  -1, 101,  -1,E 19/* 16*/   66, 104,  80,  47,  -1,  73,  74,  75,D 7/* 24*/   -1,  63,  91,  -1,  -1,  33,  32,  17,E 7I 7/* 24*/   -1,  92,  63,  -1,  -1,  33,  32,  17,E 7D 19/* 32*/   16,   1,   0,   2,   4,  53,  22,   8,	 E 19I 19/* 32*/   16,   1,   0,   2,   4,  53,  22,   8,E 19D 10/* 40*/	  10,  59,  45,  -1,  -1,  81,  82,  83,D 7/* 48*/   -1,  90,  -1,  89,  -1,  34,  19,  18,E 7I 7/* 48*/   -1,  93,  -1,  62,  -1,  34,  19,  18,E 10I 10/* 40*/	  10,  59,  45,  13,  -1,  81,  82,  83,/* 48*/   -1,  14,  -1,  62,  -1,  34,  19,  18,E 10E 7/* 56*/    3,  48,  49,  51,   6,  23,  25,  11,/* 64*/   58,  29,  15,  -1,  84,  85,  87,  -1,D 7/* 72*/   14,  62,  -1,  -1,  36,  21,  20,   5,E 7I 7D 19/* 72*/   111,  89,  -1,  -1,  36,  21,  20,   5,E 19I 19/* 72*/  111,  89,  -1,  -1,  36,  21,  20,   5,E 19E 7/* 80*/	  35,  50,  52,  38,   9,  26,  43,  28,D 7/* 88*/  105,  44,  -1,  94,  69,  70,  -1,  30,/* 96*/   -1,  36,  -1,  41,  40,  24,  37,   7,/*104*/   39,  54,  55,  27,  42,  12,  60,  -2,   E 7I 7/* 88*/  105,  44,  -1,  94,  69,  70,  -1,  90,/* 96*/   -1,  46,  -1,  41,  40,  24,  37,   7,D 13/*104*/   39,  54,  55,  27,  42,  12,  60,  14,   E 13I 13D 19/*104*/   39,  54,  55,  27,  42,  12,  60,  71,   E 19I 19/*104*/   39,  54,  55,  27,  42,  12,  60,  71,E 19E 13E 7/*112*/   98,  76,  72,  -1,  -1,  -1,  -1,  56,D 19/*120*/	  31,  57,  93,  -1,  -1,  -1,  -1,  -1,	      }; E 19I 19/*120*/	  31,  57,  93,  -1,  -1,  -1,  -1,  -1, };E 19I 15/* for type4 */E 15D 2static u_char KATANAKeyMap[] = {/* 0 */	-1,     -1,     -1,     -1,    -1,     80,    81,     -1,  /* 8 */ 82,     -1,     83,     -1,    84,     -1,    85,     -1,  /* 16*/ 86,     87 ,    -1,     -1,    -1,     -1,    -1,     -1,  /* 24*/ -1,     42,     43,     -1,    -1,     14,    32,     17,/* 32*/ 30,     1,      0,      2,     4,      53,    36,     8,	 /* 40*/	10,     41,     96,     -1,    -1,     58,    59,     60,/* 48*/ -1,     44,     -1,     45,    -1,     34,    93,     56,/* 56*/ 3,      89,     13,     51,    6,      23,    25,     11,/* 64*/ 31,     29,     15,     -1,    -1,     61,    -1,     -1,  /* 72*/ 46,     47,     -1,     -1,    18,     91,    90,     5,/* 80*/	35,     50,     52,     38,    9,      26,    92,     28,/* 88*/ 92,     94,     -1,     -1,    62,     -1,    -1,     48,/* 96*/ -1,     49,     -1,     18,    40,     24,    37,     7,/*104*/ 39,     54,     55,     27,    98,     12,    19,     -1,  /*112*/ 63,     64,     65,     -1,    -1,     -1,    -1,     16,/*120*/	21,     57, 	22,     -1,    -1,     -1,    ERROR,  IDLE  	      }; E 2I 15u_char SUNLispKeyMap_for4[128] = {D 19/* 0 */   -1,  61,  -1,  91,  -1,  97,  99,  106,/* 8 */  100,  107,  67,  108,  68,  -1,  101, -1,/* 16*/   66, 104,  80,  31,  -1,  75,  110,  74,/* 24*/   -1,  109,  63,  -1,  -1,  33,  32,  17,/* 32*/   16,   1,   0,   2,   4,  53,  22,   8,         E 19I 19/* 0 */   -1,  61,  -1,  91,  -1,  97,  99, 106,D 31/* 8 */  100, 107,  67, 108,  68,  -1, 101,  -1,E 31I 31/* 8 */  100, 107,  67, 108,  68,  47, 101,  -1,E 31/* 16*/   66, 104,  80,  31,  -1,  75, 110,  74,/* 24*/   -1, 109,  63,  -1,  -1,  33,  32,  17,/* 32*/   16,   1,   0,   2,   4,  53,  22,   8,E 19/* 40*/   10,  59,  45,  15,  -1,  64,  65,  95,/* 48*/   -1,  14,  13,  89,  -1,  34,  19,  18,/* 56*/    3,  48,  49,  51,   6,  23,  25,  11,/* 64*/   58,  29,  13,  93,  81,  82,  83,  96,D 19/* 72*/   111,  62,  -1,  -1,  36,  21,  20,   5,E 19I 19/* 72*/  111,  62,  -1,  -1,  36,  21,  20,   5,E 19/* 80*/   35,  50,  52,  38,   9,  26,  43,  28,/* 88*/  105,  44,  76,  84,  85,  87,  98,  90,/* 96*/   -1,  46,  73,  41,  40,  24,  37,   7,D 19/*104*/   39,  54,  55,  27,  42,  12,  60,  71,   E 19I 19/*104*/   39,  54,  55,  27,  42,  12,  60,  71,E 19/*112*/   94,  69,  70,  -1,  -1,  -1,  92,  56,D 19/*120*/   86,  57,  88,  -1,  -1,  102,  -1,  -1,             }; E 19I 19/*120*/   86,  57,  88,  -1,  -1, 102,  -1,  -1, };E 19I 29/* for jle */u_char SUNLispKeyMap_jle[128] = {/* 0 */   -1,  61,  -1,  91,  -1,  97,  99, 106,/* 8 */  100, 107,  67, 108,  68,  47, 101,  71,/* 16*/   66, 104,  80,  31,  -1,  75, 110,  74,/* 24*/   -1, 109,  63,  -1,  -1,  33,  32,  17,/* 32*/   16,   1,   0,   2,   4,  53,  22,   8,/* 40*/   59,  45,  30,  15,  -1,  64,  65,  95,/* 48*/   -1,  14,  13,  89,  -1,  34,  19,  18,/* 56*/    3,  48,  49,  51,   6,  23,  25,  11,/* 64*/   58,  29,  13,  93,  81,  82,  83,  96,/* 72*/  111,  62,  -1,  -1,  36,  21,  20,   5,/* 80*/   35,  50,  52,  38,   9,  26,  43,  28,/* 88*/  105,  44,  76,  84,  85,  87,  98,  90,/* 96*/   -1,  46,  73,  41,  40,  24,  37,   7,/*104*/   39,  54,  55,  27,  42,  12,  60,  10,/*112*/   94,  69,  70,  72, 103, 109,  92,  56,/*120*/   86,  57,  88,  -1,  -1, 102,  -1,  -1, };/* [40] 10->59  *//* [41] 59->45  *//* [42] 45->30  *//* [111] 71->10 *//* [115] -1 -> 72  Kakutei *//* [116] -1 -> 103 Henkan *//* [117] -1 -> 109 Nihongo On-Off */E 29I 21/*  ----------------------------------------------------------------*/E 21E 15D 2E 2D 18init_keyboard()E 18I 18init_keyboard(flg)  int flg ; /* if 0 init else re-init */E 18D 27{I 4D 26E 26E 4	int keytrans;E 27I 27  {    int keytrans;E 27D 2		int i, selectnumber;E 2D 4	E 4I 4I 15D 26E 26E 15D 5	LispReadFds = 0;E 5E 4D 27	set_kbd_iopointers();E 27I 27    set_kbd_iopointers();E 27I 34#ifdef SUNDISPLAYE 34D 9	if( (LispKbdFd = open( LispScreen.scr_kbdname )) == -1){E 9I 9D 27	if( (LispKbdFd = open( LispScreen.scr_kbdname , O_RDWR)) == -1){E 9		fprintf( stderr, "can't open %s\n", LispScreen.scr_kbdname);		exit( -1 );	}I 15D 18	keyboardtype(LispKbdFd);E 18I 18	if(flg==0){		keyboardtype(LispKbdFd);	}E 27I 27    if( (LispKbdFd = open( LispScreen.scr_kbdname , O_RDWR)) == -1)      {	fprintf( stderr, "can't open %s\n", LispScreen.scr_kbdname);	exit( -1 );      }I 34#endif SUNDISPLAYE 34    if(flg==0)      {	keyboardtype(LispKbdFd);      }E 27E 18I 34#ifdef SUNDISPLAYE 34E 15D 27	keytrans = TR_UNTRANS_EVENT;	/* keyboard does not encode key */	if(ioctl( LispKbdFd, KIOCTRANS, &keytrans)== -1){		fprintf( stderr, "Error at ioctl errnoo =%d\n", errno);			exit( -1 );	}	close( LispKbdFd );E 27I 27    keytrans = TR_UNTRANS_EVENT;	/* keyboard does not encode key */    if(ioctl( LispKbdFd, KIOCTRANS, &keytrans)== -1)      {	fprintf( stderr, "Error at ioctl errnoo =%d\n", errno);	exit( -1 );      }    close( LispKbdFd );E 27D 27	seteventmask( &LispEventMask );E 27I 27    seteventmask( &LispEventMask );I 34#endif SUNDISPLAYE 34E 27D 2	fprintf( stderr, "which Keymap?  MAIKO or KATANA\n");	fprintf( stderr, "MAIKO for KYUU.sysout\n");	fprintf( stderr, "KATANA for HACHI.sysout\n");	fprintf( stderr, "please input number\n");	fprintf( stderr, "\t1: MAIKO\n");	fprintf( stderr, "\t2: KATANA\n");	fprintf( stderr, "\t==>");	scanf("%d", &selectnumber);	fprintf(stderr, "\nselectnumber = %d\n", selectnumber);	if( selectnumber == 1)		for( i=0; i<128; i++)			SUNLispKeyMap[i] = MAIKOKeyMap[i];	else		for( i=0; i<128; i++)			SUNLispKeyMap[i] = KATANAKeyMap[i] & 0x7F;E 2I 34#ifdef XWINDOW    init_Xevent();#endif XWINDOWE 34}I 21/*  ----------------------------------------------------------------*/E 21device_before_exit(){I 34#ifdef SUNDISPLAYE 34	int keytrans;D 19	E 19I 19E 19D 9	if( (LispKbdFd = open( LispScreen.scr_kbdname )) == -1){E 9I 9	if( (LispKbdFd = open( LispScreen.scr_kbdname , O_RDWR)) == -1){E 9		fprintf( stderr, "can't open %s\n", LispScreen.scr_kbdname);		exit( -1 );	}	keytrans = TR_EVENT;	/* keyboard encodes key */	if(ioctl( LispKbdFd, KIOCTRANS, &keytrans)== -1){		fprintf( stderr, "Error at ioctl errnoo =%d\n", errno);			exit( -1 );	}	close( LispKbdFd );I 34#endif SUNDISPLAYE 34	display_before_exit();}I 21/*  ----------------------------------------------------------------*/E 21set_kbd_iopointers(){D 21	IOPage68K = (IOPAGE *)IOPage;D 19	EmMouseX68K = (DLword *) &(IOPage68K->dlmousex);	EmMouseY68K = (DLword *) &(IOPage68K->dlmousey);E 19I 19	EmMouseX68K  = (DLword *) &(IOPage68K->dlmousex);	EmMouseY68K  = (DLword *) &(IOPage68K->dlmousey);E 19I 11	EmCursorX68K = (DLword *) &(IOPage68K->dlcursorx);	EmCursorY68K = (DLword *) &(IOPage68K->dlcursory);E 21I 21	IOPage68K       = (IOPAGE *)IOPage;	EmMouseX68K     = (DLword *) &(IOPage68K->dlmousex);	EmMouseY68K     = (DLword *) &(IOPage68K->dlmousey);	EmCursorX68K    = (DLword *) &(IOPage68K->dlcursorx);	EmCursorY68K    = (DLword *) &(IOPage68K->dlcursory);E 21E 11	EmRealUtilin68K = (DLword *) &(IOPage68K->dlutilin);I 12	/* EmUtilin68K is for KEYDOWNP1 macro or etc. */	EmUtilin68K = (DLword *) &(InterfacePage->fakemousebits);E 12	EmKbdAd068K = (DLword *) &(IOPage68K->dlkbdad0);	EmKbdAd168K = (DLword *) &(IOPage68K->dlkbdad1);	EmKbdAd268K = (DLword *) &(IOPage68K->dlkbdad2);	EmKbdAd368K = (DLword *) &(IOPage68K->dlkbdad3);	EmKbdAd468K = (DLword *) &(IOPage68K->dlkbdad4);	EmKbdAd568K = (DLword *) &(IOPage68K->dlkbdad5);	EmDispInterrupt68K = (DLword *) &(IOPage68K->dldispinterrupt);D 21	EmCursorBitMap68K = (DLword *) (IOPage68K->dlcursorbitmap);E 21I 21	EmCursorBitMap68K  = (DLword *)  (IOPage68K->dlcursorbitmap);E 21}I 21/*  ----------------------------------------------------------------*/I 34#ifdef SUNDISPLAYE 34E 21seteventmask( eventmask )struct inputmask *eventmask;{	input_imnull( eventmask );	eventmask->im_flags  |=  IM_ASCII | IM_NEGASCII | IM_NEGEVENT;D 19			E 19I 19D 26E 26E 19D 21	win_setinputcodebit( eventmask, MS_LEFT);	win_setinputcodebit( eventmask, MS_MIDDLE);D 19	win_setinputcodebit(  eventmask, MS_RIGHT);E 19I 19	win_setinputcodebit( eventmask, MS_RIGHT);E 19	win_setinputcodebit( eventmask, LOC_MOVE);	win_unsetinputcodebit( eventmask, LOC_STILL);	win_unsetinputcodebit( eventmask, LOC_MOVEWHILEBUTDOWN);D 19	win_unsetinputcodebit(  eventmask, LOC_WINENTER);E 19I 19	win_unsetinputcodebit( eventmask, LOC_WINENTER);E 19	win_unsetinputcodebit( eventmask, LOC_WINEXIT);E 21I 21	win_setinputcodebit  ( eventmask, MS_LEFT );	win_setinputcodebit  ( eventmask, MS_MIDDLE );	win_setinputcodebit  ( eventmask, MS_RIGHT );	win_setinputcodebit  ( eventmask, LOC_MOVE );	win_unsetinputcodebit( eventmask, LOC_STILL );	win_unsetinputcodebit( eventmask, LOC_MOVEWHILEBUTDOWN );	win_unsetinputcodebit( eventmask, LOC_WINENTER );	win_unsetinputcodebit( eventmask, LOC_WINEXIT );E 21	win_setinputmask( LispWindowFd, eventmask, eventmask, WIN_NULLLINK);}I 34#endif SUNDISPLAYE 34I 15I 21char* getenv();		/*  ---- external entry points --------*/E 21#define MIN_KEYTYPE 3I 21#define KB_AS3000J (7 + MIN_KEYTYPE)/* KB_SUN4 not defined in older OS versions */#ifndef KB_SUN4#define KB_SUN4 4#endifI 29D 30/* For the JLE keyboardE 30I 30/* For the JLE keyboard */E 30#define KB_JLE 5E 29/*  ----------------------------------------------------------------*/I 24/*********************************************************/D 26/* E 26I 26/*E 26	keyboardtype(fd)E 24I 24D 26	Determine the keyboard type E 26I 26	Determine the keyboard typeE 26	by checking LDEKBDTYPE	If it is not set,then print the messageD 26	and exit to SHELL.	If LDEKBDTYPE's value doesn't match then E 26I 26	and exit to SHELL (for Fuji).	If LDEKBDTYPE's value doesn't match thenE 26	it is treated as type3*//*********************************************************/E 24E 21keyboardtype(fd)int fd;{ int type;I 18 int i;I 21 char *key;E 21 for(i=0;i<5000;i++){/* IDLE LOOP */}E 18D 16 if(ioctl(fd,KIOCTYPE,&type) <0)	perror("keyboardtype:");E 16I 16D 21 type = KB_SUN3;			/** default??? **/ if(ioctl(fd,KIOCTYPE,&type) !=0)	error("keyboardtype:IOCTL(KIOCTYPE) fails");E 21I 21 /* clear the keyboard field in devconfig */ InterfacePage->devconfig &= 0xfff8;E 21E 16I 21D 24 /* shell variable is first choice, otherwise use value    of ioctl instead, otherwise type-3.  type=-1 means unbound **/E 24I 24/************************************************************ Due to the problems of SunOS 4.0 & 4.0.1 calling ioctl never return the correct keyboard type. So,these 2 lines are commented out ...(Take)->AR11100E 24D 26D 24 type = -1;D 22 if ((key = getenv("LDEKEYTYPE")) != 0) {E 22I 22 if ((key = getenv("LDEKBDTYPE")) != 0) {E 24I 24  if(ioctl(fd,KIOCTYPE,&type) !=0)	error("keyboardtype:IOCTL(KIOCTYPE) fails");E 26*************************************************************/I 26E 26/* Get keytype from LDEKBDTYPE  */ if ((key = getenv("LDEKBDTYPE")) == 0) {I 34#ifdef XWINDOW#define FUJI#endif XWINDOWE 34I 26#ifdef FUJI	/* obnoxious behavior */E 26	mess_reset();D 26E 26	printf("!!CAUTION: LDEKBDTYPE is not set.\n");	printf("Please retry after setting LDEKBDTYPE correctly.\n");	printf("Usage: setenv LDEKBDTYPE <kbdtype>\n");I 26D 31	printf("       (one of type2, type3, type4, as3000j)");E 31I 31D 33	printf("       (one of type2, type3, type4, jle as3000j)");E 33I 33	printf("       (one of type2, type3, type4, jle, or as3000j)");E 33E 31E 26	exit(0); /* exit to shell */I 26#else  	if(ioctl(fd,KIOCTYPE,&type) !=0) {		error("keyboardtype:IOCTL(KIOCTYPE) fails (cont. w. type-3");		type = KB_SUN3;		}	/* otherwise, type is set */#endifI 34#ifdef XWINDOW#undef FUJI#endif XWINDOWE 34E 26 }/* if end */ else {E 24E 22	if      (strcmp("as3000j", key)==0) type = KB_AS3000J;	else if (strcmp("type4",   key)==0) type = KB_SUN4;	else if (strcmp("type2",   key)==0) type = KB_SUN2;I 29        else if (strcmp("jle",     key)==0) type = KB_JLE;E 29D 24	else {D 22	  error("keyboardtype:LDEKEYTYPE value unknown (continue w. ioctl)");E 22I 22	  error("keyboardtype:LDEKBDTYPE value unknown (continue w. ioctl)");E 22          }	} /* if end */E 24I 24	else     type = KB_SUN3;           /* default */D 26       } E 26I 26       }E 26E 24D 24 if ( (type == -1) &&      ( ioctl(fd, KIOCTYPE, &type ) != 0 ) ) {    error("keyboardtype:IOCTL(KIOCTYPE) fails (continue w. type-3)");    type = KB_SUN3;    }E 24I 24D 26 E 26I 26E 26E 24E 21 switch(type) {I 20D 21	case KB_SUN2 : /* type2 ,we stiil use keymap for type3 */		SUNLispKeyMap = SUNLispKeyMap_for3;		InterfacePage->devconfig |= type-MIN_KEYTYPE;		break;E 21I 21D 26	case KB_SUN2 : /* type2 ,we still use keymap for type3 */E 26I 26	case KB_SUN2 : /* type2, we still use keymap for type3 */E 26I 24		SUNLispKeyMap = SUNLispKeyMap_for3;		/* MIN_KEYTYPE is 3,so we can't set devconfig correctly */		/* Therefore type2 may treat as type3 */		InterfacePage->devconfig |= 0;		break;E 24E 21E 20	case KB_SUN3 : /* type3 */D 21		/*printf("type3\n"); */E 21		SUNLispKeyMap = SUNLispKeyMap_for3;		InterfacePage->devconfig |= type-MIN_KEYTYPE;		break;D 21	case /*KB_SUN4*/ 4 : /* type4 */		/*printf("type4\n"); */		SUNLispKeyMap=SUNLispKeyMap_for4;E 21I 21	case KB_SUN4 : /* type4 */		SUNLispKeyMap = SUNLispKeyMap_for4;E 21		InterfacePage->devconfig |= type-MIN_KEYTYPE;I 29		break;	case KB_JLE : /* JLE */		/*printf("jle\n"); */		SUNLispKeyMap=SUNLispKeyMap_jle;		InterfacePage->devconfig |= type-MIN_KEYTYPE;		/* InterfacePage->devconfig |= 4-MIN_KEYTYPE; */E 29		break;I 21	case KB_AS3000J : /* for AS, use type4 map */		SUNLispKeyMap = SUNLispKeyMap_for4;		InterfacePage->devconfig |= type-MIN_KEYTYPE;/* 7 */		break;E 21D 16	default:		printf("Not supported keyboard type %d\n",type);		exit(-1);E 16I 16	default: { char errmsg [ 200 ];D 19		sprintf ( errmsg, "Not supported keyboard type: %d", type);E 19I 19		sprintf ( errmsg, "Unsupported keyboard type: %d", type);E 19D 17		error( errmsg );E 17I 17                printf ( "%s\n", errmsg);I 26                printf ( "Configuring keyboard for type-3\n", errmsg);E 26                SUNLispKeyMap = SUNLispKeyMap_for3;                InterfacePage->devconfig |= KB_SUN3-MIN_KEYTYPE;E 17D 21		}E 21E 16		break;D 21 }E 21I 21		}	}E 21D 19 E 19I 19D 21E 21E 19}/* end keyboardtype*/E 15D 21E 21E 1