h59839s 00010/00001/00220d D 2.9 89/12/29 12:59:42 sybalsky 13 12c Changes from Savoires 00000/00000/00221d D 2.8 89/03/30 13:16:43 sybalsky 12 11c Word pointers to use GETWORD.es 00016/00015/00205d D 2.7 89/03/01 11:05:16 sybalsky 11 10c Changed hard-coded type numbers to symbols defined in LispTypes.hes 00003/00002/00217d D 2.6 88/10/10 14:06:20 krivacic 10 9c sun3/4 mergees 00021/00071/00198d D 2.5 88/07/08 01:41:19 masinter 9 8c clean up code, remove potential problem if datatype pointer fields aren't sortedes 00001/00001/00268d D 2.4 88/07/01 18:28:35 charnley 8 7c used new GCLOOKUPV macro.es 00002/00001/00267d D 2.3 88/06/30 11:18:56 greep 7 6c fix commentes 00002/00000/00266d D 2.2 88/06/30 10:48:09 greep 6 5c put printf inside #ifdef DEBUGes 00000/00000/00266d D 2.1 88/05/17 09:24:49 hayata 5 4c Version up to 2.1es 00007/00007/00259d D 1.4 88/05/09 21:14:45 shih 4 3c Use GCLOOKUPes 00005/00020/00261d D 1.3 88/03/20 16:48:30 masinter 3 2c merge new gc code for closure cachees 00002/00002/00279d D 1.2 88/03/13 14:50:06 hayata 2 1c Add SCCS key id (%Z%)es 00281/00000/00000d D 1.1 88/02/24 16:57:19 hayata 1 0c date and time created 88/02/24 16:57:19 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 2D 3/*** ADOPTED NEW VERSION ***/E 3/*************************************************************************//*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 *//*************************************************************************//*                                                                       *//*                       File Name : gcreclaimcell.c                     *//*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : July-7-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions :                                                 *//*                       gcreclaimcell(cell);                            *//*                       freelistcell(cell);                             *//*                                                                       *//*                                                                       *//*************************************************************************//*           Descreption :                                               *//*                                                                       *//*  The functions "gcreclaimcell" and "freelistcell" are the translated  *//*  functions from the Lisp functions "\GCRECLAIMCELL" that is the UFN   *//*  function of the opcode "RECLAIMCELL", and "\FREELISTCELL".           *//*  These functions may have the following characteristics :             *//*                                                                       *//*  	gcreclaimcell(cell)	LispPTR cell				 *//* 		This function may always return NIL(= 0), as the Lisp    *//*           	macro .RECLAIMCELLLP. in more upper level may use this   *//*              return value as the further Garbage's pointer.(The Opcode*//*              "RECLAIMCELL"'s function is specified as this, but its   *//*              UFN function is not. The gcreclaimcell function's	 *//*              behavior is same as the UFN function for speed and 	 *//*		simplicity,this is, this function is closed in this level*//*		)							 *//*		This function may reclaim the date of all types that is  *//*		Garbage.Especially, the data whose types are ARRAYBLOCK  */D 11/*		(= 0), STACKP(= 8),VMEMPAGEP(= 10) and CODEBLOCK(= 50,51,*//*		52,53,54,55,56,57,58,59) may be reclaimed by each special*/E 11I 11/*		(= 0), STACKP(= 8),VMEMPAGEP(= 10) and CODEBLOCK(= 54,55,*//*		56,57,58,59,60,61,62,63) may be reclaimed by each special*/E 11/*		processes that are specified and invoked by this function*//*		.The data whose type is LISTP is the main data type	 *//*		processed in this function actually and only then the 	 *//*		function "freelistcell" may be called for making linkage *//*		of free list.						 *//*									 *//*	freelistcell(cell)	LispPTR cell				 *//*		This function may make the linkage of free list of the	 *//*		cons cell.The header of this linkage is DTD->NEXTPAGE of *//*		LISTP and each cons page has its internal linkage of free*//*		cells.This return value is not considered as not used.	 *//*									 *//*************************************************************************//*                                                               \Tomtom *//*************************************************************************/I 13#include <stdio.h>E 13#include "lispemul.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "stack.h"#include "cell.h"#include "ifpage.h"#include "gc.h"I 13#include "dbprint.h"E 13#define CONSPAGE_LAST	0x0ffffgcreclaimcell(cell)LispPTR	cell;D 4	{register ConsCell		*ptr;E 4I 4	{register ConsCell	*ptr;E 4	 struct dtd		*typdtd; 	 DLword			typ; D 4	 register LispPTR		tmpptr, donext, tmpcell, val;E 4I 4	 register LispPTR	tmpptr, donext, tmpcell, val;E 4	 LispPTR		ptrfield,carfield; D 9	 unsigned int 		index,code;E 9I 9	 int	 		index,code;E 9	 LispPTR		*field;D 9	/*** for monitor ***/E 9	 int freecnt;	 LispPTR freeptr;	 LispPTR *actptr;D 3/***if (Listp(cell))	{tmpptr = cell;	while (Listp(tmpptr))	   { if (GetTypeNumber(car(tmpptr)) ==  11) {stab();						tmpptr = NIL;}		else tmpptr = cdr(tmpptr); 	   };	};tmpptr = NIL; **/E 3I 3E 3	  val = NIL;	  tmpptr = cell;D 9	  index = NIL;E 9I 9	  index = -1;E 9	  donext = NIL;	lp:	  ptr = (ConsCell *)Addr68k_from_LADDR(tmpptr);D 9	  typ = GetTypeNumber(tmpptr);E 9I 9D 10#ifdef CHECKE 10I 10/* # ifdef CHECKE 10	if (refcnt(tmpptr) != 1) error("reclaiming cell w/refcnt not 1");D 10#endifE 10I 10 # endif*/E 10	typ = GetTypeNumber(tmpptr);E 9	  switch(typ) 		{ 		 case TYPE_LISTP: 			{ D 3			  if (*CdrCoding_word == NIL) /* non cdrcoding */				  goto normal; E 3			  if ((code = ptr->cdr_code) == CDR_INDIRECT)				/* indirect */				  { tmpcell = ptr->car_field;				    		/* Monitor */				    freelistcell(tmpptr);				    ptr = (ConsCell *)						Addr68k_from_LADDR(tmpcell);				    tmpptr = tmpcell;				    code = ptr->cdr_code;				  };D 9			  if (index != NIL)	/* car part */			  	index = NIL;E 9I 9			  if (index != -1)	/* car part */			  	index = -1;E 9D 3			  else if ((val = gclookup((0x8000 | DELREF),						car(tmpptr))) != NIL) 			/* ((val = htfind(car(tmpptr),1))!= NIL) */E 3I 3			  else if ((val = htfind(car(tmpptr), DELREF)) != NIL) E 3					{ 					  ptr->car_field = donext;					  ptr->cdr_code = code;					  donext = tmpptr; 					  goto doval;					};D 3			  val = gclookup((0x8000 | DELREF),cdr(tmpptr));				/* val = htfind(cdr(tmpptr),1); */ 							 /* cdr part */E 3I 3			  val = htfind(cdr(tmpptr),DELREF);E 3			  if (code <= CDR_MAXINDIRECT)				{tmpcell = POINTER_PAGEBASE(tmpptr)					    + ((code - CDR_INDIRECT) << 1);				  freelistcell(tmpcell);				};			  freelistcell(tmpptr);			  goto doval;    			};D 4		case 0:  if ((index == NIL) && reclaimarrayblock(tmpptr)) E 4I 4D 9		case 0: if ((index == NIL) && reclaimarrayblock(tmpptr)) E 9I 9D 11		case 0: if ((index == -1) && reclaimarrayblock(tmpptr)) E 11I 11		case TYPE_ARRAYBLOCK:			if ((index == -1) && reclaimarrayblock(tmpptr)) E 11E 9E 4				goto trynext;D 9			 else break;	/* added Nov-26-1987 by Tomtom */		case 8: if ((index == NIL) && reclaimstackp(tmpptr))			 { /* printf("*** Reclaiming stackp(8) !!!ok!!!\n"); */				goto trynext;} /* Monitoring ***/			 else break;	/* added Nov-26-1987 by Tomtom */E 9I 9			 else break;	D 11		case 8: if ((index == -1) && reclaimstackp(tmpptr))E 11I 11		case TYPE_STACKP: if ((index == -1) && reclaimstackp(tmpptr))E 11			 { goto trynext;} 			 else break;	E 9D 11		case 10:E 11I 11		case TYPE_VMEMPAGEP:I 13			 DBPRINT(("Trying to reclaim VMEMPAGEP {}%o,%o.\n", HILOC(tmpptr), LOLOC(tmpptr)));E 13E 11D 9			 if ((index == NIL) && releasingvmempage(tmpptr))		/*	printf("*** Reclaiming vmempagep(10) !!!ok!!!\n"); */				 goto trynext; /* Monitoring ***/			 else break;	/* added Nov-26-1987 by Tomtom */E 9I 9			 if ((index == -1) && releasingvmempage(tmpptr))D 13				 goto trynext; E 13I 13			   {				DBPRINT(("Couldn't release VMEMPAGEP 0x%x.", tmpptr));				 goto trynext;			   }E 13			 else break;E 9D 11		case 50:		case 51:		case 52:		case 53:		case 54:		case 55:		case 56:		case 57:		case 58:		case 59:E 11I 11		case TYPE_CODEHUNK1:		case TYPE_CODEHUNK2:		case TYPE_CODEHUNK3:		case TYPE_CODEHUNK4:		case TYPE_CODEHUNK5:		case TYPE_CODEHUNK6:		case TYPE_CODEHUNK7:		case TYPE_CODEHUNK8:		case TYPE_CODEHUNK9:		case TYPE_CODEHUNK10:E 11D 9			if ((index == NIL) && reclaimcodeblock(tmpptr))E 9I 9			if ((index == -1) && reclaimcodeblock(tmpptr))E 9				goto trynext;D 9			else break;	/* added Nov-26-1987 by Tomtom */ E 9I 9			else break; E 9		default: 			  ;		}; 	normal: 		typdtd = (struct dtd *)GetDTD(typ); 		ptrfield = typdtd->dtd_ptrs; D 9		if (index != NIL)E 9I 9		if (index != -1)E 9		   { index = (index << 1);		     ptrfield = cdr(ptrfield);		     while ((car(ptrfield) & 0x0ffff) != index)			{ ptrfield = cdr(ptrfield);}D 9		     index = NIL;E 9I 9		     index = -1;E 9		   };			while(ptrfield != NIL)		{ carfield = car(ptrfield);		  ptrfield = cdr(ptrfield);D 4		  carfield = carfield & 0x0ffff;D 3		  val = gclookup((0x8000 | DELREF),(0x0ffffff & *(LispPTR *)				Addr68k_from_LADDR(tmpptr+carfield)));E 3I 3		  val = gclookup((0x0ffffff & *(LispPTR *)				Addr68k_from_LADDR(tmpptr+carfield)), DELREF);E 4I 4		  carfield &= 0x0ffff;D 8		  val = GCLOOKUP(0x8000,DELREF,(0x0ffffff & *(LispPTR *)E 8I 8		  val = GCLOOKUPV(0x8000,DELREF,(0x0ffffff & *(LispPTR *)E 8				Addr68k_from_LADDR(tmpptr+carfield)));E 4E 3		  if (val != NIL)			{if (ptrfield != NIL)				{ ptr = (ConsCell *)Addr68k_from_LADDR(tmpptr);				  ptr->car_field = donext;				  ptr->cdr_code = ((car(ptrfield) & 0x0ffff)								>> 1);				  donext = tmpptr;				  goto doval;				}			 else			   goto addtofreelist;			};		};	addtofreelist:I 13#ifdef DEBUG		if (typ == TYPE_VMEMPAGEP) printf("Adding VMEMPAGEP to free list.\n");#endifE 13D 9/*		if (typ == 11)  * Monitor *			{if (typdtd->dtd_free == tmpptr)				{printf("***Lankage Broker *** : %d\n",tmpptr);				stab();};			};	*/E 9		field = (LispPTR *)Addr68k_from_LADDR(tmpptr);		*field	= typdtd->dtd_free;		typdtd->dtd_free = tmpptr;D 9	/*** Monitor ***/#ifdef TRACE  		freecnt = 0;		freeptr = typdtd->dtd_free;		printf("Type is %d\n",typ);		while (freeptr != NIL)		{		if (GetTypeNumber(freeptr) != typ)			printf("***!!! Linkage error : %d.\n",typ);		if (typ == 11) printf("* %d *\n",freeptr);		actptr = (LispPTR *)Addr68k_from_LADDR(freeptr);		freeptr = *actptr;		if (freeptr != NIL)		   {if (GetTypeNumber(freeptr) != typ)			printf("***!!! Linkage error : %d.\n",typ);		   };		++freecnt;		};		printf("***Linkage is right. & cnt = %d, type = %d.\n",								freecnt,typ);#endifE 9I 9E 9	doval:		if (val != NIL)			{ tmpptr = val;D 4			  gclookup((0x8000 | ADDREF),tmpptr); E 4I 4			  GCLOOKUP(0x8000, ADDREF,tmpptr); E 4			  val = NIL;			  goto lp;			};	trynext:		if (donext != NIL)			{ tmpptr = donext;			  ptr = (ConsCell *)Addr68k_from_LADDR(tmpptr);			  donext = (LispPTR)ptr->car_field;			  index = ptr->cdr_code;			  goto lp;			};	  return(NIL);	}freelistcell(cell)LispPTR	cell;	{ struct conspage 	*pbase; 	  register ConsCell		*cell68k;D 9/*	  DLword lowptr;  */	/*** for Monitor ***//*	  LispPTR lpptr;	  struct conspage *actptr;	  int freecnt;			*/ E 9	  cell68k = (ConsCell *)Addr68k_from_LADDR(cell);	  pbase = (struct conspage *)Addr68k_from_LPAGE(POINTER_PAGE(cell));	  cell68k->cdr_code = pbase->next_cell;D 9/*	  cell68k->car_field = NIL;		*//* not required clearing */E 9	  pbase->next_cell = (cell & 0x0ff);	  if ((++pbase->count > 2) && (pbase->next_page == CONSPAGE_LAST)) D 9		/* CONSPAGE_LAST = 0x0ffff */ E 9		{ pbase->next_page = ListpDTD->dtd_nextpage;  D 9		 /* ListpDTD is on lispglobal.h */ E 9		  ListpDTD->dtd_nextpage = POINTER_PAGE(cell); 		};D 9	  /*** Monitor *****//*	   lowptr = ListpDTD->dtd_nextpage;	   lpptr = ((lowptr & 0x0ffff) << 8);	   actptr = (struct conspage *)Addr68k_from_LADDR(lpptr);	   freecnt = actptr->count;	   while ((lowptr = actptr->next_page) != NIL)		{lpptr = ((lowptr & 0x0ffff) << 8);		 actptr = (struct conspage *)Addr68k_from_LADDR(lpptr);		 freecnt += actptr->count;		 };I 6#ifdef  DEBUGE 6D 7	   printf("***Current free cells is %d.\n",freecnt);	*/E 7I 7	   printf("***Current free cells is %d.\n",freecnt);E 7I 6#endifI 7	*/E 9E 7E 6		 	   	}D 9E 9E 1