h02190s 00094/00047/00915d D 2.24 92/11/25 21:04:06 sybalsky 31 30c Fixing endif's with extra text => comment. \nes 00004/00004/00958d D 2.23 92/04/21 16:51:07 sybalsky 30 29c shortening file names for DOSes 00197/00082/00765d D 2.22 91/05/06 15:42:53 sybalsky 29 28c Fix ethernet-packet dropping buges 00063/00059/00784d D 2.21 90/09/18 23:43:28 sybalsky 28 27c Retrofit changes from AIX, DEC3100, PS/2es 00000/00000/00843d D 2.20 90/08/21 17:15:15 sybalsky 27 26c Retrofit AIX changes from IBMes 00007/00000/00836d D 2.19 90/07/04 03:58:28 sybalsky 26 25c es 00003/00000/00833d D 2.18 90/06/22 16:38:56 fuji 25 24c New compile flag NOETHERes 00202/00138/00631d D 2.17 90/06/13 18:34:55 sybalsky 24 23c AIX portability changeses 00000/00000/00769d D 2.16 90/04/20 01:28:49 sybalsky 23 22c ile names, bulk change.es 00001/00000/00768d D 2.15 90/03/02 11:27:33 sybalsky 22 21c Add h-file for lisptypes.h, for 386 change to checksum.es 00005/00007/00763d D 2.14 90/03/02 11:13:37 sybalsky 21 20c fix byte-swap needs, in checksum codees 00002/00001/00768d D 2.13 90/03/01 14:20:59 osamu 20 19c remove(coment out) select() in check_ether(). c Because select() is already called in getsignaldata().es 00011/00003/00758d D 2.12 89/12/29 12:58:43 sybalsky 19 18c Changes from Savoir -- Interrupt driven codees 00110/00085/00651d D 2.11 89/12/28 15:24:59 sybalsky 18 17c es 00111/00044/00625d D 2.10 89/12/13 10:55:05 sybalsky 17 16c interrupt-driven versiones 00003/00008/00666d D 2.9 89/02/13 14:14:33 sybalsky 16 15c Made ether failures NOT close the handle, so they may be recoverable rather than fatal.es 00011/00011/00663d D 2.8 88/12/23 14:01:24 shih 15 14c wrong sccs ides 00247/00008/00427d D 2.7 88/10/12 21:06:03 bane 14 13c Has OS4 ifdefs for both OS3 and OS4 Ethernetes 00003/00002/00432d D 2.6 88/07/18 11:58:31 root 13 12c If ether not initialized, at least clear last machine's addresses 00002/00000/00432d D 2.5 88/06/30 11:10:00 greep 12 11c put "#ifdef DEBUG" around printfes 00052/00044/00380d D 2.4 88/06/13 17:07:11 bane 11 10c Code to run with lispgo net opener programes 00062/00092/00362d D 2.3 88/06/10 13:52:24 bane 10 9c Improved init_ether, cleaned up support code thereofes 00036/00000/00418d D 2.2 88/04/19 11:37:34 shimizu 9 8c Add check_sumes 00000/00000/00418d D 2.1 88/05/17 09:23:42 hayata 8 7c Version up to 2.1es 00010/00005/00408d D 1.7 88/05/16 15:16:46 masinter 7 6c separate ether initialization from setting host number in IFpage, allows ether turnon before loading sysoutes 00216/00194/00197d D 1.6 88/05/11 12:04:33 hayata 6 5c New ether code by Yasuhiko Kiuchies 00004/00000/00387d D 1.5 88/04/27 09:15:04 bane 5 4c Added int_io_open and int_io_close calls for I/O interrupt stuffes 00002/00002/00385d D 1.4 88/04/11 18:09:57 hayata 4 3c Add SCCS key ides 00003/00003/00384d D 1.3 88/04/11 18:07:18 hayata 3 2c Change LispReadFds declaration to fix ether buges 00002/00002/00385d D 1.2 88/03/13 14:45:33 hayata 2 1c Add SCCS key id (%Z%)es 00387/00000/00000d D 1.1 88/02/24 16:56:31 hayata 1 0c date and time created 88/02/24 16:56:31 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 3/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 3I 3D 4/* This is G-file @(#) ether.c Version 1.2 (3/13/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) ether.c	1.2 3/13/88";E 4I 4D 14/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 14I 14D 15/* This is G-file @(#) ether.c Version 1.1 (9/20/88). copyright envos & Fuji Xerox  */static char *id = "@(#) ether.c	1.1 9/20/88		(envos & Fuji Xeorx)";E 15I 15D 17/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 17I 17D 21/* @(#) ether.c Version 2.9 (2/13/89). copyright envos & Fuji Xerox  */static char *id = "@(#) ether.c	2.9 2/13/89		(envos & Fuji Xerox)";E 21I 21/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%	(venue & Fuji Xerox)";E 21I 18D 29E 29/************************************************************************//*									*/D 29/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 29I 29/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*//*	Manufactured in the United States of America.			*/E 29/*									*/D 29/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 29I 29/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 29/*									*//************************************************************************/D 29E 29E 18E 17E 15E 14E 4E 3E 2/*I 6 *E 6 *	ether.c, Tue Oct 27 17:24:13 1987D 18 *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.E 18 */I 25D 28#ifdef NOETHER#elseE 25I 6E 28E 6#include <stdio.h>I 17D 18#include <errno.h>E 18E 17#include <ctype.h>#include <sys/file.h>I 18#include <signal.h>#include <errno.h>E 18#include <sys/types.h>#include <sys/time.h>#include <sys/socket.h>#include <net/if.h>#include <netdb.h>#include <netinet/in.h>I 28#ifndef NOETHERE 28#include <netinet/if_ether.h>I 24D 28#ifndef AIXE 28E 24#include <net/nit.h>I 24D 28#endif AIXE 28I 28D 31#endif NOETHERE 31I 31#endif /* NOETHER */E 31E 28E 24#include <sys/ioctl.h>I 14#ifdef OS4#include <stropts.h>#include <net/nit_if.h>#include <net/nit_pf.h>/* #include <net/nit_buf.h> */#include <net/packetfilt.h>D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14#include <sys/mbuf.h>#include <nlist.h>#include "lispemul.h"I 9#include "lispmap.h"E 9I 6D 30#include "emulglobal.h"I 22#include "lisptypes.h"E 22E 6#include "lispglobal.h"#include "address68k.h"E 30I 30#include "emlglob.h"#include "lsptypes.h"#include "lspglob.h"#include "adr68k.h"E 30#include "ether.h"I 17#include "dbprint.h"E 17D 3extern int	LispReadFds;E 3I 3D 6extern u_int	LispReadFds;E 6I 6u_int	EtherReadFds;E 6E 3int ether_fd = -1;	/* file descriptor for ether socket */D 6int ether_filter = 3;	/* bit 0=me 1=broadcast 2=multicast 3=all */E 6D 10u_char ether_host[6];	/* 48 bit address of this node */E 10I 10u_char ether_host[6] = {0,0,0,0,0,0};	/* 48 bit address of this node */E 10u_char broadcast[6] = {255, 255, 255, 255, 255, 255};int ether_bsize = 0;	/* if nonzero then a receive is pending */u_char *ether_buf;	/* address of receive buffer */D 18u_char nit_buf[2000];	/* the current chunk read from NIT (one packet) */E 18I 18u_char nit_buf[3000];	/* the current chunk read from NIT (one packet) */E 18I 17extern LispPTR *PENDINGINTERRUPT68k;extern u_int   LispReadFds;E 17D 6DLETHERIOCB *ether_icb;	/* icb to signal when receive completes */E 6I 26int ETHEREventCount = 0;E 26I 6#define	PacketTypeIP	0x0800#define	PacketTypeARP	0x0806#define	PacketTypeRARP	0x8035#define	PacketTypeXNS	0x0600#define	PacketTypePUP	0x0200#define	PacketType3TO10	0x0201I 24D 28#ifndef AIXE 28I 28#ifndef NOETHERE 28E 24I 14#ifdef OS4/* the receiving packetfilter structure *//* if this is changed, be sure to get the references to it in init_ether	and check the length (the second entry in the structure) */struct packetfilt goodpf = {0, 29,{ENF_PUSHWORD+6, ENF_PUSHLIT+ENF_CNOR, PacketTypeIP,	/* punt if PacketTypeIP */ENF_PUSHWORD+6, ENF_PUSHLIT+ENF_CNOR, PacketTypeARP,	/* or PacketTypeARP */ENF_PUSHWORD,	ENF_PUSHLIT+ENF_EQ,   8,		/* check our addr */ENF_PUSHWORD+1,	ENF_PUSHLIT+ENF_EQ,   11,		/* which is filled in */ENF_PUSHWORD+2,	ENF_PUSHLIT+ENF_EQ,   14,		/* in init_ether */ENF_AND, ENF_AND,ENF_PUSHWORD,	ENF_PUSHLIT+ENF_EQ,   0xFFFF,		/* check broadcast */ENF_PUSHWORD+1,	ENF_PUSHLIT+ENF_EQ,   0xFFFF,		/* which is all ones */ENF_PUSHWORD+2,	ENF_PUSHLIT+ENF_EQ,   0xFFFF,ENF_AND, ENF_AND,ENF_OR}};/* a filter that rejects all packets to be used by ether_suspend and the	initial routine to flush out ether_fd */struct packetfilt nopf = {0, 1, {ENF_PUSHZERO}};D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14E 6int ether_in = 0;	/* number of packets received */int ether_out = 0;	/* number of packets sent */I 14#ifndef OS4E 14D 10static char *getintname();E 10static struct nit_ioc nioc;I 14D 31#endif OS4I 24D 28#endif AIXE 28I 28#endif NOETHERE 31I 31#endif /* OS4 */E 31E 28E 24E 14I 31#endif /* NOETHER */E 31I 24I 31E 31E 24D 6InitEther()E 6I 6D 29/********************************************************************** *	ether_suspend(args) 175/70/0 *	suspend nit socket not to receive any packets **********************************************************************/E 29I 29/************************************************************************//*									*//*			e t h e r _ s u s p e n d			*//*									*//*	Suspend receiving packets from the NIT socket.			*//*	175/70/0							*//*									*//************************************************************************/E 29ether_suspend(args)D 29LispPTR	  args[];E 6{E 29I 29  LispPTR	  args[];  {E 29I 24D 28#ifndef AIXE 28I 28#ifndef NOETHERE 28E 24I 14#ifdef OS4D 29static struct packetfilt pf = {0, 1, {ENF_PUSHZERO}};E 29I 29    static struct packetfilt pf = {0, 1, {ENF_PUSHZERO}};E 29D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14D 6    struct sockaddr_nit snit;    if ((ether_fd = socket(AF_NIT, SOCK_RAW, NITPROTO_RAW)) >= 0) {	/* bind the socket to an interface */	snit.snit_family = AF_NIT;	strncpy(snit.snit_ifname, getintname(ether_fd), sizeof(snit.snit_ifname));	bind(ether_fd, &snit, sizeof(snit));	/* establish the operating modes */	bzero(&nioc, sizeof(nioc));	nioc.nioc_bufspace = 20000;	nioc.nioc_chunksize = 50;	/* small chunks so each packet read */	nioc.nioc_typetomatch = NT_ALLTYPES;	nioc.nioc_snaplen = 32767;	nioc.nioc_flags = 0;	if (ioctl(ether_fd, SIOCSNIT, &nioc) != 0) {		printf("InitEther: ioctl failed\n");I 5		int_io_close(ether_fd);E 5	    close(ether_fd);	    ether_fd = -1;	    return;	}	LispReadFds |= (1 << ether_fd);I 5	int_io_open(ether_fd);E 5	printf("InitEther: **** socket is opened ****\n");    } else {	printf("InitEther: can't open NIT socket\n");	ether_fd = -1;    }}voidEtherSuspend(){E 6D 29	if (ether_fd == -1)D 6		return;E 6I 6		return(NIL);E 29I 29    if (ether_fd == -1) return(NIL);E 29I 14#ifndef OS4E 14E 6D 29	nioc.nioc_typetomatch = NT_NOTYPES;	if ( ioctl(ether_fd, SIOCSNIT, &nioc) != 0) {D 6		printf("EtherSuspend: ioctl failed\n");I 5		int_io_close(ether_fd);E 6I 6		printf("ether_suspend: ioctl failed\n");E 29I 29    nioc.nioc_typetomatch = NT_NOTYPES;    if ( ioctl(ether_fd, SIOCSNIT, &nioc) != 0)      {	printf("ether_suspend: ioctl failed\n");E 29I 14D 31#else OS4E 31I 31#else /* OS4 */E 31D 29/* The trick here is to install a packet filter that rejects all packets,	I think... */	if ( ioctl(ether_fd, NIOCSETF, &nopf) != 0) {		perror("ether_suspend: NIOCSETF failed\n");E 29I 29    /* The trick here is to install a packet filter */    /* that rejects all packets, I think... 	*/    if ( ioctl(ether_fd, NIOCSETF, &nopf) != 0)      {	perror("ether_suspend: NIOCSETF failed\n");E 29D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14E 6E 5D 16		close(ether_fd);		ether_fd = -1;E 16I 16D 29		return(NIL);E 16	}E 29I 29	return(NIL);      }E 29I 24D 28#endif AIXE 28I 28D 31#endif NOETHERE 31I 31#endif /* NOETHER */E 31E 28E 24D 6}E 6I 6D 29	return(ATOM_T);} /* ether_suspend */E 29I 29    return(ATOM_T);  } /* ether_suspend */E 29E 6I 24E 24D 6voidEtherResume()E 6I 6D 29/********************************************************************** *	ether_resume(args) 175/71/0 *	resume nit socket to receive all types of packets **********************************************************************/E 29I 29/************************************************************************//*									*//*			e t h e r _ r e s u m e				*//*									*//*	resume nit socket to receive all types of packets 175/71/0	*//*									*//************************************************************************/E 29ether_resume(args)D 29LispPTR	  args[];E 6{	if (ether_fd == -1)D 6		return;E 6I 6		return(NIL);E 29I 29  LispPTR	  args[];  {    if (ether_fd == -1) return(NIL);E 29I 24D 28#ifndef AIXE 28I 28#ifndef NOETHERE 28E 24I 14#ifndef OS4E 14E 6D 29	nioc.nioc_typetomatch = NT_ALLTYPES;	if ( ioctl(ether_fd, SIOCSNIT, &nioc) != 0) {D 6		printf("EtherResume: ioctl failed\n");I 5		int_io_close(ether_fd);E 6I 6		printf("ether_resume: ioctl failed\n");E 29I 29    nioc.nioc_typetomatch = NT_ALLTYPES;    if ( ioctl(ether_fd, SIOCSNIT, &nioc) != 0)      {	printf("ether_resume: ioctl failed\n");E 29I 14D 31#else OS4E 31I 31#else /* OS4 */E 31/* Install a packet filter that accepts all packets we want */D 29	if ( ioctl(ether_fd, NIOCSETF, &goodpf) != 0) {		perror("ether_resume: NIOCSETF failed\n");E 29I 29    if ( ioctl(ether_fd, NIOCSETF, &goodpf) != 0)      {	perror("ether_resume: NIOCSETF failed\n");E 29D 31#endif OS4E 31I 31#endif /* OS4 */E 31I 24D 28#endif AIXE 28E 24E 14E 6E 5D 16		close(ether_fd);		ether_fd = -1;E 16I 16D 29		return(NIL);E 16	}E 29I 29	return(NIL);      }E 29I 28D 31#endif NOETHERE 31I 31#endif /* NOETHER */E 31E 28D 6}E 6I 6D 29	return(ATOM_T);} /* ether_resume */E 29I 29    return(ATOM_T);  } /* ether_resume */E 29E 6I 24E 24D 6EtherCtrlr()E 6I 6D 29/********************************************************************** *	ether_ctrlr(args) 175/72/0 *	return T if ether controller is available **********************************************************************/E 29I 29/************************************************************************//*									*//*			e t h e r _ c t r l r				*//*									*//*	return T if ether controller is available 175/72/0		*//*									*//************************************************************************/E 29ether_ctrlr(args)D 29LispPTR	  args[];E 6{D 6	if (ether_fd < 0) return(0);	return(1);E 6I 6	if (ether_fd < 0) return(NIL);	return(ATOM_T);} /* ether_ctrlr */E 29I 29  LispPTR	  args[];  {    if (ether_fd < 0) return(NIL);    return(ATOM_T);  }E 29E 6I 24E 24D 6} /* end EtherCtrlr */EtherReset()E 6I 6/********************************************************************** *	ether_reset(args) 175/73/0 *	reset ether controller and disable receipt of packets **********************************************************************/ether_reset(args)D 29LispPTR	  args[];{E 6	/*	 *	Reset the Ethernet controllerD 6	 *	Disable receipt of Ethernet packets and set the incoming	 *	packet filter to recieve me and broadcast.E 6I 6	 *	Disable receipt of Ethernet packets.E 6	 */D 6{E 6	int i;	char hostnumber[6];E 29I 29  LispPTR args[];  {    int i;    char hostnumber[6];E 29D 6	if (ether_fd < 0) {return;}E 6I 6D 29	if (ether_fd < 0) {return(NIL);}E 6D 10	get_rom_ID(hostnumber);D 6	E 6	if (ether_addr_equal(ether_host, hostnumber) == 0) {D 6		perror("Lisp Ether: bad address");		return;E 6I 6		perror("ether_reset: bad address");		return(NIL);E 6	}E 10I 10	/* JRB - host number check removed here; if ether_fd is open here,E 29I 29    if (ether_fd < 0) {return(NIL);}    /* JRB - host number check removed here; if ether_fd is open here,E 29		net is on... */E 10D 6	ether_filter = 3;	/* recieve me and broadcast */E 6D 29	ether_bsize = 0;	/* deactivate receiver */I 6	return(ATOM_T);} /* ether_reset */E 29I 29    ether_bsize = 0;	/* deactivate receiver */    return(ATOM_T);  } /* ether_reset */E 29E 6I 17E 17D 6} /* end EtherReset */EtherGetPacket(MaxByteCount, LispBufferAddr, LispIcb)	LispPTR	LispBufferAddr, MaxByteCount, LispIcb;E 6I 6D 29/********************************************************************** *	ether_get(args) 175/74/2 max_words,buffer_addrD 24 *	active the recieverE 24I 24 *	active the receiverE 24 **********************************************************************/E 29I 29/************************************************************************//*									*//*			  e t h e r _ g e t (175/74/2)			*//*									*//*	Set up the Ethernet driver to receive a packet.  The driver	*//*	first tries to read any pending packet from the net, and if	*//*	there is one, ether_get returns T.  If there is no pending	*//*	packet, the failing read sets us up to get an interrupt when	*//*	a packet DOES arrive, and ether_get returns NIL.		*//*									*//*		args[0] Length of the buffer we're passed		*//*		args[1] LISP address of a packet buffer			*//*									*//*	sets ether_buf to the buffer address, for check_ether's use	*//*	sets ether_bsize to the buffer size.  ether_bsize>0 means	*//*	it's OK to read packets from the network on interrupt.		*//*									*//************************************************************************/E 29ether_get(args)D 15LispPTR	args[]; E 15I 15D 17LispPTR	args[];E 15{E 6	/*	 *	Set up the Ethernet driver to receive a packet.  The driverD 6	 *	will copy the next incoming packet ( which is not discarded	 *	by the packet filter) into the packet buffer pointed to byE 6I 6	 *	will copy the next incoming packet	 *	into the packet buffer pointed to byE 6	 *	BufferAddr. If the Ethernet driver has buffered an	 *	incoming packet, the icb may be signalled immediately.	 *	Any incoming packets which are too big to fit in the buffer	 *	will be discarded.I 6	 *	args[0] : MaxWordCount	 *	args[1] : LispBufferAddrE 6	 */D 6{	if (ether_fd >= 0 && MaxByteCount > 0) {E 6I 6	LispPTR MaxByteCount;E 17I 17  LispPTR	args[];  {D 29    /*     *	Set up the Ethernet driver to receive a packet.  The driver     *	will copy the next incoming packet     *	into the packet buffer pointed to by     *	BufferAddr. If the Ethernet driver has buffered an     *	incoming packet, the icb may be signalled immediately.     *	Any incoming packets which are too big to fit in the buffer     *	will be discarded.     *	args[0] : MaxWordCount     *	args[1] : LispBufferAddr     */E 29    LispPTR MaxByteCount;D 29    int rfds;E 29I 29    LispPTR result = NIL;E 29I 18    int interrupt_mask;E 18E 17I 24D 28#ifndef AIXE 28I 28#ifndef NOETHERE 28E 24D 17	MaxByteCount = 2 * (0xFFFF & args[0]); /* words to bytes */	if (ether_fd >= 0 && (MaxByteCount > 0)) {E 6		ether_bsize = MaxByteCount;D 6		ether_buf = (u_char *)Addr68k_from_LADDR(LispBufferAddr);		ether_icb = (DLETHERIOCB *)Addr68k_from_LADDR(LispIcb);E 6I 6		ether_buf = (u_char *)Addr68k_from_LADDR(args[1]);E 6	}E 17I 17    MaxByteCount = 2 * (0xFFFF & args[0]); /* words to bytes */I 18    DBPRINT(("Ether Get.  "));    interrupt_mask = sigblock(sigmask(SIGIO)); /* turn off ENET interrupts */E 18    if (ether_fd >= 0 && (MaxByteCount > 0))      {D 18	ether_bsize = MaxByteCount;E 18	ether_buf = (u_char *)Addr68k_from_LADDR(args[1]);D 18     }    check_ether();	/* check for newly-arrived packets */    if (ether_bsize == 0)      { /* Packets arrived; need to set up interrupt request */#ifdef OS4#else /* not OS4 */#endifE 18I 18	ether_bsize = MaxByteCount; /* do this LAST; it enables reads */I 29	result = get_packet(); /*	check_ether(); for old behavior, move comment to above line */E 29E 18      }I 18D 29    check_ether();	/* check for newly-arrived packets */E 29    sigsetmask(interrupt_mask);	/* interrupts back on */I 24D 28#endif AIXE 28I 28D 31#endif NOETHERE 31I 31#endif /* NOETHER */E 31E 28E 24I 31E 31E 18E 17I 6D 29    return (ATOM_T);E 29I 29    return (result);E 29D 17} /* ether_get */E 17I 17  } /* ether_get */E 17E 6I 17E 17D 6} /* end EtherGetPacket */EtherSendPacket(MaxByteCount, LispBufferAddr, LispOcb)	LispPTR	LispBufferAddr, MaxByteCount, LispOcb;E 6I 6/********************************************************************** *	ether_send(args) 175/75/2 max_words,buffer_addr *	send a packet **********************************************************************/I 14#define OFFSET sizeof(sa.sa_data)E 14ether_send(args)LispPTR	args[];{E 6	/*	 *	Send a packet.	 */D 6{E 6	struct sockaddr sa;D 14	int offset = sizeof (sa.sa_data);E 14D 6	char *BufferAddr;	DLETHERIOCB *Ocb;E 6D 6	BufferAddr = (char *)Addr68k_from_LADDR(LispBufferAddr);	Ocb = (DLETHERIOCB *)Addr68k_from_LADDR(LispOcb);E 6I 6	LispPTR MaxByteCount;	char *BufferAddr; /* buffer address pointer(in native address) */E 6I 24D 28#ifndef AIXE 28I 28#ifndef NOETHERE 28E 24I 6	MaxByteCount = 2 * (0xFFFF & args[0]); /* words to bytes */	BufferAddr = (char *)Addr68k_from_LADDR(args[1]);E 6	if (ether_fd >= 0) {I 14#ifdef OS4		struct strbuf ctl,data;D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14D 6		sa.sa_family = AF_UNSPEC;	/* required for the NIT protocol */E 6I 6		sa.sa_family = AF_UNSPEC; /* required for the NIT protocol */E 6D 14		bcopy(BufferAddr, sa.sa_data, offset);		if ( sendto(ether_fd, BufferAddr+offset, MaxByteCount-offset, 0,			&sa, sizeof(sa)) == (MaxByteCount-offset) );E 14I 14		bcopy(BufferAddr, sa.sa_data, OFFSET);#ifndef OS4		if ( sendto(ether_fd, BufferAddr+OFFSET, MaxByteCount-OFFSET, 0,			&sa, sizeof(sa)) == (MaxByteCount-OFFSET) );E 14		else perror("Lisp Ether: sendto");D 6		Ocb->DLIOCBSTATUS = 0x0001; /* notify OCB */E 6		ether_out++;I 14D 31#else OS4E 31I 31#else /* OS4 */E 31		ctl.maxlen = ctl.len = sizeof(sa);		ctl.buf = (char *)&sa;		data.maxlen = data.len = MaxByteCount - OFFSET;		data.buf = BufferAddr + OFFSET;		if(putmsg(ether_fd, &ctl, &data, 0)<0) {			perror("Ether_send lost");D 16			close(ether_fd);			ether_fd = -1;E 16I 16			return(NIL);E 16		}		else {			ether_out++;			/* flush the buffers to make sure the packet leaves */			/* maybe we'll use the buffering module some day... */			ioctl(ether_fd, I_FLUSH, FLUSHW);		}D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14	}I 24D 28#endif AIXE 28I 28D 31#endif NOETHERE 31I 31#endif /* NOETHER */E 31E 28I 31E 31E 24I 6	return(ATOM_T);} /* ether_send */E 6I 24E 24D 6} /* end EtherSendPacket */EtherSetFilter(FilterBits )	LispPTR	FilterBits;	/*	 *	Set the input packet filter according to the bit mask in	 *	FilterBits.  If FilterBits is zero, all user packets are	 *	ignored.  Bits in FilterBits have the following meaning:	 *	 *			Bit position:		Enables when set:	 *			-------------		-----------------	 *				0				Our ID receive	 *				1				Broadcast receive	 *				2				Multicast receive	 *				3				All host ID receive	 */E 6I 6/********************************************************************** *	ether_setfilter(args) 175/75/1 filterbits *	check whether a packet has come. if does, notify iocb **********************************************************************/I 24E 24ether_setfilter(args)D 24LispPTR	args[];E 6{D 6	if (ether_fd < 0) {return;}	ether_filter = FilterBits & 255;E 6I 6	return(NIL);} /* ether_setfilter */E 24I 24  LispPTR	args[];  {    return(NIL);  } /* ether_setfilter */E 24E 6I 24E 24D 6} /* end EtherSetFilter */E 6I 6/********************************************************************** *	ether_debug() *	returns the ethernet statistics. **********************************************************************/I 24E 24E 6int estat[3];I 24E 24D 6int *EtherGetStatistic(StatisticNum)	int StatisticNum;	/*	 *	Returns the statistic index by StatisticNum.  If StatisticNum	 *	is zero, the controller 48-bit host number and a flag	 *	indicating whether any input signals are waiting is returned.	 */E 6I 6int *ether_debug()E 6D 24{	estat[0] = 0;D 6	if (ether_fd < 0) return(&estat[0]);	if (StatisticNum == 4) {		printf("fd %d filter %d bsize %d buf %X iocb %X in %d out %d\n ",ether_fd,ether_filter,ether_bsize,(int)ether_buf,ether_icb,ether_in,ether_out);	}	if (StatisticNum == 3) {		estat[0] = ether_out;	}	if (StatisticNum == 2) {		estat[0] = ether_in;	}	if (StatisticNum == 1) {		estat[0] = 0;	}	if (StatisticNum == 0) {		estat[1] =  255 & ether_host[5];		estat[1] += (255 & ether_host[4]) << 8;		estat[0] =  255 & ether_host[3];		estat[0] += (255 & ether_host[2]) << 8;		estat[0] += (255 & ether_host[1]) << 16;		estat[0] += (255 & ether_host[0]) << 24;		if (ether_bsize == 0) estat[2] = 0; else estat[2] = 1;	}E 6I 6	if (ether_fd < 0) return(NIL);	printf("fd %d bsize %d buf %X icb %X in %d out %d\n ",ether_fd,ether_bsize,(int)ether_buf,IOPage->dlethernet[3],ether_in,ether_out);E 6	return(estat);I 6} /* end ether_debug */E 24I 24  {D 28#ifndef AIXE 28I 28#ifndef NOETHERE 28    estat[0] = 0;    if (ether_fd < 0) return(NIL);    printf("fd %d bsize %d buf %X icb %X in %d out %d\n ",	    ether_fd, ether_bsize, (int)ether_buf,	    IOPage->dlethernet[3],ether_in,ether_out);D 28#endif AIXE 28I 28D 31#endif NOETHERE 31I 31#endif /* NOETHER */E 31E 28    return(estat);  } /* end ether_debug */E 24E 6D 6} /* end EtherGetStatistics */E 6D 6CheckEther()E 6I 6static	struct timeval	EtherTimeout = {D 15	0, 0	E 15I 15	0, 0E 15};I 17D 18#ifndef OS4	/* Statics used to keep track of where in the NIT */	/* buffer we had been reading from...		  */static int posi=0, nitbuflen=0;#endifE 18I 18E 18E 17/********************************************************************** *	check_ether()D 18 *	checks an incomming packetE 18I 18 *	checks an incoming packetE 18 **********************************************************************/I 18#ifndef OS4static int nitpos=0, nitlen=0; /* for NIT read buffer in OS3 */#endifE 18check_ether()D 17{E 17I 17  {E 17E 6	/*	 *	If receiver active then check if any packets are	 *	available from the ethernet.  If so, read the packetD 6	 *	and signal the icb and return 1.E 6I 6	 *	and signal the icb and return T.E 6	 */I 24D 28#ifndef AIXE 28I 28#ifndef NOETHERE 28E 24I 14#ifndef OS4E 14D 6{E 6I 6D 17        static int  rfds;E 6	int result, fromlen;	struct nit_hdr header;	int posi, i;E 17I 17    static int  rfds;D 18    int result, fromlen, i;E 18I 18    int result, fromlen;E 18    struct nit_hdr header;I 18    int posi, i;E 18E 17I 14D 31#else OS4E 31I 31#else /* OS4 */E 31    static int  rfds;D 17	int result;	int i;	u_long plen;	struct strbuf ctl, data;	char ctlbuf[2000];E 17I 17    int result;    int i;    u_long plen;    struct strbuf ctl, data;    char ctlbuf[2000];E 17D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14I 31E 31I 6D 17  rfds = EtherReadFds;E 17I 17    rfds = EtherReadFds;E 17I 14#ifndef OS4I 18    i = 2;E 18E 14D 17  if( select(32, &rfds, NULL, NULL, &EtherTimeout) >= 0 ){    if( (ether_fd >= 0) && (rfds & (1 << ether_fd)) ){E 6	if (ether_bsize > 0) {D 6	result = read (ether_fd, nit_buf, sizeof(nit_buf));		/* enumerate the NIT headers until the packet is found */		posi = 0;		while (posi < result) {			bcopy(&nit_buf[posi], &header, sizeof(header));			posi += sizeof(header);			switch (header.nh_state) {			case NIT_CATCH:				fromlen = header.nh_datalen;				if (check_filter(&nit_buf[posi])) {					bcopy(&nit_buf[posi], &ether_buf[0], fromlen);					ether_in++;					ether_icb->DLIOCBBYTESUSED = fromlen;					ether_bsize = 0; /* deactivate receiver */					ether_icb->DLIOCBSTATUS = 0x0001; /* notify ICB */					return(1);				}				posi += fromlen;				break;			case NIT_QUIET:			case NIT_NOMBUF:	/* ignor all the other header types */			case NIT_NOCLUSTER:			case NIT_NOSPACE:			case NIT_SEQNO: break;E 6I 6D 15 	 result = read (ether_fd, nit_buf, sizeof(nit_buf));E 15I 15	 result = read (ether_fd, nit_buf, sizeof(nit_buf));E 15	 /* enumerate the NIT headers until the packet is found */	 posi = 0;	 while (posi < result) {E 17I 17    if(/* select(32, &rfds, NULL, NULL, &EtherTimeout) >= 0 ) */ (1))      {D 18	if( (ether_fd >= 0) && (rfds & (1 << ether_fd)) )E 18I 18	if( (ether_fd >= 0) && (ether_bsize > 0) )E 18	  {D 18	    if (ether_bsize > 0) E 18I 18	    while ( (select(32, &rfds, NULL, NULL, &EtherTimeout) >= 0)		    && (i-- > 0) ) E 18	      {D 18		if (posi >= nitbuflen)		  { /* No more was left from the last NIT read; get more */		    nitbuflen = read (ether_fd, nit_buf, sizeof(nit_buf));		    posi = 0;E 18I 18		if (nitpos>=nitlen)		  { /* Used up last NIT buffer full; read another. */		    nitlen = read (ether_fd, nit_buf, sizeof(nit_buf));		    nitpos = 0;E 18		  }D 18	 /* Enumerate the NIT packet headers, looking for intereting ones */		while (posi < nitbuflen) {E 17		bcopy(&nit_buf[posi], &header, sizeof(header));		posi += sizeof(header);		switch (header.nh_state) {		case NIT_CATCH:			fromlen = header.nh_datalen;			if (check_filter(&nit_buf[posi])) {			   bcopy(&nit_buf[posi], &ether_buf[0], fromlen);			   ether_bsize = 0; /* deactivate receiver */			   ether_in++;			   IOPage->dlethernet[3] = fromlen;D 17			   return(ATOM_T);E 17I 17			   ((INTSTAT*)Addr68k_from_LADDR(*INTERRUPTSTATE_word))->ETHERInterrupt = 1;			   Irq_Stk_Check = Irq_Stk_End=0;			   *PENDINGINTERRUPT68k = ATOM_T;			   posi += fromlen;			   return(NIL);			   /* return(ATOM_T); */E 17E 6			}I 6			posi += fromlen;			break;		case NIT_QUIET:		case NIT_NOMBUF:	/* ignor all the other header types */		case NIT_NOCLUSTER:		case NIT_NOSPACE:		case NIT_SEQNO: break;E 18I 18		/* enumerate the NIT headers until the packet is found */		while (nitpos < nitlen)		  {		    bcopy(&nit_buf[nitpos], &header, sizeof(header));		    nitpos += sizeof(header);		    switch (header.nh_state)		      {			case NIT_CATCH:			  fromlen = header.nh_datalen;			  if (check_filter(&nit_buf[nitpos]))			    {			      bcopy(&nit_buf[nitpos], &ether_buf[0], fromlen);			      ether_bsize = 0; /* deactivate receiver */			      ether_in++;			      IOPage->dlethernet[3] = fromlen;			      DBPRINT(("Found packet len %d, at pos %d in buflen %d.\n", fromlen, nitpos, nitlen));			      nitpos += fromlen;			      ((INTSTAT*)Addr68k_from_LADDR(*INTERRUPTSTATE_word))->ETHERInterrupt = 1;I 26			      ETHEREventCount++;E 26			      Irq_Stk_Check = Irq_Stk_End=0;			      *PENDINGINTERRUPT68k = ATOM_T;			      /* return(NIL); */			      return(ATOM_T);			    }			  nitpos += fromlen;			  break;			/* ignore all the other header types */			case NIT_QUIET:	    break;			case NIT_NOMBUF:    DBPRINT(("No MBUFs\n")); break;			case NIT_NOCLUSTER: DBPRINT(("No Clusters\n")); break;			case NIT_NOSPACE:   DBPRINT(("No Space\n")); break;			case NIT_SEQNO:     break;		      }		  }	      }	  }      }E 18I 14D 31#else OS4E 31I 31#else /* OS4 */E 31  if(ether_fd >= 0 && ether_bsize > 0D 15  && select(32, &rfds, NULL, NULL, &EtherTimeout) >= 0 E 15I 15D 18  && select(32, &rfds, NULL, NULL, &EtherTimeout) >= 0E 15  && (rfds & (1 << ether_fd))) {E 18I 18D 20     && select(32, &rfds, NULL, NULL, &EtherTimeout) >= 0E 20I 20/*   && select(32, &rfds, NULL, NULL, &EtherTimeout) >= 0 *     -- [on '90/02/14: getsignsldata() chech this] */ E 20     && (rfds & (1 << ether_fd)))      {E 18	data.maxlen = sizeof(nit_buf);	data.len = 0;	data.buf = (char *)nit_buf;	ctl.maxlen = sizeof(ctlbuf);	ctl.len = 0;	ctl.buf = ctlbuf;	plen = 0;	result = getmsg(ether_fd, &ctl, &data, &plen);D 18	if(result >= 0 ) {D 15		if(data.len <= ether_bsize E 15I 15		if(data.len <= ether_bsizeE 15		&& data.len > 0) {			bcopy(nit_buf, &ether_buf[0], data.len);			ether_bsize = 0;			ether_in++;			IOPage->dlethernet[3] = data.len;D 17			return(ATOM_T);E 17I 17			((INTSTAT*)Addr68k_from_LADDR(*INTERRUPTSTATE_word))->ETHERInterrupt = 1;			   Irq_Stk_Check = Irq_Stk_End=0;			   *PENDINGINTERRUPT68k = ATOM_T;			return(NIL);			/* return(ATOM_T); */E 18I 18	if(result >= 0 )	  {	    if(data.len <= ether_bsize	       && data.len > 0)	      {		bcopy(nit_buf, &ether_buf[0], data.len);		ether_bsize = 0;		ether_in++;		IOPage->dlethernet[3] = data.len;		((INTSTAT*)Addr68k_from_LADDR(*INTERRUPTSTATE_word))->ETHERInterrupt = 1;I 26		ETHEREventCount++;E 26		Irq_Stk_Check = Irq_Stk_End=0;		*PENDINGINTERRUPT68k = ATOM_T;		return(NIL); /* return(ATOM_T); */	      }	  }	else if (errno != EWOULDBLOCK)	  {	    perror("Check_ether read error:\n");	  }      }E 18E 17D 31#endif OS4I 24D 28#endif AIXE 28I 28#endif NOETHERE 31I 31#endif /* OS4 */E 31E 28E 24E 14E 6D 18		}I 14#ifndef OS4E 14I 6	 }I 14#else OS4D 17	} else {E 17I 17	} else if (errno != EWOULDBLOCK) {E 17		perror("Check_ether read error:\n");D 16		close(ether_fd);		ether_fd = -1;E 16#endif OS4E 14E 6	}I 14#ifndef OS4E 14D 6	return(0);}E 6I 6    }I 14#endif OS4E 14  }  return(NIL);} /* end check_ether */E 18E 6I 31#endif /* NOETHER */E 31I 18    return(NIL);  }   /* end check_ether */I 29/************************************************************************//*									*//*				g e t _ p a c k e t			*//*									*//*	Try getting a packet, ala check_ether, returning NIL if none,	*//*	T if one was received.  This is used by ether_get only.		*//*									*//************************************************************************/get_packet()  {#ifndef NOETHER#ifndef OS4    static int  rfds;    int result, fromlen;    struct nit_hdr header;    int posi, i;D 31#else OS4E 31I 31#else /* OS4 */E 31    static int  rfds;    int result;    int i;    u_long plen;    struct strbuf ctl, data;    char ctlbuf[2000];D 31#endif OS4E 31I 31#endif /* OS4 */E 31I 31E 31#ifndef OS4    while (1)       {	if (nitpos>=nitlen)	  { /* Used up last NIT buffer full; read another. */	    nitlen = read (ether_fd, nit_buf, sizeof(nit_buf));	    if (nitlen < 0) return(NIL);  /* No more packets to try. */	    nitpos = 0;	  }	/* enumerate the NIT headers until the packet is found */	while (nitpos < nitlen)	  {	    bcopy(&nit_buf[nitpos], &header, sizeof(header));	    nitpos += sizeof(header);	    switch (header.nh_state)	      {		case NIT_CATCH:		  fromlen = header.nh_datalen;		  if (check_filter(&nit_buf[nitpos]))		    {		      bcopy(&nit_buf[nitpos], &ether_buf[0], fromlen);		      ether_bsize = 0; /* deactivate receiver */		      ether_in++;		      IOPage->dlethernet[3] = fromlen;		      DBPRINT(("Found packet len %d, at pos %d in buflen %d.\n",				fromlen, nitpos, nitlen));		      nitpos += fromlen;		      return(ATOM_T);		    }		  nitpos += fromlen;		  break;		/* ignore all the other header types */		case NIT_QUIET:	    break;		case NIT_NOMBUF:    DBPRINT(("No MBUFs\n")); break;		case NIT_NOCLUSTER: DBPRINT(("No Clusters\n")); break;		case NIT_NOSPACE:   DBPRINT(("No Space\n")); break;		case NIT_SEQNO:     break;	      }	  }      }D 31#else OS4E 31I 31#else /* OS4 */E 31    data.maxlen = sizeof(nit_buf);    data.len = 0;    data.buf = (char *)nit_buf;    ctl.maxlen = sizeof(ctlbuf);    ctl.len = 0;    ctl.buf = ctlbuf;    plen = 0;    result = getmsg(ether_fd, &ctl, &data, &plen);    if(result >= 0 )      {	if(data.len <= ether_bsize  && data.len > 0)	 {	    bcopy(nit_buf, &ether_buf[0], data.len);	    ether_bsize = 0;	    ether_in++;	    IOPage->dlethernet[3] = data.len;	    return(ATOM_T);	  }      }    else if (errno != EWOULDBLOCK) perror("Check_ether read error:\n");D 31#endif OS4#endif NOETHERE 31I 31#endif /* OS4 */E 31I 31#endif /* NOETHER */E 31    return(NIL);  }   /* end get_packet */E 29I 19E 19E 18D 6 /* check_filter  see if this packet passes the current filter setting */E 6I 6/**********************************************************************D 18 *	chech_filter(buffer)E 18I 18 *	check_filter(buffer)E 18 *	see if this packet passes the current filter settingI 14 *	This is believed obsolete with packet filtering enabledE 14 **********************************************************************/I 24E 24E 6check_filter(buffer)D 6E 6D 24u_char* buffer;{D 6short	packetType;#define	PacketTypeIP	0x800	packetType = ((short*)buffer)[6];	/* all packets */	if (ether_filter & 8) return(1);	/* multicast packets */	if ((ether_filter & 4) && (*buffer & 1)) return(1);E 6	/* braodcast packets */D 6	if ((ether_filter & 2) && ether_addr_equal(buffer, broadcast))		return(1);	/* discard IP packets */	if (packetType == PacketTypeIP) return(0);E 6I 6	if (ether_addr_equal(buffer, broadcast))		switch(((short*)buffer)[6]) {			case PacketTypeIP: return(0);			case PacketTypeARP: return(0);			default: return(1);		};E 6	/* my address */D 6	if ((ether_filter & 1) && ether_addr_equal(buffer, ether_host))		return(1);E 6I 6	if (ether_addr_equal(buffer, ether_host))		switch(((short*)buffer)[6]) {			case PacketTypeIP: return(0);			case PacketTypeARP: return(0);			default: return(1);		};E 6	return(0);}E 24I 24  u_char* buffer;  {    /* broadcast packets */    if (ether_addr_equal(buffer, broadcast))      switch(((short*)buffer)[6])	{	  case PacketTypeIP: return(0);	  case PacketTypeARP: return(0);	  default: return(1);	};    /* my address */    if (ether_addr_equal(buffer, ether_host))      switch(((short*)buffer)[6])	{	 case PacketTypeIP: return(0);	 case PacketTypeARP: return(0);	 default: return(1);	};    return(0);  }E 24I 19E 19I 6/********************************************************************** *	ether_addr_equal(add1, add2) *	checks ethernet addresses equalityI 14 *	Also believed obsoleteE 14 **********************************************************************/I 24E 24E 6ether_addr_equal(add1, add2)u_char add1[], add2[];D 24{	register int i;	for(i=0; i<6; i++)		if (add1[i] != add2[i]) return(0);	return(1);}E 24I 24  {    register int i;    for(i=0; i<6; i++) if (add1[i] != add2[i]) return(0);    return(1);  }E 24I 6D 10/********************************************************************** *	static char *getintname(s) *	get the interface name from the socket **********************************************************************/E 6static char *getintname(s){	char buf[BUFSIZ];	struct ifconf ifc;E 10I 19E 19D 10	ifc.ifc_len = sizeof (buf);	ifc.ifc_buf = buf;	if (ioctl(s, SIOCGIFCONF, (char *)&ifc) < 0) {		perror("Lisp Ether: Ethernet");		return (0);	}	return (ifc.ifc_req->ifr_name);}E 10I 6/**********************************************************************D 10 *	static get_rom_ID(host) *	gets 48bits ethernet address **********************************************************************/E 6static get_rom_ID(host)char host[];{	int s, kmem;	int index = 0;	struct arpcom arpcom;	struct nlist nl[3];	char *name;	int i;	for (i=0; i++; i<6) host[i] = 0;	/* assume only two controlers types  (like ec or ie) */	nl[0].n_name = "_ie_softc";	nl[1].n_name = "_ec_softc";	nl[2].n_name = "";	nlist("/vmunix", nl);	if (nl[0].n_value == 0) {		index = 1;		if (nl[1].n_value ==0) {			return 0;		} 	}	if ((kmem = open("/dev/kmem", 0)) < 0) {		return 0;	}	if (lseek(kmem, nl[index].n_value, 0) < 0){		return 0;	}	if (read(kmem, &arpcom, sizeof(arpcom)) != sizeof(arpcom)) {		return 0;	}	close(kmem);	name = (char *)&arpcom.ac_enaddr;	for (i=0; i<6; i++) host[i] = name[i];	return 1;}D 6InitUID()E 6I 6/**********************************************************************E 10 *	init_uid() *	sets effective user-id to real user-id **********************************************************************/init_uid()E 6D 28{	int rid;	rid = getuid();	seteuid(rid);}E 28I 28  {    int rid;    rid = getuid();    seteuid(rid);  }E 28I 19E 19I 6D 28/**********************************************************************D 24 *	init_ether()E 24I 24 *	init_ifpage_ether()E 24 *	open nit socket, called from main before starting BCE.I 13 *      init_ifpage_ether() *      sets Lisp's idea of \my.nsaddress. Clears it if ether not *      enabledE 13 **********************************************************************/E 28I 28/************************************************************************//*		i n i t _ i f p a g e _ e t h e r			*//*									*//*      sets Lisp's idea of \my.nsaddress. Clears it if ether not	*//*      enabled								*//*									*//************************************************************************/E 28I 7init_ifpage_ether()D 24{D 10if(get_rom_ID(ether_host)) {E 10I 10D 13if(ether_fd >= 0) {E 13E 10 InterfacePage->nshost0 = (DLword)((ether_host[0] << 8) + ether_host[1]); InterfacePage->nshost1 = (DLword)((ether_host[2] << 8) + ether_host[3]); InterfacePage->nshost2 = (DLword)((ether_host[4] << 8) + ether_host[5]);D 13	}E 13}E 24I 24  {    InterfacePage->nshost0 = (DLword)((ether_host[0] << 8) + ether_host[1]);    InterfacePage->nshost1 = (DLword)((ether_host[2] << 8) + ether_host[3]);    InterfacePage->nshost2 = (DLword)((ether_host[4] << 8) + ether_host[5]);  }E 24I 11D 24/* this needs to be a global so the name can be set by main() in Ctest */E 24I 24D 28#ifndef AIXE 28I 28#ifndef NOETHERE 28  /* this needs to be a global so the name can be set by main() in Ctest */D 28  /* But AIX doesn't support NIT, so dyke it out for AIX */E 28I 28  /* But NOETHER doesn't support NIT, so dyke it out for NOETHER */E 28E 24struct sockaddr_nit snit;I 24D 28#endif AIXE 28I 28D 31#endif NOETHERE 31I 31#endif /* NOETHER */E 31E 28E 24I 24I 28I 31E 31/************************************************************************//*			    i n i t _ e t h e r				*//*      								*//*	open nit socket, called from main before starting BCE.		*//*      								*//************************************************************************/E 28E 24E 11E 7E 6init_ether()D 24{E 24I 24  {E 24I 6D 11    struct sockaddr_nit snit;E 11I 10D 11	/* JRB - This code will have to be a bit different for SUN 4.0; the		probable differences are in commented-out code below		(not ifdefed because they're untested...)	*/E 10D 7if(get_rom_ID(ether_host)) {	InterfacePage->nshost0 = (DLword)((ether_host[0] << 8) + ether_host[1]);	InterfacePage->nshost1 = (DLword)((ether_host[2] << 8) + ether_host[3]);	InterfacePage->nshost2 = (DLword)((ether_host[4] << 8) + ether_host[5]);	}E 7E 6if (getuid() != geteuid()){D 6	if (get_rom_ID(ether_host))	{		InterfacePage->nshost0 = (DLword)((ether_host[0] << 8) + ether_host[1]);		InterfacePage->nshost1 = (DLword)((ether_host[2] << 8) + ether_host[3]);		InterfacePage->nshost2 = (DLword)((ether_host[4] << 8) + ether_host[5]);		printf("Etheraddr is: %d.%d.%d\n", InterfacePage->nshost0, InterfacePage->nshost1, InterfacePage->nshost2);		InitEther();E 6I 6D 10	if (get_rom_ID(ether_host)) {		if ((ether_fd = socket(AF_NIT, SOCK_RAW, NITPROTO_RAW)) >= 0) {		/* bind the socket to an interface */		snit.snit_family = AF_NIT;		strncpy(snit.snit_ifname, getintname(ether_fd), sizeof(snit.snit_ifname));		bind(ether_fd, &snit, sizeof(snit));E 10I 10	if ((ether_fd = socket(AF_NIT, SOCK_RAW, NITPROTO_RAW)) >= 0) {	/* 4.0: socket -> open("/dev/nit", O_BOTH) */	/* it's open, now query it and find out its name and address */	/* JRB - must document that Maiko uses the first net board as found		by SIOCGIFCONF (see if(4)).  Maybe we need an option to specify		which net board (suspect more than one net board on a Maiko machine		will be rare, but...).	*/	struct ifconf if_data;	struct ifreq ifbuf[20];E 11I 11D 24/* JRB - This code will have to be a bit different for SUN 4.0; the		probable differences are in commented-out code belowE 24I 24D 28#ifndef AIXE 28I 28#ifndef NOETHERE 28    /* JRB - This code will have to be a bit different for SUN 4.0; the			probable differences are in commented-out code belowE 24	(not ifdefed because they're untested...)D 24*/I 17  int flags;E 24I 24    */    int flags;E 24E 17E 11E 10I 26 /*   ((INTSTAT*)Addr68k_from_LADDR(*INTERRUPTSTATE_word))->ETHERInterrupt = 0;    ((INTSTAT2 *)Addr68k_from_LADDR(*INTERRUPTSTATE_word))->handledmask = 0;*/E 26D 10		/* establish the operating modes */		bzero(&nioc, sizeof(nioc));		nioc.nioc_bufspace = 20000;		nioc.nioc_chunksize = 50; /* small chunks so each packet read */		nioc.nioc_typetomatch = NT_ALLTYPES;		nioc.nioc_snaplen = 32767;		nioc.nioc_flags = 0;		if (ioctl(ether_fd, SIOCSNIT, &nioc) != 0) {			printf("init_ether: ioctl failed\n");		    close(ether_fd);		    ether_fd = -1;		    return(NIL);		}		EtherReadFds |= (1 << ether_fd);		printf("init_ether: **** Ethernet starts ****\n");		}	else {		printf("init_ether: can't open NIT socket\n");E 10I 10D 11	if_data.ifc_len = sizeof(ifbuf);	if_data.ifc_req = ifbuf;	/* 4.0 - before the SIOCGIFCONF, do:		bzero(ifbuf, sizeof(ifbuf))E 11I 11D 24if (ether_fd < 0) {E 24I 24    if (ether_fd < 0)      {E 24	/* it's not open yet, try and open it;D 14		if it's already open here, it was opened by lispgo and		all the appropriate stuff was done to snit by Ctest.E 14I 14D 24		if it's already open here, it was opened by ldeether and		all the appropriate stuff was done to it there.E 24I 24	   if it's already open here, it was opened by ldeether and	   all the appropriate stuff was done to it there.E 24E 14E 11	*/I 14#ifndef OS4E 14D 11	if(ioctl(ether_fd, SIOCGIFCONF, &if_data) < 0) {		perror("Couldn't GIFCONF socket; Net is off");		close(ether_fd);E 10		ether_fd = -1;D 10    		}E 10I 10		return(NIL);E 11I 11D 24	if (getuid() != geteuid()){		if ((ether_fd = socket(AF_NIT, SOCK_RAW, NITPROTO_RAW)) >= 0) {E 24I 24	if (getuid() != geteuid())	  {	    if ((ether_fd = socket(AF_NIT, SOCK_RAW, NITPROTO_RAW)) >= 0)	      {E 24		/* 4.0: socket -> open("/dev/nit", O_BOTH) */		/* it's open, now query it and find out its name and address */		/* JRB - must document that Maiko uses the first net board asD 24		found by SIOCGIFCONF (see if(4)).  Maybe we need an option to		specify which net board (suspect more than one net board on a		Maiko machine will be rare, but...).E 24I 24		   found by SIOCGIFCONF (see if(4)).  Maybe we need an option to		   specify which net board (suspect more than one net board on a		   Maiko machine will be rare, but...).E 24		*/		struct ifconf if_data;		struct ifreq ifbuf[20];D 15	E 15I 15E 15		if_data.ifc_len = sizeof(ifbuf);		if_data.ifc_req = ifbuf;		/* 4.0 - before the SIOCGIFCONF, do:			bzero(ifbuf, sizeof(ifbuf))		*/D 24		if(ioctl(ether_fd, SIOCGIFCONF, &if_data) < 0) {			perror("Couldn't GIFCONF socket; Net is off");E 24I 24		if(ioctl(ether_fd, SIOCGIFCONF, &if_data) < 0) 		  {		    perror("Couldn't GIFCONF socket; Net is off");E 24I 14D 31#else OS4E 31I 31#else /* OS4 */E 31D 24if (getuid() != geteuid()){D 17	if ((ether_fd =  open("/dev/nit", O_RDWR)) >= 0) {E 17I 17	if ((ether_fd =  open("/dev/nit", O_RDWR|FASYNC)) >= 0) {E 17	/* it's open, now query it and find out its name and address */	/* JRB - must document that LDE uses the first net board as found	by SIOCGIFCONF (see if(4)).  Maybe we need an option to specify	which net board (suspect more than one net board on an LDE machine	will be rare, but...).	*/	struct ifconf if_data;	struct ifreq ifbuf[20];E 24I 24	if (getuid() != geteuid())	  {	    if ((ether_fd =  open("/dev/nit", O_RDWR|FASYNC)) >= 0)	      {		/* it's open, now query it and find out its name and address */		/* JRB - must document that LDE uses the first net board as		   found by SIOCGIFCONF (see if(4)).  Maybe we need an option		   to specify which net board (suspect more than one net		   board on an LDE machine will be rare, but...).		*/		struct ifconf if_data;		struct ifreq ifbuf[20];E 24D 24	/* first and foremost, get the packet filter module attached		(used for ether_suspend and ether_resume) */E 24I 24		/* first and foremost, get the packet filter module attached		   (used for ether_suspend and ether_resume) */E 24D 24	if(ioctl(ether_fd, I_PUSH, "pf") < 0) {		perror("IOCTL push of pf lost");		close(ether_fd);		goto I_Give_Up;	}	if_data.ifc_len = sizeof(ifbuf);	if_data.ifc_req = ifbuf;	bzero(ifbuf, sizeof(ifbuf));	{E 24I 24		if(ioctl(ether_fd, I_PUSH, "pf") < 0)		  {		    perror("IOCTL push of pf lost");		    close(ether_fd);		    goto I_Give_Up;		  }		if_data.ifc_len = sizeof(ifbuf);		if_data.ifc_req = ifbuf;		bzero(ifbuf, sizeof(ifbuf));		{E 24	/* we have to get the interface name from another socket, since		/dev/nit doesn't know anything until it gets bound, and we		can't bind it without knowing the interface name... */D 24		int s;E 24I 24		  int s;E 24D 24		if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {			perror("No socket for interface name");			close(s);E 24I 24		  if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)		    {		      perror("No socket for interface name");		      close(s);E 24D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14D 24			close(ether_fd);			ether_fd = -1;E 24I 24		      close(ether_fd);		      ether_fd = -1;E 24I 14#ifndef OS4E 14D 24			return(NIL);E 24I 24		      return(NIL);E 24I 14D 31#else OS4E 31I 31#else /* OS4 */E 31D 24			goto I_Give_Up;E 24I 24		      goto I_Give_Up;E 24D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14D 24		}E 24I 24		    }E 24I 14#ifndef OS4E 14D 24		/* got its name, copy it into snit */		strcpy(snit.snit_ifname, if_data.ifc_req[0].ifr_name);		/* 4.0, before the SIOCGIFADDR, do:E 24I 24		  /* got its name, copy it into snit */		  strcpy(snit.snit_ifname, if_data.ifc_req[0].ifr_name);		  /* 4.0, before the SIOCGIFADDR, do:E 24			ioctl(ether_fd, NIOCBIND, &if_data.ifc_req[0])D 24		*/		/* now for the address */		if(ioctl(ether_fd, SIOCGIFADDR, &if_data.ifc_req[0]) < 0) {			perror("Couldn't GIFADDR socket: Net is off");E 24I 24		  */		  /* now for the address */		  if(ioctl(ether_fd, SIOCGIFADDR, &if_data.ifc_req[0]) < 0)		    {		      perror("Couldn't GIFADDR socket: Net is off");E 24I 14D 31#else OS4E 31I 31#else /* OS4 */E 31D 24		if (ioctl(s, SIOCGIFCONF, (char *)&if_data) < 0) {			perror("Couldn't get interface name from socket");			close(s);E 24I 24		  if (ioctl(s, SIOCGIFCONF, (char *)&if_data) < 0)		     {		      perror("Couldn't get interface name from socket");		      close(s);E 24D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14D 24			close(ether_fd);			ether_fd = -1;E 24I 24		    close(ether_fd);		    ether_fd = -1;E 24I 14#ifndef OS4E 14D 24			return(NIL);E 24I 24		    return(NIL);E 24I 14D 31#else OS4E 31I 31#else /* OS4 */E 31D 24			goto I_Give_Up;E 24I 24		    goto I_Give_Up;E 24D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14D 24		}E 24I 24		  }E 24I 14#ifndef OS4E 14		bcopy(if_data.ifc_req[0].ifr_addr.sa_data, ether_host, 6);		init_uid();D 24		}E 24I 24	      }E 24I 14D 31#else OS4E 31I 31#else /* OS4 */E 31D 24		(void) close(s);E 24I 24	    (void) close(s);E 24D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14E 11D 24	}E 24I 24	  }E 24I 14#ifdef OS4D 24	if(ioctl(ether_fd, NIOCBIND, &if_data.ifc_req[0]) < 0) {		perror("Couldn't NIOCBIND socket: Net is off");		close(ether_fd);		ether_fd = -1;		goto I_Give_Up;	}E 24I 24	if(ioctl(ether_fd, NIOCBIND, &if_data.ifc_req[0]) < 0) 	  {	    perror("Couldn't NIOCBIND socket: Net is off");	    close(ether_fd);	    ether_fd = -1;	    goto I_Give_Up;	  }E 24	/* now for the address */D 24	if(ioctl(ether_fd, SIOCGIFADDR, &if_data.ifc_req[0]) < 0) {		perror("Couldn't GIFADDR socket: Net is off");		close(ether_fd);		ether_fd = -1;		goto I_Give_Up;	}E 24I 24	if(ioctl(ether_fd, SIOCGIFADDR, &if_data.ifc_req[0]) < 0)	  {	    perror("Couldn't GIFADDR socket: Net is off");	    close(ether_fd);	    ether_fd = -1;	    goto I_Give_Up;	  }E 24	bcopy(if_data.ifc_req[0].ifr_addr.sa_data, ether_host, 6);D 24#ifdef  DEBUG	printf("init_ether: **** Ethernet starts ****\n");#endif	} else {E 24I 24	DBPRINT(("init_ether: **** Ethernet starts ****\n"));      }    else      {E 24I_Give_Up:D 24		perror("init_ether: can't open NIT socket\n");		ether_fd = -1;		exit();	}	seteuid(getuid());	}E 24I 24	perror("init_ether: can't open NIT socket\n");	ether_fd = -1;	exit();      }    seteuid(getuid());  }E 24D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14D 11	/* got its name, copy it into snit */	strcpy(snit.snit_ifname, if_data.ifc_req[0].ifr_name);	/* 4.0, before the SIOCGIFADDR, do:		ioctl(ether_fd, NIOCBIND, &if_data.ifc_req[0])	*/	/* now for the address */	if(ioctl(ether_fd, SIOCGIFADDR, &if_data.ifc_req[0]) < 0) {		perror("Couldn't GIFADDR socket: Net is off");		close(ether_fd);		ether_fd = -1;		return(NIL);	}	bcopy(if_data.ifc_req[0].ifr_addr.sa_data, ether_host, 6);E 11I 11}if (ether_fd >= 0) {I 14#ifndef OS4E 14E 11	/* bind the socket to an interface */	snit.snit_family = AF_NIT;	bind(ether_fd, &snit, sizeof(snit));I 14D 31#else OS4E 31I 31#else /* OS4 */E 31/* I think all you really have to do here is set the SNAP length, flags,	and configure the buffering module */	unsigned long snaplen = 0;	struct timeval zerotime;D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14E 10I 31E 31I 14#ifndef OS4E 14I 10	/* establish the operating modes */	bzero(&nioc, sizeof(nioc));	nioc.nioc_bufspace = 20000;	nioc.nioc_chunksize = 50; /* small chunks so each packet read */	nioc.nioc_typetomatch = NT_ALLTYPES;	nioc.nioc_snaplen = 32767;	nioc.nioc_flags = 0;	if (ioctl(ether_fd, SIOCSNIT, &nioc) != 0) {		printf("init_ether: ioctl failed\n");I 14D 31#else OS4E 31I 31#else /* OS4 */E 31	EtherReadFds |= (1 << ether_fd);/* first and foremost, flush out ether_fd's buffers and filter it *//* install packetfilter that rejects everything */	if (ioctl(ether_fd, NIOCSETF, &nopf) != 0) {		perror("init_ether: nopf NIOCSETF failed:\n");D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 14	    close(ether_fd);	    ether_fd = -1;	    return(NIL);	}I 14#ifndef OS4E 14	EtherReadFds |= (1 << ether_fd);I 18	if (fcntl(ether_fd, F_SETFL,		  fcntl(ether_fd, F_GETFL, 0) | FASYNC | FNDELAY)<0)	  perror("Ether setup SETFLAGS fcntl");	if( fcntl(ether_fd, F_SETOWN, getpid()) < 0)	  perror("Ether setup SETOWN");E 18I 14D 31#else OS4E 31I 31#else /* OS4 */E 31/* then throw away everything that's currently buffered there;	this descriptor may have been open since ldeether ran, with	no filtering; a busy net will have stuffed it full */	{int rfds = EtherReadFds;D 15	    while(select(32, &rfds, NULL, NULL, &EtherTimeout) > 0) E 15I 15	    while(select(32, &rfds, NULL, NULL, &EtherTimeout) > 0)E 15			read(ether_fd, nit_buf, sizeof(nit_buf));	}/* put the address into the packetfilter structure *//* DANGER! Vulnerable to byte ordering! DANGER! */	goodpf.Pf_Filter[8]=  *((short *)&ether_host[0]);	goodpf.Pf_Filter[11]= *((short *)&ether_host[2]);	goodpf.Pf_Filter[14]= *((short *)&ether_host[4]);/* and set up the packetfilter */	if (ioctl(ether_fd, NIOCSETF, &goodpf) != 0) {		perror("init_ether: NIOCSETF failed:\n");	    close(ether_fd);	    ether_fd = -1;	    return(NIL);	}/* clobber the flags */D 24	if(ioctl(ether_fd, NIOCSFLAGS, &snaplen) != 0) {		perror("init_ether: NIOCSFLAGS failed:\n");		close(ether_fd);		ether_fd = -1;		return(NIL);	}E 24I 24	if(ioctl(ether_fd, NIOCSFLAGS, &snaplen) != 0)	  {	    perror("init_ether: NIOCSFLAGS failed:\n");	    close(ether_fd);	    ether_fd = -1;	    return(NIL);	  }E 24D 18#endif OS4E 18I 17	DBPRINT(("INIT ETHER:  Doing I_SETSIG.\n"));D 18#ifdef OS4E 18	if (ioctl(ether_fd, I_SETSIG, S_INPUT) != 0)	  {	    perror("init_ether: I_SETSIG failed:\n");	    close(ether_fd);	    ether_fd = -1;	    return(NIL);	  }D 18#else	fcntl(ether_fd, F_SETOWN, getpid());	fcntl(ether_fd, F_SETFL, fcntl(ether_fd, F_GETFL, 0)|FASYNC|FNDELAY);#endifE 18I 18D 31#endif OS4E 31I 31#endif /* OS4 */E 31E 18D 24	if (EtherReadFds == 0) error("EtherReadFds is zero, but enet opened??");E 24I 24	if (EtherReadFds == 0)	  error("EtherReadFds is zero, but enet opened??");E 24	LispReadFds |= EtherReadFds;E 17E 14I 12D 24#ifdef  DEBUGE 12	printf("init_ether: **** Ethernet starts ****\n");I 12#endifE 12D 11	} else {		printf("init_ether: can't open NIT socket\n");		ether_fd = -1;E 10E 6	}D 6	InitUID();E 6I 6	init_uid();E 6	}E 11}I 11}E 24I 24	DBPRINT(("init_ether: **** Ethernet starts ****\n"));      }D 28#endif AIXE 28I 28D 31#endif NOETHERE 31I 31#endif /* NOETHER */E 31E 28  }E 24E 11I 9#define MASKWORD1	0xffffI 17/************************************************************************//*									*/I 19/*			c h e c k _ s u m				*/E 19/*									*/D 19/*									*//*									*//*									*/E 19I 19/*	Implements the CHECKSUM opcode; compute the checksum for an	*//*	ethernet packet.						*/E 19/*									*/I 28/*	args[0] LispPTR base;						*//*	args[1] LispPTR nwords;						*//*	args[2] LispPTR initsum;					*/E 28/*									*//*									*//************************************************************************/E 17check_sum(args)D 28 register LispPTR *args; /* args[0] LispPTR base; */ /* args[1] LispPTR nwords; */ /* args[2] LispPTR initsum; */{  register  LispPTR checksum;  register  DLword *address;  register int nwords;E 28I 28  register LispPTR *args;  {    register  LispPTR checksum;    register  DLword *address;    register int nwords;E 28D 28 address=(DLword*)Addr68k_from_LADDR(*args++); nwords = *args ++;E 28I 28    address=(DLword*)Addr68k_from_LADDR(*args++);    nwords = *args ++;E 28D 21 if( *args != NIL)	checksum = (*args) & MASKWORD1; else	checksum = 0;E 21I 21D 28 if( *args != NIL) checksum = (*args) & MASKWORD1; else checksum = 0;E 28I 28    if( *args != NIL) checksum = (*args) & MASKWORD1;    else checksum = 0;E 28E 21D 28 for(;nwords > (S_POSITIVE); address++,nwords--)  {E 28I 28    for(;nwords > (S_POSITIVE); address++,nwords--)      {E 28D 21	checksum= checksum + *address;E 21I 21	checksum= checksum + GETWORD(address);E 21D 15	if(checksum > 0xffff) E 15I 15	if(checksum > 0xffff)E 15D 28		checksum = (checksum & 0xffff) +1; /* add carry */E 28I 28	  checksum = (checksum & 0xffff) +1; /* add carry */E 28D 15		E 15I 15E 15	if(checksum >0x7fff) /* ROTATE LEFT 1 */D 28		checksum= ((checksum & 0x7fff)<<1) | 1 ;	else		checksum = checksum << 1;  }E 28I 28	  checksum= ((checksum & 0x7fff)<<1) | 1 ;	else checksum = checksum << 1;      }E 28D 28 if(checksum == MASKWORD1) return(S_POSITIVE);/* ret 0 */ else return(S_POSITIVE|checksum);} /*check_sum */I 25#endif NOETHERE 28I 28    if(checksum == MASKWORD1) return(S_POSITIVE);/* ret 0 */    else return(S_POSITIVE|checksum);  } /*check_sum */E 28E 25E 9E 1