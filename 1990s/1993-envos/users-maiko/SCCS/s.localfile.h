h16801s 00004/00000/00696d D 2.33 92/03/04 19:42:46 nilsson 35 34c es 00007/00004/00689d D 2.32 91/09/27 04:08:15 sybalsky 34 33c Fix LispStrinToCString to use fillptres 00007/00006/00686d D 2.31 91/02/04 12:57:48 sybalsky 33 32c Fix errors in teh Savoir retrofit (placement of ifdefs &c)es 00038/00001/00654d D 2.30 90/10/09 10:49:27 fuji 32 31c Add LispStringLegth and FileNameTooLong macroses 00022/00020/00633d D 2.29 90/06/20 12:39:46 mitani 31 30c add TIMEOUT in DSK_OR_FILE_Pes 00043/00020/00610d D 2.28 90/06/04 14:53:56 mitani 30 29c new directory enumerationes 00001/00001/00629d D 2.27 90/05/15 18:32:59 sybalsky 29 28c put commas in the arg list to  #define ConcDirAndName(...)es 00000/00000/00630d D 2.26 90/04/20 01:03:39 sybalsky 28 27c AIX:  shortening file names, bulk change.es 00303/00065/00327d D 2.25 90/04/19 18:29:25 mitani 27 26c Version up to 1.2es 00016/00002/00376d D 2.24 90/03/08 10:03:06 takeshi 26 25c care about byte-order in stringses 00034/00001/00344d D 2.23 90/03/02 14:40:29 takeshi 25 24c Add LispStringToCString for i386es 00040/00017/00305d D 2.22 89/12/13 11:03:05 sybalsky 24 23c string-conversion safetyes 00072/00070/00250d D 2.21 89/03/20 14:46:04 shih 23 22c cosmetices 00002/00002/00318d D 2.20 89/03/20 14:32:17 sybalsky 22 21c changed for onedarray changees 00062/00006/00258d D 2.19 88/12/01 12:06:17 hayata 21 20c To fix error message problem (connection time out & too many files open), global var *Lisp_errno is used to keep errno.es 00000/00000/00264d D 2.18 88/11/22 13:41:50 hayata 20 19c Save previous version again.es 00003/00001/00261d D 2.17 88/11/09 16:58:11 bane 19 18c Removed NIL #define; redundant with one in lispemul.hes 00001/00001/00261d D 2.16 88/10/18 15:02:20 krivacic 18 17c replace PAGESIZE with PAGE_SIZEes 00002/00001/00260d D 2.15 88/10/06 20:08:59 hayata 17 16c EOL and ALL item is added for getfileinfoes 00000/00000/00261d D 2.14 88/10/06 19:01:06 hayata 16 15c Add EOL and ALL item for getfileinfoes 00015/00002/00246d D 2.13 88/10/06 17:39:01 hayata 15 14c new RENAME is masked with FSERRORes 00010/00004/00238d D 2.12 88/10/06 17:07:14 hayata 14 13c Change RENAME for cross device rename, Add ALL item for getfileinfoes 00045/00000/00197d D 2.11 88/07/21 18:51:14 hayata 13 12c Some macros (STAT, UNLINK, RENAME ans do on) are added.es 00018/00008/00179d D 2.10 88/07/21 15:47:01 hayata 12 11c Some macros are added.es 00013/00000/00174d D 2.9 88/06/17 20:34:50 hayata 11 10c Define RemoveDodNoExtention.es 00004/00003/00170d D 2.8 88/06/17 14:29:03 hayata 10 9c Change LispVersionToUnixVersion, to fix ";ABCD" problem.es 00017/00000/00156d D 2.7 88/06/17 11:18:04 hayata 9 8c AddDotNoExtension is added, to print "." after no extwntion file.es 00013/00006/00143d D 2.6 88/06/16 16:02:18 hayata 8 7c Allow some character after ".~#~", like ".~2~%".es 00006/00001/00143d D 2.5 88/06/13 17:33:49 hayata 7 6c Add TIMEOUTes 00026/00021/00118d D 2.4 88/06/11 17:28:08 hayata 6 5c Change version convetion from ~#~ to .~#~es 00001/00003/00138d D 2.3 88/05/25 11:31:00 hayata 5 4c Add SCCS key ides 00023/00012/00118d D 2.2 88/05/25 11:28:15 hayata 4 3c Change LispStringToCString to handle FIXP stringes 00000/00000/00130d D 2.1 88/05/17 09:18:34 hayata 3 2c Version up to 2.1es 00001/00000/00129d D 1.2 88/05/07 18:20:50 hayata 2 1c Add non-recoges 00129/00000/00000d D 1.1 88/04/28 18:50:34 hayata 1 0c date and time created 88/04/28 18:50:34 by hayataeuUtTI 1D 4/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  *//* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 4I 4D 5/* This is G-file @(#) localfile.h Version 1.2 (5/7/88). copyright Xerox & Fuji Xerox  *//* This is G-file @(#) localfile.h Version 1.2 (5/7/88). copyright Xerox & Fuji Xerox  */E 4E 5I 5D 14/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */E 14I 14D 23/* This is G-file %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 23I 23D 32/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */E 32I 32/* @(#) localfile.h Version 2.29 (6/20/90). copyright envos & Fuji Xerox  */E 32E 23E 14E 5I 34E 34D 18#define	PAGESIZE	512	/* 1 page == 512 byte */E 18I 18D 27#define	PAGE_SIZE	512	/* 1 page == 512 byte */E 18I 13D 19#define	NIL	0E 19I 19/* NIL is defined in lispemul.h and everyone who includes this file	also includes lispemul.h, so this definition is redundant.   #define	NIL	0 */E 19#define	T	1E 27I 27#define	PAGE_SIZE		512	/* 1 page == 512 byte */E 27E 13#define	RECOG_OLD		S_POSITIVE | 0#define	RECOG_OLDEST		S_POSITIVE | 1#define	RECOG_NEW		S_POSITIVE | 2D 27#define	RECOG_NEW_OLD		S_POSITIVE | 3E 27I 27#define	RECOG_OLD_NEW		S_POSITIVE | 3E 27I 2#define	RECOG_NON		S_POSITIVE | 5E 2#define	ACCESS_INPUT		S_POSITIVE | 0#define	ACCESS_OUTPUT		S_POSITIVE | 1#define	ACCESS_BOTH		S_POSITIVE | 2#define	ACCESS_APPEND		S_POSITIVE | 3D 23#define	SIZE			S_POSITIVE | 1	/* For getfileinfo */E 23I 23/* For getfileinfo */D 27#define	SIZE			S_POSITIVE | 1E 27I 27#define	LENGTH			S_POSITIVE | 1E 27E 23#define	WDATE			S_POSITIVE | 2#define	RDATE			S_POSITIVE | 3#define	AUTHOR			S_POSITIVE | 5#define	PROTECTION		S_POSITIVE | 6I 14D 17#define	ALL			S_POSITIVE | 7E 17I 17#define	EOL			S_POSITIVE | 7#define	ALL			S_POSITIVE | 8E 17E 14extern	DLword	*Lisp_world;	/* To access LispSysout area */#define	ToLispTime(x)	((int)x + 29969152)D 23			/* For fetfileinfo. For WDATE&RDATE */E 23I 23			/* For getfileinfo. For WDATE&RDATE */E 23			/* 29969152 == (timer.c)LISP_UNIX_TIME_DIFF */			/* - 61200 == - 17hours */#define	ToUnixTime(x)	((int)x - 29969152)D 23			/* For fetfileinfo. For WDATE&RDATE */E 23I 23			/* For getfileinfo. For WDATE&RDATE */E 23			/* 29969152 == (timer.c)LISP_UNIX_TIME_DIFF */I 26#define StrNCpyFromCToLisp(lispbuf, cbuf ,len)	{ register int i;	\			register char *sptr,*dptr;			\			for(i=0,sptr=(cbuf),dptr =(lispbuf);i<(len);i++)\				GETBYTE(dptr++) = *sptr++;		\		}E 26D 23#define	LispStringToCString(Lisp, C){	\D 4	LispPTR	*naddress;				\	char	*base;					\	int	length;					\	int	offset;					\	naddress = (LispPTR *)(Addr68k_from_LADDR(Lisp));					\	base = (char *)(Addr68k_from_LADDR(((ONEDARRAAY *)naddress)->base));	\	offset = (int)(((ONEDARRAAY *)naddress)->offset);	\	length = ((ONEDARRAAY *)naddress)->totalsize;						\	strncpy(C, base + offset, length);			\	C[length] = '\0';				\E 4I 4D 22	ONEDARRAAY	*arrayp;	\E 22I 22	OneDArray	*arrayp;	\E 22	char	*base, *dp;		\	short	*sbase;			\	int	i;			\E 23I 23D 24#define	LispStringToCString(Lisp, C){				\	OneDArray	*arrayp;				\	char	*base, *dp;					\	short	*sbase;						\	int	i;						\E 23D 22	arrayp = (ONEDARRAAY *)(Addr68k_from_LADDR(Lisp));	\E 22I 22	arrayp = (OneDArray *)(Addr68k_from_LADDR(Lisp));	\E 22	switch(arrayp->typenumber){				\	case THIN_CHAR_TYPENUMBER:				\		base = ((char *)(Addr68k_from_LADDR(arrayp->base))) + ((int)(arrayp->offset));\		strncpy(C, base, arrayp->totalsize);			\		C[arrayp->totalsize] = '\0';				\E 24I 24I 26#define StrNCpyFromLispToC(cbuf , lispbuf, len)	{ register int i;	\			register char *sptr,*dptr;			\			for(i=0,sptr=(lispbuf),dptr =(cbuf);i<(len);i++)\				*dptr++ = GETBYTE(sptr++);		\		}I 35#define FGetNum(ptr, place) { \             if(((ptr) & 0xff0000)== S_POSITIVE) {(place) = ((ptr) & 0xffff);}\        else if(((ptr) & 0xff0000)== S_NEGATIVE) {(place) = (int)((ptr)| 0xffff0000);}\        else {return(NIL);}}E 35E 26/************************************************************************//*									*//*		  L i s p S t r i n g T o C S t r i n g			*//*									*//*	Convert the Lisp string in Lisp into a null-terminated C	*//*	string in C.  MaxLen is, for safety, the maximum length of	*//*	the resulting string, so the buffer doesn't overflow and	*//*	smash memory.							*//*									*//*	WARNINGS:  The Lisp string is truncated to fit the C string	*//*	without warning to the user.  FAT Lisp strings have only	*//*	the low 8 bits of each character copied over.			*//*									*//************************************************************************/D 25E 25I 25#ifndef BYTESWAPE 25#define	LispStringToCString(Lisp, C, MaxLen)				\  {									\    OneDArray	*arrayp;						\    char	*base, *dp;						\    short	*sbase;							\    int	i, length;							\    arrayp = (OneDArray *)(Addr68k_from_LADDR(Lisp));			\D 34    length = min(MaxLen, arrayp->totalsize);				\E 34I 34    length = min(MaxLen, arrayp->fillpointer);				\E 34    switch(arrayp->typenumber)						\      {									\	case THIN_CHAR_TYPENUMBER:					\		base = ((char *)(Addr68k_from_LADDR(arrayp->base)))  	\		       + ((int)(arrayp->offset));			\		strncpy(C, base, length);				\		C[length] = '\0';					\E 24		break;							\I 24									\E 24	case FAT_CHAR_TYPENUMBER:					\D 24		sbase = ((short *)(Addr68k_from_LADDR(arrayp->base))) + ((int)(arrayp->offset));	\		for(i=0,dp=C;i<(arrayp->totalsize);i++){		\			*dp++ = (char)(*sbase++);			\		}							\E 24I 24		sbase = ((short *)(Addr68k_from_LADDR(arrayp->base)))	\		       + ((int)(arrayp->offset));			\		for(i=0,dp=C;i<(length);i++)				\		  *dp++ = (char)(*sbase++);				\E 24		*dp = '\0';						\		break;							\	default:							\D 33		error("LispStringToCString can not handle\n");		\E 33I 33		error("LispStringToCString: Not a character array.\n");	\E 33D 24	}								\E 4	}E 24I 24      }									\  }I 25#else  /* BYTESWAP == T CHANGED-BY-TAKE */#define	LispStringToCString(Lisp, C, MaxLen)				\  {									\    OneDArray	*arrayp;						\    char	*base, *dp;						\    short	*sbase;							\    int	i, length;							\    arrayp = (OneDArray *)(Addr68k_from_LADDR(Lisp));			\D 34    length = min(MaxLen, arrayp->totalsize);				\E 34I 34    length = min(MaxLen, arrayp->fillpointer);				\E 34    switch(arrayp->typenumber)						\      {									\	case THIN_CHAR_TYPENUMBER:					\		base = ((char *)(Addr68k_from_LADDR(arrayp->base)))  	\		       + ((int)(arrayp->offset));			\D 26		for(i=0,dp=C;i<length;i++)				\		{*dp++ =(char)(GETBYTE(base++));}			\E 26I 26		/*for(i=0,dp=C;i<length;i++)				\		{*dp++ =(char)(GETBYTE(base++));}**/			\		StrNCpyFromLispToC(C , base , length );			\E 26		C[length] = '\0';					\		break;							\									\	case FAT_CHAR_TYPENUMBER:					\		sbase = ((short *)(Addr68k_from_LADDR(arrayp->base)))	\		       + ((int)(arrayp->offset));			\		for(i=0,dp=C;i<(length);i++,sbase++)				\		  *dp++ = (char)(GETWORD(sbase));				\		*dp = '\0';						\		break;							\	default:							\D 33		error("LispStringToCString can not handle\n");		\E 33I 33		error("LispStringToCString: Not a character array.\n");	\E 33      }									\  }#endif BYTESWAPI 32/************************************************************************//*									*//*		  L i s p S t r i n g L e n g t h			*//*									*//*	Get the byte length of the string in Lisp.			*//*									*//************************************************************************/#define	LispStringLength(LispString, Length, FatP)			\  {									\    OneDArray	*arrayp;						\    arrayp = (OneDArray *)(Addr68k_from_LADDR(LispString));		\    switch(arrayp->typenumber)						\      {									\	case THIN_CHAR_TYPENUMBER:					\D 34		Length = arrayp->totalsize;				\E 34I 34		Length = arrayp->fillpointer;				\E 34		FatP = 0;						\		break;							\									\	case FAT_CHAR_TYPENUMBER:					\D 34		Length = arrayp->totalsize * 2;				\E 34I 34		Length = arrayp->fillpointer * 2;			\E 34		FatP = 1;						\		break;							\	default:							\D 33		error("LispStringLength can not handle\n");		\E 33I 33		error("LispStringLength: Not a character array.\n");	\E 33      }									\  }E 32I 27D 33#define STRING_BASE(lstringp, cstringp){					  \	register LispPTR	*naddress;					  \	naddress = (LispPTR *)(Addr68k_from_LADDR(lstringp));			  \E 33I 33#define STRING_BASE(lstringp, cstringp){				\	register LispPTR	*naddress;				  \	naddress = (LispPTR *)(Addr68k_from_LADDR(lstringp));		  \E 33	cstringp  = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));  \}E 27E 25#define min(a, b) ((a <= b)?a:b)E 24D 23#define	LispNumToCInt(Lisp)		\		( ((Lisp & 0xFF0000) == S_POSITIVE) ? 	\E 23I 23#define	LispNumToCInt(Lisp)					\		( ((Lisp & 0xFF0000) == S_POSITIVE) ?		\E 23		(Lisp & 0xFFFF) : (*((int *)(Addr68k_from_LADDR(Lisp)))) );#define	UPLOWDIFF	0x20D 23#define	DOWNCASE(name){			\E 23I 23#define	DOWNCASE(name){						\I 27								\E 27E 23D 12	char	*cp;					\E 12I 12	register char	*cp;					\E 12D 27		for(cp=name;*cp!='\0';++cp)			\			if((*cp >= 'A') && (*cp <= 'Z'))	\D 23				*cp += UPLOWDIFF;			\E 23I 23				*cp += UPLOWDIFF;		\E 23	}E 27I 27								\	for(cp = name; *cp!='\0'; ++cp)				\	  if((*cp >= 'A') && (*cp <= 'Z')) *cp += UPLOWDIFF;	\}E 27D 23#define	UPCASE(name){			\E 23I 23#define	UPCASE(name){						\I 27								\E 27E 23D 12	char	*cp;					\E 12I 12	register char	*cp;					\E 12D 27		for(cp=name;*cp!='\0';++cp)			\			if((*cp >= 'a') && (*cp <= 'z'))	\D 23				*cp -= UPLOWDIFF;			\E 23I 23				*cp -= UPLOWDIFF;		\E 23	}E 27I 27								\	for(cp = name; *cp!='\0'; ++cp)				\	  if((*cp >= 'a') && (*cp <= 'z')) *cp -= UPLOWDIFF;	\}#define DIR_OR_FILE_P(name, type){				\	register int	result;					\	struct stat	sbuf;					\								\D 31	result = stat(name, &sbuf);				\	if (result < 0)						\	  type = 0;						\	else							\	  switch (sbuf.st_mode & S_IFMT) {		      	\E 31I 31	TIMEOUT(result = stat(name, &sbuf));			\	if (result < 0) {					\		*Lisp_errno = errno;				\		type = 0;					\	} else {  						\		switch (sbuf.st_mode & S_IFMT) {		\E 31								\D 31		case S_IFDIR:					\		  type = -1;					\		  break;					\E 31I 31		      case S_IFDIR:				\			type = -1;				\			break;					\E 31								\D 31		case S_IFREG:					\		  type = 1;					\		  break;					\E 31I 31		      case S_IFREG:				\			type = 1;				\			break;					\E 31								\D 31		default:					\		  /*						\		   * Should we deal with the other		\		   * types?					\		   */						\		  type = 0;					\		  break;					\	  }							\}		E 31I 31		      default:					\			/*					\			 * Should we deal with the other	\			 * types?				\			 */					\			type = 0;				\			break;					\		}						\	}							\}E 31E 27D 21E 21I 21#ifdef FSERRORE 21D 23#define	DIRP(path, dir, buf){	\I 7	int rval;		\	struct	stat	statbuf;	\E 7		strcpy(buf, path);	\		strcat(buf, dir);	\E 23I 23#define	DIRP(path, dir, buf){				\	int rval;					\	struct	stat	statbuf;			\		strcpy(buf, path);			\		strcat(buf, dir);			\E 23D 6		if( stat(buf, &statbuf) == 0)			\E 6I 6D 7		if( stat(buf, &statbuf) == 0){			\E 7I 7		TIMEOUT( rval=stat(buf, &statbuf) );	\D 21	if( rval == 0){			\E 21I 21D 23		if( rval == 0){			\E 23I 23		if( rval == 0){				\E 23E 21E 7E 6			if( (statbuf.st_mode & S_IFMT) == S_IFDIR ){	\				strcat(path, dir);			\D 6				return(1);					\			}			\E 6I 6				return(1);				\			}				\		}					\I 21		if( rval == -1 && errno == 60){		\			*Lisp_errno = 60;		\			return(0);			\		}					\E 21E 6		}I 21#elseD 23#define	DIRP(path, dir, buf){	\	int rval;		\	struct	stat	statbuf;	\		strcpy(buf, path);	\		strcat(buf, dir);	\E 23I 23#define	DIRP(path, dir, buf){				\	int rval;					\	struct	stat	statbuf;			\		strcpy(buf, path);			\		strcat(buf, dir);			\E 23		TIMEOUT( rval=stat(buf, &statbuf) );	\D 23		if( rval == 0){			\E 23I 23		if( rval == 0){				\E 23			if( (statbuf.st_mode & S_IFMT) == S_IFDIR ){	\				strcat(path, dir);			\				return(1);				\			}				\		}					\		}#endifE 21D 23#define	FILEP(path, file, buf){	\I 7	int rval;		\E 7		strcpy(buf, path);		\		strcat(buf, file);		\E 23I 23#define	FILEP(path, file, buf){				\	int rval;					\		strcpy(buf, path);			\		strcat(buf, file);			\E 23I 7		TIMEOUT( rval=access(buf, F_OK) );	\E 7D 23		if( access(buf, F_OK) == 0){	\E 23I 23		if( access(buf, F_OK) == 0){		\E 23			strcat(path, file);		\			return(1);			\		}					\		}#define	STREQ(name1, name2)(	\		(*name1 == *name2) && (strcmp(name1, name2) == 0)	\		)D 23#define	MAXNUM(i,j)  (i>j ? i : j)E 23I 23D 27/*** These aren't used -FS	#define	MAXNUM(i,j)  (i>j ? i : j)	#define	MINNUM(i,j)  (i<j ? i : j) ***/E 27I 27#define	SPECIALFILEMARK		-1E 27E 23I 30#define NumericStringP(str, truetag, falsetag) {			\	register char	*cp;						\									\	if (*str == '\0') goto falsetag;				\									\	for(cp = str; *cp!='\0'; ++cp)					\	  if(*cp < '0' || '9' < *cp)					\	    goto falsetag;						\	goto truetag;							\}E 30D 23#define	MINNUM(i,j)  (i<j ? i : j)E 23D 27#define	VERSIONLEN 10E 27D 6#define	MAXVERSION 1000000000E 6I 6D 27#define	MAXVERSION 999999999E 27I 27/*		 * Name:	LispVersionToUnixVersion * * Argument:	char	*pathname *				Xerox Lisp syntax pathname. * * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	The version part of pathname is destructively modified. * * Description: * * Destructively modify the version part of pathname which is following the * Xerox Lisp file naming convention to UNIX one. * If the file name which is passed from Lisp has the version part, it must be * a valid one (i.e. construected with only number).  This is guaranteed by Lisp * code. * This macro should be called at the top of the routines which accept the * file name from lisp before converting it into UNIX file name, because * locating the version part, the informations about quoted characters are needed. * They might be lost in the course of the conversion. * */E 27E 6D 27#define	UnixVersionToLispVersion(pathname){		\		char	*cp;				\D 6		if( (cp=index(pathname, '~')) != 0 ){	\			*cp++ = ';';		\			for(;*cp!='~';cp++);	\			*cp = '\0';			\E 6I 6D 12		char	*cp1;				\E 12I 12		register char	*cp1;				\E 12		if( ((cp=index(pathname, '~'))!=0) && (*(cp-1) == '.') && ((cp1=index(cp+1, '~'))!=0) ){	\D 23				*(cp-1) = ';';		\				for(cp++;cp!=cp1;cp++)		\					*(cp-1) = *cp;	\I 8				for(cp1++;*cp1!='\0';cp1++, cp++)	\					*(cp-1) = *cp1;			\E 8				*(cp-1) = '\0';			\E 6		}else					\			strcat(pathname, ";0");		\E 23I 23			*(cp-1) = ';';				\			for(cp++;cp!=cp1;cp++)			\				*(cp-1) = *cp;			\			for(cp1++;*cp1!='\0';cp1++, cp++)	\				*(cp-1) = *cp1;			\			*(cp-1) = '\0';				\		}else						\			strcat(pathname, ";0");			\E 23		}E 27I 27#define LispVersionToUnixVersion(pathname){				\									\	register char	*cp;						\	register char	*vp;						\	register int	ver;						\	char		ver_buf[VERSIONLEN];				\									\	cp = pathname;							\	vp = NULL;							\	while (*cp) {							\		switch (*cp) {						\									\		      case ';':						\			vp = cp;					\			cp++;						\			break;						\									\		      case '\'':					\			if (*(cp + 1) != '\0') cp += 2; 		\			else cp++;					\			break;						\									\		      default:						\			cp++;						\			break;						\		}							\	}								\									\	if (vp != NULL) {						\		/*							\		 * A semicolon which is not quoted has been found.	\		 */							\		if (*(vp + 1) == '\0') {				\			/*						\			 * The empty version field.			\			 * This is regared as a versionless file.	\			 */						\			*vp = '\0';					\D 30		} else if (numeric_string_p(vp + 1)) {			\E 30I 30		} else {						\			NumericStringP((vp + 1), YES, NO);		\		      YES:						\E 30			/*						\			 * Convert the remaining field to digit.	\			 */						\			ver = atoi(vp + 1);				\			if (ver == 0) {					\				/* versionless */			\				*vp = '\0';				\			} else {					\				sprintf(ver_buf, ".~%d~", ver);		\				*vp = '\0';				\				strcat(pathname, ver_buf);		\			}						\D 30		} else {						\E 30I 30			goto CONT;					\									\		      NO:						\E 30			strcpy(ver_buf, vp + 1);			\			strcat(ver_buf, "~");				\			*vp++ = '.';					\			*vp++ = '~';					\			*vp = '\0';					\			strcat(pathname, ver_buf);			\I 30		      CONT:						\			vp--;	/* Just for label */			\E 30		}							\	}								\}E 27D 27#define	LispVersionToUnixVersion(pathname){		\		char	*cp;				\I 6D 12		char	*cp1;				\I 8		char	*cp2;				\E 12I 12D 23		register char	*cp1;				\		register char	*cp2;				\E 23I 23		register char	*cp1;			\		register char	*cp2;			\E 23E 12E 8E 6		if( (cp=index(pathname, ';')) != 0 ){	\D 6			if(*(cp+1) != '0'){		\				*cp++ = '~';		\				for(;*cp!='\0';cp++);	\				*cp++ = '~';		\			}				\			*cp = '\0';			\		}					\		}#define	LispVersionToNoVersion(pathname){		\		char	*cp;				\		if( (cp=index(pathname, ';')) != 0 ){	\			if(*(cp+1) == '*')		\E 6I 6			switch(*(cp+1)){		\D 8			case '0':			\E 6				*cp = '\0';		\I 6				break;			\E 8			case '\0':			\				break;			\I 8			case '0':			\				if(*(cp+2) == '\0'){	\					*cp = '\0';	\					break;		\				}			\E 8D 23			default: 			\E 23I 23			default:			\E 23				*cp++ = '.';		\D 8				for(cp1=cp;*cp1!='\0';cp1++);	\E 8I 8				for(cp1=cp;((*cp1>='0')&&(*cp1<='9'))||*cp1=='*';cp1++);	\D 10				for(cp2=cp1;*cp2!='\0';cp2++)	\					*(cp2+2) = *cp2;			\				*(cp2+2) = '\0';		\E 10I 10				for(cp2=cp1;*cp2!='\0';cp2++);	\				for(;cp2!=cp1;cp2--)	\					*(cp2+2) = *cp2;\				*(cp2+2) = *cp2;\E 10E 8				*(cp1+1) = '~';		\D 8				*(cp1+2) = '\0';		\				for(;cp!=cp1;cp1--)	\E 8I 8				for(;cp!=cp1;cp1--)		\E 8					*cp1 = *(cp1-1);	\				*cp = '~';		\			}				\E 6		}					\		}E 27I 27/*		 * Name:	UnixVersionToLispVersion * * Argument:	char	*pathname *				UNIX syntax pathname.I 30 *		int	vlessp *				If 0, versionless file is converted to version 1. *				Otherwise, remains as versionless.E 30 * * Value:	If succeed, returns 1, otherwise 0. * * Side Effect:	The version part of pathname is destructively modified. * * Description: * * Destructively modify the version part of pathname which is following the * UNIX file naming convention to Xerox Lisp one. * This macro should be called, in the routines which convert the UNIX pathname * to Lisp one, just before it returns the result to Lisp, because converting * version field will append a semicolon and it might make the routine be * confused. * The file which has not a valid version field, that is ".~##~" form, is * dealt with as version 1.  */E 27I 27D 30#define UnixVersionToLispVersion(pathname){					\E 30I 30#define UnixVersionToLispVersion(pathname, vlessp){				\E 30										\	register char	*start;							\	register char	*end;							\	register char	*cp;							\	register int	len, ver_no;						\	char		ver_buf[VERSIONLEN];					\										\	if ((start = index(pathname, '~')) != NULL) {				\		/* First of all, find the version field in pathname. */		\		end = start;							\		cp = start + 1;							\		while (*cp) {							\			if (*cp == '~') {					\				start = end;					\				end = cp;					\				cp++;						\			} else {						\				cp++;						\			}							\		}								\										\		if (start != end && *(start - 1) == '.' && end == (cp - 1)) {	\			/*							\			 * pathname ends in the form ".~###~".  But we		\			 * check ### is a valid number or not.			\			 */							\			len = (int)end - (int)start - 1;			\			strncpy(ver_buf, start + 1, len);			\			ver_buf[len] = '\0';					\D 30			if (numeric_string_p(ver_buf)) {			\				*(start - 1) = ';';				\				*start = '\0';					\				*end = '\0';					\                                /* call ato i to eliminate leading 0s. */	\				ver_no = atoi(start + 1);			\				sprintf(ver_buf, "%d", ver_no);			\				strcat(pathname, ver_buf);			\			} else {						\				/* Dealt with as version 1. */			\				strcat(pathname, ";1");				\			}							\E 30I 30			NumericStringP(ver_buf, YES, NO);			\		      YES:							\			*(start - 1) = ';';					\			*start = '\0';						\			*end = '\0';						\			/* call ato i to eliminate leading 0s. */		\			ver_no = atoi(start + 1);				\			sprintf(ver_buf, "%d", ver_no);				\			strcat(pathname, ver_buf);				\			goto CONT;						\										\		      NO:							\			/* Dealt with as version 1 unless vlessp */		\			if (!vlessp) strcat(pathname, ";1");			\		      CONT:							\			cp--;	/* Just for label */				\E 30		} else {							\D 30			/* Dealt with as version 1. */				\			strcat(pathname, ";1");					\E 30I 30			/* Dealt with as version 1 unless vlessp. */		\			if (!vlessp) strcat(pathname, ";1");			\E 30		}								\	} else {								\D 30		/* Dealt with as version 1. */					\		strcat(pathname, ";1");						\E 30I 30		/* Dealt with as version 1 unless vlessp. */			\		if (!vlessp) strcat(pathname, ";1");				\E 30	}									\}/*		 * Name:	ConcDirAndName * * Argument:	char	*dir	The name of the directory. *		char	*name	The name of a file. *		char	*fname	The place where the full file name should be *				stored. * Value:	N/A * * Side Effect:	fname is replaced with the full file name. * * Description: * * Concatenate the directory name and root file name.  Checks if dir contains * the trail directory delimiter or not. * */D 29#define ConcDirAndName(dir name fname){					\E 29I 29D 30#define ConcDirAndName(dir, name, fname){				\E 30I 30#define ConcDirAndName(dir, name, fname){					\E 30E 29									\	register char	*cp1, *cp2;					\									\	cp1 = dir;							\	cp2 = dir;							\									\	while (*cp2 != '\0') {						\		switch (*cp2) {						\									\		      case '/':						\			cp1 = cp2;					\			cp2++;						\			break;						\									\		      default:						\			cp2++;						\			break;						\		}							\	}								\	if (cp1 == (cp2 - 1)) {						\		if (cp1 == dir) {					\			/* dir is a root directory. */			\			strcpy(fname, "/");				\			strcat(fname, name);				\		} else {						\			/* The trail directory is included. */		\			strcpy(fname, dir);				\			strcat(fname, name);				\		}							\	} else {							\		/* The trail directory is not included */		\		strcpy(fname, dir);					\		strcat(fname, "/");					\		strcat(fname, name);					\	}								\}/*		 * Name:	ConcNameAndVersion * * Argument:	char	*name	The root file name. *		char	*ver	The file version. *		char	*rname 	The place where the concatenated file name will be *				stored. * Value:	N/A * * Side Effect:	rname is replaced with the concatenated file name. * * Description: * * Concatenate the root file name and its version in UNIX format. * */#define ConcNameAndVersion(name, ver, rname){				\	if (*ver != '\0') {						\		strcpy(rname, name);					\		strcat(rname, ".~");					\		strcat(rname, ver);					\		strcat(rname, "~");					\	} else {							\		strcpy(rname, name);					\	}								\}#define	 VERSIONLEN		16#define	MAXVERSION		999999999#define	LASTVERSIONARRAY	0xFFFFFFFF#define	VERSIONARRAYLENGTH	200#define NoFileP(varray)						\	((varray->version_no == LASTVERSIONARRAY)? 1 : 0)#define OnlyVersionlessP(varray)							\	((varray->version_no == 0 && (varray + 1)->version_no == LASTVERSIONARRAY) ?	\	 1 : 0)E 27I 9/* An argument of AddDodNoExtention must be LispVersion convention *//* Like "foo/fee.fee;3" or "/foo/foo;3" *//* AddDodNoExtention must be put after UnixVersionToLispVersion */D 23#define	AddDodNoExtention(file){		\E 23I 23#define	AddDodNoExtention(file){			\E 23D 12		char	*cp;			\		char	*cp1;			\E 12I 12		register char	*cp;			\		register char	*cp1;			\E 12		if( (rindex(file,'.')== 0) && ((cp=rindex(file,';'))!=0) ){	\			for(cp1=cp;*cp1!='\0';cp1++);	\			*(cp1+1) = '\0';		\			for(;cp!=cp1;cp1--)		\				*cp1 = *(cp1-1);	\D 23			*cp = '.';		\		}				\E 23I 23			*cp = '.';			\		}					\E 23		}I 11/* An argument of RemoveDodNoExtenstion must be LispVersion convention *//* Like "foo/fee.fee;3" or "/foo/foo.;3" *//* RemoveDodNoExtenstion must be put before LispVersionToUnixVersion */D 23#define RemoveDodNoExtenstion(file){		\D 12		char	*cp;			\E 12I 12		register char	*cp;			\E 23I 23#define RemoveDodNoExtenstion(file){					\		register char	*cp;					\E 23E 12		if( ((cp=rindex(file, ';'))!=0) && (*(cp-1)=='.') ){	\			for(;*cp!='\0';++cp)				\				*(cp-1) = *cp;				\D 23			*(cp-1) = '\0';				\		}				\E 23I 23			*(cp-1) = '\0';					\		}							\E 23		}E 11		E 9extern	int	errno;I 12#define	ChangeToVersionless(pathname){			\		register char	*cp;			\		if( (cp=rindex(pathname, ';')) != 0)	\			*cp = '\0';			\		}D 27#define NoFileP(version_array)				\		((version_array->version_no==LASTVERSIONARRAY)? T : NIL)E 27I 13I 21#ifdef FSERRORE 21#define	UNLINK(x){					\		TIMEOUT(rval=unlink(x));		\		if(rval == -1){				\			err_mess("unlink", errno);	\I 21			*Lisp_errno = errno;		\E 21			return(0);			\		}					\		}I 21#else#define	UNLINK(x){					\		TIMEOUT(rval=unlink(x));		\		if(rval == -1){				\			err_mess("unlink", errno);	\			return(0);			\		}					\		}#endifE 21I 21#ifdef FSERRORE 21#define LINK(x,y){					\		TIMEOUT(rval=link(x, y));		\		if(rval == -1){				\			if(errno == 2)			\				return(1);		\			else{				\				err_mess("link", errno);\I 21				*Lisp_errno = errno;	\E 21				return(0);		\			}				\		}					\		}I 21#else#define LINK(x,y){					\		TIMEOUT(rval=link(x, y));		\		if(rval == -1){				\			if(errno == 2)			\				return(1);		\			else{				\				err_mess("link", errno);\				return(0);		\			}				\		}					\		}#endifE 21D 15E 15I 15#ifdef FSERRORE 15D 14#define RENAME(x,y){					\E 14I 14D 21#define RENAME(x,y,errp){				\E 21I 21D 23#define RENAME(x,y){				\E 23I 23#define RENAME(x,y){					\E 23E 21E 14		TIMEOUT(rval=rename(x, y));		\		if(rval == -1){				\D 14			if(errno == 2)			\E 14I 14			switch(errno){			\			case 2:				\E 14				return(1);		\D 14			else{				\E 14I 14			case 18:			\D 21				*errp = errno;		\E 21I 21D 23				*Lisp_errno = errno;		\E 23I 23				*Lisp_errno = errno;	\E 23E 21				return(0);		\			default:			\E 14				err_mess("rename", errno);\I 14D 21				*errp = errno;		\E 21I 21D 23				*Lisp_errno = errno;		\E 23I 23				*Lisp_errno = errno;	\E 23E 21E 14				return(0);		\			}				\		}					\		}D 15E 15I 15#elseD 23#define RENAME(x,y){				\E 23I 23#define RENAME(x,y){					\E 23		TIMEOUT(rval=rename(x, y));		\		if(rval == -1){				\			switch(errno){			\			case 2:				\				return(1);		\			default:			\				err_mess("rename", errno);\				return(0);		\			}				\		}					\		}#endifE 15I 21#ifdef FSERRORE 21D 23#define	STAT(x,y){						\		TIMEOUT(rval=stat(x, y));	\		if(rval != 0){					\			err_mess("stat", errno);		\I 21			*Lisp_errno = errno;			\E 21			return(-1);				\		}						\E 23I 23#define	STAT(x,y){					\		TIMEOUT(rval=stat(x, y));		\		if(rval != 0){				\			err_mess("stat", errno);	\			*Lisp_errno = errno;		\			return(-1);			\		}					\E 23		}D 21E 21I 21#elseD 23#define	STAT(x,y){						\		TIMEOUT(rval=stat(x, y));	\		if(rval != 0){					\			err_mess("stat", errno);		\			return(-1);				\		}						\E 23I 23#define	STAT(x,y){					\		TIMEOUT(rval=stat(x, y));		\		if(rval != 0){				\			err_mess("stat", errno);	\			return(-1);			\		}					\E 23		}#endifI 32/* * For file name length check */#define FNAMETOOLONG	200#define FileNameTooLong(val) {				\	*Lisp_errno = FNAMETOOLONG;			\	return((val));					\}E 32E 21E 13E 12E 1