h01017s 00005/00004/00161d D 1.3 92/11/25 20:18:41 sybalsky 3 2c Fixing extra text in endifs => comment.\nes 00020/00015/00145d D 1.2 92/05/27 19:14:34 sybalsky 2 1c retrofit of 386 unix changes \nes 00160/00000/00000d D 1.1 92/04/21 15:30:44 sybalsky 1 0c date and time created 92/04/21 15:30:44 by sybalskyeuUf e 0tTI 1D 3/* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  *//* %Z% %M% Version %I% (%G%). copyright Venue & Fuji Xerox  */E 3I 3/* %Z% %M% Version %I% (%G%). copyright Venue  */E 3/* 	These are the Macros Used to generate fast dispatch inline code. *//************************************************************************//*									*//*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*//*	Manufactured in the United States of America.			*//*									*//*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*//*									*//************************************************************************//************************************************************************//*									*//*	  F A S T   O P C O D E   D I S P A T C H   M A C R O S		*//*									*//*	These macros generate better opcode-dispatch code than the	*//*	native compiler will.  The difference may be only one or	*//*	two instructions, but in the inner loop, that's a LOT.		*//*									*//*	To add a new architecture, you must define 5 macros:		*//*									*//*		nextop0 - for single-byte opcodes			*//*		nextop1 - skip a byte and grab an opcode		*//*		nextop2 - skip 2 bytes and grab an opcode		*//*		nextop3 - skip 3 bytes and grab an opcode		*//*		nextop4 - skip 4 bytes and grab an opcode		*//*									*//*	(These macros are already defined naively, so undef them.)	*//*									*//*	For existing implementations, these often expand out to		*//*	calls to inline functions.					*//*									*//*									*//*									*//************************************************************************/#ifdef OPDISP	/* Only do any of this if OPDISP is set. */	/* Sun 3 */#ifdef mc68020#undef nextop0#undef nextop1#undef nextop2#undef nextop3#undef nextop4/* JRB - fast case is now nextop1 */#define nextop0 { fast0_dispatcher(); goto nextopcode; }#define nextop1 { fast1_dispatcher(); goto nextopcode; }#define nextop2 { fast1_dispatcher2(); }#define nextop3 { PCMACL += 2; nextop1; }#define nextop4 { PCMACL += 3; nextop1; }#endif	/* Sun 386i */#ifdef I386#undef nextop0#undef nextop1#undef nextop2#undef nextop3#undef nextop4/* JRB - fast case is now nextop1 */#define nextop0 { fast0_dispatcher(); goto nextopcode; }#define nextop1 { fast1_dispatcher(); goto nextopcode; }#define nextop2 { fast2_dispatcher(); }#define nextop3 { PCMACL += 2; nextop1; }#define nextop4 { PCMACL += 3; nextop1; }#endif	/* ISC 386 using gcc */#ifdef ISC#undef nextop0#undef nextop1#undef nextop2#undef nextop3#undef nextop4#define nextop0 { fast0_dispatcher(); goto nextopcode; }#define nextop1 { fast1_dispatcher(); goto nextopcode; }#define nextop2 { fast2_dispatcher(); goto nextopcode;}#define nextop3 { fast3_dispatcher(); goto nextopcode;}#define nextop4 { fast4_dispatcher(); goto nextopcode;}#define fast0_dispatcher() \    asm volatile("						\n\D 2	leal	-1(%0),%%eax					\n\	xorb	$3,%%al						\n\	movzbl	(%%eax),%%eax					\n\E 2I 2//	leal	-1(%0),%%eax					\n\/	xorb	$3,%%al						\n\/	movzbl	(%%eax),%%eax					\n\	movzbl	-1(%0),%%eax \n\E 2	jmp	*optable(,%%eax,4)" : : "r" (pccache): "ax");#define fast1_dispatcher() \    asm volatile("						\n\D 2	movl	%0,%%eax					\n\	xorb	$3,%%al						\n\E 2I 2/	movl	%0,%%eax					\n\/	xorb	$3,%%al						\n\	movzbl	(%0),%%eax \n\E 2	incl	%0						\n\D 2	movzbl	(%%eax),%%eax					\n\E 2I 2/	movzbl	(%%eax),%%eax					\n\E 2	jmp	*optable(,%%eax,4)" : "=r" (pccache) : "0" (pccache): "ax");#define fast2_dispatcher() \    asm volatile("						\n\D 2	leal	1(%0),%%eax					\n\E 2I 2/	leal	1(%0),%%eax					\n\	movzbl	1(%0),%%eax \n\E 2	addl	$2,%0						\n\D 2	xorb	$3,%%al						\n\	movzbl	(%%eax),%%eax					\n\E 2I 2/	xorb	$3,%%al						\n\/	movzbl	(%%eax),%%eax					\n\E 2	jmp	*optable(,%%eax,4)" :"=r" (pccache) : "0" (pccache): "ax");#define fast3_dispatcher() \    asm volatile("						\n\D 2	leal	2(%0),%%eax					\n\E 2I 2/	leal	2(%0),%%eax					\n\	movzbl	2(%0),%%eax \n\E 2	addl	$3,%0						\n\D 2	xorb	$3,%%al						\n\	movzbl	(%%eax),%%eax					\n\E 2I 2/	xorb	$3,%%al						\n\/	movzbl	(%%eax),%%eax					\n\E 2	jmp	*optable(,%%eax,4)" :"=r" (pccache) : "0" (pccache): "ax");#define fast4_dispatcher() \    asm volatile("						\n\D 2	leal	3(%0),%%eax					\n\E 2I 2/	leal	3(%0),%%eax					\n\	movzbl	3(%0),%%eax \n\E 2	addl	$4,%0						\n\D 2	xorb	$3,%%al						\n\	movzbl	(%%eax),%%eax					\n\E 2I 2/	xorb	$3,%%al						\n\/	movzbl	(%%eax),%%eax					\n\E 2	jmp	*optable(,%%eax,4)" :"=r" (pccache) : "0" (pccache): "ax");	#endifD 3#endif OPDISPE 3I 3#endif /* OPDISP */E 3I 3E 3#ifdef SPARCDISP#undef nextop0#undef nextop1#undef nextop2#undef nextop3#undef nextop4#define nextop0 { fast_dispatcher(table, Get_BYTE(PCMAC)); goto nextopcode; }#define nextop_n(n) {							\	PCMACL += n;							\	nextop0; 							\}#define nextop1 { nextop_n(1); }#define nextop2 { nextop_n(2); }#define nextop3 { nextop_n(3); }#define nextop4 { nextop_n(4); }D 3#endif SPARCDISPE 3I 3#endif /* SPARCDISP */E 3E 1