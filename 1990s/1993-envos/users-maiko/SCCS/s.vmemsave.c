h38596s 00040/00016/00570d D 2.42 93/02/08 15:01:19 sybalsky 53 52c Big VM (and new CDR coding) changes for 3.0 \nes 00018/00016/00568d D 2.41 92/07/24 10:47:38 sybalsky 52 51c retrofit of SGI & DEC OSF1 changes \nes 00019/00011/00565d D 2.40 92/06/26 13:51:21 sybalsky 51 50c retrofit of 386 unix changes \nes 00026/00009/00550d D 2.39 92/04/29 12:38:01 nilsson 50 49c banes changes to the page saveing.es 00005/00005/00554d D 2.38 92/04/21 17:29:10 sybalsky 49 48c shortening file names for DOS \nes 00028/00012/00531d D 2.37 91/09/27 03:36:15 sybalsky 48 47c ISC port changeses 00118/00005/00425d D 2.36 91/08/26 15:28:02 sybalsky 47 46c Bob Bane's sorted-VM performance enhancer for savevm.es 00003/00001/00427d D 2.35 91/04/09 17:20:58 sybalsky 46 45c Retrofit first round of changes from MIPS porting centeres 00017/00006/00411d D 2.34 90/11/19 23:07:06 sybalsky 45 44c Fix AR 11299, expand ~/ if necessary (i.e., if it was quoted when LDEDESTSYSOUT was set)es 00006/00007/00411d D 2.33 90/09/13 17:24:23 sybalsky 44 43c Fix bug in shutdown of forked-unix pipes when no process was forked (e.g., started lisp by ldex)es 00051/00041/00367d D 2.32 90/08/30 20:57:21 sybalsky 43 42c fix AR 11259 - only close off foees 00046/00034/00362d D 2.31 90/08/30 10:31:59 sybalsky 42 41c es 00023/00004/00373d D 2.30 90/05/31 14:52:25 fuji 41 40c Add NEW storage futures.(various process size)es 00008/00006/00369d D 2.29 90/05/15 18:24:17 sybalsky 40 39c make sysout, makesys, savevm work on 386i.es 00001/00001/00374d D 2.28 90/04/20 02:08:59 sybalsky 39 38c AIX:  shortening file names, bulk change.es 00091/00078/00284d D 2.27 90/04/19 18:28:43 mitani 38 37c vmem_save0 uses unixpathnamees 00235/00179/00127d D 2.26 90/03/25 16:39:02 sybalsky 37 36c byte-swap the sysout pages as they get written.es 00015/00009/00291d D 2.25 90/03/01 14:14:20 osamu 36 35c IF lde runs with -NF, lisp_finish() doesn't kill lde's subprocess.es 00003/00003/00297d D 2.24 89/12/13 11:00:53 sybalsky 35 34c string-safety, color ss1es 00002/00000/00298d D 2.23 89/10/19 18:02:47 sybalsky 34 33c new sysout microcode type -- set it to 15000, for Medley 1.1a identificationes 00001/00001/00297d D 2.22 89/03/18 04:03:49 sybalsky 33 32c OneDArrayes 00023/00003/00275d D 2.21 89/01/11 11:28:42 hayata 32 31c ver 2.20 masked Takeshi's change (ver 2.18). His changes are added again.es 00024/00017/00254d D 2.20 89/01/09 08:53:52 hayata 31 30c To fix AR11009, check of free space is moved to Lisp Code.es 00048/00027/00223d D 2.19 89/01/06 19:09:00 hayata 30 29c Sysout is saved to temp file, then overwite old sysut file. To fix AR 10714 (Fuji request).es 00023/00004/00227d D 2.18 89/01/04 16:58:57 shimizu 29 28c For C-Cursor trackinges 00014/00001/00217d D 2.17 88/12/21 11:51:41 hayata 28 27c Add confirmation of LispString to vmemsave0(). It is for safety.es 00001/00001/00217d D 2.16 88/12/12 18:38:08 hayata 27 26c To fix AR10945, obsolete extern declaration is removed. (ScreenBitMap)es 00013/00000/00205d D 2.15 88/12/12 16:21:22 hayata 26 25c To fix Ar10483(LDEDESTSYSOUT needs '/'), vmem_save() is changed to add './' to the only file name.es 00007/00001/00198d D 2.14 88/12/01 12:02:25 hayata 25 24c To fix error message problem (connection time out & too many files open), global var *Lisp_errno is used to keep errno.es 00001/00001/00198d D 2.13 88/11/28 16:45:57 hayata 24 23c Correct spell miss of error message.es 00002/00002/00197d D 2.12 88/11/28 15:43:01 hayata 23 22c When there is no space of file system, LOGOUT return UNIX without saving image. To fix it, vmem_save0 returns a return value of vmem_save.es 00006/00006/00193d D 2.11 88/10/12 13:51:09 hayata 22 21c In vmem_save0(), check of arg is changed.es 00031/00000/00168d D 2.10 88/10/10 14:11:13 krivacic 21 20c sun3/4 mergees 00003/00003/00165d D 2.9 88/07/26 18:59:09 hayata 20 19c move SETJMP to avoid duplicate use of jump bufferes 00002/00002/00166d D 2.8 88/07/07 14:43:45 shimizu 19 18c commented out print lineses 00002/00000/00166d D 2.7 88/06/30 11:06:38 greep 18 17c put "#ifdef DEBUG" around printfes 00019/00017/00147d D 2.6 88/06/29 10:51:12 hayata 17 16c To fix TIMEOUT, SETJMP are used.es 00001/00001/00163d D 2.5 88/06/16 10:32:49 hayata 16 15c Return value of veme_save is changed.es 00015/00010/00149d D 2.4 88/06/13 17:37:11 hayata 15 14c Add TIMEOUTes 00013/00004/00146d D 2.3 88/06/08 11:38:46 jmturn 14 13c Now kills any remaining Unix subprocesseses 00023/00016/00127d D 2.2 88/06/03 15:35:30 hayata 13 12c exit is changed to return(XXX), to fix bug AR10260es 00000/00000/00143d D 2.1 88/05/17 09:27:53 hayata 12 11c Version up to 2.1es 00004/00000/00139d D 1.11 88/05/13 16:11:48 jmturn 11 10c Kill unixcomm Processes 00000/00030/00139d D 1.10 88/05/13 14:15:48 krivacic 10 9c remove native code referenceses 00002/00002/00167d D 1.9 88/05/13 10:14:51 hayata 9 8c Add SCCS keyides 00009/00004/00160d D 1.8 88/05/11 11:46:40 hayata 8 7c Chagne free block check sequence.es 00040/00035/00124d D 1.7 88/05/10 17:35:58 krivacic 7 6c vmemsave workinges 00010/00006/00149d D 1.6 88/05/06 18:05:28 hayata 6 5c Add Disk free page checkes 00010/00006/00145d D 1.5 88/05/06 11:44:53 krivacic 5 4c native ioes 00009/00003/00142d D 1.4 88/04/26 19:49:24 hayata 4 3c Change vmem_save to recognize "~/lisp.virtualmem".es 00033/00002/00112d D 1.3 88/04/22 19:14:54 krivacic 3 2c inlinedefs re-arrangementes 00002/00002/00112d D 1.2 88/03/13 15:10:33 hayata 2 1c Add SCCS key id (%Z%)es 00114/00000/00000d D 1.1 88/02/24 16:59:09 hayata 1 0c date and time created 88/02/24 16:59:09 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 4/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 4I 4D 9/* This is G-file @(#) vmemsave.c Version 1.3 (4/22/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) vmemsave.c	1.3 4/22/88";E 9I 9D 20/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 20I 20D 22/* This is G-file @(#) vmemsave.c Version 2.8 (7/7/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) vmemsave.c	2.8 7/7/88";E 22I 22D 30/* This is G-file %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%		(envos & Fuji Xerox)";E 30I 30D 31/* This is G-file @(#) vmemsave.c Version 2.17 (12/21/88). copyright envos & Fuji Xerox  */static char *id = "@(#) vmemsave.c	2.17 12/21/88		(envos & Fuji Xerox)";E 31I 31D 35/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%      %I% %G%         (envos & Fuji Xerox)";E 35I 35D 36/* @(#) vmemsave.c Version 2.22 (3/18/89). copyright envos & Fuji Xerox  */static char *id = "@(#) vmemsave.c      2.22 3/18/89         (envos & Fuji Xerox)";E 36I 36D 40/* %Z% %M% Version %I% (%G). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%         (envos & Fuji Xerox)";E 40I 40D 41/* @(#) vmemsave.c Version 2.28 (%G). copyright envos & Fuji Xerox  */static char *id = "@(#) vmemsave.c	2.28 4/20/90         (envos & Fuji Xerox)";E 41I 41D 48/* %Z% %M% Version %I% (%G%). copyright envos & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%         (envos & Fuji Xerox)";E 48I 48D 53/* %Z% %M% Version %I% (%G%). copyright venue & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%         (venue & Fuji Xerox)";E 53I 53/* %Z% %M% Version %I% (%G%). copyright venue  */static char *id = "%Z% %M%	%I% %G%         (venue)";E 53E 48E 41E 40E 36E 35E 31E 30E 22E 20E 9E 4E 2I 48E 48I 15D 22E 22E 15D 37/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. */E 37D 41I 37E 41/************************************************************************//*									*/D 48/*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*/E 48I 48D 52/*	(C) Copyright 1989, 1990, 1991 Venue. All Rights Reserved.	*/E 52I 52/*	(C) Copyright 1989-1992 Venue. All Rights Reserved.		*/E 52/*	Manufactured in the United States of America.			*/E 48/*									*/D 48/*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*/E 48I 48/*	The contents of this file are proprietary information 		*//*	belonging to Venue, and are provided to you under license.	*//*	They may not be further distributed or disclosed to third	*//*	parties without the specific permission of Venue.		*/E 48/*									*//************************************************************************/I 48E 48E 37/**	vmemsave.c*D 37*	** ADOPTED NEW VERSIONE 37**/#include <stdio.h>D 48#include <sys/file.h>E 48#include <sys/types.h>I 48#include <sys/file.h>E 48#include <sys/stat.h>I 4#include <sys/param.h>I 38#include <sys/dir.h>I 44#ifndef AIXI 52#ifndef APOLLOE 52E 44E 38I 6#include <sys/vfs.h>I 44D 52#endif AIXE 52I 52#endif /* APOLLO */#endif /* AIX */E 52E 44I 38#include <pwd.h>E 38E 6E 4#include <errno.h>I 11#include <signal.h>I 17#include <setjmp.h>I 42D 46E 46I 46#ifdef RISCOS#include <dirent.h>D 52#endif RISCOSE 52I 52#endif /* RISCOS */E 52I 48#ifdef ISC#include <dirent.h>#include <unistd.h>#include <sys/fcntl.h>D 52#endif ISCE 52I 52#endif /* ISC */E 52E 48E 46#ifndef NOPIXRECTE 42E 17E 11#include <sunwindow/win_cursor.h>I 42D 52#endif NOPIXRECTE 52I 52#endif /* NOPIXRECT */E 52E 42I 3D 39#include "machineconfig.h"E 39I 39D 49#include "hdw_config.h"E 49I 49#include "hdw_conf.h"E 49E 39E 3#include "lispemul.h"#include "lispmap.h"D 49#include "lispglobal.h"E 49I 49#include "lspglob.h"E 49#include "ifpage.h"#include "vmemsave.h"I 15#include "timeout.h"I 21D 49#include "address68k.h"#include "lisptypes.h"#include "localfile.h"E 49I 49#include "adr68k.h"#include "lsptypes.h"#include "locfile.h"E 49I 43#include "dbprint.h"E 43E 21E 15I 51#ifdef GCC386#include "inlnPS2.h"#endifI 53#ifdef BIGVM#define GETFPTOVP(b,o) b[o]#define GETPAGEOK(b,o) (b[o]>>16)#else#define GETFPTOVP GETBASEWORD#define GETPAGEOK GETBASEWORD#endif /* BIGVME 53/* Error return values from VMEMSAVE */E 51I 13D 16#define	COMPLETESYSOUT	S_POSITIVE | 0E 16I 16#define	COMPLETESYSOUT	NILE 16#define	BADFILENAME	S_POSITIVE | 1	#define	NOFILESPACE	S_POSITIVE | 2	#define FILECANNOTOPEN	S_POSITIVE | 3#define FILECANNOTSEEK	S_POSITIVE | 4#define FILECANNOTWRITE	S_POSITIVE | 5I 31#define FILETIMEOUT	S_POSITIVE | 6E 31E 13struct stat     DEBUG_stat;extern int LispWindowFd;D 27extern struct pixrect *ScreenBitMap, *CursorBitMap, *InvisibleCursorBitMap;E 27I 27extern struct pixrect *CursorBitMap, *InvisibleCursorBitMap;E 27extern struct cursor CurrentCursor, InvisibleCursor;I 34extern IFPAGE *InterfacePage;E 34I 8char	*rindex();E 8I 7#undef roundup#define roundup( a, b) ((((unsigned)(a)+(b)-1)/(b))*(b))I 21I 25extern int	*Lisp_errno;D 45extern int	Dummy_errno;		/* If errno cell is not provided by Lisp, dummy_errno is used. */E 45I 45extern int	Dummy_errno;	/* Used if errno cell isn't provided by Lisp.*/E 45D 36E 36I 36extern int      please_fork;I 37/************************************************************************//*									*/I 43/*			l i s p s t r i n g p				*/E 43/*									*/I 43/*	Predicate:  Is the argument (which must be a Lisp 1-d array)	*//*		    a lisp string?  i.e., are its elements char's?	*/E 43/*									*/D 43/*									*//*									*/E 43/************************************************************************/E 37E 36I 28lispstringP(Lisp)D 37LispPTR	Lisp;{D 33	switch( ((ONEDARRAAY *)(Addr68k_from_LADDR(Lisp)))->typenumber ){E 33I 33	switch( ((OneDArray *)(Addr68k_from_LADDR(Lisp)))->typenumber ){E 37I 37  LispPTR	Lisp;  {    switch( ((OneDArray *)(Addr68k_from_LADDR(Lisp)))->typenumber )      {E 37E 33	case THIN_CHAR_TYPENUMBER:D 37	case FAT_CHAR_TYPENUMBER:		return(1);	default:		return(0);	}}E 37I 37	case FAT_CHAR_TYPENUMBER:   return(1);E 37I 37	default: return(0);      }  }I 38D 43/*		 * Name:	vmem_save0 * * Argument:	LispPTR	*args	args[0]D 42 *				 The file name in Lisp format specifying a file to which *				 the current Lisp image should be flushed or Lisp NIL.E 42I 42 *			 The file name in Lisp format specifying a file to which *			 the current Lisp image should be flushed or Lisp NIL.E 42 *D 42 * Value:	If succeed, returns Lisp NIL, otherwise one of the following Lisp integer *		indicating the reason of failure.E 42I 42 * Value:	If succeed, returns NIL, otherwise one of the following *		Lisp integers, indicating the reason of failure.E 42 * *			1	BADFILENAME *			2	NOFILESPACE *			3	FILECANNOTOPEN *			4	FILECANNOTSEEK *			5	FILECANNOTWRITE *			6	FILETIMEOUT * * Side Effect:	None. * * Description: * * The implementation of the VMEMSAVE SUBR call routine.   Write out the current Lisp * image to the specified file.  If the sysout file name is expricitly specified, the * directory on which the sysout file resids is exactly exisiting directory.  This is * guranteed by the Lisp code.  See \MAIKO.CHECKFREEPAGE in LLFAULT. *  * If the argument is Lisp NIL, the default sysout name * is used.  The default sysout name is "~/lisp.virtualmem", but it can be overridden * by the UNIX environment variable LDEDESTSYSOUT. */E 43E 38I 43/************************************************************************//*									*//*			v m e m _ s a v e 0				*//*									*//*	Implements the VMEMSAVE subr.  Write out the current lisp	*//*	lisp image to the specified file.  If the sysout file-name	*//*	is explicitly specified, the directory on which the file	*//*	resides is exactly (?) an existing directory.  This is		*//*	guaranteed by the Lisp code, \MAIKO.CHECKFREEPAGE in LLFAULT.	*//*									*//*	If the file argument is nill, the default sysout-file name,	*//*	"~/lisp.virtualmem", is used, subject to override by the	*//*	LDEDESTSYSOUT UNIX-environment variable.			*//*									*//*									*//*									*//*									*//* Argument:	LispPTR	*args	args[0]					*//*			 The file name in Lisp format specifying a	*//*			 file to which the current Lisp image should	*//*			 be flushed or Lisp NIL.			*//*									*//* Value:	If succeed, returns NIL, otherwise one of the		*//*		following Lisp integers, indicating the reason.		*//*									*//*			1	BADFILENAME				*//*			2	NOFILESPACE				*//*			3	FILECANNOTOPEN				*//*			4	FILECANNOTSEEK				*//*			5	FILECANNOTWRITE				*//*			6	FILETIMEOUT				*//*									*//* Side Effect:	None.							*//*									*//************************************************************************/E 43D 38/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 38E 37E 28E 25vmem_save0(args)D 37register LispPTR	*args;{D 22register int	*bufp;E 22register char	*def;register char	*cp;char	pathname[MAXPATHLEN];char	*getenv();char	*index();D 22	bufp = (int *)(Addr68k_from_LADDR(args[0]));	if( *bufp == 0){E 22I 22D 28	if( args[0] != 0){E 28I 28	if( (args[0] != 0) && lispstringP(args[0]) ){		/* check of lispstringP is safer for LispStringToCString */E 28E 22		/* arg of subrcall is non-nil */D 35		LispStringToCString(args[0], pathname);E 35I 35		LispStringToCString(args[0], pathname, MAXPATHLEN);E 35		/* Remove Host name({DSK} or {UNIX}) */		cp = index(pathname, '}');D 23		vmem_save(cp+1);E 23I 23		return( vmem_save(cp+1) );E 23	}else{		if((def=getenv("LDEDESTSYSOUT")) == 0){			strcpy(pathname, "~/lisp.virtualmem");		}else{			strcpy(pathname, def);		}D 23		vmem_save(pathname);E 23I 23		return( vmem_save(pathname) );E 23	}}E 37I 37D 38  register LispPTR	*args;  {    register char	*def;    register char	*cp;    char	pathname[MAXPATHLEN];    char	*getenv();    char	*index();    if( (args[0] != 0) && lispstringP(args[0]) )      {	/* check of lispstringP is safer for LispStringToCString */	/* arg of subrcall is non-nil */	LispStringToCString(args[0], pathname, MAXPATHLEN);	/* Remove Host name({DSK} or {UNIX}) */	cp = index(pathname, '}');	return( vmem_save(cp+1) );      }    else      {	if((def=getenv("LDEDESTSYSOUT")) == 0)	  strcpy(pathname, "~/lisp.virtualmem");	else strcpy(pathname, def);	return( vmem_save(pathname) );      }  }E 38I 38D 42	register LispPTR	*args;{	register char	*def;	char		pathname[MAXPATHLEN], sysout[MAXPATHLEN], host[MAXNAMLEN];	struct passwd	*pwd;	char		*getenv();	char		*index();E 42I 42  register LispPTR	*args;  {    register char	*def;    char	pathname[MAXPATHLEN], sysout[MAXPATHLEN], host[MAXNAMLEN];    struct passwd	*pwd;    char		*getenv();    char		*index();E 42    D 42	Lisp_errno = &Dummy_errno;E 42I 42    Lisp_errno = &Dummy_errno;E 42	D 42	if((args[0] != NIL) && lispstringP(args[0])) {		/* Check of lispstringP is safer for LispStringToCString */		LispStringToCString(args[0], pathname, MAXPATHLEN);		separate_host(pathname, host);		if (!unixpathname(pathname, sysout, 0, 0)) return(BADFILENAME);		return(vmem_save(sysout));	} else {		if((def = getenv("LDEDESTSYSOUT")) == 0) {			pwd = getpwuid(getuid()); /* NEED TIMEOUT */			if (pwd == (struct passwd *)NULL) return(FILETIMEOUT);			strcpy(sysout, pwd->pw_dir);			strcat(sysout, "/lisp.virtualmem");		} else {			strcpy(sysout, def);		}		return(vmem_save(sysout));	}}E 42I 42D 45    if((args[0] != NIL) && lispstringP(args[0])) E 45I 45    if((args[0] != NIL) && lispstringP(args[0]))E 45      {	/* Check of lispstringP is safer for LispStringToCString */	LispStringToCString(args[0], pathname, MAXPATHLEN);	separate_host(pathname, host);	if (!unixpathname(pathname, sysout, 0, 0)) return(BADFILENAME);	return(vmem_save(sysout));D 45      }     else E 45I 45      }    elseE 45      {	if((def = getenv("LDEDESTSYSOUT")) == 0)	  {	    pwd = getpwuid(getuid()); /* NEED TIMEOUT */	    if (pwd == (struct passwd *)NULL) return(FILETIMEOUT);	    strcpy(sysout, pwd->pw_dir);	    strcat(sysout, "/lisp.virtualmem");	  }D 45	elseE 45I 45	 elseE 45	  {D 45	    strcpy(sysout, def);E 45I 45	    if (*def == '~' &&	        (*(def + 1) == '/' || *(def + 1) == '\0'))	      {		pwd = getpwuid(getuid()); /* NEED TIMEOUT */		if (pwd == (struct passwd *)NULL) return(FILETIMEOUT);		strcpy(sysout, pwd->pw_dir);		strcat(sysout, def + 1);	      }	    else	      {		strcpy(sysout, def);	      }E 45	  }	return(vmem_save(sysout));      }  }E 42E 38E 37I 42I 48/************************************************************************//*									*//*				v m e m _ s a v e			*//*									*//*									*//*									*//************************************************************************/E 48E 42I 38/*		D 48 * Name:	vmem_save *E 48 * Argument:	char	*sysout_file_nameD 42 *				 The file name in UNIX format specifying a file to which *				 the current Lisp image should be flushed.E 42I 42 *			 The file name in UNIX format specifying a file to which *			 the current Lisp image should be flushed.E 42 * * Value:	If succeed, returns Lisp NIL, otherwise one of the following Lisp integer *		indicating the reason of failure. * *			1	BADFILENAME *			2	NOFILESPACE *			3	FILECANNOTOPEN *			4	FILECANNOTSEEK *			5	FILECANNOTWRITE *			6	FILETIMEOUT * * Side Effect:	None. * * Description: * * Flush out the current Lisp image to the specified file. */E 38D 37			E 37E 21I 50/* diagnostic flag value to limit the size of write() s */int maxpages = 65536;E 50I 37D 38/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/E 38E 37E 7vmem_save(sysout_file_name)D 37char	*sysout_file_name;{	int		sysout;	/* SysoutFile descriptor */D 29	DLword	*fptovp;	/* FPTOVP */E 29I 29D 30	register DLword	*fptovp;	/* FPTOVP */E 30I 30D 32	DLword	*fptovp;	/* FPTOVP */E 32I 32	register DLword	*fptovp;	/* FPTOVP */E 32E 30E 29	int	vmemsize;	/* VMEMSIZE */D 29	int	i;E 29I 29D 30	register int	i;E 30I 30D 32	int	i;E 32I 32	register int	i;E 32E 30E 29I 4	char	fullpathname[MAXPATHLEN];I 30	char	tempname[MAXPATHLEN];E 30I 8	char	dirname[MAXPATHLEN];E 8I 6	struct statfs	fsbuf;E 6I 5D 10	unsigned	pagsiz = getpagesize();E 10I 8	char	*cp;I 15D 29	int	rval;E 29I 29D 30	register int	rval;	DLword *bmptr;	extern int ScreenLocked;	extern DLword *EmCursorX68K;	extern DLword *EmCursorY68K;	extern DLword NullCursor[];		extern DLword *EmCursorBitMap68K;E 30I 30D 32	int	rval;E 32I 32	register int	rval;	DLword *bmptr;	extern int ScreenLocked;	extern DLword *EmCursorX68K;	extern DLword *EmCursorY68K;	extern DLword NullCursor[];		extern DLword *EmCursorBitMap68K;E 37I 37D 38  char	*sysout_file_name;  {E 38I 38D 42	register char	*sysout_file_name;{E 42I 42  register char	*sysout_file_name;  {E 42E 38    int		sysout;	/* SysoutFile descriptor */I 53#ifdef BIGVM	register unsigned int *fptovp;#elseE 53    register DLword	*fptovp;	/* FPTOVP */I 53#endif /* BIGVM */E 53    int	vmemsize;	/* VMEMSIZE */    register int	i;D 38    char	fullpathname[MAXPATHLEN];E 38    char	tempname[MAXPATHLEN];D 38    char	dirname[MAXPATHLEN];E 38D 44    struct statfs	fsbuf;E 44I 44 /* * *   struct statfs	fsbuf; * * */E 44    char	*cp;    register int	rval;    DLword *bmptr;D 51    extern int ScreenLocked;E 51I 51    int tot_pages = 0;	extern int ScreenLocked;E 51    extern DLword *EmCursorX68K;    extern DLword *EmCursorY68K;    extern DLword NullCursor[];	    extern DLword *EmCursorBitMap68K;E 37E 32E 30E 29E 15E 8E 5E 4I 17D 20	SETJMP(BADFILENAME);E 20D 25E 25I 25D 38#ifdef	FSERRORD 37	/* For call makepathname */	Lisp_errno = &Dummy_errno;E 37I 37    /* For call makepathname */    Lisp_errno = &Dummy_errno;E 37#endifE 38I 34D 37	InterfacePage->minbversion = 15000; /* Mark this sysout for new emulator */E 34I 26	/* When file name doew not have directory, ./ is added to the name */	switch(*sysout_file_name){E 37I 37    InterfacePage->minbversion = 15000; /* Mark this sysout for new emulator */D 38    /* When file name doew not have directory, ./ is added to the name */    switch(*sysout_file_name)      {E 37	case '~':	case '.':	case '/':D 37	case '<':			break;	default:	/* use fullpathname as a temp cache */			strcpy(fullpathname, "./");			strcat(fullpathname, sysout_file_name);			strcpy(sysout_file_name, fullpathname);	}E 37I 37	case '<':  break;	default:  /* use fullpathname as a temp cache */		  strcpy(fullpathname, "./");		  strcat(fullpathname, sysout_file_name);		  strcpy(sysout_file_name, fullpathname);      }E 38E 37			E 26E 25E 17I 3D 6	printf("Write Memory Image: %s\n",sysout_file_name);E 6D 8E 8I 4D 37	if( makepathname(sysout_file_name, fullpathname) == 0)D 13		return;E 13I 13		return(BADFILENAME);E 37I 37D 38    if( makepathname(sysout_file_name, fullpathname) == 0)	return(BADFILENAME);E 37E 13D 8	printf("Write Memory Image: %s\n",fullpathname);E 8E 38E 4E 3D 37	/* remove cursor image from screen */E 37I 37    /* remove cursor image from screen */I 38E 38E 37I 3D 29E 29I 29D 30#ifdef OLD_CURSORE 30I 30D 36E 36I 36#ifdef SUNDISPLAYE 36I 32#ifdef OLD_CURSORE 32E 30E 29E 3D 37	win_setcursor( LispWindowFd, &InvisibleCursor);E 37I 37    win_setcursor( LispWindowFd, &InvisibleCursor);E 37I 32#elseD 37	ScreenLocked=T;	taking_mouse_down();E 37I 37    ScreenLocked=T;    taking_mouse_down();E 37/*	bmptr = EmCursorBitMap68K;D 37	EmCursorBitMap68K= NullCursor;*/E 37I 37    EmCursorBitMap68K= NullCursor;*/E 37D 53#endif OLD_CURSORI 36#endif SUNDISPLAYE 53I 53#endif /* OLD_CURSOR */E 53E 36E 32I 29D 30#else	ScreenLocked=T;	taking_mouse_down();/*	bmptr = EmCursorBitMap68K;	EmCursorBitMap68K= NullCursor;*/#endif OLD_CURSORE 30E 29I 53#endif /* SUNDISPLAY */E 53D 37	/* set FPTOVP */D 7	fptovp = FPtoVP;E 7I 7	fptovp = FPtoVP + 1;E 37I 37    /* set FPTOVP */    fptovp = FPtoVP + 1;E 37E 7D 37	/* set VMEMSIZE */	vmemsize = InterfacePage->nactivepages;D 6E 6I 6D 7	if( statfs(fullpathname, &fsbuf) != 0)E 7I 7D 8	if( statfs(fullpathname, &fsbuf) != 0){		printf("System Status Error\n");E 8I 8	strcpy(dirname, fullpathname);D 13	cp = rindex(dirname, '/');E 13I 13	if((cp=rindex(dirname, '/')) == 0)E 37I 37    /* set VMEMSIZE */    vmemsize = InterfacePage->nactivepages;D 38    strcpy(dirname, fullpathname);    if((cp=rindex(dirname, '/')) == 0)E 37		return(BADFILENAME);E 13D 37	*cp = '\0';I 22	if(confirmpath(dirname) == 0)E 37I 37    *cp = '\0';    if(confirmpath(dirname) == 0)E 37		return(BADFILENAME);E 38I 31D 37/**** [HH:6-Jan-89]	>>check of free space is done by Lisp<<E 31E 22I 20	SETJMP(BADFILENAME);E 20D 15	if( statfs(dirname, &fsbuf) != 0){E 15I 15	TIMEOUT( rval=statfs(dirname, &fsbuf) );	if( rval != 0){E 15		err_mess("statfs", errno);E 8E 7D 13		return;E 13I 13		return(BADFILENAME);E 13I 7	}E 37D 38E 38E 7D 17	if(vmemsize > (fsbuf.f_bavail * 512) ){E 17I 17D 37	if( (vmemsize * BYTESPER_PAGE) > (fsbuf.f_bavail * fsbuf.f_bsize) ){E 17D 24		printf("File Systm Resources Exceeded\n");E 24I 24		printf("File System Resources Exceeded\n");E 24D 13		return;E 13I 13		return(NOFILESPACE);E 13	}I 31****/E 31I 30E 37/*	[HH:6-Jan-89]	Sequnce of save image	(1) Sysout image is saved to a temporary file, tempname.D 38	(2) if a specified file, fullpathname, is exist, the file is removed.E 38I 38	(2) if a specified file, sysout_file_name, is exist, the file is removed.E 38	(3) the temporary file is renamed to the specified file.*/D 37	E 37D 38E 38E 30E 6D 31	/* open sysoutfile */I 3I 30	SETJMP(BADFILENAME);E 31I 31D 37	SETJMP(FILETIMEOUT);E 31E 30I 22	sprintf(fullpathname, "%s/%s", dirname, cp+1);E 22E 3D 4	sysout = open(sysout_file_name, O_WRONLY | O_CREAT | O_TRUNC, 0666);E 4I 4D 15	sysout = open(fullpathname, O_WRONLY | O_CREAT | O_TRUNC, 0666);E 15I 15D 30	TIMEOUT(sysout=open(fullpathname, O_WRONLY | O_CREAT | O_TRUNC, 0666));E 30I 30	sprintf(tempname, "%s/%s-temp", dirname, cp+1);E 37I 37    SETJMP(FILETIMEOUT);D 38    sprintf(fullpathname, "%s/%s", dirname, cp+1);    sprintf(tempname, "%s/%s-temp", dirname, cp+1);E 38I 38    sprintf(tempname, "%s-temp", sysout_file_name);E 38E 37I 31	/* Confirm protection of specified file by open/close */D 37	TIMEOUT(sysout=open(fullpathname, O_WRONLY, 0666));	if (sysout == -1) {		/* No file error skip return. */		if(errno != 2){	/* No such file error.*/			return(FILECANNOTOPEN);		}	}else{		TIMEOUT( rval = close(sysout) );	}E 37I 37D 38    TIMEOUT(sysout=open(fullpathname, O_WRONLY, 0666));E 38I 38    TIMEOUT(sysout=open(sysout_file_name, O_WRONLY, 0666));E 38    if (sysout == -1)      {	/* No file error skip return. */	if(errno != 2) return(FILECANNOTOPEN); /* No such file error.*/      }    else TIMEOUT( rval = close(sysout) );E 37D 37	/* open temp file */E 31	TIMEOUT(sysout=open(tempname, O_WRONLY | O_CREAT | O_TRUNC, 0666));E 30E 15E 4	if (sysout == -1) {I 3D 13		printf("vmem_save: can't open sysoutfile: %d\n", errno);E 3D 6		error("vmem_save: can't open sysoutfile");		exit(-1);E 6I 6		return;E 13I 13		err_mess("open", errno);		return(FILECANNOTOPEN);E 13E 6	}E 37I 37    /* open temp file */    TIMEOUT(sysout=open(tempname, O_WRONLY | O_CREAT | O_TRUNC, 0666));    if (sysout == -1)      {	err_mess("open", errno);	return(FILECANNOTOPEN);      }E 37I 3D 10	/* setup NATIVE Code Info */E 10D 37	InterfacePage->machinetype = KATANA;D 5	InterfacePage->native_start_addr = native_load_address;	InterfacePage->native_length = (int)sbrk(0) - (int)native_load_address;E 5I 5D 10	InterfacePage->native_start_addr_mem_page=native_load_address/pagsiz;	InterfacePage->native_length_page = D 7		((int)sbrk(0)-(int)native_load_address) / pagsiz;E 7I 7		(roundup(sbrk(0),pagsiz)-(int)native_load_address) / pagsiz;E 7	InterfacePage->native_page_offset=vmemsize;E 5I 7	printf("vmemsize is 0x%x, SKIPPAGES: 0x%x, SKIP_DOMINOPAGES: 0x%x\nLastPage: 0x%x" , vmemsize,SKIPPAGES,SKIP_DOMINOPAGES,SKIP_DOMINOPAGES+vmemsize-SKIPPAGES);E 10D 19	printf("start vmemsave\n"); E 19I 19	/*printf("start vmemsave\n"); */E 37I 37    InterfacePage->machinetype = KATANA;I 41D 52/** CHANGES FOR NEW STORAGE **/E 52I 52E 52#ifdef NEW_STORAGE    /* Restore storagefull state */D 52    if(((*STORAGEFULLSTATE_word) & 0xffff)== SFS_NOTSWITCHABLE){E 52I 52    if(((*STORAGEFULLSTATE_word) & 0xffff)== SFS_NOTSWITCHABLE)      {E 52	/* This sysout uses only 8 Mbyte lisp space.	   It may be able to use this SYSOUT which has more than	   8 Mbyte lisp space.	   To enable to expand lisp space, \\STORAGEFULLSTATE	   should be NIL.	*/	*STORAGEFULLSTATE_word = NIL;	InterfacePage->storagefullstate=NIL;D 52    }    else {E 52I 52      }    else      {E 52	/*  Otherwise, just restore storagefullstate in IFPAGE */D 52    	InterfacePage->storagefullstate= 		(*STORAGEFULLSTATE_word) & 0xffff ;    }/** CHANGES FOR NEW STORAGE END**/E 52I 52    	InterfacePage->storagefullstate =  (*STORAGEFULLSTATE_word) & 0xffff ;      }E 52D 53#endif NEW_STORAGEE 53I 53#endif /* NEW_STORAGE */E 53E 41D 52    /*printf("start vmemsave\n"); */E 52E 37E 19I 53E 53I 47    /* First, sort fptovp table, trying to get pages contiguous */I 53#ifndef BIGVME 53D 51E 51I 51D 52#ifndef ISC	/* For some reason, the 386 doesn't like this sorted. */E 52I 52#ifndef BYTESWAP	/* Byte-swapped machines don't sort the table right. */E 52E 51    sort_fptovp(fptovp, vmemsize);I 51#endifI 53#endifE 53E 51D 51E 51E 47D 37	/* store vmem to sysoutfile */E 37I 37    /* store vmem to sysoutfile */E 37D 17    for (i = 0; i < vmemsize; i++) {E 17I 17D 37	for (i = 0; i < vmemsize; i++) {		if (fptovp[i] != 0177777) {	   		TIMEOUT( rval=lseek(sysout, i * BYTESPER_PAGE, 0) );	   		if (rval == -1) {				err_mess("lseek", errno);				return(FILECANNOTSEEK);	  		}			TIMEOUT( rval=write(sysout, (char *)(Lisp_world + (fptovp[i] * DLWORDSPER_PAGE)), BYTESPER_PAGE) );			if (rval == -1) {				err_mess("write", errno);				return(FILECANNOTWRITE);			}		}  	}E 37I 37    for (i = 0; i < vmemsize; i++)      {D 40	if (fptovp[i] != 0177777)E 40I 40D 53	if (GETBASEWORD(fptovp,i) != 0177777)E 53I 53	if (GETPAGEOK(fptovp,i) != 0177777)E 53E 40	  {I 47D 53	    int oldfptovp = GETBASEWORD(fptovp, i);E 53I 53	    int oldfptovp = GETFPTOVP(fptovp, i);E 53	    int contig_pages = 0;#ifdef BYTESWAP	    int pc;D 53#endif BYTESWAPE 53I 53#endif /* BYTESWAP */E 53E 47I 40	    register char *base_addr;I 47E 47E 40	    TIMEOUT( rval=lseek(sysout, i * BYTESPER_PAGE, 0) );	    if (rval == -1) 	      {		err_mess("lseek", errno);		return(FILECANNOTSEEK);	      }I 40D 53	    base_addr = (char *)(Lisp_world + (GETBASEWORD(fptovp,i) * DLWORDSPER_PAGE));E 53I 53	    base_addr = (char *)(Lisp_world + (GETFPTOVP(fptovp,i) * DLWORDSPER_PAGE));E 53I 47	    /* Now, let's see how many pages we can dump */D 53	    while(GETBASEWORD(fptovp,i) == oldfptovpE 53I 53	    while(GETFPTOVP(fptovp,i) == oldfptovpE 53		  && i < vmemsize) {	      contig_pages++, oldfptovp++, i++;	    }	    i--;	/* Previous loop always overbumps i */	    DBPRINT(("%4d: writing %d pages from %x\n",		    i, contig_pages, base_addr - (char*)Lisp_world));E 47E 40#ifdef BYTESWAPD 40	    word_swap_page((char *)(Lisp_world + (fptovp[i] * DLWORDSPER_PAGE)),E 40I 40	    word_swap_page(base_addr,E 40D 47			    BYTESPER_PAGE/4);E 47I 47			    contig_pages*BYTESPER_PAGE/4);E 47D 53#endif BYTESWAPE 53I 53#endif /* BYTESWAP */E 53D 47	    TIMEOUT( rval=write(sysout,D 40		     (char *)(Lisp_world + (fptovp[i] * DLWORDSPER_PAGE)),E 40I 40		     base_addr,E 40		     BYTESPER_PAGE) );E 47I 47D 50	    { int oldTT = TIMEOUT_TIME;	      /* As we can spend longer than TIMEOUT_TIME doing a big		 write, we adjust the timeout temporarily here */	      TIMEOUT_TIME += contig_pages>>5;	      TIMEOUT( rval=write(sysout,				  base_addr,				  contig_pages * BYTESPER_PAGE) );	      TIMEOUT_TIME = oldTT;	    }E 50I 50	    if(contig_pages > maxpages) {	      char *ba = base_addr;	      int pc = contig_pages;	      while (pc > maxpages) {		TIMEOUT(rval = write(sysout, ba, maxpages * BYTESPER_PAGE));		if (rval == -1) {		  err_mess("write", errno);		  return(FILECANNOTWRITE);		}		ba += maxpages * BYTESPER_PAGE;		pc -= maxpages;	      }	      if(pc > 0)		TIMEOUT(rval = write(sysout, ba, pc * BYTESPER_PAGE););	    } else { int oldTT = TIMEOUT_TIME;		     /* As we can spend longer than TIMEOUT_TIME doing a big			write, we adjust the timeout temporarily here */D 51		     TIMEOUT_TIME += contig_pages>>5;E 51I 51		     TIMEOUT_TIME += contig_pages>>3;E 51		     TIMEOUT( rval=write(sysout,					 base_addr,					 contig_pages * BYTESPER_PAGE) );		     TIMEOUT_TIME = oldTT;		   }E 50E 47#ifdef BYTESWAPD 40	    word_swap_page((char *)(Lisp_world + (fptovp[i] * DLWORDSPER_PAGE)),E 40I 40	    word_swap_page(base_addr,E 40D 47			    BYTESPER_PAGE/4);E 47I 47			    contig_pages*BYTESPER_PAGE/4);E 47D 53#endif BYTESWAPE 53I 53#endif /* BYTESWAP */E 53	    if (rval == -1)	      {		err_mess("write", errno);		return(FILECANNOTWRITE);	      }	  }      }E 37E 17D 17	if (fptovp[i] != 0177777) {D 15	    if (lseek(sysout, i * BYTESPER_PAGE, 0) == -1) {E 15I 15	    TIMEOUT( rval=lseek(sysout, i * BYTESPER_PAGE, 0) );	    if (rval == -1) {E 15D 13		printf("sysout_loader: can't seek SysoutFile");		exit(-1);E 13I 13		err_mess("lseek", errno);		return(FILECANNOTSEEK);E 13	    };D 15	    if (write(sysout, (char *)(Lisp_world + (fptovp[i] * DLWORDSPER_PAGE)), BYTESPER_PAGE) == -1) {E 15I 15	    TIMEOUT( rval=write(sysout, (char *)(Lisp_world + (fptovp[i] * DLWORDSPER_PAGE)), BYTESPER_PAGE) );	    if (rval == -1) {E 15D 13			printf("i: 0x%x, fptovp[i]: 0x%x = ",i,*fptovp);			printf("%d\n" , fptovp[i]); 			error("vmem_save: can't save vmempage");		exit(-1);E 13I 13		err_mess("write", errno);		return(FILECANNOTWRITE);E 13	    };	};    }E 17D 17E 17E 7E 3D 37	/* seek to IFPAGE */I 7D 15E 7	if (lseek(sysout, (long)FP_IFPAGE, 0) == -1) {E 15I 15D 17	TIMEOUT(rval=lseek(sysout, (long)FP_IFPAGE, 0) );E 17I 17	TIMEOUT(rval=lseek(sysout, (long)FP_IFPAGE, 0));E 17	if (rval == -1) {E 15D 13		error("vmem_save: can't seek to IFPAGE");		exit(-1);E 13I 13		err_mess("lseek", errno);		return(FILECANNOTSEEK);E 13	}D 15	D 7	/* store IFPAGE to sysoutfile */	/* SAVE_IFPAGE points buffer page for IFPAGE */D 3	 if (write(sysout, (char *)(Lisp_world + (SAVE_IFPAGE * DLWORDSPER_PAGE)), BYTESPER_PAGE) == -1) {E 3I 3/*	 if (write(sysout, (char *) (Lisp_world + (SAVE_IFPAGE * DLWORDSPER_PAGE)), BYTESPER_PAGE) == -1) {*/E 7	 if (write(sysout, (char *) InterfacePage, BYTESPER_PAGE) == -1) {E 15I 15	TIMEOUT(rval=write(sysout, (char *) InterfacePage, BYTESPER_PAGE) );	if (rval == -1) {E 37I 37    /* seek to IFPAGE */    TIMEOUT(rval=lseek(sysout, (long)FP_IFPAGE, 0));    if (rval == -1)      {	err_mess("lseek", errno);	return(FILECANNOTSEEK);      }#ifdef BYTESWAP	    word_swap_page((char *) InterfacePage,			    BYTESPER_PAGE/4);D 53#endif BYTESWAPE 53I 53#endif /* BYTESWAP */E 53    TIMEOUT(rval=write(sysout, (char *) InterfacePage, BYTESPER_PAGE) );#ifdef BYTESWAP	    word_swap_page((char *) InterfacePage,			    BYTESPER_PAGE/4);D 53#endif BYTESWAPE 53I 53#endif /* BYTESWAP */E 53    if (rval == -1)      {E 37E 15E 3D 13		error("vmem_save:can't save IFPAGE");		exit(-1);E 13I 13		err_mess("write", errno);		return(FILECANNOTWRITE);E 13	}D 3	E 3D 10D 7	/* skip dominocode in sysoutfile */E 7I 3E 3D 7	fptovp += DOMINOPAGES;	if (lseek(sysout, (long)SKIP_DOMINOPAGES, 0) == -1) {D 6		printf("vmem_save: can't skip DOMPINOCODE");		exit(-1);E 6I 6		return;E 6	}	printf("vmemsize is ");	printf("%d\n" , vmemsize);	printf("start vmemsave\n"); 	/* store vmem to sysoutfile */	for(i = SKIPPAGES; i <= vmemsize ; i++) {		/* printf("%4d %6d", i, *fptovp); */		if (*fptovp == 0 | *fptovp == 65535) {E 7D 7			error("vmem_save: Bad vmempage");			exit(-1);		}		if (write(sysout, (char *)(Lisp_world + (*fptovp * DLWORDSPER_PAGE)), BYTESPER_PAGE) == -1) {			printf("%d\n" , *fptovp); /* print bad vp for debug */			error("vmem_save: can't save vmempage");E 7I 7	/* Write out Native Code */E 7D 7			exit(-1);		}		fptovp++;		/* printf("\b\b\b\b\b\b\b\b\b\b\b"); */		}I 3/* Write out Native Code */E 7D 5	if (lseek(sysout, InterfacePage->native_start_addr, 0) == -1) {E 5I 5	if(lseek(sysout,InterfacePage->native_page_offset*BYTESPER_PAGE,0)==-1){E 5		printf("sysout_writer: can't seek to NATIVE CODE");		exit(-1);   		}D 5	printf("Writing Native Code/n");	if (write(sysout, InterfacePage->native_start_addr, InterfacePage->native_length) == -1) {E 5I 5	printf("Vmemsize: 0x%x\n",vmemsize);D 7	printf("Writing Native Code from: 0x%x\n to Lisp Page: 0x%x\n for 0x%x pages\n",native_load_address,InterfacePage->native_page_offset,InterfacePage->native_length_page);E 7I 7	printf("Writing Native Code from: 0x%x\n",native_load_address);	printf(" To Lisp Page: 0x%x\n",InterfacePage->native_page_offset);	printf(" For 0x%x pages\n",InterfacePage->native_length_page);E 7	if (write(sysout, native_load_address, InterfacePage->native_length_page*pagsiz) == -1) {E 5		printf("sysout_writer: can't write NATIVE CODE");		printf("%d\n", errno);		exit(-1);		}I 7E 7D 5	printf("Native Code written completely./n");E 5I 5	printf("Native Code written completely.\n");E 10E 5    E 3D 15	close(sysout);E 15I 15D 30	TIMEOUT( close(sysout) );E 30I 30D 37	TIMEOUT( rval = close(sysout) );	if(rval == -1){		return(FILECANNOTWRITE);	}E 37I 37    TIMEOUT( rval = close(sysout) );    if(rval == -1)      {	return(FILECANNOTWRITE);      }E 37E 30E 15I 30D 31	/* Confirm protection of specified file by open/close */	/* Because unlink depends on protection of directory file */	TIMEOUT(sysout=open(fullpathname, O_WRONLY, 0666));	if (sysout == -1) {E 31I 31D 37	TIMEOUT(rval = unlink(fullpathname));	if (rval == -1) {E 31		/* No file error skip return. */		if(errno != 2){	/* No such file error.*/D 31			fprintf(stderr,"sysout is saved to temp file, %s.", tempname);E 31			return(FILECANNOTOPEN);D 31		}	}else{		TIMEOUT( rval = close(sysout) );		TIMEOUT( rval = unlink(fullpathname) );		if(rval == -1){			return(FILECANNOTWRITE);E 31		}	}E 37I 37D 38    TIMEOUT(rval = unlink(fullpathname));E 38I 38    TIMEOUT(rval = unlink(sysout_file_name));E 38    if (rval == -1)       {	/* No file error skip return. */	if(errno != 2)	/* No such file error.*/ return(FILECANNOTOPEN);      }E 37D 37	TIMEOUT( rval=rename(tempname, fullpathname) );	if( rval== -1){		fprintf(stderr,"sysout is saved to temp file, %s.", tempname);		return(FILECANNOTWRITE);	}E 37I 37D 38    TIMEOUT( rval=rename(tempname, fullpathname) );E 38I 38    TIMEOUT( rval=rename(tempname, sysout_file_name) );E 38    if( rval== -1)      {	fprintf(stderr,"sysout is saved to temp file, %s.", tempname);	return(FILECANNOTWRITE);      }E 37E 30D 37	/* restore cursor image to screen */E 37I 37    /* restore cursor image to screen */E 37I 36#ifdef SUNDISPLAYE 36I 32#ifdef OLD_CURSORE 32I 29D 30#ifdef OLD_CURSORE 30E 29D 37	win_setcursor( LispWindowFd, &CurrentCursor);E 37I 37    win_setcursor( LispWindowFd, &CurrentCursor);E 37I 32#elseD 37	ScreenLocked=T;	/*EmCursorBitMap68K = bmptr ;*/	taking_mouse_up(*EmCursorX68K,*EmCursorY68K);	ScreenLocked=NIL;E 37I 37    ScreenLocked=T;    /*EmCursorBitMap68K = bmptr ;*/    taking_mouse_up(*EmCursorX68K,*EmCursorY68K);    ScreenLocked=NIL;E 37D 53#endif OLD_CURSORI 36#endif SUNDISPLAYE 53I 53#endif /* OLD_CURSOR */#endif /* SUNDISPLAY */E 53E 36E 32I 29D 30#else	ScreenLocked=T;	/*EmCursorBitMap68K = bmptr ;*/	taking_mouse_up(*EmCursorX68K,*EmCursorY68K);	ScreenLocked=NIL;#endif OLD_CURSORE 30E 29D 19	printf("vmem is saved completely.\n");E 19I 19D 37	/*printf("vmem is saved completely.\n");*/E 19I 13	return(COMPLETESYSOUT);E 13}E 37I 37    /*printf("vmem is saved completely.\n");*/    return(COMPLETESYSOUT);  }E 37I 37/************************************************************************//*									*/I 43/*			l i s p _ f i n i s h				*/E 43/*									*/I 43/*	Kill all forked sub-processes before exiting.			*/E 43/*									*/D 43/*									*//*									*/E 43/************************************************************************/E 37I 11extern int UnixPID;I 14/* Make sure that we kill off any Unix subprocesses before we go away */E 14E 11lisp_finish()D 37{D 14	printf("finish lisp_finish\n");I 11	kill(UnixPID, SIGKILL);E 11	device_before_exit();	exit(1);E 14I 14  char d[3];E 37I 37  {D 43    char d[3];E 43I 43    char d[4];E 43E 37I 18D 43#ifdef  DEBUGE 18D 37  printf("finish lisp_finish\n");E 37I 37    printf("finish lisp_finish\n");E 37I 18#endifE 43I 43    DBPRINT(("finish lisp_finish\n"));E 43E 18D 36  d[0] = 'E';  d[3] = 1;  write(UnixPipeOut, d, 4);	/* Send fork_Unix on a homicidal spree */  read(UnixPipeIn, d, 4);	/* Make sure it's finished */  kill(UnixPID, SIGKILL);	/* Then kill fork_Unix itself */E 36I 36D 37  if( please_fork ){		/* if lde runs with -NF(No fork),				 * floowing 5 lines don't work well. */    d[0] = 'E';    d[3] = 1;    write(UnixPipeOut, d, 4);	/* Send fork_Unix on a homicidal spree */    read(UnixPipeIn, d, 4);	/* Make sure it's finished */    kill(UnixPID, SIGKILL);	/* Then kill fork_Unix itself */  }E 36  device_before_exit();  exit(1);E 37I 37    if( please_fork )      {		/* if lde runs with -NF(No fork), */		/* following 5 lines don't work well. */	d[0] = 'E';	d[3] = 1;D 43	write(UnixPipeOut, d, 4);   /* Send fork_Unix on a homicidal spree */	read(UnixPipeIn, d, 4);	/* Make sure it's finished */	kill(UnixPID, SIGKILL);	/* Then kill fork_Unix itself */E 43I 43	/* These only happen if the fork really succeeded:D 44	if (UnixPipeOut >= 0)	  write(UnixPipeOut, d, 4);   /* Send fork_Unix on a homicidal spree */	if (UnixPipeIn >= 0)	  read(UnixPipeIn, d, 4);	/* Make sure it's finished */	if (UnixPID >= 0)	  kill(UnixPID, SIGKILL);	/* Then kill fork_Unix itself */E 44I 44	/* if (UnixPipeOut >= 0) write(UnixPipeOut, d, 4); */	/* if (UnixPipeIn >= 0 read(UnixPipeIn, d, 4);*/	/* Make sure it's finished */	/* if (UnixPID >= 0) kill(UnixPID, SIGKILL);*/	/* Then kill fork_Unix itself */E 44E 43      }    device_before_exit();    exit(1);E 37E 14	D 37}E 37I 37  }E 37I 47/************************************************************************//*									*//*			s o r t _ f p t o v p				*//*									*//*	Sort the entries in the file-page-to-virtual-page table,	*//*	to try to make a sysout file that has contiguous runs of	*//*	virtual pages in it, for speed.					*//*									*//************************************************************************/int twowords(i,j)	/* the difference between two  DLwords. */D 48DLword *i, *j;{  return(*i - *j);}E 48I 48  DLword *i, *j;  {    return(*i - *j);  }E 48#define FPTOVP_ENTRY (FPTOVP_OFFSET >> 8)sort_fptovp(fptovp, size)  DLword *fptovp;  int size;  {    int oldloc, newloc, oldsize, i;    DLword *fptr;    for(fptr = fptovp, i=0;D 51        *fptr != FPTOVP_ENTRY && i < size;E 51I 51        GETWORD(fptr) != FPTOVP_ENTRY && i < size;E 51        fptr++, i++);D 51    if(*fptr != FPTOVP_ENTRY)E 51I 51    if(GETWORD(fptr) != FPTOVP_ENTRY)E 51      {	DBPRINT((stderr, "Couldn't find FPTOVP_ENTRY; not munging\n"));	return;      }    oldloc = fptr - fptovp;    /* Found old fptovp table location, now sort the table */    qsort(fptovp, size, sizeof(DLword), twowords);ONE_MORE_TIME: /* Tacky, but why repeat code? */    /* Look up FPTOVP_ENTRY again; if it's moved, need to shuffle stuff */    for(fptr = fptovp, i=0;D 51        *fptr != FPTOVP_ENTRY && i < size;E 51I 51        GETWORD(fptr) != FPTOVP_ENTRY && i < size;E 51        fptr++, i++);D 51    if(*fptr != FPTOVP_ENTRY) error("Couldn't find FPTOVP_ENTRY second time!\n");E 51I 51    if(GETWORD(fptr) != FPTOVP_ENTRY) error("Couldn't find FPTOVP_ENTRY second time!\n");E 51    newloc = fptr - fptovp;    /* Supposedly all we have to do is adjust the fptovpstart and nactivepages       the ifpage */    InterfacePage->fptovpstart += (newloc - oldloc);    oldsize = size;D 51    for(fptr = fptovp + (size-1); *fptr == 0xffff;E 51I 51    for(fptr = fptovp + (size-1); GETWORD(fptr) == 0xffff;E 51        fptr--, InterfacePage->nactivepages--, size--);    if(size != oldsize)      DBPRINT(("Found %d holes in fptovp table\n", oldsize - size));      /* Sanity check; it's just possible there are duplicate entries... */      {	int dupcount = 0;	for(fptr = fptovp, i=1;	    i<size;	    i++, fptr++)D 51	if(*fptr == *(fptr+1))E 51I 51	if(GETWORD(fptr) == GETWORD(fptr+1))E 51	  {	    dupcount++;D 51	    *fptr = 0xffff;E 51I 51	    GETWORD(fptr) = 0xffff;E 51	  }	/* if duplicates were found, resort to squeeze them out, then mung the           size and fptovpstart again (spaghetti-code, HO!) */	if(dupcount)	  {	    qsort(fptovp, size, sizeof(DLword), twowords);	    oldloc = newloc;	    DBPRINT((stderr, "%d duplicates found\n", dupcount));	    goto ONE_MORE_TIME;	  }      }  }E 47E 1