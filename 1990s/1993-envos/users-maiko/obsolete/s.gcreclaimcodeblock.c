h11765s 00001/00001/00186d D 2.8 88/11/03 18:07:57 krivacic 16 15c add oplength for opcode # 36, miscnes 00004/00002/00183d D 2.7 88/08/01 22:41:50 bane 15 14c Bugs in entry compare and rehash function of closure-cache searches 00041/00004/00144d D 2.6 88/07/08 01:20:32 masinter 14 13c add back built-in opcode table. Make locals ints; char doesn't seem to workes 00001/00000/00147d D 2.5 88/06/21 12:43:33 masinter 13 12c must increment reference count of deleted marker in closure cache tablees 00003/00040/00144d D 2.4 88/06/09 22:53:57 masinter 12 11c Use UFN table always -- code is simpler and more likely to track changes in unimp. opses 00001/00001/00183d D 2.3 88/06/09 13:57:30 krivacic 11 10c fix && => & in code reclaimeres 00010/00005/00174d D 2.2 88/06/09 09:27:40 bane 10 9c lmm: fix ENVCALL length, allow for other ops to be addedes 00000/00000/00179d D 2.1 88/05/17 09:24:54 hayata 9 8c Version up to 2.1es 00003/00001/00176d D 1.8 88/05/07 17:23:55 masinter 8 7c Track change to Lisp code for envcall (LABELS bug fix)es 00012/00075/00165d D 1.7 88/04/29 04:54:18 masinter 7 6c Fix bug where removing implicit hash key didn't delrefes 00003/00008/00237d D 1.6 88/04/29 00:56:08 masinter 6 5c merge tomtom's changes for closure cachees 00181/00023/00064d D 1.5 88/03/20 16:48:48 masinter 5 4c merge new gc code for closure cachees 00061/00135/00026d D 1.4 88/04/14 15:58:27 masinter 4 3c Simplify codees 00011/00032/00150d D 1.3 88/04/13 22:11:28 masinter 3 2c Change reclaimcodeblock to use opcode length table rather than Lisp structurees 00002/00002/00180d D 1.2 88/03/13 14:50:22 hayata 2 1c Add SCCS key id (%Z%)es 00182/00000/00000d D 1.1 88/02/24 16:57:23 hayata 1 0c date and time created 88/02/24 16:57:23 by hayataeuUtTI 1D 2/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%M%	%I% %G%";E 2I 2D 5/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */D 4static char *id = "%Z% %M%	%I% %G%";E 4I 4static char    *id = "%Z% %M%	%I% %G%";E 5I 5D 10/* This is G-file %Z% %M% gcreclaimcodeblock.c Version %I% (%G%). copyright Xerox & Fuji Xerox  */D 6static char    *id = "@(#) gcreclaimcodeblock.c	%Z% %M%	%I% %G%";E 5E 4E 2D 3/*** ADOPTED NEW VERSION ***/E 3E 6I 6static char    *id = "@(#) gcreclaimcodeblock.c %Z% %M% %I% %G%";E 10I 10D 12/* This is G-file @(#) gcreclaimcodeblock.c gcreclaimcodeblock.c Version 1.8 (5/7/88). copyright Xerox & Fuji Xerox  */static char    *id = "@(#) gcreclaimcodeblock.c @(#) gcreclaimcodeblock.c 1.8 5/7/88";E 12I 12/* This is G-file %Z% %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  */static char *id = "%Z% %M%	%I% %G%";E 12E 10E 6D 4/*************************************************************************//*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 *//*************************************************************************//*                                                                       *//*                       File Name : gcreclaimcodeblock.c                *//*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : Sep-25-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions :                                                 *//*                       reclaimcodeblock();                             *//*                                                                       *//*                                                                       *//*                                                                       *//*************************************************************************//*           Descreption :                                               *//*                                                                       *//*  The functions "gcreclaimcell" and "freelistcell" are the translated  *//*  functions from the Lisp functions "\GCRECLAIMCELL"*//*                                                                       *//*                                                                       *//*                                                                       *//*                                                                       *//*                                                                       *//*                                                                       *//*                                                                       *//*                                                                       */ /*                                                                       */ /*                                                                       *//*************************************************************************//*                                                               \Tomtom *//*************************************************************************/E 4I 4/************************************************************************//************************************************************************//* Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	*//************************************************************************//* File Name : gcreclaimcodeblock.c      			        *//*									*//************************************************************************//*									*//* Creation Date : Sep-25-1987                      			*//* Written by Tomoru Teruuchi                       			*//* Edit by Larry Masinter						*//************************************************************************//* 									*//* Functions :                                                 		*//* reclaimcodeblock();                             			*//* 									*//* 									*//* 									*//************************************************************************//* \Tomtom 								*//************************************************************************/E 4#include "lispemul.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "lispmap.h"#include "stack.h"#include "cell.h"#include "ifpage.h"#include "gc.h"#include "array.h"I 5  #define min(a,b)		((a > b)?b:a) E 5D 4#define Oddp(num) (((num % 2) != 0)?1:0)#define min(a,b)		((a > b)?b:a)#define Trailer(ldatum,datum68)	(ldatum+2*(datum68->arlen - ARRAYBLOCKTRAILERCELLS))#define BucketIndex(n)		min(integerlength(n),MAXBUCKETINDEX)#define FreeBlockChainN(n)	((0xffffff & *FreeBlockBuckets_word)+2*BucketIndex(n))E 4#define ENDOFX			0#define GCONST			111D 4#define CodeBaselt(base,off)	(ByteCode)(Oddp(off)?(0x000ff & 	\		*(DLword *)Addr68k_from_LADDR(base+(off)/2)):		\		 ((0x0ff00 & *(DLword *)Addr68k_from_LADDR(base+(off)/2))\		 >>BITSPERBITE))#define CodeBaselt2(base,off)	((CodeBaselt(base,off) << BITSPERBITE)	\		 | CodeBaselt(base,(off+1)))#define Litatom(atm)		((GetTypeNumber(atm) == TYPE_LITATOM)?T:NIL)#define Fixp(fix)		((GetTypeNumber(fix) == TYPE_FIXP)?T:NIL)E 4I 5D 15#define Reprobefn(bits, index)  (((bits^((bits) >> 8)) || min(63, index)) || 1)E 15I 15#define Reprobefn(bits, index)  (((bits^((bits) >> 8)) & min(63, index)) | 1)E 15D 11#define Fn16bits(a, b)          ((a + b) && 0x0ffff)E 11I 11#define Fn16bits(a, b)          ((a + b) & 0x0ffff)E 11#define Hashingbits(item)       (HILOC(item)^( \	     ((LOLOC(item) & 0x1fff) << 3)^(LOLOC(item) >> 9)))#define Getikvalue(base, index) \        (*( LispPTR *)Addr68k_from_LADDR(base + (index << 1)))D 6#define ATOM_FIRST		21420     /* old index is 21416 14-April-1988 (new is 15-April-99) */	/* 21420 */E 6I 6E 6typedef struct implicit_key_hash_table {  LispPTR        base;  unsigned       last_index : 16;  unsigned       num_slots  : 16;  unsigned       num_keys   : 16;  unsigned       null_slots : 16;  LispPTR        key_accessor;} Ikhashtbl;I 14unsigned int oplength[256] = {0,0,0,0,0,1,2,2,2,2,2,2,2,3,0,0,0,2,0,0,1,1,0,2,0,0,0,0,0,0,1,0,D 160,0,0,1,9,9,0,0,E 16I 160,0,0,1,2,9,0,0,E 169,9,9,9,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,2,0,1,1,0,0,0,2,0,0,0,0,1,1,2,3,9,0,0,0,0,0,0,0,1,1,0,0,0,2,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,2,0,1,1,0,1,1,2,9,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0};E 14E 5D 3struct opcode {	LispPTR		op;	LispPTR		opcodename;	LispPTR		opnargs;	LispPTR		opprint;	LispPTR		levadj;	LispPTR		ufnfn;	LispPTR		unimpl;E 3I 3D 4unsigned char oplength[256] =  {0,0,0,0,0,1,2,2,2,2,2,2,2,3,0,0,0,2,0,0,1,1,0,2,0,0,0,0,0,0,1,0,0,0,0,1,-1,-1,0,0,-1,-1,-1,-1,0,-1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,2,0,1,1,0,0,0,2,0,0,0,0,1,1,2,3,-1,0,0,0,0,0,0,0,1,1,0,0,0,2,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,2,0,1,1,0,1,1,2,-1,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0E 4I 4D 12unsigned char   oplength[256] = {D 5	0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 3, 0, 0, 0, 2, 0, 0, 1, 1, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, -1, -1, 0, 0, -1, -1, -1, -1, 0, -1, 0, 0	,1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 1	,1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 1, 2, 3, -1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 2, 0, 1, 1, 0,	1, 1, 2, -1, 0, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1	,1, 0, 0, 0E 5I 50,0,0,0,0,1,2,2,2,2,2,2,2,3,0,0,0,2,0,0,1,1,0,2,0,0,0,0,0,0,1,0,0,0,0,1,9,9,0,0,D 109,9,9,9,0,9,0,0,E 10I 109,9,9,9,0,0,0,0,E 101,1,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,2,0,1,1,0,0,0,2,0,0,0,0,1,1,2,3,9,0,0,0,0,0,0,0,1,1,0,0,0,2,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,2,0,1,1,0,1,1,2,9,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0E 5E 4E 3};E 12D 3E 3I 3D 4/* not used here; maybe put this somewhere else?E 3LispPTR getprop(atom, tag)LispPTR		atom,tag;{LispPTR	atmptr,atmprop,propcell;   if (Litatom(atom))	{atmptr = ((PLIS_HI << 16) | ((atom & 0x0ffff) << 1));	 atmprop = *(LispPTR *)Addr68k_from_LADDR(atmptr);	 propcell = *(LispPTR *)Addr68k_from_LADDR(atmprop);	 while (Listp(propcell))		{if (Listp(cdr(propcell)))			{if (car(propcell) == tag)			   return(car(cdr(propcell)));			else			   propcell = cdr(cdr(propcell));			}		 else		    return(NIL);		};	  return(NIL);	}   else	return(NIL);}I 3*/E 4I 4typedef ByteCode *InstPtr;E 4E 3D 3LispPTR findop(opname, flg)LispPTR		opname, flg;{   if (*OpCode_Array_word == NIL)	{error("Not implemented the array function in findop.\n");	 /* *OpCodeArray_word = array(256,,,); */	};/*   if (Litatom(opname))	return(getprop(opname,Dopcode_index));   else if (Fixp(opname))		*/   if ((opname >= 0) && (opname < 256))	return(elt(*OpCode_Array_word, opname));   else if (flg)	error(opname);}E 3D 4map_code_pointers(codeblock,casep)LispPTR		codeblock;DLword		casep;{struct arrayblock 	*cbase; struct dtd		*typdtd; struct fnhead		*fnbase; struct	opcode		*tag; unsigned int		typeno, tmpnum, opnum; DLword			codeloc;   typeno = GetTypeNumber(codeblock);   if (typeno == 0)	{cbase = (struct arrayblock *)Addr68k_from_LADDR(				codeblock - ARRAYBLOCKHEADERWORDS);	 tmpnum = cbase->gctype;	}   else	{typdtd = (struct dtd *)GetDTD(typeno);	 tmpnum = typdtd->dtd_gctype;	};   if (tmpnum != CODEBLOCK_GCT)	error("ARG NOT compiled code block\n");   else 	{fnbase = (struct fnhead *)Addr68k_from_LADDR(codeblock);	 codeloc = fnbase->startpc;	 while(T)D 3	   {tag = (struct opcode *)Addr68k_from_LADDR(			findop(CodeBaselt(codeblock, codeloc), NIL));E 3I 3	   {opnum = CodeBaselt(codeblock, codeloc);E 3	    ++codeloc;D 3	    opnum = (tag->op & 0x0ffff);E 3	    switch(opnum)		{		 case ENDOFX :		/* -X- */ 			return(NIL);		 case GCONST:		/* GCONST */			if ((casep >= 0) && (casep <= 3))				gclookup(0x8000 | casep,VAG2(					CodeBaselt(codeblock, codeloc),					CodeBaselt2(codeblock,(codeloc+1))));			else			   error("Illegal funcall in map_code_pointers.\n");E 4I 4map_code_pointers(codeblock, casep)D 5	LispPTR         codeblock;	DLword          casep;E 5I 5	LispPTR		codeblock;	short		casep;E 5{	InstPtr         codeptr;D 10	ByteCode	opnum;E 10I 10D 14	register ByteCode	opnum;	register int len;E 14I 14	register unsigned int opnum;	register unsigned int len;E 14E 10	struct fnhead  *fnbase;	fnbase = (struct fnhead *) Addr68k_from_LADDR(codeblock);D 14	codeptr = (InstPtr) fnbase + fnbase->startpc;E 14I 14	codeptr = ((InstPtr) fnbase) + fnbase->startpc;E 14	while (T) {		switch (opnum=Get_BYTE(codeptr)) {		case ENDOFX:	/* -X- */			return (NIL);		case GCONST:	/* GCONST */			{LispPTR reclaimed = (Get_BYTE(codeptr + 1) << 16) |				 (Get_BYTE(codeptr + 2) << 8) |				 Get_BYTE(codeptr + 3);D 5			gclookup(0x8000 | casep, reclaimed);}E 5I 5D 8			htfind(reclaimed, casep);}E 8I 8			if (reclaimed != codeblock)				{htfind(reclaimed, casep);}			};E 8E 5E 4		};D 3	   codeloc += (tag->opnargs & 0x0ffff);E 3I 3D 4	   codeloc += oplength[opnum];E 3	   };E 4I 4D 10		codeptr += oplength[opnum] + 1;E 10I 10D 12		len = oplength[opnum];		if (len == 9) { printf("new opcode seen %d ", opnum);				oplength[opnum] = len = (((UFN *)UFNTable) + (opnum))->byte_num;				printf("length set to %d\n", len); }E 12I 12D 14		len =(((UFN *)UFNTable) + (opnum))->byte_num;E 14I 14		if ((len = oplength[opnum]) > 3) {			error("unrecognized bytecode in compiled code; continue to use UFN length");			oplength[opnum] = len =(((UFN *)UFNTable) + (opnum))->byte_num;			}E 14E 12		codeptr += len + 1;E 10E 4	};}I 5D 7LispPTR getikkey(value, keyaccessor)LispPTR value, keyaccessor;D 6{ if (keyaccessor == ATOM_FIRST)E 6I 6{ if (keyaccessor == First_index)E 6    return(*(LispPTR *)Addr68k_from_LADDR(value));  else    error("Not Implemented other case in getikkey");}E 7I 7D 15#define getikkey(value) (*(LispPTR *)Addr68k_from_LADDR(value))E 15I 15/* JRB - These values are xpointers; their high bytes are not set and	shouldn't be looked at */#define getikkey(value) ((*(LispPTR *)Addr68k_from_LADDR(value)) & 0xffffff)E 15E 7  D 7LispPTR getimplicitkeyhash(item, ik_hash_table)E 7I 7LispPTR remimplicitkeyhash(item, ik_hash_table)E 7LispPTR  item, ik_hash_table;{Ikhashtbl *ik_htable; LispPTR   reprobe, bits, limits, index,            base, value, key_accessor;    ik_htable = (Ikhashtbl *)Addr68k_from_LADDR(ik_hash_table);    bits   =  Hashingbits(item);    limits = ik_htable->last_index;    index  = (bits & limits);    base   = ik_htable->base;    value  = Getikvalue(base, index);D 7    key_accessor = ik_htable->key_accessor;E 7    if (value != *Deleted_Implicit_Hash_Slot_word)      { if (value != NIL)	  {if (item ==D 7	       getikkey(value, key_accessor))	     return(value);E 7I 7	       getikkey(value))	     {goto found;};E 7	 }	else	  return(NIL);      };    reprobe = Reprobefn(bits, limits); lp:    index = Fn16bits(index, reprobe) & limits;    value = Getikvalue(base, index);    if (value != *Deleted_Implicit_Hash_Slot_word)      { if (value != NIL)	  {if (item ==D 7	       getikkey(value, key_accessor))	     return(value);E 7I 7	       getikkey(value))	     {goto found;};E 7	 }	else	  return(NIL);      };    goto lp;D 7}E 5D 4LispPTR reclaimcodeblock(codebase)LispPTR			codebase;{struct fnhead		*fnbase;   fnbase = (struct fnhead *)Addr68k_from_LADDR(codebase);   gclookup((0x8000 | DELREF), (0x0ffffff & fnbase->framename));   if (fnbase->startpc != 0)	map_code_pointers(codebase,DELREF);   return(NIL);E 4I 4D 5LispPTR reclaimcodeblock(codebase)	LispPTR         codebase;{	struct fnhead  *fnbase;	LispPTR reclaimed;	fnbase = (struct fnhead *) Addr68k_from_LADDR(codebase);	reclaimed = (0x0ffffff & fnbase->framename);	gclookup((0x8000 | DELREF), reclaimed);	if (fnbase->startpc != 0)		map_code_pointers(codebase, DELREF);	return (NIL);E 5I 5LispPTR putimplicitkeyhash(item, ik_hash_table, new_value)LispPTR item, ik_hash_table, new_value;{Ikhashtbl *ik_htable; LispPTR   reprobe, bits, limits, index, first_index,           base, value, key_accessor, deleted_slot_index;    ik_htable = (Ikhashtbl *)Addr68k_from_LADDR(ik_hash_table);    first_index = deleted_slot_index = NIL;    bits   =  Hashingbits(item);    limits = ik_htable->last_index;    index  = (bits & limits);    base   = ik_htable->base;    value  = Getikvalue(base, index);    key_accessor = ik_htable->key_accessor;    if (value == *Deleted_Implicit_Hash_Slot_word)      deleted_slot_index = index;    else if (value != NIL)      {if (item == getikkey(value, key_accessor))	 goto found;     }    else      goto addnewentry;    first_index = index;    reprobe = Reprobefn(bits, limits); lp:    index = Fn16bits(index, reprobe) & limits;   if (index == first_index)      {if (deleted_slot_index == NIL)	 error("No Vacant slot in Implicit key hash table:");       else	 index = deleted_slot_index;       goto addnewentry;     };    value = Getikvalue(base, index);    if (value == *Deleted_Implicit_Hash_Slot_word)      deleted_slot_index = index;    else if (value != NIL)      {if (item == getikkey(value, key_accessor))	 goto found;     }    else      { if (deleted_slot_index != NIL)	  index = deleted_slot_index;	goto addnewentry;      };    goto lp;E 7 found:I 13    htfind(*Deleted_Implicit_Hash_Slot_word, ADDREF);E 13D 7    Getikvalue(base, index) = ((new_value != NIL)? new_value:			    *Deleted_Implicit_Hash_Slot_word);    if (new_value == NIL)E 7I 7    htfind(Getikvalue(base, index), DELREF);    Getikvalue(base, index) = *Deleted_Implicit_Hash_Slot_word;E 7      (ik_htable->num_keys)--;D 7    return(new_value); addnewentry:    if (new_value == NIL)      return(new_value);    else      error("The Other value (excepting NIL) is not implemented.(ik_hash)\n");E 7I 7    return (T);E 7}D 7 E 7D 7E 7LispPTR reclaimcodeblock(codebase)LispPTR			codebase;{struct fnhead		*fnbase;D 7   fnbase = (struct fnhead *)Addr68k_from_LADDR(codebase);E 7D 6#ifdef CLOSURE_CACHEE 6   if ((*Closure_Cache_Enabled_word != NIL) && D 7       (getimplicitkeyhash(codebase, *Closure_Cache_word) != NIL))     { putimplicitkeyhash(codebase, *Closure_Cache_word, NIL);       return(T);E 7I 7       (remimplicitkeyhash(codebase, *Closure_Cache_word) != NIL))     { return(T);E 7     };I 7   fnbase = (struct fnhead *)Addr68k_from_LADDR(codebase);E 7D 6#endifE 6   htfind((0x0ffffff & fnbase->framename), DELREF);   if (fnbase->startpc != 0)	map_code_pointers(codebase,DELREF);   return(NIL);E 5E 4}D 4		E 4E 1