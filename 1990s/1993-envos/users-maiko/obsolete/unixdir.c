/* This is G-file @(#) unixdir.c Version 1.2 (3/13/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) unixdir.c	1.2 3/13/88";/*** Copyright (C) 1986 by Xerox Corporation. All rights reserved. ***//**********************************************************************	Caution !!**	The functions in this file are copied from ST68K unixinterface.c.*	The following functions are included.	*		getWorkingDirectory*		readDir*********************************************************************/#include <sys/param.h>#include <sys/file.h>#include <sys/ioctl.h>#include <sys/dir.h>#include <stdio.h>#include <errno.h>#define	FAILED	-1char *getwd();extern int errno;readDir(dirName, buffer)char *dirName;char *buffer;{	DIR *dp;	struct direct *directp;#ifdef	TRACE	printf("TRACE:readDir(%s, %x)\n", dirName, buffer);#endif	if ((dp = opendir(dirName)) == (DIR *)NULL)		return(-1);	while ((directp = readdir(dp)) != (struct direct *)NULL) {			strncpy(buffer, directp->d_name, directp->d_namlen);			buffer += directp->d_namlen;			*(buffer++) = '\\';	}	closedir(dp);	*(buffer++) = '\0';	if( errno == EINVAL ) errno = 0;	/*ignore spurious error for empty dir*/	return(0);}/* *	Get the name of the current working directory and return it *	in the buffer of the given length.  A zero is returned if an *	error occurs while getting the name.  If the name will not *	fit in the buffer then only the amount that will fit is copied. *	In any case the actual length of the name is returned and the *	caller should verify that the buffer length was sufficient. */getWorkingDirectory(buffer, length)char *buffer;int length;{	char *wdValue;	char bigbuf[MAXPATHLEN];	int trueLength;#ifdef	TRACE	printf("TRACE:getWorkingDirectory(%d, %d)\n", buffer, length);#endif	wdValue = getwd(bigbuf);	if (wdValue == 0) {		return(0);	}	trueLength = strlen(wdValue);	if (trueLength >= length)		strncpy(buffer, wdValue, length);	else		strcpy(buffer,wdValue);	return(trueLength);}dirSize(dirName)char *dirName;{	DIR *dp;	long totalSize = 0;	struct direct *directp;	int base;#ifdef	TRACE	printf("TRACE:dirSize(%s)\n", dirName);#endif	if ((dp = opendir(dirName)) == (DIR *)NULL)		return(-1);	while ((directp = readdir(dp)) != (struct direct *)NULL)		totalSize += directp->d_namlen + 1;	closedir(dp);	if( errno == EINVAL ) errno = 0;	/*ignore spurious error for empty dir*/			/*  For a newly created (empty) directory, the above			 while loop computes the correct size, however, the			 last readdir apparently fails to find the end of the			 directory, and sets errno to EINVAL.  This causes the call			 from PS to fail.  If a directory is empty, but has			 at some time held some entries, readdir correctly			 finds the end of the directory.  Apparently mkdir			 does not set things up properly for readdir. */	return(totalSize + 1);}