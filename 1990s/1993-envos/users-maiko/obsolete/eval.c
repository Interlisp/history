/* This is G-file @(#) eval.c Version 2.3 (4/22/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) eval.c	2.3 4/22/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther :  Takeshi Shimizu	** ADOPTED NEW VERSION * *//******************************************************************//*		File Name :	eval.c		Including :	OP_eval		Created :	May 9, 1987 take		Changed :	May 11, 1987 take				MAY 18, 1987 TAKE				May 22, 1987 take				May 25, 1987 take				Aug 12, 1987 take				Aug 28, 1987 take				Sep 18, 1987 take				NOV 13, 1987 TAKE(simpleSTKCHK)				Nov 17, 1987 Take(macro Call_EVALFORM)				Nov 25, 1987 Take(EVALFORM_STKMIN)					Takeshi Shimizu*//******************************************************************/#include "lispemul.h"#include "lispmap.h"#include "initatoms.h"#include "lisptypes.h"#include "address68k.h"#include "address.h"#include "stack.h"#include "emulglobal.h"#include "lispglobal.h"#include "cell.h"struct frame_evalform {		DLword bf_flags ;		DLword ivar;		struct frameex1 fx;		LispPTR pvar[6];	} Frame_evalform ;/**struct frame_evalform *ScratchPTR;**/struct fnhead *EVALFORM_obj;#define EVALFORM_STKMIN 66  /* 64 + STK_SAFE for Lyric */#ifdef TRADSTACKOVER#define Call_EVALFORM { register struct frame_evalform *ScratchPTR;\ CURRENTFX->nextblock = LADDR_from_68k(CurrentStackPTR) + 2 /* +1 */; \ IVar =(DLword *) Addr68k_from_LADDR((CURRENTFX->nextblock|STK_OFFSET)) ; \ PushCStack ; \ PushStack(NIL_PTR); \ /** ScratchPTR = (struct frame_evalform *)(CurrentStackPTR +1); **/\  ScratchPTR = (struct frame_evalform *)(CurrentStackPTR +2); \ *ScratchPTR =  Frame_evalform ; /* copy cached contents */ \ CURRENTFX->pc = ((unsigned int)PC - (unsigned int)FuncObj)+1 ; \ if ( (unsigned int)(CurrentStackPTR + EVALFORM_STKMIN) >=  (unsigned int)StkLimO  ) \ { \   /** printf(" STKOVER in \EVALFORM call \n"); **/ \   TopOfStack = ATOM_EVALFORM ;\   DOSTACKOVERFLOW(2,0);\ } \ FuncObj=EVALFORM_obj ; \ ScratchPTR->fx.alink = LOLOC(LADDR_from_68k(PVar)); \ ScratchPTR->ivar = CURRENTFX->nextblock; \ PVar = (DLword *)(&(ScratchPTR->pvar[0])) ; \/** CurrentStackPTR=(DLword *)( PVar + 13 ); **/\ CurrentStackPTR=(DLword *)( PVar + 12 ); \ /* Set PC points \EVALFORM Function's first OPCODE */ \ PC = (ByteCode *)FuncObj + FuncObj->startpc ; }/*** This macro updated on 7-OCT-87 by take */#else#define Call_EVALFORM { register struct frame_evalform *ScratchPTR;\ CURRENTFX->nextblock = LADDR_from_68k(CurrentStackPTR) + 2 /* +1 */; \ IVar =(DLword *) Addr68k_from_LADDR((CURRENTFX->nextblock|STK_OFFSET)) ; \ PushCStack ; \ PushStack(NIL_PTR); \ if ( (unsigned int)(CurrentStackPTR + EVALFORM_STKMIN) >=  (unsigned int)StkLimO  ) \ { \   DOSTACKOVERFLOW(2,0);\ } \  ScratchPTR = (struct frame_evalform *)(CurrentStackPTR +2); \ *ScratchPTR =  Frame_evalform ; /* copy cached contents */ \ CURRENTFX->pc = ((unsigned int)PC - (unsigned int)FuncObj)+1 ; \ FuncObj=EVALFORM_obj ; \ ScratchPTR->fx.alink = LOLOC(LADDR_from_68k(PVar)); \ ScratchPTR->ivar = CURRENTFX->nextblock; \ PVar = (DLword *)(&(ScratchPTR->pvar[0])) ; \ CurrentStackPTR=(DLword *)( PVar + 12 ); \ /* Set PC points \EVALFORM Function's first OPCODE */ \ PC = (ByteCode *)FuncObj + FuncObj->startpc ; }#endif/******************************************************************//*	Func Name  :	OP_eval	Created :		May 7, 1987 take	Changed :	May 25 1987 take			Aug 12 1987 take(Don't depend on PROT)*//******************************************************************/OP_eval(){ LispPTR scratch; register LispPTR work ; register LispPTR lookuped; /* keep looked up value */#ifdef DEBUG	struct frameex1 *tmpFX;	tmpFX = CURRENTFX ;#endif#ifdef TRACE	printPC();	printf("TRACE: OP_eval() \n");	print(TopOfStack);#endif  switch(TopOfStack & 0x0ff0000) {   case S_POSITIVE :   case S_NEGATIVE :	PC++;			return; 			break;   case ATOMS_OFFSET :	if((TopOfStack==NIL_PTR)||(TopOfStack==ATOM_T))			{				PC++;				return ;			}			newframe(CURRENTFX,&scratch,LOLOC(TopOfStack)) ;			work = ((scratch & 0xffff0000)>> 16) | ((scratch & 0x00ff) <<16) ;			lookuped =			  *((LispPTR *)(Addr68k_from_LADDR(work)));			if(lookuped==NOBIND_PTR)			 {			   ufn(054);			   return;			 }			TopOfStack = lookuped;			PC++;			return;			break;   default :		switch(GetTypeNumber(TopOfStack)){			  case TYPE_FIXP :			  case TYPE_FLOATP : 			  case TYPE_STRINGP :			  case TYPE_ONED_ARRAY :		  	  case TYPE_GENERAL_ARRAY :					PC++;					return;					break ;			  case TYPE_LISTP : 	/* Call_EVALFORM ;*/						/*funcall(ATOM_EVALFORM,1,1);*/						Call_EVALFORM;#ifdef LISPTRACE 			printf("\\EVALFORM ");			printf("IVAR0:"); print(*((LispPTR *)IVar));			printf("IVAR1:"); print(*((LispPTR *)(IVar+2)));			printf("\n");#endif					     return;					     break;			  default :	 ufn(054);				         return;				}  } /* end switch */}/* OP_eval end *//* for CACHED FX for  \EVALFORM *//* CAUTION caution!! This prog must be called at initialize so that we can  use CACEHED FX for EVALFORM */init_evalform_frame() { DefCell *defcell68k;  extern struct fnhead *EVALFORM_obj ; defcell68k = (DefCell *)GetDEFCELL68k(ATOM_EVALFORM); if (defcell68k->defpointer ==0) 	error("init_evalform_frame: \\EVALFORM codes not yet loaded !!"); EVALFORM_obj = (struct fnhead *)Addr68k_from_LADDR(defcell68k->defpointer); EVALFORM_obj->framename = ATOM_EVALFORM ; Frame_evalform.bf_flags = 0x8000 ; /* BF_MARK */ Frame_evalform.fx.flags=6 ; /* FX */  Frame_evalform.fx.lofnheader = (defcell68k->defpointer) & 0xffff ; Frame_evalform.fx.hi2fnheader = ((defcell68k->defpointer) & 0xff0000) >>16; Frame_evalform. pvar[0] = 0xffff0000 ; Frame_evalform. pvar[1] = 0xffff0000 ; Frame_evalform. pvar[2] = 0xffff0000 ; Frame_evalform. pvar[3] = 0xffff0000 ; Frame_evalform. pvar[4] = 0xffff0000 ; Frame_evalform. pvar[5] = 0xffff0000 ;}/*init_evalform_frame*/