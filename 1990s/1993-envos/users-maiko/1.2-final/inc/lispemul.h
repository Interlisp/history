/* @(#) lispemul.h Version 2.19 (9/18/90). copyright Venue & Fuji Xerox  *//* *	Author	:	Takeshi Shimizu *			Hiroshi Hayata	 *//**********************************************************************//* 		File Name :	lispemul.h		Definitions for LispEmulator 			Date :		December 07, 1987 			Edited by :	Takeshi Shimizu				04-Jan-88 Take(Get_DLword)			05-Jan-88 Take(INTSTAT)*//**********************************************************************//************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/#ifdef NOASM#undef SUN3_OS3_IL#undef SUN3_OS4_IL#undef SUN4_OS4_IL#undef OPDISP#undef NATIVETRAN#undef UNSAFE#undef PROFILE#define NOASMFNCALL	1#endif#ifdef SUN3_OS3_IL#define SUN3_OS3_OR_OS4_IL	1#endif#ifdef SUN3_OS4_IL#define SUN3_OS3_OR_OS4_IL	1#endif	/****************************************************************/	/*								*/	/*  Architecture-specific flags:  Set flags			*/	/*  based on thing we know about the architecture		*/	/*  or idiosyncracies of the machine we're compiling for.	*/	/*								*/	/*  Defaults:	Unaligned fetches OK	UNALIGNED_FETCH_OK	*/	/*		type char is signed	SIGNED_CHARS		*/	/*								*/	/****************************************************************/	/* Set up defaults */#define UNALIGNED_FETCH_OK#define SIGNED_CHARS#ifdef suntypedef char s_char;#endif sun	/* SPARCs and MIPSs can't do unaligned word-loads */#ifdef sparc#undef UNALIGNED_FETCH_OK#define SIGNED_CHARS#endif SPARC#ifdef DEC3100#undef UNALIGNED_FETCH_OK#define SIGNED_CHARS#endif DEC3100#ifdef PS2#endif#ifdef RS6000#undef SIGNED_CHARStypedef signed char s_char;#endif RS6000#if (defined(sparc)) || (defined(DEC3100))#undef UNALIGNED_FETCH_OK#else#define UNALIGNED_FETCH_OK 1#endif sparc | DEC3100	/****************************************************************/	/* 	    End of architecture-specific flag settings		*/	/****************************************************************/#ifndef BYTESWAP	/*** Normal byte-order type decls */typedef struct {unsigned code : 8;} BYTECODE;typedef char ByteCode;typedef unsigned short  DLword;typedef char  DLbyte;typedef unsigned int  LispPTR;/* 32 bit Cell Chang. 14 Jan 87 take */typedef DLword mds_page;  /* Top word of the MDS */typedef (*CFuncPTR)();typedef struct  consstr  {    unsigned cdr_code  : 8;    unsigned car_field : 24;  } ConsCell;typedef struct ufn_entry  {    DLword atom_name;   /* UFN's atomindex */    unsigned byte_num : 8; /* num of byte code */    unsigned arg_num  : 8; /* num of argments */  } UFN;typedef struct closure_type  {    unsigned nil1    :  8;    unsigned def_ptr : 24; /* LispPTR to definition cell */    unsigned nil2    :  8;    unsigned env_ptr : 24; /* LispPTR to environment */  } Closure;typedef struct interrupt_state  { /* Interrupt-request mask to communicate with INTERRUPTED */    unsigned LogFileIO		:1; /* console msg arrived to print */    unsigned ETHERInterrupt	:1; /* 10MB activity happened */    unsigned IOInterrupt	:1; /* I/O happened (not used yet) */    unsigned gcdisabled		:1;    unsigned vmemfull		:1;    unsigned stackoverflow	:1;    unsigned storagefull	:1;    unsigned waitinginterrupt	:1;    unsigned nil	:8;	    /* mask of ints being processes */    DLword   intcharcode;  } INTSTAT;typedef struct interrupt_state_2  { /* alternate view of the interrupt state */    unsigned pendingmask	:8;    unsigned handledmask	:8;    DLword   nil;  } INTSTAT2;struct state  {    DLword		*ivar;		/* + 0 */    DLword		*pvar;		/* + 4 */    DLword		*csp;		/* + 8 */    LispPTR	 	tosvalue;	/* + 12 */    ByteCode 		*currentpc;	/* + 16 */    struct fnhead 	*currentfunc;	/* + 20*/    DLword 		*endofstack;	/* + 24*/    int 		irqcheck;	/* + 28 */    int 		irqend;		/* + 32 */    LispPTR		scratch_cstk;	/* + 34 */    int			errorexit;	/* + 38 */  };/***** Get_DLword(ptr) ptr is char* ***/#ifndef UNALIGNED_FETCH_OK#define Get_DLword(ptr)		((Get_BYTE(ptr) <<8) | Get_BYTE(ptr+1))#else#define Get_DLword(ptr)		*(((DLword *)WORDPTR(ptr)))#endif#define Get_Pointer(ptr)   ((Get_BYTE(ptr) << 16) | 	\			    (Get_BYTE(ptr+1) << 8) | 	\			    Get_BYTE(ptr+2))#ifdef BIGATOMS#define Get_AtomNo(ptr)	Get_Pointer(ptr)#else#define Get_AtomNo(ptr) Get_DLword(ptr)#endif BIGATOMS/* For bit test */typedef	struct wbits  {    unsigned MSB :1;    unsigned B1  :1;    unsigned B2	 :1;    unsigned B3	 :1;    unsigned B4	 :1;    unsigned B5  :1;    unsigned B6	 :1;    unsigned B7	 :1;    unsigned B8	 :1;    unsigned B9	 :1;    unsigned B10 :1;    unsigned B11 :1;    unsigned B12 :1;    unsigned B13 :1;    unsigned B14 :1;    unsigned LSB :1;  }WBITS;typedef	struct lbits  {    unsigned MSB	:1;    unsigned MIDDLE	:30;    unsigned LSB	:1;  }LBITS;#else	/*** Byte-swapped structure declarations, for 80386 ***/typedef struct {unsigned char code;} BYTECODE;typedef char ByteCode;typedef unsigned short  DLword;typedef char  DLbyte;typedef unsigned int  LispPTR;/* 32 bit Cell Chang. 14 Jan 87 take */typedef DLword mds_page;  /* Top word of the MDS */typedef (*CFuncPTR)();typedef struct consstr  {    unsigned car_field : 24;    unsigned cdr_code  :  8;  } ConsCell;typedef struct ufn_entry  {    unsigned arg_num  : 8; /* num of argments */    unsigned byte_num : 8; /* num of byte code */    DLword atom_name;   /* UFN's atomindex */  } UFN;typedef struct closure_type  {    unsigned def_ptr : 24; /* LispPTR to definition cell */    unsigned nil1    :  8;    unsigned env_ptr : 24; /* LispPTR to environment */    unsigned nil2    :  8;  } Closure;typedef struct interrupt_state  { /* Interrupt-request mask to communicate with INTERRUPTED */    DLword   intcharcode;    unsigned nil		:8;    unsigned waitinginterrupt	:1;    unsigned storagefull	:1;    unsigned stackoverflow	:1;    unsigned vmemfull		:1;    unsigned gcdisabled	:1;    unsigned IOInterrupt	:1; /* I/O happened (not used yet) */    unsigned ETHERInterrupt	:1; /* 10MB activity happened */    unsigned LogFileIO		:1; /* console msg arrived to print */  } INTSTAT;typedef struct interrupt_state_2  { /* alternate view of the interrupt state */    DLword   nil;    unsigned handledmask	:8;    unsigned pendingmask	:8;  } INTSTAT2;struct state  {    DLword		*ivar;		/* + 0 */    DLword		*pvar;		/* + 4 */    DLword		*csp;		/* + 8 */    LispPTR	 	tosvalue;	/* + 12 */    ByteCode 		*currentpc;	/* + 16 */    struct fnhead 	*currentfunc;	/* + 20*/    DLword 		*endofstack;	/* + 24*/    int 		irqcheck;	/* + 28 */    int 		irqend;		/* + 32 */    LispPTR		scratch_cstk;	/* + 34 */    int			errorexit;	/* + 38 */  };/* Fetching 2 bytes to make a word -- always do it the hard way *//* if we're byte-swapped:  You can't rely on byte ordering!!    */#define Get_DLword(ptr)		((Get_BYTE(ptr) <<8) | Get_BYTE(ptr+1))#define Get_Pointer(ptr)   ((Get_BYTE(ptr) << 16) | 	\			    (Get_BYTE(ptr+1) << 8) | 	\			    Get_BYTE(ptr+2))#ifdef BIGATOMS#define Get_AtomNo(ptr)	Get_Pointer(ptr)#else#define Get_AtomNo(ptr) Get_DLword(ptr)#endif BIGATOMS/* For bit test */typedef	struct wbits  {	unsigned LSB	:1;	unsigned B14	:1;	unsigned B13	:1;	unsigned B12	:1;	unsigned B11	:1;	unsigned B10	:1;	unsigned B9	:1;	unsigned B8	:1;	unsigned B7	:1;	unsigned B6	:1;	unsigned B5	:1;	unsigned B4	:1;	unsigned B3	:1;	unsigned B2	:1;	unsigned B1	:1;	unsigned MSB	:1;  } WBITS;typedef	struct lbits  {    unsigned LSB	:1;    unsigned MIDDLE	:30;    unsigned MSB	:1;  } LBITS;#endif BYTESWAP	/* Because a WBITS is only 1 word long, need byte-swapped */	/* access to it.  Use WBITSPTR(x) instead of ((WBITS *) x) */#define WBITSPTR(ptr) ((WBITS *) WORDPTR(ptr))extern struct state MachineState;#define MState (&MachineState)#define CURRENTFX 	((struct  frameex1 *)(((DLword *) PVar) - FRAMESIZE))#define	IVar		MState->ivar#define PVar		MState->pvar#define CurrentStackPTR MState->csp#define TopOfStack  	MState->tosvalue#define PC 		MState->currentpc#define FuncObj 	MState->currentfunc#define EndSTKP 	MState->endofstack#define Irq_Stk_Check   MState->irqcheck#define Irq_Stk_End	MState->irqend#define Scratch_CSTK	MState->scratch_cstk#define Error_Exit	MState->errorexit/* Typedef for IFPAGE */#include "ifpage.h"/* Typedef for IOPAGE */#include "iopage.h"/* Typedef for MISCSTAT */#include "miscstats.h"/**************************************************** MakeAddr:	base:	DLword*		offset:	word offset from base	return:	DLword*	****************************************************/#define MakeAddr(base, offset)		((DLword *)(base + (int)offset))/****************************************************GetHiWord:*****************************************************/#define GetHiWord(x)		((DLword)((x)>>16))/****************************************************GetLoWord:*****************************************************/#define GetLoWord(x)		((DLword)(x))/****************************************************GetLongWord:	address:	DLword*		retrun:		int*****************************************************/#define GetLongWord(address)		(*((int *) (address)))/****************************************************PopCStack:#define PopCStack	{TopOfStack = *((int *)(--CurrentStackPTR)); --CurrentStackPTR;}*****************************************************/#define PopCStack	{TopOfStack = *((LispPTR *)(CurrentStackPTR)); CurrentStackPTR -= 2;}/****************************************************PopStackTo:  CSTK -> Place#define PopStackTo(Place)	{Place= *((LispPTR *)(--CurrentStackPTR)); CurrentStackPTR--; }*****************************************************/#define PopStackTo(Place)	{Place= *((LispPTR *)(CurrentStackPTR)); CurrentStackPTR -= 2; }/****************************************************PushCStack:#define PushCStack	{*((int *)(++CurrentStackPTR)) = TopOfStack; ++CurrentStackPTR;}*****************************************************/#define PushCStack	{CurrentStackPTR += 2;*((LispPTR *)(CurrentStackPTR)) = TopOfStack; }/****************************************************PushStack:#define PushStack(x)	{*((LispPTR *)(++CurrentStackPTR))=x;CurrentStackPTR++;}*****************************************************/#define PushStack(x)	{CurrentStackPTR += 2;*((LispPTR *)(CurrentStackPTR))=x;}/****************************************************SmashStack:#define SmashStack(x)	(*((LispPTR *)(CurrentStackPTR-1))=x)*****************************************************/#define SmashStack(x)	(*((LispPTR *)(CurrentStackPTR))=x)/*********************************************************Get_BYTE(byteptr)	byteptr: pointer to  8 bit data**********************************************************//***** OLD definition ************* 13 Nov 1987 takeshi ***#define Get_BYTE(byteptr)	(((unsigned)(*(byteptr))) & 0xff)**********************************************/#define Get_BYTE(byteptr)	(((BYTECODE *)BYTEPTR(byteptr))->code)/**********************************************************DOSTACKOVERFLOW(argnum,bytenum) if it needs hardreturn-cleanup	then upnt to contextsw and immediately return**********************************************************/#define DOSTACKOVERFLOW(argnum,bytenum) { \			if(do_stackoverflow(T))  \			{	PushStack(S_POSITIVE | argnum); \				contextsw(SubovFXP,bytenum,1); \				return;\			} \		}/************************************************************************//*									*//*		E R R O R   &   T I M E R   P U N T   C A S E S		*//*									*//*	Set up the top-of-stack so we can continue gracefully after	*//*	handling the timer interrupt (e.g., FMEMB, which walks down	*//*	the list being searched, pushes its current state on TOS	*//*	so that it picks up where it left off after the interrupt.	*//*									*//*	Call Interface where neg number indicates an error return	*//*									*//************************************************************************/#define ERROR_EXIT(tos)		{TopOfStack=tos; Error_Exit = 1; return(-1);}#define TIMER_EXIT(tos)		{TopOfStack=tos; Error_Exit = 1; return(-2);}#define WARN(message,operation)	{warn(message);operation;return;}#define NO_WOP	{}#define NIL	0	/* added 29-jan */#define T	1#define ATOM_T	0114	/* T's AtomIndex Number 114Q */#define NIL_PTR		0   /* from cell.h 24-mar-87 take */#define NOBIND_PTR	1		#define STKLIM		0x1FFFF#define FRAMESIZE	10		/* size of frameex1: 10 words */#define FNHEADSIZE	8		/* size of fnhead: 8 words */#define BFSIZE	2		/* size of basci frame pointer: 2 words */#define BITSPER_DLWORD		16#define BITSPER_CELL		32#define BYTESPER_DLWORD		2	#define BYTESPER_CELL		4#define BYTESPER_QUAD		8#define BYTESPER_PAGE		512#define CELLSPER_QUAD		2#define CELLSPER_PAGE		128#define CELLSPER_SEGMENT	32768#define DLWORDSPER_CELL		2#define DLWORDSPER_QUAD		4#define DLWORDSPER_PAGE		256#define DLWORDSPER_SEGMENT	65536#define PAGESPER_SEGMENT	256#define PAGESPER_MDSUNIT	2#define MDSINCREMENT		512#define GUARDSTORAGEFULL	128#define GUARD1STORAGEFULL	64#define SFS_NOTSWITCHABLE	1#define SFS_SWITCHABLE		2#define SFS_ARRAYSWITCHED	3#define SFS_FULLYSWITCHED	4#define AtomHTSIZE		256 * DLWORDSPER_PAGE#define MAXPNCHARS		255    /* Maximam length of PnChars */#define GET_NATIVE_ADDR(fnobject)					\		*((int *) ((int)fnobject + fnobject->startpc - 4))/************************************************************************//*	Define sizes of FN and FNX opcodes; depends on atom size	*//************************************************************************/#ifdef BIGATOMS#define FN_OPCODE_SIZE 4#define FNX_OPCODE_SIZE 5#else#define FN_OPCODE_SIZE 3#define FNX_OPCODE_SIZE 4#endif BIGATOMS