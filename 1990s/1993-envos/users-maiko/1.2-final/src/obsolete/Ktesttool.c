/* @(#) Ktesttool.c Version 1.8 (3/23/89). copyright envos & Fuji Xerox  */static char *id = "@(#) Ktesttool.c      1.8 3/23/89";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************//* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *//***************************************************************//*	file name :	 Ktesttools.c	For Debugging Aids	Including :		dump_check_atoms()		print_atomname(index)		dump_dtd()		check_type_68k(type,ptr)		type_num(LISPPTR)		dump_conspage(base , linking )		trace_listpDTD()		a68k( lispptr)		laddr(addr68k)		dump_fnobj(index)		doko()		dumpl(laddr)		ptintPC()		all_stack_dump(start,end)		date :   14 May 1987   takeshi			 15 May 1987 take			 1  June 1987 take			 21  June 1987 NMitani			  9  Sep. 1987 take*/#include <stdio.h>#include "lispemul.h"#include "lispmap.h"#include "address68k.h"#include "lisptypes.h"#include "lispglobal.h"#include "emulglobal.h"#include "cell.h"#include "stack.h"#include "ifpage.h"#include "debug.h"#include "dbprint.h"#define URMAXFXNUM		100#define URSCAN_ALINK		0#define URSCAN_CLINK		1extern int URaid_scanlink;extern int URaid_currentFX;extern FX *URaid_FXarray[];extern int URaid_ArrMAXIndex;/************************************************************************//*									*//*			P R I N T _ A T O M N A M E			*//*									*//*	Given the Atom # for an atom, print the atom's name.		*//*									*//************************************************************************/print_atomname(index) DLword index; /* atomindex */{ char *pname; DLword length; PNCell *pnptr; pnptr =(PNCell *)GetPnameCell( index); print_package_name(pnptr->pkg_index); pname=(char *) Addr68k_from_LADDR(pnptr->pnamebase); length = (DLword) GETBYTE(pname++); while(length >0){			 putchar(GETBYTE(pname++));			 length--;		}} /* end print_atomname *//************************************************************************//*									*//*		F I N D _ P A C K A G E _ F R O M _ N A M E		*//*									*//************************************************************************/#define PACKAGES_LIMIT 255/** GET PACKAGE INDEX from PACKAGE FULL NAME */find_package_from_name(packname,len)  char *packname;  int len;  {    int index;    PACKAGE *package;    NEWSTRINGP *namestring;    DLword len2;    char *pname;    for(index =1; index <= PACKAGES_LIMIT; index++)      {	package = (PACKAGE *)Addr68k_from_LADDR(			  aref1(*Package_from_Index_word, index));	namestring = (NEWSTRINGP*)Addr68k_from_LADDR(package->NAME);	pname = (char*)Addr68k_from_LADDR(namestring->base);	if(namestring->offset != 0)	  {	    pname += namestring->offset;	  }	len2 = (DLword)(namestring->totalsize);	if(len == len2)	  {	    if(compare_chars(pname, packname, len)==T)	      {		return(index);	      }	  } } /* for end */ return(-1);}/************************************************************************//*									*//*		    P R I N T _ P A C K A G E _ N A M E			*//*									*//************************************************************************/print_package_name(index)  int index;  {    PACKAGE *package;    NEWSTRINGP *namestring;    DLword len;    char *pname;    if(index == 0)      {	printf("#:");	return;      }    package = (PACKAGE *)Addr68k_from_LADDR(			  aref1(*Package_from_Index_word, index));    namestring = (NEWSTRINGP*)Addr68k_from_LADDR(package->NAME);    pname = (char*)Addr68k_from_LADDR(namestring->base);    if(namestring->offset != 0)      {	pname += namestring->offset;	printf("OFFSET:\n");      }    len = (DLword)(namestring->totalsize);    if(compare_chars(pname , "INTERLISP", len) == T)      {	printf("IL:");	return;      }    else if(compare_chars(pname , "LISP", len) == T)     {	printf("CL:");	return;      }    else if(compare_chars(pname , "XEROX-COMMON-LISP", len) == T)      {	printf("XCL:");	return;      }    else if(compare_chars(pname , "SYSTEM", len) == T)      {	printf("SI:");	return;      }    else if(compare_chars(pname , "KEYWORD", len) == T)     {	printf(":");	return;      }    else if(compare_chars(pname , "COMPILER", len) == T)      {	printf("XCLC:");	return;      }    else      {	while(len >0)	  {	     putchar(GETBYTE(pname++));	     len--;	  }	putchar(':');	return;      }  }  /*print_package_name *//************************************************************************//*									*//*				d u m p _ d t d				*//*									*//*									*//*									*//************************************************************************/dump_dtd()  {    extern DLword *DTDspace;    struct dtd *dtdp;    DLword cnt;    dtdp = (struct dtd *)DTDspace;    dtdp++;    for (cnt = 0; cnt < INIT_TYPENUM; cnt ++)       {	printf("DTD[ %d ] for ",cnt+1);	print_atomname(dtdp->dtd_name);	putchar('\n');	printf("    dtd_name = %d\n",dtdp->dtd_name);	printf("    dtd_size = %d\n",dtdp->dtd_size);	printf("    dtd_free = %d\n",dtdp->dtd_free);	printf("    dtd_obsolate = %d\n",dtdp->dtd_obsolate);	printf("    dtd_finalizable = %d\n",dtdp->dtd_finalizable);	printf("    dtd_lockedp = %d\n",dtdp->dtd_lockedp);	printf("    dtd_hunkp = %d\n",dtdp->dtd_hunkp);	printf("    dtd_gctype = %d\n",dtdp->dtd_gctype);	printf("    dtd_descrs = %d\n",dtdp->dtd_descrs);	printf("    dtd_typespecs = %d\n",dtdp->dtd_typespecs);	printf("    dtd_ptrs = %d\n",dtdp->dtd_ptrs);	printf("    dtd_oldcnt = %d\n",dtdp->dtd_oldcnt);	printf("    dtd_cnt0 = %d\n",dtdp->dtd_cnt0);	printf("    dtd_nextpage = %d\n",dtdp->dtd_nextpage);	printf("    dtd_typeentry = 0x%x\n",dtdp->dtd_typeentry);	printf("    dtd_supertype = %d\n",dtdp->dtd_supertype);	dtdp++;      }  } /* end dump dtd *//************************************************************************//*									*//*			c h e c k _ t y p e _ 6 8 k			*//*									*//*	Check that the lisp pointer ptr is of type type, then		*//*	print a message showing the type number.			*//*									*//************************************************************************/check_type_68k(type,ptr) LispPTR *ptr;{ if (type != (GetTypeNumber(LADDR_from_68k(ptr)) ) )  {  printf("Mismatching occur !!! LispAddr 0x%x  type %d\n",LADDR_from_68k(ptr)	  ,type);  exit(-1);  }  printf("LispPTR 0x%x is the datatype %d\n", LADDR_from_68k(ptr)      ,GetTypeNumber(LADDR_from_68k(ptr)) );}/************************************************************************//*									*//*				t y p e _ n u m				*//*									*//*	Given a lisp pointer, return its type number.			*//*									*//************************************************************************/type_num(lispptr) LispPTR lispptr;{  int type;  type = GetTypeNumber(lispptr);  printf("LispPTR 0x%x is datatype %dth\n",lispptr,type);  return(type);}/************************************************************************//*									*//*			d u m p _ c o n s p a g e			*//*									*//*	Print information about a CONS page, and the cells in it.	*//*									*//************************************************************************/dump_conspage(base , linking )   struct conspage *base; /* target conspage address */   int linking;  /* look for chaiing conspage ? T/NIL */  {   ConsCell *cell;   int  i;lp:    printf("conspage at 0x%x(lisp) has %d free cells , next available cell offset is %d ,and next page is 0x%x(lisp)\n",	   LADDR_from_68k(base), (0xff & base->count), 	   (0xff & base->next_cell), base->next_page );    for( i = 0 , cell = (ConsCell *)base+1; i <127; i++,cell++)      {	printf(" LADDR : %d = Cell[ %d ]## cdr_code= %d ,car = %d\n",	       LADDR_from_68k(cell),i+1,cell->cdr_code,cell->car_field);      }    if ((linking==T) && (base->next_page != NIL_PTR))      {	base =(struct conspage *) Addr68k_from_LPAGE(base->next_page);	goto lp;      }  } /* end dump_conspage *//*********************************//* trace the link in ListpDTD->dtd_nextpage */trace_listpDTD(){extern struct dtd *ListpDTD; printf("Dump conspages from ListpDTD chain\n"); dump_conspage(Addr68k_from_LPAGE(ListpDTD->dtd_nextpage) , T);}/************************************************************************//*									*//*				a 6 8 k					*//*									*//*	Given a lisp pointer, print the corresponding native address.	*//*									*//************************************************************************/a68k(lispptr)  LispPTR lispptr;  {    DLword *val;    val = Addr68k_from_LADDR(lispptr);    printf("68k: 0x%x (%d)\n", val, val);  }/************************************************************************//*									*//*			   l a d d r					*//*									*//*	Given a native address, print the corresponding lisp ptr.	*//*									*//************************************************************************/laddr(addr68k)  DLword *addr68k;  {    int val;    val = LADDR_from_68k(addr68k);    printf("LADDR : 0x%x (%d)\n", val, val);  }/*************************************************************//* dump_fnobj(index) */#define DUMPSIZE 40dump_fnobj(index)  LispPTR index; /* atom index */  {    struct fnhead *fnobj;    DefCell *defcell68k;    LispPTR cell;    DLbyte *scratch;    int i;    defcell68k = (DefCell *)GetDEFCELL68k(index);    fnobj = (struct fnhead *)Addr68k_from_LADDR(defcell68k->defpointer);    /* check if it's the same index ??*/    if (index != (fnobj->framename))      {	printf("DEFCELL says it is ");	print_atomname(index);	printf("\n But Func OBJ says ");	print_atomname(fnobj->framename);	putchar('\n');	return;      }    printf("***DUMP Func Obj << ");    printf("start at 0x%x lisp address(0x%x 68k)\n",		LADDR_from_68k(fnobj),fnobj);    print_atomname(index);    putchar('\n');    printf("stkmin    : %d\n",fnobj->stkmin);    printf("na        : %d\n",fnobj->na);    printf("pv        : %d\n",fnobj->pv);    printf("startpc   : %d\n",fnobj->startpc);    printf("argtype   : %d\n",fnobj->argtype);    printf("framename : %d\n",fnobj->framename);    printf("ntsize    : %d\n",fnobj->ntsize);    printf("nlocals   : %d\n",fnobj->nlocals);    printf("fvaroffset: %d\n",fnobj->fvaroffset);   scratch= (DLbyte *)fnobj;   for (i= 20; i<(fnobj->startpc); i+=2)      {	printf(" 0x%x(0x%x 68k): 0%o\n",		LADDR_from_68k(scratch), scratch,		(int)(0xffff & (GETWORD((DLword *)(scratch+i)))) );      }    scratch= (DLbyte *)fnobj + (fnobj->startpc);    for (i= 0; i< DUMPSIZE; i++, scratch++)      {	printf(" 0x%x(0x%x 68k): 0%o\n", LADDR_from_68k(scratch), 		scratch, (int)(0xff & GETBYTE(scratch)) );      }} /*dump_fnobj end *//*********************************************************************/ struct doko   {    LispPTR func;    int     pc;  };struct doko doko()  {    struct doko tmp;     printf(" At ");     print_atomname(FuncObj->framename);     putchar('\n');     printf("   PC cnt = 0%o\n" ,tmp.pc=((int)(PC)- (int)FuncObj) );     tmp.func= FuncObj->framename;     return(tmp);  }/**** dump specified area (in 32 bit width) ***/dumpl(laddr)  LispPTR laddr;  {    int i;    LispPTR *ptr;    ptr = (LispPTR *)Addr68k_from_LADDR(laddr);   for(i=0; i< 40; i++,ptr++)      printf("LADDR 0x%x : %d\n", LADDR_from_68k(ptr), *ptr);  }/**** dump specified area (in 16 bit width) ***/dumps(laddr)  LispPTR laddr;  {    int i;    DLword *ptr;    ptr = (DLword *)Addr68k_from_LADDR(laddr);   for(i=0; i< 40; i++,ptr++)      printf("LADDR 0x%x : %d\n", LADDR_from_68k(ptr), (GETWORD(ptr)& 0xffff));  }/***********************/printPC()  {    unsigned short pc;    pc =(int)PC - (int)FuncObj;    printf("PC: O%o ",pc);  }/***************************/countchar(string)  char *string;  {    int cnt=0;    while(*string != '\0') { string++; cnt++;}    return(cnt);  }/***************************************************************//*	Func Name :	dump_stackframe	Desc :		For Debugging Aids	Changed		8 JUN 1987 TAKE*//***************************************************************/dump_stackframe( fx_addr68k )  struct frameex1 *fx_addr68k;  {    Bframe *bf;    if((fx_addr68k->alink & 1)==0)      {   /* FAST */	bf = (Bframe *)(((DLword *)fx_addr68k)  - 2 );      }    else      {   /* SLOW */	bf =(Bframe *) Addr68k_from_LADDR((fx_addr68k->blink+ STK_OFFSET));      }    dump_bf(bf);    dump_fx(fx_addr68k);  }dump_bf(bf)  Bframe *bf;  {    DLword *ptr;    printf("\n*** Basic Frame");    if (BFRAMEPTR(bf)->flags != 4)      {	printf("\nInvalid basic frame"); 	return(0);      };    if (BFRAMEPTR(bf)->residual) {goto printflags;}    ptr = Addr68k_from_LADDR( STK_OFFSET + bf->ivar);    if ( (((DLword*)bf - ptr) > 512) || (( (int)ptr & 1) != 0) )      {	printf("\nInvalid basic frame");	return(0);      }    while(ptr < (DLword *)bf)      {	printf("\n %x : %x %x", LADDR_from_68k(ptr),		GETWORD(ptr), GETWORD(ptr+1));	print(*ptr);	ptr+=2;      }printflags:    printf("\n %x : %x %x ",LADDR_from_68k(bf),*bf, *(bf+1));    putchar('[');    if (BFRAMEPTR(bf)->residual)	printf("Residual, ");    if (BFRAMEPTR(bf)->padding)	printf("Padded, ");    printf("usecnt=%d ] ",BFRAMEPTR(bf)->usecnt);    printf("ivar : 0x%x",BFRAMEPTR(bf)->ivar);}dump_fx( fx_addr68k)  struct frameex1 *fx_addr68k;  {    DLword *next68k;    DLword *ptr;    LispPTR atomindex;    ptr = (DLword *)fx_addr68k;    if(fx_addr68k->flags != 6)      {	printf("\nInvalid frame,NOT FX"); 	return(0);      };    atomindex = get_framename(fx_addr68k);    printf("\n*** Frame Extension for ");    print(atomindex);    printf("\n %x : %x %x ",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));    putchar('[');    if(fx_addr68k->fast) printf("F,");    if(fx_addr68k->incall) printf("incall, ");    if(fx_addr68k->validnametable) printf("V, ");    printf("usecnt = %d]; alink",fx_addr68k->usecount);    if(fx_addr68k->alink & 1)    printf("[SLOWP]");    ptr+=2;    printf("\n %x : %x %x fnheadlo, fnheadhi\n", 		LADDR_from_68k(ptr), GETWORD(ptr), GETWORD(ptr+1));    ptr+=2;    printf("\n %x : %x %x next,     pc\n",		LADDR_from_68k(ptr), GETWORD(ptr), GETWORD(ptr+1));    ptr+=2;    printf("\n %x : %x %x LoNmTbl,  HiNmTbl\n",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));    ptr+=2;    printf("\n %x : %x %x #blink,   #clink\n",LADDR_from_68k(ptr),GETWORD(ptr), GETWORD(ptr+1));    /* should pay attention to the name table like RAID does */    next68k = (DLword *)Addr68k_from_LADDR((fx_addr68k->nextblock+STK_OFFSET));    if (fx_addr68k == CURRENTFX) {next68k = CurrentStackPTR + 2;}    if ((next68k < ptr) || (((int)next68k & 1) != 0) )    {printf ("\nNext block invalid"); return(0);}    while(next68k > ptr)      {	ptr+=2;	printf("\n %x : %x %x",		LADDR_from_68k(ptr), GETWORD(ptr), GETWORD(ptr+1));      }    return (0);  } /* end dump_fx */dump_CSTK(before)  int before;  {    DLword *ptr;    ptr= CurrentStackPTR - before;    while(ptr != CurrentStackPTR)      {	printf("\n%x : %x ",LADDR_from_68k(ptr),GETWORD(ptr));	ptr++;      }    printf("\nCurrentSTKP : %x  ",LADDR_from_68k(CurrentStackPTR));    printf("\ncontents :  %x ",*((LispPTR *)(CurrentStackPTR-1)));  }/* dump_CSTK end *//******************************************//* BTV */btv()  {    struct frameex1 *fx_addr68k;    LispPTR atomindex;    struct frameex1 *get_nextFX();    fx_addr68k = CURRENTFX;loop:    dump_stackframe(fx_addr68k);    if( fx_addr68k->alink == 0 )     {printf ("\n BTV end"); return(0);};    fx_addr68k= get_nextFX(fx_addr68k);    goto loop;  } /*end btv*/get_framename(fx_addr68k)  struct frameex1 *fx_addr68k;  {    struct fnhead *fnheader;    LispPTR scratch;    /* Get FNHEAD */    if(fx_addr68k->validnametable==0)      {	scratch  = (unsigned int)(fx_addr68k->hi2fnheader << 16);	scratch |= (unsigned int)(fx_addr68k->lofnheader);      }  else      {	scratch  = (unsigned int)(fx_addr68k->hi2nametable << 16);	scratch |= (unsigned int)(fx_addr68k->lonametable);      }    fnheader = (struct fnhead *)Addr68k_from_LADDR( scratch );    return(fnheader->framename);  }/* get_framename end */FX *get_nextFX(fx)  FX *fx;  {    DLword *pv;    if(URaid_scanlink==URSCAN_ALINK)	return((FX *)Addr68k_from_StkOffset(GETALINK(fx)));    else	return((FX *)Addr68k_from_StkOffset(GETCLINK(fx)));  } /* get_nextFX end */MAKEATOM(string)  char *string;  {    int length;    length = countchar(string);    return(make_atom(string,0,length,0));  }/************************************************************************//*									*//*			M a k e A t o m 6 8 k				*//*									*//*	Given a LITATOM that exists before the package system was	*//*	turned on, return a pointer to that atom's value cell.		*//*									*//************************************************************************/DLword *MakeAtom68k(string)    char   *string;    {    int index;    index = make_atom(string, 0, countchar(string), 0);    index = VALS_OFFSET + (index << 1);    return ( Addr68k_from_LADDR( index ) );    }/****************/GETTOPVAL(string) char *string;{  int index;  LispPTR *cell68k; index=MAKEATOM(string); cell68k= (LispPTR *)GetVALCELL68k(index);  print(*cell68k);}/************************************************************************//*									*//*				S _ T O P V A L				*//*									*//*	Given a string that's an atom name minus the initial \,		*//*	print the atom's top-level value.  This is here because		*//*	DBX won't put \'s in strings you type.				*//*									*//************************************************************************/S_TOPVAL(string)  char *string;  {    int index;    LispPTR *cell68k;    int length;    char dummy[256];    dummy[0]='\\';    for(length=1; *string != '\0'; length++,string++)      { 	dummy[length] = *string;      }    index=make_atom(dummy,0,length,0);    cell68k= (LispPTR *)GetVALCELL68k(index);    print(*cell68k);  }/***************/S_MAKEATOM(string) char *string;{  int index=0; int length; char dummy[256]; dummy[0]='\\'; for(length=1; *string != '\0'; length++,string++)  { dummy[length] = *string;} index=make_atom(dummy,0,length,0);  printf("#Atomindex : %d\n",index); return(index);}/****************************************************************************//*     all_stack_dump(start,end)*/#define SDMAXLINE 40#define SD_morep	if(++sdlines>SDMAXLINE){\			 printf("\nPress Return:"); getchar();fflush(stdin);sdlines=0;}#ifndef BYTESWAPtypedef struct stack_header  {    unsigned	flags1 : 3;    unsigned	flags2  : 5;    unsigned	usecount : 8;  } STKH;#define STKHPTR(ptr) (ptr)#elsetypedef struct stack_header  {    unsigned	usecount : 8;    unsigned	flags2  : 5;    unsigned	flags1 : 3;  } STKH;#define STKHPTR(ptr) ((STKH *) (2^(int)(ptr)))#endif BYTESWAPall_stack_dump(start,end,silent) DLword start,end ,silent; /* Stack offset in DLword */{  STKH *stkptr;  DLword *start68k,*end68k,*orig68k;  DLword size,dummy;  int sdlines=0; extern IFPAGE *InterfacePage; if(start==0) start68k= Stackspace + InterfacePage->stackbase; else start68k = Addr68k_from_LADDR(STK_OFFSET | start); if(end==0) end68k= Stackspace+ InterfacePage->endofstack; else end68k = Addr68k_from_LADDR(STK_OFFSET | end); stkptr= (STKH *)start68k;  while(((DLword*)stkptr) < end68k )  {	dummy = LADDR_from_68k(stkptr);	switch (STKHPTR(stkptr)->flags1 ) {	case STK_GUARD :	case STK_FSB :			if( (STKHPTR(stkptr)->flags2 !=0) || (STKHPTR(stkptr)->usecount!=0) )				{goto badblock;};			size = GETWORD(((DLword *)stkptr) +1);			if(size <=0 || size > ((DLword*)end68k-(DLword*)stkptr))			 {goto badblock;};			if(STKHPTR(stkptr)->flags1 == STK_GUARD)			printf("\n<<  0x%x GUARD size : 0x%x >>",LADDR_from_68k(stkptr),size );			else printf("\n<<  0x%x FSB size : 0x%x >>",LADDR_from_68k(stkptr),size);			SD_morep;			size = GETWORD(((DLword *)stkptr) +1);	checksize:			if(size <=0 || size > ((DLword*)end68k-(DLword*)stkptr))			 {goto badblock;};			((DLword *)stkptr) += size;			break;	case STK_FX :			/*if((((FX *)stkptr)->pc < 24) ||				(((FX *)stkptr)->alink==0)  ||				 (STKHPTR(stkptr)->usecount > 31))			 {goto badblock;};*/			if (silent)			{SD_morep;			 printf("\n<<  0x%x: FX for ",LADDR_from_68k(stkptr));			 print(get_framename(stkptr));			 printf(" [");			 if(((FX *)stkptr)->fast)	printf("fast,");			 if(((FX *)stkptr)->native)	printf("native,");			 if(((FX *)stkptr)->incall)	printf("incall,");			 if(((FX *)stkptr)->validnametable)	printf("V,");			 if(((FX *)stkptr)->nopush)	printf("nopush,");			 printf("]"); }			else {dump_fx(stkptr);}			if((FX *)stkptr == CURRENTFX) {				printf(" <-***current***");				size= EndSTKP - (DLword*)stkptr;			}			else {			size = (Addr68k_from_LADDR(STK_OFFSET| ((FX *)stkptr)->nextblock) - (DLword*)stkptr);			};			goto checksize;	default :		       orig68k =(DLword*) stkptr;                        while(STKHPTR(stkptr)->flags1 != STK_BF) {                                if(STKHPTR(stkptr)->flags1!=STK_NOTFLG){goto badblock;};                                ((DLword *)stkptr) += DLWORDSPER_CELL;                         };			if((BFRAMEPTR(stkptr))->residual)                          { if((DLword*) stkptr != orig68k)                             {				printf("\n$$$Bad BF(res):0x%x",LADDR_from_68k(stkptr));				goto incptr;			     }			  }			 else			  {				 if(BFRAMEPTR(stkptr)->ivar						!= StkOffset_from_68K(orig68k))				 {					printf("\n$$$BF doesn't point TopIVAR:0x%x\n",LADDR_from_68k(stkptr));					goto incptr;				 }			  }			if(silent)			  { SD_morep;			    printf("\n<<  0x%x: BF ",LADDR_from_68k(stkptr));			    putchar('[');			if (BFRAMEPTR(stkptr)->residual) printf("Res,");			if (BFRAMEPTR(stkptr)->padding) printf("Pad,");			printf("ivar : 0x%x]", BFRAMEPTR(stkptr)->ivar);			} else  dump_bf(stkptr);			((DLword *)stkptr) += 2;			break;	badblock:       SD_morep;			printf("\n!!!<< 0x%x: Invalid, %x %x>>!!!",LADDR_from_68k(stkptr), GETWORD(stkptr), GETWORD(stkptr+1));	incptr:		((DLword *)stkptr)+=2;			break;	} /* case end */  } /* while end */printf("\n<< That's All , last stack :0x%x >>\n",InterfacePage->endofstack);}/************************************************************/dtd_chain(type) DLword type;  {    struct dtd *dtdp;    LispPTR next;    LispPTR *next68k;    dtdp=(struct dtd *)GetDTD(type);    next=dtdp->dtd_free;    next68k=(LispPTR *) Addr68k_from_LADDR(next);    while((*next68k) != 0)      {	if(type != GetTypeNumber(next)) {	printf("BAD cell in next dtdfree\n");	  return; }	print(next);	putchar('\n');	next= *next68k;	next68k=(LispPTR *) Addr68k_from_LADDR(next);      }    printf("That's All !\n");  }/*  dtd_chain end **/#ifdef CHECKcheck_dtd_chain(type)	DLword          type;{	register LispPTR next;	LispPTR         before;	next = ((struct dtd *)GetDTD(type))->dtd_free;	while (next != NIL) {		if (type != GetTypeNumber(next)) {			error("BAD cell in next dtdfree ");			return;		}		next = *((LispPTR *)Addr68k_from_LADDR(next));	}}#endif/************************************************************************//*									*//*			T R A C E _ F N C A L L				*//*			T R A C E _ A P P L Y				*//*									*//*	Functions for tracing function call and apply.  Trace_FNCall	*//*	takes 2 arguments:  The # of args the fn is bing called with	*//*	and the atom index of the function's name.			*//*									*//*	Trace_APPLY takes one argument:  The atom number of the		*//*	atom being applied.						*//*									*//************************************************************************/Trace_FNCall(numargs, atomindex)  int numargs;  int atomindex;  {    printf("Calling a %d-arg FN:  ", numargs);    print_atomname(atomindex);    printf(".\n");  }Trace_APPLY(atomindex)  int atomindex;  {    printf("APPLYing an atom:  ");    print_atomname(atomindex);    printf(".\n");  }