/* @(#) timer.c Version 2.31 (9/18/90). copyright Venue & Fuji Xerox  */static char *id = "@(#) timer.c	2.31 9/18/90		(Venue & Fuji Xerox)";/************************************************************************//*									*//*				t i m e r . c				*//*									*//*	Timer handling routines, plus set-up for the other interrupts	*//*	Medley uses on Unix.						*//*									*//*									*//*	Copyright 1987-1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/#include	<sys/time.h>#include	<sys/types.h>#include	<stdio.h>#include	<signal.h>#include	<fcntl.h>#include	<sys/resource.h>#include	<setjmp.h>#ifdef AIXPS2#include	<sys/fpcontrol.h>#endif AIXPS2/* Apollo and Sun have different ideas about the name of this field */#ifdef APOLLO#define sv_flags sv_onstack#endif#include	"lispemul.h"#include	"emulglobal.h"#include	"lispglobal.h"#include	"address68k.h"#include	"lisptypes.h"#include	"arith.h"#include	"lispmap.h"#include	"stack.h"#include	"dbprint.h"#define	LISP_UNIX_TIME_DIFF	29969152#define	LISP_ALTO_TIME_MASK	0x80000000#define UNIX_ALTO_TIME_DIFF	2177452800/*	Interlisp time is signed; MIN.FIXP = "01-JAN-01 00:00:00 GMT" *	Interlisp 0 is at	"19-Jan-69 12:14:08 PST" *	Unix begins at		" 1-Jan-70  0:00:00 GMT" *	(CL:- (IL:IDATE	" 1-Jan-70  0:00:00 GMT") *	      (IL:IDATE "19-Jan-69 12:14:08 PST")) *	=> 29969152, amount to add to Lisp time to get Unix time *	Alto time is unsigned; 0 = "01-JAN-01 00:00:00 GMT" *      UNIX_ALTO_TIME_DIFF is amount to add to Unix time *	to get Alto time. */int	TIMEOUT_TIME;	/* For file system timeout */char	*getenv();#ifdef XWINDOW#define FALSE 0#define TRUE  !FALSEint Event_Req = FALSE;#endif XWINDOW/************************************************************************//*									*//*			i n i t _ m i s c s t a t s			*//*									*//*	Called at initialization time to set miscstats words.		*//*	?? and to periodically update them ?? [JDS 11/22/89]		*//*									*//*									*//************************************************************************/init_miscstats()  {    MiscStats->starttime = gettime(0);    MiscStats->gctime = 0;    update_miscstats();  }/************************************************************************//*									*//*		    u p d a t e _ m i s c s t a t s			*//*									*//*	Updates counters and timers in the MISCSTATS "page".		*//*									*//*									*//*									*//************************************************************************/update_miscstats()  {    struct rusage ru;    struct timeval time;    getrusage(RUSAGE_SELF, &ru);    MiscStats->totaltime = ru.ru_utime.tv_sec * 1000			 + ru.ru_utime.tv_usec /1000;    MiscStats->swapwaittime = ru.ru_stime.tv_sec * 1000			    + ru.ru_stime.tv_usec /1000;    MiscStats->pagefaults = ru.ru_minflt + ru.ru_majflt;    MiscStats->swapwrites = ru.ru_majflt;    MiscStats->diskiotime = 0; /* ?? not available ?? */    MiscStats->diskops	= ru.ru_inblock    			 /* ?? this doesn't work ???    			+ ru.ru_outblock   */				;    gettimeofday(&time, NULL);    MiscStats->secondstmp =    MiscStats->secondsclock = (time.tv_sec + UNIX_ALTO_TIME_DIFF);  }/************************************************************************//*									*//*			s u b r _ g e t t i m e				*//*									*//*	Handler for Lisps GETTIME subr call, dispatched thru		*//*	subr.c/miscn.c sub-dispatch.					*//*									*//*	Calls gettime, and returns the result to Lisp as a SMALLP	*//*	or FIXP, as appropriate.					*//*									*//************************************************************************/DLword	*createcell68k();LispPTR subr_gettime(args)  LispPTR	args[];  {    int result;    result = gettime(args[0] & 0xffff);    if (args[1])      {	*((int*)Addr68k_from_LADDR(args[1]) ) = result;	return (args[1]);      }    else N_ARITH_SWITCH(result);}/************************************************************************//*									*//*		    		g e t t i m e				*//*									*//*	Get the value of one of the various time counters, as		*//*	specified by the argument casep.  casep's values & meanings:	*//*									*//*	0 elapsed time, in milliseconds.				*//*	1 start of elapsed-time period, in milliseconds			*//*	2 this process's run time, in milliseconds			*//*	3 total GC time, in milliseconds				*//*	4 current time-of-day, in ALTO format				*//*	5 current time-of-day, in Interlisp format			*//*	6 start of daylight-savings, as day-in-year			*//*	7 end of daylight-savings, as day-in-year			*//*	8 time zone, as hours of offset from GMT (whole hours only)	*//*									*//************************************************************************/int gettime(casep)    int casep;  {    struct	timeval	time;    struct	timezone tz;    switch (casep)      {	case 0: /* elapsed time in alto milliseconds */		gettimeofday(&time, NULL);		return((time.tv_sec + UNIX_ALTO_TIME_DIFF)*1000				    + time.tv_usec/1000);	case 1: /* starting elapsed time in milliseconds */		return(MiscStats->starttime);	case 2: /* run time, this process, in milliseconds */		update_miscstats();		return(MiscStats->totaltime);	case 3: /* total GC time in milliseconds */		return(MiscStats->gctime);	case 4: /* current time of day in Alto format */		gettimeofday(&time, NULL);		return (time.tv_sec + UNIX_ALTO_TIME_DIFF);	case 5:	/* current time of day in Interlisp format */		gettimeofday(&time, NULL);		return(time.tv_sec + LISP_UNIX_TIME_DIFF);	case 6: gettimeofday(&time, &tz);		return (98); /* this is wrong, only works in PST */	case 7: gettimeofday(&time, &tz);		return (305); /* this is wrong, only works in PST */	case 8: gettimeofday(&time, &tz);		return (tz.tz_minuteswest/60); /* only integral timezones work */	default: return (0);      }  }/************************************************************************//*									*//*			s u b r _ s e t t i m e				*//*									*//*	Converts its argument, a time in ALTO seconds, to the		*//*	UNIX time format, and sets the UNIX clock.  You must be		*//*	the super-user for this to work.				*//*									*//*	Implements the SETTIME subr call, sub-dispatched from subr.c	*//*									*//************************************************************************/subr_settime(args)  LispPTR	args[];  {    struct timeval time;    time.tv_sec = *((int*)Addr68k_from_LADDR(args[0]))    		- UNIX_ALTO_TIME_DIFF;    settimeofday(&time, NULL);  } /* end subr_settime *//************************************************************************//*									*//*		    s u b r _ c o p y t i m e s t a t s			*//*									*//*	Given source and destination MISCSTATS structure pointers,	*//*	copy the contents of the source structure into the dest.	*//*									*//*	Also calls update_miscstats, to keep stats current.		*//*									*//************************************************************************/subr_copytimestats(args)  LispPTR args[]; {    MISCSTATS *source;    MISCSTATS *dest;    source = (MISCSTATS*) Addr68k_from_LADDR(args[0]);    dest   = (MISCSTATS*) Addr68k_from_LADDR(args[1]);    update_miscstats();    *dest = *source;  }/************************************************************************//*									*//*			     N _ O P _ r c l k				*//*									*//*	Get the current time in UNIX format, convert it to micro-	*//*	seconds in ALTO format, and store the low 32 bits into		*//*	the FIXP cell passed in to us on the top of stack.		*//*									*//************************************************************************/LispPTR N_OP_rclk(tos)  register LispPTR tos;  {    struct	timeval	time;    unsigned int	usec;    gettimeofday(&time, NULL);    usec = (time.tv_sec * 1000000) + time.tv_usec;    *((unsigned int *)(Addr68k_from_LADDR(tos))) = usec;    return(tos);  } /* end N_OP_rclk *//**********************************************************************/ /* update_timer called periodically *//************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/update_timer()  {    struct  timeval time;    gettimeofday(&time, NIL);    MiscStats->secondstmp = MiscStats->secondsclock			  = (time.tv_sec + UNIX_ALTO_TIME_DIFF);  }/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************//**********************************************************************//* timer interrupt handling system	int_init() should be called before first entering dispatch loop.	int_timer_init() is called by int_init() and arms the timer interrupt.	int_io_init() is called by int_init() and arms the I/O interrupt.	int_timer_service() catches the timer signal and sets		Irq_Stk_Check & Irq_Stk_End to 0		so the rest of the system will see it and respond.	int_block() and int_unblock() block timer interrupts  and release them.	int_io_open(fd) should be called whenever a file that should interrupt		us is opened; it enables the interrupt on that fd.	int_io_close(fd) should be called whenever a file that should interrupt		us is closed; it disables the interrupt on that fd.*//* TIMER_INTERVAL usec ~ 20  per second.  This should live in some	machine-configuration	file somewhere - it can be changed as the -t parameter to lisp*/#ifdef sparcint TIMER_INTERVAL =  100000;#elseint TIMER_INTERVAL =  25000;#endifint FileIOFlag = 0;int TimerFlag = 0;extern u_int LispWindowFd;/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/#ifdef OS4void int_timer_service(sig, code, scp)#elseint int_timer_service(sig, code, scp)#endifint sig, code;struct sigcontext *scp;{/* this may have to do more in the future, like check for nested interrupts,	etc... */	Irq_Stk_Check = 0;	Irq_Stk_End = 0;	TimerFlag = 1;#ifdef XWINDOW	Event_Req = TRUE;#endif}/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/static struct sigvec timerv;void int_timer_init(){struct itimerval timert, tmpt;/* first set up the signal handler */	timerv.sv_handler = int_timer_service;	timerv.sv_mask = timerv.sv_flags = 0;	sigvec(SIGVTALRM, &timerv, 0);/* then attach a timer to it and turn it loose */	timert.it_interval.tv_sec  = timert.it_value.tv_sec = 0;	timert.it_interval.tv_usec = timert.it_value.tv_usec = TIMER_INTERVAL;	timerclear(&tmpt.it_value);	timerclear(&tmpt.it_interval);	setitimer(ITIMER_VIRTUAL, &timert, &tmpt);	getitimer(ITIMER_VIRTUAL, &tmpt);	DBPRINT(("Timer interval set to %d usec\n", timert.it_value.tv_usec));}/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/void int_io_open(fd)int fd;{#ifdef KBINT	DBPRINT(("int_io_opening %d\n", fd));	if(fcntl(fd, F_SETOWN, getpid()) == -1 ) {#ifdef DEBUG		perror("fcntl F_SETOWN ERROR");#endif		};	if(fcntl(fd, F_SETFL, fcntl (fd, F_GETFL, 0) | FASYNC) == -1)		perror("fcntl F_SETFL error");#endif}void int_io_close(fd)int fd;{#ifdef KBINT	fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~FASYNC);#endif}/************************************************************************//*									*//*			i n t _ i o _ i n i t				*//*									*//*	Set up handling for the SIGIO and SIGPOLL signals, in		*//*	support of keyboard event handling and ethernet incoming-	*//*	packet handling.						*//*									*//*									*//************************************************************************/void int_io_init()  {    static struct sigvec timerv;    static struct sigvec poll_timerv;#ifdef OS4    extern void getsignaldata();#else    extern int getsignaldata();#endif    /* first set up the signal handler */#ifdef KBINT    timerv.sv_handler = getsignaldata;    timerv.sv_mask = timerv.sv_flags = 0;    sigvec(SIGIO, &timerv, 0);     DBPRINT(("I/O interrupts enabled\n"));#endif}int oldmask = 0;/************************************************************************//*									*//*			   i n t _ b l o c k				*//*									*//*	Temporarily turn off interrupts.				*//*									*//*	NOTE that these interrupts must also be turned off in ldeboot's	*//*	forking code; if you change these, go fix that one too		*//*									*//************************************************************************/void int_block(){/* temporarily turn off interrupts */	oldmask= sigblock(sigmask(SIGVTALRM) | sigmask(SIGIO)  |			  sigmask(SIGALRM)   | sigmask(SIGXFSZ)#ifdef FLTINT 			| sigmask(SIGFPE)#endif);}/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************/void int_unblock(){	sigsetmask(oldmask);}int_timer_on () {int_unblock();}int_timer_off() {int_block  ();}/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************//*void int_timer_off(){struct sigvec tmpv, timeroffv;timeroffv.sv_handler = SIG_IGN;timeroffv.sv_mask = timeroffv.sv_flags = 0;sigvec(SIGVTALRM, &timeroffv, &tmpv);}void int_timer_on(){struct sigvec tmpv;sigvec(SIGVTALRM, &timerv, &tmpv);}*/#ifdef FLTINT/************************************************************************//*									*//*  F L O A T I N G - P O I N T   I N T E R R U P T   H A N D L I N G	*//*									*//*	This is the handler for the SIGFPE signal, to catch floating-	*//*	point exceptions.  Sets the global 'FP_error' to the error	*//*	code passed in by the signal; FP_error is checked by the	*//*	Lisp emulator FP code to make sure everything is OK.		*//*									*//************************************************************************//* The global used to signal floating-point errors */int FP_error = 0;void int_fp_service(sig, code, scp)  int sig, code;  struct sigcontext *scp;  {    switch(code)      {#ifdef AIXPS2	case FPM_DENORM:	case FPM_DIVIDE_0:	case FPM_UNDERFLOW:	case FPM_OVERFLOW:	case FPM_PRECISION:#else	case FPE_FLTDIV_TRAP:	case FPE_FLTUND_TRAP:	case FPE_FLTOVF_TRAP:	case FPE_FLTOPERR_TRAP:#endif AIXPS2 				FP_error = code;				break;	default:	  {#ifdef DEBUG	    char stuff[100];	    sprintf(stuff, "Unexpected FP error signal code: %d", code);	    perror(stuff);#endif	  }      }  }int_fp_init()  {	/* first set up the signal handler */#ifndef AIXPS2    if(ieee_handler("set", "all", int_fp_service))#else    if(signal(SIGFPE, int_fp_service))#endif AIXPS2      perror("Sigvec for FPE failed");    DBPRINT(("FP interrupts enabled\n"));  }#endif FLTINT/************************************************************************//*									*//*			t i m e o u t _ e r r o r			*//*									*//*	Error handling routine for SIGALRM.  Called when any		*//*	TIMEOUT(...) forms spend more than TIMEOUT_TIME (normally	*//*	10 sec.) trying to do an I/O operation.				*//*									*//*									*//************************************************************************/jmp_buf	jmpbuf;#ifdef OS4void#endiftimeout_error()  {    /*     * Following printf changes the contents of jmpbuf!     * This would lead to horrible segmentation violation.     *//*  printf("File access timed out.\n"); */    longjmp(jmpbuf, 1);  }/************************************************************************//*									*//*			i n t _ f i l e _ i n i t			*//*									*//*	Set up the signal handler for SIGALRM, to catch TIMEOUTs:	*//*	TIMEOUT(...) forms spend more than TIMEOUT_TIME (normally	*//*	10 sec.) trying to do an I/O operation.				*//*									*//*									*//************************************************************************/void int_file_init()  {    static struct sigvec timerv;    char	*envtime;    int	timeout_time;    /* first set up the signal handler */    timerv.sv_handler = timeout_error;    timerv.sv_mask = timerv.sv_flags = 0;    sigvec(SIGALRM, &timerv, 0);    /* Set Timeout period */    if((envtime = getenv("LDEFILETIMEOUT")) == NULL)      {	TIMEOUT_TIME = 10;      }    else      {	if( (timeout_time = atoi(envtime)) > 0) TIMEOUT_TIME = timeout_time;	else TIMEOUT_TIME = 10;      }    DBPRINT(("File timeout interrupts enabled\n"));  }/************************************************************************//*                                                                      *//*                         p a n i c u r a i d                          *//*                                                                      *//*   Most of the unused process-killing interrupts end up here; you     *//*      can't do a whole lot safely here but dump your sysout for       *//*      post-mortem analysis, but you MIGHT be able to get a clue       *//*      about what killed you.                                          *//*                                                                      *//************************************************************************/void panicuraid(sig, code, scp, addr)  int sig, code;  struct sigcontext *scp;  {    static char errormsg[200];    static char *stdmsg ="Please record the signal and code information\n\and do a 'v' before trying anything else.";    int i;    for (i=0; i<200; i++) errormsg[i]=0;    switch (sig)      {	case SIGBUS:	sprintf(errormsg,				"BUS error (code %d) at address 0x%x.\n%s",				code, addr, stdmsg);			break;	case SIGSEGV:	sprintf(errormsg,				"SEGV error (code %d) at address 0x%x.\n%s",				code, addr, stdmsg);			break;	case SIGILL:	sprintf(errormsg,				"Illegal instruction (code %d) at address 0x%x.\n%s",				code, addr, stdmsg);			break;	case SIGPIPE:	sprintf(errormsg,				"Borken PIPE (code %d) at address 0x%x.\n%s",				code, addr, stdmsg);			break;	case SIGHUP:	sprintf(errormsg,				"HANGUP signalled (code %d) at address 0x%x.\n%s",				code, addr, stdmsg);			break;	case SIGFPE:	sprintf(errormsg,				"FP error (code %d) at address 0x%x.\n%s",				code, addr, stdmsg);			break;	default:	sprintf("Uncaught SIGNAL %d (code %d).\n%s",				sig, code, stdmsg);      }    error(errormsg);  }/************************************************************************//*                                                                      *//*                     i n t _ p a n i c _ i n i t                      *//*                                                                      *//*  A catch for all the deadly interupts (but KILL, of course)          *//*  Dumps you into uraid; you probably can't get back from it,          *//*     but there is hope that you will be able to poke around with      *//*     uraid and get a clue about why you're dying.                     *//*                                                                      *//************************************************************************/void int_panic_init()  {    static struct sigvec panicv;    /* first set up the signal handler */    panicv.sv_handler = panicuraid;    panicv.sv_mask = panicv.sv_flags = 0;    sigvec(SIGHUP,  &panicv, 0);/*    sigvec(SIGINT,  &panicv, 0); */    sigvec(SIGQUIT, &panicv, 0);    sigvec(SIGILL,  &panicv, 0);/*    sigvec(SIGTRAP, &panicv, 0); */#ifdef OS4    sigvec(SIGABRT, &panicv, 0);#endif OS4    sigvec(SIGEMT,  &panicv, 0);    sigvec(SIGBUS,  &panicv, 0);    sigvec(SIGSEGV, &panicv, 0);    sigvec(SIGSYS,  &panicv, 0);    sigvec(SIGPIPE, &panicv, 0);    sigvec(SIGTERM, &panicv, 0);    sigvec(SIGXCPU, &panicv, 0);/*    sigvec(SIGPROF, &panicv, 0); */#ifdef OS4    sigvec(SIGLOST, &panicv, 0);#endif OS4    sigvec(SIGUSR1, &panicv, 0);    sigvec(SIGUSR2, &panicv, 0);#ifndef FLTINT    sigvec(SIGFPE, &panicv, 0);#endif    DBPRINT(("Panic interrupts enabled\n"));  }/************************************************************************//*									*//*			    i n t _ i n i t				*//*									*//*	Initialize all the interrupts for Lisp & the emulator.		*//*									*//************************************************************************/void int_init()  {   int_timer_init();	/* periodic interrupt timer */   int_io_init();	/* SIGIO and SIGPOLL async I/O handlers */   int_file_init();	/* file-io TIMEOUT support */   int_panic_init();    /* catch for all other dangerous interrupts */#ifdef FLTINT   int_fp_init();	/* Floating-point exception handler */#endif   int_unblock();	/* Turn on interrupts */}