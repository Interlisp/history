/* This is G-file @(#) localfile.h Version 2.11 (7/21/88). copyright Xerox & Fuji Xerox  */#define	PAGESIZE	512	/* 1 page == 512 byte */#define	NIL	0#define	T	1#define	RECOG_OLD		S_POSITIVE | 0#define	RECOG_OLDEST		S_POSITIVE | 1#define	RECOG_NEW		S_POSITIVE | 2#define	RECOG_NEW_OLD		S_POSITIVE | 3#define	RECOG_NON		S_POSITIVE | 5#define	ACCESS_INPUT		S_POSITIVE | 0#define	ACCESS_OUTPUT		S_POSITIVE | 1#define	ACCESS_BOTH		S_POSITIVE | 2#define	ACCESS_APPEND		S_POSITIVE | 3#define	SIZE			S_POSITIVE | 1	/* For getfileinfo */#define	WDATE			S_POSITIVE | 2#define	RDATE			S_POSITIVE | 3#define	AUTHOR			S_POSITIVE | 5#define	PROTECTION		S_POSITIVE | 6extern	DLword	*Lisp_world;	/* To access LispSysout area */#define	ToLispTime(x)	((int)x + 29969152)			/* For fetfileinfo. For WDATE&RDATE */			/* 29969152 == (timer.c)LISP_UNIX_TIME_DIFF */			/* - 61200 == - 17hours */#define	ToUnixTime(x)	((int)x - 29969152)			/* For fetfileinfo. For WDATE&RDATE */			/* 29969152 == (timer.c)LISP_UNIX_TIME_DIFF */#define	LispStringToCString(Lisp, C){	\	ONEDARRAAY	*arrayp;	\	char	*base, *dp;		\	short	*sbase;			\	int	i;			\	arrayp = (ONEDARRAAY *)(Addr68k_from_LADDR(Lisp));	\	switch(arrayp->typenumber){				\	case THIN_CHAR_TYPENUMBER:				\		base = ((char *)(Addr68k_from_LADDR(arrayp->base))) + ((int)(arrayp->offset));\		strncpy(C, base, arrayp->totalsize);			\		C[arrayp->totalsize] = '\0';				\		break;							\	case FAT_CHAR_TYPENUMBER:					\		sbase = ((short *)(Addr68k_from_LADDR(arrayp->base))) + ((int)(arrayp->offset));	\		for(i=0,dp=C;i<(arrayp->totalsize);i++){		\			*dp++ = (char)(*sbase++);			\		}							\		*dp = '\0';						\		break;							\	default:							\		error("LispStringToCString can not handle\n");		\	}								\	}#define	LispNumToCInt(Lisp)		\		( ((Lisp & 0xFF0000) == S_POSITIVE) ? 	\		(Lisp & 0xFFFF) : (*((int *)(Addr68k_from_LADDR(Lisp)))) );#define	UPLOWDIFF	0x20#define	DOWNCASE(name){			\	register char	*cp;					\		for(cp=name;*cp!='\0';++cp)			\			if((*cp >= 'A') && (*cp <= 'Z'))	\				*cp += UPLOWDIFF;			\	}#define	UPCASE(name){			\	register char	*cp;					\		for(cp=name;*cp!='\0';++cp)			\			if((*cp >= 'a') && (*cp <= 'z'))	\				*cp -= UPLOWDIFF;			\	}#define	DIRP(path, dir, buf){	\	int rval;		\	struct	stat	statbuf;	\		strcpy(buf, path);	\		strcat(buf, dir);	\		TIMEOUT( rval=stat(buf, &statbuf) );	\	if( rval == 0){			\			if( (statbuf.st_mode & S_IFMT) == S_IFDIR ){	\				strcat(path, dir);			\				return(1);				\			}				\		}					\		}#define	FILEP(path, file, buf){	\	int rval;		\		strcpy(buf, path);		\		strcat(buf, file);		\		TIMEOUT( rval=access(buf, F_OK) );	\		if( access(buf, F_OK) == 0){	\			strcat(path, file);		\			return(1);			\		}					\		}#define	STREQ(name1, name2)(	\		(*name1 == *name2) && (strcmp(name1, name2) == 0)	\		)#define	MAXNUM(i,j)  (i>j ? i : j)#define	MINNUM(i,j)  (i<j ? i : j)#define	VERSIONLEN 10#define	MAXVERSION 999999999#define	UnixVersionToLispVersion(pathname){		\		char	*cp;				\		register char	*cp1;				\		if( ((cp=index(pathname, '~'))!=0) && (*(cp-1) == '.') && ((cp1=index(cp+1, '~'))!=0) ){	\				*(cp-1) = ';';		\				for(cp++;cp!=cp1;cp++)		\					*(cp-1) = *cp;	\				for(cp1++;*cp1!='\0';cp1++, cp++)	\					*(cp-1) = *cp1;			\				*(cp-1) = '\0';			\		}else					\			strcat(pathname, ";0");		\		}#define	LispVersionToUnixVersion(pathname){		\		char	*cp;				\		register char	*cp1;				\		register char	*cp2;				\		if( (cp=index(pathname, ';')) != 0 ){	\			switch(*(cp+1)){		\			case '\0':			\				break;			\			case '0':			\				if(*(cp+2) == '\0'){	\					*cp = '\0';	\					break;		\				}			\			default: 			\				*cp++ = '.';		\				for(cp1=cp;((*cp1>='0')&&(*cp1<='9'))||*cp1=='*';cp1++);	\				for(cp2=cp1;*cp2!='\0';cp2++);	\				for(;cp2!=cp1;cp2--)	\					*(cp2+2) = *cp2;\				*(cp2+2) = *cp2;\				*(cp1+1) = '~';		\				for(;cp!=cp1;cp1--)		\					*cp1 = *(cp1-1);	\				*cp = '~';		\			}				\		}					\		}/* An argument of AddDodNoExtention must be LispVersion convention *//* Like "foo/fee.fee;3" or "/foo/foo;3" *//* AddDodNoExtention must be put after UnixVersionToLispVersion */#define	AddDodNoExtention(file){		\		register char	*cp;			\		register char	*cp1;			\		if( (rindex(file,'.')== 0) && ((cp=rindex(file,';'))!=0) ){	\			for(cp1=cp;*cp1!='\0';cp1++);	\			*(cp1+1) = '\0';		\			for(;cp!=cp1;cp1--)		\				*cp1 = *(cp1-1);	\			*cp = '.';		\		}				\		}/* An argument of RemoveDodNoExtenstion must be LispVersion convention *//* Like "foo/fee.fee;3" or "/foo/foo.;3" *//* RemoveDodNoExtenstion must be put before LispVersionToUnixVersion */#define RemoveDodNoExtenstion(file){		\		register char	*cp;			\		if( ((cp=rindex(file, ';'))!=0) && (*(cp-1)=='.') ){	\			for(;*cp!='\0';++cp)				\				*(cp-1) = *cp;				\			*(cp-1) = '\0';				\		}				\		}		extern	int	errno;#define	ChangeToVersionless(pathname){			\		register char	*cp;			\		if( (cp=rindex(pathname, ';')) != 0)	\			*cp = '\0';			\		}#define NoFileP(version_array)				\		((version_array->version_no==LASTVERSIONARRAY)? T : NIL)#define	UNLINK(x){					\		TIMEOUT(rval=unlink(x));		\		if(rval == -1){				\			err_mess("unlink", errno);	\			return(0);			\		}					\		}#define LINK(x,y){					\		TIMEOUT(rval=link(x, y));		\		if(rval == -1){				\			if(errno == 2)			\				return(1);		\			else{				\				err_mess("link", errno);\				return(0);		\			}				\		}					\		}#define RENAME(x,y){					\		TIMEOUT(rval=rename(x, y));		\		if(rval == -1){				\			if(errno == 2)			\				return(1);		\			else{				\				err_mess("rename", errno);\				return(0);		\			}				\		}					\		}#define	STAT(x,y){						\		TIMEOUT(rval=stat(x, y));	\		if(rval != 0){					\			err_mess("stat", errno);		\			return(-1);				\		}						\		}