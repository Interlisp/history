/* This is G-file @(#) inlinedefsC.h Version 2.40 (8/1/88). copyright Xerox & Fuji Xerox  *//* 		These are the Macros Used to generate inline c code.	These are the goto ni definitions of the opcodes.*/#undef ADDBASE#undef LOLOC#undef HILOC#undef VAG2#define CHECK_INTERRUPT {if((int)CSTKPTR > Irq_Stk_Check) goto check_interrupt;} #define SWAP_WORDS(x) \	(((unsigned int) x << 16) | (((unsigned int) x >> 16) & 0xFFFF))#define NATIVECHECK							\	{if (BCE_CURRENTFX->native) {goto gonative ;} nextop0; }#define nextop0 {goto nextopcode; }#define nextop1 {PCMAC += 1; nextop0; }#define nextop2 {PCMAC += 2; nextop0; }#define nextop3 {PCMAC += 3; nextop0; }#define nextop4 {PCMAC += 4; nextop0; }#define OPCAR \ if (Listp(TOPOFSTACK))\ {\ register ConsCell *DATUM68K = (ConsCell *)(Addr68k_from_LADDR(TOPOFSTACK));\	if (DATUM68K->cdr_code == CDR_INDIRECT)\	{\		TOPOFSTACK = ((LispPTR)((ConsCell *)Addr68k_from_LADDR(DATUM68K->car_field))->car_field);\		nextop1; \	}\	else \	{ \		TOPOFSTACK = ((LispPTR)DATUM68K->car_field);\		nextop1; \  } \  }\ else	if (TOPOFSTACK == NIL_PTR)\		{ nextop1; } \	else if ( TOPOFSTACK == ATOM_T)\		{ nextop1; } \	else \	  {\		goto op_ufn; \	  } /* end of OPCAR */#define OPCDR  \ if (Listp(TOPOFSTACK))\ {\register ConsCell *DATUM68K = (ConsCell *)(Addr68k_from_LADDR(TOPOFSTACK));\register DLword CDRCODEX = DATUM68K->cdr_code;\	if (CDRCODEX == CDR_NIL) {\		/* cdr-nil */\		TOPOFSTACK = (NIL_PTR);\		nextop1; \		} \	else if (CDRCODEX> CDR_ONPAGE) {\		/* cdr-samepage */\		TOPOFSTACK = (POINTER_PAGEBASE(TOPOFSTACK) + \		((CDRCODEX & 127) << 1));\		nextop1; \		} \	else if (CDRCODEX == CDR_INDIRECT) {	/* CDRCODEX < CDR_ONPAGE */\		/* cdr-indirect */\		TOPOFSTACK = (cdr ((LispPTR)(DATUM68K->car_field)));\		nextop1; \		} \	else\	{\		/* cdr-differentpage */\		TOPOFSTACK = ((ConsCell *)(Addr68k_from_LADDR \		(POINTER_PAGEBASE(TOPOFSTACK) + (CDRCODEX << 1)))\											)->car_field;\		nextop1; \	}\  }\ else	if (TOPOFSTACK == NIL_PTR)\		{ nextop1; } \	else\	 {\		goto op_ufn; \	 } /* end of OPCDR */#define	IVARMACRO(x)	{PUSH(GetLongWord((LispPTR *)IVAR + x )); nextop1;}#define	PVARMACRO(x)	{PUSH(GetLongWord((LispPTR *)PVAR + x )); nextop1;}#define	PVARSETMACRO(x)	{*((LispPTR *)PVAR + x) = TOPOFSTACK; nextop1;}#define	PVARSETPOPMACRO(x) {*((LispPTR *)PVAR + x) = TOPOFSTACK; POP; nextop1;}#define	PUSHATOM(x)	{PUSH(x); nextop1;}#define	JUMPMACRO(x)	{CHECK_INTERRUPT; PCMAC += x; nextop0;}#define	FJUMPMACRO(x)	{if(TOPOFSTACK != 0) {goto PopNextop1 ; }	\			{CHECK_INTERRUPT; POP; PCMAC += x; nextop0;}	\			}#define	TJUMPMACRO(x)	{if(TOPOFSTACK == 0) {goto PopNextop1 ; }	\			{CHECK_INTERRUPT; POP; PCMAC += x; nextop0;}	\			}#define GETBASE_N(n)	{ 						\		TOPOFSTACK = 						\			(S_POSITIVE | *((DLword *)			\			Addr68k_from_LADDR((0xFFFFFF & TOPOFSTACK) + n)));\		nextop2;						\		}#define GETBASEPTR_N(n) {						\		TOPOFSTACK = 						\			(0xFFFFFF & *((LispPTR *)			\			Addr68k_from_LADDR((0xFFFFFF & TOPOFSTACK) + n)));\		nextop2;						\		}#define PUTBASEBYTE							\	{ register int byteoffset;					\	  register char	*p_data;					\	 if(((0xFFFF0000 & TOPOFSTACK) != S_POSITIVE) ||		\	    ((unsigned short)TOPOFSTACK >= 256))			\		goto op_ufn;						\	 byteoffset = GET_TOS_1;					\	 switch( (0xFFFF0000 & byteoffset) ){				\	 case S_POSITIVE:						\	 	byteoffset &=  0x0000FFFF;				\	 	break;							\	 case S_NEGATIVE:						\		byteoffset |=  0xFFFF0000;				\		break;							\	 default:							\		goto op_ufn;						\	/***	if( GetTypeNumber(byteoffset) == TYPE_FIXP )		\			byteoffset = *((int *)Addr68k_from_LADDR(byteoffset));	\		else							\			goto op_ufn; ***/				\	 }								\	 --CSTKPTR;							\	 p_data = (char*)Addr68k_from_LADDR(0xFFFFFF & (POP_TOS_1)) + byteoffset;	\	 *p_data = 0xFF & TOPOFSTACK;					\	 nextop1;							\	}#define GETBASEBYTE							\	{switch( (0xFFFF0000 & TOPOFSTACK) ){				\	 case S_POSITIVE:						\		TOPOFSTACK &=  0x0000FFFF;				\		break;							\	 case S_NEGATIVE:						\		TOPOFSTACK |=  0xFFFF0000;				\		break;							\	 default:							\		if( GetTypeNumber(TOPOFSTACK) == TYPE_FIXP )		\			TOPOFSTACK = *((int *)Addr68k_from_LADDR(TOPOFSTACK));	\		else							\			goto op_ufn;					\	 }								\	 TOPOFSTACK = (0xFF & (*((char*)Addr68k_from_LADDR((0xFFFFFF & (POP_TOS_1))) + TOPOFSTACK))) | S_POSITIVE;	\	 nextop1;							\	}#define PUTBASEPTR_N(n)							\	{ register int base;						\	  base = 0xffffff & POP_TOS_1;					\	  *((LispPTR *)Addr68k_from_LADDR(base + n)) = TOPOFSTACK;      \	  TOPOFSTACK = base;						\	  nextop2;							\	}#define PUTBASE_N(n)							\	{ register int base;						\	  if (GetHiWord(TOPOFSTACK) != (S_POSITIVE >> 16))		\		goto op_ufn;						\	  base = 0xffffff & POP_TOS_1;					\	  *((DLword *)Addr68k_from_LADDR(base + n)) = GetLoWord(TOPOFSTACK);\	  TOPOFSTACK = base;						\	  nextop2;							\	}#define PVARX(x)	{ PUSH(GetLongWord((DLword * )PVAR + x)); nextop2; }#define PVARX_(x)	{ *((LispPTR *)((DLword * )PVAR+x))=TOPOFSTACK; nextop2;}#define IVARX(x)	{ PUSH(GetLongWord((DLword * )IVAR + x)); nextop2; }#define IVARX_(x)	{ *((LispPTR *)((DLword * )IVAR+x))=TOPOFSTACK; nextop2;}#define GVAR(x)		{ PUSH(GetLongWord(Valspace + (x<<1))); nextop3; }#define COPY		{ HARD_PUSH(TOPOFSTACK); nextop1; }#define SWAP		{ register LispPTR temp;			\			 temp = GET_TOS_1;				\			 GET_TOS_1 = TOPOFSTACK;			\		 	 TOPOFSTACK = temp;				\			 nextop1;					\			}#define	VAG2		{ TOPOFSTACK = (GET_TOS_1 << 16) | (0xFFFF & TOPOFSTACK); CSTKPTR--; nextop0; }#define UNWIND(n)	{ EXT; OP_unwind(); NRET;}#define FN0		{ OPFN(0); nextop0; }#define FN1		{ OPFN(1); nextop0; }#define FN2		{ OPFN(2); nextop0; }#define FN3		{ OPFN(3); nextop0; }#define FN4		{ OPFN(4); nextop0; }#define FNX		{ OPFNX;   nextop0; }#define ENVCALL		{ OP_ENVCALL; nextop0; }#define RETURN		{ OPRETURN; nextop0; }#define APPLY		{ OPAPPLY;}#define CHECKAPPLY	{ OPCHECKAPPLY; nextop1; }#define ADDBASE 	{ EXT; OP_addbase(); NRET; }/* #define OPCAR		{ EXT; OP_car(); NRET; } *//* #define OPCDR		{ EXT; OP_cdr(); NRET; } */#define RPLACA		{ EXT; OP_rplaca(); NRET; }#define RPLACD		{ EXT; OP_rplacd(); NRET; }#define RPLCONS		{ EXT; OP_rplcons(); NRET; }#define ATOMCELL_N(n)	{ EXT; OP_atomcellN(); NRET; }#define BLT		{ EXT; OP_blt(); NRET; }#define DIFFERENCE	{ EXT; OP_difference(); NRET; }#define PLUS2		{ EXT; OP_plus2(); NRET; }#define QUOTIENT 	{ EXT; OP_quot(); NRET; } #define TIMES2		{ EXT; OP_times2(); NRET; } #define IDIFFERENCE	{ EXT; OP_difference(); NRET; }#define IPLUS2		{ EXT; OP_plus2(); NRET; }#define IQUOTIENT 	{ EXT; OP_quot(); NRET; } #define ITIMES2		{ EXT; OP_times2(); NRET; } #define	GREATERP	{ EXT; OP_greaterp(); NRET; }#define	IGREATERP	{ EXT; OP_greaterp(); NRET; }#define IPLUS_N(n)	{ EXT; OP_iplusn(); NRET; }#define IDIFFERENCE_N(n) { EXT; OP_idifferencen(); NRET; }#define IREMAINDER 	{ EXT; OP_remainder(); NRET; }#define LOGOR		{ EXT; OP_logor(); NRET; } #define LOGAND		{ EXT; OP_logand(); NRET; }#define LOGXOR		{ EXT; OP_logxor(); NRET; }#define LRSH1		{ EXT; OP_lrsh1(); NRET; }#define LRSH8		{ EXT; OP_lrsh8(); NRET; }#define LLSH1		{ EXT; OP_llsh1(); NRET; }#define LLSH8		{ EXT; OP_llsh8(); NRET; }#define LSH		{ EXT; OP_lsh(); NRET; }#define ADDBASE 	{ EXT; OP_addbase(); NRET; }#define GCREF		{ EXT; OP_gcref(); NRET; }#define ASSOC		{ EXT; OP_assoc(); NRET; }#define FMEMB		{ EXT; OP_fmemb(); NRET; }#define CREATECELL	{ EXT; OP_createcell(); NRET; }#define BIN								\{									\register Stream *stream68k; /* stream instance on TOS */		\register  char *buff68k;     /* pointer to BUFF */			\									\  if ( GetTypeNumber(TOPOFSTACK) == TYPE_STREAM ) {			\	stream68k=(Stream *) Addr68k_from_LADDR(TOPOFSTACK);		\	if( ( !stream68k->BINABLE ) ||					\	    (  stream68k->COFFSET >=					\	       stream68k->CBUFSIZE   ) ) goto op_ufn;			\									\	/* get BUFFER instance */					\	buff68k =(char *)Addr68k_from_LADDR(stream68k->CBUFPTR);	\									\	/* get BYTE data and set it to TOS */				\	TOPOFSTACK = (S_POSITIVE |					\		      (Get_BYTE(buff68k + (stream68k->COFFSET)++)) );	\	nextop1;							\	}								\  else	goto op_ufn;							\}#define LISTGET		{ EXT; OP_listget(); NRET; }#define STKSCAN		{ EXT; OP_stkscan(); NRET; }#ifdef RECLAIMINC#define RECLAIMCELL	{ TOPOFSTACK = gcreclaimcell(TOPOFSTACK); nextop1; }#else#define RECLAIMCELL	{ goto op_ufn; }#endif#define GCSCAN1		{ EXT; OP_gcscan1(); NRET; }#define GCSCAN2		{ EXT; OP_gcscan2(); NRET; }#define ARG0		{ EXT; OP_arg0(); NRET; }#define CONTEXTSWITCH	{ EXT; OP_contextsw(); RET; 			\			  /*CHECK_INTERRUPT;*/ CLR_IRQ;			\			  NATIVE_NEXTOP0; }#define PILOTBITBLT	{ EXT; OP_pilotbitblt(); NRET; }#define UBFLOAT3(n)	{ goto op_ufn; }#define EQLOP		{ EXT; OP_eqlop(); NRET; }#define DRAWLINE	{ EXT; OP_drawline(); NRET; }/* JRB - removed CHECK_INTERRUPT from NOP macro */#define	NOP		{ nextop1; }#define RESLIST(n)	{ goto op_ufn; }/* ***** THESE USE THE NEWER NATIVE INTERFACE ROUTINES ***** */#define FINDKEY(x)							\		{							\		 TOPOFSTACK = N_OP_findkey(TOPOFSTACK, x);		\		 nextop2;						\		}#define RPLPTR(n)							\		{							\		 TOPOFSTACK = N_OP_rplptr(POP_TOS_1, TOPOFSTACK, n);	\		 nextop2;						\		}#define GVAR_(atom_index)						\		{							\		 TOPOFSTACK = N_OP_gvar_(TOPOFSTACK, atom_index);	\		 nextop3;						\		}/**#define BIND	{							\		 CSTKPTR = (LispPTR *) N_OP_bind(CSTKPTR, TOPOFSTACK, 	\				Get_BYTE(PCMAC+1), Get_BYTE(PCMAC+2));	\		 TOPOFSTACK = *CSTKPTR;					\		 nextop3;						\		}**/#define BIND	{register int n1;					\		register int n2;					\		register LispPTR *ppvar;				\		register int i;						\		n1 = Get_BYTE(PCMAC+1) >> 4;				\		n2 = Get_BYTE(PCMAC+1) & 0xf;				\		ppvar = (LispPTR *)PVAR + 1 + Get_BYTE(PCMAC+2);	\		for(i=0; i<n1; i++){ *--ppvar = NIL_PTR; }		\		if(n2 == 0){						\			*CSTKPTR++ = TOPOFSTACK;			\		}else{							\			*--ppvar = TOPOFSTACK;				\			for(i=1; i<n2; i++) { *--ppvar = *(--CSTKPTR); }	\		}							\		i = ~(n1 + n2);						\		TOPOFSTACK = (i<<16) | (Get_BYTE(PCMAC+2)<<1);		\		nextop3;						\		}/**#define UNBIND	{							\		 CSTKPTR = (LispPTR *) N_OP_unbind(CSTKPTR);		\		 nextop1;						\		}**/#define UNBIND	{register DLword num;					\		register LispPTR *ppvar;				\		register int	i;				\		register LispPTR value;				\		for(; !( *--CSTKPTR & 0x80000000 ););		\		value = *CSTKPTR;			\		num = (DLword) ~(value>>16);			\		ppvar = (LispPTR *)((DLword *)PVAR + 2 + GetLoWord(value));\		for(i=0;i<num;++i){*--ppvar = 0xffffffff;}		\		nextop1;						\		}/**#define DUNBIND	{							\		 CSTKPTR = (LispPTR *) N_OP_dunbind(CSTKPTR, TOPOFSTACK);\		 POP;							\		 nextop1;						\		}**/#define DUNBIND	{register DLword num;					\		register LispPTR *ppvar;				\		register int	i;				\		register LispPTR value;				\		if(TOPOFSTACK & 0x80000000){ 				\		  num =(DLword) ~(TOPOFSTACK>>16);			\		  if(num != 0){						\		    ppvar = (LispPTR *)((DLword *)PVAR + 2 + GetLoWord(TOPOFSTACK)); \		    for(i=0;i<num;++i) { *--ppvar = 0xffffffff; }		\		  }							\		}else{							\		  for(; !( *--CSTKPTR & 0x80000000 ););	\		  value = *CSTKPTR;			\		  num = (DLword) ~(value>>16);			\		  ppvar = (LispPTR *)((DLword *)PVAR + 2 + GetLoWord(value));\		  for(i=0;i<num;++i) { *--ppvar = 0xffffffff; }	\		}							\		POP;							\		nextop1;						\		}#define HILOC								\		{							\		 TOPOFSTACK = GetHiWord(TOPOFSTACK) | S_POSITIVE;	\		 nextop1;						\		}#define LOLOC								\		{							\		 TOPOFSTACK = GetLoWord(TOPOFSTACK) | S_POSITIVE;	\		 nextop1;						\		}/**#define GETBITS_N_M(a, b)						\		{							\		 TOPOFSTACK = N_OP_getbitsnfd(TOPOFSTACK, a, b);	\		 nextop3;						\		}#define PUTBITS_N_M(a,b) { EXT; OP_putbitsnfd(); NRET; }**/#define GETBITS_N_M(a, b)						\		{register int temp;					\		temp = 0xF & b;						\		TOPOFSTACK = S_POSITIVE | 				\		 (( (*(Addr68k_from_LADDR(0xFFFFFF & (TOPOFSTACK+a))))	\			>> (16 - ( (0xF & (b >> 4)) + temp + 1)) )	\			& n_mask_array[temp] );				\		 nextop3;						\		}#define PUTBITS_N_M(a, b)						\	{ int	base;							\	  register DLword	*pword;					\	  register int shift_size, field_size, fmask;			\	 if( (0xFFFF0000 & TOPOFSTACK) != S_POSITIVE ){ goto op_ufn; };	\	 base = 0xFFFFFF & POP_TOS_1;					\	 pword = (DLword*)Addr68k_from_LADDR( base + a );		\	 field_size = 0xF & b;						\	 shift_size = 15 - (0xF & (b >> 4)) - field_size;		\	 fmask = n_mask_array[field_size] << shift_size;		\	 *pword = ( (TOPOFSTACK << shift_size) & fmask) | (*pword & (~fmask));	\	 TOPOFSTACK = base;						\	 nextop3;							\	}#define CONS								\	{ TOPOFSTACK = N_OP_cons(POP_TOS_1, TOPOFSTACK);		\	  nextop1;							\	}#define MYALINK								\	{								\	 PUSH(((( CURRENTFX->alink) & 0xfffe)-FRAMESIZE) | S_POSITIVE);	\	 nextop1;							\	}#define MYARGCOUNT							\	{ register int arg_num;						\	  if (( CURRENTFX->alink & 1) == 0)				\	    arg_num = (int)((LispPTR *)(CURRENTFX) - 1);				\ 	  else								\	    arg_num = (int)(Stackspace + CURRENTFX->blink);		\	 PUSH( (DLword)((arg_num - (int)IVar) >> 2) | S_POSITIVE);	\	 nextop1;							\	}#define RCLK								\	{								\	 TOPOFSTACK = N_OP_rclk(TOPOFSTACK);				\	 nextop1;							\	}#define LISTP	{							\		 if((unsigned int)GetTypeNumber(TOPOFSTACK) != TYPE_LISTP)\    			TOPOFSTACK = NIL_PTR;				\		 nextop1;						\		}#define NTYPEX								\		{							\		 TOPOFSTACK = S_POSITIVE | (unsigned int)(GetTypeNumber(TOPOFSTACK));\		nextop1;						\		}#define TYPEP(n) 							\		{							\		  if((DLword)GetTypeNumber(TOPOFSTACK) != n)		\    			TOPOFSTACK = NIL_PTR;				\		 nextop2;						\		}#define TYPEMASK(n) 							\		{							\  		 if( ( ((DLword)GetTypeEntry(TOPOFSTACK))  & 		\		     ( (DLword)n << 8)) == 0)				\    			TOPOFSTACK = NIL_PTR;				\		 nextop2;						\		}#define INSTANCEP(atom_index)						\		{							\		 TOPOFSTACK = N_OP_instancep(TOPOFSTACK,atom_index);	\		 nextop3;						\		}#define STOREN(n)							\		{ *(CSTKPTR  - ((n+2) >> 1)) = TOPOFSTACK;		\		 nextop2;						\		}#define COPYN(n)							\		{ PUSH(*(CSTKPTR  - ((n+2) >> 1)));			\		 nextop2;						\		}#define POPN(n)									\		{TOPOFSTACK = *(CSTKPTR -= ((n)+1));	\		 nextop2;								\		}#define CLARITHEQUAL	{						\register int arg2;							\  arg2 = POP_TOS_1;							\  if ((TOPOFSTACK & 0xff0000) == S_POSITIVE)				\  {									\  if (arg2 == TOPOFSTACK) {TOPOFSTACK = ATOM_T; nextop1;}		\  if ((arg2 & 0xff0000) == S_POSITIVE) {TOPOFSTACK = NIL; nextop1;}	\  }									\  TOPOFSTACK = N_OP_eqq(arg2, TOPOFSTACK, ufn_2);			\  nextop1;								\}#define S_CHARACTER 0x70000#define AREF1	{							\LispPTR arrayarg;							\register LispPTR baseL;							\register int index;							\register DLword *arrayblk;						\DLword	*createcell68k();						\  arrayarg = POP_TOS_1;							\    if (GetTypeNumber(arrayarg) != TYPE_ONED_ARRAY) goto aref_ufn;	\    arrayblk = Addr68k_from_LADDR(arrayarg);				\    if ((TOPOFSTACK & 0xFFFF0000) != S_POSITIVE) goto aref_ufn;		\    index = TOPOFSTACK & 0xFFFF;					\    if (index >= *((DLword *)(arrayblk + 5))) goto aref_ufn;		\    index += *((DLword *)(arrayblk + 3));				\    baseL = *((LispPTR *)(arrayblk));					\    switch (0xFF & *((DLword *)(arrayblk + 2))) {			\      case 38: /* pointer : 32 bits */					\         TOPOFSTACK = *(((int *)Addr68k_from_LADDR(baseL)) + index);	\         nextop1;							\      case 20: /* signed : 16 bits */					\         TOPOFSTACK = (*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF;									\         if (TOPOFSTACK & 0x8000) TOPOFSTACK |= S_NEGATIVE;		\         else TOPOFSTACK |= S_POSITIVE;					\         nextop1;							\      case 67: /* Character :  8 bits */				\         TOPOFSTACK = S_CHARACTER | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF);								\         nextop1;							\      case 22: /* signed : 32 bits */					\         TOPOFSTACK = *(((int *)Addr68k_from_LADDR(baseL)) + index);	\         switch(TOPOFSTACK & 0xFFFF0000){				\           case 0:							\             TOPOFSTACK |= S_POSITIVE;					\             break;							\           case 0xFFFF0000:						\             TOPOFSTACK &= S_NEGATIVE;					\             break;							\           default:{register DLword *wordp;				\             wordp = createcell68k(TYPE_FIXP);				\             *((int *)wordp) = TOPOFSTACK;				\             (LispPTR)TOPOFSTACK = LADDR_from_68k(wordp);		\             }								\         }								\         nextop1;							\      case 0: /* unsigned : 1 bit per element */			\         TOPOFSTACK = S_POSITIVE | (((*(((char *)Addr68k_from_LADDR(baseL)) + (index >> 3))) >> (7 - (index & 7))) & 1);				\         nextop1;							\      case 3: /* unsigned : 8 bits per element */			\         TOPOFSTACK = S_POSITIVE | ((*(((char *)Addr68k_from_LADDR(baseL)) + index)) & 0xFF);								\         nextop1;							\      case 4: /* unsigned : 16 bits per element */			\         TOPOFSTACK = S_POSITIVE | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF);							\         nextop1;							\      case 54: /* Float : 32 bits */{register DLword *wordp;		\         wordp = createcell68k(TYPE_FLOATP);				\         *((int *)wordp) = *(((int *)Addr68k_from_LADDR(baseL)) + index);\         (LispPTR)TOPOFSTACK = LADDR_from_68k(wordp);			\         }								\         nextop1;							\      case 68: /* Character :  16 bits */				\         TOPOFSTACK = S_CHARACTER | ((*(((DLword *)Addr68k_from_LADDR(baseL)) + index)) & 0xFFFF);							\         nextop1;							\      case 86: /* XPointer : 32 bits */					\         TOPOFSTACK = *(((int *)Addr68k_from_LADDR(baseL)) + index);	\         nextop1;							\      default: /* Illegal or Unimplemented */				\        goto aref_ufn;							\    }/* end switch typenumber */					\aref_ufn:								\TOPOFSTACK = N_OP_aref1(arrayarg, TOPOFSTACK, ufn_2); nextop1;		\}#define DTEST(n)							\{									\	register int atom_index;					\	register struct dtd *dtd68k ;					\	atom_index = n;							\ for(dtd68k=(struct dtd *) GetDTD(GetTypeNumber(TOPOFSTACK));		\	atom_index != dtd68k->dtd_name ;				\	    dtd68k=(struct dtd *) GetDTD(dtd68k->dtd_supertype))	\	{								\		if( dtd68k->dtd_supertype == 0)				\		{							\		 goto op_ufn;						\		}							\	}								\nextop3;								\}/** #define FVAR(n)	{fvar_chain = PVar + n; goto fvar_code;}  **/#ifndef OLD_FVAR#define FVAR(n)	{							\register LispPTR *chain;						\chain = (LispPTR *) (PVar + n);						\if(((WBITS *)chain)->LSB){						\	PUSH(GetLongWord(Addr68k_from_LADDR(				\		0xFFFFFF & SWAP_WORDS(native_newframe(n >> 1)))));	\	nextop1;							\    }/* if(((WBITS */							\PUSH(GetLongWord(Addr68k_from_LADDR(0xFFFFFF & SWAP_WORDS(*chain))));	\nextop1;								\}#else#define FVAR(n)	{							\register DLword	*chain;							\chain = PVar + n;							\if(((WBITS *)chain)->LSB){						\	register struct fnhead	*apfnhead1;				\	register int	paoffset;					\	apfnhead1 = FuncObj;						\	paoffset  = ((int)chain - (int)PVar)>>2;			\	nnewframe(CURRENTFX,						\		  chain,						\		  (*(((DLword *)apfnhead1) +				\		     (  apfnhead1->fvaroffset				\		      - apfnhead1->nlocals				\		      + paoffset))));					\    }/* if(((WBITS */							\PUSH(									\  GetLongWord( 								\	Addr68k_from_LADDR(0xFFFFFF & (((*(chain+1))<<16) | *chain))));	\nextop1;								\}#endif#define FVAR_CODE_HERE /* no longer used, but macro referenced */#define FVAR_CODE_HERE_OBSOLETE						\fvar_code:								\{									\register DLword	*chain;							\chain = fvar_chain;							\if(((WBITS *)chain)->LSB){						\	register struct fnhead	*apfnhead1;				\	register int	paoffset;					\	apfnhead1 = FuncObj;						\	paoffset  = ((int)chain - (int)PVar)>>2;			\	nnewframe(CURRENTFX,						\		  chain,						\		  (*(((DLword *)apfnhead1) +				\		     (  apfnhead1->fvaroffset				\		      - apfnhead1->nlocals				\		      + paoffset))));					\    }/* if(((WBITS */							\PUSH(									\  GetLongWord( 								\	Addr68k_from_LADDR(0xFFFFFF & (((*(chain+1))<<16) | *chain))));	\nextop1;								\}/** #define FVARX(n)	{fvar_chain = PVar + n; goto fvarx_code;}  **/#ifndef OLD_FVAR#define FVARX(n)	{						\register LispPTR *chain;						\chain = (LispPTR *) (PVar + n);						\if(((WBITS *)chain)->LSB){						\	PUSH(GetLongWord(Addr68k_from_LADDR(				\		0xFFFFFF & SWAP_WORDS(native_newframe(n >> 1)))));	\	nextop2;							\    }/* if(((WBITS */							\PUSH(GetLongWord(Addr68k_from_LADDR(0xFFFFFF & SWAP_WORDS(*chain))));	\nextop2;								\}#else#define FVARX(n)	{						\register DLword	*chain;							\chain = PVar + n;							\if(((WBITS *)chain)->LSB){						\	register struct fnhead	*apfnhead1;				\	register int	paoffset;					\	apfnhead1 = FuncObj;						\	paoffset  = ((int)chain - (int)PVar)>>2;			\	nnewframe(CURRENTFX,						\		  chain,						\		  (*(((DLword *)apfnhead1) +				\		     (  apfnhead1->fvaroffset				\		      - apfnhead1->nlocals				\		      + paoffset))));					\    }/* if(((WBITS */							\PUSH(									\  GetLongWord( 								\	Addr68k_from_LADDR(0xFFFFFF & (((*(chain+1))<<16) | *chain))));	\nextop2;								\}#endif#define FVARX_CODE_HERE /* no longer used but macro referenced */#define FVARX_CODE_HERE_OBSOLETE					\fvarx_code:								\{									\register DLword	*chain;							\chain = fvar_chain;							\if(((WBITS *)chain)->LSB){						\	register struct fnhead	*apfnhead1;				\	register DLword *pfh;						\	register int	paoffset;					\	apfnhead1 = FuncObj;						\	pfh = (DLword *)apfnhead1;					\	paoffset = ((int)chain - (int)PVar)>>2;				\	nnewframe(CURRENTFX, chain, (*(pfh + (apfnhead1->fvaroffset + paoffset - apfnhead1->nlocals))));						\    }/* if(((WBITS */							\PUSH(									\  GetLongWord( 								\	Addr68k_from_LADDR(0xFFFFFF & (((*(chain+1))<<16) | *chain))));	\nextop2;								\}/* these opcodes UFN, but NEED to be DEFINED */#define CLFMEMB		{ goto op_ufn; }#define CLASSOC		{ goto op_ufn; }#define CLEQUAL		{ goto op_ufn; }#define ILEQUAL		{ goto op_ufn; }#define UBFLOAT1(n)	{ goto op_ufn; }#define UBFLOAT2(n)	{ goto op_ufn; }#define RESTLIST(n)	{ goto op_ufn; }#define FPLUS2		{ goto op_ufn; }#define FDIFFERENCE	{ goto op_ufn; }#define FTIMES2		{ goto op_ufn; }#define FQUOTIENT	{ goto op_ufn; }#define FGREATERP	{ goto op_ufn; }#define CLEQUAL		{ goto op_ufn; }#define MAKENUMBER 	{ goto op_ufn; }#define BOXIPLUS	{ goto op_ufn; }	#define BOXIDIFFERENCE	{ goto op_ufn; }						/* these opcodes are defined only in the Native Interface with assembly help */#define AREF2		{ goto op_ufn; }#define ASET1		{ goto op_ufn; }#define ASET2		{ goto op_ufn; }#define MISC3(n)	{ goto op_ufn; }#define MISC4(n)	{ goto op_ufn; }#define UFN_CALLS