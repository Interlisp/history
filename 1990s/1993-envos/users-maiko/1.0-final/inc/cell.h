/* This is G-file @(#) cell.h Version 2.5 (7/29/88). copyright Xerox & Fuji Xerox  *//* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Author	:	Takeshi Shimizu *			Hiroshi Hayata	 *//**********************************************************************//* 		File Name :	cell.h		Cell Manipulate Macros  				Date :		December 16, 1986 				Edited by :	Takeshi Shimizu				Changed :  24-Mar-87 take					17-APR-87 take					24-APR-87 take					08-MAY-87 take					19-may-87 take					 4-jun-87 take					15-jun-87 take(GetCons)					22-Sep-87 take(inc-alloccnt)					06-Oct-87 take(inc-alloccnt FIX)					09-Nov-87 Hayata(CheckAndCadr)					15-Apr-88 Tomtom(IncAllocCnt)*//**********************************************************************//*  CONS CELL (LISTP) definitions moved to lispemulater.h */  /* This Macro may produce the CDR code */ #define  CDRCODE(x)     LRSH (((int)x & 0x0ff000000) , 24)  /* This Macro may produce a pointer that points CAR cell */  /* On 68010,68000 This Macro does not effect *#define  CARFIELD(x)    ((int)x & 0x00ffffff)/* CDR-Codes defs */#define CDR_ONPAGE		128#define CDR_NIL			128#define CDR_INDIRECT		0#define CDR_MAXINDIRECT	127short  CarCdrError ;struct conspage  {              unsigned    count : 8   ;              unsigned    next_cell :8 ;              DLword  next_page ;      };/* Following MACROs for Conspage *//* lisp_ptr is LISP pointer, returns 68k ptr points struct conspage obj */#define Get_ConsPageBase(lisp_ptr)	(struct conspage *)Addr68k_from_LPAGE(POINTER_PAGEBASE(lisp_ptr))#define GetNewCell_68k(conspage68k)	 (ConsCell *)(((DLword *)(conspage68k)) + (unsigned)((conspage68k)->next_cell) )/* page : LISP page */#define GetCONSCount(page)	(((struct conspage *)Addr68k_from_LPAGE(page))->count)/* DEFs for DEFINITIONCELL */typedef struct definition_cell {	unsigned	ccodep	:	1 ;	unsigned	fastp	:	1 ;	unsigned	argtype	:	2 ;	unsigned	pseudocodep :	1 ;	unsigned	nil	:	3 ;	unsigned	defpointer :	24;} DefCell ;typedef struct pname_cell {	unsigned	pkg_index : 8 ;	unsigned	pnamebase : 24 ;} PNCell ;struct cadr_cell{		LispPTR car_cell;				/* Lisp address (word addressing) */		LispPTR cdr_cell;			/* Lisp address (word addressing) */};#define GetDEFCELL68k(index)	((LispPTR *)Defspace + (index) )#define GetVALCELL68k(index)	((LispPTR *)Valspace + (index))#define GetPnameCell(index)	((LispPTR *)Pnamespace + (index))/* When cadr() function is called, type check should be done. */#define	CheckAndCadr(sour, dest, ufn_num)	\		{if(GetTypeNumber(sour) != TYPE_LISTP){	\			ufn(ufn_num);	\			return;	\		}else	\			dest = cadr(sour);	\		}#define	N_CHECKANDCADR(sour, dest, ufn_addr)			\		{register LispPTR parm = sour;			\		 if(GetTypeNumber(parm) != TYPE_LISTP){		\			ERROR_EXIT(ufn_addr);			\		}else						\			dest = cadr(parm);			\		}#define	S_N_CHECKANDCADR(sour, dest, ufn_addr, tos)			\		{register LispPTR parm = sour;			\		 if(GetTypeNumber(parm) != TYPE_LISTP){		\			SAVE_ERROR_EXIT(tos,ufn_addr);			\		}else						\			dest = cadr(parm);			\		}