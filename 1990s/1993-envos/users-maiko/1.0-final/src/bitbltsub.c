/* This is G-file @(#) bitbltsub.c Version 2.4 (7/22/88). copyright Xerox & Fuji Xerox  *//* *	Copyright (C) 1988 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther :  Osamu Nakamura * */#include <stdio.h>#include <sys/ioctl.h>#include <pixrect/pixrect_hs.h>#include <sunwindow/window_hs.h>#include <sunwindow/win_ioctl.h>#include "lispemul.h"#include "lispglobal.h"#include "lispmap.h"#include "lisptypes.h"#include "emulglobal.h"#include "address68k.h"#include "address.h"#include "stack.h"#include "cell.h"#include "gc.h"#include "bitblt.h"#include "pilotbbt.h"#include "displaydata.h"/* same definition is in my.h */#define IsNumber(address)     ((*(MDStypetbl +(((address) & 0x0ffff00)>>9))) & 0x1000)		#define Expand4Bit(BITS)	\		((BITS) | ((BITS) << 4) | ((BITS) << 8) | ((BITS) << 12))		#define BITSPERWORD	(16)	/* temp definition	*/#define CURSORINP2( addrhi, x, w, h, y)	 (((((addrhi) == DISPALY_HI)||((addrhi) == DISPALY_HI+1))&& \	((x) < MOUSEXR)&&((x) + (w) > MOUSEXL)&&((y) < MOUSEYH)&&((y) + (h) > MOUSEYL)) ? \	 T : NIL) extern int LispWindowFd;/*****************************************************************(PUTPROPS \SETPBTFUNCTION MACRO	(OPENLAMBDA (BBT SourceType Operation)		(PROGN (replace (PILOTBBT PBTOPERATION) of BBT with				(SELECTQ Operation 					(ERASE 1) 					(PAINT 2) 					(INVERT 3) 					0))		       (replace (PILOTBBT PBTSOURCETYPE) of BBT with 		  	    (COND ((EQ (EQ SourceType (QUOTE INVERT)) 				       (EQ Operation (QUOTE ERASE))) 0) 		  		  (T 1))))))*****************************************************************/#define PixOperationLisp( SRCTYPE, OPERATION )	\	( SRCTYPE == INVERT_atom ? \		(OPERATION == REPLACE_atom ? PIX_NOT(PIX_SRC) : \		(OPERATION == PAINT_atom ? PIX_NOT(PIX_SRC) | PIX_DST : \		(OPERATION == ERASE_atom ? PIX_SRC & PIX_DST : \		(OPERATION == INVERT_atom ? PIX_NOT(PIX_SRC) ^ PIX_DST : ERROR)))) : \	/*  SRCTYPE == INPUT, TEXTURE */ \		(OPERATION == REPLACE_atom ? PIX_SRC : \		(OPERATION == PAINT_atom ? PIX_SRC | PIX_DST : \		(OPERATION == ERASE_atom ? PIX_NOT(PIX_SRC) & PIX_DST : \		(OPERATION == INVERT_atom ? PIX_SRC ^ PIX_DST : ERROR)))))typedef struct{	LispPTR	bmbase;	DLword	bmrasterwidth;	DLword	bmheight;	DLword	bmwidth;	DLword	bmbitperpixel;}BITMAP;extern struct pixrect *SrcPixRect, *DestPixRect, *TexturePixRect;extern struct pixrect *BlackTexturePixRect, *WhiteTexturePixRect;extern DLword	TEXTURE_atom; extern DLword	MERGE_atom; extern DLword	INPUT_atom; extern DLword	INVERT_atom; extern DLword	ERASE_atom; extern DLword	PAINT_atom; extern DLword	REPLACE_atom; int	sourcetype;	/* this var change to Global to Debug aid. */bitbltsub( args ) register LispPTR	*args;			/*	args[0] :	PILOTBBT		 *	args[1] :	SOURCEBITMAP		 *	args[2] :	SLX (SourceLeftX)		 *	args[3] :	STY (SourceTopY)		 *	args[4] :	DESTINATIONBITMAP		 *	args[5] :	DLX (DestinationLeftX)		 *	args[6] :	DTY (DestinationTopY)		 *	args[7] :	HIGHT		 *	args[8] :	SourceType		 *	args[9] :	Operation		 *	args[10] :	Texture		 *	args[11] :	WindowXOffset		 *	args[12] :	WindowYOffset		 */{	register PILOTBBT *pbt;	register BITMAP	*srcbm, *destbm;	int	slx, sty, dlx, dty,  height,		/* sourcetype,   this var change to Global to Debug aid. */		operation, 		texture, wxoffset, wyoffset;	int destbpl, sourcebpl, bptgrayoffset;	register int  pix_op;	int distance, h, w, y;	int pbtdisjointitems = 0, pbtbackward = 0; /* flags */	int displayflg = 0, desthi;	short *srcaddr, *destaddr, *base;	BITMAP *texture68k;		pbt = (PILOTBBT *)Addr68k_from_LADDR( args[0] );	srcbm	 = (BITMAP *)Addr68k_from_LADDR( args[1] );	slx 	 = (args[2] & 0xFFFF);	sty	 = (args[3] & 0xFFFF);	destbm	 = (BITMAP *)Addr68k_from_LADDR( args[4] );	dlx	 = (args[5] & 0xFFFF);	dty	 = (args[6] & 0xFFFF);	height	 = (args[7] & 0xFFFF);	sourcetype = ( args[8] == NIL_PTR ? INPUT_atom : args[8] );	operation = ( args[9] == NIL_PTR ? REPLACE_atom : args[9] );	texture = args[10];	wxoffset = ( args[11] == NIL_PTR ? 0 : args[11] & 0xFFFF );	wyoffset = ( args[12] == NIL_PTR ? 0 : args[12] & 0xFFFF );	/****start*****/	mpr_mdlinebytes                            (DestPixRect) = destbm->bmrasterwidth << 1;	destaddr = (short *)			 Addr68k_from_LADDR( ADDBASE( destbm->bmbase, 							    destbm->bmrasterwidth * dty));	(mpr_d(DestPixRect))->md_image = destaddr;	DestPixRect->pr_height = h = pbt->pbtheight;	DestPixRect->pr_width = destbpl = destbm->bmrasterwidth << 4;	w=pbt->pbtwidth; 	displayflg = CURSORINP2(GetHiWord(destbm->bmbase),dlx, (w), h, dty); /**** for DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG *****//*	displayflg = T;					*//**** for DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG *****/	if( sourcetype == TEXTURE_atom ){		slx = ((wxoffset) ? (dlx - wxoffset) : dlx) % BITSPERWORD;		if(IsNumber(texture)){			if( (texture &= 0xffff) == 0){				/* White Shade */				if(operation == REPLACE_atom){					pix_op = PIX_CLR;					goto clear_or_set;				}				goto white;			}			else if(texture == 0xffff){				/* Black Shade */				if(operation == REPLACE_atom){					pix_op = PIX_SET;					goto clear_or_set;				}				goto black_or_white;			}			else{ /* 4x4 */				TexturePixRect->pr_width = 16;					TexturePixRect->pr_height = h = 4;				base = (short *)((mpr_d(TexturePixRect))->md_image);				*base++ = Expand4Bit(((texture >> 12) & 0xf));				*base++ = Expand4Bit(((texture >> 8) & 0xf));				*base++ = Expand4Bit(((texture >> 4) & 0xf));				*base++ = Expand4Bit((texture & 0xf));				bptgrayoffset = (dty + wyoffset) % 4;								if(displayflg )					HideCursor;				pix_op = PixOperationLisp(sourcetype,operation);				pr_replrop( DestPixRect, dlx, 0, w, height, pix_op, 					    TexturePixRect, slx, bptgrayoffset);				if(displayflg )					ShowCursor;				return(0);			}		clear_or_set:				/* texture is Black Shade or White Shade, and operation is REPLACE			 * all bits in DestinationBitmap are set or clear.			 */			if(displayflg )				HideCursor;			if(pr_rop( DestPixRect, dlx, 0, 				   pbt->pbtwidth, h, pix_op, 				   DestPixRect, dlx, 0) != 0)				error("pilotbitblt: pr_rop failed\n");			if(displayflg )				ShowCursor;			return(0);		black_or_white:				/* texture is Black Shade or White Shade,			 * use BlackTexturePixRect as source			 */			if(displayflg )				HideCursor;			pix_op = PixOperationLisp( sourcetype, operation );			pr_replrop( DestPixRect, dlx, 0, w, h, pix_op,				    BlackTexturePixRect, 0, 0);			if(displayflg )				ShowCursor;			return(0);		white:			/* texture is White Shade,			 * use WhiteTexturePixRect as source			 */			if(displayflg )				HideCursor;			pix_op = PixOperationLisp( sourcetype, operation );			pr_replrop( DestPixRect, dlx, 0, w, h, pix_op,				    WhiteTexturePixRect, 0, 0);			if(displayflg )				ShowCursor;			return(0);		}		else{		/* A bitmap that is 16 bits wide. */			texture68k = (BITMAP *)Addr68k_from_LADDR(texture);			bptgrayoffset = (dty + wyoffset) 				% min( texture68k->bmheight, 16);			(mpr_d(SrcPixRect))->md_image =						(short *)Addr68k_from_LADDR(texture68k->bmbase);			SrcPixRect->pr_width = 16;				mpr_mdlinebytes(SrcPixRect) = 2;			SrcPixRect->pr_height = (h = texture68k->bmheight) > 16 ?							16 : h;			if(displayflg )				HideCursor;			pix_op = PixOperationLisp( sourcetype, operation );			pr_replrop( DestPixRect, dlx, 0, w, height, pix_op,				    SrcPixRect, slx, bptgrayoffset);			if(displayflg )				ShowCursor;			return(0);		}	}	/*	else if( sourcetype == MERGE_atom )		(RETURN (RAID "Hard bitblt case")) 	*/	else{ /* ; INPUT or INVERT	*/		mpr_mdlinebytes(SrcPixRect) = srcbm->bmrasterwidth << 1;		srcaddr = ( short *)			 Addr68k_from_LADDR( ADDBASE( srcbm->bmbase, 						      srcbm->bmrasterwidth * sty));		mpr_d(SrcPixRect)->md_image = srcaddr;		SrcPixRect->pr_height = h;		SrcPixRect->pr_width = sourcebpl = srcbm->bmrasterwidth << 4;		/* compute flags *//*		if( (srcbm == destbm) && (sty <= dty + height ) )			pbtdisjointitems = T;		if( (srcbm == destbm) && ((sty != dty ) ||						 ((slx <  dlx) && (dlx < slx + pbt->pbtwidth)))){			pbtbackward = T;			if( sty != dty )				pbtdisjointitems = T;		}*/				if(srcbm != destbm)			/* pbtdisjoint = T	*/;		else if(sty > dty){			if(sty > (dty+height))				/* pbtdisjoint = T	*/;			else				pbtdisjointitems = T;		}		else if(dty > (sty+ height))			/* pbtdisjoint = T	*/;		else if((sty != dty) ||			((slx < dlx) && (dlx < slx + pbt->pbtwidth))){			pbtbackward = T;			if( sty != dty )				pbtdisjointitems = T;		}		pix_op = PixOperationLisp( sourcetype, operation );		if(!displayflg)			 displayflg = CURSORINP2(GetHiWord(srcbm->bmbase),slx, w, h, sty);  		if(displayflg )			HideCursor;	      		if( pbtdisjointitems && pbtbackward ){			distance = abs(srcaddr - destaddr) / ((destbpl + 15) >> 4);			SrcPixRect->pr_height += distance;			if(pr_rop( SrcPixRect, dlx, distance,				   pbt->pbtwidth, h, pix_op, 				   SrcPixRect, slx, 0) != 0)				error("pilotbitblt: pr_rop failed\n");		}		else{			if(pr_rop( DestPixRect, dlx, 0, 				   pbt->pbtwidth, h, pix_op, 				   SrcPixRect, slx, 0) != 0)				error("pilotbitblt: pr_rop failed\n");		}		if(displayflg )			ShowCursor;	}}/* *	 * ********	BLTCHAR	BLTCHAR	BLTCHAR	BLTCHAR	********* * *//** \BLTCHAR ****(freplace (PILOTBBT PBTDESTBIT) of LOCAL1 with LEFT) (freplace (PILOTBBT PBTWIDTH) of LOCAL1 with (IDIFFERENCE RIGHT LEFT)) (freplace (PILOTBBT PBTSOURCEBIT) of LOCAL1 with 	(IDIFFERENCE 		(IPLUS (\GETBASE 				(ffetch (\DISPLAYDATA DDOFFSETSCACHE) of DISPLAYDATA) 				CHAR8CODE)			  LEFT)		CURX)) (\PILOTBITBLT LOCAL1 0)*********/#ifdef GETBASE#undef GETBASE#endif#define GETBASE(ptr,off)                (*((DLword *)(ptr) + (off)))typedef  struct {	unsigned nil1		: 8;	unsigned pilotbbt	: 24;	unsigned nil2		: 8;	unsigned displaydata	: 24;	unsigned nil3		: 16;	unsigned char8code	: 16;	unsigned nil4		: 16;	unsigned curx		: 16;	unsigned nil5		: 16;	unsigned left		: 16;	unsigned nil6		: 16;	unsigned right		: 16; } BLTC;	bltchar( args )register BLTC	*args;			/*	args[0] :	PILOTBBT		 *	args[1] :	DISPLAYDATA		 *	args[2] :	CHAR8CODE		 *	args[3] :	CURX		 *	args[4] :	LEFT		 *	args[5] :	RIGHT		 */{	register PILOTBBT  *pbt;	register DISPLAYDATA	*dspdata;	int 	x, y,  destbpl, sourcebpl, sourcebit, distance;	int	base;	register int displayflg;	unsigned int pix_op;		pbt	  = (PILOTBBT *)Addr68k_from_LADDR( args->pilotbbt );	dspdata	  = (DISPLAYDATA *)Addr68k_from_LADDR( args->displaydata );	(mpr_d(SrcPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,						     pbt->pbtsourcelo)) ;	(mpr_d(DestPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, 						      pbt->pbtdestlo )) ;	SrcPixRect->pr_width = sourcebpl = abs( pbt->pbtsourcebpl );	DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );	SrcPixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;		mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;	mpr_mdlinebytes(SrcPixRect) = ( sourcebpl +7) >>3;	 	base = GETBASE(Addr68k_from_LADDR(dspdata->ddoffsetscache), args->char8code);	sourcebit = base + args->left - args->curx ; 	/* if displayflg != 0 then source or destination is DisplayBitMap	 * Now we consider about only destination	 */	displayflg = cursorin(pbt->pbtdesthi, pbt->pbtdestlo, 			      args->left, (args->right - args->left), pbt->pbtheight, y, pbt->pbtbackward); /**** for DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG *****//*	displayflg = T;					*//**** for DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG *****/	pix_op = PixOperation( pbt->pbtsourcetype, pbt->pbtoperation );	if( displayflg )		HideCursor;	if(pr_rop( DestPixRect, args->left, 0, 			   (args->right - args->left),pbt->pbtheight , pix_op, 			   SrcPixRect, sourcebit, 0) != 0)		error("pilotbitblt: pr_rop failed\n");				if( displayflg )		ShowCursor;}/* y is already known	*//*** OBSOLATEint cursorin2( addrhi, x, w, h, y)DLword	addrhi;	register int	x, w, h, y;{		if((addrhi != DISPALY_HI)&&(addrhi != DISPALY_HI+1))		return( NIL );	if((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))		return( T );	else 		return( NIL );}*******OBSOLATE *****//******************************************************************//*	NEW BLTCHAR*//******************************************************************/#define BLTCHAR_argnum 3#define PUNT_TO_BLTCHAR {\	CurrentStackPTR +=(BLTCHAR_argnum-1)*DLWORDSPER_CELL ; \	ccfuncall(BLTCHAR_index,BLTCHAR_argnum,3);return;}typedef struct {	DLword	 nil;	unsigned charset	: 8;	unsigned char8code	: 8;	LispPTR displaystream; 	LispPTR displaydata;} BLTARG;#define FGetNum(ptr , place) { \	if(((ptr) & 0xff0000)== S_POSITIVE) {(place) = ((ptr) & 0xffff);}\	else if(((ptr) & 0xff0000)== S_NEGATIVE) {(place) = (int)((ptr)| 0xffff0000);}\	else {PUNT_TO_BLTCHAR;}}#define FGetNum2(ptr , place) { \	if(((ptr) & 0xff0000)== S_POSITIVE) {(place) = ((ptr) & 0xffff);}\	else if(((ptr) & 0xff0000)== S_NEGATIVE) {(place) = (int)((ptr)| 0xffff0000);}\	else {return(-1);}}LispPTR *TOPWDS68k;LispPTR BLTCHAR_index;newbltchar(args)register BLTARG *args;{    register DISPLAYDATA *displaydata68k;   register int right,left,curx;   register  PILOTBBT *pbt;   register int lmargin,rmargin,xoff;displaydata68k=(DISPLAYDATA*)Addr68k_from_LADDR(args->displaydata);if(displaydata68k->ddcharset != args->charset){	/* Currentry,this has BUG ,so I can't call it */	/*if(changecharset_display(displaydata68k,args->charset) ==-1)*/		{PUNT_TO_BLTCHAR;}}if(displaydata68k->ddslowprintingcase)	{PUNT_TO_BLTCHAR; /** \SLOWBLTCHAR--return;**/}FGetNum(displaydata68k->ddxposition,curx);FGetNum(displaydata68k->ddrightmargin,rmargin);FGetNum(displaydata68k->ddleftmargin,lmargin);FGetNum(displaydata68k->ddxoffset,xoff);right = curx + *((DLword*)Addr68k_from_LADDR		(displaydata68k->ddcharimagewidths+ args->char8code)) ;if((right> rmargin )&&(curx >lmargin))	{PUNT_TO_BLTCHAR;}if(args->displaystream != *TOPWDS68k)	{PUNT_TO_BLTCHAR;}{ register int  newpos; newpos = curx + *(DLword*)Addr68k_from_LADDR	(displaydata68k->ddwidthscache + args->char8code ); if ((0 <= newpos) && (newpos < 65536)) 	(LispPTR)(displaydata68k->ddxposition) =(LispPTR)(S_POSITIVE |newpos); else if(-65537 < newpos)	(LispPTR)(displaydata68k->ddxposition) = (LispPTR)(S_NEGATIVE | (0xffff & newpos)); else {PUNT_TO_BLTCHAR;}}	curx += xoff  ;	right +=xoff  ; if(right > ((int)displaydata68k->ddclippingright))	right=displaydata68k->ddclippingright;if(curx >  (int)(displaydata68k->ddclippingleft))	left = curx;else	left = displaydata68k->ddclippingleft;if(left <right) {	pbt= (PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt);	if(pbt->pbtheight !=0){	/****** OLD bltchar *****/	register int 	destbpl, sourcebpl, sourcebit;	int	base,y;	(mpr_d(SrcPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,					     pbt->pbtsourcelo)) ;	(mpr_d(DestPixRect))->md_image =(short *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, 					      pbt->pbtdestlo )) ;	SrcPixRect->pr_width = sourcebpl = abs( pbt->pbtsourcebpl );	DestPixRect->pr_width = destbpl = abs( pbt->pbtdestbpl );	SrcPixRect->pr_height = DestPixRect->pr_height = pbt->pbtheight;		mpr_mdlinebytes(DestPixRect) = (destbpl + 7) >> 3;	mpr_mdlinebytes(SrcPixRect) = ( sourcebpl +7) >>3;	 	base = GETBASE(Addr68k_from_LADDR(displaydata68k->ddoffsetscache), args->char8code);	sourcebit = base + left - curx ; 	if( cursorin(pbt->pbtdesthi, pbt->pbtdestlo, 	      left, (right - left), pbt->pbtheight, y, pbt->pbtbackward) ){		HideCursor;		if(pr_rop( DestPixRect, left, 0, 			   (right - left),pbt->pbtheight , 			PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ), 			   SrcPixRect, sourcebit, 0) != 0)			error("pilotbitblt: pr_rop failed\n");		ShowCursor;	 } /* display case */ 	else {		if(pr_rop( DestPixRect, left, 0, 			   (right - left),pbt->pbtheight , 			PixOperation( pbt->pbtsourcetype, pbt->pbtoperation ), 			   SrcPixRect, sourcebit, 0) != 0)			error("pilotbitblt: pr_rop failed\n");	 } /* else */		/****** OLD bltchar *****/		}	}} /* newbltchar *//******************************************************************/typedef struct {		LispPTR 	FONTDEVICE;		LispPTR 	SFObsolete1;		LispPTR 	FONTFAMILY;		LispPTR 	FONTSIZE;		LispPTR 	FONTFACE;		LispPTR 	SFObsolete2;		LispPTR 	SFObsolete3;		LispPTR 	SFObsolete4;		DLword 	SFObsolete5;		DLword 	SFObsolete6;		DLword 	SFAscent;		DLword 	SFDescent;		DLword 	SFHeight;		DLword 	ROTATION;		short		FBBOX;		short		FBBOY;		short		FBBDX;		short		FBBDY;		unsigned 	SFFACECODE		: 8;		unsigned	SFLKerns		:24;		LispPTR	SFRWidths;		LispPTR 	FONTDEVICESPEC;		LispPTR 	OTHERDEVICEFONTPROPS;		LispPTR 	FONTSCALE;		DLword	FONTAVGCHARWIDTH;		DLword	dum;		LispPTR 	FONTIMAGEWIDTHS;		LispPTR	FONTCHARSETVECTOR;		LispPTR	FONTEXTRAFIELD2;} FONTDESC;typedef struct {		LispPTR	WIDTHS;		LispPTR	OFFSETS;		LispPTR 	IMAGEWIDTHS;		LispPTR	CHARSETBITMAP;		LispPTR	YWIDTHS;		DLword	CHARSETASCENT;		DLword	CHARSETDESCENT;		LispPTR	LEFTKERN } CHARSETINFO;#define FRPLPTR(old , new) { \		GCLOOKUP(0x8000,DELREF, (old)); \		GCLOOKUP(0x8000,ADDREF, (new)); \		(old) = (new) ; }#define IMIN(x,y)  (((x) > (y)) ? (y) : (x))#define IMAX(x,y)	(((x) > (y)) ? (x) : (y))changecharset_display(displaydata68k,charset)register DISPLAYDATA *displaydata68k;DLword charset;{ register PILOTBBT *pbt68k; register FONTDESC *fontd68k; LispPTR csinfo; register CHARSETINFO *csinfo68k; BITMAP *bm68k; LispPTR *base68k; pbt68k=(PILOTBBT*)Addr68k_from_LADDR(displaydata68k->ddpilotbbt); fontd68k=(FONTDESC*)Addr68k_from_LADDR(displaydata68k->ddfont); base68k = (LispPTR*)Addr68k_from_LADDR(fontd68k->FONTCHARSETVECTOR); if((csinfo= *(base68k + charset)) == NIL ){	return(-1); /* punt case */ } csinfo68k =  (CHARSETINFO*)Addr68k_from_LADDR(csinfo);/* REF CNT */ FRPLPTR(displaydata68k->ddwidthscache , csinfo68k->WIDTHS);FRPLPTR(displaydata68k->ddoffsetscache , csinfo68k->OFFSETS);FRPLPTR(displaydata68k->ddcharimagewidths , csinfo68k->IMAGEWIDTHS); displaydata68k->ddcharset = charset; bm68k =(BITMAP*)Addr68k_from_LADDR( csinfo68k->CHARSETBITMAP); pbt68k->pbtsourcebpl = (bm68k->bmrasterwidth) << 4; if((displaydata68k->ddcharsetascent != csinfo68k->CHARSETASCENT) ||	(displaydata68k->ddcharsetdescent != csinfo68k->CHARSETDESCENT))  {		if(sfffixy(displaydata68k, csinfo68k,pbt68k )== -1)			return(-1);  } else { register LispPTR tmp;		tmp= bm68k->bmbase + 		(bm68k->bmrasterwidth * displaydata68k->ddcharheightdelta);		pbt68k->pbtsourcehi = tmp >> 16;		pbt68k->pbtsourcelo = tmp; } return(T);} /* changecharset_display */sfffixy(displaydata68k,csinfo68k,pbt68k) DISPLAYDATA *displaydata68k; CHARSETINFO *csinfo68k; PILOTBBT *pbt68k;{  int y; int chartop,top; BITMAP *bm68k; register LispPTR base,ypos,yoff; FGetNum2(displaydata68k->ddyoffset, yoff); FGetNum2(displaydata68k->ddyposition, ypos); y = ypos + yoff;  displaydata68k->ddcharsetascent=csinfo68k->CHARSETASCENT; chartop = y+ displaydata68k->ddcharsetascent; bm68k=(BITMAP*)Addr68k_from_LADDR(displaydata68k->dddestination); base = bm68k->bmbase; top = IMAX( IMIN(displaydata68k->ddclippingtop , chartop) , 0 ); base= base + (bm68k->bmrasterwidth * (bm68k->bmheight - top)); pbt68k->pbtdesthi= base >> 16; pbt68k->pbtdestlo= base ; bm68k=(BITMAP*)Addr68k_from_LADDR(csinfo68k->CHARSETBITMAP); base = bm68k->bmbase; displaydata68k->ddcharheightdelta=	IMIN( IMAX(chartop - top , 0), 65535 );/* allways positive */ base = base + bm68k->bmrasterwidth * displaydata68k->ddcharheightdelta; pbt68k->pbtsourcehi = base >> 16; pbt68k->pbtsourcelo = base ; displaydata68k->ddcharsetdescent= csinfo68k->CHARSETDESCENT;pbt68k->pbtheight = IMAX( top-(IMAX( y- displaydata68k->ddcharsetdescent,displaydata68k->ddclippingbottom)) ,0);} /* sfffixy *//******************************************************************/ccfuncall(atom_index,argnum,bytenum)  register unsigned int atom_index;   /* Atomindex for Function you want to invoke */  register int argnum;   /* Number of ARGS on TOS and STK */  register int bytenum;  /* Number of bytes of Caller's 			OPCODE(including multi-byte) */{  register struct definition_cell *defcell68k ;  /* Definition Cell PTR */  register short pv_num ; /* scratch for pv */  register struct fnhead *tmp_fn;  int rest ;  /* use for arignments */  int closurep=NIL;  register CClosure *closure68k;  /* Get Next Block offset from argnum */  CURRENTFX->nextblock = (LADDR_from_68k(CurrentStackPTR) & 0x0ffff)					- (argnum<<1)+4 /* +3  */;  /* Setup IVar */  IVar = Addr68k_from_LADDR((((LispPTR)(CURRENTFX->nextblock)) | STK_OFFSET)) ;  /* Set PC to the Next Instruction and save into FX */  CURRENTFX->pc = ((unsigned int)PC - (unsigned int)FuncObj) + bytenum ;   PushCStack ;  /* save TOS */  /* Get DEFCELL 68k address */  defcell68k =(struct definition_cell *) GetDEFCELL68k(atom_index) ;  tmp_fn = (struct fnhead *)Addr68k_from_LADDR( defcell68k->defpointer ) ;if((unsigned int)(CurrentStackPTR + tmp_fn->stkmin +STK_SAFE) >=  (unsigned int)EndSTKP )	{ LispPTR test;		test= *((LispPTR*)CurrentStackPTR);		DOSTACKOVERFLOW(argnum,bytenum-1);		S_CHECK(test==*((LispPTR*)CurrentStackPTR));	}  FuncObj = tmp_fn  ;  if( FuncObj->na >= 0 )  {	/* This Function is Spread Type */	/* Arguments on Stack Adjustment  */	rest = argnum - FuncObj->na ;		while(rest <0) { 	  PushStack(NIL_PTR) ;	  rest++;	}	CurrentStackPTR -= (rest<<1) ;  } /* if end */ /* Set up BF */CurrentStackPTR+=2; *(CurrentStackPTR) = BF_MARK ; *(CurrentStackPTR+1) = CURRENTFX->nextblock ;CurrentStackPTR+=2; /* Set up FX */ *(CurrentStackPTR) = FX_MARK; /* Now SET new FX */ ((struct frameex1 *)CurrentStackPTR)->alink = LADDR_from_68k(PVar); PVar = (DLword *)CurrentStackPTR + FRAMESIZE; ((struct frameex1 *)CurrentStackPTR)->lofnheader = 	(defcell68k->defpointer) & 0x0ffff ; ((struct frameex1 *)CurrentStackPTR)->hi2fnheader = 	((defcell68k->defpointer) & 0x0ff0000) >> 16 ; CurrentStackPTR = PVar ; /* Set up PVar area */ pv_num = FuncObj->pv+1 ; /* Changed Apr.27 */ while(pv_num > 0) {	*((LispPTR *)CurrentStackPTR) = 0x0ffff0000 ;	CurrentStackPTR += DLWORDSPER_CELL ;	*((LispPTR *)CurrentStackPTR) = 0x0ffff0000 ;	CurrentStackPTR += DLWORDSPER_CELL ;	pv_num--;  } /* Set PC points New Function's first OPCODE */ PC = (ByteCode *)FuncObj + FuncObj->startpc ;} /* end ccfuncall */