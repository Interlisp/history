/* This is G-file @(#) subr.c Version 2.25 (9/15/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) subr.c	2.25 9/15/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Author :  Takeshi Shimizu * *//***********************************************************//*		File Name :	subr.c		Including	:	OP_subrcall		Created	:	May 12, 1987 Takeshi Shimizu		Changed :	May 15 87 take		Changed :	Jun 2 87 NMitani				Jun. 5 87 take				Jun. 29 87 NMitani				Oct. 13 87 Hayata				Oct. 16 87 take				Nov. 18 87 Matsuda				Dec. 17 1987 Tomtom*//***********************************************************/ #include "lispemul.h"#include "address.h"#include "address68k.h"#include "lisptypes.h"#include "lispmap.h"#include "emulglobal.h"#include "lispglobal.h"#include "cell.h"#include "stack.h"#include "arith.h"#include "subrs.h"/***********************************************************//*	Func Name  :	OP_subrcall	Last Modify :	13-Oct 1987 take*//***********************************************************/#ifndef NOASMextern int *c_ret_to_dispatch;extern int *ret_to_dispatch;#endifextern  LispPTR Uraid_mess;LispPTR subr_lisperror(); /* 0377 */char *atom_to_str(atom_index)	LispPTR atom_index;{	PNCell *pnptr;	char *pname_base;	pnptr = (PNCell *) GetPnameCell(atom_index);	pname_base = (char *) Addr68k_from_LADDR(pnptr->pnamebase);	return(pname_base+1);} /*atom_to_str*/#define POP_SUBR_ARGS {if (( arg_num = (argnum = (Get_BYTE(PC+2)))) > 0) \     { while(arg_num >0) \	 PopStackTo(args[--arg_num]); \     }}OP_subrcall(){  static LispPTR args[30];  int  arg_num, argnum;  int i;#ifdef TRACE  printf("TRACE: OP_subrcall() \n");#endif  PushCStack; /* save TOS in memory *//*** if (( arg_num = (argnum = (Get_BYTE(PC+2)))) > 0)     {       while(arg_num >0)	 PopStackTo(args[--arg_num]);            } ***/    switch(Get_BYTE(PC+1))  {	case sb_SHOWDISPLAY  :POP_SUBR_ARGS;			DSP_showdisplay(args);			break;/* showdisplay */	case sb_DSPBOUT  :	POP_SUBR_ARGS;			DSP_dspbout( args );			break; /*dspbout */	case  sb_RAID :	POP_SUBR_ARGS;			Uraid_mess= args[0];			PC+= 3; /* for the case of hardreset */			error("URAID Called:");			Uraid_mess=NIL;			TopOfStack =NIL;			return; /* Direct return;avoid to increment PC */			break;	/* for Local File System */	case  sb_UFS_OPENFILE :	POP_SUBR_ARGS;			TopOfStack = UFS_openfile(args);			break;	case  sb_UFS_CLOSEFILE :	POP_SUBR_ARGS;			TopOfStack = UFS_closefile(args);			break;	case  sb_UFS_GETFILENAME :	POP_SUBR_ARGS;			TopOfStack = UFS_getfilename(args);			break;	case  sb_UFS_DELETEFILE :	POP_SUBR_ARGS;			TopOfStack = UFS_deletefile(args);			break;	case  sb_UFS_RENAMEFILE :	POP_SUBR_ARGS;			TopOfStack = UFS_renamefile(args);			break;	case  sb_UFS_READPAGES :	POP_SUBR_ARGS;			TopOfStack = UFS_readpage(args);			break;	case  sb_UFS_WRITEPAGES :	POP_SUBR_ARGS;			TopOfStack = UFS_writepage(args);			break;	case  sb_UFS_GETSIZE :	POP_SUBR_ARGS;			TopOfStack = UFS_getsize(args);			break;	case  sb_UFS_READDIR :	POP_SUBR_ARGS;			TopOfStack = UFS_readdir(args);			break;	case  sb_UFS_DIRECTORYNAMEP :	POP_SUBR_ARGS;			TopOfStack = UFS_directorynamep(args);			break;	case  sb_UFS_GETFILEINFO :	POP_SUBR_ARGS;			TopOfStack = UFS_getfileinfo(args);			break;	case  sb_UFS_DIRSIZE :	POP_SUBR_ARGS;			TopOfStack = UFS_dirsize(args);			break;	case  sb_UFS_CHANGEDIR :	POP_SUBR_ARGS;			TopOfStack = UFS_changedir(args);			break;	case  sb_UFS_GETFREEBLOCK:	POP_SUBR_ARGS;			TopOfStack = UFS_getfreeblock(args);			break;	case  sb_UFS_SETFILEINFO:	POP_SUBR_ARGS;			TopOfStack = UFS_setfileinfo(args);			break;	/* for Timer */	case  sb_SETUNIXTIME :	POP_SUBR_ARGS;			TopOfStack = subr_settime(args);			break;	case  sb_GETUNIXTIME :	POP_SUBR_ARGS;			TopOfStack = subr_gettime(args);			break;	case 062 :	POP_SUBR_ARGS;			TopOfStack = subr_copytimestats(args);			break;	/* for Ether */	case sb_CHECK_SUM :POP_SUBR_ARGS;			 TopOfStack = check_sum(args);			break;	case  sb_ETHER_SUSPEND :	POP_SUBR_ARGS;			TopOfStack = ether_suspend(args);			break;	case  sb_ETHER_RESUME :	POP_SUBR_ARGS;			TopOfStack = ether_resume(args);			break;	case  072 :	POP_SUBR_ARGS;			TopOfStack = ether_ctrlr(args);			break;	case  sb_ETHER_RESET : POP_SUBR_ARGS;				TopOfStack = ether_reset(args);			break;	case  sb_ETHER_GET : POP_SUBR_ARGS;				TopOfStack = ether_get(args);			break;	case  sb_ETHER_SEND : POP_SUBR_ARGS;				TopOfStack = ether_send(args);			break;	case  sb_ETHER_SETFILTER : POP_SUBR_ARGS;				TopOfStack = ether_setfilter(args);			break;	case  077: POP_SUBR_ARGS;				TopOfStack = check_ether();			break;	/* for Display */	case sb_DSPCURSOR : POP_SUBR_ARGS;				DSP_Cursor(args, argnum);			break;	case sb_SETMOUSEXY : POP_SUBR_ARGS;				DSP_SetMousePos(args);			break;	case sb_DSP_VIDEOCOLOR : POP_SUBR_ARGS;				TopOfStack = DSP_VideoColor(args);			break;	case sb_DSP_SCREENWIDTH : POP_SUBR_ARGS;				TopOfStack = DSP_ScreenWidth(args);			break;	case sb_DSP_SCREENHEIGHT : POP_SUBR_ARGS;				TopOfStack = DSP_ScreenHight(args);			break;  	/***  bitbltsub, bltchar ***/	case sb_BITBLTSUB : POP_SUBR_ARGS;			bitbltsub(args);			break;	case sb_BLTCHAR : CurrentStackPTR -= 12; /* argnum * DLwordsperCell*/			bltchar(CurrentStackPTR+2);			break;	 	case sb_NEW_BLTCHAR :  CurrentStackPTR -= 6;			newbltchar(CurrentStackPTR+2);			break;	/* for K/B */	case 0120 : POP_SUBR_ARGS;				KB_beep(args);			break;	case 0121 : POP_SUBR_ARGS;				KB_setmp(args);			break;	case sb_KEYBOARDSTATE : POP_SUBR_ARGS;				KB_enable(args);			break;	case sb_VMEMSAVE:  POP_SUBR_ARGS;						{			  /* Use value of environment variable if defined */			  char *getenv();			  char *def;			  TopOfStack =			    /* Officially should test against NULL, not 0,			       but NULL is defined in stdio.h which we			       otherwise don't need.  (It really should			       be defined somewhere else since a number			       of non-stdio routines use it.) */			    vmem_save((def = getenv("LDEDESTSYSOUT")) == 0 ?			  		"~/lisp.virtualmem" : def);			}			/* temp file name */			break;	case sb_LISPFINISH:	case sb_LISP_FINISH : POP_SUBR_ARGS;		if((argnum>0)&&(args[0]==S_POSITIVE))		/* 8/03/88 This branch impossible to take, subr has no args */			{TopOfStack=suspend_lisp(args);}		else	lisp_finish();			break;	case 0133 : POP_SUBR_ARGS;				TopOfStack = newpage(args[0]);			break;	case 0134 : POP_SUBR_ARGS;			     dogc01();       /* This function is caller of main3. */			break;	case 0135 : POP_SUBR_ARGS;			     doreclaim();    /* This function is top-level on GC. */			break;			/* read & write a abs memory address */	case sb_NATIVE_MEMORY_REFERENCE : POP_SUBR_ARGS;							switch (args[0] & 0xffff) {			case 00: 				{register int iarg;				if (argnum != 2) goto ret_nil;				N_GETNUMBER(args[1], iarg, ret_nil);				ARITH_SWITCH(*((LispPTR *) iarg), TopOfStack);				break;				}						case 01: 				{register int iarg,iarg2;				if (argnum != 3) goto ret_nil;				N_GETNUMBER(args[1], iarg, ret_nil);				N_GETNUMBER(args[2], iarg2, ret_nil);				*((LispPTR *) iarg) = iarg2;				break;				}#ifndef NOASM			case 02: 	/* get an emulator address */				{register int iarg;				if (argnum != 2) goto ret_nil;				switch (args[1] & 0xffff) {				case 00: iarg = (int) &c_ret_to_dispatch;					 break;				case 01: iarg = (int) &ret_to_dispatch;					 break;				}				ARITH_SWITCH(iarg, TopOfStack);				break;				}#endif			}			break;	ret_nil: 	TopOfStack = NIL_PTR;			break;			/* old load native (should be superceeded) */	case sb_OLD_COMPILE_LOAD_NATIVE : POP_SUBR_ARGS;				{			TopOfStack = do_system_call(args[0]);			break;			};	case sb_GET_NATIVE_ADDR_FROM_LISP_PTR: POP_SUBR_ARGS;						{ARITH_SWITCH(Addr68k_from_LADDR(args[0]), TopOfStack);			 break;			}	case sb_GET_LISP_PTR_FROM_NATIVE_ADDR: POP_SUBR_ARGS;						{register int iarg;			 N_GETNUMBER(args[0], iarg, ret_nil);			 ARITH_SWITCH(LADDR_from_68k(iarg), TopOfStack);			 break;			};	case sb_LOAD_NATIVE_FILE: POP_SUBR_ARGS;			 /* to become OBSOLETE */			{TopOfStack = dynamic_load_code(args);		 	 break;			}	case  sb_DSK_OPENFILE : POP_SUBR_ARGS;				TopOfStack = DSK_openfile(args);			break;	case  sb_DSK_CLOSEFILE : POP_SUBR_ARGS;				TopOfStack = DSK_closefile(args);			break;	case  sb_DSK_GETFILENAME : POP_SUBR_ARGS;				TopOfStack = DSK_getfilename(args);			break;	case  sb_DSK_DELETEFILE : POP_SUBR_ARGS;				TopOfStack = DSK_deletefile(args);			break;	case  sb_DSK_RENAMEFILE : POP_SUBR_ARGS;				TopOfStack = DSK_renamefile(args);			break;	case  sb_DSK_READDIR : POP_SUBR_ARGS;				TopOfStack = DSK_readdir(args);			break;	case  sb_DSK_DIRECTORYNAMEP : POP_SUBR_ARGS;				TopOfStack = DSK_directorynamep(args);			break;	case  sb_DSK_GETFILEINFO : POP_SUBR_ARGS;				TopOfStack = DSK_getfileinfo(args);			break;	case  sb_DSK_DIRSIZE : POP_SUBR_ARGS;				TopOfStack = DSK_dirsize(args);			break;	case  sb_DSK_CHANGEDIR : POP_SUBR_ARGS;				TopOfStack = DSK_changedir(args);			break;	case  sb_DSK_SETFILEINFO : POP_SUBR_ARGS;				TopOfStack = DSK_setfileinfo(args);			break;/* Communications with Unix Subprocess */        case sb_UNIX_HANDLECOMM: POP_SUBR_ARGS;			     TopOfStack = Unix_handlecomm(args);		        break;        case 0166: POP_SUBR_ARGS;			      {register int temp;			 N_GETNUMBER(TopOfStack, temp, badarg);			 temp = (int) Addr68k_from_LADDR(temp);			 ARITH_SWITCH(temp, TopOfStack);			 break;		badarg:	TopOfStack = NIL;			break;			}/* OS message print routines */ 	case sb_MESSAGE_READP: POP_SUBR_ARGS;			      TopOfStack = mess_readp();			break;	case sb_MESSAGE_READ: POP_SUBR_ARGS;			      TopOfStack = mess_read(args);			break;						/* RPC routines */      case sb_RPC_CALL: POP_SUBR_ARGS;			 TopOfStack = rpc(args);			break;/* Unix username/password utilities */      case sb_CHECKBCPLPASSWORD: POP_SUBR_ARGS;			 /* Check Unix username/password */			TopOfStack = check_unix_password(args);			break;      case sb_UNIX_USERNAME: POP_SUBR_ARGS;			  /* Get Unix username */			TopOfStack = unix_username(args);			break;      case sb_UNIX_FULLNAME: POP_SUBR_ARGS;				/* Get Unix person-name (GECOS field) */			TopOfStack = unix_fullname(args);			break;      case sb_UNIX_GETENV: POP_SUBR_ARGS;		/* get value of environment variable, or NIL */		TopOfStack = unix_getenv(args); break;      case sb_UNIX_GETPARM: POP_SUBR_ARGS;		/* get built in parameter */		TopOfStack = unix_getparm(args); break;      case sb_SUSPEND_LISP: POP_SUBR_ARGS;				/* Suspend Maiko */			TopOfStack = suspend_lisp(args);			break;      case 0200 : POP_SUBR_ARGS;		  /* MONITOR CONTROL STOP(0) or RESUME(1) */			moncontrol(args[0] & 1);			break;      case sb_USER_SUBR: POP_SUBR_ARGS;			{register LispPTR user_subr, user_args;			 N_GETNUMBER(args[0], user_subr, ret_nil);			 N_GETNUMBER(args[1], user_args, ret_nil);			 TopOfStack = UserSubr(user_subr, user_args, &args[2]);			}			break;      default :		{		char errtext[200];		sprintf ( errtext,          	    "OP_subrcall: Invalid alpha byte 0%o", ((*(PC+1)) & 0xff));		printf  ( "%s\n", errtext );		error(errtext);		break;		}   }/* switch end */PC += 3;}/* OP_subrcall */