/* This is G-file @(#) keyevent.c Version 2.9 (9/14/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) keyevent.c	2.9 9/14/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Author	:	Osamu Nakamura	 *//* *	This file contains the noutines that intenface Lisp to the *	Sun keyboand and mouse. * */#include	<stdio.h>#include	<signal.h>#include	<sys/file.h>#include	<sys/ioctl.h>#include	<sys/time.h>#include	<sunwindow/window_hs.h>#include	<sunwindow/win_ioctl.h>#include <suntool/window.h>#include <ctype.h>#include	<sundev/kbio.h>#include "lispemul.h"#include "lispglobal.h"#include "address68k.h"#include "address.h"#include "stack.h"#include "iopage.h"#include "ifpage.h"#define	MOUSE_LEFT	13#define	MOUSE_MIDDLE	15#define	MOUSE_RIGHT	14#define	CAPSKEY		16/* for contextsw */#define AS_OPCODE	1#define AS_CPROG	0#define MouseMove(x,y) {(*((DLword *)EmMouseX68K)) = x;\			(*((DLword *)EmMouseY68K)) = y;}#define PUTBASEBIT68K(base68k, offset, bitvalue ) { \	if( bitvalue) \		*((DLword*)(base68k) + (((u_short)(offset))>>4 )) \				|= 1 << (15 - ((u_short)(offset))%BITSPER_DLWORD); \	else	 \		*((DLword*)(base68k) + (((u_short)(offset))>>4 ))  \				&= ~( 1 << (15 - ((u_short)(offset)) %BITSPER_DLWORD)); \	}extern DLword  *EmMouseX68K, *EmMouseY68K, *EmKbdAd068K, *EmRealUtilin68K,*EmUtilin68K;extern DLword  *EmKbdAd168K,*EmKbdAd268K,*EmKbdAd368K,*EmKbdAd468K,*EmKbdAd568K;extern u_char SUNLispKeyMap[];extern u_int   LispReadFds, LispWindowFd;extern int	ether_fd;extern int     TTY_Fd, RS232C_Fd;static	struct timeval	SelectTimeout = {	0, 0	};extern MISCSTATS *MiscStats; LispPTR *LASTUSERACTION68k; LispPTR *CLastUserActionCell68k; LispPTR *CURSORDESTHEIGHT68k; LispPTR *CURSORDESTWIDTH68k; LispPTR *CURSORHOTSPOTX68k; LispPTR *CURSORHOTSPOTY68k; LispPTR *SOFTCURSORUPP68k;extern DLword *EmCursorX68K;extern DLword *EmCursorY68K;#define HARDCURSORHEIGHT 16typedef struct {		unsigned nil : 8;		unsigned type: 8;		unsigned num : 16;} SNum;#define  IDiff(x68k,y68k)	(((SNum*)(x68k))->num - ((SNum*)(y68k))->num)#define TrackCursor(cx,cy)	{*CLastUserActionCell68k = MiscStats->secondstmp;\	*EmCursorX68K= cx;\	*EmCursorY68K= cy;}/* function that checks to see if more input is waiting on a file;	if some is, it bumps FileIOFlag so it'll get seen next time around *//* commented out is some code that would also clobber 	Irq_Stk_Check & Irq_Stk_End to force	a new interrupt as rapidly as possible; it causes odd behavior...	needs some study and thought *//* this is currently called EVERY time the timer expires. It checks for   keyboard input *//***********NEWLY ADDED************/typedef struct {		DLword read;		DLword write; } RING;#define RING_READ(head68k)	(((RING*)(head68k))->read)#define RING_WRITE(head68k)	(((RING*)(head68k))->write)	#define MAXKEYEVENT	4598#define MINKEYEVENT	2#define KEYEVENTSIZE	 12		/* for feature use */typedef struct {	DLword 	mousex;	DLword	mousey;	DLword	utilin;	DLword	kbdad0;	DLword	kbdad1;	DLword	kbdad2;	DLword	kbdad3;	DLword	kbdad4;	DLword	kbdad5;} IOState;typedef struct {	DLword W0;	DLword W1;	DLword W2;	DLword W3;	DLword WU;	DLword W4;	DLword W5;	int		time;	unsigned	mousestate	: 3;	unsigned	shift1		: 1;	unsigned	shift2		: 1;	unsigned	lock		: 1;	unsigned	ctrl		: 1;	unsigned	meta		: 1;	unsigned	font		: 1;	unsigned	usermode1	: 1;	unsigned	usermode2	: 1;	unsigned	usermode3	: 1;	unsigned	nil		: 4;	DLword	mousex;	DLword	mousey;} KBEVENT;#define DLMOUSEUP 	0#define DLMOUSEWAITING 	1#define DLMOUSENORMAL 	2#define MOUSE_ALLBITS	7 LispPTR *MOUSECHORDTICKS68k;#define KB_ALLUP		0xffff#define RCLK(place) {  struct timeval time;\					gettimeofday(&time,NULL);\					(place)=(time.tv_sec * 1000000)+time.tv_usec;}/**NEW GLOBAL***-> will be moved***/LispPTR *KEYBOARDEVENTQUEUE68k;LispPTR *KEYBUFFERING68k;int	MouseMoveFlg=0;int	KBDEventFlg=NIL;DLword *CTopKeyevent;LispPTR DOBUFFEREDTRANSITION_index;LispPTR INTERRUPTFRAME_index;LispPTR *TIMER_INTERRUPT_PENDING68k;LispPTR *PENDINGINTERRUPT68k;LispPTR ATOM_STARTED;LispPTR *PERIODIC_INTERRUPT68k;LispPTR *PERIODIC_INTERRUPT_FREQUENCY68k;LispPTR PERIODIC_INTERRUPTFRAME_index;LispPTR DORECLAIM_index;int URaid_req=NIL;/**** NEWLY ADDED END *****/getsignaldata(sig, code, scp)int sig, code;struct sigcontext *scp;{        struct inputevent event;        static int  rfds;#ifndef KBINT        rfds = LispReadFds;/* label and ifs not needed if only keyboard on SIGIO */getmore:         if(select(32, &rfds, NULL, NULL, &SelectTimeout) >= 0 ){                if( rfds & (1 << LispWindowFd) ) {#endif                    while( input_readevent(LispWindowFd, &event) >= 0 ){                        /*if(!kb_event( &event )) {goto getmore;};*/						if((KBDEventFlg+=kb_event( &event ))>0) {			  				/* immidiately request for IRQ check */							Irq_Stk_End=Irq_Stk_Check=0;						}					}#ifndef KBINT				}		}#endif} /* end getsignaldata *//* kb_event returns 1 if a keytransition happened, 0 if not. */int kb_event( event )register struct inputevent *event;{	register u_int  upflg;	int kn;	DLword w,r;	KBEVENT *kbevent;static DLword MouseState = DLMOUSEUP;	upflg = event_is_up( event );	switch( ((unsigned short)event->ie_code) ){		case LOC_MOVE:			MouseMove( event->ie_locx, event->ie_locy );			TrackCursor(event->ie_locx,event->ie_locy );			MouseMoveFlg=T;			return(0);		case MS_LEFT:			/*mouse_button( MOUSE_LEFT, upflg );*/			PUTBASEBIT68K( EmRealUtilin68K,MOUSE_LEFT , upflg );			break;					case MS_MIDDLE:			/*mouse_button( MOUSE_MIDDLE, upflg );*/			PUTBASEBIT68K( EmRealUtilin68K,MOUSE_MIDDLE , upflg );			break;					case MS_RIGHT:			/*mouse_button( MOUSE_RIGHT, upflg );*/			PUTBASEBIT68K( EmRealUtilin68K,MOUSE_RIGHT , upflg );			break;		default:	/* keystroke */			if((kn=SUNLispKeyMap[((unsigned short)event->ie_code)]) > -1)				kb_trans( kn, upflg );			else				printf("kb_event: unknown key number=%d\n",					event->ie_code );						break;	}; 	{	 do_ring:		if(((*EmKbdAd268K) & 2113) == 0)		 {/*Ctrl-shift-NEXT*/			error("******  EMERGENCY Interrupt ******");			*EmKbdAd268K=KB_ALLUP; /*reset*/			((RING*)CTopKeyevent)->read=0;  /* reset queue */			((RING*)CTopKeyevent)->write=MINKEYEVENT; 			/*return(0);*/		 } 		else if(((*EmKbdAd268K) & 2114) == 0)		     { /* Ctrl-Shift-DEL */			*EmKbdAd268K=KB_ALLUP; /*reset*/			URaid_req=T;			((RING*)CTopKeyevent)->read=0;  /* reset queue */			((RING*)CTopKeyevent)->write=MINKEYEVENT; 			/*return(0);*/		     }		r=RING_READ(CTopKeyevent);		w=RING_WRITE(CTopKeyevent);		if(r==w) /* event queqe FULL */			goto KBnext;		kbevent=(KBEVENT*)(CTopKeyevent+ w);		RCLK(kbevent->time);		kbevent->W0= *EmKbdAd068K;		kbevent->W1= *EmKbdAd168K;		kbevent->W2= *EmKbdAd268K;		kbevent->W3= *EmKbdAd368K;		kbevent->W4= *EmKbdAd468K;		kbevent->W5= *EmKbdAd568K;		kbevent->WU= *EmRealUtilin68K;		if(r==0) /* Queue was empty */			((RING*)CTopKeyevent)->read=w;		if(w >= MAXKEYEVENT)			((RING*)CTopKeyevent)->write = MINKEYEVENT;		else			((RING*)CTopKeyevent)->write = w + KEYEVENTSIZE; 	 KBnext:		if(*KEYBUFFERING68k ==NIL)			*KEYBUFFERING68k=ATOM_T; 	} /* if *EmRealUtilin68K end */ return(1); } kb_trans( keycode, upflg )u_short	keycode;u_short upflg;{ extern IFPAGE *InterfacePage;	if( keycode < 64 )	/* DLKBDAD0 ~ 3	*/		{PUTBASEBIT68K( EmKbdAd068K, keycode, upflg );}	else if( keycode >= 80 )/* DLKBDAD4, 5	*/		{PUTBASEBIT68K( EmKbdAd068K, keycode - 16, upflg );}	else if( keycode >= 64 && keycode < 80 )/* DLUTILIN	*/		{		  PUTBASEBIT68K( EmRealUtilin68K, (keycode & 15), upflg );		  PUTBASEBIT68K( EmUtilin68K, (keycode & 15), upflg );		}}