/* This is G-file @(#) bitblt.c Version 2.9 (8/18/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) bitblt.c      2.9 8/18/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Author :  Osamu Nakamura * */#include <stdio.h>#include <sys/ioctl.h>#include <sunwindow/window_hs.h>#include <sunwindow/win_ioctl.h>#ifdef WINDOW#include <suntool/sunview.h>#include <signal.h>#include <sunwindow/cms_mono.h>#include <suntool/canvas.h>#endif#include "lispemul.h"#include "lispglobal.h"#include "lispmap.h"#include "emulglobal.h"#include "address68k.h"#include "address.h"#include "pilotbbt.h"#include "display.h"#include "bitblt.h"#include "bb.h"extern int LispWindowFd;extern int DisplayWidth, DisplayHeight;extern struct pixrect *SrcPixRect, *DestPixRect, *TexturePixRect;extern struct cursor	CurrentCursor;/* DisplayLockArea specifies win_lock area when bitblt is operated * It specifies whole screen area. */extern struct winlock DisplayLockArea;#ifdef WINDOWextern Pixwin *Lisp_pw;extern struct pixrect *ScreenBitMap;#endifhidecursor(){	ioctl( LispWindowFd, WINLOCKSCREEN, &DisplayLockArea);}showcursor(){	ioctl( LispWindowFd, WINUNLOCKSCREEN, &DisplayLockArea);}/*****************************************************************************//*****************************************************************************//**									    **//**				N_OP_pilotbitblt			    **//**									    **//**	  The Native-code compatible version of the opcode for bitblt.	    **//**									    **//**									    **//*****************************************************************************//*****************************************************************************/LispPTR N_OP_pilotbitblt(pilot_bt_tbl, tos, error_addr)     LispPTR pilot_bt_tbl;     int tos;     int *error_addr;     {	register PILOTBBT  *pbt;	register DLword 	*srcbase, *dstbase;	int displayflg;	int	sx, dx, w, h, y, srcbpl, dstbpl, backwardflg;		pbt = (PILOTBBT *)Addr68k_from_LADDR(pilot_bt_tbl);	/* if displayflg != 0 then source or destination is DisplayBitMap */ 	displayflg = cursorin(pbt->pbtdesthi, pbt->pbtdestlo, 			      (dx=pbt->pbtdestbit),  			      (w=pbt->pbtwidth), (h=pbt->pbtheight), y,			      pbt->pbtbackward)  || 		     cursorin(pbt->pbtsourcehi, pbt->pbtsourcelo,  		     	      (sx=pbt->pbtsourcebit), w, h, y, 			      pbt->pbtbackward); 		     	srcbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtsourcehi,						     pbt->pbtsourcelo));	dstbase = (DLword *)Addr68k_from_LADDR( VAG2( pbt->pbtdesthi, 						      pbt->pbtdestlo ));	if( displayflg ) HideCursor;	srcbpl = pbt->pbtsourcebpl;	dstbpl = pbt->pbtdestbpl;	backwardflg = pbt->pbtbackward;{	/* NEW BITBLT CODE */variablessome_initwhile (num_lines_remaining-- > 0){ /* begin line loop */  if (gray)  {    do_src_gray_setup    do_gray_transfer  }  if (fwd)  {    F_do_src_setup    F_do_transfer  }  {    B_do_src_setup    B_do_transfer  }do_fpt:  {    do_partial_transfer    goto next_line;  }next_line:  if (gray)  {    do_gray_advance    continue;  }  if (fwd)  {    F_do_advance    continue;  }  {    B_do_advance    continue;  }} /* end line loop */}	if( displayflg) ShowCursor;	return(pilot_bt_tbl);     } /* end of N_OP_pilotbitblt */int cursorin  ( addrhi, addrlo, x, w, h, y, backward)     DLword	addrhi;		/* Lisp addr hi-word	*/     DLword	addrlo;		/* Lisp addr lo-word	*/     register int	x, w, h, y;     {	if (addrhi == DISPALY_HI)  y = addrlo / DisplayRasterWidth;	else if (addrhi == DISPALY_HI+1)	   y = (addrlo + DLWORDSPER_SEGMENT) / DisplayRasterWidth;	else return( NIL );	if(backward) y -= h;			if((x < MOUSEXR)&&(x + w > MOUSEXL)&&(y < MOUSEYH)&&(y + h > MOUSEYL))	   return( T );	else 	   return( NIL );     }