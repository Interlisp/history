/* This is G-file @(#) lowlevel1.c Version 2.2 (5/25/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) lowlevel1.c	2.2 5/25/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther	:	Hiroshi Hayata	 */#include <stdio.h>#include "lispemul.h"#include "lispglobal.h"#include "address68k.h"#include "lispmap.h"#include "emulglobal.h"int mask_array[16] = {	1, 3, 7, 0xf, 			0x1f, 0x3f, 0x7f, 0xff,			0x1ff, 0x3ff, 0x7ff, 0xfff,			0x1fff, 0x3fff, 0x7fff, 0xffff};#ifdef C_ONLY/************************************************************ OP_putbitsnfd	entry		PUTBITS.N.FD		OPCODE[0317]	1.	<<Enter>>		TopOfStack: NewValue		*((int *)(CurrentStackPTR)):	 base address.		alpha: 	word offset.		beta:		High nibble -- number of the first bit of the field				Low nibble  -- (number of the size of the fiel) - 1	2.	Data is @[TopOfStack + alpha]	3.	Shift and mask the data.	4.	Set the data at [TopOfStack + alpha].	5.	<<Exit>>		TopOfStack: 	??***********************************************************/OP_putbitsnfd(){int	base;DLword	*pword;register short first;register short size;register short fmask, fsmask;#ifdef	TRACE	printPC();	printf("TRACE: putbitsnfd()\n");#endif	base = 0xFFFFFF & *((LispPTR *)(CurrentStackPTR));	if( (0xFFFF0000 & TopOfStack ) != S_POSITIVE ){		error("OP_putbitsnfd\n");		/* goto UFN. */	}else{		pword = Addr68k_from_LADDR( base + (0xFF & (*(PC+1))) );				/* (*(++PC)) is alpha */		size = 0xFF & (*(PC+2));		first = 0xF & (size >> 4);	/* 0 <= fisrt <= 15 */		size &= 0xF;			/* 0 <= size <= 15 */#ifdef	DEBUG	if(first+size > 15)		printf("DEBUG: OP_getbitsnfd[Bad beta! data-%x, first-%x, size-%x]\n", *pword, first, size);#endif		fsmask = 0x8000;		fsmask = fsmask >> (first + size);		if(first == 0)			fmask = 0;		else{			fmask = 0x8000;			fmask = fmask >> (first - 1);		}		fmask ^= fsmask;		TopOfStack <<= (15 - first - size);		*pword = (TopOfStack & fmask) | ((*pword) & (~fmask));			/* Low word of TopOfStack -- new data (needs mask) */			/* (*pword) -- old data. (Other of replace field is avilable.) */	}	TopOfStack = base;	CurrentStackPTR -= 2;	PC+=3;}#else/************************************************************ N_OP_putbitsnfd	entry		PUTBITS.N.FD		OPCODE[0317]	1.	<<Enter>>		TopOfStack: NewValue		*((int *)(CurrentStackPTR)):	 base address.		alpha: 	word offset.		beta:		High nibble -- number of the first bit of the field				Low nibble  -- (number of the size of the fiel) - 1	2.	Data is @[TopOfStack + alpha]	3.	Shift and mask the data.	4.	Set the data at [TopOfStack + alpha].	5.	<<Exit>>		return: 	??***********************************************************/LispPTR N_OP_putbitsnfd(base_addr, data, word_offset, beta, error_addr)	int base_addr;	int word_offset;	register int beta;	int *error_addr;{register int	base;register DLword	*pword;register int shift_size, field_size, fmask;#ifdef	TRACE	printf("TRACE: N_putbitsnfd()\n");#endif	if( (0xFFFF0000 & data ) != S_POSITIVE ) { ERROR_EXIT(error_addr); };		base = 0xFFFFFF & base_addr;	pword = Addr68k_from_LADDR( base + word_offset );	field_size = 0xF & beta;	shift_size = 15 - (0xF & (beta >> 4)) - field_size;	fmask = mask_array[field_size] << shift_size;	*pword = ( (data << shift_size) & fmask)  |  ((*pword) & (~fmask));		return(base);}#endif/************************************************************ N_OP_getbitsnfd	entry		GETBITS.N.FD		OPCODE[0312]	1.	<<Enter>>		TopOfStack: base address.		alpha: 	word offset.		beta:	High nibble -- number of the first bit of the field			Low nibble  -- (number of the size of the fiel) - 1	2.	Data is @[TopOfStack + alpha]	3.	Shift and mask the data.	4.	<<Exit>>		return: 	hi - S_POSITIVE				lo - mask & shifted data***********************************************************/LispPTR N_OP_getbitsnfd(base_addr, word_offset, beta)	int base_addr;	register int word_offset;	int beta;{register DLword	*pword;register short first;register short size;#ifdef	TRACE	printf("TRACE: N_OP_getbitsnfd()\n");#endif	pword = Addr68k_from_LADDR( 0xFFFFFF & (base_addr + word_offset) );	size = 0xF & beta;	first = 0xF & (beta >> 4);#ifdef	DEBUG	if(first+size > 15)		printf("DEBUG: N_OP_getbitsnfd[Bad beta! data-%x, first-%x, size-%x]\n", *pword, first, size);#endif	return(S_POSITIVE | 		( ( (*pword) >> (16 - (first + size + 1)) ) 			& mask_array[size] ) ) ;}/************************************************************ N_OP_putbasen	entry		PUTBASE.N		OPCODE[0315]	1.	<<Enter>>		TopOfStack: 	Low Word - replace data		*(CurrentStackPTR): base address.		alpha: offset.	2.	if high word of TopOFStack is not SMALLPL,		then call ufn2incS,		else replace (base address + offset) with data.	3.	increment PC by 2.	4.	<<Exit>>		return:	base address.		(Called only by Native code)***********************************************************/LispPTR N_OP_putbasen(base, tos, n, error_addr)	register LispPTR base, tos;	int n;	int *error_addr;{	base = 0xFFFFFF & base;	if( (0xFFFF0000 & tos ) != S_POSITIVE ) {ERROR_EXIT(error_addr);}	else{		*((DLword *) Addr68k_from_LADDR( base + n )) = GetLoWord(tos);		return(base);	}}/************************************************************ N_OP_putbaseptrn	entry		PUTBASEPTR.N		OPCODE[0316]	1.	<<Enter>>		TopOfStack: 	replace data (2 words)		*(CurrentStackPTR): base address.		alpha: offset.	2.	replace (base address + offset) with data.	3.	save base address to TopOfStack	3.	increment PC by 2.	4.	<<Exit>>		return:	base address.		(Called only by Native code) ***********************************************************/LispPTR N_OP_putbaseptrn(base, tos, n, error_addr)	register LispPTR base, tos;	int n;	int *error_addr;{	base = 0xFFFFFF & base;	*((LispPTR *) Addr68k_from_LADDR( base + n )) = tos & 0xffffff;	return(base);}