/* This is G-file @(#) gchtfind.c Version 2.4 (7/8/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) gchtfind.c	2.4 7/8/88";/*************************************************************************//*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.  *//*************************************************************************//*                                                                       *//*                       File Name : gchtfind.c                          *//*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : July-8-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions : htfind(ptr,casep);                              *//*                       gc_enter_bigrefcnt(ptr,entry);                  *//*                       gc_modify_bigrefcnt(entry,casep,ptr);           *//*                       *getlink();                                     *//*                       dellink(link,prev,entry);                       *//*                       freelink(linkcell);                             *//*                       newentry(entry,ptr,casep);                      *//*                       modentry(entry,casep,ptr);                      *//*                                                                       *//*                                                                       *//*************************************************************************//*           Description :                                               *//*	This file module may have the functions for Reference Counting.	 *//*	The function "htfind" is the main function in this module(for	 *//*	reference counting) and it is based on the UFN function "\HTFIND"*//*	of Opcode "GCREF" that is written in Xerox Lisp.		 *//*	This file's functions can be categolizeed to three groups.	 *//*	First is the main function, that is, "htfind". This isthe agent	 *//*	of manipulating the reference count table, that is, "HTmain",	 *//*	"HTcoll" and "HTbigcount". The process types of the function is  *//*	as following :							 *//*		ADDREF(= 0) : increment reference count			 *//*		DELREF(= 1) : decrement reference count			 *//*		STKREF(= 2) : set stkref field(this indicates that this	 *//*			      object is refered from stack.)		 *//*									 *//*	Second is the amount of functions that may modify the reference	 *//*	count table acually.(These function was implemented by macro in	 *//*	Lisp.)								 *//*	freelink(linkcell)	LispPTR linkcell			 *//*	 This function may arrange the free linkage of collision table	 *//*	 entries.							 *//*	dellink(link, prev, entry) LispPTR link, prev, entry		 *//*	 Thsi function may delete the entry of collision table(that may  *//*	 be indicated by "link". And "prev" may indicate the previous    *//*	 entry of the target entry, "link", on the entries' linkage.	 *//*	 If "prev" is NIL, it may tell that there is no entry between    *//*	 "link" and "entry"."entry" is the header of the linkage and the *//*	 entry in the "HTmain" table.					 *//*	*getlink()							 *//*	 This function may get the new entry template on the collision	 *//*	 table, that is, "HTcoll". And may return its Lisp Address.(But  *//*	 this gotten entry has no information. The function "newentry"	 *//*	 may set information to this new entry.)			 *//*	newentry(entry, ptr, casep)	LispPTR entry,ptr; DLword casep  *//*	 This function may set new entrie's information to new entry.	 *//*	 "entry" is the Lisp Address of new entry. "ptr" is the Lisp	 *//*	 Address of the Lisp Object. "casep" is the code of ref. counting*//*	 process.(0,1 or 2)						 *//*	modentry(entry,casep,ptr)	LispPTR entry,ptr;DLword casep   *//*	 This function may modify the reference count actually. The	 *//*	 parameters are same as the function "newentry".		 *//*	Third is the functions to manipulate the Big Count table.	 *//*	gc_enter_bigrefcnt(ptr,entry)	LispPTR ptr, entry		 *//*	 This function may be called in ADDREF to the object whose ref.	 *//*	 count is 62.Then, this function may make the new entry in the   *//*	 Big Count Table "HTbigcount".The entry of big count may have    *//*	 2 words reference count field and Lisp Address to the Lisp	 *//*	 object.							 *//*	gc_modify_bigrefcnt(entry,casep,ptr)				 *//*	 			LispPTR entry, ptr; DLword casep	 *//*	 This function may modify the reference count of entry on the    *//*	 big count table						 *//*                                                                       *//*************************************************************************//*                                                               \Tomtom *//*************************************************************************/#include "lispemul.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "gc.h"#include "lispmap.h"#include "cell.h"#ifdef CHECK#include "array.h"#endif#define MAXSMALLP		65535#define HTBIGENTRYSIZE		4#define WORDSPERPAGE		256#define MAXTYPENUMBER		INIT_TYPENUM#define GetLinkptr(entry)	(entry & 0x0fffe)#define GetSegnuminColl(entry1) ((entry1 & 0x01fe) >> 1)#define GetCountinColl(entry1)  ((entry1 & 0x0fc00) >> 10)#define GetStkCnt(entry1)		 ((entry1 & 0x0fe00) >> 9)#define Oddp(num) (((num % 2) != 0)?1:0)#define Evenp(num,prim) (((num % prim) == 0)?1:0)#define HTCOLLMAX  		HTCOLL_SIZE-2	/* 65534 in Lisp original */#define HTCOLLTHRESHOLD		(HTCOLL_SIZE/2)	/* 65528 in Lisp original *//* int ReclaimCountDown, ReclaimMin; */ 	  /* The global Variables for triggering the reclaim process *//* int GcDisabled; */	  /* This is the flag that indicates GC status. */int GetLinkRecursion = NIL;#ifdef NEWGC#define RECURSIVEGCOK (GetLinkRecursion == NIL)#else#define RECURSIVEGCOK NIL#endifDLword *getlink()    { struct htcoll *htcollents;	DLword tmpvar;	DLword *retvar;      htcollents = (struct htcoll *)HTcoll;      if ((tmpvar = htcollents->free_ptr) == 0)		{ if ((tmpvar = htcollents->next_free) >= HTCOLLTHRESHOLD)			{if (RECURSIVEGCOK) 				{GetLinkRecursion = T; 				 doreclaim(); 			 	 GetLinkRecursion = NIL; 			 	 return(NIL);} 			 else 			   if (tmpvar >= HTCOLLMAX) 			     disablegc1(NIL); 			 };		   htcollents->next_free = tmpvar+2;		   return((DLword *)Addr68k_from_LADDR(			LADDR_from_68k(HTcoll)+tmpvar));		}	 else	   { retvar = (DLword *)Addr68k_from_LADDR(LADDR_from_68k(HTcoll)						+tmpvar); 				/* offset opera */		htcollents->free_ptr = *(retvar+1);		return(retvar);	   }	}	freelink(linkcell)LispPTR linkcell;   { struct htcoll *htbase;	struct htcoll *cell68k;	htbase = (struct htcoll *)HTcoll;	cell68k = (struct htcoll *)Addr68k_from_LADDR(linkcell);	cell68k->free_ptr = 0;	cell68k->next_free = htbase->free_ptr;	htbase->free_ptr = LOLOC(linkcell); /* "LOLOC" <- "address.h" */   }dellink(link,prev,entry)LispPTR		link;LispPTR		prev;LispPTR		entry;   { struct hashentry *rentry;     struct htlinkptr *htlptr;	struct htcoll *pentry;	struct htcoll *lentry;	rentry = (struct hashentry *)Addr68k_from_LADDR(entry);	htlptr = (struct htlinkptr *)rentry; 	lentry = (struct htcoll *)Addr68k_from_LADDR(link);	if (prev != NIL)		{pentry = (struct htcoll *)Addr68k_from_LADDR(prev);		 pentry->next_free = lentry->next_free;		}	else	  htlptr->contents = (lentry->next_free | 1);	freelink(link);	lentry = (struct htcoll *)Addr68k_from_LADDR(LADDR_from_68k(HTcoll)			 + GetLinkptr(htlptr->contents));	if (lentry->next_free == 0)		{htlptr->contents = lentry->free_ptr;		 freelink(LADDR_from_68k(lentry));		};   }modentry(entry, casep, ptr)	LispPTR         entry;	DLword          casep;	LispPTR         ptr;{	register DLword gccnt;	register struct hashentry *rentry;	rentry = (struct hashentry *) Addr68k_from_LADDR(entry);	gccnt = rentry->count;	if (gccnt == MAX_GCCOUNT)		return gc_modify_bigrefcnt(entry, casep, ptr);	switch (casep) {	case ADDREF:		if (gccnt == (MAX_GCCOUNT - 1))			gc_enter_bigrefcnt(ptr, entry);		else			++(rentry->count);		break;	case DELREF:#ifdef CHECK		if (gccnt == 0)			error("attempt to decrement 0 reference count");#endif		--(rentry->count);		break;	case STKREF:		rentry->stackref = 1;		break;	case UNSTKREF:		rentry->stackref = 0;		break;	};	return ((rentry->count == 1) && (rentry->stackref == 0));}newentry(entry,ptr,casep) /* !this func. may be applied to HTmain&HTcoll! */LispPTR		  entry;LispPTR		  ptr;DLword		  casep;   { struct hashentry *rentry;	rentry = (struct hashentry *)Addr68k_from_LADDR(entry);#ifdef CHECK	if ((rentry->count != 0) || (rentry->stackref != 0)) error("new non-zero entry");#endif	rentry->segnum = HILOC(ptr);	switch(casep)		{ case ADDREF:			{rentry->count = 2;			 break;}		  case DELREF:			{return(ptr);			 break;}		  case STKREF:			{rentry->count = rentry->stackref = 1;			 break;}		  default: error("ERROR : invalid case on newentry. \n"); 				/* currently no implimented */		};	return(NIL);   }gc_enter_bigrefcnt(ptr,entry)LispPTR			ptr,entry;   { struct gc_ovfl	*oventry;     struct hashentry	*entry68;     register LispPTR	tmp;	oventry = (struct gc_ovfl *)HTbigcount;	entry68 = (struct hashentry *)Addr68k_from_LADDR(entry);	if (Oddp(LOLOC(ptr)))#ifdef CHECK		error("odd pointer in refcnt");#else		--ptr;#endif	while(((tmp = oventry->ovfl_ptr) != ATOM_T) && (tmp != NIL))						/* free area ? */	       {if (tmp == ptr)			{ error(			"ERROR : PTR already in overflow table.\n");			/* "Assure it lives forever" */			  oventry->ovfl_cnt += 0x10000;			  return(NIL);			}		else ++oventry;	   	};	if (tmp == NIL) {		if (Evenp(LADDR_from_68k(oventry+1),DLWORDSPER_PAGE)) {			if ((unsigned int)oventry+1 >= (unsigned int)HTcoll)				error("GC big reference count table overflow");			newpage(LADDR_from_68k(oventry+1));			}		}	oventry->ovfl_cnt   = MAX_GCCOUNT;	oventry->ovfl_ptr   = ptr;	entry68->count      = MAX_GCCOUNT;	return(MAX_GCCOUNT);   }gc_modify_bigrefcnt(entry,casep,ptr)DLword			casep;LispPTR			entry,ptr;   { struct gc_ovfl 	*oventry;     struct hashentry	*entry68;     LispPTR		tmp;     int		tmpcnt;	oventry = (struct gc_ovfl *)HTbigcount;	entry68 = (struct hashentry *)Addr68k_from_LADDR(entry);	if (Oddp(LOLOC(ptr)))	/* address adjustment */#ifdef CHECK	error("odd pointer in reference count");#else		--ptr;#endif	while((tmp = oventry->ovfl_ptr)!= ptr)	   if (tmp == NIL)		    { /*  gc_bigrefcnt_missing(ptr,entry);  */   			error(	"ERROR : PTR refcnt previously overflowed, but not found in table.\n");			 return(NIL);		     }	    else ++oventry; /* increment by size of oventry structure */	switch(casep)	   { case ADDREF:		       ++(oventry->ovfl_cnt);			return NIL;	     case DELREF:		       if (--(oventry->ovfl_cnt) < MAX_GCCOUNT) {				/* fallen below threshold */#ifdef CHECK				if (oventry->ovfl_cnt != MAX_GCCOUNT-1)					error("overflow table bogus entry");#endif				entry68->count = MAX_GCCOUNT-1;				oventry->ovfl_ptr = ATOM_T;				}			return NIL;		case STKREF:			{entry68->stackref = 1;			 return NIL;}		case UNSTKREF:			{entry68->stackref = 0;			 return NIL;}	   }   }LispPTR htfind(ptr,casep)LispPTR	ptr;DLword	casep;   {	LispPTR				probe;	register struct hashentry 	*entry;	register struct htlinkptr	*htlptr;/* overlay access method */	register struct htcoll		*link,*prev;	DLword			offset;	LispPTR			lpentry,lplink,lpprev;	lpprev = NIL;	if (((int)GetTypeEntry(ptr) & TT_NOREF) != 0)						/* MDS's NOREF checking */		return(NIL);	else if (*GcDisabled_word == ATOM_T) {#ifdef CHECK		error("\GCDISABLED but htfind reached");#endif		return NIL;}#ifdef CHECK	if((GetTypeNumber(ptr) == 0) && (casep != STKREF) && (casep != UNSTKREF))		 checkarrayblock(ptr-ARRAYBLOCKHEADERWORDS, NIL, NIL);#endif	entry = (struct hashentry *)Addr68k_from_LADDR(		LADDR_from_68k(HTmain) + (LOLOC(ptr) >> 1));							/* hashing entry */	htlptr = (struct htlinkptr *)entry;	/* entry's whole contents */	lpentry = LADDR_from_68k(entry);	if (htlptr->contents == 0)		/* this entry is new entry */		return(newentry(lpentry,ptr,casep));	else if (entry->collision)		{ 		/* scanning and finding the HTCOLL table */		  lplink = LADDR_from_68k(HTcoll)+GetLinkptr(htlptr->contents);						/* offset opera */		  link = (struct htcoll *)Addr68k_from_LADDR(lplink);		  while((offset = link->next_free) != 0)		   {if (HILOC(ptr) == GetSegnuminColl(link->free_ptr))			  if (modentry(lplink, casep, ptr) != NIL)				{ dellink(lplink, lpprev, lpentry);				  return(NIL);				}			  else if (GetStkCnt(link->free_ptr) == 0)				{ return(ptr);}			  else return(NIL);		    prev = link;		    lpprev = lplink;		    lplink = LADDR_from_68k(HTcoll) + offset;		    link = (struct htcoll *)Addr68k_from_LADDR(lplink);		   };		  if (HILOC(ptr) == GetSegnuminColl(link->free_ptr))			  if (modentry(lplink, casep, ptr) != NIL)				{ dellink(lplink, lpprev, lpentry);				  return(NIL);				}			  else if (GetStkCnt(link->free_ptr) == 0)				{ return(ptr);}			  else return(NIL);		  prev = link;		  lpprev = lplink;  		  link = (struct htcoll *)getlink();  		  if (link == NIL) 		    {GetLinkRecursion = T; 		     probe = GCLOOKUPV(0x8000,casep,ptr); 		     GetLinkRecursion = NIL; 		     return(probe); 		   }  		  else 		    {lplink = LADDR_from_68k(link); 		     link->next_free = 0; 		     prev->next_free = LOLOC(lplink);	/* offset opera */ 		     return(newentry(lplink, ptr, casep)); 		    };		}	else if (HILOC(ptr) == entry->segnum)				/* already existing */		{if (modentry(lpentry, casep, ptr) != NIL) 			/* case : refcnt is 1 */			{ htlptr->contents = 0; 			  return(NIL);			}		 else if ((entry->count == 0) && 				(entry->stackref == 0))			/* case : garbage is born */				 return(ptr);		      else return(NIL);		 }	else /*	making the new collision entry */	    {	link = (struct htcoll *)getlink();  	    	if (link == NIL) 		  {GetLinkRecursion = T; 		   probe = GCLOOKUPV(0x8000,casep,ptr); 		   GetLinkRecursion = NIL; 	    	   return(probe); 		 } 	    	else 		{lplink = LADDR_from_68k(link);		prev = (struct htcoll *)getlink();  		 if (prev == NIL) 		   {GetLinkRecursion = T; 		    probe = GCLOOKUPV(0x8000,casep,ptr); 		    GetLinkRecursion = NIL; 		    return(probe); 		  } 		 else			{lpprev = LADDR_from_68k(prev);			prev->next_free = LOLOC(lplink);			prev->free_ptr  = htlptr->contents;			htlptr->contents   =		 	  (DLword)(LOLOC(lpprev) | 0x01);			link->next_free = 0;			link->free_ptr  = 0;			return(newentry(lplink, ptr, casep));		/* !!newentry's first arg must be struct hashentry!! */			};		};	   }   }