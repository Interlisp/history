/* This is G-file @(#) gcarraymaker.c Version 2.4 (6/23/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) gcarraymaker.c	2.4 6/23/88";/*************************************************************************//*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co.,Ltd. All rights reserved.   *//*************************************************************************//*                                                                       *//*                       File Name : gcarraymaker.c                      *//*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : Oct-9-1987                       *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions :                                                 *//*                       LispPTR aref1(array, index);                    *//*                   	 DLword find_symbol(char_base,offset             *//*			 			 ,length,hashtbl);       *//*                       DLword get_package_atom(                        *//*                               char_base,charlen,packname,             *//*                                            packlen,externalp);        *//*                                                                       *//*************************************************************************//*           Description :                                               *//*                                                                       *//* The function "aref1" is the accessor of oned_array.                   *//* The functions "find_symbol" and "get_package_atom" are implemented    *//*     for  the method to access the atom through the package mechanisum.*//*									 *//*************************************************************************//*                                                               \Tomtom *//*************************************************************************//* THESE FUNCTIONS ARE NOW USED BY SYSOUT START AND URAID ONLY */#include "lispemul.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "stack.h"#include "cell.h"#include "ifpage.h"#include "gc.h"#include "array.h"#include "debug.h"#include "lispmap.h"#define min(a,b)		((a > b)?b:a)#define Trailer(ldatum,datum68)	(ldatum+2*(datum68->arlen - ARRAYBLOCKTRAILERCELLS))#define BucketIndex(n)		min(integerlength(n),MAXBUCKETINDEX)#define FreeBlockChainN(n)	((0xffffff & *FreeBlockBuckets_word)+2*BucketIndex(n))#define Rehash_factor(hash,tablelen)   \           (((hash) % ((tablelen) - 2)) + 1)#define Symbol_hash_reprobe(hash,rehashfactor,tablelen) \               (((hash) + (rehashfactor)) % (tablelen))#define Entry_hash(strlen,sxhash) \           (((((((strlen)^(sxhash))^((sxhash) >> 8))  \	       ^((sxhash) >> 16))^((sxhash) >> 19)) % 254) + 2)struct hashtable {  LispPTR      table;  LispPTR      hash;  LispPTR      size;  LispPTR      free;  LispPTR      deleted;};/* The end of macros & structure for medley version */LispPTR aref1(array, index)LispPTR array;int     index;{register LispPTR retval; register LispPTR base; register short   typenumber; register DLword  *actarray; actarray = Addr68k_from_LADDR(array); if (index >= *((DLword *)(actarray + 5)))   error("Invalid index in gc's aref1"); index += *((DLword *)(actarray + 3)); typenumber = 0x0ffff & *((DLword *)(actarray + 2)); base = *((LispPTR *)(actarray)); switch(typenumber) { case  3: /* unsigned 8bits */   retval = (*(((char *)Addr68k_from_LADDR(base))		 + index)) & 0x0ff;      retval |= S_POSITIVE;      break; case 4: /* unsigned 16bits */   retval = (*(((DLword *)Addr68k_from_LADDR(base))		 + index)) & 0x0ffff;      retval |= S_POSITIVE;      break; case 38:   retval = (*(((LispPTR *)Addr68k_from_LADDR(base))		 + index));      break; default :   error("Not Implemented in gc's aref1 (other types)"); }; return(retval);}LispPTR find_symbol(char_base, offset, length, hashtbl)char *char_base;DLword offset;DLword length;LispPTR hashtbl;{DLword hashval, ehashval, h2, ehash, indexvar; int arraylen; struct hashtable *hashtbladdr; LispPTR vec,hash; struct arrayheader *vec68k; hashval = compute_hash(char_base,offset, length); ehashval = Entry_hash(length, hashval); hashtbladdr = (struct hashtable *)Addr68k_from_LADDR(hashtbl); vec = hashtbladdr->table; vec68k = (struct arrayheader *)Addr68k_from_LADDR(vec); hash = hashtbladdr->hash; arraylen = vec68k->totalsize; if(arraylen==0) return(0xffffffff);/*kludge TAKE*/ h2 = Rehash_factor(hashval, arraylen); indexvar = (hashval % arraylen);retry: while (ehashval != (ehash = aref1(hash,indexvar))) {   if(ehash==NIL) return(0xffffffff);   indexvar = Symbol_hash_reprobe(indexvar, h2, arraylen); } if ((indexvar&0xffff) != NIL){   LispPTR index;     PNCell *pnptr ;   char *pname_base ;   index=aref1(vec,indexvar);   pnptr = (PNCell *)GetPnameCell(index&0xffff);   pname_base= (char *)Addr68k_from_LADDR(pnptr->pnamebase) ;   if((length == *pname_base) && 	(compare_chars(char_base,(pname_base+1),length)))   {    	 return(index&0xffff);   }   else     { 	indexvar = Symbol_hash_reprobe(indexvar, h2, arraylen);	goto retry;    } } else    return(0xffffffff); /* can't find */}/*******************************************************************//*	Func name : get_package_atom			If find symbol ,retrun index.			Else retrun 0xFFFFFFFF*//*******************************************************************/LispPTR get_package_atom(char_base, charlen, packname, packlen, externalp)char *char_base;DLword charlen;char *packname;DLword packlen;int    externalp; {int packindex; PACKAGE *packaddr; LispPTR hashtbladdr; LispPTR index; extern LispPTR find_package_from_name();/** for some NICKNAME compatibility */ if (compare_chars(packname, "XCL", packlen) == T)   packindex = find_package_from_name("XEROX-COMMON-LISP",17);  else if (compare_chars(packname, "SI", packlen) == T)   packindex = find_package_from_name("SYSTEM",6); else if (compare_chars(packname, "CL", packlen) == T)   packindex = find_package_from_name("LISP",4); else if (compare_chars(packname, "XCLC", packlen) == T)   packindex = find_package_from_name("COMPILER",8);/**** else if (compare_chars(packname, "KEYWORD", packlen) == T)   packindex = 7;***/ else   packindex=find_package_from_name(packname,packlen);if (packindex <0) {	 printf("getting package index is failed \n");	 return(0xffffffff); }/* if (packindex != 7)  Not necessary (Take)*/   packaddr = (PACKAGE *)Addr68k_from_LADDR(			  aref1(*Package_from_Index_word, packindex));/* else packaddr = (PACKAGE *)Addr68k_from_LADDR(			*Keyword_Package_word);	*/	       /* hashtbladdr = 	((externalp == T)?(packaddr->EXTERNAL_SYMBOLS):			 (packaddr->INTERNAL_SYMBOLS)); return( find_symbol(char_base, 0, charlen, hashtbladdr) );*/ if ((index=find_symbol(char_base, 0, charlen,packaddr->EXTERNAL_SYMBOLS)) != 				0xffffffff)	return(index); else	return(find_symbol(char_base, 0, charlen,packaddr->INTERNAL_SYMBOLS));}