/* This is G-file @(#) gcreclaim.c Version 2.2 (5/31/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) gcreclaim.c	2.2 5/31/88";/*************************************************************************//*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 *//*************************************************************************//*                                                                       *//*                       File Name : gcreclaim.c                         *//*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : Oct-12-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*           Functions : gcarrangementstack()                            *//*           		 doreclaim();                                    *//*                       dogc01();                                       *//*                       disablegc1(noerror);                            *//*                                                                       *//*************************************************************************//*           Descreption : 						 *//* This files' functions is the invocator that may invoke the reclaimer. *//*  gcarrangementstack()						 *//*	This function's role is  narrowing the gap between the 		 *//*      contextswitch and the subrcall.					 *//*	In the original Lisp Source, as the contextswitch process may    *//*	clear the remain area to FSB,there is no problem in scannig stack*//*	.But in the subrcall,there isn't such process.			 *//*	Therefore, the function is required to set the remain stack area *//*	 to FSB. And this function does so.				 *//*  dogc01()								 *//*	This function is the mere caller of the reclaimer.		 *//*	The callees are gcscanstack(), gcmapscan() and gcunmapscan().    *//*  doreclaim()								 *//*	This function is the real top level function of the reclaimer.   *//*	But currently this function is not used(may be used in Future.)  *//*	This function may have a problem. It is to manipulate "clock"    *//*	for keeping the GC's time period.				 *//*   disablegc1(noerror)/*      This function is the rescue function,when the HTcoll table is    *//*      overflow and so on.After this function's process is over, the    *//*      keyhandler will sense the interrupt table state and call the     *//*      function \DOGCDISABLEDINTERRUPT for reporting to Users that      *//*      this system status is dangerous and you should save your works.  *//*                                                                       *//*************************************************************************//*                                                               \tomtom *//*************************************************************************/#include "lispemul.h"#include "lispmap.h"#include "emulglobal.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "stack.h"#include "gc.h"#define MAXSMALLP		65535#define HTBIGENTRYSIZE		4#define WORDSPERPAGE		256#define WORDSPERCELL		2#define MAXTYPENUMBER		INIT_TYPENUM#define STK_HI			1 extern int GetLinkRecursion;   struct interruptstate {       unsigned nil1             :3;         unsigned gcdisabled       :1; 	unsigned vmemfull         :1; 	unsigned stackoverflow    :1; 	unsigned storagefull      :1; 	unsigned waitinginterrupt :1; 	unsigned nil2             :8; 	DLword   intcharcode; 	}; gcarrangementstack(){  LispPTR tmpnextblock; 	PushCStack;	tmpnextblock = LADDR_from_68k(CurrentStackPTR+=WORDSPERCELL);	CURRENTFX->nextblock = LOLOC(tmpnextblock);  *(CurrentStackPTR)=STK_FSB_WORD;  *(CurrentStackPTR+1)=(((int)EndSTKP-(int)CurrentStackPTR)>>1);}/****************************************************************//* The following function is the caller that is the reclaimer.  *//* And, this function is same as \DOGC1 in Lisp because in the  *//* C's implimentation the contextswitch is not required for the *//* remaining the system status.					*//****************************************************************/dogc01() { gcarrangementstack(); gcscanstack(); gcmapscan(); gcmapunscan(); return(NIL);}doreclaim(){int gctm1; MISCSTATS	*gcmisc;   if (*GcDisabled_word == NIL)	{gcmisc = (MISCSTATS *)MiscStats;	 *Reclaim_cnt_word = NIL;/* 	 gctm1 = clock(2, *GcTime1_word); temp no clock */	 if (*GcMess_word != NIL)		flip_cursor(); 	 GetLinkRecursion = T;	 dogc01(); 	 GetLinkRecursion = NIL;	 if (*GcMess_word != NIL)		flip_cursor();/*	 gcmisc->gctime +=		clock(2, *GcTime2_word) - gctm1; temp no clock */	 *Reclaim_cnt_word = *ReclaimMin_word;	};}disablegc1(noerror)int       noerror; { struct interruptstate *gcinterruptstate;  int                   count, i;  DLword                typeword;  gcinterruptstate = (struct interruptstate *)			Addr68k_from_LADDR(*INTERRUPTSTATE_word);  count = (128)*256; /* This is test value. 128 is *MdsTTsize(\MDSTTsize) */   for(i = 0;i < count;i++)    {typeword = *(DLword *)Addr68k_from_LADDR(LADDR_from_68k(MDStypetbl)+i);     *(DLword *)Addr68k_from_LADDR(LADDR_from_68k(MDStypetbl)+i)                  = (typeword | TT_NOREF);   };   *Reclaim_cnt_word = NIL;   *ReclaimMin_word  = NIL;  if ((noerror == NIL) && (*GcDisabled_word == NIL))     { gcinterruptstate->gcdisabled = T;      *PENDINGINTERRUPT_word = ATOM_T;    };  *GcDisabled_word = ATOM_T;  return(NIL);}