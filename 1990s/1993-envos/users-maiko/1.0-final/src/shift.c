/* This is G-file @(#) shift.c Version 2.3 (6/17/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) shift.c	2.3 6/17/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. * *	Auther :  Hiroshi Hayata * */#include <stdio.h>#include "lispemul.h"#include "lispglobal.h"#include "emulglobal.h"#include "address68k.h"#include "lispmap.h"#include "lisptypes.h"#include "arith.h"#define	LSH	0347DLword	*createcell68k();#ifdef C_ONLY/************************************************************OP_llsh1	entry		LLSH1		OPCODE[0340]	1.	<<Entrer>>		TopOfStack			: argument of LLSH		They are SMALLPL or SMALLNEG, Lisp address.	2.	shift argument.	3.	<<Exit>>		TopOfStack			: shifted value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_llsh1(){register int	arg;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_llsh1()\n");#endif	GetNumber( TopOfStack, arg );	arg <<= 1;	switch(arg & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg);			break;		default:			/* arg is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg;			TopOfStack = LADDR_from_68k(wordp);			break;	}	++PC;}/************************************************************OP_llsh8	entry		LLSH8		OPCODE[0341]	1.	<<Entrer>>		TopOfStack			: argument of LLSH		They are SMALLPL or SMALLNEG, Lisp address.	2.	shift argument.	3.	<<Exit>>		TopOfStack			: shifted value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_llsh8(){register int	arg;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_llsh8()\n");#endif	GetNumber( TopOfStack, arg );	arg <<= 8;	switch(arg & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg);			break;		default:			/* arg is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg;			TopOfStack = LADDR_from_68k(wordp);			break;	}	++PC;}/************************************************************OP_lrsh1	entry		LRSH1		OPCODE[0342]	1.	<<Entrer>>		TopOfStack			: argument of LRSH		They are SMALLPL or SMALLNEG, Lisp address.	2.	shift argument.	3.	<<Exit>>		TopOfStack			: shifted value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_lrsh1(){register int	arg;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_lrsh1()\n");#endif	GetNumber( TopOfStack, arg );	arg >>= 1;	switch(arg & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg);			break;		default:			/* arg is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg;			TopOfStack = LADDR_from_68k(wordp);			break;	}	++PC;}/************************************************************OP_lrsh8	entry		LRSH8		OPCODE[0343]	1.	<<Entrer>>		TopOfStack			: argument of LRSH		They are SMALLPL or SMALLNEG, Lisp address.	2.	shift argument.	3.	<<Exit>>		TopOfStack			: shifted value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_lrsh8(){register int	arg;register DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_lrsh8()\n");#endif	GetNumber( TopOfStack, arg );	arg >>= 8;	switch(arg & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg);			break;		default:			/* arg is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg;			TopOfStack = LADDR_from_68k(wordp);			break;	}	++PC;}/************************************************************OP_lsh	entry		LSH		OPCODE[0347]	1.	<<Entrer>>		TopOfStack		: shift size		Top of CurrentStack	: argument of LSH		They are SMALLPL or SMALLNEG, Lisp address.	2.	left shift argument.	3.	<<Exit>>		TopOfStack		: shifted value			It is SMALLPL or SMALLNEG, Lisp address.	If jump UFN, call UFN function agreed to *PC(==opcode).************************************************************/OP_lsh(){register int	arg;register int	size;DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_lsh()\n");#endif	GetNumber( TopOfStack, size );/*CSP	GetNumber(*((int *)(CurrentStackPTR-1)), arg);	*/	GetNumber(*((int *)(CurrentStackPTR)), arg);	if((size < 0) || (size > 15)){		/**** call Lisp Func. ****/		ufn(LSH);		return;	}	arg <<= size;	switch(arg & 0xFFFF0000){		case 0:			TopOfStack = S_POSITIVE | arg;			break;		case 0xFFFF0000:			TopOfStack = S_NEGATIVE | (0xFFFF & arg);			break;		default:			/* arg is FIXP, call createcell */			wordp = createcell68k(TYPE_FIXP);			*((int *)wordp) = arg;			TopOfStack = LADDR_from_68k(wordp);			break;		break;	}	CurrentStackPTR -= 2;	++PC;}#else/************************************************************N_OP_llsh1	entry		LLSH1		OPCODE[0340]	return(a << 1)************************************************************/N_OP_llsh1(a, error_addr)	int a, *error_addr;{#ifdef	TRACE	printPC();	printf("TRACE: OP_llsh1()\n");#endif	N_ARITH_BODY_1_UNSIGNED(a, 1, error_addr, <<);}/************************************************************N_OP_llsh8	entry		LLSH8		OPCODE[0341]	return(a << 8)************************************************************/N_OP_llsh8(a, error_addr)	int a, *error_addr;{#ifdef	TRACE	printPC();	printf("TRACE: OP_llsh8()\n");#endif	N_ARITH_BODY_1_UNSIGNED(a, 8, error_addr, <<);}/************************************************************N_OP_lrsh1	entry		LRSH1		OPCODE[0342]	return(a >> 1)************************************************************/N_OP_lrsh1(a, error_addr)	int a, *error_addr;{#ifdef	TRACE	printPC();	printf("TRACE: OP_lrsh1()\n");#endif	N_ARITH_BODY_1_UNSIGNED(a, 1, error_addr, >>);}/************************************************************N_OP_lrsh8	entry		LRSH8		OPCODE[0343]	return(a >> 8)************************************************************/N_OP_lrsh8(a, error_addr)	int a, *error_addr;{#ifdef	TRACE	printPC();	printf("TRACE: OP_lrsh8()\n");#endif	N_ARITH_BODY_1_UNSIGNED(a, 8, error_addr, >>);}/************************************************************N_OP_lsh	entry		LSH		OPCODE[0347]	return(a <?> b)************************************************************/N_OP_lsh(a, b, error_addr)	int a, b, *error_addr;{register int	arg,arg2;register int	size;DLword	*wordp;#ifdef	TRACE	printPC();	printf("TRACE: OP_lsh()\n");#endif	N_GETNUMBER(b, size, do_ufn);	N_GETNUMBER(a, arg2, do_ufn);	if (size > 0) {		if (size > 31) goto do_ufn;		arg = arg2 << size;		if ((arg >> size) != arg2) goto do_ufn;	} else 	if (size < 0) {		if (size < -31) goto do_ufn;		arg = arg2 >> -size;		if ((arg << -size) != arg2) goto do_ufn;	} else return(a);			N_ARITH_SWITCH(arg);do_ufn:	ERROR_EXIT(error_addr);}#endif