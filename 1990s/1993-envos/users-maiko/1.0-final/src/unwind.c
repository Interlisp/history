/* This is G-file @(#) unwind.c Version 2.11 (9/20/88). copyright Xerox & Fuji Xerox  */static char *id = "@(#) unwind.c	2.11 9/20/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *//******************************************************************//*		File Name  :	unwind.c		Created    :	jul 17, 1987 by T.Shimizu		Changed	   :	Jan 21 1988  takeshi*//******************************************************************/#include "lispemul.h"#include "address.h"#include "address68k.h"#include "lisptypes.h"#include "lispmap.h"#include "stack.h"#include "emulglobal.h"#include "lispglobal.h"typedef struct {	DLword bind_negval;	DLword bind_lastpvar; } BINDSLOT;OP_unwind() {   int  num ;  /* number of UNBOUND slot */   DLword *endptr; /* unwind limit */   DLword *lastpvar; /* points PVar slot that is unbounded. */#ifdef TRACE 	printPC(); printf("TRACE: OP_unwind() \n");#endif endptr = PVar + (2 * (Get_BYTE(PC+1))) - DLWORDSPER_CELL; /* set unwind limit */  if(0x80000000 & TopOfStack) /* TOS has BIND mark */   {	num = (~(TopOfStack)) >> 16 ; /* get number */ 	lastpvar =PVar +( TopOfStack & 0xffff ); /* get lastpvar */   }  else   { 	while(!( ((WBITS *)CurrentStackPTR)->MSB ))	{ /* searching BIND mark */	  CurrentStackPTR -= 2;	  if(endptr > CurrentStackPTR) goto UNWSTOP;	}	num = ~(((BINDSLOT*)CurrentStackPTR)->bind_negval); /* get number */	lastpvar =PVar +(((BINDSLOT*)CurrentStackPTR)->bind_lastpvar) ;      /* get lastpvar */  }/* UNBUND MARK loop */do { 	for(;		num>0; lastpvar -= DLWORDSPER_CELL,num--)	 {		*lastpvar = 0xffff ; /* Mark as UNBOUND */	 }	     do	{ /* searching  next BIND mark */	  CurrentStackPTR -= DLWORDSPER_CELL;	  if(endptr > CurrentStackPTR) goto UNWSTOP;	}while(!( ((WBITS*)CurrentStackPTR)->MSB ) );	num = ~(((BINDSLOT*)CurrentStackPTR)->bind_negval); /* get number */	lastpvar =PVar + (((BINDSLOT*)CurrentStackPTR)->bind_lastpvar);      /* get lastpvar */   } while(endptr < CurrentStackPTR); UNWSTOP: PC += 3 ; CurrentStackPTR += DLWORDSPER_CELL; if(Get_BYTE(PC-1)) /* keep TOS */  {	return;  } else  {	PopCStack;	return;  } } /* OP_unwind *//* ************************************************************ */LispPTR N_OP_unwind(cstkptr, tos, n, keep, error_addr) 	register LispPTR *cstkptr;	register LispPTR tos;	int n;	int keep;	int *error_addr;{ register int  num ;  /* number of UNBOUND slot */   register LispPTR *endptr; /* unwind limit */   register LispPTR *lastpvar; /* points PVar slot that is unbounded. *//* Slots:	-----------------	|		|	<- PVar	-----------------	|	.	|	|	.	|	-----------------	|		|	 ALL OF THE FOLLOWING LOCATIONS SCANNED	-----------------------------------------------------------------	|		|	<- endptr (PVar[n]) <- Result (no keep)	|	-----------------						|	| tos if keep	|	<- Result (keep)			|	-----------------						|	|		|						|	-----------------						|	|	.	|						|	|	.	|						|	-----------------						|	|   tos pushed	|	<- Start CSTKPTR			|	-----------------						|	|   		|						|	-----------------------------------------------------------------*/endptr = (LispPTR *) PVar + n; 			/* set unwind limit */ if (endptr > cstkptr) ERROR_EXIT(error_addr);*cstkptr++ = tos;	/* UNBOUND MARK loop  */while (cstkptr > endptr)     {		/* Look for the Next BIND marker */	if( (num = (int) *--cstkptr) < 0 )	   {		/* Now UNBIND the PVARS indicated by the BIND marker */	    lastpvar = (LispPTR *) (2 + PVar + (unsigned short) num) ;	    num = ~(num >> 16) + 1; 	    for(; --num > 0; )	     { *--lastpvar = 0xffffffff ; /* Mark as UNBOUND */ }	    };   }; /* endptr = cstkptr */ if(keep)   {		*(cstkptr++) = tos;  } return((LispPTR) cstkptr);} /* N_OP_unwind */