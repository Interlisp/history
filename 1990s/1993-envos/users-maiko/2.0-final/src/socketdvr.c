/* @(#) socketdvr.c Version 1.1 (8/26/91). copyright venue & Fuji Xerox  */static char *id = "@(#) socketdvr.c	1.1 8/26/91	(venue & Fuji Xerox)";/**** Copyright (C) 1988 by Fuji Xerox co.,Ltd.. Al rights reserved.**		Author: Mitsunori Matsuda*		Date  : November 2, 1988*/#include <stdio.h>#include <sys/time.h>#include <sys/file.h>#include "lispemul.h"#include "arith.h"#include "address68k.h"#include "lisptypes.h"#include "lispmap.h"#define min(x,y)  (((x) > (y)) ? (y) : (x))#define	LStringToCString(Lisp, C, MaxLen ,Len)				\  {									\    OneDArray	*arrayp;						\    char	*base;							\    short	*sbase;							\    int	i;								\									\    arrayp = (OneDArray *)(Addr68k_from_LADDR((unsigned int)Lisp));	\    Len = min(MaxLen, arrayp->totalsize);				\									\    switch(arrayp->typenumber)						\      {									\        case THIN_CHAR_TYPENUMBER:					\	    base = ((char *)						\	            (Addr68k_from_LADDR((unsigned int)arrayp->base)))	\	           + ((int)(arrayp->offset));				\	    for(i=0;i<Len;i++)						\	        C[i] = base[i];						\	    C[Len] = '\0';						\	    break;							\									\        case FAT_CHAR_TYPENUMBER:					\	    sbase = ((short *)						\		     (Addr68k_from_LADDR((unsigned int)arrayp->base)))	\	           + ((int)(arrayp->offset));				\	    base = (char *)sbase;					\	    for(i=0;i<Len*2;i++)					\	        C[i] = base[i];						\	    C[Len*2] = '\0';						\	    break;							\									\        default:							\	    error("LStringToCString can not handle\n");			\      }									\  }#define MAX_NAME_LEN 256static char XServer_Name[MAX_NAME_LEN];static int XPort_Number = 0;int XServer_Fd = -1;extern DLword *Lisp_world;Open_Socket( args )LispPTR *args;{#ifdef TRACE	printf( "TRACE: Open_Socket()\n" );#endif	int length;	LStringToCString( args[0], XServer_Name, MAX_NAME_LEN, length );	XPort_Number = (int) (0xff & args[2] );	if( XServer_Fd == -1 ) {		XServer_Fd = connect_to_server( XServer_Name, XPort_Number );		{ int res;		res = fcntl( XServer_Fd, F_GETFL );		res |= FNDELAY;		res = fcntl( XServer_Fd, F_SETFL, res );		}	} /* end if(XServer_Fd) */	return( ATOM_T );}Close_Socket(){	int stat;#ifdef TRACE 	printf( "TRACE: Close_Socket()\n" );#endif	if( (stat = close( XServer_Fd )) == -1 ) {		XServer_Fd = -1;		return( NIL );	} else {		XServer_Fd = -1;		return( ATOM_T );	}} /* end Close_Socket */typedef struct {		DLword nil[22]; /* Packet header */		DLword length;	/* Request byte lenght */		char   data[592]; /* Data body */} PACKET;#define PACKET_DEFOFFSET 46#define PACKET_MAXSIZE   638Read_Socket( args )LispPTR *args;{	PACKET *packet;	char   *buffer;	int    length	     , actlen;#ifdef TRACE	printf( "TRACE: Read_Socket()\n" );#endif	if( XServer_Fd >= 0 ) {		packet = (PACKET *) Addr68k_from_LADDR( args[0] );		if( (length = (int)(packet->length)-PACKET_DEFOFFSET) > 0 ) {			buffer = &(packet->data[0]);			if( (actlen = read( XServer_Fd, buffer, length )) > 0 ) {				packet->length = (DLword)(actlen							+ PACKET_DEFOFFSET);				return(ATOM_T); 			} /* end if(actlen) */		} /* end if(length) */	} /* end if( fd ) */	return( NIL );} /* end Read_Socket */Write_Socket( args )LispPTR *args;{	PACKET *packet;	char *buffer;	int length	  , actlen;#ifdef TRACE	printf( "TRACE: Write_Socket()\n" );#endif	if( XServer_Fd >= 0 ) {		packet = (PACKET *) Addr68k_from_LADDR( args[0] );		if( (length = (int)(packet->length)-PACKET_DEFOFFSET) > 0 ) {			buffer = &(packet->data[0]);			if( (actlen = write( XServer_Fd, buffer, length )) > 0 ) {				packet->length = (DLword)(actlen 							+ PACKET_DEFOFFSET);				return(ATOM_T); 			} /* end if( actlen ) */		}  /* end if(length) */	}  /* end if( fd ) */	packet->length = 0;	return(NIL);} /* end Write_Socket */extern int KBDEventFlg;Kbd_Transition( args )LispPTR *args;	/* args[0] is key-number */	/* args[1] is up-flg     */{	DLword key_number;		key_number = (DLword)(args[0] & 0xff);	if( args[1] ) 		kb_trans( key_number, 1 );	else 		kb_trans( key_number, 0 );	DoRing();	if( (KBDEventFlg += 1) > 0 ) {		Irq_Stk_End = Irq_Stk_Check = 0;	}} /* end Kbd_Transition */