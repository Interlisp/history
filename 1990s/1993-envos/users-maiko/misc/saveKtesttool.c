/* This is G-file Ktestool.c Version 1.1 (2/24/88). copyright Xerox & Fuji Xerox  */static char *id = "Ktestool.c	1.1 2/24/88";/* *	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved. *//***************************************************************//*	file name :	 Ktesttools.c	For Debugging Aids	Including :		dump_check_atoms()		print_atomname(index)		dump_dtd()		check_type_68k(type,ptr)		type_num(LISPPTR)		dump_conspage(base , linking )		trace_listpDTD()		a68k( lispptr)		laddr(addr68k)		dump_fnobj(index)		doko()		dumpl(laddr)		ptintPC()		all_stack_dump(start,end)  		date :   14 May 1987   takeshi			 15 May 1987 take			 1  June 1987 take			 21  June 1987 NMitani			  9  Sep. 1987 take*/#include "lispemul.h"#include "lispmap.h"#include "address68k.h"#include "lisptypes.h"#include "lispglobal.h"#include "emulglobal.h"#include "cell.h"#include "stack.h"#include "ifpage.h"extern DLword *Lisp_world ;/* extern DLword AtomFrLst; *//*************************************************************//*		Func :	print_atomname*//************************************************************/print_atomname(index) DLword index ; /* atomindex */{ char *pname ; DLword length ; PNCell *pnptr ; pnptr =(PNCell *)GetPnameCell( index); pname=(char *) Addr68k_from_LADDR(pnptr->pnamebase); if((length = *pname++) <= 0)  	printf("print_atomname: Bad length in PNameCell \n"); while(length >0){			 putchar(*pname++);			 length-- ;		}} /* end print_atomname *//*************************************************************//*		Func :	dump_dtd*//************************************************************/dump_dtd(){ extern DLword *DTDspace ;  struct dtd *dtdp ; DLword cnt ; dtdp = (struct dtd *)DTDspace ;dtdp++;for (cnt = 0 ; cnt < INIT_TYPENUM ; cnt ++) {	printf("DTD[ %d ] for ",cnt+1);	print_atomname(dtdp->dtd_name);	putchar('\n');	printf("    dtd_name = %d \n",dtdp->dtd_name);	printf("    dtd_size = %d \n",dtdp->dtd_size);	printf("    dtd_free = %d \n",dtdp->dtd_free);	printf("    dtd_obsolate = %d \n",dtdp->dtd_obsolate);	printf("    dtd_finalizable = %d \n",dtdp->dtd_finalizable);	printf("    dtd_lockedp = %d \n",dtdp->dtd_lockedp);	printf("    dtd_hunkp = %d \n",dtdp->dtd_hunkp);	printf("    dtd_gctype = %d \n",dtdp->dtd_gctype);	printf("    dtd_descrs = %d \n",dtdp->dtd_descrs);	printf("    dtd_typespecs = %d \n",dtdp->dtd_typespecs);	printf("    dtd_ptrs = %d \n",dtdp->dtd_ptrs);	printf("    dtd_oldcnt = %d \n",dtdp->dtd_oldcnt);	printf("    dtd_cnt0 = %d \n",dtdp->dtd_cnt0);	printf("    dtd_nextpage = %d \n",dtdp->dtd_nextpage);	printf("    dtd_typeentry = %x \n",dtdp->dtd_typeentry);	printf("    dtd_supertype = %d \n",dtdp->dtd_supertype);	dtdp++;  }} /* end dump dtd *//********************************//*    It prints the type number which associated by 68kptr*/check_type_68k(type,ptr) LispPTR *ptr ;{ if (type != (GetTypeNumber(LADDR_from_68k(ptr)) ) )  {  printf("Mismatching occur !!! LispAddr 0x%x  type %d  \n",LADDR_from_68k(ptr)	  ,type);  exit(-1);  }  printf("LispPTR 0x%x is the datatype %d \n", LADDR_from_68k(ptr)      ,GetTypeNumber(LADDR_from_68k(ptr)) );}/****************************************//** return type num ******/type_num(lispptr) LispPTR lispptr;{  int type;  type = GetTypeNumber(lispptr);  printf("LispPTR 0x%x is datatype %dth \n",lispptr,type);  return(type);}/******************************//* DUMP conspage prog.*//*****************************/dump_conspage(base , linking ) struct conspage *base; /* target conspage address */ int linking ;  /* look for chaiing conspage ? T/NIL */{ ConsCell *cell ; int  i;lp:	printf("conspage at 0x%x(lisp) has %d free cells , next available cell offset is %d ,and next page is 0x%x(lisp) \n",LADDR_from_68k(base),(0xff & base->count),(0xff & base->next_cell), base->next_page );		for( i = 0 , cell = (ConsCell *)base+1; i <127 ; i++,cell++)	 {		printf(" LADDR : %d = Cell[ %d ]## cdr_code= %d ,car = %d \n"		,LADDR_from_68k(cell),i+1,cell->cdr_code,cell->car_field);	 }	if ((linking==T) && (base->next_page != NIL_PTR))	{		base =(struct conspage *) Addr68k_from_LPAGE(base->next_page) ;		goto lp ;	}} /* end dump_conspage *//*********************************//* trace the link in ListpDTD->dtd_nextpage */trace_listpDTD(){extern struct dtd *ListpDTD ; printf("Dump conspages from ListpDTD chain \n"); dump_conspage(Addr68k_from_LPAGE(ListpDTD->dtd_nextpage) , T);}/*************************************/a68k( lispptr)LispPTR lispptr;{  printf("68k: 0x%x (%d) \n",Addr68k_from_LADDR(lispptr),Addr68k_from_LADDR(lispptr));}laddr(addr68k)DLword *addr68k ;{ printf("LADDR : 0x%x (%d)\n",LADDR_from_68k(addr68k),LADDR_from_68k(addr68k));}/*************************************************************//* dump_fnobj(index) */#define DUMPSIZE 40dump_fnobj(index)LispPTR index ; /* atom index */{  struct fnhead *fnobj;  DefCell *defcell68k;  LispPTR cell;  DLbyte *scratch; int i;  defcell68k = (DefCell *)GetDEFCELL68k(index); fnobj = (struct fnhead *)Addr68k_from_LADDR(defcell68k->defpointer); /* check if it's the same index ??*/ if (index != (fnobj->framename)) {	printf("DEFCELL says it is ");	print_atomname(index);	printf("\n But Func OBJ says ");	print_atomname(fnobj->framename);	putchar('\n');	return;   } printf("***DUMP Func Obj << "); printf("start at 0x%x lisp address(0x%x 68k) \n",LADDR_from_68k(fnobj),fnobj); print_atomname(index); putchar('\n'); printf("stkmin    : %d \n",fnobj->stkmin); printf("na        : %d \n",fnobj->na); printf("pv        : %d \n",fnobj->pv); printf("startpc   : %d \n",fnobj->startpc); printf("argtype   : %d \n",fnobj->argtype); printf("framename : %d \n",fnobj->framename); printf("ntsize    : %d \n",fnobj->ntsize); printf("nlocals   : %d \n",fnobj->nlocals); printf("fvaroffset: %d \n",fnobj->fvaroffset);scratch= (DLbyte *)fnobj;for (i= 20; i<(fnobj->startpc); i+=2){printf(" 0x%x(0x%x 68k): 0%o \n",LADDR_from_68k(scratch),scratch,(int)(0xffff & (*((DLword *)(scratch+i)))) );}scratch= (DLbyte *)fnobj + (fnobj->startpc);for (i= 0 ; i< DUMPSIZE; i++,scratch++){printf(" 0x%x(0x%x 68k): 0%o \n",LADDR_from_68k(scratch),scratch,(int)(0xff & (*scratch)) );}} /*dump_fnobj end *//*********************************************************************/ struct doko {  	LispPTR func ;	int     pc ;};struct doko doko(){  struct doko tmp;   printf(" At ");   print_atomname(FuncObj->framename);   putchar('\n');   printf("   PC cnt = 0%o \n" ,tmp.pc=((int)(PC)- (int)FuncObj) );   tmp.func= FuncObj->framename;   return(tmp);}/**** dump specified area (in 32 bit width) ***/dumpl(laddr) LispPTR laddr ;{  int i ;  LispPTR *ptr ;  ptr = (LispPTR *)Addr68k_from_LADDR(laddr);   for(i=0 ; i< 40 ; i++,ptr++)	printf("LADDR 0x%x : %d \n",LADDR_from_68k(ptr),*ptr);}/**** dump specified area (in 16 bit width) ***/dumps(laddr) LispPTR laddr ;{  int i ;  DLword *ptr ;  ptr = (DLword *)Addr68k_from_LADDR(laddr);   for(i=0 ; i< 40 ; i++,ptr++)	printf("LADDR 0x%x : %d \n",LADDR_from_68k(ptr),((*ptr)& 0xffff));}/***********************/printPC(){ unsigned short pc; pc =(int)PC - (int)FuncObj ;printf("PC: O%o ",pc);}/***************************/countchar(string)char *string;{ int cnt=0;while(*string != '\0'){ string++;cnt++;}  return(cnt);}/****************//****************************************************************//***************************************************************//*	Func Name :	dump_stackframe	Desc :		For Debugging Aids	Changed 	8 JUN 1987 TAKE*//***************************************************************/dump_stackframe( fx_addr68k )  struct frameex1 *fx_addr68k ;{  Bframe *bf;  DLword *next68k ;  DLword *ptr ; LispPTR atomindex ; if((fx_addr68k->alink & 1)==0)  {   /* FAST */ 	bf = (Bframe *)(((DLword *)fx_addr68k)  - 2 );    }  else  {   /* SLOW */	bf =(Bframe *) Addr68k_from_LADDR((fx_addr68k->blink+ STK_OFFSET)) ;  }/* Print IVARs */  printf("IVAR -------\n");  ptr = Addr68k_from_LADDR( STK_OFFSET + bf->ivar); while(ptr!=(DLword *)bf){  printf(" %x : %x \n",LADDR_from_68k(ptr),*ptr);  ptr++;} printf("## STACK BF at 0x%x ## \n",(LispPTR)LADDR_from_68k(bf));/* print BF  */ if(bf->flags != 4)	printf("Invalid frame,NOT BX \n"); putchar('[');  if (bf->residual)	printf("Res, ");  if (bf->padding)	printf("Pad, ");  printf("cnt=%d ]\n",bf->usecnt);  printf("ivar : 0x%x \n",bf->ivar);    printf(">> Bf's ivar says 0x%x vs. IVar says 0x%x \n",bf->ivar+STK_OFFSET,LADDR_from_68k(IVar));  atomindex = get_framename(fx_addr68k);  printf("Fname is ");  print_atomname(atomindex);  printf("\n");/***** printout FX ****/  printf("## STACK FX at 0x%x ## \n",LADDR_from_68k(fx_addr68k));  if(fx_addr68k->flags != 6)    printf("Invalid frame,NOT FX \n"); putchar('[');  if(fx_addr68k->fast)		printf("F,");  if(fx_addr68k->incall)	printf("incall, ");  if(fx_addr68k->validnametable)	printf("V, ");  printf("cnt = %d ]\n",fx_addr68k->usecount);  printf(" #alink           0x%x ",fx_addr68k->alink);  if(fx_addr68k->alink & 1)  printf("[SLOWP] \n");  else printf("\n");  printf(" fnheadlo        0x%x \n",fx_addr68k->lofnheader);  printf(" hi1,hi2 fnhead  0x%x , 0x%x \n",fx_addr68k->hi1fnheader,fx_addr68k->hi2fnheader);  printf(" nextblock       0x%x \n",fx_addr68k->nextblock);  printf(" pc              0x%x \n",fx_addr68k->pc);  printf(" lonametbl       0x%x \n",fx_addr68k->lonametable);  printf(" hi1,hi2 nametbl 0x%x , 0x%x  \n",fx_addr68k->hi1nametable,fx_addr68k->hi2nametable);  printf(" #blink           0x%x \n",fx_addr68k->blink);  printf(" #clink           0x%x \n",fx_addr68k->clink); if (fx_addr68k ==CURRENTFX) { 	ptr=PVar;	while(ptr <(CurrentStackPTR+2))	{		printf(" %x : %x \n",LADDR_from_68k(ptr),*ptr);		ptr++;	}  printf("this frame is last !! \n");  return(-1); } next68k = (DLword *)Addr68k_from_LADDR((fx_addr68k->nextblock+STK_OFFSET)) ; ptr =(DLword *)(fx_addr68k+1) ;  while(next68k > ptr)  {    printf(" %x : %x \n",LADDR_from_68k(ptr),*ptr);    ptr++;  }return (0);} /* end dump_stackframe */dump_CSTK(before)int before;{  DLword *ptr ; ptr= CurrentStackPTR - before ;while(ptr != CurrentStackPTR){	printf(" 0x%x : 0x%x \n",LADDR_from_68k(ptr),*ptr);	ptr++;}printf("CurrentSTKP : 0x%x  \n",LADDR_from_68k(CurrentStackPTR));printf("contents :  0x%x \n",*((LispPTR *)(CurrentStackPTR-1)));}/* dump_CSTK end *//******************************************//* BTV */btv(){    struct frameex1 *fx_addr68k;  LispPTR atomindex ; struct frameex1 *get_nextFX();  fx_addr68k = CURRENTFX ;  atomindex = get_framename(fx_addr68k); while(atomindex != ATOM_T)  {	dump_stackframe(fx_addr68k);	fx_addr68k= get_nextFX(fx_addr68k);	atomindex = get_framename(fx_addr68k);  } /* dump T frame */ dump_stackframe(fx_addr68k); printf("\n BTV end ********\n");} /*end btv*/  get_framename(fx_addr68k)  struct frameex1 *fx_addr68k ;{  struct fnhead *fnheader;  LispPTR scratch ;/* Get FNHEAD */  if(fx_addr68k->validnametable==0) {	scratch = (unsigned int)fx_addr68k->hi2fnheader << 16 ;	scratch |= (unsigned int)(fx_addr68k->lofnheader) ;	fnheader = (struct fnhead *)Addr68k_from_LADDR(scratch ) ;    }  else {	scratch = (unsigned int)(fx_addr68k->hi2nametable << 16);	scratch |= (unsigned int) (fx_addr68k->lonametable);	fnheader = (struct fnhead *)Addr68k_from_LADDR( scratch );    }   return(fnheader->framename);}/* get_framename end */ /**********************************************************************/ struct frameex1 *get_nextFX(fx_addr68k)  struct frameex1 *fx_addr68k;{ DLword *pv ; if(fx_addr68k->alink & 1)   pv = (DLword *)Addr68k_from_LADDR((STK_OFFSET | (fx_addr68k->alink -1))); else pv = (DLword *)Addr68k_from_LADDR((STK_OFFSET | fx_addr68k->alink)); return((struct  frameex1 *)(pv - FRAMESIZE)); } /* get_nextFX end *//*************************************************************//***************************/MAKEATOM(string)char *string;{ int length; length = countchar(string);  return(make_atom(string,0,length,0));}/****************/GETTOPVAL(string) char *string;{  int index;  LispPTR *cell68k; index=MAKEATOM(string); cell68k= (LispPTR *)GetVALCELL68k(index);  print(*cell68k);}S_TOPVAL(string) char *string;{  int index;  LispPTR *cell68k; int length; char dummy[256]; dummy[0]='\\';  for(length=1; *string != '\0'; length++,string++)  { dummy[length] = *string;} index=make_atom(dummy,0,length,0); cell68k= (LispPTR *)GetVALCELL68k(index);  print(*cell68k);}/***************/S_MAKEATOM(string) char *string;{  int index=0; int length; char dummy[256]; dummy[0]='\\';  for(length=1; *string != '\0'; length++,string++)  { dummy[length] = *string;} index=make_atom(dummy,0,length,0);  printf("#Atomindex : %d \n",index); return(index);}/****************************************************************************//*     all_stack_dump(start,end)  */typedef struct stack_header {	unsigned	flags1 : 3;	unsigned	flags2  : 5;		unsigned	usecount : 8 ; } STKH ;all_stack_dump(start,end,silent) DLword start,end ,silent; /* Stack offset in DLword */{  STKH *stkptr;  DLword *start68k,*end68k;  DLword size,dummy; extern IFPAGE *InterfacePage; if(start==0) start68k= Stackspace + InterfacePage->stackbase; else start68k = Addr68k_from_LADDR(STK_OFFSET | start) ; if(end==0) end68k= Stackspace+ InterfacePage->endofstack; else end68k = Addr68k_from_LADDR(STK_OFFSET | end) ; stkptr= (STKH *)start68k;  while(((DLword*)stkptr) < end68k )  {	dummy = LADDR_from_68k(stkptr);	switch (stkptr->flags1 ) {	case STK_FSB :			if(((stkptr->flags2 !=0) || (stkptr->usecount!=0))			 ||((dummy %2)!=0) || (*((DLword *)stkptr) == 0xffff))			{if(!silent)putchar('-');((DLword *)stkptr)++; break;}			size = *(((DLword *)stkptr) +1) ;			if(size==0)			 {	if(!silent)putchar('+');				stkptr++; break;}			printf("\n<<  0x%x FSB size : 0x%x >>\n",LADDR_from_68k(stkptr),size);			((DLword *)stkptr) += size;			break ;	case STK_GUARD :			if(((stkptr->flags2 !=0) ||(stkptr->usecount!=0))			||((dummy %2)!=0) || (*((DLword *)stkptr)== 0xffff))			 {	if(!silent)putchar('>');				((DLword *)stkptr)++; break;}			size = *(((DLword *)stkptr) +1) ;			if(size==0)			 {	if(!silent)putchar('?');				((DLword *)stkptr)++; break;}			printf("\n<<  0x%x GUARD size : 0x%x >>\n",LADDR_from_68k(stkptr),size );			((DLword *)stkptr) += size;			break ;	case STK_FX :				if((((FX *)stkptr)->pc ==0)|| (((FX *)stkptr)->pc < 24) || (((FX *)stkptr)->alink==0)  || (stkptr->usecount > 31)) {if(!silent) putchar('~');((DLword *)stkptr)++; break;}			 /******			if(((dummy+FRAMESIZE) % 4) != 0) {if(!silent) putchar('!');((DLword *)stkptr)++; break;} ** 18 Nov*/			if(!silent)putchar('\n');			printf("<<  0x%x: FX for ",LADDR_from_68k(stkptr));			print_atomname(get_framename(stkptr));			printf(" >> \n");			if(!silent){			printf("  [");			if(((FX *)stkptr)->fast)		printf("F,"); 			if(((FX *)stkptr)->incall)	printf("incall,");  			if(((FX *)stkptr)->validnametable)	printf("V,"); 			printf("cnt = %d ]\n",((FX *)stkptr)->usecount);			printf("  #alink   0x%x ",((FX *)stkptr)->alink); 			if(((FX *)stkptr)->alink & 1) 			 printf("[SLOWP] \n");  			else printf("\n");			printf(" nextblock 0x%x \n",((FX *)stkptr)->nextblock);			printf("  #blink   0x%x \n",((FX *)stkptr)->blink);				printf("  #clink   0x%x \n",((FX *)stkptr)->clink);			} 			if((FX *)stkptr == CURRENTFX) {			((DLword *)stkptr) += FRAMESIZE ;			break; }			else {			stkptr=Addr68k_from_LADDR(STK_OFFSET| ((FX *)stkptr)->nextblock) ;			break;}	case STK_BF :			if(((Bframe *)stkptr)->ivar == 0)			{ if(!silent)putchar('*');((DLword *)stkptr)++; break;}			if(!silent)putchar('\n');			printf("<<  0x%x: BF ",LADDR_from_68k(stkptr));			if(!silent){			 putchar('['); 			if (((Bframe *)stkptr)->residual)	printf("Res,"); 			if (((Bframe *)stkptr)->padding)	printf("Pad,"); 			printf("cnt=%d ]\n",((Bframe *)stkptr)->usecnt);			printf("ivar : 0x%x \n",((Bframe *)stkptr)->ivar);			} else  putchar('\n');			((DLword *)stkptr) += 2;			break;	default :			if(!silent) putchar('.');			((DLword *)stkptr)++;			break;	} /* case end */	  } /* while end */printf("<< That's All , last stack :0x%x >> \n",InterfacePage->endofstack);}/************************************************************/dtd_chain(type) DLword type;{  struct dtd *dtdp;  LispPTR next;  LispPTR *next68k; dtdp=(struct dtd *)GetDTD(type); next=dtdp->dtd_free; next68k=(LispPTR *) Addr68k_from_LADDR(next); while((*next68k) != 0) {  	if(type != GetTypeNumber(next)) {	printf("BAD cell in next dtdfree \n");	  return; }	print(next);	putchar('\n');	next= *next68k;	next68k=(LispPTR *) Addr68k_from_LADDR(next); } printf("That's All !\n");}/*  dtd_chain end **/check_dtd_chain(type) DLword type;{  struct dtd *dtdp;  LispPTR next;  LispPTR *next68k; LispPTR before; dtdp=(struct dtd *)GetDTD(type); if(dtdp->dtd_free==0) {		printf(" Type %d is exhausted.\n",type); 		return;} if(GetTypeNumber(dtdp->dtd_free) != type)   error("BAD cell in dtdfree "); next=dtdp->dtd_free; next68k=(LispPTR *) Addr68k_from_LADDR(next); while((*next68k) != 0) {  	if(type != GetTypeNumber(next)) {	error("BAD cell in next dtdfree ");	  return; }	before = next;	next= *next68k;	next68k=(LispPTR *) Addr68k_from_LADDR(next);	if(*next68k == before) error("CIRCULER founded"); }putchar('.');}/*  cehck_dtd_chain end **/