/* This is G-file %M% Version %I% (%G%). copyright Xerox & Fuji Xerox  *//***	funcallmacro.h	By Takeshi	3-Dec-87***/#define FNDEFCELL68K ((DefCell *)wordp)#define TMP_FNCELL68K ((struct fnhead *)cellp)#define APPLYSTKOVER_ATOM arg1#define APPLY_ARGNUM	arg2#define CLOSUREFUNCP arg3#define RESTARGS	arg1#define FNPV_NUM	result#define NEXTBLOCK	arg2#define LOCFNCELL	((struct fnhead *) wordp)#define OPAPPLY	{\  /** register DefCell *defcell68k -> wordp Definition Cell PTR */\  /*register int FNPV_NUM->result*/\  /** register LispPTR APPLYSTKOVER_ATOM;-> arg1 */\ /** register struct fnhead *TMP_FNCELL68K; -> cellp */\ /**  register DLword APPLY_ARGNUM ;->arg2 Num of args */\ /** int RESTARGS ;->arg1 use for arignments */\  register CClosure *closure68k; /* closure object*/\\  CLOSUREFUNCP=NIL; /* if closure,T else NIL */\  if(*(CSTKPTR) != SPOS_HI)\	error("OP_apply:Illegal data on Stack");\  else\	APPLY_ARGNUM = *(CSTKPTR+1) ;\  /* Get Next Block offset form OPCODE byte */\  CURRENTFX->nextblock = (LADDR_from_68k(CSTKPTR) & 0x0ffff)\					- (APPLY_ARGNUM<<1) /* -1 */;\  /* Setup IVAR */\  IVAR = Addr68k_from_LADDR((((LispPTR)(CURRENTFX->nextblock)) | STK_OFFSET)) ;\  /* Set PC to the Next Instruction and save into FX */\  CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 1 ;  \  if( (TOPOFSTACK  & 0xffff0000) == 0)\   { /* applyCode */\	APPLYSTKOVER_ATOM=TOPOFSTACK;\	FNDEFCELL68K =(DefCell *) GetDEFCELL68k(TOPOFSTACK) ;\	if( FNDEFCELL68K->ccodep == 0 )\	 {\	   /* This LispFunc is NOT compiled object . We must use Interpreter*/\		FNDEFCELL68K = (DefCell *)GetDEFCELL68k(ATOM_INTERPRETER);\		CSmashStack(TOPOFSTACK);  /* Move AtomIndex to CSTK */\		APPLYSTKOVER_ATOM=ATOM_INTERPRETER;\	 }\	else\	 { /* Added 26-Apr-87 */\		CSTKPTR -= 2 ;  /* to smash Arg Num on CSTK */\	 }\   }\  else\   { /* notCCode :  This Object may be Lambda Expr or C-Closure */\	/* add this clause on Aug 18 87 by take */\	if(GetTypeNumber(TOPOFSTACK)==TYPE_COMPILED_CLOSURE)\	{ /* setup closure */\		CLOSUREFUNCP=T;\		/* get closure object */\		/* And closure obj , They are equal pointer */\\		closure68k=(CClosure *)Addr68k_from_LADDR(TOPOFSTACK);\		FNDEFCELL68K =(DefCell *)closure68k;\		APPLYSTKOVER_ATOM=TOPOFSTACK;\	/* Added 09-Nov-87 by Hayata */\		CSTKPTR -= 2 ;  /* to smash Arg Num on CSTK */\	} /* if end */\	else /* Lambda Expr */\	{ \		/* prepare to call INTERPRETER */\		FNDEFCELL68K = (DefCell *)GetDEFCELL68k(ATOM_INTERPRETER);\		CSmashStack(TOPOFSTACK);  /* Move Object Pointer to CSTK */\		APPLYSTKOVER_ATOM=ATOM_INTERPRETER;\	} /* else end */\   }\  TMP_FNCELL68K = (struct fnhead *)Addr68k_from_LADDR( FNDEFCELL68K->defpointer ) ;\/* stack overflow check */\if((unsigned int)(CSTKPTR + TMP_FNCELL68K->stkmin + STK_SAFE) >=  (unsigned int)StkLimO )\	{\		TOPOFSTACK = APPLYSTKOVER_ATOM;\		CFnStkOvr(APPLY_ARGNUM,0);\		NEXTOPCODE;\	}\  FuncObj = TMP_FNCELL68K ;/* Nov 25 87 take */\ if( FuncObj->na >= 0 )\  {\	/* This Function is Spread Type */\	/* Arguments on Stack Adjustment  */\	/* Here,arg1 uses as RESTARGS(before APPLYSTKOVER_ATOM) */\	RESTARGS = APPLY_ARGNUM - FuncObj->na ;\	while(RESTARGS <0) { \	  CPushStack(NIL_PTR) ;\	  RESTARGS++;\	}\	CSTKPTR -= (RESTARGS<<1) ;\  } /* if end */\ /* Set up BF */\ CSTKPTR += 2;\ /*** *(++CSTKPTR) = BF_MARK ;**/\/**  *(++CSTKPTR) = CURRENTFX->nextblock ;***/\ *((LispPTR *)CSTKPTR) = BF_MARK32 | (CURRENTFX->nextblock) ;\ /* Set up FX */\ CSTKPTR += 2;\ *(CSTKPTR) = FX_MARK;\ CURRENTFX = (struct frameex1 *)CSTKPTR ;\ CURRENTFX->alink = LADDR_from_68k(PVAR);\ CURRENTFX->lofnheader = (FNDEFCELL68K->defpointer) & 0x0ffff ;\ CURRENTFX->hi2fnheader = ((FNDEFCELL68K->defpointer) & 0x0ff0000) >> 16 ;\ /*  Set PVAR pointer */\ PVAR = CSTKPTR = (DLword *)CURRENTFX + FRAMESIZE ;\ /* Set up PVAR area */\ FNPV_NUM = FuncObj->pv +1 ; /* Apr. 27 */\/* The following lines added on Aug 18 1987 by take */\/* IF CLOSUREFUNCP then Put the closure environmentto top of PVAR slot */\if(CLOSUREFUNCP)\{\	*((LispPTR *)CSTKPTR) = closure68k->env_ptr ;\	CSTKPTR += DLWORDSPER_CELL ;\	*((LispPTR *)CSTKPTR) = 0xFFFF0000 ; \	CSTKPTR += DLWORDSPER_CELL ; \	FNPV_NUM--;\} /* clouserp end */\ while(FNPV_NUM > 0) {\	*((LispPTR *)CSTKPTR) = 0x0ffff0000 ;\	CSTKPTR += DLWORDSPER_CELL ;\	*((LispPTR *)CSTKPTR) = 0x0ffff0000 ;\	CSTKPTR += DLWORDSPER_CELL ; \	FNPV_NUM--;\  }\ /** CSTKPTR ++ ;***/\ /* Set PC points New Function's first OPCODE */\ PCMAC = (ByteCode *)FuncObj + FuncObj->startpc ;\} /* end OPAPPLY *//****************************************************************//******			 OPFN(x)			 ********//****************************************************************/#define OPFN(x)	{ /* x is a number of the arguments on stack */\  DefCell *defcell;\  save_atom_index = Get_DLword(PCMAC+1); \  defcell = (DefCell *) GetDEFCELL68k(Get_DLword(PCMAC+1)) ;\  if( defcell->ccodep == 0 ) { goto ni; }\  LOCFNCELL = (struct fnhead *)Addr68k_from_LADDR(defcell->defpointer) ;\  if((unsigned int)(CSTKPTR + LOCFNCELL->stkmin +STK_SAFE) >=  (unsigned int)StkLimO )  {goto ni; }\  CURRENTFX->nextblock = NEXTBLOCK = LADDR_from_68k(CSTKPTR-(x<<1)+2) & 0x0ffff ;\  IVAR = Addr68k_from_LADDR((((LispPTR)NEXTBLOCK)) | STK_OFFSET) ;\  CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 3 ; \  CPushCStack ;  /* save TOS */\  if( LOCFNCELL->na >= 0 )\  {\	RESTARGS = x - LOCFNCELL->na ;\	while(RESTARGS <0) { \	 CPushStack(NIL_PTR) ;\	  RESTARGS++;\	}\	CSTKPTR -= (RESTARGS<<1) ;\  } /* if end */\ /* Set up BF */\ CPushStack(BF_MARK32 | NEXTBLOCK);\ CURRENTFX = (struct frameex1 *)(CSTKPTR) ;\ *((LispPTR *)CSTKPTR) = (FX_MARK << 16) | (LADDR_from_68k(PVAR) & 0x0ffff);\ ((struct frameex1 *)CSTKPTR)->lofnheader = defcell->defpointer;\ ((struct frameex1 *)CSTKPTR)->hi2fnheader = *((ByteCode *)(defcell) + 1);\  PVAR = CSTKPTR += FRAMESIZE ;\  result = LOCFNCELL->pv+1 ;\  while(result > 0) {\	*((LispPTR *)CSTKPTR++) = 0x0ffffffff ;\	*((LispPTR *)(CSTKPTR++)) = 0x0ffffffff ;\	result--;\  }\ CSTKPTR += 2 ; \ PCMAC = (ByteCode *)LOCFNCELL + LOCFNCELL->startpc ;\ FuncObj = LOCFNCELL  ; \} /* end OPFN *//*************** OPFNX *************/#define OPFNX	{ \  register struct definition_cell *defcell68k ;  /* Definition Cell PTR */\ /*  register short pv_num -> result;*/ /* scratch for pv */\  /***register struct fnhead *TMP_FNCELL68K;**/ \ /* int RESTARGS ; is arg1  use for arignments */ \  register CClosure *closure68k; \  /* int CLOSUREFUNCP is arg3 */ \ CLOSUREFUNCP =NIL;\ /* Get aromindex (result)*/ \/* result = (Get_BYTE(PCMAC+2) <<8) | Get_BYTE(PCMAC +3) ;  */\ result = Get_DLword(PCMAC+2);\  /* Get Next Block offset from argnum */ \  CURRENTFX->nextblock = (LADDR_from_68k(CSTKPTR) & 0x0ffff) \					- ((Get_BYTE(PCMAC +1))<<1) +4 /*+3*/ ; \  /* Setup IVAR */ \  IVAR = Addr68k_from_LADDR((((LispPTR)(CURRENTFX->nextblock)) | STK_OFFSET)) ;\  /* Set PC to the Next Instruction and save into FX */\  /* we assume FNX's bytenum is 4 */ \  CURRENTFX->pc = ((unsigned int)PCMAC - (unsigned int)FuncObj) + 4 ; \  CPushCStack ;  /* save TOS */\  /* Get DEFCELL 68k address */ \  defcell68k =(struct definition_cell *) GetDEFCELL68k(result) ; \  if( defcell68k->ccodep == 0 ) \  { \   /* This clause added on 18-Aug-87 take */\	if(GetTypeNumber(defcell68k->defpointer)==TYPE_COMPILED_CLOSURE)\	 { /* setup closure */\		CLOSUREFUNCP=T;\		/* get closure object */\		closure68k=(CClosure *)Addr68k_from_LADDR(defcell68k->defpointer);\		/* Defcell is equal to Closure->defptr */\		defcell68k=(DefCell *)closure68k ;\	 } /* if end */\	else {\  	/* This LispFunc is NOT compiled object . We must use Interpreter*/\	defcell68k = (struct definition_cell *)GetDEFCELL68k(ATOM_INTERPRETER);\	CPushStack(result); /* provide the argument for INTERPRETER */\	result=ATOM_INTERPRETER;\	 } /*else end */\  }\    /* Nov 25 87 take */\  TMP_FNCELL68K = (struct fnhead *)Addr68k_from_LADDR( defcell68k->defpointer ) ;\if((unsigned int)(CSTKPTR + TMP_FNCELL68K->stkmin +STK_SAFE) >=  (unsigned int)StkLimO )\	{\		if(CLOSUREFUNCP)\		TOPOFSTACK = LADDR_from_68k(closure68k);\		else\		TOPOFSTACK= result;\		CFnStkOvr(Get_BYTE(PCMAC +1),3);\		NEXTOPCODE;\	}\  FuncObj = TMP_FNCELL68K  ; /* Nov 25 87 take */\ if( FuncObj->na >= 0 )\  {\	/* This Function is Spread Type */\	/* Arguments on Stack Adjustment  */\	RESTARGS = Get_BYTE(PCMAC +1)- FuncObj->na ;\	while(RESTARGS <0) { \	 CPushStack(NIL_PTR) ;\	  RESTARGS++;\	}\	CSTKPTR -= (RESTARGS<<1) ;\  } /* if end */\ /* Set up BF */\ CSTKPTR +=2 ; \ *((LispPTR *)CSTKPTR) = BF_MARK32 | (CURRENTFX->nextblock) ; \ /* *(++CSTKPTR) = BF_MARK ; */\/* *(++CSTKPTR) = CURRENTFX->nextblock ; */\ /* Set up FX */\ CSTKPTR +=2 ; \ *(CSTKPTR) = FX_MARK;\ /* Now SET new FX */\ CURRENTFX = (struct frameex1 *)CSTKPTR ;\ CURRENTFX->alink = LADDR_from_68k(PVAR);\ CURRENTFX->lofnheader = (defcell68k->defpointer) & 0x0ffff ;\ CURRENTFX->hi2fnheader = ((defcell68k->defpointer) & 0x0ff0000) >> 16 ;\ /*  Set PVAR pointer */\ PVAR = CSTKPTR = (DLword *)CURRENTFX + FRAMESIZE ;\ /* Set up PVAR area   NOW result uses as pv_num*/\ result = FuncObj->pv+1 ; /* Changed Apr.27 */\/* The following lines added on Aug 18 1987 by take */\/* IF CLOSUREFUNCP then Put the closure environmentto top of PVAR slot */\if(CLOSUREFUNCP)\{\	*((LispPTR *)CSTKPTR) = closure68k->env_ptr ;\	CSTKPTR += DLWORDSPER_CELL ;\	*((LispPTR *)CSTKPTR) = 0xFFFF0000 ; \	CSTKPTR += DLWORDSPER_CELL ;\	result--;\} /* clouserp end */\ while(result > 0) {\	*((LispPTR *)CSTKPTR) = 0x0ffff0000 ;\	CSTKPTR += DLWORDSPER_CELL ;\	*((LispPTR *)CSTKPTR) = 0x0ffff0000 ;\	CSTKPTR += DLWORDSPER_CELL ;\	result--;\  }\/** CSTKPTR ++ ;**/\ /* Set PC points New Function's first OPCODE */\ PCMAC = (ByteCode *)FuncObj + FuncObj->startpc ;\} /* end OPFN */#define OPCHECKAPPLY {\	wordp =(DLword *) GetDEFCELL68k(TOPOFSTACK) ; \	if( ( ((struct definition_cell *)wordp)->ccodep ) && ( ( ((struct definition_cell *)wordp)->argtype == 0 ) ||  \	                    ( ((struct definition_cell *)wordp)->argtype == 2 )    )) \		{\		PCMAC++;\		NEXTOPCODE;\		}\	else {\		UFN(017); \		NEXTOPCODE;\		}\	}