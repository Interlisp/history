/* @(#) unixcomm.c Version 2.23 (3/18/89). copyright envos & Fuji Xerox  */static char *id = "@(#) unixcomm.c	2.23 3/18/89		(envos & Fuji Xerox)";/*Unix Interface Communications*//************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/#include "lispemul.h"#include "address.h"#include "address68k.h"#include "lisptypes.h"#include "lispmap.h"#include "emulglobal.h"#include "lispglobal.h"#include "cell.h"#include "stack.h"#include "arith.h"/* JRB - timeout.h needs setjmp.h */#ifdef HP#include <sys/ioctl.h>#endif#include <setjmp.h>#include "timeout.h"#include <stdio.h>#include <sgtty.h>#include <sys/file.h>#include <signal.h>#include <sys/wait.h>#include <errno.h>#include "dbprint.h"#include <sys/types.h>#include <sys/socket.h>#include <sys/un.h>#define NPROCS 100#define	LispStringToCString(Lisp, C){	\	LispPTR	*naddress;				\	char	*base;					\	int	length;					\	int	offset;					\	naddress = (LispPTR *)(Addr68k_from_LADDR(Lisp));		\	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base)); \	offset = (int)(((OneDArray *)naddress)->offset);	\	length = ((OneDArray *)naddress)->totalsize;		\	length = (length <= 150) ? length : 150;		\	strncpy(C, base + offset, length);	\	C[length] = '\0';				\	}/* The following globals are used to communicate between Unix   subprocesses and LISP */int ForkedIns[NPROCS],		/* Pipes going from Unix to LISP */    ForkedOuts[NPROCS],		/* Pipes going from LISP to Unix */    ForkedPIDs[NPROCS],		/* Process IDs of forked processes */    ForkedStatus[NPROCS],	/* The value returned by a subprocess */				/* (not shell) */    ForkedProcType[NPROCS];	/* -1 = PTY shell, -2 = process stream */long StartTime;			/* Time, for creating pipe filenames */#define valid_slot(slot) (slot >= 0 && slot < NPROCS && ForkedPIDs[slot])char shcom[150];		/* Here because I'm suspicious of */				/* large allocations on the stack *//* fork_Unix is the secondary process spawned right after LISP is   started, to avoid having TWO 8 mbyte images sitting around. It listens   to the pipe LispToUnix waiting for requests, and responds on UnixToLisp.   The data passed through this pipe is in 4 byte packets, of the form:   Byte 0:   Command character, one of:                   S: Fork PTY (shell) process. This is used for CHAT windows.		   F: Fork piped shell		   K: Kill process		   E: Exit (kill all subprocesses)		   C: Close stdin to subprocess		   W: call WAIT3 & get one process's close info.   Byte 1:   Process number (0 to NPROCS - 1)             Not used for S, F, and E commands	     [For S, pty letter]	     [For F, process # for pipe naming]   Byte 2:   Value, used as follows:             Only used for W command, contains byte to write	     [For S, pty number]   Byte 3:   Slot number.In the case of a F command, additional data follows the 4 byte packet.This consists of one byte representing the length of the shell commandstring, and the string itself.fork_Unix will return another 4 byte packet. The bytes are the same as thoseof the packet received except:   F:        Byte 2 is job number             Byte 3 is 1 if successful, 0 if not   S:        Byte 2 is job number             Byte 3 is 1 if successful, 0 if not   R:        Byte 2 is value of byte read from stdin, if any             Byte 3 is 1 if successful, 2 if EOF, 0 if nothing waiting   W:        Bytes 0 & 1 are the Process ID of the terminated process	     Bytes 2 & 3 are the high & low bytes of the exit status.   K:        Bytes 1 and 2 are the high and low bytes of the exit status             of the process.	     Byte 3 is 1 if an exit status was available.   E:        Always the same   C:        Always the same*/fork_Unix(){  int LispToUnix[2],		/* Incoming pipe from LISP */      UnixToLisp[2],		/* Outgoing pipe to LISP */      UnixToProcess[2],		/* Temporaries */      ProcessToUnix[2],      LispPipeIn, LispPipeOut, res, pid, slot;  char IOBuf[4], tmp[2];  /* Pipes between LISP subr and process */  if (pipe(LispToUnix) == -1) {    perror("pipe");    exit(-1);  }  if (pipe(UnixToLisp) == -1) {    perror("pipe");    exit(-1);  }  for (slot = 0; slot < NPROCS; slot++)    ForkedPIDs[slot] = 0;		/* I don't trust it, do you? */  StartTime = time(0);		/* Save the time, to create filenames with */  StartTime &= 0xFFFFFF;	/* as a positive number! */  if ((UnixPID = fork()) == -1) {  /* Fork off small version of the emulator */    perror("fork");    exit(-1);  }  if (UnixPID != 0) {    UnixPipeIn = UnixToLisp[0];    UnixPipeOut = LispToUnix[1];    close(LispToUnix[0]);    close(UnixToLisp[1]);    return(1);  }  LispPipeIn = LispToUnix[0];  LispPipeOut = UnixToLisp[1];  close(LispToUnix[1]);  close(UnixToLisp[0]);  res = fcntl(LispPipeIn, F_GETFL, 0);  res &= (65535-FNDELAY);  res = fcntl(LispPipeIn, F_SETFL, res);  while (1) {    int len;    len = 0;    while (len != 4)    {      if ((len = read(LispPipeIn, IOBuf, 4)) <0)	{	/* Get packet */	  perror("Packet read by slave");	  /*      kill_comm_processes(); */	  exit(0);	}      if (len != 4)	{	  DBPRINT(("Input packet wrong length:  %d.\n", len));	  exit(0);	}    }    slot = IOBuf[3];    IOBuf[3] = 1;    switch(IOBuf[0]) {    case 'S':			/* Fork PTY shell */      if (slot >= 0)	{ /* Find a free slot */	  res = ForkUnixShell(slot, IOBuf[1], IOBuf[2]);   /* Alloc a PTY and fork  */	  if (res == -1)	    {	      printf("Impossible failure from ForkUnixShell??\n");	      fflush(stdout);	      IOBuf[3] = 0;	    }	  else	    {	      /* ForkUnixShell sets the pid and standard in/out variables */	      ForkedStatus[slot] = -1;	      IOBuf[1] = (ForkedPIDs[slot]>>8)& 0xFF;	      IOBuf[2] = ForkedPIDs[slot] & 0xFF;	    }        }      else 	{	  printf("Can't get process slot for PTY shell.\n");	  fflush(stdout);	  IOBuf[3] = 0;	}       break;    case 'F':			/* Fork pipe command */      if (slot >= 0) 		{	/* Find a free process slot */	/* Read in the length of the shell command, and then the command */	if(read(LispPipeIn, tmp, 1)<0) perror("Slave reading cmd length");	if(read(LispPipeIn, shcom, *tmp)<0) perror("Slave reading cmd");	DBPRINT(("Cmd len = %d.\n", *tmp));	DBPRINT(("Rev'd cmd string: %s\n", shcom));	ForkedPIDs[slot] = fork(); /* Fork */	if (ForkedPIDs[slot] == 0)	  {	    int i;	    int status, sock;	    struct sockaddr_un addr;	    char PipeName[40];	    sock = socket(AF_UNIX, SOCK_STREAM, 0);	    if (sock < 0) {perror("slave socket"); exit(0);}	    sprintf(PipeName, "/tmp/LispPipe%d-%d", StartTime, slot);	    addr.sun_family = AF_UNIX;	    strcpy(addr.sun_path, PipeName);	    status = connect(sock, (struct sockaddr *)&addr,			     strlen(PipeName)+sizeof(addr.sun_family));	    if(status<0)	      {		perror("slave connect");		printf("Name = %s.\n", PipeName); fflush(stdout);		exit(0);	      }	    else	      {		DBPRINT(("Slave connected on %s.\n", PipeName));	      }	    /* Copy the pipes onto stdin, stdout, and stderr */	    dup2(sock,0);	    dup2(sock,1);	    dup2(sock,2); 	    /* Make sure everything else is closed */	    for (i = 3; i < getdtablesize(); i++)	      close(i);	    /* Run the shell command and get the result */	    status = system(shcom);	    unlink(PipeName);	    _exit((status & ~0xff) ? (status >> 8) : status);	  }	/* Check for error doing the fork */	if (ForkedPIDs[slot] == -1)	  {	    ForkedPIDs[slot] = 0;	    perror("unixcomm: fork");	    IOBuf[3] = 0;	  }	else	  {	    IOBuf[1] = (ForkedPIDs[slot]>>8)& 0xFF;	    IOBuf[2] = ForkedPIDs[slot] & 0xFF;	  }      } else IOBuf[3] = 0; /* Couldn't get a process slot */      break;    case 'W':			/* Wait for a process to die. */      {	int pid;	union wait status;	int slot;	status.w_status = 0;	IOBuf[0] = 0; IOBuf[1] = 0;	DBPRINT(("About to wait for processes.\n"));	if (((pid = wait3(&status, WNOHANG, 0)) != 0))	  {	    /* Ignore processes which are suspended but haven't exited	       (this shouldn't happen) */	    if (status.w_stopval == WSTOPPED) break;	    IOBuf[3] = status.w_T.w_Retcode;	    IOBuf[2] = status.w_T.w_Termsig;	    IOBuf[1] = pid & 0xFF;	    IOBuf[0] = (pid>>8) & 0xFF;          }	DBPRINT(("wait3 returned pid = %d.\n", pid));      }      break;    case 'C':			/* Close stdin to subprocess */      slot = IOBuf[1];      /* If this is a valid job */      if (valid_slot(slot)) {	  /* First check to see it hasn't already died */	  if (ForkedStatus[slot] != -1) {	    ForkedIns[slot] = 0;	  }      }      break;    case 'K':			/* Kill subprocess */      break;    } /* End of switch */    /* Return the status/data packet */    write(LispPipeOut, IOBuf, 4);  }}/************************************************************************//*									*//*		f i n d _ p r o c e s s _ s l o t			*//*									*//*	Find the slot in ForkedPIDs with process id 'pid'.		*//*	If 'pid' is 0, find the first free slot.			*//*	Returns the slot #, or -1 if pid isn't found (or none free)	*//*									*//*									*//************************************************************************/int find_process_slot(pid)/* Find a slot with the specified pid (can be 0 to find a free slot) */  register int pid;  {    register int slot;    for (slot = 0; slot < NPROCS; slot++)      if (ForkedPIDs[slot] == pid)	{	  DBPRINT(("find_process_slot = %d.\n", slot));	  return slot;	}    return -1;  }/************************************************************************//*									*//*									*//*									*//*									*//*									*//*									*//************************************************************************//************************************************************************//*									*//*		w a i t _ f o r _ c o m m _ p r o c e s s e s		*//*									*//*									*//*									*//*									*//************************************************************************/wait_for_comm_processes(hang)     int hang;{  int pid;  int slot;  unsigned char d[5];  d[0] = 'W';  write(UnixPipeOut, d, 4);  read(UnixPipeIn, d, 4);  pid = (d[0]<<8) | d[1];  while ((pid != 0) && (pid != 65535))    {      slot = find_process_slot(pid);      /* Ignore processes that we didn't start (shouldn't happen but         occasionally does) */      if (slot >= 0)	{	  if (d[2] == 0)	    {#ifdef  DEBUG	      printf("Process %d exited status %d\n", pid, d[3]);#endif	      ForkedStatus[slot] = d[3];	    }	  else	    {#ifdef  DEBUG	      printf("Process %d terminated with signal %d\n", pid, d[2]);#endif	      ForkedStatus[slot] = (d[2] << 8);            }	}      /* Look for another stopped process. */      d[0] = 'W';      write(UnixPipeOut, d, 4);      read(UnixPipeIn, d,4);      pid = (d[0]<<8) | d[1];    }}/************************************************************************//*									*//*		k i l l _ c o m m _ p r o c e s s e s			*//*									*//*	Kill off forked PTY-shells and forked-command processes		*//*									*//*									*//************************************************************************/kill_comm_processes() /* Kill all the subprocesses we started */{  int slot;  for (slot = 0; slot < NPROCS; slot++)    /* If this slot has an active job */    if (ForkedPIDs[slot] != 0) {      /* Kill it and all its kids */      /* killpg(ForkedPIDs[slot], SIGKILL); */      if (kill(ForkedPIDs[slot], SIGKILL)<0) perror("Killing process");      ForkedPIDs[slot] = 0;      if (ForkedProcType[slot] == -1)	{	  DBPRINT(("Kill 5 closing desc %d.\n", ForkedIns[slot]));	  close(ForkedIns[slot]);	  ForkedProcType[slot] = 0;	}      else if (ForkedProcType[slot] == -2)	/* named socket pair */	{	  char PipeName[40];	  DBPRINT(("Kill 5 closing desc %d.\n", ForkedIns[slot]));	  close(ForkedIns[slot]);	  ForkedProcType[slot] = 0;	  sprintf(PipeName, "/tmp/LispPipe%d-%d", StartTime, slot);	  unlink(PipeName);	}    }  wait_for_comm_processes(0);}/************************************************************************//*									*//*		    F i n d A v a i l a b l e P t y			*//*									*//*	Given strings Master and Slave, fill them with path names	*//*	of the forms:							*//*									*//*		Master:  /dev/ptyxx					*//*		Slave:   /dev/ttyxx					*//*									*//*	Which are the first available pty/tty pair for communicating	*//*	with a forked shell.						*//*									*//*	Assumes that valid PTY names are [pqr][0-f]; if your system	*//*	is different, you'll need to change it.				*//*									*//************************************************************************/#define PTYLETTERS "pqr"#define PTYNUMBERS "0123456789abcdef"/* Find the first PTY pair that is not in use */FindAvailablePty(Master, Slave)char *Master, *Slave;{  int res, flags;  char *let, *num;  /* From p to r */  for (let = PTYLETTERS; *let != 0; let++)    /* and 0 to f */    for (num = PTYNUMBERS; *num != 0; num++) {      sprintf(Master, "/dev/pty%c%c", *let, *num);      sprintf(Slave, "%c%c", *let, *num);      DBPRINT(("Trying %s. ", Master));      /* Try to open the Master side */      res = open(Master, O_RDWR);      if (res != -1)	{	  flags = fcntl(res, F_GETFL, 0);	  flags |= FNDELAY;	  flags = fcntl(res, F_SETFL, flags);	  return(res);	}    }  return(-1);}/************************************************************************//*									*//*			F o r k U n i x S h e l l			*//*									*//*	Fork a PTY connection to a C-shell process.			*//*									*//*									*//************************************************************************//* Creates a PTY connection to a csh */ForkUnixShell(slot, ltr, numb)  int slot;  char ltr, numb;  {    char PtySlave[20], buf[1];    int res, PID, MasterFD, SlaveFD;    struct sgttyb tio;    /* Get a PTY pair */    PID = fork();    if (PID == 0)      {	/* Divorce ourselves from /dev/tty */	res = open("/dev/tty", O_RDWR#ifdef HP				| O_NOCTTY#endif					   );	if (res >= 0)	  {#ifndef HP	    (void) ioctl(res, TIOCNOTTY, (char *)0);#endif	    (void) close(res);	  }	else	  {	    perror("Slave TTY");	    exit(0);	  }	/* Open the slave side */	sprintf(PtySlave, "/dev/tty%c%c", ltr, numb);	SlaveFD = open(PtySlave, O_RDWR);	if (SlaveFD == -1)	  {	    perror("Slave Open");	    exit(0);	  }	/* Set the terminal up to work with CHAT */	ioctl(SlaveFD, TIOCGETP, (char *)&tio);	tio.sg_flags |= CRMOD;	tio.sg_flags |= ECHO;	ioctl(SlaveFD, TIOCSETP, (char *)&tio);	(void) dup2(SlaveFD, 0);	(void) dup2(SlaveFD, 1);	(void) dup2(SlaveFD, 2);	(void) close(SlaveFD);	/* set the LDESHELL variable so the underlying .cshrc can see it and		configure the shell appropriately */	putenv("LDESHELL=YES");	/* Start up csh */	execl("/bin/csh", "csh", 0);	/* Should never get here */	perror("execl");	exit(0);      }    /* Set the process group so all the kids get the bullet too    if (setpgrp(PID, PID) != 0)    perror("setpgrp"); */    ForkedPIDs[slot] = PID;    return(1);  }/************************************************************************//*									*//*		      U n i x _ h a n d l e c o m m			*//*									*//*	LISP subr to talk to the forked "Unix process".			*//*									*//*	The first argument (Arg[0]) is a number:			*//*		0 Fork Pipe, Arg1 is a string for system(),		*//*		  returns Job # or NIL					*//*		1 Write Byte, Arg1 is Job, Arg2 is Byte,		*//*		  returns 1 (success), NIL (fail)			*//*		2 for Read Byte, Arg1 is Job,				*//*		  returns Byte, NIL (no data), T (EOF)			*//*		3 for Kill Job, Arg1 is Job, returns Status or T	*//*		4 for Fork PTY, returns Job # or NIL			*//*		5 for Kill All, returns T				*//*		6 for Close (EOF), Arg1 is Job #			*//*		7 for Job status, Arg1 is job #.  Returns T or status	*//*									*//*									*//*									*//*									*//************************************************************************/Unix_handlecomm(args)LispPTR *args;{	int command,c, dest, PID, i, slot;	LispPTR retval;	unsigned char d[4], b[1];	unsigned char ch;	unsigned char buf[1];	/* Check on all our processes, to see they're still alive. */	wait_for_comm_processes(0);	/* Get command */	N_GETNUMBER(args[0], command, bad);	switch(command) {	case 0:			/* Fork pipe process */	  {	    char PipeName[30];	    int res, slot, PipeFD, sockFD;	    struct sockaddr_un sock;	    d[0] = 'F';	    slot = find_process_slot(0);	    if (slot < 0) return(NIL);	    d[3] = slot;	    sockFD = socket(AF_UNIX, SOCK_STREAM, 0);	    if (sockFD < 0) { perror("socket open"); return(NIL);}	    sprintf(PipeName, "/tmp/LispPipe%d-%d", StartTime, slot);	    sock.sun_family = AF_UNIX;	    strcpy(sock.sun_path, PipeName);	    if (bind(sockFD, (struct sockaddr *) &sock,		     strlen(PipeName)+sizeof(sock.sun_family)) < 0)	      {		close(sockFD);		perror("binding sockets");		return(NIL);	      }	    DBPRINT(("Socket %d bound to name %s.\n", sockFD, PipeName));	    if(listen(sockFD, 1)<0) perror("Listen");	    write(UnixPipeOut, d, 4);	    /* Convert string to C  */	   LispStringToCString(args[1],shcom);	    /* Write string length, then string */	    *b = strlen(shcom) +1;	    write(UnixPipeOut, b, 1);	    write(UnixPipeOut, shcom, strlen(shcom)+1);	    DBPRINT(("Sending cmd string: %s\n", shcom));	    /* Get status */	    read(UnixPipeIn, d, 4);	    /* If it worked, return job # */	    if (d[3] == 1)	      {		TIMEOUT(PipeFD = accept(sockFD, (struct sockaddr *) 0,					(int *) 0));		if (PipeFD < 0)		  {		    perror("Accept.");		    close(sockFD);		    if (unlink(PipeName)<0) perror("Unlink");		    return(NIL);		  }		res = fcntl(PipeFD, F_GETFL, 0);		res |= FNDELAY;		res = fcntl(PipeFD, F_SETFL, res);		ForkedIns[slot] = ForkedOuts[slot] = PipeFD;		ForkedStatus[slot] = -1;		ForkedPIDs[slot] = (d[1]<<8) | d[2];		ForkedProcType[slot] = -2; /* so we can find them */		if(close(sockFD)<0)		  {perror("listen-socket close");}		return(GetSmallp(slot));	      }	    else	      {		DBPRINT(("Fork request failed."));		close(sockFD);		unlink(PipeName)<0;		return(NIL);	      }	    break;	  }	case 1:			/* Write byte */	  /* Get job #, Byte */	  N_GETNUMBER(args[1], dest, bad);slot = dest;	  N_GETNUMBER(args[2], dest, bad);ch = dest;	  if (valid_slot(slot) && (ForkedStatus[slot] == -1))	    {	      dest = write(ForkedIns[slot], &ch, 1);	      if (dest == 0) return(NIL);	        else return(GetSmallp(1));	    }	  else return(NIL);	  break;	case 2:			/* Read byte */	  /**********************************************************/	  /* 							    */	  /* NB that it is possible for the other end of the stream */	  /* to have terminated, and hence ForkedStatus != -1.	    */	  /* EVEN IF THERE ARE STILL CHARACTERS TO READ.	    */	  /* 							    */	  /**********************************************************/	  N_GETNUMBER(args[1], slot, bad);	/* Get job # */	  TIMEOUT(dest = read(ForkedIns[slot], buf, 1));	  if ((dest == 0) && (ForkedStatus[slot] == -1))	    { /* No available chars, but other guy still running */	      return(ATOM_T);	    }	  if (dest > 0)	    { /* Got a character */	      return(GetSmallp(buf[0]));	    }	  if ((ForkedStatus[slot] == -1)  &&	      ((errno == EWOULDBLOCK) || (errno == EAGAIN)) )	    { /* No available chars, but other guy still running */	      return(ATOM_T);	    }	  /* At this point, we either got an I/O error, or there */	  /* were no chars available and the other end has terminated. */	  /* Either way, signal EOF. */#ifdef DEBUG	  perror("Reading from shell");			  	  printf("Indicating EOF from PTY desc %d.\n", ForkedIns[slot]);	  fflush(stdout);#endif	  return(NIL);	  break;	case 3:			/* Kill process */	  N_GETNUMBER(args[1], slot, bad);	  if (valid_slot(slot))	    {	      /* First check to see it hasn't already died */	      if (ForkedStatus[slot] == -1)		{		  int i;		  /* Kill the job */		  kill(ForkedPIDs[slot], SIGKILL);		  for (i = 0; i < 10; i++)		    {		      /* Waiting for the process to exit is possibly risky.		         Sending SIGKILL is always supposed to kill		         a process, but on very rare occurrences this doesn't		         happen because of a Unix kernel bug, usually a user-		         written device driver which hasn't been fully		         debugged.  So we time it out just be safe. */		      if (ForkedStatus[slot] != -1) break;		      wait_for_comm_processes(0);		      sleep(1);		    }		}	    }	  else return(ATOM_T);	  if (ForkedProcType[slot] == -1)	/* PTY connection */	    {		DBPRINT(("Kill 3 closing desc %d.\n", ForkedIns[slot]));	      close(ForkedIns[slot]);	    }	  else if (ForkedProcType[slot] == -2)	/* named socket pair */	    {	      char PipeName[40];		DBPRINT(("Kill 3 closing desc %d.\n", ForkedIns[slot]));	      close(ForkedIns[slot]);	      sprintf(PipeName, "/tmp/LispPipe%d-%d", StartTime, slot);	      unlink(PipeName);	    }	  ForkedProcType[slot] = 0;	  ForkedPIDs[slot] = 0;	  /* If status available, return it, otherwise T */	  return(GetSmallp(ForkedStatus[slot]));	  break;	case 4:			/* Fork PTY process */	  {	    char MasterFD[20], SlavePTY[4];	    int Master, res, slot;	    slot = find_process_slot(0);	    if (slot < 0) return(NIL);	    Master = FindAvailablePty(MasterFD, SlavePTY);	    DBPRINT(("Fork Shell; Master PTY = %d. Slave=%c%c.\n", Master, SlavePTY[0], SlavePTY[1]));	    if (Master < 0)	      {		printf("Open of lisp side of PTY failed.\n");		fflush(stdout);		return(NIL);	      }	    d[0] = 'S';	    d[1] = SlavePTY[0];	    d[2] = SlavePTY[1];	    d[3] = slot;	    write(UnixPipeOut, d, 4);	    /* Get status */	    read(UnixPipeIn, d, 4);	    /* If successful, return job # */	    DBPRINT(("Pipe/fork result = %d.\n", d[3]));	    if (d[3] == 1)	      {		    /* Set up the IO not to block */		res = fcntl(Master, F_GETFL, 0);		res |= FNDELAY;		res = fcntl(Master, F_SETFL, res);		ForkedIns[slot] = ForkedOuts[slot] = Master;		ForkedProcType[slot] = -1; /* so we can find them */		ForkedPIDs[slot] = (d[1]<<8) | d[2];		ForkedStatus[slot] = -1;		return(GetSmallp(slot));	      }	     else	      {		printf("Fork failed.\n"); fflush(stdout);		close(Master);		return(NIL);	      }	    break;	  }	case 5:			/* Kill all the subprocesses */	  kill_comm_processes();	  return(ATOM_T);	case 6:			/* Kill all the subprocesses */	  d[0] = 'C';	  d[3] = 1;	  /* Get job # */	  N_GETNUMBER(args[1], dest, bad);	  d[1] = dest;	  d[3] = 1;	  write(UnixPipeOut, d, 4);	  /* Get status */	  read(UnixPipeIn, d, 4);	  if (ForkedProcType[dest] == -1)	    {		DBPRINT(("Kill 5 closing desc %d.\n", ForkedIns[dest]));	      close(ForkedIns[dest]);	      ForkedProcType[dest] = 0;	    }	  else if (ForkedProcType[dest] == -2)	/* named socket pair */	    {	      char PipeName[40];		DBPRINT(("Kill 5 closing desc %d.\n", ForkedIns[dest]));	      close(ForkedIns[dest]);	      ForkedProcType[dest] = 0;	      sprintf(PipeName, "/tmp/LispPipe%d-%d", StartTime, d[1]);	      unlink(PipeName);	    }	  ForkedPIDs[dest] = 0;	  return(ATOM_T);       /* break; */	case 7:			/* Current job status */	  /* Get job # */	  N_GETNUMBER(args[1], dest, bad);slot = dest;	  if (ForkedStatus[slot] == -1) return (ATOM_T);	  else return(GetSmallp(ForkedStatus[slot]));	  break;	default: return(NIL);	}      bad:	DBPRINT(("Bad input value."));	return(NIL);      }