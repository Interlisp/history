/* @(#) vmemsave.c Version 2.26 (%G). copyright envos & Fuji Xerox  */static char *id = "@(#) vmemsave.c	2.26 3/25/90         (envos & Fuji Xerox)";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************//**	vmemsave.c***/#include <stdio.h>#include <sys/file.h>#include <sys/types.h>#include <sys/stat.h>#include <sys/param.h>#include <sys/vfs.h>#include <errno.h>#include <signal.h>#include <setjmp.h>#include <sunwindow/win_cursor.h>#include "machineconfig.h"#include "lispemul.h"#include "lispmap.h"#include "lispglobal.h"#include "ifpage.h"#include "vmemsave.h"#include "timeout.h"#include "address68k.h"#include "lisptypes.h"#include "localfile.h"#define	COMPLETESYSOUT	NIL#define	BADFILENAME	S_POSITIVE | 1	#define	NOFILESPACE	S_POSITIVE | 2	#define FILECANNOTOPEN	S_POSITIVE | 3#define FILECANNOTSEEK	S_POSITIVE | 4#define FILECANNOTWRITE	S_POSITIVE | 5#define FILETIMEOUT	S_POSITIVE | 6struct stat     DEBUG_stat;extern int LispWindowFd;extern struct pixrect *CursorBitMap, *InvisibleCursorBitMap;extern struct cursor CurrentCursor, InvisibleCursor;extern IFPAGE *InterfacePage;char	*rindex();#undef roundup#define roundup( a, b) ((((unsigned)(a)+(b)-1)/(b))*(b))extern int	*Lisp_errno;extern int	Dummy_errno;		/* If errno cell is not provided by Lisp, dummy_errno is used. */extern int      please_fork;/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/lispstringP(Lisp)  LispPTR	Lisp;  {    switch( ((OneDArray *)(Addr68k_from_LADDR(Lisp)))->typenumber )      {	case THIN_CHAR_TYPENUMBER:	case FAT_CHAR_TYPENUMBER:   return(1);	default: return(0);      }  }/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/vmem_save0(args)  register LispPTR	*args;  {    register char	*def;    register char	*cp;    char	pathname[MAXPATHLEN];    char	*getenv();    char	*index();    if( (args[0] != 0) && lispstringP(args[0]) )      {	/* check of lispstringP is safer for LispStringToCString */	/* arg of subrcall is non-nil */	LispStringToCString(args[0], pathname, MAXPATHLEN);	/* Remove Host name({DSK} or {UNIX}) */	cp = index(pathname, '}');	return( vmem_save(cp+1) );      }    else      {	if((def=getenv("LDEDESTSYSOUT")) == 0)	  strcpy(pathname, "~/lisp.virtualmem");	else strcpy(pathname, def);	return( vmem_save(pathname) );      }  }/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/vmem_save(sysout_file_name)  char	*sysout_file_name;  {    int		sysout;	/* SysoutFile descriptor */    register DLword	*fptovp;	/* FPTOVP */    int	vmemsize;	/* VMEMSIZE */    register int	i;    char	fullpathname[MAXPATHLEN];    char	tempname[MAXPATHLEN];    char	dirname[MAXPATHLEN];    struct statfs	fsbuf;    char	*cp;    register int	rval;    DLword *bmptr;    extern int ScreenLocked;    extern DLword *EmCursorX68K;    extern DLword *EmCursorY68K;    extern DLword NullCursor[];	    extern DLword *EmCursorBitMap68K;#ifdef	FSERROR    /* For call makepathname */    Lisp_errno = &Dummy_errno;#endif    InterfacePage->minbversion = 15000; /* Mark this sysout for new emulator */    /* When file name doew not have directory, ./ is added to the name */    switch(*sysout_file_name)      {	case '~':	case '.':	case '/':	case '<':  break;	default:  /* use fullpathname as a temp cache */		  strcpy(fullpathname, "./");		  strcat(fullpathname, sysout_file_name);		  strcpy(sysout_file_name, fullpathname);      }			    if( makepathname(sysout_file_name, fullpathname) == 0)	return(BADFILENAME);    /* remove cursor image from screen */#ifdef SUNDISPLAY#ifdef OLD_CURSOR    win_setcursor( LispWindowFd, &InvisibleCursor);#else    ScreenLocked=T;    taking_mouse_down();/*	bmptr = EmCursorBitMap68K;    EmCursorBitMap68K= NullCursor;*/#endif OLD_CURSOR#endif SUNDISPLAY    /* set FPTOVP */    fptovp = FPtoVP + 1;    /* set VMEMSIZE */    vmemsize = InterfacePage->nactivepages;    strcpy(dirname, fullpathname);    if((cp=rindex(dirname, '/')) == 0)		return(BADFILENAME);    *cp = '\0';    if(confirmpath(dirname) == 0)		return(BADFILENAME);/*	[HH:6-Jan-89]	Sequnce of save image	(1) Sysout image is saved to a temporary file, tempname.	(2) if a specified file, fullpathname, is exist, the file is removed.	(3) the temporary file is renamed to the specified file.*/    SETJMP(FILETIMEOUT);    sprintf(fullpathname, "%s/%s", dirname, cp+1);    sprintf(tempname, "%s/%s-temp", dirname, cp+1);	/* Confirm protection of specified file by open/close */    TIMEOUT(sysout=open(fullpathname, O_WRONLY, 0666));    if (sysout == -1)      {	/* No file error skip return. */	if(errno != 2) return(FILECANNOTOPEN); /* No such file error.*/      }    else TIMEOUT( rval = close(sysout) );    /* open temp file */    TIMEOUT(sysout=open(tempname, O_WRONLY | O_CREAT | O_TRUNC, 0666));    if (sysout == -1)      {	err_mess("open", errno);	return(FILECANNOTOPEN);      }    InterfacePage->machinetype = KATANA;    /*printf("start vmemsave\n"); */    /* store vmem to sysoutfile */    for (i = 0; i < vmemsize; i++)      {	if (fptovp[i] != 0177777)	  {	    TIMEOUT( rval=lseek(sysout, i * BYTESPER_PAGE, 0) );	    if (rval == -1) 	      {		err_mess("lseek", errno);		return(FILECANNOTSEEK);	      }#ifdef BYTESWAP	    word_swap_page((char *)(Lisp_world + (fptovp[i] * DLWORDSPER_PAGE)),			    BYTESPER_PAGE/4);#endif BYTESWAP	    TIMEOUT( rval=write(sysout,		     (char *)(Lisp_world + (fptovp[i] * DLWORDSPER_PAGE)),		     BYTESPER_PAGE) );#ifdef BYTESWAP	    word_swap_page((char *)(Lisp_world + (fptovp[i] * DLWORDSPER_PAGE)),			    BYTESPER_PAGE/4);#endif BYTESWAP	    if (rval == -1)	      {		err_mess("write", errno);		return(FILECANNOTWRITE);	      }	  }      }    /* seek to IFPAGE */    TIMEOUT(rval=lseek(sysout, (long)FP_IFPAGE, 0));    if (rval == -1)      {	err_mess("lseek", errno);	return(FILECANNOTSEEK);      }#ifdef BYTESWAP	    word_swap_page((char *) InterfacePage,			    BYTESPER_PAGE/4);#endif BYTESWAP    TIMEOUT(rval=write(sysout, (char *) InterfacePage, BYTESPER_PAGE) );#ifdef BYTESWAP	    word_swap_page((char *) InterfacePage,			    BYTESPER_PAGE/4);#endif BYTESWAP    if (rval == -1)      {		err_mess("write", errno);		return(FILECANNOTWRITE);	}        TIMEOUT( rval = close(sysout) );    if(rval == -1)      {	return(FILECANNOTWRITE);      }    TIMEOUT(rval = unlink(fullpathname));    if (rval == -1)       {	/* No file error skip return. */	if(errno != 2)	/* No such file error.*/ return(FILECANNOTOPEN);      }    TIMEOUT( rval=rename(tempname, fullpathname) );    if( rval== -1)      {	fprintf(stderr,"sysout is saved to temp file, %s.", tempname);	return(FILECANNOTWRITE);      }    /* restore cursor image to screen */#ifdef SUNDISPLAY#ifdef OLD_CURSOR    win_setcursor( LispWindowFd, &CurrentCursor);#else    ScreenLocked=T;    /*EmCursorBitMap68K = bmptr ;*/    taking_mouse_up(*EmCursorX68K,*EmCursorY68K);    ScreenLocked=NIL;#endif OLD_CURSOR#endif SUNDISPLAY    /*printf("vmem is saved completely.\n");*/    return(COMPLETESYSOUT);  }/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/extern int UnixPID;/* Make sure that we kill off any Unix subprocesses before we go away */lisp_finish()  {    char d[3];#ifdef  DEBUG    printf("finish lisp_finish\n");#endif    if( please_fork )      {		/* if lde runs with -NF(No fork), */		/* following 5 lines don't work well. */	d[0] = 'E';	d[3] = 1;	write(UnixPipeOut, d, 4);   /* Send fork_Unix on a homicidal spree */	read(UnixPipeIn, d, 4);	/* Make sure it's finished */	kill(UnixPID, SIGKILL);	/* Then kill fork_Unix itself */      }    device_before_exit();    exit(1);	  }