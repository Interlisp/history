/* @(#) directory.c Version 2.29 (3/23/90). copyright venue & Fuji Xerox  */static char *id = "@(#) directory.c	2.29 3/23/90		(venue & Fuji Xerox)";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/#include <sys/types.h>#include <sys/stat.h>#include <sys/param.h>#include <sys/file.h>#include <sys/ioctl.h>#include <sys/dir.h>#include <strings.h>#include <stdio.h>#include <errno.h>#include <setjmp.h>#include "lispemul.h"#include "lispmap.h"#include "lisptypes.h"#include "timeout.h"#include "localfile.h"#define	TRUE	1#define	FALSE	0#define	FAILED	-1#define SEPRCHAR	'\\'#define DIRCHAR	'/'#undef	ALLDIRSEARCH#define	MAXNAMELEN 128extern	int*	Lisp_errno;extern	int	Dummy_errno;typedef struct	dir_spec{	struct	file_spec	*files;	struct	dir_spec	*dirs;	time_t	mtime;	u_short	namlen;			/* 3 */	char	name[MAXNAMELEN];	/* bar, only root has pathname /foo/fee */}DirSpec;typedef struct	file_spec{	struct	file_spec	*pnext;	int		ver_no;		/* 3 */	ino_t		ino;	short		nlink;	char	name[MAXNAMELEN];	/* bar */	char	version[VERSIONLEN];	/* 3, 3% */}FileSpec;DirSpec	RootDirSpec;char	*SetDirsToBuffer();char	*SetFilesToBuffer();/** For sort_file() **//** lowercase a is  97, so a << 1 is 194.    lowercase z is 122, so z << 1 is 244.    uppercase A is  65, so A << 1 is 130.    uppercase Z is  90, so Z << 1 is 180  ***//** note that x < y implies z = -1.			*/#define	CASE_CHARCMP(x, y, z)				\	{						\	register int  xx, yy;				\		xx = (x)<<1;				\		yy = (y)<<1;				\		if ( (194 <= xx)  && ( xx <= 244 ) )	\			xx -= 64;			\/* add 1 if lcase > ucase (but that's wrong) */		\		if ( (194 <= yy)  && ( yy <= 244 ) )	\			yy -= 64;			\							\		if( xx < yy )				\			z = -1;				\		else					\			if( xx == yy )			\				z = 0;			\			else				\				z = 1;			\	}#define	OLDCASE_CHARCMP(x, y, z)			\	{						\	register char	*cp1,*cp2;			\		cp1 = index(alpha_order, x);		\		cp2 = index(alpha_order, y);		\		if( (int)cp1 < (int)cp2 )		\			z = -1;				\		else					\			if( (int)cp1 == (int)cp2 )	\				z = 0;			\			else				\				z = 1;			\	}/***static	char	alpha_order[100] =	" !\"#$%&'()*+,-./0123456789:;<=>?@aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ[\\]^_`{|}~";***//*** This is masked. [13-Jan-99 HH]static	char	alpha_order[100] =	"~}|{`_^]\\[ZzYyXxWwVvUuTtSsRrQqPpOoNnMmLlKkJjIiHhGgFfEeDdCcBbAa@?>=<;:9876543210/.-,+*)('&%$#\"! ";***/static	char	alpha_order[100] =	"}|{`_^]\\[ZzYyXxWwVvUuTtSsRrQqPpOoNnMmLlKkJjIiHhGgFfEeDdCcBbAa@?>=<;:9876543210~/.-,+*)('&%$#\"! ";/************************************************************************//*									*//*			u f s _ s t r c m p				*//*									*//*	String-compare function for {UNIX} file names.  ONLY WORKS ON C	*//*	STRINGS, NOT ON LISP STRINGS ON 386's.				*//*									*//*									*//************************************************************************/ufs_strcmp(s1,s2)  register char	*s1, *s2;  {    return (-strcmp(s1, s2));  }/************************************************************************//*									*//*				d s k _ s t r c m p			*//*									*//*	String-compare function for {DSK} file names.  Almost		*//*	case-insensitive, except that upper-case is < lower-case,	*//*	so sort order is AbBbCc...  Also, legal version numbers sort	*//*	before  illegal version numbers, & illegal version sort in	*//*	the same case-insensitive way AbBb... as above			*//*									*//************************************************************************/dsk_strcmp(s1,s2)  register char	*s1, *s2;  {    register int	j, v1, v2, res1, res2;    int  num;		/* can't take address of register var */    char ch;    for (; ;++s1, ++s2)      {	CASE_CHARCMP(*s1, *s2, j);	if( j != 0) return(-j);	/* lisp wants reversed sense */	if (*s1 == '\0') return (0);  /* both null */	if (*s1 == ';')  /* both semi */	  {	    s1++; s2++;	    /* legal version is exactly res==1 a number, no more.	       resx now boolean					*/	    res1 = (1 == (sscanf ( s1, "%d%c", &num, &ch )));	    v1   = num;	    res2 = (1 == (sscanf ( s2, "%d%c", &num, &ch )));	    v2   = num;	    if ( res1 && res2 )	      { /* both versions, use < */		if ( v1 < v2 ) return(-1);		if ( v1 > v2 ) return( 1);		return(0);	      }	    /* vers. name shorter (but reverse sense) */	    else if ( res1 && !res2 ) return( 1);	    else if ( res2 && !res1 ) return(-1);	    /* otherwise continue lexical scan */	    /* need to backup 1, because forloop ++ */	    s1--; s2--;	  }      } /* for */  }file_sort(startp, f_count, devsortfn)  char	*startp; /* points the buffer in LISP, but not yet byte-swapped */  int	f_count;  int	(*devsortfn)();  {    char	*sort_buffer;    register char	*bp, *sourcep, *destp;    register int	i;    sort_buffer = (char *)malloc(MAXPATHLEN * f_count);    for (bp=sort_buffer,sourcep=startp,i=0;i<f_count;bp+=MAXPATHLEN,++i)      {	for(destp=bp;*sourcep!=	SEPRCHAR;) *destp++ = *sourcep++;	++sourcep;	*destp++ = '\0';      }    qsort(sort_buffer, f_count, MAXPATHLEN, devsortfn);/* It seems, now copy file names from work buffer to buffer in LISP   For i386, byte-swap operation should be done here */    for(bp=sort_buffer,sourcep=startp,i=0;i<f_count;bp+=MAXPATHLEN,++i)      {	for(destp=bp;*destp!='\0';) GETBYTE(sourcep++ )= *destp++;	GETBYTE(sourcep++) = SEPRCHAR;      }    free(sort_buffer);  }/************************************************************************//************ E N D   O F   F I L E - S O R T I N G   C O D E ***********//************************************************************************//************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/alldirSize(dirName, dir, dirlen, filter)  register char *dirName; /* Pointer to directoryname. ex. "/usr/aig/hayata" */  char *dir;  register int dirlen;	/* Size of directory name after dirName, initially 0 */  register char *filter; /* Pointer to filter string. ex. "*.*;*" or "a*.l*" */  {    register DIR *dp;    register struct direct *directp;    register int	totalsize;    register int	rval;    struct stat stat_buf;    char	full_name[MAXPATHLEN];#ifdef	ALLDIRSEARCH    char	newdir[MAXPATHLEN];#endif#ifdef	FSERROR    ERRSETJMP(-1);#else    SETJMP(-1);#endif    if(index(filter, '/') == 0)      {	TIMEOUT( rval=stat(dirName, &stat_buf) );	if(rval != 0)	  {	    err_mess("stat", errno);#ifdef	FSERROR	    *Lisp_errno = errno;#endif	    return(-1);	  }	return(stat_buf.st_size);      }    totalsize = 0;    TIMEOUT( dp=opendir(dirName) );    if (dp == (DIR *)NULL)      {#ifdef	FSERROR	*Lisp_errno = errno;#endif	return(-1);      }    for(S_TOUT(directp=readdir(dp)); directp!=(struct direct *)NULL; S_TOUT(directp=readdir(dp)) )       {	/* Skip "." and ".." */	if((*(directp->d_name))=='.')	  {	    if(directp->d_namlen == 1) continue;	    else if((directp->d_namlen == 2) && (*((directp->d_name)+1) == '.'))				continue;	  }	sprintf(full_name, "%s/%s", dirName, directp->d_name);	TIMEOUT( rval=stat(full_name, &stat_buf) );	if(rval != 0)	  {/** When symbolic linked file have not a linked-to file, stat cause error. So this err_mess and return should be skipped. **/	    if(errno != 2)	      {		err_mess("stat", errno);#ifdef	FSERROR		*Lisp_errno = errno;#endif		TIMEOUT( closedir(dp) );		return(-1);	      }	  }	else if((*(directp->d_name) != '.') && (stat_buf.st_mode & S_IFDIR))	  {#ifdef	ALLDIRSEARCH	    strcpy(newdir, dir);	    strcat(newdir, directp->d_name);	    strcat(newdir, "/");	    totalsize += alldirSize(full_name, newdir, strlen(newdir), filter);#else	    sprintf(full_name, "%s%s", dir, directp->d_name);	    if(DSK_matchp(full_name, filter)==TRUE)	    totalsize += (dirlen + directp->d_namlen + 2);	    /* 2 means DIRCHAR and SEPRCHAR */#endif	  }	else	  {	    sprintf(full_name, "%s%s", dir, directp->d_name);	    if(DSK_matchp(full_name, filter)==TRUE)	      totalsize += (dirlen + directp->d_namlen + 10);	   /* 10 means SEPRCHAR and version */	  }      }    TIMEOUT( closedir(dp) );    return(totalsize);  }/************************************************************************//*									*//*									*//*	This function is only called from DSK_readdir(dsk.c)		*//*									*//*									*//************************************************************************/DSK_readAllDir(dirName, dir, dirlen, filter, buffer)register char *dirName;char *dir;int dirlen;char *filter;register char *buffer;/* buffer is in LISP */{register int	rval;register DIR *dp;register struct direct *directp;char	*startp;struct stat stat_buf;char	pathname[MAXPATHLEN];static	int	f_count;#ifdef	FSERROR	ERRSETJMP(-1);#else	SETJMP(-1);#endif	STAT(dirName, &stat_buf);	if(ValidDirSpecP(dirName, stat_buf.st_mtime)==0){		/* Free RootDirSpec and re-set RootDirSpec */		FreeArea(&RootDirSpec);		strcpy(RootDirSpec.name, dirName);		RootDirSpec.namlen = strlen(dirName);		RootDirSpec.mtime = stat_buf.st_mtime;		RootDirSpec.files = 0;		RootDirSpec.dirs = 0;		TIMEOUT( dp=opendir(dirName) );		if (dp == (DIR *)NULL){#ifdef	FSERROR			*Lisp_errno = errno;#endif			return(-1);		}		for(S_TOUT(directp=readdir(dp)); directp!=(struct direct *)NULL; S_TOUT(directp=readdir(dp)) ){			sprintf(pathname, "%s/%s", dirName, directp->d_name);			TIMEOUT(rval=stat(pathname, &stat_buf));			if(rval != 0){			/* When symbolic linked file have not a linked-to file, stat cause error. So if errno = 2, skip the file */				if(errno==2){					continue;				}else{					err_mess("stat", errno);#ifdef	FSERROR					*Lisp_errno = errno;#endif					TIMEOUT( closedir(dp) );					return(-1);				}			}			if(stat_buf.st_mode & S_IFDIR){				if(SetToDirs(&RootDirSpec, directp) == -1){					TIMEOUT( closedir(dp) );					return(-1);				}			}else{				if(SetToFiles(&RootDirSpec, directp) == -1){					TIMEOUT( closedir(dp) );					return(-1);				}			}		}#ifdef	FSERROR		ERRSETJMP(-1);#else		SETJMP(-1);#endif		TIMEOUT( closedir(dp) );	}	/* Now, RootDirSpec is valid */	startp = buffer;	f_count = 0;	buffer = SetDirsToBuffer(&RootDirSpec, buffer, filter, &f_count);	buffer = SetFilesToBuffer(&RootDirSpec, buffer, filter, &f_count);	*buffer = '\0';	/* byte-swap OP will be done in file_sort on i386 */	file_sort(startp, f_count,dsk_strcmp);	return( (int)buffer - (int)startp );}/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/UFS_readAllDir(dirName, dir, dirlen, filter, buffer)register char *dirName;char *dir;int dirlen;char *filter;register char *buffer;{register DIR *dp;register struct direct *directp;char	*startp;register int	length;register int	rval;struct stat stat_buf;char	full_name[MAXPATHLEN];int	f_count = 0;#ifdef	ALLDIRSEARCHchar	newdir[MAXPATHLEN];#endif#ifdef	FSERROR	ERRSETJMP(-1);#else	SETJMP(-1);#endif	startp = buffer;	TIMEOUT( dp=opendir(dirName) );	if (dp == (DIR *)NULL){#ifdef	FSERROR		*Lisp_errno = errno;#endif		return(-1);	}	for(S_TOUT(directp=readdir(dp)); directp!=(struct direct *)NULL; S_TOUT(directp=readdir(dp))){		/* Skip "." and ".." */		if((*(directp->d_name))=='.'){			if(directp->d_namlen == 1)				continue;			else if((directp->d_namlen == 2) && (*((directp->d_name)+1) == '.'))				continue;		}		sprintf(full_name, "%s/%s", dirName, directp->d_name);		TIMEOUT( rval=stat(full_name, &stat_buf) );		if(rval != 0){/** When symbolic linked file have not a linked-to file, stat cause error. So this err_mess and return should be skipped. **/			if(errno != 2){				err_mess("stat", errno);				closedir(dp);				return(-1);			}		}		else			if((*(directp->d_name) != '.') && (stat_buf.st_mode & S_IFDIR)){#ifdef	ALLDIRSEARCH				strcpy(newdir, dir);				strcat(newdir, directp->d_name);				strcat(newdir, "/");				buffer += UFS_readAllDir(full_name, newdir, strlen(newdir), filter, buffer);#else				sprintf(full_name, "%s%s", dir, directp->d_name);				if(matchp(full_name, filter)==TRUE){				/* No need to BYTESWAP here */					strncpy(buffer, full_name, dirlen+directp->d_namlen);					buffer += (dirlen + directp->d_namlen);					GETBYTE(buffer++) = DIRCHAR;					GETBYTE(buffer++) = SEPRCHAR;					++f_count;				}#endif			}else{				sprintf(full_name, "%s%s", dir, directp->d_name);				if(matchp(full_name, filter)==TRUE){					length = dirlen + directp->d_namlen;#ifndef BYTESWAP					strncpy(buffer, full_name, length);#else					StrNCpyFromCToLisp(buffer, full_name, length);#endif BYTESWAP					buffer += length;					GETBYTE(buffer++) = SEPRCHAR;					++f_count;				}			}	}	TIMEOUT( closedir(dp) );	file_sort(startp, f_count, ufs_strcmp);	return( (int)buffer - (int)startp );}/************************************************************************	SUBROUTINES	For pattern matching check************************************************************************//************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/matchp(name, filter)char	*name;char	*filter;{char	name_name[100];char	name_extension[100];char	name_version[100];char	filter_name[100];char	filter_extension[100];char	filter_version[100];	match_parse(name, name_name, name_extension, name_version);	match_parse(filter, filter_name, filter_extension, filter_version);	if( match_part_p(name_name, filter_name) == 0)		return(0);	if( match_part_p(name_extension, filter_extension) == 0)		return(0);	if( match_part_p(name_version, filter_version) == 0)		return(0);	return(1);}/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/DSK_matchp(name, filter)char	*name;char	*filter;{/** Case insesitive matchp **/char	name_name[100];char	name_extension[100];char	name_version[100];char	filter_name[100];char	filter_extension[100];char	filter_version[100];	match_parse(name, name_name, name_extension, name_version);	match_parse(filter, filter_name, filter_extension, filter_version);	if( DSK_match_part_p(name_name, filter_name) == 0)		return(0);	if( DSK_match_part_p(name_extension, filter_extension) == 0)		return(0);	if( DSK_match_part_p(name_version, filter_version) == 0)		return(0);	return(1);}/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/match_parse(path, name, extension, version)register char	*path;		/* format is foo.fee;1 or foo.fee~1~ */register char	*name;char	*extension;char	*version;{register char	*cp,*cp1;register int	length;	if( (cp=rindex(path, ';')) != 0){	/* version -- ;# */		strcpy(version, cp+1);		length = (int)cp - (int)path;		strncpy(name, path, length);	/* name & ext is saved to name buf */		name[length] = '\0';	}else if( (cp=rindex(path, '~'))!=0 && (cp1=index(path, '~'))!=0 && cp1!=cp){			if(*(cp1-1) == '.'){				/* version -- .~#~ */				++cp1;				length = (int)cp - (int)cp1;				strncpy(version, cp1, length);				version[length] = '\0';				length = (int)cp1 - (int)path - 2;				strncpy(name, path, length);	/* name & ext is saved to name buf */				name[length] = '\0';			}else{			/* No version */			version[0] = '\0';			strcpy(name, path);			}	}else{		/* No version */		version[0] = '\0';		strcpy(name, path);	}	if( (cp=rindex(name, '.')) != 0){		strcpy(extension, cp+1);		*cp = '\0';	}else{		/* No extension */		extension[0] = '\0';	}}/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/match_part_p(name, filter)register char	*name;register char	*filter;{register char	*np, *fp;	for(np=name, fp=filter; *fp!='\0';){		if(*fp=='*'){			/* skip *s, like "***s" */			for(;*(fp+1)=='*'; ++fp);			if(*(++fp)=='\0'){/* filetr is "..*\0", the rest is OK */				return(1);			}else{			LP:				/* fp points next of *. */				for(;*fp!=*np;++np)					if(*np=='\0'){						/* np is finished */						return(0);					}				/* find candidate. */				if(match_part_p(np+1, fp+1) == 1){					/* The rest is match */					return(1);				}else{					/* try to find next cand */					++np;					goto LP;				} /* else */			} /* else */		}else{			if(*np!=*fp)				return(0);			if(*(++fp)=='\0')				if(*(++np)=='\0'){					return(1);				}else					return(0);			++np;		} /* else */	} /* for */	if(*np=='\0')		return(1);	return(0);}/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/DSK_match_part_p(n, f)register char	*n;register char	*f;{/** Case insensitive match_part_p **/char	name[100];char	filter[100];	strcpy(name, n);	strcpy(filter, f);	DOWNCASE(name);	DOWNCASE(filter);	return(match_part_p(name, filter));}/**********************************************************************************	SUBROUTINES	For versionless, currently these routines are used only for DSK.**********************************************************************************//************************************************************************//*									*//*									*//*		Do not care about BYTE-SWAP, 				*//*		because 'buffer' will be used in file_sort		*//*									*//*									*//************************************************************************/char *SetDirsToBuffer(dirs, buffer, filter, f_count_p)register DirSpec	*dirs;register char	*buffer; /* buffer is in LISP */register char	*filter;int	*f_count_p;{register DirSpec	*dp;register int	f_count = 0;	for(dp=dirs; dp->dirs!=0;){		dp=dp->dirs;		if( DSK_matchp(dp->name, filter) ){			strncpy(buffer, dp->name, dp->namlen);			buffer += dp->namlen;			*(buffer++) = DIRCHAR;			*(buffer++) = SEPRCHAR;			++f_count;		}	}	*f_count_p += f_count;	return(buffer);}/************************************************************************//*									*//*									*//*		Do not care about BYTE-SWAP, 				*//*		because 'buffer' will be used in file_sort		*//*									*//*									*//*									*//************************************************************************/char *SetFilesToBuffer(dir, buffer, filter, f_count_p)register DirSpec	*dir;register char	*buffer; /* buffer in LISP */register char	*filter; /* filter has right byte-order */int	*f_count_p;{register FileSpec	*fp;register int	high_ver;register int	len,i;register int	f_count = 0;char	name[MAXPATHLEN];char	version[VERSIONLEN];	if(dir->files==0)		return(buffer);	for(fp=dir->files; fp!=0;fp=fp->pnext){		strcpy(version, fp->version);		/* change version number */		if(fp->ver_no == 0 && STREQ(fp->version, "0") ){			/* fp is versionless file */			if(fp->nlink == 1){			/* versionless is highest+1 */				if((i=GetHighest(dir, fp->name)) == -1)					continue;				sprintf(version, "%d", i+1);			}else{			/* if versionless link some one in directory, skip */				if(LinkP(dir, fp->ino)){					continue;				}else{			/* versionless has no link with file in the directory */					strcpy(version, "1");				}			}		}		if( DSK_matchp2(fp, version, filter,dir) ){			sprintf(name, "%s;%s", fp->name, version);			AddDodNoExtention(name);			len = strlen(name);			strncpy(buffer, name, len);			buffer += len;			*(buffer++) = SEPRCHAR;			++f_count;		}	}	*f_count_p += f_count;	return(buffer);}/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/SetToDirs(dir, directp)register DirSpec	*dir;		/* RootDirSpec */register struct direct *directp;{register DirSpec	*newdp;register DirSpec	*dp;register int	rval;struct stat stat_buf;char	name[MAXPATHLEN];#ifdef	FSERROR	ERRSETJMP(-1);#else	SETJMP(-1);#endif	/* skip . and .. */	if(STREQ(directp->d_name, ".")){		return(1);	}	if(STREQ(directp->d_name, "..")){		return(1);	}	/* scan last one */	for(dp=dir;dp->dirs!=0;dp=dp->dirs);	/* get new one */	if( ( newdp = ((DirSpec *)malloc(sizeof(DirSpec))) ) == NULL)		return(-1);	/* set to new one */	strcpy(newdp->name, directp->d_name);	newdp->namlen = strlen(directp->d_name);	sprintf(name, "%s/%s", dir->name, directp->d_name);	STAT(name, &stat_buf);	newdp->mtime = stat_buf.st_mtime;	newdp->files = 0;	newdp->dirs = 0;	/* link with last */	dp->dirs = newdp;	return(1);}/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/SetToFiles(dir, directp)register DirSpec	*dir;		/* RootDirSpec */register struct direct *directp;{register FileSpec	*fp;register FileSpec	*newp;register int	rval;struct stat stat_buf;char	name[MAXPATHLEN];char	version[VERSIONLEN];#ifdef	FSERROR	ERRSETJMP(-1);#else	SETJMP(-1);#endif	/* get new one */	if( (newp = ((FileSpec *)malloc(sizeof(FileSpec)))) == NULL)		return(-1);	/* set to new one */	strcpy(name, directp->d_name);	parseversion(name, version);	strcpy(newp->name, name);	strcpy(newp->version, version);	sprintf(name, "%s/%s", dir->name, directp->d_name);	STAT(name, &stat_buf);	newp->ino = stat_buf.st_ino;	newp->nlink = stat_buf.st_nlink;	newp->ver_no = atoi(version);	newp->pnext = 0;	/* scan  and link last one */	if(dir->files==0){		dir->files = newp;	}else{		for(fp=dir->files; fp->pnext!=0;fp=fp->pnext);		fp->pnext = newp;	}	return(1);}/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/FreeArea(dir)DirSpec	*dir;		/* RootDirSpec */{register FileSpec	*fp;register FileSpec	*nextfp;register DirSpec	*dp;register DirSpec	*nextdp;	if(dir->files != 0){		for(fp=dir->files;fp!=0;fp=nextfp){			nextfp = fp->pnext;			free(fp);		}	}	if(dir->dirs != 0){		for(dp=dir->dirs;dp!=0;dp=nextdp){			nextdp = dp->dirs;			free(dp);		}	}}/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/ValidDirSpecP(dirName, mtime)char	*dirName;time_t	mtime;{	if(mtime == RootDirSpec.mtime && STREQ(dirName, RootDirSpec.name))		return(1);	else		return(0);}/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/GetHighest(dir, name)	/* return highest version no */register DirSpec	*dir;		/* RootDirSpec */char	*name;		/* foo.c */{register FileSpec	*fp;register FileSpec	*max_fp;register int	max = 0;	if(dir->files==0)		return(-1);	for(fp=dir->files; fp!=0; fp=fp->pnext){		if(STREQ(fp->name, name)){			/* Check version */			if((fp->ver_no > max) && CheckOnlyNumber(fp->version)){				max = fp->ver_no;			}		}	}	return(max);}/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/LinkP(dir, ino)register DirSpec	*dir;register ino_t	ino;{register FileSpec	*fp;register int	flag = 0;	if(dir->files==0)		return(0);	for(fp=dir->files; fp!=0; fp=fp->pnext){		if(fp->ino == ino){			if(flag)				return(1);			else				flag =1;		}	}	return(0);}/************************************************************************//*									*//*									*//*									*//*									*//*									*//************************************************************************/DSK_matchp2(fp, version, filter, dir)FileSpec	*fp;char	*version;char	*filter;DirSpec	*dir;{register char	*cp;int	i, nv;char	name_name[100];char	name_extension[100];char	name_version[100];char	filter_name[100];char	filter_extension[100];char	filter_version[100];	strcpy(name_name, fp->name);	if((cp=rindex(name_name, '.')) == 0){		/* no extension */		*name_extension = '\0';	}else{		*cp = '\0';		strcpy(name_extension, cp+1);	}	strcpy(name_version, version);	match_parse(filter, filter_name, filter_extension, filter_version);	if( DSK_match_part_p(name_name, filter_name) == 0)		return(0);	if( DSK_match_part_p(name_extension, filter_extension) == 0)		return(0);	/* Version of filter is NULL */	if(*filter_version == '\0'){		/* Nolink versionless file matches */		if(STREQ(fp->version, "0"))			return(1);		/* Highest version file matches */		if((i=GetHighest(dir, fp->name)) == -1){			return(0);		} else{			nv = atoi(name_version);			if(nv != i){				/* Not highest file */				return(0);			}			if(fp->nlink==1){				/* No link highest file */				return(0);			}			/* highest link file match */			return(1);		}	}	if( DSK_match_part_p(name_version, filter_version) == 0)		return(0);	return(1);}