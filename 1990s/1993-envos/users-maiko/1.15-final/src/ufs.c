/* @(#) ufs.c Version 2.38 (3/9/90). copyright venue & Fuji Xerox  */static char *id = "@(#) ufs.c	2.38 3/9/90		(venue & Fuji Xerox)";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/#include	<pwd.h>#include	<sys/file.h>#include	<sys/types.h>#include	<sys/stat.h>#include	<sys/param.h>#include	<sys/time.h>#include	<sys/vfs.h>#include	<setjmp.h>#include	<errno.h>#include	"lispemul.h"#include	"lispmap.h"#include	"address68k.h"#include	"lisptypes.h"#include	"arith.h"#include	"stream.h"#include	"timeout.h"#include	"localfile.h"char	*rindex();char	*index();int	*Lisp_errno;int	Dummy_errno;	/* If errno cell is not provided by Lisp, dummy_errno is used. */#define	SPECIALFILEMARK	-1UFS_openfile(args)register LispPTR	*args;/* args[0]		fullname *//* args[1]		rec *//* args[2]		acc *//* args[3]		cdate *//* args[4]		size *//* args[5]		errno */{register int	flags;	/* open system call's argument, and id of file */register int	*bufp;register int	rval;struct stat	statbuf;char	pathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[5]));		ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	TIMEOUT( rval=stat(pathname, &statbuf) );	if( rval == -1){		if(errno == 2){			/* Skip file not found error */			statbuf.st_mode = S_IFREG;		}else{			err_mess("stat", errno);#ifdef FSERROR			*Lisp_errno = errno;#endif			return(NIL);		}	}	flags = 0;	switch(args[1]){	case RECOG_OLD:	case RECOG_OLDEST:			break;	case RECOG_NEW_OLD:	case RECOG_NEW:			flags = O_CREAT;			break;	default:			return(NIL);	}	if((statbuf.st_mode & S_IFREG) == 0){		/* Not regular file, open special file */		switch(args[2]){		case	ACCESS_INPUT:				flags = O_RDONLY;				break;		case	ACCESS_OUTPUT:				flags = O_WRONLY;				break;		case	ACCESS_APPEND:				flags = O_WRONLY;				break;		case	ACCESS_BOTH:				flags = O_RDWR;				break;		default:			return(NIL);		}	}else{		switch(args[2]){		case	ACCESS_INPUT:				flags |= O_RDONLY;				break;		case	ACCESS_OUTPUT:				TIMEOUT( unlink(pathname) );				flags |= (O_RDWR | O_CREAT);				break;		case	ACCESS_APPEND:				flags |= (O_RDWR | O_CREAT);				break;		case	ACCESS_BOTH:				flags |= (O_RDWR | O_CREAT);				break;		default:			return(NIL);		}	}	TIMEOUT( flags=open(pathname, flags, 0666) );	if(flags == -1){		err_mess("open", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	/* refetch new file info */	TIMEOUT( rval=fstat(flags, &statbuf) );	if( rval == -1){		err_mess("fstat", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	bufp = (int *)(Addr68k_from_LADDR(args[3]));	*bufp = ToLispTime(statbuf.st_mtime);	bufp = (int *)(Addr68k_from_LADDR(args[4]));	if((statbuf.st_mode & S_IFREG) == 0){		/* Special file */		*bufp = SPECIALFILEMARK;	}else{		/* Regular file */		*bufp = statbuf.st_size;	}	return(GetSmallp(flags));}UFS_closefile(args)register LispPTR	*args;/* args[0]		pathname	*//* args[1]		id	*//* args[2]		cdate	*//* args[3]		errno */{register int	id;	/* FileID */register int	date;	/* Creatoin Date */register char	*base;register int	rval;static struct timeval time[2];struct stat	statbuf;char	pathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));		ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	id = LispNumToCInt(args[1]);	date = LispNumToCInt(args[2]);	TIMEOUT( rval=fstat(id, &statbuf) );		if(rval != 0){		err_mess("fstat", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	if(date == 0){ /* just close */		TIMEOUT( rval=close(id) );		if( rval == -1){			if(errno==1){	/* Not owner error */				if((statbuf.st_mode & S_IFREG) == 0){				/* Not regular file, open special file */					return(ATOM_T);				}			}			err_mess("close", errno);#ifdef FSERROR			*Lisp_errno = errno;#endif			return(NIL);		}		return(ATOM_T);	}	/* set Creation date and close */		time[0].tv_sec = statbuf.st_atime;	time[1].tv_sec = ToUnixTime(date);	TIMEOUT( rval=close(id) );	if( rval == -1){		err_mess("close", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	TIMEOUT( rval=utimes(pathname, time) );	if(rval != 0){		err_mess("utimes", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	return(ATOM_T);}UFS_getfilename(args)register LispPTR	*args;/* args[0]		pathname	*//* args[1]		rec	*//* args[2]		buffer	*//* args[3]		errno	*/{register char	*base;register LispPTR	*naddress;register int	rval;char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	if( makepathname(pathname, fullpathname) == 0){		return(NIL);	}	switch(args[1]){	case RECOG_OLD:	case RECOG_OLDEST:#ifdef	FSERROR		ERRSETJMP(NIL);#else		SETJMP(NIL);#endif		TIMEOUT( rval=access(fullpathname, F_OK) );		if(rval == -1){			/** There is no need to report access error. 			err_mess("access", errno);			**/#ifdef FSERROR			if(errno == 60)				*Lisp_errno = errno;#endif			return(NIL);		}		break;	case RECOG_NEW_OLD:	case RECOG_NEW:	case RECOG_NON:		break;	default:		return(NIL);	}	/*** CStringToLispString ***/	naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));	rval = strlen(fullpathname);#ifndef BYTESWAP	strncpy(base, fullpathname, rval);#else	StrNCpyFromCToLisp(base, fullpathname, rval);#endif BYTESWAP	return(GetSmallp(rval));}makepathname(src, dst)register char	*src;register char	*dst;				{register int len;register char	*base, *cp;register struct passwd *pwd;char	name[MAXPATHLEN];	base = src;	switch ( *base ) {	case '.':		if(getwd(dst) == 0){	/* set working directory */#ifdef FSERROR			*Lisp_errno = errno;#endif			return(0);		}		switch ( *(base+1) ){							case '.':			if(*(base+2) == '/'){	/* Now, base == "../xxxx" */				cp = rindex(dst, '/');				if(cp == 0){					return(0);				}				*cp = '\0';				strcat(dst, base+2);				return(1);								}else{									return(0);						}								case '/':			/* Now, base == "./xxx" */			strcat(dst, base+1);						return(1);								default:										return(0);						}	case '~':#ifdef FSERROR		ERRSETJMP(0);#else		SETJMP(0);#endif		if( *(base+1) == '/'){			/* path is "~/foo" */			TIMEOUT( pwd = getpwuid( getuid()) );			if(pwd == NULL){				#ifdef FSERROR				*Lisp_errno = errno;#endif				return(0);			}			sprintf(dst, "%s%s", pwd->pw_dir, base+1);			return(1);		}else{			/* path is "~foo/" */			if((cp=index(base+1, '/')) == 0){				return(0);			}else{				len = (int)cp - (int)base -1;				strncpy(name, base+1, len);				name[len] = '\0';				TIMEOUT( pwd = getpwnam(name) );				if(pwd == NULL){				#ifdef FSERROR					*Lisp_errno = errno;#endif					return(0);				}				sprintf(dst, "%s%s", pwd->pw_dir, cp);				return(1);				}		}	default:		strcpy(dst, src);							return(1);								}}UFS_deletefile(args)LispPTR	*args;/*	args[0]:	Indirect pointer to buffer	*//*	args[1]:	errno	*/{register int	rval;char	pathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));		ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	TIMEOUT( rval=unlink(pathname) );	if(rval == -1){		err_mess("unlink", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	return(ATOM_T);}UFS_renamefile(args)register LispPTR	*args;/*	args[0]:	Indirect pointer to buffer (old file name)	*//*	args[1]:	Indirect pointer to buffer (new file name)	*//*	args[2]:	pointer to errno	*/{register int	rval;char	old_pathname[MAXPATHLEN], new_pathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));		ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	LispStringToCString(args[0], old_pathname, MAXPATHLEN);	LispStringToCString(args[1], new_pathname, MAXPATHLEN);	TIMEOUT( rval=rename(old_pathname, new_pathname) );	if( rval== -1){		if(errno != 18){			/* Not, cross device rename error */			err_mess("rename", errno);		}#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	return(ATOM_T);}/*** Common routine between DSK and UNIX. ****/UFS_readpage(args)register LispPTR	*args;/*	args[0]:	Indirect pointer to FileID	*//*	args[1]:	Indirect pointer to PageOffset	*//*	args[2]:	pointer to buffer		*//*	args[3]:	pointer to errno		*/{register int	id;register int	pageoffset;register char	*bufp;register int	rval;register char	*bp;int	count;struct	stat	sbuf;	/* Strucure for FileInfo. */#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	id = LispNumToCInt(args[0]);	pageoffset = LispNumToCInt(args[1]);	bufp = (char*)(Addr68k_from_LADDR(args[2]));	TIMEOUT( rval=fstat(id, &sbuf) );	if(rval != 0){		err_mess("fstat", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	if((sbuf.st_mode & S_IFREG) != 0){		/* Not regular file: skip, no need lseek */		/* Regular file: need lseek */		/* The filepointer is set to (pageoffset*PAGE_SIZE) bytes. */		TIMEOUT( rval=lseek(id, (pageoffset*PAGE_SIZE), L_SET) );		if(rval == -1){#ifdef FSERROR			*Lisp_errno = errno;#endif			err_mess("lseek", errno);			return(NIL);		}	}	/* Read BUFFSIZE bytes file contents from filepointer. */	TIMEOUT( count=read(id, bufp, PAGE_SIZE) );	if(count == -1){#ifdef FSERROR		*Lisp_errno = errno;#endif		err_mess("read", errno);		return(NIL);	}	/* Fill the unread part of buffer with 0. */	for(bp = &bufp[count], rval=count; rval < PAGE_SIZE; ++rval, ++bp){		*bp = 0;	}#ifdef BYTESWAP{   word_swap_page(bufp, PAGE_SIZE/4);}#endif BYTESWAP	return(GetSmallp(count));}/*** Common routine between DSK and UNIX. ****/UFS_writepage(args)register LispPTR	*args;/*	args[0]	:	Indirect pointer to FileID *//*	args[1] :	Indirect pointer to PageOffset	*//*	args[2] :	pointer to buffer	*/	/*	args[3] :	Indirect pointer to size		*//*	args[4] :	pointer to errno		*/{register int	id;register int	pageoffset;register char	*bufp;register int	rval, size;#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[4]));	ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	id = LispNumToCInt(args[0]);	pageoffset = LispNumToCInt(args[1]);	bufp = (char*)(Addr68k_from_LADDR(args[2]));	size = LispNumToCInt(args[3]);	/* The filepointer is set to (pageoffset*PAGE_SIZE) bytes. */	TIMEOUT( rval=lseek(id, (pageoffset*PAGE_SIZE), L_SET) );	if(rval == -1){#ifdef FSERROR		*Lisp_errno = errno;#endif		if(errno != 28){			/* When error is file system full, skip err_mess() */			err_mess("write", errno);		}		return(NIL);	}	/* Read PAGE_SIZE bytes file contents from filepointer. */#ifdef BYTESWAP  word_swap_page(bufp, (size+3)>>2);#endif BYTESWAP	TIMEOUT( rval=write(id, bufp, size) );	if( rval == -1){#ifdef FSERROR		*Lisp_errno = errno;#endif		if(errno != 28){			/* When error is file system full, skip err_mess() */			err_mess("write", errno);		}		return(NIL);	}	return(ATOM_T);}UFS_getsize(args)register LispPTR	*args;/* This function set real file size. The name should be UFS_setsize *//*	args[0]:	Indirect pointer file ID to be closed *//*	args[1]:	Indirect pointer file size	*//*	args[2]:	pointer to errno	*/{register int	rval;register int	id;	/* FileID */register int	size;	/* file size */struct	stat	sbuf;	/* Strucure for FileInfo. */#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));		ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	id = LispNumToCInt(args[0]);	size = LispNumToCInt(args[1]);	TIMEOUT( rval=fstat(id, &sbuf) );	if(rval != 0){		err_mess("fstat", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	if((sbuf.st_mode & S_IFREG) == 0){		/* Not regular file, no need truncate */		return(ATOM_T);	}	TIMEOUT( rval=ftruncate(id, size) );	if(rval != 0){		err_mess("ftruncate", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	/* sync the file state */	/* This routine is called from Lisp FORCEOUTPUT, it expects sync */	TIMEOUT( rval=fsync(id) );	if(rval != 0){		err_mess("fsync", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	return(ATOM_T);}UFS_directorynamep(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to Directory Name *//* 	args[1]		buf for errno */	/** [hh:12/01] It is not passed from LISP **/	/** [hh:12/06] It is passed from new LISP **/{register int	rval;struct	stat	sbuf;	/* Strucure for FileInfo. */char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[1]));/**	Lisp_errno = &Dummy_errno; **/#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	if( makepathname(pathname, fullpathname) == 0)		return(NIL);#ifdef	FSERROR	ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	TIMEOUT( rval=stat(fullpathname, &sbuf) );	if(rval != 0){		err_mess("stat", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	if((sbuf.st_mode & S_IFMT) == S_IFDIR)		return(ATOM_T);	return(NIL);}UFS_getfileinfo(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to File Name *//*	args[1]:	IndirectPonter to Attribute *//*	args[2]:	IndirectPonter to BUffer *//* args[3]		buf for errno */{register unsigned int	*buffixp;register char	*base;register struct passwd *pwd;register int	rval;LispPTR	*naddress;struct stat sbuf;char	pathname[MAXPATHLEN];LispPTR	lisp_addr;#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));		ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	TIMEOUT( rval=stat(pathname, &sbuf) );	if(rval != 0){		err_mess("stat", errno);#ifdef FSERROR		*Lisp_errno = errno;#endif		return(NIL);	}	switch(args[1]){	case SIZE:		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));		*buffixp = sbuf.st_size;		return(ATOM_T);	case WDATE:		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));		*buffixp = ToLispTime(sbuf.st_mtime);		return(ATOM_T);	case RDATE:		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));		*buffixp= ToLispTime(sbuf.st_atime);		return(ATOM_T);	case AUTHOR:		TIMEOUT( pwd = getpwuid(sbuf.st_uid) );		if(pwd == NULL){		/** changed to return 0 for author name length -was **/			return(GetSmallp(0));		}		/*** CStringToLispString ***/		naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));		base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));		rval = strlen(pwd->pw_name);#ifndef BYTESWAP		strncpy( base, pwd->pw_name, rval );		#else		StrNCpyFromCToLisp( base, pwd->pw_name, rval );#endif BYTESWAP		return(GetSmallp(rval));	case PROTECTION:		buffixp = (unsigned int *)(Addr68k_from_LADDR(args[2]));		*buffixp= sbuf.st_mode;		return(ATOM_T);	case ALL:		/* length */		lisp_addr = cdr(car(args[2]));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp= sbuf.st_size;		/* wdate */		lisp_addr = cdr(car(cdr(args[2])));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp = ToLispTime(sbuf.st_mtime);		/* rdate */		lisp_addr = cdr(car(cdr(cdr(args[2]))));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp= ToLispTime(sbuf.st_atime);		/* protection */		lisp_addr = cdr(car(cdr(cdr(cdr(args[2])))));		buffixp = (unsigned int *)(Addr68k_from_LADDR(lisp_addr));		*buffixp= sbuf.st_mode;		/* author */		TIMEOUT( pwd = getpwuid(sbuf.st_uid) );		if(pwd == NULL){		/** changed to return 0 for author name length -was **/			return(GetSmallp(0));		}		lisp_addr = cdr(car(cdr(cdr(cdr(cdr(args[2]))))));		naddress = (LispPTR *)(Addr68k_from_LADDR(lisp_addr));		base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));		rval = strlen(pwd->pw_name);#ifndef BYTESWAP		strncpy( base, pwd->pw_name, rval );		#else		StrNCpyFromCToLisp( base, pwd->pw_name, rval );#endif BYTESWAP		return(GetSmallp(rval));	default:		return(NIL);	}}UFS_setfileinfo(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to File Name *//*	args[1]:	IndirectPonter to Attribute *//*	args[2]:	IndirectPonter to Value *//* 	args[3]		buf for errno */{register unsigned int	rval;struct stat	sbuf;static struct timeval time[2];char	pathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));		ERRSETJMP(NIL);#else	SETJMP(NIL);#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	switch(args[1]){	case WDATE:		TIMEOUT( rval=stat(pathname, &sbuf) );		if(rval != 0){			err_mess("stat", errno);#ifdef FSERROR			*Lisp_errno = errno;#endif			return(NIL);		}		rval = LispNumToCInt(args[2]);		time[0].tv_sec = sbuf.st_atime;		time[1].tv_sec = ToUnixTime(rval);		TIMEOUT( rval=utimes(pathname, time) );		if(rval != 0){			err_mess("utimes", errno);#ifdef FSERROR			*Lisp_errno = errno;#endif			return(NIL);		}		return(ATOM_T);	case PROTECTION:		rval = LispNumToCInt(args[2]);		TIMEOUT( rval=chmod(pathname, rval) );		if(rval != 0){			err_mess("chmod", errno);#ifdef FSERROR			*Lisp_errno = errno;#endif			return(NIL);		}		return(ATOM_T);	default:		return(NIL);	}}UFS_dirsize(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to Directory Name *//*	args[1]:	IndirectPonter to Filter Name *//* 	args[2]		buf for errno */{register int	size;char	dirname[MAXPATHLEN];char	fulldirname[MAXPATHLEN];char	filter[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[2]));	#endif	LispStringToCString(args[0], dirname, MAXPATHLEN);	if( makepathname(dirname, fulldirname) == 0)		return(NIL);	LispStringToCString(args[1], filter, MAXPATHLEN);	size = alldirSize( fulldirname, "", 0, filter);	if(size == -1)		return(NIL);	else		return(GetSmallp(size));}UFS_readdir(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to Directory Name *//*	args[1]:	IndirectPonter to Filter Name *//*	args[2]:	IndirectPonter to BUffer *//* 	args[3]		buf for errno */{register LispPTR	*naddress;register char	*base;register int	size;char	dirname[MAXPATHLEN];char	fulldirname[MAXPATHLEN];char	filter[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = (int *)(Addr68k_from_LADDR(args[3]));	#endif	LispStringToCString(args[0], dirname, MAXPATHLEN);	if( makepathname(dirname, fulldirname) == 0)		return(NIL);	LispStringToCString(args[1], filter, MAXPATHLEN);	naddress = (LispPTR *)(Addr68k_from_LADDR(args[2]));	base = (char *)(Addr68k_from_LADDR(((OneDArray *)naddress)->base));	size = UFS_readAllDir(fulldirname, "", 0, filter, base);	if(size == -1)		return(NIL);	else		return(GetSmallp(size));}UFS_changedir(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to Directory Name */{register int	rval;char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = &Dummy_errno;#endif	LispStringToCString(args[0], pathname, MAXPATHLEN);	if( makepathname(pathname, fullpathname) == 0)		return(NIL);	SETJMP(NIL);		/* There is no err in args, so we can not use ERRSETJMP */	TIMEOUT( rval=chdir(fullpathname) );	if(rval != 0){		err_mess("chdir", errno);			return(NIL);	}	return(ATOM_T);}UFS_getfreeblock(args)register LispPTR	*args;/*	args[0]:	IndirectPonter to file Name *//*	args[1]:	IndirectPonter to buffer */{register int	*buffixp;register char	*cp;register int	rval;struct statfs	buf;char	pathname[MAXPATHLEN];char	fullpathname[MAXPATHLEN];#ifdef	FSERROR	Lisp_errno = &Dummy_errno;#endif	buffixp = (int *)(Addr68k_from_LADDR(args[1]));	LispStringToCString(args[0], pathname, MAXPATHLEN);	/*** SkipHostName ***/	if(*pathname == '{'){		if((cp=index(pathname, '}')) == 0)			cp = pathname;		else			++cp;	}else		cp = pathname;	if( makepathname(cp, fullpathname) == 0){		*buffixp = 0;			return(NIL);	}	while(T){		if((cp=rindex(fullpathname, '/')) == 0){			*buffixp = 0;				return(NIL);		}		*cp = '\0';		if(confirmpath(fullpathname) == 0)			return(NIL);		SETJMP(NIL);		/* There is no err in args, so we can not use ERRSETJMP */		TIMEOUT( rval=statfs(fullpathname, &buf) );		if( rval == 0){			break;		}	}		*buffixp = buf.f_bavail;	return(ATOM_T);}