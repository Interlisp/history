/* @(#) fvar.c Version 2.24 (3/2/90). copyright venue & Fuji Xerox  */static char *id = "@(#) fvar.c	2.24 3/2/90	(venue & Fuji Xerox)";/************************************************************************//*									*//*	Copyright 1989, 1990 Venue, Fuji Xerox Co., Ltd, Xerox Corp.	*//*									*//*	This file is work-product resulting from the Xerox/Venue	*//*	Agreement dated 18-August-1989 for support of Medley.		*//*									*//************************************************************************/#include <stdio.h>#include "lispemul.h"#include "lispglobal.h"#include "address68k.h"#include "stack.h"#include "emulglobal.h"#include "lispmap.h"#include "lisptypes.h"#include "gc.h"#define	MaskShift(x)	((0xFF & (x)) << 16)/************************************************************************* N_OP_fvarn	entry of OPCODE[120b-127b]: FVAR, FVARX	1. save TopOfStack to evaluation stack.	2. set address of searching FVAR slot to chain.	3. call lookfor. (It sets some content to FVAR slot)	4. get some address by caluculation of content of FVAR slot.	5. set the address to TopOfStack.**************************************************************************/LispPTR N_OP_fvarn(n)	/* n is word offset */ register int n;  {  register DLword *chain;	/* keep FVAR slot2 in CurrentFrameExtension */  chain = PVar + n;  if(WBITSPTR(chain)->LSB)    {      /* check 15bit of FVAR slot1 in CurrentFrameExtension.	 0: bound	 1: unbound */      nfvlookup(CURRENTFX, chain, FuncObj);    }  return(GetLongWord(Addr68k_from_LADDR(0xFFFFFF &					(((GETWORD(chain+1))<<16) |					 GETWORD(chain)))));  }/************************************************************************** nfvlookup:	This routine is used by only OP_fvarn.		( in addition to N_OP_fvar_() )	1. get Atom index number of target fvar slot.	2. call fvlookfor.****************************************************************************/nfvlookup(apframe1, achain, apfnhead1)  struct frameex1 *apframe1;	/* pointer to current frame extension */  register DLword *achain;	/* pointer to 1st word of the searching				   FVAR slot in CurrentFrameExtension */  register struct fnhead *apfnhead1;	/* pointer to current function heaer */  {    register DLword *pfh;	/* pointer to current function header */    register int    paoffset;	/* 2word offset in PVAR AREA */    pfh = (DLword *)apfnhead1;    paoffset = ((int)achain - (int)PVar)>>2;		/* slot to looked for, 2word offset from PVar */    nnewframe(apframe1, achain,	      (GETWORD(pfh + (apfnhead1->fvaroffset + paoffset -			      apfnhead1->nlocals))));  }/******************************************************************************N_OP_stkscan	entry	STKSCAN		OPCODE[057]	<<Enter>>	TopOfStack:	Low word - Atom index number of variable to be saned.	<<Exit>>	TopOfStack:	Address of found value.	1. call fvlookup.	2. Set *chain to TopOfStack.	3. Increment Pc by 1.******************************************************************************/LispPTR N_OP_stkscan(tos)  LispPTR tos;  {#ifdef I386    int scratchx[3];    int *scratch = (int *)(0xFFFFFFFC & (3+(int)scratchx));    *scratch = tos;    nnewframe(CURRENTFX, (DLword *)scratch, 0xFFFF & *scratch );    return(((0xFF & *scratch)<<16) | ((unsigned int) *scratch >> 16));#else    int	scratch;    scratch = tos;    nnewframe(CURRENTFX, (DLword *)&scratch, 0xFFFF & scratch );    return(((0xFF & scratch)<<16) | ((unsigned int) scratch >> 16));#endif I386  }/**************************************************N_OP_fvar_	Entry:	FVAR_		opcode[0143]***************************************************/LispPTR N_OP_fvar_(tos, n)  register LispPTR tos;  register int n;  {    register DLword *ppvar;	/* pointer to argued Fvar slot in pvar area */    register DLword *pfreeval;	/* pointer to argued free value */    register int l1;		/* return value of fvlookup() */    ppvar = PVar + n;    if(WBITSPTR(ppvar)->LSB)	/* check unbound ? */      { /* unbound */	nfvlookup(CURRENTFX, ppvar, FuncObj);      }    pfreeval =Addr68k_from_LADDR( MaskShift((GETWORD(ppvar+1))) |					     GETWORD(ppvar) );    if( ((0xFF & GETWORD(ppvar+1)) != STK_HI))      {	GCLOOKUP(0x8000,DELREF, *((LispPTR *)pfreeval));	GCLOOKUP(0x8000,ADDREF, tos);      }    *((LispPTR *)pfreeval) = tos;    return(tos);  }#define FVSTACK		2#define FVGLOBAL	6#define FVIVARHI	0x0#define FVPVARHI	0x8000#define FVFVARHI	0xC000#define ENDSTACKMARK	0xb/******************************************************************************nnewframe	This routine is used by fvlookup and OP_stkscan.	1. scan Name table in new function header.	2. if found, set address of searching variable to chain address.	3. return the type of var, on stack, or global. (fs: unused, removed)******************************************************************************/nnewframe(newpfra2, achain, name)  register struct frameex1 *newpfra2;	/* pointer to new frame extension */  register DLword	   *achain;	/* pointer to 1st word of the searching					   FVAR slot in CurrentFrameExtension */  register int	name;		/* Atom index num. of target FVAR slot. */  {    register DLword *pindex;	/* index to indexs of new name table */    register int i;		/* temp for control */    register int nametablesize;	/* NameTable size of current function header. */    register int ph;		/* alink temp, also phase */    newframe:#ifdef SUN3_OS3_OR_OS4_IL    newframe_setup_label();#endif    /* assume that apframe1 points to the next frame to be scanned */    ph = newpfra2->alink;    if(ph == ENDSTACKMARK)      {	/* endStack */	if(name >= 0x8000)	  {	    GETWORD(achain+1) = VALS_HI + 1;	    GETWORD(achain) = name*2;	  }	else	  {	    GETWORD(achain+1) = VALS_HI;	    GETWORD(achain) = name*2;	  }	return;      }    ph &= 0xFFFE; /* to mask off SLOW bit */    newpfra2 = (struct frameex1 *)(-FRAMESIZE + Stackspace + ph);    { /* open new block to try and conserve address register */      register struct fnhead *newpfn2;	/* ptr to new fn header */      if(newpfra2->validnametable)		/* check VALIDNAMETABLE */	newpfn2 = (struct fnhead *)		   (Addr68k_from_LADDR(((newpfra2->hi2nametable)<<16 |					 newpfra2->lonametable   )));      else	newpfn2 = (struct fnhead *)		    (Addr68k_from_LADDR(((newpfra2->hi2fnheader)<<16 |					  newpfra2->lofnheader  )));      pindex = ((DLword *)newpfn2) + FNHEADSIZE;		/* now pindex points 1st word of Nametable. */      nametablesize = newpfn2->ntsize;    }#ifdef SUN3_OS3_OR_OS4_IL    newframe_loop_label();#endif    i = (int) (pindex + nametablesize);    for(; i > (int) pindex;)      {	/* searching in NewFuncHeader */	if(GETWORD((DLword *)pindex++) == (DLword)name) {ph=1; goto foundit;}cont2:	if(GETWORD((DLword *)pindex++) == (DLword)name) {ph=2; goto foundit;}cont3:	if(GETWORD((DLword *)pindex++) == (DLword)name) {ph=3; goto foundit;}cont4:	if(GETWORD((DLword *)pindex++) == (DLword)name) {ph=0; goto foundit;}	continue;foundit:	{	  register int	fvartype;   /* probing fvar vartype */	  register int	fvaroffset; /* probing fvar varoffset */	  register DLword  *ppvar;	/* ptr to probing var candidate */	  fvartype = GETWORD(pindex + nametablesize - 1);	  fvaroffset = 0xFF & fvartype;	  fvaroffset <<= 1;	  fvartype &= 0xFF00;	  switch( fvartype )	    {	      case FVPVARHI: /* 0x8000: */		     ppvar = FRAMESIZE+(DLword *)newpfra2+fvaroffset;				/* ppvar points to argued Pvar */		    if(WBITSPTR(ppvar)->MSB)				/* check UNBOUND (if *ppvar is negative , unbound) */			switch ( ph )			 {			    case 0 : continue;			    case 1 : goto cont2;			    case 2 : goto cont3;			    case 3 : goto cont4;			 }		      GETWORD(achain+1) = STK_HI;		      GETWORD(achain) = 0xFFFF & LADDR_from_68k(ppvar);			/* save High word of PVAR slot address to FVAR slot */			/* achain points to target FVAR slot */		      return;		case FVFVARHI: /* 0xC000: */		       ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;			if( WBITSPTR(ppvar)->LSB ) goto endlookfor;				/* Not Found in new FnHeader, scan next one. */			*((int *)achain) = *((int *)ppvar);				/* save address of FX to FVAR slot */				/* achain points to target FVAR slot */			return;		case FVIVARHI: /* 0x000: */			ppvar = -1 + (DLword *)newpfra2;				/* ppvar points to IVAR field in Basic  frame */			GETWORD(achain+1) = STK_HI;			GETWORD(achain) = GETWORD(ppvar) + fvaroffset;			return;		default:error("Stack corrupted: bad value in name table");	      }/* end switch */	    }/* end if */	  }/* end for */endlookfor:    goto newframe;		/* scan the next one */  }#ifdef SUN3_OS3_OR_OS4_IL#define VALS_HI_RET(x)		newframe_vals_hi_ret(x)#define STK_HI_RET(x)		newframe_stk_hi_ret(x)#else#define VALS_HI_RET(x)	\	((int) x << 17) + VALS_HI + ((unsigned short) x >> 15)#define STK_HI_RET(x)	\	((int) x << 16) | 1 | ((unsigned int) x >> 16)#endif/******************************************************************************native_newframe	1. scan Name table in new function header.	2. if found, set address of searching variable to chain address.	3. return the pointer******************************************************************************/native_newframe(slot)int	slot;			/* index of FVAR slot. */{register struct frameex2 *newpfra2;	/* pointer to new frame extension */register DLword	*achain;	/* pointer to 1st word of the searching				   FVAR slot in CurrentFrameExtension */register int	name;		/* Atom index num. of target FVAR slot. */{					/* LOCAL temp regs */	register int rslot = slot;	register struct fnhead *fnobj = FuncObj;	register LispPTR *pvar = (LispPTR *) PVar;	name = GETWORD((DLword *)fnobj +		 (fnobj->fvaroffset + rslot - fnobj->nlocals));	newpfra2 = (struct frameex2 *) ((DLword *) pvar - FRAMESIZE);	achain = (DLword *) (pvar + rslot);}{register DLword	*pindex;	/* index to indexs of new name table */register int i;			/* temp for control */register int nametablesize;	/* NameTable size of current function header. */register int alink;natnewframe:#ifdef SUN3_OS3_OR_OS4_IL	natnewframe_label();#endif	/* assume that apframe1 points to the next frame to be scanned */	alink = newpfra2->alink;	if(alink == ENDSTACKMARK){	/* endStack */		return(*((LispPTR *)achain) = VALS_HI_RET(name));	}	newpfra2 = (struct frameex2 *)(-FRAMESIZE + Stackspace + (alink & 0xFFFE));	{ /* open new block to try and conserve address register */	register struct fnhead *newpfn2;	/* ptr to new fn header */	newpfn2 = GETNAMETABLE(newpfra2);	pindex = ((DLword *)newpfn2) + FNHEADSIZE;		/* now pindex points 1st word of Nametable. */	nametablesize = newpfn2->ntsize;	}#ifdef SUN4_OS4_IL	i =  (int) (pindex + nametablesize);lookup:	pindex = (DLword *) name_scan((int)pindex, i, name | (name<<16));	if (!pindex) goto natnewframe;{{#else#ifdef SUN3_OS3_OR_OS4_IL	i = nametablesize;	if (--i < 0) goto natnewframe;	/* **** assumes:		d7 = name		d6 = i		a3 = pindex	*** */lookup:	fvar_lookup_loop();{{#else	for(i=nametablesize; --i >= 0;){					/* searching in NewFuncHeader */		if(GETWORD((DLword *)pindex++) == (DLword)name){#endif#endif		    register int     fvartype;   /* probing fvar vartype */		    register int     fvaroffset; /* probing fvar varoffset */		    register DLword *ppvar; /* ptr to probing var candidate */		    fvartype = GETWORD(pindex + nametablesize - 1);		    fvaroffset = (0xFF & fvartype) << 1;		    switch( fvartype >> 14 ){			case (FVPVARHI >> 14): /* 0x8000: */			    ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;					/* ppvar points to argued Pvar */			    if(WBITSPTR(ppvar)->MSB)			/* check UNBOUND (if *ppvar is negative , unbound) */#ifdef SUN4_OS4_IL				    goto lookup;#else#ifdef SUN3_OS3_OR_OS4_IL				    goto lookup;#else				    {				      continue;				    }#endif#endif			/* save High word of PVAR slot address to FVAR slot */			/* achain points to target FVAR slot */			     return(*((LispPTR *)achain) =				    STK_HI_RET( LADDR_from_68k( ppvar )));			case (FVFVARHI >> 14): /* 0xC000: */			    ppvar = FRAMESIZE + (DLword *)newpfra2 + fvaroffset;			    if( WBITSPTR(ppvar)->LSB )			      {			        goto endlookfor;			      }			    /* Not Found in new FuncHeader, scan next one. */			    /* save address of frame extension to FVAR slot */			    /* achain points to target FVAR slot */			    return(*((int *)achain) = *((int *)ppvar));			case (FVIVARHI >> 14): /* 0x000: */			    ppvar = (DLword *)newpfra2 - 1;			    /* ppvar points to IVAR field in Basic frame */			    return(*((LispPTR *)achain) =				    STK_HI_RET(GETWORD(ppvar)+fvaroffset));;			default:error("Stack corrupted: bad value in name table");			}/* end switch */		}/* end if */	}/* end for */endlookfor:	goto natnewframe;		/* scan the next one */}}