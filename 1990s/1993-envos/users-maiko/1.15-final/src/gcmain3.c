/* This is G-file @(#) gcmain3.c Version 2.3 (3/28/89). copyright Xerox & Fuji Xerox  */static char *id = "@(#) gcmain3.c	2.3 3/28/89";/*************************************************************************//*************************************************************************//*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.	 *//*************************************************************************//*                                                                       *//*                       File Name : gcmain3.c                           *//*                                                                       *//*************************************************************************//*                                                                       *//*                      Creation Date : July-7-1987                      *//*                      Written by Tomoru Teruuchi                       *//*                                                                       *//*************************************************************************//*                                                                       *//*           Functions : gcmapscan();                                    *//*                       gcmapunscan();                                  *//*                       gcscanstack();                                  *//*                                                                       *//*                                                                       *//*************************************************************************//*           Descreption :                                               *//*                                                                       *//*************************************************************************//*                                                               \Tomtom *//*************************************************************************/#include "lispemul.h"#include "lisptypes.h"#include "address.h"#include "address68k.h"#include "lispglobal.h"#include "emulglobal.h"#include "stack.h"#include "cell.h"#include "ifpage.h"#include "gc.h"#define HTMAIN_SIZE	0x8000   /* this will be deleted in including map */#define STK_HI		1	/* This is also. */#define WORDSPERCELL	2#define CONSPAGE_LAST	0x0ffff#define MAXHTCNT	63#define PADDING	4#define FNOVERHEADWORDS	8#define BIND_BITS(value)	((unsigned int) (value) >> 24)#define BF_FLAGS(value)		((unsigned int) (value) >> 29)#define PTR_BITS(entry)		((unsigned int)((unsigned int)((entry) << 8) >> 8))#define ADD_OFFSET(ptr, dloffset) ((LispPTR *) ((DLword *) (ptr) + (dloffset)))#define GetLinkptr(entry)	(entry & 0x0fffe)#define GetSegnuminColl(entry1) 	((entry1 & 0x01fe) >> 1)#define GetCountinColl(entry1) 	((entry1 & 0x0fc00) >> 10)#define GetStkCnt(entry1)	((entry1 & 0x0fe00) >> 9)#define GetStkrefinColl(entry1)	((entry1 & 0x0200) >> 9)#define Boundp(frame_field)	((frame_field) == 0)#define Stkref(ptr)		GCLOOKUP(0x8000, STKREF, ptr)#define GcreclaimLp(ptr) 	while((ptr = gcreclaimcell(ptr)) != NIL)  \				  GCLOOKUP(0x8000, ADDREF, ptr)#define HTLPTR ((struct htlinkptr *) WORDPTR(entry))#define HENTRY ((struct hashentry *) WORDPTR(entry))gcmapscan(){   LispPTR		prevlp;  register DLword	probe = HTMAIN_SIZE;  register LispPTR	htcoll_LADDR = (LispPTR) LADDR_from_68k(HTcoll);  LispPTR		htmain_LADDR = (LispPTR) LADDR_from_68k(HTmain);nextentry:  while((probe = gcscan1(probe)) != NIL)	{ register struct hashentry *entry;	  register LispPTR entrylp;	  entrylp = htmain_LADDR + probe;	  entry = (struct hashentry *) ((DLword *) HTmain + probe);	retry:			 if (HENTRY->collision)           { register LispPTR next_link;	     prevlp = NIL; 	/* unbound mark */	     next_link = GetLinkptr(HTLPTR->contents); 	     do {		register LispPTR linklp;		register struct htcoll *link;		linklp = htcoll_LADDR + next_link;		link = (struct htcoll *) ((DLword *) HTcoll + next_link);		{register LispPTR ptr = link->free_ptr;		 if (GetStkCnt(ptr) == 0)	         {ptr = VAG2(GetSegnuminColl(ptr),(probe << 1));                  dellink(linklp, prevlp, entrylp);		  GcreclaimLp(ptr);		  if (HTLPTR->contents == 0)		       goto nextentry;		  else goto retry;	         };		}; /* register */		prevlp = linklp;		next_link = link->next_free;		} while (next_link);	     goto nextentry;	    };  	/* if (HENTRY->collision) */	 if (GetStkCnt(HTLPTR->contents) == 0)		{ register LispPTR ptr = VAG2(HENTRY->segnum,(probe << 1));	       	  HTLPTR->contents = 0;	       	  GcreclaimLp(ptr);	        };	}; /* while((probe = gcscan1(probe)) != NIL) */	return(NIL);   }gcmapunscan(){ register DLword	probe = HTMAIN_SIZE;  register LispPTR	htcoll_LADDR = (LispPTR) LADDR_from_68k(HTcoll);  register LispPTR	htmain_LADDR = (LispPTR) LADDR_from_68k(HTmain);  while((probe = gcscan2(probe)) != NIL)	{ register struct hashentry *entry;	  register LispPTR entrylp;	  register LispPTR next_link;	  entrylp = htmain_LADDR + probe;	  entry = (struct hashentry *) ((DLword *) HTmain + probe);	retry:	  if (HENTRY->collision)	     {  LispPTR prevlp;		next_link = GetLinkptr(HTLPTR->contents);	       	prevlp = NIL;	    		do {		register struct htcoll *link;		register LispPTR linklp;		linklp = htcoll_LADDR + next_link;		link = (struct htcoll *) ((DLword *) HTcoll + next_link);		if (GetStkrefinColl(link->free_ptr) == 1)		{if (GetCountinColl(link->free_ptr) == 1)	            {dellink(linklp, prevlp, entrylp);		     goto retry;		    }		 else link->free_ptr = (link->free_ptr & 0x0fdff);		};		next_link = link->next_free;	        prevlp = linklp;		} while (next_link); /* register link */	      }	  else if (HENTRY->stackref)		{if (HENTRY->count == 1)			HTLPTR->contents = 0;		 else HENTRY->stackref = 0;		};	}; 	/* while((probe = gcscan2(probe) != NIL) */	return(NIL);}gcscanstack()	{ register  Bframe		*bascframe;	  LispPTR		scanptr,scanend,scanend68K;	  struct fnhead		*nametable;	  int			ftyp;	  int			pvcount;  scanptr = VAG2(STK_HI,InterfacePage->stackbase);  scanend = VAG2(STK_HI,InterfacePage->endofstack);  scanend68K = (LispPTR) Addr68k_from_LADDR(scanend);  bascframe = (Bframe *)Addr68k_from_LADDR(scanptr);  while(1)/*This is endless loop until encountering tail of stack */ {	ftyp = (int)bascframe->flags;	switch(ftyp) {		case STK_FX: { { 			register struct frameex1 *frameex;			register struct fnhead *fnheader;			frameex = (struct frameex1 *)bascframe;			scanptr = LADDR_from_68k(frameex);			{ register LispPTR fn_head;			  fn_head = (LispPTR)				VAG2(frameex->hi2fnheader,				     frameex->lofnheader);			  Stkref(fn_head);			  fnheader = (struct fnhead *)					Addr68k_from_LADDR(fn_head);			};			{ register int pcou;			  register LispPTR *pvars;			  pvars =(LispPTR *)				  ((DLword *)bascframe + FRAMESIZE);			  for (pcou = fnheader->nlocals;pcou-- != 0;) {				register LispPTR value;				value = *pvars;				if Boundp(BIND_BITS(value)) Stkref(value);				++pvars;			  }; /* for */			}; /* register int pcou */			{  register LispPTR qtemp;			   register LispPTR next;			   register LispPTR ntend;			   next = qtemp = (LispPTR) 				Addr68k_from_StkOffset(frameex->nextblock);					 /* this is offset */			   ntend = 0;	/* init flag */			   if (frameex->validnametable) {				register LispPTR nametable;				register unsigned int hi2nametable;				register unsigned int lonametable;				lonametable = frameex->lonametable;				hi2nametable = frameex->hi2nametable;				nametable = VAG2(hi2nametable,lonametable);				if (STK_HI == hi2nametable) {	  	  	  		Stkref(fnheader->framename);					qtemp = (LispPTR) 						Addr68k_from_StkOffset(lonametable);					ntend = (LispPTR) (						((DLword *)qtemp) + 						FNHEADSIZE +						(((struct fnhead *)qtemp)->ntsize)*2);				} else Stkref(nametable);			  }; /* frameex->validnametable */			  bascframe = (Bframe *) 					ADD_OFFSET(bascframe, FRAMESIZE+PADDING+						(((fnheader->pv)+1)<<2));			scantemps:			  while((int)bascframe < (int)qtemp) { 				register LispPTR value;				value = *((LispPTR *) bascframe);				if Boundp(BIND_BITS(value))  Stkref(value);				bascframe++;				}; /* while */			  if (ntend != 0) { 				bascframe = (Bframe *)					Addr68k_from_StkOffset(ntend);				qtemp = next;				ntend = 0;				goto scantemps;			  };			  bascframe = (Bframe *) next;			}; /* LOCAL regs qtemp next */			}; /* local regs fnheader frameex */		 	break;			};		case STK_GUARD:/* stack's tail ? */ {			if ((int) bascframe >= (int) scanend68K)				return(NIL);		  	else { 				bascframe = (Bframe *)((DLword *) 				bascframe + bascframe->ivar);				};			break;			};		case STK_FSB: { 			bascframe = (Bframe *)((DLword *) 			bascframe + bascframe->ivar);			break;			};		default:	/* must be basic frame !! */			{			register LispPTR bf_word;			while(STK_BF != BF_FLAGS(bf_word = *((LispPTR *)bascframe)))			{	Stkref(PTR_BITS(bf_word));				bascframe++;				};			bascframe++;			}; /* **** NOTE THIS CODE DOES NOT COMPILE CORRECTLY ON THE SUN 4				{register LispPTR bf_word;				 while(STK_BF != BF_FLAGS(					bf_word = *((LispPTR *)bascframe++)))					{ Stkref(PTR_BITS(bf_word));					};				}; **** */		};	/* switch */	};	/* while(1) */}