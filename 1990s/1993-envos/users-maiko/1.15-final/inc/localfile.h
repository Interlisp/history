/* @(#) localfile.h Version 2.24 (3/8/90). copyright envos & Fuji Xerox  */#define	PAGE_SIZE	512	/* 1 page == 512 byte *//* NIL is defined in lispemul.h and everyone who includes this file	also includes lispemul.h, so this definition is redundant.   #define	NIL	0 */#define	T	1#define	RECOG_OLD		S_POSITIVE | 0#define	RECOG_OLDEST		S_POSITIVE | 1#define	RECOG_NEW		S_POSITIVE | 2#define	RECOG_NEW_OLD		S_POSITIVE | 3#define	RECOG_NON		S_POSITIVE | 5#define	ACCESS_INPUT		S_POSITIVE | 0#define	ACCESS_OUTPUT		S_POSITIVE | 1#define	ACCESS_BOTH		S_POSITIVE | 2#define	ACCESS_APPEND		S_POSITIVE | 3/* For getfileinfo */#define	SIZE			S_POSITIVE | 1#define	WDATE			S_POSITIVE | 2#define	RDATE			S_POSITIVE | 3#define	AUTHOR			S_POSITIVE | 5#define	PROTECTION		S_POSITIVE | 6#define	EOL			S_POSITIVE | 7#define	ALL			S_POSITIVE | 8extern	DLword	*Lisp_world;	/* To access LispSysout area */#define	ToLispTime(x)	((int)x + 29969152)			/* For getfileinfo. For WDATE&RDATE */			/* 29969152 == (timer.c)LISP_UNIX_TIME_DIFF */			/* - 61200 == - 17hours */#define	ToUnixTime(x)	((int)x - 29969152)			/* For getfileinfo. For WDATE&RDATE */			/* 29969152 == (timer.c)LISP_UNIX_TIME_DIFF */#define StrNCpyFromCToLisp(lispbuf, cbuf ,len)	{ register int i;	\			register char *sptr,*dptr;			\			for(i=0,sptr=(cbuf),dptr =(lispbuf);i<(len);i++)\				GETBYTE(dptr++) = *sptr++;		\		}#define StrNCpyFromLispToC(cbuf , lispbuf, len)	{ register int i;	\			register char *sptr,*dptr;			\			for(i=0,sptr=(lispbuf),dptr =(cbuf);i<(len);i++)\				*dptr++ = GETBYTE(sptr++);		\		}/************************************************************************//*									*//*		  L i s p S t r i n g T o C S t r i n g			*//*									*//*	Convert the Lisp string in Lisp into a null-terminated C	*//*	string in C.  MaxLen is, for safety, the maximum length of	*//*	the resulting string, so the buffer doesn't overflow and	*//*	smash memory.							*//*									*//*	WARNINGS:  The Lisp string is truncated to fit the C string	*//*	without warning to the user.  FAT Lisp strings have only	*//*	the low 8 bits of each character copied over.			*//*									*//************************************************************************/#ifndef BYTESWAP#define	LispStringToCString(Lisp, C, MaxLen)				\  {									\    OneDArray	*arrayp;						\    char	*base, *dp;						\    short	*sbase;							\    int	i, length;							\    arrayp = (OneDArray *)(Addr68k_from_LADDR(Lisp));			\    length = min(MaxLen, arrayp->totalsize);				\    switch(arrayp->typenumber)						\      {									\	case THIN_CHAR_TYPENUMBER:					\		base = ((char *)(Addr68k_from_LADDR(arrayp->base)))  	\		       + ((int)(arrayp->offset));			\		strncpy(C, base, length);				\		C[length] = '\0';					\		break;							\									\	case FAT_CHAR_TYPENUMBER:					\		sbase = ((short *)(Addr68k_from_LADDR(arrayp->base)))	\		       + ((int)(arrayp->offset));			\		for(i=0,dp=C;i<(length);i++)				\		  *dp++ = (char)(*sbase++);				\		*dp = '\0';						\		break;							\	default:							\		error("LispStringToCString can not handle\n");		\      }									\  }#else  /* BYTESWAP == T CHANGED-BY-TAKE */#define	LispStringToCString(Lisp, C, MaxLen)				\  {									\    OneDArray	*arrayp;						\    char	*base, *dp;						\    short	*sbase;							\    int	i, length;							\    arrayp = (OneDArray *)(Addr68k_from_LADDR(Lisp));			\    length = min(MaxLen, arrayp->totalsize);				\    switch(arrayp->typenumber)						\      {									\	case THIN_CHAR_TYPENUMBER:					\		base = ((char *)(Addr68k_from_LADDR(arrayp->base)))  	\		       + ((int)(arrayp->offset));			\		/*for(i=0,dp=C;i<length;i++)				\		{*dp++ =(char)(GETBYTE(base++));}**/			\		StrNCpyFromLispToC(C , base , length );			\		C[length] = '\0';					\		break;							\									\	case FAT_CHAR_TYPENUMBER:					\		sbase = ((short *)(Addr68k_from_LADDR(arrayp->base)))	\		       + ((int)(arrayp->offset));			\		for(i=0,dp=C;i<(length);i++,sbase++)				\		  *dp++ = (char)(GETWORD(sbase));				\		*dp = '\0';						\		break;							\	default:							\		error("LispStringToCString can not handle\n");		\      }									\  }#endif BYTESWAP#define min(a, b) ((a <= b)?a:b)#define	LispNumToCInt(Lisp)					\		( ((Lisp & 0xFF0000) == S_POSITIVE) ?		\		(Lisp & 0xFFFF) : (*((int *)(Addr68k_from_LADDR(Lisp)))) );#define	UPLOWDIFF	0x20#define	DOWNCASE(name){						\	register char	*cp;					\		for(cp=name;*cp!='\0';++cp)			\			if((*cp >= 'A') && (*cp <= 'Z'))	\				*cp += UPLOWDIFF;		\	}#define	UPCASE(name){						\	register char	*cp;					\		for(cp=name;*cp!='\0';++cp)			\			if((*cp >= 'a') && (*cp <= 'z'))	\				*cp -= UPLOWDIFF;		\	}#ifdef FSERROR#define	DIRP(path, dir, buf){				\	int rval;					\	struct	stat	statbuf;			\		strcpy(buf, path);			\		strcat(buf, dir);			\		TIMEOUT( rval=stat(buf, &statbuf) );	\		if( rval == 0){				\			if( (statbuf.st_mode & S_IFMT) == S_IFDIR ){	\				strcat(path, dir);			\				return(1);				\			}				\		}					\		if( rval == -1 && errno == 60){		\			*Lisp_errno = 60;		\			return(0);			\		}					\		}#else#define	DIRP(path, dir, buf){				\	int rval;					\	struct	stat	statbuf;			\		strcpy(buf, path);			\		strcat(buf, dir);			\		TIMEOUT( rval=stat(buf, &statbuf) );	\		if( rval == 0){				\			if( (statbuf.st_mode & S_IFMT) == S_IFDIR ){	\				strcat(path, dir);			\				return(1);				\			}				\		}					\		}#endif#define	FILEP(path, file, buf){				\	int rval;					\		strcpy(buf, path);			\		strcat(buf, file);			\		TIMEOUT( rval=access(buf, F_OK) );	\		if( access(buf, F_OK) == 0){		\			strcat(path, file);		\			return(1);			\		}					\		}#define	STREQ(name1, name2)(	\		(*name1 == *name2) && (strcmp(name1, name2) == 0)	\		)/*** These aren't used -FS	#define	MAXNUM(i,j)  (i>j ? i : j)	#define	MINNUM(i,j)  (i<j ? i : j) ***/#define	VERSIONLEN 10#define	MAXVERSION 999999999#define	UnixVersionToLispVersion(pathname){		\		char	*cp;				\		register char	*cp1;				\		if( ((cp=index(pathname, '~'))!=0) && (*(cp-1) == '.') && ((cp1=index(cp+1, '~'))!=0) ){	\			*(cp-1) = ';';				\			for(cp++;cp!=cp1;cp++)			\				*(cp-1) = *cp;			\			for(cp1++;*cp1!='\0';cp1++, cp++)	\				*(cp-1) = *cp1;			\			*(cp-1) = '\0';				\		}else						\			strcat(pathname, ";0");			\		}#define	LispVersionToUnixVersion(pathname){		\		char	*cp;				\		register char	*cp1;			\		register char	*cp2;			\		if( (cp=index(pathname, ';')) != 0 ){	\			switch(*(cp+1)){		\			case '\0':			\				break;			\			case '0':			\				if(*(cp+2) == '\0'){	\					*cp = '\0';	\					break;		\				}			\			default:			\				*cp++ = '.';		\				for(cp1=cp;((*cp1>='0')&&(*cp1<='9'))||*cp1=='*';cp1++);	\				for(cp2=cp1;*cp2!='\0';cp2++);	\				for(;cp2!=cp1;cp2--)	\					*(cp2+2) = *cp2;\				*(cp2+2) = *cp2;\				*(cp1+1) = '~';		\				for(;cp!=cp1;cp1--)		\					*cp1 = *(cp1-1);	\				*cp = '~';		\			}				\		}					\		}/* An argument of AddDodNoExtention must be LispVersion convention *//* Like "foo/fee.fee;3" or "/foo/foo;3" *//* AddDodNoExtention must be put after UnixVersionToLispVersion */#define	AddDodNoExtention(file){			\		register char	*cp;			\		register char	*cp1;			\		if( (rindex(file,'.')== 0) && ((cp=rindex(file,';'))!=0) ){	\			for(cp1=cp;*cp1!='\0';cp1++);	\			*(cp1+1) = '\0';		\			for(;cp!=cp1;cp1--)		\				*cp1 = *(cp1-1);	\			*cp = '.';			\		}					\		}/* An argument of RemoveDodNoExtenstion must be LispVersion convention *//* Like "foo/fee.fee;3" or "/foo/foo.;3" *//* RemoveDodNoExtenstion must be put before LispVersionToUnixVersion */#define RemoveDodNoExtenstion(file){					\		register char	*cp;					\		if( ((cp=rindex(file, ';'))!=0) && (*(cp-1)=='.') ){	\			for(;*cp!='\0';++cp)				\				*(cp-1) = *cp;				\			*(cp-1) = '\0';					\		}							\		}		extern	int	errno;#define	ChangeToVersionless(pathname){			\		register char	*cp;			\		if( (cp=rindex(pathname, ';')) != 0)	\			*cp = '\0';			\		}#define NoFileP(version_array)				\		((version_array->version_no==LASTVERSIONARRAY)? T : NIL)#ifdef FSERROR#define	UNLINK(x){					\		TIMEOUT(rval=unlink(x));		\		if(rval == -1){				\			err_mess("unlink", errno);	\			*Lisp_errno = errno;		\			return(0);			\		}					\		}#else#define	UNLINK(x){					\		TIMEOUT(rval=unlink(x));		\		if(rval == -1){				\			err_mess("unlink", errno);	\			return(0);			\		}					\		}#endif#ifdef FSERROR#define LINK(x,y){					\		TIMEOUT(rval=link(x, y));		\		if(rval == -1){				\			if(errno == 2)			\				return(1);		\			else{				\				err_mess("link", errno);\				*Lisp_errno = errno;	\				return(0);		\			}				\		}					\		}#else#define LINK(x,y){					\		TIMEOUT(rval=link(x, y));		\		if(rval == -1){				\			if(errno == 2)			\				return(1);		\			else{				\				err_mess("link", errno);\				return(0);		\			}				\		}					\		}#endif#ifdef FSERROR#define RENAME(x,y){					\		TIMEOUT(rval=rename(x, y));		\		if(rval == -1){				\			switch(errno){			\			case 2:				\				return(1);		\			case 18:			\				*Lisp_errno = errno;	\				return(0);		\			default:			\				err_mess("rename", errno);\				*Lisp_errno = errno;	\				return(0);		\			}				\		}					\		}#else#define RENAME(x,y){					\		TIMEOUT(rval=rename(x, y));		\		if(rval == -1){				\			switch(errno){			\			case 2:				\				return(1);		\			default:			\				err_mess("rename", errno);\				return(0);		\			}				\		}					\		}#endif#ifdef FSERROR#define	STAT(x,y){					\		TIMEOUT(rval=stat(x, y));		\		if(rval != 0){				\			err_mess("stat", errno);	\			*Lisp_errno = errno;		\			return(-1);			\		}					\		}#else#define	STAT(x,y){					\		TIMEOUT(rval=stat(x, y));		\		if(rval != 0){				\			err_mess("stat", errno);	\			return(-1);			\		}					\		}#endif