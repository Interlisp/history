Files /users/maiko/stable/src/Ctest.c and /users/maiko/final3.4/src/Ctest.c are identicalFiles /users/maiko/stable/src/Ctest.o and /users/maiko/final3.4/src/Ctest.o are identicalFiles /users/maiko/stable/src/Kdebugtools.c and /users/maiko/final3.4/src/Kdebugtools.c are identicalFiles /users/maiko/stable/src/Kdebugtools.o and /users/maiko/final3.4/src/Kdebugtools.o are identicalFiles /users/maiko/stable/src/Kprint.c and /users/maiko/final3.4/src/Kprint.c are identicalBinary files /users/maiko/stable/src/Kprint.o and /users/maiko/final3.4/src/Kprint.o differFiles /users/maiko/stable/src/Ktesttool.c and /users/maiko/final3.4/src/Ktesttool.c are identicalBinary files /users/maiko/stable/src/Ktesttool.o and /users/maiko/final3.4/src/Ktesttool.o differFiles /users/maiko/stable/src/allocmds.c and /users/maiko/final3.4/src/allocmds.c are identicalBinary files /users/maiko/stable/src/allocmds.o and /users/maiko/final3.4/src/allocmds.o differFiles /users/maiko/stable/src/arith2.c and /users/maiko/final3.4/src/arith2.c are identicalBinary files /users/maiko/stable/src/arith2.o and /users/maiko/final3.4/src/arith2.o differFiles /users/maiko/stable/src/arith3.c and /users/maiko/final3.4/src/arith3.c are identicalBinary files /users/maiko/stable/src/arith3.o and /users/maiko/final3.4/src/arith3.o differFiles /users/maiko/stable/src/arith4.c and /users/maiko/final3.4/src/arith4.c are identicalBinary files /users/maiko/stable/src/arith4.o and /users/maiko/final3.4/src/arith4.o differFiles /users/maiko/stable/src/array.c and /users/maiko/final3.4/src/array.c are identicalBinary files /users/maiko/stable/src/array.o and /users/maiko/final3.4/src/array.o differFiles /users/maiko/stable/src/array2.c and /users/maiko/final3.4/src/array2.c are identicalBinary files /users/maiko/stable/src/array2.o and /users/maiko/final3.4/src/array2.o differFiles /users/maiko/stable/src/array3.c and /users/maiko/final3.4/src/array3.c are identicalBinary files /users/maiko/stable/src/array3.o and /users/maiko/final3.4/src/array3.o differFiles /users/maiko/stable/src/array4.c and /users/maiko/final3.4/src/array4.c are identicalBinary files /users/maiko/stable/src/array4.o and /users/maiko/final3.4/src/array4.o differFiles /users/maiko/stable/src/array5.c and /users/maiko/final3.4/src/array5.c are identicalBinary files /users/maiko/stable/src/array5.o and /users/maiko/final3.4/src/array5.o differFiles /users/maiko/stable/src/array6.c and /users/maiko/final3.4/src/array6.c are identicalBinary files /users/maiko/stable/src/array6.o and /users/maiko/final3.4/src/array6.o differFiles /users/maiko/stable/src/atom.c and /users/maiko/final3.4/src/atom.c are identicalFiles /users/maiko/stable/src/atom.o and /users/maiko/final3.4/src/atom.o are identicalFiles /users/maiko/stable/src/bin.c and /users/maiko/final3.4/src/bin.c are identicalBinary files /users/maiko/stable/src/bin.o and /users/maiko/final3.4/src/bin.o differFiles /users/maiko/stable/src/binds.c and /users/maiko/final3.4/src/binds.c are identicalFiles /users/maiko/stable/src/binds.o and /users/maiko/final3.4/src/binds.o are identicalFiles /users/maiko/stable/src/bitblt.c and /users/maiko/final3.4/src/bitblt.c are identicalOnly in /users/maiko/final3.4/src: bitblt.c-Binary files /users/maiko/stable/src/bitblt.o and /users/maiko/final3.4/src/bitblt.o differdiff -w -r -s /users/maiko/stable/src/bitbltsub.c /users/maiko/final3.4/src/bitbltsub.c1c1< /* This is G-file @(#) bitbltsub.c Version 2.5 (8/1/88). copyright Xerox & Fuji Xerox  */---> /* This is G-file @(#) bitbltsub.c Version 2.4 (7/22/88). copyright Xerox & Fuji Xerox  */619a620,624> > #define FRPLPTR(old , new) { \> 		GCLOOKUP(0x8000,DELREF, (old)); \> 		GCLOOKUP(0x8000,ADDREF, (new)); \> 		(old) = (new) ; }Binary files /users/maiko/stable/src/bitbltsub.o and /users/maiko/final3.4/src/bitbltsub.o differFiles /users/maiko/stable/src/blt.c and /users/maiko/final3.4/src/blt.c are identicalFiles /users/maiko/stable/src/blt.o and /users/maiko/final3.4/src/blt.o are identicalFiles /users/maiko/stable/src/car-cdr.c and /users/maiko/final3.4/src/car-cdr.c are identicalBinary files /users/maiko/stable/src/car-cdr.o and /users/maiko/final3.4/src/car-cdr.o differFiles /users/maiko/stable/src/common.c and /users/maiko/final3.4/src/common.c are identicalFiles /users/maiko/stable/src/common.o and /users/maiko/final3.4/src/common.o are identicalFiles /users/maiko/stable/src/conspage.c and /users/maiko/final3.4/src/conspage.c are identicalBinary files /users/maiko/stable/src/conspage.o and /users/maiko/final3.4/src/conspage.o differFiles /users/maiko/stable/src/createcell.c and /users/maiko/final3.4/src/createcell.c are identicalBinary files /users/maiko/stable/src/createcell.o and /users/maiko/final3.4/src/createcell.o differFiles /users/maiko/stable/src/directory.c and /users/maiko/final3.4/src/directory.c are identicalFiles /users/maiko/stable/src/directory.o and /users/maiko/final3.4/src/directory.o are identicaldiff -w -r -s /users/maiko/stable/src/disp68K.il /users/maiko/final3.4/src/disp68K.il92,96d91< /*< 	***************************************************************< 	Inlines to Decalare Labels< 	***************************************************************< */98,106d92< .inline	_asm_label_op_fn_common,0< op_fn_common:< .end< < .inline	_asm_label_check_interrupt,0< check_interrupt:< .end< < 799,803d784< /*< 	***************************************************************< 	Code for RETURN opcode< 	***************************************************************< */804a786> 807,815c789,804< 	movl	_MachineState+4,a2		|a2 = PVAR< 	movl	a2@(-20),d3			|d3 = FX >> 1< 	lsrl	#1,d3< 	jcs	do_slow_return			|jump if must do slow return< 	movl	_MachineState,a3< 	movl	_Stackspace,a1			|a1 = Stackspace< 	andw	#0x7ffff,d3< 	lea	a1@(0,d3:w:4),a2		|a2 = new PVAR< 	movl	a2,_MachineState+4---> 	movl	_CurrentFX,a1		|returnFX = a1> 	movl	#65536,d0> 	movw	a1@(2),d0		|returnFX->alink> 	lsrl	#1,d0			|low bit to carry> 	jcs	ni			|jump if slow return> 	movl	a2,a3			|CSTKPTR = IVAR> 	movl	_Lisp_world,a0		|PVar=> 	lea	a0@(0,d0:l:4),a0> 	movl	a0,_PVar> 	moveq	#20,d1> 	subl	d1,a0			|returnFX = a0> 	movl	a0,_CurrentFX		|CURRENTFX = returnFX> 	movl	#65536,d0> 	movw	a0@(-2),d0		|returnFX -1> 	movl	_Lisp_world,a1> 	lea	a1@(0,d0:l:2),a2	|IVAR = a2817,820c806< 	movw	a2@(-22),d0			|*(returnFX -1)< 	lea	a1@(0,d0:l:2),a0< 	movl	a0,_MachineState		|IVAR = < 	movl	a2@(-16),d0			|returnFX->fnheader---> 	movb	a0@(7),d0		|returnFX->hi2fnheader822,844c808,815< 	andl	#16777215,d0			< 	movl	_Lisp_world,a5< 	lea	a5@(0,d0:l:2),a0		|Addr68k_from_LADDR< 	movl	a0,_FuncObj			|FuncObj = < 	moveq	#0,d4				|returnFX->pc< 	movw	a2@(-10),d4< 	lea	a0@(0,d4:l:1),a5		|PCMAC = < 	moveq	#0,d0				|d0 = stkmin< 	movw	a0@,d0				|stkmin< 	lsll	#1,d0< 	movl	_EndSTKP,d1< 	movl	d1,d2				|d2 = save _EndSTKP< 	subl	d0,d1< 	movl	d1,_Irq_Stk_Check< 	cmpl	d1,a3< 	jgt	do_a_timer_check< 	tstl	_Irq_Stk_End< 	jle	do_a_timer_check< 	movl	d2,_Irq_Stk_End			|_Irq_Stk_End = _EndSTKP  < 	btst	#26,d3				|test native bit< 	jne	is_native_return		|jump if a native return< do_a_dispatch:< 	movb	a5@,d6				|dispatch---> 	movw	a0@(4),d0		|returnFX->lofnheader> 	movl	_Lisp_world,a1> 	lea	a1@(0,d0:l:2),a1> 	movl	a1,_FuncObj		|FuncObj = a1> 	subl	a5,a5> 	movw	a0@(10),a5		|returnFX->pc a5> 	lea	a1@(0,a5:l:1),a5	| a5 + FuncObj> 	movb	a5@,d6846,863c817< 	.word	20176< is_native_return:< 						|a0 is still _FuncObj< 						|d4 = returnFX->pc< 	moveq	#0,d0< 	movw	a0@(6),d0			|startpc< 	movl	a0@(-4,d0:l:1),a1		|*(fnobj + startpc - 40)< 	lea	a1@(0,d4:l:1),a0< 	movl	a0@(28),d3			|get entry addr< 	jeq	do_a_dispatch			|no entry point< 	movl	d7,a3@+				|push TOPOFSTACK< 	movl	_MachineState+4,a4		|setup PVAR< 	movl	_MachineState,a5		|setup IVAR< 	movl	d3,a0< 	.word	20176< 	movl	a0@,d0< 	movl	a4@,d1< 	movl	a5@,d2---> 	jmp	a0@865,867d818< do_a_timer_check:< 	movl	#256,d6< 	jmp	check_interrupt869,913d819< do_slow_return:< < 	movl	a5,_PC< 	movl	d7,_TopOfStack< 	lea	a3@(-4),a0< 	movl	a0,_CurrentStackPTR< 	jbsr	_slowreturn< 	movl	_PC,a5< 	movl	_CurrentStackPTR,a3< 	addql	#4,a3< 	movl	_TopOfStack,d7< 	movl	_FuncObj,a0< 	moveq	#0,d0< 	movw	a0@,d0< 	lsll	#1,d0< 	movl	_EndSTKP,d1< 	subl	d0,d1< 	movl	d1,_Irq_Stk_Check< 	cmpl	_Irq_Stk_Check,a3< 	jgt	do_a_timer_check< 	tstl	_Irq_Stk_End< 	jle	do_a_timer_check< 	movl	_EndSTKP,_Irq_Stk_End< 	movl	_MachineState+4,a0< 	btst	#3,a0@(-20)< 	jeq	do_a_dispatch< 	movl	_FuncObj,a6@(-32)< 	movl	a6@(-32),a0< 	moveq	#0,d0< 	movw	a0@(6),d0< 	movl	a0@(-4,d0:l),a0< 	movl	a5,d0< 	subl	a6@(-32),d0< 	lea	a0@(0,d0:l:4),a0< 	movl	a0@(28),d3< 	jeq	do_a_dispatch< 	movl	d7,a3@+< 	movl	_MachineState+4,a4< 	movl	_MachineState,a5< 	movl	d3,a0< 	.word	20176< 	movl	a0@,d0< 	movl	a4@,d1< 	movl	a5@,d2< 916,921d821< /*< 	***************************************************************< 	COMPONENTS OF FN CALL< 	***************************************************************< */< /*	Head Section of code	*/923,936d822< .inline _fnx_section1,0< 	moveq	#0,d1			|# args< 	movb	a5@(1),d1		|carefull this gets zapped!< 	moveq	#0,d0			|Get Atom Index< 	movw	a5@(2),d0< 	movl	_Defspace,a0		|Turn into Addr of Def Cell< 	movl	a0@(0,d0:l:4),d4	|d4 = defcell word< 	jge	400$			|Jump if not CCodeP< 	andl	#16777215,d4	< 	movl	_Lisp_world,a2< 	lea	a2@(0,d4:l:2),a2	|a2 = LOCFNCELL< 	movl	_MachineState+4,a1	|a1 = PVAR< 	lea	a5@(4),a0		|BCE_CURRENTFX->pc	< .end938,939c824,826< .inline _fn_section1,0< 	moveq	#0,d0			|Get Atom Index---> .inline _fn3,0> > 	moveq	#0,d0941,987c828,848< 	movl	_Defspace,a0		|Turn into Addr of Def Cell< 	movl	a0@(0,d0:l:4),d4	|d4 = defcell word< 	jge	400$			|Jump if not CCodeP< 	andl	#16777215,d4	< 	movl	_Lisp_world,a2< 	lea	a2@(0,d4:l:2),a2	|a2 = LOCFNCELL< 	movl	_MachineState+4,a1	|a1 = PVAR< 	lea	a5@(3),a0		|BCE_CURRENTFX->pc	< .end< .inline _fn_section2,0< 	subl	_FuncObj,a0		|PCMAC - FuncObj< 	movw	a0,a1@(-10)< .end< .inline _fn0_args,0< 	lea	a3@(4),a0		|a0 = newivar = CSTKPTR - x + 1< .end< .inline _fn1_args,0< 	lea	a3@(0),a0		|a0 = newivar = CSTKPTR - x + 1< .end< .inline _fn2_args,0< 	lea	a3@(-4),a0		|a0 = newivar = CSTKPTR - x + 1< .end< .inline _fn3_args,0< 	lea	a3@(-8),a0		|a0 = newivar = CSTKPTR - x + 1< .end< .inline _fn4_args,0< 	lea	a3@(-12),a0		|a0 = newivar = CSTKPTR - x + 1< .end< .inline _fnx_args,0< 	negl	d1< 	lea	a3@(4,d1:l:4),a0	|a0 = newivar = CSTKPTR - x + 1< .end< .inline _fn_section3,0< 	movl	a2@(8),d0		|get flags from FN header< 	jmi	is_native_call		|jump if a native call< 	moveq	#0,d0			|d0 = stkmin< 	movw	a2@,d0< 	lsll	#1,d0< 	movl	_Irq_Stk_End,d2< 	subl	d0,d2			|end - min< 	movl	d2,_Irq_Stk_Check	|Irq_Stk_Check = end - min< 	cmpl	d2,a3			|CSTKPTR > Irq_Stk_Check< 	jgt	check_interrupt		|jump if stack overflow< 	movl	a0,_MachineState< 	movl	_Stackspace,d2		|d2 = Stackspace< 	subl	d2,a0< 	movl	a0,d3			|d3 = NEXTBLOCK---> 	movl	_Defspace,a0> 	lea	a0@(0,d0:l:4),a1		|defcell = a1> 	movl	a1,d4				|save defcell in d4> |	movl	a1,a6@(-20)> 	btst	#7,a1@> 	jeq	ni> 	movl	a1@,d0				|defcell->defpointer> 	andl	#16777215,d0> 	movl	_Lisp_world,a0> 	lea	a0@(0,d0:l:2),a1		|LOCFNCELL> 	movl	a1,d2				|save LOCFNCELL in a1, d2> |	movl	a1,a6@(-12)> 	moveq	#0,d0> 	movw	a1@,d0				|LOCFNCELL->stkmin> 	lea	a3@(4,d0:l:2),a0> |	addql	#4,a0> 	cmpl	_StkLimO,a0> 	jcc	ni				|stack overflow> 	lea	a3@(-8),a1			|CSTKPTR-(x<<1)+2> 	subl	_Lisp_world,a1> 	movl	a1,d3989,992c850,869< 	movw	d3,a1@(-12)		|BCE_CURRENTFX->nextblock =< 	movl	d7,a3@+< 	movw	a2@(2),d0		|LOCFNCELL->na< 	jlt	275$			|jump if no need to loop---> |	movl	d3,a1> 	andl	#65535,d3			|NEXTBLOCK = d3> |	movl	d0,d3> 	movl	_CurrentFX,a1			|a1 = _CurrentFX> 	movw	d3,a1@(8)			|CURRENTFX->nextblock => 	movl	d3,d0> 	orl	#65536,d0> 	movl	_Lisp_world,a0> 	lea	a0@(0,d0:l:2),a2		|IVAR => |	movl	_CurrentFX,a0> 	movl	a5,d0> 	subl	_FuncObj,d0> 	addql	#3,d0> 	movw	d0,a1@(10)			|CURRENTFX->pc> 	movl	d7,a3@+				|CPushCStack> 	movl	d2,a1				|get LOCFNCELL = a1> 	movw	a1@(2),d0> 	tstw	d0> 	jlt	fn3noargs			|no function arguments> |	movw	a0@(2),d0994,1013c871< .end< .inline _fn0_xna,0< 	moveq	#0,d1			|x - na< .end< .inline _fn1_xna,0< 	moveq	#1,d1			|x - na< .end< .inline _fn2_xna,0< 	moveq	#2,d1			|x - na< .end< .inline _fn3_xna,0< 	moveq	#3,d1			|x - na< .end< .inline _fn4_xna,0< 	moveq	#4,d1			|x - na< .end< .inline _fnx_xna,0< 	negl	d1			|x - na< .end< .inline _fn_section4,0---> 	moveq	#2,d11015,1016c873,875< 	jpl	250$< 200$:---> |	movl	d1,d4> 	jra	fn3ly16> fn3ly17:1019,1020c878,881< 	jmi	200$< 250$:---> fn3ly16:> 	tstl	d1> 	jlt	fn3ly17> |	movl	d4,d01023,1027c884,891< 275$:< 	orl	#-2147483648,d3< 	movl	d3,a3@+< 	movl	a1,d0			|(StkOffset_from_68K(PVAR)< 	subl	d2,d0---> fn3noargs:> 	movl	d3,d0				|CPush(BF_MARK32 | NEXTBLOCK)> 	orl	#-2147483648,d0> 	movl	d0,a3@+> 	movl	a3,_CurrentFX			|CURRENTFX => 	movl	_PVar,d0> |	subl	_Lisp_world,d0> 	subl	a0,d01029,1049c893,928< 	orl	#-1073741824,d0		|(FX_MARK << 16)< 	movl	d0,a3@< 	swap	d4			|SWAP_WORDS(defcell_word)< 	movl	d4,a3@(4)< 	lea	a3@(20),a3		|CSTKPTR += FRAMESIZE< 	movl	a3,_MachineState+4	|PVAR = (LispPTR *) CSTKPTR< 	movw	a2@(4),d2		|result = LOCFNCELL->pv< 	extl	d2< 	jlt	350$< 	moveq	#-1,d4< 325$:< 	movl	d4,a3@+< 	movl	d4,a3@+< 	dbra	d2,325$< 350$:< 	addqw	#4,a3< 	moveq	#0,d0< 	movw	a2@(6),d0< 	lea	a2@(0,d0:l),a5< 	movl	a2,_FuncObj< .end---> 	andl	#65535,d0> 	orl	#-1073741824,d0> 	movl	d0,a3@				|*CSTKPTR=FX_MARK etc> 	movl	d4,a0				|defcell = a0> 	movw	a0@(2),a3@(4)			|->lofnheader = ->defpointer> |	movl	a6@(-20),a0> |	movl	a0@,d0> |	andl	#16777215,d0> |	movw	d0,a3@(4)> |	movl	d4,a0> |	movl	a6@(-20),a0> 	movb	a0@(1),a3@(7)			|hi2fnheader = *((defcell)+1)> 	lea	a3@(20),a3> 	movl	a3,_PVar			|PVar = CSTKPTR> |	movl	d2,a0> 	movw	a1@(4),d0			||LOCFNCELL->pv> 	extl	d0> 	addql	#1,d0> |	movl	d0,a6@(-8)> 	moveq	#-1,d1> 	jra	fn3ly18> fn3ly19:> 	movl	d1,a3@+> 	movl	d1,a3@+> 	subql	#1,d0> fn3ly18:> 	tstl	d0> 	jgt	fn3ly19> 	addqw	#4,a3				| CSTKPTR += 2> |	movl	d2,a0> |	moveq	#0,d0> 	subl	a5,a5> 	movw	a1@(6),a5			|LOCFNCELL->startpc> 	addl	a1,a5> |	movl	d0,a5> 	movl	a1,_FuncObj1051,1054d929< .inline _fn_section5,0< 400$:			|following "C" code does setup to opfn common< 			|< .end1056,1070d930< .inline	_to_native_label,0< is_native_call:< 	movl	a0,a5			|Set the IVAR (NEED x)< 	movl	a2,_FuncObj< 	movl	d7,a3@+< 	moveq	#0,d0< 	movw	a2@(6),d0< 	movl	d0,a0< 	movl	a0@(-4,a2:l),a0< 	movl	a0@(16),a0		|Set entry address< 	movl	a1,a4			|Set native PVAR< 	.word	20176			|Jump to native code< 	movl	a0@,d0< 	movl	a4@,d1< 	movl	a5@,d21072d931< Files /users/maiko/stable/src/dispSPARC.il and /users/maiko/final3.4/src/dispSPARC.il are identicalFiles /users/maiko/stable/src/draw.c and /users/maiko/final3.4/src/draw.c are identicalFiles /users/maiko/stable/src/draw.o and /users/maiko/final3.4/src/draw.o are identicalFiles /users/maiko/stable/src/dsk.c and /users/maiko/final3.4/src/dsk.c are identicalFiles /users/maiko/stable/src/dsk.o and /users/maiko/final3.4/src/dsk.o are identicalFiles /users/maiko/stable/src/dspsubrs.c and /users/maiko/final3.4/src/dspsubrs.c are identicalFiles /users/maiko/stable/src/dspsubrs.o and /users/maiko/final3.4/src/dspsubrs.o are identicalFiles /users/maiko/stable/src/eqf.c and /users/maiko/final3.4/src/eqf.c are identicalBinary files /users/maiko/stable/src/eqf.o and /users/maiko/final3.4/src/eqf.o differFiles /users/maiko/stable/src/ether.c and /users/maiko/final3.4/src/ether.c are identicalFiles /users/maiko/stable/src/ether.o and /users/maiko/final3.4/src/ether.o are identicalFiles /users/maiko/stable/src/findkey.c and /users/maiko/final3.4/src/findkey.c are identicalFiles /users/maiko/stable/src/findkey.o and /users/maiko/final3.4/src/findkey.o are identicalFiles /users/maiko/stable/src/fp.c and /users/maiko/final3.4/src/fp.c are identicalBinary files /users/maiko/stable/src/fp.o and /users/maiko/final3.4/src/fp.o differFiles /users/maiko/stable/src/fvar.c and /users/maiko/final3.4/src/fvar.c are identicalBinary files /users/maiko/stable/src/fvar.o and /users/maiko/final3.4/src/fvar.o differFiles /users/maiko/stable/src/gc.c and /users/maiko/final3.4/src/gc.c are identicalFiles /users/maiko/stable/src/gc.o and /users/maiko/final3.4/src/gc.o are identicalFiles /users/maiko/stable/src/gc2.c and /users/maiko/final3.4/src/gc2.c are identicalFiles /users/maiko/stable/src/gc2.o and /users/maiko/final3.4/src/gc2.o are identicalFiles /users/maiko/stable/src/gcarraymaker.c and /users/maiko/final3.4/src/gcarraymaker.c are identicalFiles /users/maiko/stable/src/gcarraymaker.o and /users/maiko/final3.4/src/gcarraymaker.o are identicaldiff -w -r -s /users/maiko/stable/src/gcfinalfuncs.c /users/maiko/final3.4/src/gcfinalfuncs.c1,2c1,2< /* This is G-file @(#) gcfinalfuncs.c Version 2.7 (7/31/88). copyright Xerox & Fuji Xerox  */< static char *id = "@(#) gcfinalfuncs.c	2.7 7/31/88";---> /* This is G-file @(#) gcfinalfuncs.c Version 2.6 (7/8/88). copyright Xerox & Fuji Xerox  */> static char *id = "@(#) gcfinalfuncs.c	2.6 7/8/88";28a29,30> /*			 refcnt();					 */> /*			 gc_lookup_bigrefcnt0();			 */118a121,186> unsigned int gc_lookup_bigrefcnt0(ptr)> LispPTR			ptr;>    { struct gc_ovfl 	*oventry;>      LispPTR		tmp;> 	oventry = (struct gc_ovfl *)HTbigcount;> 	if (Oddp(LOLOC(ptr)))			/*address adjustment */> 	   --ptr;> 	while((tmp = oventry->ovfl_ptr) != ptr)> 	   { if (tmp == NIL)> 		   { error(> 	"GC ERROR: refcnt previously overflowed, but not found in table.\n");> 			return(MAX_GCCOUNT);> 		   };> 		++oventry; /* next entry */> 	   };> 	return(oventry->ovfl_cnt);>    }> > unsigned int refcnt(ptr)> LispPTR	ptr;>    { struct hashentry 	*entry;>      struct htlinkptr	*htlptr;>      struct htcoll	*link;>      unsigned int	cnt;> 	if ((GetTypeEntry(ptr) & TT_NOREF) != 0) /* MDSTT's NOREF checking */> 		return(1);> 	entry = (struct hashentry *)Addr68k_from_LADDR(> 			LADDR_from_68k(HTmain)+(LOLOC(ptr) >> 1));> 	htlptr = (struct htlinkptr *)entry;> 	if (htlptr->contents == 0)			/* no entry */> 		return(1);> 	else if (entry->collision) 			/* scan the linkage */> 		{ link=(struct htcoll *)Addr68k_from_LADDR(> 			LADDR_from_68k(HTcoll)+GetLinkptr(htlptr->contents));> 		  while(link->next_free != 0)		/* cont linkage ? */> 			{ if (GetSegnuminColl(link->free_ptr) == HILOC(ptr))> 				if (cnt = GetCountinColl(link->free_ptr) < > 				    MAX_GCCOUNT)	/*normal in linkage*/> 					return(cnt);> 				else			/* big in linkage */> 				   { cnt = gc_lookup_bigrefcnt0(ptr);> 					return(cnt);> 				   };> 			  link = (struct htcoll *)Addr68k_from_LADDR(> 				LADDR_from_68k(HTcoll)+link->next_free);> 			}> 		  if (GetSegnuminColl(link->free_ptr) == HILOC(ptr))> 			if (cnt = GetCountinColl(link->free_ptr) < > 			    MAX_GCCOUNT)		/*normal in linkage*/> 				return(cnt);> 			else				/* big in linkage */> 			   { cnt = gc_lookup_bigrefcnt0(ptr);> 				return(cnt);> 			   };> 		  return(1);					/* no entry */> 		}> 	else if (HILOC(ptr) != entry->segnum)	/* other object's */> 		return(1);> 	else if ((cnt = entry->count) < MAX_GCCOUNT)	/* normal case */> 		return(cnt);> 	else						/* bigcount case */> 	   {cnt = gc_lookup_bigrefcnt0(ptr);> 	    return(cnt);> 	   };>    }> 139a208,209> 	 else if (free && (refcnt(base) != 1))> 		error("Free ARRAYBLOCK with RefCnt not 1\n");Binary files /users/maiko/stable/src/gcfinalfuncs.o and /users/maiko/final3.4/src/gcfinalfuncs.o differFiles /users/maiko/stable/src/gchoverflow.c and /users/maiko/final3.4/src/gchoverflow.c are identicalFiles /users/maiko/stable/src/gchoverflow.o and /users/maiko/final3.4/src/gchoverflow.o are identicaldiff -w -r -s /users/maiko/stable/src/gchtfind.c /users/maiko/final3.4/src/gchtfind.c1,2c1,2< /* This is G-file @(#) gchtfind.c Version 2.6 (8/1/88). copyright Xerox & Fuji Xerox  */< static char *id = "@(#) gchtfind.c	2.6 8/1/88";---> /* This is G-file @(#) gchtfind.c Version 2.4 (7/8/88). copyright Xerox & Fuji Xerox  */> static char *id = "@(#) gchtfind.c	2.4 7/8/88";3a4,85> /*************************************************************************/> /*************************************************************************/> /*	Copyright (C) 1987 by Fuji Xerox Co., Ltd. All rights reserved.  */> /*************************************************************************/> /*                                                                       */> /*                       File Name : gchtfind.c                          */> /*                                                                       */> /*************************************************************************/> /*                                                                       */> /*                      Creation Date : July-8-1987                      */> /*                      Written by Tomoru Teruuchi                       */> /*                                                                       */> /*************************************************************************/> /*                                                                       */> /*           Functions : htfind(ptr,casep);                              */> /*                       gc_enter_bigrefcnt(ptr,entry);                  */> /*                       gc_modify_bigrefcnt(entry,casep,ptr);           */> /*                       *getlink();                                     */> /*                       dellink(link,prev,entry);                       */> /*                       freelink(linkcell);                             */> /*                       newentry(entry,ptr,casep);                      */> /*                       modentry(entry,casep,ptr);                      */> /*                                                                       */> /*                                                                       */> /*************************************************************************/> /*           Description :                                               */> /*	This file module may have the functions for Reference Counting.	 */> /*	The function "htfind" is the main function in this module(for	 */> /*	reference counting) and it is based on the UFN function "\HTFIND"*/> /*	of Opcode "GCREF" that is written in Xerox Lisp.		 */> /*	This file's functions can be categolizeed to three groups.	 */> /*	First is the main function, that is, "htfind". This isthe agent	 */> /*	of manipulating the reference count table, that is, "HTmain",	 */> /*	"HTcoll" and "HTbigcount". The process types of the function is  */> /*	as following :							 */> /*		ADDREF(= 0) : increment reference count			 */> /*		DELREF(= 1) : decrement reference count			 */> /*		STKREF(= 2) : set stkref field(this indicates that this	 */> /*			      object is refered from stack.)		 */> /*									 */> /*	Second is the amount of functions that may modify the reference	 */> /*	count table acually.(These function was implemented by macro in	 */> /*	Lisp.)								 */> /*	freelink(linkcell)	LispPTR linkcell			 */> /*	 This function may arrange the free linkage of collision table	 */> /*	 entries.							 */> /*	dellink(link, prev, entry) LispPTR link, prev, entry		 */> /*	 Thsi function may delete the entry of collision table(that may  */> /*	 be indicated by "link". And "prev" may indicate the previous    */> /*	 entry of the target entry, "link", on the entries' linkage.	 */> /*	 If "prev" is NIL, it may tell that there is no entry between    */> /*	 "link" and "entry"."entry" is the header of the linkage and the */> /*	 entry in the "HTmain" table.					 */> /*	*getlink()							 */> /*	 This function may get the new entry template on the collision	 */> /*	 table, that is, "HTcoll". And may return its Lisp Address.(But  */> /*	 this gotten entry has no information. The function "newentry"	 */> /*	 may set information to this new entry.)			 */> /*	newentry(entry, ptr, casep)	LispPTR entry,ptr; DLword casep  */> /*	 This function may set new entrie's information to new entry.	 */> /*	 "entry" is the Lisp Address of new entry. "ptr" is the Lisp	 */> /*	 Address of the Lisp Object. "casep" is the code of ref. counting*/> /*	 process.(0,1 or 2)						 */> /*	modentry(entry,casep,ptr)	LispPTR entry,ptr;DLword casep   */> /*	 This function may modify the reference count actually. The	 */> /*	 parameters are same as the function "newentry".		 */> /*	Third is the functions to manipulate the Big Count table.	 */> /*	gc_enter_bigrefcnt(ptr,entry)	LispPTR ptr, entry		 */> /*	 This function may be called in ADDREF to the object whose ref.	 */> /*	 count is 62.Then, this function may make the new entry in the   */> /*	 Big Count Table "HTbigcount".The entry of big count may have    */> /*	 2 words reference count field and Lisp Address to the Lisp	 */> /*	 object.							 */> /*	gc_modify_bigrefcnt(entry,casep,ptr)				 */> /*	 			LispPTR entry, ptr; DLword casep	 */> /*	 This function may modify the reference count of entry on the    */> /*	 big count table						 */> /*                                                                       */> /*************************************************************************/> /*                                                               \Tomtom */> /*************************************************************************/> 12a95,103> #ifdef CHECK> #include "array.h"> #endif> > > #define MAXSMALLP		65535> #define HTBIGENTRYSIZE		4> #define WORDSPERPAGE		256> #define MAXTYPENUMBER		INIT_TYPENUM13a105,111> #define GetSegnuminColl(entry1) ((entry1 & 0x01fe) >> 1)> #define GetCountinColl(entry1)  ((entry1 & 0x0fc00) >> 10)> #define GetStkCnt(entry1)		 ((entry1 & 0x0fe00) >> 9)> #define Oddp(num) (((num % 2) != 0)?1:0)> #define Evenp(num,prim) (((num % prim) == 0)?1:0)> #define HTCOLLMAX  		HTCOLL_SIZE-2	/* 65534 in Lisp original */> #define HTCOLLTHRESHOLD		(HTCOLL_SIZE/2)	/* 65528 in Lisp original */15c113,122< /* These two functions  (freelink and dellink) are used by the (currently unused) code for  all of reclaim in C */---> /* int ReclaimCountDown, ReclaimMin; */ > 	  /* The global Variables for triggering the reclaim process */> /* int GcDisabled; */> 	  /* This is the flag that indicates GC status. */> int GetLinkRecursion = NIL;> #ifdef NEWGC> #define RECURSIVEGCOK (GetLinkRecursion == NIL)> #else> #define RECURSIVEGCOK NIL> #endif16a124,153> DLword *getlink()>     { struct htcoll *htcollents;> 	DLword tmpvar;> 	DLword *retvar;> >       htcollents = (struct htcoll *)HTcoll;>       if ((tmpvar = htcollents->free_ptr) == 0)> 		{ if ((tmpvar = htcollents->next_free) >= HTCOLLTHRESHOLD)> 			{if (RECURSIVEGCOK)>  				{GetLinkRecursion = T;>  				 doreclaim();>  			 	 GetLinkRecursion = NIL;>  			 	 return(NIL);}>  			 else>  			   if (tmpvar >= HTCOLLMAX)>  			     disablegc1(NIL);>  			 };> 		   htcollents->next_free = tmpvar+2;> 		   return((DLword *)Addr68k_from_LADDR(> 			LADDR_from_68k(HTcoll)+tmpvar));> 		}> 	 else> 	   { retvar = (DLword *)Addr68k_from_LADDR(LADDR_from_68k(HTcoll)> 						+tmpvar); > 				/* offset opera */> 		htcollents->free_ptr = *(retvar+1);> 		return(retvar);> 	   }> 	}	> 28d164< 49c185< 	if (( lentry->next_free) == 0)---> 	if (lentry->next_free == 0)56,60c192,195< #define Evenp(num,prim) ((num % prim) == 0)< #define HTCOLLMAX  		HTCOLL_SIZE-16< < /* getlink gets a new entry from the GC collision table */< DLword *getlink()---> modentry(entry, casep, ptr)> 	LispPTR         entry;> 	DLword          casep;> 	LispPTR         ptr;62,66c197,222< 	register DLword linkoff;< 	linkoff = *(HTcoll);< 	if (linkoff == 0) {< 		if ((linkoff = *(HTcoll + 1)) >= HTCOLLMAX) {< 			disablegc1(NIL);---> 	register DLword gccnt;> 	register struct hashentry *rentry;> 	rentry = (struct hashentry *) Addr68k_from_LADDR(entry);> 	gccnt = rentry->count;> 	if (gccnt == MAX_GCCOUNT)> 		return gc_modify_bigrefcnt(entry, casep, ptr);> 	switch (casep) {> 	case ADDREF:> 		if (gccnt == (MAX_GCCOUNT - 1))> 			gc_enter_bigrefcnt(ptr, entry);> 		else> 			++(rentry->count);> 		break;> 	case DELREF:> #ifdef CHECK> 		if (gccnt == 0)> 			error("attempt to decrement 0 reference count");> #endif> 		--(rentry->count);> 		break;> 	case STKREF:> 		rentry->stackref = 1;> 		break;> 	case UNSTKREF:> 		rentry->stackref = 0;> 		break;68,69c224< 		*(HTcoll + 1) = linkoff + 2;< 		return HTcoll + linkoff;---> 	return ((rentry->count == 1) && (rentry->stackref == 0));71,73d225< 	*(HTcoll) = *(HTcoll + linkoff + 1);< 	return HTcoll + linkoff;< }75,109c227,250< < #define HTCNTSHIFT 10	/* amount to shift to get hash table count */< #define HTCNTMASK 0xFC00 /* mask which masks off hash table count */< #define HTCNTSTKMASK 0XFE00 /* mask for hash table count + stack bit */< #define HTSTKMASK 0x0200 /* mask for stack bit only */< #define HTHIMASK 0x1FE	/* mask of bits which contain high part of pointer < 			in hash table */< #define HTHISHIFT 1  /* high bits in hash table are shifted left 1 */< < < /*  NewEntry is a macro for adding a new gc hash table entry;< 	entry is pointer to hash table entry< 	hiptr is the high point of the ref-cnted entry, shifted < 	casep is one of ADDREF, DELREF, etc. < */< < #define NewEntry(entry, hiptr, casep, ptr) {				     \< switch (casep) {							     \< 	case ADDREF:							     \< 		*(entry) = hiptr | (2 << HTCNTSHIFT);	/* set count = 2 */  \< 		return NIL;				/* not new 0 entry */\< 	case DELREF:							     \< 		*(entry) = hiptr; 			/* set count = 0 */  \< 		return ptr; 				/* new 0 entry */    \< 	case STKREF:  /* set refcnt to 1, stack bit to 1 */		     \< 		*(entry) = hiptr | (1<<HTCNTSHIFT) | HTSTKMASK;		     \< 		return NIL;						     \< 	default:							     \< 		error("GC error: new entry when turning off stack bit");     \< 	}}< < #define FreeLink(link) {\< 	*(link) = 0;\< 	*(link+1) = *HTcoll;\< 	*HTcoll = (link - HTcoll);\---> newentry(entry,ptr,casep) /* !this func. may be applied to HTmain&HTcoll! */> LispPTR		  entry;> LispPTR		  ptr;> DLword		  casep;>    { struct hashentry *rentry;> 	rentry = (struct hashentry *)Addr68k_from_LADDR(entry);> #ifdef CHECK> 	if ((rentry->count != 0) || (rentry->stackref != 0)) error("new non-zero entry");> #endif> 	rentry->segnum = HILOC(ptr);> 	switch(casep)> 		{ case ADDREF:> 			{rentry->count = 2;> 			 break;}> 		  case DELREF:> 			{return(ptr);> 			 break;}> 		  case STKREF:> 			{rentry->count = rentry->stackref = 1;> 			 break;}> 		  default: error("ERROR : invalid case on newentry. \n"); > 				/* currently no implimented */> 		};> 	return(NIL);112,118d252< /* ModEntry is a macro to modify an  old  gc hash table entry. < 	entry is a pointer to the entry< 	contents holds the old contents< 	ptr is the pointer being counted< 	casep is one of ADDREF, DELREF, etc.< 	remove is a label to go to if the entry will< 	go away 120,150d253< 	It always return NIL, since cannot be creating a zero-count,< 	 no-stack-bit entry */< #define ModEntry(entry, contents, ptr, casep, remove) { \< 	if (contents >= HTCNTMASK) { /* overflow; return non-zero */ \< 		modify_big_reference_count(entry, casep, ptr);\< 		return NIL;}\< 	switch (casep) {\< 	case ADDREF:\< 		contents += (1 << HTCNTSHIFT);\< 		if (contents >= HTCNTMASK ) {\< 			/* overflow */\< 			*entry = contents; \< 			enter_big_reference_count(ptr);\< 			return NIL;\< 			}\< 		break; /* check for possibly deleting entry */\< 	case DELREF:\< 		if ( (contents -= (1 << HTCNTSHIFT)) < 0) \< 			error("attempt to decrement 0 reference count");\< 		break;\< 	case STKREF:\< 		*entry = contents | HTSTKMASK;\< 		return NIL;\< 	case UNSTKREF:\< 		contents = contents & ~ HTSTKMASK;\< 		break; /* check for possibly deleting entry */\< 	}\< 	if ((contents & HTCNTSTKMASK) == (1 << HTCNTSHIFT)) goto remove;\< 	*entry = contents;\< 	return NIL;\< }152,155c255,256< /* add a new overflow entry for counts > 62 */< < void enter_big_reference_count(ptr)< LispPTR			ptr;---> gc_enter_bigrefcnt(ptr,entry)> LispPTR			ptr,entry;156a258>      struct hashentry	*entry68;159,163d260< 	/* this kludge is apparently necessary. Odd pointers are < 	illegal, but apparently some are reference counted. If you< 	get an odd pointer, just ignore the low bit */< < 	if(ptr&1) ptr &= 0xfffffffe;164a262,268> 	entry68 = (struct hashentry *)Addr68k_from_LADDR(entry);> 	if (Oddp(LOLOC(ptr)))> #ifdef CHECK> 		error("odd pointer in refcnt");> #else> 		--ptr;> #endif172c276< 			  return;---> 			  return(NIL);186c290,292< 	return;---> 	entry68->count      = MAX_GCCOUNT;> > 	return(MAX_GCCOUNT);189,191c295< /* modify an old overflow entry */< < void modify_big_reference_count(entry, casep, ptr)---> gc_modify_bigrefcnt(entry,casep,ptr)193,196c297,299< 	DLword         *entry;< 	LispPTR         ptr;< {< 	struct gc_ovfl *oventry;---> LispPTR			entry,ptr;>    { struct gc_ovfl 	*oventry;>      struct hashentry	*entry68;199,201d301< < 	/* ditto comment in entry_big_reference_count */< 	if (ptr & 1) ptr &= 0xfffffffe;202a303,310> 	entry68 = (struct hashentry *)Addr68k_from_LADDR(entry);> 	if (Oddp(LOLOC(ptr)))	/* address adjustment */> #ifdef CHECK> 	error("odd pointer in reference count");> #else> 		--ptr;> #endif> 204c312,313< 		if (tmp == NIL) {---> 	   if (tmp == NIL)> 		    { /*  gc_bigrefcnt_missing(ptr,entry);  */206,212c315,320< 			      "refcnt previously overflowed, but not found in table.\n");< 			return;< 		} else< 			++oventry;	/* increment by size of oventry< 					 * structure */< 	switch (casep) {< 	case ADDREF:---> 	"ERROR : PTR refcnt previously overflowed, but not found in table.\n");> 			 return(NIL);> 		     }> 	    else ++oventry; /* increment by size of oventry structure */> 	switch(casep)> 	   { case ADDREF:214c322< 		return;---> 			return NIL;218c326,330< 			((struct hashentry *) entry)->count = MAX_GCCOUNT - 1;---> #ifdef CHECK> 				if (oventry->ovfl_cnt != MAX_GCCOUNT-1)> 					error("overflow table bogus entry");> #endif> 				entry68->count = MAX_GCCOUNT-1;221c333,334< 		return;---> 			return NIL;> 223,224c336,337< 		((struct hashentry *) entry)->stackref = 1;< 		return;---> 			{entry68->stackref = 1;> 			 return NIL;}226,228c339,340< 		((struct hashentry *) entry)->stackref = 0;< 		return;< ---> 			{entry68->stackref = 0;> 			 return NIL;}234,248d345< < /* htfind is the main entry for reference manipulation.<   It modifies the reference count of the Lisp pointer ptr. < <    casep is one of ADDREF, DELREF, STKREF< < 	ADDREF = add 1< 	DELREF = subtract 1< 	STKREF = turn on stack bit< 	UNSTKREF = turn off stack bit< <    returns NIL if DELREF and the entry became< 	refcount = 0, stk bit off (only can happen on a *new* DELREF)< 	in which case it returns PTR */< 251,288c348,384< 	int             casep;< {< 	register DLword *entry, *link, *prev;< 	register DLword entry_contents, hiptr;< 	register struct htlinkptr *htlptr;< < 	/* if the NOREF bit is on in the type table entry, do< 	not reference count this pointer. Used for non-reference< 	counted types like symbols, and also when the GC is< 	disabled. */< < 	if (GetTypeEntry(ptr) & TT_NOREF)< 		return NIL;< < 	/* GC hash table entries have the high 8 bits of the< 	pointer stored in the middle. Set up hiptr to have< 	the high bits of the pointer ready to store or test< 	against */< < 	hiptr = (((unsigned int)ptr) >> (16-HTHISHIFT) ) & HTHIMASK;< < 	/* entry points at the place in the main hash table< 	where this pointer is stored. The 'hash' isn't one really;< 	it just uses the low bits of the pointer. */< < 	entry = HTmain + (LOLOC(ptr) >> 1);< < 	entry_contents = *entry;< < 	if (entry_contents == 0)< 		NewEntry(entry, hiptr, casep, ptr); < 		/* NewEntry returns */< < 	if (entry_contents & 1) {	/* low bit means a collision entry */< 		/* entry_contents-1 removes low bit */< 		link = HTcoll + (entry_contents - 1);< 		prev = 0;< 		goto newlink;---> DLword	casep;>    {	LispPTR				probe;> 	register struct hashentry 	*entry;> 	register struct htlinkptr	*htlptr;/* overlay access method */> 	register struct htcoll		*link,*prev;> 	DLword			offset;> 	LispPTR			lpentry,lplink,lpprev;> 	lpprev = NIL;> 	if (((int)GetTypeEntry(ptr) & TT_NOREF) != 0)> 						/* MDS's NOREF checking */> 		return(NIL);> 	else if (*GcDisabled_word == ATOM_T) {> #ifdef CHECK> 		error("\GCDISABLED but htfind reached");> #endif> 		return NIL;}> #ifdef CHECK> 	if((GetTypeNumber(ptr) == 0) && (casep != STKREF) && (casep != UNSTKREF))> 		 checkarrayblock(ptr-ARRAYBLOCKHEADERWORDS, NIL, NIL);> #endif> 	entry = (struct hashentry *)Addr68k_from_LADDR(> 		LADDR_from_68k(HTmain) + (LOLOC(ptr) >> 1));> 							/* hashing entry */> 	htlptr = (struct htlinkptr *)entry;	/* entry's whole contents */> 	lpentry = LADDR_from_68k(entry);> 	if (htlptr->contents == 0)		/* this entry is new entry */> 		return(newentry(lpentry,ptr,casep));> 	else if (entry->collision)> 		{ 		/* scanning and finding the HTCOLL table */> 		  lplink = LADDR_from_68k(HTcoll)+GetLinkptr(htlptr->contents);> 						/* offset opera */> 		  link = (struct htcoll *)Addr68k_from_LADDR(lplink);> 		  while((offset = link->next_free) != 0)> 		   {if (HILOC(ptr) == GetSegnuminColl(link->free_ptr))> 			  if (modentry(lplink, casep, ptr) != NIL)> 				{ dellink(lplink, lpprev, lpentry);> 				  return(NIL);290,293c386,397< < 	if (hiptr == (entry_contents & HTHIMASK)) {< 		ModEntry(entry, entry_contents, ptr, casep, delentry);< 		/* ModEntry returns or will go to delentry */---> 			  else if (GetStkCnt(link->free_ptr) == 0)> 				{ return(ptr);}> 			  else return(NIL);> 		    prev = link;> 		    lpprev = lplink;> 		    lplink = LADDR_from_68k(HTcoll) + offset;> 		    link = (struct htcoll *)Addr68k_from_LADDR(lplink);> 		   };> 		  if (HILOC(ptr) == GetSegnuminColl(link->free_ptr))> 			  if (modentry(lplink, casep, ptr) != NIL)> 				{ dellink(lplink, lpprev, lpentry);> 				  return(NIL);295,318c399,409< < 	/* new collision */< < 	link = getlink();< 	prev = getlink();< 	*(prev + 1) = 0;< 	*(prev) = entry_contents;< 	*(link + 1) = prev - HTcoll;< 	*(entry) = link - HTcoll + 1;< < 	NewEntry(link, hiptr, casep, ptr);< < < delentry: *(entry) = 0;< 	return NIL;< < /* start here when a collision is detected. link is a pointer to<   the entry in the collision table, prev is the previous collision<   entry or 0 if this is the first one. */< < newlink:entry_contents = *link;< 	if (hiptr == (entry_contents & HTHIMASK) ) {< 		ModEntry(link, entry_contents, ptr, casep, dellink);< 		/* ModEntry returns or goes to dellink */---> 			  else if (GetStkCnt(link->free_ptr) == 0)> 				{ return(ptr);}> 			  else return(NIL);> 		  prev = link;> 		  lpprev = lplink;>   		  link = (struct htcoll *)getlink();>   		  if (link == NIL)>  		    {GetLinkRecursion = T;>  		     probe = GCLOOKUPV(0x8000,casep,ptr);>  		     GetLinkRecursion = NIL;>  		     return(probe);320,323c411,416< 	/* collision didn't match  */< 	entry_contents = *(link + 1);< 	if (entry_contents == 0) {< 		goto nolink;--->   		  else>  		    {lplink = LADDR_from_68k(link);>  		     link->next_free = 0;>  		     prev->next_free = LOLOC(lplink);	/* offset opera */>  		     return(newentry(lplink, ptr, casep));>  		    };325,331c418,438< 	/* try the next link in the collision table */< 	prev = link;< 	link = HTcoll + entry_contents;< 	goto newlink;< < dellink:if (prev)< 		*(prev + 1) = *(link + 1);---> 	else if (HILOC(ptr) == entry->segnum)> 				/* already existing */> 		{if (modentry(lpentry, casep, ptr) != NIL) > 			/* case : refcnt is 1 */> 			{ htlptr->contents = 0; > 			  return(NIL);> 			}> 		 else if ((entry->count == 0) && > 				(entry->stackref == 0))> 			/* case : garbage is born */> 				 return(ptr);> 		      else return(NIL);> 		 }> 	else /*	making the new collision entry */> 	    {	link = (struct htcoll *)getlink(); >  	    	if (link == NIL)>  		  {GetLinkRecursion = T;>  		   probe = GCLOOKUPV(0x8000,casep,ptr);>  		   GetLinkRecursion = NIL;>  	    	   return(probe);>  		 }333,338c440,446< 		*(entry) = (*(link + 1)) | 1;< 	FreeLink(link);< 	link = HTcoll + (*entry) - 1;< 	if (*(link + 1) == 0) {< 		*(entry) = *(link);< 		FreeLink(link);---> 		{lplink = LADDR_from_68k(link);> 		prev = (struct htcoll *)getlink(); >  		 if (prev == NIL)>  		   {GetLinkRecursion = T;>  		    probe = GCLOOKUPV(0x8000,casep,ptr);>  		    GetLinkRecursion = NIL;>  		    return(probe);340c448,461< 	return NIL;--->  		 else> 			{lpprev = LADDR_from_68k(prev);> 			prev->next_free = LOLOC(lplink);> 			prev->free_ptr  = htlptr->contents;> 			htlptr->contents   => 		 	  (DLword)(LOLOC(lpprev) | 0x01);> 			link->next_free = 0;> 			link->free_ptr  = 0;> 			return(newentry(lplink, ptr, casep));> 		/* !!newentry's first arg must be struct hashentry!! */> 			};> 		};> 	   }>    }342d462< nolink:			/* no match */344,347d463< 	link = getlink();< 	*(link + 1) = *(entry) - 1;< 	*(entry) = (link - HTcoll) + 1;< 	NewEntry(link, hiptr, casep, ptr);350d465< }Binary files /users/maiko/stable/src/gchtfind.o and /users/maiko/final3.4/src/gchtfind.o differFiles /users/maiko/stable/src/gcmain3.c and /users/maiko/final3.4/src/gcmain3.c are identicalBinary files /users/maiko/stable/src/gcmain3.o and /users/maiko/final3.4/src/gcmain3.o differdiff -w -r -s /users/maiko/stable/src/gcreclaim.c /users/maiko/final3.4/src/gcreclaim.c1,2c1,2< /* This is G-file @(#) gcreclaim.c Version 2.3 (7/31/88). copyright Xerox & Fuji Xerox  */< static char *id = "@(#) gcreclaim.c	2.3 7/31/88";---> /* This is G-file @(#) gcreclaim.c Version 2.2 (5/31/88). copyright Xerox & Fuji Xerox  */> static char *id = "@(#) gcreclaim.c	2.2 5/31/88";70a71,72>  extern int GetLinkRecursion;>   118a121>  	 GetLinkRecursion = T;119a123>  	 GetLinkRecursion = NIL;Binary files /users/maiko/stable/src/gcreclaim.o and /users/maiko/final3.4/src/gcreclaim.o differFiles /users/maiko/stable/src/gcreclaimcell.c and /users/maiko/final3.4/src/gcreclaimcell.c are identicalBinary files /users/maiko/stable/src/gcreclaimcell.o and /users/maiko/final3.4/src/gcreclaimcell.o differFiles /users/maiko/stable/src/gcreclaimcodeblock.c and /users/maiko/final3.4/src/gcreclaimcodeblock.c are identicalFiles /users/maiko/stable/src/gcreclaimcodeblock.o and /users/maiko/final3.4/src/gcreclaimcodeblock.o are identicalFiles /users/maiko/stable/src/gcscan.c and /users/maiko/final3.4/src/gcscan.c are identicalFiles /users/maiko/stable/src/gcscan.o and /users/maiko/final3.4/src/gcscan.o are identicalFiles /users/maiko/stable/src/gvar2.c and /users/maiko/final3.4/src/gvar2.c are identicalBinary files /users/maiko/stable/src/gvar2.o and /users/maiko/final3.4/src/gvar2.o differFiles /users/maiko/stable/src/hardreturn.c and /users/maiko/final3.4/src/hardreturn.c are identicalFiles /users/maiko/stable/src/hardreturn.o and /users/maiko/final3.4/src/hardreturn.o are identicalFiles /users/maiko/stable/src/initdisplay.c and /users/maiko/final3.4/src/initdisplay.c are identicalFiles /users/maiko/stable/src/initdisplay.o and /users/maiko/final3.4/src/initdisplay.o are identicaldiff -w -r -s /users/maiko/stable/src/initkeyboard.c /users/maiko/final3.4/src/initkeyboard.c1,2c1,2< /* This is G-file @(#) initkeyboard.c Version 2.5 (7/6/88). copyright Xerox & Fuji Xerox  */< static char *id = "@(#) initkeyboard.c	2.5 7/6/88";---> /* This is G-file @(#) initkeyboard.c Version 2.6 (9/14/88). copyright Xerox & Fuji Xerox  */> static char *id = "@(#) initkeyboard.c	2.6 9/14/88";78c78< /*104*/   39,  54,  55,  27,  42,  12,  60,  14,   ---> /*104*/   39,  54,  55,  27,  42,  12,  60,  71,   Binary files /users/maiko/stable/src/initkeyboard.o and /users/maiko/final3.4/src/initkeyboard.o differFiles /users/maiko/stable/src/initsysout.c and /users/maiko/final3.4/src/initsysout.c are identicalFiles /users/maiko/stable/src/initsysout.o and /users/maiko/final3.4/src/initsysout.o are identicalFiles /users/maiko/stable/src/interruptcall.c and /users/maiko/final3.4/src/interruptcall.c are identicalFiles /users/maiko/stable/src/interruptcall.o and /users/maiko/final3.4/src/interruptcall.o are identicalFiles /users/maiko/stable/src/keyboardsubrs.c and /users/maiko/final3.4/src/keyboardsubrs.c are identicalFiles /users/maiko/stable/src/keyboardsubrs.o and /users/maiko/final3.4/src/keyboardsubrs.o are identicaldiff -w -r -s /users/maiko/stable/src/keyevent.c /users/maiko/final3.4/src/keyevent.c1,2c1,2< /* This is G-file @(#) keyevent.c Version 2.8 (7/21/88). copyright Xerox & Fuji Xerox  */< static char *id = "@(#) keyevent.c	2.8 7/21/88";---> /* This is G-file @(#) keyevent.c Version 2.9 (9/14/88). copyright Xerox & Fuji Xerox  */> static char *id = "@(#) keyevent.c	2.9 9/14/88";261c261,263< 			return(0);---> 			((RING*)CTopKeyevent)->read=0;  /* reset queue */> 			((RING*)CTopKeyevent)->write=MINKEYEVENT; > 			/*return(0);*/267c269,272< 			return(0);---> 			((RING*)CTopKeyevent)->read=0;  /* reset queue */> 			((RING*)CTopKeyevent)->write=MINKEYEVENT; > > 			/*return(0);*/Binary files /users/maiko/stable/src/keyevent.o and /users/maiko/final3.4/src/keyevent.o differFiles /users/maiko/stable/src/keylib.c and /users/maiko/final3.4/src/keylib.c are identicalFiles /users/maiko/stable/src/keylib.o and /users/maiko/final3.4/src/keylib.o are identicalFiles /users/maiko/stable/src/keymaker.c and /users/maiko/final3.4/src/keymaker.c are identicalFiles /users/maiko/stable/src/keytester.c and /users/maiko/final3.4/src/keytester.c are identicalFiles /users/maiko/stable/src/keytestno.c and /users/maiko/final3.4/src/keytestno.c are identicalFiles /users/maiko/stable/src/keytestno.o and /users/maiko/final3.4/src/keytestno.o are identicalFiles /users/maiko/stable/src/ldeether.c and /users/maiko/final3.4/src/ldeether.c are identicalFiles /users/maiko/stable/src/listhandle.c and /users/maiko/final3.4/src/listhandle.c are identicalBinary files /users/maiko/stable/src/listhandle.o and /users/maiko/final3.4/src/listhandle.o differFiles /users/maiko/stable/src/llstk.c and /users/maiko/final3.4/src/llstk.c are identicalFiles /users/maiko/stable/src/llstk.o and /users/maiko/final3.4/src/llstk.o are identicalFiles /users/maiko/stable/src/loader.c and /users/maiko/final3.4/src/loader.c are identicalBinary files /users/maiko/stable/src/loader.o and /users/maiko/final3.4/src/loader.o differFiles /users/maiko/stable/src/loadsysout.c and /users/maiko/final3.4/src/loadsysout.c are identicalFiles /users/maiko/stable/src/loadsysout.o and /users/maiko/final3.4/src/loadsysout.o are identicalFiles /users/maiko/stable/src/lowlevel1.c and /users/maiko/final3.4/src/lowlevel1.c are identicalFiles /users/maiko/stable/src/lowlevel1.o and /users/maiko/final3.4/src/lowlevel1.o are identicalFiles /users/maiko/stable/src/lowlevel2.c and /users/maiko/final3.4/src/lowlevel2.c are identicalBinary files /users/maiko/stable/src/lowlevel2.o and /users/maiko/final3.4/src/lowlevel2.o differFiles /users/maiko/stable/src/makevdate.c and /users/maiko/final3.4/src/makevdate.c are identicalFiles /users/maiko/stable/src/newmakeatom.c and /users/maiko/final3.4/src/newmakeatom.c are identicalFiles /users/maiko/stable/src/newmakeatom.o and /users/maiko/final3.4/src/newmakeatom.o are identicalFiles /users/maiko/stable/src/osmessage.c and /users/maiko/final3.4/src/osmessage.c are identicalFiles /users/maiko/stable/src/osmessage.o and /users/maiko/final3.4/src/osmessage.o are identicalFiles /users/maiko/stable/src/return.c and /users/maiko/final3.4/src/return.c are identicalFiles /users/maiko/stable/src/return.o and /users/maiko/final3.4/src/return.o are identicalFiles /users/maiko/stable/src/rpc.c and /users/maiko/final3.4/src/rpc.c are identicalBinary files /users/maiko/stable/src/rpc.o and /users/maiko/final3.4/src/rpc.o differFiles /users/maiko/stable/src/rplcons.c and /users/maiko/final3.4/src/rplcons.c are identicalBinary files /users/maiko/stable/src/rplcons.o and /users/maiko/final3.4/src/rplcons.o differFiles /users/maiko/stable/src/rs232c.c and /users/maiko/final3.4/src/rs232c.c are identicalFiles /users/maiko/stable/src/rs232c.o and /users/maiko/final3.4/src/rs232c.o are identicalFiles /users/maiko/stable/src/shift.c and /users/maiko/final3.4/src/shift.c are identicalBinary files /users/maiko/stable/src/shift.o and /users/maiko/final3.4/src/shift.o differFiles /users/maiko/stable/src/storage.c and /users/maiko/final3.4/src/storage.c are identicalBinary files /users/maiko/stable/src/storage.o and /users/maiko/final3.4/src/storage.o differdiff -w -r -s /users/maiko/stable/src/subr.c /users/maiko/final3.4/src/subr.c1,2c1,2< /* This is G-file @(#) subr.c Version 2.24 (8/9/88). copyright Xerox & Fuji Xerox  */< static char *id = "@(#) subr.c	2.24 8/9/88";---> /* This is G-file @(#) subr.c Version 2.25 (9/15/88). copyright Xerox & Fuji Xerox  */> static char *id = "@(#) subr.c	2.25 9/15/88";216c216< 	case 0207 :  CurrentStackPTR -= 6;---> 	case sb_NEW_BLTCHAR :  CurrentStackPTR -= 6;439c439,445< --->       case sb_USER_SUBR: POP_SUBR_ARGS;> 			{register LispPTR user_subr, user_args;> 			 N_GETNUMBER(args[0], user_subr, ret_nil);> 			 N_GETNUMBER(args[1], user_args, ret_nil);> 			 TopOfStack = UserSubr(user_subr, user_args, &args[2]);> 			}> 			break;Binary files /users/maiko/stable/src/subr.o and /users/maiko/final3.4/src/subr.o differFiles /users/maiko/stable/src/subr0374.c and /users/maiko/final3.4/src/subr0374.c are identicalFiles /users/maiko/stable/src/subr0374.o and /users/maiko/final3.4/src/subr0374.o are identicalFiles /users/maiko/stable/src/systemcallmessage.c and /users/maiko/final3.4/src/systemcallmessage.c are identicalFiles /users/maiko/stable/src/systemcallmessage.o and /users/maiko/final3.4/src/systemcallmessage.o are identicalFiles /users/maiko/stable/src/timeofday.c and /users/maiko/final3.4/src/timeofday.c are identicalFiles /users/maiko/stable/src/timer.c and /users/maiko/final3.4/src/timer.c are identicalFiles /users/maiko/stable/src/timer.o and /users/maiko/final3.4/src/timer.o are identicalFiles /users/maiko/stable/src/tty.c and /users/maiko/final3.4/src/tty.c are identicalFiles /users/maiko/stable/src/tty.o and /users/maiko/final3.4/src/tty.o are identicalFiles /users/maiko/stable/src/typeof.c and /users/maiko/final3.4/src/typeof.c are identicalBinary files /users/maiko/stable/src/typeof.o and /users/maiko/final3.4/src/typeof.o differFiles /users/maiko/stable/src/ubf1.c and /users/maiko/final3.4/src/ubf1.c are identicalBinary files /users/maiko/stable/src/ubf1.o and /users/maiko/final3.4/src/ubf1.o differFiles /users/maiko/stable/src/ubf2.c and /users/maiko/final3.4/src/ubf2.c are identicalFiles /users/maiko/stable/src/ubf2.o and /users/maiko/final3.4/src/ubf2.o are identicalFiles /users/maiko/stable/src/ubf3.c and /users/maiko/final3.4/src/ubf3.c are identicalFiles /users/maiko/stable/src/ubf3.o and /users/maiko/final3.4/src/ubf3.o are identicalFiles /users/maiko/stable/src/ufn.c and /users/maiko/final3.4/src/ufn.c are identicalFiles /users/maiko/stable/src/ufn.o and /users/maiko/final3.4/src/ufn.o are identicalFiles /users/maiko/stable/src/ufs.c and /users/maiko/final3.4/src/ufs.c are identicalFiles /users/maiko/stable/src/ufs.o and /users/maiko/final3.4/src/ufs.o are identicalFiles /users/maiko/stable/src/unix-utils.c and /users/maiko/final3.4/src/unix-utils.c are identicalBinary files /users/maiko/stable/src/unix-utils.o and /users/maiko/final3.4/src/unix-utils.o differFiles /users/maiko/stable/src/unixcomm.c and /users/maiko/final3.4/src/unixcomm.c are identicalBinary files /users/maiko/stable/src/unixcomm.o and /users/maiko/final3.4/src/unixcomm.o differFiles /users/maiko/stable/src/unwind.c and /users/maiko/final3.4/src/unwind.c are identicalFiles /users/maiko/stable/src/unwind.o and /users/maiko/final3.4/src/unwind.o are identicaldiff -w -r -s /users/maiko/stable/src/uraid.c /users/maiko/final3.4/src/uraid.c1,2c1,2< /* This is G-file @(#) uraid.c Version 1.19 (8/18/88). copyright Xerox & Fuji Xerox  */< static char *id = "@(#) uraid.c	1.19 8/18/88";---> /* This is G-file @(#) uraid.c Version 1.21 (9/19/88). copyright Xerox & Fuji Xerox  */> static char *id = "@(#) uraid.c	1.21 9/19/88";55c55< @ litatom val           Sets TOPVAL of litatom to val---> @ litatom val           Sets TOPVAL of litatom to Decimal-val64a65> !			Prints the error message passed from the emulator96,97c97,98< @ litatom val\t\tSets TOPVAL of litatom to val\n\< < Xaddress val\t\tSets the word(16-bits) at the address to val\n\---> @ litatom val\t\tSets TOPVAL of litatom to Decimal-val\n\> < Xaddress val\t\tSets the word(16-bits) at the address to Xval\n\104a106> !\t\t\tPrints the error message passed from the emulator\n\106c108< ---> /****OBSOLATE110a113> *****/114c117< 					printf("Address exceeded.\n"); \---> 					printf("Address out of range.\n"); \181c184< if((packagelen == 0) || (compare_chars(packageptr, "IL",packagelen ) == T)) ---> if((packagelen == 0) || (strncmp(packageptr, "IL",packagelen ) == 0)) 207c210,212< { register int i;---> { > /****OBSOLATE > register int i;213a219,222> ******/>   bzero(URaid_inputstring,URMAXCOMM);>   bzero(URaid_arg1,URMAXCOMM/2);>   bzero(URaid_arg2,URMAXCOMM/2);241c250< 	  printf("There is no more Stack.\n");---> 	  printf("There is no more stack.\n");251a261> 257c267< 	case 'f' :	if((URaid_arg1[0] < '0') || (URaid_arg1[0] > '9')){---> 	case 'f' :	/**if((URaid_arg1[0] < '0') || (URaid_arg1[0] > '9')){259a270,274> 			}**/> 			if(URaid_argnum==1) /* f comm only */> 			{> 			  printf("DUMP-STACK: f decmal-FXnumber\n");> 			  return(T);261c276,280< 			sscanf(URaid_arg1,"%d",&num);---> 			if( sscanf(URaid_arg1,"%d",&num) <= 0)> 			{ /* com read fails */> 			  printf("Illegal argument, not decimal number\n");> 			  return(T);> 			}264c283< 			  printf("Such Frame doesn't exist.\n");---> 			  printf("Such frame doesn't exist.\n");310a330,331> 				{> 					printf("GETTOPVAL: a litatom\n");311a333> 				}375c397,406< 					sscanf(URaid_arg1,"%x",&objaddr);---> 					if(URaid_argnum ==1)> 					{> 						printf("PRINT-INSTANCE: O HEX-LispAddress\n");> 						return(T);> 					}> 					if(sscanf(URaid_arg1,"%x",&objaddr)> 						<=0) {> 						printf("Arg not HEX number\n");> 						return(T);> 					}381c412< 					printf("PRINTTYPENAME: t xaddress\n");---> 					printf("PRINTTYPENAME: t Xaddress\n");385,386c416,421< 				HEXNUMP(URaid_arg1,"Not Address");< 				sscanf(URaid_arg1,"%x",&address);---> 				/**HEXNUMP(URaid_arg1,"Not Address");**/> 				if(sscanf(URaid_arg1,"%x",&address)<=0)> 				{> 					printf("Arg not HEX number\n");> 					return(T);> 				}444c479,480< 	case 'x' :	  /* HEX dump */---> 	case 'x' :	  /* HEX dump "x Xaddress Xnum" */> 				/* Obsolate 447,451c483,510< < 				sscanf(URaid_arg1,"%x",&address);< 				if(sscanf(URaid_arg2,"%x",&num)==-1)< 				 num = 8;< ---> 				***/> 				if(URaid_argnum==1)> 				{ /* for help */> 				  printf("HEX-DUMP: x Xaddress [Xnum]\n");> 				  return(T);> 				}> 				if(sscanf(URaid_arg1,"%x",&address)<=0)> 				{ /* arg1 not HEX */> 				  printf("Arg(Xaddress) not Xaddress\n");> 				  return(T);> 				}> 				switch(sscanf(URaid_arg2,"%x",&num))> 				{> 				  case -1 :  /* Use defaultval for word-num */> 				 	    num = XDUMPW;> 					    break;> 				  case 0  : /* Illegal number */> 					    printf("Arg(Xnum) not Xnum\n");> 					    return(T);> 					    break;> 				  default : break;> 				}> 				if(num < 0)> 				{> 				  printf("Dump words num should be positive\n");> 				  return(T);> 				}> 				/* Address range check */452a512> 				ADD_RANGEP(address+num);461c521< 						printf("%x : ",LADDR_from_68k(ptr));---> 						printf("0x%x : ",LADDR_from_68k(ptr));474c534< 					printf("SETTOPVAL: @ litatom val\n");---> 					printf("SETTOPVAL: @ litatom Decimal-val\n");482,483c542,543< 				if (compare_chars(URaid_arg2, "NIL", 3) == T)< 					val=NIL;---> 				if (strncmp(URaid_arg2, "NIL",3 ) == 0)> 					{val=NIL;}516a577> 				/* OBSOLATE518a580> 				***/520,521c582,591< 				sscanf(URaid_arg1,"%x",&address);< 				sscanf(URaid_arg2,"%x",&val);---> 				if(sscanf(URaid_arg1,"%x",&address) <=0)> 				{> 				  printf("Arg(Xaddress) not Xaddress\n");> 				  return(T);> 				}> 				if(sscanf(URaid_arg2,"%x",&val) <=0)> 				{> 				  printf("Arg(Xval) not Xaddress\n");> 				  return(T);> 				}525c595< 					printf("VAL invalid.\n");---> 					printf("Xval invalid (16 bit range exceeded).\n");580c650,654< 	case 'v' :		pr_rop(ScreenBitMap,0,0,DisplayWidth,---> 	case 'v' :		if(URaid_argnum != 2){> 					printf("VMEMSAVE: v filename (it's NOT bootable)\n");> 					return(T);> 				}> 				pr_rop(ScreenBitMap,0,0,DisplayWidth,593c667< 				  printf("VMEMSAVE finished,But it's not bootable\n");---> 				  printf("VMEMSAVE finished, but it's not bootable\n");599c673< 					printf("Illegal argument,Not number\n");---> 					printf("Illegal argument, not number\n");613c687< 	default :  printf("Not supported command.\n");---> 	default :  printf("Unsupported command.\n");Binary files /users/maiko/stable/src/uraid.o and /users/maiko/final3.4/src/uraid.o differdiff -w -r -s /users/maiko/stable/src/usersubrs.c /users/maiko/final3.4/src/usersubrs.c1,2c1,2< /* This is G-file @(#) usersubrs.c Version 1.1 (6/15/88). copyright Xerox & Fuji Xerox  */< static char *id = "@(#) usersubrs.c	1.1 6/15/88";---> /* This is G-file @(#) usersubrs.c Version 1.2 (9/15/88). copyright Xerox & Fuji Xerox  */> static char *id = "@(#) usersubrs.c	1.2 9/15/88";6d5< foo() {8a8,29> UserSubr(user_subr_index, num_args, args) > > int user_subr_index;> int num_args;> int args[28];> > {> int result = 0;> > 	printf("debug: case: 0x%x, args: 0x%x\n",user_subr_index, num_args);> 	{int i;> 	 for (i = 0; i < num_args; i++) printf("debug: arg[%d]: 0x%x\n",i,args[i]);> 	};> > 	switch (user_subr_index) {> > 		case 1:	 printf("case 1\n"); break;> 		default: printf("Unknown User Subr: 0x%x\n",user_subr_index);> 			 break;> 		}> > 	return(result);Only in /users/maiko/final3.4/src: usersubrs.oFiles /users/maiko/stable/src/vars3.c and /users/maiko/final3.4/src/vars3.c are identicalBinary files /users/maiko/stable/src/vars3.o and /users/maiko/final3.4/src/vars3.o differFiles /users/maiko/stable/src/vmemsave.c and /users/maiko/final3.4/src/vmemsave.c are identicalFiles /users/maiko/stable/src/vmemsave.o and /users/maiko/final3.4/src/vmemsave.o are identicaldiff -w -r -s /users/maiko/stable/src/xc.c /users/maiko/final3.4/src/xc.c1c1< /* This is G-file @(#) xc.c Version 2.21 (8/15/88). copyright Xerox & Fuji Xerox  */---> /* This is G-file @(#) xc.c Version 2.20 (7/27/88). copyright Xerox & Fuji Xerox  */610,614d609< #ifndef	NOASM< 	asm_label_check_interrupt();< #endif< < /* ************* I TOOK THIS CHECK OUT, IT SHOULD NOT BE NEEDED (BK)620d614< ************** */Binary files /users/maiko/stable/src/xc.o and /users/maiko/final3.4/src/xc.o differFiles /users/maiko/stable/src/z2.c and /users/maiko/final3.4/src/z2.c are identicalBinary files /users/maiko/stable/src/z2.o and /users/maiko/final3.4/src/z2.o differ