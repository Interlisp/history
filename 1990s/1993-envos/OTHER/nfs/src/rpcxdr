(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "RPC2")(IL:FILECREATED "17-Jul-90 20:59:45" IL:{DSK}<LISPFILES>ETHERNET>TCP>NFS>RPCXDR.\;2 42609        IL:|previous| IL:|date:| "17-Nov-88 15:29:51" IL:{DSK}<LISPFILES>ETHERNET>TCP>NFS>RPCXDR.\;1); Copyright (c) 1987, 1988, 1990 by Stanford University and Xerox Corporation.  All rights reserved.(IL:PRETTYCOMPRINT IL:RPCXDRCOMS)(IL:RPAQQ IL:RPCXDRCOMS           ((IL:PROPS (IL:RPCXDR IL:MAKEFILE-ENVIRONMENT IL:FILETYPE))           (EVAL-WHEN (EVAL COMPILE)                  (IL:FILES IL:RPCDECLS))           (IL:COMS                                          (IL:* IL:\; "Useful Constants")                  (IL:VARIABLES TWOTO31MINUSONE TWOTO31ST TWOTO32ND TWOTO32MINUSONE TWOTO63MINUSONE                          TWOTO64MINUSONE TWOTO64TH MINUS2TO31 MINUS2TO63))           (IL:VARIABLES *XDR-PRIMITIVE-TYPES* *XDR-CONSTRUCTED-TYPES* *XDR-CODEGEN-RECURSIVELST*)           (IL:STRUCTURES TYPSTK)           (IL:COMS                                          (IL:* IL:\;                                                            "Miscellaneous XDR Utility Functions")                  (IL:FUNCTIONS ACCESS-FCN-NAME CONSTRUCTOR-FCN-NAME FIND-IN-TYPE-STACK))           (IL:COMS                                          (IL:* IL:\;                                                            "Type Declarations and Predicates")                  (IL:TYPES XDR-INTEGER XDR-UNSIGNED XDR-HYPERINTEGER XDR-HYPERUNSIGNED)                  (IL:FUNCTIONS XDR-INTEGER-P XDR-UNSIGNED-P XDR-HYPERINTEGER-P XDR-HYPERUNSIGNED-P))           (IL:COMS                                          (IL:* IL:\;                                                     "XDR Code Generation for Constructed Functions")                  (IL:FUNCTIONS XDR-CODEGEN-COMMENT XDR-CODEGEN XDR-CODEGEN-1 XDR-CODEGEN-2                          XDR-CODEGEN-3 XDR-CODEGEN-RECURSION XDR-CODEGEN-CONSTANT                          XDR-CODEGEN-ENUMERATION XDR-CODEGEN-UNION XDR-CODEGEN-UNION-CASES                          XDR-CODEGEN-LIST XDR-CODEGEN-STRUCT XDR-CODEGEN-FIXED-ARRAY                          XDR-CODEGEN-COUNTED-ARRAY XDR-CODEGEN-LIST-OF XDR-CODEGEN-OPAQUE                          XDR-CODEGEN-SKIP XDR-CODEGEN-SEQUENCE))           (IL:COMS                                          (IL:* IL:\; "XDR run-time primitives")                  (IL:FUNCTIONS XDR-READ-INTEGER XDR-WRITE-INTEGER XDR-READ-BOOLEAN XDR-WRITE-BOOLEAN                         XDR-READ-UNSIGNED XDR-WRITE-UNSIGNED XDR-READ-HYPERINTEGER                          XDR-WRITE-HYPERINTEGER XDR-READ-HYPERUNSIGNED XDR-WRITE-HYPERUNSIGNED                          XDR-READ-STRING XDR-WRITE-STRING XDR-READ-FLOAT XDR-WRITE-FLOAT                          XDR-READ-STRING-POINTER XDR-READ-ARRAY XDR-WRITE-ARRAY                          XDR-WRITE-STRING-POINTER XDR-SKIP-PRIMITIVE XDR-ZERO-PRIMITIVE                          XDR-READ-WRITE-VOID XDR-ENUMERATION-FAULT XDR-MAKE-OPAQUE)                                                             (IL:* IL:\;                                                            "These are for backward compatibility")                  (IL:FUNCTIONS XDR-BOOLEAN XDR-INTEGER XDR-UNSIGNED XDR-HYPERINTEGER                          XDR-HYPERUNSIGNED XDR-STRING XDR-STRING-POINTER XDR-FLOAT XDR-VOID                          XDR-OPAQUE-PRIMITIVE))))(IL:PUTPROPS IL:RPCXDR IL:MAKEFILE-ENVIRONMENT (:READTABLE "XCL" :PACKAGE "RPC2"))(IL:PUTPROPS IL:RPCXDR IL:FILETYPE :COMPILE-FILE)(EVAL-WHEN (EVAL COMPILE)(IL:FILESLOAD IL:RPCDECLS))(IL:* IL:\; "Useful Constants")(DEFCONSTANT TWOTO31MINUSONE 2147483647)(DEFCONSTANT TWOTO31ST 2147483648)(DEFCONSTANT TWOTO32ND 4294967296)(DEFCONSTANT TWOTO32MINUSONE 4294967295)(DEFCONSTANT TWOTO63MINUSONE 9223372036854775807)(DEFCONSTANT TWOTO64MINUSONE 18446744073709551615)(DEFCONSTANT TWOTO64TH 18446744073709551616)(DEFCONSTANT MINUS2TO31 -2147483648)(DEFCONSTANT MINUS2TO63 -9223372036854775808)(DEFPARAMETER *XDR-PRIMITIVE-TYPES*   '((:INTEGER XDR-READ-INTEGER . XDR-WRITE-INTEGER)     (:BOOLEAN XDR-READ-BOOLEAN . XDR-WRITE-BOOLEAN)     (:UNSIGNED XDR-READ-UNSIGNED . XDR-WRITE-UNSIGNED)     (:HYPERINTEGER XDR-READ-HYPERINTEGER . XDR-WRITE-HYPERINTEGER)     (:HYPERUNSIGNED XDR-READ-HYPERUNSIGNED . XDR-WRITE-HYPERUNSIGNED)     (:STRING XDR-READ-STRING . XDR-WRITE-STRING)     (:VOID . XDR-READ-WRITE-VOID)     (:FLOAT XDR-READ-FLOAT . XDR-WRITE-FLOAT)     (:DOUBLE . XDR-DOUBLE)     (:STRING-POINTER XDR-READ-STRING-POINTER . XDR-WRITE-STRING-POINTER))   "An alist of XDR primitive types and the function(s) that encodes/decodes that type.  If CDR is a list, it is (readfn . writefn).")(DEFPARAMETER *XDR-CONSTRUCTED-TYPES*   '((:ENUMERATION . XDR-CODEGEN-ENUMERATION)     (:UNION . XDR-CODEGEN-UNION)     (:STRUCT . XDR-CODEGEN-STRUCT)     (:LIST . XDR-CODEGEN-LIST)     (:FIXED-ARRAY . XDR-CODEGEN-FIXED-ARRAY)     (:COUNTED-ARRAY . XDR-CODEGEN-COUNTED-ARRAY)     (:OPAQUE . XDR-CODEGEN-OPAQUE)     (:SKIP . XDR-CODEGEN-SKIP)     (:SEQUENCE . XDR-CODEGEN-SEQUENCE)     (:LIST-OF . XDR-CODEGEN-LIST-OF))   "Association list of XDR constructed types and the functions that create functions to read/write them")(DEFGLOBALVAR *XDR-CODEGEN-RECURSIVELST* NIL   "Place for XDR-CODEGEN to save recursive functions it found in making an expansion.A list of TYPSTK structs")(DEFSTRUCT TYPSTK   "Element on stack of types for which code already generated."   PROG   TYPE   XDRPROC   OPER   ARGS)(IL:* IL:\; "Miscellaneous XDR Utility Functions")(DEFUN ACCESS-FCN-NAME (STRUCT FIELD)    "Maps struct name and field name (strings or symbols) into theaccess function name for that slot."                         (IL:* IL:\; "")   (INTERN (CONCATENATE 'STRING (STRING STRUCT)                  "-"                  (STRING FIELD))          (SYMBOL-PACKAGE STRUCT)))(DEFUN CONSTRUCTOR-FCN-NAME (STRUCT)   "Maps a symbol or string naming a defstruct into the constructor function symbolfor that defstruct type"   (INTERN (CONCATENATE 'STRING "MAKE-" (STRING STRUCT))          (SYMBOL-PACKAGE STRUCT)))(DEFUN FIND-IN-TYPE-STACK (PRG TYP STACK)   "Find the first element in a list of TYPSTK's such that PRG and TYPmatch the PROG and TYPE fields of the TYPSTK."   (DOLIST (EL STACK)       (IF (AND (EQL PRG (TYPSTK-PROG EL))                (EQL TYP (TYPSTK-TYPE EL)))           (RETURN EL))))(IL:* IL:\; "Type Declarations and Predicates")(DEFTYPE XDR-INTEGER ()   '(AND INTEGER (SATISFIES XDR-INTEGER-P)))(DEFTYPE XDR-UNSIGNED ()   '(AND INTEGER (SATISFIES XDR-UNSIGNED-P)))(DEFTYPE XDR-HYPERINTEGER ()   '(AND INTEGER (SATISFIES XDR-HYPERINTEGER-P)))(DEFTYPE XDR-HYPERUNSIGNED ()   '(AND INTEGER (SATISFIES XDR-HYPERUNSIGNED-P)))(DEFUN XDR-INTEGER-P (I)   (AND (>= I MINUS2TO31)        (< I TWOTO31ST)))(DEFUN XDR-UNSIGNED-P (I)   (OR (AND (TYPEP I 'FIXNUM)            (>= (THE FIXNUM I)                0))       (AND (>= I 0)            (< I TWOTO32ND))))(DEFUN XDR-HYPERINTEGER-P (I)   (AND (>= I MINUS2TO63)        (<= I TWOTO63MINUSONE)))(DEFUN XDR-HYPERUNSIGNED-P (I)   (AND (>= I 0)        (<= I TWOTO64MINUSONE)))(IL:* IL:\; "XDR Code Generation for Constructed Functions")(DEFUN XDR-CODEGEN-COMMENT ()   "******************************************************* Code Generation for XCL Constructed Types *******************************************************The following functions generate code for translating between Common Lispand XDR. For each function,    CONTEXT is an RPC-PROGRAM structure with respect to which a            typedef is being constructed.    TYPEDEF is an XDR type definition, and    OPER is either READ (decode) or WRITE (encode).For all functions except XDR-CODEGEN, a third argument ARGS is a list ofarguments to the code being generated. It always begins with an XDR-stream argumentand for OPER=WRITE is usually followed by the object to be written.WARNINGS:(1) DO NOT, REPEAT DO NOT pass an (XDR-CODEGEN-xxx) as the argument of an(XDR-CODEGEN-xxx). If you do, you might cause the  code generated forthe argument to be evaluated multiple times in the code for the resulting expression.(2) The XDR-CODEGEN-xxx functions code in-line rather than wrap themselvesin LET's or LAMBDA's or whatever. To avoid complications with functionsthat require a location-specifier (CHECK-TYPE or CCASE, for example), anXDR-CODEGEN-xxx function may ***not*** generate code that assumes that itsarguments ARGS or various COUNTs are legitimate location-specifiers. If a CHECK-TYPE or similar function is to be done, a LET (or other bindingmechanism) should be generated to create a legal location-specifier."   NIL)(DEFUN XDR-CODEGEN (CONTEXT TYPEDEF OPER)   "Top-level XDR Code Generation function. Returns code to read/writean XDR element of type TYPEDEF.CONTEXT is an RPC-PROGRAM structure with respect to which theTYPEDEF is interpreted (in terms of inheritance).TYPEDEF is an XDR Type or Type definition.OPER is either 'RPC2::READ or 'RPC::WRITE.See documentation of XDR-CODEGEN-COMMENT."   (SETQ *XDR-CODEGEN-RECURSIVELST* NIL)   (LET* ((ARGS (ECASE OPER                    (READ '(XDR-STREAM))                    (WRITE '(XDR-STREAM XDR-TOPLEVEL-ITEM))))          (FCN (XDR-CODEGEN-1 CONTEXT TYPEDEF OPER ARGS NIL)))         (IF FCN             (IF (NULL *XDR-CODEGEN-RECURSIVELST*)                 (LIST 'LAMBDA ARGS FCN)                 (LIST 'LAMBDA ARGS `(LABELS ,(XDR-CODEGEN-3 *XDR-CODEGEN-RECURSIVELST*)                                            ,FCN)))             (ERROR "Could not parse XDR Type ~S" TYPEDEF))))(DEFUN XDR-CODEGEN-1 (CONTEXT TYPEDEF OPER ARGS STK)   "Generates code to read or write an element of type TYPEDEF.CONTEXT, TYPEDEF, and OPER are as in XDR-CODEGEN.ARGS is a list of the arguments forms for the generated code.For OPER=READ it will (<rpc-stream-name>), andFor OPER=WRITE it will be (<rpc-stream-name> <element>).STK is a list of TYPSTK elements, one for each named type above this one in this expansion."   (OR (COND          ((SYMBOLP TYPEDEF)                                 (IL:* IL:\;                                                            "Primitive, local or inherited type")           (LET ((TEM (CDR (ASSOC TYPEDEF *XDR-PRIMITIVE-TYPES*))))                (COND                   (TEM                                      (IL:* IL:\;                                                            "Here's how to read/write it.")                        (CONS (COND                                 ((NOT (CONSP TEM))          (IL:* IL:\; "Old way is single fn")                                  TEM)                                 ((EQ OPER 'READ)            (IL:* IL:\;                                                            "New way is (read . write)")                                  (CAR TEM))                                 (T (CDR TEM)))                              ARGS))                   ((SETQ TEM (FIND-RPC-TYPENAME CONTEXT TYPEDEF))                                                             (IL:* IL:\;                                                            "It's defined in this program")                    (XDR-CODEGEN-2 CONTEXT TEM OPER ARGS STK))                   (T                                        (IL:* IL:\; "Try to inherit it")                      (SOME #'(LAMBDA (PROGNAME)                                     (LET ((PRG (FIND-RPC-PROGRAM :NAME PROGNAME))                                           TD)                                          (AND PRG (SETQ TD (FIND-RPC-TYPENAME PRG TYPEDEF))                                               (XDR-CODEGEN-2 PRG TD OPER ARGS STK))))                            (RPC-PROGRAM-INHERITS CONTEXT))))))          ((CONSP TYPEDEF)                                   (IL:* IL:\;                                                            "Constructed or qualified type")           (LET ((FN (CDR (ASSOC (CAR TYPEDEF)                                 *XDR-CONSTRUCTED-TYPES*)))                 PRG TD)                (COND                   (FN                                       (IL:* IL:\;                                                            "Here's a function to generate code")                       (FUNCALL FN CONTEXT TYPEDEF OPER ARGS STK))                   ((AND (SYMBOLP (CAR TYPEDEF))                         (SYMBOLP (CDR TYPEDEF))                         (SETQ PRG (FIND-RPC-PROGRAM :NAME (CAR TYPEDEF)))                         (SETQ TD (FIND-RPC-TYPEDEF PRG (CDR TYPEDEF))))                                                             (IL:* IL:\;                                                            "Qualified def (prgname . type)")                    (XDR-CODEGEN-2 PRG TD OPER ARGS STK))))))       (ERROR "Could not resolve XDR Type Definition: ~S" TYPEDEF)))(DEFUN XDR-CODEGEN-2 (CONTEXT TYPENAME OPER ARGS STK)   "Expands named types. (1) Sees whether type already seen above here in this expansion.Otherwise,(2) Notes the name on TYPESTK,(3) Finds the definition of this type,(4) Calls XDR-CODEGEN-1 to expand the type definition.(5) Sees whether the XDR-CODEGEN-1 call found this type below,     if so, notes this on *XDR-CODEGEN-RECURSIVELST* and returns     call to the recursive function for this type.     otherwise just returns the code."   (IL:* IL:|;;| "Every named type expansion passes through here and gets expanded. Since it is only named types that can be recursive,  this is the only place we check for recursion")   (OR (XDR-CODEGEN-RECURSION CONTEXT TYPENAME OPER ARGS STK)       (LET (TD CODE TOP)                                    (IL:* IL:\; "No")            (PUSH (MAKE-TYPSTK :PROG CONTEXT :TYPE TYPENAME :OPER OPER :ARGS                         (IF (EQL OPER 'READ)                             ARGS                             '(RPCSTREAM RVALUE)))                  STK)                                       (IL:* IL:\; "Push type on stack")            (UNLESS (SETQ TD (FIND-RPC-TYPEDEF CONTEXT TYPENAME))                (ERROR "Null type definition for Program ~A, Type ~A" (AND CONTEXT (RPC-PROGRAM-NAME                                                                                    CONTEXT))                       TYPENAME))            (SETQ CODE (XDR-CODEGEN-1 CONTEXT TD OPER ARGS STK))                                                             (IL:* IL:\; "Generate code")            (SETQ TOP (CAR STK))                             (IL:* IL:\; "\"Pop\" stack")            (IF (NULL (TYPSTK-XDRPROC TOP))                  (IL:* IL:\;                                                            "Was this type called recursively?")                CODE                                         (IL:* IL:\; "No, just return code")                (PROGN (PUSH TOP *XDR-CODEGEN-RECURSIVELST*) (IL:* IL:\; "Yes, save recursive type")                       `(,(TYPSTK-XDRPROC TOP)                         ,@ARGS)                             (IL:* IL:\;                                                            "Return call to recursive function")                       )))))(DEFUN XDR-CODEGEN-3 (RLIST)   (IL:* IL:|;;|  "Generate the set of function definitions for LABELS. RLIST is a list of TYPSTK structs.")   (MAPCAR #'(LAMBDA (TYPSTK)                    `(,(TYPSTK-XDRPROC TYPSTK)                      ,(TYPSTK-ARGS TYPSTK)                      ,(XDR-CODEGEN-1 (TYPSTK-PROG TYPSTK)                              (OR (FIND-RPC-TYPEDEF (TYPSTK-PROG TYPSTK)                                         (TYPSTK-TYPE TYPSTK))                                  (ERROR "No typedef for Program ~A, Type ~A" (RPC-PROGRAM-NAME                                                                               (TYPSTK-PROG TYPSTK))                                         (TYPSTK-TYPE TYPSTK)))                              (TYPSTK-OPER TYPSTK)                              (TYPSTK-ARGS TYPSTK)                              RLIST)))          RLIST))(DEFUN XDR-CODEGEN-RECURSION (PRG TYP OPER ARGS STACK)   (IL:* IL:|;;|  " If type has already be seen, mark as recursive and return code calling that function")   (LET ((INSTACK (FIND-IN-TYPE-STACK PRG TYP STACK)))        (WHEN INSTACK                                        (IL:* IL:\; "Seen it before")            (SETF (TYPSTK-XDRPROC INSTACK)                  (OR (TYPSTK-XDRPROC INSTACK)                      (INTERN (SYMBOL-NAME (GENSYM (CONCATENATE 'STRING "XDR-" (SYMBOL-NAME OPER)                                                          "-"                                                          (SYMBOL-NAME TYP)                                                          "-"))))))            `(,(TYPSTK-XDRPROC INSTACK)              ,@ARGS))))(DEFUN XDR-CODEGEN-CONSTANT (CONTEXT CONSTANT)   (COND      ((NULL CONSTANT)       (ERROR "Could not resolve nil constant definition from RPC program ~a~%" (RPC-PROGRAM-NAME                                                                                 CONTEXT)))      ((INTEGERP CONSTANT)       CONSTANT)                                             (IL:* IL:\;                                                            " Immediate Constant Definition")      ((AND (SYMBOLP CONSTANT)            (OR (FIND-XDR-CONSTANT CONTEXT CONSTANT)         (IL:* IL:\;                                                            " Local Constant Definition")                (SOME #'(LAMBDA (CNTX)                               (FIND-XDR-CONSTANT (FIND-RPC-PROGRAM :NAME CNTX)                                      CONSTANT))                      (RPC-PROGRAM-INHERITS CONTEXT))        (IL:* IL:\;                                                            " Inherited Constant Definition")                )))      ((AND (CONSP CONSTANT)                                 (IL:* IL:\;                                                            "Qualified Constant Definition ")            (SYMBOLP (CDR CONSTANT))            (FIND-XDR-CONSTANT (FIND-RPC-PROGRAM :NAME (CAR CONSTANT))                   (CDR CONSTANT))))      ((ERROR "Could not resolve XDR constant ~a~%" CONSTANT))))(DEFUN XDR-CODEGEN-ENUMERATION (CONTEXT TYPEDEF OPER ARGS STK)   (LET ((CASES (CDR TYPEDEF))         (SELECTOR (IF (EQ OPER 'READ)                       'KEY                       (CADR ARGS)))         DEFAULT PARENT)        (COND           ((EQ (FIRST CASES)                :NOERRORS)                                   (IL:* IL:\;       "Means allow values other than shown here, which we will just represent by the integer value")            (SETQ CASES (CDR CASES))            (SETQ DEFAULT SELECTOR))           (T                                                (IL:* IL:\; "Generate error clause if selector invalid.  Inlcude the type that produced this enumeration if it's simple")              (SETQ DEFAULT `(XDR-ENUMERATION-FAULT ,SELECTOR ',OPER                                    ,@(AND (CONSP STK)                                           (SYMBOLP (SETQ PARENT (TYPSTK-TYPE (FIRST STK))))                                           `(',PARENT))))))        (IF (EQ OPER 'READ)            `(LET ((KEY (XDR-READ-INTEGER ,(CAR ARGS))))                  (CASE KEY                      ,.(MAPCAR #'(LAMBDA (X)                                         `(,(XDR-CODEGEN-CONSTANT CONTEXT (CADR X))                                           ',(CAR X)))                               CASES)                      (OTHERWISE ,DEFAULT)))            `(XDR-WRITE-INTEGER ,(CAR ARGS)                    (CASE ,SELECTOR                        ,.(MAPCAR #'(LAMBDA (X)                                           (LIST (CAR X)                                                 (XDR-CODEGEN-CONSTANT CONTEXT (CADR X))))                                 CASES)                        (OTHERWISE ,DEFAULT))))))(DEFUN XDR-CODEGEN-UNION (CONTEXT TYPEDEF OPER ARGS STK)   "(UNION <discriminant-type> (<enumeration-element> <arm-type>) ...(<> <>))Read Calling Sequence: XDR-UNION(xdrstream)Read Input: An integer followed by the encoding of that arm.Read Output: The enumeration element from the type of the discriminant             The discriminant and arm are returned as a dotted pair.Write Input: An enumeration element and an unencoded arm.Write calling sequence: XDR-UNION(xdrstream,discriminant,arm)Write Output: The (integer) encoding of the discriminant and the encoded arm."   (LET ((DISCRIM-TYPE (SECOND TYPEDEF))         (XDRSTREAM (FIRST ARGS))         (UNIONLIST (SECOND ARGS)))        (IF (EQ OPER 'READ)            `(LET ((DISCRIMINANT ,(XDR-CODEGEN-1 CONTEXT DISCRIM-TYPE OPER ARGS STK)))                  (LIST DISCRIMINANT (CASE DISCRIMINANT                                         ,.(XDR-CODEGEN-UNION-CASES CONTEXT TYPEDEF OPER ARGS STK))))            `(PROGN ,(XDR-CODEGEN-1 CONTEXT DISCRIM-TYPE OPER `(,XDRSTREAM (CAR ,UNIONLIST))                            STK)                    (CASE (CAR ,UNIONLIST)                        ,.(XDR-CODEGEN-UNION-CASES CONTEXT TYPEDEF OPER ARGS STK))))))(DEFUN XDR-CODEGEN-UNION-CASES (CONTEXT TYPEDEF OPER ARGS STK)   (IL:* IL:|;;| "Generate the clauses for a CASE statement which resolves the cases of TYPEDEF = (:UNION enum . cases).")   (DO ((PAIRS (CDDR TYPEDEF)               (CDR PAIRS))        (RECURARGS (IF (EQ OPER 'READ)                       ARGS                                  (IL:* IL:\;                "For WRITE, ARGS = (stream item).  Recursive calls will write (stream (cadr item)).")                       `(,(FIRST ARGS)                         (CADR ,(SECOND ARGS)))))        (ARMS)        (PAIR))       ((NULL PAIRS)        (NREVERSE ARMS))     (SETQ PAIR (CAR PAIRS))     (PUSH `(,(IF (OR (EQ (CAR PAIR)                          'OTHERWISE)                      (AND (SYMBOLP (CAR PAIR))                           (STRING= (CAR PAIR)                                  'DEFAULT)))                  'OTHERWISE                                 (IL:* IL:\;                                                            "Default arm turns into OTHERWISE case.")                  `(,(CAR PAIR)))             ,(XDR-CODEGEN-1 CONTEXT (CADR PAIR)                     OPER RECURARGS STK))           ARMS)))(DEFUN XDR-CODEGEN-LIST (CONTEXT TYPEDEF OPER ARGS STK)   "TYPEDEF = (LIST <typedef-1> ... <typedef-n>)"   (IF (EQ OPER 'READ)       `(LIST ,.(MAPCAR #'(LAMBDA (TD)                                 (XDR-CODEGEN-1 CONTEXT TD OPER ARGS STK))                       (CDR TYPEDEF)))       (LET        ((XDRSTREAM (FIRST ARGS))         (THELIST (SECOND ARGS))         (FIRSTTIME T))        (IL:* IL:|;;|  "Walk down the list we're printing, generating code to write the CAR by the appropriate type def.")        `(LET          ((THELIST ,(SECOND ARGS)))          ,@(MAPCAR #'(LAMBDA (TYPE)                             (XDR-CODEGEN-1                              CONTEXT TYPE OPER                              `(,XDRSTREAM (CAR ,(COND                                                    (FIRSTTIME (SETQ FIRSTTIME NIL)                                                           'THELIST)                                                    (T       (IL:* IL:\; "Get next tail")                                                       '(SETQ THELIST (CDR THELIST))))))                              STK))                   (CDR TYPEDEF))))))(DEFUN XDR-CODEGEN-STRUCT (CONTEXT TYPEDEF OPER ARGS STK)   "(STRUCT <defstruct-type> (<field-name> <type>) ... (<field-name> <type>))"   (LET ((STRUCT-TYPE (CADR TYPEDEF))         (XDRSTREAM (FIRST ARGS))         (THESTRUCT (SECOND ARGS)))        (IF (EQ OPER 'READ)            `(,(CONSTRUCTOR-FCN-NAME STRUCT-TYPE)            (IL:* IL:\;                                                     "Call the constructor with list of key val ...")              ,@(MAPCAN #'(LAMBDA (X)                        (IL:* IL:\; "X = (slotname type)")                                 (LIST (INTERN (SYMBOL-NAME (CAR X))                                              (FIND-PACKAGE "KEYWORD"))                                       (XDR-CODEGEN-1 CONTEXT (CADR X)                                              OPER ARGS STK)))                       (CDDR TYPEDEF)))            `(PROGN ,@(MAPCAR #'(LAMBDA (X)                                       (XDR-CODEGEN-1 CONTEXT (CADR X)                                              OPER                                              `(,XDRSTREAM (,(ACCESS-FCN-NAME STRUCT-TYPE                                                                    (CAR X))                                                            ,THESTRUCT))                                              STK))                             (CDDR TYPEDEF))))))(DEFUN XDR-CODEGEN-FIXED-ARRAY (CONTEXT TYPEDEF OPER ARGS STK &OPTIONAL RUN-TIME-COUNT)   "typedef is (:fixed-array elttype count), or (:counted-array elttype) with RUN-TIME-COUNT giving a run-time expression."   (IL:* IL:|;;| "Read or write a sequence of exactly COUNT objects of type ELTTYPE")   (LET* ((ELEMENT-TYPE (SECOND TYPEDEF))          (COUNT (COND                    (RUN-TIME-COUNT)                    (T                                       (IL:* IL:\;      "For FIXED-ARRAY, the count is a constant known at compile time and not encoded in the stream")                       (XDR-CODEGEN-CONSTANT CONTEXT (THIRD TYPEDEF)))))          (XDRSTREAM (FIRST ARGS)))         (UNLESS RUN-TIME-COUNT             (CHECK-TYPE COUNT (INTEGER 0 *)))         (IF (EQ OPER 'READ)             `(LET* ((THECOUNT ,COUNT)                     (THEARRAY (MAKE-ARRAY THECOUNT)))                    (DOTIMES (I THECOUNT THEARRAY)                        (SETF (AREF THEARRAY I)                              ,(XDR-CODEGEN-1 CONTEXT ELEMENT-TYPE OPER ARGS STK))))             `(LET ((THEARRAY ,(SECOND ARGS)))                   (DOTIMES (I ,COUNT THEARRAY)                       ,(XDR-CODEGEN-1 CONTEXT ELEMENT-TYPE OPER `(,XDRSTREAM (AREF THEARRAY I))                               STK))))))(DEFUN XDR-CODEGEN-COUNTED-ARRAY (CONTEXT TYPEDEF OPER ARGS STK)   "typedef is (:counted-array element-type)"   (IL:* IL:|;;| "Counted arrays are just like fixed arrays, except that they are preceded by their length (unsigned).")   (IF (EQ OPER 'READ)       (XDR-CODEGEN-FIXED-ARRAY CONTEXT TYPEDEF OPER ARGS STK (XDR-CODEGEN-1 CONTEXT :UNSIGNED OPER                                                                      ARGS STK))       (LET ((XDRSTREAM (FIRST ARGS)))            `(LET* ((THEARRAY ,(SECOND ARGS))                    (THECOUNT (LENGTH THEARRAY)))                   ,(XDR-CODEGEN-1 CONTEXT :UNSIGNED OPER `(,XDRSTREAM THECOUNT)                           STK)                   ,(XDR-CODEGEN-FIXED-ARRAY CONTEXT TYPEDEF OPER `(,XDRSTREAM THEARRAY)                           STK                           'THECOUNT)))))(DEFUN XDR-CODEGEN-LIST-OF (CONTEXT TYPEDEF OPER ARGS STK)   "typedef is (:list-of element-type)"   (IL:* IL:|;;| "Read or write a list of elements all of the same type.  Stream encoding is the length of the list followed by the elements.")   (LET ((ELEMENT-TYPE (SECOND TYPEDEF))         (XDRSTREAM (FIRST ARGS)))        (IF (EQ OPER 'READ)            `(IL:TO ,(XDR-CODEGEN-1 CONTEXT :UNSIGNED OPER ARGS STK)                IL:COLLECT ,(XDR-CODEGEN-1 CONTEXT ELEMENT-TYPE OPER ARGS STK))            `(LET* ((THELIST ,(SECOND ARGS))                    (THECOUNT (LIST-LENGTH THELIST)))                   ,(XDR-CODEGEN-1 CONTEXT :UNSIGNED OPER `(,XDRSTREAM THECOUNT)                           STK)                   (MAPC #'(LAMBDA (OBJ)                                  ,(XDR-CODEGEN-1 CONTEXT ELEMENT-TYPE OPER `(,XDRSTREAM OBJ)                                          STK))                         THELIST)))))(DEFUN XDR-CODEGEN-OPAQUE (CONTEXT TYPEDEF OPER ARGS STK)   "Declaration is (opaque <bytecount> <array-type>)"   (LET ((BYTECOUNT (XDR-CODEGEN-CONSTANT CONTEXT (SECOND TYPEDEF)))         (ELEMENT-TYPE (THIRD TYPEDEF))         (XDRSTREAM (FIRST ARGS)))        (CHECK-TYPE BYTECOUNT (INTEGER 0 *)               "Opaque size must be integral")               (IL:* IL:\;                                                        "Might want to check ELEMENT-TYPE here, too")        (IF (EQ OPER 'READ)            `(XDR-READ-ARRAY ,XDRSTREAM ,BYTECOUNT ',ELEMENT-TYPE)            `(XDR-WRITE-ARRAY ,XDRSTREAM ,BYTECOUNT ',ELEMENT-TYPE ,(SECOND ARGS)))))(DEFUN XDR-CODEGEN-SKIP (CONTEXT TYPEDEF OPER ARGS STK)   (LET ((BYTECOUNT (XDR-CODEGEN-CONSTANT CONTEXT (SECOND TYPEDEF))))        (CHECK-TYPE BYTECOUNT (INTEGER 0 *))        `(,(IF (EQL OPER 'READ)               'XDR-SKIP-PRIMITIVE               'XDR-ZERO-PRIMITIVE)          ,(FIRST ARGS)          ,(LOGAND (+ BYTECOUNT 3)                  -4))))(DEFUN XDR-CODEGEN-SEQUENCE (CONTEXT TYPEDEF OPER ARGS STK)   (IL:* IL:|;;| "Non-recursive way of handling a recursive type.  Each item is preceded on the stream with a boolean T, than a boolean NIL follows the last arg.  In Lisp, we represent this as a simple list.")   (LET ((STREAM (FIRST ARGS))         (ELTTYPE (SECOND TYPEDEF)))        (IF (EQ OPER 'READ)            `(IL:WHILE (XDR-READ-BOOLEAN ,STREAM)                IL:COLLECT ,(XDR-CODEGEN-1 CONTEXT ELTTYPE OPER ARGS STK))            `(DOLIST (EL ,(SECOND ARGS)                         (XDR-BOOLEAN ,STREAM NIL))                 (XDR-WRITE-BOOLEAN ,STREAM T)                 ,(XDR-CODEGEN-1 CONTEXT ELTTYPE OPER `(,STREAM EL)                         STK)))))(IL:* IL:\; "XDR run-time primitives")(DEFUN XDR-READ-INTEGER (XDRSTREAM)   (GETCELL XDRSTREAM))(DEFUN XDR-WRITE-INTEGER (XDRSTREAM VALUE)   (CHECK-TYPE VALUE INTEGER)   (PUTCELL XDRSTREAM VALUE))(DEFUN XDR-READ-BOOLEAN (XDRSTREAM)   (LET ((VALUE (GETCELL XDRSTREAM)))        (CASE VALUE            (0 NIL)            (1 T)            (OTHERWISE (RPC-SIGNAL-ERROR T `(ILLEGAL-BOOLEAN ,VALUE))))))(DEFUN XDR-WRITE-BOOLEAN (XDRSTREAM VALUE)   (PUTCELL XDRSTREAM (IF (NULL VALUE)                          0                          1)))(DEFUN XDR-READ-UNSIGNED (XDRSTREAM)   (GETUNSIGNED XDRSTREAM))(DEFUN XDR-WRITE-UNSIGNED (XDRSTREAM VALUE)   (PUTUNSIGNED XDRSTREAM VALUE))(DEFUN XDR-READ-HYPERINTEGER (XDRSTREAM)   (LET ((VALUE (+ (ASH (GETUNSIGNED XDRSTREAM)                        32)                   (GETUNSIGNED XDRSTREAM))))        (IF (> VALUE TWOTO63MINUSONE)            (- VALUE TWOTO64TH)            VALUE)))(DEFUN XDR-WRITE-HYPERINTEGER (XDRSTREAM VALUE)   (CHECK-TYPE VALUE XDR-HYPERINTEGER)   (PUTUNSIGNED XDRSTREAM (ASH VALUE -32))   (PUTUNSIGNED XDRSTREAM (LOGAND VALUE TWOTO32MINUSONE)))(DEFUN XDR-READ-HYPERUNSIGNED (XDRSTREAM)   (+ (ASH (GETUNSIGNED XDRSTREAM)           32)      (GETUNSIGNED XDRSTREAM)))(DEFUN XDR-WRITE-HYPERUNSIGNED (XDRSTREAM VALUE)   (CHECK-TYPE VALUE XDR-HYPERUNSIGNED)   (PUTUNSIGNED XDRSTREAM (ASH VALUE -32))   (PUTUNSIGNED XDRSTREAM (LOGAND VALUE TWOTO32MINUSONE)))(DEFUN XDR-READ-STRING (XDRSTREAM)   (LET* ((NBYTES (XDR-UNSIGNED XDRSTREAM))          (STRING (IL:ALLOCSTRING NBYTES)))         (GETRAWBYTES XDRSTREAM (VECTOR-BASE STRING)                0 NBYTES)         (SKIPBYTES XDRSTREAM (PADDING-BYTES NBYTES))         STRING))(DEFUN XDR-WRITE-STRING (XDRSTREAM STRING)   (CHECK-TYPE STRING STRING)   (WHEN (AND (IL:%FAT-STRING-ARRAY-P STRING)              (IL:%FAT-STRING-ARRAY-P (SETQ STRING (COPY-SEQ STRING))))                                                             (IL:* IL:\; "Only 8-bit chars supported in xdr.  COPY-SEQ is just in case it was all thin chars in a formerly fat string.")       (ERROR "XDR string contains NS characters: ~S" STRING))   (LET ((NBYTES (IL:NCHARS STRING)))        (XDR-UNSIGNED XDRSTREAM NBYTES)        (PUTRAWBYTES XDRSTREAM (VECTOR-BASE STRING)               (VECTOR-OFFSET STRING)               NBYTES)        (ZEROBYTES XDRSTREAM (PADDING-BYTES NBYTES))))(DEFUN XDR-READ-FLOAT (XDRSTREAM)   (IL:* IL:|;;| "Read a single-precision IEEE floating point number.  Fortunately, that's our internal format as well.")   (LET ((VALUE (IL:NCREATE 'IL:FLOATP)))        (GETRAWBYTES XDRSTREAM VALUE 0 4)))(DEFUN XDR-WRITE-FLOAT (XDRSTREAM V)   (IL:* IL:|;;| "Write a single-precision IEEE floating point number.  Fortunately, that's our internal format as well.")   (PUTRAWBYTES XDRSTREAM (IL:\\DTEST V 'FLOATP)          0 4))(DEFUN XDR-READ-STRING-POINTER (XDRSTREAM)   "This is a gross hack to handle what amounts to bulk data."   (LET* ((NBYTES (XDR-UNSIGNED XDRSTREAM))          (PLACE (GETOFFSET XDRSTREAM))          (PACKET (CAR PLACE))          (BYTEOFFSET (CDR PLACE)))         (IL:* IL:|;;| "This only works for UDP!!")         (IL:* IL:|;;| "Returns ((packet . byteoffset) . number-of-bytes))")         (PROG1 (CONS (CONS PACKET BYTEOFFSET)                      NBYTES)             (SKIPBYTES XDRSTREAM (PADDING-BYTES NBYTES)))))(DEFUN XDR-READ-ARRAY (XDRSTREAM BYTECOUNT ELEMENT-TYPE)   "Read an opaque array of bytecount bytes."   (LET ((QUADBYTECOUNT (LOGAND (+ BYTECOUNT 3)                               -4)))        (IL:* IL:|;;| "QUADBYTECOUNT is BYTECOUNT rounded up to multiple of 4, which is the number of actual bytes on the stream.  Note that we will always be able to read the extra bytes, if any, in the same operation because arrays in this system are always a multiple of 4 bytes long.")        (IF (EQ ELEMENT-TYPE :UNBOXED)            (LET ((ARRAY (IL:\\ALLOCBLOCK (ASH QUADBYTECOUNT -2))))                                                             (IL:* IL:\;                                                            "Just get into raw array block")                 (GETRAWBYTES XDRSTREAM ARRAY 0 QUADBYTECOUNT)                 ARRAY)            (LET ((ARRAY (MAKE-ARRAY BYTECOUNT :ELEMENT-TYPE (OR ELEMENT-TYPE 'STRING-CHAR))))                                                             (IL:* IL:\;                               "Read into array of specified type. We assume the type packs tensely")                 (GETRAWBYTES XDRSTREAM (IL:|fetch| (IL:ONED-ARRAY IL:BASE) IL:|of| ARRAY)                        0 QUADBYTECOUNT)                 ARRAY))))(DEFUN XDR-WRITE-ARRAY (XDRSTREAM BYTECOUNT ELEMENT-TYPE ARRAY)   "Write an opaque array of bytecount bytes."   (COND      ((NULL ARRAY)                                          (IL:* IL:\;                                                            "Convenient shorthand: write all zeros")       (ZEROBYTES XDRSTREAM BYTECOUNT))      ((EQ ELEMENT-TYPE :UNBOXED)       (PUTRAWBYTES XDRSTREAM ARRAY 0 BYTECOUNT))      (T (PUTRAWBYTES XDRSTREAM (IL:|fetch| (IL:ONED-ARRAY IL:BASE) IL:|of| ARRAY)                (IL:|fetch| (IL:ONED-ARRAY IL:OFFSET) IL:|of| ARRAY)                BYTECOUNT))))(DEFUN XDR-WRITE-STRING-POINTER (XDRSTREAM VALUE)   "This is a gross hack to handle what amounts to bulk data."   (IL:* IL:|;;| "Value is ((buffer . offset) . nbytes), where the first element can be just buffer if offset is zero.")   (LET* ((BUFFER (CAR VALUE))          (NBYTES (CDR VALUE))          (OUTSTREAM (RPC-STREAM-OUTSTREAM XDRSTREAM))          (OFFSET 0))         (WHEN (CONSP BUFFER)             (SETQ OFFSET (CDR BUFFER)                   BUFFER                   (CAR BUFFER)))         (XDR-UNSIGNED XDRSTREAM NBYTES)         (PUTRAWBYTES XDRSTREAM BUFFER OFFSET NBYTES)         (ZEROBYTES XDRSTREAM (PADDING-BYTES NBYTES))))(DEFUN XDR-SKIP-PRIMITIVE (XDRSTREAM N)   (SKIPBYTES XDRSTREAM N))(DEFUN XDR-ZERO-PRIMITIVE (XDRSTREAM N)   (ZEROBYTES XDRSTREAM N))(DEFMACRO XDR-READ-WRITE-VOID (&REST IGNORE)   "VOID type compiles into this"   '(PROGN NIL))(DEFUN XDR-ENUMERATION-FAULT (KEY OPER TYPE)   (IL:* IL:|;;| "Called when you try to read/write (per OPER) the value KEY, which is not valid for an enumeration.  TYPE may be the parent type.")   (CASE OPER       (READ           (CERROR "Return the integer ~D as the value"                  "Read unrecognized value ~D for enumeration type~@[ ~S~]~@[ in program ~A~]" KEY                  TYPE (AND *PROGRAM* (RPC-PROGRAM-NAME *PROGRAM*)))          KEY)       (WRITE (ERROR "~S not a valid value for enumeration type~@[ ~S~]~@[ in program ~A~]" KEY TYPE                     (AND *PROGRAM* (RPC-PROGRAM-NAME *PROGRAM*))))))(DEFUN XDR-MAKE-OPAQUE (BYTECOUNT &OPTIONAL ELEMENT-TYPE)   "Create an XDR object of type (:opaque bytecount element-type) initialized to zero."   (IF (EQ ELEMENT-TYPE :UNBOXED)       (IL:\\ALLOCBLOCK (ASH (+ BYTECOUNT 3)                             -2))       (MAKE-ARRAY BYTECOUNT :ELEMENT-TYPE (OR ELEMENT-TYPE 'STRING-CHAR))))(IL:* IL:\; "These are for backward compatibility")(DEFUN XDR-BOOLEAN (XDRSTREAM &OPTIONAL (VALUE T WRITEP))   (COND      (WRITEP (PUTCELL XDRSTREAM (IF (NULL VALUE)                                     0                                     1)))      (T (SETQ VALUE (GETCELL XDRSTREAM))         (CCASE VALUE (0 NIL)                (1 T)))))(DEFUN XDR-INTEGER (XDRSTREAM &OPTIONAL (VALUE NIL WRITEP))   (COND      (WRITEP (CHECK-TYPE VALUE INTEGER)             (PUTCELL XDRSTREAM VALUE))      (T (GETCELL XDRSTREAM))))(DEFUN XDR-UNSIGNED (XDRSTREAM &OPTIONAL (VALUE NIL WRITEP))   (IF WRITEP       (PUTUNSIGNED XDRSTREAM VALUE)       (GETUNSIGNED XDRSTREAM)))(DEFUN XDR-HYPERINTEGER (XDRSTREAM &OPTIONAL (VALUE NIL WRITEP))   (COND      (WRITEP (XDR-WRITE-HYPERINTEGER XDRSTREAM VALUE))      (T (XDR-READ-HYPERINTEGER XDRSTREAM))))(DEFUN XDR-HYPERUNSIGNED (XDRSTREAM &OPTIONAL (VALUE NIL WRITEP))   (COND      (WRITEP (XDR-WRITE-HYPERUNSIGNED XDRSTREAM VALUE))      (T (XDR-READ-HYPERUNSIGNED XDRSTREAM))))(DEFUN XDR-STRING (XDRSTREAM &OPTIONAL (STRING NIL WRITEP))   (COND      (WRITEP (CHECK-TYPE STRING STRING)             (WHEN (AND (IL:%FAT-STRING-ARRAY-P STRING)                        (IL:%FAT-STRING-ARRAY-P (SETQ STRING (COPY-SEQ STRING))))                                                             (IL:* IL:\; "Only 8-bit chars supported in xdr.  COPY-SEQ is just in case it was all thin chars in a formerly fat string.")                 (ERROR "XDR string contains NS characters: ~S" STRING))             (LET ((NBYTES (IL:NCHARS STRING)))                  (XDR-UNSIGNED XDRSTREAM NBYTES)                  (PUTRAWBYTES XDRSTREAM (VECTOR-BASE STRING)                         (VECTOR-OFFSET STRING)                         NBYTES)                  (ZEROBYTES XDRSTREAM (PADDING-BYTES NBYTES))))      (T (LET* ((NBYTES (XDR-UNSIGNED XDRSTREAM))                (STRING (IL:ALLOCSTRING NBYTES)))               (GETRAWBYTES XDRSTREAM (VECTOR-BASE STRING)                      0 NBYTES)               (SKIPBYTES XDRSTREAM (PADDING-BYTES NBYTES))               STRING))))(DEFUN XDR-STRING-POINTER (XDRSTREAM &OPTIONAL (VALUE T WRITEP))   "This is a gross hack to handle what amounts to bulk data."   (IF WRITEP       (LET* ((BUFFER (CAR VALUE))              (NBYTES (CDR VALUE))              (OUTSTREAM (RPC-STREAM-OUTSTREAM XDRSTREAM))              (OFFSET 0))                                    (IL:* IL:\; "Value is ((buffer . offset) . nbytes), where the first element can be just buffer if offset is zero.")             (WHEN (CONSP BUFFER)                 (SETQ OFFSET (CDR BUFFER)                       BUFFER                       (CAR BUFFER)))             (XDR-UNSIGNED XDRSTREAM NBYTES)             (PUTRAWBYTES XDRSTREAM BUFFER OFFSET NBYTES)             (ZEROBYTES XDRSTREAM (PADDING-BYTES NBYTES)))       (LET* ((NBYTES (XDR-UNSIGNED XDRSTREAM))              (PLACE (GETOFFSET XDRSTREAM))              (PACKET (CAR PLACE))              (BYTEOFFSET (CDR PLACE)))             (IL:* IL:|;;| "This only works for UDP!!")             (IL:* IL:|;;| "Returns ((packet . byteoffset) . number-of-bytes))")             (PROG1 (CONS (CONS PACKET BYTEOFFSET)                          NBYTES)                 (SKIPBYTES XDRSTREAM (PADDING-BYTES NBYTES))))))(DEFUN XDR-FLOAT (XDRSTREAM &OPTIONAL (V NIL WRITEP))   (IL:* IL:|;;| "Read or write a single-precision IEEE floating point number.  Fortunately, that's our internal format as well.")   (IF WRITEP       (PUTRAWBYTES XDRSTREAM (IL:\\DTEST V 'FLOATP)              0 4)       (LET ((VALUE (IL:NCREATE 'IL:FLOATP)))            (GETRAWBYTES XDRSTREAM VALUE 0 4))))(DEFUN XDR-VOID (XDRSTREAM &OPTIONAL (VALUE T WRITEP))   NIL)(DEFUN XDR-OPAQUE-PRIMITIVE (XDRSTREAM NBYTES &OPTIONAL (STRING NIL WRITEP))   (IL:* IL:|;;| "Strictly for backward-compatibility with old compiled rpc code")   (COND      (WRITEP (PUTRAWBYTES XDRSTREAM (IL:|fetch| (IL:STRINGP IL:BASE) IL:|of| STRING)                     (IL:|fetch| (IL:STRINGP IL:OFFST) IL:|of| STRING)                     NBYTES)             (UNLESS (EQL (SETQ NBYTES (LOGAND NBYTES 3))                          0)                 (DOTIMES (I (- 4 NBYTES))                     (PUTBYTE XDRSTREAM 0))))      (T (LET ((STRING (IL:ALLOCSTRING NBYTES)))              (GETRAWBYTES XDRSTREAM (IL:|fetch| (IL:STRINGP IL:BASE) IL:|of| STRING)                     (IL:|fetch| (IL:STRINGP IL:OFFST) IL:|of| STRING)                     NBYTES)              (UNLESS (EQL (SETQ NBYTES (LOGAND NBYTES 3))                           0)                  (DOTIMES (I (- 4 NBYTES))                      (GETBYTE XDRSTREAM)))              STRING))))(IL:PUTPROPS IL:RPCXDR IL:COPYRIGHT ("Stanford University and Xerox Corporation" 1987 1988 1990))(IL:DECLARE\: IL:DONTCOPY  (IL:FILEMAP (NIL)))IL:STOP