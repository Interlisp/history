(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE (DEFPACKAGE "NFS" (USE "LISP" "XCL")))(il:filecreated "14-Nov-89 18:47:23" "{piglet/n}<piglet>nfs>sources>NFSDEVICE;50" 152955       il:|changes| il:|to:|  (il:vars il:nfsdevicecoms) (il:functions nfs-nextfilefn create-nfshost-device clear-server-cache unmount-all)      il:|previous| il:|date:| "27-Oct-89 12:11:36" "{piglet/n}<piglet>nfs>sources>NFSDEVICE;49"); Copyright (c) 1988, 1989 by Xerox Corporation.  All rights reserved.(il:prettycomprint il:nfsdevicecoms)(il:rpaqq il:nfsdevicecoms ((il:* il:|;;| "SUN RPC-BASED NETWORK FILE SERVICE") (il:* il:|;;| "This file requires that exports be loaded in order to compile") (eval-when (eval compile) (il:prop (il:makefile-environment il:filetype) il:nfsdevice) (il:files il:nfsdecls)) (eval-when (eval compile load) (il:p (export (quote (*nfs-default-file-protection* *nfs-default-directory-protection* *nfs-default-timeout* *directory-cache-timeout* *nfs-cache-vars* *nfs-debug* *preserve-case* *always-write-version* *ns-to-yp-domain* *use-volume-map* *directory-follow-links* clear-server-cache find-volume linkfile))) (il:* il:\; "Note: have to export FIND-VOLUME here, since we refer to it without knowing whether NFSVOLUME will be loaded"))) (il:variables *preserve-case* *always-write-version* *ns-to-yp-domain* *use-volume-map* *nfs-default-file-protection* *nfs-default-directory-protection* *nfs-default-timeout* *nfs-cache-vars* *nfs-debug* *nfs-ok-to-time-out* *unspecified-time* *rfd-overhead-bytes*) (il:addvars (*nfs-cache-vars* rpc2:*rpc-socket-cache*) (il:\\systemcachevars rpc2:*rpc-socket-cache*)) (il:* il:\; "latter should be on rpc") (il:coms (il:* il:\; "RPC shorthand functions ") (il:functions nfs-rpc-create-link nfs-rpc-get-file-attributes nfs-rpc-rename-file nfs-rpc-read-link nfs-rpc-lookup-file nfs-rpc-delete-file nfs-dir-op nfs-rpc nfs-mount-rpc nfs-status-to-string)) (il:coms (il:* il:\; "Device/Host Information Blocks") (il:structures deviceinfo) (il:functions device-info print-deviceinfo)) (il:coms (il:* il:\; "File Information Blocks") (il:structures fileinfo) (il:functions close-fileinfo print-fileinfo)) (il:coms (il:* il:\; "Create an NFS Device") (il:functions nfs-hostnamep create-nfshost-device open-deviceinfo make-nfs-rpc-stream close-deviceinfo revalidate-deviceinfo nfs-breakconnection nfs-eventfn nfs-timeout-handler)) (il:coms (il:* il:\; "DirectoryNameP") (il:functions nfs-getfilename nfs-directorynamep)) (il:coms (il:* il:\; "Open File") (il:functions nfs-openfile openfile-access-test compute-initial-length) (il:functions nfs-getfile getfileinfo-old openfile-new create-empty-file try-to-lock-file-crock openfile-set-version fix-up-unlinked-versionless-file find-symbolic-link-target parse-link-name highest-version-in-list lowest-version-in-list) (il:* il:\; "Reopen & validate") (il:functions getvalidation revalidate-stream nfs-openp nfs-unregisterfile) (il:* il:\; "Close File") (il:functions nfs-closefile closef-replace-current-version relink-current-version relink-failed-msg closef-rename-tempfile closef-anchor-changed closef-filename-exists)) (il:coms (il:* il:\; "Delete File") (il:functions nfs-deletefile delete-directory nfs-openfile-p nfs-deletefile-versioned deletefile-failed)) (il:coms (il:* il:\; "Create directories") (il:functions create-directory create-missing-directories)) (il:coms (il:* il:\; "Stream operations") (il:functions nfs-readpages nfs-readpage) (il:functions nfs-writepages nfs-writepage) (il:functions nfs-truncatefile pad-stream-with-zeros nfs-seteofptr)) (il:coms (il:* il:\; "Rename File") (il:functions nfs-renamefile rename-directory linkfile)) (il:coms (il:* il:\; "Get / Set  File Information") (il:functions nfs-getfileinfo nfs-setfileinfo setfileinfo-internal refresh-fileinfo-fattr attribute-from-fattr)) (il:coms (il:* il:\; "Directory Enumeration") (il:structures dirgen) (il:functions nfs-generatefiles make-file-generator nfs-nextfilefn nfs-fileinfofn gfs-chase-link gfs-lookup gfs-match gfs-recur)) (il:coms (il:* il:\; "Name parsing and reassembly") (il:structures nfspath) (il:functions print-nfspath nfs-namestring unix-dir-from-list nfs-parse-namestring parse-dir-string adjust-volume rootname-from-pathname rawname-from-pathname make-versioned-filename downcase-unquoted-chars)) (il:coms (il:* il:\; "NFS Utilities") (il:variables *temp-filename-counter*) (il:functions escape-uppercase-chars lookup-home-dir temp-name-for-file make-temp-filename reset-nfs-cache-vars local-machine-name versions-from-hashentry version-from-fileid)) (il:coms (il:* il:\; "error handling") (il:functions nfs-handle-error stream-changed proceedable-error destroy-stream)) (il:coms (il:* il:\; "Directory Cache") (il:variables *directory-cache-timeout*) (il:structures dirinfo) (il:functions print-dirinfo nice-date-string get-directory get-directory-cache refresh-dirinfo find-directory-info refresh-dirinfo-fattr unixtime-greaterp encache-directory add-file-to-dircache delete-file-from-dircache highest-version-present-or-reserved clear-server-cache destroy-dirinfo unmount unmount-all)) (il:coms (il:* il:\; "Credentials") (il:structures nfscredentials) (il:variables *nfs-credentials* *nfs-credentials-cache* *last-cache-cleared*) (il:addvars (il:\\systemcachevars *nfs-credentials* *nfs-credentials-cache*) (*nfs-cache-vars* *nfs-credentials* *nfs-credentials-cache*) (il:\\afterloginfns reset-nfscredentials-cache)) (il:functions dinfo-credentials get-nfscredentials get-uid-with-domain reset-nfscredentials-cache)) (il:coms (il:* il:\; "Unix Time/Date Stuff") (il:variables *unix-start-idate*) (il:functions unix-to-idate idate-to-unix)) (il:coms (il:* il:\; "Get started") (eval-when (load) (il:p (il:\\definedevice nil (record-create fdev :hostnamep (quote nfs-hostnamep) :devicename (quote nfsdevice) :eventfn (quote il:nill))) (il:\\definedevice (quote il:nfs) (create-nfshost-device (quote il:nfs))))))))(il:* il:|;;| "SUN RPC-BASED NETWORK FILE SERVICE")(il:* il:|;;| "This file requires that exports be loaded in order to compile")(eval-when (eval compile)(il:putprops il:nfsdevice il:makefile-environment (:readtable "XCL" :package (defpackage "NFS" (:use "LISP" "XCL"))))(il:putprops il:nfsdevice il:filetype :compile-file)(il:filesload il:nfsdecls))(eval-when (eval compile load)(export (quote (*nfs-default-file-protection* *nfs-default-directory-protection* *nfs-default-timeout* *directory-cache-timeout* *nfs-cache-vars* *nfs-debug* *preserve-case* *always-write-version* *ns-to-yp-domain* *use-volume-map* *directory-follow-links* clear-server-cache find-volume linkfile)))(il:* il:\; "Note: have to export FIND-VOLUME here, since we refer to it without knowing whether NFSVOLUME will be loaded"))(defvar *preserve-case* nil "If true, new files are created in the exact case given to OPENSTREAM")(defvar *always-write-version* nil "If true, will always create a file with a version number on it, even if it is the only version and is number 1.")(defglobalvar *ns-to-yp-domain* nil "A-list associating NS domain with corresponding YP domain.  If NS domain is ambiguous, the translation is to an a-list by NS organization.")(defglobalvar *use-volume-map* nil "If true, automatically locate hosts using yp map auto.volume.")(defparameter *nfs-default-file-protection* nil "Default protection for new regular files. NIL => inherit from parent")(defparameter *nfs-default-directory-protection* nil "Default protection for directories we create.  NIL => inherit from parent.")(defvar *nfs-default-timeout* 30000 "Length of time (msec) to wait before complaining that a server is not responding")(defvar *nfs-cache-vars* nil)(defvar *nfs-debug* nil "Set to various values when debugging")(defvar *nfs-ok-to-time-out* nil "True in contexts where I'm willing to ignore timeouts.")(defglobalparameter *unspecified-time* (make-unixtime :seconds -1 :useconds -1))(defglobalparameter *rfd-overhead-bytes* 120 "Read-From-Directory reply packet may contain as much as this many bytes (incl header, etc) in addition to what we asked for." (il:* il:\; "Most I've seen needed so far is 102 (Dorado) or 112 (Daybreak), but good to have some slop."))(il:addtovar *nfs-cache-vars* rpc2:*rpc-socket-cache*)(il:addtovar il:\\systemcachevars rpc2:*rpc-socket-cache*)(il:* il:\; "latter should be on rpc")(il:* il:\; "RPC shorthand functions ")(defun nfs-rpc-create-link (fileid dirinfo filename dinfo) (nfs-rpc dinfo *create-link-to-file* (list fileid (make-diropargs :dir (dirinfo-dirhandle dirinfo) :name filename))))(defun nfs-rpc-get-file-attributes (filehandle dinfo) (nfs-rpc dinfo *get-file-attributes* (list filehandle)))(defun nfs-rpc-rename-file (old-dirhandle old-filename new-dirhandle new-filename dinfo) (nfs-rpc dinfo *rename-file* (list (make-diropargs :dir old-dirhandle :name old-filename) (make-diropargs :dir new-dirhandle :name new-filename))))(defun nfs-rpc-read-link (fhandle dinfo) (nfs-rpc dinfo *read-from-symbolic-link* (list fhandle)))(defun nfs-rpc-lookup-file (dinfo dirinfo/finfo filename) (nfs-dir-op dinfo *lookup-file-name* dirinfo/finfo filename))(defun nfs-rpc-delete-file (dinfo dirinfo/finfo filename) (nfs-dir-op dinfo *remove-file* dirinfo/finfo filename))(defun nfs-dir-op (dinfo op dirinfo/finfo name &optional restargs) (il:* il:|;;| "Perform a \"directory operation\", one that has a diropargs argument consisting of the directory handle given in DIRINFO/FINFO and name NAME.  If the operation takes additional arguments, they are in RESTARGS.") (let ((dirinfo (etypecase dirinfo/finfo (dirinfo dirinfo/finfo) (fileinfo (fileinfo-dirinfo dirinfo/finfo))))) (first (nfs-rpc-call dinfo *nfs-program* (if (integerp op) (aref *nfs-proc-vector* op) op) (cons (make-diropargs :dir (dirinfo-dirhandle dirinfo) :name name) restargs)))))(defun nfs-rpc (dinfo proc arglist) (il:* il:|;;| "Call NFS procedure PROC on ARGLIST for server specified by DINFO.  Since all NFS rpc calls return a single result, we return the single result, rather than (LIST result).") (first (nfs-rpc-call dinfo *nfs-program* (if (integerp proc) (aref *nfs-proc-vector* proc) proc) arglist)))(defun nfs-mount-rpc (dinfo proc arglist) (nfs-rpc-call dinfo *mount-program* (if (integerp proc) (aref *mount-proc-vector* proc) proc) arglist))(defun nfs-status-to-string (status) (il:* il:|;;| "Return a human-readable string for this error code") (macrolet ((compute-cases nil (il:* il:\; "What a kludge--compose a case statement out of this compile-time list.") (il:bquote (case status (il:\\\,@ (mapcar (function cdr) *nfs-status-codes*)) (otherwise status))))) (compute-cases)))(il:* il:\; "Device/Host Information Blocks")(defstruct (deviceinfo (:print-function print-deviceinfo)) "Info Specific to NFS/HOST. This info is assumed not to change, but it may be reset using NFS-DEVICEINFO-RESET." host (il:* il:\; "Hostname (Uppercase Symbol)") downhost (il:* il:\; "string-downcase of HOST field ") destaddr (il:* il:\; "IP address for remote host") rpcstream (il:* il:\; "RPC Stream used for this host") directories (il:* il:\; "Caches of directories on this host") monitorlock (il:* il:\; "Lock on DIRECTORIES") mounts (il:* il:\; "List of exported file systems") openfiles (il:* il:\; "List of open streams (maintained by OPENFILE and CLOSEF)"))(defmacro device-info (device) (il:bquote (il:fetch (il:fdev il:deviceinfo) il:of (il:\\\, device))))(defun print-deviceinfo (obj stream depth) (format stream "#<Deviceinfo for ~a>" (deviceinfo-host obj)))(il:* il:\; "File Information Blocks")(defstruct (fileinfo (:print-function print-fileinfo)) "Info Specific to a remote file. This structure usually resides in a stream, but need not." filepath (il:* il:\; "Parsed pattern (a PATHNAME)") fattr (il:* il:\; "Unix FATTR") dirinfo (il:* il:\; "Handle on parent directory") filehandle (il:* il:\; "FHandle of remote file") rawname (il:* il:\; "Name as stored on server") plist (il:* il:\; "Properties not deserving of whole slots... "))(defun close-fileinfo (finfo dinfo) "Undo any state in a FILEINFO" (il:* il:|;;| "None at this time.") nil)(defun print-fileinfo (object stream depth) (let ((path (fileinfo-filepath object))) (format stream "#<Fileinfo ~a ~o,~o>" (if (nfspath-p path) (nfs-namestring path) path) (il:\\hiloc object) (il:\\loloc object))))(il:* il:\; "Create an NFS Device")(defun nfs-hostnamep (hostname &optional device) (il:* il:|;;| "If HOSTNAME names an nfs host, return device for it.  To avoid name space conflicts, nfs hosts by convention end in /n.") (il:* il:|;;| "&OPTIONAL for DEVICE because IL:HOSTNAMEP calls this method without passing the device (seems like a bug).") (let ((hoststring (typecase hostname (symbol (symbol-name hostname)) (string hostname) (t nil))) len dinfo) (when (and hoststring (> (setq len (length hoststring)) 2) (char= (char hoststring (- len 2)) #\/) (char= (char-upcase (char hoststring (- len 1))) #\N)) (cond ((setq dinfo (open-deviceinfo hostname)) (create-nfshost-device hostname dinfo)) ((string-equal hoststring "NFS/N") (il:* il:\; "Another name for {NFS}") (il:\\getdevicefromname (quote il:nfs) t t))))))(defun create-nfshost-device (hostname &optional dinfo) "Create FDEV instance for a specific NFS Host" (let ((dev (il:\\make.pmap.device (record-create fdev :devicename hostname :directorynamep (quote nfs-directorynamep) :openfile (quote nfs-openfile) :getfilename (quote nfs-getfilename) :deletefile (quote nfs-deletefile) :generatefiles (quote nfs-generatefiles) :renamefile (quote nfs-renamefile) :getfileinfo (quote nfs-getfileinfo) :setfileinfo (quote nfs-setfileinfo) :breakconnection (quote nfs-breakconnection))))) (cond (dinfo (il:* il:\; "Actual device, not NFS pseudo-device") (setf (record-fetch fdev il:eventfn dev) (quote nfs-eventfn) (record-fetch fdev il:closefile dev) (quote nfs-closefile) (record-fetch fdev il:openp dev) (quote nfs-openp) (record-fetch fdev il:unregisterfile dev) (quote nfs-unregisterfile) (il:* il:\; "We register in openfile.  We'd unregister in closefile, but pragmatic considerations suggest otherwise.") (record-fetch fdev il:readpages dev) (quote nfs-readpages) (record-fetch fdev il:writepages dev) (quote nfs-writepages) (record-fetch fdev il:truncatefile dev) (quote nfs-truncatefile) (record-fetch fdev il:seteofptr dev) (quote nfs-seteofptr) (record-fetch fdev il:deviceinfo dev) dinfo) (let ((*nfs-default-timeout* 2000)) (il:* il:|;;| "In case we crashed earlier, clear the mount table.") (unmount-all dinfo))) (t (il:* il:\; "Pseudo-dev merely annihilates itself if it wakes up on Sun") (setf (record-fetch fdev il:eventfn dev) (function (lambda (device event) (case event ((il:afterlogout il:aftersysout il:aftermakesys il:aftersavevm) (il:* il:\; "On Sun, die") (when (eq (il:machinetype) (quote il:maiko)) (il:\\removedevice device))))))))) dev))(defun open-deviceinfo (hostname) (setq hostname (string hostname)) (let* ((len (length hostname)) (destaddr (rpc2:find-rpc-host (if (and (eql #\/ (elt hostname (- len 2))) (char-equal #\N (elt hostname (- len 1)))) (il:* il:\; "Get rid of the trailing /N") (subseq hostname 0 (- len 2)) hostname)))) (and destaddr (make-deviceinfo :host hostname :downhost (string-downcase hostname) :rpcstream (make-nfs-rpc-stream hostname destaddr) :destaddr destaddr :monitorlock (il:create.monitorlock hostname)))))(defun make-nfs-rpc-stream (hostname addr) (il:* il:|;;| "Create an RPC stream for use with NFS to this host") (let ((stream (rpc2:open-rpcstream (quote rpc2:udp) addr (quote nfs) nil (function nfs-timeout-handler)))) (setf (rpc2:rpc-stream-private stream) hostname) (il:* il:\; "So that we can get from the stream to the host name") stream))(defun close-deviceinfo (dinfo) "Undo any effects of OPEN-DEVICEINFO" (when (deviceinfo-rpcstream dinfo) (rpc2:close-rpcstream (deviceinfo-rpcstream dinfo))) (setf (deviceinfo-rpcstream dinfo) nil (deviceinfo-directories dinfo) nil))(defun revalidate-deviceinfo (dinfo) (il:* il:|;;| "If this deviceinfo has been closed due to an event, re-open it.") (when (null (deviceinfo-rpcstream dinfo)) (setf (deviceinfo-rpcstream dinfo) (make-nfs-rpc-stream (deviceinfo-host dinfo) (deviceinfo-destaddr dinfo)))))(defun nfs-breakconnection (host dev &optional fast) (il:* il:|;;| "Forget everything we know about this host") (let ((dinfo (device-info dev)) (elapsed (- (get-meta-timestamp) *last-cache-cleared*))) (when dinfo (clear-server-cache dinfo nil fast) (close-deviceinfo dinfo) (unless (deviceinfo-openfiles dinfo) (il:* il:\; "Kill the device, too") (il:\\removedevice dev))) (when (> elapsed 10) (il:* il:|;;| "Don't do this if we cleared it less than 10 seconds ago--probably from a BREAKCONNECTION(T)--we would just have to spend a long time recomputing our credentials.  Compare to time at entry, since the CLEAR-SERVER-CACHE could have taken a while.") (reset-nfs-cache-vars)) (setq *last-cache-cleared* (get-meta-timestamp)) host))(defun nfs-eventfn (device event) (let* ((dinfo (device-info device)) (opened (deviceinfo-openfiles dinfo)) rpcstream) (case event ((il:beforelogout) (when (setq rpcstream (deviceinfo-rpcstream dinfo)) (il:with.monitor (rpc2:rpc-stream-monitorlock rpcstream) (dolist (stream opened) (il:* il:\; "Worry about files open over logout") (when (il:dirtyable stream) (force-output stream)) (il:* il:\; "Assure buffered data written") (let* ((finfo (stream-info stream)) (lockfilename (getf (fileinfo-plist finfo) (quote lockfilename)))) (il:* il:|;;| "Delete any lock files; arrange to relock after logout") (when (consp lockfilename) (nfs-rpc-delete-file dinfo finfo (first lockfilename)) (setf (getf (fileinfo-plist finfo) (quote lockfilename)) :relock)))) (cond (nil (il:* il:\; "This call fails") (let ((*nfs-ok-to-time-out* t)) (il:* il:\; "Tell the server we have no further interest") (nfs-mount-rpc dinfo (quote remove-all-mount-entries) nil))) (t (clear-server-cache dinfo)))))) ((il:afterlogout il:aftersysout il:aftermakesys il:aftersavevm) (il:* il:|;;| "Kill the Socket and Directory Caches. They could have changed. Don't reopen the deviceinfo or the streams at this point; reopen them when they're touched..") (close-deviceinfo dinfo) (il:* il:\; "Undo any state in  the DEVICEINFO") (cond (opened (dolist (stream opened) (il:* il:|;;| "Undo any state in FILEINFO of each open stream on device") (setf (fileinfo-filehandle (stream-info stream)) nil))) (t (il:* il:\; "No open streams, so flush the device") (il:\\removedevice device)))))))(defun nfs-timeout-handler (rpcstream count) (il:* il:|;;| "Called when RPC times out.  COUNT is the number of times the handler has been called") (cond (*nfs-ok-to-time-out* (il:* il:\; "Make the call return NIL") nil) (t (when (eql (mod count 10) 1) (prompt-format "~%Host ~A ~@[still ~]not responding; will keep trying." (rpc2:rpc-stream-private rpcstream) (not (eql count 1)))) (il:* il:|;;| "Returning :CONTINUE means to keep trying the call.  Might want to have special cases where we cause, say, INFILEP to return NIL.") :continue)))(il:* il:\; "DirectoryNameP")(defun nfs-getfilename (name recog device) "Performs recognition on NAME.  Returns full name of the file that would be opened by OPENFILE method in RECOG recognition mode, or NIL if the file is not found." (declare (special il:*upper-case-file-names*)) (let ((newname (nfs-getfile device name nil recog (quote name)))) (when (and newname il:*upper-case-file-names*) (setq newname (il:mkatom (string-upcase newname)))) (when *nfs-debug* (format t "NFS-GETFILENAME returns ~a~%" newname)) newname))(defun nfs-directorynamep (host/dir device &optional create?) (multiple-value-bind (path device) (nfs-parse-namestring host/dir device) (and path (let* ((dinfo (device-info device)) (dirinfo (get-directory path dinfo))) (cond ((or dirinfo (and create? (il:* il:\; "Will try to create if it doesn't have unrecognized ~ spec and user confirms (or doesn't need to)") (not (eql (char (car (last (nfspath-directory path))) 0) #\~)) (or (not (eq create? (quote il:ask))) (y-or-n-p "Directory ~a not found.  Create it and all missing superiors? " (nfs-namestring path))) (setq dirinfo (create-missing-directories path dinfo)))) (let ((path (nfs-namestring (dirinfo-path dirinfo)))) (if (and (symbolp host/dir) il:*upper-case-file-names*) (il:mkatom (string-upcase path)) path))))))))(il:* il:\; "Open File")(defun nfs-openfile (filename access recog parameters device) "Open a new or old file or or closed stream" (multiple-value-bind (finfo dinfo) (nfs-getfile device filename access recog (quote open) parameters) (cond (finfo (il:* il:\; "success.  Finish the stuff we need to do to make a stream") (let ((creationdate (second (assoc (quote il:creationdate) parameters))) (type (second (assoc (quote type) parameters))) (fullname (nfs-namestring (fileinfo-filepath finfo))) (fattr (fileinfo-fattr finfo)) stream open) (declare (special il:*upper-case-file-names*)) (when (and (setq open (nfs-openfile-p dinfo fullname)) (not (and (eq access (quote il:input)) (eql 0 (logand (record-fetch stream accessbits open) il:|WriteBit|))))) (il:* il:|;;| "File is already open for conflicting access.  The only time there is no conflict is opening for INPUT when the other stream is also INPUT") (error (quote file-wont-open) :pathname fullname)) (openfile-access-test finfo dinfo access) (when creationdate (il:* il:\; "Remember creationdate for close") (setf (getf (fileinfo-plist finfo) (quote creationdate)) creationdate)) (il:* il:|;;| "Create and initialize stream  (always make a new one)") (setq stream (il:|create| stream il:device il:_ (cond ((eq (device-info device) dinfo) device) (t (il:* il:\; "We crossed hosts") (il:\\getdevicefromhostname (il:mkatom (deviceinfo-host dinfo))))))) (setf (stream-info stream) finfo) (il:|replace| il:binable il:|of| stream il:|with| t) (il:|replace| il:boutable il:|of| stream il:|with| t) (il:|replace| il:fullfilename il:|of| stream il:|with| (if il:*upper-case-file-names* (il:mkatom (string-upcase fullname)) fullname)) (il:|replace| il:eolconvention il:|of| stream il:|with| (if (if type (not (eq type (quote il:text))) (fattr-binaryp fattr)) (il:* il:\; "If user called it anything but TEXT, or the file's binary bit is on, use CR.") il:cr.eolc il:lf.eolc)) (compute-initial-length stream access) (setf (stream-validation stream) (getvalidation fattr)) (push stream (deviceinfo-openfiles dinfo)) (when *nfs-debug* (format *debug-io* "NFS-OPENFILE exited. Returned ~A~%" stream)) stream)))))(defun openfile-access-test (finfo dinfo access) (il:* il:|;;| "True if we have the desired access to the file.") (fix-this (il:* il:|;;| "Tests whether we have read access to file by trying to read it.") (il:* il:|;;| "Should just check access bits.  Check output access, too?  Usually failed already by not being able to (a) create the file [new] or (b) create the lock file [old].  However, could be funny protection cases.")) (let ((status (nfs-rpc dinfo *null-read-from-file* (list (fileinfo-filehandle finfo) 0 1 0)))) (cond ((eq status nfs-ok) t) (t (nfs-handle-error status "Open" (fileinfo-filepath finfo) t)))))(defun compute-initial-length (stream access) (il:* il:|;;| "Set the CPAGE, COFFSET, EPAGE, EOFFSET fields appropriately for a newly opened stream") (let* ((finfo (stream-info stream)) (len (fattr-size (fileinfo-fattr finfo))) (epage (ash len (- logbytesperpage))) (eoffset (logand len (1- bytesperpage)))) (cond ((eq access (quote il:append)) (il:* il:\; "Current pointer is at end") (setf (record-fetch stream cpage stream) epage (record-fetch stream coffset stream) eoffset)) (t (il:* il:\; "Current pointer is at beginning") (setf (record-fetch stream cpage stream) 0 (record-fetch stream coffset stream) 0) (when (and (eq access (quote il:output)) (> len 0)) (il:* il:\; "Opening old file for output; truncate now.") (setfileinfo-internal (device-info (stream-device stream)) finfo (quote il:length) (setq epage (setq eoffset 0)))))) (setf (stream-epage stream) epage) (setf (stream-eoffset stream) eoffset)))(defun nfs-getfile (device filename access recog option &optional parameters source-path) (il:* il:|;;| "Get a handle on FILENAME.  OPTION is one of OPEN, NAME, HANDLE.  PARAMETERS is either the alist given to OPENSTREAM, or one of the symbols DELETE-FILE, RENAME-FILE for special handling for those operations.  SOURCE-PATH is the source pathname for a RENAME-FILE.") (when (typep filename (quote stream)) (when (il:opened filename) (error "Stream is already open: ~S" filename)) (setq filename (il:|ffetch| il:fullfilename il:|of| filename))) (let ((outputp (member access (quote (il:output il:both il:append)) :test (function eq))) dinfo oldp path finfo version exactversion dirinfo table entry versionset versentry namestring tmp) (multiple-value-setq (path device) (nfs-parse-namestring filename device)) (il:* il:\; "Note that NFS-PARSE-NAMESTRING guarantees to produce a new path") (unless path (when *nfs-debug* (format *debug-io* "Cannot parse path ~A~%" filename)) (return-from nfs-getfile nil)) (setq dinfo (device-info device)) (cond ((or (nfspath-namebody path) (nfspath-version path)) (il:* il:\; "Ordinary file, will look it up like this")) ((or (eq option (quote open)) (eq recog (quote il:new))) (il:* il:\; "Can't open a directory or recognize a new version") (return-from nfs-getfile nil)) (t (il:* il:\; "Is a directory") (il:* il:|;;| "Kludge: make this look like a file in the parent directory") (let ((dirlist (nfspath-directory path))) (setf (nfspath-directory path) (cdr dirlist) (nfspath-namebody path) (car dirlist))))) (unless (eq recog (quote il:exact)) (il:* il:\; "We'll need to do recognition") (setq version (setq exactversion (nfspath-version path))) (when (or (not outputp) (and (not exactversion) (or (eq recog (quote il:old)) (eq recog (quote il:oldest))))) (il:* il:\; "We know we're not going to create the file.  So set OLDP true") (unless (and (eq option (quote name)) (or (eq recog (quote il:new)) (eq recog (quote il:old/new)))) (il:* il:\; "Except on calls from GETFILENAME in output recognition, where we still want an answer") (setq oldp t))) (cond ((and (setq dirinfo (get-directory path dinfo nil t)) (setq table (dirinfo-hashtable dirinfo))) (setq entry (gethash (setq namestring (rootname-from-pathname path)) table))) (t (il:* il:\; "Directory not found") (when oldp (il:* il:\; "Not going to create it") (return-from nfs-getfile nil)))) (cond ((null entry) (il:* il:\; "No version exists") (when oldp (il:* il:\; "Not going to create it") (return-from nfs-getfile nil))) ((and (eq parameters (quote rename-file)) (string-equal namestring (rootname-from-pathname source-path)) (equalp (nfspath-directory path) (nfspath-directory source-path))) (il:* il:|;;| "Renaming a file to the same name, but different case.  Here's the one place where we violate our rule that we use the old case of the file when a version exists.  Force VERSIONSET to have the correct name by faking one if necessary") (unless *preserve-case* (il:* il:\; "Recompute NAMESTRING to be exactly what caller said if user doesn't already ask us to preserve case") (setq namestring (let ((*preserve-case* t)) (rootname-from-pathname path)))) (setq versionset (or (versions-from-hashentry namestring entry) (list namestring)))) (t (il:* il:\; "At least one version in some spelling") (cond ((null (cdr entry)) (il:* il:\; "Only one spelling--use it.") (setq namestring (car (setq versionset (car entry))))) ((setq versionset (versions-from-hashentry namestring entry)) (il:* il:\; "Found this spelling ok")) (oldp (il:* il:\; "Not creating, and didn't find matching case") (return-from nfs-getfile nil))) (cond ((null versionset) (il:* il:\; "No versions yet, so if we've gotten this far, it must be either EXACTVERSION or version 1")) (exactversion (il:* il:\; "Wants to access specific version") (cond ((setq versentry (assoc exactversion (cddr versionset))) (il:* il:\; "found it")) ((eql (car (setq tmp (highest-version-in-list versionset))) exactversion) (il:* il:\; "There's a versionless file with no matching versioned file, but the right number") (setq versentry tmp)) (oldp (il:* il:\; "Not found, and we won't create it") (return-from nfs-getfile nil)))) (t (il:* il:\; "Do version recognition from existing files") (setq version (case recog ((il:old il:old/new) (car (setq versentry (highest-version-in-list versionset)))) (il:oldest (car (setq versentry (lowest-version-in-list versionset)))) (il:new (il:* il:\; "Kludge for name right now") (and (eq option (quote name)) (1+ (car (highest-version-in-list versionset))))))))))) (progn (il:* il:|;;| "Canonicalize case") (let ((name.ext (or namestring (rootname-from-pathname path)))) (il:* il:\; "Fill in the right case for pathname.  Leave quotes in if there is ambiguity") (setf (nfspath-namebody path) (if (cdr entry) (escape-uppercase-chars name.ext) name.ext))) (when dirinfo (il:* il:\; "Also get directory case right") (setf (nfspath-directory path) (nfspath-directory (dirinfo-path dirinfo))))) (unless (or exactversion (and (eq recog (quote il:new)) (not (eq option (quote name))))) (il:* il:\; "Fill in the version number, except don't commit yet if writing new file") (setf (nfspath-version path) (or version 1))) (when (eq option (quote name)) (return-from nfs-getfile (nfs-namestring path nil (and versionset (null (cddr versionset)) (destructuring-bind (status result) (nfs-rpc-lookup-file dinfo dirinfo (car versionset)) (il:* il:\; "Do lookup to see if it's a directory") (cond ((eql status nfs-ok) (diropres-attributes result)) (t (il:* il:\; "Can't lookup file after all") (return-from nfs-getfile nil))))))))) (setq finfo (make-fileinfo :filepath path :dirinfo dirinfo)) (cond ((and (not versentry) (not (eq recog (quote il:exact)))) (il:* il:\; "Opening new file") (assert (eq option (quote open))) (openfile-new dinfo finfo parameters nil versionset)) ((cond ((eq recog (quote il:exact)) (let ((rawname (rootname-from-pathname path t))) (cond ((and (setq dirinfo (get-directory path dinfo :exact)) (progn (il:* il:\; "Directory exists, find file exactly") (setf (fileinfo-dirinfo finfo) dirinfo) (getfileinfo-old dinfo finfo rawname option))) (il:* il:\; "Found existing raw name")) (outputp (il:* il:\; "Create file.  This is the EXACT mode OPEN for output case.") (return-from nfs-getfile (openfile-new dinfo finfo parameters rawname)))))) (t (il:* il:\; "Look up the version we recognized") (getfileinfo-old dinfo finfo (let ((basename (car versionset))) (if (assoc version (cddr versionset)) (il:* il:\; "Have a versioned name, so use it in preference to the versionless name") (make-versioned-filename basename version) (il:* il:\; "No versioned link here") basename)) option))) (case option (name (il:* il:\; "Must be EXACT case, else we'd have handled this earlier") (nfs-namestring path nil (fileinfo-fattr finfo) (eq recog (quote il:exact)))) (t (when (eq option (quote open)) (il:* il:|;;| "We're going to open the file; be sure it's okay to be opened.") (loop (il:* il:\; "Make sure we have a normal file here.  Chase links in input case.") (unless (evalcase (fattr-type (fileinfo-fattr finfo)) (nfreg (il:* il:\; "Normal file") (return)) (nflnk (il:* il:\; "Read the link.  Don't write on it.") (and (not outputp) (multiple-value-setq (finfo dinfo) (find-symbolic-link-target dinfo finfo)))) (otherwise nil)) (error (quote file-wont-open) :pathname (nfs-namestring path nil (fileinfo-fattr finfo) (eq recog (quote il:exact)))))) (when (and outputp (not (eq parameters (quote rename-file)))) (il:* il:\; "Overwriting old file--do lock crock (DEVICE has not been reset in this case, so I don't have to recompute DINFO)") (try-to-lock-file-crock finfo dinfo))) (il:* il:\; "Return lots of stuff.") (values finfo dinfo versionset dirinfo)))) (t (il:* il:\; "File not found") nil))))(defun getfileinfo-old (dinfo finfo rawname &optional option) (il:* il:|;;| "Lookup hopefully existing file FINFO under specified raw name and fill in fattr.  Return NIL on failure.  OPTION is as with NFS-GETFILE.  If it is OPEN, we may signal an error if the lookup fails for any reason other than not found.") (destructuring-bind (status result) (nfs-rpc-lookup-file dinfo finfo rawname) (evalcase status (nfs-ok (setf (fileinfo-rawname finfo) rawname) (setf (fileinfo-filehandle finfo) (diropres-file result)) (setf (fileinfo-fattr finfo) (diropres-attributes result)) finfo) (nfs-err-noent (il:* il:\; "File not found") nil) (t (if (eq option (quote open)) (nfs-handle-error status "Open" (fileinfo-filepath finfo) t) (prompt-format "~&~A: ~A" (nfs-namestring (fileinfo-filepath finfo)) (nfs-status-to-string status))) nil))))(defun openfile-new (dinfo finfo parameters &optional exactname oldversions) (il:* il:|;;| "Creates a new file according to specified openfile PARAMETERS.  If DESIRED-VERSION is true, it means that the version in the path in FINFO is the exact one the user asked for; otherwise we may go for some other one.  If EXACTNAME is true, we are opening in EXACT recog, which means this is a raw unix name to use.") (let ((path (fileinfo-filepath finfo)) (dirinfo (fileinfo-dirinfo finfo)) oldfattr) (cond (dirinfo) ((setq dirinfo (or (get-directory path dinfo (and exactname :exact) t) (create-missing-directories path dinfo))) (il:* il:\; "Got handle of dir this way") (setf (fileinfo-dirinfo finfo) dirinfo)) (t (il:* il:\; "Couldn't create.  Usually have signaled an error by now") (return-from openfile-new nil))) (when (cdr oldversions) (il:* il:\; "Look up previous version to get default mode, check that it's not a directory") (let ((key (car oldversions)) (max 0) oldtype) (destructuring-bind (status result) (nfs-rpc-lookup-file dinfo dirinfo (if (second oldversions) (il:* il:\; "Easiest to lookup the \"current\" version") key (make-versioned-filename key (car (first (cddr oldversions)))))) (cond ((eq status nfs-ok) (evalcase (setq oldtype (fattr-type (setq oldfattr (diropres-attributes result)))) ((nflnk nfdir) (il:* il:\; "Link or directory") (prompt-format "~&Failed: ~A is a ~A" (nfs-namestring (if (nfspath-version path) (let ((newpath (copy-nfspath path))) (setf (nfspath-version newpath) nil) newpath) path)) (if (eql oldtype nflnk) "link" "directory")) (error (quote file-wont-open) :pathname (namestring path))))) (t (error "NFS: Couldn't check file ~a because ~a." key (nfs-status-to-string status))))))) (cond ((eq parameters (quote rename-file)) (il:* il:\; "Called from renamefile--don't go creating anything more, just return what we know") (values finfo dinfo oldversions)) (t (let ((tempname (or exactname (make-temp-filename))) (protection (or (second (assoc (quote il:protection) parameters)) (and oldfattr (logand (fattr-mode oldfattr) *mode-inheritable*)))) (type (second (assoc (quote type) parameters)))) (il:* il:|;;| "Cedar does protection (I think) by looking up the file .~mode in this dir (or first parent that has one) and using its mode bits.  Our default is to inherit from previous version, or inherit from parent directory.") (when (and type (not (eq type (quote il:text)))) (il:* il:\; "All non text types become one.") (setq type :binary)) (loop (il:* il:\; "In case of error") (destructuring-bind (status result) (create-empty-file dinfo dirinfo tempname type protection) (cond ((not (eq status nfs-ok)) (nfs-handle-error status (quote open) path)) (t (il:* il:\; "Created temp file ok") (setf (fileinfo-filehandle finfo) (diropres-file result)) (setf (fileinfo-fattr finfo) (diropres-attributes result)) (setf (fileinfo-rawname finfo) tempname) (unless exactname (il:* il:\; "Have to do the version mess now") (openfile-set-version dinfo finfo tempname oldversions)) (il:* il:|;;| "There used to be code here claiming there was some problem in creation getting the correct group id in the file.  Show me a case.  It's possible it's a feature.") (il:* il:|;;| "(let ((gid (nfscredentials-gid (dinfo-credentials dinfo)))) (unless (eq (fattr-gid (fileinfo-fattr finfo)) gid) (nfs-setfileinfo finfo 'il:group.id gid device)))") (return (values finfo dinfo)))))))))))(defun create-empty-file (dinfo dirinfo name &optional type protection) (il:* il:|;;| "Create a new, empty file.  TYPE may be :DIRECTORY, :BINARY or NIL.  PROTECTION overrides defaults.") (nfs-dir-op dinfo (if (eq type :directory) *create-directory* *create-file*) dirinfo name (list (let* ((cred (dinfo-credentials dinfo)) (fattr (dirinfo-fattr dirinfo)) (dirmode (fattr-mode fattr))) (make-sattr :mode (if (eq type :directory) (logior *mode-directory* (or protection *nfs-default-directory-protection* (logand dirmode *mode-inheritable*))) (logior *mode-regular* (if (eq type :binary) *mode-binary* 0) (or protection *nfs-default-file-protection* (logand dirmode *mode-not-binary*)))) :uid (nfscredentials-uid cred) :gid (if (eql 0 (logand dirmode *mode-set-gid*)) (nfscredentials-gid cred) (fattr-gid fattr) (il:* il:\; "If directory has \"set gid\" bit, new files inherit the parent's group")) :size 0 :atime *unspecified-time* :mtime *unspecified-time*)))))(defun try-to-lock-file-crock (finfo dinfo) (il:* il:|;;| "Attempt to create a lock file for the existing file we're opening for writing.  To be replaced with REAL file locking sometime, I sincerely hope.  Maybe someday I'll understand Sun's locking protocol.") (let* ((rawname (fileinfo-rawname finfo)) (lockfilename (string-concat rawname "{lockfile}")) (dirinfo (fileinfo-dirinfo finfo)) (lookup-status (first (nfs-rpc-lookup-file dinfo finfo lockfilename)))) (cond ((eq lookup-status nfs-ok) (il:* il:\; "Uh-oh, there's one there already.  It's hopeless to guess when it's safe to usurp a lock.") (error (quote file-wont-open) :pathname (nfs-namestring (fileinfo-filepath finfo)))) ((eq lookup-status nfs-err-noent) (il:* il:\; "no lock file...") (il:* il:|;;| "We'll create a new one.  Due to lack of atomicity, we must make one with a silly name and link/delete it to the correct name.  Oy vey.") (let ((tempname (make-temp-filename))) (destructuring-bind (status result) (create-empty-file dinfo dirinfo tempname) (cond ((eq status nfs-ok) (let ((linkresult (nfs-rpc-create-link (diropres-file result) dirinfo lockfilename dinfo))) (il:* il:|;;| "Delete the old link to this file.  Don't worry if it fails.") (nfs-rpc-delete-file dinfo dirinfo tempname) (il:* il:|;;| "Now, did it work to create the new link?") (cond ((eq linkresult nfs-ok) (il:* il:\; "We won.  Remember the lock file's there when we close...") (setf (getf (fileinfo-plist finfo) (quote lockfilename)) (list* lockfilename (and nil (il:* il:\; "Actually, nobody uses more than just this first element right now") (unixtime-seconds (fattr-mtime (diropres-attributes result))) (diropres-file result))))) ((eq linkresult nfs-err-exist) (il:* il:\; "One appeared when we weren't looking.  Recur and handle it as above.") (try-to-lock-file-crock finfo dinfo)) (t (error "Error when linking to lock file: ~a" (nfs-status-to-string linkresult)))))) ((eq status nfs-err-acces) (il:* il:|;;| "Can't create lock file here.  Just lose; we won't be able to write, either.") (error (quote fs-protection-violation) :pathname (nfs-namestring (fileinfo-filepath finfo)))) (t (error "NFS Error Creating lock file: ~a" (nfs-status-to-string status))))))))))(defun openfile-set-version (dinfo finfo tempname oldversions) (il:* il:|;;| "We have just created a file whose raw unix name is TEMPNAME.  We want to turn this into a \".temp-foo\" file to be the newest version of foo.") (let* ((path (fileinfo-filepath finfo)) (dirinfo (fileinfo-dirinfo finfo)) (desired-version (nfspath-version path)) (reserved-version desired-version) (anchor-name (or (car oldversions) (rootname-from-pathname path t))) (anchor-temp (temp-name-for-file anchor-name)) versioned-temp) (il:* il:\; "ANCHOR-NAME is the real name we will call it when closed, sans version.  ANCHOR-TEMP is what we call it while writing it, sans version") (loop (il:* il:|;;| "Repeat this until we can reserve a version number successfully.") (when oldversions (il:* il:|;;| "First handle anything Unix has left over.") (setq oldversions (fix-up-unlinked-versionless-file dirinfo dinfo path anchor-name))) (let ((highest-version (highest-version-present-or-reserved dirinfo dinfo anchor-name)) link-status) (unless desired-version (setf (nfspath-version path) (setq reserved-version (1+ highest-version)))) (setq link-status (nfs-rpc-create-link (fileinfo-filehandle finfo) dirinfo (setq versioned-temp (make-versioned-filename anchor-temp reserved-version)) dinfo)) (cond ((eq link-status nfs-ok) (il:* il:|;;| "Got it!  Flush the gensym'd file name, and remember this name/version.") (nfs-rpc-delete-file dinfo finfo tempname) (add-file-to-dircache dirinfo anchor-temp reserved-version (fattr-fileid (fileinfo-fattr finfo))) (setf (fileinfo-rawname finfo) versioned-temp) (setf (getf (fileinfo-plist finfo) (quote tempname)) versioned-temp (getf (fileinfo-plist finfo) (quote anchor-filename)) anchor-name (getf (fileinfo-plist finfo) (quote anchor-fileid)) (cond ((and desired-version (< desired-version highest-version)) (il:* il:\; "There will be no need to link the versionless name to us at closing time, so skip this stuff") t) (oldversions (il:* il:\; "Remember the ID of the versionless file so we can tell whether things have changed when we close") (second oldversions)))) (return) (il:* il:\; "from loop")) ((eq link-status nfs-err-exist) (when (or desired-version (null (get-directory-cache dirinfo dinfo t))) (il:* il:|;;| "In first case, user specifically requested this version, but someone else has it opened (probably); in second, we failed to refresh the cache.") (error (quote file-wont-open) :pathname (nfs-namestring path))) (il:* il:\; "Try it all over again with fresh cache") (setq oldversions t)) (t (error "Trying to create ~a: ~a" versioned-temp (nfs-status-to-string link-status))))))))(defun fix-up-unlinked-versionless-file (dirinfo dinfo path key) (il:* il:|;;| "If there is a versionless file not linked to a version-numbered file, it's really the newest.  Link it to a new highest version.  Returns the version set") (loop (let ((hash (dirinfo-hashtable dirinfo)) entry versions versionless-id versionpairs) (when (or (not hash) (not (setq entry (gethash key hash))) (not (setq versions (versions-from-hashentry key entry))) (not (setq versionless-id (second versions))) (version-from-fileid versionless-id (setq versionpairs (cddr versions))) (destructuring-bind (status result) (il:* il:|;;| "There's an unlinked versionless file there.  Link a new version to it.") (nfs-rpc-lookup-file dinfo dirinfo key) (cond ((eq status nfs-ok) (let* ((v (if versionpairs (1+ (car (first versionpairs))) 1)) (link-status (nfs-rpc-create-link (diropres-file result) dirinfo (make-versioned-filename key v) dinfo))) (cond ((eq link-status nfs-ok) (add-file-to-dircache dirinfo key v (fattr-fileid (diropres-attributes result))) t) ((eq link-status nfs-err-exist) (setf (dirinfo-meta-timestamp dirinfo) 0) (il:* il:\; "Loop and try again") nil) (t (error "NFS trying to assign file ~a a version number: ~A" key (nfs-status-to-string link-status)))))) (t (error "Looking up file ~a: ~a" key (nfs-status-to-string status)))))) (return versions)))))(defun find-symbolic-link-target (dinfo finfo) (il:* il:|;;| "We expect that FINFO has all the Link's particulars filled in.  This returns a new fileinfo, with second value the (possibly new) device.") (destructuring-bind (status result) (nfs-rpc-read-link (fileinfo-filehandle finfo) dinfo) (cond ((eq status nfs-ok) (multiple-value-bind (newpath newdinfo) (parse-link-name result (fileinfo-filepath finfo) dinfo) (let ((dirinfo (get-directory newpath newdinfo))) (and dirinfo (values (getfileinfo-old newdinfo (make-fileinfo :filepath newpath :dirinfo dirinfo) (rawname-from-pathname newpath)) newdinfo))))) (t (nfs-handle-error status "Read Symbolic Link" (fileinfo-filepath finfo) t)))))(defun parse-link-name (linkname path dinfo) (il:* il:|;;| "Produce a pathname that reflects LINKNAME, the results of a readlink in the directory PATH on DINFO.  Second value is the device, in case we crossed devices.") (let ((last (1- (length linkname))) (start 0) dotpos version lastslash directory initial parent realdev) (when (and (char= (char linkname last) #\~) (setq dotpos (search ".~" linkname :from-end t :end2 last))) (il:* il:\; "Link to a versioned file!  Translate to Lisp syntax") (setq version (yp:integer-from-string linkname (+ 2 dotpos) last))) (unless (or (cond ((eql (setq initial (char linkname 0)) #\/) (il:* il:\; "Absolute directory") (setq start 1))) (not path) (il:* il:\; "Nothing to relativize from.  Hope caller isn't planning to use this.") (and (eql initial #\.) (> last 0) (case (char linkname 1) (#\/ (il:* il:\; "./foo means foo in this directory") (setq start 2) nil) (#\. (cond ((and nil (> last 1) (eql (char linkname 2) #\/)) (il:* il:\; "../foo means foo in parent directory") (il:* il:|;;| "Problem with this is that the name we have for parent does not necessarily reflect the \"real\" directory structure--it could just be a link.  So have to produce a name that includes the \"..\" in order to get there for now.  Yecch.") (setq parent (cdr (nfspath-directory path))) (il:* il:\; "All but last.  If DIR is the top-level directory, then ../ is a noop") (setq start 3)))) (t nil)))) (il:* il:\; "Name we are about to parse is relative to the directory containing the link") (setq parent (nfspath-directory path))) (cond ((setq lastslash (position #\/ linkname :from-end t)) (il:* il:\; "Parse out a directory and a namebody") (setq directory (parse-dir-string (escape-uppercase-chars linkname start lastslash t))) (when (and (null parent) *use-volume-map*) (multiple-value-bind (realdev dir) (adjust-volume directory t t) (when realdev (il:* il:\; "This is where link really points") (setq dinfo (device-info realdev)) (setq directory dir)))) (setq start (1+ lastslash)))) (values (make-nfspath :host (cond (dinfo (deviceinfo-downhost dinfo)) (path (nfspath-host path)) (t (fix-this (il:* il:\; "Cruft leftover from ATTRIBUTE-FROM-FATTR") nil))) :directory (nconc directory parent) :namebody (escape-uppercase-chars linkname start (and version dotpos) t) :version version) dinfo)))(defun highest-version-in-list (versions) (il:* il:|;;| "Return the element of VERSIONS reflecting the highest version.  If versionless file is not linked to highest version, we'll invent an entry") (let ((versionless-fileid (second versions)) (versionpairs (cddr versions))) (cond ((and versionless-fileid (not (version-from-fileid versionless-fileid versionpairs))) (il:* il:\; "There is an unlinked versionless file, so choose 1 higher than highest entry") (list (if versionpairs (1+ (car (first versionpairs))) 1) versionless-fileid)) (t (first versionpairs)))))(defun lowest-version-in-list (versions) (il:* il:|;;| "Return the element of VERSIONS reflecting the lowest version.  If only a versionless file exists, we'll invent a version 1") (let ((versionpairs (cddr versions))) (cond (versionpairs (car (last versionpairs))) ((second versions) (list 1 (second versions))))))(il:* il:\; "Reopen & validate")(defun getvalidation (fattr) "Computes the validation (= creationdate) for a file from a FATTR struct" (unix-to-idate (unixtime-seconds (fattr-mtime fattr))))(defun revalidate-stream (stream) (let ((finfo (stream-info stream))) (when (null (fileinfo-filehandle finfo)) (il:* il:|;;| "STREAM handle got tossed over logout, etc.  Try to recover the file.") (prog* ((device (stream-device stream)) (dinfo (device-info device)) (rawname (fileinfo-rawname finfo)) result dirinfo status fattr date) retry (revalidate-deviceinfo dinfo) (unless (setq dirinfo (get-directory (fileinfo-filepath finfo) dinfo)) (il:* il:\; "Couldn't get handle on directory") (go fail)) (setf (fileinfo-dirinfo finfo) dirinfo) (setq result (nfs-rpc-lookup-file dinfo dirinfo rawname)) (unless (eq (setq status (first result)) nfs-ok) (go fail)) (setq result (second result)) (setq date (getvalidation (setq fattr (diropres-attributes result)))) (unless (= date (stream-validation stream)) (il:* il:\; "File has changed out from under us") (stream-changed stream fattr (diropres-file result))) (when (eq (getf (fileinfo-plist finfo) (quote lockfilename)) :relock) (multiple-value-bind (result status) (ignore-errors (try-to-lock-file-crock finfo dinfo)) (unless (null status) (il:* il:\; "Couldn't get lock file") (go fail)))) (setf (fileinfo-filehandle finfo) (diropres-file result)) (setf (fileinfo-fattr finfo) fattr) (setf (stream-validation stream) date) (return stream) fail (il:* il:|;;| "Come here if we failed to reopen") (proceedable-error stream "Could not reestablish connection to file ~A because ~A" (list (il:|fetch| il:fullfilename il:|of| stream) (nfs-status-to-string status))) (go retry)))))(defun nfs-openp (filename access device) (il:* il:|;;;| "Device operation.  return all open streams on DEVICE with full name FILENAME and access ACCESS.  FILENAME and/or ACCESS may be NIL.") (prog ((dinfo (device-info device))) retry (return (il:|for| s il:|in| (deviceinfo-openfiles dinfo) il:|when| (and (or (null filename) (string-equal filename (record-fetch stream fullfilename s))) (or (null access) (il:\\iomodep s access t))) il:|collect| (when (eql 0 (record-fetch stream accessbits s)) (il:* il:|;;| "A closed stream on Open Files.  This shouldn't happen, since unregisterfile and setting access to NIL happen in the same place (\\CLOSEFILE).  However, when you close a TEdit window, it closes the stream twice in a race.  Wish I knew why this was happening.  Anyway, flush it and try again.  What a kludge.") (prompt-format "~&NFS: Found ~S on open file list--discarding." s) (setf (deviceinfo-openfiles dinfo) (delete s (deviceinfo-openfiles dinfo))) (go retry)) s))))(defun nfs-unregisterfile (device stream) (il:* il:|;;;| "Device operation: Remove an open stream from the list of streams kept by DEVICE.") (il:* il:|;;| "I'd do this in CLOSEFILE except for exception handling: some people know that they can return from a device's CLOSE function in order to do a close-abort, in which case we would be left with something on our open file list that's marked closed (by the generic file system code).  Bleah.") (let ((dinfo (device-info device))) (setf (deviceinfo-openfiles dinfo) (delete stream (deviceinfo-openfiles dinfo))) stream))(il:* il:\; "Close File")(defun nfs-closefile (stream &optional abort) "Closes a stream." (setq stream (il:\\dtest stream (quote stream))) (let* ((finfo (stream-info stream)) (plist (fileinfo-plist finfo)) (device (stream-device stream)) (dinfo (device-info device)) tmp) (il:\\clearmap stream) (cond ((getf plist (quote tempname)) (il:* il:|;;| "This is a new file, which needs to be renamed to its real name.  Go thru this intricate dance to rename the \"unversioned\" file to one with a number, then rename our temp file.") (closef-replace-current-version finfo dinfo)) (t (il:* il:\; "Smash lock file if any") (when (setq tmp (getf plist (quote lockfilename))) (il:* il:\; "Try to delete lock.  Don't even care whether it works at this point.") (nfs-rpc-delete-file dinfo finfo (first tmp))))) (when (setq tmp (getf plist (quote creationdate))) (nfs-setfileinfo finfo (quote il:creationdate) tmp device)) (close-fileinfo finfo dinfo) t))(defun closef-replace-current-version (finfo dinfo) (il:* il:|;;| "The FINFO is of the file being closed.  Rename operations need to fake one up.") (let* ((plist (fileinfo-plist finfo)) (fromname (getf plist (quote tempname))) (path (fileinfo-filepath finfo)) (filehandle (fileinfo-filehandle finfo)) (anchor-filename (getf plist (quote anchor-filename))) (anchor-fileid (getf plist (quote anchor-fileid))) link-result toname) (refresh-fileinfo-fattr finfo dinfo) (il:* il:|;;| "Link our file to its proper name-and-version.") (when (and (null anchor-fileid) (not *always-write-version*) (eql (nfspath-version path) 1)) (il:* il:\; "Creating version 1.  There is no need to make a versioned file here, so just make the versionless one.") (setq link-result (closef-rename-tempfile finfo dinfo fromname anchor-filename anchor-filename nil)) (when (eq link-result nfs-ok) (il:* il:|;;| "Success!  Nothing more to do") (return-from closef-replace-current-version t)) (il:* il:|;;| "Link failed, so the anchor name has appeared in the meantime.  Fall back on general method (which may still fail...)")) (setq link-result (closef-rename-tempfile finfo dinfo fromname (setq toname (make-versioned-filename anchor-filename (nfspath-version path))) anchor-filename (nfspath-version path))) (cond ((eq link-result nfs-ok)) ((eq link-result nfs-err-exist) (il:* il:\; "Already exists:  Ouch!  Call special routine to handle.") (closef-filename-exists finfo dinfo)) (t (error "CLOSEF: Couldn't link the result to ~a because: ~a." toname (nfs-status-to-string link-result)))) (il:* il:|;;| "See if the \"anchor file\" (with versionless name) is still as we remember it.") (when (eq anchor-fileid t) (il:* il:|;;| "We were writing less than the highest version, so don't bother") (return-from closef-replace-current-version t)) (let (lookup-result second-pass) (loop (setq lookup-result (nfs-rpc-lookup-file dinfo finfo anchor-filename)) (cond ((eq (first lookup-result) nfs-ok) (let ((lookup-id (fattr-fileid (diropres-attributes (second lookup-result))))) (cond ((eql lookup-id anchor-fileid) (il:* il:\; "Anchor unchanged") (return)) ((null anchor-fileid) (il:* il:\; "Anchor file just showed up.  Fine, we know it's there now.") (setq anchor-fileid lookup-id) (return)) (t (il:* il:\; "Anchor file is now different.  Call special routine to handle this and dispatch on its return-value.") (ecase (closef-anchor-changed finfo dinfo) (return (return-from closef-replace-current-version nil)) (loop nil)))))) ((eq (first lookup-result) nfs-err-noent) (il:* il:\; "Anchor file isn't there.") (cond ((null anchor-fileid) (il:* il:\; "We started without an anchor, so that's okay.") (return)) ((null second-pass) (il:* il:\; "There used to be an anchor.  Maybe is race with other host, so wait a bit.") (sleep 5) (setq second-pass t)) (t (il:* il:\; "We've already waited long enough, so go ahead without it") (setq anchor-fileid nil) (return)))) (t (cerror "Proceed taking no action" "Trying to look up ~a returned ~a." anchor-filename lookup-result) (return))))) (relink-current-version dinfo finfo anchor-filename anchor-fileid)))(defun relink-current-version (dinfo finfo rootname rootid) (il:* il:|;;| "Called when we have a new file (FINFO) that we want to be the \"current\" version.  ROOTNAME is the versionless name we would like linked to it, and ROOTID is the fileId we think ROOTNAME currently has (NIL if we believe it to be absent).") (let ((dirinfo (fileinfo-dirinfo finfo)) (path (fileinfo-filepath finfo)) link-status) (when rootid (il:* il:|;;| "There IS a versionless file to replace.  We want to delete it, then link it afresh.  However, don't delete it straight out--fIrst rename it to a temp name so we can check that it's the one we thought.") (let* ((tempname (make-temp-filename (string-concat rootname "{oldversion}"))) (dirhandle (dirinfo-dirhandle dirinfo)) (rename-status (nfs-rpc-rename-file dirhandle rootname dirhandle tempname dinfo))) (cond ((eq rename-status nfs-ok) (il:* il:\; "Rename succeeded") (destructuring-bind (lookup-status lookup-result) (nfs-rpc-lookup-file dinfo dirinfo tempname) (il:* il:\; "Look up the renamed anchor, see if it's the same as the old anchor, which we know was associated with a version") (cond ((eq lookup-status nfs-ok) (let ((lookup-fattr (diropres-attributes lookup-result))) (cond ((eql (fattr-fileid lookup-fattr) rootid) (il:* il:\; "As expected, go ahead and delete it") (nfs-rpc-delete-file dinfo dirinfo tempname)) (t (il:* il:\; "OOPS!  FIle is different!!  Try to put it back!") (cond ((eq (setq link-status (nfs-rpc-create-link (diropres-file lookup-result) dirinfo rootname dinfo)) nfs-ok) (nfs-rpc-delete-file dinfo dirinfo tempname)) (t (il:* il:\; "Eek!  Can't put it back where we found it!") (if (eql 1 (fattr-nlink lookup-fattr)) (il:* il:|;;| "If only one link to it, make user notice this.") (cerror "Proceed taking no action" "In attempting to link ~a to the new version ~a, it changed identity; NFS could not put it back because ~a.  The file with the new identity (perhaps just written there by another user) is now named ~a." rootname (nfs-namestring path) (nfs-status-to-string link-status) tempname) (nfs-rpc-delete-file dinfo dirinfo tempname)))))))) (t (il:* il:\; "Hope this never happens!") (cerror "Proceed taking no action" "In replacing the file ~a, it was not found after a successful renaming (~a).  It may have been lost." rootname (nfs-status-to-string lookup-status)))))) ((eq rename-status nfs-err-noent) (il:* il:\; "anchor file vanished in that brief interval--don't sweat it.") nil) (t (return-from relink-current-version (relink-failed-msg rootname path rename-status)))))) (il:* il:|;;| "Versionless file should be out of the way now, so link our file to that name.") (setq link-status (nfs-rpc-create-link (fileinfo-filehandle finfo) dirinfo rootname dinfo)) (cond ((eq link-status nfs-ok) (add-file-to-dircache dirinfo rootname nil (fattr-fileid (fileinfo-fattr finfo))) t) ((eq link-status nfs-err-exist) (il:* il:\; "Hmm, somebody got there first.  Leave it.") t) (t (relink-failed-msg rootname path link-status)))))(defun relink-failed-msg (rootname path status) (prompt-format "~&Couldn't link ~A to new version ~A because ~A" rootname (nfs-namestring path) (nfs-status-to-string status)))(defun closef-rename-tempfile (finfo dinfo tempname toname anchor-filename version) (il:* il:|;;| "Called by CLOSEF to try linking a real name, TONAME (i.e., ANCHOR-FILENAME + VERSION) to the file we originally created as TEMPNAME.  Returns status code; if success, we have removed the temp name") (let* ((dirinfo (fileinfo-dirinfo finfo)) (status (nfs-rpc-create-link (fileinfo-filehandle finfo) dirinfo toname dinfo))) (when (eq status nfs-ok) (il:* il:\; "Success.  Now we can delete the temporary name, and change the name in the cache, too") (nfs-rpc-delete-file dinfo finfo tempname) (delete-file-from-dircache dirinfo (temp-name-for-file anchor-filename) (nfspath-version (fileinfo-filepath finfo))) (add-file-to-dircache dirinfo anchor-filename version (fattr-fileid (fileinfo-fattr finfo)))) status))(defun closef-anchor-changed (finfo dinfo) (il:* il:|;;| "Called when, after we close our new file, the versionless (\"anchor\") file id is different than when we started.  We don't want to just smash it to point to our new version, because it could be the only one of its kind.") (fix-this (il:* il:|;;| "THIS IS ALL WRONG!!!!!")) (let* ((plist (fileinfo-plist finfo)) (fromname (getf plist (quote tempname))) (dirinfo (get-directory-cache (fileinfo-dirinfo finfo) dinfo)) (anchor-filename (getf plist (quote anchor-filename))) (subentry (cdr (versions-from-hashentry anchor-filename (dirinfo-hashtable dirinfo)))) (nullid (second subentry)) version otherversion) (cond ((null nullid) (il:* il:\; "There is no anchor") (quote loop)) ((null (setq otherversion (car (version-from-fileid nullid (cddr subentry))))) (il:* il:\; "There is no versioned file linked to the anchor--link it to a new highest version and say we're done.") (loop (destructuring-bind (status info) (nfs-rpc-lookup-file dinfo dirinfo anchor-filename) (cond ((eq status nfs-ok) (let ((link-status (nfs-rpc-create-link (diropres-file info) dirinfo (make-versioned-filename anchor-filename (1+ (highest-version-present-or-reserved dirinfo dinfo anchor-filename))) dinfo))) (cond ((eq link-status nfs-ok) (nfs-rpc-delete-file dinfo dirinfo anchor-filename) (return (quote return))) ((eq link-status nfs-err-exist) (il:* il:\; "try again...")) ((eq link-status nfs-err-stale) (return (quote loop))) (t (error "Trying to relink the file ~a: ~a" anchor-filename (nfs-status-to-string link-status)))))) ((eq status nfs-err-noent) (il:* il:\; "Anchor vanished") (return (quote loop))) (t (error "Trying to lookup the file ~a: ~a" anchor-filename (nfs-status-to-string status))))))) ((> otherversion (setq version (nfspath-version (fileinfo-filepath finfo)))) (il:* il:\; "A newer version has appeared.  We're done.") (quote return)) ((= otherversion version) (error)) ((< otherversion version) (il:* il:\; "It's linked to a lower version.") (quote loop)))))(defun closef-filename-exists (finfo dinfo) (il:* il:|;;| "We got here because the version number we were claiming has been used up by somebody else.  Find a later version number to use.") (let* ((plist (fileinfo-plist finfo)) (fromname (getf plist (quote tempname))) (toname (rawname-from-pathname (fileinfo-filepath finfo))) (dirinfo (fileinfo-dirinfo finfo)) subentry fileid otherversion) (when (and (get-directory-cache dirinfo dinfo t) (setq fileid (second (setq subentry (cdr (versions-from-hashentry (getf plist (quote anchor-filename)) (dirinfo-hashtable dirinfo)))))) (setq otherversion (car (version-from-fileid fileid (cddr subentry))))) (il:* il:|;;| "That file is named by two versions of this name.  Go ahead and stomp on the one we claim.") (loop (let* ((dirhandle (dirinfo-dirhandle dirinfo)) (rename-result (nfs-rpc-rename-file dirhandle fromname dirhandle toname dinfo))) (cond ((eq rename-result nfs-ok) (return-from closef-filename-exists nil)) (t (cerror "Try to rename it again." "Couldn't rename ~a to ~a because ~a." fromname toname rename-result)))))) (il:* il:|;;| "That file is new and different.  Foobar!") (il:* il:|;;| "Put in something to handle this better someday.") (cerror "Leave the file named ~a" "Can't rename ~a to ~a because a file by that name now exists." fromname toname)))(il:* il:\; "Delete File")(defun nfs-deletefile (name device) (multiple-value-bind (path device) (nfs-parse-namestring name device) (cond ((null path) (il:* il:\; "Malformed") nil) ((or (nfspath-namebody path) (nfspath-version path)) (il:* il:\; "Ordinary file--do recognition to get the name to pass to delete") (multiple-value-bind (finfo dinfo versions dirinfo) (nfs-getfile device path nil (quote il:oldest) (quote handle) (quote delete-file)) (unless finfo (il:* il:\; "File not found") (return-from nfs-deletefile nil)) (cond ((nfs-openfile-p dinfo (setq path (fileinfo-filepath finfo))) (when *nfs-debug* (format t "NFS-DELETEFILE cannot delete open file ~A~%" name)) (return-from nfs-deletefile nil)) ((null dirinfo) (error "Shouldn't happen: Got path but no dirinfo back from NFS-GETFILE")) ((eql (fattr-type (fileinfo-fattr finfo)) nfdir) (il:* il:\; "It's a directory--go this other way") (delete-directory path dinfo dirinfo)) (t (il:* il:|;;| "Look at the versions of the file present and see if we're talking about a version to which the \"versionless\" file is linked, or the versionless file itself.  If so, we have to do some fiddling.") (nfs-deletefile-versioned dinfo path versions dirinfo))))) (t (il:* il:\; "A directory.  Look up its parent and delete within") (delete-directory path (device-info device))))))(defun delete-directory (path dinfo &optional parentinfo) (il:* il:|;;| "Delete the directory specified by PATH.") (let* ((dirlist (nfspath-directory path)) (dirname (downcase-unquoted-chars (car dirlist)))) (cond ((or parentinfo (setq parentinfo (get-directory (make-nfspath :host (nfspath-host path) :directory (cdr dirlist)) dinfo))) (setf (nfspath-directory path) (cons (escape-uppercase-chars dirname) (nfspath-directory (dirinfo-path parentinfo)))) (il:* il:\; "Canonicalize name now") (let ((delete-result (nfs-dir-op dinfo *remove-directory* parentinfo dirname))) (cond ((eq delete-result nfs-ok) (let ((dirinfo (find-directory-info dirlist dinfo))) (when dirinfo (il:* il:\; "This dir is no more") (destroy-dirinfo dirinfo dinfo))) (nfs-namestring path)) (t (deletefile-failed path delete-result))))))))(defun nfs-openfile-p (dinfo path/finfo) (il:* il:|;;| "True if the file specified by PATH/FINFO is open on DINFO") (let ((opened (deviceinfo-openfiles dinfo))) (and opened (let ((name (etypecase path/finfo (nfspath (nfs-namestring path/finfo)) (fileinfo (nfs-namestring (fileinfo-filepath path/finfo))) (string path/finfo)))) (dolist (s opened) (when (string-equal (il:|fetch| il:fullfilename il:|of| s) name) (return s)))))))(defun nfs-deletefile-versioned (dinfo path versions dirinfo) (let* ((key (car versions)) (version-desired (nfspath-version path)) (versionless-id (second versions)) (version-id (second (assoc version-desired (cddr versions)))) (delete-result (nfs-rpc-delete-file dinfo dirinfo (cond (version-id (il:* il:\; "Always delete the versioned file if present") (make-versioned-filename key version-desired)) (t key))))) (cond ((eq delete-result nfs-ok) (delete-file-from-dircache dirinfo key (and version-id version-desired)) (when (or (null version-id) (cond ((eql version-id versionless-id) (il:* il:\; "Have a versionless file linked to the ~n~ file we just deleted, so delete it as well") (nfs-rpc-delete-file dinfo dirinfo key) (delete-file-from-dircache dirinfo key nil) t))) (il:* il:|;;| "Versionless file was deleted, see if there's a next highest version to link to") (when (cddr versions) (il:* il:\; "Link to new highest version.  We rely on DELETE-FILE-FROM-DIRCACHE smashing VERSIONS for this test to be accurate") (let* ((maxpair (first (cddr versions))) (rawname-to-link (make-versioned-filename key (car maxpair))) (max-id (second maxpair))) (destructuring-bind (lookup-status lookup-info) (nfs-rpc-lookup-file dinfo dirinfo rawname-to-link) (cond ((eq lookup-status nfs-ok) (let ((link-result (nfs-rpc-create-link (diropres-file lookup-info) dirinfo key dinfo))) (cond ((eq link-result nfs-ok) (assert (eql (fattr-fileid (diropres-attributes lookup-info)) max-id)) (add-file-to-dircache dirinfo key nil max-id)) ((eq link-result nfs-err-exist) (il:* il:\; "One just showed up.  Don't sweat this, but mark the cache bad.") (setf (dirinfo-meta-timestamp dirinfo) 0)) (t (prompt-format "~&DeleteFile couldn't link ~a to ~a because: ~a" rawname-to-link key (nfs-status-to-string link-result)))))) (t (prompt-format "~&DeleteFile failed to look up ~a because: ~a" rawname-to-link (nfs-status-to-string lookup-status)) (setf (dirinfo-meta-timestamp dirinfo) 0))))))) (nfs-namestring path)) (t (deletefile-failed path delete-result)))))(defun deletefile-failed (path delete-result) (cond ((eq delete-result nfs-err-noent) (il:* il:\; "Cache must be out of date.") (quote (setf (dirinfo-meta-timestamp dirinfo) 0)) nil) (t (prompt-format "~&Couldn't delete file ~a because: ~a" (nfs-namestring path) (nfs-status-to-string delete-result)))))(il:* il:\; "Create directories")(defun create-directory (dirname superiorinfo dinfo) (let* ((rawname (downcase-unquoted-chars dirname)) (newdirpath (make-nfspath :host (deviceinfo-host dinfo) :directory (cons (escape-uppercase-chars rawname) (nfspath-directory (dirinfo-path superiorinfo)))))) (when *nfs-debug* (format t "~%NFS-Create-Directory called for ~a in ~a" rawname (dirinfo-unixname superiorinfo))) (destructuring-bind (status result) (create-empty-file dinfo superiorinfo rawname :directory) (cond ((eq status nfs-ok) (il:* il:\; "Create succeeded, so cons up a directory object for it") (get-directory newdirpath dinfo (string-concat (dirinfo-unixpath superiorinfo) "/" rawname) nil (diropres-file result) (diropres-attributes result) superiorinfo)) (t (error "Couldn't create the directory ~a because ~a" (nfs-namestring newdirpath) (nfs-status-to-string status)))))))(defun create-missing-directories (dir-path dinfo) (il:* il:|;;| "Returns dirinfo for new directory.") (when *nfs-debug* (format t "~% NFS-Create-Missing-Directories called for ~a" dir-path)) (let* ((dirlst (nfspath-directory dir-path)) (superior-path (make-nfspath :directory (cdr dirlst) :host (nfspath-host dir-path))) (superior-dir (cond ((get-directory superior-path dinfo)) ((cdr dirlst) (il:* il:|;;| "if superior does not exist, recur up tree to create it.") (create-missing-directories superior-path dinfo)) (t (il:* il:\; "This only happens if we can't mount root") (error "Can't create directory {~A}<~A> because no access to root." (nfspath-host dir-path) (car dirlst)) nil)))) (and superior-dir (create-directory (car dirlst) superior-dir dinfo))))(il:* il:\; "Stream operations")(defun nfs-readpages (stream firstpage buffers) (if (consp buffers) (do ((bufs buffers (cdr bufs)) (page firstpage (+ 1 page)) (bytesthispage) (totalbytes 0)) ((null bufs) totalbytes) (setq bytesthispage (nfs-readpage stream page (car bufs))) (setq totalbytes (+ totalbytes bytesthispage)) (if (< bytesthispage 512) (return totalbytes))) (nfs-readpage stream firstpage buffers)))(defun nfs-readpage (stream page *read-buffer*) "Read a single VMEMPAGEP" (let ((epage (stream-epage stream))) (cond ((or (> page epage) (and (eql page epage) (eql 0 (stream-eoffset stream)))) (il:* il:\; "Request is past eof") (il:\\clearwords *read-buffer* il:wordsperpage) 0) (t (when (and (evenp page 4) il:\\interruptable) (il:* il:\; "Don't let an NFS to NFS transfer completely lock out all other NFS traffic") (il:block)) (loop (let* ((finfo (stream-info stream)) (fhandle (fileinfo-filehandle finfo)) results) (cond ((null fhandle) (il:* il:\; "First access after logout") (revalidate-stream stream)) ((eq (first (setq results (nfs-rpc (device-info (stream-device stream)) *fast-read-from-file* (il:bquote ((il:\\\, fhandle) (il:\\\, (ash page logbytesperpage)) (il:\\\, bytesperpage) 0))))) nfs-ok) (il:* il:\; "Results = (nfs-ok bytecount), with data having been read into ") (let ((nbytes (second results))) (cond ((<= 0 nbytes bytesperpage) (il:* il:\; "Good read") (when (< nbytes bytesperpage) (il:\\clearbytes *read-buffer* nbytes (- bytesperpage nbytes))) (return nbytes)) (t (il:* il:\; "This is to track an old bug we believe fixed, so this should never happen now") (prompt-format "~&NFS-READPAGE received a bogus data length of ~d; will try again.~%" nbytes))))) ((eq (first results) nfs-err-stale) (il:* il:\; "Stale handle, try to reestablish connection") (setf (fileinfo-filehandle finfo) nil) (revalidate-stream stream)) (t (nfs-handle-error (first results) (quote nfs-readpage) stream)))))))))(defun nfs-writepages (stream firstpage buffers) (if (consp buffers) (do ((bufs buffers (cdr bufs)) (page firstpage (+ 1 page))) ((null bufs)) (nfs-writepage stream page (car bufs))) (nfs-writepage stream firstpage buffers)) (il:* il:|;;| "This writing may have changed file length.") (setf (fileinfo-fattr (stream-info stream)) nil))(defun nfs-writepage (stream page vmempagep) (when (and (evenp page 4) il:\\interruptable) (il:* il:\; "Don't let an NFS to NFS transfer completely lock out all other NFS traffic") (il:block)) (loop (let* ((finfo (stream-info stream)) (fhandle (fileinfo-filehandle finfo)) status) (cond ((null fhandle) (il:* il:\; "First access after logout") (revalidate-stream stream)) ((eq (setq status (first (nfs-rpc (device-info (stream-device stream)) *fast-write-to-file* (il:bquote ((il:\\\, fhandle) 0 (il:\\\, (ash page logbytesperpage)) 0 (il:\\\, (cons vmempagep (if (eql page (stream-epage stream)) (stream-eoffset stream) bytesperpage)))))))) nfs-ok) (return t)) ((eq status nfs-err-stale) (setf (fileinfo-filehandle finfo) nil) (revalidate-stream stream)) (t (nfs-handle-error status (quote nfs-writepage) stream))))))(defun nfs-truncatefile (stream page offset) "Shortens pagemapped stream, or else lengthens and null-pads stream" (il:* il:|;;| "This should ONLY be called by NFS-SETEOFPTR.") (when *nfs-debug* (format t "NFS-TRUNCATEFILE called.~%  STREAM=~A~%  PAGE=~A~%  OFFSET=~A~%" stream page offset)) (unless (and (null page) (null offset)) (il:* il:|;;| "If both are null, we have no change to make.  Some devices respond to this call by securing the output file somehow, something we don't need to do.") (revalidate-stream stream) (unless (il:dirtyable stream) (error (quote stream-not-open) :stream stream)) (let ((epage (stream-epage stream)) (eoffset (stream-eoffset stream))) (unless page (setq page epage)) (unless offset (setq offset eoffset)) (if (or (> page epage) (and (= page epage) (> offset eoffset))) (pad-stream-with-zeros stream epage eoffset page offset) (setfileinfo-internal (device-info (stream-device stream)) (stream-info stream) (quote il:length) (+ (* page bytesperpage) offset))) t)))(defun pad-stream-with-zeros (stream oldpage oldoffset newpage newoffset) (il:\\pagedsetfileptr stream -1) (do ((page oldpage) (offset oldoffset)) ((and (>= page newpage) (>= offset newoffset))) (il:\\bout stream 0) (setq offset (+ 1 offset)) (if (>= offset bytesperpage) (progn (setq page (+ 1 page)) (setq offset 0)))))(defun nfs-seteofptr (stream nbytes) (il:* il:|;;| "Shamelessly palagerized from \\NSRANDOM.SETEOFPTR.") (let ((page (ash nbytes (- logbytesperpage))) (offset (logand nbytes (1- bytesperpage)))) (case (il:\\newlengthis stream page offset) (il:shorter (cond ((il:overwriteable stream) (il:forgetpages stream (1+ page) (prog1 (stream-epage stream) (il:* il:\; "\\seteof changes EPAGE") (il:\\seteof stream page offset))) (il:* il:|;;| "FORGETPAGES tells PMAP to throw away the extra pages.  The \\SETEOF is done first so that an interrupt will not leave STREAM pointing to old and possibly partially overwritten pages.") (nfs-truncatefile stream page offset) (il:* il:\; "Shorten the real file") t))) (il:same (il:* il:\; "Nothing to do") t) (il:longer (cond ((il:appendable stream) (il:\\seteof stream page offset) t))))))(il:* il:\; "Rename File")(defun nfs-renamefile (fromdev fromname todev toname copyflg) (il:* il:|;;| "Rename FROMNAME on FROMDEV to TONAME on TODEV.  COPYFLG means establish the link, but don't delete the source.") (unless (deviceinfo-p (device-info todev)) (il:* il:\; "Destination not NFS") (return-from nfs-renamefile (if copyflg (error "~A is not NFS." toname) (il:\\generic.renamefile fromdev fromname todev toname)))) (let (fromfinfo fromdinfo oldfromversions fromcache tofinfo todinfo oldtoversions tocache) (multiple-value-setq (fromfinfo fromdinfo oldfromversions fromcache) (nfs-getfile fromdev fromname nil (quote il:old) (quote handle))) (when (null fromfinfo) (il:* il:\; "FROMNAME not found") (return-from nfs-renamefile nil)) (when (nfs-openfile-p fromdinfo fromfinfo) (il:* il:\; "File is open") (return-from nfs-renamefile nil)) (evalcase (fattr-type (fileinfo-fattr fromfinfo)) (nfreg (il:* il:\; "Normal file")) (nfdir (return-from nfs-renamefile (if copyflg (error "nfs:linkfile: ~A is a directory" fromname) (rename-directory fromfinfo fromdinfo todev toname)))) (otherwise (il:* il:\; "Can't rename these other things (e.g. links)") (return-from nfs-renamefile nil))) (multiple-value-setq (tofinfo todinfo oldtoversions) (nfs-getfile todev toname (quote il:output) (quote il:new) (quote open) (quote rename-file) (fileinfo-filepath fromfinfo))) (when (null tofinfo) (il:* il:\; "Couldn't get to destination") (return-from nfs-renamefile nil)) (unless (eq fromdinfo todinfo) (fix-this (il:* il:|;;| "We've done much of the work needed to open both files here, seems a pity to throw it away.")) (return-from nfs-renamefile (if copyflg (error "~A and ~A are on different devices" fromname toname) (il:\\generic.renamefile fromdev fromname todev toname)))) (let* ((path (fileinfo-filepath tofinfo)) (desired-version (nfspath-version path)) (dirinfo (fileinfo-dirinfo tofinfo)) (newversion desired-version) (rootname (or (car oldtoversions) (rootname-from-pathname path))) versionless) (loop (il:* il:\; "Repeat this until we can get a version number successfully.") (il:* il:|;;| "First handle anything Unix has left over.") (setq oldtoversions (fix-up-unlinked-versionless-file dirinfo todinfo path rootname)) (let (link-status newname) (unless desired-version (setf (nfspath-version path) (setq newversion (1+ (highest-version-present-or-reserved dirinfo todinfo rootname))))) (il:* il:|;;| "Link old file to new name (with version unless it is the only 1).") (setq link-status (nfs-rpc-create-link (fileinfo-filehandle fromfinfo) dirinfo (setq newname (if (setq versionless (and (null (cddr oldtoversions)) (eql newversion 1))) rootname (il:* il:\; "No version guys needed") (make-versioned-filename rootname newversion))) fromdinfo)) (cond ((eq link-status nfs-ok) (il:* il:\; "Got it!") (setf (fileinfo-filehandle tofinfo) (fileinfo-filehandle fromfinfo) (fileinfo-fattr tofinfo) (fileinfo-fattr fromfinfo)) (add-file-to-dircache dirinfo rootname (and (not versionless) newversion) (fattr-fileid (fileinfo-fattr fromfinfo))) (unless versionless (il:* il:\; "Now mess with linking highest version") (relink-current-version todinfo tofinfo rootname (second oldtoversions))) (unless copyflg (nfs-deletefile-versioned fromdinfo (fileinfo-filepath fromfinfo) oldfromversions fromcache)) (return (nfs-namestring path))) ((and (not copyflg) (eq link-status nfs-err-crossdev)) (il:* il:|;;| "Trying to rename across file-systems.  Do generic rename. ") (return-from nfs-renamefile (il:\\generic.renamefile fromdev fromname todev toname))) ((eq link-status nfs-err-exist) (cond (desired-version (il:* il:|;;| "User specifically requested this version.  Delete the old one and try again.  Acquire the lock file first in case it's in use (hmm, DELETEFILE doesn't do this...).  Didn't do this originally in case it was going to cross devices.") (let ((lockfile (try-to-lock-file-crock tofinfo todinfo))) (nfs-deletefile-versioned todinfo (fileinfo-filepath tofinfo) oldtoversions dirinfo) (nfs-rpc-delete-file todinfo dirinfo (first lockfile)))) ((get-directory-cache dirinfo todinfo t) (il:* il:\; "Decache the directory and try this all again.")) (t (il:* il:\; "Cache refresh failed") (return nil)))) (t (error "Can't link ~A to ~A because: ~a" toname fromname (nfs-status-to-string link-status)))))))))(defun rename-directory (fromfinfo fromdinfo todev toname) (multiple-value-bind (topath todev) (nfs-parse-namestring toname todev) (and topath (let ((todinfo (device-info todev)) todirinfo toname fromdir fromdirinfo fromname status) (unless (eq fromdinfo todinfo) (il:* il:\; "Can't rename dirs across file servers") (return-from rename-directory nil)) (when (nfspath-version topath) (il:* il:\; "We don't do versions") (return-from rename-directory nil)) (unless (setq toname (nfspath-namebody topath)) (il:* il:\; "Turn it into file in superior dir") (let ((dirlst (nfspath-directory topath))) (setf (nfspath-namebody topath) (setq toname (car dirlst)) (nfspath-directory topath) (cdr dirlst)))) (unless (setq todirinfo (or (get-directory topath todinfo) (create-missing-directories topath todinfo))) (il:* il:\; "Couldn't find or create destination parent.  Usually have signaled an error by now") (return-from rename-directory nil)) (unless (eql (car (nfs-rpc-lookup-file todinfo todirinfo (setq toname (downcase-unquoted-chars toname)))) nfs-err-noent) (il:* il:\; "Destination exists, so fail") (return-from rename-directory nil)) (il:* il:|;;| "Ok, now we're finally ready to try the rename") (setq fromdirinfo (fileinfo-dirinfo fromfinfo)) (setq fromname (nfspath-namebody (fileinfo-filepath fromfinfo))) (il:* il:\; "don't need to downcase-unquoted-chars here because nfs-getfile already did that.") (when (setq fromdir (find-directory-info (string-concat (dirinfo-unixpath fromdirinfo) "/" fromname) fromdinfo)) (il:* il:\; "We have a cache of the source directory, which we need to flush now") (destroy-dirinfo fromdir fromdinfo)) (setq status (nfs-rpc-rename-file (dirinfo-dirhandle fromdirinfo) fromname (dirinfo-dirhandle todirinfo) toname todinfo)) (cond ((eq status nfs-ok) (il:* il:\; "Success") (string-concat (nfs-namestring topath t) (escape-uppercase-chars toname) ">")) (t (prompt-format "~&NFS RenameFile: ~A" (nfs-status-to-string status)) nil))))))(defun linkfile (oldname newname) (nfs-renamefile (il:\\getdevicefromname (setq oldname (il:\\add.connected.dir oldname))) oldname (il:\\getdevicefromname (setq newname (il:\\add.connected.dir newname))) newname t))(il:* il:\; "Get / Set  File Information")(defun nfs-getfileinfo (filespec attribute device) "Returns attribute of a file specified by a filename, stream or fileinfo struct" (let ((finfo (cond ((and (streamp filespec) (il:opened filespec)) (stream-info filespec)) ((fileinfo-p filespec) filespec))) fattr dinfo) (cond (finfo (il:* il:\; "From stream or elsewhere?  Refresh just in case") (setq dinfo (device-info device)) (unless (fileinfo-fattr finfo) (refresh-fileinfo-fattr finfo (device-info device)))) ((null (multiple-value-setq (finfo dinfo) (nfs-getfile device filespec nil (quote il:old) (quote handle)))) (il:* il:\; "File not found.  Only happens inside NEXTFILEFN when chasing links, since the generic getfileinfo has already done infilep on the name") (return-from nfs-getfileinfo :file-not-found))) (loop (cond ((and (eq (fattr-type (setq fattr (fileinfo-fattr finfo))) nflnk) (not (eq attribute (quote il:link)))) (il:* il:\; "chase links and repeat") (unless (multiple-value-setq (finfo dinfo) (find-symbolic-link-target dinfo finfo)) (return nil))) (t (return (attribute-from-fattr fattr attribute (fileinfo-filehandle finfo) dinfo)))))))(defun nfs-setfileinfo (name/stream attribute value device) (let ((finfo (typecase name/stream (fileinfo name/stream) (stream (when (eq attribute (quote il:length)) (return-from nfs-setfileinfo (and (nfs-seteofptr name/stream value) value))) (stream-info name/stream)))) dinfo) (cond (finfo (il:* il:\; "From stream or elsewhere?  Refresh just in case") (setq dinfo (device-info device)) (case attribute ((il:protection type) (il:* il:\; "To set these requires current attribute--make sure it hasn't changed") (refresh-fileinfo-fattr finfo dinfo)))) ((null (multiple-value-setq (finfo dinfo) (nfs-getfile device name/stream nil (quote il:old) (quote handle)))) (il:* il:\; "File not found.  Only happens inside NEXTFILEFN when chasing links") (return-from nfs-setfileinfo nil)) ((eql (fattr-type (fileinfo-fattr finfo)) nflnk) (il:* il:\; "Don't setfileinfo on a link--they may not really mean it.  Force them to look it up") (prompt-format "~&SetFileInfo aborted: ~A is a link." (nfs-namestring (fileinfo-filepath finfo))) (return-from nfs-setfileinfo nil))) (let ((status (setfileinfo-internal dinfo finfo attribute value))) (cond ((eq status t) (il:* il:\; "Success.") t) (t (il:* il:\; "Failure code") (when status (prompt-format "~&SetFileInfo[~a, ~a] failed because ~a" (nfs-namestring (fileinfo-filepath finfo)) attribute (nfs-status-to-string status))) nil)))))(defun setfileinfo-internal (dinfo finfo attribute value) (il:* il:|;;| "Sets the specified attribute of the file given by FINFO/DINFO to be VALUE.  Assumes FINFO's FATTR is as up to date as it needs to be (important for TYPE and PROTECTION, which modify only part of mode bits).  On success, updates FINFO with the new FATTR and returns T; else NIL.") (let ((mode -1) (uid -1) (gid -1) (size -1) (atime *unspecified-time*) (mtime *unspecified-time*)) (case attribute (il:* il:\; "The 6 settable fields start out with \"null\" values.  Set the one(s) we are interested in.") (type (let ((fattr (fileinfo-fattr finfo))) (unless (eql (fattr-type fattr) nfreg) (il:* il:\; "Can only change type of regular files") (return-from setfileinfo-internal nil)) (setq mode (if (or (null value) (eq value (quote il:text))) (logandc2 (fattr-mode fattr) *mode-binary-p*) (il:* il:\; "Turn off BINARY bits") (logior (fattr-mode fattr) *mode-binary*) (il:* il:\; "Turn on standard BINARY bit"))))) (il:protection (il:* il:\; "The low 12 bits (protection plus text, set-gid, set-uid) are potentially settable.") (setq mode (dpb value (byte 12 0) (fattr-mode (fileinfo-fattr finfo))))) (il:length (setq size value)) (il:group.id (setq gid value)) (il:group (setq gid (or (yp:group-gid value) (error "Group ~s is not known." value)))) (il:author (il:* il:\; "Waste of time?  Unix only lets superuser change owner") (setq uid (or (yp:get-uid value) (error "User ID ~s is not known." value)))) ((il:creationdate il:icreationdate) (when (eq attribute (quote il:creationdate)) (setq value (or (il:idate value) (error (quote il:invalid-argument-list) :argument value)))) (setq mtime (make-unixtime :seconds (idate-to-unix value) :useconds 0))) ((il:readdate il:readdate) (il:* il:\; "Actually \"last access date\"") (when (eq attribute (quote il:readdate)) (setq value (or (il:idate value) (error (quote il:invalid-argument-list) :argument value)))) (setq atime (make-unixtime :seconds (idate-to-unix value) :useconds 0))) (otherwise (when *nfs-debug* (format *trace-output* "In NFS-SETFILEINFO:  Unknown attribute ~a." attribute)) (return-from setfileinfo-internal nil))) (destructuring-bind (status result) (nfs-rpc dinfo *set-file-attributes* (list (fileinfo-filehandle finfo) (make-sattr :mode mode :uid uid :gid gid :size size :atime atime :mtime mtime))) (il:* il:\; "Mmm, what a tasty protocol") (cond ((eq status nfs-ok) (il:* il:\; "Success.  Update FINFO's FATTR") (setf (fileinfo-fattr finfo) result) t) (t (il:* il:\; "Return error code") status)))))(defun refresh-fileinfo-fattr (finfo dinfo &optional noerror) (destructuring-bind (status result) (nfs-rpc-get-file-attributes (fileinfo-filehandle finfo) dinfo) (cond ((eq status nfs-ok) (setf (fileinfo-fattr finfo) result)) (noerror (when *nfs-debug* (format *trace-output* "NFS: Get File Attributes for ~A returned ~a" (nfs-namestring (fileinfo-filepath finfo)) status)) nil) (t (error "NFS: Get File Attributes for ~A returned ~a" (nfs-namestring (fileinfo-filepath finfo)) (nfs-status-to-string status))))))(defun attribute-from-fattr (fattr attribute &optional fhandle dinfo) (il:* il:|;;| "Translate to Lisp sensibility the Unix fattr.  FHANDLE & DINFO only required for LINK and ALL") (case attribute (il:length (fattr-size fattr)) (il:is.directory (eq (fattr-type fattr) nfdir)) (il:size (il:foldhi (fattr-size fattr) bytesperpage)) (il:creationdate (il:* il:\; "Note: We (and Maiko) use MTIME for creation date.") (il:gdate (unix-to-idate (unixtime-seconds (fattr-mtime fattr))))) (il:writedate (il:* il:\; "Maiko uses MTIME again, but it's more useful to return something else.  This is \"Time status last changed\"") (il:gdate (unix-to-idate (unixtime-seconds (fattr-ctime fattr))))) (il:readdate (il:* il:\; "Actually, time of last access") (il:gdate (unix-to-idate (unixtime-seconds (fattr-atime fattr))))) (il:icreationdate (il:* il:|;;| "Note: We (and Maiko) use MTIME for creation and write date.") (unix-to-idate (unixtime-seconds (fattr-mtime fattr)))) (il:iwritedate (unix-to-idate (unixtime-seconds (fattr-ctime fattr)))) (il:ireaddate (unix-to-idate (unixtime-seconds (fattr-atime fattr)))) (il:bytesize 8) (il:protection (logand (fattr-mode fattr) *mode-protection*)) (type (evalcase (fattr-type fattr) (nfreg (and (fattr-binaryp fattr) (quote il:binary))) (nflnk (quote il:link)) (nfdir (quote il:directory)) (t (il:* il:\; "Other non-files") (quote il:binary)))) (il:author (yp:uid-name (fattr-uid fattr))) (il:group (yp:gid-name (fattr-gid fattr))) (il:group.id (fattr-gid fattr)) (il:link (and (eq (fattr-type fattr) nflnk) (destructuring-bind (status result) (nfs-rpc-read-link fhandle dinfo) (and (eq status nfs-ok) result)))) (fattr (il:* il:\; "For debugging") fattr) (il:all (il:bquote ((il:is.directory (il:\\\, (eq (fattr-type fattr) nfdir))) (il:length (il:\\\, (fattr-size fattr))) (il:creationdate (il:\\\, (attribute-from-fattr fattr (quote il:creationdate)))) (il:writedate (il:\\\, (attribute-from-fattr fattr (quote il:writedate)))) (il:readdate (il:\\\, (attribute-from-fattr fattr (quote il:readdate)))) (il:protection (il:\\\, (attribute-from-fattr fattr (quote il:protection)))) (type (il:\\\, (attribute-from-fattr fattr (quote type)))) (il:author (il:\\\, (attribute-from-fattr fattr (quote il:author)))) (il:group (il:\\\, (attribute-from-fattr fattr (quote il:group)))) (il:group.id (il:\\\, (attribute-from-fattr fattr (quote il:group.id)))) (il:link (il:\\\, (attribute-from-fattr fattr (quote il:link) fhandle dinfo))) (il:filetype (il:\\\, (fattr-type fattr))) (nlink (il:\\\, (fattr-nlink fattr))) (blocksize (il:\\\, (fattr-blocksize fattr))) (rdev (il:\\\, (fattr-rdev fattr))) (blocks (il:\\\, (fattr-blocks fattr))) (fsid (il:\\\, (fattr-fsid fattr))) (fileid (il:\\\, (fattr-fileid fattr)))))) (otherwise nil)))(il:* il:\; "Directory Enumeration")(defstruct dirgen (il:* il:|;;| "Structure to store state of enumeration of a particular directory.  This gets pushed onto the list of active generators in the top file generator state object") depth (il:* il:\; "NIL or an integer; 1 means don't recur.") dirinfo (il:* il:\; "The directory object from which we are working") files (il:* il:\; "List of file names (hash keys) still to be enumerated") hash (il:* il:\; "Dircache hash table") path (il:* il:\; "pathname whose directory is being enumerated") prefix (il:* il:\; "File must match this prefix before being considered for anything") prefix-length (il:* il:\; "Length of prefix") namepat (il:* il:\; "Name must match this after prefix.  NIL => any, :none => matching is done on whole name in conjunction with dirpat") dirpat (il:* il:\; "directory so far must patch prefix of this pattern") dirsofar (il:* il:\; "directory string so far to match") dirname (il:* il:\; "Full name of directory being enumerated, for ease in creating file names") dirname< (il:* il:\; "Same as DIRNAME, except when enumerating root, in which case it has a < so you can always concatenate a directory component") fattr (il:* il:\; "Attributes of file most recently enumerated") filehandle (il:* il:\; "file handle of same") current-root-name (il:* il:\; "Name (key) of files currently being produced") current-quoted-name (il:* il:\; "Same but quoted if necessary") quotep (il:* il:\; "true if current spelling ambiguous") current-versions (il:* il:\; "List of version numbers of that file yet to be produced") more-spellings (il:* il:\; "List of alternative spellings") next-generator (il:* il:\; "Pending generator object") link (il:* il:\; "Value of symbolic link of current file"))(defun nfs-generatefiles (device pattern desiredprops options &optional no-error) "Create generator for enumerating files in directory" (il:* il:|;;| "Note:  The gratuitous hair dealing with wildcards is an effort to make this behave the same as IFSes do.") (declare (special il:filing.enumeration.depth)) (multiple-value-bind (path device) (nfs-parse-namestring pattern device nil t) (unless path (return-from nfs-generatefiles (il:\\nullfilegenerator))) (let* ((dinfo (device-info device)) (dir (nfspath-directory path)) (name (nfspath-namebody path)) (namelen (length name)) (enumpath path) wilddir dirpat generator) (cond ((and (> namelen 2) (eql (char name (1- namelen)) #\*) (eql (char name (- namelen 2)) #\.)) (il:* il:|;;| "Pattern of form xxx*.* means xxx* to us, since extension field is not special.  Note that this is different from \"xxx*.\", which means extensionless files beginning xxx, and xxx.*, which means files named xxx with any (or null) extension") (setq name (cond ((eql (char name (- namelen 3)) #\*) (il:* il:\; "xxx*.* => xxx* but *.* => null pattern") (and (> namelen 3) (subseq name 0 (decf namelen 2)))) (t (il:* il:\; "Replace the .* with a character that pattern matcher will interpret as \"either .* or end of name\"") (setf (char name (1- (decf namelen))) #\Linefeed) (subseq name 0 namelen))))) ((not (position #\. name)) (il:* il:|;;| "No period in name means the original pattern must have terminated in period (dropped by nfs-parse-namestring), since otherwise the generic directory enumerator would have tacked \".*\" on the end.  So set flag that means \"extensionless files only\"") (setf (nfspath-namebody path) :null) (when (and (eql namelen 1) (eql (char name 0) #\*)) (il:* il:\; "The null pattern") (setq name nil)))) (cond ((and name (position #\' name)) (il:* il:\; "Get rid of quotes") (setq name (downcase-unquoted-chars name)))) (dolist (d dir) (when (il:strpos "*" d) (il:* il:\; "Wildcard in directory component") (setq wilddir d))) (when wilddir (il:* il:\; "Have to start at first dir without wildcard") (cond ((eq wilddir (first dir)) (il:* il:\; "Only last piece is wild") (setq dirpat wilddir)) (t (dolist (d dir) (when (eq d wilddir) (il:* il:\; "Wildcard in directory component") (setq dirpat (il:concatlist (cdr dirpat)))) (setq dirpat (list* ">" d dirpat))))) (setq dirpat (downcase-unquoted-chars dirpat)) (il:* il:\; "DIRPAT is pattern that must be satisfied") (setf (nfspath-directory path) (cdr (member wilddir dir :test (quote eq))))) (setq generator (make-file-generator path dinfo dirpat nil name (and (integerp il:filing.enumeration.depth) il:filing.enumeration.depth))) (cond ((dirgen-p generator) (il:* il:\; "Success") (let ((dirname (nfs-namestring path t))) (il:* il:|;;| "Fill in partial names that we can concatenate further pieces to") (setf (dirgen-dirname generator) dirname) (setf (dirgen-dirname< generator) (if (nfspath-directory path) dirname (string-concat dirname "<")))) (let ((version (nfspath-version path))) (il:* il:|;;| "Remember any explicitly requested version") (cond ((null version) (setf (nfspath-version path) :highest)) ((not (integerp version)) (setf (nfspath-version path) nil)))) (il:|create| il:filegenobj il:nextfilefn il:_ (quote nfs-nextfilefn) il:fileinfofn il:_ (quote nfs-fileinfofn) il:genfilestate il:_ (cons dinfo (list generator)))) (t (il:* il:\; "Failure") (when generator (il:* il:\; "A status code") (prompt-format "~&Can't enumerate ~a because ~a" (nfs-namestring path t) (if (eq generator nfs-err-noent) (il:* il:\; "Be more specific") "No such directory" (nfs-status-to-string generator)))) (il:\\nullfilegenerator))))))(defun make-file-generator (path dinfo dirpat dirsofar namepat depth) (multiple-value-bind (dirinfo status) (get-directory path dinfo nil :always) (unless dirinfo (return-from make-file-generator status)) (setf (nfspath-directory path) (nfspath-directory (dirinfo-path dirinfo))) (il:* il:\; "Canonicalize directory spelling") (let* ((files (dirinfo-files dirinfo)) prefix prefixlen) (cond ((null files) (il:* il:\; "Empty directory") (return-from make-file-generator nil)) (dirpat (il:* il:\; "Worrying about matching directories first") (when (null dirsofar) (il:* il:\; "First time in") (when (not (eql (char dirpat 0) #\*)) (il:* il:\; "We can restrict directory recursion to those matching this prefix") (let ((star (position #\* dirpat))) (setq prefix (subseq dirpat 0 star)) (setq dirpat (subseq dirpat star)))) (when (and namepat (not (eql (char namepat 0) #\*))) (il:* il:|;;| "Pattern is something like foo*bar>baz*.  In this case, we can't simply match the dir first and the name later, because then you could miss files like foobar>bar>baz because bar>baz doesn't match \"baz*\".  (When the name starts with *, you're safe, because the initial * will force any potential intermediate dirs to be included.)  So force us to match laboriously") (setq dirpat (string-concat dirpat ">" namepat)) (setq namepat :none)))) (namepat (il:* il:\; "Only matching names now") (let ((n (position #\* namepat))) (cond ((and (null n) (not (eql (char namepat (setq n (1- (length namepat)))) #\Linefeed))) (il:* il:\; "Enumerate a single name--no matching.  Second clause recognizes the \".*\" character") (setq files (member namepat files :test (quote string-equal))) (cond ((null files) (il:* il:\; "File not found") (return-from make-file-generator nil)) (t (il:* il:\; "Tell it this is the only file, and don't recur.") (setq files (list (car files))) (setq depth 1) (setq namepat nil)))) ((> n 0) (il:* il:\; "Everyone must match this prefix") (setq prefix (subseq namepat 0 n)) (il:* il:\; "And then have this suffix") (setq namepat (subseq namepat n))))))) (when (and (cdr files) (not (dirinfo-sorted-p dirinfo))) (il:* il:\; "Sort them.  Note that we don't do this when pattern lacks a *, as FILES is a list of one element then.") (setf (dirinfo-files dirinfo) (setq files (sort files (quote il:ualphorder))) (il:* il:\; "Faster than using STRING-LESSP") (dirinfo-sorted-p dirinfo) t)) (when prefix (il:* il:|;;| "Quickly advance FILES to the first matching member, taking advantage of the fact that list is sorted.  This saves us some overhead when there is no match at all, and allows nextfilefn to gracefully terminate at the first mismatch") (setq prefixlen (length prefix)) (il:while (string-lessp (first files) prefix) il:do (unless (setq files (cdr files)) (il:* il:\; "Ran out of files") (return-from make-file-generator nil))) (unless (and (>= (length (first files)) prefixlen) (string-equal (first files) prefix :end1 prefixlen)) (il:* il:\; "Missed it--we're already past the prefix") (return-from make-file-generator nil))) (make-dirgen :dirinfo dirinfo :files files :hash (dirinfo-hashtable dirinfo) :depth depth :path path :prefix prefix :prefix-length prefixlen :namepat namepat :dirpat dirpat :dirsofar dirsofar))))(defun nfs-nextfilefn (state &optional nameonly) (il:* il:|;;| "Called by IL:\\GENERATENEXTFILE.  Produces a full file name and alters state so that the fileinfofn will return attributes of same.  Returns NIL when enumeration exhausted") (il:block) (il:* il:\; "don't hog machine.") (destructuring-bind (dinfo . generators) state (prog (gen path versions current-spellings prefix prefixlen dirpat dirsofar namepat files namelen nextname spelling versionpairs matched thisdir newgen version filetype) top (cond ((null generators) (il:* il:\; "Exhausted") (return nil)) ((setq newgen (dirgen-next-generator (setq gen (first generators)))) (il:* il:\; "Last invocation created a subgenerator to work with.  Reason we didn't smash STATE then was so that FILEINFOFN could find the current one in the case where the subdirectory also satisfied pattern") (setf (dirgen-next-generator gen) nil) (setf (cdr state) (setq generators (cons (setq gen newgen) generators))) (setq newgen nil)) ((setq versions (dirgen-current-versions gen)) (il:* il:\; "We're enumerating these versions of a file") (gfs-lookup gen dinfo (make-versioned-filename (dirgen-current-root-name gen) (first versions))) (il:* il:\; "Get attributes") (setf (dirgen-current-versions gen) (cdr versions)) (return (string-concat (dirgen-dirname gen) (dirgen-current-quoted-name gen) ";" (string-from-integer (first versions)))))) (setq path (dirgen-path gen)) (setq prefix (dirgen-prefix gen)) (setq prefixlen (dirgen-prefix-length gen)) (when (setq dirpat (dirgen-dirpat gen)) (setq dirsofar (dirgen-dirsofar gen))) (setq namepat (dirgen-namepat gen)) (when (setq current-spellings (dirgen-more-spellings gen)) (il:* il:\; "More spellings of an earlier name, can skip the prefix testing") (when namepat (il:* il:\; "Clear this variable from possible previous iteration.  gfs-match will compute it if it needs to.") (setq namelen nil)) (go nextspelling)) freshkey (il:* il:|;;| "At this point, we have nothing left over from previous spellings.  Start afresh, trying to match against the next file") (setq files (dirgen-files gen)) nextname (when (null files) (il:* il:\; "This generator is exhausted.  Pop up one.") (go exhausted)) (setq namelen (length (setq nextname (pop files)))) (when (and prefix (not (and (>= namelen prefixlen) (string-equal nextname prefix :end1 prefixlen)))) (il:* il:\; "Prefix fails, so we must now be past the matching names (make-file-generator assured the first file matched, and file list is sorted)") (go exhausted)) (when (and (> namelen 6) (eql (char nextname 0) #\.) (eql (char nextname 1) #\~) (string= nextname "case" :start1 2 :end1 6)) (il:* il:\; "Ignore cedar .~case files") (go nextname)) (unless (setq current-spellings (gethash nextname (dirgen-hash gen))) (il:* il:\; "This can be null if someone concurrently removed this file from the directory.  Just forget we were going to do anything with it") (go nextname)) (setf (dirgen-quotep gen) (and (cdr current-spellings) t)) (setf (dirgen-files gen) files) (il:* il:\; "Save this state") nextspelling (il:* il:|;;| "At this point, the key we're working on has passed the prefix test, so (1) if it's a directory, we will recur, and (2) if it matches rest of pattern, we can produce it. ") (setf spelling (first current-spellings) (dirgen-more-spellings gen) (setq current-spellings (cdr current-spellings))) (setq nextname (car spelling)) (setq versionpairs (cddr spelling)) (cond (dirpat (il:* il:\; "Have messy directory matching to do here") (when (and versionpairs (not (eq namepat :none))) (il:* il:\; "This thing has versions, so isn't a directory, so the best we could do is match at this level, but that can only happen if we are matching the name and directory together.") (if current-spellings (go nextspelling) (go freshkey))) (setq matched (gfs-match (setq thisdir (if dirsofar (string-concat dirsofar ">" nextname) nextname)) dirpat))) (t (il:* il:\; "Just matching names") (setq matched (cond ((null namepat) (il:* il:\; "Everything matches (pattern was * or prefix*)") t) (t (il:* il:|;;| "Match pattern following non-wildcard prefix (if any).  namelen is either the length of nextname (as computed at tag nextname for one of these spellings) or nil if we are coming in after working on the same spelling.  We really don't need to do this match for every spelling, but multiple spellings are rare, and I didn't want to make the logic here more contorted than necessary.") (gfs-match nextname namepat prefixlen namelen)))) (when (and (eq matched t) (eq (nfspath-namebody path) :null) (position #\. nextname)) (il:* il:\; "We are searching for only extensionless files, and this file has a period in it--reject it, but allow recursive enumeration as if whole name matched") (setq matched (if namepat (length namepat) 0))))) (setf (dirgen-link gen) nil) (il:* il:\; "Clear any link info from previous iteration") (when (and (null versionpairs) (il:* il:\; "Might be a directory") (gfs-lookup gen dinfo nextname)) (il:* il:|;;| "See if this is a directory, in which case we have to recur. ") (when (and (eql (setq filetype (fattr-type (dirgen-fattr gen))) nflnk) *directory-follow-links* (gfs-chase-link dinfo gen)) (il:* il:\; "resolved link, refetch type") (setq filetype (fattr-type (dirgen-fattr gen)))) (when (and (eql filetype nfdir) (not (and namepat (eql (char namepat 0) #\Linefeed)))) (il:* il:|;;| "Yes, it's a directory, so we'll want to enumerate in it (depth permitting).  The second clause weeds out the case where the pattern is FOO.* and we just matched directory FOO.  In this case, we have a match on the directory (well, sort of), but we can't recur.") (setq newgen (gfs-recur gen nextname matched dinfo thisdir)))) (when (and (eq matched t) (or (not dirpat) (eq namepat :none))) (il:* il:|;;| "We have a match.  Second clause eliminates the case where we matched the directory, but still have a name to match at a lower level.  Return the appropriate first version") (setq version (nfspath-version path)) (il:* il:\; "Version requested: One of NIL (any), integer, :highest.") (cond ((null versionpairs) (il:* il:\; "No versions, just the versionless thing, which we present as version 1 (if not a dir).  We've already looked up attributes") (when (or (not version) (eq version :highest) (eql version 1)) (il:* il:\; "This is both the highest and only version, so only flake out if asked for some non-1 version") (return (if (eql filetype nfdir) (string-concat (dirgen-dirname< gen) (escape-uppercase-chars nextname) ">") (string-concat (dirgen-dirname gen) (if (dirgen-quotep gen) (escape-uppercase-chars nextname) nextname) ";1"))))) (t (il:* il:\; "There are numbered versions.  Nothing is a directory (by fiat).  We have not looked anything up yet") (let ((nullversion (and (second spelling) (not (version-from-fileid (second spelling) versionpairs)) (1+ (car (first versionpairs)))))) (il:* il:\; "NULLVERSION is the virtual version number of the versionless file, in the case where it is not linked to one of the versioned files") (unless (and (integerp version) (not (eql version nullversion)) (not (assoc version versionpairs))) (il:* il:\; "If explicit version number is not found, we can skip all this") (return (let ((name (if (dirgen-quotep gen) (escape-uppercase-chars nextname) nextname)) (thisversion (if (integerp version) version (or nullversion (car (first versionpairs)))))) (il:* il:\; "THISVERSION is the version we return now.  Always highest first, unless explicit version # requested") (gfs-lookup gen dinfo (if (eql thisversion nullversion) nextname (make-versioned-filename nextname thisversion))) (il:* il:\; "Get attributes of the first (possibly only) file we will return") (prog1 (string-concat (dirgen-dirname gen) name ";" (string-from-integer thisversion)) (unless (or version (and (not nullversion) (null (cdr versionpairs)))) (il:* il:|;;| "There are more versions to enumerate after this, so save state") (setf (dirgen-current-root-name gen) nextname (dirgen-current-quoted-name gen) name (dirgen-current-versions gen) (mapcar (function car) (if nullversion versionpairs (cdr versionpairs))))))))))))) (il:* il:|;;| "Didn't return a file, so go try another") (cond (newgen (il:* il:\; "We need to go down a level") (setq newgen nil) (go top)) (current-spellings (go nextspelling)) (t (go nextname))) exhausted (setf (cdr state) (setq generators (cdr generators))) (go top))))(defun nfs-fileinfofn (state attribute) "Get value of ATTRIBUTE of last file generated in enumeration" (destructuring-bind (dinfo gen) state (let ((fattr (dirgen-fattr gen))) (and fattr (case attribute (il:link (dirgen-link gen)) (fileinfo (il:* il:\; "Hack to return a FILEINFO to someone while enumerating.") (values (make-fileinfo :fattr fattr :dirinfo (dirgen-dirinfo gen) :filehandle (dirgen-filehandle gen)) dinfo)) (otherwise (attribute-from-fattr fattr attribute (dirgen-filehandle gen) dinfo)))))))(defun gfs-chase-link (dinfo gen) (il:* il:|;;| "The thing GEN just produced is a symbolic link.  Try following it.  Fills in the LINK field with the immediate link value.  Returns T if it succeeded in looking up the link. ") (prog ((path (dirgen-path gen)) (filehandle (dirgen-filehandle gen)) fattr dirinfo success) top (destructuring-bind (status linkname) (nfs-rpc-read-link filehandle dinfo) (cond ((eq status nfs-ok) (unless success (il:* il:\; "Only record the first link") (setf (dirgen-link gen) linkname)) (multiple-value-bind (newpath newdinfo) (parse-link-name linkname path dinfo) (cond ((and newpath (eq newdinfo dinfo) (il:* il:\; "Don't cross machines") (setq dirinfo (get-directory newpath dinfo))) (destructuring-bind (status result) (nfs-rpc-lookup-file dinfo dirinfo (downcase-unquoted-chars (nfspath-namebody newpath))) (cond ((eq status nfs-ok) (setq success t) (setf (dirgen-filehandle gen) (setq filehandle (diropres-file result))) (setf (dirgen-fattr gen) (setq fattr (diropres-attributes result))) (when (eql (fattr-type fattr) nflnk) (il:* il:\; "Keep chasing") (setq path newpath) (go top))))))))))) (return success)))(defun gfs-lookup (gen dinfo rawname) (il:* il:|;;| "Lookup existing file RAWNAME in the directory specified by GEN and fill in fattr and file handle.  Return NIL on failure.") (destructuring-bind (status result) (nfs-rpc-lookup-file dinfo (dirgen-dirinfo gen) rawname) (setf (dirgen-fattr gen) (cond ((eql status nfs-ok) (setf (dirgen-filehandle gen) (diropres-file result)) (diropres-attributes result))))))(defun gfs-match (name pattern &optional namestart nameend patstart patend) (il:* il:|;;| "Match NAME against PATTERN starting at NAMESTART and PATSTART, respectively (default to 0).  Return T if complete match, or index in PATTERN of the first * we matched thru.  NAMEEND & PATEND are internal optimization.") (unless namestart (setq namestart 0)) (unless patstart (setq patstart 0)) (unless nameend (setq nameend (length name))) (unless patend (setq patend (length pattern))) (prog (patchar laststar match) lp (unless (< patstart patend) (il:* il:\; "Ran out of pattern, so I hope we ran out of name, too") (return (if (eql namestart nameend) t laststar))) (setq patchar (char pattern patstart)) (case patchar (#\* (il:* il:\; "Wild--fall thru")) (#\Linefeed (il:* il:\; "Matches any (or null) extension") (return (if (or (>= namestart nameend) (il:* il:\; "Ran out of name, i.e. null extension") (eql (char name namestart) #\.) (il:* il:\; "Start of extension")) t laststar))) (otherwise (il:* il:|;;| "Simple character by character match") (cond ((>= namestart nameend) (il:* il:\; "Ran out of name") (return laststar)) ((char-equal patchar (char name namestart)) (il:* il:\; "Case-insensitive match") (incf namestart) (incf patstart) (go lp)) (t (il:* il:\; "Match failed") (return nil))))) (il:* il:|;;| "Handle wildcard * -- match arbitrary segment") (when (eql (1+ patstart) patend) (il:* il:\; "No more pattern, so we win") (return t)) (setq laststar patstart) (il:* il:\; "Remember we got this far") (il:* il:|;;| "Now look for a place on NAME that can match the tail of pattern") (setq patchar (char pattern (incf patstart))) wildlp (unless (< namestart nameend) (il:* il:\; "Ran out of name") (return laststar)) (when (and (char-equal patchar (char name namestart)) (setq match (gfs-match name pattern (1+ namestart) nameend (1+ patstart) patend))) (il:* il:\; "The CHAR-EQUAL is an optimization to avoid the expensive recursion until we actually have a potential starting place.") (cond ((eq match t) (il:* il:\; "Success--the whole thing matched") (return t)) ((or (null laststar) (> match laststar)) (il:* il:\; "We know we can match at least this far") (setq laststar match)))) (incf namestart) (go wildlp)))(defun gfs-recur (gen newdir matched dinfo dirsofar) (il:* il:|;;| "Return a generator that will generate the contents of NEWDIR underneath the dir being handled in GEN.  MATCHED is the outcome of matching the pattern at GEN's level.  DIRSOFAR, in the case where there is a directory pattern, shows the cumulative directory to be matched.") (il:* il:\; "Ought to be able to utilize the handle we have on this dir") (let ((dirpat (dirgen-dirpat gen)) (namepat (dirgen-namepat gen)) (depth (dirgen-depth gen)) newgen) (when (and depth (<= depth 1)) (il:* il:\; "Terminate here") (return-from gfs-recur nil)) (cond (dirpat (when (and (eq matched t) (not (eq namepat :none))) (il:* il:\; "We have done our deed: matched the directory part, so now we need only do name matching") (setq dirpat nil))) ((and namepat matched) (il:* il:\; "We need only match the unmatched suffix on levels below") (let ((namelen (length namepat))) (setq namepat (cond ((or (eql matched namelen) (and (eq matched t) (eq (char namepat (1- namelen)) #\*))) (il:* il:\; "Matched thru the final *") nil) (t (subseq namepat (if (integerp matched) matched (position #\* namepat :from-end t) (il:* il:\; "Matched whole pattern, but pattern didn't end in *, so will still have to match the final segment at lower levels"))))))))) (when (dirgen-p (setq newgen (make-file-generator (let ((path (copy-nfspath (dirgen-path gen)))) (il:* il:|;;| "Same path with an additional directory on the front") (push (escape-uppercase-chars newdir) (nfspath-directory path)) path) dinfo dirpat dirsofar namepat (and depth (1- depth))))) (il:* il:|;;| "Fill in the directory's name parts, and push it on for generating next time thru") (setf (dirgen-dirname newgen) (setf (dirgen-dirname< newgen) (string-concat (dirgen-dirname< gen) (escape-uppercase-chars newdir) ">"))) (setf (dirgen-next-generator gen) newgen) (il:* il:\; "Tell old generator to start working on this one next chance it gets") newgen)))(il:* il:\; "Name parsing and reassembly")(defstruct (nfspath (:print-function print-nfspath)) "PATHNAME as parsed for NFS." host directory (il:* il:\; "A list of directory components in reverse order") namebody (il:* il:\; "Name.ext") version)(defun print-nfspath (object stream depth) (format stream "#<Path ~A>" (nfs-namestring object)))(defun nfs-namestring (path &optional dironly fattr exact) (il:* il:|;;| "Return file name string for PATH.  If DIRONLY, we skip the name;version part.  If FATTR is given, we use it to determine whether the file is actually a directory, in which case EXACT tells whether we have to quote the uppercase chars in it.  FATTR is ignored when DIRONLY is true") (let ((host (nfspath-host path)) (dir (nfspath-directory path)) pieces) (unless dironly (il:* il:\; "Otherwise, drop out after the dir") (let ((version (nfspath-version path)) (body (nfspath-namebody path))) (cond ((and fattr (eql (fattr-type fattr) nfdir) (or (null version) (eql version 1))) (il:* il:\; "Going to render this as a directory") (when body (push (if exact body (escape-uppercase-chars body)) dir))) (t (when version (setq pieces (list ";" version))) (when body (push body pieces)))))) (when dir (dolist (d dir) (setq pieces (list* d ">" pieces))) (push "<" pieces)) (when host (setq pieces (list* "{" host "}" pieces))) (il:concatlist pieces)))(defun unix-dir-from-list (dirlist) (il:* il:|;;| "Turn a dirlist from an nfspath into a unix pathname") (let (pieces) (dolist (d dirlist) (setq pieces (list* "/" d pieces))) (il:concatlist pieces)))(defun nfs-parse-namestring (thing &optional fdev noerror patternp) (il:* il:|;;| "Custom parsing of symbol, string, or path.  Leaves case of HOST alone.  Converts DEVICE, DIRECTORY, NAME, and TYPE to lower case.  Converts :WILD to * in NAME, TYPE, and VERSION.  Converts :NEWEST to NIL in VERSION") (and thing (il:* il:\; "NIL => NIL.  Maybe should be an error") (prog (path hostname device dir name type version dotpos semipos token-start char lastindex pointer subdir warned realdev) (etypecase thing (symbol (setq thing (string thing))) (string) (nfspath (il:* il:\; "Already parsed.  Assume caller has the device already right.") (return (values thing fdev))) (pathname (il:* il:\; "Already parsed somehow, but we should take care of dir") (setq hostname (il:%pathname-host thing)) (when (il:%pathname-device thing) (go invalid)) (when (eq (setq name (il:%pathname-name thing)) :wild) (setq name "*")) (when (eq (setq type (il:%pathname-type thing)) :wild) (setq type "*")) (when (and type (> (length type) 0)) (setq name (string-concat name "." type))) (cond ((eq (setq version (il:%pathname-version thing)) :wild) (setq version "*")) ((eq version :newest) (il:* il:\; "Shouldn't have to do this") (setq version nil))) (when (setq dir (parse-dir-string (il:%pathname-directory thing))) (dolist (d dir) (il:* il:\; "Make sure there are no empty subdirectories") (unless (> (length d) 0) (go invalid)))) (go end))) (il:* il:|;;| "Need to parse THING.") (setq lastindex (1- (length thing))) (unless (>= lastindex 0) (go end)) (case (setq char (char thing (setq pointer 0))) ((#\{ #\[ #\() (prog ((hostchar (cdr (assoc char (quote ((#\{ . #\}) (#\[ . #\]) (#\( . #\)))))))) host (unless (< pointer lastindex) (go invalid)) (setq char (char thing (incf pointer))) (unless (eq char hostchar) (when (eq char #\') (incf pointer)) (go host)) (when nil (il:* il:\; "We will get host name from device--no point consing here") (setq hostname (il:substring thing 2 pointer))) (unless (< pointer lastindex) (go end)) (setq char (char thing (incf pointer)))))) (case char ((#\< #\/) (unless (< pointer lastindex) (go invalid)) (setq char (char thing (setq token-start (incf pointer))))) (t (il:* il:\; "Might want to note here that there's no opening dir char, for if/when we implement relative pathnames") (setq token-start pointer))) name (case char (#\; (setq semipos pointer)) ((#\> #\/) (il:* il:\; "Accumulate another subdir") (cond ((> pointer token-start) (push (subseq thing token-start pointer) dir)) ((null dir) (il:* il:\; "Extra leading slashes we just ignore.  This is mostly for benefit of silly links")) (t (go invalid))) (setq token-start (1+ pointer) dotpos nil semipos nil)) (#\' (incf pointer)) (#\. (unless dotpos (setq dotpos pointer)))) (when (< pointer lastindex) (setq char (char thing (incf pointer))) (go name)) (il:* il:|;;| "End of token, so gather up the remaining pieces.  POINTER = LASTINDEX.") (let ((nameend (or semipos (1+ lastindex)))) (when (> nameend token-start) (il:* il:\; "There was a name portion") (setq name (subseq thing token-start (if (and dotpos (eql dotpos (1- nameend)) (> dotpos token-start)) (1- nameend) (il:* il:\; "drop the final dot of extensionless names--it's usually an artifact of packfilename") nameend))))) (when (and semipos (< semipos lastindex)) (il:* il:\; "Parse the version field as a number.") (unless (setq version (yp:integer-from-string thing (1+ semipos) (1+ lastindex))) (il:* il:|;;| "Bad version field unless this is a pattern") (if (and patternp (eql semipos (1- lastindex)) (eql char #\*)) (setq version "*") (go invalid)))) end (when dir (il:* il:\; "Handle expansion of ~ etc.") (multiple-value-bind (realdev d w) (adjust-volume dir noerror) (when realdev (setq fdev realdev) (setq dir d)) (setq warned w))) (unless (and fdev (typep fdev (quote il:fdev)) (not (eq (record-fetch fdev devicename fdev) (quote il:nfs)))) (il:* il:\; "No device for this") (unless (or noerror warned) (prompt-format "~&Can't locate NFS volume in path ~A" thing)) (return nil)) (setq path (make-nfspath :host (deviceinfo-downhost (device-info fdev)) :directory dir :namebody name :version version)) (when (and (numberp *nfs-debug*) (> *nfs-debug* 0)) (format *debug-io* "NFS-PARSE-NAMESTRING: ~A ->~%{ ~A }< ~A > ~A ; ~A" thing (nfspath-host path) (nfspath-directory path) (nfspath-namebody path) (nfspath-version path))) (return (values path fdev)) invalid (return (and (not noerror) (error (quote invalid-pathname) :pathname thing))))))(defun parse-dir-string (str) (il:* il:|;;| "Takes a string representing a directory component, e.g., foo>bar and returns the pieces as a list in reverse order, e.g., (bar foo).") (and str (let ((end (length str)) (start 0) (i 0) dir) (loop (unless (< (incf i) end) (il:* il:\; "Got to the end") (return (cond ((> start 0) (il:* il:\; "Accumulate final dir") (push (subseq str start end) dir) dir) ((> end 0) (list str))))) (case (char str i) (#\' (il:* il:\; "Next char is quoted") (incf i)) ((#\> #\/) (push (subseq str start i) dir) (setq start (1+ i))))))))(defun adjust-volume (dirlst &optional nowarn notilde) (il:* il:|;;| "See if the first dir in the path (i.e., last in DIRLST) is special--home directory or a volume we know about.  If so, destructively modify DIRLST to reflect correct path.  Returns (up to) 3 values: the actual device that path can be found on, the revised dirlist, and a flag that is true if we have printed warnings in the prompt window.") (let* ((tail (last dirlst)) (firstdir (car tail)) homespec expanded realdev host warned) (cond ((and (setq expanded (cond ((and (not notilde) (eql (char firstdir 0) #\~)) (il:* il:\; "User's home dir") (cond ((setq homespec (lookup-home-dir firstdir))) (t (il:* il:\; "Explain here why we fail") (unless nowarn (prompt-format "~&NFS: Unrecognized user name ~A" firstdir) (setq warned t)) nil))) (*use-volume-map* (find-volume firstdir dirlst)))) (il:* il:\; "EXPANDED = (host . path)") (cond ((and (setq host (car expanded)) (setq realdev (il:\\getdevicefromhostname host))) (il:* il:\; "Found the host") t) (t (il:* il:\; "Can't find the other host for whatever reason.  Only proceed when this is a home dir expansion") (when (and (not nowarn) host) (prompt-format "~&Can't find host ~A to look up volume ~A" host firstdir) (setq warned t)) homespec))) (setq expanded (cdr expanded)) (values realdev (cond (homespec (il:* il:|;;| "Fill in the home components at the \"front\" of the directories.  FIND-VOLUME already did this for the non-home case.") (rplaca tail (car expanded)) (rplacd tail (cdr expanded)) dirlst) (t expanded)) warned)))))(defun rootname-from-pathname (path &optional exact) (il:* il:|;;| "Return the name.ext part of path.  If EXACT is true, we leave it exactly as we found it; otherwise we downcase it.") (let ((name (nfspath-namebody path))) (cond (exact name) ((and *preserve-case* (not (position #\' name))) (il:* il:\; "Preserve user's case unless explicit quotes") name) (t (downcase-unquoted-chars name)))))(defun rawname-from-pathname (path) (il:* il:|;;| "Returns the native syntax for file we know as PATH") (let ((name (downcase-unquoted-chars (nfspath-namebody path))) (version (nfspath-version path))) (if version (string-concat name ".~" (string-from-integer version) "~") name)))(defun make-versioned-filename (versionlessname version) (il:* il:|;;| "Produce a filename in nfs funny version syntax") (string-concat versionlessname ".~" (string-from-integer version) "~"))(defun downcase-unquoted-chars (string &optional start end leavequotes) (and string (do* ((start (or start 0)) (end (or end (length string))) (fillptr (- end start)) (result (make-array fillptr :element-type (quote string-char) :fill-pointer fillptr)) (i start (incf i)) (j -1) (ch)) ((>= i end) (setf (fill-pointer result) fillptr) result) (cond ((char= (setq ch (char string i)) #\') (il:* il:\; "Don't lowercase the next char") (cond (leavequotes (il:* il:\; "But keep the quote") (setf (char result (incf j)) #\')) (t (il:* il:\; "Skip the quote, so output will have one less char") (decf fillptr))) (setf (char result (incf j)) (char string (incf i)))) (t (setf (char result (incf j)) (char-downcase ch)))))))(il:* il:\; "NFS Utilities")(defvar *temp-filename-counter* 1)(defun escape-uppercase-chars (string &optional start end slashok) (il:* il:|;;| "This is here because this NFS implementation handles Lisp's need for case insensitivity by downcasing file names.  It expects files on the server to have lowercase names.  In order not to lose totally when seeing filenames with uppercase, preface uppercase chars with \"'\" to distinguish them.  This is not related to the .~case~ hack, which affects enumerations only.") (do* ((funnychars (if slashok (quote (#\' #\; #\>)) (quote (#\' #\; #\> #\/)))) (start0 (or start 0)) (end0 (or end (length string))) (nbad 0) (i start0 (1+ i)) ch) ((>= i end0) (il:* il:\; "Done") (cond ((eql nbad 0) (il:* il:\; "Nothing to quote") (if (or start end) (subseq string start end) string)) (t (il:* il:\; "Need to build a new string") (do* ((result (make-string (+ (- end0 start0) nbad))) (j -1) (i start0 (1+ i))) ((>= i end0) (il:* il:\; "Done") result) (when (or (char< #\@ (setq ch (char string i)) #\[) (member ch funnychars :test (quote eq))) (il:* il:\; "Need to quote it") (setf (char result (incf j)) #\')) (setf (char result (incf j)) ch))))) (when (or (char< #\@ (setq ch (char string i)) #\[) (member ch funnychars :test (quote eq))) (il:* il:\; "Need to quote it") (incf nbad))))(defun lookup-home-dir (~dir) (il:* il:|;;| "~DIR is a single component of a directory \"name\" beginning with \"~\".  We turn it into (host . path), where hosts is where the dir really lives and path is the real directory, as a list in reverse order.  host = NIL if we don't know the correct host") (let ((dirlength (length ~dir)) creds) (and (setq creds (cond ((eql dirlength 1) (il:* il:\; "Directory is just \"~\", so means user's home dir") (or *nfs-credentials* (get-nfscredentials))) (t (il:* il:\; "\"~name\" means name's home dir") (get-nfscredentials (subseq ~dir 1 dirlength))))) (nfscredentials-homedir creds))))(defun temp-name-for-file (filename) (il:* il:|;;| "Returns the unix name that we call FILENAME until it is closed the first time.  This lets us figure out whether someone (including us) is trying to write some version of the file so we can choose a higher version.") (string-concat ".temp-" filename))(defun make-temp-filename (&optional (prefix ".temp")) (format nil "~A-~d-~d" prefix (incf *temp-filename-counter*) (logand (il:idate) 1023)))(defun reset-nfs-cache-vars nil (dolist (v *nfs-cache-vars*) (set v nil)))(defun local-machine-name nil (fifth il:\\ip.default.configuration))(defun versions-from-hashentry (key entry) (il:* il:|;;| "Returns the versions list exactly matching KEY in the directory cache hash table value ENTRY.  If ENTRY is a hash table, we retrieve the entry first.  Roughly, an open coding of (assoc key entry :test 'string=)") (dolist (subentry (if (hash-table-p entry) (il:gethash key entry) entry)) (when (string= (car subentry) key) (return subentry))))(defun version-from-fileid (fileid versionpairs) (il:* il:|;;| "Returns the element of VERSIONPAIRS whose ID matches FILEID") (il:* il:|;;| "I thought I could do this with (assoc fileid versionpairs :key 'second), but :key means something else!") (dolist (pair versionpairs) (when (eql (second pair) fileid) (return pair))))(il:* il:\; "error handling")(defun nfs-handle-error (code caller stream &optional noncontinuable) (il:* il:|;;| "Call when you get an error CODE returned from some NFS rpc call.  Can return, in which case you're expected to retry.") (let* ((name (and stream (if (streamp stream) (il:fullname stream) (nfs-namestring stream)))) (condition (cond ((eq code nfs-err-dquot) (make-condition (quote fs-resources-exceeded) :pathname name)) ((eq code nfs-err-acces) (make-condition (quote fs-protection-violation) :pathname name)) (t (make-condition (quote simple-error) :format-string "~A failed~@[ for ~A~] because: ~A" :format-arguments (list caller name (nfs-status-to-string code))))))) (cond ((streamp stream) (il:* il:\; "With handle on stream, offer the \"trash the stream\" option") (if noncontinuable (restart-case (error condition) (il:giveup nil :report "Abort: close the stream and abort the computation" (destroy-stream stream) (abort))) (proceedable-error stream condition))) (noncontinuable (error condition)) (t (cerror "Retry the operation" condition)))))(defun stream-changed (stream fattr filehandle) (il:* il:|;;| "Called when trying to reestablish STREAM.  FATTR & FILEHANDLE are new stat of the file, which shows that the file has changed with respect to STREAM's handle.  Returning from this function will continue by using the new handle. ") (proceedable-error stream "The file ~A has been modified (at ~A) since you last accessed it.  How shall I proceed?" (list (il:fullname stream) (nice-date-string (getvalidation fattr))) (cond ((il:dirtyable stream) "Continue output to the file, possibly overwriting its more recent contents") (t "Continue, reading the new contents of the file"))) (unless (eq (il:|fetch| il:accessbits il:|of| stream) il:|OutputBits|) (il:* il:\; "reset eof to correct value") (let ((len (fattr-size fattr))) (setf (stream-epage stream) (ash len (- logbytesperpage))) (setf (stream-eoffset stream) (logand len (1- bytesperpage))))))(defun proceedable-error (stream error &optional errorargs proceed-details) (il:* il:\; "Edited  5-Feb-88 13:45 by amd") (il:* il:|;;| "Enter the debugger because of a problem with STREAM.  ERROR and ERRORARGS are passed to ERROR.  PROCEED-DETAILS, if non-NIL, is a format string describing what will happen if you choose the proceed option PROCEED (or OK).  Returns only if CONTINUE was selected.") (restart-case (apply (function error) error errorargs) (continue nil :report (lambda (err-strm) (format err-strm (or proceed-details "Try again") errorargs))) (il:giveup nil :report "Abort: close the stream and abort the computation" (destroy-stream stream) (abort))))(defun destroy-stream (stream) (il:* il:|;;| "Blow away stream in a way that we won't keep dying.  CLOSEF will just keep trying to write pages otherwise.") (il:uninterruptably (il:\\releasecpage stream)) (il:forgetpages stream) (il:* il:\; "Discard buffers before closing file, so that CLOSEF doesn't try to write anything.") (setf (fileinfo-plist (stream-info stream)) nil) (il:* il:\; "So CLOSEF won't try to write the real version, date, etc.") (il:closef stream) (il:* il:\; "Blow away the stream."))(il:* il:\; "Directory Cache")(defvar *directory-cache-timeout* 10 "Smallest length of time (in seconds) that we will assume underlying dir hasn't changed.")(defstruct (dirinfo (:print-function print-dirinfo)) "Info about a remote directory, may included cache of files in it" path (il:* il:\; "A NFSPATH for directory in Lisp form.  Only the host and directory fields are relevant") unixpath (il:* il:\; "The raw pathname we could give to mount") unixname (il:* il:\; "The last name in the path") parent (il:* il:\; "DIRINFO of parent directory") dirhandle (il:* il:\; "fhandle of directory (nil if stale)") fattr (il:* il:\; "fattr for last lookup") dir-timestamp (il:* il:\; "Unix time dir last written (from fattr, NIL if cache is empty)") meta-timestamp (il:* il:\; "Lisp time dir-timestamp last checked.") hashtable (il:* il:\; "Hash of filenames without versions to list of versions and their file-ids.") files (il:* il:\; "A list of the filenames in directory (keys in hashtable).") sorted-p (il:* il:\; "T if FILES list sorted.") monitorlock (il:* il:\; "Hold this while re-caching."))(defun print-dirinfo (object stream depth) (let ((stamp (dirinfo-meta-timestamp object))) (format stream "#<Dir ~a on ~a~:[~; (~d entries) as of ~a~]>" (dirinfo-unixpath object) (nfspath-host (dirinfo-path object)) (dirinfo-dir-timestamp object) (length (dirinfo-files object)) (if (eql stamp 0) "unknown" (nice-date-string stamp)))))(defun nice-date-string (d) (il:* il:|;;| "Return a string representation of internal date D that is not needlessly wordy by comparing with present date") (il:gdate d (if (< (- (il:idate) d) (* 60 60 12)) (il:* il:\; "If within last 12 hours, omit date") (il:dateformat il:no.date) (il:dateformat il:no.seconds))))(defun get-directory (dirpath dinfo &optional unixpath fillcache dirhandle fattr parent) (il:* il:|;;| "Look up the directory given in DIRPATH for device given by DINFO and return a DIRINFO object.  On failure, returns NIL and a status code.  UNIXPATH is optionally the raw unix name (one we could mount), or :EXACT, meaning that DIRPATH contains an exact path in its directory field.  If DIRHANDLE, FATTR, PARENT are supplied, they are directory handle, fatter and parent directory info we have already obtained on the directory, so we don't need to look it up.") (let ((dirlst (nfspath-directory dirpath)) exact dirinfo) (when (eq unixpath :exact) (il:* il:|;;| "Caller is using EXACT recognition, so look up this exact unix name") (setq exact t) (setq unixpath (unix-dir-from-list dirlst))) (il:with.monitor (deviceinfo-monitorlock dinfo) (il:* il:\; "First grab or make a directory entry for this guy.") (unless (setq dirinfo (find-directory-info (or unixpath dirlst) dinfo)) (il:* il:|;;| "Didn't find one matching DIRPATH exactly.  Try a little harder before giving up and making a new one") (let* ((unixdirs (if exact dirlst (mapcar (function downcase-unquoted-chars) dirlst))) (lispdirs (mapcar (function escape-uppercase-chars) unixdirs))) (unless (and (not unixpath) (not (equalp lispdirs dirlst)) (setq dirinfo (find-directory-info lispdirs dinfo))) (il:* il:\; "Tried again after canonicalizing the dir (which changed some quotes) and still didn't find it") (push (setq dirinfo (make-dirinfo :path (make-nfspath :host (deviceinfo-downhost dinfo) :directory lispdirs) :unixpath (or unixpath (unix-dir-from-list unixdirs)) :unixname (if (consp unixdirs) (first unixdirs) "") :dir-timestamp nil :meta-timestamp 0 :monitorlock (il:create.monitorlock unixpath))) (deviceinfo-directories dinfo)))))) (il:with.monitor (dirinfo-monitorlock dirinfo) (let ((result (cond (dirhandle (il:* il:\; "Caller has looked it up") (setf (dirinfo-dirhandle dirinfo) dirhandle (dirinfo-fattr dirinfo) fattr (dirinfo-parent dirinfo) parent) dirinfo) ((dirinfo-dirhandle dirinfo) (il:* il:\; "Looked up in the past") (if (dirinfo-fattr dirinfo) dirinfo (multiple-value-list (refresh-dirinfo-fattr dirinfo dinfo)))) (t (il:* il:\; "Have to look it up") (multiple-value-list (refresh-dirinfo dirinfo dinfo)))))) (cond ((and (consp result) (cdr result)) (il:* il:\; "Error occurred ") (values-list result)) (t (when fillcache (il:* il:\; "Caller wants cache filled") (let ((now (get-meta-timestamp)) didnt-check) (unless (or fattr (consp result) (il:* il:\; "Just got a fresh fattr") (and (not (eq fillcache :always)) (setq didnt-check (< (- now (dirinfo-meta-timestamp dirinfo)) *directory-cache-timeout*)))) (il:* il:\; "Get a fresh fattr") (when (cdr (setq result (multiple-value-list (refresh-dirinfo-fattr dirinfo dinfo)))) (return-from get-directory (values-list result)))) (unless didnt-check (setf (dirinfo-meta-timestamp dirinfo) now)) (when (unixtime-greaterp (fattr-mtime (dirinfo-fattr dirinfo)) (dirinfo-dir-timestamp dirinfo)) (il:* il:\; "Fetch directory") (encache-directory dirinfo dinfo)))) dirinfo))))))(defun get-directory-cache (dirinfo dinfo &optional always-check) (il:* il:|;;| "Assures that the cache in DIRINFO is as up to date as we need.  If ALWAYS-CHECK is true, we'll check for directory change even if we checked recently.") (il:with.monitor (dirinfo-monitorlock dirinfo) (il:* il:\; "Now with exclusive hold of the lock, see what's here") (let ((now (get-meta-timestamp)) (oldstamp (dirinfo-dir-timestamp dirinfo))) (cond ((and (not always-check) (not (null oldstamp)) (< (- now (dirinfo-meta-timestamp dirinfo)) *directory-cache-timeout*)) (il:* il:\; "We just looked up this directory a short while ago, assume it hasn't changed")) ((not (refresh-dirinfo-fattr dirinfo dinfo)) (il:* il:\; "Couldn't get its attributes.  Clear info if there was any") (setf (dirinfo-hashtable dirinfo) nil (dirinfo-files dirinfo) nil)) (t (setf (dirinfo-meta-timestamp dirinfo) now) (il:* il:\; "Update the meta-timestamp now, since we just checked.") (when (unixtime-greaterp (fattr-mtime (dirinfo-fattr dirinfo)) oldstamp) (il:* il:\; "Need to get fresh copy") (encache-directory dirinfo dinfo)))))) dirinfo)(defun refresh-dirinfo (dirinfo dinfo) (il:* il:|;;| "Get a fresh handle on the directory in DIRINFO.  Return DIRINFO on success or NIL, status on failure.") (destructuring-bind (status handle) (first (nfs-mount-rpc dinfo *add-mount-entry* (list (mount-name (dirinfo-unixpath dirinfo))))) (cond ((eql status 0) (il:* il:\; "Success") (setf (dirinfo-dirhandle dirinfo) handle) (refresh-dirinfo-fattr dirinfo dinfo)) (t (destroy-dirinfo dirinfo dinfo) (when *nfs-debug* (format t "AddMountEntry[~A] returned ~A~%" (dirinfo-unixname dirinfo) status)) (values nil status)))))(defun find-directory-info (dirpath dinfo) (il:* il:|;;| "Return the DIRINFO object associated with DIRPATH, which can be a lisp directory name as a list (from an NFSPATH), or a raw unix name as string") (let ((unixpathp (stringp dirpath))) (dolist (c (deviceinfo-directories dinfo)) (when (if unixpathp (string= dirpath (dirinfo-unixpath c)) (do ((cdir (nfspath-directory (dirinfo-path c)) (cdr cdir)) (tdir dirpath (cdr tdir))) ((null tdir) (null cdir)) (il:* il:|;;| "See if the directory lists match item for item.  This is a specialized open coding of (equalp dirpath (nfspath-directory (dirinfo-path c)), not sure it's worth it") (cond ((null tdir) (return (null cdir))) ((null cdir) (return nil)) ((not (string-equal (car cdir) (car tdir))) (return nil))))) (return c)))))(defun refresh-dirinfo-fattr (dirinfo dinfo) (il:* il:|;;| "Fill in DIRINFO's FATTR field, returning DIRINFO on success or NIL, status on failure.") (destructuring-bind (status fattr) (nfs-rpc-get-file-attributes (dirinfo-dirhandle dirinfo) dinfo) (cond ((eq status nfs-ok) (cond ((eq (fattr-type fattr) nfdir) (setf (dirinfo-fattr dirinfo) fattr) dirinfo) (t (il:* il:\; "Don't try enumerating a non-directory--server bug here.") (destroy-dirinfo dirinfo dinfo) (values nil nfs-err-notdir)))) ((eq status nfs-err-stale) (il:* il:\; "Out of date handle--just do the whole thing afresh") (refresh-dirinfo dirinfo dinfo)) (t (prompt-format "~&Could not access directory ~a because ~a." (nfs-namestring (dirinfo-path dirinfo)) (nfs-status-to-string status)) (setf (dirinfo-fattr dirinfo) nil) (values nil status)))))(defun unixtime-greaterp (x y) (il:* il:|;;| "True if the UNIXTIME object X is later than object Y.  Y may be NIL to mean day zero.") (or (null y) (let ((elapsedsecs (- (unixtime-seconds x) (unixtime-seconds y)))) (or (> elapsedsecs 0) (and (eql elapsedsecs 0) (> (unixtime-useconds x) (unixtime-useconds y)))))))(defun encache-directory (dirinfo dinfo) (let ((dirhandle (dirinfo-dirhandle dirinfo)) (hash (dirinfo-hashtable dirinfo)) rfd-args status result rfd-list files) (unless dirhandle (il:* il:\; "Handle got stale and wasn't refreshed?  I think this doesn't happen") (return-from encache-directory nil)) (setf (dirinfo-dir-timestamp dirinfo) nil) (il:* il:\; "Mark this cache trash in case we are aborted") (cond (hash (il:* il:\; "Cache has one left from before") (clrhash hash)) (t (setf (dirinfo-hashtable dirinfo) (setq hash (il:hasharray 30 nil (quote il:string-equal-hashbits) (quote string-equal)))))) (setq rfd-args (list dirhandle nil (if t 512 (il:* il:\; "Pre 4.0 servers appear to require EXACTLY this size request.  Grumble.") (- il:*maximum-packet-size* *rfd-overhead-bytes*)))) (loop (setq result (nfs-rpc dinfo *read-from-directory* rfd-args)) (il:* il:\; "Result is (status (cookie eofp . name-id-pairs)).") (cond ((eq (setq status (first result)) nfs-ok) (setq rfd-list (second result)) (setf (second rfd-args) (first rfd-list)) (il:* il:\; "Set cookie for next round") (il:* il:|;;| "Hash the filenames insensitively of case, but within each bucket separate the different capitalizations.") (dolist (pair (cddr rfd-list)) (let* ((string (first pair)) (len (length string)) entry subentry version) (when (and (> len 4) (eql (char string (1- len)) #\~)) (il:* il:\; "Extract the version") (let ((pos (1- len)) (multiplier 1) total char) (loop (cond ((<= pos 0) (il:* il:\; "Name of the form nnnn~ !") (return)) ((digit-char-p (setq char (char string (decf pos)))) (setq char (- (char-code char) (char-code #\0))) (setq total (cond (total (il:* il:\; "sigh, multi-character version") (+ (* (setq multiplier (* multiplier 10)) char) total)) (t (il:* il:\; "Optimize single char versions") char)))) (t (il:* il:\; "Not a digit.  Have we gotten to the \".~\" in front of the version?") (when (and total (eql char #\~) (> pos 1) (eql (char string (decf pos)) #\.)) (il:* il:\; "Good version") (setq string (subseq string 0 pos)) (setq version total)) (return)))))) (when version (il:* il:\; "Give me a (version fid) pair now.  If versionless, leave PAIR as (string fid) in hopes that we will insert that very pair as a brand new entry  ") (setf (first pair) version)) (il:* il:|;;| "Format of an entry is (key nullid . versionpairs)") (cond ((and (< len 3) (eql (char string 0) #\.) (or (<= len 1) (eql (char string 1) #\.))) (il:* il:\; "Don't bother storing . and ..")) ((null (setq entry (gethash string hash))) (push string files) (setf (gethash string hash) (list (if version (il:bquote ((il:\\\, string) nil (il:\\\, pair))) pair)))) ((null (setq subentry (versions-from-hashentry string entry))) (push (if version (il:bquote ((il:\\\, string) nil (il:\\\, pair))) pair) (cdr entry))) (version (il:* il:\; "Insert this pair in order of decreasing version") (do* ((prev (cdr subentry) next) (next (cdr prev) (cdr prev))) ((or (null next) (> version (caar next))) (rplacd prev (cons pair next))))) (t (il:* il:\; "Set the null id") (setf (second subentry) (second pair)))))) (when (second rfd-list) (il:* il:\; "Enumeration complete") (setf (dirinfo-files dirinfo) files (dirinfo-dir-timestamp dirinfo) (fattr-mtime (dirinfo-fattr dirinfo)) (dirinfo-sorted-p dirinfo) nil) (return dirinfo))) ((eq status nfs-err-stale) (il:* il:\; "The handle we offered is no good anymore.  Get a fresh one") (return (and (refresh-dirinfo dirinfo) (encache-directory dirinfo dinfo)))) (t (il:* il:|;;| "Normally we don't want an error in directory enumeration.  If the system were willing, we should raise an error that anyone interested could catch, but INFILEP (for example), never wants errors, but fails to trap them.") (prompt-format "~&Could not enumerate directory ~a because ~a." (nfs-namestring (dirinfo-path dirinfo)) (nfs-status-to-string status)) (setf (dirinfo-files dirinfo) files) (return dirinfo))))))(defun add-file-to-dircache (dirinfo rootname version fileid) (il:* il:|;;| "Add an entry to DIRCACHE describing a file whose unix name is ROOTNAME with (possibly) VERSION appended in version syntax and whose id is FILEID.") (il:* il:|;;| "This code is a lot like the inner loop of encache-directory--they had better agree") (unless (null dirinfo) (il:* il:\; "I assume DIRCACHE is nil only when there really isn't one.  Is that ever?") (il:with.monitor (dirinfo-monitorlock dirinfo) (let* ((hash (dirinfo-hashtable dirinfo)) (entry (il:gethash rootname hash)) (pair (and version (list version fileid))) subentry oldpair) (cond ((null entry) (setf (dirinfo-sorted-p dirinfo) nil) (push rootname (dirinfo-files dirinfo)) (setf (il:gethash rootname hash) (list (cons rootname (if version (list nil pair) (list fileid)))))) ((null (setq subentry (versions-from-hashentry rootname entry))) (push (cons rootname (if version (list nil pair) (list fileid))) (cdr entry))) ((null version) (il:* il:\; "just do the null id") (setf (second subentry) fileid)) ((null (setq oldpair (assoc version (cddr subentry)))) (il:* il:\; "Insert new version in order") (do* ((prev (cdr subentry) next) (next (cdr prev) (cdr prev))) ((or (null next) (> version (caar next))) (rplacd prev (cons pair next))))) (t (il:* il:\; "Replace old version") (setf (second oldpair) fileid))) subentry))))(defun delete-file-from-dircache (dirinfo rootname version) (unless (null dirinfo) (il:* il:\; "I assume DIRCACHE is nil only when there really isn't one.  Is that ever?") (il:with.monitor (dirinfo-monitorlock dirinfo) (let* ((hash (dirinfo-hashtable dirinfo)) (entry (il:gethash rootname hash)) subentry) (when (and entry (setq subentry (versions-from-hashentry rootname entry))) (il:* il:\; "Delete this version from subentry") (cond (version (il:* il:\; "Remove a (version fid) pair") (setf (cddr subentry) (delete version (cddr subentry) :key (quote car)))) (t (il:* il:\; "Zap the versionless id") (setf (second subentry) nil))) (unless (or (second subentry) (cddr subentry)) (il:* il:\; "Now have to delete the subentry") (rplacd subentry nil) (il:* il:\; "just in case someone was holding it") (unless (setf (il:gethash rootname hash) (delete subentry entry)) (il:* il:\; "Also have to delete from files") (setf (dirinfo-files dirinfo) (delete rootname (dirinfo-files dirinfo) :test (quote string-equal) :count 1)))))))))(defun highest-version-present-or-reserved (dirinfo dinfo key) (il:* il:|;;| "Returns the highest version either written or being written of the file with raw name KEY, or zero if there are no versions.") (get-directory-cache dirinfo dinfo) (let ((hash (dirinfo-hashtable dirinfo)) (max 0)) (unless (null hash) (il:* il:\; "Don't bother if directory empty!") (let ((entry (gethash key hash))) (when (and entry (setq entry (versions-from-hashentry key entry))) (il:* il:\; "There are old versions") (let ((versionless-id (second entry)) (versionpairs (cddr entry))) (when versionpairs (il:* il:\; "Highest version is first in list") (setq max (car (first versionpairs)))) (when (and versionless-id (not (version-from-fileid versionless-id versionpairs))) (il:* il:\; "Versionless file not linked") (incf max))))) (let* ((reserved-key (temp-name-for-file key)) (entry (gethash reserved-key hash))) (when (and entry (setq entry (versions-from-hashentry reserved-key entry))) (il:* il:\; "There are reserved versions (not yet closed)") (setq max (max max (car (first (cddr entry)))))))) max))(defun clear-server-cache (host &optional older-than-secs dont-unmount) (when (or (deviceinfo-p host) (and (or (typep host (quote il:fdev)) (setq host (il:\\getdevicefromname host))) (setq host (device-info host)))) (il:with.monitor (deviceinfo-monitorlock host) (let ((*nfs-ok-to-time-out* t) (*nfs-default-timeout* 2000) (dirs (deviceinfo-directories host)) (inuse (mapcan (function (lambda (s) (let ((finfo (stream-info s))) (and finfo (list (fileinfo-dirinfo finfo)))))) (deviceinfo-openfiles host))) (now (and older-than-secs (get-meta-timestamp)))) (unless (or older-than-secs dont-unmount) (il:* il:|;;| "Clear all the mounts at once--much faster than many unmount calls") (unmount-all host) (setq dont-unmount t)) (dolist (dirinfo (copy-list dirs)) (when (cond ((null (dirinfo-dirhandle dirinfo)) (il:* il:\; "This should have been tossed already") t) ((and older-than-secs (< (- now (dirinfo-meta-timestamp dirinfo)) older-than-secs)) (il:* il:\; "Recent, keep it") nil) (t (unless dont-unmount (il:* il:\; "Tell server we'e done") (unmount dirinfo host)) t)) (cond ((member dirinfo inuse :test (quote eq)) (il:* il:\; "Open stream points at it, so don't destroy") (setf (dirinfo-files dirinfo) nil (dirinfo-hashtable dirinfo) nil (dirinfo-dir-timestamp dirinfo) nil)) (t (setq dirs (delete dirinfo dirs)))))) (setf (deviceinfo-directories host) dirs))) (deviceinfo-host host)))(defun destroy-dirinfo (dirinfo dinfo) (il:* il:|;;| "Remove DIRINFO from the cache.") (when (dirinfo-dirhandle dirinfo) (let ((*nfs-ok-to-time-out* t) (*nfs-default-timeout* 2000)) (il:* il:\; "Unmount it") (unmount dirinfo dinfo))) (setf (dirinfo-files dirinfo) nil (dirinfo-hashtable dirinfo) nil (dirinfo-dir-timestamp dirinfo) nil) (setf (deviceinfo-directories dinfo) (delete dirinfo (deviceinfo-directories dinfo))))(defun unmount (dirinfo dinfo) (il:* il:|;;| "Unmount the directory mounted by DIRINFO") (unless (dirinfo-parent dirinfo) (il:* il:\; "If parent, we didn't use mount to get the handle.") (nfs-mount-rpc dinfo *remove-mount-entry* (list (mount-name (dirinfo-unixpath dirinfo)))) (setf (dirinfo-dirhandle dirinfo) nil)))(defun unmount-all (dinfo) (let ((*nfs-ok-to-time-out* t)) (il:* il:|;;| "Clear mount table for this host.  For some reason, this call signals \"system error\", but the mounts really do get cleared.") (ignore-errors (nfs-mount-rpc dinfo (quote remove-all-mount-entries) nil))))(il:* il:\; "Credentials")(defstruct nfscredentials "Holds a given user's credentials for Unixland" user (il:* il:\; "Username") credentials (il:* il:\; "Unix credentials object, composed from the following three items") uid gid gids homedir (il:* il:\; "Resolves directory \"~\""))(defvar *nfs-credentials* nil)(defglobalvar *nfs-credentials-cache* nil "Cache of currently known credentials. (A list of NFSCREDENTIALS structures)")(defvar *last-cache-cleared* 0 "Time (seconds) when we last cleared credentials cache.")(il:addtovar il:\\systemcachevars *nfs-credentials* *nfs-credentials-cache*)(il:addtovar *nfs-cache-vars* *nfs-credentials* *nfs-credentials-cache*)(il:addtovar il:\\afterloginfns reset-nfscredentials-cache)(defmacro dinfo-credentials (dinfo) (il:* il:|;;| "Return the credentials object for the device, or create a new one.") (quote (or *nfs-credentials* (get-nfscredentials))))(defun get-nfscredentials (&optional user) (il:* il:|;;| "Get credentials object for USER or currently logged in user.  In latter case, we insist that user be authenticated, and we set the global *NFS-CREDENTIALS* to the result.") (let ((nfscreds (if (null user) *nfs-credentials* (find user *nfs-credentials-cache* :key (quote nfscredentials-user) :test (quote string-equal))))) (unless nfscreds (il:* il:|;;| "Need to find out UID, etc.") (let (username login uid gid gids homedir auth oldcreds) (cond (user (il:* il:\; "Some random user") (setq username user) (multiple-value-setq (uid gid homedir) (yp:get-uid username)) (unless uid (il:* il:\; "Couldn't find user in yp") (return-from get-nfscredentials nil))) (t (il:* il:\; "Authenticate currently logged-in user (loop until authenticated)") (do ((failed nil t)) ((eq (il:ns.authenticate (il:ns.make.simple.credentials (setq login (il:\\internal/getpassword (quote il:|NS::|) failed)))) (quote t)))) (setq login (il:parse.nsname (car login))) (il:* il:\; "Just the name, now in NS format") (unless (setq username (cond ((multiple-value-setq (uid gid homedir) (get-uid-with-domain login)) (il:* il:\; "NS name worked directly") (record-fetch nsname nsobject login)) (t (il:* il:\; "Try aliases") (dolist (alias (il:ch.list.aliases.of login)) (when (multiple-value-setq (uid gid homedir) (get-uid-with-domain alias)) (il:* il:\; "This one worked") (return (record-fetch nsname nsobject alias))))))) (error "Can't use NFS: Neither user ~A nor any alias is registered in YP database for domain ~A." login yp:*yp-domain*)) (setq oldcreds (find username *nfs-credentials-cache* :key (quote nfscredentials-user) :test (quote string-equal))) (il:* il:\; "In case we earlier looked up ~username") (il:* il:|;;| "For logged-in user, also make authentication object") (setq auth (rpc2:create-unix-authentication (progn (il:* il:\; "\"Stamp\" -- unused") 1000) (cond (t (il:* il:\; "Well, actually, the Epoch looks at this for export control by machine") (string-downcase (local-machine-name))) (t (il:* il:\; "As far as I can tell, nobody looks at this anyway, and on Dorado we are in danger of overflowing the packet if the name is long") "")) uid gid (setq gids (yp:get-user-gids (setq username (string-downcase username)))))))) (cond (oldcreds (il:* il:\; "Re-use old credentials object") (setq nfscreds oldcreds)) (t (when homedir (il:* il:\; "e.g. /pooh/egbert.  Canonicalize it now (parse into directory list, quote uppercase chars). ") (setq homedir (parse-dir-string (escape-uppercase-chars homedir 1 nil t))) (il:* il:|;;| "Now see if we can locate the volume.  This will allow ~egbert to work even if I am nominally talking to the wrong host.") (setq homedir (cond ((and *use-volume-map* (find-volume (car (last homedir)) homedir)) (il:* il:\; "Returned (host . parsed-path).")) (t (il:* il:\; "Couldn't find the volume, so take it as is.  NIL means try to use the given host") (cons nil homedir))))) (setq nfscreds (make-nfscredentials :user username :uid uid :gid gid :homedir homedir)) (push nfscreds *nfs-credentials-cache*))) (unless user (il:* il:|;;| "Fill in real credentials for logged-in user") (setf (nfscredentials-credentials nfscreds) auth (nfscredentials-gids nfscreds) gids) (setq *nfs-credentials* nfscreds)))) nfscreds))(defun get-uid-with-domain (nsname) (il:* il:|;;| "calls yp:get-uid on the object part of NSNAME, checking that its domain is compatible with YP:*YP-DOMAIN*.  Eventually, if authentication can deal with domains, this will all be different") (let* ((nsdomain (record-fetch nsname nsdomain nsname)) (translated (cdr (assoc nsdomain *ns-to-yp-domain* :test (quote string-equal))))) (cond ((null translated) (il:* il:\; "try naked domain") (setq translated nsdomain)) ((consp translated) (il:* il:\; "alist by organization") (setq translated (cdr (assoc (record-fetch nsname nsorganization nsname) translated :test (quote string-equal)))))) (and translated (string-equal translated yp:*yp-domain*) (yp:get-uid (record-fetch nsname nsobject nsname)))))(defun reset-nfscredentials-cache (host) (il:* il:|;;| "Called after LOGIN -- clear caches that are dependent on logged-in user") (declare (ignore host) (global il:\\filedevices)) (unwind-protect (dolist (dev il:\\filedevices) (il:* il:\; "Clear directory caches, since user may now have different permissions.  Do this first, since this may need to do unmounts.") (when (typep (setq dev (device-info dev)) (quote deviceinfo)) (clear-server-cache dev))) (il:* il:|;;| "Arranged this way so that even if user somehow aborts the device cache clearing, we still wipe the credentials here.") (setq *nfs-credentials* nil) (dolist (c *nfs-credentials-cache*) (il:* il:\; "Invalidate these, but keep the info about UID, etc around.") (setf (nfscredentials-credentials c) nil))))(il:* il:\; "Unix Time/Date Stuff")(defconstant *unix-start-idate* (il:idate "1-Jan-70 00:00:00 GMT") "Interlisp Representation of 1-Jan-70 00:00:00 GMT")(defun unix-to-idate (unix-date) "Takes a Unix time and converts is to an IDATE." (il:* il:|;;| "If the date is way in the future, confine it to Lisp date range.") (min (+ unix-date *unix-start-idate*) il:max.fixp))(defun idate-to-unix (idate) (max 0 (- idate *unix-start-idate*)))(il:* il:\; "Get started")(eval-when (load)(il:\\definedevice nil (record-create fdev :hostnamep (quote nfs-hostnamep) :devicename (quote nfsdevice) :eventfn (quote il:nill)))(il:\\definedevice (quote il:nfs) (create-nfshost-device (quote il:nfs))))(il:putprops il:nfsdevice il:copyright ("Xerox Corporation" 1988 1989))(il:declare\: il:dontcopy  (il:filemap (nil)))il:stop