1

TECHNICAL PRODUCT DESCRIPTION
1

TECHNICAL PRODUCT DESCRIPTION
7.  NETWORKING AND COMMUNICATIONS
1

7.  NETWORKING AND COMMUNICATIONS
1


7.	NETWORKING AND
	COMMUNICATIONS
6


Xerox AI products have been developed in a network environment. As a result, the AI workstation hardware and software can take advantage of available network services to increase the productivity of individual programmers and of entire groups of programmers. The 1186 workstation includes as standard equipment an Ethernet interface and two RS232 serial ports. All the capabilities of network communications are available in XAIE programmaticaly and through the use of utilities.
AI workstations are typically found on networks. Network system management is particularly well suited for adding new equipment. When additional capacity is needed it is simple to add more workstations, file servers, or printers. If special computations are needed, for instance very high speed computation, it is simple to add a fast CPU to the network and to access it from existing code. This allows a network environment to include the best of all available equipment, AI or other, rather than trying to fit all sorts of work onto a general purposÖ!machine.
The ChaL library package is the basis for terminal emulation. Chat allows a window on the workstation screen to function as a terminal to a remote host. Datamedia 2500, Tektronix 4010, and VT100 are among the0terminal protocols supported. Chat can talk to the host over the Ethernet using any of the available Etheion in the userπs system, the L isp executive will notify the user, who may then tell the Programmerπs Assistant to UNDO the operation; this will re-install the previous function definition.
Aside from the benefit of being able to recover information lost through erroneous operations, UNDO is often used to flip back and forth between two states. For example, one might make some changes to a program and/or data structures, run an experiment, UNDO the changes, re-run the experiment, UNDO the UNDO, and so on.
The Spelling Corrector is central to the philosophy that the programming environment should cooperate with the programmer to the greatest possible degree. It is a pervasive and very  sophisticated input interpretation and error-correction facility.
The Spelling Corrector is invoked from many places in the system, including the File Manager, the Editor and the Lisp executive. When an unrecognized item is encountered in any of these contexts, the Spelling Corrector is invoked to find the closest match within a list of relevant items. If the name of a function is misspelled, for example, the corrector scans a list of the functions with which the user has recently worked.
When the Spelling Corrector successfully interprets a mistake, it will actually make the correction, so that future  corrections will not be necessary. For example, when the Spelling Corrector corrects a userπs function name during the execution of a program, it actually modifies the userπs program to contain the correct spelling (and notifies the File Manager of the change).
Figure X-X.  XXXXX
Note that the Spelling Corrector corrected the function definition after the user confirmed the ITimes to ITEMS change.
Most implementations of Lisp treat symbolic files as unstructured text, much as they are treated in most conventional programming environments. Function definitions are edited with a character-oriented text editor, and then the changed definitions (or sometimes the entire file) are read or compiled to install those changes in the current user environment.
XAIE uses a very different approach. A ∫residential∫ file system was developed to further reduce the time needed to edit and test programs. In a residential system, one loads a file into the environment; the file system records what objects (function definitions, variable values, properties, etc.) belong in each file, and where the file resides (on the hard disk, floppy disk, file server, etc.). After the file is loaded, the structures can be used and edited directly. Thus, the manpower associated with manipulating files is eliminated from within the edit-test loop, and all file management occurs automatically.
XAIEπs file manager is the subsystem that automatically performs the bookkeeping necessary to maintain a large system consisting of many source files and their compiled counterparts. It keeps track of what things have been changed and where they belong, thereby removing these tasks from the programmerπs responsibilities. The  file manager uses a concept called a Reader Environment to distinguish the type of file, whether it be a Common Lisp file, an Interlisp-D file or a file that resides in a user-defined environment. The reader environment information is found as a header in each file.
Figure X-X.  XXXXX
The file manager operates transparently to the user by means of ∫hooks∫ into many parts of the system. For example, the editors record which objects the user has changed (and a description of the changes, allowing the Programmerπs Assistant to UNDO the effects of the edit), and the file manager uses this information to keep track of those files that therefore have to be updated.
Figure X-X.  XXXXX
SEdit is the primary editor for XAIE programs and data. It was designed to accelerate the editing cycle by executing as a separate process, allowing the user to simply click inside the SEdit window to edit Lisp code. It is possible to have as many SEdit windows opened as desired, with each working on a separate function or data structure. As is the case for all active text in XAIE, it is possible to transfer information between different SEdit windows by using the COPY key on the keyboard.
SEdit edits Lisp code directly in memory. That is, it is operating directly on the code executed by the interpreter, not on an ASCII file. This is useful during program development as it lets programmers change one or two lines within a function and continue execution without compiling, without reentering a ∫source∫ file, and most importantly, without delay.
The effect on system execution for functions being currently edited in an SEdit window is dependent on the structure being edited. For Common Lisp definitions, SEdit is editing a copy of the object. The system does not notice the changes made in the SEdit copy until the user has installed the changes; therefore, the system will execute an ∫older∫ definition until it is explicitly replaced by the new, edited definition. For Interlisp-D definitions, SEdit is editing the actual structure in memory. Therefore, when executed, the system will run the definition as it currently appears in the SEdit window. For all other structures, such as variables and property lists, SEdit edits the actual structures, so all changes  made in the editor are installed immediately.
Each SEdit session has its own window and process. From the time the session is started until the time it is ended, SEdit remembers all changes made, allowing the user to undo and redo all edits.  When the SEdit session is ended,the entire history of the session is forgotten and the changes are installed in the system. A session is ended if the user closes the SEdit window, shrinks the SEdit window, or executes a command sequence to indicate that he or she wants the changes installed. The session can also be aborted through a specific SEdit command, whereupon all changes since the last  save command are aborted.
Editing with SEdit is done by selecting structures with the mouse and executing commands to act on the current selection. SEdit is a ∫smart∫ Lisp editor in that it is aware of standard Lisp structures: lists within parentheses, strings within double quotes, quoted lists, back-quoted lists, and so on. For example, when a user initiates a string with a double-quote character, SEdit immediately appends an ending double-quote; all type entered prior to the user entering another double-quote will appear within the string confines. SEdit also follows conventions for usage of the mouse buttons that make it easy to learn and amazingly quick to edit. The left mouse button points to parts of Lisp structures, the m~            ƒ            À            z            Ú                         Í            Ù            î             À                  è :z∫