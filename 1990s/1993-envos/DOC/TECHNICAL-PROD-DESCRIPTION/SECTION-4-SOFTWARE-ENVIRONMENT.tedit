1

TECHNICAL PRODUCT DESCRIPTION
1

TECHNICAL PRODUCT DESCRIPTION
4.  SOFTWARE ENVIRONMENT
1

4.  SOFTWARE ENVIRONMENT
1


4.	SOFTWARE ENVIRONMENT
6


The Xerox Artificial Intelligence Environment (XAIE) is at once an operating system, a collection of integrated programming languages, and a ºseamlessº development environment, giving programmers uniform access to all aspects of machine operation. XAIE functionality is available not only to aid the user in the process of code development, but can be incorporated directly into the code. Also, large subsystems are shared both by different parts of the environment and by user applications, a characteristic unique to large, dynamically linked environments like XAIE.
As applications become more complex, as both development and use require the computer to do more and more work, it becomes increasingly important for there to be a high bandwidth of communications between the computer and the user. AI applications especially find man/machine communications to be an issue. Many psychological as well as technical factors must be considered in designing an effective interface, and it is in these areas that Xerox leads the industry.
XAIE users work in a ªmodelessº environment. Users do not have to use one tool, put it away, and load another. Rather, all can coexist on the large workstation screen so that users just avert the eyes and ºclick to activateº whichever tool is needed. This speeds the use of development tools and can be incorporated into applications. The multiple overlapping windows often seen in XAIE are interpreted as a ªdesktop metaphorº ? they look like the overlapping papers on a busy person¹s desk. The windowing capability expands the effective dimensions of the screen and makes it easy to customize even very complex applications; there is no maximum number of windows which can be displayed on the screen or held, closed, in memory.
Xerox AI workstations support windows, graphics, and mouse I/O built in at the deepest hardware and software levels, so performance of these features is unmatched by competitive machines. Movement of the mouse cursor is always immediate and precise, windows can overlap in any combination, and even bitmapped graphics can be moved into and between windows instantly.
HEADING
1

The multiplicity of windows on the large display screens is the first thing a person notices when looking at the Xerox AI workstations. Each window is independent and can have any number of processes associated with it. Windows can receive both text and graphics, can be scrollable, and can automatically clip any attempt to display an object which exceeds it dimensions. Use and control of windows is very simple in XAIE. To create a window one simply types:
	(CREATEW)
The result can then be assigned into any variable.
In interactive applications users select a window by mousing it (moving the cursor into it and pressing a mouse button). The standard XAIE behavior at that point is to bring that window to the top ? the same effect as when a program writes to a window. If desired, this can be changed in various ways to simulate other vendor¹s window systems.
It is possible to attach processes to a window, such that the process is initiated only when a certain event occurs between the mouse and the window. XAIE watches for several standard events in every window, including the cursor engineering the window, the cursor moving around inside of the window, and a mouse button being pressed while the cursor is in the window.
When a window is not immediately needed it is possible to shrink it down to an ºicon,º a small drawing which represents the function or contents of the larger window. For example, a TEdit window (the document editor in XAIE) shrinks down to a little book with the file¹s name on the cover. An icon is drawn with the bitmap editor and is then assigned the value of the window property which is accessed when the window is shrunk. The icon can be put anywhere on the screen, moved or written on by users or programs, and then enlarged back into the full window.
A menu is a specialized window; it displays a number of choices from which the user makes a selection. Menus are a major form of input to the XAIE system and have therefore been made very easy to use. For example, a simple menu like this:
Figure X-X.  XXXXX
can be created with the command:
(MENU (CREATE MENU TITLE ¬ ªMY MENUº ITEMS ¬ ©(HAMBURGER FRIES SHAKE))).
More complex menus are also common, especially ones with submenus ªcascadingº to the right of the active menu.
There are many options and variations to menu design. Selection of a menu entry can simply return a value to the calling program or can directly invoke a piece of code. Menus can use any font, can have any specified number of rows or columns, can ºpop upº once, or become permanent, can float near the cursor, or be attached to a window.
Figure X-X.  XXXXX
A window can display text and graphics in any combination. Bitmapped graphics are used for drawing arbitrary pictures and, by using halftones or dithering, can appear to show gray scale images. Digitized photographs can be used as important prompts and are easy to build into applications. Geometric shapes can be drawn onto windows by using Interlisp-D native graphics commands such as (LINE...) and (CIRCLE...) or by using the GKS LispUsers module.
Graphics capabilities are found throughout XAIE and are commonly used by developed applications. The fonts and the icons that appear on the screen are special forms of bitmapped graphics. The microcoded BITBLT function (BIT BLock Transfer) manipulates cataloged bitmaps quickly enough to do simple animations. Many parts of the system also use Grapher, a package built on these capabilities which draws interactive graphs called ºbrowsers.º
Figure X-X.  XXXXX
The mouse is used to guide a pointer on the screen as it is moved across the mouse pad. The pointer (called the cursor) is generally an arrow, but it often takes other shapes to either convey information to the user (e.g. disk reads and writes, garbage collections), prompt the user for action (e.g., scan out a window or confirm a selection), or perform certain graphical operations (e.g., a ºbrushº for painting or area-fill operations). For programmers, there are a variety of built-in cursor images to choose from, or the bitmap editor can be used to create new forms.
The mouse is used to select menu items and icons, to position  windows on the screen, to select text for input or editing, and to invoke commands. Whenever a mouse button is depressed and held, the Prompt window displays information about what will happen if the button is released.
Programs can test for all combinations of mouse buttons at any time. There are functions that allow programmers to determine what will occur whenever a mouse ºeventº occurs; for example, when the cursor enters or leaves a window or when a specific button or combination of buttons is pressed while the cursor is in the background. The mouse runs in its own process and XAIE automatically spawns new mouse processes whenever necessary.
The mouse has three buttons, and programs in XAIE follow a convention for the use of each one. The left button is used for selecting objects or text, the middle button to bring up menus that are specific to a certain window or program, and the right button is used to pop up system menus or to extend text selections.
In any interactive computer language, the user interacts with the system through an ªexecutive,º which reads, interprets, and then executes commands as they are typed. In Lisp systems, an executive can be created by running a program that continuously executes three Lisp functions:
READ, which causes the workstation to wait for the user to type something in, then translates the input into the appropriate internal representation;
EVAL, the Lisp interpreter;
and
PRINT, to which is passed the result of the evaluation of the input, and prints in the executive window.
Ordinary Lisp expressions are typed into the executive, just as they would appear in the middle of a Lisp program. The distinction between the programmatic and interactive interface to the system diminishes, yielding a double advantage: typical system commands, like those used to manipulate files or invoke the editors, can easily be called by user programs; and Lisp programs can be tested from any entry point by typing that function into the executive. There is no need to learn special terminal commands that are distinct from the applications language (although special commands are used in ? and can easily be added to ? the executive, to enhance usability).
.
As the user types into the Lisp Executive, defining new functions, loading files, evaluating Lisp expressions, etc., the Programmer¹s Assistant records each input with the result system actions, forming a history list of each interaction. The user can refer to that list at any time, re-executing or even modifying previous commands.
The Programmer¹s Assistant is described in greater detail later in this chapter.
Figure X-X.  XXXXX
XAIE is a multi-processing system that can instantaneously switch between processes, thereby letting the user concurrently start up and use several different executives. There are different kinds of executives to support different language environments and different programming styles.
All Lisp executives are able to execute commands immediately. This allows the executive to perform at both the operating system level with commands such as DIR and MAKEFILE, and at the programmatic level with commands that define functions and create variables. This is especially useful since program developers frequently try out new code sections before including them in existing programs. Code changes and definitions made in the executive windows become part of the total environment ? they do not have to be re-entered as text, but can be edited if changes are needed.
An executive uses a specific package with which to interpret its commands. That is, a user could have one executive that would interpret a command as a Common Lisp command and another executive that would interpret the same commands as an InterLisp-D command. The package that is used for an executive controls how any command typed into that executive is evaluated. A user can, however, access a function or variable defined in another package by prefacing the name with its home package (e.g., CL:DEFUN). A brief explanation of the different executives offered by XAIE follow.
	XCL Executive	This is the default executive for XAIE environment, and uses the XCL-User package. The language environment is Common Lisp with Xerox extensions.
	INTERLISP Executive	This executive uses the Interlisp-D package. The language environment is Interlisp-D with modifications made to account for its integration with Common Lisp.
	LISP Executive	This executive uses the Common Lisp package. The language environment is Common Lisp as defined by the Guy Steele Common Lisp standard.
	PROLOG Executive	The default Xerox Quintus Prolog executive is a TEdit executive which expects Prolog syntax and commands instead of Lisp. The same command editing features are available, but some of the programmer¹s assistant commands are not.
		There are also different kinds of executives to support different programming styles:
	TTYIN Executive	The default executive window offers a TTYIN interface for work with Interlisp-D. All of the Programmer¹s Assistant commands are available, and within one line smart Lisp editing is possible, including variable name completion, shift-select to copy text from one part of the line to another, parenthesis balancing to help track complex expressions, and ©©typeahead.¹¹
	TEdit Executive	Another option for users is to specify a TEdit executive which has the same capabilities as the TTYIN default executive, but in addition lets you scroll the window, select text from past command lines for inclusion in the present one, search past commands for text strings, and use the other features of TEdit on your command strings.
As an environment, XAIE supplies a number of on-line help facilities. These support the languages and tools of XAIE and are easily, in some cases automatically, extendable to include applications code.
	? = 	For help remembering the arguments to a Lisp or Prolog function, a user can type a ?= after the function name requesting the system to print out the argument list. This list, printed directly below the current command line, includes arguments previously entered, with their assigned values, and all unassigned argument names. For example, to see all of the arguments to (CREATEW), the user would enter:
			(CREATEW?=
		and would see as a result:
			(CREATEW REGION TITLE BORDERSIZE NOOPENFLG)
		The type-in point is automatically placed after the word last typed by the user on the current command line. The ?= function works automatically on user-defined operations as well as on predefined XAIE functions.
	DESCRIBE	A user can request additional information about a function or variable by executing the function DESCRIBE. DESCRIBE prints out information about any Common Lisp or Interlisp-D symbol. This information, derived from values and comments found in the symbol definition, includes the symbol¹s value and any property lists attached to it.
		Figure X-X.  XXXXX
	DInfo	DInfo provides a complete set of tools for building on-line help systems. The DInfo interface consists of two windows: a graph giving the overall organization of the help system and a TEdit window giving the documentation of the node highlighted in the graph. The user can bring up different sections of the help system by specifying symbols to search for or by highlighting nodes in the graph by clicking on them with the mouse.
		DInfo is described in more detail under the Library Modules section in Chapter            .
	APROPOS and MasterScope	Many other features are available which make XAIE quite easy to use. For example, the APROPOS function searches all presently defined atoms to find ones matching a search string, then prints out the current definition and value. This is especially useful when you don¹t remember enough of a variable to look it up in a standard index. MasterScope presents the code structure of an application graphically and by answering queries about internal behavior of code it assists the developer with the development of his or her own code. MasterScope is covered in greater detail in the Library Modules Section in Chapter            .

Traditional software development methodology presupposes that a design specification for a system is completed in advance of implementation. The implementation task is then broken down into pieces that can be easily coded and debugged. The interfaces between the modules are rigidly specified, and development teams rely on consistency checks to make sure that the final system, while conforming to the initial specification, will actually work.
For some types of programs, however,  it is virtually impossible to outline the design specification in full before the actual coding begins. A typical example is the designing of human interfaces to mechanical or software systems. This requires the analysis of so many complex and subtly interacting factors that the first design will never be optimal. A trial-and-error design process in this instance is the only way to achieve success. Other such examples include the prototyping of systems to client specifications that are changing or unclear, or the developing of systems that are intended to emulate abilities that some humans possess, but cannot explain. 
It is in fact this last endeavor that has spawned these programming techniques ? artificial intelligence research is a branch of computer science that has always sought to create programs that behave in ways which we do not  fully understand. Traditional software engineering practices actually hinder development in these kinds of cases. It is inevitable that changes will be made to these systems as they are being written, and the consistency checks and enforced interfaces that help ensure successful implementations in well-understood projects become obstacles to necessary revisions when the design is incremental.
What is needed is to provide programmers with a software development system that allows major program changes to be executed rapidly and easily, while maintaining the consistency of the code. Advanced programming tools are required to aid in the programming process, enabling a single developer or a small team to quickly prototype, test, and modify programs as they close in on a  successful design. The environment then, enables programmers to control the rapid, unplanned development of exploratory applications with the same effectiveness that redundancy and structuring provide for more conventional applications.
The effectiveness of advanced programming environments such as XAIE, derive from many factors including the speed with which the programmer can interact with the environment, the tools available to assist in programming tasks, the level of integration of the tools within the environment, and the time it takes to test, edit, and re-test a piece of code. In each case, the developers of the XAIE system considered the critical resources of the software development process to be the programmer¹s time and effort, and have therefore designed the entire environment to cooperate with and amplify the efforts of the programmer.
In  XAIE, the programmer is to a great extent relieved from attending to such details as type declarations, memory management, file management, fixing typos in code, and retyping commands. Many of the time-consuming steps required in other systems for modifying pieces of code have been taken out of the edit-test loop ? compiling, reading in sources, re-linking, remaking files; all of these are accomplished automatically. The programmer  is therefore able to concentrate on higher-level design issues and the result is an accelerated development cycle.
The many facilities that support program development fall into basically two categories. One set of tools permits the programmer to find information quickly, display it effectively, and modify it easily. These tools include the Programmer¹s Assistant, the structure-based Lisp editor, SEdit, the Break Package, and the Inspector. There are knowledge-based tools that understand a program¹s content, meaning, and context. MasterScope, the power program analysis subsystem of XAIE, is of this type. The File Manager helps programmers by automatically performing the bookkeeping which would otherwise consume time and attention. Also, a set of tools is provided to tune working programs for run-time efficiency.
The Programmer¹s Assistant is derived from extensions to the basic Lisp READ-EVAL-PRINT loops that make the XAIE Lisp executive extremely easy to learn and use. Facilities like the Programmer¹s Assistant are based on a philosophy of providing an intelligent intermediary between the user and the rest of the system. These facilities provide the added advantage of modifiable Lisp executives, allowing the programmer to create custom interfaces for application programs.
As the user types into the Lisp executive, defining new functions, loading files, evaluating Lisp expressions, etc., the Programmer¹s Assistant records each input, along with a description of the results and side effects, and creates a history list of the interactions. Then, when the user desires, previous events can be re-executed (or brought back into the executive to edit before re-execution), saving retyping. In addition, the user may tell the Programmer¹s Assistant to UNDO some previous command, which cancels all of the effects of the specified operation. For example, if the user defines or loads a function with a name that was previously defined as a function in the user¹s system, the L isp executive will notify the user, who may then tell the Programmer¹s Assistant to UNDO the operation; this will re-install the previous function definition.
Aside from the benefit of being able to recover information lost through erroneous operations, UNDO is often used to flip back and forth between two states. For example, one might make some changes to a program and/or data structures, run an experiment, UNDO the changes, re-run the experiment, UNDO the UNDO, and so on.
The Spelling Corrector is central to the philosophy that the programming environment should cooperate with the programmer to the greatest possible degree. It is a pervasive and very  sophisticated input interpretation and error-correction facility.
The Spelling Corrector is invoked from many places in the system, including the File Manager, the Editor and the Lisp executive. When an unrecognized item is encountered in any of these contexts, the Spelling Corrector is invoked to find the closest match within a list of relevant items. If the name of a function is misspelled, for example, the corrector scans a list of the functions with which the user has recently worked.
When the Spelling Corrector successfully interprets a mistake, it will actually make the correction, so that future  corrections will not be necessary. For example, when the Spelling Corrector corrects a user¹s function name during the execution of a program, it actually modifies the user¹s program to contain the correct spelling (and notifies the File Manager of the change).
Figure X-X.  XXXXX
Note that the Spelling Corrector corrected the function definition after the user confirmed the ITimes to ITEMS change.
Most implementations of Lisp treat symbolic files as unstructured text, much as they are treated in most conventional programming environments. Function definitions are edited with a character-oriented text editor, and then the changed definitions (or sometimes the entire file) are read or compiled to install those changes in the current user environment.
XAIE uses a very different approach. A ºresidentialº file system was developed to further reduce the time needed to edit and test programs. In a residential system, one loads a file into the environment; the file system records what objects (function definitions, variable values, properties, etc.) belong in each file, and where the file resides (on the hard disk, floppy disk, file server, etc.). After the file is loaded, the structures can be used and edited directly. Thus, the manpower associated with manipulating files is eliminated from within the edit-test loop, and all file management occurs automatically.
XAIE¹s file manager is the subsystem that automatically performs the bookkeeping necessary to maintain a large system consisting of many source files and their compiled counterparts. It keeps track of what things have been changed and where they belong, thereby removing these tasks from the programmer¹s responsibilities. The  file manager uses a concept called a Reader Environment to distinguish the type of file, whether it be a Common Lisp file, an Interlisp-D file or a file that resides in a user-defined environment. The reader environment information is found as a header in each file.
Figure X-X.  XXXXX
The file manager operates transparently to the user by means of ºhooksº into many parts of the system. For example, the editors record which objects the user has changed (and a description of the changes, allowing the Programmer¹s Assistant to UNDO the effects of the edit), and the file manager uses this information to keep track of those files that therefore have to be updated.
Figure X-X.  XXXXX
SEdit is the primary editor for XAIE programs and data. It was designed to accelerate the editing cycle by executing as a separate process, allowing the user to simply click inside the SEdit window to edit Lisp code. It is possible to have as many SEdit windows opened as desired, with each working on a separate function or data structure. As is the case for all active text in XAIE, it is possible to transfer information between different SEdit windows by using the COPY key on the keyboard.
SEdit edits Lisp code directly in memory. That is, it is operating directly on the code executed by the interpreter, not on an ASCII file. This is useful during program development as it lets programmers change one or two lines within a function and continue execution without compiling, without reentering a ºsourceº file, and most importantly, without delay.
The effect on system execution for functions being currently edited in an SEdit window is dependent on the structure being edited. For Common Lisp definitions, SEdit is editing a copy of the object. The system does not notice the changes made in the SEdit copy until the user has installed the changes; therefore, the system will execute an ºolderº definition until it is explicitly replaced by the new, edited definition. For Interlisp-D definitions, SEdit is editing the actual structure in memory. Therefore, when executed, the system will run the definition as it currently appears in the SEdit window. For all other structures, such as variables and property lists, SEdit edits the actual structures, so all changes  made in the editor are installed immediately.
Each SEdit session has its own window and process. From the time the session is started until the time it is ended, SEdit remembers all changes made, allowing the user to undo and redo all edits.  When the SEdit session is ended,the entire history of the session is forgotten and the changes are installed in the system. A session is ended if the user closes the SEdit window, shrinks the SEdit window, or executes a command sequence to indicate that he or she wants the changes installed. The session can also be aborted through a specific SEdit command, whereupon all changes since the last  save command are aborted.
Editing with SEdit is done by selecting structures with the mouse and executing commands to act on the current selection. SEdit is a ºsmartº Lisp editor in that it is aware of standard Lisp structures: lists within parentheses, strings within double quotes, quoted lists, back-quoted lists, and so on. For example, when a user initiates a string with a double-quote character, SEdit immediately appends an ending double-quote; all type entered prior to the user entering another double-quote will appear within the string confines. SEdit also follows conventions for usage of the mouse buttons that make it easy to learn and amazingly quick to edit. The left mouse button points to parts of Lisp structures, the middle mouse button points to whole Lisp structures and the right mouse button selects structures or substructures. For example, by clicking with the left button between symbols, the user is telling SEdit to append the type to the closest symbol; by clicking with the middle button between symbols the user is telling SEdit to treat the type as a completely separate symbol.

Figure X-X.  XXXXX
SEdit commands can be selected from a pop-up menu or can be executed through a Meta or Control sequence (i.e., holding down the Meta or Control key while depressing another key to indicate the particular operation). SEdit commands include: inserting parentheses around the current selection, extracting one level of structure from the current selection, moving or copying the current selection to another place in any SEdit window, evaluating the current selection, and editing the current selection.
Aside from providing an extremely fast interface for modifying the structures of Lisp programs and data, SEdit improves programmer productivity by eliminating from within the edit-test loops the overhead associated with converting text to data structures within the Lisp address space; the results of each edit are immediately available to the system for execution.
When errors, interrupts or breakpoints are encountered, control is passed to the Xerox Lisp Debugger. The Debugger is an interactive executive which recognizes all normal executive commands, but which also provides the user with special debugging functions. These debugging functions allow the user to inspect the current state of the program, edit the broken function, change any data structures or function definitions, and so on. All of this occurs in the context of the suspended computation, which  remains available to be resumed at any time by the user.
XAIE provides debugging facilities for modifying the behavior of a function without actually editing its definition:
Figure X-X.  XXXXX
Breaking
1

The user can insert breakpoints around function definitions. When encountered, these breakpoints cause the debugger to be invoked instead of actually calling the function. The user can
Figure X-X.  XXXXX
 also specify an optional WHEN clause which acts as a conditional on whether or not the debugger is called. If the WHEN clause is true, the debugger is called, if NIL, or false, no special action is taken and the function is invoked as usual. This technique is used to implement ªone-shotº break points.
Stepping
1

Single stepping is a way of observing the computation of a program or function step by step. Every time an evaluation is made, computation stops, appropriate information is printed, and control is passed to the user for specifying the next Step command. The user has the option of continuing the stepping process, finishing without further stepping, entering the debugger, or aborting the entire computation.
Advising
1

Advising is a facility for linking original code into system or applications functions without changing the source code. By advising a function, the user supplies code that is to be automatically executed before or after the advised function has executed. For example, the Interlisp-D command:
	(ADVISE ©CNDIR¹AFTER
	©(WINDOWPROP PROMPTWINDOW ¹TITLE
	(CONCAT ª Connected directory is º !VALUE)))
advises the Interlisp-D function CNDIR so that the current connected directory appears in the title bar of the prompt window. The Interlisp-D command (UNADVISE CNDIR) will undo the advise.
The Inspector
1

Many different data types are used in XAIE, including both system data types and those created by the user. The Inspector is a display-oriented facility that allows the programmer to easily display and/or alter any data type. The key to the effectiveness of this tool is that the Inspector is informed of the different data types in use and of the different methods available to display and/or edit them. Thus, a simple command to the Inspector:
	(INSPECT object)	results in the Inspector offering a menu of all of the appropriate tools with which this type of object can be manipulated. For example, if the user asks to INSPECT a window,the inspector will open a window that displays the properties of the window data type, as well as the current value of those properties for the particular window being inspected.

		Figure X-X.  XXXXX
Or, if the user wishes to INSPECT some datatype for which the system has a special editor, the Inspector will offer the alternative aspects of datum that may be displayed by using a pop-up menu:
		Figure X-X.  XXXXX
In this case, the Inspector is invoked on a bitmap. The Inspector knows that there is a built-in editor that can be used to display and edit the actual contents of bitmaps (see the bitmaps section in Chapter __). So, a menu is popped up which allows the user to specify whether the default inspector window (fields option) or the bitmap editor (contents option) should be used.
The Inspector can be invoked both programmatically and interactively. There is a documented programmers¹ interface to the Inspector package, allowing inclusion of the Inspector functionality in user programs. In addition, one can inspect objects simply by pointing at them with the mouse as they are displayed in the editor, the break package BackTrace window, or within other inspector windows.
When the Inspector is invoked on an object, there may be more than one interpretation of what object the user is referring to; for example, when asked to INSPECT an atom which had a value, a function  definition, and a file associated with it, the inspector would pop up a menu asking whether the value of the atom should be INSPECTed or whether the list structure editor SEdit should be used on the function definition, the property list of the atom, or the contents list of the file.
MasterScope
1

MasterScope is an intelligent programming tool that ºunderstandsº a great deal about the syntax and semantics of Lisp, and analyzes user programs to aid the programmer in understanding, modifying, and debugging large, complex applications.
MasterScope resides as a Library Module and is described in greater detail later in this chapter.
XAIE contains a compatible interpreter and compiler for both the Common Lisp and Interlisp-D languages. The compiler, called the XCL compiler, can operate on either single functions defined in the current user environment or definitions stored in a file. The resulting compiled code may be stored as it is compiled, so as to be available for immediate use, or it may be written onto a file for subsequent loading.
Compiled functions are freely intermixed with source code, which is run uninterpreted until it is convenient for the system to automatically compile changed or new functions.
Both the Lisp interpreter and compiler are themselves Lisp programs, and can be called programmatically like any other function. In fact, the compiler is typically invoked by automated file management operations rather than being called explicitly by the programmer.
In XAIE, users write functions and test portions of the evolving system by executing code in an interpreted mode. These functions are collected in files, and source and compiled versions are automatically stored, usually at the end of the programming session. When the programs are next run, the compiled versions are used for execution efficiency, but as new functions are added or existing ones edited, there is no need to even incrementally recompile; the programs can be immediately run, and whenever source code is encountered, control passes to the interpreter. Thus, during most programming/editing sessions, one never waits for even single functions to re-compile; work can be compiled whenever desirable, or automatically compiled and stored upon request.
XAIE provides a facility that lets the user advise the compiler about efficient compilation of certain system-defined and user-defined functions and macros. The XCL compiler also performs its own code optimizations for both numeric and symbolic computations. For example, the automatic conversion of certain recursive functions (e.g., tail recursion) into iterative forms to save execution time and stack space, is included.
HEADING
1

An important aspect of system development is the performance tuning and contraction of the system. One important technique in improving the run-time performance of working programs is to utilize machine-efficient datatypes for the application, replacing less efficient list structures. Code optimization is then facilitated by a library of program monitoring and instrumentation functions.
TIMEALL
1

The TIMEALL function executes a function call some number of times, then reports both the total time (to 1/1,000 sec.) taken and the number of list cells treated. If any garbage collections occur during the timing, their durations are subtracted out.
SPY
1

The SPY system is a library of functions which samples the stack as programs run, analyzes the relative computation requirements of the programs active at the time of the SPYing, and reports the findings to the user in the form of a graph containing all of the executed functions and the percentage of time they required.
SPY is described in greater detail in the library Modules section in Chapter        .
Text and Graphics
1

The text and graphics capabilities of Xerox AI workstations are well known as being of very high quality. The clarity and high resolution afforded by the text and graphics capabilities on a Xerox workstation allow applications which include them to appear very professional, and are objectively more useful.
The graphic capabilities of the workstations are an outgrowth of basic research in human factors and computer use, in much the same way that the complex programming tools were developed for XAIE. Xerox has built a business by ºputting marks on paper.º The Xerox AI workstations are an extension of this by building on the modern technology of ºputting pixels on phosphor.º
XAIE does all image creation through a set of functions and data structures for device-independent graphics, known popularly as DIG. DIG is implemented through the use of a special type of stream, known as an image stream. Image streams allow programs to draw and print on an output stream regardless of the underlying device, whether it be a window, disk, or printer.
An image stream is an output stream which ºknowsº how to process graphic commands to a graphics output device. In addition to accepting the normal character-output functions, such as PRINT, an image stream can also be passed as an argument to functions that perform graphics operations, such as drawing curves or printing characters in multiple fonts. Each image stream has an image stream type, i.e., a litatom that specifies the type of graphic output device for which the image stream is processing graphics commands. Currently, the built-in image stream types are DISPLAY (for the display screen) and INTERPRESS (for Interpress format printers). There are also library modules available that define image stream types for the Press format printer, the Xerox 4045 printer, and the Epson FX-80 printer. User modules are available that define image stream types for the Silicon Graphics IRIS display, the Apple Imagewriter, and the Diablo C150 color printer. Display streams interpret graphic commands by immediately executing the appropriate operations to output the desired image on the display screen. Image streams for hardcopy devices such as Interpress printers, however, interpret graphic commands by saving information on a file which can later be sent to the printer.
Display primitives manipulate graphical images in the form of bitmaps. A bitmap is a rectangular array of ºpixels,º each of which is an integer representing the ªcolorº of one point in the bitmap image. A bitmap is created with a specific number of bit allocated for each pixel. Most bitmaps used for the display screen use one bit per pixel so that a maximum of two colors can be represented. If a pixel is 0, the corresponding location on the image is white. If a pixel is 1, its location is black. This interpretation can be changed for the display screen with the function VIDEOCOLOR so that a value of 0 indicates black and a value of 1 indicates white. Bitmaps with more than one bit per pixel are used to represent color or grey scale images. Bitmaps use a positive integer coordinate system with the lower left corner pixel at coordinate (0,0). Bitmaps are represented as instances of the datatype BITMAP and can be output to devices, expanded, shrunk, saved on files, or edited with the Bitmap Editor.
Diagrams and photographs can be converted into bitmaps by the use of scanning devices. The Xerox 295 Digital Facsimile machine can be used for this purpose at a reasonably low cost. Other scanners are also available from third party vendors, including frame grabbers which use television cameras in real time. XAIE is tremendously efficient at displaying bitmaps, and can move them from memory to screen instantly, or from disk to screen in a few seconds. However, it is important to note that one full screen bitmap is over 1,000,000 bits, even in monochrome, and any system will have a finite capacity to hold many data items this large.
XAIE includes a Bitmap Editor which allows easy editing of bitmap images. By default, each pixel is individually addressed, however, in the ºpaintº mode a user can manipulate large areas more quickly by ªbrushingº the picture with a cursor of settable size and characteristics. The Bitmap Editor is described in greater detail in the Library Modules section in Chapter          .
HEADING
1

An image object is an object that contains information about an image. This information includes such details as how to display it, how to print it, and how to manipulate it when it is included in a collection of images (such as a document). More generally, it enables you to include one kind of image, with its own semantics, layout rules, and editing paradigms, inside another kind of image. Image objects provide a general-purpose interface for image users ranging from those who want to manipulate arbitrary images to those who create images for use in documents.
The primary text and graphics utility for XAIE is TEdit. Of use to both developers and users, TEdit is basically a word processor with most of the standard formatting and text manipulation features, but which also includes capabilities for multiple fonts and inclusion of sketches and bitmaps. 
TEdit is described in greater detail in the Library Modules section in Chapter               .
Diagrams, illustrations, and flow charts are often made of geometric shapes and text.  Sketch is the XAIE drawing system which lets users easily create this kind of image. Sketches can be stand-alone files or can be included in TEdit documents or in combination with bitmaps.
Sketch is described in greater detail under the Library Modules section in Chapter         .
Each character displayed in an XAIE window is represented in the system by two types. This allows easy access to the many fonts and special character sets available. To make these more accessible, a virtual keyboard can appear on the screen which accesses a character set different than the actual keyboard. Users can output characters from the virtual keyboard by clicking on the screen keyboard with the mouse or by using control menus to make the real keyboard output the characters displayed on the screen keyboard.
Virtual keyboards are described in greater detail in the Library Modules section in Chapter         .
     (LIST ((PAGE NIL (PAPERSIZE NIL STARTINGPAGE# 1) (0 0 612 792) ((FOLIO NIL (PARALOOKS (QUAD RIGHT) CHARLOOKS (SUPERSCRIPT 0 INVISIBLE OFF SELECTPOINT OFF PROTECTED OFF SIZE 10 FAMILY OPTIMA OVERLINE OFF STRIKEOUT OFF UNDERLINE OFF EXPANSION REGULAR SLOPE REGULAR WEIGHT MEDIUM INVERTED OFF USERINFO NIL STYLE NIL) FORMATINFO NIL) (270 15 288 36) NIL) (HEADING NIL (HEADINGTYPE FOOTINGR) (54 27 558 36) NIL) (TEXT NIL NIL (54 54 504 723) NIL))) (PAGE NIL (PAPERSIZE NIL) (0 0 612 792) ((FOLIO NIL (PARALOOKS (QUAD LEFT) CHARLOOKS (SUPERSCRIPT 0 INVISIBLE OFF SELECTPOINT OFF PROTECTED OFF SIZE 10 FAMILY OPTIMA OVERLINE OFF STRIKEOUT OFF UNDERLINE OFF EXPANSION REGULAR SLOPE REGULAR WEIGHT MEDIUM INVERTED OFF USERINFO NIL STYLE NIL) FORMATINFO NIL) (54 15 288 36) NIL) (HEADING NIL (HEADINGTYPE FOOTINGV) (54 27 558 36) NIL) (HEADING NIL (HEADINGTYPE VERSOHEAD) (54 762 558 36) NIL) (TEXT NIL NIL (54 54 504 684) NIL))) (PAGE NIL (PAPERSIZE NIL) (0 0 612 792) ((FOLIO NIL (PARALOOKS (QUAD RIGHT) CHARLOOKS (SUPERSCRIPT 0 INVISIBLE OFF SELECTPOINT OFF PROTECTED OFF SIZE 10 FAMILY OPTIMA OVERLINE OFF STRIKEOUT OFF UNDERLINE OFF EXPANSION REGULAR SLOPE REGULAR WEIGHT MEDIUM INVERTED OFF USERINFO NIL STYLE NIL) FORMATINFO NIL) (270 15 288 36) NIL) (HEADING NIL (HEADINGTYPE FOOTINGR) (54 27 558 36) NIL) (HEADING NIL (HEADINGTYPE RECTOHEAD) (54 762 558 36) NIL) (TEXT NIL NIL (54 54 504 684) NIL)))))       -    ø                         T         -    ø                        T         , Ì Ìø                                 , Ì Ìø                                 3 Ì Ìø        ø                   T         F    ø        ø       PAGEHEADING 	VERSOHEAD                   F    ø        ø       PAGEHEADING 	RECTOHEAD                   E    ø      ø       PAGEHEADING FOOTINGV                   E    ø      ø       PAGEHEADING FOOTINGR                   ,                                                CLASSIC          CLASSIC           CLASSIC         G 9(DEFAULTFONT 1 (HELVETICA 12 BRR) (GACHA 8) (TERMINAL 8))          MODERN               	     HRULE.GETFN  MODERN                      	                  HRULE.GETFN  MODERN                                                     HRULE.GETFN  MODERN                                        HRULE.GETFN  MODERN                                        HRULE.GETFN  CLASSIC                                    9            Ó            Ú            o                            HRULE.GETFN  CLASSIC                       Ì                          3            X            p            0             ï                          !             I             o            R                         Ã            ¹                         =                        ³            >                                                                i                                     N             Q                                     @            C             ¢             ³                          ö             X                        `             Ê                                                   0             ×            X                         µ             ^                                     ¾                        m            k            q            ,            Å            Ö            ]            A             ù            ¬            {                          x            f            k            S                         ~                         ï            i                         l            ?                                      õ            n            1             u                          	               HRULE.GETFN  CLASSIC                        ¹                         0             	               HRULE.GETFN  CLASSIC                                    	               HRULE.GETFN  CLASSIC                       &                          "             .             ½                            HRULE.GETFN  CLASSIC                       ¾            s                                       Ã                         z                        æ                            HRULE.GETFN  CLASSIC                        ð             b                         ¯                        ý            ©                            HRULE.GETFN  CLASSIC                                                   HRULE.GETFN  CLASSIC                        û                            HRULE.GETFN  CLASSIC                       B             V                            HRULE.GETFN  CLASSIC                       4            u            q            þ            ó                        |                            HRULE.GETFN  CLASSIC                       8            '             _                         ]                         f                  ¥]zº